Steve Gartrell                 VGA ANIMATION SPRITES          VGA,ANIMATION,SPRITES          7/11/92 (00:00:00)     QB, QBasic             194  4828     ANISPRT.BAS DEFINT A-Z„„DECLARE SUB NoBoxSprite (StartX%, StartY%, NumRows%, NumCols%, Sprite%())„CONST C$ = "Created 7/11/92 by Steve Gartrell.  No rights reserved."„„'this constant is the color you won't use.„CONST NoColor% = 1„„SCREEN 13  'VGA 320x200 pixels x 256 colors„„'paint with color you don't want copied!!„PAINT (10, 10), NoColor%„„'Draw a sprite„„CIRCLE (165, 100), 9, 4„PAINT (165, 100), 90, 4„CIRCLE (165, 100), 8, 4, 0, 3.14„CIRCLE (165, 100), 9, 90, 3.14, 6.28„PSET (162, 99), 122„CIRCLE (162, 99), 3, 6„PSET (168, 99), 122„CIRCLE (168, 99), 3, 6„CIRCLE (165, 103), 3, 42, 3.43, 5.83„„'Copy the sprite into an array...„„cell% = 0„DIM Sprite%(1 TO 441)„„FOR y% = 90 TO 110„   FOR x% = 155 TO 175„      cell% = cell% + 1„      Sprite%(cell%) = POINT(x%, y%)„   NEXT„NEXT„„'Borrowed this random pattern generator from Rich Geldreich!!„'Modified to prohibit use of color 1 for demo purposes.„„FOR A = 1 TO 400„   RANDOMIZE TIMER„   IF RND > .05 THEN„       LINE -(RND * 320, RND * 200), RND * 254 + 1„   ELSE„       LINE -(RND * 320, RND * 200), RND * 254 + 1, BF„   END IF„NEXT„„„StartX% = 160: StartY% = 100„„'There are actually 21 rows and 21 cols,„' but this makes it faster by eliminating„' some math!!!„„NumRows% = 20: NumCols% = 20„„'First call initializes (places) sprite...„„CALL NoBoxSprite(StartX%, StartY%, NumRows%, NumCols%, Sprite%())„„DO„   DO: t$ = UCASE$(INKEY$): LOOP UNTIL LEN(t$)„„   SELECT CASE LEN(t$)„      CASE 2„         SELECT CASE ASC(RIGHT$(t$, 1))„            CASE &H48                  ' 72d = UP„               StartY% = StartY% - 10„               IF StartY% < 0 THEN StartY% = 180„               CALL NoBoxSprite(StartX%, StartY%, NumRows%, NumCols%, Sprite%())„            CASE &H50                  ' 80d = DOWN„               StartY% = StartY% + 10„               IF StartY% > 180 THEN StartY% = 0„               CALL NoBoxSprite(StartX%, StartY%, NumRows%, NumCols%, Sprite%())„„            CASE &H4B                  ' 75d = LEFT„               StartX% = StartX% - 10„               IF StartX% < 0 THEN StartX% = 300„               CALL NoBoxSprite(StartX%, StartY%, NumRows%, NumCols%, Sprite%())„            CASE &H4D                  ' 77d = RIGHT„               StartX% = StartX% + 10„               IF StartX% > 300 THEN StartX% = 0„               CALL NoBoxSprite(StartX%, StartY%, NumRows%, NumCols%, Sprite%())„            CASE ELSE„               BEEP: BEEP„         END SELECT„      CASE ELSE„         IF t$ = "Q" THEN„            EXIT DO„         ELSE„            BEEP: BEEP„         END IF„   END SELECT„„LOOP„„ToggleY% = 1„ToggleX% = -1„„DO„   StartY% = StartY% + ToggleY%„   IF StartY% < 1 OR StartY% > 179 THEN„      IF ToggleY% = -1 THEN„         ToggleY% = 1„      ELSE„         ToggleY% = -1„      END IF„   END IF„   StartX% = StartX% + ToggleX%„   IF StartX% < 1 OR StartX% > 299 THEN„      IF ToggleX% = -1 THEN„         ToggleX% = 1„      ELSE„         ToggleX% = -1„      END IF„   END IF„   CALL NoBoxSprite(StartX%, StartY%, NumRows%, NumCols%, Sprite%())„LOOP UNTIL LEN(INKEY$)„„SCREEN 0„WIDTH 80„COLOR 7, 0„END„„SUB NoBoxSprite (StartX%, StartY%, NumRows%, NumCols%, Sprite%())„„'Static definition means location of sprite known at„' start of routine if it was placed previously„„STATIC OldStartY&, OldEndY&„„'Calculate vid mem offset address„„StartY& = StartY% * 320& + StartX%„EndY& = StartY& + (NumRows% * 320&) + StartX%„„cell% = 1„„'Vid mem segment in screen 13„„DEF SEG = &HA000„„WAIT &H3DA, 8, 8  'Wait till _start_ of vertical retrace„WAIT &H3DA, 8„„'Note that this FOR/NEXT won't execute if first call-„' since both sides of the FOR/NEXT = 0.  After first„' call, it restores the background and retrieves the sprite!„' (Which means you can't overwrite the sprite, or it„' is saved in it's overwritten state!!)„„FOR y& = OldStartY& TO OldEndY& STEP 320„   FOR Addr& = y& TO y& + NumCols%„      IF Sprite%(cell%) <> NoColor% THEN„         CurrentPix% = PEEK(Addr&)„         POKE Addr&, Sprite%(cell%)„         Sprite%(cell%) = CurrentPix%„      END IF„      cell% = cell% + 1„   NEXT„NEXT„„cell% = 1„„WAIT &H3DA, 8, 8„WAIT &H3DA, 8„„„' Place the sprite at the StartX%, StartY% location but„' ONLY AFTER storing the background!!!„„„FOR y& = StartY& TO EndY& STEP 320„   FOR Addr& = y& TO y& + NumCols%„      IF Sprite%(cell%) <> NoColor% THEN„         CurrentPix% = PEEK(Addr&)„         POKE Addr&, Sprite%(cell%)„         IF CurrentPix% = NoColor% THEN„            CurrentPix% = CurrentPix% + 256„         END IF„         Sprite%(cell%) = CurrentPix%„      END IF„      cell% = cell% + 1„   NEXT„NEXT„„DEF SEG„„OldStartY& = StartY&: OldEndY& = EndY&„„END SUB„„Steve Demo                     EGA ANIMATION OF MAN WALKING   EGA,ANIMATION,WALKING          Unknown Date (00:00:00)QB, QBasic             318  10532    MANWALK.BAS 'Written By Steve Demo for Public Domain !„'Any and all source may be mangled, distroyed, burned, copied, or deleted as„'you see fit :-).„'„'I have only directed my intrests in Graphics with in the last month or so„'and this is what I have come up with so far.„'The moveing images were created by a program I wrote using Rich's Gif„'engine. It is fairly simple to make for your self just study the POINT„'function and you should be able to make one to. As you will notice I am„'not much of an artist and this is just a quick Demo anyways.„'„'I have also been able to make a space ship move and fire a laser. And„'distory the object fired on. If you would like to see this code drop me„'a note.„„„DEFINT A-Z„DECLARE SUB ManWalk1 (newx, newy)„DECLARE SUB ManWalk2 (newx, newy)„DECLARE SUB ManWalk3 (newx, newy)„DECLARE SUB ManWalk4 (newx, newy)„DECLARE SUB ManWalk5 (newx, newy)„DECLARE SUB DrawScreen ()„DECLARE SUB Pause (ticks%)„REM $DYNAMIC„REDIM BackArray%(250)„„SCREEN 7, , 1, 0„„DrawScreen„„Xpos% = 160„GET (Ypos%, Xpos%)-(Ypos% + 13, Xpos% + 18), BackArray%„old.Ypos% = Ypos%„old.Xpos% = Xpos%„yes = 1„PCOPY 1, 2„DO„COLOR , 0„count = 0„PCOPY 2, 1„ GET (old.Ypos%, old.Xpos%)-(old.Ypos% + 13, old.Xpos% + 18), BackArray%„ Runcount = 1„ FOR Ypos% = 5 TO 290 STEP 2„   count = count + 1„   yes = yes + 1„    IF LEN(INKEY$) THEN EXIT DO„   KeyPress$ = ""„   PUT (old.Ypos%, old.Xpos%), BackArray%, PSET„   GET (Ypos%, Xpos%)-(Ypos% + 13, Xpos% + 18), BackArray%„  'LINE (Ypos%, Xpos%)-(Ypos% + 13, Xpos% + 18), 10, B   '  To test GET„  'SOUND 700, .05„    IF yes > 1 THEN„        ManWalk2 Xpos%, Ypos%„        yes = 0„    ELSE„        ManWalk1 Xpos%, Ypos%„    END IF„    IF count > 30 THEN„        PUT (Ypos%, Xpos%), BackArray%, PSET„        GET (Ypos%, Xpos%)-(Ypos% + 13, Xpos% + 18), BackArray%„        ManWalk3 Xpos%, Ypos%„        PCOPY 1, 0„        Pause 12„        count = 0„    END IF„  PCOPY 1, 0„  old.Ypos% = Ypos%„  old.Xpos% = Xpos%„  Pause 2„ NEXT Ypos%„„ FOR alarm = 1 TO 15„   'PLAY "t180l60<<<dgdgda>>>"„ NEXT alarm„„ FOR x = 1 TO 320 STEP 5„    LINE (x, 205)-(1, x), 10„ NEXT x„„PAINT (163, 148), 12, 1„PAINT (250, 24), 14, 3„LINE (162, 147)-(188, 178), 4, B„COLOR , 9„FOR Ypos% = 290 TO 10 STEP -3„  yes = yes + 1„   IF LEN(INKEY$) THEN EXIT DO„  PUT (old.Ypos%, old.Xpos%), BackArray%, PSET„  GET (Ypos%, Xpos%)-(Ypos% + 13, Xpos% + 18), BackArray%„  'LINE (Ypos%, Xpos%)-(Ypos% + 13, Xpos% + 18), 10, B   '  To test GET„  'SOUND 400, .05„  'SOUND 700, .05„   IF yes > 1 THEN„      ManWalk5 Xpos%, Ypos%„      yes = 0„   ELSE„      ManWalk4 Xpos%, Ypos%„   END IF„  PCOPY 1, 0„  old.Ypos% = Ypos%„  old.Xpos% = Xpos%„  Pause 1„ NEXT Ypos%„„LOOP„„REM $STATIC„SUB DrawScreen„RANDOMIZE TIMER„FOR xx = 1 TO 300„    x = RND * 320„    y = RND * 200„    PSET (x, y), 15„NEXT xx„LINE (1, 170)-(320, 200), 1, BF„ FOR x = 1 TO 320 STEP 5„     LINE (x, 205)-(1, x), 7„ NEXT x„LINE (263, 165)-(309, 189), 7, BF„LINE (265, 166)-(308, 187), 0, B„LINE (267, 168)-(306, 185), 0, B„LINE (270, 171)-(303, 183), 1, BF„LINE (160, 145)-(190, 180), 5, BF„LINE (162, 147)-(188, 178), 1, B„LINE (165, 150)-(185, 175), 4, BF„CIRCLE (250, 24), 25, 3„PAINT (250, 24), 8, 3„„END SUB„„SUB ManWalk1 (newx, newy)„'$DYNAMIC„REDIM F(190)„F(5) = 6: F(6) = 6: F(7) = 6:„F(12) = 6: F(13) = 6: F(14) = 6: F(15) = 6: F(16) = 14: F(17) = 6: F(20) = 6: F(21) = 6: F(22) = 6:„F(23) = 6: F(24) = 14: F(25) = 14: F(26) = 14: F(28) = 6: F(29) = 6: F(30) = 6: F(31) = 6: F(32) = 14: F(33) = 14:„F(34) = 9: F(35) = 14: F(37) = 6: F(38) = 6: F(39) = 14: F(40) = 14: F(41) = 14: F(42) = 14: F(43) = 14: F(44) = 14:„F(45) = 14: F(46) = 6: F(47) = 6: F(48) = 6: F(49) = 14: F(50) = 14: F(51) = 14: F(52) = 14: F(53) = 14: F(55) = 6:„F(56) = 6: F(57) = 6: F(58) = 14: F(59) = 14: F(60) = 14: F(61) = 4: F(65) = 6: F(66) = 6:„F(67) = 14: F(68) = 14: F(69) = 14: F(70) = 14: F(77) = 14:„F(85) = 11: F(86) = 3: F(87) = 3: F(94) = 11: F(95) = 3:„F(96) = 3: F(103) = 11: F(104) = 11: F(105) = 11:„F(113) = 3: F(114) = 11: F(115) = 11: F(121) = 3: F(122) = 3: F(123) = 3:„F(130) = 3: F(132) = 3: F(140) = 3:„F(142) = 3: F(148) = 3: F(151) = 3:„F(156) = 10: F(157) = 10: F(160) = 10: F(161) = 10:„d = 0„   FOR x = newx TO newx + 17„      FOR xxx = newy TO newy + 8„       d = d + 1„       PixielColor = F(d)„      IF PixielColor <> 0 THEN„        IF POINT(xxx, x) <> 7 THEN„           PSET (xxx, x), PixielColor„        END IF„      END IF„      NEXT xxx„   NEXT x„„ERASE F„END SUB„„REM $STATIC„SUB ManWalk2 (newx, newy)„'$DYNAMIC„REDIM F(171)„„F(4) = 6: F(5) = 6: F(6) = 6: F(10) = 6: F(11) = 6: F(12) = 6: F(13) = 6: F(14) = 14:„F(15) = 6: F(17) = 6: F(18) = 6: F(19) = 6: F(20) = 6: F(21) = 14: F(22) = 14: F(23) = 14: F(25) = 6:„F(26) = 6: F(27) = 6: F(28) = 14: F(29) = 14: F(30) = 9: F(31) = 14: F(33) = 6: F(34) = 14: F(35) = 14: F(36) = 14:„F(37) = 14: F(38) = 14: F(39) = 14: F(40) = 14: F(41) = 6: F(42) = 6: F(43) = 14: F(44) = 14: F(45) = 14: F(46) = 14: F(47) = 14:„F(49) = 6: F(50) = 6: F(51) = 14: F(52) = 14: F(53) = 14: F(54) = 4: F(57) = 6: F(58) = 6: F(59) = 14:„F(60) = 14: F(61) = 14: F(62) = 14: F(68) = 14:„F(75) = 11: F(76) = 11: F(77) = 3: F(83) = 11: F(84) = 11: F(85) = 3:„F(90) = 11: F(91) = 11: F(92) = 3: F(93) = 3: F(98) = 11: F(100) = 3:„F(101) = 3: F(107) = 3: F(108) = 3: F(109) = 3:„F(115) = 3: F(117) = 3: F(123) = 3:„F(126) = 3: F(130) = 3: F(133) = 3:„F(138) = 10: F(139) = 10: F(142) = 10: F(143) = 10:„d = 0„   FOR x = newx TO newx + 17„      FOR xxx = newy TO newy + 7„       d = d + 1„       PixielColor = F(d)„     „      IF PixielColor <> 0 THEN„        IF POINT(xxx, x) <> 7 THEN„           PSET (xxx, x), PixielColor„        END IF„      END IF„     „      NEXT xxx„   NEXT x„„ERASE F„END SUB„„REM $STATIC„SUB ManWalk3 (newx, newy)„'$DYNAMIC„REDIM F(220)„„F(13) = 6: F(14) = 6: F(15) = 6: F(16) = 6: F(20) = 6: F(21) = 6: F(22) = 6: F(23) = 6:„F(24) = 6: F(25) = 6: F(26) = 6: F(28) = 6: F(29) = 6: F(30) = 6: F(31) = 6: F(32) = 14: F(33) = 14: F(34) = 6:„F(35) = 6: F(37) = 6: F(38) = 6: F(39) = 14: F(40) = 9: F(41) = 14: F(42) = 9: F(43) = 14: F(44) = 6: F(45) = 6:„F(46) = 6: F(47) = 14: F(48) = 14: F(49) = 14: F(50) = 14: F(51) = 14: F(52) = 14: F(53) = 14: F(54) = 6: F(55) = 6: F(56) = 6:„F(57) = 14: F(58) = 14: F(59) = 14: F(60) = 14: F(61) = 14: F(62) = 6: F(63) = 6: F(64) = 6: F(65) = 6: F(66) = 14: F(67) = 4:„F(68) = 4: F(69) = 4: F(70) = 14: F(71) = 6: F(72) = 6: F(73) = 6: F(74) = 6: F(75) = 14: F(76) = 14: F(77) = 14: F(78) = 14:„F(79) = 14: F(80) = 6: F(85) = 14: F(86) = 14:„F(93) = 11: F(94) = 3: F(95) = 3: F(102) = 11: F(103) = 3:„F(104) = 3: F(111) = 11: F(112) = 11: F(113) = 11:„F(121) = 3: F(122) = 11: F(123) = 11: F(129) = 3: F(130) = 3: F(131) = 3:„F(138) = 3: F(140) = 3: F(148) = 3:„F(150) = 3: F(156) = 3: F(159) = 3:„F(165) = 10: F(166) = 10: F(168) = 10: F(169) = 10:„d = 0„   FOR x = newx TO newx + 20„      FOR xxx = newy TO newy + 8„       d = d + 1„       PixielColor = F(d)„      IF PixielColor <> 0 THEN„        IF POINT(xxx, x) <> 7 THEN„           PSET (xxx, x), PixielColor„        END IF„      END IF„     „      NEXT xxx„   NEXT x„„ERASE F„END SUB„„REM $STATIC„SUB ManWalk4 (newx, newy)„'$DYNAMIC„REDIM F(200)„„F(12) = 6: F(13) = 6: F(14) = 6: F(20) = 6: F(21) = 14: F(22) = 6:„F(23) = 6: F(24) = 6: F(25) = 6: F(29) = 14: F(30) = 14: F(31) = 14: F(32) = 6: F(33) = 6:„F(34) = 6: F(35) = 6: F(38) = 14: F(39) = 9: F(40) = 14: F(41) = 14: F(42) = 6: F(43) = 6: F(44) = 6:„F(45) = 6: F(46) = 14: F(47) = 14: F(48) = 14: F(49) = 14: F(50) = 14: F(51) = 14: F(52) = 14: F(53) = 6: F(54) = 6:„F(56) = 14: F(57) = 14: F(58) = 14: F(59) = 14: F(60) = 14: F(61) = 6: F(62) = 6: F(63) = 6: F(66) = 4:„F(67) = 14: F(68) = 14: F(69) = 14: F(70) = 6: F(71) = 6: F(72) = 6: F(75) = 14: F(76) = 14: F(77) = 14:„F(78) = 14: F(79) = 6: F(80) = 6: F(86) = 14:„F(94) = 3: F(95) = 11: F(96) = 11: F(103) = 3: F(104) = 11:„F(105) = 11: F(112) = 3: F(113) = 3: F(114) = 11: F(115) = 11:„F(121) = 3: F(122) = 3: F(124) = 11: F(130) = 3: F(131) = 3:„F(132) = 3: F(139) = 3: F(141) = 3:„F(147) = 3: F(150) = 3: F(157) = 3:„F(160) = 3: F(165) = 10: F(166) = 10: F(168) = 10: F(169) = 10:„d = 0„   FOR x = newx TO newx + 18„      FOR xxx = newy TO newy + 8„       d = d + 1„       PixielColor = F(d)„      TestPoint = POINT(xxx, x)„      IF PixielColor <> 0 THEN„        IF TestPoint <> 7 AND TestPoint <> 10 AND TestPoint <> 12 THEN„           PSET (xxx, x), PixielColor„        END IF„      END IF„     „      NEXT xxx„   NEXT x„„ERASE F„END SUB„„REM $STATIC„SUB ManWalk5 (newx, newy)„'$DYNAMIC„„REDIM F(200)„„F(12) = 6: F(13) = 6: F(14) = 6: F(20) = 6: F(21) = 14: F(22) = 6:„F(23) = 6: F(24) = 6: F(25) = 6: F(29) = 14: F(30) = 14: F(31) = 14: F(32) = 6: F(33) = 6:„F(34) = 6: F(35) = 6: F(38) = 14: F(39) = 9: F(40) = 14: F(41) = 14: F(42) = 6: F(43) = 6: F(44) = 6:„F(45) = 6: F(46) = 14: F(47) = 14: F(48) = 14: F(49) = 14: F(50) = 14: F(51) = 14: F(52) = 14: F(53) = 6: F(54) = 6:„F(56) = 14: F(57) = 14: F(58) = 14: F(59) = 14: F(60) = 14: F(61) = 6: F(62) = 6: F(63) = 6: F(66) = 4:„F(67) = 14: F(68) = 14: F(69) = 14: F(70) = 6: F(71) = 6: F(72) = 6: F(75) = 14: F(76) = 14: F(77) = 14:„F(78) = 14: F(79) = 6: F(80) = 6: F(86) = 14:„F(94) = 3: F(95) = 11: F(96) = 11: F(103) = 3: F(104) = 11:„F(105) = 11: F(112) = 3: F(113) = 3: F(114) = 11: F(115) = 11:„F(121) = 3: F(122) = 3: F(124) = 11: F(130) = 3: F(131) = 3:„F(133) = 3: F(139) = 3: F(141) = 3:„F(147) = 3:  F(151) = 3: F(156) = 3:„'F(160) = 3: F(165) = 10: F(166) = 10: F(168) = 10: F(169) = 10:„F(159) = 3: F(165) = 10: F(166) = 10: F(168) = 10: F(169) = 10:„d = 0„   FOR x = newx TO newx + 18„      FOR xxx = newy TO newy + 8„       d = d + 1„       PixielColor = F(d)„      TestPoint = POINT(xxx, x)„      IF PixielColor <> 0 THEN„        IF TestPoint <> 7 AND TestPoint <> 10 AND TestPoint <> 12 THEN„           PSET (xxx, x), PixielColor„        END IF„      END IF„      NEXT xxx„   NEXT x„ERASE F„END SUB„„REM $STATIC„ SUB Pause (ticks%)„    '**** ticks% are 1/18th second„    DEF SEG = 0„    DO UNTIL TestTick% > ticks%„        LastTick% = GetTick%„        GetTick% = PEEK(&H46C)„        IF LastTick% <> GetTick% THEN„            TestTick% = TestTick% + 1„        END IF„    LOOP„    DEF SEG„ END SUB„„Fred Sexton Jr.                SCREEN 13 GRAPHICS UTILITIES   SCREEN,13,GRAPHICS,UTILITIES   Year of 1991 (00:00:00)QB, QBasic             167  5996     G13UTIL.BAS DEFINT A-Z„'$DYNAMIC„DECLARE SUB changeclr (ary(), oclr, nclr)„DECLARE SUB mirror (ary(), bry())„DECLARE SUB superimp (ary(), xpos, ypos, mode)„DECLARE SUB scrollup (ary(), xpos, ypos)„„'***************************************************************************„'                       SCREEN 13 GRAPHIC UTILITIES                                                                 „'                            by FRED SEXTON JR.                                     „'  CHANGECLR„'     Searches an image array for a color and changes it to a„'     different color.„'     syntax =>  CALL changeclr(array(),oldcolor,newcolor)„'„'  MIRROR„'     Returns a mirror image of first array in second array.„'     ****DIMENSION BOTH ARRAYS TO THE SAME SIZE****„'     syntax =>  CALL mirror(array1(), array2())„'„'  SUPERIMP„'     Puts a graphic image at specified location.„'     Depending on setting of mode varible the image„'     is either put in front of or behind the images„'     that exist on the screen.„'     syntax =>  CALL superimp(array(), xpos, ypos, mode)„'                mode = 0  => put in front„'                mode = 1  => put behind„'„'  SCROLLUP„'     Scrolls a graphic image up onto the screen ending up„'     at specifeid location.„'     syntax =>  CALL scrollup(array(), xpos, ypos)„'„'„'***************************************************************************„„SUB changeclr (ary(), oclr, nclr)„„xwidth = ary(0) \ 8                     'get x-axis width„yheight = ary(1)                        'get y-axis height„„bytes& = CLNG(xwidth) * CLNG(yheight)   'find # of bytes in image„                                        'while avoiding overflow error„„DEF SEG = VARSEG(ary(2))                'set the segment„aofs = VARPTR(ary(2))                   'get starting offset„„FOR t& = 0& TO bytes& - 1               'search the required # of bytes„ IF PEEK(t& + aofs) = oclr THEN POKE t& + aofs, nclr   'change as needed„NEXT„„END SUB„„SUB mirror (ary(), bry())„„bry(0) = ary(0)                         'make bit width the same„bry(1) = ary(1)                         'make height the same„„xwidth = ary(0) \ 8                     'get x-axis width„yheight = ary(1)                        'get y-axis height„„aseg = VARSEG(ary(2))                   'get the segment of array1„aofs = VARPTR(ary(2))                   'get the offset of element 2„bseg = VARSEG(bry(2))                   'get the segment of array2„bofs = VARPTR(bry(2)) + xwidth - 1      'get the offset to start at„„„                                        'the two sets of "FOR:NEXT„                                        'will effectively step thru array1„                                        'byte by byte„FOR t = 1 TO yheight„ FOR tt = 0 TO xwidth - 1„    DEF SEG = aseg„    value = PEEK(aofs + tt)             'get a value from array1„    DEF SEG = bseg„    POKE bofs, value                    'put it into array2„    bofs = bofs - 1„  NEXT„aofs = aofs + xwidth                    'setup offsets for next row„bofs = bofs + (xwidth * 2)„NEXT„                                        'return to default segment„DEF SEG„„END SUB„„SUB scrollup (ary(), xpos, ypos)„„yheight = ary(1)                      'get yaxis height„ypos = ypos + yheight                 'setup starting ypos value„„FOR t = 1 TO yheight„  ary(1) = t                          'modify the value that PUT will use„  ypos = ypos - 1                     'move ypos up one row„  PUT (xpos, ypos), ary, PSET         'put image to screen„ „  SOUND 32767, 2                      'use your favorite method to create„                                      'a delay here„                                      '(I use an routine I wrote in„                                      '            MASM but this will work)„NEXT„„END SUB„„SUB superimp (ary(), xpos, ypos, mode)„„DIM wry(UBOUND(ary))                  'dim a work array the same size„„xwidth = ary(0) / 8                   'get x-axis width„yheight = ary(1)                      'get y-axis height„„GET (xpos, ypos)-(xpos + xwidth - 1, ypos + yheight - 1), wry„                                     „                                  'get the target area of screen in work array„„„IF mode = 0 THEN                      'mode 0 means put in front„„ FOR t = 2 TO UBOUND(ary)             'search the source array„ „  DEF SEG = VARSEG(ary(t))            'starting with element 2„  lb = PEEK(VARPTR(ary(t)))           'get the lower byte„  ub = PEEK(VARPTR(ary(t)) + 1)       'get the upper byte„„  IF lb <> 0 THEN                     'if soucre array isn't zero„   DEF SEG = VARSEG(wry(t))„   POKE VARPTR(wry(t)), lb            'put it into work array„  END IF„„  IF ub <> 0 THEN                     'same thing for upper byte„   DEF SEG = VARSEG(wry(t))„   POKE VARPTR(wry(t)) + 1, ub„  END IF„„ NEXT„ DEF SEG                              'return to default segment„„ELSE                                  'nonzero mode means put behind„„ FOR t = 2 TO UBOUND(wry)             'search work array„  DEF SEG = VARSEG(wry(t))            'starting with element 2„  lb = PEEK(VARPTR(wry(t)))           'get lower byte„  ub = PEEK(VARPTR(wry(t)) + 1)       'get upper byte„„  IF lb = 0 THEN                      'if work value is zero„   DEF SEG = VARSEG(ary(t))           'get corresponding byte„   lb = PEEK(VARPTR(ary(t)))          'from source array„   DEF SEG = VARSEG(wry(t))           'put it into work array„   POKE VARPTR(wry(t)), lb„  END IF„„  IF ub = 0 THEN                      'same thing for upper byte„   DEF SEG = VARSEG(ary(t))„   ub = PEEK(VARPTR(ary(t)) + 1)„   DEF SEG = VARSEG(wry(t))„   POKE VARPTR(wry(t)) + 1, ub„  END IF„„ NEXT„ DEF SEG                              'return to default segment„END IF„                                     „PUT (xpos, ypos), wry, PSET           'put the resulting array on screen„„END SUB„„Lucifer Productions            WORMHOLE                       VGA,WORMHOLE                   05/11/1995 (00:00:00)  QB, QBasic             247  23328    WORMHOLE.BAS' Wormhole:„' Lucifer's first production„' Release Date: May 11th, 1995„'„'   This scrolltext string exceeded Qbasic's limitation. So we had to„' rewrite the code to accomidate it. Pretty damn good, eh? It took about five„' hours to write the text. That's longer than it took to write the code.„'   So I suppose you are going to want some technical info. O.k. Wormhole is„' a looping scrolltext demo with a palette-rotating wormhle, and a moving„' logo.„'   The story of Lucifer:„'   It all started way the hell back in October of '94 when Psycho BFG (who„' called himself gristle then) started a demo group called IBMLAND. You must„' keep in mind that IBMLAND was only a joke, that became less of one when it„' spread. Anyway, IBMLAND's members became too lazy and were kicked out by„' Psycho BFG and I.„'   Instead of releasing demos under our own names, he and I formed a new„' demo group, Lucifer. And so now the only pure 100% Qbasic group is the one„' that rose from the ashes of IBMLAND: Lucifer.„'   The only problem is that Lucifer has only two members (Psycho BFG and I„' obviously), and we have not been successful at finding motivated members.„'   So in conclusion, if you would like to contribute to Lucifer's production„' and are willing to actually DO SOMETHING, then write to me at:„'„' 4727 Holly Lake Drive,„' Lake Worth, FL, USA, 33463.„'„' Remember: if you want a reply, use the password found in the scrolltext!„'„'  If you do not feel like sending a letter all the way to Lake Worth, FL,„' want to ask questions about these demos, or get the old IBMLAND demos„' then write to Psycho BFG at:„'„' 518 Jennings Street,„' Greenacres, FL, USA, 33463„'„' IBMLAND demos available: Anarchy, Spectrum, Art, Mystic Circle, Domino„' For a limited time only, we have Art version 1.2 with new texts and colors„' by ThE DaEmOn of ex-IBMLAND„'„' Note from Psycho BFG: You KNOW we're never going to get any mail, right?„'                  666: No shit, Sherlock, but it would be cool if we did!„'           Psycho BFG: So prove us wrong!  We'll even pay for our own stamp„'                       to reply and actually we're lying about the password„'                       requirement.„'                  666: You may think Basic sucks (if so, your right), but„'                       it does have some advanteges like: the source code„'                       comes with it and uh... well... like... yeah!„'„' Lucifer is:„' 666 - Organizer, Bugs, GFX, PR„' Psycho BFG - Main Bugs, GFX, Noise„'„'„' Psycho BFG's guide to reading this scrolltext„' -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-„' The entire scrolltext takes almost 30 minutes to complete, so get some„' refreshments and a comfortable chair.„' All texts in fading red are just highlighted„' Usually Red text means I am talking 'out loud'„' Usually Blue text means 666 is talking 'out loud'„' If it's just our names, as in a red "Psycho BFG" or blue "666" then„' they are just meant to be highlights„' Also there are places in the demo where we switch typers without any„' visual clues; you have to figure these out yourself.„ „SCREEN 13„LOCATE 24, 5„COLOR 255„PALETTE 255, 63 * 65536 + 63 * 256 + 63„PRINT "PLEASE WAIT - INITIALIZING DEMO";„VIEW SCREEN (0, 0)-(319, 179)„READ scr$„linen = 1„linep = 1„„'OUT 968, 0„'FOR i = 1 TO 765„'OUT 969, 0„'NEXT i„„OUT 968, 12„OUT 969, 63„OUT 969, 0„OUT 969, 0„OUT 968, 9„OUT 969, 0„OUT 969, 0„OUT 969, 63„„n = 0„x = 5„FOR i = 200 TO 40 STEP -1„n = n + 1„IF n = 6 THEN n = 1„x = x / 1.003„FOR j = 1 TO 10„CIRCLE (160, i), x, n, , , .5„x = x * 1.003„NEXT j„NEXT i„„VIEW SCREEN (0, 0)-(319, 199)„„DIM c(265)„FOR i = 1 TO 6„c(i) = i * (63 / 6)„NEXT i„FOR i = 7 TO 256„c(i) = 0„NEXT i„„FOR i = 1 TO 49„CIRCLE (160 + i - i, 70 + i - i), i, 200 - i„CIRCLE (160 + i - i, 71 + i - i), i, 200 - i„CIRCLE (160 + i - i, 72 + i - i), i, 200 - i„NEXT i„„LINE (0, 0)-(320, 10), 0, BF„„LOCATE 1, 32„COLOR 1„PRINT "LUCIFER"„FOR i = 248 TO 320„FOR j = 0 TO 10„IF POINT(i, j) > 0 THEN LINE ((i - 196) * 2, j * 2 + 50)-((i - 196) * 2 + 2, j * 2 + 52), 15, BF„NEXT j„NEXT i„„FOR i = 100 TO 220„FOR j = 49 TO 75„IF POINT(i, j) = 15 THEN GOTO skip2j„IF POINT(i + 1, j + 1) = 15 THEN PSET (i, j), 50„IF POINT(i, j + 1) = 15 OR POINT(i + 1, j) = 15 THEN PSET (i, j), 49„IF POINT(i - 1, j + 1) = 15 OR POINT(i + 1, j - 1) = 15 THEN PSET (i, j), 48„IF POINT(i, j - 1) = 15 OR POINT(i - 1, j) = 15 THEN PSET (i, j), 47„IF POINT(i - 1, j - 1) = 15 THEN PSET (i, j), 46„skip2j:„NEXT j„NEXT i„FOR i = 100 TO 220„FOR j = 49 TO 75„IF POINT(i, j) = 15 THEN PSET (i, j), 32 - (j - 49)„NEXT j„NEXT i„„FOR i = 1 TO 5„n = i * 12„c = n * 65536 + n * 256 + n„PALETTE i + 45, c„NEXT i„„LINE (0, 0)-(320, 10), 0, BF„„FOR i = 1 TO 50„r = i + 13„G = i - 1„c = G * 256 + r„PALETTE i + 150, c„NEXT i„„FOR i = 0 TO 15„c = i * 4„n = c * 65536 + c * 256 + c„PALETTE i + 16, n„NEXT i„„LOCATE 1, 12„COLOR 255„PRINT "LUCIFER KICKS ASS!"„DIM ass(200, 8)„GET (50, 0)-(250, 8), ass„LINE (50, 0)-(250, 8), 0, BF„ax = 0„av = 0„„DIM text(312 * 8)„„DO„OUT 968, 1„FOR j = 1 TO 5„OUT 969, c(j)„OUT 969, 0„OUT 969, 0„NEXT j„„PUT (ax, 0), ass, PSET„ax = ax + av„IF ax < 50 THEN av = av + 1 ELSE av = av - 1„„b = c(5)„FOR j = 5 TO 2 STEP -1„c(j) = c(j - 1)„NEXT j„c(1) = b„„z = TIMER * 100„DO„LOOP WHILE TIMER * 100 - z < 1„„tm = tm + 1„IF tm < 3 THEN GOTO skip2l„GET (16, 180)-(311, 199), text„PUT (8, 180), text, PSET„LOCATE 24, 39„DO„at$ = MID$(scr$, linep, 1)„linep = linep + 1„IF linep > LEN(scr$) THEN„ linep = 1„ linen = linen + 1„ IF linen > 16 THEN : linen = 1: RESTORE„ READ scr$„END IF„IF sl > ln THEN sl = 1„IF at$ = "*" THEN clr = 1„IF at$ = "@" THEN clr = 2„IF at$ = "#" THEN clr = 3„IF at$ = "$" THEN clr = 4„IF at$ = "%" THEN clr = 12„IF at$ = "^" THEN clr = 9„IF at$ = "&" THEN clr = 255„LOOP WHILE INSTR("*@#$%^&", at$) > 0„COLOR clr„PRINT at$;„tm = 1„skip2l:„LOOP WHILE INKEY$ = ""„CLS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 'If you are reading this, we told you about it!!!„„DATA "  *H@e#l$l*o@,# $p*e@o#p$l*e$!  &It's me, %Psycho BFG &of *L@u#c$i*f@e#r &typing.  I'm here at ^666&'s house, and he's about to go get us some food.  Scrolltext writing can be a strenuous task, even for the experienced, so we r going with the preventive medecine trend and stocking up before we really get into it... wait a sec... I just realized that this scroll is pure white... I ripped some code from a demo of mine from quite some time ago, and it seems to be missing the vital code for 'scrolltext commands'... here, I'll fix it now.  Ah... as I'm sure you've noticed, these texts have neat colors now... let me show you those again: we can have *R@E#D* F@A#D$I*N@G&...  and of course the standard %Psycho BFG red &and ^666 blue.  &So... here, before I forget, let's hand out some credits and greetings.  This demo was coded by %Psycho BFG, &and of course the scrolltext was written by ^b%o^t%h ^o%f ^u%s&.  ok, since ^666& is begging to write the greetings, I'll let him take over for a little while.. i guess... "„DATA " *D@a#m$n *i@t#!$!*! &What a fucking liar! I wasn't begging. Anyways, greetings go to: Coolgrease, Sinner, and Satanic Majesty of ex-IBMLAND... Cascada... Pilveveikot (I have no goddamn idea how to spell it)... Future Crew (nice name (@N#O$T&))... Electro Motive Force... Type One of TFL... Tran (Hell was especially coool)... Bill Gates... <-- whoa look back there! Sorry about that bug!... Stefan Gagne... Pis and Egor of Future Wrec... Dr. Sbaitso... Icecoldhacknslashdeathbladerunner... Topaz Beerline... All of those mental floss people... Mike Judge... I gess that about does it for the greets... Now for the fuckings... They go to: That guy that said IBMLAND sucked because he saw a Future Crew demo that was better... Nad Rotezc (for hosting MTV Sprots)... Jay Leno... Sonic PC (for screwing up the *A@s#s$e*m@b#l$y* @'#9$4&)... Steve Wazniak (for the sucky Macintosh)... Bill Gates (whew we finally got it right this time)... All cobol lamers... Gerber King (for those sucky anti McReynalds commercials)... "„DATA "Well, ^666 &went to go molest his cat, so I'm resuming the typing... hey, he just kicked me!  Damn it!  Alright, let's have an interview.  %Psycho BFG: &Hey ^666,& tell us about yourself...  ^666: &Well, ... uh, well, there's really not much to say about me... so lets skip the crap questions.  %Psycho BFG: &Ok, ok ok... did you have any trouble coding this demo?  ^666: &No.  I didn't code it.  Dumbass.  %BFG: &Oh that's right... I did... well um... do you do any coding yourself?  ^666: &Yes, I do. I'm working on our next demo, Loser. It will be featuring some better effects... like crossfading, dotmorphing, a mosaic. Other than that I have no idea what will be in it... %Psycho BFG: &Ok...- ^666: &Will you stop typing 'ok'?!   %Psycho BFG: &I'm asking the questions here... ok... hahaha okokokokokok  hahaha!  Alright... now... ^666&... you said some 'better effects'.  Did you mean better effects than the ones in this demo, or just good effects in general?  ^666&: better than this demo, dumbass!  %BFG: &Alright, "„DATA "I'm going to kick your ass now!  %Wham! ^ow!  %Pow!  ^Quit it!  Slam!  %ow you assmunch!  ^666&: O.k. Now the keboard is all mine and you can't do anything about it (at least not when you're lying on the floor, unconsious (%if I'm unconsious, how am I helping you with spelling?&)(That was just me typing to fool you))... Uh oh %Psycho BFG &just woke up... Now he's whining about how when he stomps on the floor, his nose hurts... Whew he shut the hell up... Oh yeah, I guess that concludes this interview. See us in our next scrolltext demo for another one... Now I will pass the keyboard over to %Psycho BFG&, who has been bugging for it, for quite some time now. *W@h#e$w*!&  I thought he was never going to shut up!  So now I'm going to talk about Loser a bit... if you ever get that demo (you got this one, didn't you?), then just remember, all the SUCKY parts were coded by ^666.&  And  ^wham! %Ow, quit it!  ^Give me that fart knocker. &Now for some @R#E$A*L& info on Loser. %Psycho BFG& was lying again... ^cut it out, "„DATA "asswipe& he just hit me... excuse me for one moment; I h%gfsds&a%gfsaghh&v%gfdg&e to%gfsdgs ^quit it! &I have to settle something... %Ah... that was easy... &Now let's get back to the scrolltext.  This text is now about 4200 bypes (^bypes? %bytes, assmunch!&) long... that about one quarter of what we want it to be total... so be prepared for the rest of it... or if you're a *T@O#T$A*L @W#U$S*S &then you can just skip out and read it directly from the .bas file.  But then you wouldn't see all the *C@O#O$L $E#F@F*E$C#T@S*!&, <- like that one.  You'll just see garbage like VS%$TW#BH T^WVYE^# %G& (well actually we can't show you what you'd see exactly because it would cause effects in the scroll!!! @d#a$m*n #i$t*!@!#!&)  Well it doesn't matter anyway because you're still reading this, arent you?  Unless you're being a wuss.  Ok, now if you want to contact us, send mail to   4727 Holly Lake Drive    Lake Worth, FL   33463   - that's 666... i mean ^666&'s house... and remember, if you want a reply, the password is: "„DATA "$#@%%#&D$%@$%&O$#@$&R%#%$#@*&K!!!  Got it?  If you did not, well *F@U#C$K @Y#O$U*!@!#!  &Alright... now ^666 &wants the keyboard oh he just changed his mind but TOO BAD!  Here is ^666!& Asswipe!!!... %Ow! Cut it out!!! ^Well if you're going to bitch about it then O.k.& So like do you want to see some anagrams... if not, tough shit!!! Here it goes... The four seasons-=> Fart on Sues shoe... Santa Clause-=> Satan's a clue... The mind is a terrible thing to waste-=> Broil tainted semen with great shit (no racism/offense intended)... And the big one...: You rob dead Zack Braggwelsche of his fatty pit-=> Go get fistfucked by a psycho %(BFG)& with a razor blade (offense intended)... Anagrams *k$i#c@k *a$s#s@!*!$!& O.k. Now I think I'll let %Psycho BFG& type... i am typing this with my nose... no really!  i am typing this sentence with another part of my body but I wont tell you which... hahaha!  So let's talk about cool people vs. dorky people.  As you can tell, I am a cool person.  ^666, &on the other hand, is a total dork.  Uh oh... he's  "„DATA "starting to lurk behind me...  ^you don't know when it's coming, dude...  %Ow!!! &ok, just to get you back, I'm gonna give you the keyboard again!!!  Muahahahahahahahahaaa!  ^No way it's your's %Ok, I'll type as long as you promise not to hit me... ^I'm not going to make a promise I can't keep... %Well fuck that... here you go, ^667. ^O.k., Sane LFG... %ööö... ^Chopsy G(oat) B(utt) F(ucker)... %6(IQ points) 6(years old) 6(times he masturbates each day)... ^iD-ripper-offer... %90210... ^You forgot to make it %red^, dumbass!... %look again, dork!  ^That's just because you change it, BiFG... %Enough of this.  Let's quit insulting each other, ^999. %It's time we got back to the real scrolltext.  &Do you really think that the public wants to hear about our arguments? ^I don't give a flying fuck about the public &(<-=-= sorry about that I really do)...  &To tell the truth... I think they really DO want to hear about it...  %POW!!!  ^Yeeow!  %WHACK!  ^Ow!  %SLAM!  ^Smack!!! Eat that Psucko BFG... %Say what you want, ^90210%, but @G#O$D% is on my side. ^What a wuss!!! "„DATA "*G$O#D^ isn't going to save your ass every time... You need to learn how to take care of yourself!!! &A message to @G#O$D&: Don't zap him yet... give him time to repent... ^90210&, this may be your last chance...  Oh BTW!  This text is now about 7.5k long!  Half of our goal!!  @L#U$C*I@F#E$R& @F#O$R*E@V#E$R*!@!#!  ^Do you really think *G$O#D^ is going to save your ass if you keep doing things like that? %like what?  Being nice to you?  I thought we were supposed to be friends or something... ^We R, it's just that you keep bragging about how *G$O#D^ is going to save your ass but not mine... %Well if I didn't warn you I would be a real jerk, wouldn't I?  I'm far to noble to lie about such things anyways.  ^Noble?! Ha! You've got to be kidding... The only thing that makes you noble is your amazing ability to be a dumbass!! Ow that hurt!!, %Psicko Butt-Fucker^!! %Quit standing behind me, ^90210%!  Look... I just am sick of fighting!  We've been fighting for the last... lets see... almost the last 2k!  I just want to get on "„DATA "with the demo... even if you suck, we're still in the same group, ^90210%, and we should cooperate.  ^What the hell does 'even if you suck' supposed to mean? %Um... nothing... ^902%... ^666% i mean... it um... it's nothing, really!  ^Yeah-fucking-right, %Psycho Boy-Fucking-Gomer^... %Is that really me?  ^Didn't I type it, ashino baka!!! %Do you wish that you type it, ashino baka?  ^I *d$i#d^ type it, Psucko... %I see ^So do I... %I need more data... ^Tough shit, Dr. Sbanking! %Move your hands of my keyboard. ^And if I don't... %Don't you think that you can... ^I know I can, Sbanking... %Are you glad that you can, Sbanking...?  ^Fuck you!!! %90210, you are getting me to GTRSEY24... parity warning... ^Fuck fuck fuck fuck!!! %YOU YOU YOU YOU!  @I#'$m @b#a$c*k@!#!$!%!  Heyyyyy... %Psycho BFG& is back from @H#E$L*L&, where I've spent my winter vacation... Hell really is nice in the winter and you should visit sometime. -^you have been playing too much Doom&- Anyways... hey, ^666&, you spelled DooM wrong!  ^bite me& Shut up!  Anyways, "„DATA "this text is almost 10k long! Remember our goal is to get past 15k, so there's still a bit to type... ^666, & do you have anything to say?  Not right now... I think we should go do something else and then come back and finish this text...  Alright... lets go...  3:00pm signing off for now...       %Psycho BFG& is back!  Its been 80 minutes since we saved the last time... what?  You munch!  Just because no time has passed for you, doesn't mean it hasn't for us!!!  Here look...           See I just @l#e$f*t &a leak... it took about a minute... you see... the only way we can show you time is holding down the space bar             and that gets boring for both you and us.  Did that clear anything up?  Now... I believe ^666& has something to say...     Yes it's me, ^666&... I'm back (%no shit&)... O.k. I got a cool joke. There is this little kid playing with his train set, saying: 'all of you mother fuckers that want to get off, get off. And all of you suns of bitches that want to stay on, stay on!.' So like, then his mother told him to go in his room for two hours. Two hours "„DATA "later... he comes out of his room AND says: 'all passengers who would like to get off, get off. All passengers who would like to stay on, stay on. If you r angry about the two hour delay, see the @b#i$t*c@h& in the kitchen'... Cool, eh? O.k. now it's %Psycho BFG's& turn to tell a joke...  Well, I was going to tell the one about the jew who won the lottery using his concentration camp tatoo as his numbers, but some people might find that offensive... so I'll go with.. the Tennis Elbow... alright... see there's a guy who has an injury, so he goes to a doctor's office.  The doctor tells him to piss in a cup, pour it into the machine in the hallway, and insert 75 cents.  His result was a card saying: 'You have tennis elbow.  Compress with a hot towel for fifteen minutes a day for two weeks.'  Well, he did, but he couldn't stop thinking about that machine... finally curiosity overcame him: he got his wife and daughter to both piss in the cup, he dripped some radiator fluid from the car into the cup, and to top it all off, he ejaculated into it.  "„DATA "The next day he went up to the machine and poured it in, and entered 75 cents.  The machine clanked around for about five minutes and finally spat out a card that read: 'Dear sir: Your wife has the clap, your daughter is pregnant, your car is about to blow an axle, and if you don't stop jerking off, you'll @N#E$V*E@R &get rid of that tennis elbow!'  Let's see ^666& top that one...  No problem... This story/joke is entitled 'Italian Goes to Breakfast in L.A.' (No offense to any Italian people). So 'dis one day I went out to brekfest and I ordered two peese of toast two eggs and two pancakes. De waiter only brought me one peese of toast. So I say to heem 'I want two peese.' And so he said to me 'the bathroom is that way.' So I say to heem 'no you don't undarstand. I want two peese on tha plate.' And he say to me 'you bettar not piss on the plate you sumanabitch.' The end... Beat that %Psycho BFG&...  Damn, I don't know if I can... well I'll try my version of a foreigner in L.A.  It's a short one, so you don't have to read all that setup crap.  'Dear sir... could you tell me "„DATA "the way to Grand Central Station... or shall I just go fuck myself?'   Um... I gues ^666& wins... but it's not my fault.  I was going to use his next anyhow.  Yes I won... That's because I 'm... (%WAIT, I JUST THOUGHT OF ONE!!!)  &Ok here's %Psycho BFG's& joke du jour... What do milk and elephants have in common?  . . . . . . . . . . . . They both come in quarts!!!  Of course some of you might not get that one... 'wait a few more years, kid'  Now back to the regularly scheduled broadcast.  Anyway... as I was saying, I won because I am cooler (%That just means he didn't get my joke... I wonder why...&) *F$U#C@K *Y$O#U@!!!^ I got your damn joke (%yeah, I just explained it to him&), but I still won!!! Besides elephants come in gallons (%how would you know? ^I asked your dad! %that was stupid... hehehe)& Hey, I just thought of something... 1961 upsidedown is 1961!!!  %Psycho BFG& is back.  I figured I better take over or you'll die of boredom (actually, he just had to @l#e$a*v@e &a dump.  Anywayz I'd like to talk about stuff now.  "„DATA "For example, this text is now 13.5k long!  This is not something I'm proud of, but it's split about half and half I'd say between me and ^667& typing (he's not here right now so I can say @W#H$A*T@E#V$E*R @I #W$A@N*T&).  This equality is something I am going to fix right here and now... I will type... say, until the end of the line.  Alright... now I'd like to send a few greets myself (I helped with the above greets, but some people were left out).  Since you've read for so long, I will reward you with all the @C#O$O*L &greetings.  Greetings from me to ULTRA2KRAD4U (2KRAD4U was a KICKASS demo... try again in basic though)... INFERIORS (do some @R#E$A*L &basic!)... Daemon (both of them...ThE DaEmOn, and Daemon)... Sorcerers (keep up them cool demos)... Zodiak (try a few PC speaker tunes... if you want, I'll send you my PC-Tracker)... The Flamooties (or whatever you're called... Kukoo2 had a good start, but the second part wasn't as good)... 508537 (great name, guys!)... Ford Prefect (all of 'em)... Sand (eggs and oisters?)... Ok... that's one line... want to try for 2 in a row?  "„DATA "Here's the second!  Now for the list of least used hyphenated words, in descending order:  OWL-FLAVORED...LICK-PROOF...PRE-SPANKED...HAT-RESISTANT...CONDOM-FLAVORED...MOOKIE-PROOFED...PLUTONIUM-FREE...FLY-JAMMED...POST-OPENED...FART-FLAVORED...and finally...@S#U$G*A@R#-$F*R@E#E$!&  Now... hey did you know that in some versions of battle chess you can see the queens nipples poking at her shirt as she goes to make a kill?  Hey I just typed the longest sentence ever known to man but when I tried to copy it to get a byte count it just was truncated at the 256 byte mark and I KNOW that there was more than that, probably because it was cut off in the middle of the word 'dumbass'.  Lets get a byte count of that.  On second thought lets not.  If it's less than 256 bytes I will be unsatisfied and if it's more then I'll have to retype it all.  Instead, let's just count the number of bytes in the entire scrolltext.  <-= @A#T @T#H$A*T @M#A$R*K @T#H*E @S#C$R*O@L#L$T*E@X#T $I*S @E#X$A*C@T#L$Y @1#5$9*1@3 @b#y$t*e@s @l#o$n*g@!#!$!*!  @W#E @H#A$V*E @S#U$C*C@E#E$D*E@D#!$!*!  &But do you think we are going to stop here?  "„DATA "Well, whatever your answer is, YOU'RE RIGHT!!!         "„„Rich Geldreich                 3-D WIREFRAME PROGRAM          3D,WIREFRAME                   Year of 1992 (00:00:00)QB, QBasic             404  13852    3D.BAS      'Well, here you go! This is an improved, easier to read version of my„'fast 3-D wireframe program. I've done some things that a couple„'people recommended and I've also sped it up a little.„'(The number at the upper left corner of the screen is the number of frames„'per second that are being displayed. It's updated every 20 frames, so„'it will be a little choppy.)„„„'3DEXP1a.BAS By Rich Geldreich April 16th, 1992„'(This version has some documentation...)„„DEFINT A-Z„TYPE LineType„    X AS INTEGER„    Y AS INTEGER„    Z AS INTEGER„    X1 AS INTEGER„    Y1 AS INTEGER„    Z1 AS INTEGER„END TYPE„DIM Points(100) AS LineType„DIM Xs(100), Ys(100), Xe(100), Ye(100), Xn(100), Yn(100)„DIM Xs1(100), Ys1(100), Xe1(100), Ye1(100)„DIM X(100), Y(100), Z(100), Pointers1(100), Pointers2(100)„DIM R(100)„DIM Cosine&(360), Sine&(360)„CLS„PRINT "3-D Craft"„PRINT "By Rich Geldreich 1992"„PRINT„PRINT "Keys to use: (Turn NUMLOCK on!)"„PRINT "Q...............Quits"„PRINT "Numeric keypad..Controls your position(press 5 on the keypad"„PRINT "                to completly stop yourself) "„PRINT "-...............Forward exceleration"„PRINT "+...............Backward exceleration"„PRINT "Arrow keys......Controls the rotation of the craft"„PRINT "F...............Excelerates the craft (Forward)"„PRINT "B...............Slows the craft (Backward)"„PRINT "S...............Stops the craft"„PRINT "A...............Toggles Auto Center, use this when you lose";„PRINT " the craft"„PRINT "C...............Stops the craft's rotation"„PRINT "V...............Resets the craft to starting position"„PRINT„PRINT "Wait a sec..."„„'The following for/next loop makes a sine & cosine table.„'Each sine & cosine is multiplied by 1024 and stored as long integers.„'This is done so that we don't have to use any slow floating point„'math at run time.„a = 0„FOR a! = 0 TO 359 / 57.29577951# STEP 1 / 57.29577951#„    Cosine&(a) = INT(.5 + COS(a!) * 1024)„    Sine&(a) = INT(.5 + SIN(a!) * 1024): a = a + 1„NEXT„'Next we read in all of the lines that are in the object...„FOR a = 0 TO 44„    READ Points(a).X, Points(a).Y, Points(a).Z„    READ Points(a).X1, Points(a).Y1, Points(a).Z1„NEXT„'Here comes the hard part... Consider this scenario:„„'We have two connected lines, like this:„„'   1--------2 and 3„'            |„'            |„'            |„'            |„'            4„'Where 1,2, 3, & 4 are the starting and ending points of each line.„'The first line consists of points 1 & 2  and the second line„'is made of points 3 & 4.„'So, you ask, what's wrong? Nothing, really, but don't you see that„'points 2 and 3 are really at the sample place? Why rotate them twice,„'that would be a total waste of time? The following code eliminates such„'occurrences from the line table. (great explanation, huh?)„„NumberLines = 45„'take all of the starting & ending points and put them in one big„'array...„Np = 0„FOR a = 0 TO NumberLines - 1„    X(Np) = Points(a).X„    Y(Np) = Points(a).Y„    Z(Np) = Points(a).Z„    Np = Np + 1„    X(Np) = Points(a).X1„    Y(Np) = Points(a).Y1„    Z(Np) = Points(a).Z1„    Np = Np + 1„NEXT„'Now set up two sets of pointers that point to each point that a line„'is made of... (in other words, scan for the first occurrence of each„'starting and ending point in the point array we just built...)„FOR a = 0 TO NumberLines - 1„    Xs = Points(a).X„    Ys = Points(a).Y„    Zs = Points(a).Z            'get the 3 coordinates of the start point„    FOR B = 0 TO Np - 1         'scan the point array„        IF X(B) = Xs AND Y(B) = Ys AND Z(B) = Zs THEN„            Pointers1(a) = B    'set the pointer to point to the„            EXIT FOR            'point we have just found„        END IF„    NEXT„    Xs = Points(a).X1           'do the same thing that we did above„    Ys = Points(a).Y1           'except scan for the ending point„    Zs = Points(a).Z1           'of each line„    FOR B = 0 TO Np - 1„        IF X(B) = Xs AND Y(B) = Ys AND Z(B) = Zs THEN„            Pointers2(a) = B„            EXIT FOR„        END IF„    NEXT„NEXT„'Okay, were almost done! All we have to do now is to build a table„'that tells us which points to actually rotate...„Nr = 0„FOR a = 0 TO NumberLines - 1„    F1 = Pointers1(a)   'get staring & ending point number„    S1 = Pointers2(a)„    IF Nr = 0 THEN      'if this is the first point then it of course„                        'has to be rotated„        R(Nr) = F1: Nr = Nr + 1„    ELSE„        found = 0       'scan to see if this point already exists...„        FOR B = 0 TO Nr - 1„            IF R(B) = F1 THEN„                found = -1: EXIT FOR    'shoot, it's already here!„            END IF„        NEXT„        IF NOT found THEN R(Nr) = F1: Nr = Nr + 1   'point the point„                                                    'in the array it we„    END IF                                          'can't find it...„„    found = 0   'now look for the ending point„    FOR B = 0 TO Nr - 1„        IF R(B) = S1 THEN„            found = -1: EXIT FOR„        END IF„    NEXT„    IF NOT found THEN R(Nr) = S1: Nr = Nr + 1„NEXT„PRINT "Press any key to begin..."„a$ = INPUT$(1)„'The following sets up the rotation & perspective variables.„„'Vs = the screen that is currently being viewed„'Ws = the screen that is currently being worked on„Vs = 1: Ws = 0„„'Deg1 & Deg2 are the two angles of rotation„'D1 & D2 are the deltas of each axes. If D1 = -5, for instance, then„'Deg1 will be decreased 5 degress every frame.„Deg1 = 0: Deg2 = 0: D1 = 0: D2 = 0„„'Spos & Mypos are for the perspective routines...„'Spos is the screen's Z coordinate and Mypos is the users Z coordinate„Spos = -250: Mypos = 0„„'Mx, My, and Mz are the coordinates of the user.„'Ox, Oy, and Oz are the coordinates of the craft.„Mx = 0: my = 0: Mz = 0: Ox = 0: Oy = 0: Oz = -260„'main loop„NumberOfFrames = 0„DEF SEG = &H40„StartTime = PEEK(&H6C)„DO„„    'swap the viewing and working screens for page flipping...„    SWAP Vs, Ws„    SCREEN 9, , Ws, Vs„„    'adjust the angles according to their deltas...„    Deg1 = (Deg1 + D1) MOD 360„    Deg2 = (Deg2 + D2) MOD 360„    'fix the angles up if they go out of range„    IF Deg1 < 0 THEN Deg1 = Deg1 + 360„    IF Deg2 < 0 THEN Deg2 = Deg2 + 360„    'get the sine and cosine of each angle from the tables„    'that were prepared at the beginning of the program„    C1& = Cosine&(Deg1): S1& = Sine&(Deg1)„    C2& = Cosine&(Deg2): S2& = Sine&(Deg2)„„    'now we must adjust the object's coordinates„    'based on how quickly it is moving...„„    X = Speed: Y = 0: Z = 0„„    X1 = (X * C1&) \ 1024: Y1 = (X * S1&) \ 1024„    X2 = (X1 * C2&) \ 1024: Zn = (X1 * S2&) \ 1024„    Ox = Ox + X2: Oy = Oy + Y1: Oz = Oz + Zn„    IF Oz > 32000 THEN Oz = 32000„    IF Oz < -32000 THEN Oz = -32000„    IF Ox > 32000 THEN Ox = 32000„    IF Ox < -32000 THEN Ox = -32000„    IF Oy > 32000 THEN Oy = 32000„    IF Oy < -32000 THEN Oy = -32000„„    'if Atloc is true then Auto-Center is on...„    IF Atloc THEN„        Mx = Mx + (Ox - Mx) \ 4„        my = my + (Oy - my) \ 4„        Mz = Mz + ((Oz + 200) - Mz) \ 4„    ELSE„        'adjust the users position based on how much he is moving...„        Mz = Mz + Mzm: Mx = Mx + Mxm: my = my + Mym„        IF Mz > 32000 THEN Mz = 32000„        IF Mz < -32000 THEN Mz = -32000„        IF Mx > 32000 THEN Mx = 32000„        IF Mx < -32000 THEN Mx = -32000„        IF my > 32000 THEN my = 32000„        IF my < -32000 THEN my = -32000„    END IF„    '(Wait for vertical retrace, reduces flicker. This was recommended„    'by someone on the echo but I can't remember who! Thanks)„    WAIT &H3DA, 8„    'erase the old lines...„    IF Ws = 1 THEN„        FOR a = 0 TO Ln(Ws) - 1„            LINE (Xs1(a), Ys1(a))-(Xe1(a), Ye1(a)), 0„        NEXT„    ELSE„        FOR a = 0 TO Ln(Ws) - 1„            LINE (Xs(a), Ys(a))-(Xe(a), Ye(a)), 0„        NEXT„    END IF„    'print frames per second„    LOCATE 1, 1: PRINT a$„    'rotate the points...„    FOR a = 0 TO Nr - 1„        R = R(a): Xo = X(R): Yo = Y(R): Zo = Z(R)„        X1 = (Xo * C1& - Yo * S1&) \ 1024„        Y1& = (Xo * S1& + Yo * C1&) \ 1024 - my + Oy„        X1& = (X1 * C2& - Zo * S2&) \ 1024 - Mx + Ox„        Zn = (X1 * S2& + Zo * C2&) \ 1024 - Mz + Oz„        'if the point is too close(or behind) the viewer then„        'don't draw it...„        IF (Mypos - Zn) < 15 THEN„            Xn(R) = -1: Yn(R) = 0: Zn = 0„        ELSE„            'Put the point into perspective...„            'The original formula was:„            'Xnew=Xnew+( -Xold * ( (Spos-Z) / (MPos-Z) ) )„            'Ynew=Ynew=( -Yold * ( (Spos-Z) / (Mpos-Z) ) )„            v = (1330& * (Spos - Zn)) \ (Mypos - Zn)„            Xn(R) = 320 + X1& + (-X1& * v) \ 1330„„            'The Y coordinate is also multiplied by .8 to adjust„            'for SCREEN 9's height to width ratio...„„            Yn(R) = 175 + (8 * (Y1& + (-Y1& * v) \ 1330)) \ 10„        END IF„    NEXT„    'draw the lines...„    '(There are two seperate cases, each puts it's coordinates„    'in a different array for later erasing. I could of used a„    '2 dimensional array for this but that is slower.)„    IF Ws = 1 THEN„        Ln = 0„        FOR a = 0 TO NumberLines - 1„            F1 = Pointers1(a): S1 = Pointers2(a)„            Xn = Xn(F1): Yn = Yn(F1)„            'if Xn<>-1 then it's in view...„            IF Xn <> -1 THEN„                IF Xn(S1) <> -1 THEN„                    X1 = Xn(S1): Y1 = Yn(S1)„                    LINE (X1, Y1)-(Xn, Yn), 14„                    'store the lines so they can be erased later...„                    Xs1(Ln) = X1: Ys1(Ln) = Y1„                    Xe1(Ln) = Xn: Ye1(Ln) = Yn„                    Ln = Ln + 1„                END IF„            END IF„        NEXT„    ELSE„        Ln = 0„        FOR a = 0 TO NumberLines - 1„            F1 = Pointers1(a): S1 = Pointers2(a)„            Xn = Xn(F1): Yn = Yn(F1)„            'if Xn<>-1 then it's in view...„            IF Xn <> -1 THEN„                IF Xn(S1) <> -1 THEN„                    X1 = Xn(S1): Y1 = Yn(S1)„                    LINE (X1, Y1)-(Xn, Yn), 14„                    'store the lines so they can be erased later...„                    Xs(Ln) = X1: Ys(Ln) = Y1„                    Xe(Ln) = Xn: Ye(Ln) = Yn„                    Ln = Ln + 1„                END IF„            END IF„        NEXT„    END IF„    Ln(Ws) = Ln„    K$ = UCASE$(INKEY$)„    'Process the keystroke(if any)...„    IF K$ <> "" THEN„        SELECT CASE K$„            CASE "A"„                Atloc = NOT Atloc„            CASE "+"„                Mzm = Mzm + 2„            CASE "-"„                Mzm = Mzm - 2„            CASE "5"„                Mxm = 0: Mym = 0: Mzm = 0„            CASE "4"„                Mxm = Mxm - 2„            CASE "6"„                Mxm = Mxm + 2„            CASE "8"„                Mym = Mym - 2„            CASE "2"„                Mym = Mym + 2„            CASE "F"„                Speed = Speed + 5„            CASE "B"„                Speed = Speed - 5„            CASE "C"„                D1 = 0: D2 = 0„            CASE "S"„                Speed = 0„            CASE CHR$(0) + CHR$(72)„                D1 = D1 + 1„            CASE CHR$(0) + CHR$(80)„                D1 = D1 - 1„            CASE CHR$(0) + CHR$(75)„                D2 = D2 - 1„            CASE CHR$(0) + CHR$(77)„                D2 = D2 + 1„            CASE "Q"„                SCREEN 0, , 0, 0: CLS : PRINT "See ya later!"„                END„            CASE "V"„                D1 = 0: D2 = 0: Deg1 = 0: Deg2 = 0: Speed = 0„        END SELECT„    END IF„    NumberOfFrames = NumberOfFrames + 1„    SOUND 32767, .1„    'see if 20 frames have passed; if so then see„    'how long it took...„    IF NumberOfFrames = 20 THEN„        TotalTime = PEEK(&H6C) - StartTime„        IF TotalTime < 0 THEN TotalTime = TotalTime + 256„        FramesPerSecX100 = 36400 \ TotalTime„        High = FramesPerSecX100 \ 100„        Low = FramesPerSecX100 - High„        'A$ has the string that is printed at the upper left„        'corner of the screen„        a$ = MID$(STR$(High), 2) + "."„        a$ = a$ + RIGHT$("0" + MID$(STR$(Low), 2), 2) + "  "„        NumberOfFrames = 0„        StartTime = PEEK(&H6C)„    END IF„LOOP„'The following data is the shuttle craft...„'stored as Start X,Y,Z & End X,Y,Z„DATA -157,22,39,-157,-18,39„DATA -157,-18,39,-127,-38,39„DATA -127,-38,39,113,-38,39„DATA 113,-38,39,193,12,39„DATA 33,42,39,33,42,-56„DATA 33,42,-56,-127,42,-56„DATA -127,42,-56,-157,22,-56„DATA -157,22,-56,-157,22,39„DATA -157,22,-56,-157,-18,-56„DATA -157,-18,-56,-157,-18,39„DATA -157,-18,-56,-127,-38,-56„DATA -127,-38,-56,-127,-38,39„DATA -127,-38,-56,113,-38,-56„DATA 113,-38,-56,113,-38,39„DATA 113,-38,-56,193,12,-56„DATA 193,12,-56,193,12,39„DATA -157,22,-56,193,12,-56„DATA 193,12,39,-157,22,39„DATA -56,-13,41,-56,-3,41„DATA -56,-3,41,-26,-3,41„DATA -26,-3,41,-26,7,41„DATA -51,7,41,-31,-13,41„DATA -11,-13,41,-11,-3,41„DATA -11,-3,41,-1,7,41„DATA 9,7,41,9,-8,41„DATA 9,-8,41,24,-8,41„DATA 34,16,41,34,-38,41„DATA 33,-39,41,33,-39,-53„DATA 33,-39,-53,33,15,-53„DATA -42,-38,19,-72,-38,19„DATA -72,-38,19,-72,-38,-41„DATA -72,-38,-41,-42,-38,-41„DATA -42,-38,-41,-42,-38,19„DATA 33,42,39,34,16,41„DATA 33,42,-56,33,15,-53„DATA -157,22,39,-127,42,39„DATA -127,42,-56,-127,42,39„DATA -127,42,39,33,42,39„DATA 159,-8,-56,159,-8,40„DATA 143,-18,-56,143,-18,39„DATA 193,12,39,193,32,30„DATA 33,42,39,193,32,30„DATA 193,32,30,193,32,-47„DATA 33,42,-56,193,32,-47„DATA 193,12,-56,193,32,-47„„Carlos E. Diaz, Jr.            MAKE & SAVE BMP                MAKE,SAVE,BMP                  Year of 1994 (00:00:00)QB, QBasic             112  5604     BASICBMP.BAS'==== BASICBMP.BAS by Carlos E. Diaz, Jr. (XTDD74A) ===„'==== Copyright (C) 1994 ===„'==== Though copyrighted for proof of authorship, ===                      „'==== I, Carlos E. Diaz, Jr. have denoted the source code of ===           „'==== BASICBMP.BAS as PUBLIC DOMAIN. === =„'-------------------------------- NOTICE! ---------------------------------„'---    This program, written by Carlos E. Diaz, Jr. create BMP's of screen„'---    12 only! Use this program at your own risk! The writer has taken good„'---    care to make this program safe, but he is NOT liable for ANY damage it„'---    may cause.„'---    The file name of the BMP must be specified in the SUB makeBMP.     „'---    The program will not overwrite an existing file with the same name „'---    set in the SUB makeBMP.                            „'---    This program is only fast if you have a fast computer.             „'---    The white line that creeps from the bottom to the top of the screen„'---    simply shows what horizontal line the program is working on.        „'---    The only known side effect is that when the file is opened by      „'---    Windows' PaintBrush, the colors may not match those of the BASIC screen.„'---    If you have trouble opening the .BMP file from Windows, change your„'---    Windows display driver to 640x480 16 colors from Windows Setup.     „'---    This program was written and tested with QBASIC interpretive BASIC.  „                                   „DECLARE SUB MakeBMP ()„DECLARE SUB BMPheader (Hd$)„SCREEN 12„'-------------------------Draw Something on the Screen -------------------   „                                   „FOR t = 1 TO 25„     x1 = RND * 640„     y2 = RND * 480„     x2 = RND * 640„     y2 = RND * 480„     c = RND * 4 + 1„     LINE (x1, y1)-(x2, y2), c„     LINE (639 - x1, y1)-(639 - x2, y2), c„     LINE (x1, 479 - y1)-(x2, 479 - y2), c„     LINE (639 - x1, 479 - y1)-(639 - x2, 479 - y2), c„NEXT t„LINE (0, 0)-(639, 479), 15, B„a$ = "-=This BMP file was created by BASICBMP.BAS, a 100% QBasic program=-"„LOCATE 15, (40 - (LEN(a$) / 2)): PRINT a$„'--------------------------- Make the BMP file„'REMark the next line if you dont want to change the screen to a BMP.„CALL MakeBMP    'This is the heart of the program         „PRINT "!Program Complete!"„END„„SUB BMPheader (Hd$)„'**** This Header Creates a 640 x 480 16 color BMP format ONLY!! ****„'**** The exact meaning of each byte is unknown. ****                        „                         „'**** The only known side effect is that colors will not match ****          „                                    „'**** their BASIC equivalents when the .BMP is opened by ****                „                                 „'**** Windows 3.1's PaintBrush. ****                                         „        „    Hd$ = CHR$(66) + CHR$(77) + CHR$(118) + CHR$(88) + CHR$(2) + CHR$(0) + CHR$(0) + CHR$(0)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(118) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(40) + CHR$(0)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(128) + CHR$(2) + CHR$(0) + CHR$(0) + CHR$(224)„    Hd$ = Hd$ + CHR$(1) + CHR$(0) + CHR$(0) + CHR$(1) + CHR$(0) + CHR$(4) + CHR$(0) + CHR$(0)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(128)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(128) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(128) + CHR$(128)„    Hd$ = Hd$ + CHR$(0) + CHR$(128) + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(128) + CHR$(0)„    Hd$ = Hd$ + CHR$(128) + CHR$(0) + CHR$(128) + CHR$(128) + CHR$(0) + CHR$(0) + CHR$(128)„    Hd$ = Hd$ + CHR$(128) + CHR$(128) + CHR$(0) + CHR$(192) + CHR$(192) + CHR$(192)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(255) + CHR$(0) + CHR$(0) + CHR$(255)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(255) + CHR$(255) + CHR$(0) + CHR$(255)„    Hd$ = Hd$ + CHR$(0) + CHR$(0) + CHR$(0) + CHR$(255) + CHR$(0) + CHR$(255) + CHR$(0)„    Hd$ = Hd$ + CHR$(255) + CHR$(255) + CHR$(0) + CHR$(0) + CHR$(255) + CHR$(255) + CHR$(255)„    Hd$ = Hd$ + CHR$(0)„END SUB„„SUB MakeBMP„    DIM Header AS STRING„    DIM X AS INTEGER, Y AS INTEGER„    DIM a AS INTEGER, B AS INTEGER, c  AS INTEGER„    DIM filename AS STRING„    DIM Filelen AS LONG„    WINDOW SCREEN (0, 479)-(639, 0)„    '======== Set File name from this line ======„    filename$ = "C:\FIRSTBMP.BMP"„    BMPheader Header„    OPEN filename FOR BINARY ACCESS WRITE AS #1„         Filelen = LOF(1)„    CLOSE #1„    IF Filelen = 0 THEN„         OPEN filename FOR BINARY ACCESS WRITE AS #1„              PUT #1, , Header„              FOR Y = 479 TO 0 STEP -1„                   FOR X = 0 TO 639 STEP 2„                        a = POINT(X, Y)„                        B = POINT(X + 1, Y)„                        c = a * 16 + B„                        Buffer$ = Buffer$ + CHR$(c)„                   NEXT X„                   PUT #1, , Buffer$„                   Buffer$ = ""„                   LINE (0, Y)-(639, Y), 15„              NEXT Y„         CLOSE #1„    ELSE„         LOCATE 2, 1„         PRINT "*Attention!! Cannot make file " + CHR$(34) + filename + CHR$(34) + "!*"„          PRINT "*That file already exists and this*"„          PRINT "*program will NOT overwrite another file!*"„    END IF„END SUB„„Unknown Author(s)              SCALE DOOM FACE                SCALE,DOOM,FACE                Year of 1994 (00:00:00)QB, QBasic             113  4967     DOOMFACE.BAS'Here's a code to draw the face from DOOM in any size you want...„'Takes a while on slow computers, but you could BSAVE it into„'a file and BLOAD it into your program.„„DIM HALF(66)„DIM ONE(221)„DIM TWO(810)„DIM THREE(1771)„DIM FOUR(3104)„DIM FIVE(4964)„DIM SIX(7072)„SCREEN 13„PALETTE 14, (256 ^ 2 * 8) + (256 * 12) + 17„PALETTE 22, (256 ^ 2 * 30) + (256 * 30) + 54„PALETTE 48, (256 ^ 2 * 55) + (256 * 58) + 63„PALETTE 49, (256 ^ 2 * 52) + (256 * 56) + 63„PALETTE 50, (256 ^ 2 * 49) + (256 * 54) + 63„PALETTE 51, (256 ^ 2 * 46) + (256 * 52) + 63„PALETTE 52, (256 ^ 2 * 44) + (256 * 51) + 63„PALETTE 53, (256 ^ 2 * 41) + (256 * 49) + 63„PALETTE 54, (256 ^ 2 * 38) + (256 * 47) + 63„PALETTE 55, (256 ^ 2 * 36) + (256 * 46) + 63„PALETTE 56, (256 ^ 2 * 32) + (256 * 44) + 63„PALETTE 57, (256 ^ 2 * 30) + (256 * 42) + 63„PALETTE 58, (256 ^ 2 * 28) + (256 * 40) + 59„PALETTE 59, (256 ^ 2 * 26) + (256 * 38) + 57„PALETTE 60, (256 ^ 2 * 24) + (256 * 36) + 55„PALETTE 61, (256 ^ 2 * 22) + (256 * 34) + 53„PALETTE 62, (256 ^ 2 * 20) + (256 * 32) + 51„PALETTE 63, (256 ^ 2 * 19) + (256 * 31) + 50„PALETTE 64, (256 ^ 2 * 18) + (256 * 30) + 47„PALETTE 65, (256 ^ 2 * 17) + (256 * 28) + 44„PALETTE 66, (256 ^ 2 * 16) + (256 * 27) + 42„PALETTE 67, (256 ^ 2 * 15) + (256 * 26) + 40„PALETTE 68, (256 ^ 2 * 14) + (256 * 24) + 38„PALETTE 69, (256 ^ 2 * 13) + (256 * 23) + 35„PALETTE 70, (256 ^ 2 * 12) + (256 * 21) + 33„PALETTE 71, (256 ^ 2 * 11) + (256 * 20) + 31„PALETTE 72, (256 ^ 2 * 10) + (256 * 19) + 29„PALETTE 73, (256 ^ 2 * 9) + (256 * 17) + 26„PALETTE 74, (256 ^ 2 * 8) + (256 * 16) + 23„PALETTE 75, (256 ^ 2 * 7) + (256 * 15) + 20„PALETTE 76, (256 ^ 2 * 6) + (256 * 13) + 18„PALETTE 77, (256 ^ 2 * 5) + (256 * 11) + 15„PALETTE 78, (256 ^ 2 * 4) + (256 * 10) + 12„PALETTE 79, (256 ^ 2 * 3) + (256 * 8) + 10„PALETTE 144, (256 ^ 2 * 24) + (256 * 32) + 39„PALETTE 148, (256 ^ 2 * 12) + (256 * 20) + 25„PALETTE 162, (256 ^ 2 * 16) + (256 * 46) + 53„PALETTE 163, (256 ^ 2 * 11) + (256 * 38) + 48„PALETTE 164, (256 ^ 2 * 7) + (256 * 30) + 43„PALETTE 165, (256 ^ 2 * 4) + (256 * 22) + 38„PALETTE 210, (256 ^ 2 * 46) + (256 * 53) + 63„PALETTE 212, (256 ^ 2 * 30) + (256 * 44) + 63„PALETTE 213, (256 ^ 2 * 22) + (256 * 40) + 63„PALETTE 224, (256 ^ 2 * 63) + (256 * 63) + 63„PALETTE 225, (256 ^ 2 * 53) + (256 * 63) + 63„„1„CLS„A = 2    'Change this to a higher number for a bigger face.„GOSUB DOOMFACE„DEF SEG„DO: LOOP UNTIL INKEY$ <> ""„SYSTEM„„DOOMFACE:„CLS„FOR X = 1 TO 29 * A STEP A„FOR Y = 1 TO 24 * A STEP A„READ C„PSET (Y, X), C„FOR Z = 1 TO A„FOR Z2 = 0 TO A - 1„PSET (Y + Z2, X + Z - 1), C„PSET (Y + Z - 1, X + Z2), C„PSET (Y + Z - 1, X + Z - 1), C„NEXT Z2„NEXT Z„NEXT Y„NEXT X„RETURN„'Color data„DATA 0,0,0,0,0,76,74,74,74,73,72,72,72,72,72,73,74,74,76,0,0,0,0,0„DATA 0,0,0,78,74,75,74,73,69,64,65,62,62,65,66,68,72,74,75,74,78,0,0,0„DATA 0,0,78,74,72,69,68,64,63,62,67,65,68,68,68,69,69,72,72,75,76,78,0,0„DATA 0,0,78,72,70,72,69,68,65,70,66,69,67,72,72,72,72,74,75,78,78,79,0,0„DATA 0,79,77,74,72,74,69,68,69,69,69,69,76,69,74,76,74,76,78,79,79,79,79,0„DATA 0,79,77,76,75,74,69,75,68,73,73,69,73,76,73,76,77,74,79,78,78,77,79,0„DATA 0,79,76,76,72,72,75,69,75,73,72,73,73,69,69,69,70,70,73,76,77,76,79,0„DATA 0,79,76,75,72,69,72,75,67,75,72,69,67,65,68,67,69,69,69,73,76,76,79,0„DATA 0,79,76,74,69,66,65,67,67,65,65,65,65,65,65,67,67,65,66,69,75,76,79,0„DATA 0,79,76,72,68,62,63,63,65,67,66,66,66,66,67,65,63,63,62,68,74,76,79,0„DATA 0,79,76,72,68,62,58,59,62,64,67,69,69,67,64,62,59,58,62,68,72,76,79,0„DATA 0,79,76,73,65,59,50,56,59,59,62,61,61,62,59,59,56,50,59,65,72,76,79,0„DATA 65,73,76,72,73,73,75,67,60,65,72,65,65,72,65,60,67,75,73,73,72,76,73,65„DATA 65,73,14,69,66,66,68,70,72,73,73,69,69,73,73,72,70,68,66,66,69,14,73,65„DATA 69,73,148,65,72,163,225,224,162,163,165,61,61,165,163,162,224,225,163,72,65,14,8,73,69„DATA 73,74,70,65,69,66,163,162,163,164,69,62,59,69,164,163,162,163,66,69,65,70,74,73„DATA 70,74,70,22,61,64,66,69,66,63,61,213,212,61,63,66,69,66,64,61,22,70,74,70„DATA 69,74,69,62,60,58,60,63,213,55,59,213,212,59,55,213,63,60,58,60,62,69,74,69„DATA 0,74,70,67,66,64,61,213,53,60,61,212,210,61,60,53,213,61,64,66,67,70,74,0„DATA 0,74,72,68,67,64,58,57,61,66,68,144,144,68,66,61,57,58,64,67,68,72,74,0„DATA 0,0,72,65,68,61,55,59,64,75,72,70,70,72,75,64,59,55,61,68,65,72,0,0„DATA 0,0,74,63,68,59,57,62,62,61,64,67,67,64,61,62,62,57,59,68,63,74,0,0„DATA 0,0,75,66,67,61,59,62,61,57,54,60,60,54,57,61,62,59,61,67,66,75,0,0„DATA 0,0,0,70,66,63,61,69,72,165,165,165,165,165,165,72,69,61,63,66,70,0,0,0„DATA 0,0,0,75,69,65,63,63,63,61,59,213,213,59,61,63,63,63,65,69,75,0,0,0„DATA 0,0,0,0,73,66,62,60,63,66,69,71,71,69,66,63,60,62,66,73,0,0,0,0„DATA 0,0,0,0,0,73,66,62,60,63,63,59,59,63,63,60,62,66,73,0,0,0,0,0„DATA 0,0,0,0,0,0,75,70,65,61,59,54,54,59,61,65,70,75,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,79,73,69,67,67,67,67,69,73,79,0,0,0,0,0,0,0„„Matt Hart                      VIDEO MEMORY SEGMENT           VIDEO,MEMORY,SEGMENT           05-18-92 (21:02:00)    QB, QBasic             32   961      VIDEOSEG.BAS' JG>   Is there a way that I can determine wether to use &HB000 or„' JG> &HB800 when doing stuff with the screen?„„'A word (2 bytes) at 0000:0463h tells the port address of the CRT„'controller index register.  It will be 03B4h for monochrome and 03D4h„'for color, MSB last.„„DEF SEG = 0„MonType$ = HEX$(PEEK(&H0464))+HEX$(PEEK(&H0463))„DEF SEG„SELECT CASE MonType$„     CASE "3D4"         ' Color„          StartSeg = &HB800„          NumBytes = 80*25*2„     CASE "3B4"         ' Monochrome„          StartSeg = &HB000„          NumBytes = 80*25*2„END SELECT„„' JG>  And also, how do I save„' JG> and load screens with BSAVE and BLOAD? „„'For any screen, you save the number of bytes of the screen beginning at„'the segment and offset of the screen.  For text screens, this is:„     DEF SEG = StartSeg„     BSAVE "SCR.BIN",0,NumBytes„     DEF SEG„„'Bload is the same:„     DEF SEG = StartSeg„     BLOAD "SCR.BIN",0„     DEF SEG„Unknown Author(s)              PCX VIEWER                     PCX,VIEWER                     Unknown Date (00:00:00)QB, QBasic             182  4778     PCXVIEW.BAS DECLARE SUB SetPalette (pcxpal$)„DECLARE SUB SelectScreen ()„DECLARE SUB ReadPCXLine (PCXFile%, TotalBytes%, ScanLine%())„DECLARE SUB ReadPCXByte (PCXFile%, value%)„DECLARE SUB OpenPCXFile (PCXname$, xsize%, ysize%, TotalBytes%, pcxpal$)„DEFINT A-Z„TYPE PCXHeaderStruc„    Manufacxturer AS STRING * 1„    version AS STRING * 1„    Encoding AS STRING * 1„    BitsPerPixel AS STRING * 1„    xmin AS INTEGER„    ymin AS INTEGER„    xmax AS INTEGER„    ymax AS INTEGER„    Hres AS INTEGER„    Vres AS INTEGER„    ColorMap AS STRING * 48„    Reserved1 AS STRING * 1„    NumPlanes AS STRING * 1„    BytesPerLine AS INTEGER„    PaletteType AS INTEGER„    HScrSize AS INTEGER„    VScrSize AS INTEGER„    Resreved2 AS STRING * 54„END TYPE„DIM SHARED PCXheader AS PCXHeaderStruc„DIM SHARED PCXFile„DIM SHARED ScrMode, ScrMaxX, ScrMaxY„DIM SHARED ScrMaxColor, ScrBitsPerPixel„DIM SHARED byte AS STRING * 1„DO„   SCREEN 0„   WIDTH 80„   LINE INPUT "PCX filename: "; PCXname$„   IF PCXname$ = "" THEN EXIT DO„   OpenPCXFile PCXname$, xsize, ysize, TotalBytes, pcxpal$„   SEEK #PCXFile, LEN(PCXheader) + 1„   SelectScreen„   SCREEN ScrMode„   SetPalette pcxpal$„   REDIM ScanLine(TotalBytes + 1)„   pbits = xsize * ASC(PCXheader.BitsPerPixel)„   sbits = ScrMaxX * ScrBitsPerPixel„   IF pbits > sbits THEN„      ScanLine(0) = sbits + 1„   ELSE„      ScanLine(1) = pbits„   END IF„   ScanLine(1) = 1„   y = 0„   DO„      ReadPCXLine PCXFile, TotalBytes, ScanLine()„      PUT (0, y), ScanLine„      y = y + 1„   LOOP WHILE y < ysize OR y < ScrMaxY„   CLOSE #PCXPile„   BEEP„   i$ = INPUT$(1)„LOOP„END„„SUB OpenPCXFile (PCXname$, xsize, ysize, TotalBytes, pcxpal$)„PCXFile = FREEFILE„OPEN PCXname$ + ".pcx" FOR BINARY AS #PCXFile„GET #PCXFile, 1, PCXheader„pcxpal$ = LEFT$(PCXheader.ColorMap + STRING$(768, 0), 768)„IF ASC(PCXheader.version) = 5 THEN„   SEEK #PCXFile, LOF(PCXFile) - 768&„   GET #PCXFile, , byte„   IF ASC(byte) = 12 THEN GET #PCXFile, , pcxpal$„END IF„„„xsize = PCXheader.xmax - PCXheader.xmin + 1„ysize = PCXheader.ymax - PCXheader.ymin + 1„TotalBytes = ASC(PCXheader.NumPlanes) * PCXheader.BytesPerLine„END SUB„„SUB ReadPCXByte (PCXFile, value)„STATIC count, CountValue, BufferLOC, Buffer$„„IF count > 0 THEN„   value = CountValue„   count = count - 1„ELSE„   IF BufferLOC > LEN(Buffer$) OR LEN(Buffer$) = 0 THEN„      BufferLEN& = LOF(PCXFile) - LOC(PCXFile)„      IF BufferLEN& > 15000 THEN„         BufferLEN& = 15000„      END IF„      IF BufferLEN& <= 0 OR EOF(PCXFile) THEN„         EXIT SUB„      END IF„      Buffer$ = SPACE$(BufferLEN&)„      GET #PCXFile, , Buffer$„      BufferLOC = 1„   END IF„   value = ASC(MID$(Buffer$, BufferLOC, 1))„   BufferLOC = BufferLOC + 1„   IF value >= 192 THEN„      count = value - 193„      IF BufferLOC >= LEN(Buffer$) THEN„         BufferLEN& = LOF(PCXFile) - LOC(PCXFile)„         IF BufferLEN& > 15000 THEN„            BufferLEN& = 15000„         END IF„         IF BufferLEN& <= 0 OR EOF(PCXFile) THEN„            EXIT SUB„         END IF„         Buffer$ = SPACE$(BufferLEN&)„         GET #PCXFile, , Buffer$„         BufferLOC = 1„      END IF„      CountValue = ASC(MID$(Buffer$, BufferLOC, 1))„      BufferLOC = BufferLOC + 1„      value = CountValue„   END IF„END IF„„END SUB„„SUB ReadPCXLine (PCXFile, TotalBytes, ScanLine())„zero$ = CHR$(0)„index = LBOUND(ScanLine) + 2„count = 0„DO„   ReadPCXByte PCXFile, pixels„   ScanLine(index) = pixels„   IF count = TotalBytes THEN EXIT DO„   ReadPCXByte PCXFile, pixels„   ScanLine(index) = ScanLine(index) + CVI(zero$ + CHR$(pixels))„   count = count + 2„   index = index + 1„LOOP WHILE count < TotalBytes„END SUB„„SUB SelectScreen„SELECT CASE ASC(PCXheader.BitsPerPixel)„   CASE 1„      IF ASC(PCXheader.NumPlanes) = 4 THEN„         ScrMode = 12„         ScrMaxX = 639„         ScrMaxY = 479„         ScrMaxColor = 15„         ScrBitsPerPixel = 1„      ELSE„         ScrMode = 11„         ScrMaxX = 639„         ScrMaxY = 479„         ScrMaxColor = 1„         ScrBitsPerPixel = 1„      END IF„   CASE 2„      ScrMode = 1„      ScrMaxX = 319„      ScrMaxY = 199„      ScrMaxColor = 3„      ScrBitsPerPixel = 2„   CASE 8„      ScrMode = 13„      ScrMaxX = 319„      ScrMaxY = 199„      ScrMaxColor = 255„      ScrBitsPerPixel = 8„END SELECT„END SUB„„SUB SetPalette (pcxpal$)„version = ASC(PCXheader.version)„IF version = 5 AND ScrMode = 13 THEN„   FOR i = 0 TO ScrMaxColor„      r = ASC(MID$(pcxpal$, i * 3 + 1, 1)) \ 4„      g = ASC(MID$(pcxpal$, i * 3 + 2, 1)) \ 4„      b = ASC(MID$(pcxpal$, i * 3 + 3, 1)) \ 4„      PALETTE i, b * 65536 + g * 256 + r„   NEXT i„ELSE„   PALETTE„END IF„END SUB„„Jeff Benson                    GRAPHICAL SPHERE               GRAPHICAL,SPHERE               11-19-91 (08:31:00)    QB, QBasic             53   1110     SPHERE.BAS  'Here's a program worth trying, people . . . all you need is QuickBASIC„'(of course) and a VGA graphics adaptor. Give it a shot, you might„'learn something. This program was found on a local BBS.„ „' Program Creates a moving sphere by shifting the VGA palette„ „SCREEN 13„DIM Sphere(700)„CLS„PAINT (160, 100), 201„Red = 1„Green = 1„Blue = 1„Radius = 25„FOR PaletteRange = 15 TO 40„  Red = PaletteRange„  Green = PaletteRange„  ToColor = 65536 * Blue + 256 * Green + Red„  PALETTE PaletteRange, ToColor„  CIRCLE (160, 100), Radius, PaletteRange„  PAINT (160, 100), PaletteRange„  IF Radius > 1 THEN„    Radius = Radius - 1„  END IF„NEXT„ „' Get Sphere, store in array, clear and repaint screen„ „GET (134, 78)-(186, 122), Sphere„CLS„PAINT (160, 100), 201„X = 4„Y = 4„ „' Move Sphere around screen until a key is pressed„ „WHILE INKEY$ = ""„  IF X > 259 THEN„    Xadj = -1„  ELSEIF X <= 4 THEN„    Xadj = 1„  END IF„  IF Y >= 148 THEN„    Yadj = -1„  ELSEIF Y <= 4 THEN„    Yadj = 1„  END IF„  X = X + Xadj„  Y = Y + Yadj„  PUT (X, Y), Sphere, PSET„WEND„END„„Rich Geldreich                 SHADED 3-D POLYGON             SHADE,3D                       Year of 1992 (00:00:00)QB, PDS                648  21792    SHADE3D.BAS 'Shaded 3-D animation with shadows [solid5.bas] for QB4.5/PDS„'By Rich Geldreich 1992„'Notes...„'   This version uses some floating  point math in the initialization„'code for shading, but after initialization floating point math is not„'used at all.„'   The  shading  imploys Lambert's Law to determine the intensity of„'each visible polygon.  Three simple  lookup tables are calculated at„'initialization time  which  are  used  to  eliminate  multiples  and„'divides in the main animation code.„'   The hidden face  detection  algorithm  was  made  by Dave Cooper.„'It's fast, and does not require any multiples and divides under most„'cases.  The "standard" way of detecting hidden faces, by finding the„'dot product of the normal of each polygon and  the  viewing  vector,„'was not just good (or fast) enough for me!„'   The PolyFill routine is the major  bottleneck  of  this  program.„'QB's  LINE  command isn't as fast as I would like it to be...  On my„'286-10, the speed isn't that bad (after all, this is all-QB!).  On a„'386 or 486, this thing should fly...  [hopefully]„'   The  shadows  are  calculated by projecting a line with the light„'source's vector through each of the points on the solid.  Where this„'line hits the ground  plane(which  has  a  constant Y coordinate) is„'where the new shadow point is plotted.„'   This program is 100% public domain- but  of  course  please  give„'some credit if you use anything from this program.  Thanks!„DEFINT A-Z„DECLARE SUB CullPolygons ()„DECLARE SUB DrawLine (xs%, ys%, xe%, ye%, EdgeList() AS ANY)„DECLARE SUB DrawObject ()„DECLARE SUB DrawShadows ()„DECLARE SUB EdgeFill (EdgeList() AS ANY, YLow%, YHigh%, C%)„DECLARE SUB FindNormals ()„DECLARE SUB PolyFill (x1%, y1%, x2%, y2%, x3%, y3%, C%)„DECLARE SUB RotatePoints ()„DECLARE SUB ShadePolygons ()„ „CONST True = -1, False = 0„ „TYPE EdgeType              'for fast polygon rasterization„    Low         AS INTEGER„    High        AS INTEGER„END TYPE„TYPE PointType„    XObject     AS INTEGER 'original cooridinate„    YObject     AS INTEGER„    ZObject     AS INTEGER 'rotated coodinated„    XWorld      AS INTEGER„    YWorld      AS INTEGER„    ZWorld      AS INTEGER„    XView       AS INTEGER 'rotated & translated coordinate„    YView       AS INTEGER„    XShadow     AS INTEGER 'coordinates projected onto the ground plane„    YShadow     AS INTEGER„END TYPE„TYPE PolyType„    P1          AS INTEGER '3 points which make up the polygon(they point„    P2          AS INTEGER ' to the point list array)„    P3          AS INTEGER„    Culled      AS INTEGER 'True if plane not visible„    ZCenter     AS INTEGER 'Z center of polygon„    ZOrder      AS INTEGER 'Used in the shell sort of the ZCenters„    Intensity   AS INTEGER 'Intensity of polygon„    WorldXN     AS INTEGER 'Contains the coordinates of the point„    WorldYN     AS INTEGER ' which is both perpendicular and a constant„    WorldZN     AS INTEGER ' distance from the polygon„    NormalX     AS INTEGER 'Normal of polygon -128 to 128„    NormalY     AS INTEGER ' (used for fast Lambert shading)„    NormalZ     AS INTEGER„END TYPE„TYPE LineType„    P1          AS INTEGER 'Used for shadow projection„    P2          AS INTEGER„END TYPE„ „DIM SHARED EdgeList(199) AS EdgeType„DIM SHARED SineTable(359 + 90) AS LONG 'cos(x)=sin(x+90)„DIM SHARED R1, R2, R3, ox, oy, oz„DIM SHARED MaxPoints, MaxPolys, MaxLines„ „DIM SHARED lines(100) AS LineType„DIM SHARED Polys(100) AS PolyType„DIM SHARED Points(100) AS PointType„DIM SHARED lx(256), ly(256), lz(256)   'lookup tables for Lambert shading„„DIM SHARED s, XLow(1), XHigh(1), YLow(1), YHigh(1)„DIM SHARED ShadowXLow(1), ShadowXHigh(1), ShadowYLow(1), ShadowYHigh(1)„DIM SHARED lx, ly, lz„ „PRINT "QuickBASIC/PDS 3-D Solid Animation": PRINT "By Rich Geldreich 1992"„PRINT : PRINT "Keys: [Turn NUMLOCK on]"„PRINT "Left.....................Angle 1 -"„„PRINT "Right....................Angle 1 +"„PRINT "Up.......................Angle 2 -"„PRINT "Down.....................Angle 2 +"„PRINT "-........................Angle 3 -"„PRINT "+........................Angle 3 +"„PRINT "5........................Rotation Stop"„PRINT "0........................Rotation Reset"„PRINT "Up Arrow.................Forward"„PRINT "Down Arrow...............Backward"„PRINT "Left Arrow...............Left"„PRINT "Right Arrow..............Right"„PRINT : PRINT "Initializing..."„ „MaxPoints = 4  'Pyramid.„'Points follow...„DATA -100,0,100, -100,0,-100, 100,0,-100, 100,0,100, 0,-290,0„MaxPolys = 5„'Polygons follow (they must be specified in counterclockwise„'order for correct hidden face removal and shading)„DATA 4,0,3, 4,3,2, 4,1,0, 4,2,1, 3,0,1, 3,1,2„MaxLines = 7„'Lines follow for shadow computation...„DATA 4,0, 4,1, 4,2, 4,3, 0,1, 1,2, 2,3, 3,0„ „'MaxPoints = 7 'Cube.„'DATA -100,100,100„'DATA 100,100,100„'DATA 100,100,-100„'DATA -100,100,-100„'DATA -100,-100,100„'DATA 100,-100,100„'DATA 100,-100,-100„'DATA -100,-100,-100„'MaxPolys = 11„'DATA 5,4,0, 5,0,1„'DATA 6,2,3, 3,7,6„'DATA 6,5,1, 6,1,2„'DATA 7,0,4, 7,3,0„'DATA 6,7,4, 6,4,5„'DATA 0,3,2, 1,0,2„'MaxLines = 11„'DATA 0,1, 1,2, 2,3, 3,0„'DATA 4,5, 5,6, 6,7, 7,4„'DATA 4,0, 5,1, 6,2, 7,3„ „'MaxPoints = 15 'Wierd pencil-like shape...„'DATA 0,0,0, 250,0,0, 400,40,0, 400,60,0, 250,100,0, 0,100,0,-20,90,0, -20,10,0„'DATA 0,0,-50, 250,0,-50, 400,40,-50, 400,60,-50, 250,100,-50, 0,100,-50, -20,90,-50, -20,10,-50„'MaxPolys = 27„'DATA 1,0,7, 1,7,2, 2,7,6, 2,6,3, 3,6,4, 4,6,5„'DATA 9,15,8, 9,10,15, 10,14,15, 10,11,14, 11,13,14, 11,12,13„'DATA 8,7,0, 8,15,7, 8,0,1, 9,8,1, 9,1,2, 10,9,2, 10,2,3, 11,10,3„'DATA 12,11,4, 11,3,4, 4,5,13, 4,13,12„'DATA 5,6,14, 5,14,13, 14,6,7, 14,7,15„'MaxLines = 23„'DATA 0,1, 1,2, 2,3, 3,4, 4,5, 5,6, 6,7, 7,0„'DATA 8,9, 9,10, 10,11, 11,12, 12,13, 13,14, 14,15, 15,0„'DATA 0,8, 1,9, 2,10, 3,11, 4,12, 5,13, 6,14, 7,15„ „FOR a = 0 TO MaxPoints„    READ Points(a).XObject, Points(a).YObject, Points(a).ZObject„    X = X + Points(a).XObject: Y = Y + Points(a).YObject: Z = Z + Points(a).ZObject„NEXT„'Center the object„X = X \ (MaxPoints + 1): Y = Y \ (MaxPoints + 1): Z = Z \ (MaxPoints + 1)„FOR a = 0 TO MaxPoints„    Points(a).XObject = Points(a).XObject - X„    Points(a).YObject = Points(a).YObject - Y„    Points(a).ZObject = Points(a).ZObject - Z„NEXT„FOR a = 0 TO MaxPolys„    READ Polys(a).P1, Polys(a).P2, Polys(a).P3„NEXT„FOR a = 0 TO MaxLines„    READ lines(a).P1, lines(a).P2„NEXT„ „'Precalculate the normal point of each polygon for fast Lambert shading„„FindNormals„ „'Precalculate the sine table„a = 0„„FOR a! = 0 TO (359 + 90) / 57.29 STEP 1 / 57.29„    SineTable(a) = SIN(a!) * 1024: a = a + 1„NEXT„ „'Some light source configurations won't work that great!„l1 = 70: l2 = 40           'light source's spherical coordinates„a1! = l1 / 57.29: a2! = l2 / 57.29„„s1! = SIN(a1!): c1! = COS(a1!)„s2! = SIN(a2!): c2! = COS(a2!)„lx = 128 * s1! * c2!        'convert spherical coordinates to a vector„ly = 128 * s1! * s2!        'scale up by 128 for integer math„lz = 128 * c1!„ „FOR a = -128 TO 128         'precalculate the three light source tables„    lx(a + 128) = lx * a    'for fast Lambert shading„    ly(a + 128) = ly * a„    lz(a + 128) = lz * a„NEXT„ „PRINT "Strike a key...": DO: LOOP WHILE INKEY$ = ""„ „R1 = 0: R2 = 0: R3 = 0      'three angles of rotation„ox = 0: oy = -50: oz = 1100 'object's origin (this program cannot currently„                            'handle the object when it goes behind theviewer!)„s = 1: t = 0„ „SCREEN 7, , 0, 0„OUT &H3C8, 0                'set 16 shades„FOR a = 0 TO 15„    OUT &H3C9, (a * 34) \ 10„    OUT &H3C9, (a * 212) \ 100„    OUT &H3C9, (a * 4) \ 10„    IF a = 7 THEN OUT &H3C7, 16: OUT &H3C8, 16„NEXT„LINE (0, 100)-(319, 199), 9, BF„LINE (0, 0)-(319, 99), 3, BF„SCREEN 7, , 1, 0„LINE (0, 100)-(319, 199), 9, BF„LINE (0, 0)-(319, 99), 3, BF„ „YHigh(0) = -32768: ShadowYHigh(0) = -32768„YHigh(1) = -32768: ShadowYHigh(1) = -32768„DO„    'Flip active and work pages so user doesn't see our messy drawing„    SCREEN 7, , s, t: SWAP s, t„ „    'Wait for vertical retrace to reduce flicker„    WAIT &H3DA, 8„ „    'Erase the old image from the screen„    IF YHigh(s) <> -32768 THEN„        IF YHigh(s) < 100 THEN„            LINE (XLow(s), YLow(s))-(XHigh(s), YHigh(s)), 3, BF„        ELSEIF YLow(s) < 100 THEN„            LINE (XLow(s), YLow(s))-(XHigh(s), 99), 3, BF„            LINE (XLow(s), 100)-(XHigh(s), YHigh(s)), 9, BF„        ELSE„            LINE (XLow(s), YLow(s))-(XHigh(s), YHigh(s)), 9, BF„        END IF„    END IF„    IF ShadowYHigh(s) <> -32768 THEN„        LINE (ShadowXLow(s), ShadowYLow(s))-(ShadowXHigh(s), ShadowYHigh(s)), 9, BF„    END IF„    RotatePoints„    CullPolygons„    ShadePolygons„ „    XLow(s) = 32767: XHigh(s) = -32768„    YLow(s) = 32767: YHigh(s) = -32768„    DrawShadows„    DrawObject„ „    R1 = (R1 + D1) MOD 360: IF R1 < 0 THEN R1 = R1 + 360„    R2 = (R2 + D2) MOD 360: IF R2 < 0 THEN R2 = R2 + 360„    R3 = (R3 + D3) MOD 360: IF R3 < 0 THEN R3 = R3 + 360„    oz = oz + dz: ox = ox + dx„    IF oz < 600 THEN„        oz = 600: dz = 0„    ELSEIF oz > 8000 THEN„        oz = 8000: dz = 0„    END IF„    IF ox < -4000 THEN„        ox = -4000: dx = 0„    ELSEIF ox > 4000 THEN„        ox = 4000: dx = 0„    END IF„    a$ = INKEY$„    SELECT CASE a$„    CASE "4"„        D1 = D1 - 2„    CASE "6"„        D1 = D1 + 2„    CASE "8"„        D2 = D2 - 2„    CASE "2"„        D2 = D2 + 2„    CASE "5"„„        D1 = 0: D2 = 0: D3 = 0„    CASE "0"„        R1 = 0: R2 = 0: R3 = 0„        D1 = 0: D2 = 0: D3 = 0„    CASE "+"„        D3 = D3 + 2„    CASE "-"„        D3 = D3 - 2„    CASE CHR$(27)„        END„    CASE CHR$(0) + CHR$(72)„        dz = dz - 20„    CASE CHR$(0) + CHR$(80)„        dz = dz + 20„    CASE CHR$(0) + CHR$(77)„        dx = dx - 20„    CASE CHR$(0) + CHR$(75)„        dx = dx + 20„    END SELECT„LOOP„ „'Shades the polygons using Lambert shading. Notice the total lack of„'floating point math- only 1 divide is required for each polygon shaded.„'(This divide can be eliminated, but the shading won't be as accurate.)„„'"Culls" the polygons which aren't visible to the viewer. Also shades„'each polygon using Lambert's law.„SUB CullPolygons„    'This algorithm for removing hidden faces was developed by Dave Cooper.„    'There is another method, by finding the dot product of the„    'plane's normal and the viewing vector, but this algorithm is„    'much faster because of its simplicity(and lack of floating point„    'calculations).„    FOR a = 0 TO MaxPolys„        P1 = Polys(a).P1„        P2 = Polys(a).P2„        P3 = Polys(a).P3„ „        IF Points(P1).YView <= Points(P2).YView THEN„            IF Points(P3).YView < Points(P1).YView THEN„                PTop = P3„                PNext = P1„                PLast = P2„            ELSE„                PTop = P1„                PNext = P2„                PLast = P3„            END IF„        ELSE„            IF Points(P3).YView < Points(P2).YView THEN„                PTop = P3„                PNext = P1„                PLast = P2„            ELSE„                PTop = P2„                PNext = P3„                PLast = P1„            END IF„        END IF„ „        XLow = Points(PTop).XView„        YLow = Points(PTop).YView„ „        XNext = Points(PNext).XView„        XLast = Points(PLast).XView„ „        IF XNext <= XLow AND XLast >= XLow THEN„            Polys(a).Culled = True„        ELSEIF XNext >= XLow AND XLast <= XLow THEN„            Polys(a).Culled = False„        ELSE„            YNext = Points(PNext).YView„            YLast = Points(PLast).YView„            IF ((YNext - YLow) * 256&) \ (XNext - XLow) < ((YLast - YLow) * 256&) \ (XLast - XLow) THEN„                Polys(a).Culled = False„            ELSE„                Polys(a).Culled = True„            END IF„        END IF„ „    NEXT„END SUB„„'Enters a line into the edge list. For each scan line, the line's„'X coordinate is found. Notice the lack of floating point math in this„'subroutine.„SUB DrawLine (xs, ys, xe, ye, EdgeList() AS EdgeType)„ „    IF ys > ye THEN SWAP xs, xe: SWAP ys, ye„ „    IF ye < 0 OR ys > 199 THEN EXIT SUB„„    IF ys < 0 THEN„        xs = xs + ((xe - xs) * -ys) \ (ye - ys)„        ys = 0„„    END IF„ „    xd = xe - xs„    yd = ye - ys„ „    IF yd <> 0 THEN xi = xd \ yd: xrs = ABS(xd MOD yd)„ „    xr = -yd \ 2„ „    IF ye > 199 THEN ye = 199„ „    xdirect = SGN(xd) + xi„ „    FOR Y = ys TO ye„        IF xs < EdgeList(Y).Low THEN EdgeList(Y).Low = xs„        IF xs > EdgeList(Y).High THEN EdgeList(Y).High = xs„ „        xr = xr + xrs„        IF xr > 0 THEN„            xr = xr - yd„            xs = xs + xdirect„        ELSE„            xs = xs + xi„        END IF„    NEXT„ „END SUB„„SUB DrawObject„ „    'Find the center of each visible polygon, and prepare the order list.„    NumPolys = 0„    FOR a = 0 TO MaxPolys„        IF Polys(a).Culled = False THEN 'is this polygon visible?„            Polys(NumPolys).ZOrder = a„            NumPolys = NumPolys + 1„            Polys(a).ZCenter = Points(Polys(a).P1).ZWorld + Points(Polys(a).P2).ZWorld + Points(Polys(a).P3).ZWorld„        END IF„    NEXT„    'Sort the visible polygons by their Z center using a shell sort.„    NumPolys = NumPolys - 1„    Mid = (NumPolys + 1) \ 2„    DO„        FOR a = 0 TO NumPolys - Mid„            CompareLow = a„            CompareHigh = a + Mid„            DO WHILE Polys(Polys(CompareLow).ZOrder).ZCenter < Polys(Polys(CompareHigh).ZOrder).ZCenter„                SWAP Polys(CompareLow).ZOrder, Polys(CompareHigh).ZOrder„                CompareHigh = CompareLow„                CompareLow = CompareLow - Mid„                IF CompareLow < 0 THEN EXIT DO„            LOOP„        NEXT„        Mid = Mid \ 2„    LOOP WHILE Mid > 0„    'Plot the visible polygons.„    FOR Z = 0 TO NumPolys„        a = Polys(Z).ZOrder 'which polygon do we plot?„        P1 = Polys(a).P1: P2 = Polys(a).P2: P3 = Polys(a).P3„        PolyFill (Points(P1).XView), (Points(P1).YView), (Points(P2).XView), (Points(P2).YView), (Points(P3).XView), (Points(P3).YView), (Polys(a).Intensity)„    NEXT„END SUB„„SUB DrawShadows„    YLow = 32767: YHigh = -32768„    XLow = 32767: XHigh = -32768„    FOR a = 0 TO MaxPoints„        'Project the 3-D point onto the ground plane...„        temp& = (Points(a).YWorld - 200)„        X = Points(a).XWorld - (temp& * lx) \ ly„        Y = 200 'ground plane has a constant Y coordinate„        Z = Points(a).ZWorld - (temp& * lz) \ ly„        'Put the point into perspective„        xTemp = 160 + (X * 400&) \ Z„        yTemp = 100 + (Y * 300&) \ Z„ „        Points(a).XShadow = xTemp„        Points(a).YShadow = yTemp„ „        'Find the lowest & highest X Y coordinates„        IF yTemp < YLow THEN YLow = yTemp„„        IF yTemp > YHigh THEN YHigh = yTemp„        IF xTemp < XLow THEN XLow = xTemp„        IF xTemp > XHigh THEN XHigh = xTemp„    NEXT„ „    'Store lowest & highest coordinates for later erasing...„    ShadowXLow(s) = XLow: ShadowYLow(s) = YLow„„    ShadowXHigh(s) = XHigh: ShadowYHigh(s) = YHigh„    IF XHigh < 0 OR XLow > 319 OR YLow > 199 OR YHigh < 0 THEN EXIT SUB„    IF YHigh > 199 THEN YHigh = 199„    IF YLow < 0 THEN YLow = 0„ „    'Initialize the edge list„    FOR a = YLow TO YHigh„        EdgeList(a).Low = 32767„        EdgeList(a).High = -32768„    NEXT„ „    'Enter the lines into the edge list„    FOR a = 0 TO MaxLines„        P1 = lines(a).P1„        P2 = lines(a).P2„        DrawLine (Points(P1).XShadow), (Points(P1).YShadow), (Points(P2).XShadow), (Points(P2).YShadow), EdgeList()„        'LINE ((Points(P1).XShadow),(Points(P1).YShadow))-((Points(P2).XShadow), (Points(P2).YShadow)), 0„    NEXT„ „    'Fill the polygon„    EdgeFill EdgeList(), YLow, YHigh, 3„ „END SUB„„SUB EdgeFill (EdgeList() AS EdgeType, YLow, YHigh, C)„    FOR a = YLow TO YHigh„        LINE (EdgeList(a).Low, a)-(EdgeList(a).High, a), C„    NEXT„END SUB„„'This routine initializes the data required by the fast Lambert shading„'algorithm. It calculates the point which is both perpendicular„'and a constant distance from each polygon and stores it. This point„'is then rotated with the rest of the points. When it comes time for„'shading, the normal to the polygon is looked up in a simple lookup„'table for maximum speed.„SUB FindNormals„    FOR a = 0 TO MaxPolys„        P1 = Polys(a).P1: P2 = Polys(a).P2: P3 = Polys(a).P3„ „        'find the vectors of 2 lines inside the polygon„        ax! = Points(P2).XObject - Points(P1).XObject„        ay! = Points(P2).YObject - Points(P1).YObject„        az! = Points(P2).ZObject - Points(P1).ZObject„ „        bx! = Points(P3).XObject - Points(P2).XObject„        by! = Points(P3).YObject - Points(P2).YObject„        bz! = Points(P3).ZObject - Points(P2).ZObject„ „        'find the cross product of the 2 vectors„        nx! = ay! * bz! - az! * by!„        ny! = az! * bx! - ax! * bz!„        nz! = ax! * by! - ay! * bx!„ „        'normalize the vector so it ranges from -1 to 1„        M! = SQR(nx! * nx! + ny! * ny! + nz! * nz!)„        IF M! <> 0 THEN nx! = nx! / M!: ny! = ny! / M!: nz! = nz! / M!„        'store the vector for later rotation(notice that it is scaled„        'up by 128 so it can be stored as an integer variable)„        Polys(a).WorldXN = nx! * 128 + Points(P1).XObject„        Polys(a).WorldYN = ny! * 128 + Points(P1).YObject„        Polys(a).WorldZN = nz! * 128 + Points(P1).ZObject„    NEXT„END SUB„„'Draws a polygon to the screen. Simply finds the start and stop X„'coordinates for each scan line within the polygon and uses the„'LINE command for filling.„SUB PolyFill (x1, y1, x2, y2, x3, y3, C) 'for QB 4.5 guys„ „    'find lowest and high X & Y coordinates„    IF y1 < y2 THEN YLow = y1 ELSE YLow = y2„    IF y3 < YLow THEN YLow = y3„    IF y1 > y2 THEN YHigh = y1 ELSE YHigh = y2„    IF y3 > YHigh THEN YHigh = y3„ „    IF x1 < x2 THEN XLow = x1 ELSE XLow = x2„    IF x3 < XLow THEN XLow = x3„    IF x1 > x2 THEN XHigh = x1 ELSE XHigh = x2„    IF x3 > XHigh THEN XHigh = x3„ „    IF YLow < 0 THEN YLow = 0„    IF YHigh > 199 THEN YHigh = 199„ „    IF XLow < XLow(s) THEN XLow(s) = XLow„    IF XHigh > XHigh(s) THEN XHigh(s) = XHigh„ „    IF YLow < YLow(s) THEN YLow(s) = YLow„    IF YHigh > YHigh(s) THEN YHigh(s) = YHigh„ „„    'check for polygons which cannot be visible„    IF YHigh < 0 OR YLow > 199 OR XLow > 319 OR XHigh < 0 THEN EXIT SUB„ „    'initialize the edge list„    FOR a = YLow TO YHigh„        EdgeList(a).Low = 32767„        EdgeList(a).High = -32768„    NEXT„ „    'Remember the lowest & highest X and Y coordinates drawn to the„    'screen for later erasing„ „    'Find the start and stop X coodinates for each scan line„    DrawLine (x1), (y1), (x2), (y2), EdgeList()„    DrawLine (x2), (y2), (x3), (y3), EdgeList()„    DrawLine (x3), (y3), (x1), (y1), EdgeList()„    EdgeFill EdgeList(), YLow, YHigh, C„ „END SUB„„'Rotates the points of the object and the object's normals.„'Avoids floating point math for speed.„SUB RotatePoints„ „    'lookup the sine and cosine of each angle...„    s1& = SineTable(R1): c1& = SineTable(R1 + 90)„    s2& = SineTable(R2): c2& = SineTable(R2 + 90)„    s3& = SineTable(R3): c3& = SineTable(R3 + 90)„ „    'rotate the points of the object„    FOR a = 0 TO MaxPoints„        xo = Points(a).XObject„        yo = Points(a).YObject„        zo = Points(a).ZObject„        GOSUB Rotate3D„ „        Points(a).XView = 160 + (x2 * 400&) \ z3„        Points(a).YView = 100 + (y3 * 300&) \ z3„        'IF y3 > 300 THEN STOP„ „        Points(a).XWorld = x2„        Points(a).YWorld = y3„        Points(a).ZWorld = z3„    NEXT„    'rotate the normals of each polygon...„    FOR a = 0 TO MaxPolys„        xo = Polys(a).WorldXN„        yo = Polys(a).WorldYN„        zo = Polys(a).WorldZN„        GOSUB Rotate3D„        P1 = Polys(a).P1„        'unorigin the point„        x2 = x2 - Points(P1).XWorld„        y3 = y3 - Points(P1).YWorld„        z3 = z3 - Points(P1).ZWorld„        'check the bounds just in case of a round off error„        IF x2 < -128 THEN x2 = -128 ELSE IF x2 > 128 THEN x2 = 128„        IF y3 < -128 THEN y3 = -128 ELSE IF y3 > 128 THEN y3 = 128„        IF z3 < -128 THEN z3 = -128 ELSE IF z3 > 128 THEN z3 = 128„        'store the normal back; it's now ready for the shading„        'calculations (which are simplistic now)„        Polys(a).NormalX = x2 + 128„        Polys(a).NormalY = y3 + 128„        Polys(a).NormalZ = z3 + 128„    NEXT„    EXIT SUB„ „Rotate3D:„    x1 = (xo * c1& - zo * s1&) \ 1024 'yaw„    z1 = (xo * s1& + zo * c1&) \ 1024„ „    z3 = (z1 * c3& - yo * s3&) \ 1024 + oz 'pitch„    y2 = (z1 * s3& + yo * c3&) \ 1024„ „    x2 = (x1 * c2& + y2 * s2&) \ 1024 + ox 'roll„    y3 = (y2 * c2& - x1 * s2&) \ 1024 + oy„ „RETURN„END SUB„„SUB ShadePolygons„    FOR a = 0 TO MaxPolys„        IF Polys(a).Culled = False THEN„„         'lookup the polygon's normal for shading„         '(128*128)\15 = 1092„         Intensity = (lx(Polys(a).NormalX) + ly(Polys(a).NormalY) + lz(Polys(a).NormalZ)) \ 1092„         IF Intensity < 0 THEN Intensity = 0„         Intensity = Intensity + 5„         IF Intensity > 15 THEN Intensity = 15„„         Polys(a).Intensity = Intensity„        END IF„    NEXT„END SUB„„Rich Geldreich                 DRAWING ELLIPSES               DRAW,ELLIPSES                  Year of 1993 (00:00:00)QB, QBasic, PDS        94   2632     DRAWELIP.BAS'Callable all-integer ellipse routine.„'By Rich Geldreich July 1993„DEFINT A-Z„DECLARE SUB DrawEllipse (ox%, oy%, prx%, pry%, co%)„„SCREEN 13 'the DrawEllipse routine is screen mode independent„rx = 51: ry = 51„DO 'test for DrawEllipse„    DrawEllipse 160, 100, rx, ry, 14„    DO: A$ = INKEY$: LOOP UNTIL A$ <> ""„    DrawEllipse 160, 100, rx, ry, 0„    IF LEN(A$) = 2 THEN„        A = -ASC(RIGHT$(A$, 1))„    ELSE„        A = ASC(A$)„    END IF„    SELECT CASE A„    CASE -72„        ry = ry - 3: IF ry < 0 THEN ry = 90„    CASE -80„        ry = ry + 3: IF ry > 90 THEN ry = 0„    CASE -75„        rx = rx - 3: IF rx < 0 THEN rx = 150„    CASE -77„        rx = rx + 3: IF rx > 150 THEN rx = 0„    CASE 27„        END„    END SELECT„LOOP„„'Calling parameters:„'ox, oy   = origin„'prx      = X radius„'pry      = Y radius„'co       = color„SUB DrawEllipse (ox, oy, prx, pry, co)„  DIM xe AS LONG, ye AS LONG, e AS LONG„  IF pry = 0 THEN 'special cases for horizontal & vertical ellipses„    LINE (ox - prx, oy)-(ox + prx, oy), co„    EXIT SUB„  END IF„  IF prx = 0 THEN„    LINE (ox, oy - pry)-(ox, oy + pry), co„    EXIT SUB„  END IF„  'work with largest axis to avoid rounding errors„  IF pry <= prx THEN„    x = 0: y = pry„    xe = 0: ye = CLNG(prx) * prx„    e = -ye \ 2: c = ye \ pry„    DO„      IF e <= 0 THEN„        DO„          PSET (ox + x, oy + y), co: PSET (ox - x, oy + y), co„          PSET (ox + x, oy - y), co: PSET (ox - x, oy - y), co„          x = x + 1„          xe = xe + pry„          e = e + xe„        LOOP WHILE e <= 0„      ELSE„        PSET (ox + x, oy + y), co: PSET (ox - x, oy + y), co„        PSET (ox + x, oy - y), co: PSET (ox - x, oy - y), co„      END IF„      y = y - 1„      ye = ye - c„      e = e - ye„    LOOP UNTIL y = 0„    PSET (ox + x, oy), co: PSET (ox - x, oy), co„    PSET (ox + x, oy), co: PSET (ox - x, oy), co„  ELSE„    x = 0: y = prx„    xe = 0: ye = CLNG(pry) * pry„    e = -ye \ 2: c = ye \ prx„    DO„      IF e <= 0 THEN„        DO„          PSET (ox + y, oy + x), co: PSET (ox - y, oy + x), co„          PSET (ox + y, oy - x), co: PSET (ox - y, oy - x), co„          x = x + 1„          xe = xe + prx„          e = e + xe„        LOOP WHILE e <= 0„      ELSE„        PSET (ox + y, oy + x), co: PSET (ox - y, oy + x), co„        PSET (ox + y, oy - x), co: PSET (ox - y, oy - x), co„      END IF„      y = y - 1„      ye = ye - c„      e = e - ye„    LOOP UNTIL y = 0„    PSET (ox, oy + x), co: PSET (ox, oy + x), co„    PSET (ox, oy - x), co: PSET (ox, oy - x), co„  END IF„END SUB„Rich Geldreich                 GIF VIEWER                     GIF,VIEWER                     Unknown Date (00:00:00)QB, QBasic, PDS        140  4906     GIFVIEW.BAS DEFINT A-Z„DIM Prefix(4095), Suffix(4095), OutStack(4095), ShiftOut(8)„ „'The following line is for the QB environment(slow).„DIM Ybase AS LONG, Powersof2(11) AS LONG, WorkCode AS LONG„'For more speed, unremark the next line and remark the one above,„'before you compile... (Change back when inside the environment.)„'DIM Ybase AS INTEGER, Powersof2(11) AS INTEGER, WorkCode AS INTEGER„ „FOR A = 0 TO 7: ShiftOut(8 - A) = 2 ^ A: NEXT„FOR A = 0 TO 11: Powersof2(A) = 2 ^ A: NEXT„A$ = COMMAND$: IF A$ = "" THEN INPUT "GIF file"; A$: IF A$ = "" THEN END„IF INSTR(A$, ".") = 0 THEN A$ = A$ + ".gif"„OPEN A$ FOR BINARY AS #1„A$ = "      ": GET #1, , A$„IF A$ <> "GIF87a" THEN PRINT "Not a GIF87a file.": END„GET #1, , TotalX: GET #1, , TotalY: GOSUB GetByte„NumColors = 2 ^ ((A AND 7) + 1): NoPalette = (A AND 128) = 0„GOSUB GetByte: Background = A„GOSUB GetByte: IF A <> 0 THEN PRINT "Bad screen descriptor.": END„IF NoPalette = 0 THEN P$ = SPACE$(NumColors * 3): GET #1, , P$„DO„    GOSUB GetByte„    IF A = 44 THEN„        EXIT DO„    ELSEIF A <> 33 THEN„        PRINT "Unknown extension type.": END„    END IF„    GOSUB GetByte„    DO: GOSUB GetByte: A$ = SPACE$(A): GET #1, , A$: LOOP UNTIL A = 0„LOOP„GET #1, , XStart: GET #1, , YStart: GET #1, , XLength: GET #1, , YLength„XEnd = XStart + XLength: YEnd = YStart + YLength: GOSUB GetByte„IF A AND 128 THEN PRINT "Can't handle local colormaps.": END„Interlaced = A AND 64: PassNumber = 0: PassStep = 8„GOSUB GetByte„ClearCode = 2 ^ A„EOSCode = ClearCode + 1„FirstCode = ClearCode + 2: NextCode = FirstCode„StartCodeSize = A + 1: CodeSize = StartCodeSize„StartMaxCode = 2 ^ (A + 1) - 1: MaxCode = StartMaxCode„ „BitsIn = 0: BlockSize = 0: BlockPointer = 1„X = XStart: Y = YStart: Ybase = Y * 320&„ „SCREEN 13: DEF SEG = &HA000„IF NoPalette = 0 THEN„    OUT &H3C7, 0: OUT &H3C8, 0„    FOR A = 1 TO NumColors * 3: OUT &H3C9, ASC(MID$(P$, A, 1)) \ 4: NEXT„END IF„LINE (0, 0)-(319, 199), Background, BF„DO„    GOSUB GetCode„    IF Code <> EOSCode THEN„        IF Code = ClearCode THEN„            NextCode = FirstCode„            CodeSize = StartCodeSize„            MaxCode = StartMaxCode„            GOSUB GetCode„            CurCode = Code: LastCode = Code: LastPixel = Code„            IF X < 320 THEN POKE X + Ybase, LastPixel„            X = X + 1: IF X = XEnd THEN GOSUB NextScanLine„        ELSE„            CurCode = Code: StackPointer = 0„            IF Code > NextCode THEN EXIT DO 'bad GIF if this happens„            IF Code = NextCode THEN„                CurCode = LastCode„                OutStack(StackPointer) = LastPixel„                StackPointer = StackPointer + 1„            END IF„ „            DO WHILE CurCode >= FirstCode„                OutStack(StackPointer) = Suffix(CurCode)„                StackPointer = StackPointer + 1„                CurCode = Prefix(CurCode)„            LOOP„ „            LastPixel = CurCode„            IF X < 320 THEN POKE X + Ybase, LastPixel„            X = X + 1: IF X = XEnd THEN GOSUB NextScanLine„ „            FOR A = StackPointer - 1 TO 0 STEP -1„                IF X < 320 THEN POKE X + Ybase, OutStack(A)„                X = X + 1: IF X = XEnd THEN GOSUB NextScanLine„            NEXT„ „            IF NextCode < 4096 THEN„                Prefix(NextCode) = LastCode„                Suffix(NextCode) = LastPixel„                NextCode = NextCode + 1„                IF NextCode > MaxCode AND CodeSize < 12 THEN„                    CodeSize = CodeSize + 1„                    MaxCode = MaxCode * 2 + 1„                END IF„            END IF„            LastCode = Code„        END IF„    END IF„LOOP UNTIL DoneFlag OR Code = EOSCode„A$ = INPUT$(1)„END„ „GetByte: A$ = " ": GET #1, , A$: A = ASC(A$): RETURN„ „NextScanLine:„    IF Interlaced THEN„        Y = Y + PassStep„        IF Y >= YEnd THEN„            PassNumber = PassNumber + 1„            SELECT CASE PassNumber„            CASE 1: Y = 4: PassStep = 8„            CASE 2: Y = 2: PassStep = 4„            CASE 3: Y = 1: PassStep = 2„            END SELECT„        END IF„    ELSE„        Y = Y + 1„    END IF„    X = XStart: Ybase = Y * 320&: DoneFlag = Y > 199„RETURN„GetCode:„    IF BitsIn = 0 THEN GOSUB ReadBufferedByte: LastChar = A: BitsIn = 8„    WorkCode = LastChar \ ShiftOut(BitsIn)„    DO WHILE CodeSize > BitsIn„        GOSUB ReadBufferedByte: LastChar = A„        WorkCode = WorkCode OR LastChar * Powersof2(BitsIn)„        BitsIn = BitsIn + 8„    LOOP„    BitsIn = BitsIn - CodeSize„    Code = WorkCode AND MaxCode„RETURN„ReadBufferedByte:„    IF BlockPointer > BlockSize THEN„        GOSUB GetByte: BlockSize = A„        A$ = SPACE$(BlockSize): GET #1, , A$„        BlockPointer = 1„    END IF„    A = ASC(MID$(A$, BlockPointer, 1)): BlockPointer = BlockPointer + 1„RETURN„„Eli Bennett                    OUT COMMAND                    OUT,COMMAND                    08-15-95 (20:34:00)    QB, QBasic, PDS        51   1909     OUTRGB.BAS  'Date: 08-15-95 (20:34)             Number: 583„'From: ELI BENNETT                  Refer#: NONE„'  To: MICHELLE QUINN                Recvd: NO„„'On (11 Aug 95) Michelle Quinn wrote to Olivier Dagenais...„„' MQ> DOES ANYONE KNOW HOW to use mode 13 vga Palette commands to get colors„' MQ> OTHER„' MQ> than shades of red. I know how to use the palette command, and how to use„' MQ> QuickBasic, but i cannot for the life of me figure out how to get something„' MQ> other than 0-63 shades of red!„„' EEEEEWwww... Never ever use that ugly disgusting palette command...„'        use the OUT command..„„'       The vga card has three unique ports for what you want„„„'      &h3c7 in basic or in asm 03c7H           (READ from color)„'      &h3c8                                    (WRITE to color)„'      &h3c9                                    (RGB to read or set)„„'      here is how this works......„'      lets say you want to change color 0 or black into the brightest„'      blue possible but you want to save the origenal rgb values„'      just do this„'----------------------cut-----------------„       DEFINT A-Z„       SCREEN 13„       'get origonal rgb values„       OUT &H3C7, 0     'read first colors rgb values„       Ored = INP(&H3C9)    'RED„       Og = INP(&H3C9)    'GREEN„       Ob = INP(&H3C9)    'BLUE„       'the first time you read or write you are reading or writing to„       'the red register, and then the green one and so on then it loops„       '(if you read again) back to the top or to RED„       OUT &H3C8, 0             '(write to the first color)„       OUT &H3C9, 0„       OUT &H3C9, 0„       OUT &H3C9, 63            'highest blue possible„       PSET (0, 0), 0„       SLEEP„       'restore old rgb vals.„       OUT &H3C8, 0„       OUT &H3C9, Ored„       OUT &H3C9, Og„       OUT &H3C9, Ob„       SCREEN 0, 0, 0, 0„       END„„The ABC Programmer             STAR/CREDIT SCROLLER           STAR,CREDIT,SCROLLER           08/02/95 (00:00:00)    QB, QBasic, PDS        105  3142     STARS.BAS   '==============================================================„'  Star/Credit Scroller by William Yu 1995„'  Simple use of page flipping to create a star trek effect„'==============================================================„DEFINT A-Z„DECLARE SUB ReGenerate (X)„DECLARE SUB CenterPrint (Y, MSG$)„DECLARE SUB ChangeMessage (Message)„SCREEN 7, 0, 0, 0„„DIM SHARED Stars(100) AS INTEGER„DIM SHARED StarColor(100) AS INTEGER„DIM SHARED MSG$„„X = 0„DO„  X = X + 1„  RANDOMIZE TIMER„  I = INT(RND * 320) + 1„  C = INT(RND * 3) + 1„  IF C = 1 THEN C = 7„  IF C = 2 THEN C = 8„  IF C = 3 THEN C = 15„  Stars(X) = I„  StarColor(X) = C„LOOP UNTIL X = 100„„LINE (0, 45)-(320, 50), 8, BF„LINE (0, 46)-(320, 49), 7, BF„LINE (0, 47)-(320, 48), 15, BF„LINE (0, 156)-(320, 151), 8, BF„LINE (0, 155)-(320, 152), 7, BF„LINE (0, 154)-(320, 153), 15, BF„CIRCLE (160, 100), 10, 10„PAINT (160, 100), 14, 10„XCor = 160: Ycor = 100„Y = 19„Message = 1„ChangeMessage Message„„DO„  V$ = INKEY$„  IF V$ = CHR$(0) + "P" THEN Ycor = Ycor + 2„  IF V$ = CHR$(0) + "H" THEN Ycor = Ycor - 2„  IF V$ = CHR$(0) + "M" THEN XCor = XCor + 3„  IF V$ = CHR$(0) + "K" THEN XCor = XCor - 3„  IF Ycor > 140 THEN Ycor = 140       ' Disable this for UnderLap„  IF Ycor < 60 THEN Ycor = 60         ' Disable this for OverLap„  FOR X = 1 TO 100„    PSET (Stars(X), X + 50), StarColor(X)„  NEXT„  PCOPY 0, 1                          ' Copies Page 0 to Page 1„  SCREEN 7, 0, 1, 0                   ' Write to Page 1 (Hidden)„  LINE (0, 45)-(320, 156), 0, BF      ' Use CLS for Over/UnderLap„  FOR X = 1 TO 100„    Stars(X) = Stars(X) - 1„    IF Stars(X) <= 0 THEN ReGenerate X„  NEXT X„  COLOR 11: CenterPrint Y, MSG$„  LINE (0, 45)-(320, 50), 8, BF       ' This is an overlap„  LINE (0, 46)-(320, 49), 7, BF„  LINE (0, 47)-(320, 48), 15, BF„  CIRCLE (XCor, Ycor), 10, 10         ' Move the Circle around„  PAINT (XCor, Ycor), 14, 10„  LINE (0, 156)-(320, 151), 8, BF     ' This is an underlap„  LINE (0, 155)-(320, 152), 7, BF„  LINE (0, 154)-(320, 153), 15, BF„  PCOPY 1, 0                          ' Copy Page 1 (Hidden) to Page 0„  SCREEN 7, 0, 0, 0                   ' Switch back to visual page„  Y = Y - 1„  IF Y = 7 THEN Y = 19: Message = Message + 1: ChangeMessage Message„LOOP UNTIL V$ = CHR$(27)„„SUB CenterPrint (Y, MSG$)„ „  Row! = 20 - (LEN((MSG$)) / 2) + .5„  LOCATE Y, Row!: PRINT MSG$„„END SUB„„SUB ChangeMessage (Message)„„IF Message = 7 THEN Message = 1„  IF Message = 1 THEN MSG$ = "Credit Star Scroller By William Yu"„  IF Message = 2 THEN MSG$ = "This Is A Cheap Page Flipping Technique"„  IF Message = 3 THEN MSG$ = "You Can Slow This Down By Adding Delays"„  IF Message = 4 THEN MSG$ = "Modify This Code As You Wish"„  IF Message = 5 THEN MSG$ = "USE Arrow Keys To Move The Circle"„  IF Message = 6 THEN MSG$ = "Enjoy This Demo, L8r!"„„END SUB„„SUB ReGenerate (X)„„  RANDOMIZE TIMER„  I = INT((350 - 320 + 1) * RND + 320)„  C = INT(RND * 3) + 1„  IF C = 1 THEN C = 7„  IF C = 2 THEN C = 8„  IF C = 3 THEN C = 15„  Stars(X) = I„  StarColor(X) = C„„END SUB„„Unknown Author(s)              SIDE WRITE FONTS               SIDE,WRITE,FONTS               Unknown Date (00:00:00)QB, QBasic, PDS        74   3665     SIDEWRIT.BASDEFINT A-Z„DECLARE SUB SideWrite (Mot$, PosX, PosY, Couleur, Opt)  'this is for QB4 only„„SCREEN 1                                            '320 x 200 x 4 graphics„DIM Temp(13)                                        'holds upper left corner„GET (0, 0)-(8, 7), Temp                             'save upper left corner„„'SCREEN 9                                           '640 x 350 x 16 graphics„'DIM Temp(57)„'GET (0, 0)-(8, 13), Temp„„CALL SideWrite("Side Writing", 0, 120, 1, 1)              '90¯ up„CALL SideWrite("Italic Side Writing", 20, 160, 2, 2)      '90¯ italic„CALL SideWrite("Vertical Writing", 40, 10, 3, 3)          '0¯ down„CALL SideWrite("Side Writing", 55, 10, 1, 4)              '270¯ down„CALL SideWrite("Italic Side Writing", 73, 10, 2, 5)       '270¯ down italic„CALL SideWrite("Big Side Writing", 90, 190, 3, 6)         'big 90¯ up„CALL SideWrite("Big Italic Side Writing", 115, 190, 1, 7) 'big 90¯ up italic„CALL SideWrite("Big Vertical Writing", 145, 10, 2, 8)     'big 0¯ down„CALL SideWrite("Normal", 10, 0, 3, 9)                     '0¯„CALL SideWrite("Normal Italic", 70, 0, 1, 10)             '0¯ right italic„CALL SideWrite("Big ", 180, 0, 2, 11)                     'big 0¯ right„CALL SideWrite("Big Italic", 220, 0, 3, 12)               'big 0¯ right italic„CALL SideWrite("All This DEMO", 180, 50, 1, 10)„CALL SideWrite("was done", 195, 60, 2, 9)„CALL SideWrite("--> with <--", 180, 76, 3, 11)„CALL SideWrite("SideWrit.Bas!!", 180, 100, 1, 12)„CALL SideWrite("______________", 180, 102, 1, 12)„„PUT (0, 0), Temp, PSET                              'restore upper left corner„„SUB SideWrite (Mot$, PosX, PosY, Couleur, Opt) STATIC„FOR Nombre = 1 TO LEN(Mot$)„    LOCATE 1, 1„    PRINT MID$(Mot$, Nombre, 1)        'print word's letters one by one„    FOR X = 0 TO 7„      FOR Y = 0 TO 7                   'use 0 TO 13 for EGA„        IF POINT(X, Y) THEN            'read pixel on/off for sideways copy„           IF Opt = 1 THEN„              PSET (Y + PosX, 8 - X + PosY - (8 * Nombre)), Couleur„           ELSEIF Opt = 2 THEN„              PSET (Y + PosX, 8 - X + PosY - (8 * Nombre) + Y), Couleur„           ELSEIF Opt = 3 THEN„              PSET (X + PosX, PosY + (8 * Nombre) + Y), Couleur„           ELSEIF Opt = 4 THEN„              PSET (8 - Y + PosX, PosY + (8 * Nombre) + X), Couleur„           ELSEIF Opt = 5 THEN„              PSET (8 - Y + PosX, PosY + (8 * Nombre) + X - Y), Couleur„           ELSEIF Opt = 6 THEN„              PSET (Y + PosX + Y, 8 - X + PosY - (8 * Nombre)), Couleur„              PSET (1 + Y + PosX + Y, 8 - X + PosY - (8 * Nombre)), Couleur„           ELSEIF Opt = 7 THEN„              PSET (Y + PosX + Y, 8 - X + PosY - (8 * Nombre) + Y), Couleur„              PSET (1 + Y + PosX + Y, 8 - X + PosY - (8 * Nombre) + Y), Couleur„          ELSEIF Opt = 8 THEN„              PSET (X + PosX + X, PosY + (8 * Nombre) + Y), Couleur„              PSET (1 + X + PosX + X, PosY + (8 * Nombre) + Y), Couleur„           ELSEIF Opt = 9 THEN„              PSET (X + PosX + (Nombre * 8), PosY + Y), Couleur„           ELSEIF Opt = 10 THEN„              PSET (X + PosX + (Nombre * 8) - Y, PosY + Y), Couleur„           ELSEIF Opt = 11 THEN„              PSET (X + PosX + (Nombre * 8), PosY + Y + Y), Couleur„              PSET (X + PosX + (Nombre * 8), 1 + PosY + Y + Y), Couleur„           ELSEIF Opt = 12 THEN„              PSET (X + PosX + (Nombre * 8) - Y, PosY + Y + Y), Couleur„              PSET (X + PosX + (Nombre * 8) - Y, 1 + PosY + Y + Y), Couleur„           END IF„        END IF„      NEXT Y„    NEXT X„NEXT Nombre„END SUB„„Unknown Author(s)              ENGLISH SCRIPT FONTS           ENGLISH,SCRIPT,FONTS           Unknown Date (00:00:00)QB, QBasic, PDS        159  7844     SCRIPT.BAS  '===========================„'   English Script Fonts„'===========================„„DIM a$(122)„     a$(32) = "BR8"„     a$(33) = "BR2G2RED8BD2D2HR2HBU2U3LU3R2D3U5FBU2BR2"„     a$(34) = "BRBUGDRND2RULBR3DRND2RULUBR3"„     a$(35) = "BR7G2D6LDU6L2GR3D3L3GR3ND2R4UNL2D3EU5NL3UL2NUR3UD"„     a$(35) = a$(35) + "5R2EL3U3R3EL3U2EBR5"„     a$(36) = "BR5DND15G4D4RNU4E3R3D6LNU6DLDL3HL2NDE2GR2DR2U10RF"„     a$(36) = a$(36) + "URUNL3EBUBR3"„     a$(37) = "BR4LG3DED2ED2EDE3LEL2EL2EBR6G2RDLD2HD3HD3HD3HD2UB"„     a$(37) = a$(37) + "R6REL3EL2ELE3DED2ED3EUBU7BR2"„     a$(38) = "BR6RF2NG3L2UL2G2RGDEDRND3G2NR3G3RGDERGDERGD2EURE3"„     a$(38) = a$(38) + "H2R2D2F5REUGLNH4UH4E2R2D2RENL5BU8BR3"„     a$(39) = "BRD4UHR2UL2BUBR5"„     a$(40) = "BR6G4REG3REG3R2UG2ND5RD7RU4D5RU3FDBU16BR3"„     a$(41) = "BD17E4LGE3LGE3LGUE2DHENU3LNU5HNU5UHU3GDBU2BR7"„     a$(42) = "BR3D3ND3NL3NR3NG2NH2NF2E2BUBR3"„     a$(43) = "BR5BD4D4ND4NL4LND5NU3DL4R8UL3R4BU8BR3"„     a$(44) = "BRBD13D3GE2UL2RBU14BR5"„     a$(45) = "BD9NR6ER6BU8BR3"„     a$(46) = "BD15R2GU2BU14BR5"„     a$(47) = "BD16E2LELE2DHE2DHE2DHE2DHE2DHE2BR3"„     a$(48) = "BR4G3D8UHU4E4NR2DNR3FNR3FR2GR2D4LU4D6G3UNE3L2H2ED"„     a$(48) = a$(48) + "RDRBU12BR8"„     a$(49) = "BD2E2ND13GR2UD13H2R4GE2BU11BR3"„     a$(50) = "BD4E4L2D3HUR2ER2DRND5FD3NG3LNG7LG5D3GUENR6FNR4FR2"„     a$(50) = a$(50) + "E2HREBU10BR3"„     a$(51) = "BR3G3NF2RE2RNG3DRF2DHD2HD4H2ED2R2D4ENU2G4H3LE2D2E"„     a$(51) = a$(51) + "D2ED2EBU13BR6"„     a$(52) = "BR6D14FU14LG6DR8FL8R6D3FDEBU13BR3"„     a$(53) = "BR9G3L4U2R5GL4D6E3RG2RERGR2FND3L3FRD3G3LHNR3HNR5H"„     a$(53) = a$(53) + "LR4H2GRBU10BR10"„     a$(54) = "BR5F2RGH2LF2DH2LG2D9HNU6UE5D2EUD3EUND5FD3G5U3LU3B"„     a$(54) = a$(54) + "U11BR9"„     a$(55) = "BD3E2R7GNL7G2RG2RG2ERG3ERG2ERG2D2FU3ED4E2LBU13BR6"„     a$(56) = "BDBR6L3G3R2DL2FRED3HR3HD2R3HD3HR3ND3GD3G2NH4L2UR2"„     a$(56) = a$(56) + "NH4L3ULULUE8L2DEUL2UBR6"„     a$(57) = "BUBR4G4D3FNU4EUD3RU2FE4ND5GD6G2NL5G2HRU2L2EBU7BR4"„     a$(57) = a$(57) + "R2UH2LF2LNH2LHU2BR7"„     a$(58) = "BD7R2GU2BD6D2HR2BU13BR4"„     a$(59) = "BD7R2HD2BD4D3GE2UL2BU13BR6"„     a$(61) = "BD6R6EL6BD3R6GNL6BU9BR5"„     a$(63) = "BR3G3ER4HLD2R3DL2FRG4DBD2D2HR2BU13BR6"„     a$(65) = "BD6U3NE2RE3NR3DR4G3L2DEUR3EG2DGDG2NH3NR7DNR7G2NR3"„     a$(65) = a$(65) + "DNR4DFBR3HR2E3D3FNE2U14GND9E2BR3"„     a$(66) = "BD3UEDRUR3EG3D4L2GDER2D5LG2NDE2REU9FED8EU8EDER3GR"„     a$(66) = a$(66) + "2D2HD2G2HUND9D2R3ND5FD4LG2L5GE3R3DL3BU13BR8"„     a$(67) = "BDBR4G3RG2ND4RD6FNU4RNU2ED2NR4UR6NE2NUL3U12G3D6EU"„     a$(67) = a$(67) + "6ER5GLU2LUBR6"„     a$(68) = "BDBR2NR7FR8GR2GRD2NL2D3NL2D3GNL6GL6GE3U10G3D7G2E3"„     a$(68) = a$(68) + "U2L3GE2R2U4E2R2D5RGD2RGDBU11BR7"„     a$(69) = "BR4G3ND8RG2D4RED4RNU2FNU2NR4ER5NE2NUL3U12G3D6EU6E"„     a$(69) = a$(69) + "NR7ER2D2R3G4R4UNL3BU5BR3"„     a$(70) = "BD6E2DR3UL2EU2D14L2GR2ERURUHU11R7NUL2UL3ED13GU8R3"„     a$(70) = a$(70) + "EL4U4BUBR8"„     a$(71) = "BD6D4FDU8E3D9G2U2D3NR7ERD2R4HU12L2ND8R5HD2R2GR2G4"„     a$(71) = a$(71) + "R4HLD2R2ND3LD3G2BU13BR6"„     a$(72) = "BD3UNR5ER5EG4D9GRENU9FRNU11EU11E2NRG2D4RE3D2END9R"„     a$(72) = a$(72) + "D7G2LEBU13BR5"„     a$(73) = "BD3URUR2D12L2GDR2UEU11EBR3G2D12L2DRE2U12EBR3"„     a$(74) = "BD5BRRUL2U2E2R3DL4R6DL3R5LG3D9GL3G2ER3DRUR3U2RU10"„     a$(74) = a$(74) + "ED9BL3DU9E2RERBUBR3"„     a$(75) = "BD3E2R3NEGL2FD8G2LGE5DU8BR2NE2D8G3R4HLD2FURE3D2FU"„     a$(75) = a$(75) + "2FRDH4LF2EH2E3LEL3GE2RBU3BR6"„     a$(76) = "BD2E2R4EG2NL4D11L2G2ERENU9RNE3R2F2RNE3HRNE2UE2LHB"„     a$(76) = a$(76) + "L3NU7FU7EBU3BR7"„     a$(77) = "BR6LG4D11LUREU5L2UR2U4ERD11NG2U5R6D5EG3H2R3GNU12H"„     a$(77) = a$(77) + "U6LNR5RU5LHR2DR6H2GRGND5R2DR2D12NEHU11E2BUBR3"„     a$(78) = "BD3E2D2R3H2D14L3NDER2EU10RED11NG2U4E3R4GDGDGDGDR4"„     a$(78) = a$(78) + "EG2L2U2RHEUEUEU3L3FRU2L3G3E4RL5E2RGR2BUBR7"„     a$(79) = "BR9L4G5ND6RD8R8LGL4U2LUE2NU8LU7ER6FL3HGD10UE3R3DG"„     a$(79) = a$(79) + "3REU5FUL3NG2RE2DHULBU3BR6"„     a$(80) = "BUBD3E3D2LR2HD2LR2ND14GND13DG3R2GRDFGLNG2DR2D4R3U"„     a$(80) = a$(80) + "3NU13R4GU2L3R5EL2E2DNU7HU2L2G3FRLHE3REUL3NGR"„     a$(80) = a$(80) + "2EU2GU2GL2E2NDBR8"„     a$(81) = "BR8L3G5ND6RD8R10GR2EGHL3GL4UHUF2R2NU13R2E4G2DEU9L"„     a$(81) = a$(81) + "3HR3D2LFNG3DERD4L3G3UBL3NU8EU8EBR11"„     a$(82) = "BD14E5U8EG2L2GE2RD10G2E3FG2R5G2HRU2LUENU8ENE4F4DN"„     a$(82) = a$(82) + "E3H2R3H3LNF3UE2U4L4E2D3FR2UL2U2BUBR8"„     a$(83) = "BR11G6H3UE2R3D2REL6GF3NR6L2HG2DED2ED2NR7ENR5RE2L2"„     a$(83) = a$(83) + "R8GR2ND3GD3G3UGU4RNDG5L3HU2R7DH2RL5R2UBU10BR13"„     a$(84) = "BD3E2DE2NR5DR9EG2L5D6G3NU3LU7NE3RG2D3F2E2NU5G2NR2"„     a$(84) = a$(84) + "DR8NE2NULGNL4U12BUBR7"„     a$(85) = "BD3E2R6EG2L6R4G4ND4RNED6FU3FD2FU2FR3NE4GNL2U13G2D"„     a$(85) = a$(85) + "6GU5EBR4E3D13E2L3DU11FRBU3BR4"„     a$(86) = "BD3UE2RG2RD10NLENU11D2F2NE6H2R3GUHRUNE3U3NE3U6H2B"„     a$(86) = a$(86) + "R7NG3D9ENL3U3NL3U3NL2UHBR4"„     a$(87) = "BD3E3D14H2RU9LE2RFD12GU3FRE2U10GE2D14HUF2DU3RD2NE"„     a$(87) = a$(87) + "4U13BR2UED11EU9HBR4"„     a$(88) = "BD3E3D4FU4LGR2D6L3ER3U4D6GDG2ND2L3NDERFRBR4R4EG3R"„     a$(88) = a$(88) + "EL2U2LND2LU5R3GL3D3R2UL2U5EUE2LED3FU3FDE"„     a$(88) = a$(88) + "BU2BR4"„     a$(89) = "R3GRD10NG3LG2D2ED2NR3ER4HR5DGBU3L2BU2RL4U10FRUD9U"„     a$(89) = a$(89) + "E3R3D2G2LEURU4L3NGR4DU3GU2GU2GUL2BR8"„     a$(90) = "BD3UE2D2LR8U2GNL7D2NG5LG3L3R8L2GLDR3L8R4G2RERG3UG"„     a$(90) = a$(90) + "D2GUR8GU2R2L7RER5EBU11BR3"„     a$(97) = "BD6NE3F2G2D2F2U3HD2RFUR3D2EL2NU9EU8NEL3F2DGNLEU3H"„     a$(97) = a$(97) + "BU3BR6"„     a$(98) = "RD12NLFNU13FU2FURENU7RU6L2U2G3U6EBR7"„     a$(99) = "BD6NE3RD5GR5EG2LGU3LRU6E2D2ED2EBU5BR3"„     a$(100) = "BFGDERGR2GR2G4ND4RD5FU3FD3E3NU6LNGU5NE2ULURBU5BR5"„     a$(101) = "BD7RNE3D4GRFNU6F2NE3UEL2ELU2E4L3FU2LBU5BR6"„     a$(102) = "BR3G2D12LR3GU9L2R4L2U4EDED2EBU2BR3"„     a$(103) = "BD17R5EL5E6D5L2EU2L2GLEL2NU5EU4E3D2ED5EU4EBU4BR3"„     a$(104) = "BDFD13E2NL3HU10NE2D6E4GDED9G3ERE2U9BU5BR3"„     a$(105) = "BD6ED9FE2LGU9RHBU2URBUBR4"„     a$(106) = "BD5ED2ED10GE2U8H2BU2URBUBR4"„     a$(107) = "BDFD12HR4G2U13NE2D6E3R2FL3FRG4ER2GR2D4EUL2U3BU10"„     a$(107) = a$(107) + "BR5"„     a$(108) = "BDFD11NL2DFELU13EBR3"„     a$(109) = "BD6UED10HF2ELU9FNRE2D10FU10FNRE2D10RNE2U9FBU6BR3"„     a$(110) = "BD5NE2RED9FE2LGU9FNE2RED2RU2D9FE2LGU8EBU4BR4"„     a$(111) = "BD7NE4ND4RD5F2UHUF2E2NU6LU4H2EDFU2BU4BR4"„     a$(112) = "BD5E2D13LR2NFU5NL2U7FE2D2ED9GH3R5DL3FE2U6BU5BR3"„     a$(113) = "BD6NE3ND6RNE2D7FU2FE2D5NGR2HU9FG2DU5L2EBU4BR6"„     a$(114) = "BD5NE2RED8HF3E2LGU2GU8FE2D2ED3EUBU5BR3"„     a$(115) = "BD13NE8R6GLU2NL3BR3ENU2LU3LD2HL3EL2NU2EU2E2DR4GN"„     a$(115) = a$(115) + "L2E2BU3BR3"„     a$(116) = "BD4NE3RD9HR2D2EDNE2HU10FRBU4BR4"„     a$(117) = "BD5NE2RED8FNU9FU3FDEF2E2L3FU10G2R3G2D5U8BU4BR6"„     a$(118) = "BR3G3RDEUD10NLF2NE4U2RL2ELU7BR4NHD7EU5BU5BR3"„     a$(119) = "BR2G2D2RU3D12HF2EUGU9FE2ND9FD8F2E2RGNHEU9NG3FND8"„     a$(119) = a$(119) + "BU4BR3"„     a$(120) = "BD6E3DGRD2RU2D5G4U3FRE2RD2RD2E3GLHUHUE4D2HLE2BU3BR3"„     a$(121) = "BD5NE2RED10GDFR3EUGBH3RNU10EDE4NU6LU5G2BU6BR6"„     a$(122) = "BD7UE3D2ED2EDG4R4HLD2R3DL2D2EL2DL2GDFR2EBU16BR5"„     SCREEN 9„     CLS„     w$ = "Quick Basic 4.5 now offered in English Script!"„     DRAW "c 14;s4 bm80,70;"„     GOSUB loop1„     DRAW "c 15;s4 bm1,100;"„     w$ = "!#$%&'()*+,-./0123456789:;<=>?&"„     GOSUB loop1„     DRAW "c 11;s4 bm1,130;"„     w$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"„     GOSUB loop1„     DRAW "C 14;S4 BM1,170;"„     w$ = "[\]^_'abcdefghijklmnopqrstuvwxyz"„     GOSUB loop1„     DRAW "c 11;s4 bm1,200;"„     w$ = "Wasn't I a nice guy to crop all those lines for you?"„     GOSUB loop1„     DRAW "c11;s4 bm1,220;"„     w$ = "You know those lines that go A$=A$+"„     GOSUB loop1„„END„„loop1:„FOR x = 1 TO LEN(w$)„y = ASC(MID$(w$, x, 1))„DRAW a$(y)„NEXT„RETURN„„Matt Hart                      PSET ON ANY SCREEN TYPE        PSET,ON,ANY,SCREEN,TYPE        Unknown Date (00:00:00)QB, PDS                36   1199     BPSET.BAS   'Here's a PSET type function that'll work in ANY screen mode:„„' BPSET.BAS  Matt Hart„'„' Do a PSET in any screen mode using the BIOS„„    '$INCLUDE: '\BC71\QBX.BI'       ' Use your path to QB.BI or QBX.BI„    DEFINT A-Z                      ' For IDE, load with C:\>qb /l„    DIM SHARED InRegs AS RegTypeX„    DIM SHARED OutRegs AS RegTypeX„„' ------------------ Sample Code„    InRegs.AX = &H10           ' EGA 640x350x16„    CALL InterruptX(&H10, InRegs, OutRegs)„    ' We are now in a screen mode unrecognized by QB„    ' No graphics command will work - QB doesn't know we are in graphics.„    ' This'll work with any screen mode - Super VGA, etc...„    C = 1 : Y! = 0„    Slope! = 350/640„    FOR X = 0 TO 639„        CallY = CINT(Y!)            ' Y must be an integer in the CALL„        CALL BiosPSET(X,CallY,C)„        Y! = Y! + Slope!„        C = C + 1 : IF C > 15 THEN C = 1„    NEXT„    WHILE INKEY$="":WEND„    SCREEN 2 : SCREEN 0„' ------------------------------„„SUB BiosPSET(X,Y,C)„    InRegs.AX = &H0C00 + C„    InRegs.BX = 0           ' BH is page - set to 0„    InRegs.CX = X„    InRegs.DX = Y„    CALL InterruptX(&H10, InRegs, OutRegs)„END SUB„Rich Geldreich                 ASM FADER                      ASM,FADER                      11-16-92 (00:00:00)    QB, PDS                150  4934     ASMFADER.BAS;Some noiseless VGA DAC fading routines for QB4.5/PDS„;By Rich Geldreich 1992„;Assembled with TASM v2.0„IDEAL„MODEL SMALL„DATASEG„Palette db 768 dup (?)„CODESEG„PUBLIC GetPalette, SetPalette„EVEN„PROC    SetPalette              ;Sets the pallette retrieved by „GetPalette„                                ;to a specified brightness„;DECLARE SUB SetPalette (BYVAL Brigtness, BYVAL Start, BYVAL Num)„Brightness EQU [ss:bp+10]„Start      EQU [ss:bp+08]„Num        EQU [ss:bp+06]„Parameters = 3„ „        Push    bp              ;set us up a stack frame„        Mov     bp, sp„        Push    ds si di        ;lets not get QB mad now„ „        Mov     ax, @data       ;get start of palette buffer„        Mov     ds, ax„        Mov     si, offset Palette„ „        Mov     ax, Start       ;get start color„        Mov     dx, 03C7h       ;get ready to start changing colors„        Out     dx, al„        Inc     dx„        Out     dx, al„        Inc     dx              ;dx=03C9h„ „        Mov     di, 03DAh       ;di=VGA status register„ „        Mov     bl, Brightness  ;limit brigtness to an 8 bit value„„        Mov     cx, Num         ;CX=# of registers to change„        Jcxz    @@Done          ;if no registers to change then exit„ „        Add     ax, cx          ;calculate the last register to change„        Cmp     ax, 256         ;if too much then exit„        Ja      @@Done„ „        EVEN                    ;color alteration loop„@@10:   REPT    2               ;change Red & Green colors„        Lodsb„        Mul     bl              ;calculate (Color*brightness)\256„        Mov     al, ah„        Out     dx, al          ;do it„        ENDM„ „        Lodsb                   ;precalculate the last register„        Mul     bl„        Mov     bh, ah„ „        Xchg    dx, di          ;dx=status port„        EVEN„@@20:   In      al, dx          ;wait for horizontal retrace„        Test    al, 1„        Jz      @@20„        Xchg    dx, di„        Mov     al, bh„        Out     dx, al          ;let the change take affect where it's„„safe„        Loop    @@10            ;'till done„@@Done:„        Pop     di si ds bp     ;pop us some regs„        Retf    Parameters*2    ;bye bye„ENDP    SetPalette„PROC    GetPalette              ;Must call this routine before „SetPalette!„;DECLARE SUB GetPalette ()„        Push    es„        Mov     ax, @data„        Mov     es, ax„        Mov     dx, offset Palette ;es:dx addresses palette„        Mov     cx, 256„        Xor     bx, bx„        Mov     ax, 01017h„        Int     010h„        Pop     es„        Retf    0„ENDP    GetPalette„END„„'The OBJ file(for those poor guys without TASM) and a small demo„'follows this message.„„„'To execute this script, save it to a file and type DEBUG < filename„'where "filename" is the name of this script file.„E165"FADEIT.LZH" 0„E200"XEP9gVKBhkH...UI/...9urPN.G.8MIE2JIGItmH0do2jr2..2.4W7qk2lu7j"„E23D"jTiZD/gp2W3NkSJ8W2fEnnnB3MdbOdMZEWibIAGfMlKPQBQ1FEQF.qaJ66gML"„E27A"OkIVM83ZdW1DVW2kiZOgUi0KDE4EdPhl75ebKOb8nUI9GtkA8k0gpAZqQD7Az"„E2B7"oLT7fQCynCmNunP0vTUsxC6uZVRThglk8jvihWLcgYKWm1IJcHxBLUfhI6VAG"„E2F4"AX5QFwJUsaAp3MVHzN96U6d/pcEnkgEAluEL.P1/QURQWqWkUR1uhekJ.3/nI"„E331"63W2GWI7l/kRsz7LIjBmlRxAwEi7ovlyHU.mQx9XTCR/ivsI9EqCc0qhQ6vzg"„E36E"iwhYZ9KhgBSbETs0wa5BzSPPpiTUDzFLfGbb08w33hhOMDxJGGtB8rcJXeTJ4"„E3AB"Ie6UMtHjru0DRTzvc80TKjVFZCPbEgKANGYF/pY3w8..."„E100 B8 0 3C BA 65 1 33 C9 CD "!rC" BE 0 2 50 BD 62 1 55 BF 88 90„E117 "W3" DB B1 FA 8A F0 80 C1 6 32 E4 AC "<9v" 8 "<Zv" 2 2C 6 2C„E12F 7 2C 2E E3 E8 D3 E0 A C6 AA 2 D8 92 "IIMu" E0 80 FB 33 75 9 5A„E147 59 5B B4 40 CD 21 73 7 B4 9 BA 58 1 CD 21 CD 20 7 "Error!$"„G„Q„ „Finally, here is a test program for the above assembly subroutine:„ „'A small demonstration of how to use the noiseless palette routine„'by Rich Geldreich„'to link the OBJ file into a QLB & LIB use:„'LINK /Q fadeit,,,bqlb45.lib (QB4.5)„'LINK /Q fadeit,,,qbxqlb,;   (PDS)„'LIB fadeit+fadeit,,,;„'Load QB with QB/lfadeit „DEFINT A-Z„DECLARE SUB GetPalette ()„DECLARE SUB SetPalette (BYVAL B, BYVAL S, BYVAL NC)„                       'brightness   |        |„SCREEN 13                        'start color |„'draw some garbage                        'number of colors„RANDOMIZE TIMER 'wow the circles are different every time„FOR A = 1 TO 100„    x = RND * 320„    y = RND * 200„    C = RND * 256„    CIRCLE (x, y), RND * 50, C„    PAINT (x, y), RND * 256, C„NEXT„GetPalette„DO„    FOR A = 255 TO 0 STEP -5„        WAIT &H3DA, 8„        SetPalette A, 0, 256„    NEXT„    FOR A = 1 TO 255 STEP 5„        WAIT &H3DA, 8„        SetPalette A, 0, 256„    NEXT„LOOP„ „'    If anybody spots noise while the program is fading up & down, tell„'me and I'll go back to the drawing board and find a new algorithm! I'm„'pretty sure there won't be, however.„ „'    Rich„Rich Geldreich                 ASM FADER FIX                  ASM,FADER,FIX                  11-21-92 (00:00:00)    TASM, QB, PDS          150  5539     FADEFIX.BAS ;Noiseless VGA DAC fading routines for QB4.5/PDS(works on 286's and up)„;By Rich Geldreich 1992„;Assembled with TASM v2.0„.286„IDEAL„MODEL SMALL„DATASEG„Palette    db 768 dup (?)„NewPalette db 768 dup (?)„CODESEG„PUBLIC GetPalette, SetPalette„EVEN„PROC    SetPalette              ;Sets the pallette retrieved by „                                ;GetPalette to a specified brightness„;DECLARE SUB SetPalette (BYVAL Brigtness, BYVAL Start, BYVAL Num)„Brightness EQU [ss:bp+10] ;0-128„Start      EQU [ss:bp+08] ;0-255„Num        EQU [ss:bp+06] ;1-256„Parameters = 3„        Push    bp              ;set us up a stack frame„        Mov     bp, sp„        Push    es ds si di     ;lets not get QB mad now„        Mov     ax, @data       ;get access to palette buffers„        Mov     ds, ax„        Mov     es, ax„        Xor     ax, ax„        Mov     al, Start       ;get start color„        Mov     dx, 03C7h       ;tell the VGA some DAC values will„        Out     dx, al          ;be coming„        Inc     dx„        Out     dx, al„        Inc     dx              ;dh=3„        Mov     si, ax          ;add start*3 to the palette offset„        Shl     si, 1„        Add     si, ax„        Add     si, offset Palette„        Mov     bl, Brightness  „        Cmp     bl, 128         ;limit brightness if too high„        Jna     @@Ok1„        Mov     bl, 128„@@Ok1:        „        Mov     cx, Num         ;CX=# of registers to change„        Jcxz    @@Done          ;if no registers to change then exit„        Add     ax, cx          ;calculate the last register to change„        Sub     ax, 256         ;if too many then limit„        Jna     @@OK2„        Sub     cx, ax„@@OK2:        „        Mov     di, offset NewPalette„        Mov     bp, cx          ;save cx for later„EVEN                            ;color precalculation loop„@@10:   REPT    3               ;repeat 3 times(for Red, Green, & Blue)„        Lodsb                   ;„        Mul     bl              ;new=old*brightness„        Shl     ax, 1           ;new=(new*2)\256 or new=new\128„        Mov     al, ah„        Stosb„        ENDM„        Loop    @@10„        Mov     cx, bp          ;multiply number of colors by 3„        Shl     cx, 1„        Add     cx, bp„        Mov     si, offset NewPalette„        Mov     dl, 0DAh        ;wait for vertical retrace„@@15:   In      al, dx          ;wait for end of vertical retrace„        Test    al, 8           ;(for very fast machines)„        Jnz     @@15„@@20:   In      al, dx          ;now wait for start of vertical„        Test    al, 8           ;retrace„        Jz      @@20„        Mov     dl, 0C9h        ;dx=03C9h„        Rep     Outsb           ;output the new colors„@@Done:„        Pop     di si ds es bp  „        Retf    Parameters*2    ;bye bye„ENDP    SetPalette„PROC    GetPalette              ;Must call this routine before „;DECLARE SUB GetPalette ()      ;SetPalette!„        Push    es„        Mov     ax, @data„        Mov     es, ax„        Mov     dx, offset Palette ;es:dx addresses palette„        Mov     cx, 256„        Xor     bx, bx„        Mov     ax, 01017h„        Int     010h„        Pop     es„        Retf    0„ENDP    GetPalette„END„„„To execute this script, save it to a file and type DEBUG < filename„where "filename" is the name of this script file.„E165"FADEIT.LZH" 0„E200"XcK9gVKBhoK....W/...uWJRN.G.8MIE2JIGItmH0dY8Mo2..2EEW7qk2luCj"„E23D"jjztZC5Bsl1Kc.SmKO2t.OSnLBMZeYtcaMGaWGDeLkKQoJ//u//ctc6gI/M6i"„E27A"M3VRO/oIGBCMElJM6eG6Y2DQ.gsqHrjTkXVV8.G8NFOMMaMZTAnAmqX2MTKh2"„E2B7"Q06b61vQEM2hcy3GzWLIEAUFYXNqNa3OQhxKma.gCdivVWQwzK457fagSl0MN"„E2F4"kqOjZddVEBtGBAXTDv77qiPAtd81dEnjImHFoo2MuU/cQga6Ll0StISrvXy1J"„E331"XBBRgzAKI4S2YaRGyKoxa2BG1x.Pjj55cTBtv47HCIf0fKPgU./3obnn4gkX9"„E36E"kLwZfnbdYiywKIehfehzZWIhQwZ8B/cq03gOOSQeY8ozyJZRSh2wQA3v.MJd4"„E3AB"HUrjSG9TZzw5txbme4RNac7jUkXzSjzV6m4i5rykLbP13KkSwvuk/lgfHOS.6"„E3E8"Xwd5zgeOhYdxxahgIw.U7Nzb0ZVDZ16mQV0OjOVacvCZzitF.."„E100 B8 0 3C BA 65 1 33 C9 CD "!rC" BE 0 2 50 BD 93 1 55 BF 88 90„E117 "W3" DB B1 FA 8A F0 80 C1 6 32 E4 AC "<9v" 8 "<Zv" 2 2C 6 2C„E12F 7 2C 2E E3 E8 D3 E0 A C6 AA 2 D8 92 "IIMu" E0 80 FB 97 75 9 5A„E147 59 5B B4 40 CD 21 73 7 B4 9 BA 58 1 CD 21 CD 20 7 "Error!$"„G„Q„ „And finally, here is the test program:„ „'A small demonstration of how to use the noiseless palette routine„'by Rich Geldreich„'to link the OBJ file into a QLB & LIB use:„'LINK /Q fadeit,,,bqlb45.lib (QB4.5)„'LINK /Q fadeit,,,qbxqlb,;   (PDS)„'LIB fadeit+fadeit,,,;„'Load QB with QB/lfadeit„DEFINT A-Z„DECLARE SUB GetPalette ()„DECLARE SUB SetPalette (BYVAL Brightness, BYVAL StartC, BYVAL NumC)„'Brightness, ranges from 0-128 where 128 is max.„'StartC, ranges from 0-255„'NumC, ranges from 1-256„'Before calling SetPalete, GetPalette must be called so SetPalette„'has something to work with.„SCREEN 13„'draw some garbage    „RANDOMIZE TIMER 'wow the circles are different every time„FOR A = 1 TO 100„    x = RND * 320„    y = RND * 200„    C = RND * 256„    CIRCLE (x, y), RND * 50, C„    PAINT (x, y), RND * 256, C„NEXT„GetPalette  'Retrieve the screen's palette„DO„    FOR A = 128 TO 0 STEP -2 'Fade the palette down„        SetPalette A, 0, 256„    NEXT„    FOR A = 1 TO 128 STEP 2  'Fade it up„        SetPalette A, 0, 256„    NEXT„LOOP„ „'That should do it! Remind me to think twice before posting an early„'version of a routine... [hate when that happens] .......    Rich„Raymond Keith                  MASM V6.0 FADER                MASM,FADER                     Year of 1992 (00:00:00)MASM                   71   2421     MASMFADE.ASM;Some noiseless VGA DAC fading routines for QB4.5/PDS„;By Rich Geldreich 1992„;REM Assembled with TASM v2.0„;CONVERTED TO MASM 6.0 by Raymond Keith„ „;Declare statements you would place in QuickBasic/PDS„;DECLARE SUB GetPalette ()„;DECLARE SUB SetPalette (BYVAL Brigtness, BYVAL Start, BYVAL Num)„ „        .MODEL MEDIUM, BASIC„        .DATA„Palette db 768 dup (?)„        .CODE„        EVEN„SetPalette PROC  USES ax bx cx dx si di ds, Brightness:Word, Start:Word,Num:Word„        Mov    ax, @data              ;get start of palette buffer„        Mov    ds, ax„        Mov    si, offset Palette„ „        Mov    ax, Start              ;get start color„        Mov    dx, 03C7h              ;get ready to start changing colors„        OUT    dx, al„        Inc    dx„        OUT    dx, al„        Inc    dx                     ;dx=03C9h„        Mov    di, 03DAh              ;di=VGA status register„        Mov    bx, Brightness         ;limit brigtness to an 8 bit value„        Mov    cx, Num                ;CX=# of registers to change„        Jcxz   @@Done                 ;if no registers to change then exit„ „        Add    ax, cx                 ;calculate the last register to change„        Cmp    ax, 256                ;if too much then exit„        Ja     @@Done„ „        EVEN                          ;color alteration loop„@@10:   REPT 2                        ;change Red & Green colors„        Lodsb„        Mul    bl                     ;calculate (Color*brightness)\256„        Mov    al, ah„        Out    dx, al                 ;do it„        ENDM„ „        Lodsb                         ;precalculate the last register„        Mul    bl„        Mov    bh, ah„ „        Xchg   dx, di           ;dx=status port„        EVEN„@@20:   In     al, dx           ;wait for horizontal retrace„        Test   al, 1„        Jz     @@20„        Xchg   dx, di„        Mov    al, bh„        Out    dx, al           ;let the change take affect where it's safe„        Loop   @@10             ;'till done„@@Done:„        RET„SetPalette ENDP„ „GetPalette PROC USES ax bx cx dx es  ;Must call this routine before„        Mov    ax, @data„        Mov    es, ax„        Mov    dx, offset Palette    ;es:dx addresses palette„        Mov    cx, 256„        Xor    bx, bx„        Mov    ax, 01017h„        Int    010h„        RET„„GetPalette ENDP„END„Calvin French                  GENERIC FONT DESIGNER          GENERIC,FONT,DESIGNER          Year of 1993 (00:00)   QB, PDS                318  7478     GFONT.BAS   DEFINT A-Z„'„' GFONT - Gerneric font designer for QBABBS. Calvin French 1993.„' version 0.0 - pre-release„'„' Press "c" to see a palette of colors. It can be configured„' via bpp to show anywhere from 2 to 256 different colors (bpp is„' bits per pixel).„'„' SUB GFontDraw (bpp, w, h, wc, hc, xg, yg, xc, yc, GfxArr())„' bpp - bits per pixel„' w   - width in pixels„' h   - height in pixels„' wc  - width of one cell (for color selection, as well)„' hc  - hieght of one cell (for color selection, as well)„' xg  - grid x starting„' yg  - grid y starting„' xc  - color selection grid x starting„' yc  - color selection grid y starting„' GfxArr - Integer array (w,h) containing the color of each„'          pixel.„'„' It's very integrateable and you should have no problems changing„' stuff. Have fun and I HOPE that this helps (at least a little)„'„DECLARE SUB GFontDraw (bpp, w, h, wc, hc, xg, yg, xc, yc, GfxArr())„DECLARE SUB GFontDrawScreen ()„DECLARE FUNCTION GFontColor (bpp%, wc%, hc%, xc%, yc%)„DECLARE FUNCTION GFontMenu (MenuArr$())„„CONST true = -1, false = NOT true„„SCREEN 13„„DIM GfxArr%(1 TO 30, 1 TO 30)„CALL GFontDrawScreen„CALL GFontDraw(8, 30, 30, 5, 5, 30, 30, 32, 32, GfxArr%())„„FUNCTION GFontColor (bpp, wc, hc, xc, yc)„„SELECT CASE bpp„  CASE 1                ' 2 colors   [MCGA]„    h = 1„    w = 2„    MaxColor = 1„  CASE 2                ' 4 colors   [CGA]„    h = 1„    w = 4„    MaxColor = 3„  CASE 4                ' 16 colors  [EGA]„    h = 2„    w = 8„    MaxColor = 15„  CASE 8                ' 256 colors [VGA]„    h = 11„    w = 24„    MaxColor = 255„END SELECT„„'„' save the background„'„DIM BackArr((w * wc + 2) * (h * hc + 2) + 2)„GET (xc - 1, yc - 1)-(xc + (w * wc) + 1, yc + (h * hc) + 1), BackArr„„'„' draw the box„'„LINE (xc, yc)-(xc + (w * wc), yc + (h * hc)), 0, BF„LINE (xc - 1, yc - 1)-(xc + (w * wc) + 1, yc + (h * hc) + 1), 15, B„„'„' Draw the color palette„'„FOR y = 0 TO h - 1„  FOR x = 0 TO w - 1„    LINE (xc + (x * wc) + 1, yc + (y * hc) + 1)-(xc + (x * wc) + (wc - 1), yc + (y * hc) + (hc - 1)), NextColor, BF„    NextColor = NextColor + 1„    IF NextColor > MaxColor THEN NextColor = MaxColor„  NEXT x„NEXT y„„oldx = 1„oldy = 1„x = 1„y = 1„„'„' main color choosing loop„'„DO„  '„  ' update cursor position, et cetera„  '„  LINE (xc + ((oldx - 1) * wc), yc + ((oldy - 1) * hc))-(xc + ((oldx - 1) * wc) + wc, yc + ((oldy - 1) * hc) + hc), 0, B„  LINE (xc + ((x - 1) * wc), yc + ((y - 1) * hc))-(xc + ((x - 1) * wc) + wc, yc + ((y - 1) * hc) + hc), 15, B„  oldx = x„  oldy = y„„  '„  ' inkey loop„  '„  DO„    key$ = INKEY$„  LOOP UNTIL LEN(key$)„„  '„  ' take action„  '„  SELECT CASE key$„    CASE CHR$(&H0) + CHR$(&H48)   ' [up]„      y = y - 1„      IF y < 1 THEN y = 1„    CASE CHR$(&H0) + CHR$(&H50)   ' [down]„      y = y + 1„      IF y > h THEN y = h„    CASE CHR$(&H0) + CHR$(&H4B)   ' [left]„      x = x - 1„      IF x < 1 THEN x = 1„    CASE CHR$(&H0) + CHR$(&H4D)   ' [right]„      x = x + 1„      IF x > w THEN x = w„    CASE CHR$(&HD)                ' [enter]„      GFontColor = POINT(xc + ((x - 1) * wc + 1), yc + ((y - 1) * hc) + 1)„      PUT (xc - 1, yc - 1), BackArr, PSET„      EXIT FUNCTION„  END SELECT„LOOP„„„END FUNCTION„„SUB GFontDraw (bpp, w, h, wc, hc, xg, yg, xc, yc, GfxArr())„„'„' save the background„'„DIM BackArr((w * wc + 2) * (h * hc + 2) + 2)„GET (xg - 1, yg - 1)-(xg + (w * wc) + 1, yg + (h * hc) + 1), BackArr„„'„' draw the box„'„LINE (xg, yg)-(xg + (w * wc), yg + (h * hc)), 0, BF„LINE (xg - 1, yg - 1)-(xg + (w * wc) + 1, yg + (h * hc) + 1), 15, B„„'„' draw the image (if any)„'„FOR x = 0 TO w - 1„  FOR y = 0 TO h - 1„    LINE (xg + (x * wc) + 1, yg + (y * hc) + 1)-(xg + (x * wc) + (wc - 1), yg + (y * hc) + (hc - 1)), GfxArr(x + 1, y + 1), BF„  NEXT y„NEXT x„„x = 1„y = 1„c = 15„oldx = 1„oldy = 1„„'„' main drawing loop„'„DO„  '„  ' update cursor position, et cetera„  '„  LINE (xg + ((oldx - 1) * wc), yg + ((oldy - 1) * hc))-(xg + ((oldx - 1) * wc) + wc, yg + ((oldy - 1) * hc) + hc), 0, B„  LINE (xg + ((x - 1) * wc), yg + ((y - 1) * hc))-(xg + ((x - 1) * wc) + wc, yg + ((y - 1) * hc) + hc), 15, B„  oldx = x„  oldy = y„„  '„  ' inkey loop„  '„  DO„    key$ = INKEY$„  LOOP UNTIL LEN(key$)„„  '„  ' take action„  '„  SELECT CASE key$„    CASE CHR$(&H20)               ' [spacebar]„      LINE (xg + ((x - 1) * wc) + 1, yg + ((y - 1) * hc) + 1)-(xg + ((x - 1) * wc) + (wc - 1), yg + ((y - 1) * hc) + (hc - 1)), c, BF„      GfxArr(x, y) = c„    CASE CHR$(&H0) + CHR$(&H48)   ' [up]„      y = y - 1„      IF y < 1 THEN y = 1„    CASE CHR$(&H0) + CHR$(&H50)   ' [down]„      y = y + 1„      IF y > h THEN y = h„    CASE CHR$(&H0) + CHR$(&H4B)   ' [left]„      x = x - 1„      IF x < 1 THEN x = 1„    CASE CHR$(&H0) + CHR$(&H4D)   ' [right]„      x = x + 1„      IF x > w THEN x = w„    CASE "c", "C"                 ' [c] or [C]„      c = GFontColor(bpp, wc, hc, xc, yc)„    CASE CHR$(&H9)                ' [tab]„      REDIM MenuArr$(4)„      MenuArr$(0) = " GFont Grid Menu:"„      MenuArr$(1) = " Save image to font"„      MenuArr$(2) = " Load image from font"„      MenuArr$(3) = " Return to editor"„      MenuArr$(4) = " Quit GFont"„      SELECT CASE GFontMenu(MenuArr$())„        CASE 1: 'GFontPutChar    ' [Save image to font]„        CASE 2: 'GFontGetChar    ' [Load image from font]„        CASE 3:                 ' [Return to editor]„        CASE 4                  ' [Quit GFont]„          PUT (xg - 1, yg - 1), BackArr, PSET„          EXIT SUB„      END SELECT„  END SELECT„LOOP„„END SUB„„DEFSNG A-Z„SUB GFontDrawScreen„„LINE (1, 1)-(319, 199), 32, BF„„END SUB„„DEFINT A-Z„SUB GFontMakeFontFile (FileName$)„„DIM GFontBuff AS STRING * 80„„PRINT„PRINT "Creating font file: "; FileName$„PRINT„DO„  INPUT "Width?", w$„„LOOP UNTIL VAL(w$) <> 0„DO„  INPUT "Hieght?", h$„LOOP UNTIL VAL(h$) <> 0„„OPEN FileName$ FOR BINARY AS #1„„GFontBuff$ = " GFont font file for QBABBS. GFont [PD] by Calvin French August 1993. " + CHR$(26)„„PUT #1, , GFontBuff$„„wid = VAL(w$)„PUT #1, , wid„hie = VAL(h$)„PUT #1, , hie„„„„END SUB„„FUNCTION GFontMenu (MenuArr$())„„LastOpt = UBOUND(MenuArr$)„„FOR n = 0 TO LastOpt„  IF LEN(MenuArr$(n)) > LongestLen THEN LongestLen = LEN(MenuArr$(n))„NEXT n„„x1 = 32„y1 = 32„x2 = x1 + LongestLen * 8 + 32„y2 = y1 + (LastOpt + 1) * 8„„DIM BackArr((x2 - x1 + 2) * (y2 - y1 + 2) + 4)„GET (x1 - 1, y1 - 1)-(x2 + 1, y2 + 1), BackArr„LINE (x1 - 1, y1 - 1)-(x2 + 1, y2 + 1), 0, BF„LINE (x1 - 1, y1 - 1)-(x2 + 1, y2 + 1), 15, B„„LOCATE y1 \ 8 + 1, x1 \ 8 + 1„COLOR 13„PRINT MenuArr$(0);„„CurrOpt = 1„„DO„  '„  ' Update menu„  '„  FOR n = 1 TO LastOpt„    IF n = CurrOpt THEN„      COLOR 15„    ELSE„      COLOR 7„    END IF„    LOCATE y1 \ 8 + n + 1, x1 \ 8 + 1„    PRINT MenuArr$(n);„  NEXT n„„  DO„    key$ = INKEY$„  LOOP UNTIL LEN(key$)„„  SELECT CASE key$„    CASE CHR$(&H0) + CHR$(&H48)   ' [up]„      CurrOpt = CurrOpt - 1„      IF CurrOpt < 1 THEN CurrOpt = 1„    CASE CHR$(&H0) + CHR$(&H50)   ' [down]„      CurrOpt = CurrOpt + 1„      IF CurrOpt > LastOpt THEN CurrOpt = LastOpt„    CASE CHR$(&HD)                ' [enter]„      GFontMenu = CurrOpt„      PUT (x1 - 1, y1 - 1), BackArr, PSET„      EXIT FUNCTION„  END SELECT„„LOOP„„END FUNCTION„„Ian Remmler                    PLASMA GENERATOR               PLASMA,GENERATOR               Unknown Date (00:00)   QB, QBasic, PDS        154  4395     PLASMGEN.BAS'PLASMA GENERATOR By: Ian Remmler„'------ ---------„„DECLARE FUNCTION Rand% ()„DECLARE FUNCTION PntClr% (x%, y%)„DECLARE SUB Dot (x%, y%, c%)„DECLARE SUB Adjust (xa%, ya%, x%, y%, xb%, yb%)„DECLARE SUB SubDivide (x1%, y1%, x2%, y2%)„DECLARE SUB MakePal (col%(), x%, y%)„„DEFINT A-Z„DIM r(-8 TO 264), g(-8 TO 264), b(-8 TO 264)  'For the palette values.„COMMON SHARED F  'Graininess factor„„IF INSTR(COMMAND$, "/?") OR INSTR(COMMAND$, "-?") THEN GOTO PrntHelp„'REM above line if you are using QBasic.„RANDOMIZE TIMER„DEF SEG = &HA000„F = 10: ra = 1: rb = 255: d = 1: s = 1„SCREEN 13„„Start:„GOSUB PalSet  'Get a random palette to start with.„Dot 0, 0, RND * 255 + 1„Dot 319, 0, RND * 255 + 1„Dot 319, 199, RND * 255 + 1„Dot 0, 199, RND * 255 + 1„SubDivide 0, 0, 319, 199„BEEP„„Rotate:„  DO„    a$ = INKEY$„    IF LEN(a$) THEN GOSUB keys  'Check to see if an option key was pushed.„    FOR a = 1 TO 9„      'This loop is needed to keep the palette from screwing up when palette„      'rotation speed is > 1.„      r(255 + a) = r(a): g(255 + a) = g(a): b(255 + a) = b(a)„      r(1 - a) = r(255 - a): g(1 - a) = g(255 - a): b(1 - a) = b(255 - a)„    NEXT„    FOR t = ra TO rb STEP d  'This loop rotates the palette.„      SWAP r(t), r(t + d * s)„      SWAP g(t), g(t + d * s)„      SWAP b(t), b(t + d * s)„    NEXT„    GOSUB Set  'Output the new palette values to the VGA adapter.„  LOOP„„PalSet:„  'This routine uses a technique similar to the plasma generator„  'itself to create a smooth palette.„  FOR a = 1 TO 255„    r(a) = -1: g(a) = -1: b(a) = -1„  NEXT„  r(1) = INP(64) \ 4: g(1) = INP(64) \ 4: b(1) = INP(64) \ 4„  r(255) = r(1) + Rand: g(255) = g(1) + Rand: b(255) = b(1) + Rand„  MakePal r(), 1, 255„  MakePal g(), 1, 255„  MakePal b(), 1, 255„  GOSUB Set„RETURN„„Set:„  'Dump all the palette values to the VGA adapter.„  OUT &H3C8, 1„  WAIT &H3DA, 8„  FOR c = 1 TO 255„    OUT &H3C9, r(c)„    OUT &H3C9, g(c)„    OUT &H3C9, b(c)„  NEXT„RETURN„„keys:„  SELECT CASE UCASE$(a$)„    CASE " "  'Reverse direction of palette rotation.„      SWAP ra, rb: d = -d„    CASE CHR$(13)  'Make a new random palette.„      GOSUB PalSet„    CASE "F"  'Change the "graininess" (Amount of randomness).„      SCREEN 0: WIDTH 80, 25„      PRINT "Current = "; F„      PRINT : INPUT "Enter new graininess factor. - ", F„      SCREEN 13: GOTO Start„    CASE CHR$(49) TO CHR$(57)  'Change palette rotation speed.„      s = VAL(a$)„    CASE CHR$(27)  'Exit the program.„      END„  END SELECT„RETURN„„PrntHelp:„  PRINT "PLASMA GENERATOR - By: Ian Remmler"„  PRINT "------ ---------"„  PRINT "[ENTER] : Create a random palette."„  PRINT "[SPACE] : Reverse direction of palette rotation."„  PRINT "1 - 9   : Change palette rotation speed."„  PRINT "F       : Enter new graininess factor."„  PRINT "[ESC]   : Exit the program."„  PRINT "/? or -? on command line to display help."„  END„„SUB Adjust (xa, ya, x, y, xb, yb)„  IF PntClr(x, y) <> 0 THEN EXIT SUB„  q = ABS(xa - xb) + ABS(ya - yb)„  v = (PntClr(xa, ya) + PntClr(xb, yb)) \ 2 + (Rand * q * F) \ 10„  IF v < 1 THEN v = 1„  IF v > 255 THEN v = 255„  Dot x, y, v„END SUB„„SUB Dot (x, y, c)  'Fast replacement for PSET.„  POKE y * 320& + x, c„END SUB„„SUB MakePal (col(), x, y)„  z = (x + y) \ 2„  IF col(z) <> -1 THEN EXIT SUB„  q = ABS(x - y) \ 8„  c = (col(x) + col(y)) \ 2 + Rand * q„  IF c < 0 THEN c = 0„  IF c > 63 THEN c = 63„  col(z) = c„  MakePal col(), x, z„  MakePal col(), y, z„END SUB„„FUNCTION PntClr (x, y)  'Fast replacement for POINT.„  PntClr = PEEK(y * 320& + x)„END FUNCTION„„FUNCTION Rand  'This returns a value of -1, 0, or 1 and is much faster than RND.„  Rand = INP(64) MOD 3 - 1„END FUNCTION„„SUB SubDivide (x1, y1, x2, y2)„  IF (x2 - x1 < 2) AND (y2 - y1 < 2) THEN EXIT SUB„  x = (x1 + x2) \ 2„  y = (y1 + y2) \ 2„  Adjust x1, y1, x, y1, x2, y1„  Adjust x1, y2, x, y2, x2, y2„  Adjust x2, y1, x2, y, x2, y2„  Adjust x1, y1, x1, y, x1, y2„  IF PntClr(x, y) = 0 THEN„    v = (PntClr(x1, y1) + PntClr(x2, y1) + PntClr(x2, y2) + PntClr(x1, y2) + PntClr(x1, y) + PntClr(x, y1) + PntClr(x2, y) + PntClr(x, y2)) \ 8„    Dot x, y, v„    IF INKEY$ = CHR$(27) THEN END„  END IF„  SubDivide x1, y1, x, y„  SubDivide x, y, x2, y2„  SubDivide x, y1, x2, y„  SubDivide x1, y, x, y2„END SUB„„Rich Geldreich                 ASSEMBLY PLASMA GENERATOR      ASSEMBLY,PLASMA,GENERATOR      Unknown Date (00:00)   QB, PDS                461  13238    PLASMA.BAS  'PLASMA.BAS & PLASMA.ASM„'Input graininess on command line. Valid values are 0-40.„'Try running with a graininess of 1, and zooming in on areas with„'very little overall elevation (ie. areas that are mostly the same„'color). Some very interesting "non-cloudly" patterns will show„'themselves if you look at the right areas. If you do get some wierd„'looking patterns, make sure you try color cycling with a random„'palette.„'„'Keys recognized:„'"C"        = Toggles color cycling.„'"R"        = Sets the default palette.„'"1" to "9" = Introduces random colors into the palette while color„'             cycling.„'Array keys = Moves zoom box.„'Enter      = Zooms area inside zoom box.„'Escape     = Quits.„'„DEFINT A-Z„ „DECLARE SUB SubDivide (CX1%, CY1%, CX2%, CY2%, CC1%, CC2%, CC3%, CC4%)„DECLARE SUB SetPoint (BYVAL X, BYVAL Y, BYVAL C)„DECLARE FUNCTION GetPoint (BYVAL X, BYVAL Y)„DECLARE SUB SeedRand (BYVAL NewSeed&)„DECLARE FUNCTION GetRand% (BYVAL MaxRand%)„ „TYPE StackType„    X1 AS INTEGER„    Y1 AS INTEGER„    X2 AS INTEGER„    Y2 AS INTEGER„    C1 AS INTEGER„    C2 AS INTEGER„    C3 AS INTEGER„    C4 AS INTEGER„END TYPE„ „DIM SHARED AStack(511) AS StackType„DIM SHARED Clamp(-4096 TO 4096)„DIM SHARED F&„DIM SHARED P(0 TO 40, 0 TO 40)„DIM SHARED D(0 TO 40, 0 TO 40)„DIM r(255), g(255), B(255)„ „a$ = COMMAND$„IF LEN(a$) THEN„    F& = VAL(a$)„    IF F& < 0 THEN„        F& = 0„    ELSEIF F& > 40 THEN„        F& = 40„    END IF„ELSE„    F& = 8„END IF„ „FOR a = -4096 TO 4096„    IF a < 1 THEN„        Clamp(a) = 1„    ELSEIF a > 255 THEN„        Clamp(a) = 255„    ELSE„        Clamp(a) = a„    END IF„NEXT„ „SCREEN 13„ „'Set default palette.„GOSUB PalSet„ „'Seed the psuedo-random number generator with the current time.„DEF SEG = &H40„SeedRand PEEK(&H6C) + PEEK(&H6D) * 256& + PEEK(&H6E) * 65536„'Draw plasma.„C1 = GetRand(256) + 1„C2 = GetRand(256) + 1„C3 = GetRand(256) + 1„C4 = GetRand(256) + 1„SetPoint 0, 0, C1„SetPoint 319, 0, C2„SetPoint 319, 199, C3„SetPoint 0, 199, C4„ „'Plot the starting plasma.„CALL SubDivide(0, 0, 319, 199, C1, C2, C3, C4)„ „C = 1„ „DO„    Xs = (320 - 40) \ 2„    Ys = (200 - 40) \ 2„ „    DO„        FOR a = 0 TO 41„            SetPoint Xs + a, Ys, GetPoint(Xs + a, Ys) XOR &HAA„            SetPoint Xs + a, Ys + 41, GetPoint(Xs + a, Ys + 41) XOR &HAA„            SetPoint Xs, Ys + a, GetPoint(Xs, Ys + a) XOR &HAA„            SetPoint Xs + 41, Ys + a, GetPoint(Xs + 41, Ys + a) XOR &HAA„        NEXT„ „        DO„            IF CycleOn THEN„                IF RandC > 0 THEN„                    IF GetRand(10) <= RandFreq THEN„                        r(RandC) = GetRand(64)„                        g(RandC) = GetRand(64)„                        B(RandC) = GetRand(64)„                    ELSE„                        r(RandC) = 0„                        g(RandC) = 0„                        B(RandC) = 0„                    END IF„                    RandC = RandC + 1„                    IF RandC = 256 THEN„                        RandC = 0„                    END IF„                END IF„ „                WAIT &H3DA, 8„                OUT &H3C8, 1„                D = C„                FOR a = 1 TO 255„                    OUT &H3C9, r(D)„                    OUT &H3C9, g(D)„                    B = B(D)„                    WAIT &H3DA, 1„                    OUT &H3C9, B„                    WAIT &H3DA, 1, 1„                    D = D + 1„                    IF D = 256 THEN D = 1„                NEXT„                C = C + 1„                IF C = 256 THEN C = 1„                WAIT &H3DA, 8, 8„            END IF„ „            a$ = INKEY$„        LOOP UNTIL LEN(a$)„ „        FOR a = 0 TO 41„            SetPoint Xs + a, Ys, GetPoint(Xs + a, Ys) XOR &HAA„            SetPoint Xs + a, Ys + 41, GetPoint(Xs + a, Ys + 41) XOR &HAA„            SetPoint Xs, Ys + a, GetPoint(Xs, Ys + a) XOR &HAA„            SetPoint Xs + 41, Ys + a, GetPoint(Xs + 41, Ys + a) XOR &HAA„        NEXT„ „        SELECT CASE a$„        CASE CHR$(0) + CHR$(72) 'up„            Ys = Ys - 5„            IF Ys < 0 THEN Ys = 0„        CASE CHR$(0) + CHR$(80) 'down„            Ys = Ys + 5„            IF Ys > 200 - 42 THEN Ys = 200 - 42„        CASE CHR$(0) + CHR$(77) 'right„            Xs = Xs + 5„            IF Xs > 320 - 42 THEN Xs = 320 - 42„        CASE CHR$(0) + CHR$(75)'left„            Xs = Xs - 5„            IF Xs < 0 THEN Xs = 0„        CASE CHR$(13), "0"„            EXIT DO„        CASE "C", "c"„            CycleOn = NOT CycleOn„        CASE "R", "r"„            GOSUB PalSet„            C = 1„        CASE "1" TO "9"„            RandC = 1„            RandFreq = ASC(a$) - 49„        CASE CHR$(27)„            END„        END SELECT„    LOOP„ „    L = 256„    h = 0„    FOR Y = Ys TO Ys + 40„        FOR X = Xs TO Xs + 40„            P = GetPoint(X, Y) - 1„            IF P < L THEN L = P„            IF P > h THEN h = P„            P(X - Xs, Y - Ys) = P„        NEXT„    NEXT„ „    'Maximize the scale of the new plasma to take advantage of„    'all colors- this will usually cause the zoomed plasma's colors to„    'appear different from its original colors, but must be done because„    'there are only 256 colors available.„    IF (h - L) = 0 THEN 'avoid overflow error„        Scaler& = 256„    ELSE„        Scaler& = (255 * 256&) \ (h - L)„    END IF„ „    FOR Y = 0 TO 40„        FOR X = 0 TO 40„            P = 1 + ((P(X, Y) - L) * Scaler&) \ 256„            IF P > 255 THEN P = 255„            P(X, Y) = P„        NEXT„    NEXT„ „    CLS„ „    FOR Y = 0 TO 40„        Ys = Y * 5: IF Ys > 199 THEN Ys = 199„        FOR X = 0 TO 40„            Xs = X * 8: IF Xs > 319 THEN Xs = 319„            SetPoint Xs, Ys, P(X, Y)„        NEXT„    NEXT„ „    ERASE D„ „    'Fill in the black areas.„    FOR Y = 0 TO 39„        Ys = Y * 5„        Ye = Ys + 5„        IF Ye > 199 THEN Ye = 199„        FOR X = 0 TO 39„            Xs = X * 8„            Xe = Xs + 8„            IF Xe > 319 THEN Xe = 319„            CALL SubDivide(Xs, Ys, Xe, Ye, P(X, Y), P(X + 1, Y), P(X + 1, Y + 1), P(X, Y + 1))„        NEXT„    NEXT„LOOP UNTIL a$ = CHR$(27)„END„ „PalSet:„  'Alter this section here for another palette.„  FOR a = 0 TO 63„    s = 0: r = 63: g = a: B = 0: GOSUB Set„    s = 64: r = 63 - a: g = 63: B = 0: GOSUB Set„    s = 128: r = 0: g = 63 - a: B = a: GOSUB Set„    s = 192: r = a: g = 0: B = 63: GOSUB Set„  NEXT„RETURN„ „Set:„  IF a + s = 0 THEN RETURN  'to keep the background black„  r(a + s) = r„  g(a + s) = g„  B(a + s) = B„  OUT &H3C8, a + s„  OUT &H3C9, r„  OUT &H3C9, g„  OUT &H3C9, B„RETURN„ „'This subroutine subdivides the screen into small areas„'and fills them in with psuedo-random colors. Areas close the each„'other are very similar, but as the distance increases between two„'areas they grow very different.„SUB SubDivide (CX1, CY1, CX2, CY2, CC1, CC2, CC3, CC4)„ „    sp = 0„    AStack(sp).X1 = CX1: AStack(sp).Y1 = CY1„    AStack(sp).X2 = CX2: AStack(sp).Y2 = CY2„    AStack(sp).C1 = CC1: AStack(sp).C2 = CC2„    AStack(sp).C3 = CC3: AStack(sp).C4 = CC4„    sp = sp + 1„ „    DO WHILE sp„        sp = sp - 1„        X1 = AStack(sp).X1: Y1 = AStack(sp).Y1„        X2 = AStack(sp).X2: Y2 = AStack(sp).Y2„        C1 = AStack(sp).C1: C2 = AStack(sp).C2„        C3 = AStack(sp).C3: C4 = AStack(sp).C4„Jag:„        'Find center of area.„        X = (X1 + X2) \ 2„        Y = (Y1 + Y2) \ 2„ „        CA = GetPoint(X, Y1)„        IF CA = 0 THEN„            CA = Clamp((C1 + C2) \ 2 + ((GetRand(128) - 64) * (X2 - X1) * F&) \ 256)„            SetPoint X, Y1, CA„        END IF„ „        CB = GetPoint(X2, Y)„        IF CB = 0 THEN„            CB = Clamp((C2 + C3) \ 2 + ((GetRand(128) - 64) * (Y2 - Y1) * F&) \ 256)„            SetPoint X2, Y, CB„        END IF„ „        CC = GetPoint(X, Y2)„        IF CC = 0 THEN„            CC = Clamp((C4 + C3) \ 2 + ((GetRand(128) - 64) * (X2 - X1) * F&) \ 256)„            SetPoint X, Y2, CC„        END IF„ „        CD = GetPoint(X1, Y)„        IF CD = 0 THEN„            CD = Clamp((C1 + C4) \ 2 + ((GetRand(128) - 64) * (Y2 - Y1) * F&) \ 256)„            SetPoint X1, Y, CD„        END IF„ „        CM = GetPoint(X, Y)„        'Set center point to the average of all the pixels surrounding it.„        IF CM = 0 THEN„            CM = (C1 + C2 + C3 + C4 + CA + CB + CC + CD) \ 8„            SetPoint X, Y, CM„        END IF„ „        IF X2 - X1 > 2 THEN„            'Recursively subdivide the area into 4 smaller areas.„ „            'CALL SubDivide(X, Y, X2, Y2, CM, CB, C3, CC)„            AStack(sp).X1 = X: AStack(sp).Y1 = Y„            AStack(sp).X2 = X2: AStack(sp).Y2 = Y2„            AStack(sp).C1 = CM: AStack(sp).C2 = CB„            AStack(sp).C3 = C3: AStack(sp).C4 = CC„            sp = sp + 1„ „            'CALL SubDivide(X1, Y1, X, Y, C1, CA, CM, CD)„            AStack(sp).X1 = X1: AStack(sp).Y1 = Y1„            AStack(sp).X2 = X: AStack(sp).Y2 = Y„            AStack(sp).C1 = C1: AStack(sp).C2 = CA„            AStack(sp).C3 = CM: AStack(sp).C4 = CD„            sp = sp + 1„ „            'CALL SubDivide(X, Y1, X2, Y, CA, C2, CB, CM)„            AStack(sp).X1 = X: AStack(sp).Y1 = Y1„            AStack(sp).X2 = X2: AStack(sp).Y2 = Y„            AStack(sp).C1 = CA: AStack(sp).C2 = C2„            AStack(sp).C3 = CB: AStack(sp).C4 = CM„            sp = sp + 1„ „            'CALL SubDivide(X1, Y, X, Y2, CD, CM, CC, C4)„            Y1 = Y„            X2 = X„            C1 = CD„            C2 = CM„            C3 = CC„            GOTO Jag„ „        END IF„ „    LOOP„ „END SUB„„„'---------------8<-----[ Begin PLASMA.ASM ]----->8---------------„„.286: : :„IDEAL„MODEL MEDIUM„;----------------------------------------------------------------„DATASEG„LABEL           LookUp  WORD„                Y = 0„                REPT 200„                dw Y„                Y = Y + 320„                ENDM„RandSeed        dw      0,0„;----------------------------------------------------------------„CODESEG„ASSUME          DS:@CODE, DS:@DATA, SS:@DATA, ES:NOTHING„;----------------------------------------------------------------„;Sets a point in the 320x200x256 mode.„EVEN„PUBLIC SetPoint„PROC SetPoint„Xp              EQU     <[bx+8]>„Yp              EQU     <[bx+6]>„C               EQU     <[bx+4]>„P = 3„                Mov     ax, 0A000h„                Mov es, ax„                Mov bx, sp„                Mov ax, C„                Mov di, Xp„                Mov bx, Yp„                Shl bx, 1„                Add di, (bx + LookUp)„                Stosb„                Retf P * 2„ENDP SetPoint„;----------------------------------------------------------------„;Grabs a point's color in the 320x200x256 mode.„EVEN„PUBLIC GetPoint„PROC GetPoint„Xp              EQU     <[bx+6]>„Yp              EQU     <[bx+4]>„P = 2„                Mov     ax, 0A000h„                Mov es, ax„                Mov bx, sp„                Mov si, Xp„                Mov bx, Yp„                Shl bx, 1„                Add si, (bx + LookUp)„                Xor     ax, ax„                Lods    [byte es:si]„                Retf P * 2„ENDP GetPoint„;----------------------------------------------------------------„;Seeds the psuedo-random number generator.„PUBLIC SeedRand„PROC SeedRand„NewSeedH        EQU     <[bx+6]>„NewSeedL        EQU     <[bx+4]>„P = 2„                Mov bx, sp„                Mov ax, NewSeedL„                Mov (RandSeed), ax„                Mov ax, NewSeedH„                Mov (RandSeed + 2), ax„                Retf P * 2„ENDP SeedRand„;----------------------------------------------------------------„;Returns psuedo-random number between 0 and MaxVal-1.„EVEN„PUBLIC GetRand„PROC GetRand„MaxVal          EQU     <[word bx+4]>„P = 1„                Mov ax, (RandSeed)„                Mov bx, (RandSeed + 2)„                Mov cx, ax„                Mov     dx, 08405h„                Mul dx„                Shl cx, 3„                Add ch, cl„                Add dx, cx„                Add dx, bx„                Shl bx, 1„                Shl bx, 1„                Add dx, bx„                Add dh, bl„                Shl bx, 5„                Add dh, bl„                Add ax, 1„                Adc dx, 0„                Mov (RandSeed), ax„                Mov (RandSeed + 2), dx„                Mov bx, sp„                Mov cx, dx„                Mul MaxVal„                Mov ax, cx„                Mov cx, dx„                Mul MaxVal„                Add ax, cx„                Adc dx, 0„                Mov ax, dx„                Retf P * 2„ENDP GetRand„;----------------------------------------------------------------„END„„'---------------8<-----[ End PLASMA.ASM ]----->8---------------„ „'That's all! Although I haven't timed my plasma implementation against„'the one posted here a few days ago, it's visually faster on my 286/10.„„Steve Demo                     PALETTE STUFF                  PALETTE,STUFF                  10/10/93 (00:00)       QB, QBasic, PDS        58   2126     PALSTUFF.BASDEFINT A-Z„DECLARE SUB SetPalette ()„SCREEN 13„FOR x = 0 TO 255„ LINE (x + 20, 10)-(x + 20, 180), x„NEXT x„LOCATE 1, 12: PRINT "Press any Key": a$ = INPUT$(1)„LOCATE 1, 10: PRINT SPACE$(18)„FOR j = 1 TO 6„ PALETTE: SOUND 30000, 14„ SetPalette„ SOUND 30000, 14„NEXT j„SetPalette„DO UNTIL LEN(INKEY$)„ LOCATE 1, 10: PRINT "Now that's Simple"„ LOCATE 24, 10: PRINT SPACE$(18); : SOUND 30000, 4„ LOCATE 1, 10: PRINT SPACE$(18)„ LOCATE 24, 10: PRINT "Now that's Simple"; : SOUND 30000, 4„LOOP„SCREEN 0: WIDTH 80„„'This program was created by PAL2CODE (c) 1993 SRD SoftWare„SUB SetPalette„REDIM F(768)„F$ = "#####M#M##MMM##M#MM8#MMM88888b8b88bbb88b8bbb8bbb": GOSUB MKPLT„F$ = "+++...222555999===@@@DDDHHHKKKOOOSSSVVVZZZ^^^bbb3": GOSUB MKPLT„F$ = "##8##=##?&&B**E--H11K55N88Q<<T@@XDDZII]NN_SSbYY3+": GOSUB MKPLT„F$ = "#8-#=/#B2#G4#L6#Q9#V;#\>#\B*]F2^K:_OA`TIaXQb]Y33#": GOSUB MKPLT„F$ = "66#99#<<#??#BB#EE#HH#LL#OO#RR#UU#XX#[[#^^#bb##8%#": GOSUB MKPLT„F$ = ":(#<,#?/#A3#C7#F:#H>#KB#ME#OI#RM#TP#WT#YX#\\YbYRb": GOSUB MKPLT„F$ = "QJbJG^GDZDAWA>S>;O;8L85H52E2/A/,=,):)&6&$3#YbbQbb": GOSUB MKPLT„F$ = "JbbE__A\\=ZZ:VV7RR5NN2JJ0FF-BB*>>(::%66#33Y^bQ[bJ": GOSUB MKPLT„F$ = "XbBUb:Rb3Ob+Mb#Jb#F\#BV#>P#:J#6D#3?#/9#,3YYbQRbJJ": GOSUB MKPLT„F$ = "bEE_@@\<<Y88V55R33N11J..F,,B**>'':%%6##3/@$2B#5D#": GOSUB MKPLT„F$ = "8F#;H#>J#AL#DN#GP#JR#MT#PV#SX#VZ#Y\#]_#bYb`S`^N^\": GOSUB MKPLT„F$ = "H\ZCZX=XV8VT3UP0QL.MH+ID(EA&A<%<7$73#3-+&1-'5/):2": GOSUB MKPLT„F$ = "+;3+=4,?5-@6-B7.D8/E9/G:0I;1J<1L=2N>3O?3Q@4SA5UB6": GOSUB MKPLT„F$ = "VD8WF;XH>YJAZMD[OG\QJ]SM^VP_XS`ZVb]ZZ##X)#W0#U6#T": GOSUB MKPLT„F$ = ";#S@#RF#PJ#ON#CN#6M#*M##L(#K3#K?#KH#FL#>M#5M#-N6#": GOSUB MKPLT„F$ = "Q>#QD#QL#QQ#NQ#FQ#@Q#9Q#1R#+R##bbb": GOSUB MKPLT„  DEF SEG = &HA000„      FOR Colors = 1 TO 768     'convert this to load a PAL file„        OUT &H3C9, F(Colors)    'from disk eg. GET #1,,a$„      NEXT Colors               'F=ASC(A$) ect...„  ERASE F„  DEF SEG„EXIT SUB„„MKPLT:„    j = j + 1„    FOR jj = 1 TO LEN(F$)„       count = count + 1„       F(count) = (ASC(MID$(F$, jj, 1)) - 35)„    NEXT jj„RETURN„END SUB„„Rich Geldreich                 MAKE GIF FILE                  MAKE,GIF,FILE                  Year of 1992 (00:00)   QB, PDS                368  15032    MAKEGIF.BAS '„'-----------------------------------------------------------------------------„'    PDS 7.1 & QB4.5 GIF Compression Routine v1.01 By Rich Geldreich 1992„'-----------------------------------------------------------------------------„'QuickBASIC 4.5 & QBASIC users: Use search and replace and change all of the„'"SSEG" strings to "VARSEG" strings for this program to work properly.„'„'If anybody finds any problems with this routine, or has any questions,„'then write/call:„'Rich Geldreich„'410 Market St.„'Gloucester City, NJ 08030„'(609)-742-8752 or (609)-456-0721„'„'This routine is in the public domain... do what you want with it! Just„'give credit where credit is due! Thanks!„'„'NOTE: This version does not currently support EGA palettes.„'V1.01- fixed up VGA palette messups with some VGA's„„DEFINT A-Z„DECLARE SUB BufferWrite (A%)„DECLARE FUNCTION GetByte% ()„DECLARE SUB MakeGIF (A$, ScreenX%, ScreenY%, Xstart%, YStart%, Xend%, Yend%, NumColors%, AdaptorType%)„DECLARE SUB PutByte (A%)„DECLARE SUB PutCode (A%)„CONST True = -1, False = 0„„DIM SHARED OutBuffer$, OStartAddress, OAddress, OEndAddress, Oseg„DIM SHARED CodeSize, CurrentBit, Char&, BlockLength„DIM SHARED Shift(7) AS LONG„DIM SHARED x, y, Minx, MinY, MaxX, MaxY, Done, GIFFile, LastLoc&„„ShiftTable:„DATA 1,2,4,8,16,32,64,128„„'-------------- Only for testing purposes:„SCREEN 13„„FOR A = 1 TO 40„    x = RND * 320„    y = RND * 200„    c = RND * 256„    CIRCLE (x, y), RND * 80, c„    PAINT (x, y), RND * 256, c„„NEXT„FOR A = 1 TO 1000: LINE -(RND * 320, RND * 200), RND * 256: NEXT„LINE (0, 0)-(0, 199), 14„„MakeGIF "temp.gif", 320, 200, 0, 0, 319, 199, 256, 2„„'Puts a byte into the disk buffer... when the disk buffer is full it is„'dumped to disk.„SUB BufferWrite (A) STATIC„„    IF OAddress = OEndAddress THEN  'are we at the end of the buffer?„        PUT GIFFile, , OutBuffer$   ' yup, write it out and„        OAddress = OStartAddress    '  start all over„    END IF„    POKE OAddress, A                'put byte in buffer„    OAddress = OAddress + 1         'increment position„END SUB„„'This routine gets one pixel from the display.„FUNCTION GetByte STATIC„    GetByte = POINT(x, y)           'get the "byte"„    x = x + 1                       'increment X coordinate„    IF x > MaxX THEN                'are we too far?„        LINE (Minx, y)-(MaxX, y), 0 'a pacifier for impatient users„        x = Minx                    'go back to start„        y = y + 1                   'increment Y coordinate„        IF y > MaxY THEN            'are we too far down?„            Done = True             ' yup, flag it then„        END IF„    END IF„END FUNCTION„„'„'-----------------------------------------------------------------------------„'    PDS 7.1 & QB4.5 GIF Compression Routine v1.00 By Rich Geldreich 1992„'-----------------------------------------------------------------------------„'„'A$          = output filename„'ScreenX     = X resolution of screen(320, 640, etc.)„'ScreenY     = Y resolution of screen(200, 350, 480, etc.)„'XStart      = <-upper left hand corner of area to encode„'YStart      = < "                                      "„'Xend        = <-lower right hand corner of area to encode„'Yend        = < "                                       "„'NumColors   = # of colors on screen(2, 16, 256)„'AdaptorType = 1 for EGA 2 for VGA„'NOTE: EGA palettes are not supported in this version of MakeGIF.„'„SUB MakeGIF (A$, ScreenX, ScreenY, Xstart, YStart, Xend, Yend, NumColors, AdaptorType)„    'hash table's size - must be a prime number!„    CONST Table.Size = 7177„„    DIM Prefix(Table.Size - 1), Suffix(Table.Size - 1), Code(Table.Size - 1)„   „    'The shift table contains the powers of 2 needed by the„    'PutCode routine. This is done for speed. (much faster to„    'look up an integer than to perform calculations...)„    RESTORE ShiftTable„    FOR A = 0 TO 7: READ Shift(A): NEXT„   „    'MinX, MinY, MaxX, MaxY have the encoding window„    Minx = Xstart: MinY = YStart„    MaxX = Xend: MaxY = Yend„   „    'Open GIF output file„    GIFFile = FREEFILE                  'use next free file„    OPEN A$ FOR BINARY AS GIFFile„   „    'Put GIF87a header at beginning of file„    B$ = "GIF87a"„    PUT GIFFile, , B$„   „    'See how many colors are in this image...„    SELECT CASE NumColors„        CASE 2              'monochrome image„            BitsPixel = 1   '1 bit per pixel„            StartSize = 3   'first LZW code is 3 bits„            StartCode = 4   'first free code„            StartMax = 8    'maximum code in 3 bits„„        CASE 16             '16 colors images„            BitsPixel = 4   '4 bits per pixel„            StartSize = 5   'first LZW code is 5 bits„            StartCode = 16  'first free code„            StartMax = 32   'maximum code in 5 bits„       „        CASE 256            '256 color images„            BitsPixel = 8   '8 bits per pixel„            StartSize = 9   'first LZW code is 9 bits„            StartCode = 256 'first free code„            StartMax = 512  'maximum code in 9 bits„    END SELECT„    'This following routine probably isn't needed- I've never„    'had to use the "ColorBits" variable... With the EGA, you„    'have 2 bits for Red, Green, & Blue. With VGA, you have 6 bits.„    SELECT CASE AdaptorType„        CASE 1„            ColorBits = 2               'EGA„        CASE 2„            ColorBits = 6               'VGA„    END SELECT„    „    PUT GIFFile, , ScreenX  'put screen's dimensions„    PUT GIFFile, , ScreenY„    'pack colorbits and bits per pixel„    A = 128 + (ColorBits - 1) * 16 + (BitsPixel - 1)„    PUT GIFFile, , A„    'throw a zero into the GIF file„    A$ = CHR$(0)„    PUT GIFFile, , A$„    'Get the RGB palette from the screen and put it into the file...„    SELECT CASE AdaptorType„    CASE 1„        STOP„        'EGA palette routine not implemented yet„    CASE 2„        OUT &H3C7, 0„        FOR A = 0 TO NumColors - 1„            'Note: a BIOS call could be used here, but then we have to use„            'the messy CALL INTERRUPT subs...„            R = (INP(&H3C9) * 65280) \ 16128 'C=R * 4.0476190(for 0-255)„            G = (INP(&H3C9) * 65280) \ 16128„            B = (INP(&H3C9) * 65280) \ 16128„            A$ = CHR$(R): PUT GIFFile, , A$„            A$ = CHR$(G): PUT GIFFile, , A$„            A$ = CHR$(B): PUT GIFFile, , A$„        NEXT„    END SELECT„   „    'write out an image descriptor...„    A$ = ","                        '"," is image seperator„    PUT GIFFile, , A$               'write it„    PUT GIFFile, , Minx             'write out the image's location„    PUT GIFFile, , MinY„    ImageWidth = (MaxX - Minx + 1)  'find length & width of image„    ImageHeight = (MaxY - MinY + 1)„    PUT GIFFile, , ImageWidth       'store them into the file„    PUT GIFFile, , ImageHeight„    A$ = CHR$(BitsPixel - 1)        '# bits per pixel in the image„    PUT GIFFile, , A$„   „    A$ = CHR$(StartSize - 1)        'store the LZW minimum code size„    PUT GIFFile, , A$„   „    'Initialize the vars needed by PutCode„    CurrentBit = 0: Char& = 0„    „    MaxCode = StartMax          'the current maximum code size„    CodeSize = StartSize        'the current code size„    ClearCode = StartCode       'ClearCode & EOF code are the„    EOFCode = StartCode + 1     '  first two entries„    StartCode = StartCode + 2   'first free code that can be used„    NextCode = StartCode        'the current code„   „    OutBuffer$ = STRING$(5000, 32)  'output buffer; for speedy disk writes„    A& = SADD(OutBuffer$)           'find address of buffer„    A& = A& - 65536 * (A& < 0)„    Oseg = VARSEG(OutBuffer$) + (A& \ 16)   'get segment + offset >> 4„    OAddress = A& AND 15                  'get address into segment„    OEndAddress = OAddress + 5000         'end of disk buffer„    OStartAddress = OAddress              'current location in disk buffer„    DEF SEG = Oseg„„    GOSUB ClearTree                       'clear the tree & output a„    PutCode ClearCode                     '  clear code„   „    x = Xstart: y = YStart          'X & Y have the current pixel„    Prefix = GetByte                'the first pixel is a special case„    Done = False                    'True when image is complete„    „    DO 'while there are more pixels to encode                        „„        DO 'until we have a new string to put into the table„„            IF Done THEN 'write out the last pixel, clear the disk buffer„                         'and fix up the last block so its count is correct„               „                PutCode Prefix  'write last pixel„                PutCode EOFCode 'send EOF code„               „                IF CurrentBit <> 0 THEN„                    PutCode 0       'flush out the last code...„                END IF„                PutByte 0„„                OutBuffer$ = LEFT$(OutBuffer$, OAddress - OStartAddress)„                PUT GIFFile, , OutBuffer$„                A$ = ";" + STRING$(8, &H1A) 'the 8 EOF chars is not standard,„                                            'but many GIF's have them, so how„                                            'much could it hurt?„                PUT GIFFile, , A$„               „                A$ = CHR$(255 - BlockLength) 'correct the last block's count„                PUT GIFFile, LastLoc&, A$„               „                CLOSE GIFFile„                EXIT SUB„            ELSE 'get a pixel from the screen and see if we can find„                 'the new string in the table„                Suffix = GetByte„                GOSUB Hash        'is it there?„                IF Found = True THEN Prefix = Code(Index) 'yup, replace the„                                    'prefix:suffix string with whatever„                                    'code represents it in the table„            END IF„        LOOP WHILE Found  'don't stop unless we find a new string„        „        PutCode Prefix    'output the prefix to the file„       „        Prefix(Index) = Prefix  'put the new string in the table„        Suffix(Index) = Suffix„        Code(Index) = NextCode  'we've got to keep track if what code this is!„       „        Prefix = Suffix         'Prefix=the last pixel pulled from the screen„       „        NextCode = NextCode + 1   'get ready for the next code„        IF NextCode = MaxCode + 1 THEN  'can an output code ever exceed„                                        'the current code size?„            'yup, increase the code size„„            MaxCode = MaxCode * 2„            „        'Note: The GIF89a spec mentions something about a deferred clear„        'code. When the clear code is deferred, codes are not entered„        'into the hash table anymore. When the compression of the image„        'starts to fall below a certain threshold, the clear code is„        'sent and the hash table is cleared. The overall result is„        'greater compression, because the table is cleared less often.„        'This version of MakeGIF doesn't support this, because some GIF„        'decoders crash when they attempt to enter too many codes„        'into the string table.„„            IF CodeSize = 12 THEN       'is the code size too big?„                PutCode ClearCode       'yup; clear the table and„                GOSUB ClearTree         'start over„                NextCode = StartCode„                CodeSize = StartSize„                MaxCode = StartMax„„„            ELSE„                CodeSize = CodeSize + 1 'just increase the code size if„            END IF                      'it's not too high( not > 12)„        END IF„        „    LOOP 'while we have more pixels„ClearTree:                 „    FOR A = 0 TO Table.Size - 1       'clears the hashing table„        Prefix(A) = -1                '-1 = invalid entry„        Suffix(A) = -1„        Code(A) = -1„    NEXT„RETURN„'this is only one of a plethora of ways to search the table for„'a match! I used a binary tree first, but I switched to hashing„'cause it's quicker(perhaps the way I implemented the tree wasn't„'optimal... who knows!)„Hash:„    'hash the prefix & suffix(there are also many ways to do this...)„     '?? is there a better formula?„    Index = ((Prefix * 256&) XOR Suffix) MOD Table.Size„    '„    '(Note: the table size(7177 in this case) must be a prime number, or„    'else there's a chance that the routine will hang up... hate when„    'that happens!)„    '„    'Calculate an offset just in case we don't find what we want on the„    'first try...„    IF Index = 0 THEN    'can't have Table.Size-0 !„        Offset = 1„    ELSE„        Offset = Table.Size - Index„    END IF„    „    DO 'until we (1) find an empty entry or (2) find what we're lookin for„                                  „       „        IF Code(Index) = -1 THEN  'is this entry blank?„            Found = False         'yup- we didn't find the string„            RETURN„        'is this entry the one we're looking for?„        ELSEIF Prefix(Index) = Prefix AND Suffix(Index) = Suffix THEN„            'yup, congrats you now understand hashing!!!„    „            Found = True„            RETURN„        ELSE„            'shoot! we didn't find anything interesting, so we must„            'retry- this is what slows hashing down. I could of used„            'a bigger table, that would of speeded things up a little„            'because this retrying would not happen as often...„            Index = Index - Offset„            IF Index < 0 THEN   'too far down the table?„                'wrap back the index to the end of the table„                Index = Index + Table.Size„            END IF„        END IF„    LOOP„END SUB„„'Puts a byte into the GIF file & also takes care of each block.„SUB PutByte (A) STATIC„    BlockLength = BlockLength - 1   'are we at the end of a block?„    IF BlockLength <= 0 THEN        ' yup,„        BlockLength = 255           'block length is now 255„        LastLoc& = LOC(1) + 1 + (OAddress - OStartAddress) 'remember the pos.„        BufferWrite 255                                    'for later fixing„    END IF„    BufferWrite A   'put a byte into the buffer„END SUB„„'Puts an LZW variable-bit code into the output file...„SUB PutCode (A) STATIC„    Char& = Char& + A * Shift(CurrentBit) 'put the char were it belongs;„    CurrentBit = CurrentBit + CodeSize    ' shifting it to its proper place„    DO WHILE CurrentBit > 7               'do we have a least one full byte?„        PutByte Char& AND 255             ' yup! mask it off and write it out„        Char& = Char& \ 256               'shift the bit buffer right 8 bits„        CurrentBit = CurrentBit - 8       'now we have 8 less bits„    LOOP 'until we don't have a full byte„END SUB„„Peter Norton                   DETECT VIDEO CARD              DETECT,VIDEO,CARD              Unknown Date (00:00)   QB, PDS                66   1821     GETVCARD.BASDECLARE FUNCTION GetVideoCard$ ()„„TYPE RegType„        ax      AS INTEGER„        bx      AS INTEGER„        cx      AS INTEGER„        dx      AS INTEGER„        bp      AS INTEGER„        si      AS INTEGER„        di      AS INTEGER„        flags   AS INTEGER„END TYPE„„DECLARE SUB INTERRUPT (IntNo AS INTEGER, InRegs AS RegType, OutRegs AS RegType)„„        CLS„        PRINT "Your video card is a "; GetVideoCard$„„END„„FUNCTION GetVideoCard$„„REM This function returns a 3-letter string: "MDA" (monochrome adapter card)„REM "CGA" (color graphics adapter), "EGA" (enhanced graphics adapter),„REM "PGA" (professional graphics adapter), "VGA" (variable graphics array)„„   DIM InRegs AS RegType, OutRegs AS RegType„   InRegs.ax = &H1A00„   CALL INTERRUPT(&H10, InRegs, OutRegs)„   IF (OutRegs.ax AND &HFF) = &H1A THEN„       Code = OutRegs.bx AND &HFF„       SELECT CASE Code„           CASE 1„                GetVideoCard$ = "MDA"„           CASE 2„                GetVideoCard$ = "CGA"„           CASE 4 TO 5„                GetVideoCard$ = "EGA"„           CASE 6„                GetVideoCard$ = "PGA"„           CASE 7 TO 8„                GetVideoCard$ = "VGA"„       END SELECT„       EXIT FUNCTION„   ELSE„       InRegs.ax = &H1200„       InRegs.bx = &H10„       CALL INTERRUPT(&H10, InRegs, OutRegs)„       IF (OutRegs.bx AND &HFF) <> &H10 THEN„           GetVideoCard$ = "EGA"„           EXIT FUNCTION„       ELSE„           InRegs.ax = &HF00„           CALL INTERRUPT(&H10, InRegs, OutRegs)„           IF (OutRegs.ax AND &HFF) = 7 THEN„               GetVideoCard$ = "MDA"„               EXIT FUNCTION„           ELSE„               GetVideoCard$ = "CGA"„               EXIT FUNCTION„           END IF„       END IF„   END IF„„END FUNCTION„„Rich Geldreich                 SCREEN COMPRESSION             SCREEN,COMPRESSION             12/26/92 (00:00)       PDS, VBDOS             577  25954    SP.BAS      'SCREEN 13 (320x200x256) Screen Compressor (SP1.BAS)„'Public Domain By Rich Geldreich, December 26, 1992„ „'Anyone  may  use this program in anything they want,  as long as the„'original author(me,  duh)  is  given  credit  where credit is due...„'Thanks.   I'd appreciate a little cash on the side if you  make  any„'money  off a product that uses this program...   :-) If you make any„'neat modifications/optimizations to this program or the ASM decoder,„'I would really like to seem them!„ „'Description:„'    This simple SCREEN 13  compression  program uses an LZ77 variant„'to compress SCREEN 13 images.  A FAST assembly subroutine is used to„'decompress the image back to the screen.    The  compression  should„'always beat  PCX, and should come fairly close or beat out GIF under„'most cases.„'„'    The assembly decompressor's  speed  is several magnitudes faster„'than the quickest GIF decoder I've seen, VPIC 5.1. (Look how  simple„'it is  and  you'll know why!) BTW- The output stage of this program„'was optimized for  decoding  speed,   not for compression.   Several„'optimizations could be added to increase this program's  compression„'performance,   such  as  entropy  encoding  on the distance & length„'tokens(which would slow the decoder down immensely),  increasing the„'sizes of the sliding dictionary and look ahead buffers,  and further„'optimizing the  non-greedy  aspect  of  this  LZ77 implementation to„'choose the best character/match combinations to store in the  output„'stream.„'„'    The assembly subroutine is for 286's and  above,   only.    This„'program does NOT work under QuickBASIC,  only PDS and VB/DOS because„'of the use of BYVAL.„'„'    Any  questions,   cash/and  or  death   threats   call   me   at„'(609)-742-8752  2:30pm  -  11:30pm  eastern  time  or  send  a  self„'addressed stamped evelope (SASE) to:„'„'                     Rich Geldreich„'                     410 Market St.„'                     Gloucester City, NJ 08030„'„'Possible  uses of this program:  Use a GIF or PCX converter(or SHELL„'out  to  VPIC)  to  display  the  image  you  want  to  use  in your„'application on SCREEN 13.   Then encode the image with this program.„'You  can  then  instantly  recall  the  image using the fast Decom13„'assembly language subroutine.„„DEFINT A-Z„'Declaration  for  the assembly decompressor.   If the area of memory„'passed does not start with  "RG",  the compressed image's signature,„'then this routine will just return without  doing  anything.    This„'prevents your machine from hanging when you pass it a bum pointer.„„DECLARE SUB Decom13 (BYVAL InSegment, BYVAL InOffset)„ „CONST True = -1, False = 0„'A larger buffer size would surely increase compression.„CONST BufferSize = 4096, HashSize = 4096„CONST Null = BufferSize, Threshold = 2, MaxMatch = 273„CONST MaxCompares = 300 'Controls compression ratio vs. speed„ „'Arrays for LZ77 style compression with multiple linked lists„DIM SHARED RingBuffer((BufferSize + MaxMatch - 1) - 1)„DIM SHARED NextCell((BufferSize + HashSize + 1) - 1)„DIM SHARED LastCell((BufferSize + HashSize + 1) - 1)„'Temp. holding buffer for compression tokens„DIM SHARED CodeBuffer(16 * 3 - 1)„ „'Misc. stuff„DIM SHARED DoneFlag, xp, yp, xl, yl, xh, yh„DIM SHARED Match.Length, Match.Position, Match.Distance„DIM SHARED IOBuffer$, IOPointer„DIM SHARED CodePointer, CodeCounter, OrMask AS LONG, BitAccum AS LONG„ „SCREEN 13„ „'**COMPRESSION EXAMPLE**„RANDOMIZE TIMER„FOR a = 1 TO 100  'draw us some garbage„    x = RND * 319: y = RND * 199: c = RND * 255„„    CIRCLE (x, y), RND * 60, c: PAINT (x, y), RND * 255, c„NEXT„FOR a = 1 TO 200: LINE -(RND * 319, RND * 199), RND * 255: NEXT„Compress13 "coolfile.bci" 'compress the screen to coolfile.bci„ „'**DECOMPRESSION EXAMPLE**„'Allocate 64,000 bytes for a worst case scenario, decrease this of„'course to match the image's compressed size in bytes...„REDIM image(32000): DEF SEG = VARSEG(image(0))„BLOAD "coolfile.bci", VARPTR(image(0)) 'Load the compressed data.„ „PRINT "Press a key to decompress.": B$ = INPUT$(1): SCREEN 13„ „'Call the asm routine to decompress the image.„Decom13 VARSEG(image(0)), VARPTR(image(0)): B$ = INPUT$(1)„ „'Compresses a SCREEN 13 image to a BLOADable file. Use the ASM sub„'Decom13 to decompress the image back to the screen. This routine„'currently crawls, because I didn't optimize it that much.„'The entire palette is also saved to the compressed file,„SUB Compress13 (F$)„    OPEN F$ FOR OUTPUT AS #1: CLOSE : OPEN F$ FOR BINARY AS #1„    'Store the BLOAD header and image signature.„    a$ = CHR$(&HFD) + CHR$(0) + CHR$(&HA0) + STRING$(4, 0) + "RG"„    PUT #1, , a$„    'Initialize a 4k disk output buffer„    IOBuffer$ = SPACE$(4096): IOPointer = 1„    CodePointer = 0: CodeCounter = 0: OrMask = 1: BitAccum = 0„    'Write the screen's palette.„    OUT &H3C7, 0: FOR a = 0 TO 767: WriteByte INP(&H3C9): NEXT„ „    DoneFlag = False: xl = 0: yl = 0: xh = 319: yh = 199„    xp = xl: yp = yl 'coordinate of next point to compress„ „    InitRingBuffer   'clear the ring buffer„    InitLZ77         'initialize the linked list pool„    'prime the look ahead buffer„    S = 0: R = BufferSize - MaxMatch„    FOR LookAheadLength = 0 TO MaxMatch - 1„        IF DoneFlag THEN„            EXIT FOR„        ELSE„            RingBuffer(R + LookAheadLength) = GetPixel„        END IF„    NEXT„    'find first string„    FindString R„    DO„        'if match too small(less than 3 chars), the just output„        'a single character„        IF Match.Length <= Threshold THEN„            OutputChar RingBuffer(R): Last.Match.Length = 1„        ELSE„            'output a string match token„            Last.Match.Length = Match.Length„            'Send  the match's distance,  instead of its position in„            'the ring buffer, because the decompressor is not using a„            'ring buffer to store the decompressed data.„            Match.Distance = (R - Match.Position) AND (BufferSize - 1)„            OutputMatch„        END IF„        'prime the look ahead buffer with more characters„        FOR a = 0 TO Last.Match.Length - 1„            IF DoneFlag THEN EXIT FOR 'exit this loop if no more chars„            'delete string at S, then store a new char at S„            DeleteString S: RingBuffer(S) = GetPixel„            'keep a "ghost buffer" at the end of the ring buffer to„            'avoid using a logical AND on all of our buffer pointers„            IF S < (MaxMatch - 1) THEN„                RingBuffer(S + BufferSize) = RingBuffer(S)„            END IF„            S = (S + 1) AND (BufferSize - 1)„            R = (R + 1) AND (BufferSize - 1)„            'if not last time through loop then just add string to the„            'linked list pool, otherwise add it and find a match„            '(this could be optimized so the IF/THEN conditional  is„            'removed from inside this loop)„            IF a = (Last.Match.Length - 1) THEN„                FindString R„            ELSE„                MakeString R„            END IF„        NEXT„        FOR a = a TO Last.Match.Length - 1„            'this loop is active when no more characters are available„            'from the input stream„            'Kill string at S, not sure if this is needed because„            'we're  not  storing any characters in its place. I see„            'no reason to do it,   but  this  is one of those little„            'quirks that all LZSS implementations I've seen have... ?„ „            DeleteString S„            S = (S + 1) AND (BufferSize - 1)„            R = (R + 1) AND (BufferSize - 1)„            LookAheadLength = LookAheadLength - 1„            IF LookAheadLength THEN„                IF a = (Last.Match.Length - 1) THEN„                    FindString R„                ELSE„                    MakeString R„                END IF„ „                'Limit  match  length  because the look ahead buffer„                'is growing smaller.   This is another little oddity„                'I've seen amoung the LZSS compressors,  they all do„                'this check outside this  loop  before they output a„                'character/match token...    There's  no  reason  to„                'check  outside  the  loop because the string search„                'function always  limits  the  match  length  to the„                'look ahead buffer's size.   We only check when  the„                'look ahead buffer starts to get smaller.„ „                IF Match.Length > LookAheadLength THEN„                    Match.Length = LookAheadLength„                END IF„            END IF„        NEXT„    LOOP WHILE LookAheadLength 'loop while still more chars to encode„    OutputEOF„    WriteFlush„    'get (compressed size)-header„    a& = LOF(1) - 7: SCREEN 0: WIDTH 80„    IF a& > 64000 THEN„        PRINT "Image could not be compressed."„        CLOSE #1: KILL F$„    ELSE„        PRINT "Image compressed to"; a&; "bytes."„        IF a& > 32767 THEN a& = a& - 65536„        'store the compressed size so BLOAD loads everything in„        a = a&: PUT #1, 6, a: CLOSE #1„    END IF„END SUB„ „'Deletes the string at S from the linked list pool.„SUB DeleteString (BYVAL S)„    NextCell = NextCell(S): LastCell = LastCell(S)„    NextCell(LastCell) = NextCell: LastCell(NextCell) = LastCell„    NextCell(S) = Null„END SUB„ „'Attempts to find a match at R+1 that is larger than the match found„'at R, to get rid of some of the encoder's "greedy" characteristics.„FUNCTION FindAlternate (BYVAL R, BYVAL MatchLength)„    B1 = RingBuffer(R): B2 = RingBuffer(R + 1): B3 = RingBuffer(R + 2)„    'hash out the first three characters of the string to locate„    P = (BufferSize + 1) + ((B1 * 14096& XOR B2 * 77 XOR B3) MOD HashSize)„    MatchChar = RingBuffer(R + MatchLength)„    FOR x = 1 TO MaxCompares„        P = NextCell(P) 'traverse linked list P for a match„        'if we struck bottom then search failed„        IF P = Null THEN FindAlternate = False: EXIT FUNCTION„        'compare string P to string R„        IF RingBuffer(P) = B1 AND RingBuffer(P + 1) = B2 AND RingBuffer (P + 2) = B3 AND RingBuffer(P + MatchLength) = MatchChar THEN„            FOR SearchLength = 3 TO (MaxMatch - 1) - 1„                IF RingBuffer(R + SearchLength) <> RingBuffer(P + SearchLength) THEN EXIT FOR„            NEXT„            'if we find a longer match then exit with success„            IF SearchLength > MatchLength THEN FindAlternate = True: EXIT FUNCTION„        END IF„    NEXT„    FindAlternate = False„END FUNCTION„ „'Attempts  to  locate  a  match  in the linked list pool for  R. Most„'other LZ77/LZSS  implementations  I've  seen  use  a  binary tree to„'locate string matches.   In this implementation,  I use  a  pool  of„'linked  lists to locate strings.   Each linked list contains strings„'which all  start  with the  same 3 characters. (Well, usually. Since„'hash collisions can occur,  sometimes  a linked list contains two or„'more different strings.   This isn't cool,  and can't be  eliminated„'unless  another approach to collision handling is used.)„'„'    To locate a string,  its linked list is located through a simple„'hashing formula(which was home brewed,  BTW,   so it may not be that„'optimal),  and then each string in the list is compared against  our„'target  string until we either find a string which matches perfectly„'or the "bombout" variable is decremented to zero.   The bombout rate„'defines the number of string  compares  which may be performed until„'the algorithm stops searching and settles with what it  has.    This„'decreases  compression  slightly,  but greatly increases compression„'speed,  especially when  the  input  stream  contains  large runs of„'repeated data.   (ARJ adjusts its bombout  rate  with  command  line„'options:   options  -m4  to  -m0 vary the number of compares it does„'against its string directionary,  therefore "dialing" in compression„'speed  vs.    compression  ratio.    PKZIP  1.93a  does  this  also.„'Normally, PKZIP 1.93a will set its bombout rate to 50 compares.  The„'Continued on page 4„„'-s option brings this down to 10-7 compares(can't remember exactly),„'and  the -ex option increases the  bombout  rate  to  500  compares.„'Obviously, the -ex option slows down PKZIP 1.93a  because it can  do„'up to ten times more string compares than usual.)„'„'    One optimization that I have not seen anywhere yet speeds up the„'string  search  by  skipping  strings which can't possibly be larger„'than the largest string found up to that point...„'„'    For  instance,   let's  say we are searching for the string "the„'president eats peanuts".   Let's  also  say  the largest match we've„'found so far is "the president ", or 14 characters.  The next string„'to  compare  against  our target is "the president finds coolness in„'compression".  Since the whole point of searching is to look for the„'largest match, there's no use in doing a whole string compare if the„'match will be smaller/equal to  our current match.   A quick compare„'of the character that must match for the match length to  be  larger„'will  tell  us  if  the  string  *may* be larger.   If the character„'matches,  we must do the compare.   If it doesn't,  then there is no„'use in doing the string compare because the match cannot possibly be„'longer.   Since the 15th character of our target string is "e",  and„'the 15th character of our search string is "f",  it can instantly be„'discarded because the  match  cannot  possibly  be  larger  than  14„'characters.   This especially speeds up the search when large string„'matches  are found in the input stream(such as in text files).   And„'since the optimization is relatively trivial, it shouldn't slow down„'the string search loop much  at  all  when  input stream is not very„'compressable.„'„'   Finally,  using the linked list pool to find string matches makes„'finding the  closest  AND  longest  match  very  simple(finding  the„'closest  match  aids  entropy encoding in attaining more compression„'because it can  favor  close  matches  over  far  ones).   Since new„'strings are always inserted as the first string in its  pool,    the„'entire  list is already sorted in order of distance from our current„'position in the ring buffer.„SUB FindString (BYVAL R)„    B1 = RingBuffer(R): B2 = RingBuffer(R + 1): B3 = RingBuffer(R + 2)„    'hash the first 3 characters of the string to find„    LinkHead = (BufferSize + 1) + ((B1 * 14096& XOR B2 * 77 XOR B3) MOD HashSize)„    Match.Length = 0: MatchChar = B1: P = LinkHead„    FOR x = 1 TO MaxCompares 'MaxCompares is the bombout rate„        'traverse linked list P for match„        P = NextCell(P): IF P = Null THEN EXIT FOR„        'If first 3 characters match, and the character at„        'P+MatchLength=R+MatchLength, then compare strings.„        IF RingBuffer(P) = B1 AND RingBuffer(P + 1) = B2 AND RingBuffer (P + 2) = B3 AND RingBuffer(P + Match.Length) = MatchChar THEN„            FOR SearchLength = 3 TO (MaxMatch - 1) - 1„                IF RingBuffer(R + SearchLength) <> RingBuffer(P + SearchLength) THEN EXIT FOR„            NEXT„            'if matchsize=maxmatch then take it and run„            '(MaxMatch-1) because our look ahead buffer is one„            'character longer than the maximum match length.„            IF SearchLength >= (MaxMatch - 1) THEN„                Match.Length = (MaxMatch - 1)„                Match.Position = P„                EXIT FOR„            END IF„            'if we find a longer match then take it„            IF SearchLength > Match.Length THEN„                Match.Length = SearchLength„                Match.Position = P„                MatchChar = RingBuffer(R + Match.Length)„            END IF„        END IF„    NEXT„    'make the new string the first entry in its linked list pool„    'so we always find the closest match„    a = NextCell(LinkHead): NextCell(LinkHead) = R„    LastCell(a) = R: LastCell(R) = LinkHead: NextCell(R) = a„    'Attempt to find a longer match at R+1. If there is a longer„    'match, then set the match length to zero so the current match„    'is ignored.„    IF (Match.Length <> 0) AND (Match.Length <> (MaxMatch - 1)) THEN„        IF FindAlternate(R + 1, Match.Length) THEN Match.Length = 0„    END IF„END SUB„ „'Returns one pixel from the display.„FUNCTION GetPixel„    GetPixel = POINT(xp, yp): xp = xp + 1„    IF xp > xh THEN„        LINE (xl, yp)-(xh, yp), 0„        xp = xl: yp = yp + 1: DoneFlag = yp > yh„    END IF„„„END FUNCTION„ „'Initializes the linked list pool arrays„'Page 5 of ENCODE13.BAS begins here.„SUB InitLZ77„    FOR a = 0 TO (BufferSize + 1 + HashSize) - 1„        NextCell(a) = Null: LastCell(a) = Null„    NEXT„END SUB„ „'Initializes the ring buffer.„SUB InitRingBuffer„    FOR a = 0 TO BufferSize - MaxMatch - 1: RingBuffer(a) = 0: NEXT„END SUB„ „'Stores the string at R into its linked list without scanning for a„'match.„SUB MakeString (BYVAL R)„    LinkHead = (BufferSize + 1) + ((RingBuffer(R) * 14096& XOR _„RingBuffer(R + 1) * 77 XOR RingBuffer(R + 2)) MOD HashSize)„    a = NextCell(LinkHead): NextCell(LinkHead) = R: LastCell(a) = R„    LastCell(R) = LinkHead: NextCell(R) = a„END SUB„ „'Stores an uncompressed character and its flag to the output code„'buffer.„SUB OutputChar (BYVAL a)„    OrMask = OrMask * 2 'send a binary 0„    CodeBuffer(CodePointer) = a     'store the character„    CodeCounter = CodeCounter + 1„    IF CodeCounter = 16 THEN        'if 16 codes the write 'em out„        'write the bit flags„        WriteByte BitAccum AND 255: WriteByte BitAccum \ 256„        'write the codes„        FOR a = 0 TO CodePointer: WriteByte CodeBuffer(a): NEXT„        CodePointer = 0: CodeCounter = 0: OrMask = 1: BitAccum = 0„    ELSE„        CodePointer = CodePointer + 1„    END IF„END SUB„ „'Writes an EOF code to the output code buffer„SUB OutputEOF„    BitAccum = BitAccum OR OrMask„    CodeBuffer(CodePointer) = 15„    CodeBuffer(CodePointer + 1) = 0: CodeBuffer(CodePointer + 2) = 255„    WriteByte BitAccum AND 255: WriteByte BitAccum \ 256„    FOR a = 0 TO CodePointer + 2: WriteByte CodeBuffer(a): NEXT„END SUB„ „'Outputs a match and its flag to the output code buffer.„SUB OutputMatch„    BitAccum = BitAccum OR OrMask: OrMask = OrMask * 2„    'Favor short matches(3-17 characters).„    IF Match.Length < 18 THEN„        CodeBuffer(CodePointer) = (Match.Length - (Threshold + 1)) OR„_„(Match.Distance AND &HF) * 16„        CodeBuffer(CodePointer + 1) = Match.Distance \ 16„        CodePointer = CodePointer + 2„    ELSE„        CodeBuffer(CodePointer) = 15 OR (Match.Distance AND &HF) * 16„        CodeBuffer(CodePointer + 1) = Match.Distance \ 16„        CodeBuffer(CodePointer + 2) = Match.Length - 18„        CodePointer = CodePointer + 3„    END IF„    CodeCounter = CodeCounter + 1„    IF CodeCounter = 16 THEN„        WriteByte BitAccum AND 255: WriteByte BitAccum \ 256„        FOR a = 0 TO CodePointer - 1: WriteByte CodeBuffer(a): NEXT„        CodePointer = 0: CodeCounter = 0: OrMask = 1: BitAccum = 0„    END IF„END SUB„ „'Stores one byte into the disk output buffer, and flushes it when it„'is full.„SUB WriteByte (BYVAL a)„    MID$(IOBuffer$, IOPointer, 1) = CHR$(a)„    IOPointer = IOPointer + 1„    IF IOPointer = 4097 THEN 'if buffer full then flush„        PUT #1, , IOBuffer$: IOPointer = 1„    END IF„END SUB„ „'Flushes the disk output buffer.„SUB WriteFlush„    IOBuffer$ = LEFT$(IOBuffer$, IOPointer - 1): PUT #1, , IOBuffer$„END SUB„ „„'---------8<----[ DECOM13.ASM begins here. ]---->8-------------„;TASM v2.0 source code for DECOM13.OBJ. By Rich Geldreich, 1992„;A LZ77 style sliding dictionary decompressor for SCREEN 13 images.„.286                                    ;<-sorry 8088 & 8086 guys,„IDEAL                                   ;it's 1992 get a real CPU!„MODEL SMALL„CODESEG„PUBLIC  Decom13„PROC    Decom13„INPTR   EQU [dword ss:bp+6]„P       = 2„        Cld                             ;clear direction flag„        Push    bp                      ;setup stack frame„        Mov     bp, sp„        Push    ds es si di             ;preserve important regs„        Lds     si, INPTR               ;get pointer from stack„        Cmp     [word ds:si], 'R'+'G'*256 ;is an image there?„        Je      @@OK                    ;nope„        Jmp     @@Exit„@@OK:   Inc     si                      ;get by signature„        Inc     si„        Mov     [word cs:ISeg1+1], ds   ;a little self modifying code„        Mov     [word cs:ISeg2+1], ds   ; can't hurt(I think).„        Jmp     @@10                    ;empty the prefetch„@@20:   Mov     dx, 03C4h               ;sequencer register„        Mov     al, 1                   ;clocking mode register„        Out     dx, al„        Inc     dx„        In      al, dx„        Or      al, 32                  ;set screen off bit„        Out     dx, al                  ;go for screen disable„        Mov     dl, 0DAh                ;wait for vertical retrace„@@30:   In      al, dx„        And     al, 8„        Jz      @@30„        Mov     dl, 0C8h                ;dx=03C8h„        Mov     cx, 768                 ;prepare to set the palette„        Xor     al, al                  ;start at attribute 0„        Out     dx, al„        Inc     dx„        Rep     Outsb                   ;output the palette„        Push    0A000h                  ;es=screen's segment„        Pop     es„        Xor     di, di                  ;di=output offset„        Mov     dx, di                  ;dx=# bits left in bitbuffer„EVEN                                    ;-decode loop starts here-„@@MoreBits:„        Lodsw                           ;prime the bitbuffer„        Mov     dl, 16                  ;16 more bits now„        Mov     bp, ax„        Shr     bp, 1                   ;character or match?„        Jc      @@Match                 ;go for match if carry set„EVEN„@@NoMatch:„        Movsb                           ;store one character„@@MainLoop:„        Dec     dx                      ;any more bits left?„        Jz      @@MoreBits              ;get more if not„        Shr     bp, 1                   ;character of match?„        Jnc     @@NoMatch               ;go if character(carry=0)„@@Match:                                ;-handles a string match-„        Lodsw                           ;get match length and„        Mov     cx, ax                  ; and distance„        Shr     ax, 4                   ;shift by the match length„        Neg     ax                      ;got -distance now„        Add     ax, di                  ;ax=match position„        And     cx, 0Fh                 ;get low 4 bytes for length„        Add     cl, 3                   ;add in length threshold„        Cmp     cl, 18                  ;is this a big match?„        Je      @@GetMore               ;go get 1 more byte if so„        Xchg    ax, si                  ;save si and set si to match„        Mov     bx, es                  ; position„        Mov     ds, bx                  ;ds=es=0A000h„        Rep     Movsb                   ;copy the string„        Mov     si, ax                  ;restore ds and si„ISeg1:  Mov     ax, 09999h              ;<--self modifying code„        Mov     ds, ax„        Jmp     @@MainLoop              ;go again„EVEN„@@GetMore:„        Mov     bx, ax                  ;save match pos in bx„        Xor     ax, ax                  ;get one more byte for„        Lodsb                           ; match length„        Add     cx, ax„        Cmp     cx, 273                 ;end of image code?„        Je      @@Exit                  ;if so then done„        Xchg    bx, si                  ;save si and set si to match„'Continued on page 2„„'Page 2 of DECOM13.ASM begins here.„        Mov     ax, es                  ; pos„        Mov     ds, ax                  ;ds=es=0A000h„        Rep     Movsb                   ;copy the data„        Mov     si, bx                  ;restore ds and si„ISeg2:  Mov     ax, 09999h              ;<--self modifying code„        Mov     ds, ax„        Jmp     @@MainLoop„@@Exit: Mov     dx, 03C5h               ;turn screen back on„        In      al, dx„        And     al, NOT 32„        Out     dx, al„        Pop     di si es ds bp          ;exit back to caller„        Retf    P*2„@@10:   Jmp     @@20„ENDP    Decom13„END„'---------8<----[ DECOM13.ASM ends here. ]---->8-------------„„„ „   Oops. Here is the OBJ for the assembly decoder:„ „To execute this script, save it to a file and type DEBUG < filename„where "filename" is the name of this script file.„„E165"DECOM13.OBJ" 0„E200".q..9EKNXxKPlAX9/BJHhXs5....IJbQWx46/BrQZpaMgJaQU.WJZ7rQdxaPU"„E23D"6X9kY9WH..Edjf0dUl0YJqMjpKAnsGEHp2g6C...ZCHK8...U4W1..EVGdZA."„E27A"E/TFJFMF3/1x2F3N7a5..Gk0U.12kMKm..3w3F/FJE2EIEI3YkMS..6/..2IE"„E2B7".DM70.M.F57pHJ/pWOG..4wj.P/d1..E.5EIF1xIHlA1...UX6G...7O.F08h"„E2F4".2...kTJ9mi54MpJ3Pb//mXI5Fr.df6.4NY9AuFS.s0XSU7.df6.uGw.k4Uv0"„E331"lC1UsigOnC76ErymWQi.AUA.viEnv4O..u/nwzWLregEg6uFriQ7.7d8FbwFr"„E36E"yQsruW65Au2QDq1QwUVz.U/D.Ut9/RFM7X1vsqnHuWkXPaNu6qfHBY9WxA.nu"„E3AB".65MyF2.RFQcrA0gXMDDd9CDiNadXMjShuKw.gHmrizZL5wFL8H..dDrz2kN0"„E3E8".EQ4I3.lSEJ.mfc....R"„E100 B8 0 3C BA 65 1 33 C9 CD "!rC" BE 0 2 50 BD 7D 1 55 BF 88 90„E117 "W3" DB B1 FA 8A F0 80 C1 6 32 E4 AC "<9v" 8 "<Zv" 2 2C 6 2C„E12F 7 2C 2E E3 E8 D3 E0 A C6 AA 2 D8 92 "IIMu" E0 80 FB 0 75 9 5A„E147 59 5B B4 40 CD 21 73 7 B4 9 BA 58 1 CD 21 CD 20 7 "Error!$"„G„Q„Matt Hart                      DEFINITIVE SCREEN SAVER        DEFINITIVE,SCREEN,SAVER        01/14/93 (00:00)       QB, PDS                486  15579    DEFSCRS.BAS ' DEFSCRS.BAS  1-14-93  Matt Hart„'„' The definitive screen saver„' Works in any screen mode, compresses and saves„' multiple screens or screen portions per file.„' Screen portions can be restored to any part of„' the screen for window movement.„'„' Compile with /AH„'„' Storage method:„' --------------- Each Screen„'             x = Screen 1 data„'             x = Screen 2 data„'             .....„'             x = Screen (number of screens) data„'       4 bytes = Number of RLL bytes for screen„'       4 bytes = Number of actual bytes for screen„'       4 bytes = Offset into file for screen data„'       2 bytes = X1„'       2 bytes = Y1„'       2 bytes = X2„'       2 bytes = Y2„'       2 bytes = Screen mode number„'             ..... Continue for number of screens„' ---------------------------„'       Last 2 bytes is the number of screens„'„' The seemingly backward method of storing the screen info„' after the screen data is done so that offsets for screen„' data do not change, and a screen's data need not be moved„' when adding screens.„'„' RLL compression is:„'       Ascii 0 = RLL code follows„'           Ascii 0 = Just kidding - actually ascii 0„'             OR„'           Ascii 1-255 = Number of repeats„'           Ascii 0-255 = Character to repeat„'         OR„'       Ascii 1-255 = Character„'„' I use the backslash division (integer division) with rather„' than regular division to prevent linking with the floating„' point library - and it is faster anyway.„'„' Note that the compression and (especially important) the decompression„' can easily be done in assembly and would be, by some previous RLL stuff,„' about 27 times faster.„'„' All of these test screens took up only 18K in a disk file - but many„' contained repetitive colors, so actual compression will be less.„'„' MonType = 0 For MONO„' MonType = 1 For CGA„' MonType = 2 For EGA„' MonType = 3 For MCGA or VGA„„DEFINT A-Z„DECLARE SUB HSSaveScreen (ScreenFile$, X1%, Y1%, X2%, Y2%, MonType%, ScrNum%)„DECLARE SUB HSRestoreScreen (ScreenFile$, X1%, Y1%, MonType%, ScrNum%)„DECLARE SUB HSRLLCompress (Store&(), RLL&(), ActualBytes&, RLLBytes&)„DECLARE SUB HSIncAddr (DSeg%, DAddr%, Num%)„DECLARE SUB HSRLLDeCompress (Store&(), RLL&(), RLLBytes&)„„    TYPE RegTypeX„        AX    AS INTEGER„        BX    AS INTEGER„        CX    AS INTEGER„        DX    AS INTEGER„        BP    AS INTEGER„        SI    AS INTEGER„        DI    AS INTEGER„        Flags AS INTEGER„        DS    AS INTEGER„        ES    AS INTEGER„    END TYPE„    TYPE HSDefScrsType„        RLLBytes    AS LONG„        ActualBytes AS LONG„        Offset      AS LONG„        X1          AS INTEGER„        Y1          AS INTEGER„        X2          AS INTEGER„        Y2          AS INTEGER„        ScrMode     AS INTEGER„        MonType     AS INTEGER„    END TYPE„„    MonType = 3„' ----------------------------- Sample Code„    RANDOMIZE TIMER„    ScreenFile$ = "DEFSCRS.BIN"„„    CLS : PRINT "Test Screen 0"                         ' Any type„    COLOR 14, 4: PRINT "     Test Screen 0"„    COLOR 6, 4: LOCATE 25, 1: PRINT SPACE$(80);„    X1 = 1: Y1 = 1: X2 = 80: Y2 = 25„    CALL HSSaveScreen(ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„„    CLS : C = 1: A$ = "Second Test 0  "                 ' Any type„    COLOR 7, 0„    FOR Y = 1 TO 25„        COLOR C: LOCATE Y, 1„        PRINT A$ + A$ + A$ + A$ + A$; Y;„        C = C + 1: IF C = 16 THEN C = 1„    NEXT„    X1 = 1: Y1 = 1: X2 = 80: Y2 = 25„    CALL HSSaveScreen(ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„        „    SCREEN 1: LINE (0, 0)-(80, 80), 1, BF               ' CGA +„    PRINT "Screen 1"„    X1 = 0: Y1 = 0: X2 = 80: Y2 = 80„    CALL HSSaveScreen(ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„„    SCREEN 7: LINE (0, 0)-(100, 100), 10, BF            ' EGA +„    PRINT "Screen 7"„    X1 = 0: Y1 = 0: X2 = 100: Y2 = 100„    CALL HSSaveScreen(ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„„    SCREEN 9: LINE (0, 0)-(639, 349), 12, BF            ' EGA +„    PRINT "Screen 9"„    X1 = 0: Y1 = 0: X2 = 639: Y2 = 349„    CALL HSSaveScreen(ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„„    SCREEN 11: Red& = 50: Green& = 30: Blue& = 10       ' VGA +„    Colr& = 65536 * Blue& + 256& * Green& + Red&„    PALETTE 1, Colr&: LINE (0, 0)-(100, 100), 1, BF„    PRINT "Screen 11"„    X1 = 0: Y1 = 0: X2 = 100: Y2 = 100„    CALL HSSaveScreen(ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„„    SCREEN 13: Pal = 0                                  ' VGA +„    FOR X = 0 TO 318 STEP 20„        Red& = RND(1) * 63: Green& = RND(1) * 63: Blue& = RND(1) * 63„        Colr& = 65536 * Blue& + 256& * Green& + Red&„        PALETTE Pal, Colr&„        LINE (X, 0)-(X + 19, 75), Pal, BF„        Pal = Pal + 1„    NEXT„    FOR X = 0 TO 318 STEP 20„        Red& = RND(1) * 63: Green& = RND(1) * 63: Blue& = RND(1) * 63„        Colr& = 65536 * Blue& + 256& * Green& + Red&„        PALETTE Pal, Colr&„        LINE (X, 76)-(X + 19, 150), Pal, BF„        Pal = Pal + 1„    NEXT„    FOR X = 0 TO 318 STEP 20„        Red& = RND(1) * 63: Green& = RND(1) * 63: Blue& = RND(1) * 63„        Colr& = 65536 * Blue& + 256& * Green& + Red&„        PALETTE Pal, Colr&„        LINE (X, 151)-(X + 19, 199), Pal, BF„        Pal = Pal + 1„    NEXT„    PRINT "Screen 13"„    X1 = 0: Y1 = 0: X2 = 319: Y2 = 199„    CALL HSSaveScreen(ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„    NumScreens = ScrNum„    CLS : SCREEN 1: SCREEN 0: WIDTH 80„„    ScrNum = 3: CALL HSRestoreScreen(ScreenFile$, 80, 80, MonType, ScrNum)„    DO: A$ = INKEY$: LOOP UNTIL LEN(A$)„    ScrNum = 6: CALL HSRestoreScreen(ScreenFile$, 80, 80, MonType, ScrNum)„    DO: A$ = INKEY$: LOOP UNTIL LEN(A$)„„    DO„        CLS„        ScrNum = INT(RND * NumScreens) + 1: X1 = 0: Y1 = 0„        CALL HSRestoreScreen(ScreenFile$, X1, Y1, MonType, ScrNum)„„        DO: A$ = INKEY$: LOOP UNTIL LEN(A$)„    LOOP UNTIL A$ = CHR$(27)„„    SCREEN 0: WIDTH 80: CLS : END„„    ' Good candidate for assembly„SUB HSIncAddr (DSeg, DAddr, Num)„    IF CLNG(DAddr) + Num > 32751& THEN„        DAddr = DAddr - 32752& + Num„        DSeg = DSeg + 2047„        DEF SEG = DSeg„    ELSE„        DAddr = DAddr + Num„    END IF„END SUB„„SUB HSRestoreScreen (ScreenFile$, X1, Y1, MonType, ScrNum)„    F = FREEFILE„    OPEN ScreenFile$ FOR BINARY AS F„    IF LOF(F) = 0 THEN CLOSE F: EXIT SUB„    SEEK F, LOF(F) - 1„    Z$ = "  ": GET F, , Z$: NumScreens = CVI(Z$)„    REDIM Scrs(1 TO NumScreens) AS HSDefScrsType„    SeekPos& = LOF(F) - LEN(Scrs(1)) * NumScreens - 1„    SEEK F, SeekPos&„    FOR i = 1 TO ScrNum„        GET F, , Scrs(i)„    NEXT„„    SEEK F, Scrs(ScrNum).Offset„    DimSize = Scrs(ScrNum).RLLBytes \ 4 + 1„    REDIM RLL&(1 TO DimSize)„    Z$ = "    "„    FOR i = 1 TO DimSize„        GET F, , Z$: RLL&(i) = CVL(Z$)„    NEXT„„    IF Scrs(ScrNum).ScrMode = 0 THEN WIDTH 80„    SCREEN Scrs(ScrNum).ScrMode„    IF Scrs(ScrNum).ScrMode > 10 THEN„        SELECT CASE Scrs(ScrNum).ScrMode„            CASE 11: NumPal = 2„            CASE 12: NumPal = 16„            CASE 13: NumPal = 256„        END SELECT„        DIM Pal(1 TO NumPal) AS STRING * 3„        FOR i = 1 TO NumPal„            GET F, , Pal(i)„        NEXT„        DIM InRegs AS RegTypeX„        DIM OutRegs AS RegTypeX„        InRegs.AX = &H1012„        InRegs.BX = 0„        InRegs.CX = NumPal„        InRegs.ES = VARSEG(Pal(1))„        InRegs.DX = VARPTR(Pal(1))„        CALL INTERRUPTX(&O10, InRegs, OutRegs)„    END IF„    CLOSE F„„    DimSize = Scrs(ScrNum).ActualBytes \ 4 + 1„    REDIM Store&(1 TO DimSize)„„    ' Good candidate for assembly„    CALL HSRLLDeCompress(Store&(), RLL&(), Scrs(ScrNum).RLLBytes)„    ' Actually, the array could be decompressed directly to the screen„    ' without the need for the incremental Store&() array„„    IF X1 = 0 THEN X1 = Scrs(ScrNum).X1„    IF Y1 = 0 THEN Y1 = Scrs(ScrNum).Y1„    XDiff = Scrs(ScrNum).X2 - Scrs(ScrNum).X1„    YDiff = Scrs(ScrNum).Y2 - Scrs(ScrNum).Y1„    X2 = X1 + XDiff„    Y2 = Y1 + YDiff„„    IF Scrs(ScrNum).ScrMode > 0 THEN GOSUB RestoreGraphics: EXIT SUB„„    IF MonType THEN TSeg = &HB800 ELSE TSeg = &HB000„„    FSeg = VARSEG(Store&(1)): FAddr = VARPTR(Store&(1))„„    ' Good candidate for assembly„    NumCols = X2 - X1„    FOR l = Y1 TO Y2„        Addr = (X1 - 1) * 2 + (l - 1) * 160„        FOR i = Addr TO Addr + (NumCols * 2) STEP 2„            DEF SEG = FSeg„            Char = PEEK(FAddr): FAddr = FAddr + 1„            DEF SEG = TSeg„            POKE i, Char„        NEXT„    NEXT„    FOR l = Y1 TO Y2„        Addr = (X1 - 1) * 2 + 1 + (l - 1) * 160„        FOR i = Addr TO Addr + (NumCols * 2) STEP 2„            DEF SEG = FSeg„            Attr = PEEK(FAddr): FAddr = FAddr + 1„            DEF SEG = TSeg„            POKE i, Attr„        NEXT„    NEXT„    EXIT SUB„„RestoreGraphics:„    PUT (X1, Y1), Store&(1)„RETURN„END SUB„„    ' Good candidate for assembly„SUB HSRLLCompress (Store&(), RLL&(), ActualBytes&, RLLBytes&)„    RLLBytes& = 0&„    FSeg = VARSEG(Store&(1)): FAddr = VARPTR(Store&(1))„    TSeg = VARSEG(RLL&(1)): TAddr = VARPTR(RLL&(1))„    FOR i& = 1& TO ActualBytes&„        DEF SEG = FSeg„        Z = PEEK(FAddr)„        CALL HSIncAddr(FSeg, FAddr, 1)„        IF i& < ActualBytes& - 2 AND PEEK(FAddr) = Z AND PEEK(FAddr + 1) = Z AND PEEK(FAddr + 2) = Z THEN„            Num = 4„            i& = i& + 3„            CALL HSIncAddr(FSeg, FAddr, 3)„            DO UNTIL PEEK(FAddr) <> Z OR i& > ActualBytes&„                IF Num = 255 THEN EXIT DO„                Num = Num + 1„                i& = i& + 1„                CALL HSIncAddr(FSeg, FAddr, 1)„            LOOP„            RLLBytes& = RLLBytes& + 3„            DEF SEG = TSeg„            POKE TAddr, 0: CALL HSIncAddr(TSeg, TAddr, 1)„            POKE TAddr, Num: CALL HSIncAddr(TSeg, TAddr, 1)„            POKE TAddr, Z: CALL HSIncAddr(TSeg, TAddr, 1)„        ELSEIF Z = 0 THEN„            DEF SEG = TSeg„            POKE TAddr, 0: CALL HSIncAddr(TSeg, TAddr, 1)„            POKE TAddr, 0: CALL HSIncAddr(TSeg, TAddr, 1)„            RLLBytes& = RLLBytes& + 2„        ELSE„            DEF SEG = TSeg„            POKE TAddr, Z: CALL HSIncAddr(TSeg, TAddr, 1)„            RLLBytes& = RLLBytes& + 1„        END IF„„    NEXT„    ERASE Store&„END SUB„„    ' Good candidate for assembly„SUB HSRLLDeCompress (Store&(), RLL&(), RLLBytes&)„    FSeg = VARSEG(RLL&(1)): FAddr = VARPTR(RLL&(1))„    TSeg = VARSEG(Store&(1)): TAddr = VARPTR(Store&(1))„    FOR i& = 1 TO RLLBytes&„        DEF SEG = FSeg„        Z = PEEK(FAddr): CALL HSIncAddr(FSeg, FAddr, 1)„        IF Z = 0 THEN„            Z = PEEK(FAddr): CALL HSIncAddr(FSeg, FAddr, 1)„            i& = i& + 1&„            IF Z = 0 THEN„                DEF SEG = TSeg„                POKE TAddr, Z: CALL HSIncAddr(TSeg, TAddr, 1)„            ELSE„                Char = PEEK(FAddr): CALL HSIncAddr(FSeg, FAddr, 1)„                i& = i& + 1&„                DEF SEG = TSeg„                FOR j = 1 TO Z„                    POKE TAddr, Char: CALL HSIncAddr(TSeg, TAddr, 1)„                NEXT„            END IF„        ELSE„            DEF SEG = TSeg„            POKE TAddr, Z: CALL HSIncAddr(TSeg, TAddr, 1)„        END IF„    NEXT„    ERASE RLL&„END SUB„„SUB HSSaveScreen (ScreenFile$, X1, Y1, X2, Y2, MonType, ScrNum)„    F = FREEFILE„    OPEN ScreenFile$ FOR BINARY AS F„    IF LOF(F) THEN„        SEEK F, LOF(F) - 1„        Z$ = "  ": GET F, , Z$: NumScreens = CVI(Z$) + 1„        REDIM Scrs(1 TO NumScreens) AS HSDefScrsType„        SeekPos& = LOF(F) - LEN(Scrs(1)) * (NumScreens - 1) - 1„        SEEK F, SeekPos&„        FOR i = 1 TO NumScreens - 1„            GET F, , Scrs(i)„        NEXT„    ELSE„        NumScreens = 1„        REDIM Scrs(1 TO NumScreens) AS HSDefScrsType„        SeekPos& = 1„    END IF„    ScrNum = NumScreens„„    DEF SEG = 0: BIOSMode = PEEK(&H449): DEF SEG„    SELECT CASE BIOSMode„        CASE 3„            ScrMode = 0: NumBytes& = (X2 - X1 + 1) * 2 * (Y2 - Y1 + 1)„        CASE 4„            ScrMode = 1: BPP = 2: P = 1: GOSUB CalcBytes„        CASE 6„            ScrMode = 2: BPP = 1: P = 1: GOSUB CalcBytes„        CASE 13„            ScrMode = 7: BPP = 1: P = 4: GOSUB CalcBytes„        CASE 14„            ScrMode = 8: BPP = 1: P = 4: GOSUB CalcBytes„        CASE 16„            ScrMode = 9: BPP = 1: P = 4„            GOSUB CalcBytes  ' P = 2 for 64K EGA„        CASE 15„            ScrMode = 10: BPP = 1: P = 2: GOSUB CalcBytes„        CASE 17„            ScrMode = 11: BPP = 1: P = 1„            GOSUB CalcBytes: NumPal = 2„        CASE 18„            ScrMode = 12: BPP = 1: P = 4„            GOSUB CalcBytes: NumPal = 16„        CASE 19„            ScrMode = 13: BPP = 8: P = 1„            GOSUB CalcBytes: NumPal = 256„    END SELECT„„    DimSize = NumBytes& \ 4 + 1„    REDIM Store&(1 TO DimSize)„    TSeg = VARSEG(Store&(1)): TAddr = VARPTR(Store&(1))„    ActualBytes& = 0&„„    IF ScrMode > 0 THEN GOSUB GetGraphics: GOTO SaveIt„„    IF MonType THEN FSeg = &HB800 ELSE FSeg = &HB000„„    ' Good candidate for assembly„    NumCols = X2 - X1„    FOR l = Y1 TO Y2„        Addr = (X1 - 1) * 2 + (l - 1) * 160„        FOR i = Addr TO Addr + (NumCols * 2) STEP 2„            DEF SEG = FSeg„            Char = PEEK(i)„            DEF SEG = TSeg„            POKE TAddr, Char„            TAddr = TAddr + 1„            ActualBytes& = ActualBytes& + 1&„        NEXT„    NEXT„    FOR l = Y1 TO Y2„        Addr = (X1 - 1) * 2 + 1 + (l - 1) * 160„        FOR i = Addr TO Addr + (NumCols * 2) STEP 2„            DEF SEG = FSeg„            Attr = PEEK(i)„            DEF SEG = TSeg„            POKE TAddr, Attr„            TAddr = TAddr + 1„            ActualBytes& = ActualBytes& + 1&„        NEXT„    NEXT„„SaveIt:„    DimSize = ActualBytes& \ 4& + 4096      ' Extra 4K just in case„    REDIM RLL&(1 TO DimSize)„    CALL HSRLLCompress(Store&(), RLL&(), ActualBytes&, RLLBytes&)„„    Scrs(NumScreens).RLLBytes = RLLBytes&„    Scrs(NumScreens).ActualBytes = ActualBytes&„    Scrs(NumScreens).Offset = SeekPos&„    Scrs(NumScreens).X1 = X1„    Scrs(NumScreens).Y1 = Y1„    Scrs(NumScreens).X2 = X2„    Scrs(NumScreens).Y2 = Y2„    Scrs(NumScreens).ScrMode = ScrMode„    Scrs(NumScreens).MonType = MonType„„    FSeg = VARSEG(RLL&(1))„    FAddr = VARPTR(RLL&(1))„„    SEEK F, SeekPos&„„    SaveSize = RLLBytes& \ 4 + 1„    FOR i = 1 TO SaveSize„        Z$ = MKL$(RLL&(i))„        PUT F, , Z$„    NEXT„„    IF ScrMode > 10 THEN„        DIM Pal(1 TO NumPal) AS STRING * 3„        DIM InRegs AS RegTypeX„        DIM OutRegs AS RegTypeX„        InRegs.AX = &H1017„        InRegs.BX = 0„        InRegs.CX = NumPal„        InRegs.ES = VARSEG(Pal(1))„        InRegs.DX = VARPTR(Pal(1))„        CALL INTERRUPTX(&H10, InRegs, OutRegs)„        FOR i = 1 TO NumPal„            PUT F, , Pal(i)„        NEXT„    END IF„„    FOR i = 1 TO NumScreens„        PUT F, , Scrs(i)„    NEXT„„    Z$ = MKI$(NumScreens): PUT F, , Z$„    CLOSE F„    EXIT SUB„„GetGraphics:„    GET (X1, Y1)-(X2, Y2), Store&(1)„    ActualBytes& = NumBytes&„RETURN„CalcBytes:„    N& = ((X2 - X1 + 1) * BPP): NumBytes& = N& \ 8 - ((N& MOD 8) > 0)„    NumBytes& = NumBytes& * P * (Y2 - Y1 + 1) + 4„RETURN„END SUB„„Calvin French/Victor Yiu       FAST SPRITE ROUTINE            FidoNet QUIK_BAS Echo          Year of 1993           ASM, QB, PDS           166  5812     SPRITES.BAS ' Here is the self-extracting script that makes a QuickBasic/PDS callable„' OBJect file containing Sprite manipulation code in assembly.„' More information (source) on next page...„'„'>>> Page 1 of SPRITE.OBJ begins here. TYPE:BINAA TLEN:142„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"SPRITE.OBJ",4^6:Z&=142:?STRING$(50,177);„U"&O-%+%xuwnIyjje%3%%)%htij%+uzg#qnhGAg,%/%n%'(4&+_5%%%&.%uzyx%uw„U"ny%j%%%)Uor%%&%%zGZeC%5&>E/K1%o]*9Zk3]4e&p3\ZM5O&#Z%(+Zs-kXDXvc„U"u%/9eC6y[WqXRPB>e&X0hoC.6dd_lu[$df2_.-D,,C1%*AY'%(%C„END SUB„CLOSE:IF S=158AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„'>>> Page 1 of SPRITE.OBJ ends here. Last page. TCHK:158„„„'Here's the rewritten code that does exactly yours should do.„'I've included a sample program (posted after this message) to demonstate„'its capabilities (and what it should do).  BTW, it is FAST.  (At least„'fast enough on a 286 to be acceptable.)  It is on par with games from„'Apogee (DUKE Nukem, Cosmo's Adventure's...)!„„'BTW -- it is twice as fast as PUT (XOR/OR), but half the speed as PUT„'(PSET).„„'Performance on 100x100x256 sprites:„'    10MHz 8088:   7 updates per second     <--- pretty acceptable, considering„'   34MHz 80486: 150 updates per second          what it is...„„;=================================================================„; SimpleSprite v1.1 (SSPRITE.ASM) A simple sprite routine„; in asm to overlay GET format images.„;„; Calvin French, 1993  Victor Yiu, 2,348 B.C.„; Released into the Public Domain„;„; NOTE: This routine handles sprites of all sizes *****„;„; DECLARE SUB PutSprite (BYVAL x%, BYVAL y%, BYVAL imgseg%, BYVALimgoff%,_„;       BYVAL imgWid%, BYVAL imgHei%)„„CODE SEGMENT PARA 'PUBLIC'„    PUBLIC PutSprite„    ASSUME CS:CODE, DS:nothing, ES:nothing, SS:nothing„„BytesPerLine    EQU   320       ; ****** CHANGE to other number is needed„                                ; defaults to 320, for 320x200x256 res.„PutSprite PROC FAR„        PUSH BP         „        MOV BP, SP      ;set up stack frame„        PUSH DS„        PUSH SI„        PUSH DI         ; save BASIC's needed registers„„        LDS SI, WORD PTR SS:[BP+10] ; very fast segment/offset loading„                                    ; using LES/DS„        MOV AX, 0A000h„        MOV ES, AX          ; set up vid. mem. addr.„„        MOV AX, SS:[BP+14]  ; get Y address„        MOV BX, 320         ; *320„        MUL BX„        MOV DI, SS:[BP+16]  ; put X in SI„        ADD DI, AX          ; add rest -- result in SI„„        MOV DX, SS:[BP+6]   ; put height in DX„        MOV CX, SS:[BP+8]   ; put width in CX„        MOV BX, CX          ; save it in BX (width)„        MOV BP, DI          ; save screen pointer to BP„„        CLD                 ; look into the future„„    ; ============== main stuff starts„EVEN„NewPixel:„        LODSB               ; get byte [DS:SI] -> AL„        OR AL, AL           ; set flags„        JZ Skip             ; if zero (lesser common case), then jump„                            ; Jumping eats processor time and is BAD.„        STOSB               ; if not, write byte„        LOOP NewPixel       ; next loop„EVEN„EndOfLine:                  ; fell out of loop (end of line)„        MOV CX, BX          ; reset count for next loop„        ADD BP, BytesPerLine; increment next screen line„        MOV DI, BP          ; place offset into DI„        DEC DX              ; reduce height„        JZ OttaHere         ; finished?  YES!„        JMP SHORT NewPixel  ; nope -- continue...„EVEN„Skip:                       ; goes here to skip pixel„        INC DI              ; skip byte (don't do anything)„        LOOP NewPixel       ; next pix.„        JMP SHORT EndOfLine ; if end of loop, jump to handler„„    ; ============== closing procedure„EVEN „OttaHere:„        POP DI              ; restore registers„        POP SI„        POP DS„        POP BP„        RET 12              ; and remove 12 bytes of passed params.„PutSprite ENDP              ; from stack„    CODE ENDS„END„„„„'Here's the DEMOnstration program I made to show how FAST it is.„'BTW -- the asm., although acceptably fast, used jumps and no-in-line„'code. I don't know another way of doing it...  Good news is .. IT WORKS!„„'Here it goes:„' ========================„DEFINT A-Z„„DECLARE SUB PutSprite (BYVAL x%, BYVAL y%, BYVAL imgseg%, BYVAL imgoff%, BYVAL imgWid%, BYVAL imgHei%)„DIM ScreenCut%(5102)      '100x100x256„DIM ScreenCut2%(5102)„„SCREEN 13„„CLS„RANDOMIZE TIMER„FOR Z = 1 TO 50 STEP 3          ' make demo image to paste„    CIRCLE (50, 50), Z, Z + 16, , , 1.1„NEXT„„GET (0, 0)-STEP(100, 100), ScreenCut%„LOCATE 15, 1„PRINT "100x100x256 Color Circle"„PRINT "saved into memory."„PRINT : PRINT "Press any key to change backgrounds"„PRINT "and print sprite."„DO: LOOP UNTIL LEN(INKEY$)„„CLS„LINE (0, 0)-(319, 100), 5, BF„PutSprite x, 0, VARSEG(ScreenCut(0)), VARPTR(ScreenCut(0)) + 4, 101,101„LOCATE 15, 1„PRINT "WOW! Notice it DIDN'T destory the"„PRINT "background!"„PRINT : PRINT "Press a key to something cool!"„DO: LOOP UNTIL LEN(INKEY$)„„CLS : T! = TIMER: x = 0„LOCATE 24, 7„PRINT "thousand pixels per second!";„LOCATE 25, 6„PRINT "updates per second!   WWWOOOOWW!";„„DO UNTIL LEN(INKEY$)„    PutSprite RND * 219, RND * 79, VARSEG(ScreenCut(0)),VARPTR(ScreenCut(0)) + 4, 101, 101„    x = x + 1„    Z! = TIMER - T!„    IF Z! >= 1 THEN„        LOCATE 24, 1„        Z = INT(10 * x / Z!)„        PRINT Z;„        LOCATE 25, 1„        PRINT Z \ 10;„    END IF„LOOP„Scott Pessoni                  LED DISPLAYS                   FidoNet QUIK_BAS Echo          10-02-95 (18:36)       QB, QBasic, PDS        228  9481     LED-DISP.BAS'LED-DISP.BAS: Version 1.0„'Scott Pessoni - August 1995„'„'These are some subroutines that I wrote to simulate different„'kinds of LED Displays.  This is the first version so it's not filled„'with to meny fetures but they are handy at some time.  The Led„'Display does not handle negitive numbers or decimals.  You also have„'to watch out for LedBar so that the formula doesn't overflow with large„'numbers.  The Leds aren't very pritty yet but I'm working on digitizing„'some!  The Leds are handy for showing the status of something because„'all you have to do is change the the led state and not remember the„'X and Y locations!  Have fun and tell me what you think.  Look for„'version 2 some time.„'-----------------------------------------------------------------------„DECLARE SUB Leds (LedNumber%, Status%)„DECLARE SUB LedBar (Number%)„DECLARE SUB LedDisplay (Number%)„DEFINT A-Z„DIM SHARED DisplayLedX, DisplayLedY, LedDigits„DIM SHARED GraphLedX, GraphLedY, GraphElements, GraphNum„„SCREEN 13„„'This sets the default colors to use for the Bright/Dim led panals:„'Red Leds:„PALETTE 16, 65536 * 15 + 256 * 15 + 57„PALETTE 17, 65536 * 2 + 256 * 2 + 19„'Green Leds:„'PALETTE 16, 65536 * 15 + 256 * 57 + 15„'PALETTE 17, 65536 * 2 + 256 * 19 + 2„'----------------„„'-------- Led Digit Display Setup -----------------„DisplayLedX = 0 '|- Upper Left corner of„DisplayLedY = 0 '|  Led Digit display„LedDigits = 4   'Number of digits to have on display„'--------------------------------------------------„'-------- Led Bar Graph Display Setup -------------„GraphLedX = 0  '|- Upper Left corner of„GraphLedY = 20 '|  Led Graph display„GraphElements = 32  'Number of graph elements. Maximum 32„GraphNum = 1000 'The number when the graph is 100%„'--------------------------------------------------„'--------- Led Lights Setup -----------------------„TYPE Led„     x AS INTEGER '|- Upper Left corner of LED„     y AS INTEGER '|„     s AS INTEGER 'Current Status of LED (-1=Led not used 0=Off 1= On)„END TYPE„DIM SHARED Led(5) AS Led„„FOR Temp = 1 TO 5 'Make LEDs unused until you assign them„     Led(Temp).s = -1„NEXT Temp„„Led(1).x = 40: Led(1).y = 5: Led(1).s = 0  '|- Make some LED's„Led(2).x = 60: Led(2).y = 5: Led(2).s = 0  '|„'--------------------------------------------------„„'============ DEMO:„LedDisplay -1 '|- Any negitive number will Clear/Create display„LedBar -1     '|„Leds 0, 0     '   Draw all LED's at there set states„„FOR Count = 0 TO 1000„     LedDisplay Count   'Update Led Digits with current number„     LedBar Count       'Update Led Bar graph with current number„     SubCount = SubCount + 1                          '|- Every 10 numbers„     IF SubCount = 10 THEN Leds 1, -1: SubCount = 0   '|  toggle the Led„     IF Count > 500 THEN Leds 2, 1                    'After 500 turn Led ON„NEXT Count„„DO: LOOP UNTIL INKEY$ <> ""„END„„'LedBar: A simulated Led Bargraph„'-----------------------------------------------„'LedBar Number„'    Number = The current number you want to update the bar graph with„'-----------------------------------------------„SUB LedBar (Number)„„IF Number < 0 THEN 'If Negitive then blank Bar Graph„     FOR MakeGraph = 1 TO GraphElements * 2 STEP 2 'Make the Bar graph„          LINE (GraphLedX + MakeGraph, GraphLedY)-(GraphLedX + MakeGraph, GraphLedY + 5), 17„     NEXT MakeGraph„     EXIT SUB„END IF„„Elements = INT(Number * GraphElements / GraphNum) 'Calculate Number Elements„IF Elements > GraphElements THEN Elements = GraphElements 'Check limts„„'----------------- Draw Bar Graph --------------------------------„FOR MakeGraph = 1 TO Elements * 2 STEP 2 'Make the Bar graph (Lit)„LINE (GraphLedX + MakeGraph, GraphLedY)-(GraphLedX + MakeGraph, GraphLedY + 5), 16„NEXT MakeGraph„FOR MakeGraph = Elements * 2 + 1 TO GraphElements * 2 STEP 2 'Make the Bar graph (Dim„LINE (GraphLedX + MakeGraph, GraphLedY)-(GraphLedX + MakeGraph, GraphLedY + 5), 17„NEXT MakeGraph„'------------------------------------------------------------------„END SUB„„'LedDisplay: Generates a simulated Digital Led Display.„'------------------------------------------------------------„'LedDisplay (Number)„'    Number = The number you want to display on the Digital Display„'------------------------------------------------------------„SUB LedDisplay (Number%)„IF Number < 0 THEN  'Setup Led Display panel„     FOR PlotX = DisplayLedX TO DisplayLedX + ((LedDigits - 1) * 8) STEP 8„          '----------- One LED Matrix digit --------------------„          LINE (PlotX + 1, DisplayLedY)-(PlotX + 5, DisplayLedY), 17„          LINE (PlotX, DisplayLedY + 1)-(PlotX, DisplayLedY + 5), 17„          LINE (PlotX + 6, DisplayLedY + 1)-(PlotX + 6, DisplayLedY + 5), 17„          LINE (PlotX + 1, DisplayLedY + 6)-(PlotX + 5, DisplayLedY + 6), 17„          LINE (PlotX, DisplayLedY + 7)-(PlotX, DisplayLedY + 11), 17„          LINE (PlotX + 6, DisplayLedY + 7)-(PlotX + 6, DisplayLedY + 11), 17„          LINE (PlotX + 1, DisplayLedY + 12)-(PlotX + 5, DisplayLedY + 12), 17„          '------------------------------------------------------„     NEXT PlotX„     EXIT SUB„END IF„„Number = FIX(Number) 'Get rid of the decimals incase there are some„Number = VAL(LEFT$(STR$(Number), LedDigits + 1)) 'Chop Number to LED size„„PlotX = DisplayLedX„„IF LEN(STR$(Number)) - 1 < LedDigits THEN  'Clear Unused digits„     FOR ClearEmptyDigits = 1 TO LedDigits - (LEN(STR$(Number)) - 1)„     LINE (PlotX + 1, DisplayLedY)-(PlotX + 5, DisplayLedY), 17„     LINE (PlotX, DisplayLedY + 1)-(PlotX, DisplayLedY + 5), 17„     LINE (PlotX + 6, DisplayLedY + 1)-(PlotX + 6, DisplayLedY + 5), 17„     LINE (PlotX + 1, DisplayLedY + 6)-(PlotX + 5, DisplayLedY + 6), 17„     LINE (PlotX, DisplayLedY + 7)-(PlotX, DisplayLedY + 11), 17„     LINE (PlotX + 6, DisplayLedY + 7)-(PlotX + 6, DisplayLedY + 11), 17„     LINE (PlotX + 1, DisplayLedY + 12)-(PlotX + 5, DisplayLedY + 12), 17„     PlotX = PlotX + 8„     NEXT ClearEmptyDigits„END IF„„„FOR PlotDigit = 1 TO LEN(STR$(Number)) - 1 'Plot each number to a LED„„WorkDigit$ = MID$(STR$(Number), PlotDigit + 1, 1) 'Get 1 Digit„„SELECT CASE WorkDigit$ 'Find and select which elements to turn on„     CASE "0"„          E1 = 16: E2 = 16: E3 = 16: E4 = 17: E5 = 16: E6 = 16: E7 = 16„   „     CASE "1"„          E1 = 17: E2 = 17: E3 = 16: E4 = 17: E5 = 17: E6 = 17: E7 = 16„  „     CASE "2"„          E1 = 17: E2 = 16: E3 = 16: E4 = 16: E5 = 16: E6 = 16: E7 = 17„  „     CASE "3"„          E1 = 17: E2 = 16: E3 = 16: E4 = 16: E5 = 17: E6 = 16: E7 = 16„  „     CASE "4"„          E1 = 16: E2 = 17: E3 = 16: E4 = 16: E5 = 17: E6 = 17: E7 = 16„ „     CASE "5"„          E1 = 16: E2 = 16: E3 = 17: E4 = 16: E5 = 17: E6 = 16: E7 = 16„  „     CASE "6"„          E1 = 16: E2 = 17: E3 = 17: E4 = 16: E5 = 16: E6 = 16: E7 = 16„  „     CASE "7"„          E1 = 17: E2 = 16: E3 = 16: E4 = 17: E5 = 17: E6 = 17: E7 = 16„  „     CASE "8"„          E1 = 16: E2 = 16: E3 = 16: E4 = 16: E5 = 16: E6 = 16: E7 = 16„  „     CASE "9"„          E1 = 16: E2 = 16: E3 = 16: E4 = 16: E5 = 17: E6 = 17: E7 = 16„END SELECT„'Plot the LEDs to the screen------------------------„LINE (PlotX, DisplayLedY + 1)-(PlotX, DisplayLedY + 5), E1„LINE (PlotX + 1, DisplayLedY)-(PlotX + 5, DisplayLedY), E2„LINE (PlotX + 6, DisplayLedY + 1)-(PlotX + 6, DisplayLedY + 5), E3„LINE (PlotX + 1, DisplayLedY + 6)-(PlotX + 5, DisplayLedY + 6), E4„LINE (PlotX, DisplayLedY + 7)-(PlotX, DisplayLedY + 11), E5„LINE (PlotX + 1, DisplayLedY + 12)-(PlotX + 5, DisplayLedY + 12), E6„LINE (PlotX + 6, DisplayLedY + 7)-(PlotX + 6, DisplayLedY + 11), E7„'--------------------------------------------------„PlotX = PlotX + 8„NEXT PlotDigit„END SUB„„'Leds: Updates Leds„'--------------------------------------------------------------------„'     Leds (LedNumber, Status)„'LedNumber = Led to change (0 to Setup/Update ALL LEDS)„'Status = -1 Flip/Flop State  0 Led Off  1 Led On„'---------------------------------------------------------------------„SUB Leds (LedNumber, Status)„„IF LedNumber = 0 THEN  'Update ALL Led's„     FOR MakeLeds = 1 TO 5„          IF Led(MakeLeds).s = 0 THEN  'Make dim Led's„               LINE (Led(MakeLeds).x, Led(MakeLeds).y)-(Led(MakeLeds).x + 2, Led(MakeLeds).y + 2), 0, BF„               PSET (Led(MakeLeds).x + 1, Led(MakeLeds).y + 1), 17„          ELSEIF Led(MakeLeds).s = 1 THEN 'Make Lit Led's„               LINE (Led(MakeLeds).x, Led(MakeLeds).y)-(Led(MakeLeds).x + 2, Led(MakeLeds).y + 2), 17, BF„               PSET (Led(MakeLeds).x + 1, Led(MakeLeds).y + 1), 16„          END IF„     NEXT MakeLeds„     EXIT SUB„END IF„„IF Status = -1 THEN 'Flip/Flop the state of the Led.„     IF Led(LedNumber).s = 1 THEN Led(LedNumber).s = 0 ELSE Led(LedNumber).s = 1„ELSE       'Assign Led's Status if not Flip/Flop„     Led(LedNumber).s = Status„END IF„        „'---- Update current status of the selected LED„IF Led(LedNumber).s = 0 THEN 'Display Led OFF„     LINE (Led(LedNumber).x, Led(LedNumber).y)-(Led(LedNumber).x + 2, Led(LedNumber).y + 2), 0, BF„     PSET (Led(LedNumber).x + 1, Led(LedNumber).y + 1), 17„ELSEIF Led(LedNumber).s = 1 THEN 'Display Led ON„     LINE (Led(LedNumber).x, Led(LedNumber).y)-(Led(LedNumber).x + 2, Led(LedNumber).y + 2), 17, BF„     PSET (Led(LedNumber).x + 1, Led(LedNumber).y + 1), 16„END IF„„END SUB„„Dave Navarro, Jr.              PB FADING ROUTINE              dave@powerbasic.com            Unknown Date           PB                     71   1683     PBFADE.BAS  $CPU 8086                 ' program works on any CPU„$OPTIMIZE SIZE            ' make smallest possible executable„$COMPILE UNIT             ' compile to a unit (PBU)„$DEBUG MAP OFF            ' turn off map file generation„$DEBUG PBDEBUG OFF        ' don't include pbdebug support in our executable„$LIB ALL        OFF       ' turn off all unused PowerBASIC libraries„$ERROR ALL      OFF       ' turn off bounds checking„„DEFINT A-Z                ' default all variables to integers for maximum„                          ' speed and minimum size„„%FLAGS = 0„%AX = 1„%BX = 2„%CX = 3„%DX = 4„%SI = 5„%DI = 6„%BP = 7„%DS = 8„%ES = 9„„SHARED Target$„„SUB FadeOut() PUBLIC„  IF LEN( Target$ ) = 0 THEN„    Target$ = STRING$( 765, 0 )„    REG %AX, &H1017„    REG %BX, 0„    REG %CX, 255„    REG %ES, STRSEG( Target$ )„    REG %DX, STRPTR( Target$ )„    CALL INTERRUPT &H10„  END IF„  FOR J% = 1 TO 32„    CALL FadeDAC( -4 )„  NEXT J%„END SUB„„SUB FadeIn() PUBLIC„  IF LEN( Target$ ) = 0 THEN„    EXIT SUB„  END IF„  FOR J% = 1 TO 32„    CALL FadeDAC( 4 )„  NEXT J%„END SUB„„SUB FadeDAC( Inc% ) PRIVATE„  LOCAL Buff$, N%, K%„  Buff$ = STRING$( 765, 0 )„  REG %AX, &H1017„  REG %BX, 0„  REG %CX, 255„  REG %ES, STRSEG( Buff$ )„  REG %DX, STRPTR( Buff$ )„  CALL INTERRUPT &H10„  FOR J% = 1 TO LEN( Buff$ )„    N% = ASC( MID$( Buff$, J%, 1 )) + Inc%„    IF N% < 0 THEN N% = 0„    K% = ASC( MID$( Target$, J%, 1 ))„    IF N% > K% THEN N% = K%„    MID$( Buff$, J%, 1 ) = CHR$( N% )„  NEXT J%„  REG %AX, &H1012„  REG %BX, 0„  REG %CX, 255„  REG %ES, STRSEG( Buff$ )„  REG %DX, STRPTR( Buff$ )„  CALL INTERRUPT &H10„END SUB„Earl Montgomery                IMAGE MAKER                    FidoNet QUIK_BAS Echo          09-29-95 (22:21)       QB, PDS                174  10697    IMAGE.BAS   '>>> Page 1 of IMAGEMKR.ZIP begins here. TYPE:BINAA TLEN:7669„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"IMAGEMKR.ZIP",4^6:Z&=7669:?STRING$(50,177);„U"%up()%9%%%#-%7f.RDI5(0Wr&%%%)k%%%/%%%%ht%qtwx%Sgns*fhfoB<e„U"9U/n/D8p??d?[H)TIGzm-,c3e.[n$Q1Ps(1BK7jJR>,7B]1%J[Ug0?\gFG„U"MXG>^gid5*(cKT:\fp'NY24c3-BX]fcHi2=iEAjPpvT3-19*S8?VWjK^;&„U"l?VQ^W--]rGU6Ta,ZMGdpE,NOEKr7)-AjiGIj<?C2.Vz?>r17f+I1R^RIk„U"K[W<Z1h'/=Z\Is6J4QBBG8(m,<d[E<LH>JikaWdMS+=I3<#,H-ku>Z(DIA„U"6WAs6E*,aLqep>LuA:m#slfveu[mbZOn722/,ajj</9u*=<19*1S?P0,+Y„U"'<tN_[t=oxtCDk6X+ZY;h1NH+zFCvnK\2*$F$\&3RrlR)AKVWg,.B>edX&„U"W=SOrW^iWm1<19d*SMhT[sMsU6pOH5cRO0%%%%%#%%%O%nlz(%['%%d%%X„U"k%*up(%)9%%[%-%0B+bDd9]J,2#/%%u%C%%1%%%%n%rflj%rpwS[gfx.h(„U"<BTo16w'j>vV&Kdnsmf[7KLOpKC3Gj/Zv#mcph<4Cs*JaEX\aqcmCYekdZ„U"[*e7-toM2/enq0*THcQ,RQ;i*d]D['VUn(RXC5vL\EV0XrO:P:EF/YTlw4„U"NiHh:LgHUnDQJ:-rS*&od&BwL$;S(0[,e%ByP8M37YkWNSjDw-#^4ExH$;„U"mK7)m;R[^1[X&.tL][t$bOt2'et'EunS]c%F-keWeIf9:]xPCAQtU[KbG[„U"%,_&>Q\8Yd9)U4>p3KI\Kd.bsZ.\+N(-X+QnCzX#T3-XE]iehaiI:k6?gX„U"MODr:wxiX*Bxh5*#$b&VGUBghp,('V+xSJ>fzO<WBAvHiT98e]^DMH7xaT„U"=+j%;<QeNQZ_/YM.7qB+5*3Y<Bm9&L=b<jrnRYZ(G/DzT;^C>OY:sHCAts„U"n%.uiUSR79Kk\m9^':n%'vUS1/*=bKalj<j.JovSXhC5m1RBYC?M[xJy6(„U"+gx#pRv_j.Ks/kL8G-VolZIf,eJI*8i.jQ?G+q6W[tqd9G8?GA]Gb#.ZC]„U"D7K<U&7Kt9N_&?3_,_;NL,PBpETV)^Asf1>ni1&k;4P>y<:.L?zN(a?P&9„U"mC_K3z1pY,H+/4W^Mh*R?U/Po*>PNVKVNVk](hfGZ<MGB3lIFA**JQ'bE,„U"'uMY:GttI[UWW0(d=l8:oBlvj(zN?%QPkJ?rxO>ae;gnQcRtwQ3JT'LSCF„U"*D-bNKnIPw.f++tUhVx1nH*44.a2SzD+tfj7YoNSO^O^UEVZ(D<D*r=8HD„U"B(%?aJaLjCS)%A#[%]AO<7:CoqlTCEnBN^o-p1-uV^aV8fw7W=<<Jk1,C-„U"o(B[co<T+ScBF1B%BZhQ&I6G]:&/iQtIvG]2BYiQ.J$G]<n/j%/AqjAAJi„U"<UyuCDh]H53lz:j-UhVY&0<Z[N/Aq-,X=JzrA-,,hYT(qa/T-T*:T0Td)T„U"Of2rG]RcVif+B&j6+vr18?ugNY-/PLQ:dmUgvE+;Ow/0BBUq<'j1sgUm2D„U"L>3>OApYeK84ehuv)\\8yA1PkU:9<%_YMQS<x*QutQ^vA0ji*UL\Pm)iy7„U"eZ5S8ig(5+0LuQ3djX/0j)f<b;Kl3<RWs)Hbh$imUJ8Z#K0;a\v[NFHB%?„U"m-NenO,qk51#aF=HCqkz0]i8r7l_W*L6FkhCB1H]KhhHEPN<9Vxr$'/u9]„U"]'COJ0zar_lu-4Rt73$*Y^[oLY#?UO1^eB%wS*8op//aHq9h[w+4j5]4Y$„U"4k-1<C9zTF0]zN]4)GnJ3B=jZ6WU0'JXNHZ3Oc'N*D/BLcZ0]CKa+5gBSY„U".(8iHG:tqu.95.7<zle.NI]W8p+;?MS?2x'Bbr41&l,2OiGjRQagp[hCOm„U"Q+[N_:BY^\pxDJ_dj]WfoOeAg4')j\D.=QE=BOEC5\;_S5YTt8Ao1ymO<,„U"vTX-_)m)#/E>//DW#cdq0T4pP;h0g=DEbX]RS-VX$il6#/G%Lx''LL+X3?„U"VBZex](#WHYtK2fs#w;#QloOLY+4tN7(P=3^H*9x^1NlBBM_.S=xPf9QpJ„U"qK,(V2]v2MUgPesnsLMpoi&U'=,vJZHxwMia8uciV#v\xWh^QI5cIqiDwy„U"uonCo>/OzaH%+&fyUXwg/CAmiKL$[c%=g_TOff^nS'5UYJL=5_[1saO/6j„U"s2?$>cvcBVZrYC-Pn0=BPTzX&<za=QG8Y,bR2WvouU;1<a=f:>WQh.*FKG„U"KWP,1//yy,BULfVR\&J<0A?dC[5uQ#C)i'))&.Z+d7&N?ZHgDU)GsT]z6P„U"MHHE-*U>J06x=5CB%zFx%5(1grCh(X%CT^]Yr81]dm^YGuEhbY*B/\W7hg„U"oJZgw)HkiQhHH(9Z&Zo/6FxGS-p98W<YN$vAemWzR]$ImAElGqDpE$lhqp„U"]qc)_77B=.CB]d;aj(:AP-o8kH]BPLYJ'Y(BN<\udZ+YvILXNd[^+=Yc<d„U"dcA42I+J%E:?7O6Q'QN8ITXJfN/983+GwSlUo*Y,?P1k_G#6vabI9GKWhC„U"MmYnocSbNxB>JW9+lU*jh4*h0U89i$r^s,V8U1Qtmh3+=$/[b=H?sAG^jv„U"=^]U,.vhu1E[+e3G,#+Q6.\OQQV8TOxRT6fHB7k5%I#q<*/5T=[1VS*a)G„U"LP?<]<c1XFXdm4gf1_A,3(NOer$g(Ac^NtZ;e:=zpR7oV;V]\YUh$A&V#p„U"dc=<3fvfw:s/Aar4-&AO0mr6eP=)m%Ks8mf(rFHJ#=kEb)e?0(eUVZ8+Or„U"R=2=uVrdVS/=9/rmBi^IAcKSRXC[.5RJDJi.;zA086FA,=WJ4Ub=w\K1wY„U"+[fpxgWT$i<ngg=Q)QX7VJ^H;?lq-nG']x%DcuPS>C6G1r;,YeI4)T6Qjo„U"*(9bh(nBI<qzj09Z>'S1DfQBkmW3o1u8Z07/M#1qubd/0(G7>pp61cwXbw„U"i5GCsl8^DB,O7a[\w][m<Me(sM9jnK8COLCh^#di3l\Gz6CHedPcgN3hLU„U"bM;?1_Zc7c%dBA&l:(66Hp.eB^JdlQPq>eM.oVAa/>N^V&=Xk0Jz0mBHXH„U"KL;a8.GDQDd0vFfH;KD7hGsLZRZA=B$(5&6bY4%Npb+?:,nEa4p'h40$9A„U")8&hiZ()1eEUkS/UHIN5;1(Q<gc)&7:]/Z)#,OY=6mA2:LC5+(Q8:iiZhS„U"]UY%>5aHFg0i?;WUY#C5K8QnrjLJ,rR[EE-\-)#YBbi[B(g#_WojL<JrRZ„U"(ECr-B';r&&^KVJIJV5ttz>LNK\n[8G8Ep&qZwTO.VqXnV[hb9FVnQ.0<U„U"tK4V_ulBU7h^%OVJLLV5vvl>Nz%N>cmshin4J76lv_7qFBT=,rFeneaR.W„U"e*q1qcU[^G)/&#B+-HkdKVeqZk9$>bFq3jEqW<S\;rXedC]Qa+BklRqym+„U"k[.7fATQg61,C=((2&m#hsQZ\,7hS3e'[jVT;>7rCZ>cDNEM:tS\NZ3iat„U"aYZ7TAlLUaLO1hC.]7f<vDv%IiB>&1;6./Y*Frk)iShJiP(>^p.?>N3ZZ%„U"r3F3n3A6:2.5N=&Y6Q4/LdOFTAKU_N*H<p^oIr;a'[%1#bkm'?]2n-,68<„U"VTH&JlK3j&lDslr^5b-t*Tl(H&vpn?Wq<^+Whu>QRaaq+W+cBTVX,ff=AJ„U",b-tMuJwI4(:=F)*yJ<sR[NV*<H(Dk..%[EFl#'?NP4nZxs3pBd\P^;>>g„U"q*HV[^8=d_Y7n3D2Y,6:;avH$qm$:Tg9FB:C&t7prB^By)OHv\qt&u$PZc„U":N?6;vFBcU9I1N^.q.?(Pw2%up()%9%%%I-%Kk7$D_G>caZ%%%%9&%%%/%„U"#%%r(%wjfi%Sgfx+xi4-?jmpxD?A1EmzU]^Lw?#D-lm0v5?M\'MAQ+LC:Q„U"wB1xBbw\Z9Ol.p:a8Bl9oZIx:Yb\ZwxlSY:ED(QCQ:+7lw9g1\OcMRlR+G„U",vE;'x%Ep&xEVb[dJvH-BLtn-:Fdm4&A?1/Yy?1\%u+RE_'ycJ'>k(Mdy/„U"zZY\huM0wxoo(%Kfl[bzYMhjgmJy&&q%.9+>#v&y:Sw5[^0I1cu1u?F2L&„U"ixrSo(N&m&wh$#?6'sVkLuP9W(T=I5?qoP0%r/]%.zAND488>xYg4mY5AY„U"?^[^'%%up(%)9%%#%-%'Am$Dk=CbBM[&%%6%&%%0%%%%r)(&wn%yjSg.fx„U"Dv3D=Qej9Vjqg(,lQI2I7sB*6<,Do]2XI'&i7_Frqf8sUL1rQ/87R<Ifye„U"j$Fg,HF(vAk*vW_tnW1T<&O;^8S>u0jP<7'/hGodvCT:gz.?[(/foEJ,J[„U"TjN_]$+Q9z3<pp$DPW?\OBKZ/(WC)]w^Z5CoP<rc\7MOi/MT%6)VJ(dmBd„U"szj):zMY=L^4eZ>8Ar%_>F9&sGMM3r(cDYuP78U($D)5ylSk60<0f'f[->„U"CQF_DFe>C*QgErE-_R3C[BQ\=ZZ?i:FJ8*mpUn/PS',4*kSnZRgYM5RDN-„U"BJ%]Ew9XxmawGjBvy#6[vQn45sBg&MYt<oTJ2I#oB$:jNjB+)=T>TjAmu2„U"%2Fe-Ao>Z)z<iD-Ns1,&Fdup%()9%%%%-%(OKbDlxSO-&9)%%''/%%%1%%„U"%%nrfl%jrpw%SithVT%X>BT[5MOTIN/Rt<mpUTP/C+PO>j%&$v7h2DaRHW„U"3%Jqpx,>#jG:aVYrxM;Fs%i,aJ.+q;(p\?4h7$X/w$igTu&bu[p^TU\>XK„U"<#;Oe(O;&0YrvGcV7jhir0fIREI;/Tck7eAN*w/:.r.4hfX/D_<97i^';D„U"Xe)hj8+T>&g9/*>V8&'#5j>0o:O1hvE?'E;yN>Eaat'Zf/2U#S;W[1XuSe„U"jCS?TM;E-VB]Ci/l:tp)1eJcQOC1X-S4.QG9$^_KQ5'>7Ex'O#i(P8I6Zk„U"L-YcE<Ct3't/xB]>jvSH;_Z('PD5^t7+(i;S%f&/Kja/o#(&-z&Pzl4iZW„U"9(v/nsN032x?n'N]IU/<.f9c&/mi2>[Vw-a_Ic&glIo0hK?C\B/OB>qm?[„U")cnvkpVSQK%y2x2/*zo#['HY$hbNQnS'\l<Vw;(+WGU/](bD)z(wtKHm''„U"v8RIDrXdC+/h,aRLsuBg#(f)Lz94*Z>P*656=jmxm((L?tCAp8dRiE\aaA„U"a(10.6Y#FKa(.>Av<Haq\TNm<(cNuJ%cET?Sjg1;3p](J:WL%bmek'0hc_„U"<I_,f6FdnWE9R3Jlr'</G#bU&niLjD3QuKz#4gO:G')zPM1l+Qx\4zEEV0„U">mJ%4$8jJa,fMC[uvHo;,]f_9Q<ts834\tJ''ormfHN\oB'/f1,VKia[(N„U"N+w(aS+J0DgHkaV4InL<lpXelVDiEuezEy>KvWl-<i<;:F6%hcQ\wV%A?&„U"y*Ij5RaGwL>__LdxcDEgkRowWbV5g<CL.yu28gW^7eI,]?iJp<y7eFxh)H„U"SW8Fp4i1W6lC0#Pbml6U)ELOiETeqAqi1y8l*KgK#0s9cs'JHh54kh<O0F„U"_8[s5<g(hB?aUU>22wyUXGSfo(kbZKG3\owh=D0Ewa=k.U;XlBi0+F]]Lh„U"JjXR&T,IS&/Vhc.0H,OZ*Zpo6JuD6\U\x.=1E2&BBL&I,LT>(OSOE[]q*H„U"]KKIdT_)K6G^SNr=BlT4V#B457O[A'K[JI'RFAAXXLwNCE^n1h&)zMCGQn„U";a-RuKEdsSud5e'pbKHMjTqvl+tIWBWSP,3O_ejGBjJ38-Oak]+j+/>oMs„U"B=XpbFjQsPK.k.SK>.I?o$N)_%ui([o/DA7c-*2HB^.?2^DS$_;0a=%Amx„U"5q4n[mc.?KU=:1nq6IDbH(6]IR[j($]Adxv\>uo56+98%9H#WQ[5c.Lz(g„U"c7LR2Lh0=u/;+%ilG]Dd0D79;/&QLc0oe$D[vFP-Q;Cc_*KB_&aZSh0sEn„U";>dGGj5nK='8Ou]Z_El[-lw]Wqm0&EoXd.U4_g.Cb3AI.,X;1d-Oaap-x-„U"DhniW5<-)EJbQo/e-q$R-CgPx+rP9nS<lLpN6tIKldTT6A:Zo4%DWpMoAf„U"VJz/Pb(]z:pZqRiiC0;FF<,]AWTe$\bIks'Zdup%()9%%%%-%(:HaDKu1P„U"G%d&%%&K*%%%/%%%%gzlr%fsSgRnsFc<*9<U:5UHMB.$=JOO1_1(4l_9G6„U"lui11L_aCgnEEDpTaYFD<h.Dr/MC=Qb_rJdsVL#/^4p1hN[3ivnDKjn+&)„U"2Q2d/gi4pE*['ijng*%4*OK_%6>E)\(8z%G;59VrBe&E6Gu#1G2c'YhXll„U"$bK*M(%uEuw9u)1-&H33Ph$b\xB<+/_]EX1(/X/8Vo<r=<SS<q4FP;xAGi„U"+0f7q)%$=+S%.bJU_Njk'd'dS'pE<Dl0vVU&J-nHg=++MVH0/gK+NZBZ)b„U"6NGSjJf#/3cB9qmefAM6IIX8qY4Xagn\(k+EAsQJ,I+7tEt(OS41\ci9q5„U"?G>Yk6IBFD;[7=iOrpf\Wr/d7x'wD8hzY=*?q-u^ZILtyu6o3m;'Hhd]4u„U"m6HlXa,sdm\u\AP#UHbr&.up(%)9%%%%-%:\HaDE[K'Jm%%%%%%7%%/%%%„U"%g%zlrf%sSif4yfff+7<E-#jX1j;=ilD<0Za9m159I:[l9OX0X#>py+g1m„U"HB)Mo?\rHAeXZGr?IrInAJR#/1p83CUsrfcr3'(k.\*CqiQe8sijIf1^'K„U"D8jPa?#HPgvJKr0CdPgN)Ac:azrfppMcrWZ.*aJ*-lOWl_HGaO_*s6MD[r„U"*-t]7Nuw(_KHv6igtvFf(Dh^gUSt_^3ch^>4tdu6X6goFTgKk>l##Gnnl)„U"J.a<Lt:xHS0vzLcgyn>Nu$l$gtfstjiqEn4<X:t8XsP3*u&8COZglt7P&D„U"Cxu4Fo00lT_=rx[P>tN88'l98M5%%up(%)9%%[%-%tAH\DquR<LL%%%%%%„U"7%%/%%%%u%flti%fSifsyNQJ+/<E1#*u,Hp6YvwKHRB;kg=3S-^CqCA%OA„U"ZPDOg[(M8ju];+*nn?gv,i_In99\X_Dqlzj0nJq^%b]pv\Xh<w;s9)HnOB„U"v%^cp2c\c$mu8hAlfs-(w\buKhbSu0tnvf7Sl$_l+x0PH7tBVRSH*Y<XO*„U"QZ&fio3,DpYCg$^-wcF4uq7GlM]^MMZuqXnsdQrxk.x.UZsL'pm-D2wl(x„U"MfrxL#hGNic5?xRO&Qjt6(Z#%i#K\8(NYpdXl,LhI(QxugW:$l2%%up()%„U"9%%%R-%tHR\Dq3:.&q%.%%K*%%%/%%%%uf%ltif%Sgns<Nb6sB<U9T*(#J„U"T5$K=mIE_E<T_3br9i-5fLRmW$*J;akICF2U:MvwNW/>c5&p(ANR_^w1Ht„U"sO=DwpM,N+sdLIiUnyri1f:_jKtbjJ)7CnsyF%Kgwi:HTlQC<+EA88$YBs„U";2mqagqKmLa_Q+AC7f)CY8Uns%+_68)>2012T=I&DgwQ4I>qhlh?J1d?Qa„U"HKo(ON;F2w6ujqGsGY(nchoM*ouYe,N$'[LgDLc4+iEa#D)S8aTLYJ/fN6„U">qMtjDrM,7_<GupBB/Ma<o0SqQcw*idj#43PF0GfU3-DO<Y90]esO'8H>u„U"LEt0f6%up()%9%%%#-%)ddbDq6(>Em)I%%o[%%%0%%%%qj%yyjw%xSgnXs„U"fS>.q#4As,iX<_,7Z#+v?7sHLJ8eHef:'qESC3&8IVq>.q?<PZ4)bH>=<4„U"5g9asi'EX5015-'Mqg7G3bnFI6s[i?K^jD5AJVia^:,)\e1OJLnSj5d>\B„U"Qq_mici?;h$jnBb7pW6vZ]ZWV<(%[i%%'idGxEL0*HfbxCmKw7Tu&RJjLA„U"E%f=1Hna7.QJxj(4e_T*J$(-PAtL$p9to4A#Ht'c:3xp,EpGYrAZv/IMPl„U"p<isEO4K,Wr/JP.^B(]i,qQRuW/+ydxT&D%xN]5(y#rOD$6b??qCFLqCE)„U"]VE:]fS<uwc)VqHewkJ9^pIJ\LcA,5T;AN%2[r/Y6FoJry?';I6R_<X0X=„U"kM'tkpzKx'R#B%2n[b.?+C8VZSJZ^[i+jF3HNmq+5C)]VcoN?ttQ?u3QL<„U"=dP1Ch8UhC)]:Vi.kll:vgNl]m==JpJHi4=C)o'V?t_:\J(BJn^u3Pg=NW„U"1^RDV2Ru2ouId58BqrSqj*Wmg?vQ?:vDVBm<B]/'6>pi?NapVDy3gxuRHO„U"hG4f#>mrMbThRqRU''yyZCGzJdsQvBm6e0h$4V3(?G'AyrqqRUEK+QJfRx„U"nhT\)0d7ez4ze$\x[N*ASj,K2jaJ<79fn2qHh:M3aD,YGi8.&3y4R0AryA„U"&)5%%%%%%%I3zawKVK>=->)4_lqhFx$t=V6nm8W&oiv35ue6VLcSqEp5\m„U"U#=9,Vl#/iT%c5bC3Z^6ghNj8K_;*71A[qkZfR[?oyfwkf;EG4G,U7$xC&„U"ur/0=-kH8?'5'lVCj%56+.3sb5LHoG++_uFm$1B,;AbC-fKH(Eh8'Q*uy<„U"Xi_WL5iSiBF4gJ0pMFBBNkiT]PtgVBLlqY'?<5AF9s6]/sokwo'($=ZpZ^„U"D>\s4RSBQUt*)iU>kh?FLKps8NP-E[zGQWu2E:il#JB;9eDt>N6gULLmj2„U"D)+.,lq;X$jJfjWSGnD:pGQU$9nt>[S>pF9S%Q&c8yZ'w'Nug8ljt\?0+K„U"8'tQu$nV9if>c5GY<+$;DY-wY\[OcAN-+dSmdT0dU'NOsWOn/B#\Smk#>r„U"ep&mZE1X'fk#Nn.?8aSsGAfsi>+xXS>y&v0MyX^C.iM%s,6?Hp\nVaZ'7V„U"J\APK2pGQU'PtDjvVNxW%MValp[X$w>Js=*Z(Ks0kPu8''mVlF%<cN$[Xc„U"Av?SMF$5e]:%?(hH$OERNu(HpOsU-N_NxY^]ehiAO0CdrGQUeisb&,Vf>h„U"b1wz9*lca#&kpF^E[N)b-S50>\(<5]4d(b9P;aHul/_T#TE+Ae_O/BxYJm„U"HUuV.^=^hNcD6:H,&r:I(I/9#EC%k5%%%%%%%%%%%%%%%%%%%%%%%%%%%%„U"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%^%oVw%+up&%'9%9%%%%-.%7fR(DI5„U"0&Wr&%%%)k%%%/%%%%%%%%%%%E%%%%%%%%%h%tqtw%xSgn%sup&%'9%9%%„U"%%-=%0+b:Dd]J',2/%(%uC%%%1%%%%%%%%%&%E#%%%D%&%%n%rflj%rpwS„U"%gfxu%p&'9%%9%%#%-%K\k$D_pGcaZ%%%%9%&%%/%%%%%%%%%&%%E%%+%%„U"0%.%r(w%jfiS%gfxu%p&'9%%9%%#%-%'Am$Dk=CbBM[&%%6%&%%0%%%%%%„U"%%%&%%E%%+%.1%I%r(&%wnyj%Sgfx%up&'%9%9%%%%-%(OKbDlxSO-&9)%„U"%''/%%%1%%%%%%%%%&%E%%%%+3%%%nr%fljr%pwSi%thup%&'9%%9%%%#-„U"%:H7aDu1)PGd&.%%K*%%%/%%%%%%%%%%%%E%%%&i7%%%gzlr%fsSg%nsup„U"%&'9%%9%%%#-%:H7aDEK7'Jm%%%%%7%%%/%%%%%%%%%%%%E%%%%&9%%%gz„U"lr%fsSi%fyup%&'9%%9%%%R-%tHd\DqR?<LL%%%%%7%%%/%%%%%%%%%%%%„U"E%%%%B:%%%uflt%ifSi%fyup%&'9%%9%%%R-%tHR\Dq3:.&q%.%%K*%%%/„U"%%%%%%%%%%%%E%%%%=;%%%uflt%ifSg%nsup%&'9%%9%%%#-%)ddbDq6(>„U"Em)I%%o[%%%0%%%%%%%%%%%%E%%%%]<%%%qjyy%jwxS%gnsu%p*+%%%%%/„U"%%/%[#'%%x%#%%%%%„END SUB„CLOSE:IF S=73AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243 ELSE ?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Joshua Dickerson               3D ROTATING CUBE               FidoNet QUIK_BAS Echo          Unknown Date           QB, QBasic, PDS        164  5029     3DCUBE.BAS  'By Joshua Dickerson„'„DECLARE SUB InitProgram ()„DECLARE SUB MainLoop ()„DECLARE SUB Calc3D ()„DECLARE SUB Rotation ()„DECLARE SUB DrawObject ()„'„DIM SHARED Lines, World(500, 3)„DIM SHARED X, Y, Z, sX, sY, Xa, Ya, Za, sXs, sYs, D„DIM SHARED R1, R2, R3, Sr1, Sr2, Sr3, Cr1, Cr2, Cr3, mX, mY, mZ, Eye„'„READ Lines„FOR I = 1 TO Lines„FOR J = 1 TO 3„ READ World(I, J)„NEXT„NEXT„'„InitProgram„MainLoop„SCREEN 0„END„'„'CUBE LOOKING THINGY„DATA 24„DATA -90,-90,-90, -90,-90,90,     -90,-90,90,    90,-90,90„DATA  90,-90,90,   90,-90,-90,     90,-90,-90,  -90,-90,-90„DATA -90,90,-90,  -90,90,90,      -90,90,90,    90,90,90„DATA  90,90,90,    90,90,-90,      90,90,-90,  -90,90,-90„DATA -90,90,-90,  -90,-90,-90,    -90,-90,90,  -90,90,90„DATA  90,90,90,    90,-90,90,      90,-90,-90,  90,90,-90„'„'DIAMOND LOOKING THINGY„'DATA 26„'DATA -90,0,-90,   -90,0,90,       -90,0,90,    90,0,90„'DATA  90,0,90,     90,0,-90,       90,0,-90,  -90,0,-90„'DATA -90,0,-90,    0,90,0,        -90,0,90,    0,90,0„'DATA  90,0,90,     0,90,0,         90,0,-90,   0,90,0„'DATA -90,0,-90,    0,-25,0,       -90,0,90,    0,-25,0„'DATA  90,0,90,     0,-25,0,        90,0,-90,   0,-25,0„'DATA  0,-25,0, 0,90,0„'„'EMPEROR ANDROSS (STAR FOX)„DATA 142„'„'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒNOSEƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„DATA  5,-4,10,    -5,-4,10,       -5,-4,10,   -5,-25,10„DATA -5,-25,10,    0,-52,0,        0,-52,0,    5,-25,10„DATA  5,-25,10,    5,-4,10,        5,-25,10,   10,-18,2„DATA  10,-18,2,    10,2,2,         10,2,2,     5,-4,10„DATA  10,2,2,     -10,2,2,        -10,2,2,    -5,-4,10„DATA -10,2,2,     -10,-18,2,      -10,-18,2,  -5,-25,10„'„'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒMOUTHƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„DATA -10,2,2,     -28,26,0,       -10,2,2,     0,14,5„DATA  0,14,5,      10,2,2,         28,26,0,    10,2,2„DATA -28,26,0,     0,14,5,         0,14,5,     28,26,0„DATA -28,26,0,     0,18,6,         0,18,6,     28,26,0„DATA -28,26,0,     0,31,6,         0,31,6,     28,26,0„DATA  0,14,5,      0,18,6,        -28,26,0,    0,36,5„DATA  0,36,5,      28,26,0,        0,31,6,     0,36,5„DATA -8,47,0,      0,36,5,         0,36,5,     8,47,0„'„'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒOUTLINE OF FACEƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„DATA  0,-52,0,    -26,-47,0,      -26,-47,0,  -37,-32,0„DATA -37,-32,0,   -37,-6,0,       -37,-6,0,   -28,26,0„DATA -28,26,0,    -8,47,0,        -8,47,0,     8,47, 0„DATA  8,47,0,      28,26,0,        28,26,0,    37,-6,0„DATA  37,-6,0,     37,-32,0,       37,-32,0,   26,-47,0„DATA  26,-47,0,    0,-52,0„'„'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒFOREHEADƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„DATA  0,-52,0,    -23,-33,10,     -23,-33,10, -5,-25,10„DATA -26,-47,0,   -23,-33,10,     -37,-32,0,  -23,-33,10„DATA -37,-18,0,   -23,-33,10,     -10,-18,2,  -23,-33,10„DATA  0,-52,0,     23,-33,10,      23,-33,10,  5,-25,10„DATA  26,-47,0,    23,-33,10,      37,-32,0,   23,-33,10„DATA  37,-18,0,    23,-33,10,      23,-33,10,  10,-18,2„'„'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒEYES + CHEEKSƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„DATA -37,-18,0,   -23,-26,12,     -23,-26,12, -10,-18,2„DATA -37,-18,0,   -23,-13,10,     -23,-13,10, -10,-18,2„DATA -37,-18,0,   -23,-17,12,     -23,-17,12, -10,-18,2„DATA -23,-33,10,  -23,-26,12,     -23,-17,12, -23,-13,10„DATA -10,2,2,     -23,-13,10,     -23,-13,10, -37,-6,0„DATA  37,-18,0,    23,-26,12,      23,-26,12,  10,-18,2„DATA  37,-18,0,    23,-13,10,      23,-13,10,  10,-18,2„DATA  37,-18,0,    23,-17,12,      23,-17,12,  10,-18,2„DATA  23,-33,10,   23,-26,12,      23,-17,12,  23,-13,10„DATA  10,2,2,      23,-13,10,      23,-13,10,  37,-6,0„„'„SUB Calc3D„'„X = -1 * X: Xa = Cr1 * X - Sr1 * Z: Za = Sr1 * X + Cr1 * Z„X = Cr2 * Xa + Sr2 * Y: Ya = Cr2 * Y - Sr2 * Xa: Z = Cr3 * Za - Sr3 * Ya„Y = Sr3 * Za + Cr3 * Ya: X = X + mX: Y = Y + mY: Z = Z + mZ: sX = D * X / Z„sY = D * Y / Z„'„END SUB„'„SUB DrawObject„'„Rotation„FOR I = 1 TO Lines STEP 2„X = World(I, 1)„Y = World(I, 2)„Z = World(I, 3)„Calc3D„sXs = sX: sYs = sY„'„X = World(I + 1, 1)„Y = World(I + 1, 2)„Z = World(I + 1, 3)„Calc3D„'„LINE (sXs, sYs)-(sX, sY), Eye„NEXT„'„END SUB„'„SUB InitProgram„'„SCREEN 9, 1, 0, 1„WINDOW (-200, -150)-(200, 150)„VIEW (8, 9)-(632, 341), 0, 15„CLS                    'PAGE 0„'„SCREEN 9, 1, 1, 0„WINDOW (-200, -150)-(200, 150)„VIEW (8, 9)-(632, 341), 0, 15„CLS                    'PAGE 1„'„D = 1200      'View point and rotation values„mZ = -1500„mX = -5„R1 = 0„R2 = 0„R3 = .3„'„END SUB„'„SUB MainLoop„'„WHILE INKEY$ = ""„  'R1 = R1 + RND(1) * .05: IF R1 > 6.28 THEN R1 = 0„  'R2 = R2 + RND(1) * .05: IF R2 > 6.28 THEN R2 = 0„  'R3 = R3 + RND(1) * .05: IF R3 > 6.28 THEN R3 = 0„  R1 = R1 + .1: IF R1 > 6.28 THEN R1 = 0„'  „  CLS : Eye = 7: DrawObject„  Page = ABS(Page = 0)           'Page switching is used to hide the drawing„  SCREEN 9, 1, 1 - Page, Page    'process so the image looks smooth.„WEND„'„END SUB„'„SUB Rotation„'„Sr1 = SIN(R1): Sr2 = SIN(R2): Sr3 = SIN(R3)„Cr1 = COS(R1): Cr2 = COS(R2): Cr3 = COS(R3)„'„END SUB„Earl Montgomery                VGA SCREEN CAPTURE TSR         EXECUTABLE                     Unknown Date           QB, QBasic, PDS        101  6519     VGACLIP.BAS 'VGACLIP.EXE„'It is a TSR that captures any 320*200*256 graphic screen along„'with the palettes in ONE Bsave file. Basic loader source to follow.„CLS:?STRING$(50,178):DEFINT A-Z 'Created by PostIt! 6.0„FOR A=0 TO 6:P(A)=2^A:NEXT:OPEN "B",1,"VGACLIP.EXE„T$="abcdefghijklmnopqrstuvwxyz":T$=T$+UCASE$(T$)+"0123456789#$„G"nPfIbK(zbaiaGga$$pib(bqdm(icaE*e(caq9aSd*r*Cb)ug*D*6b)qi*M*Xc)y„G"l)GW*hd)mn*2*Hd)Oo)W8+e)Kq)qfb)Ke)0s)Gob)cf)8u)qvb)Ff)Ww)WEb)bg„G")Sy*Mb)Ig)WA)qTb)Kh)yF)W#b*i)uG)Gcc)ti)GH)q(icaAaGiamcaI(maCca4„G"aWjaieaNaGyaCcaGaGlaihaUaGFa4caLaGn(ca5aqmaKdabcqoaKia5aGtaieaQ„G"bGqa4baGcaC(ka4baOambaOcWiaKkaBdGqaeCacbG4bieaVhGqaySacbWIdieaw„G"(Ra8baScqnaWkaGbaRamhaScqlaml(bWSaqba3caCaClakaqWaubacdqnaimaL(„G"ZaycaodGd(nax(0aWbavd//////////////////,GySz1rbnetjbfi(GKb)M//)„G"d/+8$$acbUW(u4A(qPjdaCca4A(qPjWeieaJQ(HQ(JY(hBGda8cc4YfaqPjdaWk„G"a4A(qPjdaWkaHY(JaCDdKEAaOP(ydaqPjcaimaqHly(LMo(OamcW1nq6$(Um(u4„G"A(qPPdcieaJcbaHcbaJkbaJaCDdKEeaGRz(LMm(RaOzvaicaP7(46haqPjdaWka„G"AwfaIaq6o(UqcauAY(ScGMvbGiaGRT(LMm(RaGR4(LMm(RaGlebaLMm(RaGRpba„G"fUu(uAY(N(Uu(uAQ(PcWOy(Uu(uAY(#cqOyaWiax3aP7(Ak(U(UofauAY(ScaUo„G"(u4A(qPjWaieaP3maAk(cbW$gOba$BJgaOjcaClaqPPcamlaqHlh(LMmaWjaGlE„G"bafUC(uAs(OcqUcaWkihfUW(uAc(bdauAI(5(u4ccaqPjdaCca4ccaqHlh(LMia„G"qo(fUcgauAI(5(u4ccaqPjdaCca4c6RqPzea8ja6E8aZaS7Pxba6M8aSdd5l6bj„G"a4ObQgGjiEqOK(qJsca98Va#noU(kuAgbaFcaUG(uZamu4Yq$ZinuAQ(UaGMmaW„G"NaOP(4caAUcacbGMPhGqaGRb(LMEbGqaOzvaic/4UnaoInJgWAa67i08cfc7tlm„G"nhYOUgaJaVlybSc20QuZHSB9a44WMSOhcaGJdBYIoicadgSclY#kHNOjXgGhhWO„G"hQgWVSpqUOaWmaZ$8RovUWaquldkSbqltnhsvlYUvxTOFgKOpypWI2HWImmop7Y„G"#a7mVCwm4WmTZ839GMgaW0a8VDiOjda4laR$YvbfKMkaq1aG1G5lGDHS6I2HWI0„G"jqkoyAab4aPbKus$Bd2dOjda4laj#qI$jW8K#LxDPmb(qv4EGdndrxlx1ISpi7b„G"D1XgGC)WIgPqJw9RMeaq2aqlpYKCZHSl(iNtlI9V4gWIxFuOQgWQlAecRUOrgSk„G"u5E(0cuZHKLCV4HJEOAalAfc0cuZH8HCGStWZvGXgGCa9SW20raT#0Ci$BNcAQ(„G"mdWxlwExkB(A6(ldW6IB1vE4ObSgGjk6aGait7#giaMOib8acDeWtc1nGrIlVbA„G"Q(qdWbJJGbmITJa$X8KU4WF8Lxlx1ISB1vlAhclsWI#zWIvymb$BCb$RPda4mai„G"wbIeSiYdO84nfuqAQ(vdWvlAhclsNal6Nbl2Naj6J2d81G5lGCVKyhP4GPbeGdK„G"gqsjD0rj#qI$jqu7eSDcSyWlI88KM1kiVt02jWIrVOYlAJ2dmpPlo8$2HGMk(Za„G"8VDgOPcaWmaF5vxkt)mdW5yG0buhiocSjHcjaMSOhscWOshqIEqDa6BYXgajalb„G"Gjm6GKaS$YZaCogiDa0DHJaVi2hAG0bCOhuhG#MmkKaysIEija7VmuEG72a4i2h„G"BaYbCeaFGLma$mavTi7lANblsNa3tHUGfqOSgWkqFSbZgW$$tBmGcBanhY$$$$$„G"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$d///aqvlYU„G"vx5YG#Wja$thchBaYbahaRlX$2zGMatGqaCSbihWBaSaW0zWxE1LYe(JoWdbl6f„G"cl#Hli6rVa4cI#4lalAebUmkSaSOrcuW(4YOUcGdFqlnnhsIEOkamAaRa4WbWIW„G"V#bGUyma6NgaSq8RHaOBLdGoNba7e$Qia6U6aOhzaWsXVocGUbpa6ggaSw8RKaO„G"71dG#Eba7f$Aja6kbbOdxaWgYVAcGUOqa6LfaSL8RNaOlweGUwbaRj$kka6IhbO„G"$uaWIYVMcGUysa6efaSj8RGaORAdGEobyXhhBaYb)Pl0$UySb7cW$7ZjutfLuvz„G"1vEyGlmAHSa4sIMqla4UnaoI9G#mB(qxm67i0lAsSbSFVqHaTr1Cij6XSbOjNfi„G"eaU8VlUcWGetGMaxGqaOVloAHSa4YIMqla7FWhF5vxAL1wy1PlgBWU(WWvTi7w5„G"XIEHWIFSW20jGJB7Oh8qWma7iWZMGVccGUQna6YcGCbnlc#6ha6IXaOxkaYrZSq„G"4RHaOBLdGoMai3jZoHVkcGURoa6lcGCAmlf#6ia6g8aO7haY1WSw4RKaO71dGEC„G"am3b4c(FSovqo7f#Aja6kbbO3faYX#SH4RMaOlkeGouai33ZwIVEcGUyra6dbGC„G"spRj#kka6IhbOBdaYv8SO4RPaOlMeGEkaihUF8VDi8VDgOPbfiea9)0Dk#E1LYe„G"(u0wtZHKyhmwKayrBjnhYWdYZ$1ja#dlZ$rpE0JBYoxq3a5VE8mITj7CKa1v$Ie„G"SitcOVjjEGjj#Ka7J7$$NibjsKaRd9#UaOp$c(0nKla6ZUa8FDi4IXg8l(S#mUa„G"Op6c(1TIht5sXEOk(#daB9bDi4cG#Wla$xheUySb$c(C6Y$E4haOFK$p7I$o8la„G"67Y$U4ha7df5G5Iog0la11aTc0SfK8Gl6yGVaqNby5Y$UiiaAAybcbGlgBWVaib„G"wpZPl#BGUa4Y$EyiaC6I$oOlaDUVYc(NU4Vb6cGl$7HIaWPl#7GUa05#kl(C6I$„G"gOlaU8VhocaNU4Vd6cqN7RS(WjG8daDeWde1TX#nJcu#tSl#BGUaWPl$7HKaWPl„G"#7GUa0jw0vU#U4Vb6cGl$7HKaWPl#7GUa05#kl(C6I$gOlaU8VhwcaNU4Vd6cqN„G"7RS(WjG8dqDoqltUySb8c(D6Y$UOj(Ypd39UlgBaVa8FN7ZPl$7HMa4IXgWl(OS„G"(WPl#BGUa4Y$E4jaC6YJgyladsSaU4Vd6cGl$BJTa05YC6I$gOlaU8VhIcaNU8O„G"b4cWGelGl#7GUa4Y$2GlaDU8#UaOp$c(1zG#U8VlMcGla6ZUa8pDY7IXg8l(WPl„G"$7HPaG#58$mavTi7wD1IEzWI3jWG#mB(uNa3tb6dcWIqZi2c5OW7iCDumdWlENa„„G"d6ZSbaqDcCpfF5vxkl(lENal6$IpmVP1P9IcV#3au1IStBunhYul6fclEXcsxNa„G"mQTJcBYIEWAa0cvZHKl(Goma4iWMSJhbaqDjaKJatBsnhICtG#kamx6ok8IEzGj„G"l#LaMC$f3h9w0cvZHSyWDPmbamLb0kvZHyYIh5$O#qWbBnShH6dboInG#)Av3a5„G"$XWdyW)KnJ6db4VU8KhMIGZaGMhMIeVoaMhM#WcI5GS$YamOpwh(1HdTV0Cij6b„G"qeWObcraTr1Cij6H1bSOhSgaTq1CilpOpwh(0rHhZS9HEyDa0cvZHuSfaraTA0C„G"iFSmJEOAalx1ISVOrgmQQb0LYcaqvlYoUb(u$Bhc$BNbAscaGcqxkt(vTi7wDf$„G"ECWIgPWI2zWIuSiDcOeEWSOFiSydl2Nal#ns4LZa4VcY2ndRY7ADUSJYYPYcsth„G"dwDvulQ88MM1xEvh6RS$Ih$VDiOPcaWma$BNbAQ(mdWxE1LYgaWmaVU5vTi7tTO„G"xgS4b$BNbAQ(mdWwDPS(u1ISpi7Vnvus1OvrsRgnhYIgzqJw5RMeaq2amZ25Eca„G"06uZHixalT4WAL1wlwExkl(vTi7lAKbqPPqaWka4cCaqPPqaWkahBa0be(DPS(u„G"1ISVOrgaLMcbaRa0LYcaWXgaDabaWYvTi7hBaYb)l6Lbl#WIxjWIEaDa0cuZHm3„G"bA6(ldW6jStWZvGXgGCa98VDgOPcaWmaDPS)qvlYUvxTODgSidJtr$lsNadeVtS„G"QaW0zalGqNaRlG4ZRPc(nalANblsNaZt6IdZ$$2zGMk(Za8LxDPS(u1ISVOrgKP„G"uqPPgaClaDPS(u1ISB1vl6LblAecgBW6daWcaNhdZi99BVb0lkS$oS#a#U#a5Q(„G"Z8VthnJ03h$IOV4W3h$IyVyXakmmisXcax35lSDDJdOpRpW$1vGthzmbTS4ZAQ(„G"qdW8KU4WF5vxkt(vTi7wzSbghW$l6LblEWcatxd5hn0lENajsK$hF)4vxkl(vTi„G"7xTOtiOPc(nalAKbZR6Id$vxkt(vTi7wD1I2zWImOPc(naJtXI2zWI0jaR8eMCg„G"WJE3jajFPQ4YV4W$BNbAQ(mdWxE1LYc)qnvusz1vvXVhhaOpgh(0zKVyhWIwpGf„G"KgWoYpxoTIAa1zWIypWnRhVtoTO$Z0#oYphjlYH9dhaDse96dn0aZpW6b4HPbKI„G"hKgW6JV4dbf08KMYBcSo2D9LxAL1wyTm(6dYbaqDdmkYbSmavTi7qn1USpqoEzG„G"Cqm4WmLJxgChc$BNbAY(#cWwy1LYc)rLlfaSl7dm4paqNddombIB$USpWuAY(#c„G"qwldLMoaGZamUibfKMkaq1amy#cmhbRKmwlV4WRMIdMgqaoqAajLuIpK4FcG1Yt„G"TibhwqIeSixcCyxcKixcSaW0nqI35$G9(DgSyxcK4F#V1Y87XbhBaYb)74GPbyN„G"iA6(fdWooyAa2DXkoyAa74aQbyhbj6aQbSOdMgGXgGCao8l2bmGpKgWYaeLvxXV„G"hhSO#lc$ImSiDcmpPi2WxEL1Y///////.kaqdawDuqdXusqbIDX4cmWac8GGYqP„G"asm5KdmGuuyYXgin9MB0D2BTvMC5b(GbG(qgaVu1eaOgatv3yJv2CMvhBSLhiYv„G"wBVzxzKbGdaiiadfMBU9gDGixzT9MDLfsiaqjabXMCLfgz5bsAUnhDHXgBLrwiG„G"0ciVufi09gi15gBVfgzaGca6cGvhfeiZnMCLvMBGmwyWrxDYvgiVzgiZidm4jdm„G"WGNm1ydiJ9gBVj3CPaG5aq1usbcAH5gzSvMCGKMBJ9MCW9MCHrxzKbIy5bstPng„G"AHvgBGCvzSngAWOcaueGvhf0qmLeuG8svGq3BGixzT9MDLXciVjhibXevTyfi09„G"giHngDPzxy0v2caiuawDuqtnKuQ4Yqbbf9MaGubCvyY5wAUDwiGy1rbn1qsPIld„G"feuGugEPnhDZbYBUbczPn3AHesig(Fby1rbn1qsr(ggGldfeu.$$F///G//*0p/„G"c(Xb0Gc+ytnmn0s0e/"„N=4488:K=255:IF LEN(C$)<>5984 THEN ?"Bad script!"Ksum!":END„FOR A=1 TO N:LOCATE 1:?STRING$(50/N*A,177):IF L=0 THEN GOSUB G:L=6„W=T\P(6-L):GOSUB G:W=W OR T*P(L):L=L-2:B$=CHR$(W AND K):PUT 1,,B$:NEXT„?:IF C=95 THEN ?"Ok":END ELSE ?"Bad checksum!":END„G:I=I+1:T=INSTR(T$,MID$(C$,I,1))-1:C=(C+T)*2:C=C\256+(C AND 255):RETURN„SUB G(A$):SHARED C$:FOR Q=2 TO 9:DO:S=INSTR(A$,CHR$(Q+38))„IF S THEN A$=LEFT$(A$,S-1)+STRING$(Q,97)+MID$(A$,S+1)„LOOP WHILE S:NEXT:C$=C$+A$:END SUB„Earl Montgomery                VGA CLIP EDITOR                For use with VGACLIP.EXE       Year of 1990           QB, PDS                244  7068     CLIPED.BAS  ' $INCLUDE: 'qb.bi'„DEFINT K, P„ON ERROR GOTO errorroutine„DIM B(500)„DIM d(100)„DIM PIX(1000)„DIM inreg AS RegType„DIM outreg AS RegType„restart:„SCREEN 0: CLS„PRINT "CLIPEDv6.BAS": PRINT "Copyright (C) Earl Montgomery 1990"„PRINT„GOSUB keyboard„begin:„SCREEN 13: DEF SEG = &HA000„DRAW "c142;bm100,100;r4;br2;bu2;u3;bd5;br2;r4;bl6;bd2;d3;"„DRAW "bm2,2;r6;d6;l6;u6;"„GET (2, 2)-(8, 8), d„GET (98, 92)-(114, 108), B„CLS„OUT &H3C8, 0„FOR k = 0 TO 767: OUT &H3C9, 0: NEXT„DEF SEG = &HA000„BLOAD n$ + ".cap", 0: DEF SEG = &HA000 + 4000„OUT &H3C8, 0„FOR k = 0 TO 767: P = PEEK(k): OUT &H3C9, P: NEXT„REM Main Program„x% = 160: y% = 100„cursor:„PUT (x%, y%), B„inkey1:„i$ = INKEY$: IF i$ = "" THEN GOTO inkey1„IF i$ = " " THEN GOTO inkey1„PUT (x%, y%), B„AA% = ASC(i$) AND 223„IF AA% = 0 THEN GOTO mainkeyboardscan„IF AA% = 71 THEN COLOR 15: CLS : SCREEN 0: DEF SEG : END„IF AA% = 83 THEN GOTO preparetoexit„IF AA% = 72 THEN GOTO helpscrn„IF AA% = 90 THEN GOTO zoom„GOTO cursor„mainkeyboardscan:„IF ASC(MID$(i$, 2)) = 75 THEN x% = x% - 2„IF ASC(MID$(i$, 2)) = 77 THEN x% = x% + 2„IF ASC(MID$(i$, 2)) = 72 THEN y% = y% - 2„IF ASC(MID$(i$, 2)) = 80 THEN y% = y% + 2„IF ASC(MID$(i$, 2)) = 71 THEN x% = x% - 2: y% = y% - 2„IF ASC(MID$(i$, 2)) = 79 THEN x% = x% - 2: y% = y% + 2„IF ASC(MID$(i$, 2)) = 73 THEN x% = x% + 2: y% = y% - 2„IF ASC(MID$(i$, 2)) = 81 THEN x% = x% + 2: y% = y% + 2„IF x% > 300 THEN x% = 300„IF x% < 6 THEN x% = 6„IF y% > 180 THEN y% = 180„IF y% < 5 THEN y% = 5„GOTO cursor„helpscrn:„DEF SEG = &HA000: BSAVE "temp.bin", 0, 64780!: CLS„„DEF SEG = &HA000 + 4000„OUT &H3C7, 0„FOR k = 0 TO 767„A = INP(&H3C9)„POKE k, A„NEXT„SCREEN 9„COLOR 12, 0„PRINT "Command from main screen:"„PRINT "<G>=Good Bye  <H>=This menu."„PRINT "<S>=Press this key before saving the picture using VGACLIP!"„PRINT "<Z>=Go to ZOOM Edit Mode."„PRINT„PRINT "Commands from ZOOM Edit Mode:"„PRINT "<D>=Pen-Down Mode."„PRINT "<C>=Increases color value."„PRINT "<->=Decreases color value."„PRINT "<F>=Changes color to the same color as one block to the right."„PRINT "<L>=Return to the main screen without saving the editing."„PRINT "<S>=Saves your editing and returns to the main screen."„PRINT "<U>=Pen Up Mode."„PRINT "Use the arrow keys on the keypad to move the cursor. Home moves"„PRINT "the cursor up and to the left. PgUp moves it up and to the right."„PRINT "End moves it down and to the left and PgDn moves it down and to"„PRINT "the right. All keys are repeat keys. Just hold them down!"„PRINT "Press any key to continue."„inkey2:„Z$ = INKEY$: IF Z$ = "" THEN GOTO inkey2„SCREEN 13„OUT &H3C8, 0: FOR k = 0 TO 767: OUT &H3C9, 0: NEXT„DEF SEG = &HA000: BLOAD "temp.bin", 0„DEF SEG = &HA000 + 4000„OUT &H3C8, 0„FOR k = 0 TO 767: P = PEEK(k): OUT &H3C9, P: NEXT„GOTO cursor„zoom:„GET (x%, y%)-(x% + 19, y% + 19), PIX„DEF SEG = &HA000 + 4000„OUT &H3C7, 0„FOR k = 0 TO 767: A = INP(&H3C9): POKE k, A: NEXT„DEF SEG = &HA000: BSAVE "temp.bin", 0, 64780!„CLS : PUT (50, 50), PIX, PSET„FOR y = 4 TO 164 STEP 8„LINE (100, y)-(260, y), 142„NEXT„FOR x = 100 TO 260 STEP 8„LINE (x, 4)-(x, 164), 142„NEXT„x = 160: y = 100„X1 = 59: Y1 = 60„i% = 1„OPEN "r", #1, "zoom", 1: FIELD 1, 1 AS O$„FOR y = 50 TO 69„FOR x = 50 TO 69„LSET O$ = CHR$(POINT(x, y)): PUT 1, i%„i% = i% + 1„NEXT x, y„CLOSE #1„i% = 1„„OPEN "r", #1, "zoom", 1: FIELD 1, 1 AS O$„FOR y = 6 TO 164 STEP 8„FOR x = 102 TO 260 STEP 8„GET #1, i%: i% = i% + 1„IF ASC(O$) = 142 THEN PAINT (x, y), 143, 142: GOTO skipover„PAINT (x, y), ASC(O$), 142„skipover:„NEXT x, y„CLOSE #1„x = 176: y = 88„flag$ = "jump"„LINE (170, 180)-(190, 198), 142, B„c = POINT(x, y)„IF c = 142 THEN c = 143„PAINT (180, 185), c, 142: LOCATE 25, 30: PRINT c;„inkey3:„i$ = INKEY$: IF i$ = "" THEN GOSUB putcursor: GOTO inkey3„AA = ASC(i$)„IF AA = 0 THEN GOTO keyboardscanfromzoom„IF i$ = "d" OR i$ = "D" THEN flag$ = ""„IF i$ = "c" OR i$ = "C" THEN c = c + 1: IF c > 255 THEN c = 0„IF i$ = "-" OR i$ = "_" THEN c = c - 1: IF c < 0 THEN c = 0„IF c = 142 AND i$ = "-" OR i$ = "_" THEN c = 141„IF c = 142 AND i$ = "c" OR i$ = "C" THEN c = 143„IF i$ = "c" OR i$ = "C" THEN GOSUB printnewcolor„IF i$ = "-" OR i$ = "_" THEN GOSUB printnewcolor„IF i$ = "f" OR i$ = "F" THEN c = POINT(x + 8, y): IF c = 142 THEN c = 143„IF i$ = "s" OR i$ = "S" THEN GOTO savefromkeyboard„IF i$ = "l" OR i$ = "L" THEN GOSUB bloadscrn: GOTO cursor„IF i$ = "u" OR i$ = "U" THEN flag$ = "jump"„IF flag$ = "" THEN PAINT (x, y), c, 142: PSET (X1, Y1), c„PUT (x - 3, y - 3), d: FOR d = 0 TO 50: NEXT: PUT (x - 3, y - 3), d„i$ = "": GOTO inkey3„keyboardscanfromzoom:„IF ASC(MID$(i$, 2)) = 75 THEN x = x - 8: X1 = X1 - 1„IF ASC(MID$(i$, 2)) = 77 THEN x = x + 8: X1 = X1 + 1„IF ASC(MID$(i$, 2)) = 72 THEN y = y - 8: Y1 = Y1 - 1„IF ASC(MID$(i$, 2)) = 80 THEN y = y + 8: Y1 = Y1 + 1„IF ASC(MID$(i$, 2)) = 71 THEN x = x - 8: y = y - 8: X1 = X1 - 1: Y1 = Y1 - 1„IF ASC(MID$(i$, 2)) = 79 THEN x = x - 8: y = y + 8: X1 = X1 - 1: Y1 = Y1 + 1„IF ASC(MID$(i$, 2)) = 73 THEN x = x + 8: y = y - 8: X1 = X1 + 1: Y1 = Y1 - 1„IF ASC(MID$(i$, 2)) = 81 THEN x = x + 8: y = y + 8: X1 = X1 + 1: Y1 = Y1 + 1„IF x > 256 THEN x = 256„IF x < 104 THEN x = 104„IF y > 160 THEN y = 160„IF y < 8 THEN y = 8„IF X1 < 50 THEN X1 = 50„IF X1 > 69 THEN X1 = 69„IF Y1 > 69 THEN Y1 = 69„IF Y1 < 50 THEN Y1 = 50„IF flag$ = "jump" THEN GOSUB putcursor: GOTO inkey3„PAINT (x, y), c, 142„PSET (X1, Y1), c„GOTO inkey3„savefromkeyboard:„GET (50, 50)-(69, 69), PIX„DEF SEG = &HA000: BLOAD "temp.bin", 0„PUT (x%, y%), PIX, PSET„GOTO cursor„„preparetoexit:„REM blanks cursor and saves-ends„PUT (x%, y%), B: PUT (x%, y%), B„inkey4:„i$ = INKEY$: IF i$ = "" THEN GOTO inkey4„IF i$ = "g" OR i$ = "G" THEN CLS : SCREEN 0: END„GOTO inkey4„errorroutine:„SCREEN 0: WIDTH 80: CLS : RESUME restart„keyboard:„DIM inregs AS RegTypeX, outregs AS RegTypeX„filespec$ = "*.cap" + CHR$(0)„PRINT STRING$(75, 196)„inregs.ax = &H2F00„CALL INTERRUPTX(&H21, inregs, outregs)„data.seg = outregs.es„data.off = outregs.bx„inregs.ax = &H4E00„inregs.dx = SADD(filespec$)„inregs.ds = -1„CALL INTERRUPTX(&H21, inregs, outregs)„cy = outregs.flags AND 1„IF cy = 0 THEN„WHILE cy = 0„DEF SEG = data.seg„f.name$ = ""„i = data.off + 30„WHILE PEEK(i) <> 0„f.name$ = f.name$ + CHR$(PEEK(i))„i = i + 1„WEND„DEF SEG„PRINT f.name$ + " ";„inregs.ax = &H4F00„CALL INTERRUPTX(&H21, inregs, outregs)„cy = outregs.flags AND 1„WEND„ELSE GOSUB PRINTNOCAPFILES„END IF„PRINT STRING$(75, 196)„INPUT "Filename to load"; n$„RETURN„PRINTNOCAPFILES:„PRINT "There are no .CAP files in this directory."„PRINT STRING$(75, 196)„INKEY5:„i$ = INKEY$: IF i$ = "" THEN GOTO INKEY5„DEF SEG : CLS : SCREEN 0: WIDTH 80: END„putcursor:„PUT (x - 3, y - 3), d„FOR d = 0 TO 50: NEXT„PUT (x - 3, y - 3), d„RETURN„printnewcolor:„PAINT (180, 185), c, 142„LOCATE 25, 30„PRINT "    ";„LOCATE 25, 30„PRINT c;„RETURN„bloadscrn:„CLS„DEF SEG = &HA000„BLOAD "temp.bin", 0„RETURN„„Zabudsky Aaron Scott           WINDOWS BITMAP VIEWER          FidoNet QUIK_BAS Echo          Unknown Date           QB, QBasic, PDS        279  8837     BMPVIEW.BAS CLS„INPUT "Filename to load: ", filename$„OPEN filename$ FOR BINARY AS #1„„header$ = SPACE$(14)„sizing$ = SPACE$(4)„GET #1, 1, header$„GET #1, 15, sizing$„bmpinfosize = CVI(sizing$)„'bmpinfosize - Is the size of the information header for the bitmap.„'              Different bitmap versions have variations in filetypes.„'              40 is a standard windows 3.1 bitmap.„'              12 is for OS/2 bitmaps„'The next routine reads in the appropriate headers and colour tables.„'nbits is the number of bits per pixel - i.e. number of colours„'1 bit = 2 colours, 4 bits = 16 colours, 8 bits = 256 colours, etc.„'the 24 bit mode does not have a palette, its colours are expressed as„'image data„„'Design of a windows 3.1 bitmap - Taken from bmp.zip on the„'x2ftp.oulu.fi ftp site under /pub/msdos/programming/formats„'Specifications for a Windows 3.1 bitmap. (.BMP)„'Email any questions/responses to me at zabudsk@ecf.utoronto.ca„'or post to alt.lang.basic or comp.lang.basic.misc.„„'       | # of   |„'Offset | bytes  | Function (value)„'-------+--------+--- General Picture information starts here---------„'  0    |   2    | (BM) - Tells us that the picture is in bmp format„'  2    |   4    | Size of the file (without header?)„'  6    |   2    | (0) Reserved1 - Must be zero„'  8    |   2    | (0) Reserved2 - Must be zero„'  10   |   4    | Number of bytes offset of the picture data„'-------+--------+--- Information Header starts here -----------------„'  14   |   4    | (40/12) Size of information header (Win3.1/OS2)„'  18   |   4    | Picture width in pixels„'  22   |   4    | Picture Height in pixels„'  26   |   2    | (1) Number of planes, must be 1„'  28   |   2    | Number of bits per pixel (bpp), must be 1,4,8 or 24„'  30   |   4    | (0) Compression - 0 means no compression, 1,2 are RLEs„'  34   |   4    | Image size in bytes„'  38   |   4    | picture width in pels per metre„'  42   |   4    | picture height in pels per metre„'  46   |   4    | (0) Number of colours used in the picture, 0 means all„'  50   |   4    | (0) Number of important colours, 0 means all„'-------+--------+--- Palette data starts here -----------------------„'  54   |   1    | (b) - blue intensity component, color 0 - range 0 to 255„'  55   |   1    | (g) - green intensity component, color 0 - range 0 to 255„'  56   |   1    | (r) - red intensity component, color 0 - range 0 to 255„'  57   |   1    | (0) - unused„'  58   |   1    | (b) - blue intensity component, color 0 - range 0 to 255„'  ...  | ...    |„'  54   | 4*2^bpp| total range of palette„'-------+--------+--- Image data starts here -------------------------„'54+    | width* | Bitmap data starting at lower left portion of the„'(4*2^n)| height*| image moving from left towards right. Moving up 1„'       | (8/bpp)| pixel when at the right hand side of the image, starting„'       |        | from the left side again, until the top right of the„'       |        | image is reached„„'Note that this format is slightly different for a OS/2 Bitmap.„'The header is the same up to (but not including) bit 30-„'The palette colour values follow at bit 30, with the form...„'1 byte blue intensity„'1 byte green intensity„'1 byte red intensity„'For each colour of the picture.„'Bitmapped image data follows the colour tables„„„'Special note: When storing 1 bit (2 colour) pictures.„'8 horizontal pixels are packed into 1 byte. Each bit determines„'the colour of one pixel (colour 0 or colour 1)„„'4 bit pictures (16 colours) use 2 nibbles (4 bits) for each pixel„'thus there are 2 pixels for each byte of image data.„„'8 bit pictures use 1 byte per pixel. Each byte of image data„'represents one of 256 colours.„„'24 bit pictures express colour values by using 3 bytes and each has a„'value between 0 and 255. The first byte is for red, the second is for„'green and the third is for blue. Thus (256)^3 or 2^24 of 16777216 different„'colours.„„IF bmpinfosize = 12 THEN„   infoheader$ = SPACE$(12)„   GET #1, 15, infoheader$„   nbits = CVI(MID$(infoheader$, 15, 4))„„   IF nbits = 1 THEN„      palet$ = SPACE$(6)„      GET #1, bmpinfosize + 15, palet$„   ELSEIF nbits = 4 THEN„      palet$ = SPACE$(48)„      GET #1, bmpinfosize + 15, palet$„   ELSEIF nbits = 8 THEN„      palet$ = SPACE$(768)„      GET #1, bmpinfosize + 15, palet$„   END IF„ELSEIF bmpinfosize = 40 THEN„   infoheader$ = SPACE$(40)„   GET #1, 15, infoheader$„   nbits = CVI(MID$(infoheader$, 15, 4))„   IF nbits = 1 THEN„      palet$ = SPACE$(8)„      GET #1, bmpinfosize + 15, palet$„   ELSEIF nbits = 4 THEN„      palet$ = SPACE$(64)„      GET #1, bmpinfosize + 15, palet$„   ELSEIF nbits = 8 THEN„      palet$ = SPACE$(1024)„      GET #1, bmpinfosize + 15, palet$„   END IF„END IF„„„ft$ = MID$(header$, 1, 2)„PRINT "Type of file (Should be BM): "; ft$„„filesize = CVL(MID$(header$, 3, 4))„PRINT "Size of file: "; filesize„„r1 = CVI(MID$(header$, 7, 2))„PRINT "Reserved 1: "; r1„„r2 = CVI(MID$(header$, 9, 2))„PRINT "Reserved 2: "; r2„„offset = CVL(MID$(header$, 11, 4))„PRINT "Number of bytes offset from beginning: "; offset„„PRINT„„headersize& = CVL(MID$(infoheader$, 1, 4))„PRINT "Size of header: "; headersize&„„picwidth = CVL(MID$(infoheader$, 5, 4))„PRINT "Width: "; picwidth„„picheight = CVL(MID$(infoheader$, 9, 4))„PRINT "Height: "; picheight„nplanes = CVI(MID$(infoheader$, 13, 4))„PRINT "Planes: "; nplanes„„PRINT "Bits per plane: "; nbits„„PRINT„„IF headersize = 40 THEN„   PRINT "Compression: ";„   comptype = CVL(MID$(infoheader$, 17, 4))„   IF comptype = 0 THEN PRINT "None"„   IF comptype = 1 THEN PRINT "Run Length - 8 Bits"„   IF comptype = 2 THEN PRINT "Run Length - 4 Bits"„„   imagesize = CVL(MID$(infoheader$, 21, 4))„   PRINT "Image Size (bytes): "; imagesize„„   xsize = CVL(MID$(infoheader$, 25, 4))„   PRINT "X size (pixels per metre): "; xsize„„   ysize = CVL(MID$(infoheader$, 29, 4))„   PRINT "Y size (pixels per metre): "; ysize„„   colorsused = CVL(MID$(infoheader$, 33, 4))„   PRINT "Number of colours used: "; colorsused„„   neededcolours = CVL(MID$(infoheader$, 37, 4))„   PRINT "Number of important colours: "; neededcolours„END IF„PRINT„PRINT "Press Any key to continue."„WHILE INKEY$ = ""„WEND„„IF nbits = 1 THEN„   SCREEN 11„ELSEIF nbits = 4 THEN„   SCREEN 13„ELSEIF nbits = 8 OR nbits = 24 THEN„   SCREEN 13„END IF„IF bmpinfosize = 40 THEN ngroups = 4„IF bmpinfosize = 12 THEN ngroups = 3„„IF nbits = 24 THEN„   IF ngroups = 3 THEN„      FOR c = 0 TO 63„         d = c * 4„         palet$ = palet$ + CHR$(d) + CHR$(d) + CHR$(d)„         palet$ = palet$ + CHR$(d) + CHR$(d) + CHR$(d + 1)„         palet$ = palet$ + CHR$(d) + CHR$(d + 1) + CHR$(d)„         palet$ = palet$ + CHR$(d + 1) + CHR$(d) + CHR$(d)„      NEXT c„   ELSEIF ngroups = 4 THEN„      FOR c = 0 TO 63„         d = c * 4„         palet$ = palet$ + CHR$(d) + CHR$(d) + CHR$(d) + CHR$(0)„         palet$ = palet$ + CHR$(d) + CHR$(d) + CHR$(d + 1) + CHR$(0)„         palet$ = palet$ + CHR$(d) + CHR$(d + 1) + CHR$(d) + CHR$(0)„         palet$ = palet$ + CHR$(d + 1) + CHR$(d) + CHR$(d) + CHR$(0)„      NEXT c„   END IF„END IF„„FOR x = 1 TO LEN(palet$) STEP ngroups„   zb# = INT((ASC(MID$(palet$, x, 1))) / 4)„   zg# = INT((ASC(MID$(palet$, x + 1, 1))) / 4)„   zr# = INT((ASC(MID$(palet$, x + 2, 1))) / 4)„   zc# = zb# * 65536# + zg# * 256# + zr#„   cres = ASC(MID$(palet$, x + 3, 1))„   PALETTE ((x - 1) / ngroups), zc#„NEXT x„„IF nbits = 24 THEN„   y = picheight - 1„   x = 0„   dat$ = "   "„   WHILE y >= 0„      WHILE x < picwidth„         GET 1, , dat$„         p1 = INT(ASC(MID$(dat$, 1, 1)) + ASC(MID$(dat$, 1, 1)) + ASC(MID$(dat$, 1, 1)))„         PSET (x, y), p1„         x = x + 1„      WEND„      y = y - 1„      x = 0„   WEND„ELSEIF nbits = 8 THEN„   y = picheight - 1„   x = 0„   dat$ = " "„   WHILE y >= 0„      WHILE x < picwidth„         GET 1, , dat$„         PSET (x, y), ASC(dat$)„         x = x + 1„      WEND„      y = y - 1„      x = 0„   WEND„ELSEIF nbits = 4 THEN„   y = picheight - 1„   x = 0„   dat$ = " "„   WHILE y >= 0„      WHILE x < picwidth„        GET 1, , dat$„        LOCATE 1, 1„        p1 = ASC(dat$) AND 15„        p2 = ASC(dat$) AND 240 / 16„        PSET (x, y), p1„        PSET (x + 1, y), p2„        x = x + 2„      WEND„      y = y - 1„      x = 0„   WEND„ELSEIF nbits = 1 THEN„   y = picheight - 1„   x = 0„   dat$ = " "„   WHILE y >= 0„      WHILE x < picwidth„        GET 1, , dat$„        p1 = ASC(dat$)„        FOR p = 0 TO 7„           PSET (x + (7 - p), y), (p1 AND 2 ^ p) / 2 ^ p„        NEXT p„        x = x + 8„      WEND„      y = y - 1„      x = 0„   WEND„END IF„„CLOSE„„The ABC Programmer             EARTHQUAKE EFFECT DEMO         EARTHQUAKE,EFFECT,DEMO         07-23-94 (00:00)       QB, QBasic, PDS        95   2764     QUAKE.BAS   '==========================================„' EARTHQUAKE by William Yu (07-23-94)„' Creates an Earthquake effect„' Works on any graphics mode„' Here's a short demo, modify as you wish„'==========================================„„DECLARE SUB EarthQuake ()„DIM CRAFT(500)„CLS„SCREEN 12„OUT &H3D4, 9: OUT &H3D5, 1„DO„  RANDOMIZE TIMER„  Clock = Clock + 1„  X = INT(RND * 640) + 1„  Y = INT(RND * 280) + 1„  Z = INT(RND * 15) + 1„  PSET (X, Y), Z„LOOP UNTIL Clock = 150„LOCATE 3, 25: COLOR 14: PRINT "JOURNEY TO THE UNKNOWN DIMENSION"„CIRCLE (320, 120), 20, 13, , , 11 / 22„PAINT (320, 120), 13„CIRCLE (315, 122), 2, 6, , , 1 / 3: PAINT (315, 122), 6„CIRCLE (323, 124), 2, 5, , , 1 / 3: PAINT (323, 124), 5„CIRCLE (320, 117), 2, 6, , , 1 / 3: PAINT (320, 117), 6„SLEEP 1„LINE (610, 12)-(630, 4), 10„LINE (610, 12)-(634, 8), 10„LINE (634, 8)-(630, 4), 10„PAINT (630, 6), 10: PSET (617, 10), 10: PSET (616, 10), 10„CIRCLE (628, 7), 2, 9, , , 1 / 3: PAINT (628, 7), 9„LINE (632, 6)-(634, 6), 12: LINE (630, 4)-(632, 4), 12„LINE (634, 8)-(636, 8), 12„GET (639, 2)-(609, 13), CRAFT„X = 609: Y = 2„MOVECRAFT:„X = X - 3„Y = Y + 1.1„PUT (X, Y), CRAFT, PSET„IF X = 333 THEN GOTO CRASH„GOTO MOVECRAFT„CRASH:„PSET (330, 115), 10: PSET (330, 115), 12: PSET (325, 116), 15„PSET (330, 114), 15: PSET (329, 113), 12: PSET (326, 115), 10„PSET (331, 115), 10: PSET (331, 115), 12: PSET (325, 113), 10„PSET (332, 114), 15: PSET (327, 113), 10: PSET (329, 114), 10„PSET (330, 113), 10: PSET (328, 112), 10„LINE (333, 114)-(380, 110), 12„LINE (333, 114)-(380, 105), 12„LINE (333, 114)-(380, 100), 12„LINE (333, 114)-(360, 100), 12„LINE (333, 114)-(345, 102), 12„EarthQuake„LINE (333, 114)-(380, 110), 14„LINE (333, 114)-(380, 105), 14„LINE (333, 114)-(380, 100), 14„LINE (333, 114)-(360, 100), 14„LINE (333, 114)-(345, 102), 14„EarthQuake„PUT (333, 100), CRAFT, AND„LINE (333, 114)-(380, 110), 12„LINE (333, 114)-(380, 105), 12„LINE (333, 114)-(380, 100), 12„LINE (333, 114)-(360, 100), 12„LINE (333, 114)-(345, 102), 12„EarthQuake„LINE (333, 114)-(380, 110), 0„LINE (333, 114)-(380, 105), 0„LINE (333, 114)-(380, 100), 0„LINE (333, 114)-(360, 100), 0„LINE (333, 114)-(345, 102), 0„LINE (341, 105)-(355, 110), 0, BF„EarthQuake„OUT &H3D4, 8: OUT &H3D5, 0„SLEEP 1„LOCATE 3, 25: PRINT SPACE$(32)„LOCATE 3, 29: COLOR 12: PRINT "WHAT THE HELL WAS THAT!!!"„SLEEP 1„LOCATE 3, 29: COLOR 14: PRINT "HELP! HELP! AHHH...I'M..."„SLEEP 2„LOCATE 3, 29: COLOR 12: PRINT "       NO RESPONSE       "„SLEEP 1„LOCATE 3, 32: PRINT "WHAT HAPPENED TO HIM?"„SLEEP 2„„SUB EarthQuake„„Delay = 5500       ' Increase this or decrease for earthquake delay„„FOR X = 1 TO Delay„  OUT &H3D4, 8: OUT &H3D5, X„NEXT X„END SUB„„Matt Hart                      SAVE/RESTORE GRAPHICS SCREENS  FidoNet QUIK_BAS Echo          07-28-92 (21:55)       QB, PDS                293  9721     GSAVES.BAS  ' MK> Does anyone know how to save the graphics screen for 640x480x16, VGA?„' MK> Also, using a binary file?"BSAVE", not a text file...„'„'„' GSAVES.BAS  by Matt Hart„' Save/Restore multiple graphics screens in„' any mode to a single file.„'„' Compile with /AH for huge arrays and„' /X for error trapping with RESUME NEXT„'„' The data is stored as follows:„'   1 Byte  :  Monitor Type„'   1 Byte  :  Screen Mode (0-13)„'   For VGA monitors, the palette (long integers)„'   is stored next for screens 11, 12, and 13„'    Screen Mode   Number of Bytes   Number of Attributes„'       11               8                   2„'       12              64                  16„'       13            1024                 256„' „    DEFINT A-Z„    DECLARE FUNCTION CalcBytes&(X,Y,BPP,P)„    TYPE RegTypeX„        ax    AS INTEGER„        bx    AS INTEGER„        cx    AS INTEGER„        dx    AS INTEGER„        bp    AS INTEGER„        si    AS INTEGER„        di    AS INTEGER„        flags AS INTEGER„        ds    AS INTEGER„        es    AS INTEGER„    END TYPE„    '„    CONST False = 0„    CONST True  = NOT False„„    ON ERROR GOTO ErrorTrap„    '„    REDIM NumBytes&(0 TO 13)„    NumBytes&(0)  = 4000&„    NumBytes&(1)  = CalcBytes&(320,200,2,1)„    NumBytes&(2)  = CalcBytes&(640,200,1,1)„    NumBytes&(3)  = CalcBytes&(720,348,1,1)„    NumBytes&(7)  = CalcBytes&(320,200,1,4)„    NumBytes&(8)  = CalcBytes&(640,200,1,4)„    NumBytes&(9)  = CalcBytes&(640,350,1,4)„    NumBytes&(10) = CalcBytes&(640,350,1,2)„    NumBytes&(11) = CalcBytes&(640,480,1,1)„    NumBytes&(12) = CalcBytes&(640,480,1,4)„    NumBytes&(13) = CalcBytes&(320,200,8,1)„    '„    FileName$ = "SCREENS.BIN"„    ' Example 1 : Screen 0„    CLS : PRINT "This is Screen 0"„    COLOR 14 : PRINT "     This is Screen 0"„    Mon = 0 : ScrMode = 0 : ScreenNum = 1„    CALL SaveScreen(FileName$, Mon, ScrMode, ScreenNum, NumBytes&(),Ecode)„    CLS„    CALL RestoreScreen(FileName$, ScreenNum, NumBytes&(), Ecode)„    END„    ' Parameters are:„    '     FileName$  =  File to save the screen to„    '           Mon  =  Monitor Type„    '                     0 = Monochrome/Text Only„    '                     1 = Hercules„    '                     2 = CGA„    '                     3 = EGA„    '                     4 = VGA„    '       ScrMode  =  Current Screen Mode (0-13)„    '     ScreenNum  =  Screen Number to Save„    '                   Will return with the last screen„    '                   number in the file if ScreenNum„    '                   was greater than the last screen + 1„    '   NumBytes&()  =  Array containing the number of bytes„    '                   needed to save a screen„    '         Ecode  =  0 if no error, 1 if„    '                   ScreenNum already exists and„    '                   is not the same ScrMode and Mon,„    '                   or -1 if some other error.„    '„ErrorTrap:„    Ecode = True„    RESUME NEXT„    '„SUB SaveScreen(FileName$, Mon, ScrMode, ScreenNum, NumBytes&(), Ecode)„    Ecode = False„    Buf = FreeFile„    OPEN "B",Buf,FileName$ : IF Ecode THEN EXIT SUB„    CurScr = 1  :  CurPos& = 1„DO„    IF EOF(Buf) THEN EXIT DO„    M$=" " : S$=" " : GET Buf,,M$ : GET Buf,,S$„    M=ASC(M$) : S=ASC(S$) : CurPos& = CurPos& + 2„    IF CurScr = ScreenNum THEN„        IF M=Mon AND S=ScrMode THEN„            SEEK #Buf, CurPos& - 2„            EXIT DO„        ELSE„            Ecode = 1„            EXIT DO„        ENDIF„    ELSE„        IF M=4 THEN„            SELECT CASE S„                CASE 11 : CurPos& = CurPos& + 8&„                CASE 12 : CurPos& = CurPos& + 64&„                CASE 13 : CurPos& = CurPos& + 1024&„            END SELECT„        ENDIF„        CurPos& = CurPos& + NumBytes&(S)„        SEEK #Buf, CurPos&„        IF Ecode THEN EXIT DO       ' a DOS Error„        CurScr = CurScr + 1„    ENDIF„LOOP„    IF Ecode <> 0 THEN GOTO SS.Ending„    ScreenNum = CurScr„    A$=CHR$(Mon)+CHR$(ScrMode) : PUT #Buf,,A$„    IF Ecode THEN GOTO SS.Ending        ' DOS Error„    REDIM Saver&(1 TO NumBytes&(ScrMode))„    SaveSeg = VARSEG(Saver&(1))„    SaveAdd& = VARPTR(Saver&(1))„    SELECT CASE ScrMode„        CASE 0„            FOR P=0 TO 3999„                DEF SEG = &HB000 : Z=PEEK(P)„                DEF SEG = SaveSeg : POKE SaveAdd&+P,Z„            NEXT P„            DEF SEG„        CASE 1,7,13 : GET (0,0)-(319,199),Saver&„        CASE 2,8    : GET (0,0)-(639,199),Saver&„        CASE 3      : GET (0,0)-(719,347),Saver&„        CASE 9,10   : GET (0,0)-(639,349),Saver&„        CASE 11,12  : GET (0,0)-(639,479),Saver&„    END SELECT„    IF Ecode THEN GOTO SS.Ending        ' Wrong Screen mode probably„    IF Mon = 4 THEN„        SELECT CASE S„            CASE 11 : NumPal = 2„            CASE 12 : NumPal = 16„            CASE 13 : NumPal = 256„            CASE ELSE : NumPal = 0„        END SELECT„        IF NumPal > 0 THEN„            DIM InRegs AS RegTypeX„            DIM OutRegs AS RegTypeX„            REDIM PalInfo&(0 TO NumPal-1)„            FOR i = 0 TO NumPal-1„                InRegs.ax = &H1015„                InRegs.bx = i„                CALL INTERRUPTX (&H10, InRegs, OutRegs)„                A& = (OutRegs.cx AND &HFF00) \ &HFF„                B& = (OutRegs.cx AND &HFF)„                C& = (OutRegs.dx AND &HFF00) \ &HFF„                PalInfo&(i) = 65536& * B& + 256& * A& + C&„            NEXT i„            PSeg = VARSEG(PalInfo&(0)) : PAdd& = VARPTR(PalInfo&(0))„            FOR i = 0 TO NumPal*4-1„                DEF SEG = PSeg„                A$=CHR$(PEEK(PAdd&)) : DEF SEG„                PUT Buf,,A$„                PAdd& = PAdd& + 1„                IF PAdd& > (16*1024) THEN„                    PAdd& = PAdd& - (16*1024)„                    PSeg = PSeg + (16*1024\64)„                ENDIF„            NEXT„        ENDIF„    ENDIF„    FOR i=0 TO NumBytes&(ScrMode)-1„        DEF SEG = SaveSeg„        A$=CHR$(PEEK(SaveAdd&)) : DEF SEG„        PUT Buf,,A$„„        IF Ecode THEN EXIT FOR„        SaveAdd& = SaveAdd& + 1„        IF SaveAdd& > (16*1024) THEN„            SaveAdd& = SaveAdd& - (16*1024)„            SaveSeg = SaveSeg + (16*1024\64)„        ENDIF„    NEXT i„    IF Ecode THEN GOTO SS.Ending        ' DOS Error„    CLOSE Buf„    EXIT SUB„SS.Ending:„    CLOSE Buf„END SUB„„„SUB RestoreScreen(FileName$, ScreenNum, NumBytes&(), Ecode)„    Ecode = False„    Buf = FreeFile„    OPEN "B",Buf,FileName$ : IF Ecode THEN EXIT SUB„    CurScr = 1  :  CurPos& = 1„DO„    IF EOF(Buf) THEN„        Ecode = True„        EXIT DO„    ENDIF„    M$=" " : S$=" " : GET Buf,,M$ : GET Buf,,S$„    M=ASC(M$) : S=ASC(S$) : CurPos& = CurPos& + 2„    IF CurScr = ScreenNum THEN„        EXIT DO„    ELSE„        IF M=4 THEN„            SELECT CASE S„                CASE 11 : CurPos& = CurPos& + 8&„                CASE 12 : CurPos& = CurPos& + 64&„                CASE 13 : CurPos& = CurPos& + 1024&„            END SELECT„        ENDIF„        CurPos& = CurPos& + NumBytes&(S)„        SEEK #Buf, CurPos&„        IF Ecode THEN EXIT DO       ' a DOS Error„    ENDIF„LOOP„    IF Ecode <> 0 THEN GOTO SS.Ending„    REDIM Saver&(1 TO NumBytes&(ScrMode))„    SaveSeg = VARSEG(Saver&(1))„    SaveAdd& = VARPTR(Saver&(1))„    G$=" "„    SELECT CASE ScrMode„        CASE 0„            FOR P=0 TO 3999„                GET Buf,,G$ : Z=ASC(G$)„                DEF SEG = SaveSeg : POKE SaveAdd&+P,Z : DEF SEG„            NEXT P„        CASE 1,7,13 : GET (0,0)-(319,199),Saver&„        CASE 2,8    : GET (0,0)-(639,199),Saver&„        CASE 3      : GET (0,0)-(719,347),Saver&„        CASE 9,10   : GET (0,0)-(639,349),Saver&„        CASE 11,12  : GET (0,0)-(639,479),Saver&„    END SELECT„    IF Ecode THEN GOTO SS.Ending        ' Wrong Screen mode probably„    IF Mon = 4 THEN„        SELECT CASE S„            CASE 11 : NumPal = 2„            CASE 12 : NumPal = 16„            CASE 13 : NumPal = 256„            CASE ELSE : NumPal = 0„        END SELECT„        IF NumPal > 0 THEN„            DIM InRegs AS RegTypeX„            DIM OutRegs AS RegTypeX„            REDIM PalInfo&(0 TO NumPal-1)„            FOR i = 0 TO NumPal-1„                InRegs.ax = &H1015„                InRegs.bx = i„                CALL INTERRUPTX (&H10, InRegs, OutRegs)„                A& = (OutRegs.cx AND &HFF00) \ &HFF„                B& = (OutRegs.cx AND &HFF)„                C& = (OutRegs.dx AND &HFF00) \ &HFF„                PalInfo&(i) = 65536& * B& + 256& * A& + C&„            NEXT i„            PSeg = VARSEG(PalInfo&(0)) : PAdd& = VARPTR(PalInfo&(0))„            FOR i = 0 TO NumPal*4-1„                DEF SEG = PSeg„                A$=CHR$(PEEK(PAdd&)) : DEF SEG„                PUT Buf,,A$„                PAdd& = PAdd& + 1„                IF PAdd& > (16*1024) THEN„                    PAdd& = PAdd& - (16*1024)„                    PSeg = PSeg + (16*1024\64)„„                ENDIF„            NEXT„        ENDIF„    ENDIF„    FOR i=0 TO NumBytes&(ScrMode)-1„        DEF SEG = SaveSeg„        A$=CHR$(PEEK(SaveAdd&)) : DEF SEG„        PUT Buf,,A$„        IF Ecode THEN EXIT FOR„        SaveAdd& = SaveAdd& + 1„        IF SaveAdd& > (16*1024) THEN„            SaveAdd& = SaveAdd& - (16*1024)„            SaveSeg = SaveSeg + (16*1024\64)„        ENDIF„    NEXT i„    IF Ecode THEN GOTO SS.Ending        ' DOS Error„    CLOSE Buf„    EXIT SUB„SS.Ending:„    CLOSE Buf„END SUB„„FUNCTION CalcBytes&(X,Y,BPP,P)„    C& = 4+INT(((X)*(BPP)+7)/8)*P*(Y)„    CalcBytes& = C& + C& MOD 4&„END FUNCTION„Dave Navarro, Jr.              PB GIF DECODER                 FidoNet POWER_BAS Echo         10-21-95 (18:53)       PB                     208  5318     DECGIF.BAS  DEFINT A-Z„„DECLARE FUNCTION Getbit ()„DECLARE FUNCTION ReadCode (CodeSize)„DECLARE SUB PlotPixel (A)„„True = -1„False = 0„„DIM ByteBuffer AS STRING * 1„DIM Powers(8), Prefix(4096), Suffix(4096), Outcode(1024)„DIM MaxCodes(12), Powers2(16)„SHARED Xstart, Xend, True, False„„FOR A = 1 TO 8: Powers(A) = 2 ^ (A - 1): NEXT„DATA 4,8,16,&h20,&h40,&h80,&h100,&h200,&h400,&h800,&h1000,8192„„FOR A = 0 TO 11: READ MaxCodes(A): NEXT„DATA 1,3,7,15,31,63,127,255„„FOR A = 1 TO 8: READ CodeMask(A): NEXT„DATA 1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384„„FOR A = 0 TO 14: READ Powers2(A): NEXT„„F$="TMP.GIF"„„OPEN F$ FOR BINARY AS #1 LEN = 1„IF LOF(1) = 0 THEN PRINT "File not found!": CLOSE : KILL F$: END„„FOR A = 1 TO 6„    GET #1, , ByteBuffer: A$ = A$ + ByteBuffer„NEXT„IF A$ <> "GIF87a" THEN„    PRINT "Warning, the "; A$; " protocol is being used in this file."„    LINE INPUT "Proceed anyway(Y/N)?"; A$„    IF UCASE$(A$) <> "Y" THEN END„END IF„„GET #1, , TotalX„GET #1, , TotalY„„PRINT TotalX;"x";TotalY;"x";„„GET #1, , ByteBuffer: A = ASC(ByteBuffer)„BitsPixel = (A AND 7) + 1„„GET #1, , ByteBuffer: Background = ASC(ByteBuffer)„GET #1, , ByteBuffer„„IF ASC(ByteBuffer) <> 0 THEN„    PRINT "Bad file."„    END„END IF„„PRINT 2^BitsPixel„„GET$ 1, (2^BitsPixel)*3, Pal$„„FOR I = 1 TO LEN(Pal$)„        Tmp? = ASC(MID$(Pal$,I,1))„        SHIFT RIGHT Tmp?,2„        MID$(Pal$,I,1)=CHR$(Tmp?)„NEXT I„„GET #1, , ByteBuffer„IF ByteBuffer <> "," THEN„    PRINT "Bad file."„    END„END IF„„GET #1, , Xstart„GET #1, , Ystart„GET #1, , Xlength„GET #1, , Ylength„Xend = Xlength + Xstart - 1: Yend = Ylength + Ystart - 1„„GET #1, , ByteBuffer„A = ASC(ByteBuffer)„IF (A AND 128) = 128 THEN„    PRINT "Local colormap encountered."„    END„ELSEIF (A AND 64) = 64 THEN„    PRINT "Image is interlaced!"„    END„END IF„„GET #1, , ByteBuffer„CodeSize = ASC(ByteBuffer): ClearCode = Powers2(CodeSize)„EOFCode = ClearCode + 1: FirstFree = ClearCode + 2„FreeCode = FirstFree: CodeSize = CodeSize + 1„InitCodeSize = CodeSize: Maxcode = MaxCodes(CodeSize - 2)„Bitmask = CodeMask(BitsPixel)„„GET #1, , ByteBuffer„BlockLength = ASC(ByteBuffer) + 1: Bitsin = 8„OutCount = 0„X = Xstart: Y = Ystart„„I$=INPUT$(1)„Mode13 1„„REG 1, &H1012„REG 2, 0„REG 3, 256„REG 4, STRPTR(Pal$)„REG 9, STRSEG(Pal$)„CALL INTERRUPT &H10„„DO„    Code = ReadCode(CodeSize)„    IF Code <> EOFCode THEN„        IF Code = ClearCode THEN„            CodeSize = InitCodeSize„            Maxcode = MaxCodes(CodeSize - 2): FreeCode = FirstFree„            Code = ReadCode(CodeSize): CurCode = Code„            OldCode = Code: FinChar = Code AND Bitmask„                                                PlotPixel FinChar„        ELSE„            CurCode = Code: InCode = Code„            IF Code >= FreeCode THEN„                CurCode = OldCode„                Outcode(OutCount) = FinChar„                OutCount = OutCount + 1„            END IF„            IF CurCode > Bitmask THEN„                DO„                    Outcode(OutCount) = Suffix(CurCode)„                    OutCount = OutCount + 1„                    CurCode = Prefix(CurCode)„                LOOP UNTIL CurCode <= Bitmask„            END IF„            FinChar = CurCode AND Bitmask„            Outcode(OutCount) = FinChar„            OutCount = OutCount + 1„            FOR I = OutCount - 1 TO 0 STEP -1„              PlotPixel OutCount„            NEXT„            OutCount = 0„            Prefix(FreeCode) = OldCode: Suffix(FreeCode) = FinChar„            OldCode = InCode: FreeCode = FreeCode + 1„            IF FreeCode >= Maxcode THEN„                IF CodeSize < 12 THEN„                    CodeSize = CodeSize + 1: Maxcode = Maxcode * 2„                END IF„            END IF„        END IF„    END IF„    A$ = INKEY$„LOOP UNTIL Code = EOFCode OR A$ <> ""„BEEP„IF A$ = "" THEN A$ = INPUT$(1)„„Mode13 0„END„„„'This subprogram gets one bit from the data stream.„FUNCTION Getbit STATIC„    SHARED Powers(), Bitsin, BlockLength, Num„    DIM ByteBuffer AS SHARED STRING * 1„    Bitsin = Bitsin + 1„    IF Bitsin = 9 THEN„        GET #1, , ByteBuffer„        TempChar = ASC(ByteBuffer)„        Bitsin = 1„        Num = Num + 1„        IF Num = BlockLength THEN„            BlockLength = TempChar + 1„            GET #1, , ByteBuffer„            TempChar = ASC(ByteBuffer)„            Num = 1„        END IF„    END IF„    IF (TempChar AND Powers(Bitsin)) = 0 THEN Getbit = 0 ELSE Getbit = 1„END FUNCTION„„'This subprogram plots one pixel on the display.„SUB PlotPixel (A) STATIC„                DEF SEG = &HA000„                        POKE Y*320+X, A„                DEF SEG„    X = X + 1„                IF X > Xend THEN„        X = Xstart„        Y = Y + 1„    END IF„END SUB„„'This subprogram reads one LZW code from the data stream.„„FUNCTION ReadCode (CodeSize)„    SHARED Powers2()„    Code = 0„    FOR Aa = 0 TO CodeSize - 1„        Code = Code + Getbit * Powers2(Aa)„    NEXT„    ReadCode = Code„END FUNCTION„„SUB Mode13(Bool)„        IF Bool THEN„                REG 1, &H0013„         ELSE„                REG 1, &H0003„        END IF„        CALL INTERRUPT &H10„END SUB„Dave Navarro, Jr.              PB PCX DECODER                 FidoNet POWER_BAS Echo         10-21-95 (18:54)       PB                     108  2578     DECPCX.BAS  'Decode PCX files„'by Dave Navarro, Jr.„„DEFINT A-Z„„TYPE PcxHeader„        Mfg    AS BYTE„        Ver    AS BYTE„        Enc    AS BYTE„        Bpp    AS BYTE„        XMin   AS INTEGER„        YMin   AS INTEGER„        XMax   AS INTEGER„        YMax   AS INTEGER„        Hres   AS INTEGER„        Vres   AS INTEGER„        Pal    AS STRING * 48„        Resrv  AS BYTE„        ColPl  AS BYTE„        Bpl    AS INTEGER„        PalTyp AS INTEGER„        Filler AS STRING * 58„END TYPE„„DIM Header AS PcxHeader„DIM ByteBuffer AS BYTE„„OPEN "B",1,"TMP.PCX"„         GET# 1,,Header„         IF Header.Mfg <> 10 AND Header.Ver <> 5 THEN„                 PRINT "Not a 256 color PCX file!"„                 END„         END IF„„         Tmp& = LOF(1) - 768„         SEEK# 1, Tmp&„         GET$ 1,768,Palete$„„         FOR I = 1 TO 768„                 Tmp? = ASC(MID$(Palete$,I,1))„                 SHIFT RIGHT Tmp?,2„                 MID$(Palete$,I,1)=CHR$(Tmp?)„         NEXT I„„         SEEK# 1, 128„„         Wid = Header.Xmax - Header.Xmin + 1„         Dep = Header.Ymax - Header.Ymin + 1„         Byt = Header.Bpl„„         PRINT Wid;"x";Dep;"x";2^Header.Bpp„„         I$=INPUT$(1)„„         Mode13 1„„         REG 1, &H1012„         REG 2, 0„         REG 3, 256„         REG 4, STRPTR(Palete$)„         REG 9, STRSEG(Palete$)„         CALL INTERRUPT &H10„„   FOR Y = 0 TO Dep - 1„                 FOR X = 0 TO Byt - 1„                         GET# 1,,ByteBuffer„                         ByteBuffer = ByteBuffer AND &HFF„                         IF (ByteBuffer AND &HC0) = &HC0 THEN„                                 Times = ByteBuffer AND &H3F„                                 GET# 1,,ByteBuffer„                                 FOR I = 1 TO Times„                                         PlotPixel ByteBuffer„                                 NEXT I„                                ELSE„                                         PlotPixel ByteBuffer„                         END IF„                 NEXT X„         NEXT Y„„CLOSE 1„„BEEP„I$=INPUT$(1)„Mode13 0„END„„„SUB PlotPixel(Z AS BYTE)„        SHARED Wid„        STATIC X, Y„        DEF SEG = &HA000„                POKE Y*320+X, Z„        DEF SEG„        INCR X„        IF X > Wid THEN„                X = 0„                INCR Y„        END IF„END SUB„„SUB Mode13(Bool)„        IF Bool THEN„                REG 1, &H0013„         ELSE„                REG 1, &H0003„        END IF„        CALL INTERRUPT &H10„END SUB„Brett Levin                    3D CRAFT WITH COLOR            Rich Geldreich                 09-19-92 (00:00)       QB, QBasic, PDS        448  15482    3DCOLOR.BAS 'Well, here you go! This is an improved, easier to read version of my„'fast 3-D wireframe program. I've done some things that a couple„'people recommended and I've also sped it up a little.„'(The number at the upper left corner of the screen is the number of„'frames per second that are being displayed. It's updated every 20 frames, so„'it will be a little choppy.)„„'3DEXP1b.BAS By Rich Geldreich April 16th, 1992„'„'Modifications by Brett Levin 9/19/92„'„'    I've added another option to the DATA statements that define„'  the lines, the last option is the color of that line.  To make„'  it easier to change and/or create new objects, there is an added„'  data statement near the end that defines the number of lines.„'  I've also fixed some spelling here and there and messed with„'  the interface.„'    The next thing that I think needs to be done is to add a D3, so„'  you can control the yaw (?) of the object.  We could use pgup/pgdwn„'  for this.  If you have any comments/questions, be sure to ask.„'„'    Rich- Be sure to tell me what you think of this.  I'm working on a„'  addition that will allow...  SCRIPTED ANIMATIONS!!  Cool huh?  Tell„'  me what you think.„'„'(This version has some documentation...)„DEFINT A-Z„„READ numberlines   ' First DATA statement near end of program„                   ' WARNING: Make sure you have less than 51 lines!„„TYPE LineType„    X AS INTEGER„    Y AS INTEGER„    Z AS INTEGER„    X1 AS INTEGER„    Y1 AS INTEGER„    Z1 AS INTEGER„    LineColor AS INTEGER„END TYPE„DIM Points(numberlines) AS LineType„DIM Xs(100), Ys(100), Xe(100), Ye(100), Xn(100), Yn(100)„DIM Xs1(100), Ys1(100), Xe1(100), Ye1(100)„DIM X(100), Y(100), Z(100), Pointers1(100), Pointers2(100)„DIM R(100)„DIM Cosine&(360), Sine&(360)„CLS„COLOR 15„PRINT "3-D Craft v.1b"„PRINT "By Rich Geldreich 1992"„PRINT "(Slight modifications by Brett Levin 9/19/92)": COLOR 7„PRINT„PRINT "Keys to use: (Turn NUMLOCK on!)"„COLOR 15: PRINT "  General controls": COLOR 7„PRINT "Q...............Quits"„COLOR 15: PRINT "  View controls": COLOR 7„PRINT "Numeric keypad..Controls your position(press 5 on the keypad"„PRINT "                to completly stop yourself) "„PRINT "-...............Move forward"„PRINT "+...............Move backward"„COLOR 15: PRINT "  Object controls": COLOR 7„PRINT "Arrow keys......Controls the rotation of the craft"„PRINT "F...............Accelerates the craft (Forward)"„PRINT "B...............Slows the craft (Backward)"„PRINT "S...............Stops the craft"„PRINT "A...............Toggles Auto Center, use this when you lose";„PRINT " the craft"„PRINT "C...............Stops the craft's rotation"„PRINT "V...............Resets the craft to starting position"„PRINT„PRINT "Wait a sec..."„„'The following for/next loop makes a sine & cosine table.„'Each sine & cosine is multiplied by 1024 and stored as long integers.„'This is done so that we don't have to use any slow floating point„'math at run time.„A = 0„FOR A! = 0 TO 359 / 57.29577951# STEP 1 / 57.29577951#„    Cosine&(A) = INT(.5 + COS(A!) * 1024)„    Sine&(A) = INT(.5 + SIN(A!) * 1024): A = A + 1„NEXT„„'Next we read in all of the lines that are in the object...„FOR A = 0 TO numberlines - 1„    READ Points(A).X, Points(A).Y, Points(A).Z„    READ Points(A).X1, Points(A).Y1, Points(A).Z1„    READ Points(A).LineColor„NEXT„'Here comes the hard part... Consider this scenario:„„'We have two connected lines, like this:„„'   1--------2 and 3„'            |„'            |„'            |„'            |„'            4„'Where 1,2, 3, & 4 are the starting and ending points of each line.„'The first line consists of points 1 & 2  and the second line„'is made of points 3 & 4.„'So, you ask, what's wrong? Nothing, really, but don't you see that„'points 2 and 3 are really at the sample place? Why rotate them twice,„'that would be a total waste of time? The following code eliminates such„'occurrences from the line table. (great explanation, huh?)„„'take all of the starting & ending points and put them in one big„'array...„Np = 0„FOR A = 0 TO numberlines - 1„    X(Np) = Points(A).X„    Y(Np) = Points(A).Y„    Z(Np) = Points(A).Z„    Np = Np + 1„    X(Np) = Points(A).X1„    Y(Np) = Points(A).Y1„    Z(Np) = Points(A).Z1„    Np = Np + 1„NEXT„'Now set up two sets of pointers that point to each point that a line„'is made of... (in other words, scan for the first occurrence of each„'starting and ending point in the point array we just built...)„FOR A = 0 TO numberlines - 1„    Xs = Points(A).X„    Ys = Points(A).Y„    Zs = Points(A).Z            'get the 3 coordinates of the start„    FOR B = 0 TO Np - 1         'scan the point array„        IF X(B) = Xs AND Y(B) = Ys AND Z(B) = Zs THEN„            Pointers1(A) = B    'set the pointer to point to the„            EXIT FOR            'point we have just found„        END IF„    NEXT„    Xs = Points(A).X1           'do the same thing that we did above„    Ys = Points(A).Y1           'except scan for the ending point„    Zs = Points(A).Z1           'of each line„    FOR B = 0 TO Np - 1„        IF X(B) = Xs AND Y(B) = Ys AND Z(B) = Zs THEN„            Pointers2(A) = B„            EXIT FOR„        END IF„    NEXT„NEXT„'Okay, were almost done! All we have to do now is to build a table„'that tells us which points to actually rotate...„Nr = 0„FOR A = 0 TO numberlines - 1„    F1 = Pointers1(A)   'get staring & ending point number„    S1 = Pointers2(A)„    IF Nr = 0 THEN      'if this is the first point then it of course„                        'has to be rotated„        R(Nr) = F1: Nr = Nr + 1„    ELSE„        Found = 0       'scan to see if this point already exists...„        FOR B = 0 TO Nr - 1„            IF R(B) = F1 THEN„                Found = -1: EXIT FOR    'shoot, it's already here!„            END IF„        NEXT„        IF NOT Found THEN R(Nr) = F1: Nr = Nr + 1   'point the point„                                                    'in the array it we„    END IF                                          'can't find it...„„    Found = 0   'now look for the ending point„    FOR B = 0 TO Nr - 1„        IF R(B) = S1 THEN„            Found = -1: EXIT FOR„        END IF„    NEXT„    IF NOT Found THEN R(Nr) = S1: Nr = Nr + 1„NEXT„PRINT "Press any key to begin..."„A$ = INPUT$(1)„'The following sets up the rotation & perspective variables.„„'Vs = the screen that is currently being viewed„'Ws = the screen that is currently being worked on„Vs = 1: Ws = 0„„'Deg1 & Deg2 are the two angles of rotation„'D1 & D2 are the deltas of each axes. If D1 = -5, for instance, then„'Deg1 will be decreased 5 degress every frame.„Deg1 = 0: Deg2 = 0: D1 = 0: D2 = 0„„'Spos & Mypos are for the perspective routines...„'Spos is the screen's Z coordinate and Mypos is the users Z coordinate„Spos = -250: Mypos = 0„„'Mx, My, and Mz are the coordinates of the user.„'Ox, Oy, and Oz are the coordinates of the craft.„Mx = 0: my = 0: Mz = 0: Ox = 0: Oy = 0: Oz = -260„'main loop„NumberOfFrames = 0„DEF SEG = &H40„StartTime = PEEK(&H6C)„DO„„    'swap the viewing and working screens for page flipping...„    SWAP Vs, Ws„    SCREEN 9, , Ws, Vs„„    'adjust the angles according to their deltas...„    Deg1 = (Deg1 + D1) MOD 360„    Deg2 = (Deg2 + D2) MOD 360„    'fix the angles up if they go out of range„    IF Deg1 < 0 THEN Deg1 = Deg1 + 360„    IF Deg2 < 0 THEN Deg2 = Deg2 + 360„    'get the sine and cosine of each angle from the tables„    'that were prepared at the beginning of the program„    C1& = Cosine&(Deg1): S1& = Sine&(Deg1)„    C2& = Cosine&(Deg2): S2& = Sine&(Deg2)„„    'now we must adjust the object's coordinates„    'based on how quickly it is moving...„„    X = Speed: Y = 0: Z = 0„„    X1 = (X * C1&) \ 1024: Y1 = (X * S1&) \ 1024„    X2 = (X1 * C2&) \ 1024: Zn = (X1 * S2&) \ 1024„    Ox = Ox + X2: Oy = Oy + Y1: Oz = Oz + Zn„    IF Oz > 32000 THEN Oz = 32000„    IF Oz < -32000 THEN Oz = -32000„    IF Ox > 32000 THEN Ox = 32000„    IF Ox < -32000 THEN Ox = -32000„    IF Oy > 32000 THEN Oy = 32000„    IF Oy < -32000 THEN Oy = -32000„„    'if Atloc is true then Auto-Center is on...„    IF AtLoc THEN„        Mx = Mx + (Ox - Mx) \ 4„        my = my + (Oy - my) \ 4„        Mz = Mz + ((Oz + 200) - Mz) \ 4„    ELSE„        'adjust the users position based on how much he is moving...„        Mz = Mz + Mzm: Mx = Mx + Mxm: my = my + Mym„        IF Mz > 32000 THEN Mz = 32000„        IF Mz < -32000 THEN Mz = -32000„        IF Mx > 32000 THEN Mx = 32000„        IF Mx < -32000 THEN Mx = -32000„        IF my > 32000 THEN my = 32000„        IF my < -32000 THEN my = -32000„    END IF„    '(Wait for vertical retrace, reduces flicker. This was recommended„    'by someone on the echo but I can't remember who! Thanks)„    WAIT &H3DA, 8„    'erase the old lines...„    IF Ws = 1 THEN„        FOR A = 0 TO Ln(Ws) - 1„            LINE (Xs1(A), Ys1(A))-(Xe1(A), Ye1(A)), 0„        NEXT„    ELSE„        FOR A = 0 TO Ln(Ws) - 1„            LINE (Xs(A), Ys(A))-(Xe(A), Ye(A)), 0„        NEXT„    END IF„    'print frames per second„    LOCATE 1, 1: PRINT A$„    'rotate the points...„    FOR A = 0 TO Nr - 1„        R = R(A): Xo = X(R): Yo = Y(R): Zo = Z(R)„        X1 = (Xo * C1& - Yo * S1&) \ 1024„        Y1& = (Xo * S1& + Yo * C1&) \ 1024 - my + Oy„        X1& = (X1 * C2& - Zo * S2&) \ 1024 - Mx + Ox„        Zn = (X1 * S2& + Zo * C2&) \ 1024 - Mz + Oz„        'if the point is too close(or behind) the viewer then„        'don't draw it...„        IF (Mypos - Zn) < 15 THEN„            Xn(R) = -1: Yn(R) = 0: Zn = 0„        ELSE„            'Put the point into perspective...„            'The original formula was:„            'Xnew=Xnew+( -Xold * ( (Spos-Z) / (MPos-Z) ) )„            'Ynew=Ynew=( -Yold * ( (Spos-Z) / (Mpos-Z) ) )„            V = (1330& * (Spos - Zn)) \ (Mypos - Zn)„            Xn(R) = 320 + X1& + (-X1& * V) \ 1330„„            'The Y coordinate is also multiplied by .8 to adjust„            'for SCREEN 9's height to width ratio...„„            Yn(R) = 175 + (8 * (Y1& + (-Y1& * V) \ 1330)) \ 10„        END IF„    NEXT„    'draw the lines...„    '(There are two seperate cases, each puts it's coordinates„    'in a different array for later erasing. I could of used a„    '2 dimensional array for this but that is slower.)„    IF Ws = 1 THEN„        Ln = 0„        FOR A = 0 TO numberlines - 1„            F1 = Pointers1(A): S1 = Pointers2(A)„            Xn = Xn(F1): Yn = Yn(F1)„            'if Xn<>-1 then it's in view...„            IF Xn <> -1 THEN„                IF Xn(S1) <> -1 THEN„                    X1 = Xn(S1): Y1 = Yn(S1)„                    LINE (X1, Y1)-(Xn, Yn), Points(A).LineColor„                    'store the lines so they can be erased later...„                    Xs1(Ln) = X1: Ys1(Ln) = Y1„                    Xe1(Ln) = Xn: Ye1(Ln) = Yn„                    Ln = Ln + 1„                END IF„            END IF„        NEXT„    ELSE„        Ln = 0„        FOR A = 0 TO numberlines - 1„            F1 = Pointers1(A): S1 = Pointers2(A)„            Xn = Xn(F1): Yn = Yn(F1)„            'if Xn<>-1 then it's in view...„            IF Xn <> -1 THEN„                IF Xn(S1) <> -1 THEN„                    X1 = Xn(S1): Y1 = Yn(S1)„                    LINE (X1, Y1)-(Xn, Yn), Points(A).LineColor„                    'store the lines so they can be erased later...„                    Xs(Ln) = X1: Ys(Ln) = Y1„                    Xe(Ln) = Xn: Ye(Ln) = Yn„                    Ln = Ln + 1„                END IF„            END IF„        NEXT„    END IF„    Ln(Ws) = Ln„    K$ = UCASE$(INKEY$)„    'Process the keystroke(if any)...„    IF K$ <> "" THEN„        SELECT CASE K$„            CASE "A"„                AtLoc = NOT AtLoc„            CASE "+"„                Mzm = Mzm + 2„            CASE "-"„                Mzm = Mzm - 2„            CASE "5"„                Mxm = 0: Mym = 0: Mzm = 0„            CASE "4"„                Mxm = Mxm - 2„            CASE "6"„                Mxm = Mxm + 2„            CASE "8"„                Mym = Mym - 2„            CASE "2"„                Mym = Mym + 2„            CASE "F"„                Speed = Speed + 5„            CASE "B"„                Speed = Speed - 5„            CASE "C"„                D1 = 0: D2 = 0„            CASE "S"„                Speed = 0„            CASE CHR$(0) + CHR$(72)„                D1 = D1 + 1„            CASE CHR$(0) + CHR$(80)„                D1 = D1 - 1„            CASE CHR$(0) + CHR$(75)„                D2 = D2 - 1„            CASE CHR$(0) + CHR$(77)„                D2 = D2 + 1„            CASE "Q"„                SCREEN 0, , 0, 0: CLS : PRINT "See ya later!"„                END„            CASE "V"„                D1 = 0: D2 = 0: Deg1 = 0: Deg2 = 0: Speed = 0„        END SELECT„    END IF„    NumberOfFrames = NumberOfFrames + 1„    'see if 20 frames have passed; if so then see„    'how long it took...„    IF NumberOfFrames = 20 THEN„        TotalTime = PEEK(&H6C) - StartTime„        IF TotalTime < 0 THEN TotalTime = TotalTime + 256„        FramesPerSecX100 = 36400 \ TotalTime„        High = FramesPerSecX100 \ 100„        Low = FramesPerSecX100 - High„        'A$ has the string that is printed at the upper left„        'corner of the screen„        A$ = MID$(STR$(High), 2) + "."„        A$ = A$ + RIGHT$("0" + MID$(STR$(Low), 2), 2) + "  "„        NumberOfFrames = 0„        StartTime = PEEK(&H6C)„    END IF„„LOOP„„'This defines the number of lines...„DATA 45„'The following data is the shuttle craft...„'stored as Start X,Y,Z, End X,Y,Z, Line color„„'  Note: I have added a little description to each section of the„'   line data to make it easier to experiment around with the colors..„'  Don't ask how long this took me... <G>„„' top„DATA -157,22,39,-157,-18,39,7„DATA -157,-18,39,-127,-38,39,7„DATA -127,-38,39,113,-38,39,7„DATA 113,-38,39,193,12,39,7„' bottom„DATA 33,42,39,33,42,-56,8„DATA 33,42,-56,-127,42,-56,8„DATA -127,42,-56,-157,22,-56,8„DATA -157,22,-56,-157,22,39,8„' top„DATA -157,22,-56,-157,-18,-56,7„DATA -157,-18,-56,-157,-18,39,7„DATA -157,-18,-56,-127,-38,-56,7„DATA -127,-38,-56,-127,-38,39,7„DATA -127,-38,-56,113,-38,-56,7„DATA 113,-38,-56,113,-38,39,7„DATA 113,-38,-56,193,12,-56,7„' bottom„DATA 193,12,-56,193,12,39,8„DATA -157,22,-56,193,12,-56,8„DATA 193,12,39,-157,22,39,8„' writing„DATA -56,-13,41,-56,-3,41,12„DATA -56,-3,41,-26,-3,41,13„DATA -26,-3,41,-26,7,41,4„DATA -51,7,41,-31,-13,41,5„DATA -11,-13,41,-11,-3,41,5„DATA -11,-3,41,-1,7,41,4„DATA 9,7,41,9,-8,41,13„DATA 9,-8,41,24,-8,41,12„' top„DATA 34,16,41,34,-38,41,7„DATA 33,-39,41,33,-39,-53,7„DATA 33,-39,-53,33,15,-53,7„' hatch„DATA -42,-38,19,-72,-38,19,4„DATA -72,-38,19,-72,-38,-41,4„DATA -72,-38,-41,-42,-38,-41,4„DATA -42,-38,-41,-42,-38,19,4„' bottom„DATA 33,42,39,34,16,41,8    „DATA 33,42,-56,33,15,-53,8  „DATA -157,22,39,-127,42,39,8„DATA -127,42,-56,-127,42,39,8„DATA -127,42,39,33,42,39,8 „' window„DATA 159,-8,-56,159,-8,40,9 „DATA 143,-18,-56,143,-18,39,9„' bottom„DATA 193,12,39,193,32,30,8  „DATA 33,42,39,193,32,30,8   „DATA 193,32,30,193,32,-47,8 „DATA 33,42,-56,193,32,-47,8 „DATA 193,12,-56,193,32,-47,8„„