Douglas Lusher                 READ/CHANGE BAUD RATE          FidoNet QUIK_BAS Echo          Unknown Date           QB, QBasic, PDS        129  4064     UART.BAS    ' >  BTW, what's MCR???„„'  Modem Control Register.„„' >  'Douglas Lusher posted some code sometime back showing how„' >  'to read and change the baud rate using INP/OUT.„„„ FUNCTION UARTpresent% (CommPort%)„ 'returns True (-1) if a National Semiconductor UART (8250B,„ '  16450, 16550, or 16550A) is present at the comm port„ '  specified. If communications is in progress on the port,„ '  it will be disrupted by running this proceedure.„ 'Based on Pascal code by Jeff Duntemann„ '  in Dr. Dobbs Journal, July 1991„ ' assume False, UART not detected„ UARTpresent% = 0„ ' a constant„ LoopBit% = &H10„ ' get the base address for the specified port„ SELECT CASE CommPort%„   CASE 1: PortBase% = &H3F8„   CASE 2: PortBase% = &H2F8„   CASE 3: PortBase% = &H3E8„   CASE 4: PortBase% = &H2E8„   CASE ELSE: ERROR 5„ END SELECT„ RBRPort% = PortBase%„ THRPort% = RBRPort%„ MCRPort% = RBRPort% + 4„ MSRPort% = RBRPort% + 6„ ' put UART into loopback test mode:„ ' first, save the current value of MCR„ HoldMCR% = INP(MCRPort%)„ ' turn on loopback test mode„ OUT MCRPort%, HoldMCR% OR LoopBit%„ HoldMSR% = INP(MSRPort%)„ ' out a specific pattern of bits„ OUT MCRPort%, &HA OR LoopBit%„ ' see if the correct pattern of bits comes back„ Temp% = INP(MSRPort%) AND &HF0„ IF Temp% = &H90 THEN UARTpresent% = -1„ ' restore the value of MSR„ OUT MSRPort%, HoldMSR%„ ' take the UART out of loopback mode and restore„ ' original value of MCR„ OUT MCRPort%, HoldMCR AND NOT LoopBit%„ END FUNCTION„„ FUNCTION UARTtype% (CommPort%)„ 'returns the type of UART installed at the specified comm port„ ' 0 = error (bad UART or no UART at this comm port)„ ' 1 = 8250, usually (not always) found in PC or XT„ ' 2 = 16450, usually found in AT class machines„ ' 3 = 16550, found in PS/2 mod 50/60/early 80.  FIFOs don't work!„ ' 4 = 16550A, found in later PS/2's. FIFOs fully operative.„ 'Based on Pascal code by Jeff Duntemann„ '  in Dr. Dobbs Journal, July 1991„„ ' get the base address for the specified port„ SELECT CASE CommPort%„   CASE 1: PortBase% = &H3F8„   CASE 2: PortBase% = &H2F8„   CASE 3: PortBase% = &H3E8„   CASE 4: PortBase% = &H2E8„   CASE ELSE: ERROR 5„ END SELECT„„ FCRport% = PortBase% + 2„ IIRport% = FCRport%„ Scratchport% = PortBase% + 7„ ' write a pattern of bits to the scratch register„ OUT Scratchport%, &HAA„ ' attempt to read it back„ IF INP(Scratchport%) <> &HAA THEN„   ' a UART w/o a scratch register is an 8250„   UARTtype% = 1„ ELSE„   ' setting bit zero of the FCR port enables FIFO buffers„   OUT FCRport%, &H1„   ' get the FIFO status bits„   Temp% = INP(IIRport%) AND &HC0„   SELECT CASE Temp%„     ' if bits 6 & 7 are set it is a 16550A„     CASE &HC0: UARTtype% = 4„     ' if bit 7 is set and bit 6 is clear it is a 16550„     CASE &H80: UARTtype% = 3„     ' neither bit 6 or bit 7 set means it is a 16450„     CASE &H0: UARTtype% = 2„     ' error occured„     CASE ELSE: UARTtype% = 0„   END SELECT„   ' disable the FIFO buffers„   OUT FCRport%, &H0„ END IF„„ END FUNCTION„„ FUNCTION BaudRate& (CommPort%)„ 'returns the current baud rate for the specifed port„ BaudRate& = 0„ SELECT CASE CommPort%„   CASE 1: BaseAddr% = &H3F8„   CASE 2: BaseAddr% = &H2F8„   CASE ELSE: EXIT FUNCTION„ END SELECT„ OUT BaseAddr% + 3, INP(BaseAddr% + 3) OR &H80„ LSB% = INP(BaseAddr%)„ MSB% = INP(BaseAddr% + 1)„ OUT BaseAddr% + 3, INP(BaseAddr% + 3) AND &H7F„ Divisor& = (MSB% * &H100) + LSB%„ IF Divisor& THEN BaudRate& = 115200 \ Divisor&„ EXIT FUNCTION„„ SUB SetBaudRate (CommPort%, NewBaudRate&)„ ' Dr. Dobbs Journal, May 1991, pg. 127„ SELECT CASE CommPort%„   CASE 1: BaseAddr% = &H3F8„   CASE 2: BaseAddr% = &H2F8„   CASE ELSE: EXIT SUB„ END SELECT„ LCR% = BaseAddr% + 3„ Divisor% = 115200 \ NewBaudRate&„ Temp% = INP(LCR%)„ OUT LCR%, Temp% OR &H80           ' OUT LCR%, INP(LCR%) OR &H80„ OUT BaseAddr% + 1, Divisor% \ &H100„ OUT BaseAddr%, Divisor% AND &HFF„ OUT LCR%, Temp% AND &H7F          ' OUT LCR%, INP(LCR%) AND &H7F„ END SUB„Chad Beck                      COM ROUTINES                   FidoNet QUIK_BAS Echo          11-09-95 (02:12)       QB, QBasic, PDS        62   3401     COM.BAS     ' > I am STILL in need of a routine to initialize com ports 1 through 4„' > at speeds  up to hopefully 115,200bps... My routines have stopped„' > working. I do NOT need  any routines for writing/reading port data,„' > all I need is something to set the  bps rate, and maybe the parity,„' > data bits, and stop bits as well. Doesn't anyone have source that„' > meets these requirements?„„'     Alright, alright.  You've suffered long enough.  To set the BPS„'rate, first you need to calculate the Baud Rate Divisor, then set bit 7„'of the Line Control Register on, then write the Baud Rate Divisor, the„'set bit 7 of the Line Control Register back off.  This is untested:„„    BRD = 1843200 \ (16 * BitRate)           'calculate Baud Rate Divisor„„    Byte = INP(ComAddress + 3) OR 128        'set bit 7 of LCR high„    OUT ComAddress + 3, Byte„„    OUT ComAddress + 1, BRD \ 256             'MSB of BRD„    OUT ComAddress, BRD AND 255               'LSB of BRD„„    Byte = INP(ComAddress + 3) AND 127       'set bit 7 of LCR low„    OUT ComAddress + 3, Byte„„                                ---***---„„     The Parity, Data & Stop bits are easier:„„    OUT ComAddress + 3, Byte„„     The bit values of Byte are as follows (I'll spare the high ASCII):„------------------------------------------------------------------------„|   Bit #      Meaning             Setting                             |„|----------------------------------------------------------------------|„|    0-1       Character length                                        |„|                   5 bits           00                                |„|                   6 bits           01                                |„|                   7 bits           10                                |„|                   8 bits           11                                |„|     2        Stop bits                                               |„|                   1 bit             0                                |„|                   1.5 bits          1 (5-bit characters)             |„|                   2 bits            1 (6, 7 & 8-bit characters)      |„|    3-5       Parity                                                  |„|                   Ignore           000                               |„|                   Odd              100                               |„|                   Even             110                               |„|                   Mark             101                               |„|                   Space            111                               |„|     6        Break condition                                         |„|                   Disabled          0                                |„|                   Enabled           1                                |„|     7        Port toggle                                             |„|                   Normal            0 (use THR/RDR & IER registers)  |„|                   Alternate         1 (use BRDL & BRDH registers)    |„|                                                                      |„------------------------------------------------------------------------„„     So, for instance, 8 data bits, 1 stop bit and no parity is 00000011„binary (3) while 7 data bits, 1 stop bit and even parity is 00011010„binary (26).„     Make sense?  Let's hope so.„„Erik Olson                     ANSI MODEM TERMINAL            Rolf@ice.prima.ruhr.de         05-16-94 (23:20)       PB                     539  12416    TERMINAL.BAS' Ansi modem terminal program for PowerBASIC„' Public Domain by Erik Olson„„$OPTION CNTLBREAK OFF„$COM 2048„$STRING 4„$LIB GRAPH OFF„$LIB IPRINT OFF„$LIB LPT ON„$LIB COM ON„$FLOAT EMULATE„$COMPILE EXE„„%FALSE = 0„%TRUE  = NOT %FALSE„„' sound effects„DECLARE SUB BELL()„DECLARE SUB DAGNABBIT()„DECLARE SUB FWEEP()„DECLARE SUB FWOP()„DECLARE SUB YIPPEE()„„' support routines„DECLARE SUB TERMINAL(STRING)„DECLARE FUNCTION POPDIR$(STRING)„„ON ERROR GOTO ErrorHandler„„DIM MENU$(10)„SHARED MENU$(), TermScreen$, Termx%, Termy%, ScrnBuf%„„CLS„FWEEP„MESSAGE "ANSI MODEM TERMINAL"„DELAY .5„MESSAGE "PowerBASIC 3.00b"„DELAY .5„MESSAGE "INITIALIZING PORTS"„SETPORTS„DELAY .3„MESSAGE "VERIFY PARAMETERS"„BELL„„A$ = DIR$("OPENCOM.DAT")„IF A$="" THEN„	P$="COM2:2400,N,8,1,RS,CS,CD,DS,ME    "„ELSE„	OPEN A$ FOR INPUT AS #1„	LINE INPUT #1, P$„	CLOSE #1„END IF„P$=P$+SPACE$(40-LEN(P$))„P$=EDITBOX$(P$)„IF P$="" THEN END ELSE OPEN "OPENCOM.DAT" FOR OUTPUT AS #1:PRINT #1, P$:CLOSE„„TERMINAL P$„„LOCATE 25,1:END„„„' ==========[subroutines]=============„„„„SUB TERMINAL(Parameter$)„IF Parameter$ = "" THEN EXIT SUB„ComBuf% = FREEFILE„CapBuf% = 9„PrnBuf% = 10„OPEN Parameter$ FOR RANDOM AS #ComBuf%„ScrnBuf% = FREEFILE„OPEN "CONS:" FOR OUTPUT AS #ScrnBuf%„IF LEN(TermScreen$) THEN„	RESTORESCREEN TermScreen$:ANSILOCATE Termx%, Termy%„	LOCATE Termx%,Termy%,1„ELSE„	CLS:ANSILOCATE 1,1:LOCATE 1,1,1„END IF„PRINT #ScrnBuf%, "PowerBASIC 3.00b Modem Terminal Program"„PRINT #ScrnBuf%, "Terminal Mode ˛ Press INSERT for menu"„PRINT #ScrnBuf%, "RESETTING MODEM..."„RESETMODEM ComBuf%„BELL„„DO„	A$=INKEY$„	IF A$=CHR$(27) THEN A$=CHR$(0,82)„	IF LEN(A$) = 2 THEN„		ANSICURSOR x%,y%„		LOCATE x%,y%,0„		SELECT CASE A$„		CASE CHR$(0,45)   'alt-X = quit„		CLS:PRINT "Wait...":RESETMODEM ComBuf%:PRINT "*** End Program"„		LOCATE 25,1,1:CHAIN "PA(CAR).EXE"     'END„„			CASE CHR$(0,72) '  up arrow„			Print #Combuf%,chr$(27)+"]A";„			CASE CHR$(0,75) '  left arrow„			Print #Combuf%,chr$(27)+"]C";„			CASE CHR$(0,77) '  right arrow„			Print #Combuf%,chr$(27)+"]D";„			CASE CHR$(0,79) '  end„			Print #Combuf%,chr$(27)+"]K";„			CASE CHR$(0,80) '  down arrow„			Print #Combuf%,chr$(27)+"]B";„			CASE CHR$(0,71) '  home„			Print #Combuf%,chr$(27)+"]H";„			CASE CHR$(0,83) '  Delete„			Print #Combuf%,chr$(&H7F);„„			CASE CHR$(0,104) ' ALT-F1„			O$=SAVESCREEN$„			FWEEP„			IF Capture%=0 THEN MESSAGE "CAPTURE FILENAME:"„			INCR Capture%„			IF Capture% THEN Cap$=EditBox$("                      ")„			IF Cap$="" THEN Capture%=0„			FWEEP„			IF Capture%=1 THEN„				Capture%=-1„				MESSAGE "CAPTURE ON"„				OPEN Cap$ FOR APPEND AS #CapBuf%„			ELSE„				MESSAGE "CAPTURE OFF"„				CLOSE #CapBuf%„			END IF„			DELAY 1„			RESTORESCREEN O$„„			CASE CHR$(0,38)  ' ALT-L„			O$=SAVESCREEN$„			INCR Printer%„			FWEEP„			IF Printer%=1 THEN„				Printer%=-1„				MESSAGE "PRINTER ON"„			ELSE„				MESSAGE "PRINTER OFF"„			END IF„			DELAY 1„			RESTORESCREEN O$„			CASE CHR$(0,35)  ' ALT-H„				O$=SAVESCREEN$„				FWEEP„				MESSAGE "RESETTING MODEM..."„				RESETMODEM Combuf%„				FWOP„				RESTORESCREEN O$„		ANSILOCATE x%,y%„                CASE ELSE„                'menu„                O$ = SAVESCREEN$„                ANSICURSOR X%, Y%„                MENU$(1) = "Dial a Number  "„		MENU$(2) = "Toggle Capture "„		MENU$(3) = "Toggle Printing"„		MENU$(4) = "End Session    "„		MENU$(5) = ""„                FWEEP„                SELECT CASE POPMENU(MENU$())„                        CASE 1„				O2$=SAVESCREEN$„				MESSAGE "Number to Dial"„				A$ = EDITBOX$("                      ")„				RESTORESCREEN O2$„				IF LEN(A$) THEN„					RESETMODEM ComBuf%„					DELAY 1„					PRINT #ComBuf%, "ATDT"+A$„				END IF„„			CASE 2„			FWEEP„			IF Capture%=0 THEN MESSAGE "CAPTURE FILENAME:"„			INCR Capture%„			IF Capture% THEN Cap$=EditBox$("                      ")„			IF Cap$="" THEN Capture%=0„			FWEEP„			IF Capture%=1 THEN„				Capture%=-1„				MESSAGE "CAPTURE ON"„				OPEN Cap$ FOR APPEND AS #CapBuf%„			ELSE„				MESSAGE "CAPTURE OFF"„				CLOSE #CapBuf%„			END IF„			DELAY 1„			CASE 3„			INCR Printer%„			FWEEP„			IF Printer%=1 THEN„				Printer%=-1„				MESSAGE "PRINTER ON"„			ELSE„				MESSAGE "PRINTER OFF"„			END IF„			DELAY 1„			CASE 4   ' end session„			MESSAGE "RESETTING MODEM"„			RESETMODEM ComBuf%„			AbortFlag% = %TRUE:CHAIN "PA(CAR).EXE"„                        CASE ELSE„                        FWOP„                END SELECT„                RESTORESCREEN O$„		FWOP„		ANSILOCATE X%,Y%„        END SELECT„        IF AbortFlag% THEN EXIT LOOP„        ELSE  ' len a$ does not equal 2„                PRINT #ComBuf%,A$;„	END IF ' len a$„„                IF LOC(ComBuf%) THEN„                        A$=INPUT$(1,ComBuf%)„                        IF A$=CHR$(8) THEN A$=CHR$(8)+" "+CHR$(8)„                        IF A$ = CHR$(7) THEN A$ = "": BELL„„			IF Printer% THEN LPRINT A$;„			IF Capture% THEN PRINT #CapBuf%, A$;„			PRINT #ScrnBuf% , A$;„                END IF„LOOP„CLOSE #ComBuf„TermScreen$ = SAVESCREEN$„ANSICURSOR Termx%, Termy%„END„„END SUB„„SUB SETPORTS„def seg=&h40„poke 0,&hf8  '03F8  sets com1 address irq 4„poke 1,&h03„poke 2,&hf8  '02F8  sets com2 address irq 3„poke 3,&h02„poke 4,&he8  '03E8  sets com3 address irq 4„poke 5,&h03„poke 6,&he8  '02E8  sets com4 address irq 3„poke 7,&h02„def seg„„END SUB„„SUB RESETMODEM(m%)„	DELAY 1.1„	PRINT #m%,"+"; : DELAY .3„	PRINT #m%,"+"; : DELAY .3„	PRINT #m%,"+"; : DELAY 1.1„	PRINT #m%,"ATZ"„	DELAY .5„END SUB„„„FUNCTION SaveScreen$„REG 1, 15*256„CALL INTERRUPT &H10„IF Reg(1) - (Reg(1)\256) * 256 = 7 THEN Address=&HB000 else Address=&HB800„DEF SEG = ADDRESS„SaveScreen$=PEEK$(0,4000)„DEF SEG„END FUNCTION„„SUB RestoreScreen(S$)„REG 1, 15*256„CALL INTERRUPT &H10„IF Reg(1) - (Reg(1)\256) * 256 = 7 THEN Address=&HB000 else Address=&HB800„DEF SEG = Address„POKE$ 0, S$„DEF SEG„END SUB„„FUNCTION PopMenu(item$())„' Center a scrolling menu on the screen containing options in Item$()„' This function returns the number of the selected item, or 0 if ESC pressed.„COLOR 0,7„MenWid=0:MenHi=0„DO:MenHi=MenHi+1:IF LEN(Item$(MenHi))>MenWid then MenWid=LEN(Item$(MenHi))„LOOP WHILE LEN(Item$(MenHi))„MenHi=MenHi:MenWid=MenWid+4„„' Menu box is MenHi x MenWid„		wa% = 12 - (MenHi\2)„		wb% = 40 - (MenWid\2)„		wc% = wa% + MenHi„		wd% = wb% + MenWid„CALL SingleBox(Wa%,Wb%,Wc%,Wd%)„„For y=1 to MenHi-1„	Locate 12 - (MenHi\2) + y, 42 - (MenWid\2):Print Item$(y)„Next y„„	PopMe=1„	DO„	Locate 12 - (MenHi\2) + PopMe,42-(MenWid\2),0„		 Color 7,0 : Print Item$(PopMe) : Color 0,7„	do:a$ = Inkey$:loop while a$=""„		If Len(a$) = 2 THEN a=asc(right$(a$,1)) else a=asc(a$)„„„		SELECT CASE a„„		CASE &H48 ' up arrow„		Locate 12 - (MenHi\2) + PopMe,42-(MenWid\2)„		Print Item$(PopMe)„		PopMe=PopMe-1„		If PopMe = 0 then PopMe = MenHi-1„„		CASE &H50 ' dn arrow„		Locate 12 - (MenHi\2) + PopMe,42-(MenWid\2)„		Print Item$(PopMe)„		PopMe=PopMe+1„		If PopMe = MenHi then PopMe = 1„„„		CASE &H47   ' home„                Locate 12 - (MenHi\2) + PopMe,42-(MenWid\2)„		Print Item$(PopMe)„		PopMe=1„„„		CASE      &H4D      ' right arrow ........ it could happen„		CASE      &H4B      ' left arrow„				    ' these keys might indicate that the„				    ' user wants to move horizontally to„				    ' another menu.  See CASEKEYS.BAS for„				    ' a generic keyboard polling CASE struct„„„„		CASE      &H51      ' page down„		Locate 12 - (MenHi\2) + PopMe,42-(MenWid\2)„		Print Item$(PopMe)„		PopMe=MenHi„„		CASE      &H49      ' page up„                Locate 12 - (MenHi\2) + PopMe,42-(MenWid\2)„		Print Item$(PopMe)„		PopMe=1„„		CASE 27   ' escape„		PopMenu=0 : Exit Loop„„		CASE 13„		PopMenu=PopMe : Exit Loop„„		CASE ELSE„		END SELECT„„„loop„„COLOR 7,0„END FUNCTION„„„„„FUNCTION EditBox$(Default$)„„COLOR 0,7„CALL SingleBox(19, 38-(LEN(Default$)\2), 21, 42+(LEN(Default$)\2))„y = 40 - (LEN(Default$) \ 2) : YY=len(rtrim$(default$))„DO„„„   LOCATE 20,Y,0:PRINT Default$  ' if you want to put the box somewhere„   LOCATE  20,Y+yy,1             ' else, change these locate statements„„„   DO:A$=INKEY$:LOOP WHILE LEN(A$)=0„   IF LEN(A$) THEN„      SELECT CASE(A$)„      CASE CHR$(27), CHR$(13)„         EXIT SELECT„      CASE CHR$(8)„         IF YY THEN„            YY=YY-1„            IF YY THEN„               Default$=LEFT$(Default$,yy)+MID$(Default$,yy+2) + " "„            ELSE„               Default$=MID$(Default$,yy+2) + " "„            END IF„         END IF„      CASE CHR$(0)+CHR$(83)„         IF YY THEN„            Default$=LEFT$(Default$,yy)+MID$(Default$,yy+2) + " "„         ELSE„            Default$=MID$(Default$,yy+2) + " "„         END IF„      CASE CHR$(0)+CHR$(&H4D)„         IF YY < LEN(Default$) THEN YY=YY+1„      CASE CHR$(0)+CHR$(&H4B)„         IF YY THEN YY=YY-1„      CASE CHR$(0)+CHR$(79) 'end„         yy=LEN(RTRIM$(default$))„      CASE CHR$(0)+CHR$(71)„         yy=0„„      CASE ELSE„         IF LEN(A$)=1 and YY=0 THEN Default$=SPACE$(LEN(default$))„         IF LEN(A$)=1 and YY < LEN(Default$) THEN_„         MID$(Default$,YY+1,1) = A$ : YY=YY+1„„      END SELECT„      IF A$=CHR$(27) THEN EditBox$="":EXIT LOOP„      IF A$=CHR$(13) THEN EditBox$=RTRIM$(Default$):EXIT LOOP„„   END IF„LOOP„COLOR 7,0„END FUNCTION„„„SUB SingleBox (Wa%, Wb%, Wc%, Wd%) PUBLIC„„REG 1, 15*256„CALL INTERRUPT &H10„IF Reg(1) - (Reg(1)\256) * 256 = 7 THEN Address&=&HB000 else Address&=&HB800„DEF SEG = ADDRESS&„„   LOCATE Wa%, Wb%,0: PRINT CHR$(213) + STRING$((Wd% - Wb%) - 1, 205) + CHR$(184)„   LOCATE Wc%, Wb%: PRINT CHR$(212) + STRING$((Wd% - Wb%) - 1, 205) + CHR$(190)„„   FOR zxy% = 1 TO Wc% - Wa% - 1„      LOCATE Wa% + zxy%, Wb%„      PRINT CHR$(179) + SPACE$((Wd% - Wb%) - 1) + CHR$(179)„        ' right side of the box is Wa+zxy *80 + Wd + 1„	' stuff an attribute into there„	POKE ( (Wa%+Zxy%) * 160 ) + (Wd%*2) + 1,8„   NEXT zxy%„        for i%=(Wc% * 160) + ((wb%+2)*2)-1 TO (Wc%*160) + ((Wd%*2)+2)-1 STEP 2„        ' What this does is calculate the memory locations of the characters„        ' in video ram„        POKE i%, 8„	Next i%„DEF SEG„END SUB„„SUB Message (E$)„   CALL SingleBox(10, 20, 12, 60)„   LOCATE 11, 40 - (LEN(E$) \ 2)„   PRINT E$;„END SUB„„FUNCTION YesNo (Prompt$)„IF LEN(Prompt$) < 15 THEN Prompt$ = SPACE$(8 - LEN(Prompt$) \ 2) + Prompt$ + SPACE$(8 - LEN(Prompt$) \ 2)„Wb% = 38 - LEN(Prompt$) \ 2„Wd% = 42 + LEN(Prompt$) \ 2„Wa% = CSRLIN„Wc% = Wa% + 3„CALL SingleBox(Wa%, Wb%, Wc%, Wd%)„LOCATE Wa% + 1, 40 - LEN(Prompt$) \ 2: PRINT Prompt$„YorN = -1„LET YorN$ = "<Yes>    No "„DO„   LOCATE Wa% + 2, 34: PRINT YorN$„   DO: A$ = INKEY$: LOOP WHILE A$ = ""„   IF UCASE$(A$) = "Y" THEN YorN = -1„   IF UCASE$(A$) = "N" THEN YorN = 0„   IF A$ = CHR$(0) + CHR$(&H4D) THEN YorN = 0„   IF A$ = CHR$(0) + CHR$(&H4B) THEN YorN = -1„   IF A$ = CHR$(13) THEN EXIT LOOP„   IF YorN THEN LET YorN$ = "<Yes>    No " ELSE LET YorN$ = " Yes    <No>"„„LOOP„YesNo = YorN„„END FUNCTION„„SUB SETHIBIT ' toggle blink to intensity bit„	REG 1,&H1003„	REG 2,0„	CALL INTERRUPT &H10„END SUB„„SUB ANSILOCATE(ROW%, COL%)   'Sets BIOS cursor„	LOCATE Row%,Col%,1„	REG 1,&H0200„	REG 2,0„	REG 3,(Row%*256)+COL%„	CALL INTERRUPT &H10„END SUB„„SUB ANSICURSOR(ROW%, COL%)   'Returns the current position of the cursor„REG 1,&H0300„REG 2,0„CALL INTERRUPT &H10„ROW% = (REG(4) \ 256) + 1„COL% = (REG(4) AND &HFF) + 1„END SUB„„SUB FWEEP„For y% = 800 TO 1800 STEP 200„SOUND y%,.1„NEXT y%„END SUB„„SUB FWOP„FOR y% = 1800 TO 800 STEP -200„SOUND y%, .1„NEXT y%„END SUB„„SUB YIPPEE„SOUND 1000,1:SOUND 2000,1:SOUND 3000,1„END SUB„„SUB DAGNABBIT„SOUND 50,5„END SUB„„SUB BELL„Sound 1000,.1„SOUND 5000,.1„SOUND 2500,.1„SOUND 1000,.1„DELAY 1„END SUB„„„ErrorHandler:„„E = Err„EO$=SAVESCREEN$„DAGNABBIT„FWOP:FWOP:FWOP„MESSAGE "ERROR:" + STR$(E)„LOCATE 19,1„IF YesNo("Continue?") THEN RESTORESCREEN EO$:RESUME NEXT„FWEEP„LOCATE 19,1„IF YesNo("Exit to DOS?") THEN CLS:END„FWEEP„RESTORESCREEN EO$:MESSAGE "RESETTING MODEM...":RESETMODEM ComBuf%„RESTORESCREEN EO$„RUN„„Erik Olson                     PB FOSSIL ROUTINES             Rolf@ice.prima.ruhr.de         08-14-94 (02:57)       PB                     127  8372     PBFOSL.BAS  ' Please run under PowerBASIC to extract PBFOSL.ZIP„DEFINT A-Z: SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"PBFOSL.ZIP",4^6:Z&=5973:?STRING$(50,177);„U"%up()%9%%%.-%*y&n>%5,=&S1%%%DI%%%0%%%%ug%kxht%rSgfFx.><nBG0rJBb„U"BN2onm71$UXr[&$^tbaD1_o>K*Zj/1Fg$2b64I'Y-E:\aO[?vnNHq8F.DPA2E)F„U"t[XI-WXD.I%]MBtO8Z%YLSgkh-EiIP=6:nB6$$V$Z3[dOrgi&$VhfK]84l\QWfL„U"N#%Zs&aFRuJh3p&,o)F-m/.XDk4f'h%KnDPg7xN0EdIL;.keDW8j5gRs1=YOmC;„U"TL>F3wYQ\OSJ).5[$uBxSF[CI_EO27xgveW]**8_)YjAj22tcI;k)M3p>s)4q7f„U"2fXq9#yGZ^F7Bgti%ug(kXh>:5vi:93+?t4rtXmOKiFIp\Kf)l&_*<Pdj>:qLYa„U"aAMn;cuMVR#NLYKB/m-,6T$gC%<3t#>c2i[0j>t+m-rc\6i'^v.]Q48Q4#I)0hG„U"S3G&59f15ijsK0&X]RXB0u7=AzEoq-+&'5dP^A2D.oKC\S2l\^^Ctxt0L?_m-Q/„U"C&v9c7$G8-LgI]0+4ugJK4W[*E)p>.55:+56A[gFhmqI>a'EakV\09CEGx03r1E„U")<R(nnm'_kYMZmC:Y,/6K'9,)a\<UL?RIC0&aY2me[+Fcm^J)u?lg/0cra2ZLDZ„U"ot+c$ufD?brpllL=DGT<4;k$X+:W5R3*%KIo:8^I?751]661Co9Y=3c8XJnfUk=„U"77[L98dLi$.Ej/-xDkC+e+.8>Ao5KfW<&t6*D<&&#g*sh:-.JK*'8wtB;3'.'=X„U"/qM9(Z64XVGXqb\Oz9r>\EhoJm:RXCRodhm&+,LFkokgTs(D;a[htgT$Emv.Y1S„U"x^-xiOq'M*KS:6Iu&Tci.-5)EuFMCT=S:%nNY_qM>=;V9'Gt=0bP:a]6pH,JC%S„U"&Cv:foCX_pS%.%Jw>P]RKxHl#qA#L<;xHP7Ldh.fic];r]Hi[AM,>(aYN4K/5Ti„U".l5HI4%Z#o3<Q-\OyRx2[8UFL*?b*m:,5&y4gHOD^:7rV26D=tH(NNU))&=W6mO„U"S8mtw'[OrrUTg)B8*Rzm6x/2;vW0ZOyo0M+jG1OQ=w[Ka8G?Iv)]T-),Vuj5tbp„U"BGiW*c0&m'.qg4Yj%jXEZz&0E+(u-XyCK(nPkf+PhDrLJ%O3t,%?rN9ePraBS=j„U"CiG%z5[aOmBkjZVBqCMQ9hEcx?[IH&t/f2WtOtVr+P_sV2r/*38[P)D[2WryOZE„U"6B,10byeqNQ#f=xnda<NbCo-XPiq_xNyD$ka/?dzIDB&A:ypE8op;BQC.QrEdC(„U"miK[A+2+bXOS,XVWCeU4JsOnDEG*RGs,6gfY<_&I=2.(ZX/'-B1FFoXakkhe+j*„U"/yQ%5RM*4jq,puNqdi1plU7Bdu_SGMbq84#o;ham'w0'C5-T^'pt.1[TMS$e6DK„U"];Qb9I^kD$MTHR*.Dk[gy88$-[;/8aJW['-3n_XfEr1lg$lq84<KCAH69_<:LpK„U"y$jsgc7S5KK(1<z/j5JUcT'7)vgY:I#pGlG/C\9b#LHqp3nk+T-*r)YfN*NiQp:„U"xk/p5_UQ)$Wa.ER5fLEedyGjI?ut2JQR]5Dn2-0hFsTT34PJ6LT0_RtC2QhGSB+„U")q8hv.->'OB)I0wM.OWXE[gfw/QM#u_>.f=Gpl;K<c4Iemf,,W/6)$u[U-Mjgt(„U"'E+$t.PU/eSIbwPC<PH/>qN;^0x11-wgkfa5=2(/YVcRE_7dnHnS9jOO68fEAK#„U"3qm5X\Vbo:4Z<8oIBBu_BC',2HFMdgxNgC-MAlp[7-YNHe<la4Lq8a2h*_crOKM„U"*1N)Ly_w=HP6)HG:-dVYl+2i'S=a'rbQKHl.,9RQv5MmcH02BGu&&&u-M\k.i$:„U"YYa-ukMd6K9Z[9mT28R2,Tw%Q#7kKcHV6EC#JzB_LD47C=\t>_mNsSFb$n.>nbz„U"1n<5ggP'4v3[X=r,DbB'ZD0R;Hwe7ieytjiJ0?2b?&MH0f6w%1V.)SkRO*g6nEr„U"^7dbE4,RMthTh-771%w[O7=pU%W<#hM:?[$RQMV<cO?U?1G[692XXF4ho]oxOb9„U"6_tr>BKr\+b%T?BN6.0biCL;\2q<H>i7;X[.7$>2cqHt#rRJTtp8<OIUxcw5lOO„U"Ysu>#i,5iNbq&N_$:K8WA6ufMYnnbEWuRDR*kAIUc^RvabQVww/.I-q<:p2K_Q_„U"JYbk\gt=Elw5OWtWVQBp])lh\ln7XWVcjKFK+<_xjLr_9rP8Ddd=v7&J;z[q(+\„U"VMIvit\(FnlD-UeEKf+:(ll4AZN?j^aN%1jSqubdns/f_&=*<3$tMC23^rCYbrH„U"zEJ,'yca$>B\[9cdu*l31z1/4s0q;:p6Ng;?'J.A5ghrpPMf?ZgXs1?oLQYL7-i„U"t)27//gH,GD=;*o06'$OfOvF]j_J5ooC5,17-64$WH.he;4-D$[,t_+8a4kc\Ja„U">.a+n_+:ZIB$7G1'WZW5mc90\bXU+tFkYh+>pwKxN+3?ADhf'JN.M)4Yem4uL0t„U"4BJhoL=vG=Ml%8DJ4&jdv[IuDhH.%2N/3KHN-.G:\m.Sxl0%g>LPOZp5S^9?04Y„U"4x31'B4v_*V\wpY+gp9J),nYAHK--<;q3(d4kXKmD.-?6e235D^E)a2SlqZ<qd>„U",1UBn.)$)W*M,L3InjEV[D1[REl)08>3MbZkX&UPSz?-sGutuf_-j?7Vo$kV/Se„U"0szZ13<D_#ykcl^Yx8,$i6SHu5r_9t3i4Uux#RDf?sZp;q\6h]6^=F^+FD_#4*g„U">mrbv5%gNcH9al?i3?XSjr++[vmg%V=kAd382HeKF1q^Bj=tmdH72Z0L/k63jY'„U"QE8/QMYF%.J05,ilqV]s8LLjAhm^Y40Ppb.oN75EGu(f\xb_<V#XyeCP&9kSS1/„U"NCte&ZGvqElKf^?3P?DdIA3uHWEkSPW+k?^T8:2x8n?'.Z.[*coXMjliJl1u=B/„U"#Guq\Fa;E/:d+Fk3xq;6qU,r\wG0O*+Q]ag:X[sKDY\MaDVA9dE/F_1BCM6R1yo„U"R>f5LUK0*nwMphrlgw#L:1r/^#mz(Y.T&aNC#%g?j_2/q'WB':D7%jWgUdiofj1„U"_<h-PZFR7-u[t:]'n^/dVICz7taSRcxH#;P4%Dh7W+>aLho-Hk5/SxP\KCe(w:\„U">;^NDV$HKtm1BYpMVO#X79rdwWx5)'spnoJyp:\+D98a(q?pf_47xd\$,'];HF7„U";+jnIIbZdf$;Yr<Dp7^Js+g88OLEJyrg;6x^j6$/FBP[pI'i8UZ0fsco'/vabqN„U"M0r02antdo<g*f;u]&ErP%QKV2q(9kslqRxTA2]F)p'^sXydd:\oSgRF[:-^*S.„U"NZrJK_vxt?e1-xh?xLp6K($:mIzGwLhN2ZW?t+FjXV<m<<p4S]RlsGJ1E:k8xjQ„U"C*H%]Sb\jw$sZ7S\RjK?:V\RnSq9\?8[3C3D_=&E^rh)&;6PSgL8Ffu?ZN+EEf_„U"g#3ia*WE$qi,llpIlnC/LGN=gXb2]b0eW4A,f(]$$(V^OJx0)L6OIsQipMe#/B%„U"8*5hnjdMd%5EhUj90S+i;7nfy+yc(v?kfG2<)%C>Tt:CJf1B[V_ZmXX^/.aeLrj„U"QU(<d/_4K0ZEpj[k>J0H>93_5(P]hI3c3HdZ855Mp[&7]dy\GL>waN-po_t=XHj„U"Vs\<rc.k<Q'6J+rYUNQdFq+mkrH]8Kkgxg_=>3=:8ZnvkD_&]5C^bjHCn^^k>oW„U"6oEC>jmRA5mrU=q26UZ3/B(=_g+t-pB,=cLkaXhkv1hDM'o(LSPgjJ2l:y)N=3[„U"E$AQ0JblA?F4\n'0&L][gvQla.*R>n&6APsDpesRBtIrb]9GZT65HVdEt_SROGg„U"_]npCkol.Ftiw>wb<Pou/E'F7K><.r0Ep2&m8Hc2p6\Dn^T<8NDPXz/%a1o.gNj„U"Wnq>>S&m;M'+X/^8l5O#E1GhhB[+jsp:KiH0%Yz3wyMtp6%Um4oLI^0'M>bE/]T„U"u[WML8n\OcGPtrWEgKWfVVs\^k9aqsYH6hbKC;Q+dx#u%p()9%%%%-g%H+tC?s=„U"$%3D(%+%[+%%%0%%%%ktx%yjwr%SgfxJ\y<^\y]9w8Kru4V6'F/gg5C_(Kj]VO#„U"=IVA+;-/lOv'ZUUa:1ZS[Uno8R1C73s+VD)JsnkvHHdWABvn5/%R]PE6V?K2VUR„U"(:#a$sG)Wq+s[+c;;vL=r^aORZQM8F78%1,JP7E9d0YfAR&>Vd8G#7bF9kT)uA*„U"be%NDtY9uhffA%E^4+grFzRSUlY9\.rD,bTq62uven8Z%1U%NA9QB&3*J$tNy*G„U"s+;&7Grnhr>C%1a)J]ZYr[R<'-h^Tq_FYp:5p%^5R-Df&U7x:=H(jV;vtaIaLWQ„U"HD8,n=4;\z+H1][bgA5/geZ.wQ2u/ezCLaXR'GjL'TaL^WFQL^xV9H%jb[huj=X„U"R\/k:wUB9oXVbXA.\)hw,l$WA><r+TZAx7QsQhPNgb:t^-aDK.9SYkr=u3LYd.$„U"VSWhr*xwu78c2EH#laAtP%:$5l9i&TtEv57Uwe>Jis]5-gB*]sLK*tx6&E-^qTE„U";/D1^zm%dkw]=wmdPCNfpD-PtLbe\(ESMrqI2l-5P&M]L7R3&].e$48EFpa]F)u„U"[+F_ab-[f+*lu0Dx*Ft_4X>]m*<k')nWzFgYu.No%5AWMwy;-d.vcF$UKb-i3wr„U"GQIkE%ISJOQBb;^,*s2]-R\pHD69Z-cN+oX21]7E0B$Z?h3,6:[Plab]4<H,d0U„U"I/5JuDr5hU(LQYxx_CfZ)NGpQgbn$BQL6pc*i%lPhb2t0*j8pQ-YQR.&Di;xL>i„U"4z[1B46+EbUWVYW[11Lic\2&dLEQ/b<a*f=JM$n=SSl'n&+Q;=VzQdfaE&=L]dl„U"Fp>\=#h>dZZ&+E]M)>_Q*hAql9(<o/5YE*9gF-V&MxK^q-XddAK4scFim/L_<RP„U"fWTxntcCQ=-ca^1d-BUWYttghx,B$5Z7C]CE-q=qoDtq7f''DXL/$$*NlVLfwol„U"p>&Y'ZAA:Mkpb)1w=tk0/iZjY9pcffbNp%Mv<4)1co]6X-plb>%1b1^<tEe1'?/„U"FH48SWojGD4qxEpQE;,2q,u%p()9%%%%-g%<9#[AlFV*$L&%+%C'%%%+%%%%wjf„U"#irj4jw:9U7e16,]k4_/pue-m]Ip44%F00R(.Dopt>\.5O;*6[qsxBXrp\0gr3X„U"j:m?d6pVsHP&rP&mplRX&NlZD50H&aX<]bFr%mM30mUbYL-;I-<DI$V9#+m#9b[„U"mYWwfF?I+;+:CSD$\g;twFjaMaO7b&ai,/O,jC0bj=$kt]b$FO2fbhcmm+XfhdK„U"U]u_a5(j6+xAY%fF$0z[>j'\K?m[OI70i&B122w0T*.s^k]AvCBg8LQ\5P?s3oD„U"W]Wjh]c&hNu%jMvG$G]Z/e>(8gkr#L2(0/W>7a7+2Gy4]=RbC:$n1/bKJl3Cvor„U"WH5i?\pPxG+$Ia_j]5;;EGrV9O:%?ESV60ZVEl9Tqh%7%X0C$uaU%]Jn%RG_C[R„U"fB5y2WQVu&4):?<lGg4^FX$7ee5W3F5phw]z&(qlA$;9G9jnJv)R]TOl2N]wlBN„U"m>U+H8EmxeeIk(0nd*d+yU^w0vqFOUtCX*9;ww%%up()%9%%%%-%Z<I3BH8>08r„U").%%07%%%/%%%%kt%xxnq%SgfxN&&0>][k5vRCNx0m?fGa_AxrA0nwdo&/qfGO)„U"Rutsw8eRgp'ljPqniSkNX(Tp)jQq5a4d7OJdH>ZWGE]o#2lZJM[m'LUn],'1=c]„U"3GGAbcdHTGuHGHa*,sGIg&g1+V;+:[+0Ry4kUlxbe]Du)iIDVCUcXvuquMxK>QR„U"5dU>j$6S_R#iD'u05-H*EVm^aS(l]R\'i8MqOu1R6eidU]D7UO9k94/F9I_&&r$„U"Tl?-e#/Lp9rYS]8X[gs+pPtpQ8rA)i4M)4:Z#%\5lUi3N+[mnQRO./h+p4s56$t„U"e6EW3'i\x:RroK_;Z^AakAnFF)n8kduCQ&Z,hT%st\a_S(W>iBN^-brFn+6JE3P„U"fa]%w/dK5^M%sawst$4OLs3D+qO0QBbI#8&O%M<FuW[$*Lzlbx+Q*1JiosHMqE9„U"iHhFQEN'8I4MgAY+A/s,$I$i?Lv-2y$guwV.#Ge8GfrN\<TV+/3d\o0%8;wmqp&„U"i-VqQw-;0m%c_boHE+Cm%c[&0\*()nm'7Q'+J.QE.(>YtiZJ-Sxwf\W_dNZ>JY)„U"+AjX'79/P47:&o4hY*ORiAO#*.dS?4v*tcA7XGg]U&G2puIs\7,l>75[GyzClDx„U"oR?/+5cZ\$2m_*'7bo]#q[ywt7Ghc;xNU$<0o-)$dn&V$*Xa=(]He,GB+7+'s?*„U"KnkHgc-M.x);r.62)iO68R4gAIajXU;EalI#kiXUQ.y2:?QIQpUv:PWW+S%(?m'„U"/-eX%fBFqa7u02)If(u1[w#u\JTJx0SD-E^*8JHr94m\6%F=+WuDkT1XybnQ4L+„U"Z7(^GS(B[24$+f?G)n<U88]x<+_cY4OHRQk#Cklhy+':v]+2],ZxL*4zJK;gnHC„U"iA&ijb'Tv3/FFAl/mW>259u[ntBxI7(0Tl9&_PVEp3,bn;uJnqamgE?tR1Z\_'6„U"(XL&-dq.]mHl3w$^myA.nZvt8so2L(p8Hd$t36>yb,LB4D3hAbp5]41635+0uS\„U"%[WisyKY4nbO]&cQ%E0Z3/hjVHggN%JoH&Pr/7(k:KJ?n(N9=N:$Y^'D>oW.k+$„U"m%>LWbR7W/7:N+JLTQWUok_LrdGX)j=]iJEuNs=](od7jW<09n69\p9RaM)8=cp„U"[ZB+F%$,7Og1+CRHm%'$C0)O7<nB3kJG4kN,._mXb'=ICwy;/2AH4i5$n[D3]XT„U"9HTq,-no84.=2'IBkaSUC\'Brbl>[k$3ZKL1zd3crg]DY960oL7^E\-#W$b'W9a„U"C3H$dXP385Ur%lPC:lq=LhCp=?nlvs&pvLBEEp,WO9j5-yWON1t?d&'3lgAi7>m„U"qpGZ3_A=n7>aI</A#Oix1G:_.+98s:?<C#s[Gp?h%A\kyRZ__dXdgMqsz0q7B##„U"LHpDA2YKBj'*Deu-h<;;pa+i^'+%Vp^E<**u;]GQl'lzbI_*[*GQ2vghL2Hfq8n„U"*ZXte8].Igux/*zP=RbbpTro2GqYuOP^kEuK^Pvj>9<,a=L?-VRv%A86dnAHKSu„U"g[GVn<LFiRfmpbJ$yGMsp(%Yg&Zaknx1OYAv+pLEwxSdJ>:J&><vi^b&x*0p]HJ„U"RC7m#N?ub&iph:XW6/MJI7Q-ac(\O+6gR=y4eNAxx%&up&%'9%9%%%%-C%*yn#>„U"%5='&S1%%%DI%%%0%%%%%%%%%&%E%%%%%%%%%u%gkxh%trSg%fxup%&'9%%9%%%„U"I-%H+0t?s=&$3D(7%%[+%%%0%%%%%%%%%&%%E%%%&&1%%%ktxy%jwrS%gfxu%p&„U"'9%%9%%#%-%<,9#AlXFV$L[&%%C%'%%+%%%%%%%%%&%%E%%(%n4%%%wjf%irju%„U"p&'9%%9%%%%-%Z#<3BHq808r#)%%0%7%%/%%%%%%%%%&%%E%%%%e6%%%ktx%xnq„U"S%gfxu%p*+%%%%%)[%)%W#%%%0%;%%%%%„END SUB„CLOSE:IF S=98AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Michael Parker                 COM SUPPORT                    comp.lang.basic.misc           03-03-96 (07:25)       QB, QBasic, PDS        110  3328     COMSUPP.BAS '>   Help on how to access COM's 1 through 4 or 8. Please help.„„'Here's a _very_ nice routine to open com1-com4 (up to 115k baud, too).„'These routines were written by Michael Parker.  Hope they help.„'Originally posted by Jonathan Leger <leger@pc2.pc.maricopa.edu>„„'--- START HERE ---„„' Quick Basic Routine OpenCom„' This routine will accept the entire OPEN command parameters„' that is in QB 4.5 , the only exception is the baud rate and„' COM port.  Baud rate is optional, if specified, this module„' will set the specifed rate up to 115,200.  If the baud rate„' is specifed at 0, the specifed port will be polled  for the„' current baud rate and the baud rate will be set at the rate„' that is present, if any.  NOTE:  the baud rate parameter on„' the command line IS  NOT optional,  if you want this module„' to set the baud rate,  put an extra comma  into the command„' line to replace the baud rate.  The COM Port will accept up„' to COM 4 now.„„' OPENCOM "COMX:{option list1 [baudrate,parity,databit]},{option list2}„' AS FileNum"„' examples:„' OPENCOM "COM1:38400 as 1"„' OPENCOM "COM4:,op500 as 1"„' OPENCOM "COM2:2400,n,8,1,op500 as 4"„' OPENCOM "COM3:,,, OP500 as 2"„„DECLARE SUB OPENCOM (InString$)„CALL OPENCOM(InString$)„END„„SUB OPENCOM (Sting$)„Sting$ = LTRIM$(RTRIM$(Sting$))„Port$ = UCASE$(LEFT$(Sting$, 5))„Sting$ = RIGHT$(Sting$, LEN(Sting$) - 5)„FOR x = 1 TO LEN(Sting$)„     H$ = MID$(Sting$, x, 1)„     IF UCASE$(H$) = "A" THEN„          H$ = H$ + MID$(Sting$, x + 1, 1)„          IF UCASE$(H$) = "AS" THEN„                FileNum = VAL(MID$(Sting$, x + 2, LEN(Sting$)))„                EXIT FOR„          END IF„     END IF„     InputString$ = InputString$ + H$„NEXT x„FOR x = 1 TO LEN(InputString$)„     IF MID$(InputString$, x, 1) <> "," THEN„          BaudRate$ = BaudRate$ + MID$(InputString$, x, 1)„     ELSE„          InputString$ = MID$(InputString$, x + 1, LEN(InputString$))„          EXIT FOR„     END IF„NEXT x„IF LTRIM$(BaudRate$) = "" THEN„     BaudRate& = 0„END IF„SELECT CASE Port$„     CASE "COM1:"„          BaseAddr% = &H3F8„          Port1$ = "COM1:"„     CASE "COM2:"„          BaseAddr% = &H2F8„          Port1$ = "COM2:"„     CASE "COM3:"„          BaseAddr% = &H2F8„          Port1$ = "COM1:"„     CASE "COM4:"„          BaseAddr% = &H3F8„          Port1$ = "COM2:"„     CASE ELSE„          PRINT "Illegal COM Port"„END SELECT„„IF BaudRate$ = "" THEN„     OUT BaseAddr% + 3, INP(BaseAddr% + 3) OR &H80„     LSB% = INP(BaseAddr%)„     MSB% = INP(BaseAddr% + 1)„     OUT BaseAddr% + 3, INP(BaseAddr% + 3) AND &H7F„     Divisor& = MSB% * &H100 + LSB%„     IF Divisor& = 0 THEN„          BaudRate& = 0„     ELSE„          BaudRate& = 115200 / Divisor&„     END IF„ELSE„     BaudRate& = VAL(BaudRate$)„END IF„IF LEFT$(InputString$, 1) <> "," THEN„     InputString$ = "," + InputString$„END IF„OPEN Port1$ + "300" + InputString$ FOR RANDOM AS FileNum„IF Port$ = "COM3:" THEN„     POKE &H400, &HE8„ELSEIF Port$ = "COM4:" THEN„     POKE &H402, &HE8„END IF„IF BaudRate& <> 0 THEN„     Divisors# = 115200 / BaudRate&„END IF„LCR = BaseAddr% + 3„Temp = INP(LCR)„OUT LCR, Temp OR 128„OUT BaseAddr% + 1, INT(Divisors# / 256)„OUT BaseAddr%, Divisors#„OUT LCR, Temp AND 127„„END SUB„Dick Dennison                  DIAL A PHONE NUMBER            QB Tidbits                     10-19-91 (00:00)       QB, QBasic, PDS        192  5630     DIAL.BAS    ' DIAL    BAS : Dial a phone number on the screen„' author .....: Dick Dennison [74270,3636] 1:272/34 914-374-3903 *hst 24 hrs„' supports ...: COM1 - COM4„' syntax .....: DIAL portnum%„' includes ...: None„' notes ......: Move the cursor with the arrow keys to the phone number„'             : Press the ']' key and move the right arrow key across„'             : the number and press Enter„'             : Uses Basic's OPEN COMx commands„' cost .......: Free = Credit where credit due„'             : Do not use as is for commercial use - may not be resold„'             : May not be rebundled without prior written consent„' dated ......: 10/19/91„' credits ....: Thanks to Mike Welch for CLIPMSG, and Pete Petrakis for his        „'             : notes on Com Port swapping.„„DECLARE SUB Hangup (Port%)„DECLARE SUB Getnum (row%, Col%, markit%, Port%)„DECLARE SUB Setup (Port%)„„COLOR 0, 7„LOCATE 25, 1„PRINT "     Move the cursor to the beginning of the phone number and press Space  ";„LOCATE 10, 1„IF VAL(COMMAND$) < 1 OR VAL(COMMAND$) > 4 THEN      'Get the portnum%„     PRINT "Port number must be on command line"„     END„ELSE Port% = VAL(COMMAND$)„END IF„                   „                    'Setup some special key functions„CR$ = CHR$(13)„Nul$ = CHR$(0)„ArrowLt$ = Nul$ + CHR$(75)„ArrowRt$ = Nul$ + CHR$(77)„ArrowUp$ = Nul$ + CHR$(72)„ArrowDn$ = Nul$ + CHR$(80)„EndKey$ = Nul$ + CHR$(79)„Esc$ = CHR$(27)„Home$ = Nul$ + CHR$(71)„SpaceBar$ = CHR$(32)„                   'Save vectors at bios Addresses for Com1-Com2„  OldPort1H = PEEK(&H400)„  OldPort1L = PEEK(&H401)„  OldPort2H = PEEK(&H402)„  OldPort2L = PEEK(&H403)„„'Move cursor around„'==================================================================„DO                         'This section lets the user move„ In$ = INKEY$             'move the cursor around on the screen„ SELECT CASE In$          'to the beginning of the phone number„  CASE CR$„    IF markit% THEN       'A CR signals the end of the highlight„     row% = CSRLIN„     Col% = POS(0) - count%„     EXIT DO„    END IF„  CASE Esc$                'END„    END„  CASE Home$               'Goto the beginning of the line„     LOCATE , 1„  CASE EndKey$             'Goto the end of the line„     LOCATE , 80„  CASE ArrowUp$            'UpArrow„     x% = CSRLIN„     IF x% > 1 THEN LOCATE x% - 1„  CASE ArrowDn$            'DownArrow„     x% = CSRLIN„     IF x% < 25 THEN LOCATE x% + 1„  CASE ArrowLt$                                 'LeftArrow„     IF POS(0) > 1 THEN LOCATE , POS(0) - 1„     IF markit% THEN count% = count% - 1       'If markit% then ' ' was pressed„  CASE ArrowRt$                             'RightArrow„     „     IF markit% THEN„          count% = count% + 1               'If markit% then ' ' was pressed„          row% = CSRLIN: Col% = POS(0)„          a% = SCREEN(row%, Col%)„          PRINT CHR$(a%);„     ELSE„          IF POS(0) < 80 THEN LOCATE , POS(0) + 1„     END IF„  CASE SpaceBar$„     IF markit% THEN„          count% = count% + 1               'If markit% then ' ' was pressed„          row% = CSRLIN: Col% = POS(0)„          a% = SCREEN(row%, Col%)„          PRINT CHR$(a%);„     ELSE„          BEEP„          markit% = -1                      'Flag set for marking number„     END IF„ END SELECT„ LOCATE , , 1                   'Keep cursor flashing„LOOP„'======================================================================„„         'Get the phone number off the screen„Getnum row%, Col%, count%, Port%„„         'Restore old vectors„CLOSE 1„  DEF SEG = 0„     POKE &H400, OldPort1H„     POKE &H401, OldPort1L„     POKE &H402, OldPort2H„     POKE &H403, OldPort2L„  DEF SEG„END„„SUB Getnum (row%, Col%, markit%, Port%)„IF row% < 1 THEN row% = 1: IF Col% < 1 THEN Col% = 1„LOCATE row%, Col%„FOR x% = 0 TO markit%           'Read the phone number off the screen„     a% = SCREEN(row%, Col% + x%)„     Dialstr$ = Dialstr$ + CHR$(a%)„NEXT x%„LOCATE 23, 25„PRINT "Dialing : "; Dialstr$;„LOCATE 25, 1„PRINT "             Pickup handset and then press space or ESC phone rings      ";„COLOR 7, 0„„Setup Port%„PRINT #1, "ATM1DT" + Dialstr$     'Dial the numbar„„DO„     b$ = INKEY$„     IF b$ = " " THEN„          Hangup Port%„          EXIT DO„     END IF„     IF b$ = CHR$(27) THEN„          Hangup Port%„          EXIT DO„     END IF„LOOP„„END SUB„„SUB Hangup (Port%)„„PRINT "...Disconnecting 1";„SELECT CASE Port%                'Drop DTR„    CASE 1„        OUT &H3FC, (INP(&H3FC) AND 252)   'com1„    CASE 2„        OUT &H2FC, (INP(&H2FC) AND 252)   'com2„    CASE 3„        OUT &H3FC, (INP(&H3FC) AND 252)   'com3„    CASE 4„        OUT &H2FC, (INP(&H2FC) AND 252)   'com4„END SELECT„     PRINT "...2...";„     PRINT #1, "+++";   'Switch to modem command mode„     SLEEP 1„     PRINT #1, "ATH"    'Send hangup command„     PRINT "...CLICK";„„END SUB„„SUB Setup (Port%)„'Sets up the comport by swapping the address fo com4 with com2 and„'com3 with com1 if necessary„DEF SEG = 0„ POKE &H400, &HF8„ POKE &H401, 3„ POKE &H402, &HF8„ POKE &H403, 2„„SELECT CASE Port%„     CASE 1„        Start$ = "COM1:2400,N,8,1,DS0"„     CASE 2„        Start$ = "COM2:2400,N,8,1,DS0"„     CASE 3„        POKE &H400, &HE8   'For com1 to com3„        POKE &H401, &H3„        Start$ = "COM1:2400,N,8,1,DS0"„     CASE 4„        POKE &H402, &HE8   'For com2 to com4„        POKE &H403, &H2„        Start$ = "COM2:2400,N,8,1,DS0"„END SELECT„DEF SEG„„„OPEN Start$ FOR RANDOM AS 1„„END SUB„„Carl Gorringe                  IRQ # OF TCP/IP DRIVER PACKET  FidoNet QUIK_BAS Echo          05-29-96 (16:15)       QB, QBasic, PDS        81   2502     TCP.BAS     '>I've been working on a program a game that can be played across a modem lin„'>and alot of my freinds seem to like it and have ased that I try to make in„'>work on a IPX network using ethiernet card. The code to make it three playe„'>would be easy to do, but I haven't a clue how to send packets throught a„'>network. Does anyone know any books, liberies, source code, that deals with„'>programs working across networks ?„„'Isn't IPX in some ways similar to the TCP/IP Internet protocal?„'Well, I wish I could help with some code to send packets of data, but„'I haven't gotten around to figuring it out yet. What I DO have is some„'code to detect which IRQ number a Packet Driver is loaded on. (A Packet„'Driver is a TSR which helps in sending packets of data over networks.)„'Maybe you can find a use for it!„„'-------------------------------„'          TCP1.BAS„'-------------------------------„'  (c) Carl Gorringe 1/14/96„' Released to the PUBLIC DOMAIN„„' This is used to detect a PC/TCP Packet Driver„„DECLARE FUNCTION TCP.GetIRQ% ()„'------------------------------------------------------------„CLS„Num% = TCP.GetIRQ%„„PRINT„PRINT„PRINT "IRQ ="; Num%; " ("; HEX$(Num%); " hex)"„„END„„FUNCTION TCP.GetIRQ%„„' (c) Carl Gorringe 1/14/96 << v1.0 >>„'--------------------------------------„'  Returns the IRQ number that the„'   TCP/IP packet driver resides.„'  Returns 0 if driver not loaded.„'--------------------------------------„'<< Done - Tested OK >>„„RetNum% = 0„FOR IRQ% = &H60 TO &H80„„   VectorOff% = IRQ% * 4  '<-- Point to IRQ # in Interupt Vector Table„„   DEF SEG = 0„      CodeSeg& = PEEK(VectorOff% + 3) * 256& + PEEK(VectorOff% + 2)„      CodeOff& = PEEK(VectorOff% + 1) * 256& + PEEK(VectorOff% + 0)„„   DEF SEG = CodeSeg&„      Char1% = PEEK(CodeOff& + 3)„      Char2% = PEEK(CodeOff& + 4)„      Char3% = PEEK(CodeOff& + 5)„      Char4% = PEEK(CodeOff& + 6)„      Char5% = PEEK(CodeOff& + 7)„      Char6% = PEEK(CodeOff& + 8)„      Char7% = PEEK(CodeOff& + 9)„      Char8% = PEEK(CodeOff& + 10)„      Char9% = PEEK(CodeOff& + 11)„„   DEF SEG„„   ProgID$ = CHR$(Char1%) + CHR$(Char2%) + CHR$(Char3%)„   ProgID$ = ProgID$ + CHR$(Char4%) + CHR$(Char5%) + CHR$(Char6%)„   ProgID$ = ProgID$ + CHR$(Char7%) + CHR$(Char8%)„„   'PRINT ProgID$        '*** Test ***„„   IF ProgID$ = "PKT DRVR" AND Char9% = 0 THEN„      RetNum% = IRQ%„      EXIT FOR„   END IF„„NEXT IRQ%„„TCP.GetIRQ% = RetNum%„„END FUNCTION„Robert Fortune                 ACCESSING COM PORT VIA INT 14  FidoNet QUIK_BAS Echo          08-26-96 (11:39)       QB, PDS                239  10367    BIOSCOM.BAS '-> Sorry, but that's the way QuickBasic does it. You have to use„'-> OPEN/CLOSE to read/write to files as well as COMPORTS.„„'>       Actually, I found this in a help file:„„'>INARY%(AX) = &H3C00            ' DOS function to create a file.„'>INARY%                         ' DOS attribute for created file.„„'>       It appears that you can use Interrupts to work with files (and„'>probably devices such as commports).  I bet someone here could use the above„'>(or they might not even need it) to create their own OPEN/CLOSE SUBs and„'>other SUBs to work with the files such as writing to, reading from, and„'>getting information like LOF and EOF.„„'   Yes you can. Here is some play code I've fiddled around with. It isn't„'   error-proof but it does demonstrate using BIOS Int 14h to access a com„'   port. You would use similar code to access a FOSSIL driver (BNU, X00...)„'   The demo code doesn't do anything but reset\init modem, dial out and„'   then hang up. It does show how to use interrupts to access a com port.„„' --------- CUT HERE -------------------- CUT HERE ---------------------------„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM *  BIOSCOM.BAS    8/26/1996                                           *„REM *  Demo QB code to access a serial port via BIOS INT 14h using        *„REM *  QB\PDS.  YOU MUST start QB\PDS with the /L command line switch to  *„REM *  allow QB to call BIOS interrupt 14H as in:   QB BIOSCOM /L         *„REM *                                                                     *„REM *  Maximum baud rate BIOS Int 14H reliably supports is 9600 BPS.      *„REM *  This demo program uses 9600 BPS on COM 2 with NO parity, one Stop  *„REM *  Bit and eight Data Bits. Modify as needed. - RAF                   *„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„DEFINT A-Z    ' All untyped variables default to type integer„'$INCLUDE: 'REGTYPE.BI'„„DECLARE SUB InitPort (PortNum%, BaudRate%)„DECLARE SUB GetStatus ()„DECLARE SUB Get1Byte (Byte$)„DECLARE SUB GetStr (Text$)„DECLARE SUB Send1Byte (Byte$)„DECLARE SUB SendStr (Text$)„DECLARE FUNCTION Dec2Bin$ (b%) ' Useful function for determining com parms„„DIM SHARED Registers AS RegType„DIM SHARED ComPort%, BaudRate%, Parity%, StopBits%, DataBits%„„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM *   Example QB code to test BIOS INT 14H to access a serial port      *„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„„ComPort% = 1      ' zero-based so 1 is actually com 2 (com 1 would be 0)„BaudRate% = 9600  ' 9600 BPS (max that BIOS INT 14H reliably supports)„Parity% = 16      ' use NO parity        00010000„StopBits% = 0     ' use one Stop bit     00000x00„DataBits% = 3     ' use eight Data bits  00000011„„REM * * * * * * * * * * * * MAIN PROGRAM CODE * * * * * * * * * * * * * * *„CR$ = CHR$(13)    ' ASCII code for carriage return\ENTER„ESC$ = CHR$(27)   ' ASCII code the the ESC key„CLS„PRINT„CALL InitPort(ComPort%, BaudRate%)„PRINT„PRINT "Testing BIOS Interrupt 14H in QB\PDS to access a serial port."„PRINT„PRINT "Communications Port:" + STR$(ComPort% + 1)„PRINT "BPS Rate: " + STR$(BaudRate%)„PRINT "Resetting com port "; LTRIM$(STR$(ComPort% + 1)); "...";„„ByteStr$ = ""„Text$ = "ATZ" + CR$     ' initialize\reset modem to use modem profile 0„CALL SendStr(Text$)„„REM Wait for an OK from the modem that it received our modem„REM reset command.„DO„  CALL GetStr(Text$)„LOOP UNTIL INSTR(Text$, "OK")  ' u might wanna check for error(s) here„PRINT "done!"„PRINT„PRINT„„REM Dial a number. Best to dial your own phone number here which will„REM ensure a BUSY signal and not annoy anyone.„„LINE INPUT "Enter your telephone number: "; Number$„IF Number$ = "" THEN Number$ = "555-1212"  ' Information please? <g>„PRINT„Text$ = "ATDT" + Number$ + CR$ ' ATDT touch tone line (ATDP for pulse line)„CALL SendStr(Text$)            ' And dial out„„REM Wait for a BUSY or CONNECT from the modem to be sure that the modem„REM received our DIAL command properly. In a real world program you would„REM need to check for other conditions like NO CARRIER, etc...„PRINT "Press ESC key to cancel"„PRINT„ByteStr$ = ""„DO„  CALL Get1Byte(Byte$)„  ByteStr$ = ByteStr$ + Byte$„  PRINT Byte$;„  AnyKey$ = INKEY$„  IF AnyKey$ <> "" THEN EXIT DO„LOOP UNTIL INSTR(ByteStr$, "BUSY") OR INSTR(ByteStr$, "CONNECT")„PRINT„PRINT "Hanging up...";„Text$ = "ATH0" + CR$    ' force the modem to hang up„CALL SendStr(Text$)„PRINT "All done Bubba!"„END  ' The End.„REM * * * * * * * * * * * * * THE END * * * * * * * * * * * * * * * * * * *„„REM * * * * * * * * * * * * * * * * * * * * * * * * *„REM  Converts a decimal number into a binary string.„REM  Called with:  b% which is an integer variable„REM  Returns:  binary value of integer b%„REM * * * * * * * * * * * * * * * * * * * * * * * * *„FUNCTION Dec2Bin$ (b%) STATIC„Temp$ = ""„H$ = HEX$(b%)„FOR I% = 1 TO LEN(H$)„    Digit% = INSTR("0123456789ABCDEF", MID$(H$, I%, 1)) - 1„    IF Digit% < 0 THEN„       Temp$ = ""„       EXIT FOR„    END IF„    J% = 8„    K% = 4„   DO  ' convert from hexadecimal to binary„       Temp$ = Temp$ + RIGHT$(STR$((Digit% \ J%) MOD 2), 1)„       J% = J% - (J% \ 2)„       K% = K% - 1„       IF K% = 0 THEN EXIT DO„   LOOP WHILE J%„NEXT I%„Dec2Bin$ = Temp$„END FUNCTION„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM   Receives one byte from active port via BIOS INT 14H - Function 2„REM   Called with: AH = 2„REM                DX = serial port 0 to 3 (zero-based)„REM   Returns: AH = Line Status„REM            AL = Byte recieved„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„SUB Get1Byte (Byte$)„   PortFunc% = 2      ' Int 14H Function 2 = Read Char from port„   AL% =  0           ' zero-out, unused with this function„   Registers.AX = AL% + (256 * PortFunc%)„   Registers.DX = ComPort%  ' com port (zero-based, com 1 is zero, etc...)„   CALL INTERRUPT(&H14, Registers, Registers)„   Byte$ = CHR$(Registers.AX AND 255) ' return string of ASCII char rec'd„END SUB„„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM  Reads line and modem status of the specified com port„REM  Called with:  AH = 3  ' function 3 (Get status) of INT 14H„REM                DX = serial port 0 to 3 (zero-based)„REM  Returns:  AH = Line Status„REM            AL = Modem Status„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„SUB GetStatus„    AL% = 0          ' zero out AL register half„    AH% = 3          ' Int 14H Function 3 = Read line and modem status„    Registers.AX = AL% + (256 * AH%)„    Registers.DX = ComPort%  ' zero based active com port number„    CALL INTERRUPT(&H14, Registers, Registers)„    LineStat% = Registers.AX \ 256       ' extract AH from AX register„    ModemStat% = Registers.AX AND 255    ' extract AL from AX register„END SUB„„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM  Gets a string from the active com port one byte at a time using„REM  INT 14H's Get Byte function (2). *See Get1Byte SUB„REM  Example:  CALL GetStr(Text$)„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„SUB GetStr (Text$)„ DO„   CALL Get1Byte(Byte$)„   Text$ = Text$ + Byte$„ LOOP WHILE Byte$ <> CHR$(13)  ' loop till a carriage return is rec'd„END SUB„„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM  Opens and initializes the com port via BIOS INT 14h (Function 0).„REM  Registers set before calling:„REM           AH = INT 14H function we want to invoke ( 0 = initialize port)„REM           AL = Serial port initialization values (Baud, Parity...)„REM           DX = com port number (zero based, 0 is com 1, 1 is com 2...)„REM  Returns:  AH = Line Status„REM            AL = Modem Status„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„SUB InitPort (ComPort%, BaudRate%)„  SELECT CASE BaudRate%    ' max baud via BIOS INT 14H is 9600 BPS„         CASE 9600„              BaudVal% = 128 + 64 + 32  ' (224) = binary 11100000„         CASE 2400„              BaudVal% = 128 + 32       ' (160) = binary 10100000„         CASE 1200„              BaudVal% = 128            ' (128) = binary 10000000„         CASE 300„              BaudVal% = 64             ' (64)  = binary 01000000„  END SELECT„  ComParms% = BaudVal% + Parity% + StopBits% + DataBits%„  PortFunc% = 0 ' Function 0 (of Int 14H) which is init port„  Registers.AX = ComParms% + (256 * PortFunc%)„  Registers.DX = ComPort%  ' active com port to init (zero-based)„  CALL INTERRUPT(&H14, Registers, Registers) ' call the interrupt„END SUB„„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM  Sends one byte to the specified serial port (zero based ComPort) via -„REM  Function 1 of BIOS INT 14H„REM  Called with: AH = 1„REM               AL = ASCII value of the byte to send„REM               DX = Serial port 0 to 3 (zero based; use 0 for port 1...)„REM  Returns:  AH = Line Status„REM            AL = unchanged (the byte that was sent)„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„SUB Send1Byte (Byte$)„    PortFunc% = 1      ' INT 14H Function 1 = write char to port goes into AH„    Byte% = ASC(Byte$) ' ASCII value of byte which goes into AL„    Registers.AX = Byte% + (256 * PortFunc%)„    Registers.DX = ComPort%  ' com port number (zero-based)„    CALL INTERRUPT(&H14, Registers, Registers)„END SUB„„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„REM  Sends a string to the active com port one byte at a time using„REM  INT 14H's Send Byte function (1).„REM  Called with:  Text$ which is the string to send out the com port.„REM  Example:  CALL SendStr(Text$)„REM„REM * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„SUB SendStr (Text$)„    FOR I% = 1 TO LEN(Text$)„        OneByte$ = MID$(Text$, I%, 1)„        CALL Send1Byte(OneByte$)„    NEXT I%„END SUB„' --------- CUT HERE -------------------- CUT HERE ---------------------------„Erik Bruggema                  REMOTE ACCESS UTILITIES        immsstok@worldaccess.nl        08-28-96 (18:27)       QB, QBasic, PDS        77   5021     RA_UTILS.BASDEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"RA_UTILS.ZIP",4^6:Z&=3487:?STRING$(50,177);„U"%up()%9%%%I-%K'mAF8b1Cb6'7%%#-%%%1%%%%qf%xyhf%qqSg7fx&y1r^jUa95„U"lC)NGoP^*yRS5sCtz14__QAa(6G?.FJ2U[ZCia/aFxc7wEB-[)w;o&tBqNFGg6s„U"d5Xr8OmVQmnv=mUu%bG^)OuG+N1.I7]3;2_KP>Ur-uW*;p/Vhjx;K*3)t'm&-M?„U"Ej[V$s#e/mi+/j1ma2WCt#ovoEF98R=eb9)2cI+5^G(lQ7cCZ(Zn8V9\TT3.q;8„U"#3r#[]/%f8Odmse0D5L^M;m+w*H]RD;$+s#mA8+yC*F0o\M1Z0'bbj1>I]MDm#i„U"Fg9#ifJo8[<uTOwm9j;Z3f:Yo,0)zw>&4EGmcE700LxYBr:0bbEis?2^DH<.c[t„U"2oEtB#PuwwP5nFaaBoi:55hPJGArLckj0A4&E56IGY4C&QRbwh[$BJsAQ;0QU)1„U"T,SATHp9Y'bpNrmA3-'M<'$U+%D0/[VJN&LK6iF;S<^e:7)o8c%D/UVqO_(F;7w„U"OSDjBnoS^j?Vr7$V]VhL)V]1iQrI\pK3$vh-pi5+j6*qB,)FOAZ#_ru\B9PuqOK„U"Q]qbMQiN+Ia(r+q7m8mxTcC$6IB6S7DA'/>R2KbI7Z+'Jp9J=cE]th(v&Tc&)qb„U";Fgu59rS&[4rtyoW#pc_l8?n&X[F4etuk/(AHVJTcUdU.<QXS[DoVQRBf5J?hqx„U"%m&_iA^U,KuzrGcT:$3<-u;SJ94MMGxd441_1N#hO^dioId'KfxaSrN]+uT3--9„U"(O[B3lyvLup3fvfo:f*dPW2(rR[nJLD:)haD(^$100Z=)5l=9XN(Z('F-H.bb&T„U"J&Nup(%)9%%[%-%S[g#FXAR$(<[%%%e%%%%1%%%%q%fxyh%fqqS#ggx2c]iRKmx„U"-GDUT&dAh00Et+<9;[>Ph>s-?_HAu(RN3_,3b3>N9NaO.aB2%(Pa3#v\6s&=,Hh„U"J+a6IP_8nvPn4zn'S'h$B&L&(=1xD]<wf*rD//U32///Z-))WWMS_[Cc*N-N&%H„U"k%%up()%9%%%I-%s%%AF2O&>kZ&.%%A'%%%0%#%%x(%xnsk%tSgf^xDvJ+o<U98„U"L4]D73zQO',Uj5p*pVKsvaKJL93^p$Ds=TuJ_:v]6r\0241-7ZG2pm&BtMN]OP+„U"*d;.^,_+dr4&p)M?FHnq90V&pePijTTFxR>Zny[.)4MkST2?VxpB;FDn=QD7rFP„U">se3C4v4*HcUc&VZg.4Jl3.UVc1u:M(nR+*5HC:i$9]2&.\vF-DwD;l^2Y+7ToP„U"0]o=yg#Gv/27^4#sei*x5]186/92vBV#z]61<kiM3B%[$/YCIl\W7C_V::k5)9l„U"&0>%mh.7K5:^<5:_GQ8xx:N_kkdMith/p]y[13ToWfok*WdRD48D26$pQ24##$l„U"7Mmm+$FAIlnv0;oaU[KR3kpV9l+W=G;tq4o6l&M)uydEJF$,dBKyr<QVoN;'(Du„U"p%()9%%%%-%%X-6F&9a,e%G%%%&w%%%%0%%%(x(xn%sktS[ggxF*9p2%[U-j:L<„U"3v/%Aa8y.HmMUG;XZIp+k1K\Is<8&Iup(%)9%%#%-%o&'AFzhuL1s['%%4%:%%0„U"%%%%y%nrjq%tlSgRfx&f<X>SUU5OX$BqDs;<L/c5c$uE%BKIMPLkQOa%qzDH59*„U"9>dm.LYi8.[SO3ilja,l9roeTUbZ4<-*HR\_SLQ)UZKNa$jYLrM=g&sV5RaqlRG„U"+9]TIYpqGa3X%ZYRHPDV-<kqCc.SEG*APg:a5Z*]j'=9bV=?nV+r3TrU<dL7ftJ„U"K4TN#R?Dtvp\X/=>&(]48,mkuLj+V.4WcH4b7t5f3SAPD:Ye)AAOQ++ZaQHGDH0„U"A?)A3*;((HZQA<QSRYLD<y^F[Vlj$krrtWJuw7rLN-R:%7,(,SF35q%68F735/_„U")/iD#aJR9OjMBu)#kn[TUZ9luf)k<Wj9OwF4r)EPM[vo=5)cH?[RFxAhz*&4o.s„U"c0je$D6gdhsIsr]X603Y<[3+yIU]F4^EAm0.XiEn3RHh5DjgA0(opF\46:,gfp#„U"=<*3?8NGXF)EohrxxWHtxp'Oq0KjS43E%.LqqGkgay>sF.N[OqHgNHC\?((Hxx:„U"$_\+,G)VYFK71V#5\B2VHa5l2*&pF;=\1Hxg7(xIy.>Yd++r.fx,#IyB(Yd,rBn„U"fxPBIyF0_y_U3h2y_Y1OsuQOD[_9a'kF'$Y9_j^F.ZSNV1dUko7$SZqSWy_pMe$„U"7;;ZQHtUb:B,#=vGF$0Z3W8Qji,za<#t=eE4D?>qK./GqY-g5T$Gf3>[5Yha+1:„U"WA>iZa1;V41Y-<N>SQDi7UAvXaeHZL1.G6qQ2.mXU_,2AW'Si6a[MO4[7K?m6[&„U"'+3=KB+S4m(C<2soBCT;Y['mrqY5)KA=ZSH+A$ZG[-m'tZ5/AhGZS1NAjZ[T3m1„U"Zu55AQqZS7AitZ[9dm=[5H;A][YS=A*.Q=Z*>0*YRU;[>QE)'=5IS\Cx5xD*QC=„U"Z*0**oRcTv#2UiMZOiXBgkqAwSv>38z&17bD>5%Qh51Rb>>?)'UhU*mMy1;f41)„U"^h>k>3i'Ul+UmsyL1n4k7S.x%%up()%9%%%7-%Sg##Fy-(,iI%%%%l%%%%0%%%%„U"yn%rjqt%lSggax\U)]IZULK.Y24M/3/5NY//1&O%kE/3'1qu9A9<*9YK+%%up(%„U")9%%%%-%S#&CFpB<DxE#'%%d%+%%/%%%%z%xjwt%sSgfCxLy,,>SU98Ll[d2+4b„U"ki/YM&)J'zz%&'io(hf)zSLY=:nr+4,mBVwvYKfi$A^STotBg27jc#Es?ua<w4w„U"*/Vh,B$n\J%6RTI5onefea?dfYR(h?87]=$bd#Q]$S4*>pfpk=b^^q0g,g'okcG„U"J4+vCp5twE_^$#$k9pn:,$'n4Nmd(H9;H'KK2yt',DA8j[yNde]gNJk1zx7<'fl„U"8eZ(t6M\>7a9m70c7ipJ^3#c*,0NGUzd&Sfq\q+FmO/:Ot0#>v)M-$ScfInkTBg„U"5\Ei1EU_iF(p.u&+%N/oqz_d30$f)D2wZQ;xomrugNvWl[J^m*;XDTPqZ7cd]U,„U"=%U/GT,M?nd5,[K%mXdNxHHY1eChBo)^Eqr)R_5V?78Zj\Rf16Xth)49CKE?:5b„U",h[fJhc1<d#1m_Kw1)5.^HqpnPtvF.GRS9wYva\wA]LDu\,d=l'TwZS&PC+;S0P„U"KD_s78^6Sg_2f0X9e>%zMq8'XRiU&+SS$1OtC'\W6p\:wOeA.A[[A_YVVI,eO_S„U"-:8Z;PK^l/d0j.^CcpTdcw7CJfU59&z#&5k[\TG4v#^/2tH>3tT/lLXof8,TX0j„U"s+k6hk6KD>yxGfP?Ndq:NN$w<b.QuFNB0d4lFDp#8UE_n#SGb\.j*L(3eOTQm_^„U"yWh<$-AXWp;GBn/AsLrt*$uuzg4V2t'6dxcy-H?>H$2olB5^/P$>xa?a#3$=+cU„U"&o2)B^'130tH7J+TP^tYGx/BfXc,.[-J*6oLh$qAA7%ii?DUfOnj$J(khHrn9$E„U"YX1QoGRKa7-vWdu%p()9%%%%-+%Tg#UFx'),33%%+%O%%%%/%%%%zxj%wtsS#gg„U"x29iRKx=-GDTYNZ<G-km.[p+Ui)LH#;lh#NIU$wxZPFPwT4i_OxZe20m9rp1gxB„U"_HQ#BjLtF?#vb(OOcA6swt?9699hCu]h$bu$gcp$vUhpa,g(.sq?XsEQu)zIVUA„U"8[b.-tG.o4s]xVhlg6]=0t.E#%Y^P*E;NNF^s&Ela?wI#[LR'<P\pByn-x+de$n„U"jfcjfolYtQ3't4X;#TILUwDK2%,_u;Kbo7rrTj-o46(%%up&%'9%9%%%%-1%K'A„U"=F8bC)b6'%+%#-%%%1%%%%%%%%%&%E%%%%%%%%%q%fxyh%fqqS%gfxu%p&'9%%9„U"%%[%-%S[g#FXAR$(<[%%%e%%%%1%%%%%%%%%&%%E%%(%$'%%%qfx%yhfq%qSgg%„U"xup&%'9%9%%%%-1%s%A#F2O>%kZ&%(%A'%%%0%%%%%%%%%&%E%%%%M%(%%x&(xn„U"s%ktSg%fxup%&'9%%9%%%%-%X-.6F9a%,eG%.%%w%%%%0%%%%%%%%%&%%E%%%&U„U")%%(x(xn%sktS%ggxu%p&'9%%9%%#%-%o&'AFzhuL1s['%%4%:%%0%%%%%%%%%&„U"%%E%%+%J)%%%ynr%jqtl%Sgfx%up&'%9%9%%%%-%'Sg#FCy-,i%I%%%%l%%%%0%„U"%%%%%%%%&%E%7%%m,%%%yn%rjqt%lSgg%xup&%'9%9%%%%-%%S&C:Fp<D(xE'%(„U"%d+%%%/%%%%%%%%%&%E%%%%f%-%%z%xjwt%sSgf%xup&%'9%9%%%%-+%Tg#UFx'„U"),33%%+%O%%%%/%%%%%%%%%&%E[%%%X%/%%z%xjwt%sSgg%xup*%+%%%%%-%-+%„U"A&%+%:0%%%%%„END SUB„CLOSE:IF S=194AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Kurt Kuzba                     TERMINAL W/ANSI EMULATION      FidoNet QUIK_BAS Echo          06-05-96 (00:00)       QB, QBasic, PDS        201  7783     QUIKTERM.BAS'_|_|_|   QUIKTERM.BAS„'_|_|_|   This program will operate in ANSI emulation with ANSI„'_|_|_|   auto-detect. Must be compiled for high speeds.„'_|_|_|   No warrantee or guarantee is given or implied.„'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (6/5/96)„DECLARE SUB QuikCFG (d() AS STRING)„DECLARE SUB ansi (A$)„ON ERROR GOTO BooBoo„DIM FKEYS(13) AS STRING: port% = 0„FError$ = "ok": OPEN "quikterm.cfg" FOR INPUT AS #2„IF FError$ = "ok" THEN„   FOR t% = 0 TO 13„      IF EOF(2) THEN EXIT FOR„      LINE INPUT #2, FKEYS(t%)„   NEXT: port% = VAL(FKEYS(0))„END IF: CLOSE 2„Ex$ = CHR$(27) + "[": CrLf$ = CHR$(13) + CHR$(10)„CLS : altx$ = Ex$ + "0;1;32mALT/X to exit terminal" + CrLf$„IF port% = 0 THEN„   LOCATE 1, 1, 1: PRINT "Choose a port (1/2)"„   DO: port% = INSTR(" 12", INKEY$): LOOP WHILE port% < 2„   port% = port% - 1: FError$ = "ok"„   OPEN "quikterm.cfg" FOR OUTPUT AS #2„   IF FError$ = "ok" THEN PRINT #2, MID$(STR$(port%), 2)„END IF: CLOSE 2„FOR t% = 1 TO 34: ansi MID$(altx$, t%, 1): NEXT„port$ = "COM" + MID$(STR$(port%), 2) + ":19200,N,8,1"„FError$ = "ok": OPEN port$ FOR RANDOM AS #1 LEN = 8192„IF FError$ <> "ok" THEN PRINT "MODEM ERROR": END„DO„   Modemin$ = "": IF NOT EOF(1) THEN Modemin$ = INPUT$(1, #1)„   ansi Modemin$„   IF ANSIDetect$ <> "" THEN PRINT #1, ANSIDetect$: ANSIDetect$ = ""„   kb$ = INKEY$„   IF kb$ <> "" THEN„      k% = ASC(kb$)„      IF k% = 0 THEN„         k% = ASC(MID$(kb$, 2))„         SELECT CASE k%„            CASE 45: CLOSE #1: END„            CASE 59 TO 68: k% = k% - 58„               kb$ = FKEYS(k%)„               DO: e% = INSTR(UCASE$(kb$), "^M")„                  IF e% > 0 THEN MID$(kb$, e%) = MID$(kb$, e% + 1)„                  IF e% > 0 THEN kb$ = LEFT$(kb$, LEN(kb$) - 1)„                  IF e% > 0 THEN MID$(kb$, e%, 1) = CHR$(13)„               LOOP WHILE e% > 0„               IF FKEYS(k%) = "" THEN k% = 0„            CASE 133, 134: k% = k% = 122„               kb$ = FKEYS(k%)„               IF FKEYS(k%) = "" THEN k% = 0„            CASE 37: QuikCFG FKEYS(): k% = 0„            CASE ELSE: k% = 0„         END SELECT„      END IF: IF k% > 0 THEN PRINT #1, kb$;„   END IF„LOOP: CLOSE #1: END„BooBoo:„   FError$ = STR$(ERR): RESUME NEXT„DEFINT A-Z„SUB ansi (A$)„DEFINT A-Z: DEF SEG = &HB800„STATIC W, e, L, C, O, M, F, B, V, e$: SHARED ANSIDetect$„IF W < 99 THEN W = 100: C = 0: F = 7: B = 0: A = 0: M = F + 16 * B„IF A$ = "" THEN LOCATE C \ 80 + 1, C MOD 80 + 1, 1: EXIT SUB„IF e <> 27 THEN„   IF ASC(A$) <> 27 THEN GOSUB CHRout:  ELSE e = 27: e$ = A$„   EXIT SUB„END IF„IF O <> 27 AND ASC(A$) = 34 THEN O = e: EXIT SUB„IF O = 27 THEN„   IF ASC(A$) = 34 THEN O = 0„   EXIT SUB„END IF: e$ = e$ + A$„IF LEN(e$) = 2 AND A$ <> "[" THEN e = 0: e$ = "": EXIT SUB„S = INSTR("HfABCDsuJKmhlpn", A$)„SELECT CASE S„  CASE 0: EXIT SUB„  CASE 1: GOSUB CursorA„  CASE 2: GOSUB CursorA„  CASE 3: L = -1: GOSUB CursorL„  CASE 4: L = 1: GOSUB CursorL„  CASE 5: L = 1: GOSUB CursorC„  CASE 6: L = -1: GOSUB CursorC„  CASE 7: V = C„  CASE 8: C = V„  CASE 9: COLOR F, B: CLS : C = 0„  CASE 10: FOR L = C TO C + 79 - (C MOD 80)„           POKE L * 2, 32: POKE L * 2 + 1, M: NEXT„  CASE 11: GOSUB Colorz„  CASE 15: A$ = CHR$(27) + "[" + MID$(STR$(C \ 80 + 1), 2) + ";"„           ANSIDetect$ = A$ + MID$(STR$((C MOD 80) + 1), 2) + "R"„END SELECT: e = 0: e$ = "": EXIT SUB„CursorA: L = VAL(MID$(e$, INSTR(e$, "[") + 1))„   C = VAL(MID$(e$, INSTR(e$, ";") + 1))„   IF C > 0 THEN C = (C - 1): IF C > 79 THEN C = 79„   IF L > 0 THEN L = (L - 1): IF L > 24 THEN L = 24„   C = L * 80 + C: RETURN„CursorL: p = VAL(MID$(e$, INSTR(e$, "[") + 1))„   p = p - (p < 1): L = INT(C \ 80) + p * L„   IF L < 0 THEN L = 0:  ELSE IF L > 24 THEN L = 24„   C = (C MOD 80) + L * 80: RETURN„CursorC: p = VAL(MID$(e$, INSTR(e$, "[") + 1))„   p = p - (p < 1): L = (C MOD 80) + p * L: C = INT(C \ 80) * 80„   IF L < 1 THEN L = 0:  ELSE IF L > 79 THEN L = 79„   C = C + L: RETURN„Colorz: e$ = MID$(e$, INSTR(e$, "[") + 1)„   DO: e = VAL(e$)„      SELECT CASE e„         CASE 0: F = 15: B = 0„         CASE 1: F = F OR 8„         CASE 5: B = B OR 8„         CASE 8: F = B„         CASE 30 TO 37: p = e - 29„            e = ASC(MID$("@DBFAECG", p)) AND 7: F = (F AND 248) + e„         CASE 40 TO 47: p = e - 39„            e = ASC(MID$("@DBFAECG", p)) AND 7: B = (B AND 248) + e„      END SELECT: p = INSTR(e$, ";"): e$ = MID$(e$, p + 1)„   LOOP WHILE p > 0: M = F + 16 * B: RETURN„CHRout: p = ASC(A$)„   IF p = 7 THEN FOR t% = 800 TO 1111 STEP 20: SOUND t%, .1: NEXT: RETURN„   IF p = 8 THEN„      IF (C MOD 80) > 0 THEN„         FOR t% = C * 2 TO (C \ 80) * 160 + 159„            POKE t% - 2, PEEK(t%)„         NEXT: C = C - 1„      END IF: RETURN„   END IF„   IF p = 13 THEN C = C - (C MOD 80): RETURN„   IF p = 10 THEN C = C + 80„   IF p <> 10 THEN POKE C * 2, p: POKE C * 2 + 1, M: C = C + 1„   IF C >= 2000 THEN„      C = C - 80: LOCATE 30, 80: PRINT„      DIM PK%(2): PK%(0) = 32: PK%(1) = M„      FOR L = 3680 TO 3839„         POKE L, PEEK(L + 160): POKE L + 160, PK%(L AND 1)„      NEXT„   END IF: RETURN„END SUB„„SUB QuikCFG (d() AS STRING)„   SHARED port%„   DIM buf(4000) AS STRING * 1: DEF SEG = &HB800: F$ = SPACE$(80)„   FOR t% = 0 TO 3999: buf(t%) = CHR$(PEEK(t%)): NEXT„   csr% = LEN(d(0)) + 1: macro% = 0: COLOR 10, 0: CLS : COLOR 14, 4„   PRINT " COM "; : COLOR 10, 0: PRINT LEFT$(d(0) + F$, 75);„   FOR t% = 1 TO 12„      COLOR 14, 4: LOCATE t% + 1, 1: PRINT " F"; RIGHT$(STR$(t%), 2); " ";„      COLOR 10, 0: PRINT LEFT$(d(t%) + F$, 75); : NEXT„   PRINT : PRINT : PRINT "RETURN exits: ALT/S saves"„   DO: LOCATE macro% + 1, 6: COLOR 15, 1: PRINT LEFT$(d(macro%) + F$, 75);„      LOCATE , csr% + 5: DO: k$ = INKEY$: LOOP WHILE k$ = ""„      k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))„      SELECT CASE k%„         CASE 8„            IF csr% > 1 THEN„               csr% = csr% - 1„               MID$(d(macro%), csr%) = MID$(d(macro%), csr% + 1)„               d(macro%) = LEFT$(d(macro%), LEN(d(macro%)) - 1)„            ELSE SOUND 999, .7„            END IF„         CASE 13: FOR t% = 0 TO 3999: POKE t%, ASC(buf(t%)): NEXT: EXIT SUB„         CASE 32 TO 255„            L$ = LEFT$(d(macro%), csr% - 1): r$ = MID$(d(macro%), csr%)„            d(macro%) = LEFT$(L$ + k$ + r$, 70)„            IF csr% < 75 THEN csr% = csr% + 1:  ELSE SOUND 999, .7„         CASE -31„            FError$ = "ok": OPEN "quikterm.cfg" FOR OUTPUT AS #2„            IF FError$ = "ok" THEN„               FOR t% = 0 TO 13: PRINT #2, d(t%): NEXT: port% = VAL(d(0))„            END IF: CLOSE 2„         CASE -71: csr% = 1„         CASE -72„            IF macro% > 0 THEN„               LOCATE macro% + 1, 6: COLOR 10, 0„               PRINT LEFT$(d(macro%) + F$, 75);„               macro% = macro% - 1: csr% = LEN(d(macro%)) + 1„            ELSE SOUND 999, .7„            END IF„         CASE -75„            IF csr% > 1 THEN csr% = csr% - 1:  ELSE SOUND 999, .7„         CASE -77„            IF csr% < 70 THEN csr% = csr% + 1:  ELSE SOUND 999, .7„         CASE -79: csr% = LEN(d(macro%)) + 1„         CASE -80„            IF macro% < 12 THEN„               LOCATE macro% + 1, 6: COLOR 10, 0„               PRINT LEFT$(d(macro%) + F$, 75);„               macro% = macro% + 1: csr% = LEN(d(macro%)) + 1„            ELSE SOUND 999, .7„            END IF„         CASE -83„            IF LEN(d(macro%)) >= csr% THEN„               MID$(d(macro%), csr%) = MID$(d(macro%), csr% + 1)„               d(macro%) = LEFT$(d(macro%), LEN(d(macro%)) - 1)„            ELSE SOUND 999, .7„            END IF„      END SELECT„   LOOP„END SUB„'_|_|_|   end   QUIKTERM.BAS„Brian Mahocker                 PHREAK FONE                    ButtNuggie@aol.com             10-22-96 (18:45)       QB, QBasic, PDS        48   3463     PFONE10.BAS 'Phreak Fone Ver. 1.0   By: Brian Mahocker„Start:„CLS„LET Start% = 0„LOCATE 1, 1: COLOR 8: PRINT "P"; : COLOR 7: PRINT "H"; : COLOR 15: PRINT "R"; : COLOR 8: PRINT "e"; : COLOR 7: PRINT "a"; : COLOR 15: PRINT "K"; : COLOR 8: PRINT " "; : COLOR 7: PRINT "F"; : COLOR 15: PRINT "o"; : COLOR 8: PRINT "N"; : COLOR 7: PRINT "e"; : COLOR 15: PRINT " "; : COLOR 8: PRINT " "; : COLOR 7: PRINT "V"; : COLOR 15: PRINT "e"; : COLOR 8: PRINT "R"; : COLOR 7: PRINT "."; : COLOR 15: PRINT " "; : COLOR 8: PRINT "1"; : COLOR 7: PRINT "."; : COLOR 15: PRINT "0"; : COLOR 8: PRINT "           "; : COLOR 7: PRINT "B"; : COLOR 15: PRINT "y"; : COLOR 8: PRINT ":"; : COLOR 7: PRINT " "; : COLOR 15: PRINT "B"; : COLOR 8: PRINT "R"; : COLOR 7: PRINT "i"; : COLOR 15: PRINT "a"; : COLOR 8: PRINT "n"; : COLOR 7: PRINT " "; : COLOR 15: COLOR 8: PRINT "M"; : COLOR 7: PRINT "a"; : COLOR 15: PRINT "H"; : COLOR 8: PRINT "o"; : COLOR 7: PRINT "C"; : COLOR 15: PRINT "K"; : COLOR 8: PRINT "e"; : COLOR 7: PRINT "R": COLOR 15: PRINT„INPUT "THe LoWeST NuMBeR To DiaL  (No Dash) : ", LN&„INPUT "THe HiGHeST NuMBeR To DiaL (No Dash) : ", HN&„INPUT "PoRT NuMBeR (1/2) : ", port$„INPUT "RePeaT? (Y/N) :", R$: IF R$ = "Y" OR R$ = "y" THEN LET Repeat% = 1: IF R$ = "N" OR R$ = "n" THEN LET Repeat% = 0:„INPUT "aRe THeSe SeTTiNGS CoRReCT? (Y/N) : ", correct$: IF correct$ = "N" OR correct$ = "n" THEN GOTO Start„CLS„LOCATE 1, 1: COLOR 8: PRINT "P"; : COLOR 7: PRINT "H"; : COLOR 15: PRINT "R"; : COLOR 8: PRINT "e"; : COLOR 7: PRINT "a"; : COLOR 15: PRINT "K"; : COLOR 8: PRINT " "; : COLOR 7: PRINT "F"; : COLOR 15: PRINT "o"; : COLOR 8: PRINT "N"; : COLOR 7: PRINT "e"; : COLOR 15: PRINT " "; : COLOR 8: PRINT " "; : COLOR 7: PRINT "V"; : COLOR 15: PRINT "e"; : COLOR 8: PRINT "R"; : COLOR 7: PRINT "."; : COLOR 15: PRINT " "; : COLOR 8: PRINT "1"; : COLOR 7: PRINT "."; : COLOR 15: PRINT "0"; : COLOR 8: PRINT "           "; : COLOR 7: PRINT "B"; : COLOR 15: PRINT "y"; : COLOR 8: PRINT ":"; : COLOR 7: PRINT " "; : COLOR 15: PRINT "B"; : COLOR 8: PRINT "R"; : COLOR 7: PRINT "i"; : COLOR 15: PRINT "a"; : COLOR 8: PRINT "n"; : COLOR 7: PRINT " "; : COLOR 15: COLOR 8: PRINT "M"; : COLOR 7: PRINT "a"; : COLOR 15: PRINT "H"; : COLOR 8: PRINT "o"; : COLOR 7: PRINT "C"; : COLOR 15: PRINT "K"; : COLOR 8: PRINT "e"; : COLOR 7: PRINT "R": COLOR 15: PRINT„LOCATE 3, 1: PRINT "CuRReNT FoNe NuMBeR :"„LOCATE 4, 1: PRINT "TiMe LeFT FoR CuRReNT FoNe NuMBeR :"„LOCATE 5, 1: PRINT "CuRReNT PoRT : "„COLOR 8: LOCATE 5, 16: PRINT port$„StartDialing:„LET PN& = LN&„DO„COLOR 8: LOCATE 3, 22: PRINT PN&: COLOR 15„OPEN "COM" + port$ + ":" + "9600,N,8,1,ASC" FOR OUTPUT AS #1„PRINT #1, "ATD" + ""; PN&; ""„LET time% = 15„DO„SOUND 32767, 9.1„SOUND 32767, 9.1„COLOR 8: LOCATE 4, 36: PRINT time%„LET time% = time% - 1„LOOP UNTIL time% = -1„SOUND 32767, 10„PRINT #1, "+++"„SOUND 32767, 10„PRINT #1, "AT Z H0"„PRINT #1, "ATH"„SOUND 32767, 10„CLOSE #1„IF Repeat% = 1 AND PN& = HN& THEN GOTO StartDialing„IF Rapeat% = 0 AND PN& = HN& THEN GOTO End.„LET PN& = PN& + 1„LOOP„End.:„PLAY "T200L50MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>"„PLAY "T200L50MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>"„PLAY "T200L50MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>"„PLAY "T200L50MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>"„PLAY "T200L50MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>"„PLAY "T200L50MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>"„„Scott Turchin                  BACKSPACE LOCALLY & OVER MODEM nitehawk@tscnet.com            10-29-96 (11:13)       PB                     127  3288     BACKSPC.BAS SUB XPRINT(Fore%,Back%,StringofData$,LF%) PUBLIC„'------------No color--------------------„IF NOT Ansi% THEN  'Don't add colors in..„	COLOR Fore%,Back%„	PRINT StringofData$;„	PRINT #1, StringofData$;„        IF LF%=1 THEN„	    PRINT„	    IF Carrier(Port%) THEN PRINT #1,CRLF$„	END IF„        EXIT SUB„END IF„„'-------------color part--------------------„ESC1$=LTRIM$(CHR$(27)+"[")    'esc$ was used publicly in my program, I chose„esc1$ to eliminate problems.„GOSUB SETCOLORS„„IF Carrier(Port%) THEN Print #1, ForeColor$+StringofData$;„IF Carrier(Port%) AND (Flash% OR Back%>0) THEN PRINT #1,CHR$(27)+"[0;30m";„'clears flashing„„IF Flash% THEN INCR Fore%,16„COLOR Fore%,Back%„IF INSTR(StringofData$,CHR$(8)) THEN EXIT SUB ELSE PRINT StringofData$; 'Do„not print the backspace...„„IF LF%=1 THEN„    COLOR 7,0„    PRINT„    IF Carrier(Port%) THEN PRINT #1,CRLF$„END IF„COLOR 7,0 'Reset it..just in case„EXIT SUB„„SETCOLORS:„IF Fore% <= 8 THEN ESC1$=ESC1$+"0;"„IF Fore%>8 AND Fore%<16 THEN ESC1$=ESC1$+"1;"„IF Fore%>16 THEN„        Flash%=-1„        ESC1$=ESC1$+"5;"„	DECR Fore%,16„END IF„   SELECT CASE Fore%„        CASE 0„        ForeColor$=ESC1$+"30m"„        CASE 1„         ForeColor$=ESC1$+"34m"„        CASE 2„         ForeColor$=ESC1$+"32m"„        CASE 3„         ForeColor$=ESC1$+"36m"„        CASE 4„         ForeColor$=ESC1$+"31m"„        CASE 5„         ForeColor$=ESC1$+"35m"„        CASE 6„         ForeColor$=ESC1$+"33m"„        CASE 7„         ForeColor$=ESC1$+"37m"„        CASE 8„         ForeColor$=ESC1$+"30m"„        CASE 9„         ForeColor$=ESC1$+"34m"„        CASE 10„           ForeColor$=ESC1$+"32m"„        CASE 11„           ForeColor$=ESC1$+"36m"„        CASE 12„           ForeColor$=ESC1$+"31m"„        CASE 13„           ForeColor$=ESC1$+"35m"„        CASE 14„           ForeColor$=ESC1$+"33m"„        CASE 15„           ForeColor$=ESC1$+"37m"„        CASE ELSE„           Fore%=7„   END SELECT„IF Back%>0 THEN ForeColor$=LEFT$(ForeColor$,6)„   SELECT CASE Back%„        CASE 0„        'IS ASSUMED BLACK ALREADY„        CASE 1„           ForeColor$=ForeColor$+";44m"„        CASE 2„           ForeColor$=ForeColor$+";42m"„        CASE 3„           ForeColor$=ForeColor$+";46m"„        CASE 4„           ForeColor$=ForeColor$+";41m"„        CASE 5„           ForeColor$=ForeColor$+";45m"„        CASE 6„           ForeColor$=ForeColor$+";43m"„        CASE 7„           ForeColor$=ForeColor$+";47m"„        CASE ELSE„           Back%=0„   END SELECT„RETURN„END SUB„„SUB BACKSPACE(I$,Fore%,Back%) PUBLIC„COLOR Fore%,Back%„CHATX% = CSRLIN: CHATY% = POS( O )„IF CHATY%=1 THEN„	PRINT " ";„        LOCATE CHATX%,CHATY%,1„ELSE„LOCATE CHATX%,CHATY%-1„PRINT " ";„LOCATE CHATX%,CHATY%-1„END IF„XPRINT Fore%,Back%,CHR$(8)+" "+CHR$(27)+"[D",0 'backspace one line, move „forward one line remotely using ANSI escape sequence.„IF InChat% THEN    'This backspaces a chat.log file in my chat routine..„	Y=LOF(3)    'chat.log is opened as #3...„	IF Y>2 THEN„		SEEK #3, Y-1„		PRINT #3," ";„		SEEK #3, Y-1„	END IF„END IF„IF LEN(I$) THEN I$=LEFT$(I$,LEN(I$)-1) ELSE I$=NULL$  'subtract one „character if it is a word otherwise eliminate it...„END SUB„