Charlie Quante                 A FILTERED INKEY$ ROUTINE      charlie@charlie.seanet.com     11-05-96               QB, QBasic, PDS        66   2503     TESTKEY.BAS 'FULL Header Extraction for this Source Code has been Enabled„' A sample program to demonstrate the TestKey subroutine.„„DECLARE SUB TestKey (KeyFlag%, CaseFlag%, KeysAccepted$)„„    CLS„    DEFINT A-Z„'----------------------------------------------------------------------------„'   Prompt the user for a number from 1 to 4.„'   call TestKey - CaseFlag is unimportant for this example.„'   Print the number of the item selected.„„    PRINT "Select a number from 1 to 4: "„    TestKey KeyFlag, -1, "1234"„    PRINT "You selected item"; KeyFlag„'----------------------------------------------------------------------------  „„'   Prompt the user for a letter from A to Z„'   Call TestKey - Note: Notice that you can have a combination of upper and„'                        lowercase letters.„'   In this example CaseFlag is set to -1 and any key pressed is converted„'   into uppercase. The same applies to the KeysAccepted$ string.„'   Convert the number returned by KeyFlag back into a letter.„„    PRINT„    PRINT "Select a letter from A to Z: "„    TestKey KeyFlag, -1, "ABCDEfghijklmnopqrstuvwxyz"„    PRINT "You selected letter "; CHR$(34); CHR$(KeyFlag + 64); CHR$(34)„'----------------------------------------------------------------------------„  „'   Now CaseFlag is set to 0, and the user must enter either an uppercase„'   A through E, or a lowercase f through z„„    PRINT„    PRINT "Okay, select another letter from A to Z: "„    TestKey KeyFlag, 0, "ABCDEfghijklmnopqrstuvwxyz"„    PRINT "You selected letter "; CHR$(34); CHR$(KeyFlag + 64); CHR$(34)„„SUB TestKey (KeyFlag, CaseFlag, KeysAccepted$)„'Purpose: „'           Get input from the user, and test it to see if it is one of„'           the keys that are acceptable.„'Variables:„'           CaseFlag      - If CaseFlag is -1 then all input, is converted„'                           to uppercase.„'           KeyFlag       - Returns a number indicating which acceptable key„'                           was pressed.„'           KeysAccepted$ - Holds the acceptable keys.„'           GetKey$ - Gets the key pressed via the INKEY$ command. „„„    KeyFlag = 0„    IF CaseFlag THEN KeysAccepted$ = UCASE$(KeysAccepted$)„„    DO WHILE KeyFlag = 0„        GetKey$ = ""„       „        DO WHILE GetKey$ = ""„            GetKey$ = INKEY$„        LOOP„       „        IF CaseFlag THEN GetKey$ = UCASE$(GetKey$)„        KeyFlag = INSTR(KeysAccepted$, GetKey$)„    LOOP„END SUB„„Chris McKenzie                 CHECK ASCII CHARACTER CODE     unknown@sprynet.com            12-29-96 (14:06)       QB, QBasic, PDS        34   1067     CHKASC.BAS  'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„' This is a seemingly useless program, run it to find out what it is.„'ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„„CLS„FOR WaitFiveSeconds% = 5 TO 1 STEP -1„  LOCATE 1, 1: PRINT "Press key and HOLD.  You have"; WaitFiveSeconds%;"seconds to choose key."„  SLEEP 1„NEXT WaitFiveSeconds%„CLS„„FOR KeyBeingChecked = 1 TO 255„  Button$ = INKEY$„  SLEEP 1„  IF Button$ = CHR$(KeyBeingChecked) THEN GOTO ItHasBeenFound„  LOCATE 1, 1: PRINT "Checking code"; KeyBeingChecked„  PercentDone = (KeyBeingChecked / 255) * 100 MOD 100„  LOCATE 2.1: PRINT PercentDone; "% done."„NEXT KeyBeingChecked„„NotFound:             „  CLS„  PRINT "I'm sorry but the Ascii character code was not found."„  GOTO Final„„ItHasBeenFound:„  CLS„  PRINT "The key has been found!  It is Ascii character"; KeyBeingChecked;„  GOTO Final„„Final:„  PRINT "Press [Esc] to quit."„NotPressingAButton: Button$ = INKEY$: IF Button$ <> CHR$(27) THEN GOTO NotPressingAButton„END„Nick Kochakian                 KEY GENERATOR                  NickK@worldnet.att.net         02-12-97 (15:23)       QB, QBasic, PDS        314  3850     KEYGETR.BAS '----------------------------------------------------------------------------„'Fast key getter„'„'1/20/97„'1997 By: - Nick Kochakian -„'„'Use this to get keys for a game, etc.„'„'If you have any comments or questions please e-mail me at:„'„'nickK@worldnet.att.net„'„'Have fun! :)„'----------------------------------------------------------------------------„„'To exit just press: ESC -> ( CHR$(27) )„„'How to use the information with your program:„'Say the computer returns something like this:„'CHR$( 0 ) + ;„'What you'd need to enter into your program to make it work would be:„'IF A$=CHR$(0)+; THEN  ,etc...„„CLS„„A = 255„DIM A$(A)„FOR A = 1 TO 255„READ A$(A)„NEXT A„„A = 1„„PRINT "Press any key... Press ESC to exit..."„DO„„DO„A$(A) = INKEY$„LOOP UNTIL A$(A) <> ""„PRINT "CHR$(";„PRINT ASC(A$(A));„PRINT ") + "; A$(A)„'A$(A) = INEKY$„LOOP UNTIL A$(A) = CHR$(27)„„„'Up: IF a$(a) = CHR$(0) + "H" THEN BEEP„'Down: IF a$(a) = CHR$(0) + "P" THEN BEEP„'CHR$(0)+"K"  <- Left„'CHR$(0)+"M"  <- Right„'CHR$(0)+";"  <- F1„'all chr$(0)+""""" from here„'< <- F2„'= <- F3„'> <- F4„'? <- F5„'@ <- F6„„END„DATA  1„DATA  2„DATA  3„DATA  4„DATA  5„DATA  6„DATA  7„DATA  8„DATA  9„DATA  10„DATA  11„DATA  12„DATA  13„DATA  14„DATA  15„DATA  16„DATA  17„DATA  18„DATA  19„DATA  20„DATA  21„DATA  22„DATA  23„DATA  24„DATA  25„DATA  26„DATA  27„DATA  28„DATA  29„DATA  30„DATA  31„DATA  32„DATA  33„DATA  34„DATA  35„DATA  36„DATA  37„DATA  38„DATA  39„DATA  40„DATA  41„DATA  42„DATA  43„DATA  44„DATA  45„DATA  46„DATA  47„DATA  48„DATA  49„DATA  50„DATA  51„DATA  52„DATA  53„DATA  54„DATA  55„DATA  56„DATA  57„DATA  58„DATA  59„DATA  60„DATA  61„DATA  62„DATA  63„DATA  64„DATA  65„DATA  66„DATA  67„DATA  68„DATA  69„DATA  70„DATA  71„DATA  72„DATA  73„DATA  74„DATA  75„DATA  76„DATA  77„DATA  78„DATA  79„DATA  80„DATA  81„DATA  82„DATA  83„DATA  84„DATA  85„DATA  86„DATA  87„DATA  88„DATA  89„DATA  90„DATA  91„DATA  92„DATA  93„DATA  94„DATA  95„DATA  96„DATA  97„DATA  98„DATA  99„DATA  100„DATA  101„DATA  102„DATA  103„DATA  104„DATA  105„DATA  106„DATA  107„DATA  108„DATA  109„DATA  110„DATA  111„DATA  112„DATA  113„DATA  114„DATA  115„DATA  116„DATA  117„DATA  118„DATA  119„DATA  120„DATA  121„DATA  122„DATA  123„DATA  124„DATA  125„DATA  126„DATA  127„DATA  128„DATA  129„DATA  130„DATA  131„DATA  132„DATA  133„DATA  134„DATA  135„DATA  136„DATA  137„DATA  138„DATA  139„DATA  140„DATA  141„DATA  142„DATA  143„DATA  144„DATA  145„DATA  146„DATA  147„DATA  148„DATA  149„DATA  150„DATA  151„DATA  152„DATA  153„DATA  154„DATA  155„DATA  156„DATA  157„DATA  158„DATA  159„DATA  160„DATA  161„DATA  162„DATA  163„DATA  164„DATA  165„DATA  166„DATA  167„DATA  168„DATA  169„DATA  170„DATA  171„DATA  172„DATA  173„DATA  174„DATA  175„DATA  176„DATA  177„DATA  178„DATA  179„DATA  180„DATA  181„DATA  182„DATA  183„DATA  184„DATA  185„DATA  186„DATA  187„DATA  188„DATA  189„DATA  190„DATA  191„DATA  192„DATA  193„DATA  194„DATA  195„DATA  196„DATA  197„DATA  198„DATA  199„DATA  200„DATA  201„DATA  202„DATA  203„DATA  204„DATA  205„DATA  206„DATA  207„DATA  208„DATA  209„DATA  210„DATA  211„DATA  212„DATA  213„DATA  214„DATA  215„DATA  216„DATA  217„DATA  218„DATA  219„DATA  220„DATA  221„DATA  222„DATA  223„DATA  224„DATA  225„DATA  226„DATA  227„DATA  228„DATA  229„DATA  230„DATA  231„DATA  232„DATA  233„DATA  234„DATA  235„DATA  236„DATA  237„DATA  238„DATA  239„DATA  240„DATA  241„DATA  242„DATA  243„DATA  244„DATA  245„DATA  246„DATA  247„DATA  248„DATA  249„DATA  250„DATA  251„DATA  252„DATA  253„DATA  254„DATA  255„Joe Huber, Jr.                 MULTIPLE KEYS                  huberjjr@nicom.com             03-08-97 (13:07)       QB, QBasic, PDS        97   3058     MULTIKEY.BASDECLARE FUNCTION MULTIKEY (KEYNUM)„„'MUTIKEY FUNCTION - LETS YOU TRAP SEVERAL KEYS AT ONCE (BETTER THAN INKEY$!!)„'„'USAGE:„'  riable=MULTIKEY(KEYNUM)„'WHERE KEYNUM IS THE KEY YOU WANT TO TRAP„'  riable = 1 IF KEY IS DEPRESSED, 0 IF IT ISN'T„'„'EMAIL ME AT: huberjjr@nicom.com„'„'HAVE FUN!!!„„„DIM SHARED KEYS(255), SC(255), DU(255)  'ALWAYS NEED THIS!!!„„CLS„„X = 10: Y = 10„XX = X: YY = Y„„DO„„'FOR I = 1 TO 255                    '\„' TEST = MULTIKEY(I)                 ' |-TEST LOOP„' LOCATE 1, 1: PRINT TEST; I         ' |„' WHILE INKEY$ = "": WEND            ' | PRESS KEY IN QUESTION UNTIL„'  IF TEST = 1 THEN END              ' | LOOP ENDS. THE SECOND NUMBER IS THE„'NEXT I                              '/  SCAN CODE FOR MULTIKEY„„RIGHT = MULTIKEY(75)    ' GET SOME KEYS' STATUSES„LEFT = MULTIKEY(77)„UP = MULTIKEY(72)„DOWN = MULTIKEY(80)„SPACE = MULTIKEY(57)„ESC = MULTIKEY(1)„„IF ESC = 1 THEN END    'TEMINATE WHEN ESCAPE IS PRESSED„„IF TIMELOOP = 100 THEN             'THIS MOVES YOU AROUND„ IF RIGHT = 1 THEN X = X - 1„ IF LEFT = 1 THEN X = X + 1        'THE TIMELOOP   RIABLE DELAYS„ IF UP = 1 THEN Y = Y - 1          'MOVEMENT WITHOUT SLOWING DOWN„ IF DOWN = 1 THEN Y = Y + 1        'INPUT (WITHOUT IT YOU WOULD GO„ TIMELOOP = 0                      'WAAAAYYY TOO FAST)„END IF„„IF X >= 80 THEN X = 80        'KEEPS YOU FROM GOING OFF THE SCREEN AND„IF X <= 0 THEN X = 1          'MAKING AN ERROR„IF Y >= 23 THEN Y = 23„IF Y <= 0 THEN Y = 1„„„IF SPACE = 1 THEN                    'CHANGES YOUTR SHAPE WHEN„ LOCATE Y, X: PRINT CHR$(94)         'YOU HIT SPACE„ELSE„ LOCATE Y, X: PRINT CHR$(127)„END IF„„IF XX <> X OR YY <> Y THEN           'UPDATES YOUR POSITION„ LOCATE YY, XX: PRINT " "„ LOCATE Y, X: PRINT CHR$(127)„END IF„„„XX = X: YY = Y                     'TELLS ME WHERE I WAS LAST„„TIMELOOP = TIMELOOP + 1„„LOOP                 'LOOP (DUH...) :)„„'THANX TO Eric Carr FOR FIGURING OUT HOW TO TRAP SEVERAL KEYS AT ONCE„'EVERYTHING ELSE WRITTEN BY ME,              „„FUNCTION MULTIKEY (KEYNUM)„„ STATIC FIRSTIME„„ IF FIRSTIME = 0 THEN„  FOR E = 0 TO 127              '\„  SC(E) = E: DU(E) = 1          '|„  NEXT                          '|-ERIC CARR'S CODE--------------------\„  FOR E = 128 TO 255            '|                                     |„  SC(E) = E - 128: DU(E) = 0    '|                                     |„  NEXT                          '/                                     |„  FIRSTIME = -1                 '                                      |„ END IF                         '                                      |„                                '                                      |„ I$ = INKEY$       ' So the keyb buffer don't get full     \routine/ \ |„ I = INP(&H60)     ' Get keyboard scan code from port 60h   \lines/  |-/„ OUT &H61, INP(&H61) OR &H82: OUT &H20, &H20       '         \!!!/   |„ KEYS(SC(I)) = DU(I) ' This says what keys are pressed        \!/    /„„MULTIKEY = KEYS(KEYNUM)„„„END FUNCTION„Joe Huber, Jr.                 MULTIKEY FUNCTION UPDATE       huberjjr@nicom.com             05-13-97 (14:46)       QB, QBasic, PDS        127  3287     MULTIKEY.BASDECLARE SUB KEYTEST (LOWERLIMIT!, UPPERLIMIT!)„DECLARE FUNCTION MULTIKEY (KEYNUM)„„'MUTIKEY FUNCTION - LETS YOU TRAP SEVERAL KEYS AT ONCE (BETTER THAN INKEY$!!)„'„'USAGE:„'  riable=MULTIKEY(KEYNUM)„'WHERE KEYNUM IS THE KEY YOU WANT TO TRAP„'  riable = 1 IF KEY IS DEPRESSED, 0 IF IT ISN'T„'„'CALL KEYTEST(lower,upper)„'Use this to find new keycodes„'(unrem below to test)„„' CALL KEYTEST(1, 200)„„'Gives all keynums between 1 & 200„'If the 0 by the number becomes a 1, then the key with that keycode is„'currently being depressed„„'EMAIL ME AT: huberjjr@nicom.com„'„'HAVE FUN!!!„„'„„„„CLS„„X = 10: Y = 10„XX = X: YY = Y„„DO„„RIGHT = MULTIKEY(75)    ' GET SOME KEYS' STATUSES„LEFT = MULTIKEY(77)„UP = MULTIKEY(72)„DOWN = MULTIKEY(80)„SPACE = MULTIKEY(57)„ESC = MULTIKEY(1)„„IF ESC = 1 THEN END    'TEMINATE WHEN ESCAPE IS PRESSED„„IF TIMELOOP = 100 THEN             'THIS MOVES YOU AROUND„ IF RIGHT = 1 THEN X = X - 1„ IF LEFT = 1 THEN X = X + 1        'THE TIMELOOP   RIABLE DELAYS„ IF UP = 1 THEN Y = Y - 1          'MOVEMENT WITHOUT SLOWING DOWN„ IF DOWN = 1 THEN Y = Y + 1        'INPUT (WITHOUT IT YOU WOULD GO„ TIMELOOP = 0                      'WAAAAYYY TOO FAST)„END IF„„IF X >= 80 THEN X = 80        'KEEPS YOU FROM GOING OFF THE SCREEN AND„IF X <= 0 THEN X = 1          'MAKING AN ERROR„IF Y >= 23 THEN Y = 23„IF Y <= 0 THEN Y = 1„„„IF SPACE = 1 THEN                    'CHANGES YOUTR SHAPE WHEN„ LOCATE Y, X: PRINT CHR$(94)         'YOU HIT SPACE„ELSE„ LOCATE Y, X: PRINT CHR$(127)„END IF„„IF XX <> X OR YY <> Y THEN           'UPDATES YOUR POSITION„ LOCATE YY, XX: PRINT " "„ LOCATE Y, X: PRINT CHR$(127)„END IF„„„XX = X: YY = Y                     'TELLS ME WHERE I WAS LAST„„TIMELOOP = TIMELOOP + 1„„LOOP                 'LOOP (DUH...) :)„„'THANX TO Eric Carr FOR FIGURING OUT HOW TO TRAP SEVERAL KEYS AT ONCE„'EVERYTHING ELSE WRITTEN BY ME,              „„SUB KEYTEST (LOWERLIMIT, UPPERLIMIT)„„„DO„X = 1„Y = 1„„ FOR I = LOWERLIMIT TO UPPERLIMIT„  TEST = MULTIKEY(I)„  LOCATE Y, X„  PRINT TEST; I„ „  IF Y < 23 THEN„   Y = Y + 1„  ELSE„   Y = 1„   X = X + 7„  END IF„ NEXT I„„LOOP WHILE MULTIKEY(1) = 0„END„END SUB„„FUNCTION MULTIKEY (KEYNUM)„„ STATIC FIRSTIME, KEYS(), SC(), DU()„„ IF FIRSTIME = 0 THEN„  DIM KEYS(255), SC(255), DU(255)„  FOR E = 0 TO 127              '\„  SC(E) = E: DU(E) = 1          '|„  NEXT                          '|-ERIC CARR'S CODE--------------------\„  FOR E = 128 TO 255            '|                                     |„  SC(E) = E - 128: DU(E) = 0    '|                                     |„  NEXT                          '/                                     |„  FIRSTIME = -1                 '                                      |„ END IF                         '                                      |„                                '                                      |„ I$ = INKEY$       ' So the keyb buffer don't get full     \routine/ \ |„ I = INP(&H60)     ' Get keyboard scan code from port 60h   \lines/  |-/„ OUT &H61, INP(&H61) OR &H82: OUT &H20, &H20       '         \!!!/   |„ KEYS(SC(I)) = DU(I) ' This says what keys are pressed        \!/    /„„MULTIKEY = KEYS(KEYNUM)„„„END FUNCTION„Robert Fortune                 KEYBOARD PORT TO SET DELAY     Ethan Winer's BASIC Techniques 07-01-97 (19:00)       QB, QBasic, PDS        45   2220     KEYPORTS.BAS'>I am making this "action"-game, where you have to avoid asteroids to get„'>points. However, I don't know how to get rid of keyboard delay, which is„'>VERY disturbing in a game like this. Does anyone know to get completely„'>rid of it? I have gotten it to minimum with DOS-command:„'>"mode con rate=32 delay=1", but there is still delay. Can anyone help„'>me?„„'   From Ethan Winer's book "BASIC: Techniques and Utilities" (available„'   in freeware form in the WINER.ZIP file):„„'   Keyboard Ports„„'   There are several ports associated with the keyboard, and one is of„'   particular interest. The enhanced keyboards that come with AT-class„'   and later computers allow you to control how quickly keystrokes are„'   repeated automatically. There are actually two values - one sets the„'   initial delay before keys begin to repeat, and the other establishes„'   the repeat rate. By sending the correct values through the keyboard„'   port, you can control the keyboard's typematic response. The complete„'   program that follows shows how to do this, and Table 10.3 shows how„'   the delay and repeat values are determined.„„   OUT &H60, &HF3        ' get keyboard's attention„   FOR D& = 1 TO 100     ' brief delay to give the hardware time to settle„   NEXT„„   Value = 7             ' 1/4 second initial delay, 16 CPS„   OUT &H60, Value„„'   Table 10.3 shows only some of the possible values that can be used.„'   However, you can interpolate additional values for delay times and„'   repeat rates between those shown.„„'  Table 10.3„'  Sample Values for Setting the initial and Repeat Rate on AT-Style Keyboard„'  --------------------------------------------------------------------------„'     Initial Delay                 0.25  0.50  0.75  1.00„'     30 characters per second       00    20    40    60„'     16 characters per second       07    27    47    67„'      8 characters per second       0F    2F    4F    6F„'      4 characters per second       17    37    57    77„'      2 characters per second       1F    3F    5F    7F„„'     Note: All values are shown in hexadecimal„'  ---------------------------------------------------------------------------„Kerry S. Goodin                TEST KEYBOARD BUFFER FOR CHAR  medvrsys@venus.net             08-19-97 (09:59)       QB, PDS                33   1547     INSTAT.BAS  ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„' -----Instat.bas----                                                      '„' Function to test the keyboard buffer to see if a character is present.   '„'                                                                          '„' ( A key has been pressed).                                               '„' It will not read the character but will return -1 if there is a          '„' character or 0 is there is not a character in the buffer thus leaving    '„' the buffer undisturbed.  This mimics the same function in PowerBasic(c)  '„' but for QB 4.5.                                                          '„' Written by: Kerry S. Goodin, D.D.S.                                      '„'                                                                          '„' USE AT YOUR OWN RISK.                                                    '„'                                                                          '„'note: start QB with the /L QB switch                                      '„'                                                                          '„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„„DEFINT A-Z„DECLARE FUNCTION instat ()„„'$INCLUDE: 'c:\qb45\qb.bi'„„DIM SHARED inRegs AS RegType, outRegs AS RegType„„FUNCTION instat„	inRegs.ax = &HB00„	CALL INTERRUPT(&H21, inRegs, outRegs)„	IF (outRegs.ax AND &HFF) <> 0 THEN„		instat = -1„	ELSE„		instat = 0„	END IF„END FUNCTION„Tommi Utriainen                CAPS ON/OFF ROUTINE            tomppa@pcuf.fi                 09-14-97 (21:42)       QB, QBasic, PDS        28   508      CAPS.BAS       ' caps on/off„   ' PRG BY TOMPPA 92„„   CLS„„                ' 0 normal„                ' 1 shift-„                ' 2 shift-„                ' 4 Ctrl-„                ' 8 Alt-„                ' 16 scroll lock„                ' 32 numlock„                ' 64 CAPSLOCK „                ' 128 -„                ' 256 -„„   DEF SEG = 0„   POKE &H417, 0„   DEF SEG„„„   LINE INPUT "lowecase:"; text$„„   DEF SEG = 0„   POKE &H417, 64„   DEF SEG„„   LINE INPUT "uppercase:"; text$„