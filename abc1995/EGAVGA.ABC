Rick Pedley                    SINE GRAPH                     SINE,GRAPH                     03-11-92 (10:20:00)    QB, QBasic             45   1611     SINEGRPH.BASDEFINT A-Z„DIM SineRow!(240), SineCol!(350)„FOR x = 1 TO 240„   SineRow!(x) = SIN(x / 10) * 30„NEXT x„FOR x = 1 TO 350„   SineCol!(x) = SIN(x / 20) * 30„NEXT x„                                                                 „SCREEN 12, 0  'VGA 640 x 480                                    „CF = 1: MaxVertRes = 480: MaxHorzRes = 640„R = 0: P = 0: H = 0„C = 0: A = 0: Z = 0: Under = -1  'Change to 0 for no under side.„T = 1: L = 1: K = MaxVertRes: D = 0: G = 0„T1! = TIMER„Start:                                                          „   P = K„   FOR C = T + D TO 1 STEP -CF„      A = T + L: R = A - C: IF R > 240 GOTO SkipSurface„      Z = (SineRow!(R) + SineCol!(C)) + 150„      H = K - Z - R„      IF H >= P OR H < 0 GOTO Underside„      P = H: PSET (A - 1, P), 9  '<-Try 10,12,13,etc.           „Underside:                                                      „      IF Under THEN„         IF R = L OR R = L + 1 THEN G = H + 5: GOTO SkipUnder„         IF H <= G GOTO SkipUnder„         G = H: IF G > MaxVertRes GOTO SkipUnder„         PSET (A - 1, G), 1 '<-Try 2,4,12, etc.                 „      END IF„SkipUnder:                                                      „   NEXT C„                                                                 „SkipSurface:                                                    „   IF A = MaxHorzRes GOTO Done„   T = T + 1„   IF T > 350 THEN„      T = 350„      L = L + 1: D = D + 1„      IF D = CF THEN D = 0„   END IF„   GOTO Start„Done:                                                           „DO UNTIL LEN(INKEY$): LOOP„„Unknown Author(s)              PICTURE SCALING                PICTURE,SCALING                Unknown Date (00:00:00)QB, QBasic             58   1980     SCALEPIC.BASDECLARE SUB DrawPicture ()„„SCREEN 9   'adjust for your system type„„LINE (0, 0)-(639, 349), 11, BF„x1 = 0„x2 = 1020„y1 = 0„y2 = 764„xPos% = 10„yPos% = 10„i% = 1„„DO„    ' define viewport„        VIEW (xPos%, yPos%)-(xPos% + 200, yPos% + 155), 0, 15„„    ' define logical coordinates„        WINDOW SCREEN (x1, y1)-(x2 / i%, y2 / i%)„„        DrawPicture„        i% = i% + 1„        xPos% = xPos% + 210„        IF i% = 4 THEN xPos% = 10: yPos% = 175„LOOP UNTIL i% = 7„END„„DATA 68, 4, 200, 76, 52, 12, 112, 44, 128, 52, 172, 76, 128, 52„DATA 68, 84, 112, 44, 84, 60, 128, 68, 100, 84, 68, 36, 96, 52„DATA 128, 68, 154, 84, 128, 68, 128, 116, 130, 54, 130, 68, 68„DATA 4, 52, 12, 172, 76, 142, 90, 142, 76, 142, 108, 142, 108„DATA 200, 76, 200, 76, 200, 92, 200, 92, 68, 164, 128, 116, 84„DATA 140, 52, 12, 52, 154, 52, 154, 68, 164, 68, 164, 68, 100„DATA 68, 36, 68, 84, 84, 45, 84, 76, 84, 109, 84, 140, 68, 100„DATA 96, 116, 84, 124, 112, 108, 68, 84, 128, 116, 85, 75, 113„DATA 91, 112, 77, 112, 108, 84, 119, 92, 115, 142, 86, 150, 82„DATA 180, 66, 186, 62, 186, 62, 236, 90, 236, 90, 68, 184, 68„DATA 184, 16, 154, 16, 154, 52, 133, 16, 154, 16, 160, 16, 160„DATA 68, 190, 68, 190, 68, 184, 68, 190, 236, 96, 236, 96, 236„DATA 90„„SUB DrawPicture STATIC„        RESTORE„        FOR i% = 1 TO 40        ' read coordinates„                READ x1%, y1%, x2%, y2%„                LINE (x1%, y1%)-(x2%, y2%), 1„        NEXT„„        PAINT (56, 20), 1, 1: PAINT (136, 64), 1, 1„        PAINT (120, 80), 1, 1: PAINT (152, 110), 14, 1„        PAINT (76, 48), 14, 1: PAINT (124, 60), 14, 1„        PAINT (68, 12), 2, 1: PAINT (80, 84), 2, 1„        PAINT (92, 128), 2, 1: PAINT (36, 150), 12, 1„        PAINT (150, 125), 12, 1: PAINT (80, 120), 14, 1„        PAINT (150, 125), 12, 1: PAINT (150, 142), 14, 1„        PAINT (88, 118), 12, 1: PAINT (144, 86), 12, 1„        PAINT (100, 120), 2, 1: PAINT (165, 90), 2, 1„END SUB„Scott Bailey                   BALL PATTERN USING XOR         BALL,PATTERN,XOR               Unknown Date (00:00:00)QB, QBasic             62   1281     BALLPTRN.BAS'BALLPTRN.BAS by Scott Bailey„'public domain„'draws patterns by XORing the ball bouncing off the walls„'hitting the spacebar starts a different pattern„„DEFINT A-Z„RANDOMIZE TIMER„SCREEN 12„CLS„CIRCLE (10, 10), 2, 3„CIRCLE (10, 10), 1, 9„DIM fly(0 TO 19)„GET (7, 7)-(12, 12), fly„„restart:„    CLS„    FOR h = 0 TO 639 STEP 10„        LINE (0, h)-(639, h), 4„        LINE (h, 0)-(h, 479), 4„    NEXT„   „    LINE (0, 0)-(639, 479), 4, B„   „    direction = INT(RND * 4) + 1„    x = RND * 300 + 10„    y = RND * 460 + 10„„DO„    a$ = INKEY$„    IF a$ = CHR$(27) THEN END„    IF a$ = " " THEN GOTO restart„   „    SELECT CASE direction„        CASE 1„            x = x + 4„            y = y - 4„        CASE 2„            y = y + 4„            x = x + 4„        CASE 3„            x = x - 4„            y = y + 4„        CASE 4„            x = x - 4„            y = y - 4„    END SELECT„„    IF x > 620 OR x < 20 OR y > 460 OR y < 20 THEN„        SELECT CASE direction„            CASE 1„                direction = 2„            CASE 2„                direction = 3„            CASE 3„                direction = 4„            CASE 4„                direction = 1„        END SELECT„    END IF„    PUT (x, y), fly„LOOP„„G.C.Harder                     EGA PCX VIEWER                 EGA,PCX,VIEWER                 Unknown Date (00:00:00)QB, QBasic, PDS        62   2476     PCX16.BAS        'PCX SAVE & PCX LOAD FOR EGA SCREEN 9 (640 x 350, 16 COLOR)          „     'BY G.C.HARDER, RE-ENGINEERED FROM C SOURCE IN„     ' "FRACTAL PROGRAMMING IN C"„    „     DEFINT A-Z„     DECLARE SUB PCXSave (File$, Pal.Array%())„     DECLARE SUB PCXLoad (File$, Pal.Array%())„ „     FileName$ = "Demo4.PCX"„     SCREEN 9, 0, 1, 0„     DIM Pal.Array%(15)„     FOR I% = 0 TO 15: READ Pal.Array%(I%): NEXT„     CLS„     LOCATE 25, 30: PRINT "Loading " + FileName$;„   „     PCXLoad FileName$, Pal.Array%()„     'default Palette Colors                                             „     DATA 0,1,2,3,4,5,20,7,56,57,58,59,60,61,62,63                      „„SUB PCXLoad (File$, Pal.Array%()) STATIC„        SCREEN 9, 0, 0, 0: OPEN File$ FOR BINARY AS #1: SEEK #1, 17„        DIM Byte AS STRING * 1„        FOR I% = 0 TO 15„           GET #1, , Byte: red% = ASC(Byte) / 85„           GET #1, , Byte: green% = ASC(Byte) / 85„           GET #1, , Byte: Blue% = ASC(Byte) / 85„           red% = ((red% AND 1) * 32) OR ((red% AND 2) * 2)„           green% = ((green% AND 1) * 16) OR (green% AND 2)„           Blue% = ((Blue% AND 1) * 8) OR ((Blue% AND 2) \ 2)„           Hue% = red% OR green% OR Blue%: Pal.Array%(I%) = Hue%„        NEXT„        PALETTE USING Pal.Array%(0): SEEK #1, 129: DEF SEG = &HA000„        FOR k% = 0 TO 349„           A$ = INKEY$: IF A$ = CHR$(27) THEN END„           Addr% = 80 * k%: Line.end% = Addr% + 80: J% = 1„           DO WHILE J% <= 4„              B% = J%„              IF J% = 3 THEN B% = 4„              IF J% = 4 THEN B% = 8„              OUT &H3C4, 2: OUT &H3C5, B%„              GET #1, , Byte: Byte.1% = ASC(Byte)„              IF (Byte.1% AND 192) <> 192 THEN„                 POKE Addr%, Byte.1%: Addr% = Addr% + 1„                 IF Addr% >= Line.end% THEN Addr% = 80 * k%: J% = J% + 1„              ELSE„                 Byte.1% = Byte.1% AND 63„                 GET #1, , Byte: Byte.2% = ASC(Byte)„                 FOR M% = 1 TO Byte.1%„                    B% = J%„                    IF J% = 3 THEN B% = 4„                    IF J% = 4 THEN B% = 8„                    OUT &H3C4, 2: OUT &H3C5, B%: POKE Addr%, Byte.2%„                    Addr% = Addr% + 1„                    IF Addr% >= Line.end% THEN Addr% = 80 * k%: J% = J% + 1„                 NEXT„              END IF„           LOOP„        NEXT„        OUT &H3C4, 2: OUT &H3C5, &HF: DEF SEG ': CLOSE #1„  „     END SUB„„Bryan Flick                    RESIZABLE VGA FONTS            RESIZABLE,VGA,FONTS            Year of 1992 (00:00:00)QB, QBasic, PDS        119  4561     VGAFONT.BAS ' Resizable VGA Font Routine„' Written by Bryan Flick„' (C) Copyright 1992, All Rights Reserved„ „' Below is a font routine that I wrote in QuickBASIC 4.5. With the PrintText„' subroutine, it is possible to print scalable characters, in any of 16„' colors, in either underline, italics, or shadow mode (or a combination of„' any three). Works only in VGA mode.„ „DEFINT A-Z: DIM Font(94, 8, 16), XS(8), YS(16): GOTO Start„ „PrintText:„' A$    = String to print„' Col1  = Color of font„' Col2  = Background color of font (used with shadow)„' T     = Tool (0=none, 1=underline, 2=italics, 4=shadow)„' X     = Starting X position       (in pixels)„' Y     = Starting Y position       (in pixels)„' XSize = Size of font horizontally (in pixels)„' YSize = Size of font vertically   (in pixels)„ „IX = XSize \ 8: IY = YSize \ 16„T1 = T AND 1„T2 = T AND 2: IF T2 <> 0 THEN T2 = 1„T3 = T AND 4: IF T3 <> 0 THEN T3 = 1„ „XS = IX * 8: YS = IY * 16„FOR I = 1 TO 8: XS(I) = IX: NEXT I„FOR I = 1 TO 16: YS(I) = IY: NEXT I„ „IF XS <> XSize THEN FOR I = 1 TO XSize - XS: XS(I) = XS(I) + 1: NEXT I„ „IF YS <> YSize THEN FOR I = 1 TO YSize - YS: YS(I) = YS(I) + 1: NEXT I„ „FOR I = 1 TO LEN(A$): C = ASC(MID$(A$, I, 1))„ „IF C = 13 THEN X = 0: Y = Y + YSize: IF Y < 480 GOTO Oops ELSE RETURN„IF C = 32 THEN X = X + XSize: IF X < 640 GOTO Oops ELSE RETURN„ „IF C >= 33 AND C <= 127 THEN Char = C - 32„ „TD1:    XS2 = Font(Char, 0, 0): XS3 = 0„        FOR A = 1 TO XS2: XS3 = XS3 + XS(A): NEXT A„        IF X + XS3 > 639 THEN RETURN„        X2 = X: Y2 = Y„        FOR K = 1 TO 16: Z1 = YS(K): IF Z1 = 0 THEN 96„        FOR J = 1 TO XS2: Z2 = XS(J): IF Z2 = 0 THEN 95„        IF Font(Char, J, K) = 0 GOTO TD2„        X9 = X + Z2 - 1: Y9 = Y + Z1 - 1„        IF T2 = 1 GOTO T2„        IF T3 = 1 THEN LINE (X + IX, Y + IY)-(X9 + IX, Y9 + IY), Col2, BF„        LINE (X, Y)-(X9, Y9), Col1, BF„        GOTO TD2„T2:     Q = (4 - K \ 2) * IX„        IF T3 = 1 THEN LINE (X + Q + IX, Y + IY)-(X9 + Q + IX, Y9 + IY), Col2, BF„        LINE (X + Q, Y)-(X9 + Q, Y9), Col1, BF„TD2:    X = X + Z2„95      NEXT J: X = X2: Y = Y + Z1„96      NEXT K: Y = Y2„        IF T1 = 1 THEN LINE (X, Y + YSize - 2)-(X + XS3, Y + YSize -2), Col1„        IF T1 = 1 AND T3 = 1 THEN LINE (X + 1, Y + YSize - 1)-(X + XS3+ 1, Y + YSize - 1), Col2„        X = X + XS3 + 1„Oops:   NEXT I„ „RETURN„ „Start: SCREEN 12: COLOR 15: PRINT "Please wait...": COLOR 1„ „Char1 = 1„        FOR Char2 = 33 TO 126„        LOCATE 2, 1: PRINT CHR$(Char2)„        FOR J = 1 TO 16: FOR I = 1 TO 8„        Font(Char1, I, J) = POINT(I - 1, J + 15)„        NEXT I, J„        I = 8: A = 0„2691    FOR J = 1 TO 8: IF Font(Char1, I, J) <> 0 THEN A = 1„        NEXT J„        IF A = 0 THEN I = I - 1: IF I <> 1 THEN 2691„        Font(Char1, 0, 0) = I„        Char1 = Char1 + 1„        NEXT Char2„ „X = 0: Y = 0: T = 0: XSize = 8: YSize = 16„ „CLS : COLOR 15„ „A$ =„"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*)"„ „PRINT "This is a sample of the 8x16 font...": PRINT„Col1 = 10: X = 0: Y = 16: GOSUB PrintText„PRINT "This is a sample of the 8x16 font underlined...": PRINT„Col1 = 11: T = 1: X = 0: Y = 48: GOSUB PrintText„PRINT "This is a sample of the 8x16 font italicized...": PRINT„Col1 = 12: T = 2: X = 0: Y = 80: GOSUB PrintText„PRINT "This is a sample of the 8x16 font with shadows...": PRINT„Col1 = 13: Col2 = 5: T = 4: X = 0: Y = 112: GOSUB PrintText„PRINT "This is a sample of the 8x16 font underlined, italicized, with„shadows...": PRINT„Col1 = 14: Col2 = 6: T = 7: X = 0: Y = 144: GOSUB PrintText„PRINT "This is a sample of the 16x16 font...": PRINT„Col1 = 10: T = 0: X = 0: Y = 176: XSize = 16: GOSUB PrintText„PRINT "This is a sample of the 8x32 font...": PRINT : PRINT„Col1 = 11: X = 0: Y = 208: XSize = 8: YSize = 32: GOSUB PrintText„PRINT "This is a sample of the 32x32 HEADLINE font, with shadows!":„PRINT : PRINT : PRINT„Col1 = 12: Col2 = 4: T = 4: X = 0: Y = 256: XSize = 32: YSize = 32:„GOSUB PrintText„PRINT TAB(29); "Written by Bryan Flick"„PRINT TAB(32); "53 Olde Mill Run"„PRINT TAB(30); "Stroudsburg, PA 18360"„PRINT TAB(27); "717-421-1764 (24 hour BBS)": PRINT„COLOR 11: PRINT TAB(21); "(C) Copyright 1992, All Rights Reserved"„SLEEP: END„ „' That's it! Hopefully the echo doesn't butcher the program up too„' much, if so just let me know and I'll find another way to resend„' it! If you take a look at it, I'd appreciate it if you let me know„' what you think! Thanks!„Jon Springer                   FONT DESIGN                    FONT,DESIGN                    Year of 1992 (00:00)   QB, QBasic, PDS        423  14092    FE.BAS      DEFINT A-Z„DECLARE SUB Get.input ()„DECLARE SUB Editor ()„DECLARE SUB In.key ()„DECLARE SUB Out.alphabet ()„DECLARE SUB Save.font ()„DECLARE SUB Load.font ()„DECLARE SUB Put.pixel ()„DECLARE SUB Help ()„DECLARE SUB Fill ()„DECLARE SUB Insert ()„DECLARE SUB Delete ()„DECLARE SUB Gets.puts ()„DIM SHARED font(62, 16, 16), store(16, 16), box(1 TO 2), grid(16, 16)„DIM SHARED i, z, a$, k$, name$, flag, delay, down, across, X, Y„DIM SHARED maxacross, maxdown, cell, gonk„ON ERROR GOTO Handler„LET box(1) = 16: box(2) = 16: maxacross = 64: maxdown = 35„    down = 1: across = 1: name$ = "default": delay = 60„KEY 1, CHR$(176): KEY 2, CHR$(177): SCREEN 9: COLOR 11, 8: WIDTH 80, 25„'-----------------------------------------------------------------„main:„CLS : Get.input: CLS„maxacross = INT(640 / box(1)): maxdown = INT(350 / box(2)): z = 0: i = 0: a$ = ""„edit.start:„   Editor„GOTO main:„Handler:„     BEEP„     SELECT CASE ERR„     CASE 52 TO 67„     PRINT : PRINT "An error in file-handling has occurred..."„     PRINT "Any key...": a$ = INPUT$(1)„     CLOSE : SCREEN , , 0, 0: COLOR 13, 8„     CASE 6„     PRINT "Bad input...Try again"; : a$ = INPUT$(1)„     RESUME main„     CASE ELSE„     SCREEN , , 0, 0: CLS : PRINT "Unrecoverable Error #"; ERR„     IF ERR = 5 THEN PRINT "256k EGA required for FONT...": a$ = INPUT$(1)„     END„     END SELECT„     RESUME edit.start„ „„SUB Delete„PALETTE 12, 13„  FOR i = cell + 1 TO 62„    FOR glom = 1 TO box(1)„      FOR glim = 1 TO box(2)„        LET font(i - 1, glom, glim) = font(i, glom, glim)„      NEXT„    NEXT„  NEXT„    FOR glom = 1 TO box(1)„      FOR glim = 1 TO box(2)„        LET font(62, glom, glim) = 0„      NEXT„    NEXT: Out.alphabet: i = 0„END SUB„„SUB Editor„start.editor:„     cell = 1„     COLOR 14, 8„     LOCATE 1, 1: PRINT "Editing "; CHR$(34); name$; CHR$(34); "  ";„     PRINT box(1); "across"; box(2); "down";„     PRINT "              Font Display Window"„     LINE (0, 13)-(639, 15), 12, BF: LINE (320, 0)-(323, 300), 12, BF„     LINE (0, 300)-(639, 303), 12, BF„     LOCATE 23, 1: PRINT "<?> displays other useful keys.        ";„     PRINT "         <Esc> Exits Editor";„     LOCATE 25, 1: PRINT "<Space> & cursor keys edit cell.";„     PRINT "               <F1> Save  <F2> Load";„     LINE (320, 303)-(323, 350), 12, BF: LINE (0, 325)-(639, 327), 12, BF„     IF gonk = 1 THEN Out.alphabet„     COLOR 13, 8„     LOCATE 4, 1: PRINT "Enter lower/upper case letters or"„     PRINT " # 0/9 to move among cells.": COLOR 14, 8„do.grid:„     LOCATE 20, 1: PRINT "You are at cell"; cell; "; "„     IF cell < 27 THEN„        PRINT "The letter "; CHR$(cell + 64); "                  "„     END IF„     IF cell > 26 AND cell < 53 THEN„        PRINT "The letter "; CHR$(cell - 26 + 96); "         "„     END IF„     IF cell > 52 THEN PRINT "A user defined cell"„     LINE (10, 100)-(200, 260), 0, BF„     FOR i = 1 TO box(2)„       FOR z = 1 TO box(1)„        IF font(cell, z, i) = 0 THEN„          LINE (10 * z, 100 + ((i - 1) * 10))-(10 * z + 10, 100 + ((i - 1) * 10) + 10), 15, B„        ELSE„          LINE (10 * z, 100 + ((i - 1) * 10))-(10 * z + 10, 100 + ((i - 1) * 10) + 10), 15, BF„        END IF„       NEXT z„     NEXT i„in.k:„     In.key„     IF i = 6 THEN GOTO do.grid„     IF i = 2 THEN GOTO animate„     IF i = 3 THEN EXIT SUB„     IF i = 4 THEN Save.font„     IF i = 5 THEN Load.font„     IF i = 1 THEN Out.alphabet„     IF i = 13 THEN Help„     IF i = 7 THEN Insert„     IF i = 8 THEN Delete„     IF i = 9 OR i = 10 THEN Fill„     IF i = 11 OR i = 12 THEN Gets.puts„   IF flag = 1 THEN LET flag = 0: GOTO start.editor„   GOTO do.grid„animate:„    LET font(cell, across, down) = font(cell, across, down) + 1„    IF font(cell, across, down) = 2 THEN LET font(cell, across, down) = 0„      IF font(cell, across, down) = 1 THEN„      LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), 15, BF„      ELSE„      LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), 0, BF„      LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), 15, B„    END IF„  gonk = 1:  Put.pixel:  GOTO in.k„END SUB„„SUB Fill„  IF i = 9 THEN LET g = 0 ELSE g = 1„  FOR glom = 1 TO box(1)„     FOR glim = 1 TO box(2)„     LET font(cell, glom, glim) = g„     LET across = glom: LET down = glim: Put.pixel„     NEXT„  NEXT„LET down = 1: LET across = 1„END SUB„„SUB Get.input„  LOCATE 1, 12: PRINT "Font Des";„  LINE (30, 20)-(610, 260), 13, B„  PRINT "ign   vers.";„  LINE (40, 30)-(600, 250), 13, B„  PAINT (31, 21), 1, 13„  PRINT "2.5   ****   written by Jon Springer    "„  LOCATE 4, 23: PRINT "Enter a number to change options": COLOR 14, 8„  LOCATE 5, 21: PRINT STRING$(40, "- ")„  LOCATE 7, 22: PRINT "1>   Character box across."„  LOCATE 9, 22: PRINT "2>   Character box down..."„  LOCATE 11, 22: PRINT "3>   Font Set name........"„  LOCATE 13, 22: PRINT "4>   Screen blanker......."„  LOCATE 14, 21: PRINT STRING$(40, "- "): COLOR 11„  LOCATE 16, 22: PRINT "Esc>   Go to Editor"„  LOCATE 17, 22: PRINT "Q>     System"„  GOSUB print.options„'--------------------------------------------------------------------„stuff.input:„  LOCATE 23, 1: a$ = INKEY$: z = z + 1: IF z = 5000 THEN z = 1„  IF z = 1 THEN PRINT CHR$(219)„  IF z = 2500 THEN PRINT " "„  IF a$ = "" THEN GOTO stuff.input„  IF a$ = "Q" OR a$ = "q" THEN GOTO end.message„  IF a$ = CHR$(27) THEN EXIT SUB„  IF a$ = "1" THEN GOSUB one„  IF a$ = "2" THEN GOSUB two„  IF a$ = "3" THEN GOSUB three„  IF a$ = "4" THEN GOSUB four„  GOSUB print.options„  LOCATE 23, 1: PRINT STRING$(78, " ")„  GOTO stuff.input„one:„INPUT "Enter character box across "; a$„i = VAL(a$)„IF i > 16 THEN LET i = 16„IF i < 2 THEN LET i = 2„box(1) = INT(i)„a$ = ""„RETURN„two: „INPUT "Enter character box down "; a$„i = VAL(a$)„IF i > 16 THEN LET i = 16„IF i < 2 THEN LET i = 2„box(2) = INT(i)„a$ = ""„RETURN„three:„LINE INPUT "Enter new name > "; k$„IF k$ = "" THEN RETURN„IF LEN(k$) > 8 OR LEN(k$) < 1 THEN LOCATE 23, 1: GOTO three„LET name$ = k$„RETURN„four:„INPUT "Enter new screen blanker delay "; a$„i = VAL(a$)„IF i > 200 THEN LET i = 200„IF i < 10 THEN LET i = 10„delay = INT(i) * 2„a$ = ""„RETURN„print.options:„  LOCATE 7, 48: PRINT box(1): LOCATE 9, 48: PRINT box(2)„  LOCATE 11, 49: PRINT name$; "                ":„  LOCATE 13, 48: PRINT delay / 2; "   ": RETURN„end.message:„SCREEN 0: COLOR 14: PRINT "FONT DESIGN 2.5...1992": PRINT : COLOR 7, 0: END„END SUB„„SUB Gets.puts„  IF i = 11 THEN GOTO gets„puts:„  FOR lom = 1 TO box(1)„     FOR lim = 1 TO box(2)„     LET font(cell, lom, lim) = store(lom, lim)„     LET across = lom: LET down = lim: Put.pixel„     NEXT„  NEXT„  EXIT SUB„gets:„  FOR lom = 1 TO box(1)„     FOR lim = 1 TO box(2)„     LET store(lom, lim) = font(cell, lom, lim)„     NEXT„  NEXT„END SUB„„SUB Help„SCREEN , , 1, 1: CLS„LOCATE 2, 30: COLOR 13, 8: PRINT "*** Help Screen ***"„LOCATE 20, 30: PRINT "***** Any Key *****"„LOCATE 3, 30: COLOR 1: PRINT STRING$(80, 176): PRINT : PRINT : COLOR 14„PRINT "<Enter>   = Refresh font display window": PRINT„PRINT "<Insert>  = Insert a blank cell, bumping last cell in the font"„PRINT "<Delete>  = Delete a cell, moving all cells after it up one "„PRINT : PRINT "<Home>    = Clear a cell"„PRINT "<End>     = Fill a cell": PRINT„PRINT "<Pg Up>   = Store a cell"„ PRINT "<Pg Down> = Paste the stored cell"„LOCATE 17, 30: COLOR 1: PRINT STRING$(80, 176): COLOR 15„stuf.input:„  LOCATE 25, 1: a$ = INKEY$: z = z + 1: IF z = 5000 THEN z = 1„  IF z = 1 THEN PRINT CHR$(219);„  IF z = 2500 THEN PRINT " ";„  IF a$ = "" THEN GOTO stuf.input„a$ = "": SCREEN , , 0, 0: COLOR 14„END SUB„„SUB In.key„   flag = 0: Null$ = CHR$(0)„main.input:„     LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), col, B„     a$ = INKEY$: z = z + 1: IF z > 1000 THEN LET z = 1„     IF z = 1 THEN col = 14 ELSE IF z = 500 THEN col = 4: LET nerf = nerf + 1„      IF nerf = delay THEN GOSUB blanker„     IF a$ = "" THEN GOTO main.input„     nerf = 0„     IF a$ = CHR$(8) THEN LET i = 1: flag = 1: EXIT SUB„     IF a$ = CHR$(13) THEN LET i = 1: EXIT SUB„     IF a$ = " " THEN LET i = 2: EXIT SUB„     IF a$ = CHR$(27) THEN LET i = 3: EXIT SUB„     IF a$ = CHR$(176) THEN LET i = 4: EXIT SUB„     IF a$ = CHR$(177) THEN LET i = 5: EXIT SUB„     IF a$ = "?" OR a$ = "/" THEN LET i = 13: EXIT SUB„   SELECT CASE a$„     CASE Null$ + CHR$(75)   ' LEFT key: move cursor left„         flag = 1„         LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), 15, B„         across = across - 1: IF across = 0 THEN across = box(1)„     CASE Null$ + CHR$(77)   ' RIGHT key: move cursor right„         flag = 1„         LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), 15, B„         across = across + 1: IF across > box(1) THEN across = 1„     CASE Null$ + CHR$(72)   ' UP key: move cursor up„         flag = 1„         LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), 15, B„         down = down - 1: IF down = 0 THEN down = box(2)„     CASE Null$ + CHR$(80)   ' DOWN key: move cursor down„         flag = 1„         LINE (10 * across, 100 + ((down - 1) * 10))-(10 * across + 10, 100 + ((down - 1) * 10) + 10), 15, B„         down = down + 1: IF down > box(2) THEN down = 1„     CASE Null$ + CHR$(82)„         i = 7: EXIT SUB„     CASE Null$ + CHR$(83)„         i = 8: EXIT SUB„     CASE Null$ + CHR$(71)„         i = 9: EXIT SUB„     CASE Null$ + CHR$(79)„         i = 10: EXIT SUB„     CASE Null$ + CHR$(73)„         i = 11: EXIT SUB„     CASE Null$ + CHR$(81)„         i = 12: EXIT SUB„   END SELECT„   LOCATE 7, 1: PRINT "ACROSS"; across; " DOWN"; down; "     "„ „   IF flag = 1 THEN LET flag = 0: GOTO main.input„i = 6„IF ASC(a$) < 48 THEN LET cell = 1: EXIT SUB„IF ASC(a$) < 58 THEN LET cell = 53 + (ASC(a$) - 48): EXIT SUB„IF ASC(a$) >= 65 AND ASC(a$) <= 90 THEN„  LET cell = 1 + (ASC(a$) - 65): EXIT SUB„END IF„IF ASC(a$) >= 97 AND ASC(a$) <= 122 THEN„   LET cell = 27 + (ASC(a$) - 97): EXIT SUB„END IF„LET cell = 1: EXIT SUB„blanker:„   nerf = 0: SCREEN , , 1, 1: COLOR 0, 0: LINE (0, 0)-(639, 349), 0, BF„   a$ = INPUT$(1): SCREEN , , 0, 0: a$ = "": COLOR 14, 8: RETURN„END SUB„„SUB Insert„PALETTE 12, 13„  FOR i = 61 TO cell STEP -1„    FOR glom = 1 TO box(1)„      FOR glim = 1 TO box(2)„        LET font(i + 1, glom, glim) = font(i, glom, glim)„      NEXT„    NEXT„  NEXT„    FOR glom = 1 TO box(1)„      FOR glim = 1 TO box(2)„        LET font(cell, glom, glim) = 0„      NEXT„    NEXT: Out.alphabet: i = 0„END SUB„„SUB Load.font„   gonk = 1„   SCREEN , , 1, 1„   LOCATE 1, 1: CLS„   FILES "*.f": PRINT : PRINT„   INPUT "Load what font "; a$„   IF LEN(a$) > 8 OR LEN(a$) < 1 THEN BEEP: GOTO endall2„   OPEN a$ + ".f" FOR INPUT AS #1„   INPUT #1, box(1), box(2)„   ERASE font„   FOR i = 1 TO 62„     FOR ii = 1 TO box(1)„     FOR iii = 1 TO box(2)„       INPUT #1, font(i, ii, iii)„     NEXT iii„     NEXT ii„   NEXT i„   LET name$ = a$„   CLOSE„endall2:„SCREEN , , 0, 0„     across = 1: down = 1„     COLOR 14, 8„     FOR i = 1 TO 12„     LOCATE i + 3, 42: PRINT STRING$(38, " ")„     NEXT„     LOCATE 1, 1: PRINT "Editing "; CHR$(34); name$;„     PRINT CHR$(34); "  "; box(1); "across"; box(2); "down";„     LINE (0, 13)-(639, 15), 12, BF: LINE (320, 0)-(323, 300), 12, BF„     COLOR 14, 8„     Out.alphabet„ „END SUB„„SUB Out.alphabet„   IF flag = 0 THEN X = 330: Y = 50 ELSE X = 2: Y = 2„   IF flag = 1 THEN SCREEN 7„   PALETTE 12, 13„   FOR i = 1 TO 13„     FOR across = 1 TO box(1)„     FOR down = 1 TO box(2)„     IF font(i, across, down) = 1 THEN col = 15 ELSE col = 0„     PSET (X + (i * box(1)) + across, Y + down), col„     IF font(i + 13, across, down) = 1 THEN col = 15 ELSE col = 0„     PSET (X + (i * box(1)) + across, Y + down + 30), col„     IF font(i + 26, across, down) = 1 THEN col = 15 ELSE col = 0„     PSET (X + (i * box(1)) + across, Y + down + 60), col„     IF font(i + 39, across, down) = 1 THEN col = 15 ELSE col = 0„     PSET (X + (i * box(1)) + across, Y + down + 90), col„     IF i < 11 THEN„       IF font(i + 52, across, down) = 1 THEN col = 15 ELSE col = 0„       PSET (X + (i * box(1)) + across, Y + down + 120), col„     END IF„     NEXT down„     NEXT across„   NEXT i„   IF flag = 0 THEN GOTO past.it.all„   COLOR 15: LOCATE 21, 3: FOR i = 1 TO 26: PRINT CHR$(64 + i); : NEXT„   LOCATE 23, 3: FOR i = 1 TO 26: PRINT CHR$(96 + i); : NEXT„   a$ = INPUT$(1): a$ = "": down = 1: across = 1„   SCREEN 9: COLOR 13, 8: EXIT SUB„past.it.all:„down = 1: across = 1: PALETTE: COLOR 14, 8„END SUB„„SUB Put.pixel„  dx = 0: i = cell„  IF cell > 13 THEN LET dx = dx + 30: i = cell - 13„  IF cell > 26 THEN LET dx = dx + 30: i = cell - 26„  IF cell > 39 THEN LET dx = dx + 30: i = cell - 39„  IF cell > 52 THEN LET dx = dx + 30: i = cell - 52„  IF font(cell, across, down) = 1 THEN LET col = 15 ELSE LET col = 0„  PSET (330 + (i * box(1)) + across, dx + 50 + down), col„END SUB„„SUB Save.font„   SCREEN , , 1, 1: LOCATE 1, 1: CLS„   FILES "*.*": PRINT : PRINT„   PRINT TAB(10); "Save "; name$; " to disk?"; : a$ = INPUT$(1)„   IF a$ <> "Y" AND a$ <> "y" THEN GOTO endall„   OPEN name$ + ".F" FOR OUTPUT AS #1„   WRITE #1, box(1), box(2)„   FOR i = 1 TO 62„     FOR ii = 1 TO box(1)„     FOR iii = 1 TO box(2)„        IF ii = box(1) AND iii = box(2) THEN„          IF font(i, ii, iii) = 1 THEN PRINT #1, "1" ELSE PRINT #1, "0"„        ELSE„          IF font(i, ii, iii) = 1 THEN PRINT #1, "1,";  ELSE PRINT #1, "0,";„        END IF„     NEXT iii„     NEXT ii„   NEXT i„   CLOSE„endall:„ SCREEN , , 0, 0: COLOR 14, 8„END SUB„„Ian Remmler                    3D ATTRACTOR DEMO              3D,ATTRACTOR,DEMO              Unknown Date (00:00)   QB, PDS                236  5307     3DATTR.BAS  'Here's a 3D attractor demo that lets you rotate the attractor on„'the X, Y, and Z axes then view it. (like on FractInt) If you have„'a mouse you can use it to zoom in. I didn't spend time on putting„'in a keyboard equivalent, so if you don't have a mouse you can make„'a routine for the keyboard, or change the WINDOW statement manually.„'Have fun with it, and feel free to hack it to pieces.„„DECLARE SUB Crsr (x!)„DECLARE SUB zoom ()„DECLARE FUNCTION MPos (Coord)„DECLARE FUNCTION MBttn ()„„'$INCLUDE: 'qb.bi'„DIM SHARED Regs AS RegTypeX„DIM sine(359) AS SINGLE, cosine(359) AS SINGLE„„CONST pi = 3.1415926535#„„dist = 100 'This is the distance from the screen used in the„ 'perspective formula.„„AngleX = 0 '\„AngleY = 0 ' > angles of rotation„AngleZ = 0 '/„„SCREEN 9„PRINT "Creating SIN/COS Tables..."„PRINT : PRINT "Press F1 any time to goto Main Menu."„PRINT "Press F2 any time to exit program."„PRINT : PRINT "If you have a mouse, you can use the LMB to"„PRINT "zoom in on an attractor,or the RMB to exit."„LOCATE 24, 1: PRINT "Strange Attractor Demo - By: Ian Remmler.";„twirl$ = "\-/" + CHR$(179)„„FOR t = 0 TO 359 'create sine/cosine tables„LOCATE 1, 28: PRINT MID$(twirl$, t MOD 4 + 1, 1)„sine(t) = SIN(t * (pi / 180))„cosine(t) = COS(t * (pi / 180))„NEXT„„KEY(1) ON            '\„KEY(2) ON            ' \ sets up event trapping on F1 & F2„ON KEY(1) GOSUB Main ' /„ON KEY(2) GOSUB Leave'/„GOSUB WhichOne„„Lorenz: 'Converted from the FractInt documentation.„WINDOW (-32, -0)-(32, 35)„dt = .05„a = 3„b = 15„c = 1„„Lstart:„x = 1„y = 1„z = 1„„CLS„GOSUB Translate„PSET (xxx, yyy)„Crsr 1„DO„xx = x: yy = y: zz = z„x = xx + (-a * xx * dt) + (a * yy * dt)„y = yy + (b * xx * dt) - (yy * dt) - (zz * xx * dt)„z = zz + (-c * zz * dt) + (xx * yy * dt)„GOSUB Translate„Crsr 0: LINE -(xxx, yyy): Crsr 1„IF MBttn = 1 THEN zoom: GOTO Lstart„LOOP UNTIL MBttn = 2„Crsr 0„GOSUB Leave„„Rossler: 'Also from FractInt docs.„WINDOW (-64, -35)-(64, 35)„dt = .05„a = .2„b = .2„c = 5.7„„Rstart:„x = 1„y = 1„z = 1„„CLS„GOSUB Translate„PSET (xxx, yyy)„Crsr 1„DO„xx = x: yy = y: zz = z„x = xx - yy * dt - zz * dt„y = yy + xx * dt + a * yy * dt„z = zz + b * dt + xx * zz * dt - c * zz * dt„GOSUB Translate„Crsr 0: LINE -(xxx, yyy): Crsr 1„IF MBttn = 1 THEN zoom: GOTO Rstart„LOOP UNTIL MBttn = 2„Crsr 0„GOSUB Leave„„Mutant: 'Wrote this one all by myself! Pretty spiffy, huh?„WINDOW (-32, -17.5)-(32, 17.5)„dt = .02„a = 8„b = 10„c = 10„„Mstart:„x = 1„y = 1„z = 1„„CLS„GOSUB Translate„PSET (xxx, yyy)„Crsr 1„DO„xx = x: yy = y: zz = z„x = xx - (a * zz * dt) + (-a * yy * dt)„y = yy + (b * xx * dt) - (yy * dt) - (zz * xx * dt)„z = zz + (-c * zz * dt) - (xx * yy * dt)„GOSUB Translate„Crsr 0: LINE -(xxx, yyy): Crsr 1„IF MBttn = 1 THEN zoom: GOTO Mstart„LOOP UNTIL MBttn = 2„Crsr 0„GOSUB Leave„„Translate: 'converts x,y,z coords. to x,y so they can be put on„ 'the screen. We use the basic rotation formula on the„ 'X axis, then Y, then Z.„za = z * sine(AngleX) - y * cosine(AngleX) '\ X rotation„ya = z * cosine(AngleX) + y * sine(AngleX) '/„za = za * sine(AngleY) - x * cosine(AngleY) '\ Y rotation„xa = za * cosine(AngleY) + x * sine(AngleY) '/„xa = ya * sine(AngleZ) - xa * cosine(AngleZ) '\ Z rotation„ya = ya * cosine(AngleZ) + xa * sine(AngleZ) '/„xxx = xa * (dist / (dist + za))„yyy = ya * (dist / (dist + za))„RETURN„„Main:„KEY(1) ON„ON KEY(1) GOSUB Main„CLS : PRINT "Main Menu!"„PRINT "1. Select an Attractor."„PRINT "2. Change Parameters."„PRINT "3. Change Angles of Rotation."„PRINT„DO: q = VAL(INKEY$)„LOOP WHILE q = 0„ON q GOSUB WhichOne, Params, Angles„CLS„RETURN„„WhichOne:„„CLS : PRINT "Select an Attractor!"„PRINT : PRINT "1. Lorenz"„PRINT "2. Rossler"„PRINT "3. Mutant"„PRINT„DO: q = VAL(INKEY$)„LOOP WHILE q = 0„ON q GOSUB Lorenz, Rossler, Mutant„„Params:„PRINT "Input New Parameters!"„PRINT„PRINT "A= "; a; " "; : INPUT a„PRINT "B= "; b; " "; : INPUT b„PRINT "C= "; c; " "; : INPUT c„PRINT "DT= "; dt; " "; : INPUT dt„CLS„RETURN„„Angles:„PRINT "Change Angles of Rotation!"„PRINT„PRINT "X= "; AngleX; " "; : INPUT AngleX„PRINT "Y= "; AngleY; " "; : INPUT AngleY„PRINT "Z= "; AngleZ; " "; : INPUT AngleZ„PRINT "Perspective Distance= "; dist; " "; : INPUT dist„CLS„RETURN„„Leave:„END„„SUB Crsr (x) 'this sub turns the pointer on and off (Crsr 0=off)„SELECT CASE x                                     '(Crsr 1=on)„CASE 0„Regs.ax = 2„CASE 1„Regs.ax = 1„END SELECT„CALL INTERRUPTX(&H33, Regs, Regs)„END SUB„„FUNCTION MBttn 'returns which buttons are currently down.„Regs.ax = 3„CALL INTERRUPTX(&H33, Regs, Regs)„MBttn = Regs.bx„END FUNCTION„„FUNCTION MPos (Coord) 'returns the x,y coords. of the mouse„Regs.ax = 3„CALL INTERRUPTX(&H33, Regs, Regs)„SELECT CASE Coord„CASE 0„MPos = Regs.cx„CASE 1„MPos = Regs.dx„END SELECT„END FUNCTION„„SUB zoom 'zooms in on the attractor using the mouse.„Crsr 0„PCOPY 0, 1„Crsr 1„x1 = PMAP(MPos(0), 2)„y1 = PMAP(MPos(1), 3)„DO„Crsr 0„PCOPY 1, 0„x2 = PMAP(MPos(0), 2)„y2 = PMAP(MPos(1), 3)„Crsr 1„LINE (x1, y1)-(x2, y2), , B„WHILE PMAP(MPos(0), 2) = x2 AND PMAP(MPos(1), 3) = y2: WEND„LOOP WHILE MBttn = 1„WINDOW (x1, y1)-(x2, y2)„Crsr 0„END SUB„Kim Christensen                SHOW 16 COLOR BMP              SHOW,16,COLOR,BMP              Unknown Date (00:00)   QB, QBasic, PDS        74   2318     SHOWBMP.BAS 'By Kim Christensen„'This routine will read in a Windows Bitmap file and display it.„'Only 16 color Bitmaps are supported. Even with SCREEN 13: I am„'only using that mode to "blow up" the picture a bit.„'Comments? Questions? Suggestions? : uv317@freenet.victoria.bc.ca„'No flames please! :)„„INPUT "Filename"; data$„IF LTRIM$(RTRIM$(data$)) = "" THEN END„OPEN data$ FOR BINARY AS #1„IF LOF(1) = 0 THEN PRINT "File not found!": CLOSE : KILL data$: END„„table$ = INPUT$(54, #1)  'Get the file header (54 bytes)„DIM table&(30)           'Create numerical array for header„DEF SEG = VARSEG(table&(1))„pointer% = VARPTR(table&(1))„„'Poke the data from string "table$" into numerical array "table&"„FOR x% = 0 TO 51„ POKE pointer% + x%, ASC(MID$(table$, x% + 3, 1))„NEXT„DEF SEG„„'Check for valid file type„IF MID$(table$, 1, 2) <> "BM" OR table&(4) <> 40 THEN„   PRINT "Not a valid *.BMP file!": END„END IF„IF table&(8) <> 0 THEN„   PRINT "This program will not diplay RLE encoded files": END„END IF„IF ASC(MID$(table$, 29, 1)) <> 4 THEN„   PRINT "Only 16 color bitmaps are supported!": END„END IF„„'Set the video mode for best picture fit„IF (table&(5) < 321) AND (table&(6) < 201) THEN„   SCREEN 13„ELSE„   SCREEN 12„END IF„LOCATE 2, 1„PRINT " Image is "; table&(5); " by "; table&(6)„„thecolors$ = INPUT$(table&(3) - 54, #1) 'Read in pallette info„DEF SEG = VARSEG(pal&)„pointer% = VARPTR(pal&)„'Poke the pallette info from the string "thecolors$"„'into pal& and reduce to 6 bits per byte.„FOR x% = 0 TO 63 STEP 4„ POKE pointer%, (ASC(MID$(thecolors$, x% + 3, 1))) \ 4„ POKE pointer% + 1, (ASC(MID$(thecolors$, x% + 2, 1))) \ 4„ POKE pointer% + 2, (ASC(MID$(thecolors$, x% + 1, 1))) \ 4„ POKE pointer% + 3, 0„PALETTE x% \ 4, pal&„NEXT„DEF SEG„„'Read in Bitmap data and set pixels accordingly„y% = table&(6) 'Put number of vertical pixels into y%„DO„  data$ = INPUT$((((table&(5) - 1) OR 7) + 1) \ 2, #1)„    IF (table&(5) \ 2) < LEN(data$) THEN„       linelength% = table&(5) \ 2„    ELSE„       linelength% = LEN(data$)„    END IF„    FOR x% = 1 TO linelength%„      pixel% = ASC(MID$(data$, x%, 1))„      PSET (x% * 2 + 1, y%), pixel% AND 15„      PSET (x% * 2, y%), pixel% \ 16„    NEXT„    y% = y% - 1„LOOP UNTIL EOF(1) OR INKEY$ <> ""„SLEEP„Christy Gemmell                HORIZONTAL PAN DEMO            HORIZONTAL,PAN,DEMO            Unknown Date (00:00)   QB, QBasic, PDS        45   1387     PANDEM.BAS  ' PANDEM.BAS    demonstrates how to pan EGA/VGA screens„'„'   Author:     Christy Gemmell„'„    DECLARE SUB PanDisplay (x%, y%)„„    CONST FALSE = 0, TRUE = NOT FALSE„„    SCREEN 9„    LINE (0, 0)-(639, 349), 9, BF„    VIEW SCREEN (40, 25)-(600, 325), 0, 15„    CIRCLE (319, 174), 150, 14„    PAINT (319, 174), 14, 14„„    x% = 0: y% = 0: Esc$ = CHR$(27)„    LeftArrow$ = CHR$(0) + CHR$(75): RightArrow$ = CHR$(0) + CHR$(77)„    UpArrow$ = CHR$(0) + CHR$(72): DownArrow$ = CHR$(0) + CHR$(80)„„    DO„        DO„            KeyStroke$ = INKEY$„        LOOP WHILE KeyStroke$ = ""„        Pan% = TRUE„        SELECT CASE KeyStroke$„            CASE LeftArrow$„                 IF x% > 0 THEN x% = x% - 1„            CASE RightArrow$„                 IF x% < 79 THEN x% = x% + 1„            CASE UpArrow$„                 IF y% > 0 THEN y% = y% - 1„            CASE DownArrow$„                 IF y% < 22 THEN y% = y% + 1„            CASE ELSE„                 Pan% = FALSE„        END SELECT„        IF Pan% THEN PanDisplay x%, y% * 5„    LOOP UNTIL KeyStroke$ = Esc$„END„„'   Set display window co-ordinates -- [MAIN CODE!!]„'   Works on EGA, VGA, MCGA, no CGA„SUB PanDisplay (x%, y%) STATIC„    OUT &H3D4, 12: OUT &H3D5, y%            ' Scroll screen vertically„    OUT &H3D4, 13: OUT &H3D5, x%            ' Scroll screen horizontally„END SUB„Victor Yiu                     VERTICAL PAN DEMO              VERTICAL,PAN,DEMO              Unknown Date (00:00)   QB, QBasic, PDS        25   702      VERTPAN.BAS DEFINT A-Z„SCREEN 9: CLS„COLOR 4, 0„FOR X = 1 TO 24„LOCATE X, 1: PRINT STRING$(79, "X");„NEXT„CIRCLE (300, 200), 150, 14„PAINT (301, 201), 12, 14„SLEEP (4)„FOR I% = 0 TO 26480 STEP 80„REM M% stands for MSB and L%=LSB„M% = FIX(I% / 256): L% = I% - (M% * 256)„OUT &H3D4, 12: OUT &H3D5, M%: OUT &H3D4, 13: OUT &H3D5, L%„WAIT &H3DA, 8 'Wait for vertical retrace„FOR D = 0 TO 100: NEXT: 'Adjust for different scroll speed„NEXT„FOR I% = 26480 TO 0 STEP -80„M% = FIX(I% / 256): L% = I% - (M% * 256)„OUT &H3D4, 12: OUT &H3D5, M%: OUT &H3D4, 13: OUT &H3D5, L%„WAIT &H3DA, 8: 'waits for vertical retrace„FOR DELAY = 0 TO 100: NEXT: 'Adjust for different scroll speed„NEXT„SLEEP (1)„RUN„„Greg Turgeon                   LOAD 16 COLOR PCX              comp.lang.basic.misc           Unknown Date           PB                     391  11537    LOADPCX.BAS '                    Contains LoadPCX16, a 16 color PCX image file„'                        loader for VGA graphics mode 12h„'„'This file contains the following routines:„'„'SUB LoadPCX16(pcx$, Sline%, Col%)    16 color PCX file loader„'SUB LoadColorPCX16                   loads 16 color PCX data to VGA DAC regs„'„'IMPORTANT: LoadPCX16 calls the routine VideoOff to blank the screen„'while the PCX image is being loaded.  If you disable this feature,„'be sure to rem out both calls to VideoOff.„'„'ALSO IMPORTANT: LoadPCX16 allows an image smaller than full-screen„'(640 X 480) to be repositioned on screen.  However, instead of the„'coordinate system (X,Y), with X and Y identifying pixel positions,„'LoadPCX16 employs (Sline%, Col%) with Sline% identifying a vertical„'screen pixel position and Col% following the text mode convention„'(in this case 0-79) for horizontal positioning.  The routine performs„'error-checking for available repositioning space on-screen.„'„'As now written, the demo requires VGA.  LoadPCX16 calls the routine„'LoadColorPCX16, which employs BIOS calls available only on color VGA„'hardware.  Error checking for repositioning also assumes VGA mode 12h„'(640 X 480) only.„'„'I first wrote LoadPCX16 in BASIC (PB 3.0c).  On my 386SX 16, loading the„'test file (a fairly complex image originally generated by FRACTINT)„'from a RAM drive took over 90 seconds.  The routine as presented here,„'converted almost entirely to assembly, loads the same image in 1.8 seconds.„'„'My thanks to Murray Moffatt for his patience and persistence while„'testing LoadPCX16.„'„'Greg Turgeon - CIS: 76470,2417„„$LIB GRAPH ON„$LIB VGA ON„DECLARE FUNCTION GetStrLoc&( BYVAL AllocHandle% ) 'must be declared„„DEFINT A - Z„%yes = -1: %no = 0„„'''create variable to load w/PCX file header data„TYPE PCXheader„  Mfg           AS BYTE„  Version       AS BYTE„  Encoding      AS BYTE„  BitsPerPixel  AS BYTE„  Xmin          AS INTEGER„  Ymin          AS INTEGER„  Xmax          AS INTEGER„  Ymax          AS INTEGER„  HorizontalRes AS INTEGER„  VerticalRes   AS INTEGER„  Pal           AS STRING * 48„  Reserved      AS BYTE„  NumColrPlanes AS BYTE„  BytesPerSLine AS INTEGER„  PalInfo       AS INTEGER„  Filler        AS STRING * 58„END TYPE„DIM PIX1 AS SHARED PCXheader„„'''use command$ to identify pix to load„pcx$ = UCASE$( COMMAND$ )„IF ISFALSE( LEN( DIR$( pcx$ ))) THEN„  PRINT: PRINT "Cannot find PCX file "; pcx$„  END„END IF„„CALL LoadPCX16( pcx$, Sline%, Col% )„END„„'===========================„SUB LoadPCX16( FileName$, BYVAL Sline%, BYVAL Col% )„  PCXfile = FREEFILE„  OPEN FileName$ FOR BINARY AS PCXfile„  DOShandle% = FILEATTR( PCXfile, 2 ) 'DOS handle needed for asm„  FileBytes& = LOF( PCXfile )„„'''load header into var & verify that PCX file is correct format„  get# PCXfile,, PIX1„  IF PIX1.Mfg < > 10 OR PIX1.Version < > 5 THEN 'Mfg 10 = ZSoft, Version 5 = 3.„    CLOSE PCXfile„    PRINT: PRINT "mfg: "; PIX1.mfg, "Version"; PIX1.Version„    PRINT "Incorrect PCX version"„    EXIT SUB„  END IF„„  PixWidth% = PIX1.Xmax - PIX1.Xmin„  PixHeight% = PIX1.Ymax - PIX1.Ymin„„  PRINT„  PRINT "Width: "; PixWidth%, "Height:"; PixHeight%„  PRINT "Encoding type:"; PIX1.Encoding„  PRINT "Bits per pixel per plane:"; PIX1.BitsPerPixel„  PRINT "Horizontal resolution of originating system:"; PIX1.HorizontalRes;„  PRINT "  Vertical resolution:"; PIX1.VerticalRes„  PRINT "Number of color planes:"; PIX1.NumColrPlanes„  PRINT "Number of bytes per scan line per plane:"; PIX1.BytesPerSLine„  PRINT "Palette info (color/bw = 1, grayscale = 2):"; PIX1.PalInfo„  PRINT "File size: "; FileBytes&; " bytes"„„  SLEEP„  SCREEN 12„„'''error checking: don't reposition image unless there's room„  MaxX% = 639: MaxY% = 479„  IF Sline% > ( MaxY% - PixHeight% ) - 2 THEN Sline% = 0„  IF Col% > (( MaxX% - PixWidth% ) \ 8 ) THEN Col% = 0„„  PixBPerLine% = PIX1.BytesPerSLine 'create for asm„  CALL LoadColorPCX16 'load PIX1.Pal colors„  SEEK PCXfile, 128 'start of screen data„„  ChunkSize% = FRE( t$ ) 'create largest buffer possible„  FileBuffer$ = STRING$( ChunkSize%, 0 ) '(reduce size to smooth out display if„„  ! push WORD ptr FileBuffer$„  ! CALL getstrloc; now dx: ax = LOC, cx = length„  ! mov FBytesSeg??, dx; SAVE SEG & addr of FileBuffer$„  ! mov FBytesPtr??, ax„'''establish offset if repositioning image„  ! mov ax, Sline%„  ! mov dx, 80„  ! mul dx„  ! add ax, Col%„  ! mov Mover??, ax„'''determine how many bytes per line for the current video mode„'''bytes per line will = screen column figure in BIOS data area„  ! xor bx, bx„  ! mov es, bx„  ! mov bx, &h44A„  ! mov ax, es: [bx]„  ! mov BPerLine%, ax„  ! CALL LoadChunk        ; load FileBuffer$„  ! mov ScreenLine%, -1   ; start AT - 1 TO allow FOR inc TO 0„'''begin loading pix to screen„NewLine:„  ! inc ScreenLine%„  ! mov dx, ScreenLine%„  ! cmp dx, PixHeight%    ; IF ScreenLine% > PixHeight%, THEN PixDone„  ! jle LineOK„  ! jmp PixDone„LineOK:„  ! mov ax, BPerLine%     ; Addr?? = BPerLine% * ScreenLine%„  ! imul dx„  ! mov di, ax            ; di = target SCREEN address FOR loading„  ! add ax, PixBPerLine%  ; LineEnd?? = Addr?? + PixBPerLine%( PIX1.BytesPerSLi„  ! mov LineEnd??, ax„'''si = ptr to position in FileBuffer$, Plane% = target video plane„  ! mov Plane%, 0         ; begin each LINE w / plane 0„  ! CALL SelectPlane„NewByte:„  ! cmp Plane%, 3         ; done WITH ALL 3 planes?„  ! ja NewLine            ; IF yes„  ! CALL GetNextByte      ; IF no, load a BYTE into al FROM FileBuffer$„  ! mov ah, al            ; make a copy of NextByte?„  ! AND al, 192           ; IF top 2 BITS NOT set, THEN load the one BYTE„  ! cmp al, 192           ; IF set, THEN it 's a repeater, so load the„  ! je RepByte            ; bytes AND assume continuing ON same LINE„  ! mov al, ah            ; RESTORE al = NextByte?, AND load BYTE„  ! push di               ; SAVE di( stosb increases di )„  ! mov dx, &h0A000       ; BASE video SEG„  ! add di, Mover??       ; add ANY repositioning value„  ! stosb                 ; load the BYTE TO SCREEN„  ! pop di„  ! inc di                ; update position FOR loading„„  ! mov ax, LineEnd??     ; check: AT the END of a SCREEN line?„  ! cmp ax, di„  ! ja NewByte            ; IF no„  ! mov ax, ScreenLine%   ; IF yes, THEN move back TO„  ! mov bx, BPerLine%     ;„  ! imul bx               ; start of LINE AND switch„  ! mov di, ax            ;„  ! inc Plane%            ; TO NEXT video plane„  ! CALL SelectPlane„  ! jmp NewByte„RepByte:„'''coming in, ah = NextByte?„  ! mov al, ah            ; RESTORE al = NextByte?„  ! AND al, 63            ; CLEAR BITS 6&7 TO leave the„  ! mov cl, al            ; number of times TO REPEAT„  ! xor ch, ch„  ! CALL GetNextByte      ; load the COLOR BYTE into al„DoTheReps:„  ! push di„  ! mov dx, &h0A000„  ! mov es, dx            ; di already = address„  ! add di, Mover??       ; add ANY repositioning value„  ! stosb; load TO video„  ! pop di„„  ! inc di„  ! cmp di, LineEnd??     ; AT END of line?„  ! je NextPlane          ; IF yes, GOSUB NextPlane„DoNextRep:„  ! LOOP DoTheReps        ; IF no„  ! jmp NewByte„NextPlane:„  ! push ax„  ! push dx„  ! mov ax, ScreenLine%   ; move back TO start of LINE„  ! mov dx, BPerLine%     ; AND„  ! imul dx               ; move TO NEXT video plane„  ! mov di, ax„  ! inc Plane%„  ! pop dx„  ! pop ax„  ! CALL SelectPlane„  ! jmp DoNextRep„PixDone:„'''reset all planes„  ! mov ax, &h0F02„  ! mov dx, &h3C4„  ! OUT dx, ax„„  CLOSE PCXfile„„  SLEEP„„  SCREEN 0„  EXIT SUB„GetNextByte:„'''don't push ax; it sends back NextByte?„  ! push bx„  ! push cx„  ! push es„„  ! mov es, FBytesSeg??„  ! mov bx, FBytesPtr??„  ! add bx, si; si = FileBuffer$ BYTE ptr, so bx now - > NextByte?„  ! mov al, BYTE ptr es: [bx]; now al = NextByte?„„  ! inc si; increase FileBuffer$ ptr„  ! dec BuffPtr%; decrease ptr FOR countdown„  ! jnz ChunkNotDone; IF more IN FileBuffer$„  ! CALL LoadChunk; IF empty, THEN GET more„ChunkNotDone:„  ! pop es„  ! pop cx„  ! pop bx„  ! retn„LoadChunk:„  ! push ax„  ! push bx„  ! push cx„  ! push dx„  ! push ds„'if FileBytes& =< ChunkSize% then ChunkSize% = FileBytes&„  ! mov ax, FileBytes&[00]„  ! mov dx, FileBytes&[02]„  ! cmp dx, 0            ; IF dx < > 0 THEN FileBytes& must„  ! jg SameSize          ; be > ChunkSize%„  ! cmp ax, ChunkSize%„  ! jle SameSize         ; IF FileBytes& < ChunkSize%, THEN make„  ! mov ChunkSize%, ax   ; ChunkSize% = FileBytes& FOR final pass„SameSize:„  ! mov bx, FBytesSeg??„  ! mov ds, bx„  ! mov dx, FBytesPtr??„  ! mov bx, DOShandle%„  ! mov cx, ChunkSize%„  ! mov ah, &h3F; reload FileBuffer$„  ! INT &h21„  ! jnc ReCalc„ErrorHandler:„  ! mov ChunkSize%, ax„  ! pop ds„  ! pop dx„  ! pop cx„  ! pop bx„  ! pop ax„  CLOSE„  LOCATE 1, 1„  IF ISTRUE( ChunkSize% ) THEN„    SOUND 800, .5: PRINT "Error: "; ChunkSize%„  END IF„  getkey„  SCREEN 0„  END„ReCalc:„  ! mov ax, FileBytes&[00]  ; recalculate size of remaining FileBytes&„  ! mov dx, FileBytes&[02]„  ! mov bx, ChunkSize%      ; subtract portion already loaded TO SCREEN„  ! SUB ax, bx„  ! sbb dx, 0„  ! mov FileBytes&[02], dx„  ! mov FileBytes&[00], ax„  ! xor si, si              ; si = FileBuffer$ ptr FOR loading; start AT 0„  ! mov ax, ChunkSize%„  ! mov BuffPtr%, ax        ; ptr FOR countdown„„  ! pop ds„  ! pop dx„  ! pop cx„  ! pop bx„  ! pop ax„  ! retn„SelectPlane:„  ! push ax„  ! push bx„  ! push cx„  ! push dx„„  ! mov ax, 1; determine 2 ^ plane„  ! cbw„  ! mov cx, Plane%„  ! shl ax, cl„  ! mov ah, al; ah now = plane desired„  ! mov dx, &h3C4; plane SELECT„  ! mov al, 2„  ! OUT dx, ax„„  ! pop dx„  ! pop cx„  ! pop bx„  ! pop ax„  ! retn„END SUB„„'===========================„SUB LoadColorPCX16„  NumBytes?? = LEN( PIX1.Pal )„  Addr1?? = VARPTR( PIX1.Pal )„'''palette regs actually index -> DAC regs„'''build array of the DAC regs to which palette regs (0-15) are indexed„  REDIM temp?( 0: 15 )„  RESTORE DefaultDACregs„  FOR a? = 0 TO 15: READ temp?( a? ): NEXT a?„    DACValSeg?? = VARSEG( temp?( 0 )): DACValPtr?? = VARPTR( temp?( 0 ))„'''reduce PCX 0-255 color values to 0-63„    ! push ax„    ! push bx„    ! push cx„    ! push dx„    ! push es„    ! push si„    ! push di; make both ds: si & es: di - > PIX1.Pal„„    ! mov ax, ds; ALL fixed length strings are IN ds„    ! mov es, ax„    ! mov ax, Addr1??„    ! mov si, ax„    ! mov di, ax„    ! mov cx, NumBytes??„    ! cld; increment„Reducer:„    ! lodsb„    ! shr al, 1; \ 4 TO reduce„    ! shr al, 1„    ! stosb„    ! LOOP Reducer„'''load each DAC reg„    ! mov si, Addr1??; now ds: [si] = PIX1.Pal„    ! mov es, DACValSeg??„    ! mov di, DACValPtr??; es: [di] = temp%( 0 )„    ! mov cx, 16„    ! mov ax, &h1010„    ! xor bx, bx„LoadRegs:„    ! push cx„    ! mov bl, BYTE ptr es: [di]; pal REG„    ! mov dh, BYTE ptr ds: [si]; red„    ! inc si„    ! mov ch, BYTE ptr ds: [si]; green„    ! inc si„    ! mov cl, BYTE ptr ds: [si]; blue„    ! inc si„„    ! push bp„    ! INT &h10„    ! pop bp„„    ! pop cx„    ! inc di; NEXT pal REG„    ! LOOP LoadRegs„„    ! pop di„    ! pop si„    ! pop es„    ! pop dx„    ! pop cx„    ! pop bx„    ! pop ax„    ERASE temp?„    EXIT SUB„DefaultDACregs:„    DATA 0, 1, 2, 3, 4, 5, 20, 7, 56, 57, 58, 59, 60, 61, 62, 63„END SUB„Duane Jahnke                   256 COLORS IN SCREEN 12        256,COLORS,SCREEN,12           06-14-92 (14:32)       QB, QBasic, PDS        125  3939     COLR256K.BAS'NOTE: VGA required to run this program.„„'This program demonstrates how to calculate and display the 256k colors„'available in SCREEN 12.  The formula used below looks kind of cryptic„'at first, but it will begin to make sense after you think about„'how colors work.„„'There are 3 basic colors: red, green, and blue.„'In SCREEN 12, each of these colors has an intensity range of 0 to 63„'That gives a total of 64 shades for each one.„'Therefore, 64 * 64 * 64 = 262144 (256k) possible colors.„'Sounds good, well the down side is that BASIC can only display„'16 of them at one time, oh-well.„'Red's palette begins at 0„'Green's palette begins at 256„'Blue's palette begins at 65536„'Therefore, the palette formula is:„'       PalColor& = (65536 * blue%) + (256 * green%) + red%„„'Enough of that, run this and see what you think.„„'--------------------------------------------------------------------------„ON ERROR GOTO ETrap     'set an error trap„SCREEN 12       'set the screen mode„PALETTE 1, 0    'assign black to color attribute #1 to use as the default„„w% = 100: x% = 50         'set the viewport boundry coordinate var's„y% = 540: z% = 300„VIEW SCREEN (w%, x%)-(y%, z%), 0, 15    'define a viewport w/ border„LINE (w%, x%)-(y%, z%), 1, BF           'draw a box, fill w/ color 1„„COLOR 15        'put options on the screen„LOCATE 3, 14: PRINT "PALETTE VALUE:"„LOCATE 21, 14: PRINT "R = More red                         Red intensity:"„LOCATE 22, 14: PRINT "r = Less red"„LOCATE 24, 14: PRINT "G = More green                     Green intensity:"„LOCATE 25, 14: PRINT "g = Less green"„LOCATE 27, 14: PRINT "B = More blue                       Blue intensity:"„LOCATE 28, 14: PRINT "b = Less blue"„LOCATE 30, 35: PRINT "Esc = Quit";„„DO  'loop here and update the palette and data w/ each key hit„„    a& = (65536 * blue%) + (256 * green%) + red%   'calc the new palette„„    PALETTE 1, a&   'display the new palette„„    LOCATE 3, 28: PRINT a&; "     "   'update the screen data„    LOCATE 21, 65: PRINT red%„    LOCATE 24, 65: PRINT green%„    LOCATE 27, 65: PRINT blue%„„    DO: k$ = INKEY$      'wait for a user key„    LOOP WHILE k$ = ""„„    SELECT CASE k$       'process the key„        CASE "R"„            IF red% < 63 THEN        'increment red intensity„                red% = red% + 1„            ELSE„                SOUND 200, .1„            END IF„„        CASE "r"„            IF red% > 0 THEN         'decrement red intensity„                red% = red% - 1„            ELSE„                SOUND 200, .1„            END IF„„        CASE "G"„            IF green% < 63 THEN      'increment green intensity„                green% = green% + 1„            ELSE„                SOUND 200, .1„            END IF„„        CASE "g"„            IF green% > 0 THEN       'decrement green intensity„                green% = green% - 1„            ELSE„                SOUND 200, .1„            END IF„„        CASE "B"„            IF blue% < 63 THEN       'increment blue intensity„                blue% = blue% + 1„            ELSE„                SOUND 200, .1„            END IF„„        CASE "b"„            IF blue% > 0 THEN        'decrement blue intensity„                blue% = blue% - 1„            ELSE„                SOUND 200, .1„            END IF„       „        CASE CHR$(27)„„        CASE ELSE„            SOUND 200, .1„„    END SELECT„LOOP UNTIL k$ = CHR$(27)    'exit if escape is hit„„VIEW        'close the viewport„CLS„PALETTE     'reset the palette to default„SCREEN 0„„'print the final palette data„PRINT "FINAL PALETTE VALUE   :"; a&„PRINT "RED INTENSITY         :"; red%„PRINT "GREEN INTENSITY       :"; green%„PRINT "BLUE INTENSITY        :"; blue%„„Done:„END„„ETrap:„    CLS     'display the error code and exit program„    PRINT "BASIC RUNTIME ERROR #"; ERR„RESUME Done„„