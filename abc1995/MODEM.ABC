Bryan Leggo                    XMODEM TRANSFER PROTOCOL       XMODEM,TRANSFER,PROTOCOL       Unknown Date (00:00)   QB, PDS                718  31867    XMODEM.BAS  „'  +-------------------------------------------------------------------+„'  |                                                                   |„'  |   XMODEM.BAS                                Author: Bryan Leggo   |„'  |                                                                   |„'  |   Original XModem, XModem-CRC, and XModem-1K Transfer Protocols   |„'  |                                                                   |„'  |   Uses standard QuickLibrary for "FileExists" function. Use /L    |„'  |   for QB.QLB in environment or the .LIB while compiling.          |„'  |                                                                   |„'  +-------------------------------------------------------------------+„„DECLARE FUNCTION CalcCheckSum% (Blk$)„DECLARE FUNCTION CalcCRC& (X$, CRCHigh%, CRCLow%)„DECLARE FUNCTION FileExists% (T$, Attrib%)„DECLARE FUNCTION NoCarrier% ()„DECLARE FUNCTION TimedGet$ (Limit&, Cancelled%)„DECLARE FUNCTION Warn$ (Message$)„DECLARE SUB ClrLn (Ln%, Spaces%)„DECLARE SUB OpenCom (ComChan%, Param$)„DECLARE SUB PurgeBuffer ()„DECLARE SUB ReceiveXModem (BlkSize%, F$)„DECLARE SUB SendXModem (BlkSize%, F$)„DECLARE SUB SimpleTerminal ()„DECLARE SUB Txt (Side$, T$)„DECLARE SUB Transfer (WhichWay$)„DECLARE SUB VidBar (BarOn%, Col%, Length%)„„TYPE RegTypeX                                   'Register Type for„   ax    AS INTEGER                             ' Interrupt Calls„   bx    AS INTEGER„   cx    AS INTEGER                             'AX = AH AL„   dx    AS INTEGER                             'BX = BH BL, etc.„   bp    AS INTEGER„   si    AS INTEGER„   di    AS INTEGER„   Flags AS INTEGER„   ds    AS INTEGER„   es    AS INTEGER„END TYPE„„CONST TRUE = -1, FALSE = 0                      'Boolean Constants„„DEFINT A-Z„„DIM SHARED CR$, LF$, BS$, Escape$               'Global String Constants„DIM SHARED Lft$, Rght$, Up$, Down$„DIM SHARED PgUp$, PgDown$„DIM SHARED XOn$, XOff$„DIM SHARED Ack$, Nak$, Soh$, Stx$, Eot$, Can$   'Protocol Pseudo-Constants„DIM SHARED ComBase, Baud&„DIM SHARED Txt1st, TxtMax                       'Used by Txt Sub„DIM SHARED Kolor, BGKolor                       'Screen Colors„DIM SHARED ErrCode, ErrCt                       'Error Number & Count„„'===========================================================================„'                  I N I T I A L I Z E     V A R I A B L E S„'===========================================================================„„CR$ = CHR$(13): LF$ = CHR$(10): BS$ = CHR$(8): Escape$ = CHR$(27)„Up$ = CHR$(0) + CHR$(72): Down$ = CHR$(0) + CHR$(80)„Lft$ = CHR$(0) + CHR$(75): Rght$ = CHR$(0) + CHR$(77)„PgUp$ = CHR$(0) + CHR$(73): PgDown$ = CHR$(0) + CHR$(81)„XOn$ = CHR$(17): XOff$ = CHR$(19): Ack$ = CHR$(6): Nak$ = CHR$(21)„Soh$ = CHR$(1): Stx$ = CHR$(2): Eot$ = CHR$(4): Can$ = CHR$(24)„„Baud& = 2400                                       'Set the BaudRate„Param$ = STR$(Baud&) + ",N,8,1,RS,OP,CD0,DS0"      ' and Com Parameters„„„'===========================================================================„'                         M A I N     P R O G R A M„'===========================================================================„„OpenCom 1, Param$                               'Open Port 1 with Parameters$„SimpleTerminal                                  'Terminal Mode„END„„„'***************************************************************************„'                        E R R O R     H A N D L E R„'***************************************************************************„„Handler:„ErrCode = ERR                               'Copy Err # to Global Var„ErrCt = ErrCt + 1                           'Try Statement Causing the Error„IF ErrCt MOD 3 = 0 THEN                     ' Twice Before Giving Up and„   RESUME NEXT: ErrCt = 0                   ' Going to the Next Statement„ELSE„   RESUME„END IF„„FUNCTION CalcCheckSum (Blk$)                'Returns CheckSum on Blk$„„C& = 0                                      'Use Long Int to Avoid Overflow„FOR Q = 1 TO LEN(Blk$)„   C& = C& + ASC(MID$(Blk$, Q, 1))          'Add to Add Bits of Each Byte„NEXT Q„C& = (C& AND 255)                           'AND Out Hi Byte Bits„CalcCheckSum = C&„END FUNCTION„„FUNCTION CalcCRC& (B$, CRCHigh%, CRCLow%)      'Calculates CRC for Each Block„„DIM Power(0 TO 7)                              'For the 8 Powers of 2„DIM CRC AS LONG„„FOR I = 0 TO 7                                 'Calculate Once Per Block to„   Power(I) = 2 ^ I                            ' Increase Speed Within FOR J„NEXT I                                         ' Loop„CRC = 0                                        'Reset for Each Text Block„FOR I = 1 TO LEN(B$)                           'Calculate for Length of Block„   ByteVal = ASC(MID$(B$, I, 1))„   FOR J = 7 TO 0 STEP -1„      TestBit = ((CRC AND 32768) = 32768) XOR ((ByteVal AND Power(J)) = Power(JCRC = ((CRC AND 32767&) * 2&)))„      IF TestBit THEN CRC = CRC XOR &H1021&     ' <-- This for 16 Bit CRC„      '*** IF TestBit THEN CRC = CRC XOR &H8005&     ' <-- This for 32 Bit CRC„   NEXT J„NEXT I„CRCHigh% = (CRC \ 256)                          'Break Word Down into Bytes„CRCLow% = (CRC MOD 256)                         ' for Comparison Later„ComputeCRC& = CRC                               'Return the Word Value„END FUNCTION„„REM $DYNAMIC„SUB ClrLn (Ln, Spaces)                       'Clears Line from Left Side„LOCATE Ln, 1, 0: PRINT SPACE$(Spaces);       ' for Number of Designated„LOCATE Ln, 1                                 ' Spaces. Returns Cursor to„END SUB                                      ' to First Column Afterwards„„FUNCTION FileExists (T$, Attrib)     'True if File T$ Exists else False„„DIM F AS STRING * 64„DIM Inx AS RegTypeX„DIM Outx AS RegTypeX„„Inx.ax = &H2F00                      'Function 2FH Gets the DTA Address in„CALL INTERRUPTX(&H21, Inx, Outx)     ' ES:BX„DTASeg = Outx.es„DTAAddr = Outx.bx„F$ = LTRIM$(RTRIM$(UCASE$(T$))) + CHR$(0)„„Inx.ds = VARSEG(F$)                  'Pass the File Specs by Giving Address„Inx.dx = VARPTR(F$)                  ' of String that Contains Specification„Inx.ax = &H4E00                      'Function 4EH for Find 1st Matching Entry„Inx.cx = Attrib                      'CX = Directory Attribute (0=Files Only)„CALL INTERRUPTX(&H21, Inx, Outx)     'Use Interrupt 21H„IF Outx.Flags AND 1 THEN„   FileExists = FALSE„ELSE„   FileExists = TRUE„END IF„„END FUNCTION„„FUNCTION NoCarrier„„DEF SEG = &H40„IF (INP(ComBase + 6) AND 128) = 0 THEN NoCarrier = TRUE ELSE NoCarrier = FALSE„DEF SEG„„END FUNCTION„„REM $STATIC„SUB OpenCom (ComChan, Param$)„„CLOSE 1„SELECT CASE ComChan                   'Will Require Swapping at &H400, &H402„CASE 1                                ' Order to Support Com 3 and 4„   ComBase = &H3F8„   OPEN "R", 1, "COM1:" + Param$„CASE 2„   ComBase = &H2F8„   OPEN "R", 1, "COM2:" + Param$„END SELECT„„END SUB„„SUB PurgeBuffer                                    'Clear Comm Line of Chars„„Mark& = TIMER                                      'Mark Starting Time„DO„   IF NOT EOF(1) THEN                              'Get More Chars While Some„      JunkIt$ = INPUT$(1, 1): Mark& = TIMER        ' In the Buffer and it's„   END IF                                          ' Less Than 1/2 Second„LOOP UNTIL EOF(1) AND (ABS(TIMER - Mark&) > .5)    ' Since Last Char Gotten„END SUB„„SUB ReceiveXModem (BlkSize, F$)                 '(Block Size and Filename)„DIM B$(1 TO 4)                                  'Temp Storage of Block Bytes„„CLOSE 9: OPEN "O", #9, F$                       'Save File to Channel #9„PRINT #1, XOff$; XOn$;„Cancels$ = STRING$(3, Can$)„Underway = FALSE                                'True After 1st Pkt Confirmed„Blocks = 1                                      'Block/Pkt Counter (1-Max)„BlkNum = 1                                      'Packet Block Number (1-255)„Bad = 0                                         'Bad Packets/Error Count„BCt = 0                                         'RAM Block Ptr for B$()„PurgeBuffer                                     'Get Rid of Extra Chars„CrcMode = TRUE: PktSize = BlkSize + 5           'Try CRC Mode First„PRINT #1, "C";                                  'Send "C" to Signal It„„„GetPacket:                                      'Get Packet of Bytes„'IF NoCarrier THEN ErrType = 13: GOTO ShowErr    'Are We Still Online?„Pkt$ = ""„FOR Tries = 1 TO 10                             'Allow 10 Tries„   W$ = TimedGet$(8, Cancelled)                 'Get Response/1st Char of Pkt„   IF Cancelled THEN ErrType = 11: GOTO ShowErr 'Quit If User Cancelled„   SELECT CASE W$                               '1st Byte Is:„   CASE Soh$: BlkSize = 128: EXIT FOR           'Soh = 128 Byte Block Coming„   CASE Stx$: BlkSize = 1024: EXIT FOR          'Stx = 1K Block Coming„   CASE Eot$: GOTO ReceptionDone                'End of Xmission. Close Out.„   CASE Can$: EXIT FOR                          'Cancelled by Sender„   CASE ""                                      'No Char In Means Timed Out„      Bad = Bad + 1: LOCATE 7, 40„      PRINT "Tries:"; Tries; TAB(80);„   CASE ELSE                                    'Else Didn't Get An Expected„      PurgeBuffer                               ' Response So Purge Characters„   END SELECT„   IF NOT Underway THEN                         'Handshaking Not Complete Yet„      IF Tries < 4 THEN                         ' So Send Out Init Char Again„         CrcMode = TRUE: PRINT #1, "C";         ' Send a "C" to Start CRC or„      ELSE                                      ' a <Nak> for Standard Mode„         CrcMode = FALSE: PRINT #1, Nak$;„      END IF„   END IF„   IF Bad >= 10 THEN                            'Have Reached the Max of 10„      ErrType = 14: PurgeBuffer: GOTO ShowErr   ' Errors from TimeOuts or„   END IF                                       ' Bad Packets so Abort„NEXT Tries„IF CrcMode THEN                                 'Blk Size Determined by <Soh>„   PktSize = BlkSize + 5                        ' or <Stx>, PacketSize by„ELSE                                            ' BlockSize and Type of Check„   PktSize = BlkSize + 4                        ' Used (1 Extra Byte for CRC)„END IF„Pkt$ = W$                                       'We've Got the First Byte„WHILE LEN(Pkt$) <= PktSize - 1                  'Now Get Rest of Packet„   W$ = TimedGet$(4, Cancelled)„   IF Cancelled THEN ErrType = 11: GOTO ShowErr„   IF LEN(W$) THEN                              'If There is a Byte then Add„      Pkt$ = Pkt$ + W$                          ' it to the Packet„      IF LEFT$(Pkt$, 3) = Cancels$ THEN         'Packet Starting with Three„         PRINT #1, Cancels$; Ack$;              ' <Can>s Is a Cancellation So„         ErrType = 12: GOTO ShowErr             ' <Ack>nowledge And Abort„      END IF„   ELSE                                         'Else Null Means We Timed Out„      Bad = Bad + 1„      LOCATE 7, 40: PRINT TAB(80);„      LOCATE 7, 40: PRINT "Character Timeout. Errors:"; Bad;„      GOTO CheckPacket„   END IF„WEND„„CheckPacket:                                              'Check Packet Errors„IF LEN(Pkt$) = PktSize THEN                               'If Packet Right Size„  IF BlkNum = ASC(MID$(Pkt$, 2, 1)) + 1 AND (BlkNum XOR 255) = ASC(MID$(Pkt$, ErrType = 7)) THEN GOTO ShowErr                          'Repeated Block #„    ELSEIF BlkNum <> ASC(MID$(Pkt$, 2, 1)) THEN            'Block Counts Don't„      ErrType = 5: GOTO ShowErr                           ' Match. Try New Pkt„    ELSEIF (BlkNum XOR 255) <> ASC(MID$(Pkt$, 3, 1)) THEN  'Block Ct Complement„      ErrType = 6: GOTO ShowErr                           ' Mismatch. Try New„  END IF                                                 ' Packet„  Blk$ = MID$(Pkt$, 4, BlkSize)                          'Else Copy the Block„  IF CrcMode THEN                                        'Do CheckSum or CRC„    J& = CalcCRC&(Blk$, Hi, Low)„    IF Hi <> ASC(MID$(Pkt$, PktSize - 1, 1)) THEN ErrType = 4: GOTO ShowErr„    IF Low <> ASC(MID$(Pkt$, PktSize, 1)) THEN ErrType = 4: GOTO ShowErr„  ELSE„    ChkSum = CalcCheckSum(Blk$)„    IF ChkSum <> ASC(MID$(Pkt$, PktSize, 1)) THEN ErrType = 3: GOTO ShowErr„  END IF„  GOSUB ShowProgress                             'Displays Xfer Status„  BlkNum = 255 AND (BlkNum + 1)                  'Success Thru All CheckPts„  Blocks = Blocks + 1: Bad = 0                   ' so Increment Block Cts„  Underway = TRUE                                ' Mark Handshake Completed„  IF BlkSize = 1024 THEN                         'For Xmodem-1k Write to Disk„    PRINT #9, Blk$;                             ' Immediately„  ELSE„    BCt = BCt + 1: B$(BCt) = Blk$               'Else Save 4 Blocks In RAM„    IF BCt = 4 THEN                             ' Write them to Disk Every„      PRINT #9, B$(1); B$(2); B$(3); B$(4);    ' 4th, i.e. After 512 Bytes„      BCt = 0                                  ' Reset RAM Block Index„    END IF„  END IF                                         'Acknowledge Good Block Read„  PRINT #1, Ack$;                                ' And Go to Get Next Packet„  GOTO GetPacket„IF LEN(Pkt$) < PktSize THEN ErrType = 1: GOTO ShowErr                      'Err and Get New Packet„IF LEN(Pkt$) > PktSize THEN„  ErrType = 2: GOTO ShowErr                      ' And Get New Packet„ELSE                                              'Else an Unexpected Error„  ErrType = 8: GOTO ShowErr                      ' So Warn and Try for New„END IF                                            ' Packet„                                                  ' Last 2 Should NOT Occur„„ReceptionDone:„IF BCt <> 0 THEN                                  'If Some Bytes Still In„   FOR I = 1 TO BCt: PRINT #9, B$(I); : NEXT I    ' Memory Then Write Them„END IF                                            ' to Disk„CLOSE 9: PRINT #1, Ack$;                          'Xmit Complete so Close„EXIT SUB                                          ' File and Send Final Ack„„„'---------------------------------------------------------------------------„„ShowErr:„Response$ = Nak$                                  'Send Nak After Most Errors„SELECT CASE ErrType„CASE 1: ErM$ = "Short Block in #" + STR$(Blocks)„CASE 2: ErM$ = "Long Block in #" + STR$(Blocks)„CASE 3: ErM$ = "Checksum Error in #" + STR$(Blocks)„CASE 4: ErM$ = "CRC Error in #" + STR$(Blocks)„CASE 5: ErM$ = "Block # Error in #" + STR$(Blocks)„CASE 6: ErM$ = "Complement Error in #" + STR$(Blocks)„CASE 7: ErM$ = "Block # Repeated in #" + STR$(Blocks - 1): Response$ = Ack$„CASE 8: ErM$ = "Unexpected Error!"„CASE 9:„CASE 10: ErM$ = "Transfer Cancelled"„CASE 11: ErM$ = "Transfer Aborted by User"„CASE 12: ErM$ = "Transfer Aborted by Sender"„CASE 13: ErM$ = "No Carrier"„CASE 14: ErM$ = "Maximum Errors. Transfer Aborted."„END SELECT„LOCATE 7, 40: PRINT TAB(80);                      'Show the ErrorMsg„LOCATE 7, 40: PRINT ErM$;„IF ErrType < 10 THEN                              'ErrType < 10 is Recoverable„   Bad = Bad + 1                                  ' Count One More Error„   PRINT #1, Response$;                           ' Respond Nak (or Ack) and„   Pkt$ = "": GOTO GetPacket                      ' Go to Get Packet Again„ELSE„   J$ = Warn$(ErM$)                               'Notify User of Cancel„   SLEEP 2: PurgeBuffer                           'Get Rid of Remaining Pkt„   PRINT #1, STRING$(5, 24); STRING$(5, 8);       'Send 5 <Can>s & 5 <BS>s„   CLOSE 9: KILL F$                               'ErrType >= 10 is Fatal so„   EXIT SUB                                       ' Kill Off File and Quit„END IF„„'---------------------------------------------------------------------------„„ShowProgress:                                     'Show Byte Counts & Bar„KBytes = INT(Blocks * (BlkSize / 1024))„LOCATE 5, 40: PRINT "Received #"; Blocks; TAB(60); KBytes; "K Bytes";„IF BarLength = 0 THEN„   LOCATE 9: VidBar FALSE, 1, 80„   FOR K = 1 TO 9„      LOCATE 10, K * 8 - 1„      PRINT LTRIM$(STR$(100 * (KBytes \ 100) + (K * 10))); "K ";„   NEXT K„END IF„BarLength = INT(80 * ((KBytes MOD 100) / 100))„LOCATE 9: VidBar TRUE, 1, BarLength„RETURN„„„„' Block refers to Block of Text from File (128 bytes, 1024 for Xmodem-1K)„' Packet Refers to Block + Extra "Control" Characters, i.e. :„„'       XModem: SOH + BlockCt + Complement BlockCt + Block + CheckSum„'    XModemCRC: SOH + BlockCt + Complement BlockCt + Block + CRC (Hi & Low)„'    XModem-1K: STX + BlockCt + Complement BlockCt + Block + CheckSum„' XModemCRC-1K: STX + BlockCt + Complement BlockCt + Block + CRC (Hi & Low)„„END SUB„„SUB SendXModem (BlkSize, F$)                              '(Bytes, FileName$)„„CLOSE 9: OPEN F$ FOR RANDOM AS 9 LEN = 128„FIELD #9, 128 AS BlkOf128$„FiLen& = LOF(9): TtlBlocks = FiLen& \ BlkSize             'Get File Length„IF FiLen& MOD BlkSize > 0 THEN TtlBlocks = TtlBlocks + 1  ' in Bytes & Blocks„LOCATE 3, 40: PRINT "Blocks:"; TtlBlocks; TAB(60);„Seconds = ((TtlBlocks * 6) + FiLen&) \ (Baud& \ 16)„Est$ = STR$(Seconds \ 3600) + STR$(Seconds \ 60) + STR$(Seconds MOD 60)„FOR I = 2 TO LEN(Est$)„   IF MID$(Est$, I, 1) = " " THEN MID$(Est$, I, 1) = ":"„NEXT I„PRINT "Est. Time:"; Est$;„„ErM$ = "Transfer Aborted"                        'Generic Msg In Case of Error„Blocks = 0: BlkNum = 0                           'Blocks (1-?), BlkNum (1-255)„EoFile = FALSE: W$ = ""                          'Initialize Block, Byte,„Ct& = 0                                          'To Count Bytes Used & Sent„Bad = 0                                          'Error Counter„PurgeBuffer                                      'Clear the Com Line„„DO                                               'Shake Hands with Receiver„   W$ = TimedGet$(20, Cancelled)                 'Get Initial Character„„   IF Cancelled THEN GOTO AbortSend              'If User Pressed <Esc>„   SELECT CASE W$„   CASE Can$: GOTO AbortSend                     'Receiver is Cancelling„   CASE Nak$: CrcMode = FALSE: EXIT DO           'Nak for Standard XModem„   CASE "C": CrcMode = TRUE: EXIT DO             'C Indicates XModem-CRC„   END SELECT                                    'Begin After <Nak> or C„LOOP„„MakePacket:„IF NoCarrier THEN                                    'Still Online?„   ErM$ = "No Carrier!": GOTO AbortSend„END IF„W$ = "": Blocks = Blocks + 1: Bad = 0                'Advance Block Counter„IF (BlkSize = 1024) AND ((Ct& + 896) > FiLen&) THEN  'If Doing 1k and at End„   BlkSize = 128                                     ' of File Then Shorten„END IF                                               ' to Avoid Extra Nulls„IF BlkSize = 128 THEN MaxBCt = 1 ELSE MaxBCt = 8     '8 Groups of 128 = 1024„BCt = 0: Blk$ = ""                                   'Build the Block$„DO„   Ct& = Ct& + 128: GET #9                           'Advance File Ptr, Get Fro„   BCt = BCt + 1: Blk$ = Blk$ + BlkOf128$„   IF Ct& >= FiLen& THEN                             'If It's Last Block We're„      EoFile = TRUE                                  ' About Done Xmitting„      Pad = Ct& - FiLen&                             ' Pad the End with Nulls„      MID$(Blk$, BlkSize - Pad, Pad) = STRING$(Pad, CHR$(0))„      EXIT DO„   END IF„LOOP UNTIL BCt = MaxBCt                              'Done After 1 (8 for 1k)„BlkNum = (255 AND Blocks)                            ' So Assemble the Packet„Pkt$ = Soh$ + CHR$(BlkNum) + CHR$(BlkNum XOR 255) + Blk$„IF BlkSize = 1024 THEN MID$(Pkt$, 1, 1) = Stx$       '1st Byte is Stx for 1K„IF CrcMode THEN                                      'End of Packet Varies„   J& = CalcCRC&(Blk$, Hi%, Low%)                    ' with Check Method Used„   Pkt$ = Pkt$ + CHR$(Hi%) + CHR$(Low%)              ' 2 Bytes for CRC„ELSE„   ChkSum = CalcCheckSum(Blk$)                       ' 1 Byte for CheckSum„   Pkt$ = Pkt$ + CHR$(ChkSum)„END IF„„SendPacket:„PRINT #1, Pkt$;                                      'Send the Packet and„LOCATE 5, 40: PRINT "Sending #"; Blocks;             ' Show Progress on Screen„P = INT((Blocks / TtlBlocks) * 100)                  'Calculate Percentage„IF P <= 100 THEN                                     'Percentage Can Be > 100„   LOCATE 5, 60: PRINT P; "% Complete": LOCATE 9     ' On Last Blocks of 1k„   VidBar TRUE, 1, INT((Blocks / TtlBlocks) * 80)    ' Mode Since Last 1024 is„END IF                                               ' Sent in 128 Byte Blocks„„DO                                                   'Packet Has Been Sent so„   W$ = TimedGet$(10, Cancelled)                     'Get Response/Confirm„   IF Cancelled THEN GOTO AbortSend                  'Quit If User <Esc>aped„   SELECT CASE W$                                    'Interpret Response„   CASE Ack$                                         'Block Acknowledged So„      Bad = 0                                        ' Send Next Packet If„      IF EoFile THEN EXIT DO ELSE GOTO MakePacket    ' More Data„   CASE ELSE                                         'Else„      Bad = Bad + 1                                  ' Count 1 More Error„      IF Bad > 9 THEN GOTO AbortSend                 ' Abort If Over Limit„      IF W$ = Can$ THEN                              'If a <Can> Then Look„         FOR I = 1 TO 2                              ' For at Least 2 More to„            W$ = W$ + TimedGet$(2, Cancelled)        ' Be Sure (Or User Esc)„            IF Cancelled THEN GOTO AbortSend„            IF W$ = STRING$(3, Can$) THEN GOTO AbortSend„         NEXT I„         GOTO SendPacket„      ELSE„         PurgeBuffer                                 'Any Other Char Is an„         GOTO SendPacket                             ' Error So ReSend Packet„      END IF                                         ' & Look for <Ack> Again„   END SELECT„LOOP„„ConcludeSend:„ErM$ = "End of Transmission": GOSUB ShowStatus       'Proper End of Transmit„CLOSE 9: PRINT #1, Eot$;                             'Close File, Send the EOT„I$ = TimedGet$(10, Cancelled)                        'Get Final Char„IF I$ = Ack$ THEN                                    'Should Be an <Ack> but„   ErM$ = "Acknowledged": GOSUB ShowStatus„ELSEIF Cancelled THEN                                'Allow User to Cancel„   EXIT SUB„ELSE                                                 'If Not an <Ack> Resend„   GOTO ConcludeSend                                 ' <Eot> and Try Again„END IF„EXIT SUB„„'---------------------------------------------------------------------------„„AbortSend:„J$ = Warn$(ErM$)                                 'Show Error Status„CLOSE 9                                          'Close File„PRINT #1, STRING$(5, Can$); STRING$(5, BS$);     'Send Cancel to Receiver„EXIT SUB„„'---------------------------------------------------------------------------„„ShowStatus:„LOCATE 7, 40: PRINT ErM$; TAB(80);               'Show the Status or ErrorMsg„RETURN„„END SUB„„SUB SimpleTerminal„ON ERROR GOTO Handler„FF$ = CHR$(12): Hm$ = CHR$(11)„„CLS : GOSUB InfoBar„PRINT #1, "AT S0=1"                       'Send Modem Initialization String„DO„   Out$ = INKEY$                          'Look for Key Press„   'IF LEN(Out$) THEN                      'If There IS One then Select„      SELECT CASE Out$„      CASE PgUp$, PgDown$                 ' to Upload or Download„         Transfer Out$: GOSUB InfoBar„      CASE Escape$                        ' Escape to End Program„         EXIT DO„      CASE CHR$(0) + CHR$(59)„         PRINT #1, "atdt 626-9456"„      CASE ELSE„         PRINT #1, Out$;                  ' Else Send the Character Verbatim„      END SELECT„   'END IF„   IF LOC(1) THEN                         'Is there Incoming Data from Com?„      DO                                  ' If So then Get Chars Until No„         ComChr$ = INPUT$(1, 1)           ' More or End of a Line <LF>„         SELECT CASE ComChr$„         CASE BS$: ComChr$ = CHR$(29)     'Replace BackSpaces with CHR$(29)„         CASE FF$, Hm$: ComChr$ = ""      'Filter these Out„         CASE LF$: ComChr$ = "": EXIT DO  'Ignore Linefeeds But Exit Do Loop„         END SELECT„         PRINT ComChr$;                   'Print the Char Received On Screen„      LOOP UNTIL LOC(1) = 0               'No More Com Waiting„   END IF„LOOP„EXIT SUB„„'---------------------------------------------------------------------------„„InfoBar:„CLS„LOCATE 24, 1: COLOR 0, 7„PRINT " <PgUp> to Upload,        <PgDown> to Download,         <Escape> to End Program ": COLOR 7, 0: LOCATE 24, 1„RETURN„„END SUB„„FUNCTION TimedGet$ (Limit&, Cancelled)            'Timed Routine to Get One„                                                  'Character from Comm Port„Mark& = TIMER                                     'Mark Starting Time„DO„   IF NOT EOF(1) THEN                             'If Chars Waiting Then„      TimedGet$ = INPUT$(1, 1): EXIT FUNCTION     ' Return 1 Character„   END IF„   IF INKEY$ = Escape$ THEN                       'User Can Press <Esc> to„      Cancelled = TRUE: EXIT FUNCTION             ' Quit„   END IF„LOOP WHILE ABS(TIMER - Mark&) < Limit&            'Wait Up Until Past Limit„TimedGet$ = ""                                    'Return "" If Timing Out„END FUNCTION„„REM $DYNAMIC„SUB Transfer (WhichWay$)                  'WhichWay = PgUp (U/L), PgDn (D/L)„ON ERROR GOTO Handler„„NumProtos = 4                             'Number of Protocols Here„SendDir$ = ""                             'Define Directories Where Files Will„RecvDir$ = ""                             ' Be DownLoaded To or Uploaded From„SendExternal$ = ""                        'DOS Command Line Used to Execute„RecvExternal$ = ""                        ' External Protocol (~ for Filename)„Kolor = 0: BGKolor = 7                    'Transfer Area in Reverse Video for„COLOR Kolor, BGKolor                      ' Contrast„VIEW PRINT 1 TO 11: CLS 2: VIEW PRINT     'Clear Top 11 Lines„LOCATE 11, 1: PRINT STRING$(80, "#");„„IF WhichWay$ = PgUp$ THEN                 'Determine if Sending or Receiving„   Way$ = "Sending": Sending = TRUE       ' From Key Pressed„ELSE„   Way$ = "Receiving": Sending = FALSE„END IF„DO„   ClrLn 9, 80: PRINT "File You Are "; Way$; ": ";„   F$ = "": LINE INPUT F$„   IF F$ = "" THEN GOTO ExitTransfer„   F$ = UCASE$(F$)„   IF Sending THEN„      IF LEN(SendDir$) THEN„         IF INSTR(F$, ":") = 0 THEN F$ = SendDir$ + "\" + F$„      END IF„      IF FileExists(F$, 0) THEN Ok = TRUE ELSE J$ = Warn$("File Not Found")„   ELSE„      IF LEN(ReceiveDir$) THEN„         IF INSTR(F$, ":") = 0 THEN F$ = ReceiveDir$ + "\" + F$„      END IF„      IF FileExists(F$, 0) THEN„         ClrLn 9, 80„         PRINT F$; " Already Exists! Overwrite it? (Y/N)? ";„         DO: B$ = UCASE$(INKEY$)„         LOOP UNTIL LEN(B$) AND INSTR("YN", B$)„         IF B$ = "Y" THEN Ok = TRUE„      ELSE„         ErrCode = 0: F = FREEFILE„         OPEN "O", F, F$„         IF ErrCode THEN J$ = Warn$("Bad Path/Filename?") ELSE Ok = TRUE„         CLOSE F„      END IF„   END IF„LOOP UNTIL Ok„„Txt1st = 1: TxtMax = 30                            'And Draw a Box Around„LOCATE 1, 1„PRINT TAB(40); "Choose a Protocol"; TAB(80);„Txt "T", ""„Txt "C", "       XModem       "„Txt "C", " XModem-1k (YModem) "„Txt "C", " External Protocol  "„Txt "C", "       Cancel       "„Txt "B", ""„R = 1: C = 0„DO„   LOCATE R + 1, 2, 0„   VidBar TRUE, 2, 30„   DO: C$ = INKEY$: LOOP UNTIL LEN(C$)„   VidBar FALSE, 2, 30„   SELECT CASE C$                                      'Based on Terminator:„   CASE Up$: R = R - 1: IF R < 1 THEN R = NumProtos    ' Go to Line Above„   CASE Down$: R = R + 1: IF R > NumProtos THEN R = 1  ' or Line Below„   CASE CR$: EXIT DO„   CASE Escape$: EXIT DO„   END SELECT„LOOP„IF C$ = Escape$ THEN GOTO ExitTransfer                 'Cancelled by User„VidBar TRUE, 2, 30„LOCATE 9, 1: PRINT "+--+---+---+---+---+---+---+---+---+---|---+---+---+---+---+---+---+---+---+---+"„LOCATE 1, 3: PRINT " Press <Escape> to Cancel "„LOCATE 1, 40: PRINT Way$; ": "; UCASE$(F$); TAB(80);„IF Sending THEN„   LOCATE 10, 1: PRINT "0%    10%     20%     30%     40%     50%     60%     70%     80%     90%   100%"„   SELECT CASE R„   CASE 1: SendXModem 128, F$„   CASE 2: SendXModem 1024, F$„   CASE 3: Ext$ = SendExternal$: GOSUB InsertFileName: SHELL Ext$„   CASE 4: GOTO ExitTransfer„   END SELECT„ELSE„   SELECT CASE R„   CASE 1: ReceiveXModem 128, F$„   CASE 2: ReceiveXModem 1024, F$„   CASE 3: Ext$ = RecvExternal$: GOSUB InsertFileName: SHELL Ext$„   CASE 4: GOTO ExitTransfer„   END SELECT„END IF„'PLAY "T90 O3 L32 CBCBCBCBCBCBCBCBCBCBCBCBCBCBCBC"     'All Done Warning Sound„„ExitTransfer:„COLOR 7, 0                                            'Back to White on Black„VIEW PRINT 1 TO 11: CLS 2: VIEW PRINT                 'Clear Top 11 Lines„VIEW PRINT 1 TO 24: LOCATE 24, 1, 1„EXIT SUB„„'----------------------------------------------------------------------------„„InsertFileName:                    'Substitute FileName for ~ in Strings Used„P = INSTR(Ext$, "~")               ' to Call External Protocol (Send or Recv)„IF P > 1 THEN„   Ext$ = LEFT$(Ext$, P - 1) + F$ + RIGHT$(Ext$, LEN(Ext$) - P)„END IF„RETURN„„END SUB„„REM $STATIC„SUB Txt (Side$, Text$)                  'Put 1 Line of Text w/ Box Delimiters„„IF LEN(Text$) > TxtMax THEN Text$ = LEFT$(Text$, TxtMax - 2)„SpaceLeft = (TxtMax - LEN(Text$)) \ 2„LOCATE , Txt1st„IF LEN(Text$) MOD 2 = 1 THEN Text$ = Text$ + " "„IF Side$ = LCASE$(Side$) THEN Shadow$ = ""„SELECT CASE UCASE$(Side$)„CASE "T"„   Text$ = "+" + STRING$(TxtMax, "-") + "+"                    'Top Border„   C = (TxtMax \ 2) - (LEN(T$) \ 2)„   MID$(Text$, C) = T$„CASE "B"„   Text$ = "+" + STRING$(TxtMax, "-") + "+"                    'Bottom Border„   C = (TxtMax \ 2) - (LEN(T$) \ 2)„   MID$(Text$, C) = T$„CASE "C"„   Text$ = "|" + STRING$(SpaceLeft, " ") + Text$ + STRING$(SpaceLeft, " ") + "|"„CASE "R"„   Text$ = "|" + STRING$(2 * SpaceLeft, " ") + Text$ + "|"     'Right-Justify„CASE "L"„   Text$ = "|" + Text$ + STRING$(2 * SpaceLeft, " ") + "|"     'Left-Justify„END SELECT„„PRINT Text$; Shadow$;                                   'Print Text, DeLimits„IF CSRLIN < 24 THEN PRINT                               'Go to Next Line„IF (Side$ = "B") AND LEN(Shadow$) THEN„   IF CSRLIN = 24 THEN LOCATE 25„   LOCATE , Txt1st„   PRINT " "; STRING$(TxtMax + 1, Shadow$); Shadow$;„   Shadow$ = ""„END IF„END SUB„„SUB VidBar (BarOn, Col, Length)„„113 LOCATE , Col                        'Position at Paramter Column„IF BarOn THEN                           'IF Hilighting (BarOn = True) then„   COLOR BGKolor, Kolor                 ' Use the BGKolor in the FG„   FOR J = Col TO Col + Length - 1      'Across the Screen for the "Length"„      PRINT CHR$(SCREEN(CSRLIN, J));    ' Re-Print the Char That is Already„   NEXT J                               ' There in It's New Colors„ELSE„   COLOR Kolor, BGKolor                 'ELSE De-HiLiting So Return Colors„   FOR J = Col TO Col + Length - 1      ' to Normal and Re-Print each Char„      PRINT CHR$(SCREEN(CSRLIN, J));    ' in the Row with the Regular Video„   NEXT J„END IF„LOCATE , Col                            'Return to 1st Column„COLOR Kolor, BGKolor                    ' and Normal Colors„END SUB„„FUNCTION Warn$ (Warning$)„LOCATE 1, 40: COLOR 20„PRINT " "; Warning$; TAB(80);„COLOR Kolor, BGKolor„'BEEP: BEEP„END FUNCTION„„The ABC Programmer             ACCESSING COM 3/4              ACCESSING,COM3,COM4            05/02/95 (00:00)       QB, QBasic, PDS        44   1296     COM3COM4.BAS'Port Addresses: COM1  --  03F8h„'                COM2  --  02F8h„'                COM3  --  03E8h„'                COM4  --  02E8h„„'EXAMPLE: Accessing COM3„„   DEF SEG = 64       'move QuickBASIC segment pointer to BIOS data area„   POKE &H0, &HE8     'change com1: address in BIOS data area to com3:„   DEF SEG            'return to QB's DGROUP„„   'open com3: by issuing open "com1:" command„„   OPEN "COM1:9600,N,8,1" FOR OUTPUT AS #1„„„   PRINT #1, "ATDT555-5555"  'print to comm port„        „   CLOSE #1           'close comm port„„   DEF SEG = 64       'point to BIOS data area„   POKE &H0, &HF8     'restore "com1:" address in BIOS data area to com1:„   DEF SEG            'return to DGROUP„„„'EXAMPLE: Accessing COM4„„   DEF SEG = 64       'move QuickBASIC segment pointer to BIOS data area„   POKE &H2, &HE8     'change com2: address in BIOS data area to com4:„   DEF SEG            'return to DGROUP„„'open com4: by issuing open com2: command„„   OPEN "COM2:9600,N,8,1" FOR OUTPUT AS #1„„„   PRINT #1, "ATDT555-5555"  'print to comm port„„   CLOSE #1           'close comm port„„   DEF SEG = 64       'point to BIOS data area„   POKE &H2, &HF8     'restore com2: address in BIOS data area to com2:„   DEF SEG            'return to DGROUP„„Jack Moffitt                   REFERENCE TO MODEM COMMUNICATIOREFERENCE,MODEM,COMMUNICATION  Unknown Date (00:00)   Text                   421  19364    MODEM.REF              Programmer's Reference to Modem Communications„„                               by„„                           Jack Moffitt„„„INTRODUCTION„~~~~~~~~~~~~„        Direct UART programming is a subject that not many people are„familiar with.  Since the advent of FOSSIL, many people advise that one„should use that for all communications, to make it more portable.  But„for some instances, it is necessary to have internal modem routines to„go on. Because no one seems to know or understand this subject, and„because I have found no other texts on the subject, I have decided to„put it all into one text, and maybe round off the edges on this subject.„„„THE ASYNCRONOUS MODEM„~~~~~~~~~~~~~~~~~~~~~„        The asyncronous modem uses one (or more) specific ports on a„computer, as well as an IRQ (Interrupt Request).  Every time a character„of data is received in the device, an interrupt is processed.  One must„make a interrupt service routine to handle this input, but where does it„go? Since the IRQs are tied into interrupts, knowing the IRQ the device„is using, we can replace that interrupt.  The port addresses and IRQ„vectors are as follows:„„Port Addresses: COM1  --  03F8h        IRQ Vectors   :  0  --  08h„                COM2  --  02F8h                         1  --  09h„                COM3  --  03E8h                         2  --  0Ah„                COM4  --  02E8h                         3  --  0Bh„                                                        4  --  0Ch„                                                        5  --  0Dh„Standard Port IRQs: COM1  --  4                         6  --  0Eh„                    COM2  --  3                         7  --  0Fh„                    COM3  --  4                         8  --  70h„                    COM4  --  3                         9  --  71h„                                                       10  --  72h„                                                       11  --  73h„                                                       12  --  74h„                                                       13  --  75h„                                                       14  --  76h„                                                       15  --  77h„„For standard use, the IRQ for comm ports 1 and 3 is 4, and for 2 and 4„it's 3.  The 8250 UART has 10 registers available for getting, receiving„and interperating data.  They are all located at offsets from the base„address of the port.  Here are the registers and their offsets:„„Register Offsets:  Transmitter Holding Register (THR)       --  00h„                   Receiver Data Register (RDR)             --  00h„                   Baud Rate Divisor Low Byte (BRDL)        --  00h„                   Baud Rate Divisor High Byte (BRDH)       --  01h„                   Interrupt Enable Register (IER)          --  01h„                   Interrupt Identification Register (IIR)  --  02h„                   Line Control Register (LCR)              --  03h„                   Modem Control Register (MCR)             --  04h„                   Line Status Register (LSR)               --  05h„                   Modem Status Register (MSR)              --  06h„„With this information one can address any register by adding the offset„to the base address.  Therefor, if one is using COM2 (base address„02F8h) they would access the Modem Status Register with: port[$02F8 +„$06].„„„TRANSMITTER HOLDING REGISTER„~~~~~~~~~~~~~~~~~~~~~~~~~~~~„        This register contains the data to be sent to the remote PC or„modem. When bit 5 (THR empty) of the LSR is set, one can write to this„port, thus sending data over the phone line or null modem cable.„„„RECEIVER DATA REGISTER„~~~~~~~~~~~~~~~~~~~~~~„        This register contains the incoming data.  Read this register„only if bit 0 (Data Received) of the LSR is set, otherwise on will get„unpredictable characters.„„„BAUD RATE DIVISOR„~~~~~~~~~~~~~~~~~„        The Baud Rate Divisor is used to set the BPS rate.  To calculate„the Baud Rate Divisor, one must use the formula: (UART Clock„Speed)/(16*BPS). The UART Clock Speed is 1843200.  To set the BRD one„must first set bit 7 (port toggle) of the Line Control Register to 1,„and then write the low and high bytes to the correct offsets. Always„remember to reset LCR bit 7 to 0 after one is finished setting the BPS„rate.„„„INTERRUPT ENABLE REGISTER„~~~~~~~~~~~~~~~~~~~~~~~~~„        The IER is used to simulate real interrupt calls.  Write a byte„containing to interrupt information to enable any interrupts, all„interrupts also have corresponding actions to clear the interrupts.„Here's the list:„„Info Byte:„„bit   7-6-5-4       3                 2                 1           0„      ~~~~~~~       ~                 ~                 ~           ~„     Always 0   MSR Change   Data Error or Break    THR empty  Data Received„„To Clear:       Read MSR          Read LSR        Output to THR   Read RDR„„„INTERRUPT IDENTIFICATION REGISTER„~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~„        This register is used to determine what kind of interrupts have„occured.  Read one byte from this register, and use AND masks to find„out what has happened.  The information in the byte is:„„Info Byte:„„bit   7-6-5-4-3    2-1                                    0„      ~~~~~~~~~    ~~~                                    ~„       Unused      0-0 = Change in MSR                If this bit is set„                   0-1 = THR empty                    more than one„                   1-0 = Data Received                interrupt has„                   1-1 = Data Error or Break          occured.„„„LINE CONTROL REGISTER„~~~~~~~~~~~~~~~~~~~~~„       The Line Control Register (LCR) is used for changing the settings„on the serial line.  It is also used for initializing the modem„settings. Write a byte to the port, containing the following info:„„LCR Byte.„      Port Toggle   Break Condition   Parity      Stop Bits   Data Bits„bit       7                6           5-4-3          2          1-0„          ~                ~           ~~~~~          ~          ~~~„          0 = Normal       0 = Off     0-0-0 = None   0 = 1      0-0 = 5„          1 = Set BRD      1 = On      1-0-0 = Odd    1 = 2      0-1 = 6„                                       1-1-0 = Even              1-0 = 7„                                       1-0-1 = Mark              1-1 = 8„                                       1-1-1 = Space„„Everything is pretty clear except for the purpose of bits 6 and 7.  Bit„6 controls the sending of the break signal.  Bit 7 should always be 0,„except if one is changing the baud rate.  Then one must set it to one,„write to the BRD and then set it back to zero.  One can only write to„the BRD if this bit is set.„„„MODEM STATUS REGISTER„~~~~~~~~~~~~~~~~~~~~~„        Just like the LSR returns the status of the RS232 line, the MSR„returns the status of the modem.  As with other registers, each bit in„the byte one reads from this port contains a certain piece of info.„„MSR byte.„„bit        0 = Change in CTS„           1 = Change in DSR„           2 = Change in RI„           3 = Change in DCD„           4 = CTS on„           5 = DSR on„           6 = RI on„           7 = DCD on„„Carrier Detect is achieved by testing bit 7, to see if the line is„ringing test bit 6.„„„„PUTTING IT ALL TOGETHER„~~~~~~~~~~~~~~~~~~~~~~~„        One can now use this information about the 8250 UART to start„programming their own modem routines.  But before they can do that, they„must learn a little about interrupts and the 8259A PIC (Programmable„Interrupt Controller).  This information is necessary to write modem„routines that are not dependant on a slow BIOS.„„„INTERRUPTS„~~~~~~~~~~„        Interrupts are a broad subject, and this is not a reference for„them. For for information on interrupts, one should look at DOS„Programmer's Reference 4th Edition.  Although there are two kinds of„interrupts - Non- Maskable and Maskable, maskable interrupts are the„only ones that one should be concerned with.  When an interrupt„generates, the processor finishes the current command, and then saves a„few variables (the address to return to) on the stack and jumps to the„vector of the interrupt.  One can turn off maskable interrupts with the„STI, and back on with CLI.  One can not turn off non-maskable„interrupts.  Replacing interrupt routines in pascal is very easy.„Include the DOS unit in their program, and use the procedures GetIntVec„and SetIntVec.  To replace the interrupt for COM2 (remember it's 0Bh)„one would do this:„„                     GetIntVec($0B, OldInt0Bh);„                     SetIntVec($0B, NewInt0Bh);„„At the end of the program, one MUST restore the interrupt using:„„                     SetIntVec($0B, OldInt0Bh);„„Failing to do this will most likely result in a system crash after the„program terminates. Because another interrupt may be called inside„another interrupt at any time, it is necessary to turn off interrupts,„as mentioned above, every once in a while. Remember all this, and„programming for the modem will be much easier ( :) ).„„„8259 PROGRAMMABLE INTERRUPT CONTROLLER„~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~„         The 8259A PIC is used by the processor as a gateway for„interrupts. The 8259A decides which interrupts go first and which„are currently active. The order interrupts are processed in in„the order of their IRQ number. Thus, IRQ0 will always be„processed before IRQ1 if both are generated at the same time.„Since asyncronous communication uses IRQs, we must instruct the„8259A PIC on when are interrupts should start interrupting, and„when they should stop.  When initializing the modem, one must„"turn on" the IRQ before one can start to use it.  Turning back„off is identical, but don't turn it off if one is writing door„routines!  To do either requires one assign the value contained„at the port the value AND the mask.  The masks for turning on and„off the 8259A follows.„„To Turn On:„            mask = (1 shl (IRQ number)) xor $00FF„To Turn Off:„             mask = 1 shl (IRQ number)„„One must also reset the PIC in the custom interrupt handler after one is„finished with it.  That will allow the PIC to process the next„interrupt.„„To reset the PIC, write 20h to it.  This is also refered to as the End„Of Interrupt (EOI) signal.  This must also be done after first„initializing the modem.  There is another PIC on the 286, allowing the„last 8 IRQs (7 - 15). The second PIC is called the cascade PIC.  The„addresses for the PIC command and mask ports are listed next.„„8259A PIC command address         = 20h„8259A PIC mask address            = 21h„Cascade 8259A PIC command address = A0h„Cascade 8259A PIC mask address    = A1h„„To reset the PIC always write to the command, and for turning off with„the masks always write to the mask.  The masks for the cascade PIC are„the same for the other PIC.  So the mask for IRQ0 is equal to the mask„for IRQ7. Also, one should write 20h to the cascade PIC as the EOI„signal.„„„„INPUT/OUTPUT CONTROL„~~~~~~~~~~~~~~~~~~~~„        To keep the text simple, only buffered input will be covered.„Buffered output is a subject of more depth than one can provide in a„short reference.  Buffered input is relatively simple, but there are a„few things one must consider.  The size of the buffer is very import,„make the buffer to big and one will eat up the datasegment, make the„buffer to small and one will get overruns.  A good choice for a general„buffer would be in the range of 4 to 8k.  This should allow plenty of„room for all incoming data. Another inportant factor is the type of„buffer.  For simplicity and ease of use, a circular input buffer is„recommended.  A head and a tail point to the start and end of the„buffer, and they will both wrap around when either go past the end of„the buffer, thus making the buffer a kind of circle.  Getting data in„the buffer is the primary job of the custom interrupt routine.  Clearing„the buffer and reading characters from the buffer is then as easy as„reading a character from an array, and advancing the head of the buffer.„Sending characters over the phone can be accomplished by waiting for the„flow control and then sending the character to the THR, repeating for„every character.„„THE INTERRUPT SERVICE ROUTINE„~~~~~~~~~~~~~~~~~~~~~~~~~~~~~„        The ISR (Interrupt Service Routine) is the backbone for„asyncronous communication.  The interrupt is called for every„character that comes through the modem.  So in the interrupt one„must process these incoming characters or else they will be lost.„Since the the interrupt got called, one must check the IIR„(Interrupt Identification Register) to see what actually cause the„interrupt to be called.  Since the interrupt is mainly dealing„with handling the incoming data, and for reasons of simplicity,„flow control will be ommited from the routine but will be„discussed later in this text.  Since one is writing to the buffer,„and since another character is likely to come in during this time,„one must disable interrupts for the shortest time possible while„writing to the buffer, and then reenable them so no data is lost.„(NOTE: If the ISR is to be contained in a unit, it must be„declared in the unit's interface section as an INTERRUPT„procedure.) After disabling interrupts, checking for data,„discarding data if no buffer space is available, putting the data„in the buffer if there is room, and clearing the RDR if any data„error or break occured, one must turn on the interrupts and issue„the EOI signal to the 8259A PIC or both the 8259A PIC and the„cascade PIC if IRQ7 - IRQ15 is used.  Here is a sample rou„„„const„  BaseAddr: array[1 .. 4] of word = ($03F8, $02F8, $03E8, $02E8);„  { Nice array to make finding the base address easy }„„var„  Buffer: array[1 .. 4096] of char;  { A 4k buffer for input }„  Temp,  { Varible to hold various modem statuses }„  CommPort: byte;  { Comm Port in use }„  Head,  { Start of the buffer }„  Tail,  { End of the buffer }„  Size: word;  { Size of the buffer }„  Cascade: boolean;  { For IRQ7 - IRQ15 }„„procedure Async_ISR; interrupt; { NOTE: must declare the procedure„interrupt }„begin„  inline($FB); { STI - Disable interrupts }„  Temp := port[BaseAddr[CommPort] + $02];  { Read a byte from the IIR }„  if Temp and $06 = $04 then  { Character received }„  begin„    if Head <> Tail then  { Make sure there is room in the buffer }„    begin„      Buffer[Tail] := Chr(port[BaseAddr[CommPort] + $00]);  { Read char }„      inc(Tail);  { Position the Tail for the next char }„      if Tail > 4096 then Tail := 0;  { If Tail is greater, wrap the buffer }„    end„    else temp := port[BaseAddr[CommPort] + $00];  { Throw away overruns }„  end„  else if Temp and $06 = $06 then  { Data error or break }„    Temp := port[BaseAddr[CommPort] + $00];  { Clear RDR }„  inline($FA);  { CLI - Enable interrupts }„  port[$20] := $20;  { Reset the 8259A PIC }„  if Cascade then port[$A0] := $20;  { Reset the cascade PIC }„end;„„„First the procedure disables interrupts, then it reads the IIR to find„out what kind of interrupt needs processing.  The procedure then masks„out bits 2 and 1 and tests it to see if bit 4 is set.  If data is„received it checks to make sure there is room in the buffer, and places„the character at the position marked by Tail, otherwise it disregards„the character as overrun. If a data error occured it clears the RDR to„make sure no garbage is received.  Finally it enables interrupts and„resets the 8259A (and the cascade if necessary).„„SENDING CHARACTERS„~~~~~~~~~~~~~~~~~~„        Sending character over the modem is much simpler than getting„them. First one must wait for the flow control and for the UART and then„write the character to the THR.  Here's an example:„„procedure XmitChar(C: char);  { Uses variable and constant declarations from„begin                           the previous example }„  while ((port[BaseAddr[CommPort] + $05] and $20 <> $20) and  { Wait for THR }„         (port[BaseAddr[CommPort] + $06] and $10 <> $10))  { Wait for CTS }„  do ;  { Do nothing until CTS and THR empty }„  port[BaseAddr[CommPort] + $00] := Ord(C);  { Send character }„end;„„This waits for the CTS signal and for the THR to be clear and then sends„the character.  To send strings just use this in a repeat loop such as:„„for x := 1 to length(s) do„  XmitChar(s[x]);„„„READING CHARACTERS„~~~~~~~~~~~~~~~~~~„       The actual reading of character takes place in the ISR, but one„still has to get them from the buffer.  Just read the character at„the head of the buffer and pass it back.  An example:„„function RemoteReadKey: char;  { Uses var and const from above }„begin„  RemoteReadKey := Buffer[Head];  { Get the character }„  inc(Head);  { Move Head to the next character }„  if Head > 4096 then Head := 0;  { Wrap Head around if necessary }„  dec(Size);  { Remove the character }„end;„„To find out if a character is waiting is even easier:„„function RemoteKeyPressed: boolean;  { Uses vars and consts from above }„begin„  RemoteKeyPressed := Size > 0;  { A key was pressed if there is data„in„end;                               the buffer }„„„INITIALIZING MODEM PARAMETERS AND OTHER TOPICS„~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~„       For most cases one can use interrupt 14h function 00h to„initialize modem parameters, but if the baud rate is over 9600, this„function will not work.  One must change the BRD themselves. It is a„simple matter of accessing the BRD by setting the LCR bit 7 to 1 and„writing to the BRD and then reseting the LCR bit 7 back to 0.„Everything else, clearing buffers, flushing buffers, formatting input,„is all up to the programmer.  I have provided one with enough„information to grasp the basis of modem programming and the I/O„involved.„„FLOW CONTROL„~~~~~~~~~~~~„      Flow control is mainly used to prevent overflow error on today's„high speed modems.  CTS/RTS was already covered earlier, but nothing has„been said for XOn/XOff.  XOn/XOff will send a certain character (usually„a ^S) when the input buffer has reached a certain percentage of„capacity. This signal is XOff.  When the buffer has gone down to another„percentage of capacity, XOn (usually a ^Q) will be sent.  It is the„programmer's job to look for XOn/XOff codes and interperate them, as„there are no standard ways to do it as with CTS/RTS.  It is also his job„to make sure he or she sends the signals at the appropriate time.„„CONCLUSION„~~~~~~~~~~„        This text is general, and won't satisfy the needs of advanced„modem programmers.  It was written to help those just starting, or„thinking about starting, through the ordeal of finding a book, or read„through source not knowing what some of it does.  If one finds any„mistakes, please feel free to contact me via the Pascal FIDONet echo,„and he will gladly correct them.  Also, if one would like more„information on other related topics, contact me via the Pascal echo, and„I will try to help.„Donn Bly                       BEYOND 19200                   BEYOND,19200                   Unknown Date (00:00)   QB, QBasic, PDS        30   982      HIGHBAUD.BASDECLARE SUB BaudLatch ()„'Use the straight OPEN COM statement for 19200.  To go higher you can„'use this code (originally from Donn Bly):„„BaudLatch„„SUB BaudLatch   'enables 38400 baud  want to put in com3 and com4 support„'NewBaud$ = "38400"„'BaudNum% = 3   'for 38.4„'BaudNum% = 2  'for 56000„BaudNum% = 1 'for 115K„Port$ = "COM4:"„ „SELECT CASE Port$„        CASE "COM1:"„                BaseAddress% = &H3F8„        CASE "COM2:"„                BaseAddress% = &H2F8„        CASE "COM3:"„                BaseAddress% = &H3E8„        CASE "COM4:"„                BaseAddress% = &H2E8„END SELECT„        OldLSR% = INP(BaseAddress% + 3)„        OUT (BaseAddress% + 3), (OldLSR% OR &H80)   ' Enable the Divisor Latch„        OUT (BaseAddress% + 0), (BaudNum% MOD &HFF) ' Lo Byte of Baud Rate„        OUT (BaseAddress% + 1), (BaudNum% \ &H100)  ' Hi Byte of baud Rate„        OUT (BaseAddress% + 3), OldLSR%             ' Disable Divisor Latch„END SUB„„Robert Benson                  DTR PATCH FOR QB               DTR,PATCH,FOR,QB               01/17/91 (21:32)       TEXT                   156  2407     DTRPATCH.TXTTo the end that it is an ongoing struggle to get Microsoft to listen„to the needs of the programmer, the following patches are provided„to enable you to patch your copies of BRUN45.EXE and BCOM45.LIB.„„Before beginning, make sure you have backup copies of BRUN45.EXE„and BCOM45.LIB.„„BCOM45.LIB DTR Patch„--------------------„„With Debug in a DOS path, type :„„  debug bcom45.lib„„Type :„„  s cs:0 ffff b0 00 e3 01„„Debug should show :„„  xxxx:1529„„  where xxxx can be any number depending upon where Debug loaded the„  program into memory.  In any case, the number is not important.„„Type :„„  u 1529„„Debug should show :„„  MOV   AL,00„  JCXZ  152E„  INC   AX„  ADD   DX,+04„  OUT   DX,AL„„This is where QB graciously resets the comm port to parameters it thinks„the comm port should have.„„To fix the problem, Type :„„  a 1529„„  mov   al,01„  [Enter]„„  a 152d„„  nop„  [Enter]„„  where [Enter] is the Enter key (do not type the characters)!„„„To verify that you typed everything correctly, Type„„  u 1529„„Debug should show :„„  MOV   AL,01„  JCXZ  152E„  NOP„  ADD   DX,+04„  OUT   DX,AL„„„To save the corrections Type :„„  w„„Debug should show :„„  Writing 35EF7 bytes„„„Now type Q and you are finished patching BCOM45.LIB„„„„BRUN45.EXE DTR Patch„--------------------„„First, rename BRUN45.EXE to BRUN45.X„„With Debug in a DOS path, type :„„  debug BRUN45.X„„Type :„„  s cs:0 ffff b0 00 e3 01„„Debug should show :„„  xxxx:9E78„„  where xxxx can be any number depending upon where Debug loaded the„  program into memory.  In any case, the number is not important.„„Type :„„  u 9e78„„Debug should show :„„  MOV   AL,00„  JCXZ  9E7D„  INC   AX„  ADD   DX,+04„  OUT   DX,AL„„This is where QB graciously resets the comm port to parameters it thinks„the comm port should have.„„To fix the problem, Type :„„  a 9e78„„  mov   al,01„  [Enter]„„  a 9e7c„„  nop„  [Enter]„„  where [Enter] is the Enter key (do not type the characters)!„„„To verify that you typed everything correctly, Type„„  u 9e78„„Debug should show :„„  MOV   AL,01„  JCXZ  9E7D„  NOP„  ADD   DX,+04„  OUT   DX,AL„„„To save the corrections Type :„„  w„„Debug should show :„„  Writing 12E80 bytes„„„Now type Q and you are finished patching BRUN45.X„„Rename BRUN45.X back to BRUN45.EXE„Coridon Henshaw                ACCESSING FOSSIL IN BASIC      QuickBASIC ScrapBook           02-14-93 (21:39)       QB, PDS                146  3225     FOSSIL.BAS  DECLARE FUNCTION FossInit% (Port%)„DECLARE FUNCTION BlockRead$ (Port%)„DECLARE FUNCTION BlockWrite% (Port%, Buffer$)„DEFINT A-Z„ „'$INCLUDE: 'QB.BI'    or use QBX.BI for PDS„„DIM SHARED Regs AS RegTypeX„„FUNCTION BlockRead$ (Port)„Buffer$ = STRING$(32766, 0) 'Max 32766 bytes to read„Regs.cx = LEN(Buffer$)„Regs.dx = Port„Regs.es = VARSEG(Buffer$)   ' Change to SSEG for PDS„Regs.di = SADD(Buffer$)„CALL INTERRUPTX(&H14, Regs, Regs)„BlockRead$ = LEFT$(Buffer$, Regs.ax)„END FUNCTION„„FUNCTION BlockWrite (Port, Buffer$)„Regs.cx = LEN(Buffer$)„Regs.dx = Port„Regs.es = VARSEG(Buffer$)  ' Change to SSEG for PDS„Regs.di = SADD(Buffer$)„CALL INTERRUPTX(&H14, Regs, Regs)„BlockWrite = Regs.ax 'Number of chars transfered„END FUNCTION„„SUB FossDeInit (Port)„' Release the FOSSIL device driver„Regs.ax = &H500„Regs.dx = Port„INTERRUPTX &H14, Regs, Regs„END SUB„„FUNCTION FossInit (Port)„ „' Initialize the FOSSIL device driver„'„' dx = Communications port number (0-3)„' ah = &H04    Fossil Function Number - Initialize FOSSIL driver„'                                       (Raises DTR in the porcess)„ „Regs.dx = Port„Regs.ax = &H400„CALL INTERRUPTX(&H14, Regs, Regs)„ „IF Regs.ax <> &H1954 THEN„   FossInit = False 'Fossil Not Found„END IF„ „FossInit = True„ „END FUNCTION„„SUB SetDtr (Port, DtrStatus)„Regs.dx = Port 'Set carrier detect low or high„SELECT CASE DtrStatus„    CASE 0„    Regs.ax = &H600„    CASE 1„    Regs.ax = &H601„    CASE ELSE„    Regs.ax = &H600„    BEEP„END SELECT„INTERRUPTX &H14, Regs, Regs„END SUB„„SUB SetFlowControl (Port, Control)„Regs.dx = Port„SELECT CASE Control„ CASE 1 'Xon/Xoff on transmit„  Regs.ax = &H601„ CASE 2 'CTS/RTS„  Regs.ax = &H602„ CASE 3 'Xon/Xoff on recieve„  Regs.ax = &H608„END SELECT„CALL INTERRUPTX(&H14, Regs, Regs)„END SUB„„SUB SetPortParams (Port, Bps AS LONG, Bits, Stops, Parity$)„Regs.dx = Port„Regs.ax = 0„SELECT CASE Bps„    CASE 300„    Regs.ax = (Regs.ax OR &H40)„    CASE 600„    Regs.ax = (Regs.ax OR &H60)„    CASE 1200„    Regs.ax = (Regs.ax OR &H80)„    CASE 2400„    Regs.ax = (Regs.ax OR &HA0)„    CASE 4800„    Regs.ax = (Regs.ax OR &HC0)„    CASE 9600„    Regs.ax = (Regs.ax OR &HE0)„    CASE 19200„    Regs.ax = (Regs.ax OR &H0)„    CASE 38400„    Regs.ax = (Regs.ax OR &H20)„    CASE ELSE„    Regs.ax = (Regs.ax OR &HA0)„    'Default to 2400 baud„END SELECT„ „SELECT CASE Bits„    CASE 5„    Regs.ax = (Regs.ax OR &H0)„    CASE 6„    Regs.ax = (Regs.ax OR &H1)„    CASE 7„    Regs.ax = (Regs.ax OR &H2)„    CASE 8„    Regs.ax = (Regs.ax OR &H3)„    CASE ELSE„    Regs.ax = (Regs.ax OR &H3)„    'Default to 8 bits„END SELECT„ „SELECT CASE Stops„    CASE 1„    Regs.ax = (Regs.ax OR &H0)„    CASE 2„    Regs.ax = (Regs.ax OR &H4)„    CASE ELSE„    Regs.ax = (Regs.ax OR &H0)„    'Default to 1 stop bit„END SELECT„ „SELECT CASE UCASE$(Parity$)„    CASE "N"„    Regs.ax = (Regs.ax OR &H0)„    CASE "O"„    Regs.ax = (Regs.ax OR &H8)„    CASE "E"„    Regs.ax = (Regs.ax OR &H18)„    CASE ELSE„    Regs.ax = (Regs.ax OR &H0)„    ' Default to no parity„END SELECT„Regs.dx = Port„INTERRUPTX &H14, Regs, Regs„END SUB„„Unknown Author(s)              DETECTING CARRIER              FidoNet QUIK_BAS Echo          Unknown Date           QB, QBasic, PDS        18   763      DETCARR.BAS '>Looking for and example of code to monitor carrier detect. Would like to„'>be able to have a local programer using Thorobred  add carrier detect to„'>his program but he has never seen any code as to what to do. I know there„'>has to be someone in the Quick Basic world that can do this and hopefully„'>we can transfer this to another basic program. Any help appreciated.„ „ „ DEFINT A-Z„ FUNCTION Carrier(Port) ' returns false (0) if no carrier„ Select Case Port„    CASE 1: BaseAddress = &H3F8„    case 2: BaseAddress = &H2F8„    CASE 3: BaseAddress = &H3E8„    CASE 4: BaseAddress = &H2E8„    CASE ELSE: BaseAddress  = Port„            'For Those PS/2 types out there or Weird ones„ End Select„ Carrier = (INP(BaseAddress + 6) AND &h80) > 0„James Vahn                     ALARM ON CONNECTION            FidoNet QUIK_BAS Echo          10-18-92 (10:18)       QB, QBasic, PDS        109  2703     CONNECT.BAS '>  Does anyone have code that allows you to dial a number through„'>  the modem, and allow the user to pick up the phone when it„'>  connects (and things to watch for, like how do you know when„'>  it's safe to pick up the phone)?„„„' This routine sends an alarm when a connection is made.„„„'modem.bas  is an ASCII terminal to demo an autodialer.  James Vahn„DECLARE SUB Keyscan ()„DECLARE SUB Delay (td!)„DECLARE SUB Dial (num$)„„' Put all modem response into a 10k buffer declared global.„COMMON SHARED ModemIn$„„ON ERROR GOTO Handler„ON COM(2) GOSUB GetBuf„COM(2) ON„„CALL Dial ("555-1212")„„DO„ CALL Keyscan      ' You're online now. Stay in this loop forever.„LOOP„„Handler:„RESUME NEXT„„GetBuf:„InStr$ = INPUT$(LOC(1), #1)„„   ' swap a backspace char for a left cursor.„   DO„      BackSpace = INSTR(InStr$, CHR$(8))„      IF BackSpace THEN„         MID$(InStr$, BackSpace) = CHR$(29)„      END IF„   LOOP WHILE BackSpace„„   ' eliminate line feeds.„   DO„      LineFeed = INSTR(InStr$, CHR$(10))„      IF LineFeed THEN„         InStr$ = LEFT$(InStr$, LineFeed - 1) + MID$(InStr$, LineFeed + 1)„      END IF„   LOOP WHILE LineFeed„„   ModemIn$ = RIGHT$(ModemIn$ + InStr$, 10240)„   PRINT (InStr$);            'print modem buffer to screen.„RETURN„„SUB Delay (td!)„  TimeDelay! = (TIMER + td!) mod 86400„  WHILE TimeDelay! > TIMER: WEND„END SUB„„SUB Dial (num$)„„OPEN "COM2:2400,N,8,1" FOR RANDOM AS #1„„CLS„LOCATE 25, 40: PRINT "ALT-X to exit.."„LOCATE 1, 1, 1„  PRINT #1, "ATZ"„  CALL Delay(1.25)„  PRINT #1, "ATS7=45 S0=0 V1 M0"     ' modem initialization string„  CALL Delay(1.25)„„DO„  CALL Delay(1)„  PRINT "Dialing ....."„  PRINT #1, "atdt" + Num$ + CHR$(13)„„ TimeDelay! = TIMER + 40„„   DO UNTIL TIMER > TimeDelay!„       CALL Keyscan„       test = INSTR(RIGHT$(ModemIn$, 20), "CONNECT")„        IF test THEN result = -1: EXIT DO„       test = INSTR(RIGHT$(ModemIn$, 5), "BUSY")„        IF test THEN result = 0: EXIT DO„       test = INSTR(RIGHT$(ModemIn$, 12), "NO DIALTONE")„        IF test THEN result = 0: CALL Delay(2): EXIT DO„       test = INSTR(RIGHT$(ModemIn$, 11), "NO CARRIER")„        IF test THEN result = 0: CALL Delay(2): EXIT DO„„   LOOP„„LOOP UNTIL result„„FOR t = 1 TO 5            ' It answered! ring the alarm!„  SOUND 750, 2„  SOUND 550, 2„  SOUND 650, 2„  IF INKEY$ <> "" THEN EXIT FOR„NEXT„„END SUB„„SUB Keyscan„' This would be a good place to check for PgDn/PgUp and shell to an„' external transfer protocol like Zmodem.„„a$ = INKEY$„    IF a$ = CHR$(0) + CHR$(45) THEN CLOSE : END '  ALT-X to exit.„    PRINT #1, a$;    ' send keypress to modem„END SUB„David Colston                  BBS DICE DOOR GAME             FidoNet QUIK_BAS Echo          Year of 1993           QB, PDS                452  11136    DOORGAME.BAS'A local sysop wanted a door to roll dice for a dungeons and dragons„'game. I thought you might like to see it. Some of the code might look„'familar<g>. Not all of the fossil routines are used, but are offered„'for completeness.„„DECLARE SUB Delay (X!)„DECLARE SUB CheckPortStatus (Port%, Info%, Reg AS ANY)„DECLARE SUB FossInit (Port%, Present%, Reg AS ANY)„DECLARE SUB GetChar (Port%, Good%, InBound$, Present%, Reg AS ANY)„DECLARE SUB PrintCon (A$, Reg AS ANY)„DECLARE SUB SendChar (Port%, Sent%, Present%, Outbound$, Reg AS ANY)„' $INCLUDE: 'QBX.BI'„' Include Data Types for IN„DEFINT A-Z„'$STATIC„DIM Reg AS RegType                ' Used for INTERRUPT calls„A# = TIMER + 120 'Allow only two minute in this door„					 'This saves us from constantly monitoring„					 'carrier detect.„ON TIMER(A#) GOSUB Quit„ON KEY(10) GOSUB Quit'Allow local bail out by sysop„TIMER ON„KEY(10) ON„Port = VAL(LTRIM$(RTRIM$(COMMAND$)))' Port =0 is port 1, etc.„Start:„DIM Rolls(1000)„FossInit Port, Present, Reg 'Find out if fossil is present or„					   'if we're just looking on a PC.„Bits = 8   'Defaults for almost all boards!„Stops = 1„Parity$ = "N"„SendChar Port, Sent, Present, CHR$(12), Reg 'Just in case they„														    „'have„X$ = CHR$(27) + "[2J   Dice Door 1.0 By David Colston (c) 1993"„X$ = X$ + CHR$(13) + CHR$(10)„'Send ansii clear screen and return; line feed„ „X$ = X$ + "   Enter your character name:"„FOR I = 1 TO LEN(X$)„	SendChar Port, Sent, Present, MID$(X$, I, 1), Reg„	PrintCon MID$(X$, I, 1), Reg'Echo to board consol.„NEXT„DO„	GetChar Port, Good, InBound$, Present, Reg„	IF Good THEN„	    IF InBound$ <> CHR$(13) THEN User$ = User$ + InBound$„	    SendChar Port, Sent, Present, InBound$, Reg„	    PrintCon InBound$, Reg„	END IF„LOOP UNTIL InBound$ = CHR$(13)„DiceSides:„X$ = CHR$(13) + CHR$(10) + "   Enter Number of Dice Sides:"„FOR I = 1 TO LEN(X$)„	SendChar Port, Sent, Present, MID$(X$, I, 1), Reg„	PrintCon MID$(X$, I, 1), Reg„NEXT„Sides$ = ""„DO„	GetChar Port, Good, InBound$, Present, Reg„	IF Good THEN„		IF INSTR(1, "1234567890", InBound$) > 0 THEN„			 Sides$ = Sides$ + InBound$„			 SendChar Port, Sent, Present, InBound$, Reg„		 END IF„		 PrintCon InBound$, Reg„	 END IF„LOOP UNTIL InBound$ = CHR$(13)„IF VAL(Sides$) < 2 OR VAL(Sides$) > 100 THEN GOTO DiceSides„Dice:„X$ = CHR$(13) + CHR$(10) + "   Enter Number of Dice      :"„FOR I = 1 TO LEN(X$)„	SendChar Port, Sent, Present, MID$(X$, I, 1), Reg„	PrintCon MID$(X$, I, 1), Reg„NEXT„Dice$ = ""„DO„	 GetChar Port, Good, InBound$, Present, Reg„	 IF Good THEN„		 IF INSTR(1, "1234567890", InBound$) > 0 THEN„			 Dice$ = Dice$ + InBound$„			 SendChar Port, Sent, Present, InBound$, Reg„		 END IF„		 PrintCon InBound$, Reg„	  END IF„LOOP UNTIL InBound$ = CHR$(13)„IF VAL(Dice$) < 2 OR VAL(Dice$) > 100 THEN GOTO Dice„Grey = FREEFILE„OPEN "Greyhawk.rol" FOR APPEND AS Grey' Output for game bulletin„PRINT #Grey, "On "; DATE$; " "; User$; " had the following roll."„PRINT #Grey, "# Dice = "; Dice$; " # Sides = "; Sides$„RANDOMIZE TIMER„TotalRoll = 0„FOR I = 1 TO VAL(Dice$)„    Roll = INT(RND(1) * VAL(Sides$)) + 1„    X$ = CHR$(13) + CHR$(10) + "   Die" + STR$(I) + " Showed" + STR$(Roll)„    TotalRoll = TotalRoll + Roll„    FOR J = 1 TO LEN(X$)„	   SendChar Port, Sent, Present, MID$(X$, J, 1), Reg„	   PrintCon MID$(X$, J, 1), Reg„    NEXT„    PRINT #Grey, RIGHT$(X$, LEN(X$) - 2)„NEXT„X$ = CHR$(13) + CHR$(10) + "   Total Rolled Was" + STR$(TotalRoll)„PRINT #Grey, RIGHT$(X$, LEN(X$) - 2)„PRINT #Grey, SPACE$(10)„FOR J = 1 TO LEN(X$)„	 SendChar Port, Sent, Present, MID$(X$, J, 1), Reg„	 PrintCon MID$(X$, J, 1), Reg„NEXT„SendChar Port, Sent, Present, CHR$(13), Reg„X$ = CHR$(13) + CHR$(10) + "  Press any key."„FOR J = 1 TO LEN(X$)„	 SendChar Port, Sent, Present, MID$(X$, J, 1), Reg„	 PrintCon MID$(X$, J, 1), Reg„NEXT„DO„	 GetChar Port, Good, InBound$, Present, Reg„	 IF Good THEN PrintCon InBound$, Reg„LOOP UNTIL Good„„Quit:„END„ „'This door in not error trapped one of you guys might do better!„„SUB CheckPortStatus (Port, Info, Reg AS RegType)„ „' ah = &H03     Fossil Function Number - Status„' al = &H00     Place Holder„' dx = Communications port number       (0-3)„Reg.dx = Port„Reg.ax = &H300„INTERRUPT &H14, Reg, Reg„ „IF (Reg.ax AND &H80) <> 0 THEN Info = (Info OR &H1)„' carrier detect present ?„IF (Reg.ax AND &H100) <> 0 THEN Info = (Info OR &H2)„' buffer has data?„IF (Reg.ax AND &H200) <> 0 THEN Info = (Info OR &H4)„' Was buffer overun?„IF (Reg.ax AND &H4000) = 0 THEN Info = (Info OR &H8)„' output buffer data ?„IF (Reg.ax AND &H2000) = 0 THEN Info = (Info OR &H10)„' Is output buffer overrun?„END SUB„„SUB CtrlBreak (Port, Present)„SELECT CASE Port„	CASE 0„	address = &H3F8„	CASE 1„	address = &H2F8„	CASE 2„	address = &H3E8„	CASE ELSE„	address = &H2E8„END SELECT„Old1 = INP(address + 1)„OUT address + 1, 0„Old2 = INP(address + 3)„SetLow = Old2 OR &H40„A# = TIMER„OUT address + 3, SetLow„Delay .5„OUT address + 3, Old2 'Set it back the way it was!„OUT address + 1, Old1„END SUB„„DEFSNG A-Z„SUB Delay (X!) STATIC„CheckTime! = TIMER„WHILE TIMER < CheckTime! + X!„WEND„END SUB„„DEFINT A-Z„SUB ErrorMessage (A$, X) STATIC„A$ = ""„SELECT CASE X„ „   CASE 3„	  A$ = "Return with out GOSUB."„   CASE 4„   A$ = "Out of Data."„   CASE 5„			 A$ = "Illegal Function Call."„   CASE 6„			 A$ = "Math Overflow."„   CASE 7„			 A$ = "Out of Memory."„   CASE 9„			 A$ = "Subscript out of range."„   CASE 11„			 A$ = "Division by Zero."„   CASE 14„			 A$ = "Out of String Space."„   CASE 16„			 A$ = "String Formula Too Complex."„   CASE 19„			 A$ = "No RESUME."„   CASE 20„			 A$ = "RESUME without error."„   CASE 24„			 A$ = "Device TimeOut."„   CASE 25„			 A$ = "Device Fault."„   CASE 27„			 A$ = "Out of Paper."„   CASE 39„			 A$ = "Case Else Expected."„   CASE 40„			 A$ = "Variable Required."„   CASE 50„			 A$ = "Field OverFlow."„   CASE 51„			 A$ = "Internal Error."„   CASE 52„			 A$ = "Bad File Name or Number."„   CASE 53„			 A$ = "File Not Found."„   CASE 54„			 A$ = "Bad File Mode."„   CASE 55„			 A$ = "File Already Open."„   CASE 56„			 A$ = "Field Statement Active."„   CASE 57„			 A$ = "Device I/O Error."„   CASE 58„			 A$ = "File Already exists."„   CASE 59„			 A$ = "Bad Record Length."„   CASE 61„			 A$ = "Disk Full."„   CASE 62„			 A$ = "Input past end of file."„   CASE 63„			 A$ = "Bad Record Number."„   CASE 64„			 A$ = "Bad File Name."„   CASE 67„			 A$ = "Too many files."„   CASE 68„			 A$ = "Device Unavailable."„   CASE 69„			 A$ = "Communications Buffer OverFlow."„   CASE 70„			 A$ = "Access Denied."„   CASE 71„			 A$ = "Disk or Drive Not Ready."„   CASE 72„			 A$ = "Disk Media Error. (Bad Disk!)"„   CASE 75„			 A$ = "Path/File access error."„   CASE 76„			 A$ = "Path not Found."„   CASE ELSE„			 A$ = "Unknown Error #" + STR$(X)„ „END SELECT„ „END SUB„„SUB FossDeinit (Port, Reg AS RegType)„' Release the FOSSIL device driver„Reg.ax = &H500„Reg.dx = Port„INTERRUPT &H14, Reg, Reg„END SUB„„SUB FossInit (Port, Present, Reg AS RegType)„Present = -1„ „' Initialize the FOSSIL device driver„'„' dx = Communications port number (0-3)„' ah = &H04    Fossil Function Number - Initialize FOSSIL driver„'                                       (Raises DTR in the porcess)„ „Reg.dx = Port„Reg.ax = &H400„INTERRUPT &H14, Reg, Reg„IF Reg.ax <> &H1954 THEN„   Present = 0 'Fossil Not Found„END IF„ „END SUB„„SUB GetChar (Port, Good, InBound$, Present, Reg AS RegType)„CheckPortStatus Port, Info, Reg ' Test for space in OUTPUT buffer„IF NOT Present THEN„			 InBound$ = INKEY$„			 IF InBound$ > "" THEN„				    Good = -1„			 ELSE„				    Good = 0„			 END IF„			 EXIT SUB„END IF„IF (Info AND &H4) = 0 THEN„	   IF (Info AND &H2) = &H2 THEN„			 Reg.ax = &H200„			 Reg.dx = Port„			 INTERRUPT &H14, Reg, Reg„			 InBound$ = CHR$(Reg.ax)„			 Good = -1„	   ELSE„			 Good = 0' No Characters in input buffer„			 InBound$ = INKEY$„			 IF InBound$ > "" THEN Good = -1„	   END IF„ELSE ' Input buffer over-run„	   Good = 0„	   Reg.ax = &HA00„	   Reg.dx = Port„	   INTERRUPT &H14, Reg, Reg„	   BEEP„END IF„END SUB„„SUB PrintCon (A$, Reg AS RegType) STATIC„IF A$ = "" THEN EXIT SUB„	   Reg.ax = &H600„	   Reg.dx = ASC(A$)„	   INTERRUPT &H21, Reg, Reg„	   IF A$ = CHR$(13) THEN„			 Reg.ax = &H600„			 Reg.dx = 10„			 INTERRUPT &H21, Reg, Reg„	   END IF„END SUB„„SUB SendChar (Port, Sent, Present, Outbound$, Reg AS RegType)„A! = TIMER„IF NOT Present THEN„	   Sent = 0„	   EXIT SUB„END IF„DO„	   CheckPortStatus Port, Info, Reg ' room in buffer ?„	   IF (Reg.ax AND &H80) = 0 THEN„			 Sent = -1„			 EXIT DO„	   END IF„    IF (Info AND &H10) = 0 THEN„		 Reg.dx = Port„		 Reg.ax = &H100 + ASC(Outbound$)„		 INTERRUPT &H14, Reg, Reg„		 Sent = -1„	   END IF„LOOP WHILE NOT Sent AND TIMER - A! < 2„IF Sent = 0 AND Reg.ax AND &H80 <> 0 THEN„    Sent = 0 ' Output buffer full„    Reg.ax = &H900„    Reg.dx = Port„    INTERRUPT &H14, Reg, Reg„END IF„END SUB„„SUB SetDtr (Port, DtrStatus$, Reg AS RegType)„Reg.dx = Port 'Set carrier detect low or high„SELECT CASE UCASE$(DtrStatus$)„    CASE "L"„    Reg.ax = &H600„    CASE "H"„    Reg.ax = &H601„    CASE ELSE„    Reg.ax = &H600„    BEEP„END SELECT„INTERRUPT &H14, Reg, Reg„END SUB„„SUB SetHandShake (Port, HandShake, Reg AS RegType)„Reg.dx = Port„IF HandShake > &HF THEN„    HandShake = &H2„    'Set handshake to RTS/CTS.„    BEEP„END IF„Reg.ax = &HF00 + HandShake„INTERRUPT &H14, Reg, Reg„Reg.ax = &H1000„Reg.dx = Port„INTERRUPT &H14, Reg, Reg„END SUB„„SUB SetPortParams (Port, Baud$, Bits, Stops, Parity$, Reg AS RegType)„Reg.dx = Port„Reg.ax = 0„SELECT CASE Baud$„    CASE "300"„    Reg.ax = (Reg.ax OR &H40)„    CASE "600"„    Reg.ax = (Reg.ax OR &H60)„    CASE "1200"„    Reg.ax = (Reg.ax OR &H80)„    CASE "2400"„    Reg.ax = (Reg.ax OR &HA0)„    CASE "4800"„    Reg.ax = (Reg.ax OR &HC0)„    CASE "9600"„    Reg.ax = (Reg.ax OR &HE0)„    CASE "19200"„    Reg.ax = (Reg.ax OR &H0)„    CASE "38400"„    Reg.ax = (Reg.ax OR &H20)„    CASE ELSE„    Reg.ax = (Reg.ax OR &HA0)„    'Default to 2400 baud„END SELECT„ „SELECT CASE Bits„    CASE 5„    Reg.ax = (Reg.ax OR &H0)„    CASE 6„    Reg.ax = (Reg.ax OR &H1)„    CASE 7„    Reg.ax = (Reg.ax OR &H2)„    CASE 8„    Reg.ax = (Reg.ax OR &H3)„    CASE ELSE„    Reg.ax = (Reg.ax OR &H3)„    'Default to 8 bits„END SELECT„ „SELECT CASE Stops„    CASE 1„    Reg.ax = (Reg.ax OR &H0)„    CASE 2„    Reg.ax = (Reg.ax OR &H4)„    CASE ELSE„    Reg.ax = (Reg.ax OR &H0)„    'Default to 1 stop bit„END SELECT„„SELECT CASE UCASE$(Parity$)„    CASE "N"„    Reg.ax = (Reg.ax OR &H0)„    CASE "O"„    Reg.ax = (Reg.ax OR &H8)„    CASE "E"„    Reg.ax = (Reg.ax OR &H18)„    CASE ELSE„    Reg.ax = (Reg.ax OR &H0)„    ' Default to no parity„END SELECT„Reg.dx = Port„INTERRUPT &H14, Reg, Reg   'Set it up!„END SUB„„Bob Perkins                    QB FOSSIL ROUTINES             FidoNet QUIK_BAS Echo          10-24-95 (21:28)       QB, PDS                348  11206    QBFOSSIL.BAS   '       -=-=-=-=-=-   Data for initfossil()   -=-=-=-=-=-=-„ '[initialize fossil driver]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'DTR is raised„ 'returns 0 for successful, -1 for failure„ '„ '       -=-=-=-=-=-    Data for inituart()    -=-=-=-=-=-=-„ '[initialize uart]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'valid baud rates are 38400, 19200, 9600, 4800, 2400, 1200, 600, 300„ 'parity% :   0=none   8=odd   24=even„ 'stop%   :   0=1bit   4=2bits„ 'wordlen%:   0=5bits  1=6bits  2=7bits  3=8bits„ 'returns rs-232 status code bits in ah„ 'bit0=RDA   (input data available in buffer)„ 'bit1=OVRN  (data has been lost)„ 'bit5=THRE  (room available in output buffer)„ 'bit6=TSRE  (output buffer empty)„ 'returns modem status bits in al„ 'bit3 = always set„ 'bit7 = carrier detect„ '„ '       -=-=-=-=-=-  Data for deinitfossil()  -=-=-=-=-=-=-„ '[deinitialize fossil driver]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'state of DTR is not affected, use setDTR() first to set desired state.„ 'nothing returned„ '„ '       -=-=-=-=-=-     Data for setDTR()     -=-=-=-=-=-=-„ '[set state of DTR]„ 'port%  = 0=com1, 1=com2, 2=com3, 3=com4„ 'state% = 0 to lower,  1 to raise„ 'nothing returned„ '„ '       -=-=-=-=-=-    Data for waitreceive   -=-=-=-=-=-=-„ '[get character from port with wait]„ 'NOTE: Will not return until a character is received!„ '      Use check4char%() before calling!„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'returns ascii value of character received„ '„ '       -=-=-=-=-=-    Data for check4char    -=-=-=-=-=-=-„ '[non-destructive read-ahead]„ 'Use before waitreceive() to make sure character available.„ '"peeks" at character without retrieving from buffer.„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'returns 0 for no character, or ascii value of char waiting in buffer„ '„ '       -=-=-=-=-=-     Data for sendchar%    -=-=-=-=-=-=-„ '[send character out port]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'returns 0 if successful, -1 if character rejected (buffer full)„ '„ '       -=-=-=-=-=-   Data for getdriverinfo  -=-=-=-=-=-=-„ '[get information about fossil driver]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'loads structure driverinfo with information about driver„ '„ '       -=-=-=-=-=-    Data for flushbuffer   -=-=-=-=-=-=-„ '[flush output buffer]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'flushes buffer, waiting until all characters have been sent„ 'nothing returned„ '„ '       -=-=-=-=-=-  Data for purgeoutputbuff -=-=-=-=-=-=-„ '[purge output buffer]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'clears output buffer destroying any characters waiting to be sent.„ 'nothing returned„ '„ '       -=-=-=-=-=-  Data for purgeinputbuff  -=-=-=-=-=-=-„ '[purge input buffer]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'clears input buffer destroying any characters waiting to be read.„ 'nothing returned„ '„ '       -=-=-=-=-=-     Data for sendbreak    -=-=-=-=-=-=-„ '[toggle break]„ 'port% = 0=com1, 1=com2, 2=com3, 3=com4„ 'status:  1 = start sending break,  0 = stop sending break„ 'nothing returned„ '„ '       -=-=-=-=-=-       Data for reboot     -=-=-=-=-=-=-„ '[fossil reboot]„ 'if coldwarm% = 0 then cold boot  (memory check)„ 'if coldwarm% = 1 then warm boot„ 'nothing returned (obviously)„ '„ '       -=-=-=-=-=-     Data for writeansi    -=-=-=-=-=-=-„ '[writes character to screen with ANSI support]„ 'nothing returned„ '       -=-=-=-=-=-  Data for writeansistrng  -=-=-=-=-=-=-„ '[writes a string of characters to the screen with ANSI]„ 'uses calls to writeansi()„ 'nothing returned„ '„ '       -=-=-=-=-=-    Data for getcurorpos   -=-=-=-=-=-=-„ '[get current cursor location]„ 'current row returned in row%, column in column%„ '„ '       -=-=-=-=-=-    Data for setcurorpos   -=-=-=-=-=-=-„ '[set cursor location]„ 'specify row% and column%„ 'nothing returned„ '„ '„ TYPE driverinfo„   structsize AS INTEGER          'size of structure„   spec AS STRING * 1             'spec fossil conforms to„   revlevel AS STRING * 1         'rev level of fossil„   IDoffset AS INTEGER            'id string offset„   IDsegment AS INTEGER           'id string segment„   inputbuffsize AS INTEGER       'input buffer size in bytes„   inpbytesleft AS INTEGER        'bytes waiting in buffer„   outputbuffsize AS INTEGER      'output buffer size in bytes„   outbytesleft AS INTEGER        'bytes waiting in buffer„   screenwidth AS STRING * 1      'screen width„   screenlength AS STRING * 1     'screen length„   comp2modembaud AS STRING * 1   'computer to modem baud rate„ END TYPE„ DIM SHARED driverinfo AS driverinfo  'structure for getdriverinfo()„ '„„ '$INCLUDE: 'qb.bi'„ DIM SHARED regs AS regtype„ '„ DECLARE FUNCTION initfossil% (port%)„ DECLARE SUB deinitfossil (port%)„ DECLARE FUNCTION inituart% (port%, baud&, parity%, stopbits%, wordlen%)„ DECLARE SUB setDTR (port%, state%)„ DECLARE FUNCTION waitreceive% (port%)„ DECLARE FUNCTION check4char% (port%)„ DECLARE FUNCTION sendchar% (port%, char%)„ DECLARE SUB getdriverinfo (port%)„ DECLARE SUB flushbuffer (port%)„ DECLARE SUB purgeoutputbuff (port%)„ DECLARE SUB purgeinputbuff (port%)„ DECLARE SUB sendbreak (port%, status%)„ DECLARE SUB reboot (coldwarm%)„ DECLARE SUB writeansi (char%)„ DECLARE SUB writeansistrng (ansistring$)„ DECLARE SUB setcursorpos (row%, column%)„ DECLARE SUB getcursorpos (row%, column%)„ DECLARE FUNCTION getblock% (buffer$, port%)„ DECLARE FUNCTION writeblock% (port%)„ '„ crlf$ = CHR$(13) + CHR$(10)„ ctrlx$ = CHR$(24)„ port% = 1        'com2:„ '......................... Initialize FOSSIL .........................„ IF initfossil%(port%) THEN PRINT "Fossil driver not loaded!": END„ '.......................... Initialize UART ...........................„ 'com2:, 9600 baud, no parity, 1 stop bit, 8 data bits„ baud& = 9600: parity% = 0: stopbits% = 0: wordlen% = 3„ status% = inituart%(port%, baud&, parity%, stopbits%, wordlen%)„ '.................. Display Fossil driver ID string ...................„ getdriverinfo (port%)„ DEF SEG = driverinfo.IDsegment      'get fossil ID string„ CLS : x% = 0: PRINT "Fossil ID string = ";„ DO„   a% = PEEK(driverinfo.IDoffset% + x%)„   writeansi a%„   x% = x% + 1„ LOOP UNTIL a% = 0„ DEF SEG„ writeansistrng crlf$ + crlf$ + "To exit press CTRL-X" + crlf$„ '......................... Main Program Loop...........................„ 'simple modem communications program...„ DO„  a$ = INKEY$„  IF LEN(a$) THEN„     DO„       test% = sendchar%(port%, ASC(a$))    'send until accepted„     LOOP WHILE test%„  END IF„  IF check4char%(port%) THEN„    char% = waitreceive(port%)„    writeansi char%„  END IF„ LOOP UNTIL a$ = ctrlx$„ '............................. Program End ............................„ '„ setDTR port%, 0       'lower DTR„ writeansistrng crlf$ + "FOSSIL deinitializing.  Program End."„ deinitfossil port%    'release fossil„ END„„ FUNCTION check4char% (port%)„ 'non-destructive read-ahead to peek and see if char waiting..„ regs.ax = &HC00„ regs.dx = port%„ interrupt &H14, regs, regs„ IF regs.ax = &HFFFF THEN„   check4char% = 0„ ELSE„   check4char% = regs.ax AND &HFF„ END IF„ END FUNCTION„„ SUB deinitfossil (port%)„ 'DTR is NOT affected„ regs.ax = &H500„ regs.dx = port%„ interrupt &H14, regs, regs„ END SUB„„ SUB flushbuffer (port%)„ 'flush buffer waiting until all output is done„ regs.ax = &H800„ regs.dx = port%„ interrupt &H14, regs, regs„ END SUB„„ FUNCTION getblock% (buffer$, port%)„   DIM regsx AS regtypex„   regsx.ax = &H1800„   regsx.cx = LEN(buffer$)„   regsx.dx = port%„   regsx.es = VARSEG(buffer$)„   regsx.di = SADD(buffer$)„   interruptx &H14, regsx, regsx„   getblock% = regs.ax„ END FUNCTION„„ SUB getcursorpos (row%, column%)„   regs.ax = &H1200„   interrupt &H14, regs, regs„   row% = (regs.dx AND &HFF00) \ 256„   column% = regs.dx AND &HFF„ END SUB„„ SUB getdriverinfo (port%)„ DIM regsx AS regtypex„ regsx.ax = &H1B00„ regsx.dx = port%„ regsx.cx = LEN(driverinfo)„ regsx.es = VARSEG(driverinfo)„ regsx.di = VARPTR(driverinfo)„ interruptx &H14, regsx, regsx„ '„ ' AX = number of characters transferred„ ' CX = 3058h ("0X") (X00 FOSSIL only)„ ' DX = 2030h (" 0") (X00 FOSSIL only)„ '„ 'structure driveinfo filled with data from call..„ END SUB„„ FUNCTION initfossil% (port%)„ regs.ax = &H400„ regs.dx = port%„ interrupt &H14, regs, regs„ IF regs.ax = &H1954 THEN initfossil% = 0 ELSE initfossil% = -1„ END FUNCTION„„ FUNCTION inituart% (port%, baud&, parity%, stopbits%, wordlen%)„ 'regs.ah = 0, regs.al = parameters„ 'regs.dx = port to init 0=com1, 1=com2, etc.. (255 for local testing)„ 'parity = bits 4-3,  stopbits = bit 2,  wordlength = bits 1-0„   SELECT CASE baud&„     CASE 38400: baudrate% = 32  '001  bits 7-6-5„     CASE 19200: baudrate% = 0   '000„     CASE 9600: baudrate% = 224  '111„     CASE 4800: baudrate% = 192  '110„     CASE 2400: baudrate% = 160  '101„     CASE 1200: baudrate% = 128  '100„     CASE 600: baudrate% = 96    '011„     CASE 300: baudrate% = 64    '010„   END SELECT„ regs.ax = baudrate% + parity% + stopbits% + wordlen%„ regs.dx = port%„ interrupt &H14, regs, regs„„ 'Return: AH = RS-232 status code bits„ '            0: RDA - input data is available in buffer„ '            1: OVRN - data has been lost„ '            5: THRE - room is available in output buffer„ '            6: TSRE - output buffer empty„ '        AL = modem status bits„ '            3 : always 1„ '            7: DCD - carrier detect„„ inituart% = regs.ax„ END FUNCTION„„ SUB purgeinputbuff (port%)„ regs.ax = &HA00„ regs.dx = port%„ interrupt &H14, regs, regs„ END SUB„„ SUB purgeoutputbuff (port%)„ regs.ax = &H900„ regs.dx = port%„ interrupt &H14, regs, regs„ END SUB„„ SUB reboot (coldwarm%)„ 'if coldwarm% = 0 then cold boot, 1 then warm boot.„ regs.ax = &H1700 + coldwarm%„ interrupt &H14, regs, regs„ END SUB„„ SUB sendbreak (port%, status%)„ 'status = 1 send break, status = 0 stop sending break„ regs.ax = &H1A00 + status%„ regs.dx = port%„ interrupt &H14, regs, regs„ END SUB„„ FUNCTION sendchar% (port%, char%)„ 'returns 0 if char accepted, -1 if not..„ regs.ax = &HB00 + char%„ regs.dx = port%„ interrupt &H14, regs, regs„ IF regs.ax = 0 THEN sendchar% = -1 ELSE sendchar% = 0„ END FUNCTION„„ SUB setcursorpos (row%, column%)„   regs.ax = &H1100„   regs.dx = row% * 256 + column%„   interrupt &H14, regs, regs„ END SUB„„ SUB setDTR (port%, state%)„ regs.ax = &H600 + state% 'state% = 0 for lower or 1 for raise„ regs.dx = port%„ interrupt &H14, regs, regs„ END SUB„„ FUNCTION waitreceive% (port%)„ regs.ax = &H200„ regs.dx = port%„ interrupt &H14, regs, regs„ waitreceive% = regs.ax  'ah will be 0 so no need to AND with FFh„ END FUNCTION„„ SUB writeansi (char%)„   regs.ax = &H1300 + char%„   interrupt &H14, regs, regs„ END SUB„„ SUB writeansistrng (ansistring$)„   'calls writeansi() for each character in string„   FOR x% = 1 TO LEN(ansistring$)„     writeansi ASC((MID$(ansistring$, x%, 1)))„   NEXT x%„ END SUB„„