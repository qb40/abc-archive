Rich Geldreich                 PC MOD PLAYER                  PC,MOD,PLAYER                  12/06/92 (00:00)       QB, PDS                823  30048    QBMP16.BAS  ' A THREE Part Snippet   (MODPLAY.BAS, QBMPASM.ASM, QBMPASM.OBJ)„„'QBMP16.BAS (experiment 27-parallel substager/mixer & looping overmix)„'A Sample PDS/QB4.5 4-Channel Amiga MOD Player„'Written by Rich Geldreich (C) Copyright December 6, 1992„'You may use this program for anything you wish, but if you're going to„'make any money off it I would like to know about it first.„'„'NOTES: This program also requires INTRPT.OBJ (from QB.LIB or QBX.LIB),„'and QBMPASM.ASM to function. I have only tested this program in„'PDS 7.1. I *highly* recommend that you only run this program compiled!„'„'To compile(this is a pretty complicated procedure for beginners):„'-First, you must extract INTRPT.OBJ from QB.LIB or QBX.LIB(depending„'-on QB/BC7). Type:„'LIB QBX.LIB *INTRPT.OBJ,;              [BC7]„'LIB QB.LIB *INTRPT.OBJ,;               [QB4.5]„'-Then make a QLB by:„'LINK /q QBMPASM+INTRPT,,,QBXQLB,;      [BC7]„'LINK /q QBMPASM+INTRPT,,,BQLB45        [QB4.5]„'-And a LIB by:„'LIB QBMPASM QBMPASM+INTRPT,;           [BC7 or QB4.5]„'-Then load QBX(or QB) with the following and compile:„'QB(x) /lQBMPASM QBMP16„'Please note that the above instructions for QB4.5 haven't been tested.„'„'If you have a fast computer and want better sound change the variable„'"IntRate=11000" below to a larger number(max is about 25,600 hz!!) „'This program is currently configured to load MODs up to about 370k, „'change the line that says "Null& = SETMEM(-400000)" to load larger „'MODs. Anyone having problems or questions and can afford a L/D call: „'(609)-742-8752 between 3:00pm and 1:00am eastern time.„'„'If you get it compiled successfully, then run it with:„'QBMP16 modfile.MOD„'You should hear the MOD play on your PC-Speaker. The keys 1-4 turn on/„'off each channel, and the left and right arrows fast forward/rewind the „'MOD. Press escape to drop back to DOS. Here goes!! -RG„DEFINT A-Z„CONST True = -1, False = 0„„DECLARE FUNCTION CheckDoneFlag% ()„DECLARE SUB SetBuffers (BYVAL BDS%, BYVAL Buffer1%, BYVAL Buffer2%,_„BYVAL BufferSize%)„DECLARE FUNCTION GetCS% ()„DECLARE FUNCTION GetOF% ()„DECLARE FUNCTION UnsignedComp% (BYVAL A%, BYVAL B%)„„DECLARE SUB SetInt8Rate (A&)„DECLARE SUB SpeakerOff ()„DECLARE SUB SpeakerOn ()„DECLARE FUNCTION Alloc% (A%)„DECLARE SUB ExitWithError (A$)„DECLARE FUNCTION Extract% (A$, offset%)„„TYPE RegTypeX„     ax    AS INTEGER„     bx    AS INTEGER„     cx    AS INTEGER„     dx    AS INTEGER„     bp    AS INTEGER„     si    AS INTEGER„     di    AS INTEGER„     flags AS INTEGER„     ds    AS INTEGER„     es    AS INTEGER„END TYPE„DIM SHARED CPU as RegTypeX„„'Sample arrays.„DIM S.Name(30) AS STRING * 22„DIM S.Volume(30)„DIM S.Segment(30)„DIM S.RepStart(30),     S.RepLength(30)„DIM S.Length(30)„„'Channel arrays„DIM C.InactiveFlag(3)„DIM C.Volume(3)„DIM C.Segment(3)„DIM C.Period(3),        C.HighStep(3),  C.LowStep(3)„DIM C.Offset(3),        C.Remainder(3)„DIM C.RepStart(3),      C.RepLength(3), C.LoopEnd(3)„DIM C.Length(3)„„'For command processing„DIM C.Command(3)„DIM C.PortSpeed(3)„DIM C.PortDest(3)„DIM C.VolumeSpeed(3)„„'Misc. Arrays„DIM PeriodHigh(1023),   PeriodLow(1023) 'Precalculated step rates.„DIM VolumeTable(63, 255) 'Precalculated volume tables.„DIM SampleBuffer(1199)   'buffer for mixing+playing at same time.„DIM PatternSegment(127)  'Holds segments of all the patterns to play.„DIM ChannelOn(3)„„DIM Scale8to6(255)       'Translation table for dividing each signed„                         'sample by 4.„'=====================================================================„'Modify this variable for better sound(controls how many samples are„'mixed per second).„IntRate = 11000      „„ON ERROR GOTO ErrorHandler„„PRINT "QBMP v1.6 - An Amiga MOD player written in PDS/QuickBASIC."„PRINT "(C) Copyright 1992 By Rich Geldreich"„„'Precalculate an 8-bit to 6-bit signed translation table, to translate„'the signed 8 bit samples in the MOD to signed 6 bit samples for mixing.„FOR A=-128 to 127„    C=A\4:IF A<0 then Scale8to6(A+256)=C ELSE Scale8to6(A)=C„NEXT„„'Free up 400,000 bytes of far memory(increase this if you get an out of„'memory error while loading big MODs).„Null& = SETMEM(-400000)„„FileSpec$ = Command$„IF INSTR(FileSpec$,".")=0 THEN FileSpec$=FileSpec$+".MOD"„'Attempt to open the MOD file.„OPEN FileSpec$ FOR INPUT AS #1:CLOSE #1„OPEN FileSpec$ FOR BINARY AS #1„„'Check to see if MOD contains 15 or 31 samples...„A$ = "    ": GET #1, 1081, A$„'If the string at offset 1081 is "M.K.", or the first 3 letters are„'"FLT", then the MOD contains 31 samples:„S.Max = 15 - 16 * ((A$ = "M.K.") OR (LEFT$(A$, 3) = "FLT"))„„'Print the MOD's title„A$ = SPACE$(20): GET #1, 1, A$:PRINT "Title: ";A$„'=====================================================================„A$ = SPACE$(8)„FOR A = 0 TO S.Max - 1„    'Skip the sample's name„    GET #1, , S.Name(A)„    'Get the info on the sample„    GET #1, , A$„    S.Volume(A)         = ASC(MID$(A$, 4, 1))„    IF S.Volume(A) > 64 THEN S.Volume(A) = 64„    S.Length(A)         = Extract(A$, 1)„    S.RepStart(A)       = Extract(A$, 5)„    S.RepLength(A)      = Extract(A$, 7)„    IF S.RepLength(A) = 2 THEN S.RepLength(A) = 0„    IF S.Length(A)=2 THEN S.Length(A)=0„„'Check the sample's loop end to make sure it's in range.„    A&=S.RepStart(A)+S.RepLength(A)-1:IF A&<0 THEN A&=A&+65536„    B&=S.Length(A):IF B&<0 THEN B&=B&+65536„    IF A&>B& THEN 'If not in range, then divide by two(DigiStudio does„        A&=S.RepLength(A):IF A&<0 THEN A&=A&+65536    '           this). ?„        A&=A&\2:S.RepLength(A) = A&„„        A&=S.RepStart(A):IF A&<0 THEN A&=A&+65536„        A&=A&\2:S.RepStart(A) = A&„    END IF„„NEXT„'=====================================================================„A$ = " ": GET #1, , A$: T.Length = ASC(A$): GET #1, , A$„'Load the pattern table, and find the highest pattern to load.„HighestPattern = -1„FOR A = 0 TO 127„    GET #1, , A$: B = ASC(A$)„    IF B > HighestPattern THEN HighestPattern = B„    PatternSegment(A) = B„NEXT„'=====================================================================„IF S.Max = 31 THEN SEEK #1, LOC(1) + 5„A$ = SPACE$(1024)„'Load the patterns.„FOR A = 0 TO HighestPattern„    LOCATE , 1: PRINT USING "Parsing Pattern ##"; A;„    GET #1, , A$„    B = Alloc(80): DEF SEG = B: C = 0: e = 1„    FOR d = 1 TO 256„        b1 = ASC(MID$(A$, e, 1)): b2 = ASC(MID$(A$, e + 1, 1))„        b3 = ASC(MID$(A$, e + 2, 1)): b4 = ASC(MID$(A$, e + 3, 1))„        e = e + 4„        sample = (b1 AND 240) OR (b3 \ 16)„        period = (b1 AND 15) * 256 OR b2„        effect = b3 AND 15:operand = b4„„        IF sample > S.Max THEN sample = 0„        IF period > 1023 OR period < 20 THEN period = 0„„        SELECT CASE effect„        CASE &HC„            IF operand > 64 THEN operand = 64„        END SELECT„        'Store the channel in an expanded format for ease of „        'processing during playing.„        POKE C, sample„        POKE C + 1, period \ 256„        POKE C + 2, period AND 255„        POKE C + 3, effect„        POKE C + 4, operand„        C = C + 5„    NEXT„    'Fill in the pattern's segment in the position table.„    FOR d = 0 TO 127:IF PatternSegment(d)=A THEN PatternSegment(d)=B„    NEXT„NEXT„'=====================================================================„'Load the samples.„FOR A = 0 TO S.Max - 1„    LOCATE , 1: PRINT USING "Loading Sample ##  "; A + 1;„„    d& = S.Length(A): IF d& < 0 THEN d& = d& + 65536„    'Allocate 1024 bytes more than needed for mixer runoff.„    d& = d& + 1024„    IF d& > 65500 THEN ExitWithError "Sample Too Large"„„    B = Alloc(d& \ 16 + 1) 'Allocate memory for the sample.„    S.Segment(A) = B„„    'Load the sample„    CPU.ax = &H3F00„    CPU.bx = FILEATTR(1, 2)„    CPU.ds = B: CPU.dx = 0„    CPU.cx = S.Length(A)„„    CALL interruptx(&H21, CPU, CPU)„    IF (CPU.Flags AND 1) THEN ExitWithError "Error Loading Sample"„„    DEF SEG = B„„    A& = S.Length(A): IF A& < 0 THEN A& = A& + 65536„„    'Divide each byte of the sample by 4 for mixing. A lookup table „    'is used because QB doesn't support signed bytes.„    FOR B& = 0 TO A& - 1„        POKE B&, Scale8to6(PEEK(B&))„    NEXT„„    'Clear the end of the sample for mixer runoff.„    FOR A& = A& TO A& + 1023:POKE A&, 0:NEXT„NEXT„'=====================================================================„LOCATE ,1:PRINT SPACE$(40);„„'Figure out how many samples are mixed per 1/50th of a second.„IntsPerClick = IntRate \ 50„„'Precalculate a step for each period. The constant &H369040 is from „'the Amiga, it is scaled up by 256 (&h100) so floating point math can„'be eliminated.„K& = &H36904000 \ IntRate„FOR A = 20 TO 1023„    A& = K& \ A„    PeriodHigh(A) = A& \ 256„    PeriodLow(A) = CINT(A&) AND 255„NEXT„'Precalculate the volume lookup tables. Enables the mixer to adjust„'the volume of a sample without slow multiples and divides.„FOR A = 0 TO 63„    FOR B = -128 TO -1„        C = (B * A) \ 64: IF C < 0 THEN C = C + 256„        VolumeTable(A, B + 256) = C„    NEXT„    FOR B = 0 TO 127:VolumeTable(A, B) = (B * A) \ 64:NEXT„NEXT„„'Make all channels currently inactive, but enable them(the keys 1-4„'toggle the ChannelOn() table to turn off/on channels).„FOR A = 0 TO 3: C.InactiveFlag(A) = True: ChannelOn(A)=True:NEXT„„BufferOffset    = 512   'Current mixing offset.„T.Tempo         = 6     'Default tempo is 6/50th of a second.„T.ClicksLeft    = 6     'Clicks left before a line.„T.Pos           = 0     'Lines left before a new pattern.„GOSUB StartNewPattern„GOSUB DoLine„„'Save old interrupt 8 handler.„CPU.ax = &H3508:CALL interruptx(&H21, CPU, CPU)„Old8.Offset = CPU.bx:Old8.Segment = CPU.es„„'Initialize the assembly buffer player.„SetBuffers VARSEG(SampleBuffer(0)), VARPTR(SampleBuffer(0)), _„           VARPTR(SampleBuffer(512)), IntsPerClick * 2„„'Set int 8 to our asm routine„CPU.ax = &H2508:CPU.ds = GetCS:CPU.dx = GetOF„CALL interruptx(&H21, CPU, CPU)„„'Reprogram the 8255's timer to the specified sample rate.„SetInt8Rate &H1234DE \ IntRate„„'Turn speaker on, and play the MOD.„SpeakerOn„DO„    'Wait for sync signal from the assembly buffer player...„    DO: LOOP UNTIL CheckDoneFlag„„    'Mix more samples, to keep the MOD going.„    GOSUB DoMix„„    A$=INKEY$„    IF A$<>"" THEN  'Process any keystrokes.„        K=ASC(RIGHT$(A$,1))„        SELECT CASE K„        CASE 49 TO 52   '1-4„            ChannelOn(K-49) = NOT ChannelOn(K-49)„        CASE 27         'Escape„            Exit do     „        CASE &H4b       'Left„            T.Pos=T.Pos-1„            IF T.Pos<0 THEN T.Pos=T.Length-1„            GOSUB StartNewPattern„        CASE &H4d       'Right„            T.Pos=T.Pos+1„            IF T.Pos=>T.Length THEN T.Pos=0„            GOSUB StartNewPattern„        END SELECT„   END IF„„LOOP„'Turn off speaker.„SpeakerOff„'Set int 8 rate to normal (18.2 hz)„SetInt8Rate 0„„'restore old int 8 handler„CPU.ax = &H2508:CPU.ds = Old8.Segment:CPU.dx = Old8.Offset„CALL interruptx(&H21, CPU, CPU)„„LOCATE ,1:PRINT SPACE$(40);„END„'=====================================================================„'Processes 1 line(4 channels) of a pattern.„DoLine:„    DEF SEG = PatternSegment„„    FOR A = 0 TO 3„        C = PEEK(T.Offset): T.Offset = T.Offset + 1„„        IF C <> 0 THEN  'Process a new sample, if any.„            C = C - 1„            'Load then new sample into the channels arrays.„            C.Segment(A)        = S.Segment(C)„            C.Volume(A)         = S.Volume(C)„            C.RepStart(A)       = S.RepStart(C)„            C.RepLength(A)      = S.RepLength(C)„            C.Length(A)         = S.Length(C)„            C.LoopEnd(A)        = C.Length(A)„        END IF„„        C = PEEK(T.Offset) * 256 + PEEK(T.Offset + 1)„        T.Offset = T.Offset + 2„        IF C <> 0 THEN  'Process a new period, if any.„            IF PEEK(T.Offset) <> 3 THEN„                C.Period(A)     = C„                C.HighStep(A)   = PeriodHigh(C) 'Lookup the step rate „                C.LowStep(A)    = PeriodLow(C)  'of the new period.„                C.Offset(A)     = 0             'Set current offset=0.„                C.LoopEnd(A)    = C.Length(A)„                C.Remainder(A)  = -256          'Set remainder to 0.„                C.InactiveFlag(A) = False       'Turn channel on.„            END IF„        END IF„„        C.Command(A) = 0„        M = PEEK(T.Offset)„        IF M<>0 THEN    'Process a command, if any.„            o = PEEK(T.Offset + 1)„            SELECT CASE M„            CASE 12             'Volume„                C.Volume(A) = o„            CASE 15             'Tempo„                T.Tempo = o„            CASE 1              'Port Down„                C.Command(A)   = 2„                C.PortSpeed(A) = O„            CASE 2              'Port Up„                C.Command(A)   = 3„                C.PortSpeed(A) = O„            CASE 3              'Port to Note„                IF C.Period(A) > C THEN„                    C.Command(A) = 4„                ELSE„                    C.Command(A) = 5„                END IF„                '!!!fix„                'If no port destination, then use last.„                IF C=0 THEN C=C.PortDest(A)„                IF C<113 THEN C=113 ELSE IF C>1023 THEN C=1023„„                C.PortSpeed(A) = o„                C.PortDest(A)  = C„            CASE 10             'Volume Slide„                C.Command(A) = 1„                IF O AND 15 THEN„                    C.VolumeSpeed(A) = -(O AND 15)„                ELSE„                    C.VolumeSpeed(A) = O\16„                END IF„            CASE 11             'Position Jump„                IF o<T.Length THEN„                    T.Pos = o„                    T.Line = 1„                END IF„            CASE 13             'Pattern Skip„                T.Line = 1„            END SELECT„        END IF„        T.Offset = T.Offset + 2„    NEXT„    T.ClicksLeft = T.Tempo„    T.Line = T.Line - 1:IF T.Line = 0 THEN GOTO NewPattern„RETURN„NewPattern:„    T.Pos = T.Pos + 1:IF T.Pos >= T.Length THEN T.Pos = 0„    GOSUB StartNewPattern„RETURN„StartNewPattern:„    LOCATE ,1„    PRINT USING "Playing:###"; (T.Pos*100&)\T.Length;„    PRINT "%";„    T.Line              = 64„    PatternSegment      = PatternSegment(T.Pos)„    T.Offset            = 0„RETURN„'=====================================================================„'Main mixer follows. While the assembly routine is playing one buffer,„'this routine mixes the other.„DoMix:„    BufferOffset = BufferOffset XOR 512„„    Tm=0„    FOR K = 0 TO 3„        IF C.InactiveFlag(K)=False AND ChannelOn(K) THEN„            GOSUB Mix„            Tm = 1„        END IF„    NEXT„    If Tm=0 then 'If all channels inactive, just clear buffer to 0's.„        FOR B = BufferOffset TO BufferOffset + IntsPerClick-1„            SampleBuffer(B) = 0„        NEXT„    END IF„„    T.ClicksLeft = T.ClicksLeft - 1„    'If not time for a new line the process slide commands, if any.„    IF T.ClicksLeft = 0 THEN GOSUB DoLine ELSE GOSUB DoCommands„RETURN„'=====================================================================„Mix:„    MixesLeftToDo   = IntsPerClick„    OffsetNow       = BufferOffset„„    'Preload all needed variables for speed.„    DEF SEG = C.Segment(K)„    o = C.Offset(K)                     'current offset into sample„    r = C.Remainder(K)             'current remainder(0-255) at offset„    v = C.Volume(K)                     'volume(0-64)„„    h = C.HighStep(K)                   'integer step„    l = C.LowStep(K)                    'remainder step(0-255)„„    IF C.RepLength(K) THEN„        DO„         'If sample loops then calculate the number of mixes left until„         'the loop occurs...„            PL&=C.LoopEnd(K)-o„„         'Thanks to QB's lack of unsigned ints, we must do this...„            IF PL&<0 THEN PL&=PL&+65536„„            MixesTillRepeat&=(PL&*256-(r+256)) \ ((h * 256&) + l)„„         'If there is any remainder left, then add 1 to MixesTillRepeat.„            IF ( (PL& * 256 - (r+256)) MOD ((h * 256&) + l) ) THEN„                MixesTillRepeat&=MixesTillRepeat&+1„            END IF„         'If we must loop in this pass, then mix whatever is left before„         'the loop, and then update our sample pointer to the start of „         'the loop.„            IF MixesLeftToDo >= MixesTillRepeat& THEN„„                MixesToDo      = MixesTillRepeat&„                MixesLeftToDo  = MixesLeftToDo - MixesToDo„„                'Mix whatever is left before the loop...„                GOSUB LowLevelMix„„               'Throw back our pointer to the loop start.„                IF C.LoopEnd(K)  = C.Length(K) THEN'If first time,setup„                    o            = C.RepStart(K)    'for next loop.„                    C.LoopEnd(K) = C.RepStart(K) + C.RepLength(K)„                ELSE„                    o            = o - C.RepLength(K)„                ENDIF„            ELSE„                EXIT DO 'Doesn't loop in this pass, just exit.„            END IF„        LOOP '<--Check again for VERY short loop lengths.„    END IF„„    'Mix whatever is left.„    MixesToDo = MixesLeftToDo„    Gosub LowLevelMix„„    'Store back the offset and its remainder.„    C.Offset(K) = o„    C.Remainder(K) = r„„'If sample doesn't loop, and the offset passed the end of the sample,„'then turn off the channel.„    IF C.RepLength(K) = 0 AND UnsignedComp(o, C.Length(K)) > 0 THEN„        C.InactiveFlag(K) = True„    END IF„RETURN„„LowLevelMix:„    'Copies the samples from the instruments to the mixing buffer.„    'If this is the first copy (Tm=0), then just store the sample,„    'otherwise add it into the buffer.„    If Tm=0 then„        'Since most channels will have a volume of 64 (max), then„        'only use the volume lookup table (which is slow) when needed.„        IF v <> 64 THEN„            FOR OffsetNow = OffsetNow TO OffsetNow + MixesToDo - 1„                SampleBuffer(OffsetNow) = VolumeTable(v, PEEK(o))„                o = o + h„                'If remainder overflows, then increment the offset by„                '1 and adjust the remainder back down.„                r = r + l: IF r => 0 THEN r = r - 256: o = o + 1„            NEXT„        ELSE„            FOR OffsetNow = OffsetNow TO OffsetNow + MixesToDo - 1„                SampleBuffer(OffsetNow) = PEEK(o)„                o = o + h„                r = r + l: IF r => 0 THEN r = r - 256: o = o + 1„            NEXT„        END IF„    ELSE„        'Since this isn't the first mix(Tm<>0), we must add in the new„        'samples into the buffer. Since each sample is already divided„        'by 4, we don't have to divide the sample buffer by 4 when we're„        'all done, to increase speed[(A+B+C+D)/4 = (A/4+B/4+C/4+D/4)].„        IF v <> 64 THEN„            FOR OffsetNow = OffsetNow TO OffsetNow + MixesToDo - 1„                SampleBuffer(OffsetNow) = SampleBuffer(OffsetNow)+_„VolumeTable(v, PEEK(o))„                o = o + h„                r = r + l: IF r => 0 THEN r = r - 256: o = o + 1„            NEXT„        ELSE„            FOR OffsetNow = OffsetNow TO OffsetNow + MixesToDo - 1„                SampleBuffer(OffsetNow)=SampleBuffer(OffsetNow)+_„PEEK(o)„                o = o + h„                r = r + l: IF r => 0 THEN r = r - 256: o = o + 1„            NEXT„        END IF„    END IF„RETURN„'=====================================================================„'Process the MOD sliding commands...„DoCommands:„    FOR A=0 TO 3„        IF C.Command(A) THEN„            SELECT CASE C.Command(A)„            CASE 1                      'Volume slide„                C.Volume(A)=C.Volume(A)+C.VolumeSpeed(A)„                IF C.Volume(A)<0 THEN„                    C.Volume(A)=0„                    C.Command(A)=0„                ELSEIF C.Volume(A)>64 THEN„                    C.Volume(A)=64„                    C.Command(A)=0„                END IF„            CASE 2                      'Port down„                C.Period(A) = C.Period(A) - C.PortSpeed(A)„                IF C.Period(A)<113 THEN„                    C.Period(A)  = 113„                    C.Command(A) = 0„                END IF„                C.HighStep(A)   = PeriodHigh(C.Period(A))„                C.LowStep(A)    = PeriodLow(C.Period(A))„            CASE 3                      'Port up„                C.Period(A) = C.Period(A) + C.PortSpeed(A)„                IF C.Period(A)>1023 THEN„                    C.Period(A) = 1023„                    C.Command(A) = 0„                END IF„                C.HighStep(A)   = PeriodHigh(C.Period(A))„                C.LowStep(A)    = PeriodLow(C.Period(A))„            CASE 4                      'Port to Note Down„                C.Period(A) = C.Period(A) - C.PortSpeed(A)„                IF C.Period(A) <= C.PortDest(A) THEN„                    C.Period(A) = C.PortDest(A)„                    C.Command(A) = 0„                END IF„                C.HighStep(A)   = PeriodHigh(C.Period(A))„                C.LowStep(A)    = PeriodLow(C.Period(A))„            CASE 5                      'Port to Note Up„                C.Period(A) = C.Period(A) + C.PortSpeed(A)„                IF C.Period(A) >= C.PortDest(A) THEN„                    C.Period(A) = C.PortDest(A)„                    C.Command(A) = 0„                END IF„                C.HighStep(A)   = PeriodHigh(C.Period(A))„                C.LowStep(A)    = PeriodLow(C.Period(A))„            END SELECT„        END IF„    NEXT„RETURN„'=====================================================================„'Allocates memory from DOS.„FUNCTION Alloc (A)„    CPU.ax = &H4800:CPU.bx = A„    CALL interruptx(&H21, CPU, CPU)„    IF (CPU.Flags AND 1) THEN ExitWithError "Out of Memory"„    Alloc = CPU.ax„END FUNCTION„'=====================================================================„SUB ExitWithError (A$)„    IF POS(0) <> 1 THEN PRINT„    PRINT A$: END„END SUB„'=====================================================================„'Extracts a Motorola word from a string, and multiples it by 2.„FUNCTION Extract% (A$, offset)„    v& = (512&*ASC(MID$(A$,offset,1))+ASC(MID$(A$,offset+1, 1))*2&)„    IF v& > 65535 THEN ExitWithError "Sample Too Large"„    IF v& > 32767 THEN v& = v& - 65536„    Extract% = v&„END FUNCTION„'=====================================================================„'Reprograms the 8255 timer so it hits an int 8 at a different rate.„SUB SetInt8Rate (A&)„    OUT &H42, 2 + 4 + 16 + 32„    OUT &H40, A& AND 255„    OUT &H40, A& \ 256„END SUB„'=====================================================================„SUB SpeakerOff„    OUT &H61, INP(&H61) AND 252„END SUB„'=====================================================================„SUB SpeakerOn„    OUT &H61,INP(&H61) OR 3:OUT &H43,128+32+16:OUT &H42,0„    OUT &H42,0:OUT &H43,128+16„END SUB„'=====================================================================„ErrorHandler:„    SELECT CASE ERR„    CASE 7„        ExitWithError "Out of Memory Error"„    CASE 52, 53, 68„        ExitWithError "Bad File Name/File not found"„    CASE ELSE„        ExitWithError "Fatal Error"+STR$(ERR)+" has occured!"„    END SELECT„'END OF QBMP16.BAS====================================================„„„„'---------8<-----[ Begin: QBMPASM.ASM - Assembler Code ]----->8----------„„'If you don't have any assembly compiles, then look at the following „'program QBMPASM.OBJ and compile using DEBUG„„;QBMPASM.ASM (Misc. ASM & PC-Speaker routines for QBMP16.BAS)„;Written by Rich Geldreich (C) Copyright November 27, 1992„;Assembled with TASM v2.0 (This module hasn't been documented yet.)„IDEAL„MODEL SMALL„CODESEG„PUBLIC  CheckDoneFlag, SetBuffers, GetCS, GetOF, UnsignedComp„EVEN„ASSUME cs:@CODE, ds:@CODE, es:NOTHING, ss:@DATA„;=====================================================================„Buffer1  dw 0„Buffer2  dw 0„DoneFlag db 0„XLATTable: ;PC-Speaker LOG table„db 32,31,30,29,28,27,26,25,24,24,23,23,22,22,21,21,21,20,20,20,19,19,19„db 18,18,18,18,17,17,17,17,16,16,16,16,15,15,15,15,14,14,14,14,14,13,13„db 13,13,13,12,12,12,12,12,11,11,11,11,11,11,10,10,10,10,10,10,9,9,9,9„db 9,9,8,8,8,8,8,8,7,7,7,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,4,4,4,4,4„db 4,4,3,3,3,3,3,3,3,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,65,65,65,65,65,65,65„db 64,64,64,64,64,64,64,63,63,63,63,63,63,63,62,62,62,62,62,62,62,61,61„db 61,61,61,61,61,60,60,60,60,60,60,60,59,59,59,59,59,59,59,58,58,58,58„db 58,58,57,57,57,57,57,57,56,56,56,56,56,56,55,55,55,55,55,55,54,54,54„db 54,54,53,53,53,53,53,52,52,52,52,52,51,51,51,51,50,50,50,50,49,49,49„db 49,48,48,48,48,47,47,47,46,46,46,45,45,45,44,44,43,43,42,42,41,40,39„db 38,37,36,35,34,33„;=====================================================================„EVEN„PROC    NewInt8„        Push    ds ax bx„BDS     = $+1„        Mov     ax, 09999h„        Mov     ds, ax„Offset8 = $+1„        Mov     bx, 09999h„        Mov     al, [ds:bx]„        Inc     bx„        Inc     bx„        Mov     [word cs:Offset8], bx„End8    = $+2„        Cmp     bx, 09999h„        Je      @@10„@@Back: Mov     bx, offset XLATTable„        Xlat    [cs:bx]„        Out     042h, al„        Mov     al, 020h„        Out     020h, al„        Pop     bx ax ds„        Iret„EVEN„@@10:   Mov     [byte cs:DoneFlag], -1„        Mov     bx, [cs:Buffer1]„        Xchg    bx, [cs:Buffer2]„        Mov     [cs:Buffer1], bx„        Mov     [word cs:Offset8], bx„BufferSize = $+2„        Add     bx, 09999h„        Mov     [word cs:End8], bx„        Jmp     @@Back„ENDP    NewInt8„;=====================================================================„EVEN„PROC    CheckDoneFlag„        Xor     al, al„        Xchg    [cs:DoneFlag], al„        Cbw„        Retf    0„ENDP    CheckDoneFlag„;=====================================================================„PROC    SetBuffers  ;BDS Buffer1 Buffer2 BufferSize„;                     12   10       8        6„        Push    bp„        Mov     bp, sp„        Push    ds cs„        Pop     ds„        Mov     ax, [ss:bp+8]„        Mov     [ds:Buffer2], ax„        Mov     ax, [ss:bp+12]„        Mov     [word ds:BDS], ax„        Mov     ax, [ss:bp+10]„        Mov     [ds:Buffer1], ax„        Mov     [word ds:Offset8], ax„        Mov     bx, [ss:bp+6]„        Mov     [word ds:BufferSize], bx„        Add     ax, bx„        Mov     [word ds:End8], ax„        Pop     ds bp„        Retf    8„ENDP    SetBuffers„;=====================================================================„PROC    GetCS„        Mov     ax, cs„        Retf    0„ENDP    GetCS„;=====================================================================„PROC    GetOF„        Mov     ax, offset NewInt8„        Retf    0„ENDP    GetOF„;=====================================================================„PROC    UnsignedComp„        Push    bp„        Mov     bp, sp„        Mov     ax, [ss:bp+08]„        Cmp     ax, [ss:bp+06]„        Jae     @@AboveOrEqual„        Xor     ax, ax„@@Back: Pop     bp„        Retf    4„@@AboveOrEqual:„        Mov     ax, 1„        Jmp     @@Back„ENDP    UnsignedComp„;=====================================================================„END„'---------8<-----[ End: QBMPASM.ASM - Assembler Code ]----->8----------„„„„'---------8<-----[ Begin: QBMPASM - DEBUG Code ]----->8----------„To execute this script, save it to a file and type DEBUG < filename„where "filename" is the name of this script file.„E165"QBMPASM.OBJ" 0„E200".q..92bMh/LMnpa9/BJHcVs5....IJbQWx46/BrQZpaMgJaQU.WJZ7rQdxaPU"„E23D"6X9kY9WH..EdTGEyZl0l7KPk3qQhtGEHpYA6C...ZCHK8...U4W1..EVGdZA."„E27A"E/TFJFMF3/1x2F3N7a5..Gc4U.12UOKm..3w3F/FJE2EIEI3YkMS..6/..2IE"„E2B7".DM70.M.F57pHJ/pWOG..4wj.P/73..E.BA2G3BoG2xYH3N2H/RYJ/.EKE4/."„E2F4".2U0HJ2J0JZF4JYIHxJ..gDYA.../IkF3FpEHhM..k3YA.../IkF3FpH4tM.."„E331"c3YH.../kEJCBJG5tIF2BoHB/ZY/.EA6G...7O.F08f/2..........UwV5Rk"„E36E"l4OY/4MQl3KMF3JI/3IEl2HAV2G6V2F2F2F./2E.l1Dwk1CsU1CsE1BoE1Bk."„E3AB"1Ak.19gk09gk08cU08cU07YE07YE06U.06U.05Qk/5Qk/5MU/4MU/4ME/3IE/"„E3E8"3IE/2E./2E./2Ak.1Ak.1AU.06U.06U./2E./2E./2EE/3IE/3IE./2E./2E."„E425"xnDzwnDzwXDysXDysXDxoHDxoHDxk1Dwk1DwknCvgnCvgnCucXCucXCtYHCtY"„E462"HCsU1CsU1CrQnBrQnBqMXBqMHBpIHBpE1BoE1BnAnAn6XAm6HAl2HAk.1Akwm"„E49F"9jsW9ioG9hk09fgW8eY08bMG7YAW6V.d5EB3iNadXMjPaNes/1BY97ul1/2sy"„E4DC"Na7REgP/.smpa92gUMC6PVp5D1d94P./.wj99u/..smVS6..iYc5..U97ul1/"„E519"2skNad97u/5/gymE81kiMc/2..a9LpWgvV1TgcF6Ae..gcFAAe0/gcF8A8..A"„E556"u1/gcL4Yc5A3k.1D85/wFL8X..AWwmsOE.9LpWgjcF6gXF4Ab/n.QL8H..s4."„E593".fTzvQ42.3X/J/IQ6I3ElnEJ.3b1J/IgDI3El1FJ.3X2J/IQII3ElPFJ.3b4J"„E5D0"/IwPI3ElpFJ.3X5J/IwTI3El2GJ.3z6J/6VW0...o/"„E100 B8 0 3C BA 65 1 33 C9 CD "!rC" BE 0 2 50 BD FB 2 55 BF 88 90„E117 "W3" DB B1 FA 8A F0 80 C1 6 32 E4 AC "<9v" 8 "<Zv" 2 2C 6 2C„E12F 7 2C 2E E3 E8 D3 E0 A C6 AA 2 D8 92 "IIMu" E0 80 FB 0 75 9 5A„E147 59 5B B4 40 CD 21 73 7 B4 9 BA 58 1 CD 21 CD 20 7 "Error!$"„G„Q„ „        I have spent _many_ months optimizing my MOD playing„algorithms so they would be efficient enough to do in almost all„QB.  On my 286/10, I've rated it to use about 95% processor time at„11,000 hertz.  This may not sound like much, but the all-assembler„version of this algorithm(which is used in my first demo that we„will be releasing under Renaissance) is extremely efficient - it can„play any MOD up to 65,535 hertz on my 286/10 (and still have about„25% processor time remaining!).  This test was done on my Tandy's„DMA DAC, which can play at very high sample rates.„Unknown Author(s)              MUSICAL ORGAN SIMULATOR        MUSICAL,ORGAN,SIMULATOR        Unknown Date (00:00)   QB, QBasic, PDS        160  6735     ORGAN.BAS   10 '----------- MUSICAL ORGAN SIMULATION ------------„30 '„40 KEY OFF: CLS : LOCATE , 25„50 DEFINT A-Z„60 PRINT CHR$(14); " MUSICAL ORGAN SIMULATION "; CHR$(14)„70 PRINT„72 '„75 '----------- PUT UP VIDEO DISPLAY --------------„77 '„80 PRINT "THIS PROGRAM ALLOWS YOUR COMPUTER TO MIMIC ";„90 PRINT "IN A SIMPLE WAY THE OPERATION OF"„100 PRINT "A MUSICAL ORGAN. ALTHOUGH THE PC IS ";„110 PRINT "OBVIOUSLY NO MATCH FOR A $250,000 PIPE"„120 PRINT "ORGAN, IT CAN PRODUCE A VARIETY OF ENTER";„130 PRINT "TAINING SOUNDS. THE TOP ROW OF KEYS"„140 PRINT "SPANS C5-C6, THE SECOND ROW C4-C5. HITTING";„150 PRINT " THE SPACEBAR SHIFTS ALL KEYS UP OR"„160 PRINT "DOWN ONE OCTAVE FOR A TOTAL RANGE OF C4-C7. TREMOLO ";„170 PRINT "CAN BE TURN ON OR OFF BY"„180 PRINT "PRESSING THE CARRIAGE RETURN, WHILE NOTE ";„190 PRINT "DURATION CAN BE ADJUSTED IN 0.1-SEC."„200 PRINT "INCREMENTS BY MEANS OF THE < AND > ";„210 PRINT "KEYS (UNSHIFTED).";„230 H$ = STRING$(3, 205): T$ = CHR$(196)„240 X$ = CHR$(179): F$ = STRING$(3, 196)„250 LOCATE 11, 32: PRINT "KEY ASSIGNMENTS";„260 LOCATE 12, 13: PRINT CHR$(201);„270 FOR I = 1 TO 12: PRINT H$; CHR$(209); : NEXT„280 PRINT H$; CHR$(187);„290 LOCATE 13, 13: PRINT CHR$(186);„310 PRINT TAB(65); CHR$(186);„320 LOCATE 14, 13: PRINT CHR$(204);„330 FOR I = 1 TO 12: PRINT H$; CHR$(216); : NEXT„340 PRINT H$; CHR$(185)„350 LOCATE 15, 13: PRINT CHR$(186);„370 PRINT TAB(65); CHR$(186);„380 LOCATE 16, 13: PRINT CHR$(199);„390 FOR I = 1 TO 12: PRINT F$; CHR$(197); : NEXT„400 PRINT F$; CHR$(182);„410 LOCATE 17, 13: PRINT CHR$(186);„430 PRINT TAB(65); CHR$(186);„440 LOCATE 18, 13: PRINT CHR$(200);„450 FOR I = 1 TO 12: PRINT H$; CHR$(207); : NEXT„460 PRINT H$; CHR$(188);„470 LOCATE 13, 15„480 PRINT "C"; TAB(19); "C#"; TAB(23); "D"; TAB(27); "D#";„490 PRINT TAB(31); "E"; TAB(35); "F"; TAB(39); "F#";„500 PRINT TAB(43); "G"; TAB(47); "G#"; TAB(51); "A";„510 PRINT TAB(55); "A#"; TAB(59); "B"; TAB(63); "C";„520 LOCATE 15, 14: PRINT "ESC";„530 FOR I = 1 TO 9: PRINT TAB(4 * I + 15); CHR$(I + 48); : NEXT„540 PRINT TAB(55); "0"; TAB(59); "-"; TAB(63); "=";„550 LOCATE 17, 14„560 PRINT "TAB"; TAB(19); "Q"; TAB(23); "W"; TAB(27); "E";„570 PRINT TAB(31); "R"; TAB(35); "T"; TAB(39); "Y";„580 PRINT TAB(43); "U"; TAB(47); "I"; TAB(51); "O";„590 PRINT TAB(55); "P"; TAB(59); "["; TAB(63); "]";„591 FOR I = 17 TO 61 STEP 4: LOCATE 13, I: PRINT X$; : NEXT„592 FOR I = 17 TO 61 STEP 4: LOCATE 15, I: PRINT X$; : NEXT„593 FOR I = 17 TO 61 STEP 4: LOCATE 17, I: PRINT X$; : NEXT„594 LOCATE 20, 1: PRINT CHR$(218); STRING$(5, 196); CHR$(191);„595 PRINT TAB(72); CHR$(218); STRING$(7, 196); CHR$(191);„596 LOCATE 21, 1: PRINT X$; "SHIFT"; X$; TAB(72); X$; "TREMOLO"; X$;„597 LOCATE 22, 1: PRINT CHR$(192); STRING$(5, 196); CHR$(217);„598 PRINT TAB(72); CHR$(192); STRING$(7, 196); CHR$(217);„600 LOCATE 20, 30„610 FOR I = 1 TO 9: PRINT TAB(2 * I + 28); CHR$(48 + I); : NEXT„615 PRINT TAB(48); "10";„620 LOCATE 20, 38: COLOR 31, 0: PRINT "5"; : COLOR 7, 0„630 LOCATE 21, 30: PRINT CHR$(212);„640 FOR I = 1 TO 8: PRINT CHR$(205); CHR$(207); : NEXT„650 PRINT CHR$(205); CHR$(190);„660 LOCATE 22, 31: PRINT CHR$(27); " NOTE DURATION "; CHR$(26);„670 LOCATE 25, 15: PRINT "* WHEN YOU HAVE FINISHED, PRESS ";„680 PRINT "B TO ENTER BASIC *";„690 '„700 '---------------- INITIALIZE -------------------„710 '„720 TREMOLO = 1 ' 1=TREMOLO OFF, -1=TREMOLO ON„730 SHIFT = 1   ' 1=NO SHIFT, 2=UPWARD SHIFT OF ONE OCTAVE„740 B = 5: D = 9' CORRESPOND TO 0.5-SEC. INITIALIZE DURATION„750 PLAY "MB"   ' SET UP BUFFER FOR NOTES„760 '„770 '----------- LOOP TO READ KEYBOARD -------------„780 '„800 V$ = INPUT$(1)„810 IF V$ = CHR$(27) THEN F = 523: GOSUB 2000: GOTO 800„820 IF V$ = "1" THEN F = 554: GOSUB 2000: GOTO 800„830 IF V$ = "2" THEN F = 587: GOSUB 2000: GOTO 800„840 IF V$ = "3" THEN F = 622: GOSUB 2000: GOTO 800„850 IF V$ = "4" THEN F = 659: GOSUB 2000: GOTO 800„860 IF V$ = "5" THEN F = 698: GOSUB 2000: GOTO 800„870 IF V$ = "6" THEN F = 740: GOSUB 2000: GOTO 800„880 IF V$ = "7" THEN F = 784: GOSUB 2000: GOTO 800„890 IF V$ = "8" THEN F = 831: GOSUB 2000: GOTO 800„900 IF V$ = "9" THEN F = 880: GOSUB 2000: GOTO 800„910 IF V$ = "0" THEN F = 932: GOSUB 2000: GOTO 800„920 IF V$ = "-" THEN F = 988: GOSUB 2000: GOTO 800„930 IF V$ = "=" THEN F = 1047: GOSUB 2000: GOTO 800„935 IF V$ = CHR$(9) THEN F = 262: GOSUB 2000: GOTO 800„940 IF V$ = "q" OR V$ = "Q" THEN F = 277: GOSUB 2000: GOTO 800„950 IF V$ = "w" OR V$ = "W" THEN F = 294: GOSUB 2000: GOTO 800„960 IF V$ = "e" OR V$ = "E" THEN F = 311: GOSUB 2000: GOTO 800„970 IF V$ = "r" OR V$ = "R" THEN F = 330: GOSUB 2000: GOTO 800„980 IF V$ = "t" OR V$ = "T" THEN F = 349: GOSUB 2000: GOTO 800„990 IF V$ = "y" OR V$ = "Y" THEN F = 370: GOSUB 2000: GOTO 800„1000 IF V$ = "u" OR V$ = "U" THEN F = 392: GOSUB 2000: GOTO 800„1010 IF V$ = "i" OR V$ = "I" THEN F = 415: GOSUB 2000: GOTO 800„1020 IF V$ = "o" OR V$ = "O" THEN F = 440: GOSUB 2000: GOTO 800„1030 IF V$ = "p" OR V$ = "P" THEN F = 466: GOSUB 2000: GOTO 800„1040 IF V$ = "[" OR V$ = "{" THEN F = 494: GOSUB 2000: GOTO 800„1050 IF V$ = "]" OR V$ = "}" THEN F = 523: GOSUB 2000: GOTO 800„1060 IF V$ = CHR$(32) THEN GOSUB 2500: GOTO 800'SHIFT W/SPACEBAR„1065 '   IN LINE BELOW < AND > CAUSE DURATION TO BE SET„1070 IF V$ = CHR$(44) OR V$ = CHR$(46) THEN GOSUB 3000: GOTO 800„1080 IF V$ = CHR$(13) THEN GOSUB 3500: GOTO 800'CR=TREMOLO ON/OFF„1090 IF V$ = "b" OR V$ = "B" THEN CLS : END„1110 GOTO 800„1120 END„1130 '„1140 '--------- SUBROUTINE TO SOUND A NOTE ---------„1150 '„1155 '„2000 SOUND 100, 0: F = F * SHIFT„2010 IF TREMOLO = 1 THEN SOUND F, D: RETURN„2015 N = .33 * D: IF N < 1 THEN N = 1„2020 DELTA = .012 * F: F1 = F + DELTA: F2 = F - DELTA„2025 '--- TREMOLO LOOP ---„2030 FOR I = 1 TO N„2040    SOUND F1, 1: SOUND F, 1: SOUND F2, 1„2050 NEXT I„2060 RETURN„2470 '„2480 '---- SUBROUTINE TO SET OCTAVE-SHIFT FLAG -----„2490 '„2500 SHIFT = INT(1 + (1 / SHIFT))„2510 IF SHIFT = 1 THEN COLOR 7, 0 ELSE COLOR 0, 7„2520 LOCATE 21, 2: PRINT "SHIFT": COLOR 7, 0„2530 RETURN„2970 '„2980 '----- SUBROUTINE TO SET NOTE DURATION -------„2990 '„3000 C = B: IF V$ = CHR$(46) THEN B = B + 1 ELSE B = B - 1„3010 IF B > 10 THEN B = 10„3020 IF B < 1 THEN B = 1„3030 LOCATE 20, (2 * C + 28)„3035 IF C < 10 THEN PRINT CHR$(C + 48) ELSE PRINT "10"„3040 COLOR 31, 0: LOCATE 20, (2 * B + 28)„3050 IF B < 10 THEN PRINT CHR$(B + 48) ELSE PRINT "10"„3060 COLOR 7, 0: D = B * 1.8„3070 RETURN„3470 '„3480 '----- SUBROUTINE TO SET TREMOLO FLAG ----------„3490 '„3500 TREMOLO = -TREMOLO„3510 IF TREMOLO = 1 THEN COLOR 7, 0 ELSE COLOR 0, 7„3520 LOCATE 21, 73: PRINT "TREMOLO": COLOR 7, 0„3530 RETURN„„„Unknown Author(s)              SB VOC PLAYER                  SB,VOC,PLAYER                  Unknown Date (00:00)   QB, PDS                64   2136     VOCPLAY.BAS ' .VOC Player„' Edit VocFile$ to your desired file & directory„„DECLARE SUB SetVoice (OnOff%)„„'Set this to directory where VOC files are stored.„„'-Div.Init (maybe you get the filename from commandline?„  VocFile$ = "QBSND\RUSH.VOC"        ' input-file„  VocFile% = FREEFILE             ' .„  Delay% = 125                      ' value for delay„„'-open the voc-file„  OPEN VocFile$ FOR BINARY AS #VocFile%„„'-parameters for copy-to-soundblaster„  Bytes& = LOF(VocFile%)          ' number of bytes„  BytesRemaining& = Bytes&        ' number of remaining bytes„  BufferMax% = &H7F00             ' largest buffer„  Buffer$ = SPACE$(BufferMax%)    ' create buffer„„  SetVoice 1                      ' Soundblaster on„„'-read {BufferMax%} bytes from disc, output on SB„  DO„     BytesRemaining& = BytesRemaining& - BufferLen%„     IF BytesRemaining& = 0 THEN EXIT DO ' nothing left over?„     IF BytesRemaining& > BufferMax% THEN ' how many bytes?„        BufferLen% = BufferMax%          '„     ELSE„        BufferLen% = BytesRemaining&     ' remaining (<BufferMax%)..„        Buffer$ = SPACE$(BufferLen%)     ' ..throw it into SB :-)„     END IF„     '„     GET #VocFile%, , Buffer$            ' read buffer„     DEF SEG = VARSEG(Buffer$)             ' get address of buffer„     VOff% = SADD(Buffer$)               ' .„     '„„     FOR t% = 1 TO BufferLen%            ' output od {bufferlen%}„         FOR qq% = 1 TO Delay: NEXT qq% ' delay„         WAIT &H22C, &H80, &HFF         ' wait for data-ready„         OUT &H22C, &H10„         WAIT &H22C, &H80, &HFF„         OUT &H22C, PEEK(VOff%)„         VOff% = VOff% + 1„     NEXT t%„     '„  LOOP WHILE INKEY$ = ""„„  SetVoice 0                            ' SB off„  CLOSE #VocFile%                       ' close file„  END                                   ' .. good bye :-)„„SUB SetVoice (OnOff%)„    IF OnOff% THEN„       WAIT &H22C, &H80, &HFF       ' wait for data-ready on SB„       OUT &H22C, &HD1              ' ON„    ELSE„       WAIT &H22C, &H80, &HFF„       OUT &H22C, &HD3              ' OFF„    END IF„END SUB„„Charles Graham                 PIANO NOTES                    PIANO,NOTES                    Unknown Date (00:00)   QB, QBasic, PDS        68   1495     PITCH.BAS   '> How can I calculate all the notes on„'> a piano (Notes 1-84)?„'„REM PITCH.BAS by Charles Graham„' There are 88 keys on a standard piano keyboard.„' This program lists the approximate Cycles-Per-Second„' for each piano key and plays the tone.„DIM keyno$(12)„FOR x = 1 TO 12„    READ keyno$(x)„NEXT x„keyno = 1„mult = 1.059463„pitch = 27.5„CLS„COLOR 15, 1„PRINT STRING$(17, "-");„PRINT " Piano Note Frequencies ";„PRINT STRING$(17, "-")„PRINT "Key #", "Note", "  CPS", "Comments        "„LOCATE 25, 1„PRINT SPACE$(18);„PRINT "Press a key to continue";„PRINT SPACE$(18);„COLOR 12, 0„LOCATE 3, 1„VIEW PRINT 3 TO 24„DO„    PRINT USING " ##"; keyno;„    PRINT ,„    note = note + 1„    IF note > 12 THEN„        note = 1„    END IF„    PRINT keyno$(note),„    IF keyno$(note) = "A" AND pitch >= 37 THEN„        pitch = INT(pitch + .5)„    END IF„    PRINT USING "####.##"; pitch;„    IF keyno = 40 THEN„        PRINT , "Middle C";„    END IF„    IF pitch >= 37 THEN„        SOUND pitch, 4„        PRINT„    ELSE„        PRINT , "Too low to sound"„    END IF„    keyno = keyno + 1„    pitch = pitch * mult„    DO„        a$ = INKEY$„    LOOP UNTIL LEN(a$)„LOOP UNTIL keyno > 88„VIEW PRINT 1 TO 25„LOCATE 25, 1„COLOR 15, 1„PRINT SPACE$(20);„PRINT "Press a key to end";„PRINT SPACE$(21);„DO„    a$ = INKEY$„LOOP UNTIL LEN(a$)„COLOR 7, 0„CLS„END„DATA "A", "A#/Bb", "B", "C", "C#/Db", "D"„DATA "D#/Eb", "E", "F", "F#/Gb", "G", "G#/Ab"„Unknown Author(s)              THEME SONGS (POPEYE)           THEME,SONGS,POPEYE             Unknown Date (00:00)   QB, QBasic, PDS        20   723      POPEYE.BAS  ' > Do you happen by chance to have the theme„' > from Popeye or........„„'Popeye„PLAY "MNT150L8O3EGGGL4FL8EL2GP8L8GAFAL4>CL8<AL2GP8L8GAFA>C<B"„PLAY "AGAGECEGGGL4AL8BL2>C."„„'Looney Tunes„PLAY "MST200L8O3E.L16DL8CDED+ECDDDL2D.L8D.L16CL8<B>CDC+D<B>C"„PLAY "CCL2C.L8<G.L16G+L8A.L16G+L8G.L16G+L8A.L16G+L8G>DDL2D."„PLAY "L8<AG+AL4>DEL2G"„„'Theme from The Old Star Trek„PLAY "MNT255L1O4B.D.F.<A.P8L2GL8G>C.L2FFL4E.L8EL4C<A>DL2GP8"„PLAY "L4GL1BP4L2CL8CF.L2A+A+L4A.L8AL4FDGL2>CP8L4CL1EP1L2O3G"„PLAY ">F.L4EDC<BL2A+L1A+L2G>G.L4FEDCL2<BL1BL4A+L2A.L4B>C+DE"„PLAY "F+GL2AL1A+.L2<A+.L4>CDD+FGG+L2A+L1BL2<G>F.L4EDC<BL2A+"„PLAY "L1A+L4G+L2G>G.L4FEDCL2<BL1BL4A+L2A.L4B>CDEFEL2G.L4GL2A+."„PLAY "L4AL2GL1CL4D.F.A.L1>C"„„Mark H. Butler                 SPACE MUSIC (TWILIGHTZONE)     SPACE,MUSIC,TWILIGHTZONE       10-01-92 (15:40)       QB, QBasic, PDS        72   1818     SPACEMUS.BASDEFINT A-Z„DECLARE SUB PhotonTorpedoe ()„DECLARE SUB SpaceMusic ()„DECLARE SUB TwiLightZoNe ()„„SUB PhotonTorpedoe„    DIM A$(1 TO 25), Di$(1 TO 6)„    PLAY "mfl64t255"„    Pl$ = "cc#dd#eff#gg#aa#b"„    FOR i = 1 TO 6„        Di$(i) = "o" + RTRIM$(STR$(i))„    NEXT„    FOR i = 1 TO 6„        FOR T = 1 TO 2„            PLAY Di$(i)„            PLAY Pl$„        NEXT T„    NEXT i„END SUB„„SUB SpaceMusic„    FOR Rounds = 1 TO 2„        FOR w = 800 TO 500 STEP -100„            FOR x = 700 TO 400 STEP -100„                FOR y = 600 TO 300 STEP -100„                    FOR z = 400 TO 200 STEP -100„                        SOUND w, .3: SOUND x, .3„                        SOUND y, .3: SOUND z, .3„                    NEXT z„                NEXT y„            NEXT x„        NEXT w„    NEXT Rounds„END SUB„„SUB TwiLightZoNe„    Count = 0„    FOR Snd = 500 TO 100 STEP -200„        SOUND Snd, 4„    NEXT Snd„    FOR Bloops = 1 TO 42„        Snnd = (RND * 2400)„        IF Snnd < 37 OR Snnd > 3700 THEN Snnd = 250„        Snd = (RND * 66) + 37„        IF Count = 6 THEN SOUND Snnd, 3: Count = 0„        SOUND Snd, 4„        Count = Count + 1„    NEXT Bloops„    FOR Snd = 100 TO 500 STEP 200„        SOUND Snd, 4„    NEXT Snd„    FOR x = 1 TO 3„        FOR y = 1 TO 3„            SOUND 1050, .13: SOUND 1350, 3.5„            SOUND 1150, .13: SOUND 1450, 3.5„            SOUND 1050, .13: SOUND 1350, 3.5„            SOUND 850, .13: SOUND 1150, 3.5„        NEXT y„        FOR z = 1 TO 5„            Svd = (RND * 550) + 37„            SOUND Svd, 1.7„        NEXT z„    NEXT x„    FOR i = 1 TO 5„        Svd = (RND * 550) + 37„        SOUND Svd, 1.7„    NEXT i„    FOR Snd = 175 TO 37 STEP -10„        SOUND Snd, 1„    NEXT Snd„    SOUND 37, 10„END SUB„Gary Pool                      HELIAS FIGHT MUSIC             HELIAS,FIGHT,MUSIC             Year of 1992 (00:00)   QB, QBasic, PDS        78   4277     HELIAS.BAS  'I saw that a few folks were interested in music.  Here's a little ditty„'I came up with for our local Catholic High School students to„'distribute.  It's the school fight song.  Any similarities between this„'and the fight song for a certain Catholic College located in Indiana is„'purely intentional.  Oh, by the way, the school colors are gold and„'blue.  Gosh, this is an old program.  I had just gotten QB 4.0 and„'wasn't used to NOT using line numbers.„'„10  'Helias Fight Song courtesy of Gary Pool„20  CLEAR : COLOR 14, 1: CLS : R = 8: COLOR 1, 14„30  C1 = 1: C2 = 9: C3 = 17: C4 = 29: C5 = 37: C6 = 45: C7 = 57„    C8 = 65: C9 =73„40  O2$ = "MFT200O2": O3$ = "MFT200O3"„50  PLAY O3$ + "L4CL8CCL4CCCCO2BB-"„60  PLAY O2$ + "L1A": LOCATE R, C1: PRINT "Cheer,  "„70  PLAY O2$ + "L2A-": LOCATE R, C3: PRINT "Cheer   "„80  PLAY O2$ + "L2A": LOCATE R, C4: PRINT "for     "„90  PLAY O2$ + "L4B-": LOCATE R, C6: PRINT "He -    "„100 PLAY O2$ + "L2B-": LOCATE R, C7: PRINT "li -    "„110 PLAY O2$ + "L4A": LOCATE R, C8: PRINT "as      "„120 PLAY O2$ + "L1B-": LOCATE R, C9: PRINT "High    ": R = R + 1„130 PLAY O2$ + "L4B-": LOCATE R, C1: PRINT "We're   "„140 PLAY O2$ + "L2B-": LOCATE R, C3: PRINT "out     "„150 PLAY O2$ + "L4B-": LOCATE R, C4: PRINT "to      "„160 PLAY O2$ + "L2A": LOCATE R, C6: PRINT "win     "„170 PLAY O2$ + "L2B-": LOCATE R, C7: PRINT "or      ": R = R + 1„180 PLAY O3$ + "L4C": LOCATE R, C1: PRINT "fight   "„190 PLAY O3$ + "L2C": LOCATE R, C3: PRINT "till    "„200 PLAY O2$ + "L4B": LOCATE R, C4: PRINT "we      "„210 PLAY O3$ + "L1C": LOCATE R, C6: PRINT "die!    "„220 PLAY O3$ + "L2D": LOCATE R, C7: PRINT "Send    ": R = R + 1„230 PLAY O3$ + "L2F": LOCATE R, C1: PRINT "a       "„240 PLAY O3$ + "L2E": LOCATE R, C3: PRINT "cheer   "„250 PLAY O3$ + "L2D": LOCATE R, C4: PRINT "for     "„260 PLAY O3$ + "L2C": LOCATE R, C6: PRINT "school's"„270 PLAY O2$ + "L2A": LOCATE R, C7: PRINT "dear    ": R = R + 1„280 PLAY O2$ + "L1F": LOCATE R, C1: PRINT "name,   "„290 PLAY O2$ + "L4A": LOCATE R, C3: PRINT "we're   "„300 PLAY O2$ + "L2G": LOCATE R, C4: PRINT "out     "„310 PLAY O2$ + "L4F+": LOCATE R, C6: PRINT "to      "„320 PLAY O2$ + "L2A": LOCATE R, C7: PRINT "fight   ": R = R + 1„330 PLAY O2$ + "L2G": LOCATE R, C1: PRINT "and     "„340 PLAY O2$ + "L4F+": LOCATE R, C2: PRINT "win     "„350 PLAY O2$ + "L2G": LOCATE R, C3: PRINT "the     "„360 PLAY O3$ + "L1C": LOCATE R, C4: PRINT "game.   "„370 PLAY O2$ + "L4A": LOCATE R, C5: PRINT "We      "„380 PLAY O2$ + "L2A": LOCATE R, C6: PRINT "ne -    "„390 PLAY O2$ + "L4A": LOCATE R, C7: PRINT "ver     "„400 PLAY O2$ + "L2G+": LOCATE R, C8: PRINT "fal -   "„410 PLAY O2$ + "L2A": LOCATE R, C9: PRINT "ter,    ": R = R + 1„420 PLAY O2$ + "L4B-": LOCATE R, C1: PRINT "we      "„430 PLAY O2$ + "L2B-": LOCATE R, C3: PRINT "ne -    "„440 PLAY O2$ + "L4A": LOCATE R, C4: PRINT "ver     "„450 PLAY O2$ + "L1B-": LOCATE R, C6: PRINT "fall    "„460 PLAY O2$ + "L4B-": LOCATE R, C9: PRINT "He -    ": R = R + 1„470 PLAY O2$ + "L2B-": LOCATE R, C1: PRINT "li -    "„480 PLAY O2$ + "L4B-": LOCATE R, C3: PRINT "as      "„490 PLAY O2$ + "L2A": LOCATE R, C4: PRINT "High    "„500 PLAY O2$ + "L2B-": LOCATE R, C6: PRINT "will    "„510 PLAY O3$ + "L4C": LOCATE R, C9: PRINT "win     ": R = R + 1„520 PLAY O3$ + "L2C": LOCATE R, C1: PRINT "o -     "„530 PLAY O2$ + "L4B": LOCATE R, C3: PRINT "ver     "„540 PLAY O3$ + "L1C": LOCATE R, C4: PRINT "all     "„550 PLAY O3$ + "L2D": LOCATE R, C6: PRINT "while   "„560 PLAY O3$ + "L2F": LOCATE R, C9: PRINT "our     ": R = R + 1„570 PLAY O3$ + "L2E": LOCATE R, C1: PRINT "loy -   "„580 PLAY O3$ + "L2D": LOCATE R, C3: PRINT "al      "„590 PLAY O3$ + "L2C": LOCATE R, C4: PRINT "teams   "„600 PLAY O2$ + "L2A": LOCATE R, C6: PRINT "are     "„610 PLAY O2$ + "L2F": LOCATE R, C9: PRINT "march - ": R = R + 1„620 PLAY O2$ + "L2G": LOCATE R, C1: PRINT "ing     "„630 PLAY O2$ + "L4A": LOCATE R, C3: PRINT "on -    "„640 PLAY O3$ + "L2C": LOCATE R, C4: PRINT "ward    "„650 PLAY O2$ + "L4B-": LOCATE R, C6: PRINT "to      "„660 PLAY O2$ + "L2A": LOCATE R, C7: PRINT "vic -   "„670 PLAY O2$ + "L2G": LOCATE R, C8: PRINT "to -    "„680 PLAY O2$ + "L1F": LOCATE R, C9: PRINT "ry!     "„690 END: SYSTEM„Sunny Hughes                   GUNS 'N ROSES SONG             GUNS,ROSES                     09-28-92 (00:00)       QB, QBasic, PDS        22   660      GUNSROSE.BAS'Example of how to play music with the SOUND statement for QB45„'and QBASIC„'GUNS & ROSES (Sweet Child O' Mine) Public Domain 9-28-92„' Sunny Hughes„SOUND 284, 3 : SOUND 586, 3„SOUND 426, 3 : SOUND 379, 3„SOUND 758, 3 : SOUND 426, 3„SOUND 716, 3 : SOUND 426, 3„SOUND 284, 3 : SOUND 568, 3„SOUND 426, 3 : SOUND 379, 3„SOUND 758, 3 : SOUND 426, 3„SOUND 716, 3 : SOUND 426, 3„SOUND 319, 3 : SOUND 568, 3„SOUND 426, 3 : SOUND 379, 3„SOUND 758, 3 : SOUND 426, 3„SOUND 716, 3 : SOUND 426, 3„SOUND 319, 3 : SOUND 568, 3„SOUND 426, 3 : SOUND 379, 3„SOUND 758, 3 : SOUND 426, 3„SOUND 716, 3 : SOUND 426, 3„SOUND 379, 3 : SOUND 568, 3„SOUND 426, 3„KrisJanis Gale                 THE MUSIC COMPOSER             MUSIC,COMPOSER                 Unknown Date (00:00)   QB, QBasic, PDS        288  6779     MUSCOMP.BAS DECLARE SUB Instructions ()„DECLARE SUB MusicConfig ()„DECLARE SUB SaveFile (PlayIt$)„DECLARE SUB LoadFile (PlayIt$, found$)„DECLARE SUB ComposeMusic (PlayIt$)„DO„CLS„PRINT "The MusicComposer"„PRINT "Programmed by Krisjanis 'The Hacker' Gale"„PRINT„PRINT "Type:": PRINT„PRINT "1) To get instructions."„PRINT "2) To compose a new music."„PRINT "3) To replay newly made or loaded music."„PRINT "4) To save music currently in memory."„PRINT "5) To load previously composed music from a file."„PRINT "6) To Quit.": PRINT„LOCATE 23, 1„PRINT "Press number of selection..."„DO„LET in$ = INKEY$„LOOP WHILE in$ = ""„SELECT CASE in$„CASE "1"„  CALL Instructions„CASE "2"„  IF PlayIt$ <> "" THEN„    CLS„    INPUT "Erase what exists?(y/n)...>", erase$„    IF erase$ = "y" THEN„      CLS„      LET PlayIt$ = ""„      CALL ComposeMusic(PlayIt$)„    END IF„    IF erase$ = "n" THEN„      INPUT "Add on to what exists?(y/n)...>", addon$„      IF addon$ = "y" THEN„        CLS„        PRINT PlayIt$„        CALL ComposeMusic(PlayIt$)„      END IF„    END IF„  ELSE„    CLS„    CALL ComposeMusic(PlayIt$)„  END IF„CASE "3"„  CLS„  INPUT "Loop music indefinately?(y/n)...>", yesno$„  IF yesno$ = "y" THEN„    PRINT "Press ESC to stop music loop."„    DO„      PLAY PlayIt$„    LOOP UNTIL INKEY$ = CHR$(27)„  END IF„  IF yesno$ = "n" THEN„    PLAY PlayIt$„  END IF„CASE "4"„  CALL SaveFile(PlayIt$)„CASE "5"„  CALL LoadFile(PlayIt$, found$)„CASE "6"„  LOCATE 22, 1„  PRINT "Thanks for using my program."„  PRINT "                 --Krisjanis 'The Hacker' Gale--"„  SLEEP 1„END SELECT„LOOP UNTIL in$ = "6"„END„„SUB ComposeMusic (PlayIt$)„PRINT "Play!"„DO„SLEEP„LET in$ = INKEY$„SELECT CASE in$„CASE "a"„  PLAY "c"„  PRINT "C ";„  LET PlayIt$ = PlayIt$ + "c"„CASE "w"„  PLAY "c#"„  PRINT "C# ";„  LET PlayIt$ = PlayIt$ + "c#"„CASE "s"„  PLAY "d"„  PRINT "D ";„  LET PlayIt$ = PlayIt$ + "d"„CASE "e"„  PLAY "e-"„  PRINT "E- ";„  LET PlayIt$ = PlayIt$ + "e-"„CASE "d"„  PLAY "e"„  PRINT "E ";„  LET PlayIt$ = PlayIt$ + "e"„CASE "f"„  PLAY "f"„  PRINT "F ";„  LET PlayIt$ = PlayIt$ + "f"„CASE "t"„  PLAY "f#"„  PRINT "F# ";„  LET PlayIt$ = PlayIt$ + "f#"„CASE "g"„  PLAY "g"„  PRINT "G ";„  LET PlayIt$ = PlayIt$ + "g"„CASE "y"„  PLAY "a-"„  PRINT "A- ";„  LET PlayIt$ = PlayIt$ + "a-"„CASE "h"„  PLAY "a"„  PRINT "A ";„  LET PlayIt$ = PlayIt$ + "a"„CASE "u"„  PLAY "b-"„  PRINT "B- ";„  LET PlayIt$ = PlayIt$ + "b-"„CASE "j"„  PLAY "b"„  PRINT "B ";„  LET PlayIt$ = PlayIt$ + "b"„CASE "k"„  PLAY ">c<"„  PRINT "HiC ";„  LET PlayIt$ = PlayIt$ + ">c<"„CASE ","„  PRINT "1/12 note "„  PLAY "l6"„  LET PlayIt$ = PlayIt$ + "l6"„CASE "."„  PRINT "3/2 len. ";„  LET PlayIt$ = PlayIt$ + "."„CASE "["„  PLAY "<"„  PRINT "OctvDn ";„  LET PlayIt$ = PlayIt$ + "<"„CASE "]"„  PLAY ">"„  PRINT "OctvUp ";„  LET PlayIt$ = PlayIt$ + ">"„CASE "p"„  PLAY "n0"„  PRINT "Pause ";„  LET PlayIt$ = PlayIt$ + "n0"„CASE "1"„  PLAY "l1"„  PRINT "Whole ";„  LET PlayIt$ = PlayIt$ + "l1"„CASE "2"„  PLAY "l2"„  PRINT "Half ";„  LET PlayIt$ = PlayIt$ + "l2"„CASE "3"„  PLAY "l4"„„  PRINT "Quarter ";„  LET PlayIt$ = PlayIt$ + "l4"„CASE "4"„  PLAY "l8"„  PRINT "Eighth ";„  LET PlayIt$ = PlayIt$ + "l8"„CASE "5"„  PLAY "l16"„  PRINT "Sixteenth ";„  LET PlayIt$ = PlayIt$ + "l16"„CASE "6"„  PLAY "l32"„  PRINT "Thirty-Second ";„  LET PlayIt$ = PlayIt$ + "l32"„CASE "7"„  PLAY "l64"„  PRINT "Sixty-Fourth ";„  LET PlayIt$ = PlayIt$ + "l64"„CASE "8"„  PLAY "ms"„  PRINT "Staccato ";„  LET PlayIt$ = PlayIt$ + "ms"„CASE "9"„  PLAY "mn"„  PRINT "Normal ";„  LET PlayIt$ = PlayIt$ + "mn"„CASE "0"„  PLAY "ml"„  PRINT "Lengato ";„  LET PlayIt$ = PlayIt$ + "ml"„CASE "="„  INPUT "Octave(0-6)...>", octave„  PLAY "o" + STR$(octave)„  LET PlayIt$ = PlayIt$ + "o" + MID$(STR$(octave), 2, LEN(STR$(octave)))„CASE "-"„  INPUT "Tempo?(32-255 qtr.notes/sec.)...>", tempo„  PLAY "t" + STR$(tempo)„  LET PlayIt$ = PlayIt$ + "t" + MID$(STR$(tempo), 2, LEN(STR$(tempo)))„END SELECT„LOOP UNTIL in$ = CHR$(27)„END SUB„„SUB Instructions„CLS„PRINT "Welcome to my music composition program."„PRINT "Summary of menu choices:"„PRINT "1) Displays this help file."„PRINT "2) Allows you to create new music and store it in RAM."„PRINT "   (See summary of keys below.)  When you are done, press ESC."„PRINT "3) Replays music that was just composed and is still in RAM."„PRINT "4) Allows you to save newly composed music to a file."„PRINT "5) Lets you load a file that you already saved so that you don't have"„PRINT "   to start over and recompose the music."„PRINT "6) Like it says.  QUITS the program."„LOCATE 11, 1„PRINT„PRINT "Notes:"„PRINT "a: C"; TAB(10); "w: C#"; TAB(20); "s: D"; TAB(30); "e: E-";„PRINT TAB(40); "d: E"; TAB(50); "f: F"; TAB(60); "t: F#"„PRINT "g: G"; TAB(10); "y: A-"; TAB(20); "h: A"; TAB(30); "u: B-"; TAB(40); "j: B";„PRINT TAB(50); "k: hiC"„PRINT„„PRINT "Functions:"„PRINT ",: 1/12 note (for eighth note triplets)"„PRINT ".: 3/2 length"; TAB(20); "p: pause"„PRINT "=: Select octave"; TAB(25); "[: Lowers octave"; TAB(50); "]:"; Raises; octave; ""„PRINT "-: Change tempo"; TAB(25); "1-7: Changes note length (1: whole, 2: half, etc.)"„PRINT "8: Staccatto"; TAB(25); "9: Normal"; TAB(50); "0: Lengato"„PRINT„LOCATE 23, 1„PRINT "Press any key to continue..."„DO„LOOP WHILE INKEY$ = ""„END SUB„„SUB LoadFile (PlayIt$, found$)„CLS„DO„CHDIR "\"„FILES "*."„INPUT "Please enter PATH where you saved the file...>", path$„CHDIR path$„FILES "*."„INPUT "Is the file there?(y/n)...>", found$„IF found$ = "n" THEN„  INPUT "Give up search?(y/n)...>", abort$„END IF„LOOP UNTIL found$ = "y" OR abort$ = "y"„IF found$ = "y" THEN„INPUT "Please specify which file (from those above)...>", name$„OPEN name$ FOR INPUT AS #1„INPUT #1, PlayIt$„CLOSE #1„END IF„END SUB„„SUB SaveFile (PlayIt$)„CLS„INPUT "Will this be a NEW or PREVIOUS file?(n/p)...>", neworprev$„IF neworprev$ = "n" THEN„  CHDIR "\"„  FILES "*."„  INPUT "Please enter PATH to save file to...>", path$„  CHDIR path$„  INPUT "Enter new file name (please use no file extension!)...>", name$„END IF„IF neworprev$ = "p" THEN„  DO„  CHDIR "\"„  FILES "*."„  INPUT "Please enter PATH where you saved the file...>", path$„  CHDIR "\"„  CHDIR path$„  FILES "*."„  INPUT "Is the file there?(y/n)...>", found$„    IF found$ = "n" THEN„      INPUT "Give up search?(y/n)...>", abort$„    END IF„  LOOP UNTIL found$ = "y" OR abort$ = "y"„  IF found$ = "y" THEN„    INPUT "Enter previous file name (it WILL be overwritten!)...>", name$„  END IF„END IF„OPEN name$ FOR OUTPUT AS #1„PRINT #1, PlayIt$„CLOSE #1„END SUB„„Unknown Author(s)              MOD FORMAT                     MOD,FORMAT                     Unknown Date (00:00)   TEXT                   96   4227     MODFORM.TXT Protracker 2.3A Song/Module Format:„-----------------------------------„„Offset  Bytes  Description„------  -----  -----------„   0     20    Songname. Remember to put trailing null bytes at the end...„               When written by ProTracker this will be only uppercase;„               there are only historical reasons for this. (And the„               historical reason is that Karsten Obarski, who made the„               first SoundTracker, was stupid.)„„Information for sample 1-31:„„Offset  Bytes  Description„------  -----  -----------„  20     22    Samplename for sample 1. Pad with null bytes. Will only be„               uppercase.  The samplenames are often used for storing„               messages from the author; in particular, samplenames„               starting with a '#' sign will generally be a message. This„               convention is a result of a player called IntuiTracker„               displaying all samples starting with # as a message to the„               person playing the module.„  42      2    A WORD with samplelength for sample 1.  Stored as number of„               words.  Multiply by two to get real sample length in bytes.„               This is a big-endian number; for all PC programmers out„               there, this means that to get your 8-bit-orginated format,„               you have to swap the two bytes.„  44      1    Lower four bits are the finetune value, stored as a signed„               four bit number. The upper four bits are not used, and„               should be set to zero.„               They should also be masked out reading; you can never be„               sure what some stupid program could have stored here...„  45      1    Volume for sample 1. Range is $00-$40, or 0-64 decimal.„  46      2    Repeat point for sample 1. Stored as number of words offset„               from start of sample. Multiply by two to get offset in bytes.„  48      2    Repeat Length for sample 1. Stored as number of words in„               loop. Multiply by two to get replen in bytes.„„Information for the next 30 samples starts here. It's just like the info„for sample 1.„„Offset  Bytes  Description„------  -----  -----------„  50     30    Sample 2...„  80     30    Sample 3...„   .„   .„   .„ 890     30    Sample 30...„ 920     30    Sample 31...„„Offset  Bytes  Description„------  -----  -----------„ 950      1    Songlength. Range is 1-128.„ 951      1    This byte is set to 127, so that old trackers will search„               through all patterns when loading.„               Noisetracker uses this byte for restart, ProTracker doesn't.„ 952    128    Song positions 0-127.  Each hold a number from 0-63 (or„               0-127) that tells the tracker what pattern to play at that„               position.„1080      4    The four letters "M.K." - This is something Mahoney & Kaktus„               inserted when they increased the number of samples from„               15 to 31. If it's not there, the module/song uses 15 samples„               or the text has been removed to make the module harder to„               rip. Startrekker puts "FLT4" or "FLT8" there instead.„               If there are more than 64 patterns, PT2.3 will insert M!K!„               here. (Hey - Noxious - why didn't you document the part here„               relating to YOUR OWN PROGRAM? -Vishnu)„„„Offset  Bytes  Description„------  -----  -----------„1084    1024   Data for pattern 00.„   .„   .„   .„xxxx  Number of patterns stored is equal to the highest patternnumber„      in the song position table (at offset 952-1079).„„  Each note is stored as 4 bytes, and all four notes at each position in„the pattern are stored after each other.„„00 -  chan1  chan2  chan3  chan4„01 -  chan1  chan2  chan3  chan4„02 -  chan1  chan2  chan3  chan4„etc.„„Info for each note:„„ _____byte 1_____   byte2_    _____byte 3_____   byte4_„/                \ /      \  /                \ /      \„0000          0000-00000000  0000          0000-00000000„„Upper four    12 bits for    Lower four    Effect command.„bits of sam-  note period.   bits of sam-„ple number.                  ple number.„Unknown Author(s)              VOC FORMAT                     VOC,FORMAT                     Unknown Date (00:00)   TEXT                   59   2449     VOCFORM.TXT -----------------------------------------------------------------„„Creative Voice File (VOC) Format:„„    HEADER (bytes 00-19)„    Series of DATA BLOCKS (bytes 1A+) [Must end w/ Terminator Block]„„-----------------------------------------------------------------„„HEADER:„=======„     byte #     Description„     ------     ------------------------------------------„     00-12      Creative Voice File„     13-15      1A 1A 00  (eof to abort printing of file)„     16-17      Version number (minor,major) (VOC-HDR puts 0A 01)„     18-19      2's Comp of Ver. # + 1234h (VOC-HDR puts 29 11)„„-----------------------------------------------------------------„„DATA BLOCK:„===========„„   Data Block:  TYPE(1-byte), SIZE(3-bytes), INFO(0+ bytes)„   NOTE: Terminator Block is an exception -- it has only the TYPE byte.„„      TYPE   Description     Size (3-byte int)   Info„      ----   -----------     -----------------  „-----------------------„      00     Terminator      (NONE)              (NONE)„      01     Sound data      2+length of data    *„      02     Sound continue  length of data      Voice Data„      03     Silence         3                   **„      04     Marker          2                   Marker# (2 bytes)„      05     ASCII           length of string    null terminated string„      06     Repeat          2                   Count# (2 bytes)„      07     End repeat      0                   (NONE)„„      *Sound Info Format:       **Silence Info Format:„       ---------------------      ----------------------------„       00   Sample Rate           00-01  Length of silence - 1„       01   Compression Type      02     Sample Rate„       02+  Voice Data„„„  Marker#           -- Driver keeps the most recent marker in a status byte„  Count#            -- Number of repetitions + 1„                         Count# may be 1 to FFFE for 0 - FFFD repetitions„                         or FFFF for endless repetitions„  Sample Rate       -- SR byte = 256-(1000000/sample_rate)„  Length of silence -- in units of sampling cycle„  Compression Type  -- of voice data„                         8-bits    = 0„                         4-bits    = 1„                         2.6-bits  = 2„                         2-bits    = 3„                         Multi DAC = 3+(# of channels) [interesting--„                                       this isn't in the developer's manual]„„Unknown Author(s)              ROLAND FORMAT                  ROLAND,FORMAT                  Unknown Date (00:00)   TEXT                   127  5939     ROLFORM.TXT       Ok, here's the ROL file format, as requested by someone. This I„got from the 80XXX Assembler echo where Emil Gilliam posted it. I hope„others will be able to use this. Remind me to post the BNK file format„later, ok?„„      This is in Assembler format, but I'll try tell explain how„non-assembly programmers can read this too. Remember, I got it from the„Assembler echo, so this to be expected.„„      Ok, well, the first field is the name of the area. The second is„the data type:„„             db -     Bytes„             dw -     Words (2 bytes)„             dd -     Double word (4 bytes)„„      The next field is either a question mark, or a DUP. A dup is„   duplicate, meaning a whole bunch of bytes. So, a '32 dup (0)' is 32„   bytes. The zereo is of no use to Basic programmers.„„      The last field is a comment, this tells about the stuff.„„       ___O_/____________________| SNIP |_____________________O_/___„          O \                    | HERE |                     O \„„file_version_major      dw      ?           ;Should equal 0„file_version_minor      dw      ?           ;Should equal 4„                        db      40 dup (0)  ;Unused„ticks_per_beat          dw      ?„beats_per_measure       dw      ?„editing_scale_y_axis    dw      ?           ;Used by Visual Composer„editing_scale_x_axis    dw      ?„                        db      0           ;Unused„mode                    db      ?           ;0=percussive (6 voices & 3„                                            ; drums), 1=melodic (9 voices)„                        db      90 dup (0)  ;Should equal 0„                        db      38 dup (0)  ;Filler„                        db      15 dup (0)  ;Filler„basic_tempo             dd      ?           ;Beats per minute (I think)„                                            ; This is a "float" type„„;This tells how many times to repeat time_of_event and tempo_multiplier„number_of_tempo_events  dw      ?„„;(The tempo events thing is because of the fact that the tempo might change„;during the song.  The tempo for each tempo event (from 0.01 to 10.0) is„;multiplied by the basic tempo.)„„;These two are repeated the number of times given in number_of_tempo_events„time_of_event           dw      ?           ;Time of event, in ticks„                                            ; (Not sure if this is the„                                            ; length of the event or the„                                            ; elapsed time in ticks since„                                            ; the start of the song.)„tempo_multiplier        dd      ?           ;This is a "float" type„„;Okay.  Now all of the rest of the fields are repeated for each of the„;eleven voices.„„                        db      15 dup (0)  ;Filler„time_of_last_note       dw      ?           ;Time (in ticks) of last note„                                            ; + 1„„;These next two fields are repeated while the summation of note_duration is„;less than time_of_last_note...„„note_number             dw      ?           ;0=silence, 12 to 107 = normal„                                            ; note, subtract 60 from this„                                            ; value for the value to  give„                                            ; the AdLib sound driver„                                            ;60=middle C, 61=C#, 12=C three„                                            ;octaves below middle C, etc.„note_duration           dw      ?           ;Note duration in ticks„„                        db      15 dup (0)  ;Filler (gee, this is getting„                                            ; rather wasteful...)  Not„                                            ; repeated with note_number or„                                            ; or note_duration„„„;number_of_inst_events tells how many times to repeat the four fields that„;come after it (the time_of_inst_event, instrument_name, filler, and unused)„„number_of_inst_events   dw      ?           ;Number of instrument events„„;These 4 are repeated as many times as number_of_inst_events says„„time_of_inst_event      dw      ?           ;Time of event in ticks„instrument_name         db      9 dup (?)   ;Instrument name„                        db      0           ;Filler„                        dw      0           ;Unused„„;NOT repeated with time_of_inst_event or instrument_name or the filler and„;unused fields following them„„                        db      15 dup (0)  ;Filler„„;number_of_vol_events tells how many times to repeat the two fields that„;come after it (the time_of_vol_event and volume_multiplier)„„number_of_vol_events    dw      ?           ;Number of volume events„„;Repeat these two as many times as number_of_vol_events says„„time_of_vol_event       dw      ?           ;Time of event, in ticks„volume_multiplier       dd      ?           ;Volume multiplier (0.0 to 1.0,„                                            ; a "float"„„;NOT repeated with time_of_vol_events and volume_multiplier„„                        db      15 dup (0)  ;Filler„„;number_of_pitch_events tells how many times to repeat the two fields that„;come after it (the time_of_pitch_event and pitch_variation).„„number_of_pitch_events  dw      ?           ;Number of pitch events„„;Repeat these two as many times as number_of_pitch_events says„„time_of_pitch_event     dw      ?           ;Time of pitch event, in ticks„pitch_variation         dd      ?           ;Pitch variation, a "float",„                                            ; from 0.0 to 2.0, 1.0 is„                                            ; normal)„„       Well, I hope this helps who ever is into FM music and stuff. The„easiest way of playing ROLs is to use the SB-SOUND.COM or SOUND.COM„sound drivers. They even play it in the background. „Unknown Author(s)              CMF FORMAT                     CMF,FORMAT                     Unknown Date (00:00)   TEXT                   96   3542     CMFFORM.TXT CMF consists of 3 different block structures: header block, instrument„block and a music block.„„                        Header Block.„„Offset         Description„„00-03          File ID'CTMF'„04-05          Version # (currently 1.10)„06-07          Offset of instrument block from start of file„08-09          Offset of music block from start of file„0A-0B          Ticks per quarter note (default=120)„0C-0D          Clock ticks per second (default=96)„0E-0F          Offset of music title from start of file (0=none)„10-11          Offset of composer name (0=none)„12-13          Offset of remarks (0=none)„14-23          Channel-in-use table (16 bytes long)„24-25          # of instruments used„26-27          Basic tempo„28-            Title, composer and/or remarks„„„                Instrument Block„„Each instrument block is 16 bytes long. „„Offset         Description„„00             Modulator characteristic„01             Carrier characteristic„                   bit 7    Pitch Vibrato„                       6    Amplitude Vibrato„                       5    Sustaining Sound„                       4    Envelope Scaling„                       3-0  Frequency Multiplier„02             Modulator Scaling/Output Level„03             Carrier Scaling/Output Level„                  bit 7-6  Level Scaling„                      5-0  Output Level„04             Modulator Attack/Delay„05             Carrier Attack/Delay„                   bit 7-4 Attack Rate „                       3-0 Delay Rate„06             Modulator Sustain Level/Release Rate„07             Carrier Sustain Level/Release Rate„                   bit 7-4  Sustain Level„                       3-0  Release Rate„08             Modulator Wave Select„09             Carrier Wave Select„                   bit 7-2 (all cleared)„                       0-1 Wave Select„0A             Feedback/Connection„                   bit 7-4 (cleared)„                       3-1 Modulator Feedback   „                       0   Connection„0B-0F          Not used (Reserved)„„  „                        Music Block„„The music block is single track, polyphonic, with a max of 16 channels.„It adheres to the Standard Midi File format. It is like: „ „ Music block = <delta time> <Midi event> <delta time> <Midi event>...„„ where:       Delta time = amount of time before Midi event (in ticks)„„              Midi event = any Midi channel message„Here is where the book gets foggy. Some Midi events are Control Change„events but it doesn't say if all are like that. These are the only ones„discussed:„„Control Number       Control Data„   66h               1-127 (Used as markers in music)„   67h               0-Melody mode„                     1-Rhythm mode„„I don't know of the 0 or 1 are bits or follow the Control Number but it„appears that there will be a 66h then a number between 1 and 127 „designating seminote length (1 seminote = 1/128 of a tick or something)„or a 67h and a 0 or 1 to determine the mode. In Rhythm mode, the last „5 channels are:„„Channel      Rhythm„12           Bass Drum„13           Snare„14           Tom-tom„15           Top-cymbal„16           High-hat„„Control Number      Control Data„   68h                0-127 (Changes pitch upward by the # of 1/128 seminotes.„                             0=Cancel pitch change)„„   69h                0-127 (Changes pitch downward by the # of 1/128 „                             seminotes. 0=Cancel pitch change)„Unknown Author(s)              S3M FILE FORMAT                S3M,FORMAT                     Unknown Date (00:00)   TEXT                   126  4918     S3MFORM.TXT       Here's the S3M file format..„„„offset in file          length          description„0                       28              name of song„28                      2               WORD - 1A10H (can be used to identify)„„30                      2               ? (Unknown!)„32                      2               Sequence table length.„34                      2               # of instruments.„36                      2               # of patterns.„38                      6               filler (?)„44                      4               BYTE - "SCRM" (ID)„48                      1               Volume (range is UNKNOWN)„49                      1               Tempo (6 in 6/125)„50                      1               BPM (125 in 6/125, divide by 2.5 to get„                                        divisor)„51                      13              filler„64                      32              Channel maps.„„Channel map: Logical voice = offset into channel map.„             Voices 0-7 = LEFT speaker, Voices 8-15 = RIGHT speaker.„             FF means that the voice is OFF. (Try getting into PANIC and„             changing the table.)„„96                      sequencelen     Sequence table - BYTE, FF=pattern N/A.„„96+sequencelen          nInst*2         Instrument pointer table. NOTE though that„these pointers point to the 32- byte information section and NOT the instrument„itself - WORD. SHL 4 to get„„                                        actual offset.„96+sequencelen+nInst*2  nPatt*2         Pattern pointer table. Same as„                                        Instrument pointer table except that„                                        these point to ACTUAL patterns. Padded„                                        to paragraph boundary with 80h.„„„Instrument information section:„„Relative offset         length          description„0                       1               Boolean flag - if instrument is used.„1                       13              BYTE - DOS name.„14                      2               Absolute pointer to Instrument SHR 4.„16                      4               DWORD - size in bytes.„20                      4               DWORD - repeat start.„24                      4               DWORD - repeat END. (Not LENGTH!)„28                      2               WORD - volume. (Max 64)„30                      1               filler (?)„31                      1               Boolean flag - instrument looped?„32                      2               C-2 Hz/finetune. (1)„34                      14              filler„48                      28              BYTE - instrument name.„76                      4               BYTE - "SCRS".„„Pattern reading:„„Start of pattern:„„There is a word at the very beginning. That is the pattern size in„bytes.„„Subtract 2 to get ACTUAL length after word.„„(logic START)„Loop01:„„Read byte at location & increment pointer. (OPTIONAL - decrement length; each„pattern is ALWAYS 64-rows long.) Byte is bitmapped:„„bits 0-4 = channel # (0-31). (See it REALLY was a 32-channel format!)„bit 5 = 0=no note event, 1=note event.„bit 6 = 0=no vol. event, 1=vol. event.„bit 7 = 0=no effect, 1=effect.„„„(DO IN ORDER)„„If bit 5=1 then read 2 bytes & increment pointer. First byte = note - upper 4„bits=octave, lower 4=note. NOTE MUST NOT EXCEED 0BH. Subtract 2 from octave to„get ACTUAL octave. Second byte = sample.„„If bit 6=1 then read byte & increment pointer. Byte = volume. Max=40h.„„If bit 7=1 then read 2 bytes & increment pointer. Second byte=effect„argument.„„First byte = effect. Effect map is after this.„„Loop to Loop01 until bitmapped byte = 00. Then increment row. Loop until 64 rows„are read and/or End of Pattern.„„Instruments follow Patterns. They are in unsigned (signed? whatever, they'll„play properly without modification on a SB) format.„„„Effect map:„„00 = ?„01 = Set tempo„02 = Jump pattern„03 = End pattern„04 = Volume Slide. If lower 4 bits of ARGUMENT are SET & the argument is >„     0FH, then this is a fine Volume Slide UP and upper 4 = argument.„     If upper 4 bits are SET, this is a fine volume slide DOWN and lower 4 =„     argument.„     If neither conditions are met, then this is a normal volume slide (upper„     4=amount up and lower 4=amount down.)„05 = Porta down. If upper 4 are set then this is FINE and lower 4 = argument,„     otherwise this is a normal porta down.„06 = Porta up. Same with porta down.„07 = Porta to Note. Same as ProTracker.„08 = Vibrato. Same as ProTracker.„09 = Tremolo. Same as ProTracker.„0A = Arppegio. Same as SoundTracker.„0B = Tone/Vibrato + Volume.„0C = same as 0B I think.„0D = ?„0E = ?„0F = Sample Offset.„10-13 = ?„14 = Set BPM.„15-FF = ?„„NOTE: Patterns, Instrument definitions, and Instruments all start on„      paragraph boundaries.„Unknown Author(s)              669 FILE FORMAT                669,FORMAT                     Unknown Date (00:00)   TEXT                   66   2857     669FORM.TXT       Here's the file format for 669s. They are much like MODs, but they„have 8 tracks in them and the samples are unsigned. That unsigned part„has been causing trouble for people trying to rip samples from MODs and„using them in 669s. To fix a sample, just XOR every byte in it with 128.„This will flip the signed bit, making everything right...„„       ___O_/____________________| SNIP |_____________________O_/___„          O \                    | HERE |                     O \„„.669 file format:„„offset         +length&type    +description„---------------+---------------+---------------------------------------„------„0              |1 word         |marker, value=0x6669„2              |108 bytes      |song message„0x6e           |1 byte         |NOS = number of samples saved (0-64)„0x6f           |1 byte         |NOP = number of patterns saved (0-128)„0x70           |1 byte         |loop order number„0x71           |0x80 bytes     |order list„0xf1           |0x80 bytes     |tempo list for patterns„0x171          |0x80 bytes     |break location list for patterns„0x1f1          |NOS*size struct|sample data„               | samp          |„+--------------+---------------+„|struct samp {„|  13 bytes ASCIIZ filename of instrument„|  1 dword length of instrument„|  1 dword offset of beginning of loop„|  1 dword offset of end of loop„|} smp[NOS]„+--------------+---------------+---------------------------------------„„0x1f1+         |NOP*0x600      |patterns„(NOS*0x19)     |               |„+--------------+---------------+„|this is repeated 8 times for every row and the array of 8 of these is„| repeated 64 times for each pattern.„|„| bits:„|   BYTE[0]:             BYTE[1]:            BYTE[2]:„|  aaaaaaaa             bbbbbbbb            cccccccc„|  |----Ÿ|-----------------Ÿ|--Ÿ            |--Ÿ|--Ÿ„|  |     |                  |               |   |„|  |     |                  4 bit volume    |   command value„|  |     |                                  |„|  |     aabbbb = 6 bit instrument number   command:„|  |                                         0 = a„|  note value = (12*oct)+note                1 = b„|                                            2 = c„|  special values for byte 0:                3 = d„|    0xfe = no note, only volume change      4 = e„|    0xff = no note or volume change         5 = f„|„|                                           special value for byte 2:„|                                             0xff = no command„|„+--------------+---------------+---------------------------------------„„0x1f1+         |rest of file   |samples„(NOS*0x19)+    |               |„(NOP*0x600)    |               |„„       ___O_/____________________| SNIP |_____________________O_/___„          O \                    | HERE |                     O \„„Edward Schlunder               RIP 669 SOUND UTILITY          RIP,669,SOUND,UTILITY          08-18-93 (00:16)       PDS                    170  4102     RIP669.BAS  '      Here's a little program to rip out the samples in a 669 file. It„'   will help you get the hang of 669 file formats.. I'm sorry if it„'   doesn't run in QB4.5, I'm using PDS 7.1..„„'      Yeah, it's copyrighted, but you guys can use any of the stuff in„'   here as long as you give me credit for the things I wrote. Ok guys?„„DEFINT A-Z„DECLARE FUNCTION Exist% (FileName$)„TYPE RegTypeX„ AX AS INTEGER„ BX AS INTEGER„ CX AS INTEGER„ DX AS INTEGER„ BP AS INTEGER„ SI AS INTEGER„ DI AS INTEGER„ FLAGS AS INTEGER„ DS AS INTEGER„ ES AS INTEGER„END TYPE„„TYPE Struc669„ Marker    AS INTEGER„ SongMess1 AS STRING * 36„ SongMess2 AS STRING * 36„ SongMess3 AS STRING * 36„ NOS       AS STRING * 1„ NOP       AS STRING * 1„ Loop      AS STRING * 1„ PatOrder  AS STRING * 128„ PatTempo  AS STRING * 128„ PatBreak  AS STRING * 128„END TYPE„„TYPE SampType„ FileName  AS STRING * 13„ InsLeng   AS LONG„ BegLoop   AS LONG„ EndLoop   AS LONG„END TYPE„„COLOR 10, 1„CLS„PRINT "                              Rip 669 sound utility."„PRINT "                                  Version 1.00."„PRINT "             Written by: Edward Schlunder. Copyright (C) 1993,„MAGICS"„COLOR 11„PRINT STRING$(80, 196);„PRINT„„COLOR 12, 1„FileName$ = COMMAND$„„GetNewFile:„IF LEN(FileName$) = 0 THEN„COLOR 12„PRINT "Enter EXIT to abort."„INPUT "Name and path of file to rip [HARDWIRE]: ", FileName$„IF UCASE$(FileName$) = "EXIT" THEN END„IF LEN(FileName$) = 0 THEN FileName$ = "HARDWIRE"„END IF„„IF INSTR(FileName$, ".") = 0 THEN FileName$ = FileName$ + ".669"„„IF Exist(FileName$) = 0 THEN„COLOR 12„PRINT "File "; FileName$; " does not exist! ";„FileName$ = ""„GOTO GetNewFile„END IF„„OPEN FileName$ FOR BINARY AS 1„„DIM Header AS Struc669„GET 1, 1, Header„IF Header.Marker <> &H6669 THEN„COLOR 12„PRINT "File is not in .669 file format or is corrupted."„END„ELSE„COLOR 12„PRINT "Valid .669 file."„END IF„„COLOR 12„COLOR 10„PRINT "⁄ƒ ";„COLOR 12„PRINT "Song Message: ";„COLOR 10„PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„PRINT "≥"; Header.SongMess1; "≥"„PRINT "≥"; Header.SongMess2; "≥"„PRINT "≥"; Header.SongMess3; "≥"„PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„„COLOR 12„NOS& = ASC(Header.NOS)„NOP& = ASC(Header.NOP)„PRINT "Number of samples saved: "; NOS&„PRINT "Number of patterns saved:"; NOP&„„DIM Samples(NOS&) AS SampType„FOR J = 0 TO NOS& - 1„ GET 1, , Samples(J)„NEXT„„„SEEK 1, &H1F1 + NOS& * 25 + NOP& * 1536„COLOR 11„ FOR J = 0 TO NOS& - 1„GetNew:„ IF INSTR(Samples(J).FileName, CHR$(0)) > 9 THEN„  IF INSTR(Samples(J).FileName, ".") = 0 THEN„   MID$(Samples(J).FileName, 9, 1) = CHR$(0)„  END IF„ END IF„„ File$ = LEFT$(Samples(J).FileName, INSTR(Samples(J).FileName, CHR$(0)) - 1)„ IF File$ = "" THEN J = J + 1: GOTO GetNew„„ IF Exist((File$)) THEN„  Row = CSRLIN„  LOCATE 24, 1„  PRINT File$; " already exists! Input new filename (SKIP to goto next):";„  INPUT "", File$„  LOCATE Row„  IF LEN(File$) = 0 THEN END„  IF UCASE$(File$) = "SKIP" THEN GOTO Skip„ END IF„„ OPEN File$ FOR BINARY AS 2„  IF J MOD 2 THEN LOCATE , 40 ELSE LOCATE CSRLIN + 1, 1„  PRINT File$; ","; Samples(J).InsLeng; "bytes long.";„„  IF Samples(J).InsLeng > 32767 THEN InsLeng = 32767 ELSE InsLeng = Samples(J).„  Sam$ = SPACE$(InsLeng)„  ByteLoc& = SEEK(1)„  GET 1, , Sam$„  SEEK 1, ByteLoc& + Samples(J).InsLeng„  PUT 2, 1, Samples(J)„  PUT 2, , Sam$„ CLOSE 2„Skip:„NEXT„CLOSE 1„END„„„FUNCTION Exist% (FileName$)„DIM InRegs AS RegTypeX, OutRegs AS RegTypeX„File$ = FileName$„InRegs.AX = &H4E00             'Function for searching for a file„InRegs.CX = 63                 'Search for all files„FileName$ = FileName$ + CHR$(0)'Dos requires an ASCIIZ string, so add„CHR$(0)„InRegs.DS = SSEG(FileName$)    'Load DS:DX with„InRegs.DX = SADD(FileName$)    'the address of FileName$„CALL InterruptX(&H21, InRegs, OutRegs)   'Call DOS„'If AX contains a value, then file does not exist„SELECT CASE OutRegs.AX„CASE 0„Exist = -1„CASE ELSE„Exist = 0„END SELECT„FileName$ = File$„END FUNCTION„Merlin R. Null                 SQUAWK (ANNOYING SOUNDS)       SQUAWK,ANNOYING,SOUNDS         04-17-87 (00:00)       QB, QBasic, PDS        314  9523     SQUAWK.BAS  DEFINT A-X„RANDOMIZE TIMER„Cuckoo$ = "T120L16MLO3BF#"„Zap$ = "T255L64MLO4BAGFEDC<BAGFEDEC<BAGFEDC<BAGFEDC<BAGFEDC"„Tifweet$ = "T255L32O4mlDGD<G>DGDDGDGBAGF#EE"„Zang1$ = "T255L64MLO2BCADGEFEGDACBCADGEFEGDACB"„Zang2$ = "T255L64MLO3BCADGEFEGDACBCADGEFEGDACB"„Zang3$ = "T255L64MLO4BCADGEFEGDACBCADGEFEGDACB"„Zang4$ = "T255L64MLO5BCADGEFEGDACBCADGEFEGDACB"„Downer1$ = "T150L64MSO4BGEC<AFL16D"„Downer2$ = "T150L64MSO4BFC<GD<AL16E"„Downer3$ = "T150L64MSO4BE<AD<GC<L32F"„UpScale1$ = "T150L64MSO3DFA>CEGL16B"„UpScale2$ = "T120L64MSO2E.A.>D.G.>C.F.B."„UpScale3$ = "T150L64MSO0F>CG>DA>EB."„Tweedle$ = "T240L64MLO4EGEGEGCFCFCFGEGEGE"„Whoople$ = "T255L64O4CDEFGABO3CDEFGABO2CDEFGAB"„Bongee1$ = "T255L64MLO1BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„Bongee2$ = "T255L64MLO2BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„Bongee3$ = "T255L64MLO3BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„Bongee4$ = "T255L64MLO4BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„Uhoh1$ = "T255L64MLO1CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„Uhoh2$ = "T255L64MLO2CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„Uhoh3$ = "T255L64MLO3CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„Uhoh4$ = "T255L64MLO4CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„BobWhite$ = "T120L16O4C#.P16T255L64mlC#DD#EFF#GG#AA#BO5CC#DD#EF"„Whung$ = "T255L32mlO3CD<CD>>CD<<CD>>CD<<CD>CD"„Phone2$ = "T240L64MLO4EGEGEGEGEGEGEGEGEGEGEGEGEGEGEG"„Tweet$ = "O4T255L64MLB-BB-BAGAG.>EGG>EGG"„Wolf$ = "T200L64MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>CC#DD#EFED#DC#"„Fweet$ = "T255L64MsO4C#DD#EFF#GG#AA#B>CC#DD#EF"„COLOR 14, 1„CLS„LOCATE 3, 10„PRINT "Squawkers and Zangers and Off-Key Loud Clangers and Things that";„LOCATE 4, 10„PRINT "go Bleep in the Night.   (C) 1987 Merlin R. Null    version 1.0";„LOCATE 2, 1„COLOR 15, 1„PRINT TAB(6); "…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ"„PRINT TAB(6); "∫";„LOCATE 3, 75„PRINT "∫"„PRINT TAB(6); "∫";„LOCATE 4, 75„PRINT "∫"„PRINT TAB(6); "ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ"„PRINT TAB(6); "∫  A  Cuckoo         N  Chang          a  Boingee 1      n Mew"„PRINT TAB(6); "∫  B  Zap            O  Oh!            b  Boingee 2      o Tweet"„PRINT TAB(6); "∫  C  Tifweet        P  Space 1        c  Boingee 3      p Phone"„PRINT TAB(6); "∫  D  Zang 1         Q  Space 2        d  Boingee 4      q Phone"„PRINT TAB(6); "∫  E  Zang 2         R  Gurgle         e  Uhoh 1         r Wolf"„PRINT TAB(6); "∫  F  Zang 3         S  Spectre        f  Uhoh 2         s Siren"„PRINT TAB(6); "∫  G  Zang 4         T  Grup 1         g  Uhoh 3         t Fweet"„PRINT TAB(6); "∫  H  Downer 1       U  Grup 2         h  Uhoh 4         u Zhoup"„PRINT TAB(6); "∫  I  Downer 2       V  Chirp          i  Bob White      v Vrowr"„PRINT TAB(6); "∫  J  Downer 3       W  Waver          j  Whung          w Zhou"„PRINT TAB(6); "∫  K  UpScale 1      X  Tweedle        k  Kazango        x Art"„PRINT TAB(6); "∫  L  UpScale 2      Y  Blurp          l  Who 1          y Coo"„PRINT TAB(6); "∫  M  UpScale 3      Z  Whoople        m  Who 2          z Squawk"„PRINT TAB(6); "»ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ"„LOCATE 20, 29„COLOR 12, 1„PRINT "…ÕÕÕÕÕª";„LOCATE 21, 29„PRINT "∫ F10 ∫";„LOCATE 22, 29„PRINT "»ÕÕÕÕÕº";„LOCATE 21, 37„COLOR 15, 1„PRINT "Cacophony";„LOCATE 24, 6, 1„PRINT "Noise (A-Z, a-z) or <Esc> to exit ? ";„WHILE X$ <> CHR$(27)„  IF DemoFlag THEN„    IF INKEY$ = "" THEN„      X = INT(RND * 52) + 65„      IF X > 90 THEN„        X = X + 6„      END IF„      X$ = CHR$(X)„    ELSE„      DemoFlag = 0„      LOCATE 24, 6„      PRINT STRING$(40, 32);„      LOCATE 24, 6, 1„      PRINT "Noise (A-Z, a-z) or <Esc> to exit ? ";„    END IF„  ELSEIF RandomSounds > 0 THEN„    X = INT(RND * 52) + 65„    IF X > 90 THEN„      X = X + 6„    END IF„    X$ = CHR$(X)„    RandomSounds = RandomSounds - 1„  ELSE„GetKey:„    X$ = INKEY$„    IF X$ = "" THEN GOTO GetKey„  END IF„„  IF LEN(X$) = 2 THEN„    IF RIGHT$(X$, 1) = "D" THEN         '<F10>„      DemoFlag = -1„      LOCATE 24, 6„      PRINT STRING$(45, 32);„      LOCATE 24, 6, 0„      COLOR 12, 1„      PRINT "Press Any Key to Stop... ";„      COLOR 15, 1„    END IF„  ELSEIF X$ > "0" AND X$ < ":" THEN     '1-9„    RandomSounds = VAL(X$)„  END IF„  IF LEN(X$) = 1 AND X$ > CHR$(31) THEN„    IF DemoFlag THEN„      LOCATE 24, 31„      PRINT X$;„      LOCATE 24, 31„    ELSE„      LOCATE 24, 42„      PRINT X$;„      LOCATE 24, 42„    END IF„  END IF„  IF X$ = "A" THEN„    PLAY "X" + VARPTR$(Cuckoo$)„  ELSEIF X$ = "B" THEN„    PLAY "X" + VARPTR$(Zap$)„  ELSEIF X$ = "C" THEN„    PLAY "X" + VARPTR$(Tifweet$)„  ELSEIF X$ = "D" THEN„    PLAY "X" + VARPTR$(Zang1$)„  ELSEIF X$ = "E" THEN„    PLAY "X" + VARPTR$(Zang2$)„  ELSEIF X$ = "F" THEN„    PLAY "X" + VARPTR$(Zang3$)„  ELSEIF X$ = "G" THEN„    PLAY "X" + VARPTR$(Zang4$)„  ELSEIF X$ = "H" THEN„    PLAY "X" + VARPTR$(Downer1$)„  ELSEIF X$ = "I" THEN„    PLAY "X" + VARPTR$(Downer2$)„  ELSEIF X$ = "J" THEN„    PLAY "X" + VARPTR$(Downer3$)„  ELSEIF X$ = "K" THEN„    PLAY "X" + VARPTR$(UpScale1$)„  ELSEIF X$ = "L" THEN„    PLAY "X" + VARPTR$(UpScale2$)„  ELSEIF X$ = "M" THEN„    PLAY "X" + VARPTR$(UpScale3$)„  ELSEIF X$ = "N" THEN                  'Chang„    FOR J = 1 TO 4„      FOR I = 2000 TO 50 STEP -400„        SOUND I, .2„      NEXT„      FOR I = 800 TO 2000 STEP 400„        SOUND I, .2„      NEXT„    NEXT„  ELSEIF X$ = "O" THEN„    FOR I = 800 TO 2000 STEP 100        'Oh„      SOUND I, .2„    NEXT„    FOR I = 2000 TO 50 STEP -100„      SOUND I, .2„    NEXT„  ELSEIF X$ = "P" THEN„    FOR I = 1000 TO 40 STEP -20         'Space 1„      SOUND I, .2„    NEXT„  ELSEIF X$ = "Q" THEN„    FOR I = 10000 TO 500 STEP -500      'Space 2„      SOUND I, .2„    NEXT„  ELSEIF X$ = "R" THEN„    FOR I = 10 TO 50 STEP 10            'Gurgle„      FOR J = 50 TO 10 STEP -10„       SOUND I ^ 2 + J ^ 2, .1„      NEXT„    NEXT„  ELSEIF X$ = "S" THEN„    FOR Z = 1 TO 30 STEP .4             'Spectre„      SOUND (SIN(Z) + 40) * 50, .2„    NEXT„  ELSEIF X$ = "T" THEN„    FOR I = 10 TO 50 STEP 10            'Grup 1„      FOR J = 50 TO 10 STEP -10„        SOUND I * J, .1„      NEXT„    NEXT„  ELSEIF X$ = "U" THEN„    FOR I = 30 TO 70 STEP 10            'Grup 2„      FOR J = 70 TO 30 STEP -10„        SOUND I * J, .1„      NEXT„    NEXT„  ELSEIF X$ = "V" THEN„    FOR I = 30 TO 60 STEP 10            'Chirp„      FOR J = 60 TO 30 STEP -10„        SOUND I * J, .2„      NEXT„    NEXT„  ELSEIF X$ = "W" THEN„    FOR Z = 1 TO 30 STEP .7             'Waver„      SOUND (SIN(Z) + 20) * 30, .2„    NEXT„  ELSEIF X$ = "X" THEN„    PLAY "X" + VARPTR$(Tweedle$)„  ELSEIF X$ = "Y" THEN„    FOR I = 1 TO 40                     'Blurp„      SOUND INT(RND * 1400) + 450, .1„    NEXT„  ELSEIF X$ = "Z" THEN„    PLAY "X" + VARPTR$(Whoople$)„  ELSEIF X$ = "a" THEN                    'a„    PLAY "X" + VARPTR$(Bongee1$)„  ELSEIF X$ = "b" THEN„    PLAY "X" + VARPTR$(Bongee2$)„  ELSEIF X$ = "c" THEN„    PLAY "X" + VARPTR$(Bongee3$)„  ELSEIF X$ = "d" THEN„    PLAY "X" + VARPTR$(Bongee4$)„  ELSEIF X$ = "e" THEN„    PLAY "X" + VARPTR$(Uhoh1$)„  ELSEIF X$ = "f" THEN„    PLAY "X" + VARPTR$(Uhoh2$)„  ELSEIF X$ = "g" THEN„    PLAY "X" + VARPTR$(Uhoh3$)„  ELSEIF X$ = "h" THEN„    PLAY "X" + VARPTR$(Uhoh4$)„  ELSEIF X$ = "i" THEN„    PLAY "X" + VARPTR$(BobWhite$)„  ELSEIF X$ = "j" THEN„    PLAY "X" + VARPTR$(Whung$)„  ELSEIF X$ = "k" THEN„    FOR I = 10000 TO 500 STEP -500      'Space 2„      SOUND I, .2„    NEXT„    PLAY "X" + VARPTR$(Zap$)„  ELSEIF X$ = "l" THEN„    FOR Y = 10.2 TO 8.2 STEP -.2        'Who 1„      SOUND (TAN(Y) + 36) * 25, .8„      SOUND (SIN(Y) + 20) * 50, .4„    NEXT„  ELSEIF X$ = "m" THEN„    FOR Y = 10.2 TO 8.2 STEP -.2        'Who 2„      SOUND (TAN(Y) + 36) * 10, .8„      SOUND (SIN(Y) + 20) * 20, .4„    NEXT„  ELSEIF X$ = "n" THEN„    FOR Y = 10.8 TO 8 STEP -.1          'Mew„      SOUND (TAN(Y) + 50) * 25, .4„    NEXT„  ELSEIF X$ = "o" THEN„    FOR I = 1 TO 3„      PLAY "X" + VARPTR$(Tweet$)„    NEXT„  ELSEIF X$ = "p" THEN„    FOR Y = 1 TO 10                     'Phone 1„      SOUND 1195, .4„      SOUND 2571, .4„    NEXT„  ELSEIF X$ = "q" THEN„    PLAY "X" + VARPTR$(Phone2$)„  ELSEIF X$ = "r" THEN„    PLAY "X" + VARPTR$(Wolf$)„  ELSEIF X$ = "s" THEN„    FOR Y = 1 TO 3                      'siren„      SOUND 550, 9„      SOUND 400, 9„    NEXT„  ELSEIF X$ = "t" THEN„    FOR I = 1 TO 2„      PLAY "X" + VARPTR$(Fweet$)„    NEXT„  ELSEIF X$ = "u" THEN„    FOR Z = 3 TO 9 STEP .2              'Zhoup„      SOUND 120 + Z ^ 4, .1„      SOUND 0, .1„    NEXT„  ELSEIF X$ = "v" THEN„    FOR Z = 9 TO 3 STEP -.1             'Vrowr„      SOUND 120 + Z ^ 4, .1„      SOUND 0, .1„    NEXT„  ELSEIF X$ = "w" THEN„    FOR I = 40 TO 15 STEP -1            'Zhou„      SOUND I * 90, .1„      SOUND I * 80, .1„      SOUND I * 70, .1„      SOUND I * 60, .1„      SOUND I * 50, .1„    NEXT„  ELSEIF X$ = "x" THEN„    FOR I = 1 TO 10                      'Art„      SOUND 1195 - 50 * I, .3„      SOUND 1195 + 50 * I, .3„    NEXT„  ELSEIF X$ = "y" THEN„    FOR I = 0 TO 150 STEP 10            'Coo„      SOUND 1295 - I, .4„      SOUND 1095 + I, .4„    NEXT„  ELSEIF X$ = "z" THEN                  'Squawk„    FOR I = 1 TO 20„      SOUND I * 50, .1„      SOUND I * 100, .1„      SOUND I * 150, .1„    NEXT„  END IF„WEND„END„„Unknown Author(s)              SOUND AFFECTS DEMO             SOUND,AFFECTS,DEMO             Unknown Date (00:00)   QB, QBasic, PDS        81   2032     NOISES.BAS  ' QB 4.5 Version of Sound Effects Demo Program„„defint a-z„„„DECLARE SUB Bounce (Hi%, Low%)„DECLARE SUB Fall (Hi%, Low%, Del%)„DECLARE SUB Siren (Hi%, Range%)„DECLARE SUB Klaxon (Hi%, Low%)„DEFINT A-Z„„' Sound effects menu„DO„   CLS„   PRINT "Sound effects": PRINT„   COLOR 15, 0: PRINT "  B"; :  COLOR 7, 0: PRINT "ouncing"„   COLOR 15, 0: PRINT "  F"; :  COLOR 7, 0: PRINT "alling"„   COLOR 15, 0: PRINT "  K"; :  COLOR 7, 0: PRINT "laxon"„   COLOR 15, 0: PRINT "  S"; :  COLOR 7, 0: PRINT "iren"„   COLOR 15, 0: PRINT "  Q"; :  COLOR 7, 0: PRINT "uit"„   PRINT : PRINT "Select: ";„„   ' Get valid key„   DO„      Q$ = UCASE$(INPUT$(1))„   LOOP WHILE INSTR("BFKSQ", Q$) = 0„„   ' Take action based on key„   CLS„   SELECT CASE Q$„      CASE IS = "B"„         PRINT "Bouncing . . . "„         Bounce 32767, 246„      CASE IS = "F"„         PRINT "Falling . . . "„         Fall 2000, 550, 500„      CASE IS = "S"„         PRINT "Wailing . . ."„         PRINT " . . . press any key to end."„         Siren 780, 650„      CASE IS = "K"„         PRINT "Oscillating . . ."„         PRINT " . . . press any key to end."„         Klaxon 987, 329„      CASE ELSE„   END SELECT„LOOP UNTIL Q$ = "Q"„END„„' Loop two sounds down at decreasing time intervals„SUB Bounce (Hi%, Low%) STATIC„   FOR Count = 60 TO 1 STEP -2„      SOUND Low - Count / 2, Count / 20„      SOUND Hi, Count / 15„   NEXT Count„END SUB„„' Loop down from a high sound to a low sound„SUB Fall (Hi%, Low%, Del%) STATIC„   FOR Count = Hi TO Low STEP -10„      SOUND Count, Del / Count„   NEXT Count„END SUB„„' Alternate two sounds until a key is pressed„SUB Klaxon (Hi%, Low%) STATIC„   DO WHILE INKEY$ = ""„      SOUND Hi, 5„      SOUND Low, 5„   LOOP„END SUB„„' Loop a sound from low to high to low„SUB Siren (Hi%, Range%)„   DO WHILE INKEY$ = ""„      FOR Count = Range TO -Range STEP -4„         SOUND Hi - ABS(Count), .3„         Count = Count - 2 / Range„      NEXT Count„   LOOP„END SUB„Edward Schlunder               PC SPEAKER DIGITAL SOUND       PC,SPEAKER,DIGITAL,SOUND       Unknown Date (00:00)   TEXT                   81   3992     PCSPEAK.TXT > I'm trying to write some code that plays audio files (VOC, SND, etc.)„> through  the PC speaker.  The audio data I'm working with is 8 bits,„> and the PC speaker is only a one bit device.  Here's what I'm doing:„„      Nice try, but the PC's Internal Speaker can do about 6 bits. It„just takes a little figuring out.. If you set up the PIT correctly, it„can be really easy! Here, let me help you..„„      I'm writing a book on sound and stuff. It will be really cool.„It's gonna include information on programming all the sound cards„available, such as the SB, AdLib, and GUS. It's also gonna talk about„doing some stuff on the Internal speaker, so I've been writing a section„on getting different volumes on the PC's Internal Speaker. The book„isn't finished by far, but, the part about playing digital sound on the„internal speaker is *almost* finished. I'll post this pre-release of„BWSB for you..„„       ___O_/____________________| SNIP |_____________________O_/___„          O \                    | HERE |                     O \„„   > Volume <„„      Some programmers have discovered that they can create different„   volume settings on the speaker. This is done by giving the speaker„   +5v and then quickly giving it 0v. Because the speaker is rather slow„   to responding to the power (when compared to the computer's logic),„   it does not go fully out, like it should when given +5v. By making„   the speaker go out only so much and then pulling it back in, we can„   have different volumes by changing the amount of time that the„   speaker can move.„„      This sounds like a very timely task, and it is, if you program the„   speaker directly. Using the PIT to drive the speaker makes the task„   MUCH easier (not to mention much easier to program!).„„      To do this, we must setup the PIT to do some certain little„   things. To set it up for doing different volumes, we do the following„   (Basic source code):„„      OUT   &H43, &HB6                 'Setup to make no sound„      OUT   &H42, &HFF„      OUT   &H42, 0„„      OUT   &H43, &H90                 'Setup to interrupt on terminal„                                       'count„„      OneShot = INP(&H61) OR 3         'Puts the speaker in one shot mode„      OUT   &H61, OneShot„„      After this has been done, any values sent to port 42h tell the PIT„   what volume the speaker should be at. The speaker, however, has an„   upper limit to the volume which isn't very loud. The upper limit is„   64, any values above that can cause distortion.„„      Lets see what this is doing. The values that you give to port 42h„   are really telling the PIT how long to delay in between toggles of„   the speaker. With really small delays, the speaker is moved back in„   before it can get totally out. This is a quiet noise. With larger„   delays, the speaker can go completely out before being pulled back„   in. This creates a loud noise.„„      Now, if you specify a large volume level, the speaker will go„   completely out, but the PIT will still be delaying.. The PIT will„   eventually pull it back, but obviously, this will be no louder than a„   value between 64 and 255. Infact, it could be softer, the extended„   delays would slow down the number of vibrations it makes, making less„   noise (I'm not sure about this idea).. This the distortion I had„   talked about earlier.„„      After you are finished using the speaker in different volumes„   (usually at the end of your program), you should set the PIT back the„   way it was before, so that other programs will run correctly. If you„   don't do this, any tone made by an other program will continue on,„   never stopping because of your program. This is very annoying for the„   user, you have to reboot usually to make the tone stop.„„      This is what is necessary to reset the PIT:„„      OUT   &H43, &HB6„      OneShot = INP(&H61) AND &HFC„      OUT   &H61, OneShot„Unknown Author(s)              JINGLE BELLS & WE WISH...      JINGLE,BELLS,WE,WISH           Unknown Date (00:00)   QB, QBasic, PDS        13   384      CAROLS.BAS  „'Jingle bells„PLAY "MBMNT210O3L4EEEP4EEEP4EGCDL1EL4FFFFFEEL8EEL4EDDEL2DL4G"„PLAY "P4O3L4EEEP4EEEP4EGCDL1EL4FFFFFEEL8EEL4GGFDL4CL1"„„'We wish you a merry christmas„PLAY "MBMNT200O3L4CFL8FGFEL4DDDGL8GAGF"„PLAY "L4ECCAL8AB-AGL4FDL8CCL4DGEL2F"„PLAY "L4CFFFL2EL4EFEDL2CL4CAGF"„PLAY "O4L4CO3L4CL8CCL4DGEL2F"„PLAY "L4CFL8FGFEL4DDDGL8GAGFL4ECCAL8AB-AG"„PLAY "L4FDL8CCL4DGEL2F"„„Brett Levin                    SOUND CARD DETECTION           QuickBASIC ScrapBook           11-12-92 (00:00)       QB, QBasic, PDS        150  4633     SBSOUND.BAS ' SBSOUND.BAS by Brett Levin 1992„'„'  These routines were made entirely from a pretty detailed (techie, but„' not that I mind <G>) text file on programming the FM ports on the AdLib/SB.„'  You are free to use this in any program what so ever, as long as you„' give credit where credit is due.. (stole that line from Rich!) :)„ „DEFINT A-Z„DECLARE FUNCTION DetectCard% ()„DECLARE SUB SBInit ()„DECLARE SUB WriteReg (Reg%, Value%)„DECLARE SUB SBPlay (note%)„ „CONST false = 0, true = NOT false„ „SCREEN 0: CLS„ „IF DetectCard = true THEN„  PRINT "AdLib-compatible sound card detected."„ELSE„  PRINT "Unable to find/detect sound card."„  BEEP„  SYSTEM„END IF„PRINT " Initalizing...";„ „SBInit„ „PRINT " Done."„ „FOR nt = 0 TO 255„SBPlay nt„NEXT nt„ „PRINT„PRINT "  These routines only support one channel/voice of the FM chip, but"„PRINT "eventually I may fix them so you can have a bunch o' instruments on"„PRINT "at once.  I'd also like to write a replacement for SBFMDRV.COM, but"„PRINT "that's far off, and probably not in QB anyway.  This is too fast"„PRINT "compiled, so if you are going to use it in anything, add a delay."„PRINT "                                  Enjoy!         -Brett 11/12/92"„PRINT„ „FOR nt = 255 TO 0 STEP -1„SBPlay nt„NEXT nt„ „PRINT "[Press any key to end]"„SLEEP„ „CALL WriteReg(&HB0, &H0)  'Makes sure no extra sound is left playing„ „FUNCTION DetectCard%„ „'  Purpose:   Detects an AdLib-compatible card.„'             Returns -1 (true) if detected and 0 (false) if not.„'  Variables: Nope„ „CALL WriteReg(&H4, &H60)„CALL WriteReg(&H4, &H80)„B = INP(&H388)„CALL WriteReg(&H2, &HFF)„CALL WriteReg(&H4, &H21)„  FOR x = 0 TO 130„    A = INP(&H388)„  NEXT x„C = INP(&H388)„CALL WriteReg(&H4, &H60)„CALL WriteReg(&H4, &H80)„Success = 0„IF (B AND &HE0) = &H0 THEN„  IF (C AND &HE0) = &HC0 THEN„    Success = -1„  END IF„END IF„DetectCard% = Success„ „END FUNCTION„ „SUB SBInit„'  Initialize the sound card„ „'(This is the "quick-and-dirty" method; what it's doing is zeroing out„'  all of the card's registers.  I haven't had any problems with this.)„ „FOR q = 1 TO &HF5„  CALL WriteReg(q, 0)„NEXT q„ „END SUB„ „SUB SBPlay (freq%)„ „'  Purpose:      Plays a note„ „'  Variables:    freq% - Frequency (00-FF hex)„'                duration% - Duration (n seconds) (not used)„ „'  I'm still working on this part, it may be ugly, but it works <g>.„'  The first group of WriteRegs is the modulator, the second is the„'  carrier.„'  If you just want to know how to create your own instrument, play around„'  with the second values in the first four calls to WriteReg in each group.„'  :-)  Have fun!  - Brett„ „CALL WriteReg(&H20, &H7)    ' Set modulator's multiple to F„CALL WriteReg(&H40, &HF)    ' Set modulator's level to 40 dB„CALL WriteReg(&H60, &HF0)   ' Modulator attack: quick, decay: long„CALL WriteReg(&H80, &HF0)   ' Modulator sustain: medium, release: medium„CALL WriteReg(&HA0, freq%)„ „ „CALL WriteReg(&H23, &HF)   ' Set carrier's multiple to 0„CALL WriteReg(&H43, &H0)   ' Set carrier's level to 0 dB„CALL WriteReg(&H63, &HF0)  ' Carrier attack: quick, decay: long„CALL WriteReg(&H83, &HFF)  ' Carrier sustain: quick, release: quick„CALL WriteReg(&HB0, &H20)  ' Octave„ „CALL WriteReg(&HE0, &H0)   ' Waveform argument for Tom..„                           ' &H00 is the default, but I felt like„                           ' dropping it in for you.. :)„ „' I originally had an extra argument, duration!, but for some reason„' I wanted to do the timing outside of this sub..  You can change it back„' if needs require..„ „'TimeUp! = TIMER + duation!„'WHILE TimeUp! > TIMER: WEND  ' Worst you can be off is .182 of a second„ „END SUB„SUB WriteReg (Reg%, Value%)„'  Purpose:   Writes to any of the SB/AdLib's registers„'  Variables: Reg%: Register number,„'             Value%: Value to insert in register„'              (Note: The registers are from 00-F5 (hex))„OUT &H388, Reg     '388h = address/status port, 389h = data port„  FOR x = 0 TO 5   ' This tells the SB what register we want to write to„    A = INP(&H388) ' After we write to the address port we must wait 3.3ms„  NEXT x„ „OUT &H389, Value   ' Send the value for the register to 389h„  FOR x = 0 TO 34  ' Here we must also wait, this time 23ms„    A = INP(&H388)„  NEXT x„ „END SUB„ „'That program will produce a motorcycle engine effect.  I do have code„'that will play a frequency (from 0 to 800 I believe) on any of 11„'octaves, and I'm waiting for the authors permission to post it.„James Vahn                     PC SPEAKER FREQUENCY           FidoNet QUIK_BAS Echo          Unknown Date           QB, QBasic, PDS        22   706      FREQ.BAS    'This shows how to make specific frequencies through the PC„'speaker.  How high a note can you hear?  :-)„ „'Speaker.bas - James Vahn 1:30854/20@fidonet„'Shows the use of PC hardware to generate sound.„'„        Old = INP(&H61)     ' 8255 PPI chip. Save the original.„        OUT &H43, 182       ' 8253 Timer chip. 10110110b Channel 2, mode 3„        Port = INP(&H61)    ' get the 8255 port contents.„        OUT &H61, Port OR 3 ' enable the speaker and use channel 2.„ „INPUT "Desired Frequency in Hz"; Hz„Divisor = 1193180 / Hz„LSB = Divisor MOD 256„MSB = Divisor \ 256„ „OUT &H42, LSB„OUT &H42, MSB„ „PRINT "Press any to stop"„WHILE INKEY$ = "": WEND„OUT &H61, Old  ' turn it off.„Unknown Author(s)              TURN PC SPEAKER OFF            TURN,PC,SPEAKER,OFF            Unknown Date           QB, QBasic, PDS        21   652      NOSOUND.BAS '  > Does anyone know how to turn the speaker off?„'  > I thought there would be a port address for the speaker but„'  > I can't find the address.„„'Here's something I picked up somewhere.  Unfortunately, I can't credit„'it:„„DEFINT A-Z„„DECLARE SUB NoSound ()„„'***********************************************************************„'* SUB NoSound„'*„'* PURPOSE„'*    Turns off the continuous tone.„'***********************************************************************„SUB NoSound STATIC„   C% = INP(&H61)                            'mask off speaker„   OUT &H61, (C% AND &HFC)                   '   output from timer„END SUB„Jos Szabo                      WAV PLAYER                     BASIC Archives HomePage        Unknown Date           QB, QBasic, PDS        63   2147     WAVPLAY.BAS DECLARE SUB SetVoice (OnOff%)„CLS„'-Div.Init (maybe you get the filename from commandline?„  VocFile$ = "C:\sounds\hey!.wav"       ' input-file„  FILES "c:\sounds\*.*"„  PRINT„  INPUT "Please enter a file path and name (.WAV):  ", VocFile$„  VocFile$ = "c:\sounds\" + VocFile$ + ".wav"„  VocFile% = FREEFILE             ' .„  Delay% = 11                      ' value for delay„„'-open the voc-file„  OPEN VocFile$ FOR BINARY AS #VocFile%„„'-parameters for copy-to-soundblaster„  Bytes& = LOF(VocFile%)          ' number of bytes„„  BytesRemaining& = Bytes&        ' number of remaining bytes„  BufferMax% = &H7F00             ' largest buffer„  Buffer$ = SPACE$(BufferMax%)    ' create buffer„„  SetVoice 1                      ' Soundblaster on„„'-read {BufferMax%} bytes from disc, output on SB„  DO„     BytesRemaining& = BytesRemaining& - BufferLen%„     IF BytesRemaining& = 0 THEN EXIT DO ' nothing left over?„     IF BytesRemaining& > BufferMax% THEN ' how many bytes?„        BufferLen% = BufferMax%          '„     ELSE„        BufferLen% = BytesRemaining&     ' remaining (<BufferMax%)..„        Buffer$ = SPACE$(BufferLen%)     ' ..throw it into SB :-)„     END IF„„     GET #VocFile%, , Buffer$            ' read buffer„     DEF SEG = VARSEG(Buffer$)           ' get address of buffer„     VOff% = SADD(Buffer$)               ' .„„     FOR t% = 1 TO BufferLen%            ' output od {bufferlen%}„         'FOR qq% = 1 TO Delay: NEXT qq% ' delay„         WAIT &H22C, &H80, &HFF         ' wait for data-ready„         OUT &H22C, &H10„         WAIT &H22C, &H80, &HFF„         OUT &H22C, PEEK(VOff%)„         VOff% = VOff% + 1„     NEXT t%„„„  LOOP WHILE INKEY$ = ""„„  SetVoice 0                            ' SB off„  CLOSE #VocFile%                       ' close file„  END                                   ' .. good bye :-)„„SUB SetVoice (OnOff%)„    IF OnOff% THEN„       WAIT &H22C, &H80, &HFF       ' wait for data-ready on SB„       OUT &H22C, &HD1              ' ON„    ELSE„       WAIT &H22C, &H80, &HFF„       OUT &H22C, &HD3              ' OFF„    END IF„END SUB„Jos Szabo                      SB NOTE PLAYER                 BASIC Archives HomePage        Unknown Date           QB, QBasic, PDS        128  3737     NOTEPLAY.BASDECLARE SUB TickPause (Ticks%)„OPTION BASE 1„DEFINT A-Z„DIM A0$(6)„AddressPort = &H388„DataPort = &H389„FOR clport = 0 TO 244:„OUT AddressPort, clport: OUT DataPort, 0„NEXT„OUT AddressPort, &H20: OUT DataPort, &HF1„OUT AddressPort, &HDB: OUT DataPort, &HFF„OUT AddressPort, &H40: OUT DataPort, &H90„OUT AddressPort, &H60: OUT DataPort, &HF0„OUT AddressPort, &H80: OUT DataPort, &HFF„OUT AddressPort, &H23: OUT DataPort, &H1„OUT AddressPort, &H43: OUT DataPort, &H0„OUT AddressPort, &H63: OUT DataPort, &HF0„OUT AddressPort, &H83: OUT DataPort, &H77„„littleJAZZditty:„„FOR xx = 1 TO 2„        FOR x = 1 TO 6„                GOSUB BinDelta„                OUT AddressPort, &HA0: OUT DataPort, A0„                OUT AddressPort, &HB0: OUT DataPort, &H30„                TickPause 2.5„                OUT AddressPort, &HB0: OUT DataPort, &H0„                TickPause .3„        NEXT x„        FOR a = 1 TO 3„                x = 5„                GOSUB BinDelta„                OUT AddressPort, &HA0: OUT DataPort, A0„                OUT AddressPort, &HB0: OUT DataPort, &H30„                TickPause 4„                x = 2 + a„                GOSUB BinDelta„                OUT AddressPort, &HA0: OUT DataPort, A0„                OUT AddressPort, &HB0: OUT DataPort, &H30„                TickPause 6„        NEXT a„        OUT AddressPort, &HB0: OUT DataPort, 0„NEXT xx„FOR x = 6 TO 2 STEP -1„        GOSUB BinDelta„        OUT AddressPort, &HA0: OUT DataPort, A0„        OUT AddressPort, &HB0: OUT DataPort, &H30„        TickPause 4„        OUT AddressPort, &HB0: OUT DataPort, &H0„        TickPause .3„NEXT x„x = 5„GOSUB BinDelta„OUT AddressPort, &HA0: OUT DataPort, A0„OUT AddressPort, &HB0: OUT DataPort, &H30„TickPause 16„OUT AddressPort, &HB0: OUT DataPort, &H0„END„„BinDelta:„„    A0$(1) = "01101011"   ' 1„    A0$(2) = "10000001"   ' 2„    A0$(3) = "10011000"   ' 3„    A0$(4) = "10110000"   ' 4„    A0$(5) = "11001010"   ' 5„    A0$(6) = "11100101"   ' 6„'      b0$ = "00110000"„           '  xx^   ^      /2 unused/1 on-off/3 octave/2 fnum-hi„           '  xxOoctFmbit„„    bn$ = A0$(x): rBn$ = "": GOSUB BtD: A0 = Dec„RETURN„„BtD:„„Dec = 0!„IF LEN(bn$) <> 8 THEN RETURN„    FOR xT = 8 TO 1 STEP -1„        rBn$ = rBn$ + MID$(bn$, xT, 1)„    NEXT„„    FOR xT = 0 TO 7„        BD = VAL(MID$(rBn$, xT + 1, 1))„        IF BD THEN Dec = Dec + 2 ^ xT„    NEXT„RETURN„„'„'  ZDDDDDDBDDDDDDDDDDDBDDDDDDDDDDBDDDDDBDDDDDDDDDDD?„'  3      3           3          3F-H  3 F-NUMBER L3„'  3 NOTE 3 FREQUENCY 3 F-NUMBER CDDDDDEDDDDDDDDDDD4„'  3      3           3          3  10 3 76543210  3„'  CDDDDDDEDDDDDDDDDDDEDDDDDDDDDDEDDDDDEDDDDDDDDDDD4„'  3  C#  3   277.2   3    363   3  01 3 01101011  3„'  3  D   3   293.7   3    385   3  01 3 10000001  3„'  3  D#  3   311.1   3    408   3  01 3 10011000  3„'  3  E   3   329.6   3    432   3  01 3 10110000  3„'  3  F   3   349.2   3    458   3  01 3 11001010  3„'  3  F#  3   370.0   3    485   3  01 3 11100101  3„'  @DDDDDDADDDDDDDDDDDADDDDDDDDDDADDDDDDDDDDDDDDDDDY„'„„DEFSNG A-Z„SUB TickPause (Ticks%) STATIC„DEFINT A-Z„„    ' Ticks%        The number of ticks to delay.  There are 18.2 ticks„    '               per second.  This routine returns the ticks as an„    '               integer - it does not use QB's floating point„    '               routine.„„    TestTick = 0„„    DEF SEG = zero„    WHILE TestTick < Ticks„„        lastTick = Tick„        Tick = PEEK(&H46C)     'Get a tick from the clock.„„        '   ---- Prevents endless loop when rolling past midnight.„        IF lastTick <> Tick THEN TestTick = TestTick + 1„„    WEND„    DEF SEG„„END SUB„Multiple Authors               RPG MUSIC SAMPLES              Eblana-l                       05/95 (00:00)          QB, QBasic, PDS        178  5037     RPGMUSIC.BAS' The Eblana-l collection of Final Fantasy RPG Music Samples„„'Date: Tue May 23 15:50:04 1995„'From: FuSoYaFF2@aol.com„'Subject: Qbasic Cyan„'To: eblana-l@netcom.com„„„PRINT "CYAN'S SONG PROGRAMMED BY FuSoYa"„PLAY "<L4F>DL2C<L8B-AL4FL4G P4"„PLAY "L4F>DL2C<L8B-AL8FAL4G P4"„PLAY "L4F>DL2C<L8B-AL4FL1G"„„'FuSoYa„„'Date: Sat May 27 23:44:13 1995„'From: fv185@cleveland.Freenet.Edu (John Risser)„'Subject: FF3 Overworld music - final build„'To: Eblana-l@netcom.com„'Reply-To: fv185@cleveland.Freenet.Edu (John Risser)„„„'FF3 Overworld/Beginning Credits Song - Final Beta„PLAY "O2MSGB->D<GGB->D<GGB->D<GGB->D>"„PLAY "MNO3G8A8B-8O4D8O3MLB-1MNB-2A8G8A2MLD1MND2"„PLAY "O3G8A8B-8O4D8O3MLB-1MNB-2A8G8A2O4MLD1MND2"„PLAY "O3B-8O4C8D8F8MLD1MND2C8<B-8>C2<MLF1MNF2"„PLAY "O3B-8A8MLG1G2MNB-8A8MLG1MNG2"„PLAY "MNO3G8A8B-8O4D8O3MLB-1MNB-2A8G8A2MLD1MND2"„PLAY "O3G8A8B-8O4D8O3MLB-1MNB-2A8G8A2O4MLD1MND2"„PLAY "O3B-8O4C8D8F8MLD1MND2C8<B-8>C2<MLF1MNF2"„PLAY "O3B-8A8MLG1G2MNB-8A8MLG1MNG2"„PLAY "O3B-8>C8D8F8MLD1MND2C8<B-8>C2<MLF1MNF2"„PLAY "O3B-8>C8D8F8MLD1MND2C8<B-8>C2MLF1MNF2"„PLAY "MNO3G8A8B-8O4D8O3MLB-1MNB-2A8G8A2MLD1MND2"„PLAY "O3B-8A8MLG1G2MNB-8A8MLG1MNG2"„PLAY "MLO3D16G16B-16>D1D2MND+8D8C+2<MLA1A"„PLAY "MLO3D16G16B-16>C1C1C2MNC4C4<B-4F+4MLG1G1G1G2<G1"„„'by John Risser„'Date: Sat May 20 10:34:23 1995„'From: FuSoYaFF2@aol.com„'Subject: Qbasic again. . .„'To: eblana-l@netcom.com„„„PRINT "HERE'S A LITTLE SONG I WROTE ON QBASIC"„PLAY "<F>L3DL4DL8C<B-AB->L1F P8 L4GAB-L2DL4EF"„PRINT "HOPE YOU LIKED IT; I WROTE IT UP IN FIVE MINUTES!"„PRINT "                    FuSoYa"„„'Date: Sun May 21 20:43:38 1995„'From: NEStevens@aol.com„'Subject: QBasic - Kefka's Theme„'To: eblana-l@netcom.com„„„1 REM Kefka Theme - Nora E. Stevens„2 PLAY "t80mso2d8e8f8g8a8f8b-8a16g16a8f8e8f16g16f8d8c#8d16e16d8mn<b-8a8b-8a8b-8p8"„3 PLAY "a8>d8e8f8g8a8f8b-8a16g16a8f8e8f16g16f8d8c#8d16e16d8mn<b-8a8b-8a8b-8"„„'.\\„„'Date: Tue May 23 11:59:37 1995„'From: NEStevens@aol.com„'Subject: QBasic - Menacing music from FF3„'To: eblana-l@netcom.com„„„1 REM Menacing-type Theme - Nora E. Stevens„2 PLAY "O1Mn>e-8.msP16<b8a-8.P8"„3 PLAY "a-8b-8>d-8<b8b-8g8a-8a-8a-8"„4 PLAY "mn>e-8.msP16<b8a-8.P8"„5 PLAY "A-8E8E-8B8..A-8"„„'.\\„„'Date: Sun May 21 20:45:52 1995„'From: NEStevens@aol.com„'Subject: QBasic - Oh My Hero mk. II„'To: eblana-l@netcom.com„„„1 REM Oh My Hero - Nora E. Stevens„2 PLAY "mlo3e4f4g4.mnc2p8mle4.g4mnb4b2p8mla4b4mn>c4.c4<mlb4.a4.g2p8"„3 PLAY "mng4g4.mlf4e4f4.p8mnf4f4.mle4e-4e4.p8"„4 PLAY "mne4e4.e4mle-4.d-4e-4e2mng2p8"„5 PLAY "mlo3e4f4g4.mnc2p8mle4f4g4mnb4b4.p8mla4b4mn>c4.c4<mlb4.a4.g2p8"„6 PLAY "mng4g4.mlf4e4f4.p8mnf4f4.mle4e-4e4.p8"„7 PLAY "mne4.e4mld4.c4d4c2p8mne4.e4mld4.c4d4c2."„„'.\\„„'Date: Fri May 19 20:00:18 1995„'From: FuSoYaFF2@aol.com„'Subject: Qbasic again„'To: eblana-l@netcom.com„„„PRINT "HERE'S ANOTHER ONE. . . "„PLAY "<L4FL4A>C<L4F P4 L4GA>CL2E L4DEL2FL4FEDC P4 CCL8<B-AL2B- P4L4B-B-L8AG#L4A P4 L4AAFAL3>C"„PRINT "THE OPERA FROM FF3. . . . . . . .SORTA"„PRINT "FuSoYa"„„'FuSoYa„„'Date: Sun May 21 20:45:53 1995„'From: NEStevens@aol.com„'Subject: QBasic - Overworld mk. II„'To: eblana-l@netcom.com„„„1 REM Overworld Theme - Revised by Nora E. Stevens„2 PLAY "MNO3G8A8B-8O4D8O3B-1A8G8A2D1"„3 PLAY "O3G8A8B-8O4D8O3B-1A8G8A2O4D1"„4 PLAY "O3B-8O4C8D8F8D1C8<B-8>C2<F1"„5 PLAY "O3B-8A8MLG1G4MNB-8A8MLG1G4P4"„6 PLAY "MNO3G8A8B-8O4D8O3B-1A8G8A2D1"„7 PLAY "O3G8A8B-8O4D8O3B-1A8G8A2O4D1"„8 PLAY "O3B-8O4C8D8F8D1C8<B-8>C2<F1"„9 PLAY "O3B-8A8MLG1G4MNB-8A8MLG1G4P4"„10 PLAY "O3B-8O4C8D8F8D1C8<B-8>C2<F1"„11 PLAY "O3B-8O4C8D8F8D1C8<B-8>C2F1"„12 PLAY "MNO3G8A8B-8O4D8O3B-1A8G8A2D1"„13 PLAY "O3B-8A8MLG1G4MNB-8A8MLG1G4"„„'.\\„„'Date: Tue May 23 13:48:57 1995„'From: Sundrinker@aol.com„'Subject: More QBASIC...„'To: eblana-l@netcom.com„„„'Here's Shadow's music:„„PLAY "o4cl2g.l8gfe-dl4cl8de-l4<b-l2>c."„PLAY "l4cl2g.l8gfe-dl4cl8dcl4<b-l2>c."„PLAY "o4l8g.l16gl2b-.l16g.a.b-.l1al8b-al4gl8agl4fl1g"„PLAY "o4l4cl2g.l8gfe-dl4cl8de-l4<b-l2>c."„„'Phyr„„'Date: Tue May 23 15:46:52 1995„'From: FuSoYaFF2@aol.com„'Subject: Qbasic-Setzer„'To: eblana-l@netcom.com„„„'Here's a little bit of it. . . „PRINT "FF3'S BEST SONG PROGRAMMED BY FuSoYa"„PLAY "L4<C>L8DC<L2B P8 L8GA>C<BAL4GA"„PLAY "L4<C>L8DC<L2B P8 L8GA>C<BA"„„'FuSoYa„„'From risser@ZANSIII.millersv.edu Mon Sep 11 11:57:32 1995„'Date: Sun, 10 Sep 95 15:03:17 EDT„'From: John Risser <risser@ZANSIII.millersv.edu>„'To: Eblana-l@netcom.com, eblana-lite@netcom.com„'Subject: Shadow's music - final beta„„„' Shadow's music - Final beta„' by John Risser„' (no offense FuSoYa, but it's better than yours)„1„PLAY "T161O1MSE4P2P4E4E4E4P1P4"„PLAY "O1MSE4P2P4E4E4E4P1"„PLAY "MNO4E4MLB1MNB8A4G4F+4E4F+4G4D4MLE1MNE1P2P4"„PLAY "O4E4MLB1MNB8A4G4F+4E4F+4O3B4O4D4MLE1MNE1P2P4"„PLAY "O4B4>MLD1MN<B8>C#8D4MLC#1MNC#4P8."„PLAY "O5D4C#4<B4>C#4<F+4A4MLB1MNP4"„PLAY "O4E4MLB1MNB8A4G4F+4E4F+4G4D4MLE1.MNE2P2P4."„GOTO 1„„'--„'. <-- The super-string of all sigs!„Krisjanis Gale                 MUSIC COMPOSER                 FidoNet QUIK_BAS Echo          Year of 1993           QB, QBasic, PDS        288  6779     MUSICOMP.BASDECLARE SUB Instructions ()„DECLARE SUB MusicConfig ()„DECLARE SUB SaveFile (PlayIt$)„DECLARE SUB LoadFile (PlayIt$, found$)„DECLARE SUB ComposeMusic (PlayIt$)„DO„CLS„PRINT "The MusicComposer"„PRINT "Programmed by Krisjanis 'The Hacker' Gale"„PRINT„PRINT "Type:": PRINT„PRINT "1) To get instructions."„PRINT "2) To compose a new music."„PRINT "3) To replay newly made or loaded music."„PRINT "4) To save music currently in memory."„PRINT "5) To load previously composed music from a file."„PRINT "6) To Quit.": PRINT„LOCATE 23, 1„PRINT "Press number of selection..."„DO„LET in$ = INKEY$„LOOP WHILE in$ = ""„SELECT CASE in$„CASE "1"„  CALL Instructions„CASE "2"„  IF PlayIt$ <> "" THEN„    CLS„    INPUT "Erase what exists?(y/n)...>", erase$„    IF erase$ = "y" THEN„      CLS„      LET PlayIt$ = ""„      CALL ComposeMusic(PlayIt$)„    END IF„    IF erase$ = "n" THEN„      INPUT "Add on to what exists?(y/n)...>", addon$„      IF addon$ = "y" THEN„        CLS„        PRINT PlayIt$„        CALL ComposeMusic(PlayIt$)„      END IF„    END IF„  ELSE„    CLS„    CALL ComposeMusic(PlayIt$)„  END IF„CASE "3"„  CLS„  INPUT "Loop music indefinately?(y/n)...>", yesno$„  IF yesno$ = "y" THEN„    PRINT "Press ESC to stop music loop."„    DO„      PLAY PlayIt$„    LOOP UNTIL INKEY$ = CHR$(27)„  END IF„  IF yesno$ = "n" THEN„    PLAY PlayIt$„  END IF„CASE "4"„  CALL SaveFile(PlayIt$)„CASE "5"„  CALL LoadFile(PlayIt$, found$)„CASE "6"„  LOCATE 22, 1„  PRINT "Thanks for using my program."„  PRINT "                 --Krisjanis 'The Hacker' Gale--"„  SLEEP 1„END SELECT„LOOP UNTIL in$ = "6"„END„„SUB ComposeMusic (PlayIt$)„PRINT "Play!"„DO„SLEEP„LET in$ = INKEY$„SELECT CASE in$„CASE "a"„  PLAY "c"„  PRINT "C ";„  LET PlayIt$ = PlayIt$ + "c"„CASE "w"„  PLAY "c#"„  PRINT "C# ";„  LET PlayIt$ = PlayIt$ + "c#"„CASE "s"„  PLAY "d"„  PRINT "D ";„  LET PlayIt$ = PlayIt$ + "d"„CASE "e"„  PLAY "e-"„  PRINT "E- ";„  LET PlayIt$ = PlayIt$ + "e-"„CASE "d"„  PLAY "e"„  PRINT "E ";„  LET PlayIt$ = PlayIt$ + "e"„CASE "f"„  PLAY "f"„  PRINT "F ";„  LET PlayIt$ = PlayIt$ + "f"„CASE "t"„  PLAY "f#"„  PRINT "F# ";„  LET PlayIt$ = PlayIt$ + "f#"„CASE "g"„  PLAY "g"„  PRINT "G ";„  LET PlayIt$ = PlayIt$ + "g"„CASE "y"„  PLAY "a-"„  PRINT "A- ";„  LET PlayIt$ = PlayIt$ + "a-"„CASE "h"„  PLAY "a"„  PRINT "A ";„  LET PlayIt$ = PlayIt$ + "a"„CASE "u"„  PLAY "b-"„  PRINT "B- ";„  LET PlayIt$ = PlayIt$ + "b-"„CASE "j"„  PLAY "b"„  PRINT "B ";„  LET PlayIt$ = PlayIt$ + "b"„CASE "k"„  PLAY ">c<"„  PRINT "HiC ";„  LET PlayIt$ = PlayIt$ + ">c<"„CASE ","„  PRINT "1/12 note "„  PLAY "l6"„  LET PlayIt$ = PlayIt$ + "l6"„CASE "."„  PRINT "3/2 len. ";„  LET PlayIt$ = PlayIt$ + "."„CASE "["„  PLAY "<"„  PRINT "OctvDn ";„  LET PlayIt$ = PlayIt$ + "<"„CASE "]"„  PLAY ">"„  PRINT "OctvUp ";„  LET PlayIt$ = PlayIt$ + ">"„CASE "p"„  PLAY "n0"„  PRINT "Pause ";„  LET PlayIt$ = PlayIt$ + "n0"„CASE "1"„  PLAY "l1"„  PRINT "Whole ";„  LET PlayIt$ = PlayIt$ + "l1"„CASE "2"„  PLAY "l2"„  PRINT "Half ";„  LET PlayIt$ = PlayIt$ + "l2"„CASE "3"„  PLAY "l4"„„  PRINT "Quarter ";„  LET PlayIt$ = PlayIt$ + "l4"„CASE "4"„  PLAY "l8"„  PRINT "Eighth ";„  LET PlayIt$ = PlayIt$ + "l8"„CASE "5"„  PLAY "l16"„  PRINT "Sixteenth ";„  LET PlayIt$ = PlayIt$ + "l16"„CASE "6"„  PLAY "l32"„  PRINT "Thirty-Second ";„  LET PlayIt$ = PlayIt$ + "l32"„CASE "7"„  PLAY "l64"„  PRINT "Sixty-Fourth ";„  LET PlayIt$ = PlayIt$ + "l64"„CASE "8"„  PLAY "ms"„  PRINT "Staccato ";„  LET PlayIt$ = PlayIt$ + "ms"„CASE "9"„  PLAY "mn"„  PRINT "Normal ";„  LET PlayIt$ = PlayIt$ + "mn"„CASE "0"„  PLAY "ml"„  PRINT "Lengato ";„  LET PlayIt$ = PlayIt$ + "ml"„CASE "="„  INPUT "Octave(0-6)...>", octave„  PLAY "o" + STR$(octave)„  LET PlayIt$ = PlayIt$ + "o" + MID$(STR$(octave), 2, LEN(STR$(octave)))„CASE "-"„  INPUT "Tempo?(32-255 qtr.notes/sec.)...>", tempo„  PLAY "t" + STR$(tempo)„  LET PlayIt$ = PlayIt$ + "t" + MID$(STR$(tempo), 2, LEN(STR$(tempo)))„END SELECT„LOOP UNTIL in$ = CHR$(27)„END SUB„„SUB Instructions„CLS„PRINT "Welcome to my music composition program."„PRINT "Summary of menu choices:"„PRINT "1) Displays this help file."„PRINT "2) Allows you to create new music and store it in RAM."„PRINT "   (See summary of keys below.)  When you are done, press ESC."„PRINT "3) Replays music that was just composed and is still in RAM."„PRINT "4) Allows you to save newly composed music to a file."„PRINT "5) Lets you load a file that you already saved so that you don't have"„PRINT "   to start over and recompose the music."„PRINT "6) Like it says.  QUITS the program."„LOCATE 11, 1„PRINT„PRINT "Notes:"„PRINT "a: C"; TAB(10); "w: C#"; TAB(20); "s: D"; TAB(30); "e: E-";„PRINT TAB(40); "d: E"; TAB(50); "f: F"; TAB(60); "t: F#"„PRINT "g: G"; TAB(10); "y: A-"; TAB(20); "h: A"; TAB(30); "u: B-"; TAB(40); "j: B";„PRINT TAB(50); "k: hiC"„PRINT„„PRINT "Functions:"„PRINT ",: 1/12 note (for eighth note triplets)"„PRINT ".: 3/2 length"; TAB(20); "p: pause"„PRINT "=: Select octave"; TAB(25); "[: Lowers octave"; TAB(50); "]:"; Raises; octave; ""„PRINT "-: Change tempo"; TAB(25); "1-7: Changes note length (1: whole, 2: half, etc.)"„PRINT "8: Staccatto"; TAB(25); "9: Normal"; TAB(50); "0: Lengato"„PRINT„LOCATE 23, 1„PRINT "Press any key to continue..."„DO„LOOP WHILE INKEY$ = ""„END SUB„„SUB LoadFile (PlayIt$, found$)„CLS„DO„CHDIR "\"„FILES "*."„INPUT "Please enter PATH where you saved the file...>", path$„CHDIR path$„FILES "*."„INPUT "Is the file there?(y/n)...>", found$„IF found$ = "n" THEN„  INPUT "Give up search?(y/n)...>", abort$„END IF„LOOP UNTIL found$ = "y" OR abort$ = "y"„IF found$ = "y" THEN„INPUT "Please specify which file (from those above)...>", name$„OPEN name$ FOR INPUT AS #1„INPUT #1, PlayIt$„CLOSE #1„END IF„END SUB„„SUB SaveFile (PlayIt$)„CLS„INPUT "Will this be a NEW or PREVIOUS file?(n/p)...>", neworprev$„IF neworprev$ = "n" THEN„  CHDIR "\"„  FILES "*."„  INPUT "Please enter PATH to save file to...>", path$„  CHDIR path$„  INPUT "Enter new file name (please use no file extension!)...>", name$„END IF„IF neworprev$ = "p" THEN„  DO„  CHDIR "\"„  FILES "*."„  INPUT "Please enter PATH where you saved the file...>", path$„  CHDIR "\"„  CHDIR path$„  FILES "*."„  INPUT "Is the file there?(y/n)...>", found$„    IF found$ = "n" THEN„      INPUT "Give up search?(y/n)...>", abort$„    END IF„  LOOP UNTIL found$ = "y" OR abort$ = "y"„  IF found$ = "y" THEN„    INPUT "Enter previous file name (it WILL be overwritten!)...>", name$„  END IF„END IF„OPEN name$ FOR OUTPUT AS #1„PRINT #1, PlayIt$„CLOSE #1„END SUB„„Unknown Author(s)              WILLIAM TELL OVERTURE          FidoNet QUIK_BAS Echo          09/95 (00:00)          QB, QBasic, PDS        67   4143     WILLTELL.BAS'WILLTELL.BAS   the William Tell Overture (Lengthy version)„„PLAY "MST150L4O2BP8L16BBL4BP8L16BBL8BG+EG+BG+B>E<BG+EG+BG+B"„PLAY ">EL4<BP8L16BBL4BP8L16BBL4BP8L16BBL4BP8L16BBL8BL16BBL8B"„PLAY "BBL16BBL8BBBL16BBL8BBBL16BBL8BBL2BBL8BP8P4P4P8L16<BBL8B"„PLAY "L16BBL8BL16BBL8>EF+G+L16<BBL8BL16BBL8>EL16G+G+L8F+D+<B"„PLAY "L16BBL8BL16BBL8BL16BBL8>EF+G+L16EG+L4BL16BAG+F+L8EG+E"„PLAY "L16>BBL8BL16BBL8BL16BBL8>EF+G+L16<BBL8BL16BBL8>EL16G+"„PLAY "G+L8F+D+<BL16BBL8BL16BBL8BL16BBL8>EF+G+L16EG+L4BL16BA"„PLAY "G+F+L8EG+EL16<G+G+L8G+L16G+G+L8G+L16G+G+L8G+>C+<G+>C+"„PLAY "<G+>C+<G+F+ED+C+L16G+G+L8G+L16G+G+L8G+L16G+G+L8G+>C+<G+"„PLAY ">C+<G+>C+<BA+BA+BL16G+G+L8G+L16G+G+L8G+L16G+G+L8G+>C+"„PLAY "<G+>C+<G+>C+<G+F+ED+C+L16G+G+L8G+L16G+G+L8G+L16G+G+L8G+"„PLAY ">C+<G+>C+<G+>C+<BA+BL16<BBL8BL16F+F+L8F+L16F+F+L8F+G+"„PLAY "AL4F+L8AG+L4EL8G+F+F+F+L16>F+F+L8F+L16F+F+L8F+G+AL4F+"„PLAY "L8AG+L4EL8G+F+L16<BBL8BL16<BBL8BL16BBL8BL16BBL8>EF+G+"„PLAY "L16<BBL8BL16BBL8>EL16G+G+L8F+D+<BL16BBL8BL16BBL8BL16B"„PLAY "BL8>EF+G+L16EG+L4BL16BAG+F+L8EG+EL16>BBL8BL16BBL8BL16B"„PLAY "BL8>EF+G+L16<BBL8BL16BBL8>EL16G+G+L8F+D+<BL16BBL8BL16B"„PLAY "BL8BL16BBL8>EF+G+L16EG+L4BL16BAG+F+L8EG+EL64<EFGAB>CD"„PLAY "L8EL16EEL8EEL4G+.L8F+ED+EC+L16<B>C+<B>C+<B>C+D+E<ABAB"„PLAY "AB>C+D+<G+AG+AG+AB>C+<F+G+F+G+F+G+F+G+F+G+F+D+<B>B>C+"„PLAY "D+L8ED+EC+L16<B>C+<B>C+<B>C+D+E<ABABAB>C+D+<G+AG+AG+A"„PLAY "B>C+<F+G+F+G+F+AF+EL8EP8L4C+L16C+<C>C+<C>D+C+<BAAG+EC+"„PLAY "C+C+C+C+ED+<CG+G+G+G+G+G+>C+EG+>C+C+C+C+C+<C>C+<C>D+C+"„PLAY "<BAAG+EC+C+C+C+C+ED+<CG+G+G+G+G+G+>C+EG+>C+ED+C+D+<CG+"„PLAY "G+G+>G+EC+D+<CG+G+G+>G+EC+D+<BG+G+A+GD+D+G+GG+GG+AG+F+"„PLAY "E<BA+B>E<B>F+<B>G+ED+EG+EAF+B>G+F+ED+F+EC+<B>C+<B>C+D+"„PLAY "EF+G+<ABAB>C+D+EF+<G+AG+AC>C+D+E<F+G+F+G+F+G+F+G+F+G+"„PLAY "F+D+<BC>C+D+E<BA+B>E<B>F+<B>G+ED+EG+EAF+B>G+F+ED+F+EC+"„PLAY "<B>C+<B>C+D+EF+G+<ABAB>C+D+EF+<G+AG+AB>C+D+E<F+>C+<C>C+"„PLAY "D+C+<AF+E>EF+G+AB>C+D+L8EL16EEL8EEL4G+.L8FED+EC+L16<B"„PLAY ">C+<B>C+<B>C+D+E<ABABAB>C+D+<G+AG+AG+AB>C+<F+G+F+G+F+"„PLAY "G+F+G+F+G+F+D+<B>B>C+D+L8EL16EEL8EEL4G+.L8F+ED+EC+L16<B"„PLAY ">C+<B>C+<B>C+D+E<ABABAB>C+D+<G+AG+AG+AB>C+<F+G+F+G+F+"„PLAY "AG+F+L8E<B>EL16G+G+L8G+L16G+G+L8G+L16G+G+L8G+>C+<G+>C+"„PLAY "<G+>C+<G+F+ED+C+L16G+G+L8G+L16G+G+L8G+L16G+G+L8G+>C+<G+"„PLAY ">C+<G+>C+<BA+BA+BL16G+G+L8G+L16G+G+L8G+L16G+G+L8G+>C+"„PLAY "<G+>C+<G+>C+<G+F+ED+C+L16G+G+L8G+L16G+G+L8G+L16G+G+L8G+"„PLAY ">C+<G+>C+<G+>C+<BA+BA+BL16<F+F+L8F+L16F+F+L8F+G+AL4F+"„PLAY "L8AG+L4EL8G+F+B<BL16>F+F+L8F+L16F+F+L8F+G+AL4F+L8AG+L4E"„PLAY "L8G+F+L16BBL8BL16<BBL8BL16BBL8BL16BBL8>EF+G+L16<BBL8B"„PLAY "L16BBL8>EL16G+G+L8F+D+<BL16BBL8BL16BBL8BL16BBL8>EF+G+"„PLAY "L16EG+L4BL16BAG+F+L8E<B>EL16>BBL8BL16BBL8BL16BBL8>EF+"„PLAY "G+L16<BBL8BL16BBL8>EL16G+G+L8F+D+<BL16BBL8BL16BBL8BL16B"„PLAY "BL8>EF+G+L16<EG+L4BL16BAG+F+EF+G+AG+AB>C+<B>C+D+ED+EF+"„PLAY "G+A<B>A<B>A<B>A<B>A<B>A<B>A<B>A<BEF+G+AG+AB>C+<B>C+D+"„PLAY "ED+EF+G+A<B>A<B>A<B>A<B>A<B>A<B>A<B>A<BP16G+>G+<G+P16"„PLAY "D+>D+<D+P16E>E<EP16A>A<AP16G+>G+<G+P16D+>D+<D+P16E>E<E"„PLAY "P16A>A<A>G<G>G<G>G<G>G<GL8>GECEL16G+<G+>G+<G+>G+<G+>G+"„PLAY "<G+L8>G+E<B>EL16G+<G+>G+<G+>G+<G+>G+<G+L8>G+FC+FL16A+"„PLAY "<A+>A+<A+>A+<A+>A+<A+L8>A+GEGBP16L16A+P16AP16G+P16F+P16"„PLAY "EP16D+P16C+P16<BP16A+P16AP16G+P16F+P16EP16D+P16F+EF+G+"„PLAY "AG+AB>C+<B>C+D+ED+EF+G+A<B>A<B>A<B>A<B>A<B>A<B>A<B>A<B"„PLAY "EF+G+AG+AB>C+<B>C+D+ED+EF+G+A<B>A<B>A<B>A<B>A<B>A<B>A"„PLAY "<B>A<BP16G+>G+<G+P16D+>D+<D+P16E>E<EP16A>A<AP16G+>G+<G+"„PLAY "P16D+>D+<D+P16E>E<EP16A>A<A>G<G>G<G>G<G>G<GL8>GECEL16G+"„PLAY "<G+>G+<G+>G+<G+>G+<G+L8>G+E<B>EL16G+<G+>G+<G+>G+<G+>G+"„PLAY "<G+L8>G+FC+FL16A+<A+>A+<A+>A+<A+>A+<A+L8>A+GEGBP16L16A+"„PLAY "P16AP16G+P16F+P16EP16D+P16C+P16<BP16A+P16AP16G+P16F+P16"„PLAY "EP16D+P16FED+ED+L8EL16BBL8BL16BBL8BL16BBL8>EF+G+L16<B"„PLAY "BL8BL16BBL8BL16BBL8>G+ABP8EF+G+P8<G+ABP8P2L16<BC>C+DD+"„PLAY "EFF+GG+AA+BC>C+D+ED+F+D+ED+F+D+ED+F+D+ED+F+D+ED+F+D+E"„PLAY "D+F+D+ED+F+D+ED+F+D+L8EL16E<E>E<E>E<EL8>EL16<B<B>B<B>B"„PLAY "<BL8>BL16G+<G+>G+<G+>G+<G+L8>GL16E<E>E<E>E<EL8>EL16EE"„PLAY "L8EEEL16<BBL8BBBL16G+G+L8G+G+G+L16EEL8EEE<B>E<B>G+EBG+"„PLAY ">E<B>E<B>G+EBG+L4>EP8L16EEL8EEEEL4EP8L16EL4EP8L16O2EL2E"„Monte Ferguson                 VOC TO SAMPLE DUMP STANDARD    FidoNet QUIK_BAS Echo          03-02-93 (00:00)       QB, QBasic, PDS        444  15256    VOC2SDS.BAS ' VOC2SDS by Monte Ferguson (C) Copyright 1993 Monte Ferguson„'„' Notes: This code was not written to be elegant or user friendly, or to be„' a tutorial on how to write good code - it was written to WORK the way *I*„' wanted it to.„'„' If you'd like to swipe the code or hack it, please feel free. I ask only„' that you send me a copy of anything you create with it - that would be my„' payment. Mention in your dox would be nice, too :-)„'„' Monte Ferguson„' 1250 Anita Drive #304„' Kent, OH  44240„' Fido: 1:157/200.39„'„' Enjoy.„'„' P.S. - hardcoded stuff that's easy to change is generally marked with„'      <<< LOOK <<„' ie, channel numbers, sample number, etc.„„DECLARE FUNCTION GetBlkLen! ()„DECLARE FUNCTION GenPath$ (FSpec$)„DECLARE FUNCTION GenSpec$ (FSpec$, DefExt$)„DECLARE FUNCTION SngToM3$ (n!)„DECLARE FUNCTION M3toDec! (m3$)„DECLARE FUNCTION Hx$ (Text$)„„DEFINT A-Z„'„' VOC2SDS - Converts .VOC files to Sample Dump Standard„' Copyright 1993 Monte Ferguson„'„' First version      01-Mar-93„'„CONST Vers = "1.0"„CONST LastUpdate = "02-Mar-93"„CONST Copyright = "VOC2SDS Copyright 1993, Monte Ferguson"„CONST False = 0„CONST True = NOT False„„TYPE VOCHeaderType„  Des AS STRING * 20„  BlockOffset AS INTEGER„  Vers AS INTEGER„  VerComp AS INTEGER„END TYPE„„TYPE SDSHeaderType„  f07e AS STRING * 2„  Channel AS STRING * 1„  One AS STRING * 1„  SampleNum AS STRING * 2„  Bits AS STRING * 1„  Period AS STRING * 3„  SLength AS STRING * 3„  SustLoopStart AS STRING * 3„  SustLoopEnd AS STRING * 3„  LoopType AS STRING * 1„  F7 AS STRING * 1„END TYPE„„TYPE SDSBLockType„  f07e AS STRING * 2„  Channel AS STRING * 1„  Two AS STRING * 1„  PktCnt AS STRING * 1„  DTA AS STRING * 120„  ChkSum AS STRING * 1„  F7 AS STRING * 1„END TYPE„„„„DIM VocHead AS VOCHeaderType„DIM SDSHead AS SDSHeaderType„DIM SDSBLock AS SDSBLockType„„„„FileSpec$ = GenSpec$(LTRIM$(UCASE$(COMMAND$)), "VOC")„„PRINT Copyright„PRINT Vers + " " + LastUpdate„PRINT ""„„IF LEN(FileSpec$) > 0 THEN„  FPath$ = GenPath$(FileSpec$)„  d$ = DIR$(FileSpec$)„  DO WHILE d$ <> ""„    KY$ = INKEY$„    f$ = FPath$ + d$„    PRINT ""„    a$ = "------" + f$ + "------"„    PRINT SPACE$(40 - LEN(a$) / 2) + a$„    PRINT ""„    ' Examine the file„    OPEN f$ FOR BINARY AS #1„    GET #1, , VocHead„    IF VocHead.Des <> "Creative Voice File" + CHR$(26) THEN„      PRINT "Bogus header, not a .VOC file."„    ELSE„      v$ = HEX$(VocHead.Vers)„      IF LEN(v$) < 4 THEN v$ = STRING$(4 - LEN(v$), "0") + v$„      v$ = LTRIM$(STR$(VAL("&H" + LEFT$(v$, 2)))) + "." + LTRIM$(STR$(VAL("&H" + RIGHT$(v$, 2))))„      PRINT "Version:"; v$„      PRINT "Offset to 1st data block:"; VocHead.BlockOffset„      SEEK #1, VocHead.BlockOffset + 1„      BlockCount = 0„„      '         1         2         3         4         5         6         7         8„      '12345678901234567890123456789012345678901234567890123456789012345678901234567890„      'Blk Type                Bytes     Secs  SmplRate Pack      Other„      '##  \                 \ #,###,### ###.# ##,###   \       \ \                  \„      PRINT "Blk Type                Bytes     Secs  SmplRate Pack      Other"„      PRINT STRING$(79, "-")„      Converted = False„        DO„          BlockCount = BlockCount + 1„          BType$ = SPACE$(1)„          GET #1, , BType$„          SELECT CASE ASC(BType$)„            CASE 0„              BType$ = "Terminator"„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; 0; 0; 0; "N/A"„              EXIT DO„            CASE 1„              BL! = GetBlkLen„              s! = SEEK(1)„              BType$ = "Voice Data"„              SR$ = SPACE$(1)„              GET #1, , SR$„              SR! = ASC(SR$)„              SR! = INT(1000000! / (256 - SR!) + .5)„              Secs! = INT((BL! / SR!) * 10) / 10„              Pk$ = SPACE$(1)„              „              GET #1, , Pk$„              SELECT CASE ASC(Pk$)„                CASE 0„                  PT$ = "Raw 8-bit"„                CASE 1„                  PT$ = "4-bit"„                CASE 2„                  PT$ = "2.6 bit"„                CASE 3„                  PT$ = "2 bit"„                CASE ELSE„                  PT$ = "Unknown!"„              END SELECT„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; Secs!; SR!; PT$„              IF Pk$ <> CHR$(0) THEN„                PRINT "    ---> PACKED BLOCK, CANNOT CONVERT!"„              ELSE„                IF NOT Converted THEN„                  PRINT "    ---> Converting...";„                  Target$ = FPath$ + d$„                  p = LEN(Target$)„                  DO WHILE p >= 1„                    IF MID$(Target$, p, 1) = "." THEN„                      EXIT DO„                    END IF„                    p = p - 1„                  LOOP„                  IF p = 0 THEN„                    Target$ = Target$ + ".SDS"„                  ELSE„                    Target$ = LEFT$(Target$, p) + "SDS"„                  END IF„                  OPEN Target$ FOR BINARY AS #2„                  SDSHead.f07e = CHR$(&HF0) + CHR$(&H7E)„                  SDSHead.Channel = CHR$(0)         ' <<<<<<<<<<<<<<<< LOOK <<<<<<„                  SDSHead.One = CHR$(1)„                  SDSHead.SampleNum = CHR$(0) + CHR$(0)' <<<<<<<<<<<<<<<< LOOK <<<<<<„                  SDSHead.Bits = CHR$(16)           ' <<<<<<<<<<<<<<<< LOOK <<<<<<„                  SDSHead.Period = SngToM3$((1 / SR!) * 1000000000#)„                  SDSHead.SLength = SngToM3$(BL!)„                  SDSHead.SustLoopStart = SngToM3$(0)' <<<<<<<<<<<<<<<< LOOK <<<<<<„                  SDSHead.SustLoopEnd = SngToM3$(BL!)' <<<<<<<<<<<<<<<< LOOK <<<<<<„                  SDSHead.LoopType = CHR$(0)         ' <<<<<<<<<<<<<<<< LOOK <<<<<<„                  SDSHead.F7 = CHR$(&HF7)„                  PUT #2, , SDSHead„                  ' Now we create blocks by fetching 40 bytes of .VOC data„                  ' at a shot. Since 16 bits takes 3 7-bit words, that gives„                  ' us the correct 120 bytes/block length for SDS.„                  nb! = BL! / 40„                  IF nb! <> INT(nb!) THEN„                    nb! = INT(nb!) + 1„                  END IF„                  „                  ' Yes, this grunges the last block if it's not a multiple of„                  ' 40 bytes. So sue me. I *told* you this was quick and dirty! :-)„                  FOR i = 1 TO nb!„                    Pkt = (i - 1) MOD 128' Packet Count„                    Smp$ = SPACE$(40)„                    GET #1, , Smp$„                    Chk = &H7E      ' The running checksum„                    Chk = Chk XOR 0 ' Channel Num„                    Chk = Chk XOR 2 ' "Two"„                    Chk = Chk XOR Pkt„                    DTA$ = ""„                    FOR j = 1 TO LEN(Smp$)„                      Byte8 = ASC(MID$(Smp$, j, 1))„                      ' This next line converts the 8-bit sample to 16 bits:„                      Byte16! = Byte8 * 256!„                      ' And this stuff divides our 16 bits into three MIDI data bytes.„                      ' The 1st bytes is 512s, the 2nd byte is 4 and the last bytes is the„                      ' remainder (0-3) but LEFT JUSTIFIED within the 7-bit field. Hey, I„                      ' didn't write the standard, I just live with it! :-)„                      b1 = INT(Byte16! / 512)„                      r1! = Byte16! - (b1 * 512!)„                      b2 = INT(r1! / 4)„                      r2! = r1! - (b2 * 4)„                      b3 = r2! * 32„                      Chk = Chk XOR b1„                      Chk = Chk XOR b2„                      Chk = Chk XOR b3„                      DTA$ = DTA$ + CHR$(b1) + CHR$(b2) + CHR$(b3)„                    NEXT j„„                    SDSBLock.f07e = CHR$(&HF0) + CHR$(&H7E)„                    SDSBLock.Channel = CHR$(0)      ' <<<<<<<< LOOK <<<<<<<<<<<<„                    SDSBLock.Two = CHR$(2)„                    SDSBLock.PktCnt = CHR$(Pkt)„                    SDSBLock.DTA = DTA$„                    SDSBLock.ChkSum = CHR$(Chk)„                    SDSBLock.F7 = CHR$(&HF7)„                    PUT #2, , SDSBLock„                    y = CSRLIN„                    x = POS(0)„                    PRINT INT((i / nb!) * 100); "%";„                    LOCATE y, x„                  NEXT i„                  CLOSE #2„                  PRINT "Done."„                  Converted = True„                  REM Stuff„                ELSE„                  PRINT "(this version only converts the 1st block...)"„                END IF„              END IF„„„              SEEK #1, s! + BL!„            CASE 2„              BL! = GetBlkLen„              s! = SEEK(1)„              BType$ = "Voice Continuation"„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; Secs!; SR!; PT$„              SEEK #1, s! + BL!„            CASE 3„              BL! = GetBlkLen„              s! = SEEK(1)„              BType$ = "Silence"„              Pr$ = SPACE$(2)„              GET #1, , Pr$„              Pr = CVI(Pr$)„              SR$ = SPACE$(1)„              GET #1, , SR$„              SR! = ASC(SR$)„              SR! = INT(1000000! / (256 - SR!) + .5)„              Secs! = INT((Pr / SR!) * 10) / 10„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; Secs!; SR!; "N/A"„              SEEK #1, s! + BL!„            CASE 4„              BL! = GetBlkLen„              s! = SEEK(1)„              BType$ = "Marker"„              Pr$ = SPACE$(2)„              GET #1, , Pr$„              Pr = CVI(Pr$)„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; Secs!; SR!; "N/A"; "Marker=" + LTRIM$(STR$(Pr))„              SEEK #1, s! + BL!„            CASE 5„              BL! = GetBlkLen„              BType$ = "ASCII Text"„              s! = SEEK(1)„              Txt$ = SPACE$(BL!)„              GET #1, , Txt$„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; 0; 0; "N/A"; "Text follows:"„              PRINT SPACE$(4); Txt$„              SEEK #1, s! + BL!„            CASE 6„              BL! = GetBlkLen„              s! = SEEK(1)„              BType$ = "Repeat"„              Pr$ = SPACE$(2)„              GET #1, , Pr$„              Pr = CVI(Pr$)„              IF Pr <> &HFFFF THEN„                RP$ = "Repeat" + STR$(Pr) + " times."„              ELSE„                RP$ = "Repeat endlessly."„              END IF„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; 0; 0; "N/A"; RP$„              SEEK #1, s! + BL!„            CASE 7„              BL! = GetBlkLen„              s! = SEEK(1)„              BType$ = "End Repeat"„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; 0; 0; "N/A"„              SEEK #1, s! + BL!„            CASE ELSE„              BL! = GetBlkLen„              s! = SEEK(1)„              BType$ = "UNKNOWN:" + LTRIM$(STR$(ASC(BType$)))„              SR$ = SPACE$(1)„              GET #1, , SR$„              SR! = ASC(SR$)„              SR! = INT(1000000! / (256 - SR!) + .5)„              Secs! = INT((BL! / SR!) * 10) / 10„              Pk$ = SPACE$(1)„              GET #1, , Pk$„              SELECT CASE ASC(Pk$)„                CASE 0„                  PT$ = "Raw 8-bit"„                CASE 1„                  PT$ = "4-bit"„                CASE 2„                  PT$ = "2.6 bit"„                CASE 3„                  PT$ = "2 bit"„                CASE ELSE„                  PT$ = "Unknown!"„              END SELECT„              PRINT USING "##  \                 \ #,###,### ###.# ##,###   \       \ \                  \"; BlockCount; BType$; BL!; Secs!; SR!; PT$„              SEEK #1, s! + BL!„          END SELECT„          IF BType$ = CHR$(0) OR KY$ = CHR$(27) THEN„            EXIT DO„          END IF„        LOOP„„    END IF„    CLOSE #1„    PRINT ""„    PRINT ""„    IF KY$ = CHR$(27) THEN„      EXIT DO„    END IF„    d$ = DIR$„  LOOP„ELSE„  PRINT "No files matching " + COMMAND$„  PRINT ""„  PRINT "VOC2SDS - a utility to convert .VOC files to Sample Dump Standard MIDIEx data."„  PRINT "Copyright 1993 Monte Ferguson"„  PRINT "Vers: "; Vers; ", Last Updated:"; LastUpdate„  PRINT "Usage: VOC2SDS filespec"„  PRINT ""„  PRINT "filespec may contain wildcard characters, .VOC extension is assumed."„  PRINT "Data is written to filename.SDS. Only 8-bit RAW blocks can be converted!"„  PRINT "(and this version does only the 1st voice block)"„END IF„„FUNCTION GenPath$ (FSpec$)„  ' Parses the path out of passed file spec (FSpec$)„  p = LEN(FSpec$)„  DO WHILE p > 0„    IF INSTR("\:", MID$(FSpec$, p, 1)) > 0 THEN„      EXIT DO„    END IF„    p = p - 1„  LOOP„  IF p > 0 THEN„    GenPath$ = LEFT$(FSpec$, p)„  ELSE„    GenPath$ = ""„  END IF„„END FUNCTION„„FUNCTION GenSpec$ (FSpec$, DefExt$)„REM --------------------------------------------------------------------„REM  Given a filespec (FSpec$) and a default extension (DefExt$) try to„REM find some matching files„REM„REM„t$ = FSpec$           ' Temp work variable„„REM Let's try as-is...„IF LEN(DIR$(t$)) = 0 THEN„  ' Ok, let's add the default extention...„  IF RIGHT$(t$, 1) <> ":" THEN„    ' Keeps us from blowing up on "A:.TXT", etc„    t$ = t$ + "." + DefExt$„  END IF„  IF LEN(DIR$(t$)) = 0 THEN„    ' Alright, let's do *.ext„    t$ = FSpec$ + "*." + DefExt$„    IF LEN(DIR$(t$)) = 0 THEN„      ' Last try... add a directory slash AND *.ext„      t$ = FSpec$ + "\*." + DefExt$„      IF LEN(DIR$(t$)) = 0 THEN„        ' I give up!„        t$ = ""„      END IF„    END IF„  END IF„END IF„„GenSpec$ = t$„„END FUNCTION„„FUNCTION GetBlkLen!„  a$ = SPACE$(3)„  GET #1, , a$„  l = ASC(a$)„  M = ASC(MID$(a$, 2))„  h = ASC(RIGHT$(a$, 1))„  GetBlkLen! = h * 256! * 256! + M * 256! + l„END FUNCTION„„FUNCTION Hx$ (Text$)„  h$ = ""„  FOR i = 1 TO LEN(Text$)„    a = ASC(MID$(Text$, i, 1))„    d$ = HEX$(a)„    IF LEN(d$) < 2 THEN d$ = "0" + d$„    IF LEN(h$) > 0 THEN„      h$ = h$ + SPACE$(1)„    END IF„    h$ = h$ + d$„  NEXT i„  Hx$ = h$„END FUNCTION„„FUNCTION M3toDec! (m3$)„  IF LEN(m3$) <> 3 THEN STOP„  m1 = ASC(MID$(m3$, 1))„  m2! = ASC(MID$(m3$, 2)) * 128„  m3! = ASC(MID$(m3$, 3)) * 16384!„  M3toDec! = m1 + m2! + m3!„END FUNCTION„„FUNCTION SngToM3$ (n!)„  i1 = INT(n! / 16384!)„  r! = n! - (i1 * 16384!)„  i2 = INT(r! / 128)„  i3 = r! - (i2 * 128)„  SngToM3$ = CHR$(i3) + CHR$(i2) + CHR$(i1)„END FUNCTION„„