Jonathan Zuck                  TSR PHONE DIALER DEMO          FidoNet POWER_BAS Echo         Year of 1990           PB                     116  4745     TSRDIAL.BAS 'I've seen some messages lately about doing TSR's in BASIC and„'thought I'd share one that I came across.  It was included in„'the .zip file I downloaded it in, so I assume it's alright to„'distribute.  Here it is....„„'======================================================================„'=  DialTSR  (TSR Phone Dialer Demonstration)                         =„'=  by Jonathan Zuck                                                  =„'=  Copyright 1990, User Friendly, Inc.                               =„'=                                                                    =„'=       bc dialtsr /o;                                               =„'=       link /noe /nod dialtsr str00512 _noval _noread , , nul , pdq =„'=       exe2com dialtsr                                              =„'=                                                                    =„'======================================================================„„DEFINT A-Z„'$INCLUDE: 'PDQDECL.BAS'„„DIM Registers AS RegType          'RegType is defined in PDQDECL.BAS„One = 1                           'these variable save code size below„Two = 2„Three = 3„Seven = 7„„DialStr$ = "ATDT"                 'These are for Hayes compatible„HangStr$ = "ATH"                  '  modems„„'I chose to use the BIOS here for a number of reasons:„'  1. There is less code overhead„'  2. There are fewer compatibility questions„'  3. It parallels the FNBIOSPrint routine in SETUPTSR.BAS and as„'     such has greater application then OUTs„„DEF FNBIOSDial% (Character)„    FNBIOSDial% = 0                'assume no errors„    Registers.AX = 256 + Character 'put the character into AL, 1 into AH„    Registers.DX = 0               'specify Com1: (use 1 for Com2: etc.)„    Interrupt &H14, Registers      'call the BIOS write service„    PRINT HEX$(Registers.AX)„    IF Registers.AX AND &H8000 THEN   'check bit 7 of AH, error if set„       FNBIOSDial% = -1„    END IF„END DEF„„'Modem initialization, only need once and it doesn't matter if the„'underlying applications change it.  In fact, if you have executed„'a command like:„'   MODE COM1:9600,N,8,1,P„'you don't need to initialize at all„„Registers.AX = 67             'put the character into AL, 0 into AH„Registers.DX = 0              'specify Com1: (use 1 for Com2: etc.)„Interrupt &H14, Registers     'call BIOS„„ID$ = "ResDial (c) 1990 User Friendly, Inc. - press Ctrl-D to activate"„Row = CSRLIN                  'print at the current cursor location„Column = POS(0)„„PDQPrint ID$, Row, Column, Seven„„ScrnSize = 480                  '3 lines * 80 cols for prompt & input„BufSeg = AllocMem%(ScrnSize)    'allocate memory to save the screen„DEF SEG = 0                     'see what type of monitor„IF PEEK(&H463) = &HB4 THEN ScrSeg = &HB000 ELSE ScrSeg = &HB800„Num2Dial$ = "                                 "„„'----- set up the TSR as a pop-up using Ctrl-D„CALL PopUpHere(&H420, ID$)  'Ctrl-D, pass the unique ID string„GOTO EndIt                  'skip past the interrupt handler below„„'----- the following code is invoked each time Ctrl-D is pressed„BlockCopy ScrSeg, Zero, BufSeg, Zero, ScrnSize  'save the underlying scr„Row = CSRLIN                                    'and the cursor location„Column = POS(0)„„'----- draw a box and prompt for the phone number„PDQPrint "+-------------------------------------------------------------„PDQPrint "| Enter a phone number to dial:„PDQPrint "+-------------------------------------------------------------„„LOCATE 2, 33                                 'position the cursor„BIOSInput Num2Dial$, 112                     'get number„„'This is where we dial the number:„„FOR X = 1 TO 4„    Char = ASC(MID$(DialStr$, X, One))       'first send the "ATDT"„    ComErr = FNBIOSDial%(Char)„    IF ComErr THEN GOTO NoCom„NEXT„„FOR X = 1 TO 33                    'now the number, spaces ignored„    ComErr = FNBIOSDial%(ASC(MID$(Num2Dial$, X, One)))„    IF ComErr THEN GOTO NoCom„NEXT„„ComErr = FNBIOSDial%(13)           'all AT commands terminate with„IF ComErr THEN GOTO NoCom          ' a CR„„PDQPrint "Dialing, hit a key to hang up:", Two, Three, Seven„„WHILE BIOSInkey% = 0: WEND         'Now pick up the phone...„FOR X = 1 TO 3                     'and hang up the modem„    ComErr = FNBIOSDial%(ASC(MID$(HangStr$, X, One)))„    IF ComErr THEN GOTO NoCom„NEXT„„NoCom:„BlockCopy BufSeg, Zero, ScrSeg, Zero, ScrnSize  'restore the screen cont„LOCATE Row, Column                              'and the cursor location„„CALL PopDown                                    'back to underlying app.„„EndIt:„CALL EndTSR(ID$)                        'this installs us as a TSR„Sam Paulson                    DATE & TIME TSR                FidoNet POWER_BAS Echo         11-13-95 (00:49)       PB                     105  3345     TIMETSR.BAS 'In an interesting conversation between Sam Paulson and "Unnamed" he wrote:„„'>> Is it normal for a PowerBASIC TSR to take up 94k of RAM?„'>> All my program does is display the time and date.„'> Do you mean when it is waiting to be invoked or when it is„'> actually running?„„'While it is waiting to be invoked.  My offline mail reader (SLMR)„'displays the amount of memory available, so I checked to see what„'it said with both the TSR loaded and unloaded, and there was a 94k„'difference.„„'> I'm using PB 3.1 here and the several "test" TSR's I've written„'> seem to be about 5K in size when they are waiting to be triggered.„'> I've never checked how large they are when actually running but I'd„'> expect them to be a lot bigger since the mechanism swaps whatever„'> is running out while it loads the running code for the TSR.„„'I use PB 3.00a, and my program was just a first attempt at writing„'a TSR with PB.  Using the example from one of the online help topics,„'I figured out how to leave the disk swapping out of the program (takes„'forever to load on a floppy-only system like mine), so maybe that's„'the reason.„„'I guess my program isn't any big secret <g>, so here it is for all to„'examine (and poke fun at):„'-------------------------------------„'Time & Date TSR„„$compile exe„$lib iprint off„$option cntlbreak off„„x& = setmem(-700000)„popup key chr$(8,30,247)„popup multiplex &HC000,254„reg 1,&HC000 : reg 4,254„call interrupt &H2F„if reg(1) <> &HC000 and reg(4) <> 254 then end„print "Time & Date Installed. Press Alt-A to activate."„reg 1,&HC001 : reg 4,252„popup sleep„„while 1=1„  x% = pos         : y% = csrlin„  def seg = &hB800 : savedSreen$ = peek$(0,4000)„„  color 9,1 : Center 11, ""„      Center 12, "                   "„      Center 13, "                   "„„  if reg(1) = &HC000 and reg(4) = 254 then„     Center 14, ""„     color 15,1 : Center 12, "Time & Date"„  Center 13, "Already Installed"„     i$ = input$(1)„  else„     Center 14, "<U>ninstall"„     color 15,1 : while a$ = ""„                     a$ = inkey$„     TimeConvert tim$ : Center 12, tim$„     DateConvert dat$ : Center 13, dat$„                  wend„  end if„„  poke$ 0, savedSreen$„  locate y%, x%„  if lcase$(a$) = "u" then if popup(1) then end„  reg 1, &HC001 : reg 4,252„  a$ = ""„  popup sleep„wend„„sub DateConvert (dat$) static„   'date format = 05-23-1995„   restore„   d = val(left$(date$, 2))„   for i = 1 to 12„   read month$„   if i = d then„      dat$ = month$ + " " + mid$(date$,4,2) + ", " + mid$(date$,7,4)„      if val(mid$(date$,4,1)) = 0 then„         dat$ = month$ + " " + mid$(date$,5,1) + ", " + mid$(date$,7,4)„      end if„   end if„   next i„   data January,February,March,April,May,June,July,August,September,Octc„end sub„„sub TimeConvert (tim$) static„   'time format = 05:35:20.43„   if val(left$(time$,2)) > 12 then„      tim$ = str$(val(left$(time$,2)) - 12) + mid$(time$,3,3) + "pm"„   else„      tim$ = left$(time$, 5) + "am"„      if val(left$(time$,1)) < 1 then tim$ = mid$(time$,2,4) + "am"„      if val(left$(time$,2)) < 1 then tim$ = "  12" + mid$(time$,3,3) +„   end if„end sub„„sub Center (lineNumber%, text$)„   row% = (80 - len(text$)) \ 2„   locate lineNumber%, row%„   print text$;„end sub„Jamshid Khoshrangi             BOYER-MOORE INSTR              qjackson@direct.ca             12-05-95 (00:00)       PB                     412  15108    BOYER.BAS   $IF 0„„    BOYER.BAS                                           BOYER.BAS„„„                            Boyer-Moore INSTR„„             Translated from Pure MASM to PB Inline Assembler„„                                   by„„                   Quinn Tyler Jackson (aka "Jamshid")„„                           qjackson@direct.ca„„„                    Copyright 1994 by Michael Abrash„         Modifications Copyright 1995 by AhuraMazda(tm) Software„„                 (Distributed with Abrash's permission.)„„    NOTES:„„        I have a great book in my library of reference works called„        _Zen of Code Optimization_ by Michael Abrash (Coriolis Group„        Books, AZ, 1994).  Chapter 14 deals entirely with what is„        known as the Boyer-Moore String Search.„„        Abrash includes with his book the ASM code for a C-linkable,„        small memory model Boyer-Moore string search.  I decided,„        in my folly, to do my best to translate Abrash's crowning„        achievement into PowerBASIC inline assembler.„„        It wasn't an easy task.  First of all, I am not an assembler„        wizard.  I can fumble my way around well-commented ASM, but„        it's not my native tongue, to say the least.  Abrash's code„        was written for the small model, which assumes that CS, ES,„        and SS are all one and the same segment.  Although this makes„        Abrash's code elegant, it also made it a nightmare for me„        to rework for a CS, ES, and SS that could very well reside in„        three very distant segments.  Let's just say that this little„        bit of conversion took me about three days of steady study,„        an open MASM 6.1 reference manual, and a lot of hot chocolate,„        but I think I've managed....  Especially difficult and„        frustrating were PowerBASIC's constant FIXUP OVERFLOW errors„        during compilation.„„        Put simply, BINSTR(), which stands for "Boyer INSTR" does what„        INSTR does, but in some cases, it does it better.  Be that as„        it may, in some pathological cases, it does it worse.  BINSTR„        is the hacker's INSTR, then.  As long as the programmer has a„        far understanding of the kind of strings he will be employing,„        the speed gains with BINSTR are phenomenal.  If the data stream„        is uncertain, INSTR is possibly the better generic choice.  I„        can only warn the programmer: "Know Thy Data!"„„    BOYER-MOORE STRING SEARCHES:„„        Just about every decent book on computer science theory talks„        about the theoretically superlative "Boyer-Moore String Search"„        and leaves it at that.  Just what is the beast?„„        Consider the brute force method of finding a substring within„        a string.  Essentially, we click ahead one byte at a time,„        comparing it to the first byte of our Pattern, until the byte„        matches.  Then we compare the second byte of the Pattern with„        the next byte, until we fail.  When we fail, we advance in„        the buffer one byte and continue this way until we hit another„        first byte match.  Either we find what we're looking for, or„        we don't.  Meanwhile, we waste a lot of cycles doing things„        over and over again.„„        It makes intuitive sense that the assembler instructions„        REPNZ SCASB will be about the fastest search for a substring„        pattern in a buffer that there is.  After all, how could„        200 lines of assembler be FASTER than a simple REPNZ SCASB?„„        Well, consider this:  Suppose we're looking for the pattern„        "XYZ" in a buffer containing "XYAXYZ".  We match on "X", we„        match on "Y", and we mismatch on "A".  A close look at this„        tells us something: we don't have to do our next search„        starting at the second byte....  We can skip ahead to byte„        four in the buffer.„„        Now consider something else: we wasted two hits to be„        disappointed by a miss at the end.  What would happen if we„        compared the last byte of the pattern with the third byte„        of the buffer first?  A mismatch of the rightmost character„        of a pattern tells us much more than a mismatch of the„        leftmost character.  If the mismatched character in the„        buffer doesn't appear in the pattern, then we've not just„        eliminated ONE potential match, but as many potential„        matches as there are characters in the pattern.„„        It gets quite technical from this point on.  Read Abrash's„        book if you can't follow the code.  What it all amounts to„        are these rules of thumb:„„            The longer the pattern to match, the faster„            the search when using a Boyer-Moore engine.„„            The nature of the data affects the speed of the„            search when using a Boyer-Moore engine.„„        That said, searching for an "A" in a stream with only one "A"„        at the very end of it would prove slow using BINSTR.  Searching„        for a 1K pattern in a large stream proves amazingly efficient„        when compared to PowerBASIC's INSTR.  Again: "Know Thy Data!"„„„    FINAL WORD:„„        I can take none of the credit for either the algorithm or its„        implementation.  I took the time to provide a PowerBASIC 3.2„        version of Abrash's code, that's all.  Have fun with it.„„        Jamshid„„$ENDIF„„$ERROR BOUNDS ON„$DIM ALL„„DEFINT A-Z„„DECLARE FUNCTION BINSTR (_„    TheStart    AS INTEGER,_„    Target      AS STRING,_„    Rule        AS STRING)„„%DEBUG = -1„„$IF %DEBUG„„    DIM Rule AS STRING,_„        Target AS STRING„„    OPEN "PB.EXE" FOR BINARY ACCESS READ AS #1„    GET$ #1, 1000  , Rule$„    GET$ #1, 28000 , Target$     ' Tag some near random stuff to the„                                ' beginning to make things interesting„    Target$ = Target$ + Rule$„    CLOSE #1„„    CLS„„    VIEW TEXT (10,7)-(75,20)„„    PRINT "Boyer-Moore String Search Implementation for PowerBASIC 3.2"„    PRINT„    PRINT "Translated from Michael Abrash's code by Jamshid Khoshrangi"„    PRINT„„    DIM n AS INTEGER„„    MTIMER„        n = BINSTR(1, Target$, Rule$)„    PRINT ,,"Boyer INSTR: "; MTIMER; "microseconds"„    PRINT ,,"Found at offset: ";n„„    PRINT„„    MTIMER„        n= INSTR(Target$, Rule$)„    PRINT ,,"PB'S INSTR: ";MTIMER; "microseconds"„    PRINT ,,"Found at offset: "; n„„$ENDIF„„'   I've found that the Boyer-Moore method works best on patterns„'   that are 5 or more bytes long.  The BINSTR() FUNCTION will use„'   a standard INSTR() on shorter patterns, incurring about 40 to„'   50 microseconds of overhead on my system.„„%SMALLEST.PATTERN = 2„%SMALLEST.BUFFER  = 4„„FUNCTION BINSTR (_„    TheStart        AS INTEGER,_„    Target          AS STRING,_„    Rule            AS STRING _„    ) PUBLIC AS INTEGER„„    ' ES:DI Target„    ' DS:SI Rule„„    DIM PatLen  AS INTEGER,_„        BuffLen AS INTEGER„„    DIM StackSeg AS WORD,_„        PatSeg AS WORD,_„        PatPtr AS WORD,_„        BuffSeg AS WORD,_„        BuffPtr AS WORD,_„        TrueBuffPtr AS WORD„„    PatLen      = LEN(Rule)„    BuffLen     = LEN(Target)„„    IF BuffLen < %SMALLEST.BUFFER THEN„        FUNCTION = INSTR(TheStart, Target, Rule)„        EXIT FUNCTION„    ELSE„        IF PatLen < %SMALLEST.PATTERN THEN„            FUNCTION = INSTR(TheStart, Target, Rule)„            EXIT FUNCTION„        END IF„    END IF„„    IF TheStart > BuffLen THEN      ' we might as well not even bother„        EXIT FUNCTION„    END IF„„    StackSeg    = 0                 ' We do this for later inline ASM„„    PatSeg      = STRSEG(Rule)„    PatPtr      = STRPTR(Rule)„    BuffSeg     = STRSEG(Target)„    BuffPtr     = STRPTR(Target) + TheStart„    TrueBuffPtr = BuffPtr„„    !   cld„    !   push    sp„    !   push    si             ;preserve caller's register variables„    !   push    di„    !   push    es„    !   push    ds„    !   sub     sp, 256*2      ;allocate space for SkipTable on our„    !                          ; stack„„    '   Create the table of distances by which to skip ahead on mismatches„    '   for every possible byte value.  First, initialize all skips to the„    '   pattern length; this is the skip distance for bytes that don't„    '   appear in the pattern.„„    !   mov     ax,PatLen„    !   and     ax,ax          ;return an instant match if the„    !   jz      InstantMatch   ; pattern 0-length„„    !   mov     StackSeg,ss„    !   mov     es,StackSeg„    !   mov     di,sp          ;point to SkipBuffer„„    !   mov     cx,256„    !   rep     stosw„„    !   mov     es,BuffSeg„    !   mov     ds,PatSeg„„    !   dec     ax             ;from now on, we only need„    !   mov     PatLen,ax      ; PatLen - 1„„    '   Point to last (rightmost) byte of first potential pattern match„    '   location in buffer.„„    !   add     BuffPtr, ax„„    '   Reject if buffer is too small, and set the count of the number of„    '   potential pattern match locations in the buffer.„„    !   sub     BuffLen,ax„    !   jbe     NoMatch„„    '   Set the skip values for the bytes that do appear in the pattern„    '   to the distance from the byte location to the end of the pattern.„    '   When there are multiple instances of the same byte, the rightmost„    '   instance's skip value is used. Note that the rightmost byte of the„    '   pattern isn't entered in the skip table; if we get that value for„    '   a mismatch, we know for sure that the right end of the pattern has„    '   already passed the mismatch location, so this is not a relevant„    '   byte for skipping purposes.„„    !   mov     si,PatPtr      ;point to start of pattern„    !   and     ax,ax          ;are there any skips to set?„    !   jz      SetSkipDone    ;no„    !   mov     di,sp          ;point to SkipBuffer„„SetSkipLoop:„    !   sub     bx,bx          ;prepare for word addressing off byte value„    !   mov     bl,ds:[si]     ;get the next pattern byte„    !   inc     si             ;advance the pattern pointer„    !   shl     bx,1           ;prepare for word look-up„    !   mov     ss:[di+bx],ax  ;set the skip value when this byte value„    !                          ;is the mismatch value in the buffer„    !   dec     ax„    !   jnz     SetSkipLoop„„SetSkipDone:„    !   mov     dl,ds:[si]     ;DL=rightmost pattern byte from now on„    !   dec     si             ;point to next-to-rightmost byte of pattern„    !   mov     PatPtr,si      ; from now on„„    '   Search the buffer.„„    !   std                    ;for backward REPZ CMPSB„    !   mov     di,BuffPtr     ;point to the first search location„    !   mov     cx,BuffLen     ;# of match locations to check„„SearchLoop:„    !   mov     si,sp          ;point SI to SkipTable„„    '   Skip through until there's a match for the rightmost pattern„    '   byte.„„    '   We jump this way to avoid a FIXUP OVERFLOW under PB... <sigh>„    !   jmp     QuickSearchLoop„„InstantMatch:„    !   mov     ax,BuffPtr„    !   jmp     short Done„„    '   Compare the pattern and the buffer location, searching from high„    '   memory toward low (right to left).„„FullCompare:„    !   mov     BuffPtr,di     ;save the current state of„    !   mov     BuffLen,cx     ; the search„    !   mov     cx,PatLen      ;# of bytes yet to compare„    !   jcxz    Matched        ;done if there was only one character„    !   mov     si,PatPtr      ;point to next-to-rightmost bytes„    !   dec     di             ; of buffer location and pattern„„    !   repz    cmpsb          ;compare the rest of the pattern„„    !   jz      Matched        ;that's it; we've found a match„„    '   It's a mismatch; let's see what we can learn from it.„„    !   inc     di             ;compensate for 1-byte overrun of REPZ CMPSB;„    !                          ; point to mismatch location in buffer„    !                          ; # of bytes that did match.„    !   mov     si,BuffPtr„    !   sub     si,di„„    '   If, based on the mismatch character, we can't even skip ahead„    '   as far as where we started this particular comparison, then„    '   just advance by 1 to the next potential match; otherwise, skip„    '   ahead from this comparison location by the skip distance for„    '   the mismatch character, less the distance covered by the„    '   partial match.„„    !   sub     bx,bx          ;prepare for word addressing off byte value„    !   mov     bl,es:[di]     ;get the value of the mismatch byte in buffer„    !   add     bx,bx          ;prepare for word look-up„    !   add     bx,sp          ;SP points to SkipTable„    !   mov     cx,ss:[bx]     ;get the skip value for this mismatch„    !   mov     ax,1           ;assume we'll just advance to the next„    !                          ; potential match location„    !   sub     cx,si          ;is the skip far enough to be worth taking?„    !   jna     MoveAhead      ;no, go with the default advance of 1„    !   mov     ax,cx          ;yes; this is the distance to skip ahead from„    !                          ; the last potential match location checked„„MoveAhead:„    '   Skip ahead and perform the next comparison, if there's any buffer„    '   left to check.„„    !   mov     di,BuffPtr„    !   add     di,ax          ;BuffPtr += Skip„    !   mov     cx,BuffLen„    !   sub     cx,ax          ;BuffLen -= Skip;„    !   ja      SearchLoop     ;continue if any buffer left„„    '   Return a NULL pointer for no match.„„NoMatch:„    !   sub     ax,ax„    !   jmp     short Done„„    '   Return start of match in buffer (BuffPtr - (PatLen - 1)).„„Matched:„    !   mov ax, BuffPtr„    !   sub ax, TrueBuffPtr„    !   sub ax, PatLen„„    !   les bx, [bp+&HE]„    !   add ax, es:[bx]         ; Parameter: TheStart„„    !   inc ax„    !   mov FUNCTION, ax„„Done:„    !   cld„    !   add     sp,256*2       ;deallocate space for SkipTable„    !   pop     ds„    !   pop     es„    !   pop     di             ;restore caller's register variables„    !   pop     si„    !   pop     sp„„EXIT FUNCTION„„QuickSearchLoop:„    !   mov     bl,es:[di]     ;rightmost buffer byte at this location„    !   cmp     dl,bl          ;does it match the rightmost pattern byte?„    !   jz      FullCompare    ;yes, so keep going„    !   sub     bh,bh          ;convert to a word„    !   add     bx,bx          ;prepare for look-up in SkipTable„„    !   mov     ax,ss:[si+bx]  ;get skip value from skip table for this„    !                          ; mismatch value„„    !   add     di,ax          ;BuffPtr += Skip;„    !   sub     cx,ax          ;BuffLen -= Skip;„    !   ja      QuickSearchLoop;continue if any buffer left„    !   jmp     short NoMatch„„    '   Return a pointer to the start of the buffer (for 0-length„    '   pattern).„„END FUNCTION„Thomas Gohel                   TSR-CLOCK                      alt.lang.basic                 10-31-95 (00:00)       PB                     141  3699     TSRCLOCK.BAS'> Is there a way to have the ON TIMER() loop use a value less than 1 second?„'> I was hoping for 16 times a second.  Otherwise, how can I specify„'> the ON UEVENT to look for INT 1 (I believe that's the interrupt that is„'> called 18.2 times a second--timer tick)?„„'Here is a source for a INT1C clock. The routine is called 18.2 times in a„'second:„„'*************************************************************************„'„'  demonstration for a little TSR-clock with PowerBASIC 3.0/3.2„'„'  copyright by Thomas Gohel, GERMANY„'„'*************************************************************************„„$COMPILE EXE "PBCLOCK.EXE"„$OPTION CNTLBREAK OFF„„CLS„TSRClock "ON"                              ' Clock on„SHELL„TSRClock "OFF"                             ' Clock off„END„„SUB TSRClock(Action$) public„„        SELECT CASE Action$„            CASE "ON", "EIN", "+"„                NewIntVektorSeg?? = CODESEG(Time)„                NewIntVektorOff?? = CODEPTR(Time)„                ! call GetOldInterruptVektor„                ! call SetNewInterruptVektor„            CASE "OFF", "AUS", "-"„                ! call SetOldInterruptVektor„            CASE ELSE„                PRINT "illegal function call!"„        END SELECT„        EXIT SUB„„        Time:„„        ! push  ax„        ! push  bx„        ! push  cx„        ! push  dx„        ! push  si„        ! push  di„        ! push  bp„        ! push  ds„        ! push  es„„        ! mov   ax, &hb800               ;Set the Video-RAM„        ! mov   es, ax„        ! mov   bx, 142                  ;Set the position„        ! mov   al, &h04„        ! out &h70, al„        ! in    al, &h71„        ! call WriteTime„        ! call WriteHyphen„        ! mov   al, &h02„        ! out &h70, al„        ! in    al, &h71„        ! call WriteTime„        ! call WriteHyphen„        ! mov   al, &h00„        ! out &h70, al„        ! in    al, &h71„        ! call WriteTime„        ! pop   es„        ! pop   ds„        ! pop   bp„        ! pop   di„        ! pop   si„        ! pop   dx„        ! pop   cx„        ! pop   bx„        ! pop   ax„        ! jmp dword OldTimerProcedure    ; jump old handler (incl. IRET)„„        WriteTime:„        ! mov   ah, al„        ! mov   cl, 4„        ! shr   ah, cl„        ! mov   ch, ah„        ! shl   ch, cl„        ! sub   al, ch„        ! add   ah, 48„        ! add   al, 48„        ! mov   cl, 11                    ;set color„        ! mov   es:[bx], ah„        ! inc   bx„        ! mov   es:[bx], cl„        ! inc   bx„        ! mov   es:[bx], al„        ! inc   bx„        ! mov   es:[bx], cl„        ! inc   bx„        ! retn„„        WriteHyphen:„        ! mov   ah, 58„        ! mov   es:[bx], ah„        ! inc   bx„        ! mov   es:[bx], cl„        ! inc   bx„        ! retn„„        SetNewInterruptVektor:„        ! push ds„        ! mov  ah, &h25„        ! mov  al, &h1C„        ! mov  dx, NewIntVektorOff??„        ! mov  ds, NewIntVektorSeg??„        ! int  &h21„        ! pop  ds„        ! retn„„        SetOldInterruptVektor:„        ! push ds„        ! mov  ah, &h25„        ! mov  al, &h1C„        ! mov  dx, OldTimerProcedure[00]„        ! mov  ds, OldTimerProcedure[02]„        ! int  &h21„        ! pop  ds„        ! retn„„        GetOldInterruptVektor:„        ! push ds„        ! mov ah, &h35„        ! mov al, &h1C„        ! int &h21„        ! pop ds„        ! mov OldTimerProcedure[02], es„        ! mov OldTimerProcedure[00], bx„        ! retn„„        OldTimerProcedure:                ' old Int1C-pointer„        ! dd 0„END SUB„Jamshid Khoshrangi             ARRAYS OF ARRAYS               qjackson@direct.ca             12-19-95 (14:15)       PB32                   369  8496     ARRARR.BAS  $IF 0„„    ARRARR.BAS                                                  ARRARR.BAS„„                     Arrays of Arrays Demonstration Code„„                  Copyright 1995 by AhuraMazda(tm) Software„„                         (FOR POWERBASIC 3.2 ONLY!)„„                        Written by Jamshid Khoshrangi„„                   This program is copyrighted freeware.„„$ENDIF„„$IF 0„„    NOTE:„„    The purpose of this file is to explore creating "arrays of arrays."„„    I would like to create an array of string arrays, where each subarray„    can be of an indeterminite length.  The trouble with "native" two„    dimensional string arrays is that they are x by y elements in size.„„    This demonstration shows how it is possible to create an array of„    arrays where each subarray has a unique number of elements.„„    This is an experimental program, so I don't guarantee anything.„    It's not the prettiest code in the world.„„    I hope it helps you as much as it has me!„„    Jamshid„„$ENDIF„„DEFINT A-Z„„%DESC.LENGTH = 64„„DIM ListNameArray(1:32) AS SHARED STRING„DIM ListDescArray(1:32) AS SHARED STRING * %DESC.LENGTH„„DIM NumLists AS SHARED INTEGER„„LoggedList$ = "NONE"„„DO„    CLS„    PRINT„    PRINT "Currently logged to list {"; LoggedList$; "}"„    PRINT„    PRINT "C)reate List"„    PRINT "A)dd member to list"„    PRINT "S)witch to list"„    PRINT "D)isplay list"„    PRINT "F)ind member"„    PRINT "Q)uit"„„    DO„        K$ = UCASE$(INKEY$)„    LOOP UNTIL LEN(K$)„„    SELECT CASE K$„        CASE "Q"„            EXIT DO„„        CASE "C"„            ListCreate LoggedList$„„        CASE "A"„            ListMemberAdd LoggedList$„„        CASE "S"„            ListSwitch LoggedList$„„        CASE "D"„            ListDisplay LoggedList$„„        CASE "F"„            ListMemberFind„„    END SELECT„„LOOP„„CLS„PRINT "Demo summary information:"„„FOR i = 1 TO NumLists„    REDIM Temp(1) AS STRING„    ArrayFromArrayGet ListDescArray(i), Temp()„    PRINT "Subarray {";ListNameArray(i);"} has"; UBOUND(temp); "element(s)."„    ArrayToArrayPut ListDescArray(i), Temp()„NEXT i„„PRINT„PRINT "Thank you for trying this program out!"„BEEP 2„„SUB ListCreate (ListName AS STRING)„„    ' creating a list has the side effect of logging onto that list„„    CLS„    PRINT "Create List"„    PRINT„    LINE INPUT "New List Name: "; NewList$„„    ARRAY SCAN ListNameArray(), = NewList$, TO ListPtr„    IF ListPtr THEN„        PRINT "List already exists!"„        PRINT "Hit any key to continue...."„        SLEEP„        EXIT SUB„„    ELSE„„        INCR NumLists„        IF NumLists < UBOUND(ListDescArray) THEN„            ListName = NewList$„            ListNameArray(NumLists) = NewList$„            DIM Holder(0:0) AS STRING„            ArrayToArrayPut ListDescArray(NumLists), Holder()„        ELSE„            PRINT "List limit reached!"„            PRINT "Hit any key to continue...."„            SLEEP„        END IF„„    END IF„„END SUB„„SUB ListMemberAdd (LoggedList AS STRING)„„    IF LoggedList = "NONE" THEN„        PRINT„        PRINT "You must first log onto a list!"„        PRINT "Hit any key to continue...."„        SLEEP„        EXIT SUB„    ELSE„        CLS„        PRINT "Add member to list {"; LoggedList; "}"„        PRINT„        LINE INPUT "New member: "; NewMember$„„        ARRAY SCAN ListNameArray(), = LoggedList, TO ListPtr„„        DIM Temp(1) AS STRING„        ArrayFromArrayGet ListDescArray(ListPtr), Temp()„„        TopElem = UBOUND(Temp) + 1„        REDIM.PRESERVE Temp(), TopElem„        Temp(TopElem) = NewMember$„„        ' we must be sure to put the array back into the holder array„        ArrayToArrayPut ListDescArray(ListPtr), Temp()„„    END IF„„END SUB„„SUB ListSwitch (LoggedList AS STRING)„„    DO„        CLS„        PRINT "Switch lists"„        PRINT„„        FOR i = 1 TO NumLists„            PRINT ListNameArray(i),„        NEXT i„        PRINT„        PRINT„        LINE INPUT "Log onto list: "; NewList$„„        ARRAY SCAN ListNameArray(), = NewList$, TO ListPtr„        IF ListPtr THEN„            LoggedList = NewList$„            EXIT DO„        END IF„        PRINT„        PRINT "List does not exist!"„        PRINT "Hit any key to reenter...."„        SLEEP„    LOOP„„END SUB„„SUB ListDisplay (LoggedList AS STRING)„„    IF LoggedList = "NONE" THEN„        PRINT„        PRINT "You must first log onto a list!"„        PRINT "Hit any key to continue...."„        SLEEP„        EXIT SUB„    ELSE„        CLS„        PRINT "Display of members of list {"; LoggedList; "}"„        PRINT„„        ARRAY SCAN ListNameArray(), = LoggedList, TO ListPtr„„        DIM Temp(1) AS STRING„        ArrayFromArrayGet ListDescArray(ListPtr), Temp()„„        FOR i = 1 TO UBOUND(Temp)„            PRINT Temp(i)„        NEXT i„„        ' we must be sure to put the array back into the holder array„        ArrayToArrayPut ListDescArray(ListPtr), Temp()„„        PRINT„        PRINT "Hit any key to continue...."„        SLEEP„„    END IF„„END SUB„„„SUB ListMemberFind ()„„    CLS„    PRINT "Find first member"„    PRINT„    LINE INPUT "Member to find: "; TheMember$„„    IF NumLists = 0 THEN„        PRINT "You must create at least one list to use this feature!"„        PRINT "Hit any key to continue...."„        SLEEP„        EXIT SUB„    END IF„„    ArrayArrayScan ListDescArray(), TheMember$, OutPtr, OutElem„„    IF OutElem THEN„        PRINT„        PRINT "The member '";TheMember$; "' was first found in"„        PRINT "the list called {"; ListNameArray(OutElem);"}."„        PRINT "It was element number"; OutPtr;"in that list."„        PRINT„        PRINT "Hit any key to continue...."„        SLEEP„„    ELSE„        PRINT "Member not found in any list."„        PRINT "Hit any key to continue...."„        SLEEP„    END IF„„END SUB„„SUB ArrayArrayScan (_„    DescArray() AS STRING * %DESC.LENGTH,_„    Test AS STRING,_„    OutPtr AS INTEGER,_„    OutElem AS INTEGER)„„    DIM Temp(0:0) AS STRING„„    FOR i = 1 TO UBOUND(DescArray)„        IF DescArray(i) <> STRING$(%DESC.LENGTH,0) THEN„            ArrayFromArrayGet DescArray(i), Temp()„„            ARRAY SCAN Temp(), =Test, TO OutPtr„„            ' we must be sure to put the array back into the holder array„            ArrayToArrayPut DescArray(i), Temp()„        END IF„        IF OutPtr THEN„            OutElem = i„            EXIT SUB„        END IF„    NEXT i„„END SUB„„SUB ArrayFromArrayGet (_„    DescArray AS STRING * %DESC.LENGTH,_„    ANY)„„    DIM Source AS DWORD„„    ! mov ax, [bp+6]„    ! mov bx, [bp+8]„    ! mov Source[0], ax„    ! mov Source[2], bx„„    Dest???   = VARPTR32(DescArray)„„    DIM InDesc  AS STRING PTR * %DESC.LENGTH„    DIM OutDesc AS STRING PTR * %DESC.LENGTH„„    InDesc = Source„    OutDesc = Dest???„„    SWAP @InDesc, @OutDesc„„END SUB„„„SUB ArrayToArrayPut (_„    DescArray AS STRING * %DESC.LENGTH,_„    ANY)„„    '   NOTE:  Once the array has been PUT to the holder array, it„    '   MUST NOT BE EXPLICITLY ACCESSED!„„    DIM Source AS DWORD„„    ! mov ax, [bp+6]„    ! mov bx, [bp+8]„    ! mov Source[0], ax„    ! mov Source[2], bx„„    Dest???   = VARPTR32(DescArray)„„    DIM InDesc  AS STRING PTR * %DESC.LENGTH„    DIM OutDesc AS STRING PTR * %DESC.LENGTH„„    InDesc = Source„    OutDesc = Dest???„„    SWAP @InDesc, @OutDesc„„END SUB„„%TRUE   =   -1„%FALSE  =   NOT %TRUE„„SUB REDIM.PRESERVE (InArray() AS STRING, NewMax AS INTEGER)„„ArrayStart  = LBOUND (InArray)„ArrayEnd    = UBOUND(InArray)„„'   We'd better make it HUGE, just in case the original array was„'   huge....„DIM HUGE OutArray(ArrayStart:NewMax) AS STRING„„SELECT CASE NewMax > ArrayEnd„  CASE %TRUE„        FOR i = ArrayStart TO ArrayEnd„          OutArray(i) = InArray(i)„        NEXT i„        REDIM InArray(ArrayStart:NewMax) AS STRING„        FOR i = ArrayStart TO ArrayEnd„            InArray(i) = OutArray(i)„        NEXT i„„    CASE %FALSE„        FOR i = ArrayStart TO NewMax„            OutArray(i) = InArray(i)„        NEXT i„        REDIM InArray(ArrayStart:NewMax) AS STRING„        FOR i = ArrayStart TO NewMax„            InArray(i) = OutArray(i)„        NEXT i„„END SELECT„„END SUB„Jamshid Khoshrangi             UPPERCASE PB LINE OF CODE      qjackson@direct.ca             12-20-95 (00:00)       PB                     85   2126     PB_UCASE.BAS$IF 0„„                           Released to the public domain.„                           Written by Jamshid Khoshrangi.„„                                    20 DEC 1995„„    PB_UCASE() returns the uppercase of a PowerBASIC line of code --„„    That is to say, everything is uppercased that is OUTSIDE of quotes„    and that ISN'T a comment.„„    I've used as many tricks as I can think of to make it as fast as„    possible, short of using inline ASM.„„    For speed, this code uses pointers, and therefore is compatible „    with PowerBASIC 3.2+ only.„„$ENDIF„„DEFINT A-Z„„CLS„„Q$= CHR$(34)„„InText$ = "Print "+Q$+"This is a test!"+Q$+_„          "; SomeOtherStuff ' This is a comment"„„'InText$ = "Print 5 ' comment"„„PRINT InText$„„MTIMER„Temp$ = PB_UCASE (InText$)„PRINT MTIMER„„PRINT Temp$„„FUNCTION PB_UCASE (BYVAL InText AS STRING) AS STRING„„    FirstQuote = INSTR(InText, CHR$(34))„„    ' We uppercase every up to the first quotatation mark.  It's a„    ' bit faster this way, since we can skip over a lot of initial„    ' command stuff at once.„    MID$(InText, 1, FirstQuote) = UCASE$(LEFT$(InText, FirstQuote))„„    ' I love pointers.  Thank you PowerBASIC!„    DIM InTextPtr AS BYTE PTR„    InTextPtr  = STRPTR32(InText) + FirstQuote„„    IF FirstQuote THEN„        InLiteral = -1„    END IF„„    FOR i = 1 TO LEN(InText) - FirstQuote„„        IF @InTextPtr > 96 THEN„            IF @InTextPtr < 123 THEN„                IF NOT InLiteral THEN„                    '   This has the effect of uppercasing the byte.„                    BIT RESET @InTextPtr, 5„                END IF„            END IF„        ELSE„            IF @InTextPtr = 34 THEN„                InLiteral = NOT InLiteral„            ELSE„                IF NOT InLiteral THEN„                    IF @InTextPtr = 39 THEN„                        FUNCTION = InText„                        EXIT FUNCTION„                    END IF„                END IF„            END IF„        END IF„„        INCR InTextPtr„„    NEXT i„„    FUNCTION = InText„„END FUNCTION„Alexander Podkolzin            PB SOURCE CODE BEAUTIFIER      app@sbank.e-burg.su            12/94 (00:00)          PB                     631  23857    PBB.BAS     ' First of all, excuse me for my English. This program is a greate deal an„' exercise in English language, not in BASIC. It's a pity, but English for„' me is "dead" language, as Latin for instance. Just image: I'v never talked„' with any alive English speaking person...„' I'v been using this program from the beginning of 1995, suc·essfully :)„' Last revision: December,1994.„'---------------------------------------------------------------------------„'                          PowerBASIC 3.0C „'    Demonstrates some features of the best BASIC of the 20th century.„'                    Author: Alexander Podkolzin,„'                       app@nw.sbank.e-burg.su„'               Choose an author as you choose a friend!„'               USERS! THERE IS NO ANY WARRANTY FOR YOU,„'                      USE IT ON YOUR OWN RISK !„'                     This program is "FREEWARE"„'                     Fortune favours the brave !„'                    Any suggestions are welcomed!„'---------------------------------------------------------------------------„ $lib all off„ $optimize speed„ $compile exe„'---------------------------------------------------------------------------„' This program does not change your initial code.    It creates a new file„' to look through (with extension ".app") and has to be run with  filename„' you want to modify with any combination of following keys„' ( default is "/b/c/d" ):„'„'                /b..............beautifying (attempt of)„'                /c....................uppercase keywords„'                /d..................delete empty strings„'                /l....................lowercase keywords„'                /m...........minimize blanks in comments„'                /n.....................strip all indents„'                /s....................strip all comments.„'„' You can incert all these keys into the first line of your program. In„' this case first line has to contain "$PBB", followed by those keys„' and "'" in the first position, e.g.: "'     $PBB /b/c/d".„'„' P.S......Well, you know, not only programming but simple writing„'          also is a great deal of art.  So do not hope  that the„'          program will make all job for you.  Only 80%! If you want„'          a thing well done, do it yourself.„'„' P.P.S... Beauty is in the eye of the beer holder...„'„' P.P.P.S..Remember: Every last error in my program really is the last,„'                    but one.         :)„'---------------------------------------------------------------------------„' This BEAUTIFIER:  (Of course my own programming style caused its features)„'„'      - does not change your initial file;„'      - does not change strings inside block $IF 0 ... $ENDIF;„'      - does not separates long statements with "_", as nobody can foresee„'        all possible cases, even Me :-) .    I denyed  separation as it's„'        a 5% of work, but to program it I have to do 3 times more  code!„'      - does not devide strings such as "IF ... THEN ... : ... : ..."„'      - does (about comments):„'        = if nitial comment begins from 1st position it remains there,„'          in all other cases comment is to be placed from position„'          of comment (%commentpos);„'        = if comment can't be placed from %commentpos (statement is„'          longer), then it's to be placed from his statement`s position;„'„' Demands to initial code:        ( Yes, there are many things depending„'                                   on your style )„'„' 1.  The number of quotational marks in a string have to be even.„' 2.  Syntax of initial text has to submit to PowerBASIC rules, as some„'     BASICs have different key words (for example "END IF" and "ENDIF").„' 3.  ...?„'„' Play with the program and find what key (combination) you prefer.„' You can enhance the program easyly, as it's written in clear manner.„' For more readability of the code I separate logical conditions in basic„' places.„' Perhaps,there is a some kind of superfluousness in the program, sorry.„' I wish you an excelent beautifying with this program!„'---------------------------------------------------------------------------„defint a-z„'---------------------------------------------------------------------------„' Tastes differ...„„%indent     =   2         ' unconditional indent„ %delta      =   3         ' indent for structured statements„  %indntincr  =   2         ' indent increment„   %maxlen     =  77         ' maximum length of line„    %maxelem    =  10         ' maximum number of string constants in a line„     %commentpos =  41         ' from this position comment begins,„                                ' if a string is longer then %commentpos,„                                 ' comment is being placed before the string„     %FALSE = 0„     %TRUE  = NOT %FALSE„„     SkipBeforeLabel = %TRUE     ' if you need blank lines before label„„'---------------------------------------------------------------------------„if command$="" then„   print "Using: <name[.ext]> /b/c/d/l/m/n/s"„    print "/b - beautifying,"„     print "/c - uppercase keywords,"„      print "/d - delete empty strings,"„       print "/l - lowercase keywords,"„        print "/m - shorten blanks in comments,"„         print "/n - strip indents,"„          print "/s - strip comments."„           end„end if„„if %delta<>0 then                 ' It is a good horse that never stumbles.„     del$     = space$(%delta)„     else„     del$     = ""„end if„„if %indntincr<>0 then„     indinc$  = space$(%indntincr)„     else„     indinc$  = ""„end if„„if %indent<>0 then„     ind$     = space$(   %indent)„     ind0$=ind$„else„     ind$     = ""„end if„'---------------------------------------------------------------------------„delempty  = %FALSE         ' Tell that to the marines...„needupper    =   %FALSE„ needlower      =     %FALSE„  minblanks        =       %FALSE„  needbeauty          =         %FALSE„ stripindents            =           %FALSE„ stripcomments              =             %FALSE„„  task$=combme$(lcase$(command$))„„  n=instr(task$,".")„  if n<>0 then„    filename$  = left$(task$,n-1)„    extension$ = mid$(task$,n,4)„  else„    filename$  = task$„    extension$ = ".bas"„  end if„„if len(filename$)=0 then„  print "Bad filename!"„  end„end if„„if extension$ = ".app" then„   print "Extension .APP is not allowed!"    ' so Let well alone...„   end„end if„'---------------------------------------------------------------------------„'          Why doesn't DOS ever say "EXCELLENT command or filename!"„'---------------------------------------------------------------------------„„if instr(task$,"/") = 0 then      ' default combination of keys„   sourcefile = freefile„   open filename$+extension$ for input  as sourcefile„   line input #sourcefile,s$„   s$=lcase$(s$)„   close sourcefile„   if instr(s$,"$pbb ")<>0 and instr(s$,"/")<>0 then„      task$=task$+mid$(s$,instr(s$,"/"))„   else„      task$=task$+"/b/c/d"„   end if„end if„„if instr(task$,"/b") then         ' beauty indents„         task$=remove$(task$,"/b")„              needbeauty   = %TRUE„                            end if„if instr(task$,"/c") then         ' uppercase reserved words„         task$=remove$(task$,"/c")„             needupper     = %TRUE„                            end if„if instr(task$,"/l") then         ' lowercase reserved words„         task$=remove$(task$,"/l")„             needlower     = %TRUE„                            end if„if instr(task$,"/d") then         ' delete empty strings„         task$=remove$(task$,"/d")„              delempty     = %TRUE„                            end if„if instr(task$,"/m") then         ' minimize blanks in comments„         task$=remove$(task$,"/m")„              minblanks    = %TRUE„                            end if„if instr(task$,"/n") then         ' remove all indents„         task$=remove$(task$,"/n")„              stripindents = %TRUE„                            end if„if instr(task$,"/s") then         ' remove all comments„         task$=remove$(task$,"/s")„              stripcomments= %TRUE„                            end if„'---------------------------------------------------------------------------„' Here we are preparing the   '            The more haste, the less speed...„' string  of reserved  words. '„' String, because  INSTR  is  '„' faster  then    ARRAY SCAN. '    Buy a Pentium so you can reboot faster...„'„  dim mi%(%maxelem,2)„„  while s$<>"Goodbye!"„     read s$„     reswd$=reswd$+s$„  wend„'---------------------------------------------------------------------------„' Come on!  Well begun is half done...„„t#=timer  ' We shell see how the cat jump...„„sourcefile = freefile„open filename$+extension$ for input  as sourcefile„destfile = freefile„open filename$+".app"   for output as destfile„nline=0„„s$="' Date of the last formatting = " + DATE$ + "  " + TIME$„PRINT #destfile,s$„„DO        ' begin of the main loop„„  if eof(sourcefile) then  exit loop„  line input #sourcefile,s$„  incr nline„„  if s$ = "" then            ' do we need empty strings ?„     if delempty then„        iterate              ' No? we don't.„     else„        gosub printme        ' Yes, of course.„     end if„  end if„  z$=lcase$(left$(ltrim$(s$),6))„„  if instr(z$, "$if 0")<>0  then„     skipblock = %TRUE„     gosub printme„     iterate„  end if„„  if instr(z$,"$endif")<>0  then„     skipblock = %FALSE„     gosub printme„     iterate„  end if„„  if skipblock then          ' All lines inside of $IF 0 ... $ENDIF„    gosub printme            ' we have not to change... (My opinion).„    iterate„  end if                     ' And skip ASM-statements:„„  if left$(z$,1)="!" or left$(z$,4)="asm " then„    gosub printme„    iterate„  end if„„  if needbeauty or stripindents then„    oldindent$=""„  else„    oldindent$=leadingblanks$(s$)„  end if„  s$=removerubbish$(s$)„'---------------------------------------------------------------------------„  call separate(s$,lin$,comment$,cp) ' To pick the plums out of the pudding„„  if minblanks then„    comment$=combme$(comment$)„  end if„„  if ltrim$(lin$)="" then„    nostmnt = %TRUE„  else„    nostmnt = %FALSE„  end if„'---------------------------------------------------------------------------„  if nquo%(lin$,mi%()) then   ' makes info about string constants.„   beep„    print "Error (ODD QUOTE). Correct this error in line #"; nline„     print "and restart program. Write down the line # and press a key."„      z$=input$(1)„       end if„'---------------------------------------------------------------------------„' We have to fill all blanks with any special simbol for not to harm  the„' string constants„for  i=1 to %maxelem„  if mi%(i,1)=0 then exit for„    for  k=mi%(i,1) to mi%(i,2)„      if mid$(lin$,k,1)=" " then„        mid$(lin$,k,1)=chr$(5)„          end if„            next k„              next i„'---------------------------------------------------------------------------„lin$=combme$(lin$)   ' It's a string„cpy$=lin$            ' It's its copy„statement$=""„'---------------------------------------------------------------------------„' In this loop we sculpture '                What's done cannot be undone...„' a string word by word     '„„do while lin$<>""„  st$=getword$(lin$,del$)„  z$=st$„  z$=ucase$(z$)„  if needupper and isinlist(reswd$," "+z$+" ") then st$=ucase$(st$)„  if needlower and isinlist(reswd$," "+z$+" ") then st$=lcase$(st$)„  statement$=statement$+st$+del$„loop„'---------------------------------------------------------------------------„statement$ = combme$(statement$)„replace chr$(5) with " " in statement$         ' to restore our blanks„zorro$ = lcase$(statement$)„'--------------------------------------------------------------------------„' Here  we are checking the `ends` of sructured statements;„' `ends` before `begins`, as shift for begin has to be one string later.„' For more readability of the program I separate conditions:„'„   a = ( left$(zorro$, 6) =         "end if" )„   b = ( left$(zorro$, 4) =           "wend" )„   c = ( left$(zorro$,10) =     "end select" )„   d = ( left$(zorro$, 4) =           "loop" )„   e = ( left$(zorro$, 4) =           "next" )„   f = ( left$(zorro$, 8) =       "end type" )„   g = ( left$(zorro$,12) =   "end function" )„   h = ( left$(zorro$, 7) =        "end sub" )„„   if  a  OR  b  OR  c  OR  d  OR  e OR f OR g OR h then„     needshift=%FALSE„„     if c then„       if len(addshift$)>%delta then„         addshift$=space$(len(addshift$)-%delta)„       end if„     end if„„     if len(addshift$)>%delta then„       addshift$ = space$(len(addshift$) - %delta)„     else„       addshift$=""„     end if„   end if„„'--------------------------------------------------------------------------„fullshift$=oldindent$+ind$+addshift$„if not needbeauty           then„  statement$ = oldindent$+statement$„else„  statement$ = fullshift$+statement$„end if„if stripcomments            then„  comment$ = ""„  statement$=oldindent$+statement$„end if„z$=ltrim$(statement$)„if stripindents then  statement$ = z$„' --------------------------------------------------------------------------„' And now exceptions:                      The exception proves the rule...„'„a = (not stripindents) and needbeauty„b = (left$(lcase$(z$),4) = "else")„c = (left$(lcase$(z$),4) = "case")„if (a and b) or (c) and (not stripindents) then„   statement$ = right$(rtrim$(statement$),len(statement$)-%delta-1)„end if„'--------------------------------------------------------------------------„'                 Well, at last we'v reached our goal !„                          GOSUB printstring„'--------------------------------------------------------------------------„fullshift$=""„'--------------------------------------------------------------------------„' Here we are checking the `begins` of structured statements„„   a = (left$(zorro$, 3) =          "if ") and (right$(zorro$,5)="then ")„   b = (left$(zorro$, 6) =       "while ") and (instr(zorro$,"wend")=0)„   c = (left$(zorro$,12) = "select case ")„   d = (left$(zorro$, 3) =          "do ") and (instr(zorro$,"loop")=0)„   e = (left$(zorro$, 4) =         "for ") and (instr(zorro$,"next")=0)„   f = (left$(zorro$, 5) =        "type ")„   g = (left$(zorro$, 9) =    "function ")„   h = (left$(zorro$, 4) =        "sub " )„   i = (left$(zorro$, 3) =          "if ") and (right$(zorro$,2)="_ ")„„   if a OR b OR c OR d OR e OR f OR g OR h OR i then„     needshift=%TRUE„     addshift$=space$(len(addshift$) + %delta)„     if c then„       addshift$=addshift$+space$(%delta)„     end if„   end if„'--------------------------------------------------------------------------„LOOP ' end of the main loop„„close sourcefile„close destfile„„  print„  print„  print "Your COMMAND$ was: ";command$„  print "Total lines = "; nline„  print "Total time  = "; using$("####.###",timer-t#);" s."„  print "THANK YOU, Bye-Bye !"„'„'--------------------------------------------------------------------------„' Empty vessels make the greatest...„'„  sound 524,0.5 : delay 0.10      ' C„  sound 660,0.5 : delay 0.10      ' E„  sound 784,0.5 : delay 0.10      ' G„  sound 660,0.5 : delay 0.20      ' E„  sound 524,0.2 : delay 0.10      ' C„  sound 494,0.5 : delay 0.20      ' H„  sound 880,0.5 : delay 0.10      ' A„  sound 880,1.0 : delay 1.00      ' A„„'--------------------------------------------------------------------------„END  ' Bye-Bye !                               Out of sight, out of mind...„'--------------------------------------------------------------------------„printstring:„statement$ = rtrim$(statement$)„cpy$=rtrim$(cpy$)„'---------------------------------------------------------------------------„a = ( right$(cpy$,1) = ":" )„b = ( instr(cpy$, any " ()<>=\;+-,/*"+chr$(34) ) = 0)„if a and b  then                             ' In my humble opinion, labels„  statement$=ltrim$(statement$)              ' should be at the left margin.„     if SkipBeforeLabel then„       s$=""„       gosub printme„     end if„end if„'---------------------------------------------------------------------------„  comment$ = ltrim$(rtrim$(comment$))„„            if nostmnt then„              if cp=1 then„                s$=comment$„              else„                 s$=space$(cp)+comment$„              end if„              if s$<>"" and not stripcomments then„                 gosub printme„              end if„              return„            end if„'---------------------------------------------------------------------------„„  n = len(statement$)„  if n < %commentpos then              ' statement$ is not too long„    if comment$<>"" then„      d$=space$(%commentpos-n-1)„    else„      d$=""„    end if„    s$=statement$+d$+comment$„    gosub printme„  else                                 ' statement$ is too long„    if comment$<>"" then„      d$=leadingblanks$(statement$)„      s$=d$+ltrim$(comment$)„      gosub printme„    end if„    s$=statement$„    gosub printme„  end if„return„'---------------------------------------------------------------------------„printme:„    PRINT s$„    PRINT #destfile,s$„return„'--------------------------------------------------------------------------„FUNCTION isquoted%(ss$,n%,c$)  ' checks whether Nth simbol is quoted by c$„s$ = left$(ss$,n%-1)„isquoted% = (TALLY(s$,c$) mod 2) * (instr(n%+1,ss$,c$)<>0)„END FUNCTION„'--------------------------------------------------------------------------„FUNCTION removerubbish$(s$)„for  i%=1 to len(s$)„  k%=asc(mid$(s$,i%,1))„  if k%<32 then„    mid$(s$,i%,1)=" "„  end if„next i%„removerubbish$=s$„END FUNCTION„'--------------------------------------------------------------------------„FUNCTION nquo%(s$,mi%())„' Function creates info  about string constants in  s$.„' mi%(i,1).....................contains begin position,„' mi%(i,2)..contains end position of I-string constant.„' Returns:„' 1..........if there are ODD  number of '"' in string,„' 0..........if there are EVEN number of '"' in string.„„    for k%=1 to %MAXELEM              ' Cleaning„       mi%(k%,1)=0„       mi%(k%,2)=0„    next k%„    n% =len(s$)                       ' Little pitchers have long ears„    nquo%=0„    if n%=0 then exit function„    c$=chr$(34)„    nq%=instr(s$,c$)                  ' Position of the quotational mark„    if nq%=0 then exit function„    k%  = 1„    nk% = 0„    l%  = 1„    for i%=nq% to n%                  ' Here we are„      if mid$(s$,i%,1)=c$ then        ' making our array„         k%=k% xor 1„         mi%(l%,k%+1)=i%„         incr l%,k%„         incr nk%„      end if„    next i%„    nquo% = nk% mod 2„END FUNCTION„'--------------------------------------------------------------------------„FUNCTION getword$(ss$,del$)   ' Parser. Returns regular word - unit of text„s$   = extract$(ss$, any " =()<>\;:+-,/*")„getword$=s$„ss$  = ltrim$(ss$, s$)„del$ = left$(ss$,1)„ss$  = ltrim$(ss$)„if left$(ss$,1)=del$ then ss$  = mid$(ss$,2,len(ss$)-1)„END FUNCTION„'--------------------------------------------------------------------------„FUNCTION IsInList%(RW$,s$)„  if instr(1,RW$,s$)<>0 then„     isinlist%= %TRUE„  else„     isinlist%= %FALSE„  end if„END FUNCTION„'--------------------------------------------------------------------------„FUNCTION LeadingBlanks$(ss$)„  s$=ltrim$(ss$)„  n%=len(ss$)-len(s$)„  if n%=0 then„    leadingblanks$=""„  else„    leadingblanks$=space$(n%)„  end if„END FUNCTION„'--------------------------------------------------------------------------„FUNCTION CombMe$(ss$)„  ss$=ltrim$(rtrim$(ss$))„  do„    replace "  " with " " in ss$„  loop while instr(ss$,"  ")„  combme$=ss$+" "„END FUNCTION„'--------------------------------------------------------------------------„SUB Separate(s$,lin$,comment$,cp%)        ' separates line and comment„  c$=chr$(39)                             ' cp% - comment position„  lin$ =s$„  comment$=""„  cp%=0„  z$=ucase$(s$)+" "„  m%=instr(z$,"REM ")„  if m%<>0 then mid$(s$,m%,4)=chr$(39,32,32,32)„  k%=instr(s$,c$)„  if k%<>0 then„    if isquoted(s$,k%,chr$(34))=0 then„      lin$ =rtrim$(left$(s$,k%-1))„      comment$=right$(s$,len(s$)-k%+1)„      cp%=k%„      exit sub„    else„      exit sub„    end if„  end if„END SUB„„'^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^„'   ATTENTION!„' Every reserved word has to finish with " " (blank).„' The last word of the list has to be "Goodby!".„' If you want your own reserved words, which will be printed with caps or„' lowers, include them into this list!„'___________________________________________________________________________„„DATA "$ALIAS $CODE $COM $COM1 $COM2 $COMPILE $CPU $DEBUG $DIM $DYNAMIC "„DATA "$ELSE $ENDIF $ERROR $EVENT $FLOAT $HUGE $IF $INCLUDE $INLINE $LIB "„DATA "$LINK $OPTIMIZE $OPTION $SEGMENT $SOUND $STACK $STATIC $STRING ABS "„DATA "ABSOLUTE ACCESS ALL AND ANY APPEND ARRAY AS ASC ASCEND ASCII ASM AT "„DATA "ATN ATTRIB BASE BEEP BIN$ BINARY BIT BITS BLOAD BSAVE BYCOPY BYVAL "„DATA "CALL CASE CBCD CBYT CDBL CDWD CEIL CEXT CFIX CLNG CHAIN CHDIR CHDRIVE "„DATA "CHR$ CINT CIRCLE CLEAR CLNG CLOSE CLS CNTLBREAK COLLATE COLOR COM "„DATA "COMMAND$ COMMON COS CQUD CSNG CSRLIN CURDIR$ CVB CVD CVE CVF CVI CVL "„DATA "CVMD CVMS CVQ CVS CWRD DATA DATE$ DECLARE DECR DEF DEFBCD DEFDBL "„DATA "DEFEXT DEFFIX DEFFLX DEFINT DEFLNG DEFQUD DEFSNG DEFSTR DELAY DELETE "„DATA "DESCEND DIM DIR$ DO DRAW DYNAMIC ELSE ELSEIF EMS END ENDMEM ENVIRON "„DATA "ENVIRON$ EOF EQV ERADR ERASE ERDEV ERDEV$ ERL ERR ERROR ERRTEST EXE "„DATA "EXECUTE EXIT EXP EXP10 EXP2 EXTERNAL EXTRACT$ FAR FIELD FILEATTR "„DATA "FILES FIX FIXDIGITS FLEXCHR$ FLUSH FN FOR FRAC FRE FREEFILE FROM "„DATA "FUNCTION GET GETSTRLOC GET$ GOSUB GOTO HEX$ IF IMP IN INCR INKEY$ "„DATA "INP INPUT INPUT$ INSERT INSTAT INSTR INT INTERRUPT IOCTL IOCTL$ "„DATA "ISFALSE ISTRUE ITERATE KEY KILL LBOUND LCASE$ LEFT LEFT$ LEN LET "„DATA "LINE LIST LOC LOCAL LOCATE LOCK LOF LOG LOG10 LOG2 LOOP LPOS LPRINT "„DATA "LSET LTRIM$ MAP MAX MAX$ MAX% MEMPACK MEMSET MID$ MIN MIN$ MIN% MKDIR "„DATA "MKB$ MKD$ MKDWD$ MKE$ MKF$ MKI$ MKL$ MKMD$ MKMS$ MKQ$ MKS$ MKWRD$ MOD "„DATA "MTIMER MULTIPLEX NAME NEXT NOT OCT$ OFF ON OPEN OPTION OR OUT OUTPUT "„DATA "PAINT PALETTE PEEK PEEK$ PEEKI PEEKL PEN PLAY PMAP POINT POKE POKE$ "„DATA "POKEI POKEL POPUP POS PRESET PRINT PSET PUBLIC PUT PUT$ QUIET RANDOM "„DATA "RANDOMIZE READ REDIM REG REM REMOVE$ REPEAT$ REPLACE RESET RESTORE "„DATA "RESUME RETURN RIGHT RIGHT$ RMDIR RND ROTATE ROUND RSET RTRIM$ RUN "„DATA "SAVE SCAN SCREEN SEEK SEG SELECT SETMEM SGN SHARED SHELL SHIFT "„DATA "SIGNED SIN SLEEP SORT SOUND SPACE$ SPC SQR STATIC STEP STICK STOP TR$ "„DATA "STRIG STRING$ STRPTR STRSEG STUFF SUB SWAP SYSTEM TAB TAGARRAY TALLY "„DATA "TAN TEXT THEN TIME$ TIMER TO TROFF TRON TYPE UBOUND UCASE UCASE$ "„DATA "UEVENT UNION UNLOCK UNTIL USING USING$ VAL VARPTR VARPTR$ VARSEG "„DATA "VERIFY VIEW WAIT WEND WHILE WIDTH WINDOW WITH WRITE XOR "„DATA "KYBD: SCRN: CONS: LPT1: LPT2: LPT3: COM1: COM2: COM3: COM4: "„DATA "BYTE WORD INTEGER LONG DOUBLE STRING "„„DATA "Goodbye!"        ' End of The Key Words List.„„'^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^„' Sorry, my English would even a cat laugh...„' See P.P.P.S.!„'___________________________________________________________________________„„The ABC Programmer             CONNECT 4 PB                   Check GAMES.ABC For QB Version 12-28-95 (14:41)       PB                     290  7518     C4.BAS      '===================================================„' EGA CONNECT FOUR by William Yu  (Converted to PB)„'„' Only a few lines needed to be changed to get this„' up and running, have fun PB users!„'„' INSTRUCTIONS For Game Play:„'   Object of the game is to connect your coloured„'   chips four in a row, horizontally, vertically or„'   diagonally before the other person does.„'===================================================„„DEFINT A-Z„DECLARE SUB DrawGrid ()„DECLARE SUB DrawChip (X%, ChipColor%)„DECLARE SUB EraseChip (X%)„DECLARE SUB DropChip (X%, ChipColor%, Valid%)„DECLARE SUB SwitchTurn (X%, ChipColor%, ChipColor2%)„DECLARE SUB CheckForWin (Grid(), Row%, Col%, ChipColor%)„DECLARE SUB WhoWon (ChipColor%)„DECLARE SUB ComputerTurn (ChipColor%, ChipColor2%)„„SHARED True,False,Computer,User,Player,Level„„DIM Grid(8, 8) AS INTEGER   ' Do not change unless you know what you're doing„	True = 1       ' Define Constants„	False = 0„	Computer = 12  ' Define Colors for Computer/User„	User = 9       ' Computer = Red / User = Blue„				   ' Computer <> User„	Player = 1     ' One or Two Players„				   ' If two players then Player Two = Computer„	Level = 0      ' Level of difficulty against computer„				   ' 0 = Moronic„				   ' 1 = Easy          Please implement„				   ' 2 = Normal        computer difficulty„				   ' 3 = Hard„				   ' 4 = Really Hard„„SCREEN 7, 0, 0, 0      ' Change to other screen modes if desired„„DrawGrid               ' Call DrawGrid Subroutine (Draws Playing Field)„„GoesFirst = True       ' User goes first (Change to False to go second)„„IF GoesFirst THEN„  ChipColor = User     ' Using two variables for swapping later„  ChipColor2 = Computer„ELSE„   ChipColor = Computer„   ChipColor2 = User„   ComputerTurn ChipColor, ChipColor2„END IF„„X = 144              ' X value changes § 28„					 ' Leftend value  = 60„					 ' Rightend value = 256„Drops = 0            ' Setup Counter  (Max of 64 Drops before grid is filled)„„DO„  IF Drops = 64 THEN GOTO TieBreak„  DrawChip X, ChipColor„  DO„	K$ = INKEY$„  LOOP UNTIL K$ <> ""„„SELECT CASE K$„	CASE CHR$(0) + "M"          ' User Pressed RIGHT ARROW„		EraseChip X„		IF X < 256 THEN         ' Make sure it's not end of grid„			Incr X, 28„		ELSE                    ' Else go back to beginning„			X = 60„		END IF„	CASE CHR$(0) + "K"          ' User Pressed LEFT ARROW„		EraseChip X„		IF X > 60 THEN            ' Make sure it's not at beginning of grid„			Decr X, 28„		ELSE                      ' Else go to the end of the grid„			X = 256„		END IF„	CASE CHR$(0) + "P", CHR$(13)      ' User Pressed ENTER or DOWN„		DropChip X, ChipColor, Valid  ' Drop the Chip„		IF Valid = True THEN          ' Valid Drop„			SwitchTurn X, ChipColor, ChipColor2„			Incr Drops                ' Increase counter„			Valid = False„			IF Player = 1 AND Drops <> 64 THEN ComputerTurn ChipColor, ChipColor2„		END IF„	CASE CHR$(27)               ' User Pressed ESC  (Quit Program)„		GOTO ProgramEND„END SELECT„LOOP„„TieBreak:„  LOCATE 1, 1: COLOR 15: PRINT "It's a tie!"„„ProgramEND:„  END„„SUB CheckForWin (Grid(), Row, Col, ChipColor)„„'              <--- Column --->„'              1 2 3 4 5 6 7 8  XY„'              ----------------+„'              o o o o o o o o | 1„'              o o o o o o o o | 2„'              o o o o o o o o | 3„'              o o o o o o o o | 4„'  Start to -> o o o o o o o o | 5„'   Check      o o o o o o o o | 6„'    Down      o o o o o o o o | 7„'              o o o o o o o o | 8„'„' Here's what is checked first:„'„'   HORIZONTAL then VERTICAL then DIAGONAL„'„' You can change the order if you wish.„„Connect = 1„„FOR C = Col - 1 TO Col - 3 STEP -1„	IF C = 0 THEN EXIT FOR„	IF Grid(C, Row) = ChipColor THEN Incr Connect ELSE EXIT FOR„NEXT C„IF Connect = 4 THEN WhoWon ChipColor„FOR C = Col + 1 TO Col + 3„	IF C = 9 THEN EXIT FOR„	IF Grid(C, Row) = ChipColor THEN Incr Connect ELSE EXIT FOR„NEXT C„IF Connect = 4 THEN WhoWon ChipColor ELSE Connect = 1„„' Check Vertical, only if dropped chip is high enough to count downwards„' If not, forget checking„„IF Row < 6 THEN„	FOR C = Row + 1 TO Row + 3„		IF Grid(Col, C) = ChipColor THEN Incr Connect ELSE EXIT FOR„	NEXT C„END IF„IF Connect = 4 THEN WhoWon ChipColor ELSE Connect = 1„„„' Diagonal Check (Left Up/Down)„„BackRow = Row„FOR C = Col - 1 TO Col - 3 STEP -1„	IF C = 0 THEN EXIT FOR„	IF Row = 1 THEN EXIT FOR„	Decr Row„	IF Grid(C, Row) = ChipColor THEN Incr Connect ELSE EXIT FOR„NEXT C„IF Connect = 4 THEN WhoWon ChipColor„Row = BackRow„FOR C = Col + 1 TO Col + 3„	IF C = 9 THEN EXIT FOR„	IF Row = 8 THEN EXIT FOR„	Incr Row„	IF Grid(C, Row) = ChipColor THEN Incr Connect ELSE EXIT FOR„NEXT C„IF Connect = 4 THEN WhoWon ChipColor ELSE Connect = 1„„„' Diagonal Check (Right Up/Down)„„Row = BackRow„FOR C = Col + 1 TO Col + 3„	IF C = 9 THEN EXIT FOR„	IF Row = 1 THEN EXIT FOR„	Decr Row„	IF Grid(C, Row) = ChipColor THEN Incr Connect ELSE EXIT FOR„NEXT C„IF Connect = 4 THEN WhoWon ChipColor„Row = BackRow„FOR C = Col - 1 TO Col - 3 STEP -1„	IF C = 0 THEN EXIT FOR„	IF Row = 8 THEN EXIT FOR„	Incr Row„	IF Grid(C, Row) = ChipColor THEN Incr Connect ELSE EXIT FOR„NEXT C„IF Connect = 4 THEN WhoWon ChipColor ELSE Connect = 1„„END SUB„„SUB ComputerTurn (ChipColor, ChipColor2)„„SELECT CASE Level„	CASE 0„	  DO„		RANDOMIZE TIMER„		Col = INT(RND * 8) + 1„		X = 60 + ((Col - 1) * 28)„		DropChip X, ChipColor, Valid„	  LOOP UNTIL Valid = True„	CASE 1„	CASE 2„	CASE 3„	CASE 4„END SELECT„„SwitchTurn X, ChipColor, ChipColor2„„END SUB„„SUB DrawChip (X, ChipColor)„„CIRCLE (X, 7), 8, ChipColor„PAINT (X, 7), ChipColor„„END SUB„„SUB DrawGrid„„LINE (45, 20)-(270, 180), 14, BF„LINE (51, 17)-(275, 17), 14„LINE (275, 17)-(275, 175), 14„LINE (51, 17)-(45, 20), 14„LINE (275, 17)-(270, 20), 14„LINE (275, 175)-(270, 180), 14„PAINT (273, 100), 6, 14„LINE (45, 181)-(270, 181), 12„LINE (276, 175)-(290, 189), 12„LINE (45, 181)-(31, 195), 12„LINE (270, 181)-(284, 195), 12„LINE (31, 195)-(284, 195), 12„LINE (290, 189)-(284, 195), 12„LINE (275, 176)-(270, 181), 12„PAINT (150, 185), 12„PAINT (282, 184), 4, 12„„FOR Y = 30 TO 170 STEP 20„	FOR X = 60 TO 260 STEP 28„		CIRCLE (X, Y), 8, 0„		PAINT (X, Y), 0, 0„		CIRCLE (X, Y), 6, 14, 4.6, .1„	NEXT X„NEXT Y„„END SUB„„SUB DropChip (X, ChipColor, Valid) SHARED„„Col = (X - 60) / 28 + 1        ' Calculates the Column (1-8)„„FOR C = 8 TO 2 STEP -1„	IF Grid(Col, C) = False THEN EXIT FOR„NEXT C„„IF Grid(Col, C) = False THEN     ' Empty Holder, place your chip here„	Grid(Col, C) = ChipColor     ' Make it filled„	Row = ((C - 1) * 20) + 30    ' Calculate the Row„	CIRCLE (X, Row), 8, 8        ' Make Chip border color Dark Grey„	PAINT (X, Row), ChipColor, 8 ' Fill chip color„	Valid = True„	CheckForWin Grid(), C, Col, ChipColor„END IF„„END SUB„„SUB EraseChip (X)„„PAINT (X, 7), 0„„END SUB„„SUB SwitchTurn (X, ChipColor, ChipColor2)„„EraseChip X„SWAP ChipColor, ChipColor2    ' Swap the two variables„X = 144                       ' Reset X Coordinates„DrawChip X, ChipColor„„END SUB„„SUB WhoWon (ChipColor)„„' Check who wins„' Do whatever you want for the closing screen„„IF ChipColor = User THEN„	IF Player = 1 THEN PRINT "You Win!" ELSE PRINT "Player One Wins!"„ELSE„	IF Player = 1 THEN PRINT "Computer Wins!" ELSE PRINT "Player Two Wins!"„END IF„„END„„END SUB„„The ABC Programmer             OTHELLO REVISED FOR PB         Check GAMES.ABC For QB Version 12-29-95 (12:19)       PB                     362  8353     OTHELLO.BAS  '==========================================================„ ' Othello Revision by William Yu [1995]  (Converted to PB)„ '„ ' Minimum Requirements:  EGA„ '„ ' Instructions for gameplay:„ '„ '   The basis of the game relies on turning the other„ '   players "chips" over.  The more "chips" that you turn„ '   over results in more "chips" of your color on the„ '   board.  In the end, the player with the most "chips"„ '   of their color on the grid wins the game!„ '„ ' Enjoy this game, the computer does random moves so it'll„ ' be a snap to kick its butt.„ '==========================================================„„ DEFINT A-Z„ CLS: SCREEN 7,0,0,0„„ BEGINGAME:„ X = 0: Y = 0: W = 230: Z = 190„ LINE (15, 15)-(215, 175), 15, B„ LINE (14, 14)-(216, 176), 7, B„ LINE (13, 13)-(217, 177), 8, B„ PAINT (150, 100), 7, 15„ FOR X = 35 TO 205 STEP 20„   LINE (X, 15)-(X, 175), 15„ NEXT X„ FOR Y = 31 TO 180 STEP 16„   LINE (15, Y)-(215, Y), 15„ NEXT Y„ PC = 12„ PLAYERC = 9„ CIRCLE (105, 87), 7, PLAYERC„ PAINT (105, 87), PLAYERC„ CIRCLE (125, 87), 7, PC„ PAINT (125, 87), PC„ CIRCLE (105, 103), 7, PC„ PAINT (105, 103), PC„ CIRCLE (125, 103), 7, PLAYERC„ PAINT (125, 103), PLAYERC„„ LOCATE 2, 32: COLOR 15: PRINT "OTHELLO"„ LINE (95, 79)-(115, 95), 0, B„ X = 95: Y = 79: W = 115: Z = 95„„ CIRCLE (275, 30), 7, PLAYERC„ PAINT (275, 30), PLAYERC„ COLOR 15,0„ LOCATE 9, 32: PRINT "PLAYERS"„ LOCATE 11, 31: PRINT "1. ONE"„ LOCATE 13, 31: PRINT "2. TWO"„ DO„   A$ = INPUT$(1)„ LOOP UNTIL A$ = "1" OR A$ = "2"„ LOCATE 9, 32: PRINT SPACE$(7)„ LOCATE 11, 31: PRINT SPACE$(6)„ LOCATE 13, 31: PRINT SPACE$(6)„ IF A$ = "1" THEN PLAYER = 1 ELSE PLAYER = 2„ LOCATE 20, 32: PRINT CHR$(34); : COLOR 10: PRINT "P"; : COLOR 15: PRINT CHR$(34); "ass"„ LOCATE 22, 32: PRINT CHR$(34); : COLOR 10: PRINT "Q"; : COLOR 15: PRINT CHR$(34); "uit"„ BOX = 4„„ DO„   IF PLAYERC = 12 AND PLAYER = 1 THEN GOSUB COMPUTER„   V$ = INKEY$„   IF V$ = CHR$(0) + "P" THEN GOSUB DOWN„   IF V$ = CHR$(0) + "K" THEN GOSUB LEFTY„   IF V$ = CHR$(0) + "M" THEN GOSUB RIGHTY„   IF V$ = CHR$(0) + "H" THEN GOSUB UP„   IF UCASE$(V$) = "P" THEN SWAP PLAYERC, PC: PAINT (275, 30), PLAYERC, 0„   IF UCASE$(V$) = "Q" THEN GOTO OTHELLOEND„   IF V$ = CHR$(13) THEN GOSUB PUTSQUARE„   IF V$ = CHR$(27) THEN GOTO OTHELLOEND„ LOOP„„ LEFTY:„   IF X = 15 THEN RETURN„   LINE (X, Y)-(W, Z), 15, B„   X = X - 20: W = W - 20„   LINE (X, Y)-(W, Z), 0, B„ RETURN„„ RIGHTY:„   IF W = 215 THEN RETURN„   LINE (X, Y)-(W, Z), 15, B„   X = X + 20: W = W + 20„   LINE (X, Y)-(W, Z), 0, B„ RETURN„„ DOWN:„   IF Z = 175 THEN RETURN„   LINE (X, Y)-(W, Z), 15, B„   Y = Y + 16: Z = Z + 16„   LINE (X, Y)-(W, Z), 0, B„ RETURN„„ UP:„   IF Y = 15 THEN RETURN„   LINE (X, Y)-(W, Z), 15, B„   Y = Y - 16: Z = Z - 16„   LINE (X, Y)-(W, Z), 0, B„ RETURN„„ COMPUTER:„ LOCATE 9, 31: COLOR 14: PRINT "COMPUTING"„ BACKX = X„ BACKY = Y„ AGAIN = 0„ RANDOMIZE TIMER„ DO„   V$ = INKEY$„   IF V$ = CHR$(27) THEN GOTO DECIDEWINNER„   RNY = INT(RND * 10) + 1„   RNX = INT(RND * 10) + 1„   IF RNY = 1 THEN Y = 15 ELSE Y = 15 + ((RNY - 1) * 16)„   IF RNX = 1 THEN X = 15 ELSE X = 15 + ((RNX - 1) * 20)„   GOSUB PUTSQUARE„   AGAIN = AGAIN + 1„   IF AGAIN = 250 THEN„     LOCATE 9, 31: COLOR 11: PRINT "  PASS!  "„     SLEEP 1„     SWAP PLAYERC, PC„     PAINT (275, 30), PLAYERC, 0„     LOCATE 9, 31: PRINT SPACE$(9)„     X = BACKX„     Y = BACKY„     RETURN„   END IF„ LOOP UNTIL VALID = 1„ IF VALID <> 1 THEN„   FOR Y = 15 TO 170 STEP 16„     FOR X = 15 TO 200 STEP 20„       GOSUB PUTSQUARE„       IF VALID = 1 THEN EXIT FOR„     NEXT X„     IF VALID = 1 THEN EXIT FOR„   NEXT Y„   X = BACKX„   Y = BACKY„ END IF„ LOCATE 9, 31: PRINT SPACE$(9)„ X = BACKX„ Y = BACKY„ RETURN„„ PUTSQUARE:„ VALID = -1„ Colour = POINT(X + 10, Y + 10)„ IF Colour <> 7 THEN„   IF PLAYERC = 12 AND PLAYER = 1 THEN„     RETURN„   ELSE„     LOCATE 10, 31: COLOR 10: PRINT "OCCUPIED!": SLEEP 1: LOCATE 10, 31: PRINT SPACE$(9): RETURN„   END IF„ END IF„ ' Check side on Right„ N = X + 20„ M = N„ C = 0„ FOR R = N TO 200 STEP 20„   C = POINT(R + 10, Y + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R - 20„   FOR R = M TO N STEP 20„     PAINT (R + 10, Y + 10), PLAYERC, 7„   NEXT R„ END IF„ ' Check side on Left„ N = X - 20„ M = N„ C = 0„ FOR R = N TO 10 STEP -20„   C = POINT(R + 10, Y + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R + 20„   FOR R = N TO M STEP 20„     PAINT (R + 10, Y + 10), PLAYERC, 7„   NEXT R„ END IF„ ' Check Up„ N = Y - 18„ M = N„ C = 0„ FOR R = N TO 10 STEP -16„   C = POINT(X + 10, R + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R + 16„   FOR R = N TO M STEP 16„     PAINT (X + 10, R + 10), PLAYERC, 7„   NEXT R„ END IF„ ' Check Down„ N = Y + 14„ M = N„ C = 0„ FOR R = N TO 170 STEP 16„   C = POINT(X + 10, R + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R - 14„   FOR R = M TO N STEP 16„     PAINT (X + 10, R + 10), PLAYERC, 7„   NEXT R„ END IF„ ' Check Diagonals„ ' Right & Down„ N = Y + 14„ F = X + 20„ M = N„ G = F„ C = 0„ FOR R = N TO 170 STEP 16„   C = POINT(F + 10, R + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„   F = F + 20„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R - 14„   F = X + 20„   FOR R = M TO N STEP 16„     PAINT (F + 10, R + 10), PLAYERC, 7„     F = F + 20„   NEXT R„ END IF„ ' Right & Up„ N = Y - 18„ F = X - 20„ M = N„ G = F„ C = 0„ FOR R = N TO 10 STEP -16„   C = POINT(F + 10, R + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„   F = F - 20„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R + 16„   F = F + 20„   FOR R = N TO M STEP 16„     PAINT (F + 10, R + 10), PLAYERC, 7„     F = F + 20„   NEXT R„ END IF„ ' Left & Down„ N = Y + 14„ F = X - 20„ M = N„ G = F„ C = 0„ FOR R = N TO 170 STEP 16„   C = POINT(F + 10, R + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„   F = F - 20„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R - 14„   F = X - 20„   FOR R = M TO N STEP 16„     PAINT (F + 10, R + 10), PLAYERC, 7„     F = F - 20„   NEXT R„ END IF„ ' Left & Up„ N = Y - 18„ F = X + 20„ M = N„ G = F„ C = 0„ FOR R = N TO 10 STEP -16„   C = POINT(F + 10, R + 10)„   IF C = 7 THEN EXIT FOR„   IF C = PLAYERC THEN EXIT FOR„   F = F + 20„ NEXT R„ IF C = PLAYERC AND N <> R THEN„   VALID = 1„   N = R + 16„   F = F - 20„   FOR R = N TO M STEP 16„     PAINT (F + 10, R + 10), PLAYERC, 7„     F = F - 20„   NEXT R„ END IF„ IF VALID = -1 THEN„   IF PLAYER = 1 AND PLAYERC = 12 THEN„ ELSE„   LOCATE 9, 32: COLOR 14: PRINT "ILLEGAL"„   LOCATE 11, 33: PRINT "MOVE!"„   SLEEP 1„   LOCATE 9, 32: PRINT SPACE$(9)„   LOCATE 11, 33: PRINT SPACE$(5)„ END IF„ RETURN„ ELSE„   BOX = BOX + 1„ END IF„ CIRCLE (X + 10, Y + 8), 7, PLAYERC„ PAINT (X + 10, Y + 8), PLAYERC„ SWAP PLAYERC, PC„ PAINT (275, 30), PLAYERC, 0„ IF BOX = 100 THEN LOCATE 9, 31: PRINT SPACE$(9): GOTO DECIDEWINNER„ RETURN„„ DECIDEWINNER:„ BLUE = 0„ RED = 0„ LOCATE 20, 31: PRINT SPACE$(9)„ LOCATE 22, 31: PRINT SPACE$(9)„ LOCATE 8, 33: COLOR 10: PRINT "FINAL"„ LOCATE 10, 33: PRINT "SCORE"„ LOCATE 13, 31: COLOR 9: PRINT "BLUE:"„ LOCATE 15, 31: COLOR 12: PRINT "RED: "„ COLOR 15„ Y = 24„ DO„ FOR X = 25 TO 220 STEP 20„   CL = POINT(X, Y)„   IF CL = 9 THEN BLUE = BLUE + 1: LOCATE 13, 36: PRINT BLUE„   IF CL = 12 THEN RED = RED + 1: LOCATE 15, 36: PRINT RED„ NEXT X„ Y = Y + 16„ LOOP UNTIL Y >= 170„ COLOR 14„ IF BLUE > RED THEN LOCATE 19, 31: PRINT "BLUE WINS!"„ IF RED > BLUE THEN LOCATE 19, 31: PRINT "RED WINS!"„ IF BLUE = RED THEN LOCATE 19, 31: PRINT "IT'S A TIE"„„ LOCATE 25, 1: PRINT "ANOTHER GAME [Y/N] "; : COLOR 12„ DO„   A$ = INPUT$(1)„   ANS$ = UCASE$(A$)„ LOOP UNTIL ANS$ = "Y" OR ANS$ = "N"„ IF UCASE$(A$) = "Y" THEN CLS: GOTO BEGINGAME„„„ OTHELLOEND:„ SCREEN 0, 0, , 0: CLS„ WIDTH 80, 25„„Robert Seidel                  SCREEN 13 TOOLBOX              seidel@ifk.uni-jena.de         10-28-95 (00:00)       PB                     467  30777    XGRAFPB.BAS '>>> Page 1 of XGRAFPB.ZIP begins here. TYPE:BINAA TLEN:22740„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"XGRAFPB.ZIP",4^6:Z&=22740:?STRING$(50,177);„U"%up()%9%'%.-%9be+Dx_6bO6&%%%w(%%%+%.%%'l%SgfxDd_f>AQe5TThIuV;x8„U".rW-PKbR<(e9Im9WO]>[C%mjF*'V$<MN<Xl'-#FJr>i,>5$-Fp-BC_=-5Bhzz=)„U"<^u-fa-)jla)+<pqNMm2eywo.LtG37p-eNht=>;%c7z.IG01xH96Zn;h2q9b\:(„U"qJ$ZE;0u-?(C8>+5U1,Rd:?i/xb,<>cR754sTHV\zgYV;#HR>2CUhIBv8=Y&<Nt„U"[N;Q$BXN&-fg?SV8]>Y+w#=>f7mFE\lAEKeMqITH]%f#^t34DKJKkmfA:7s]%/R„U";Mnf[SfEvOJUj[vs$aCcPK&%;3Tk;$%ZZrP[j?-J_[:x?#xV7pslR.),J7-KpF/„U"Fdcx#g9^8yCvd\P-YcY1C?L+HHi0Y<E%9/SYzS4=2E<aG'EKoieR[/W9EsJ$hpd„U"$-?'[%)s^8-)q62yWsV.Kw^.0:'6vZRg\<f79KH-8Ox?O3Z(q:<+Xu%p()9%%'%„U"-I%P\3jC(=h-DA%%%%e&%%%,%%%%fii%SgfxCz^f:B<E=UrhQxZRb9/PSVAC=%$„U"Qn0\TukOG[]Y[;McIidpZ_u6tRs*^Lw4s6q6nTBG3)x].8UOJ2K^=H1oY_Ejs*)„U"gwAC-t+COR>Mmv1LhYkb$0hXGE7z9(^vA+e.4jP)q1hhTdI.J;6RggHn't2w7O4„U"#xS%\(8Qll(/F/koBAo8rMF(*C3$/NuWI^T\q=?[pC::\xg3lKjonD^XeG7m#6n„U"(zOq-9-u8sM-wa^(Mr5)VTZ/_Y:k^8q4v&%up()%9%'%7-%qbe+DE7;\mt*.%%G„U"6%%%-%%%%ij%rtSgIfxt'8Jx[m45xnO]7hhb%.mU8L-WDFAJ=GjA*1yQZ0jcyN'„U"q[iDd&J0XJXwuG6k'0$N*NAsqHm(bnLbjXm0%$=*6Z5qs1ZA=U.Zr;.V+XQiVVA„U"5mKjsk#'\QH=O,;9DHTgd?W0]N7M4gF8anNm<0>;$ASTs;<TAzU=[ejapI<L6*8„U"KQm;7kAi=L]&k(3=;ITtsH1ocB];H'sUq^/_'6;^y39:755V-ewBd%T-q4)lttP„U"0.KpbM*%48NL?(+=)3Mp-+K%f<84ecdR9gZVRvI3_UCDaHvsv=Mm_9Xg?)Ab6YR„U";7JasY:/mUNp2oKU.)Xc0Jtwx)pQ[PZM'Bk*q_pG8W^p4gI[=\H]<U2f,BHO;T-„U"#DPWXOAKAG#4lQ*>kt^&c&1GnZTCUHoj2qc#R,.22i2b(7T#Zi$j&jk8,*)WH1q„U"(w0Wg%7eQnb$Z95;gOk9#ZF-xsugLra7gG);eFM4W:uWcWGoN7d[Idv2_=&jcFc„U"q;De'xF.Ka7A)V(3rmyq^?.#LB;jQX^1a6aiZo0_U&.h;cL'p$rq3b3g>e%,&S=„U"AdT_j-:TD?,(Ku0dpLT>'FU--v7,FW/*FHu1F?/Fc*+f=EPrLg6SEbe5DM6=Gkh„U"u&Q)tnje2FVLHU1^2JiMyaF+Q0_y?7%iUJiSPE$TB5F>lVKILQl&?1cgQNeX4Nd„U"RYJdy:bjc=;n*HiNUT'H_gW3$7u-;HviBnl;s==>(<X\6eh1)OAGQBl'tWd7x*?„U"/S]6'BnVYWa-t2,N4\H0DcoK'hh(v/;0%5w9.kMD_xjiV=Ccs]<.G8&I,faKV<A„U"ngD?pE$7x*6]ZXW(VX[-i0unEwaQSq*VVX#&*-rLfu;'&A=(?u3;C0L2i1a+1QH„U"-xV,avNbBnnCt4]nHaq\cW>WtQ[:c/JYscJ+R6^?M8Yn^k-BZb^S6t#oXQ<$qeJ„U"]-9q2psAFlh/69AOtF\hx:w(ZOh.]k0*MaV^)F&^JqvH/q[H#uSYJnX%C;L(/9L„U"5dk;a]fKUm1k^_aX:%hj2-G\HoP;\%Il#T5Ajg5x+7[?GQOLoAu#^[_y[.S\9Nq„U"[OS0M0<KXwAEKUM6?/6[$pgb5FQ=*ann^<%9-#C^_k#dPlY2YBCj'-is/MxVV8g„U"1l:M\ol$/n\Mc6TX402lb'sk3VeHMC1s+Cx[n.<Dj=I#lvoh3J#6,]eVlpa$Q75„U"ChE9GF+Z=RLGL]R,Y5ER\s'lS=RU5/<zRWHPYQ\g;veLi%\(-Z^e.Z-ox.c>;Xf„U"91JmL).E8k\NvR6p-VU_1H(<K9McquvD/V+/A+fJQ4CL8xp:#w%tjBB9DRP6yh0„U"[qP\vGzpHvk)A+7;]*>a9*N<CB?H'5:y[)D#94e?jH(XC_S;_>JhOr/P((=VVUj„U"H*E*k^.W]>%SiFm.S'lh_d/hI-T>g9#d\/JB_1I;7Nl3:;s&VlHWB-h,&A?M&G,„U"uVgVa1Hd)WfZ'H+<HjJ't#k&6p&o\S<M&'9n_t[q)(#HznV>$kCb;hF+PpBeu&;„U"J+tLQcv=EO#<0)GWTR(7;g/_8OMnoE$22ogG1(R.ApsC^B&tLC^jnsJ)b2m1bTY„U"]H<&OBE)A]<,cEVoUc<',rx=?hXId9*#agc\tEhL44.-4$_-RXT/BwbE5[VhY&p„U"f=\bweg5ltCA9lrk%<%r1qyKrerejd?jj&<lCdojpd>AJ8m\s#+0T9FZ$[32E2h„U"bNXpX3gd#,goXpW0lGvAMSaW+DV%14K\JE/-n'?8&6'qRLV0I0f'-weUj48)8l=„U"D%cpI0ZbYstgLO/zB.OF5P]xWhoV/m#u^Sv6UT401NeA<^u^zL3g\1/T7.<wgx9„U"qys)agH;BM2a+-gt'7'(lLBnYn[xBK]h#(H_mRva/K<sFevEs]WG-v1+_eEopJ2„U"L;8xiL5,1QWYowU,Ci17?SSd5Vl$?IZsnXQ'i?cex%(up(%)9%'[%-%>%mtDabm„U"nNv#*%%G%6%%-%%%%i%jrtS#gfpt_'Jx[Rm5xn+O7hh'b.mUI8-WD)FJ=G)j*1y„U"tQ0jcPy'q[2id&Jn0JXw;u6k'50N*NoAqHm<(nLbojm0%n$*6Zg5s1ZoAU.Zgr.„U"V+XXiVVVAmKjUs#'\?Q=O,b;DHT#g?W0Q]7M48g8an\N<0>6;ASTis<TAdz=[e8„U"jpI<ZL*8K[Q;7kQA=L]W&(3=B;TtsJHocBg]H'sgU^/_Z';^ya3:75g5-ewAB%T„U"-Tq)ltUt0.K;pM*%$4NL?7(=)3dM-+KH%<84?edR9ugVRvPI_UC7DHvsovMm_m9„U"g?);A6YR];JasdY/mUdN2oKBU)XcC0twxe)Q[PNZ'Bkh*_pGl8^p4Ag[=\,H<U2„U"<fBHOa;-#DkPXOA)KG#4Yl*>k/t&c&<1nZTeCHojh2c#RB,22i:2(7Tu#i$jS&k„U"8,3*WH1.qw0W%g7eQ:n$Z9i5gOk%9ZF-nxugL9r7gGi)eFMj4:uWkcGoNA7[IdN„U"v_=&=jFcq3;e'xAFKa71AV(3[ryq^B?#LBR;QX^916aicZ0_UB&h;c+Lp$rOqb3„U"gC>%,&oSAdTR_-:TuD,(KFudpLpT'FU=-v7,jF/*FtH1F?9/c*+nfEPrIL6SEEb„U"5DMo6Gkh(uQ)tRne2FKVHU1M^JiM7yF+Q30y?7Q%UJiWSE$TVBF>lFVILQ)l?1c„U"XgNeXP4dRYAJy:b?j=;n?*iNU,TH_gOW$7ug-Hvi^Bl;so=>(<(X6eh31OAG+Ql„U"'tAW7x*E?S]6+'nVY8W-t2Q,4\H20coKM'h(vi/0%5aw.kM1DxjioVCcsj].G8#„U"&,fahK<An2g?pE\$x*6s]XW(nV[-it0nEwZaSq*hVX#&>*rLfgu'&A.=?u3.;0L„U"2Jia+1=Q-xV8,vNb$BnCt-4nHa*qcW>rWQ[:EcJYsCc+R6t^M8Y.nk-B<Z^S6't„U"oXQ5<qeJ?]9q2mpAFlEh69ApOF\hfxw(ZLO.]k60MaV1^F&^gJvH/'qH#urSJnX„U"/%;L(b/L5dgka]fdKm1k2^aX:N%j2-*GHoP*;%Ilc#5AjVgx+7s[GQOaLAu#'^_„U"y[$.\9N&qOS0HM<KX(wEKUYM?/64[pgb95Q=*_an^<c%-#C1^k#dZPY2Y0Bj'-n„U"i/MxiV8g1elM\o4l/n\?M6TXH42lbm'k3V?eMC18sCx[#n<Dj#=#lvMo3J#<6]e„U"Vdla$QW7ChE:9F+Z\=LGL\],Y5\E\s'_l=RUD5<zR=WPYQJ\;veQL%\(u-^e.>Z„U"ox.pc;XfI9JmL#)E8kO\vR6>pVU_=1(<KM9cqu2v/V+)/+fJSQCL8dx:#wr%jBB„U"39RP6My0[q*PvGz?pvk)8A7;]p*a9*jNCB?+H5:y1[D#9C4?jHo(C_S2;>JhlO/„U"P(o(VVU=j*E*/k.W]'>SiF#mS'l1hd/h?IT>g%9d\/,J_1I\;Nl3g:s&V=lWB-;„U"h&A?(MG,uIVVa1BH)Wf-ZH+<RHJ'tW#&6pc&\S<*M'9np_[q)'(HznqV$kCgbhF„U"+dPBeui&J+tXLcv=SE#<0;)WTR\(;g/^_OMn4o$22JoG1(BRAps.CB&t0L^jnDs„U")b2JmbTY=]<&O5B)A];<cEVdoc<'k,x=?ohId9&*agcq\EhLT4.-41$-RXETBwb„U"UE[Vh(Ypf=:\wegZ5tCAZ9rk%'<r1qFyrerSed?j*j<lCadjpd*>J8mn\#+0cTF„U"Z$O[2E2:hNXpQXgd#I,oXpHWlGvLASaW2+V%1G4\JE>/n'?(86'qIRV0IG0'-wf„U"ej48_)l=D=%pI0<ZYstKgO/zABOF5+PxWhio/m#/uSv6cU401DNA<^0uzL3*g1/„U"TB7<wgaxqys7)gH;NB2a+J-t'70'lLBpnn[xbBiuAIG9f4OsXAy1ELp4]M4gcUR„U"QI>C%8.AD.a$lee/NK&TPM(?cHVj%IK&lQq<JGG=%<mWm\f9:q8rd%up()%9%'%„U"#-%1UJ3C6K+cQD+.%%K3%%%,%%%%uh&'SgfLxd&*>B[A3hMvYx>oE_'+$9gW32l„U"BW^x/?;/S%TnO[,D-11=o\VEjc=s'ETu>PvFPl.FlEcO3/#J=nns:t9.xG4.kz=„U",^uDubM*LK'W?(mBc5Med\S$gwp'u/_stx*6>B+Gb:alL'gG)9HG^hoR*0Pt<-c„U"i^PcmkE?d;$DSL.fGRA<A9-Tb0;rP'bBBa9AFN:=(MlD8H2#GHCkIlRSU,f$YTd„U"hSV/fL-%eJVM3#F6??Hn?4_#V.a8HJox-YgQFmj<,ge%R4j5P?.RBPXG(z#/y<y„U"KH>Cktfu,YmXy>+0V9p#cn2WY>AZl%kYPT[>4Zo8Q]Zq'CMe/tuTTDQ/a.XkXcw„U"m/CQH57*<43gVpoH.RbNjDF8wM#n&P46s#%%JE?bcG#x2ApB;J1)L^HgqKASbd$„U"_2:Xh_k$o7gg'IT9*Kw%/Iyh[ljH^JTFGy<HTZ+uw]_4.&B\a=*UEai6ArA9G0-„U"rc:R'l1[_S[+U[HSPNmbCYnM+0oXG2E,We9*DLH81$R&s[*-hksJSA2x%UK4*fI„U"x1i;yBY0#3c_C0kPf-sd\K$hUb<;eS=#qm0<JBqWGo6-^ch9PUA3sRfmD#_SXyC„U"P=<P[>^5o^#z+Om(;Rf9.si_I'k$4qL;UK[Sk<[qC7^[4K[CmbCaVdc5\LXK5Z5„U":a^hZcP[[ZJ.QBXJKQiCRK\L6om#X2Zc+oi-J'Ahh3dH:qJCP$%^:*Gu6Tlto.D„U"<Pg0>/wTG]x5jCF<KXkJWpvyS\lc3EWn3Vm=VnkYL2Dy.npvxlBdF]Tt0]_:&nH„U"tii01a0'lCLSO8d\SUk1OOMi<62y79U]HAY9C00;xD&iZgej,aHriP$I87KE=4:„U":[^)7ruJ%dvvd^e9,W^yBDsF0ayO<3(AfLUtXT2E0s]OkugGbUB96PJ]g+h/c3)„U"F]B6b#kj0<.bu;Y#]u=jor6PkEEoTS.8hziI>&n28pY]d4H&%_Jk+?CM3HBn4OI„U"h??mnkR/2.(Qhh_-AY^,IH&yY#3ib)IYg39,?D9\K*]kc>EZ#Ul2-Sf5tVvoV0]„U"&Z1MiS,7-[_tbKBrJk)2,6U_THeMVR?*eJa-YYT%Spy4]\z?&>ApT?uIs&,P-ki„U"R_1=H/j(P(9aZ0*7'0_V%%\BT]u85;$SspgoA7jS2X4DYBRu_8XovB(P=SG(TJZ„U".N#CP)h90($9jGfNX:\(;jMqN%MbbD0jbI9Jxq.>N/9K6[3%ob9e:;bVF*=F,i6„U"1Z8y4;qOE;WotC9ZoQ6rpe7ZpeJQ.%Hl82W6qY'g?-qU]82tJXgereePlH?IKh9„U"pFt^nQ^O8OTK5\;X7tpYC=s%j:wL*RW#HC&Oke]T9T:%.D^8g.wK>G9Z4.S+2SH„U"ZD70R$I3]?Y*v1T^<DLV#\m.qG704fNkzUP2&KThDhBX_Iqf)t0rM-6mgqzL#WU„U"_;j7.meTaOxn'T8;qQ'S-gP&z*JlJD<7l8*bgA9=oT5uEvW\A*'V+84Kg9A8I.2„U"R^F0lQKCrbX^:-/D;)eB6qs-+#k8hf2aPcjLf0,zau-J#z%Y>4rV#U,EeFYukN;„U"1>D(,rU-T&.Q<b[$,Nc?4u*WZP,o-d]wj2WGtqL;3w:e[:J*RZe)sF<(#L5Zq9E„U"xY:H<I;bJbJZnvxj9\)rGK_EnODmFPrUU1aO\):B,B'?CWY#%cKb=K4W-*t.M#B„U"XHn7EBG_KYlR,aP+Q^f6^D#acr\B6qi>jUnqb6EWvn$)-%0^Gqb<wg:iZ^dp>Uo„U"S_j%P[SFMVk*M/4GrtEYisLQfZ<V;PWntQ]ZHsc[ee>L+;mD2,\068YaHQVI&>R„U"*e_g>zk>8ot#jB$Lq->.VQr30[J$N\Sd'>kV\](FDlq<#S)JnoX[sTc7n'R,SOL„U"f&seV/eeLi8RQuD4c&DkVVCi%uSJd8VrF7r3$cjrt?2bO%P>^2(NFj\<ttNdfR=„U"5//fn4ZH_Rp>GFD&Le3CrdcFxBbqR9tx>_TD48zcr#%up()%9%'%R-%vTA3C?l8„U",Bg%7%%*&%%%,%%%%wl%gSgf^x4uD,9<U595#u4:hwS=<K_KpbJaF+4:JZB_;tI„U"60ByHedCj%82n9t[FVBfZMFE56iOTg6nf/L#oHY2D/zgo6g7Rt-MI\^v*j3WmAb„U"YvzB2eRHAi%Zu+2qo.q938Z/fkc*Rmi[VHG1SyAj*l2GkxCe2e0SuI[y)eNJ]9p„U"k?8LG8.a]NbLaZi<($F2uK+ah9FSo?iXI^.mbBY/p+lLO^BN3&3*?v%5h\&)TGV„U"$IgdsfJn,c,X^BC9P',rqa;z9e=QWw6yeYhiZEh)G[5_tN84;g'[6',:i'WEa=h„U"c1xG+<v'u%p()9%%'%-I%jG3=Cbb,'8A&%+%m&%%%0%%(%'hn%whqj%Sgfx)T$f„U"tARe5TThIuVtf?=O1'ey,IrY80&xI2yo9+6&MOeScq3*\gE8Fl_R=T6;ZWGt59o„U"2qQ(-r10-tNYqQ\EZL;Uc&UiC&Q8b2d_,rRW%lBU08>WF_->\d]G&Qc+9?$f+^0„U"%\deN-qP&AIjRYujg4V-s97c\43#,*u:Dsl%%NQJ-9pJ:;D&J[*&OcrLHL-qVN4„U"5KTRSO_K)_pMAT9h8Ou3H1%?e5L8_2g.WC1E__5;(T[J4u]SstB'f4<SQ:):NqW„U"mx=t[9b]P;o930uxYnw?'LrK;4hGYAtkp6GiKuza0x<)7t&<)ltMSxYOH53[-<+„U"]mce2AUC(MTNff?8/X^,Ghe6u:7GDs(<Lns+%up()%9%'%R-%tEe3Cn>2]#^&.%„U"%i(%%%+%.%%'l%SgfpDd$t>\je5>KhmKVC<zrk^[XEm']CGU9d-B+B]*i*lnYa>„U"4ER(0a8>c_Mj6&:?wA+8nDtDET5\tMr13[rs6eTX63o4A01)caD1_c%JZAXHA6=„U"(,6L.zRPz0'Ok]$Sqo0Xw=;C\?3mwz:I<rdQxo%j\Z:?0eq-6*9'(<g*.Be9\yh„U"z9AbD40?AGUqSSYfSl)<O(*jrr+l<g[geS\tcrdtk6i,Zw<65<4IV+\Xm?Ft3w,„U"_)nHPg7#SEF6oif?WRyU;ZC$^P[zmnMk_SL>t\3fTk*?&$rZ(p?&p7pr$PDbJm:„U"HVrnX.(O2;T$yoZ#oq_]lwQ$'z9[^&LjwS%FABq$q$%PQTU03-BcR'PqIA(fe01„U"kbkXjNfUd(<:yds^qw5488T>yp93=w7$<Nd/uk79au$=c7wg&0:KD5'oH#;3U[X„U"v#o]*79g?WNk6I\Y+8;,lY4ohgJ%zQ$y^yp_BW]r%A>YIJDucvf2PVk<p^OSfQH„U"W$IiiYVYW*]I,u%p()9%%'%-O%^P3dCAuY&Pr'%(%?*%%%,%%(%'lW%SgfxJdx,„U"^BKe9L+LZdAj\'QTuV-NqPoR;OFsVKdC7)5LOPDC8V3*K]=Nq_d-pGqN8,<Pmpg„U"I$W>BHv]dX3B6q#S:^r0=$^(M?=gKo.6Z'tGsUc0'qlZ%TbEk-(Y1IO62l=<bHa„U"F8j+jFY\Wab&R^'7NwZFuGoQ_&8KombN08GtU1n6aVd28BG,cEf$UoF?vJMAkVL„U",762b2WX#sWwTT&U//YyeU[6*Zo(7e1&8ZnAG.rpS<(77M+7>C,juMf)*a(chFM„U"$sj\)k2#<^'H'*9_Mh/TGXm+QHpxUtpwhXqhu/(jVkvZt7SPLsmM,<OQpQf.\\N„U"B'$*c,)B[;)_wplhpeIXS55fhnr[2MjdMo_\ohHU5GGY#KM_(GROb&/vIX+]rUX„U"wFE4kkze&_IJ<gR5(pENIE6FcYgM-x9Xf?MK6kV>m'GM-=HIc0_jx,gEgo8E;&N„U"Nu)REqn#*].?W48&Sv53dDpB1P1DK6#ErEtmo*&xUaiGgCwYgwEA\J&Y07Ki:1R„U">f[70k&pm2fel?P'M4BnwpZ->j+_Gp$i1hEwDuV+*7P9cMwg/Y+kb-cH*UbTQva„U"FcZ-,'o7g]O*s:Ne60[-s%0,XxKw)gGqO9ES*\s2Zl=l.d6qGmJap-XGXL;%JDp„U"jHX5W_o^gD:gp0/rah9h?WrY(_=/&A<Y>uxYS'RT=8zgscWWJ6-hXr^nL4[CgUR„U"[W0T,q.d<<]&d(w)0yKqLyy3[\wZjgn/Rp2qRc&>up(%)9%'#%-%o#ntD:W*$XL„U"#'%%.%*%%.#%%%'%lwfk%SgfxB.yv>BSU5M+l[dADWXG$X9S+y/bK\+Mb5rOs'&„U"K6_T?&0UF5/rrKN8,5p-$O/<4*Cu[4h74$XLsfU-UI2x%y:p%Wu)pdSt'-TbgO7„U"Iq>X?CdwQuiYUf\C7->1'tU>KkJ5Sk,1&6Ch=N3J$Dgqdy?H'N-CpJk0JPLu255„U"aW:FE2+0qM\P#w1<t4,8jHmBRA]ga7#_,q2RWP[*Lkbg/[$:?7;0fI35t[B5fWH„U"RBGO+.)\H1NoRn\,:IkCPCw3f29[n'=KocvJ-A2>Gb&PrgKw#lP>vjk:I.UW/</„U"paV7lELu)2_>Cl5$s=*_S#<*yQLSsdgLoTALyhE%GqZs2?7=^,lEfy=TU;sCDTi„U"kNQ#BG]9h]OrSZaJ+*]%Kw43_:y#-w9i];/Iw+O1Ih](6[*,-<[s>mS9x\G6*^m„U"QjWMe_HD>YDTK'Q=Yh6#>QMt4mOo[h#epUSnq2<rBBv't<d7nQm?cz:jH9]=$kC„U"o(I+K>gCXJp3<iN;^I\:F0-M7e5pf;+gft0c+jGfI(]HQ-2pR5cC0pu'k::fkko„U"T3puSvxspEjp*:yETtXccTGO<J].ZZu%B#iCQA*OHhae$>spMh_HGo#qUbSaXe^„U"D5[AJmXY:4R0Hka.gos8TS/>\#mEwzPY?lELMwSS.87/.JZ<WugF8A3Y.5OpZE<„U"XdXVeZ3^anVxZM%LH:mX?X3OPNB(q5sOkwK#L//AG\Hv)*ul9u0CsEm(Zji/&fI„U"j0-(qSh2gIv[w9Obk4k+C'b81R,ADn.nI6u3cfH'k+JgdG[wE.TF0PT>o?jcFw#„U"q%2up(%)9%'#%-%&#mtD$79:>b[&%%7%(%%.#%%%'%qnsj%SgfxT&u:9];e56s0„U"w<DLF7YPTcV-Q+#P[5&%Vn#5p#G5*S)o4uR8hE0%Ku/*63S$utoF7$p59o=z<:-„U"tm$:aM&c81aYM3DOi$IZKN_LqhRmXN2r1%MfK_KgUV%4fgjYIcLt+6jE'mZ'ZL>„U"#F4d9uuS87p:O.BY,NYPD$gd:R3U_KtG]=9_FDCB2vM]<T<WH;T40TpEzbB4uRA„U"gJged-5p+,6Q/qSN*g>C>g0PddL_CWJ61bXS;jR6hUVWL5lCSOvt=7Z.W[ZWJJ]„U":jF50_>m1Crl/x$nlD_4:BfP^0A$^4BZ?==*<#BjG[QZF=5h-YWe7?g&BCzi3MX„U"]6Cnhx#TX_^4C6X_zJSnIg;EY5cJnlt$VGKqL.Qd,j^+BUqMY5x%u+#JQn89]YX„U"jPM?i%0up(%)9%'%%-%,DF3C>R,v+$%'%%h%,%%,#%%%'%ulSg7fx6y3T=jep5L„U"0]JN]Xy2-c<1i1ei5D0o[d;2*:nD?zyqNj1r1B)%\;$7rDUS,U%>txkIoZ:OEhi„U",B(_i%8L+nV8ah]8Y#(h[$8:E*I]DqJX$\J%b&ciL5rRJGX-6o&CFY]#.A\6S+U„U"uTTApb;GXBG_-INg)M4tYCi*^&'HT_ag](GJJ^9(+7V;jHd;Y+J(>e9L=j_N_Xp„U"ZZJ8_R6:B[-^07Asba]F75='7T1T,pA;9pA>&1jDtT4R/C+Dagr&ZKrfa5-Ii=L„U"],9fmj5'6^0*A-Y%(h?a9JpG+Aoezc6s8\3'-s,DJ#vUPq>HjH?q(esZmdUCZZk„U"TGrTlWcL(mfoi-'<N3&f=^K9$[>T3(T77[qt/nH-V:q/3iq?VaSQ1vEO'jLukLk„U"VbcGlNaeT1aF(ihQ],X8d)4SC6HUmG+lxfS.Bt-O+l_CfVd#HB-R[bG;VYHF^kf„U"+4lVbr5-pDj.vI3^Q=-tz<4s&ziZjA9Jq=b(%^LTb?Papi:wL0h[;[#LWIZ_f77„U"[qFj34J)mcEVbB=_cJjB*G=6-hXcpMRoIseN.))l\b=,\?MoNA=HJ0ni1R'1T?6„U"E'8>w?'D1?bZO\='Hh0xqh6EL2Y>:21r$ru3=k5wU5T9A\dUzaaMP-L\Yzs6AnY„U"j_^FW[4rIy7w=p.\JPX#)kg5W=w_^O/r*m7RD;d;Mx:>K;27w>^Y0]DXn$%kK8;„U"p?NB2\;>E5^+,W^xFI+glM5ZiNl\(rjyi*fV\,khI#w()<Uh3oX)+xjGa=6Yr;V„U"NIB3uL2mJun*/K630.or^pbyO669/-\eyaqPc3H<c7z9r$hYdho+Yt#u%p()9%%„U"'%-I%%N3aC'V,,(A(%(%z2%%%/%%(%'uw%nsyS[gfxfM&<By8%5wAG6u4z82#bJ„U"XNc683s15%D^$9TR&q*.I_i^$%.<WeX7vQN6WVR)k;6l2XXrMUdqWJo=^t74Q?L„U"DaeQB3DLEQn/I?c?g'w>ja&<[/MPHZxui3U])>bUjY1,fVPLCPA#Z'mHN'u)WM4„U"DHd&bYFk,LV122i_PIotJ,JJB&6(fn,hT8^sRZUHoG:tiV;K,*[n8=JQ'v6>&9K„U"Y^n4-PuYXL&^UR]BOF;;%WI9.SD*2/25:_$XKN*Fq^_;)8k(Gw;G;H^Y<bB#,&K„U"O1XY3PEHJT<.O*>T8t9NqOz?9,Y,DxEr*>G%R=J*3Sq4;;j21%VxHCM[gx$RgVX„U"Ihlyv4g(NN-<>l>C+L>I7<WY6LtCo/Mv0]tolJH+FEVfm99x?F<X?I10Db*Ln#S„U"S-1pm/8paB1U_-Yf>S7lC4a5hr)_VF$AhGmVjtLR2h3p,9[6U2Uz%?_;'*o+X2k„U"l[n-=se2$hp57/R]s&*s56j^n>\6WRe^I9(8HE9gY#Iik]kF4o6LT+WZW\Lsk+c„U"x^h\.DrEt5Qe;)g*57J2?aw.&]DKjh_YZbC1>UV$E6F)EyI+NV;2RN&7ASV)7Sg„U"bk47=i)qXGS/fFUXex0DCRJeV$m8J?CZUFTJ=\$3rUDVRGBL2_pc<F7uq2rIQ^<„U"_Lia>LP)(T$eSVS9VzIpR=ja)Q%mY6qHieq/Yop>lq/R63dI'pL,3<#2zioL3J-„U"y*$xR;d0n^S<Mt4d_^yjOf]1vS1hvIU7EX+'=]7)-c7C(uhMZQ5QrpQb<2AEsIk„U"=qwc%6\q[.P/d-Aq>$gJ&jkL8TGi55;?MZ93J&dK9JKVsvngMU=DCM.&rtL[n-#„U"Knz(ZqV5'j$/m821NVqu(anG#-lu^Y[stQ%WP.XEh,&5[ch/VYf';==rl0E5\>s„U"1?q>fNFUCi<J]j^w&PVd<VSGEX=&ki<Bj)=pxJ7>XVN[GyPdL0/+w_V&Ua$PbP-„U"eo9vKJMv.HtQCI^=Pf8ncEL;i;6mgE^/23B]sZOUBla8v\gO9bGm>tnEhG/,,^2„U"C=DmCm;WvlR>lHeRH9S\_[=nhuc3C>.5W5o$2MaTHgl=n,pO<V1&K0yz_/EMLR4„U"&7a'?tK/gV)o-JUx)5Nu'vXp)mM_=LfK4pTTBm2uG*Zf1RL*>o-nb4Z3<Q[Bw&C„U"W,c[u<mDy>Mi;A&s5n=<fC=7tgV8)mmRZlI9EDGrU?Dv(wX:X:C5[j.u%p()/%%„U"%%%#%:c+CD9+U(l9%%(%9%%%%0%%%%knq(j.ni#Sin)&'lwf.kE%V%SUVE%xhwj„U"%jsEV%XEyt%tqgtJ'E5>AAEu>2F4Ag%fxnh#EXSGAG2/0M;<>B&CEkw.jj&f#wj„U"E1AHEw>M14ACIEx48234;EMB483D4;e8D5:SDD=8R924=0S)34up%()9%%'%-%.„U"^c+Da'mDp'F*%%&m1%%%.%%%&'lwf%kSitLhd%<,B[[5$wMXpdD[hG5cE/7ZA^g„U"iC4l??qW*W?2USK9J'[=SW]$]RZU0wV6wY9J=fAVJJ<XR#Z=g,^<o(&;.%;RIW5„U"P4E$dq22A_U:*4O40?upY+.BTfGeCy9m8&hv+DV)f&.E'o.&<tfozMzL0-lX8Rx„END SUB„SUB V2„U"utPr5>F.GT4GRdde7stKc-]oDa;-dQiNM?j6bLVPNqlA1#<+y=p-N+hWCIx%W_^„U"&ikf:n?)udvD7F%.F&[fFn0.S&u,$NHN\78o7h1D%k('cKa[HW$Qf]Z.b:w?^6d„U"[g8\+M.'GLN;4x+Z^+&-[jUCIlfg]]5N<))14zFb=iP]+ibKQ&:2p/jP\kPiE*m„U"g/YxbpHlN^Tn)vq,m[v[j[Q?iB'W<1X38P76#N(j&o==tE=t4):$u62%<]^AlB(„U"Nir0rUkjl$L3K>ZslIg/U#Pa_Ql%nN[TYUegV%.SNTos/,pFl_S(U69<33-vaS?„U"Lsu/?%+n]?_t?DH2=0E#E:<Yk?;]?<gw2a9.Yq5NsS>,,/ujh3/rU\E5\?L=7j5„U";rR7jIj.qDk>2kkke#]qL_ssEh6=Ic#+jG6lEhVLZIA\q_;05bT;8Gz\AAmi2:3„U"kTQ6VngE;4p.u/>S=VQs>VQpW6dnq2.[9#AavtK1H[i:O;8$t%.:Xe(s-/#/Y)L„U"]MsYxl0o;P99.S2.Vz]M\80p1+IRAKxEf>y),>MU[<r%;6LKJUU$,-$Y;=o-Q/H„U"6;-.L*dShV-<MJHr[9^K%&DaLl4H(=e=HW+oY+TN6Zh?:mNA^Ay>EIkN79_W4E1„U"tP4uuF6s07qNSgrf6&z-Vw)HttaG4blrFKUPj>b#F/'_Q5>wKiK,hvU(b%Kei2x„U"SM\g:p]Ahk8FTes'BB:)M1s7Gj:oCl3HEB$45:>&lw=Ofa&>rS]=edE?3F]6+gb„U"uJ1HKG'.k1v2SOJ6ybaRFRg0I=z6ert1IctUb.X9#GfJ#vY+-M>-<1.&My:Mwds„U"'duGB^T^aTft>n89D*PV:D+ESEnl0l2WsG_3nZ;,JSsD6\0)IzlRQZUVjl4CUlf„U"oFISSLl(F.o/F:/VmYKeR?\DtDM)iY1J_R&LjG,^qkW[1E?shCE]l_HZ2kB9N8*„U"9wb.%KOge.O*PS0pPBb5VXV<RN\);*ZQi8##3umu_KB;2JzJzZ/:Fb*QeSWP_^,„U",XI_Cr8/L6rGXJ#W=L<7E-,Bp'pc*,UpHjqZg?/tc=/gqaRDq;p=-ob3\M)kF+)„U"1uT0e<_NOXo]2HLO)KjrTy/=MyAt:gnpP2Koe-q7&ow(/=l_&a9m=?KJf0-^5Ao„U"6Ga&bp'vK4WmZ]V;%<OzNO]ouMOn*U=d)PwmgL;i=l\R#%SGAp=9<)WS>CDSO:o„U"ZlouD692?YS$5SPfLlQwbo9k%[T7qqgT\^Aq:/H6Wa(XYjr?sa8e6#u2a/\T9ZH„U"m3dt=-hp&LA6l)IS>Wq^j)wT:0p);Y^F8+'fdLRgV#YL725%;DD:QYng'#NQBA-„U"ySI>UF>8Vhu<mq1\X'It:b9<gKiG9lr$Paj*Z3&Bc]1hW\(q#Ap[Js\K(;*=bu9„U"h$bnmBB_$NS)dA3>+dsMJZ2kNbK5%%;4,EK5WMI-^I=psqp'r>SW,Z$Z^/-c1W#„U"_pg-tTLw;WQZt8n&VYC;Cj9Q]K=UjG,6JEXbi;j8mC<2y)DNvkO*lVHlG9/DiWV„U"C_5HP\(PhfI,1,xDC]FtF34S[ZV\YgPUX'S]CQgC#C1GZKU?K\0-X6=VY#$*pA#„U"[5$i3sN\v43</J\p-#sE/)5BuH?O]?$6%]0A/4Qw2RxSwQ^+3t%[NXV5#o?FW&J„U"L^+WOlw.\SHo8)-/9F$)LMjq0%*cMeWe<p<:[He1NA^A]Q9ka[[9.MWv>UU1+C'„U"o4up%()9%%'%-%3BK3C>i17)&SM%%'%]%%%-%%%%qfsi#Suh'3VJ<u2*&iKd-A2„U"9l/i&j:4H30ED4I0Liz?MCiof$&_6*m#mIEsHQTx;cNg[V\]8L*3D[,],Of]z^N„U"R%HXIv(zPa'E6r3z33RPXFJscg6s++u&I<bKpIlfm;hZmE=Eb^<c$Q[15EM:zEz„U"-_P?.c'=b$YHGlMtkp5;WN*CzZCiH*W'd.fldcA\Qx^.(MHJH(<R/Y,6HuTRtEQ„U"RUt;dugkNvmf=T7p(Y*hpmHxg4K:B$'df0BJ:ZOx62uXv:,l/AFxrlNsg,N*Bc,„U"A]$[unhWn\\\\8<+>wlP,XNCblr44QwLr:o\dese.D,dox<PSYjP8Hljnj?PrdN„U"HtBbJnXd52Euv:<dstXuqQJnJ>uwgJniCjN5<7#vD$F&\Nom4(nR\\'6Ti/8LTl„U"C'>Xd57RldH?6k#vbdW8NLKlhJfqZxcs.ZXs_)u4wO?K<<n-ox5PxG37O-rXGd&„U"u8xB?t*pWsmbSxr3&\n52-<MVc5s<ldz&&cNdbnKhXzNs6B?rTZjh(NWEM5HbLh„U"Lsn^\inrB^8=Q4x3-h>MXxclntRXtPjL<\vStU\Mup>H.rJkMsN7o_dVqtjF(8i„U"RGJ\?fN0Rlc#l0g\._rNcFG5ZW_x9>44RSQdfnZGnjdL91vGRlx1$rYbo,^>M7j„U"[5Jt^dcHuqwjnX/48HBTzY6V6bY(rg*5.XGe)J'B2'*ByS[Q#4+s4]P-rtGbd<e„U"n+dutk$0p\Mx.VG/NEZ*3VD23t,$KQs=t4_/6\Jz8J79hSEkZ4p)vVF?nI6Pim_„U"o*08#&3:#47/47t>Jrj9rNLrYkr(&8Hwh4mPaOl1L<JUmEgf$F[VP#_2DK&dH,g„U")ZNVGD3OLn*8T$CnQtEZrXWM+%Q=BW1Tuh,\m>L7p]GtoArW3$3\j,?Rt:4Ap^Y„U"7B3,?HM*FQOHEO7E=*_1aVG<uTGEp'r3cmp$UA3tZh'\hgc&I;09rD<pehDoXpX„U"Xutv6q2#kEDOpj$6qw=PhlhXI);#.U<*.%Z*B=z8)-dQs-[Ygt,1-zJ/18F<L*9„U"*:)I2C0L-v-h3-Jif&p-(:DZd77V&8:'BXtj\/Sm_o[TQ2VFlxlL\r:RtkKW5Sw„U"P2<;Sjb<m_C$PiJ7&VuYgjmu3bvRxsg60dviexMQ*9K3xSk3kVm-;cxW<,\m.'^„U"maEwL3LKoC6_)?g%Xag4la#>=nsooSWtl$tzpu81PH5n;)9oYU#-D;G\tP7]h0\„U"I_'V&GdB>S3lu;[,#7v2MI9mooDZjLSE_h\W;+ASAQpxjdWd#6p_^L<b8ak:H'N„U"VNSBkt>7h*$<p[t#op;hjIsMBS[2Wqj\c?hchu$6Q%%bbqE91l/RHdiwqnD:Y%l„U"_iL/Zxf]%-Uvf7eH92H,A5Dsxa,(0ap#\m^gB\LYaR>:Bv]UNOF;3:<e,,9d]Gl„U"uQ*KVt^hvguW&4%sXA3afA5P9uLYJ>tIbQi'*6o1BL%YOs*4MTEYP$Ukog?xRe0„U"d/Jl96,ikoq9j%(7m%6Mi+Mw^]_B334Xf(U1n\zIJQ(mQkEl=j$\IH1%OR+H<c5„U"oM#?^C1H-'#y]F_]tc1r4ChdT4R5\F*Zg_#)')x,F]=#IC&xp)0t0quKDcs/(\M„U"bQ=s'_[4u0h,oG]\anj/'pqO$:Cu.9)&]iM_1iL#?:?WI5,T4Mm,<>$.%?=>m[I„U"xn)+(B9p)Y$)tAXi/p\co1:-k4eZQ:Zd.WUdpYkF4GXWtF^fWS&%tg2BC,[-b*L„U",/FhE7aq#5$5YJWKhDo0ZO$$,rV_.H44fQ64[9)ibVeOHVOr)gF9bEPKM%RCgh#„U"?fcnLvRpjlXG0W>Wh/r6?)%hCtJ%w.cg]j6&ZF9#6th/ASf%?w0a'?wHp5.6N\e„U"B\gho[l=Vfpfat0RuWBQbh2$/ruA]FgHiU#rXjI7fUCGlKH]+Z)a=J.'?E'N3+)„U"cRjPiRGR\fY6Y7P-]<]?ab4w/Jdjlx^bwuG_DpPMZK#Es[CL1NQ]$Bt?;bSIn%u„U"1?g0QyahKROI;2G7SGo<18vWYz;,0rz&S'1xdwa'2Hr:$MOr,Mc(+.0jw#ls*ri„U"3/0YaGr9,O.c%v#L]qFFRWdd3A$B7mUml5Z2)w+xJcPA/AKUqL>0qG5-A;POMwt„U"aDcr8hXb=jxa7jm_^R6r)PsiE<[^CYL\\/Bt)%]D>%AL=3]AoJ.K,81*PRCs+$V„U"s#$bl(=&RQ'f)fszh#EkH>in8Z$ETjH+jtN,$-_G[kFYCh\cMp)pVV_xDHtr/CY„U"3,Z.U-Op^eY$5TD-0mvgG6q_6F29xwI<>b/yiKF7xQ08TFh)-sqH0s7m7&+?9-n„U"=8nJ3Zb8%R7%m%vI6LXxk]%5=Kt;^eFFIMbXjFq=K>s[2P)Gch[66P^pFR[f5SJ„U"P<CJcu3<MV-Hv6wSIx]7MsfqL(9TH1T>86)a)R4:;qDDBHTZC,$5TP#i10p<_0A„U"P_(91R::y(Jgb/GO8c,8'=kx[*X_u>v;Tl?enBiit_(LU1%FzY<#nyr?>%mI&\T„U"_HB<S*jN2#1OL9/'<e&ofd6<Q8K]'2\M2mMSVALi+nFt_xt8:?O;Ua6=s[UDNXj„U"(V.csq2L$P)3l6JNN;V3Fl&e_TGR[#mEe?,A8Rd*n)ahADn2:X;;raw_*ZH;1+,„U";9b#&TkoE>2nt#T=O=A#UAO?ZB]mo<ze*+?O7wrg$t[B6$kl+z(8h46v7dlhK]a„U"LhMWJ5gfvd;20o7X0j7r6i$fMgATht<QX7Sub$6eOUhd*:515;C^C$z1f9:6c^d„U"KNT<cW&.sl'lN>uk^':LO^4a\V82Y8cg4V=z,Iiz3P/3R^,q'.UEV>+JsHZ#eb2„U"9/S5mA\J09ojZ3<Xd,S\9$$qCsH)>^34HV&Z\;nudN34k7xn*>%W#gaqkcr(7:b„U"VW%DN7DVx\dM_*3v2&E9ZaWa5^G:)_Dci<;.en[b(SRO0?kb[.Z]r_zw>?[CI\7„U"jhqN_XaV:J'%[\-#t;J&(L#.;JbJ_<4zulX,s7<XM:A,,RHpIBlDzhwr=bQXR.V„U"tS>4oEx(m:_4LU4qSy<?)0%H3hR+tQg7$lE-D:4?3OaRu5q&(3f,r]E-KE_3Ai1„U"Dr$81EqLhiGe;1ma>kY?'M]lQFw(N%pZ(Cw=6eo,Ee6X+RONY%GFNnZ;fD4tHNW„U"-jn4?%vAw:QCM4[$0N*XhA1#t'MIZb-%iJp7lV;+pYjfY-D:zSEzJq0<AJIB,yG„U"lUCwU.^n^NniwyQ66w<XnnI;Eamqq>rL>IeHS1v>;($Z,-9Uk=\HEaV-K<g#WQT„U"pjFK.T3&N:1C3h]E34Y&c]O)U3Ne:lz:2)dK0wgNA_mc/As80%:]BpyJT;.$3Zr„U"aKAgMHEohp]CrCTYnVgX??G5+F(+XYI*j::N/J7JCaO2l^lzIe'0j6F)S<rZ/zw„U"#hVLp>Dcjr,hE'*_A4R2]St#=aLe_+$*\$feAf4rz;pK)B/(EK_^?mjl;<OX6.h„U"sm/.T0Q%AqZ5gQed)%%_HN*mBrF/jTPn*I([EKqB(jtbV1D?3VTk1,#j;[E8y7Y„U"z-n85(ITIwt>DflAbgj3&OJXpFM8L,h#H7:*Z?D/XDySewfjmva_5-IkX;(e?8Y„U";o)]N;RTo>\-9=(5=fc78'%kg^D>)XmbfcZPsI9bX(FIMfY92g6Jrb'Nc+hY<R:„U"$9Wb?JyCzpe<y,>'[F+ksD(L4S:;&RE03$9OWfq^A]/mUt)UDtIPX-7M+d_Wc'A„U";R:r-'7\Z(CN<:lA:(tO<[E^Nh[b(Yvt7viedN9M7Hnlr=Y:rC[Z(4l]Xjn(HqF„U">17H-/\#[2k%(j$T-yUU-9*yd?+9)9[[=Glusbn.Z]cHqFgPAYEW#^_9,3<apvN„U"qkbe7KMzE9d/?PYG%$y[n,V_R<mr3JWk_,_[JtWf=#N,d5>#kvU84H6c-:'qEUP„U"k1O,lp'rN7EPn2p)%8e/Z0W:OyuqEjpRu-n/OcE;3hppCr-7WWCTqAFe,VqE'(Z„U"EfL7AMpWA?EIqiTB%iK<8azSsa6&u%/'8FmsT=Z1hoE9YSuJ0j0nE+u$tUCTb.:„U"4k0?(AGbE[Z32?1aSU5MKh#PK$tR<(6fI9dy13x]n-#bnb:1J2lZQV)oo'lo,dt„U"k&bPD]qO='JBaf::)^8N+X&XSlyFr)3A8rF)WqTV.b_o7+#GkuTZjTIz6^OBNRA„U"]1koUHfVf9%h/\;[)Y1ZfVbG7Ep&)OkR?/MSO(%dy_-3Tr9bj/:9m94P;o&6BAH„U"Q9/+t+CvaoVSjYDW-1Sp3V:4]uh_Gr8x>/$3uw7)MK8i5$i)35lq?2j9T%oDcR]„U"(e9j?htu[<$/2#TaF/HhnRE,qir(]ElZU^,H#:kyf)Me)Bh:[#(&^P)97K<U%*-„U"1t<IZQ+lvX?%/qP*zCYgI#*#bbW<'t[\Op+x7PxAIppoZgH4ZZ_('0l7rV?g1R[„U"dF?f&IZjv$RRFnA8r[8g7S\6i;$3T>E)$mK*9*o:E'K9ShaNPj1#s?5Y8uPnh.I„U"UO9iQq0pWJmM^>4*u'*#'e0>*0Lz2m<(F_4a[nnCPXxQ<%sokIOU'5KdDx*YNOI„U"TsF'/=EM(O_i_L)S3ES(B>Pe70Cf+x/K#73m^rC1AoVN&x)$\k:$rI0LTn_l4x$„U"62Dqz)oA*f<a7JK+SI:&^VHrY^zbF6RqLQZi]n/P-qrl1#v_MQI7jOeB[n6.R'b„U"Si-#bxE#wi0YfsmuBca]R+(KPhUJQiJqFv,xDCyQDqMs^iS>RR1j_ejcbLmarPY„U";iN(i_olm7'$B$/iDaI*lsnKIt-80O8uQkEY&-00kO,-Q-7uGT;6HjFab?YEJ:E„U")=2hW[4f&#&AuWJb(W-'xf/Z6J+PAp3'6*ge^or8.&Krgh_dUqv9=F6Vf&z_B$L„U"q^1M\P5tqOWM9n;YG90j^#7]4O=K%9$tSV0pFbMwqW>bNFKQ[*VFZ>i(+0H&m?J„U"hh-k9Sl8mWXFTsYLGG01.%)4o=tcjF/2rOFWXi*3aO5+G[tAgse\sr>bpQFO5na„U"shA)HpZ=/LGFA5630%HU9OdJWt[nPYF;uuYQ:Lf#Yn2FhVN)%=+1n(;,3K?LS1k„U"VY5Ifh?JAh]lfPaK]PT-0Zq=7Lx1]Sw2lpof']=sF2N)R=U-;(FkbiGba5M0WN)„U"57X3Q.DX)aPP<o_72c8yU*<Tgm/P38XCny1xG'+(cX;H*b[r'9rr=Q/Bh?kx)De„U"H3Q+1jgOewf?[m?rilbY^Zo$3g5(u5':t5g+<oaIrUSs_T^gK1]s>ZNYNUMfPnW„U"A3$1NkVJX9]'%Xw^)gC[V\)Sxazk5G1h/DzK*WB2ARrA/1sI]sL7qUiF6?8;gfw„U";'&gRU)On>1mP8_B,NLghHRuJ):(Eufc_I,s)&&9ZCE#HC%OBJF8kJqpEk%NlBt„U"J.wo#198-hP2hZ_?8Be4.JxB59]8cCHlGs'/-^h\&j^(E%$rW,0e=,iGAjS.v33„U";jyw%v.*?v*#WxEwCuMv2Wdj-gR+G(>>U;=:rw_Md#8MZ2^_72a\/Jk17nP4:kh„U"/qYrfavME'F]_7($5>Vn?*]LL3vM6AqU8_)_XepO9TCni%=+IZM-C.%&oG1g4j(„U"]R*W2kd,#/(%50:dwW\$-rsK^9;te,aO:qi2:u=)(wIQ\'9wkwaDJ8u(u=P;U-l„U"I2Zc$f)DV^^_Wm?IUS1c<tQ:,GbIVHk6;HW90;[5qz>5k[r+-H+x#A0d:k2\S&0„U"]e=f6YnQ=\f0:^hs#xq,3O<Jpxq:J=;P,5:1v)-f>wI%#U5XoL4Z8X[I$yQYYIG„U"J9J+d<AohcS2jfr22uJj1tV_+bq/R[AAsHR*VO4kpLosH3#^57y.^%VdXP?Z.R0„U"L.T3,+D]s;Q1/4e^ZKOJK[DDacL\peXOnJXL.^GpNWQ[2EX9R8G?#EaeVmfYKzS„U"05<dm38;VDKrYsGlc9#Bmpc.0gpffR(IWVLMA7W<eP4>J-C>zO0(i46B)m#J8w8„U"E,P--O?h+obsC'lj^#eQ5w(zo:HIF4mcR<o'DHL8I3DbP=^*+S%bCIXsY5U.S67„U"X7?CIg)5:O2)rMN6lRl3Z?1T,Or]7^9FV(B)N8a;bjU5,*Y[Hi'e&Of)%a6;\jU„U"QiUEe<>ba9'd(VE/KUw'wb/^>2_w:wj#5K<$f$VeI7kIk%6dMEjVYXUmH&N\:;T„U"&d'+*OFF45o8LKsE-+Vz,TT,.S-QGk[QTBqh7uNbo^V1&+gQ'=1dPs;=BnGT8R6„U"?P)w7Pf%sR)RX2C1ao)2\#()-tsa]4&3ip9$p?UI+hGq$s1\<3Z63L:*qC:NXSb„U"N<K?q)i?I9SGG$p5-TC[]Pf*CPH$;:;Qj9:8a2;M0/5Au<^mRSB>X7iPT[9&+m:„U"?YdH%'fI_OHVh,r4fpA3cd)RJs^HJYVg<uQeNki,ftWr9q&d$KZ#8M:[sc:'**f„U"YUS5'y+2N(LK/nozMGnT*^TWN^O:2TxnA*')Px=J9;4O#7XM][A;Sv+%OkL:6u0„U"Q.+M*z-yhdpkLttt)#jgpkPAe^EkX]]QSmXX<LKe#/sDZ#^RV1+:%KA+4EXJr%X„U"hJ%RNU^eHc+)^el3IeeI<h0.)\GvxFQJH0xK5WKSuh52TSwSMYjuW81:W-gi?US„U"m(5iLp(q%uHC:RE2*K+'bJOy1%'#i(wWSg6,K.fslR+Qa%_L4805Xx[.VmdpN%N„U"#r/08;z;&=>&ey46G>iO-Ah9Ol/e23R(f8/V;6&d[;9N2\irap0CFF$f;p2PSK8„U"T$'9+]/x+dYU:P,;eb&n[-Pk%[+n%Ro%]j4_+?.&.*U9>l'dRzoHgBkA&JXUXN0„U"BV-#pKUBic-J:\jh.98k79yP=E78KbCfE;LkHuViHEO=h*;Cj'L(MCX6.A#PHpO„U"/6J*h[OO67oPypY_K(#iU-BJ)SKI.k23J[mM5>=^P0#(r9Oi_eqE#4Z+RSQknre„U"fB-C.>buFVE=hUFjQD?E8*7:pkFp[o,I0vA.YR<2>TmwDb)6$XqXhoVeIfE8J->„U"W/0-Wq[<d5D_+'jcF+K+S5J#3G()Hb&.J_lPL7S,hqXGY\6?SCl/bS$$6\JKrg=„U"92inrjs+2NSFv$MK*9BtR5J1Eb.sFg$,ph66N7FH^&=\A)UlB_,rKXm_+We,oa[„U".&C1kUyv)eB5Es\5F'_\:K7LO4T4=X3K'Ww\k##FXJuJ8v_8_=\(x='AmyqZ>)N„U"*C2Q)dTt3oto&+pT?CF]6;Mh&N+C8WjQFTkrSXFG4KIMi:2T;kQ<OwvcVkF71l;„U"hj2T=hzm$YE*u9Hc).\R7x5;saEn#s8E1T+0b=ZU<(p/f<T/1Gcn0kiEt7W<B2L„U"e2VUOZX?I;Df)0Jvao2&pM4?(BirT4,Wk+%a^c*i0JmF;iAH/01da,BO0QT+^Fq„U"eH\k*E7+^=xTFqh51%sg1bt+l,1VsBB/_30L2VPtS?\Bee1dOoSm\Q3sRcP_c2R„U"0n%2oGM/T$,^..KG.eNg+U.p:p&EM.m36lIO1NC9WoB8DMJ%,UH.WRlXcJL7VPP„U"6VU$XEJK>&*?h^USbNH)_cg2?'%[\T3f;ktN:juO1K6$ee5JkDN=)i10$-/q85T„U"LIjN-&I'X-uyTM/Yp'D4XwU1XswFC\m*nXQY+2O*AWbnkHfR%7;[:vm<[OMChX=„U"N_Bs<\?LY>j[H8+u#JeDHIkk/d0TNZwG[i4E25%QmE8%ulCbcniM6-K2kTX(sHq„U"pBblJ_GBBgQM0TUz?]]77#w+doa\9vCk#7Sp#/8wjddNv)mfq*$Gh;hI*;-Iq1e„U"29?H2[B5Y1CD;fk1l'DHTs&E,fq,#*__I^Qj79Sb5.cRExJQOxq%++X2+c)rd<z„U"'ZvS#3m(Ls<GvrnL[dU.Ia4864vR1,Fe/w%>S%Cd?rM-I8S,jpl[k.klBLC^V4E„U"3i(9s%I7Q>>XGn[lHmq:1DPX%b+PULdF,97J<lkJ[JkoFWkMa4%>iI5vmm^cHKf„U"Sn<c;HpUkkt#(=&TWLe-rM^^P\akUa^P=:n.T,8D3fDqlK<d?EJsiz^V%qZN\qg„U"PXX_FSB_iO?.cL0rIB'r?bnJ#mU>%7SamI?]oeAi_h7-s,8'Z96FJQ85G6=H7j_„U"#vHa.%=Bb_a78QExF7&CH5PTDNY5S?/8l'YsI&ULNG?G4ZoiC2bZ3&5mnb*G6vu„U"HE+^L4/TP]4^&e2PHN%363K5Kj_#ubtkq^[7GL^vXMu)55Mr4cVxKq#/tYptVRs„U")a^o5vq'&Ly+O7H4+8UT$WG;s1>-AGMt7?<,mEkWs<+OF5DKeIje=L$jokit_+H„U")kMB_Bn7$=ysvJ_.sr*gJh1,Jf>_rEQ>D6M7YXwO;8$Y<$ah&/e$t.Dj#Z5M<hh„U"U]u1cP4?P5#D7%g/gA_$[0aIn;1L8-sD,SX>n=g))c+-iWp<f=24p[lj17ZZwGk„U"t+cRK(5%Cc-Hr(kK*liEFbrGSZgyp,o_Du3U%JZ)&H3.Q'GLKn^UCGO6QLRwq<^„U"'$6A<S$DMe/R:i0n,e=9>#H*pBeBQ>C6nLkj(K.KB^nw?qv(f/0#j^l:iBjg=o=„U"8mDE7S6^+G'3)a*[ocTtXK,QM_$RJs;J\uutE-E:ht_YHibLjhmdbOLu?=E2wBb„U"j3IH9jpm3$U66t4N)_A>o$b8g)w%;l7Cr>/G[t&1qC_Xd0U]>>#0WM8;DEU\Z3#„U"K2cMAsu#cm2$-klG#xP(a^w$;Y#v0-_i8*sUgJXCGN8PhsmrA;w<BrD]s2djX+J„U"JnjRz'x3T96g;FHRciCnrShN^O0B$AqXRI^RL-UO:FY$mkyDMh,_'%6vC=*ek>0„U"tbu^LMCqE*q:^i)-aF]tn4U8c>1Zi%,_$XSUe7g+o\,CUM8Pm\DgaL8b)GNXuDG„U"J->eOGh9'YFNrJu-b988_W<a+_W'4mK%i.9ma,vj$n/cq\>kjwKGGt<=i*f,M24„U":?6ZDgRr:>BbUAJcm2)[q/T<YsQiuK]$ZZkq-'Ekb1SVV],5[GXR.F,O0WteCZm„U"Eq0Au>#%Kl5Xd2eijRQ=Fi]5\-sc>Z5,?^Y7]NYwxB-]t8J<[\_\izZDI$U;X/Y„U"*dD]G.jrUWNrSJj'):S;:6VY;uDsdiN1Qj=_D+<Rkf+PkMgD*Gq;v,qYyFPvrk$„U"*_?IM:c\w/$KP+Ri$_ZX.fycimVl2DTe'8ABj)0WS%;I1]i#3[A.KZZP]b$+DlK„U"[2P*:]sEFa#VcZ-uc1q0I[nftdL28+k,^GabECVV9R\u*7Eeq+,+>jL\='NOU$*„U"K8Y#,fBqaPu>Nj4i,xvc0^z5?Hc/Ju.&H;LlPwvQ$.8iUPs.8h+k&86I$//owp;„U"eCA0+N?:eu'94GUV[rB=[%7^ihVv\#ANj^a73,0A((*scP,<>>(UjIGxLNngn:P„U"Pn92M98[h:wXbAf'8z;;pJJ93q$Y^UvP&'UrbG)UrP-ZdACI^wZ0E<x#kui?aR0„U",w&EX<D<2>8_[Uj86(%Ml$HZ2/+?tDReu>s(&QA^.\RZ/RiOj0M(TP-W4*m7$*O„U"6HCi2>C5+.'K3w8aD]KR*EP^-njCJj[2u9n+g&a8r5my2e5j3\y6Lxj.ighAQP#„U"0qs'L&]?fSgOq)a(3G(R1#Pq<%V#Ia?G]C*#>I8#pn.WOG+^CN_66YW,Hxa7xYI„U"A$+k^rZ-=UA,=WuCd)d4>jr^Hb_aYHJ9C(%,%j;QP0[Gy;W:bj;4q?>J8&7?FA8„U"NZy*L7&$D>E[_cjluBnxZI5tUbnm<-Ub^KIuG8lL9'=-uQ:6sx2D+%z+ak8zC9,„U"mmv6$4[%J0<T>g5B0QZq*#Onv+dEweWs\IaiL7_$42ExrQdloygIn&Z+NbBr\x2„U"tE5+7wK9^C&Zs8Am%f?=55&lMCGSgvp5#A-3;FBqmhNrBp4k6/PHJ6yIkUc&=k?„U"A=hU*.Kq-eTvyaPfbqUc.dCWJi47gS$U\94G2SNpj2J4T[%rOf()MW1'e<e:xG=„U"^M<M)j$xd[(SQ5_I.lLDe31s0cNO9U09Gh&pC5FREOP2eol]CpT$WQH'1[9C>:g„U"ULuqLD4JXU(H4Jc8kR[hqpEotP.W6[[qsDHdX)+zY*oem#Pp>1DYK)aTh+#c.N/„U"'6&6RrrkDqR53.MSReJqou.tQ*5gkzI_RNt]=8j;P32Zf_(z;10bNoHo:'h#*kg„U"qpL[7Ve<6H-&T1(:f(l6v]Wl]5&008[%X4KG0hNm5lmmd8[_g\<R8qf?js3D/W*„U"k3''GptC))Az.H]rc9LMrU(ig#]qPtpTR5Mm-i%Fxuo/#]P/_J$<TAG[OZkY3YD„U"/B<Vcjsi\>*7)_RM'p:zj:/13p]<>(fY&1QK;8)#IMZ'$Z=HErj-;XJaM>/yD#t„U"t[ef>qPNdichj\eUy<+i7#]mPQ2kC35<9:6g^Glo^HfnleOv?$&u^[9z<Rspq5]„U"_HXtFgY^JBN<J['+Ki&;J%qcaPHh<V16aM.RoPGa,:>Vh^o+ZT+jA2\on))h--_„U"gcora#W[Fb&_3GJ[CAXNcXK^'I1(^('JX>CsBCu6*[Lo]zA%+SYR7S?iqI40?F,„U"uN-.RDcHKOCvb%fZf?1&DtCvRT'8\.R*=K)>/vQQ-e.QJt9h4^L,j(p3+kiH?>G„U"uKj9*HsM\\W#N]G-U#=g(0gf.I<iH%9r1l5^t,nXkEV?;+ZE*e3b&,X>5H3W;F+„U"3pT9Oe:Lo6xMcg6P[TGD,L?^L%-%U&FN.Qm6^B7.Q]9_&BXQ8dSKPa<M]_JX<qP„U"/1=-)f;9e'Fr5T1ur94BXJh3.NlLUb&?;hZuY^_im&b[q$jGSCg't?:uhG3k$AB„U"Gi9p5w\fB'UuVRb2Yg=o.FfE=BUd85m#1Nm\/X%^v7OAqCf2]StfR>bi0jWd,oV„U"6KxO\?M^,fIij4M?iHO';UQ8td9BqYTTi#>f+(6'qYK(nnIjBkvxuh,^G'3jfUd„U"4;Yb9Af8evNXmM.#LHy0suZ#G\hB60D_^2ai2(aJ$XdiVR5bd_I74pC0?e-=-/]„U"Y<)Ye;KnG#<-=IB?KsB-t?l,:72LMIL7Xs9([)hEPn_sCj1Sun+9Yiwk*pEb=&=„END SUB„SUB V3„U"<8\vSthd5b_*#oXEhk]u:Q,^X?qAcYA;IDfHAN^/>_8Y;Q7%jPcK$Vn.lZnLCpl„U"j.iJhPWj?C>Vi.KdF(5_a=Dx0I^B_(JFl1]57SQ$sHmqldsl0BdG8[T\Q$rM((O„U"Mr=-/l&cL8/a'F\F#-joFFZ^FM5^p]>crWogi8QkHDFDkHDdpZjIFzKkY;yXd'#„U"rUaO\ItoY_Z1Gk0^3sj'VM$XLkk+dC'3t%l\/,>n;*3DzF1u^U6'&*QET$;ZQMj„U"T&q5:*diF[ovAB.x_>\i(uO22O))3d$^#HjOA;VfDD?#3tZ/INvWLY_5Nh9<?M%„U"K_PU=;.tL)CX1)IOh&(GXo?&VCX=RK+H33sttQtB:#lQLjU]UDf0A)6/y+WCqPD„U"lOF1UoFk6;UT7U,]8OP*FpEM<Ac<PkDSC+FXO/QV)4T#5JyKUoB6K<_m9.mS#H$„U"/>R2lMrmL34U7:rw4XqWfzErBpU1_T&_U,l3l0brG0943*;1Ni?a;Xrf3*lj\a)„U"VtQ(awea4\qS#o(+[JI:;Fm&zR1PAFF-EVjMTice'^i8Eo9Vq_VjW\,;8$c\l:U„U"V]]Rp<(5mVs?n/%.NInFNEih+P8-Ri3B*lT0aEhEMO'sMG\'K5dZdF>\W<t+Fn9„U"7fX&aS%11fQ<gt?8/NsFacrU)SP=teJa>[)'o?]y>fu3TO<Cpd]>Vo?H,&]Gp,q„U"DZ]IWcg%Tk6]%.>PJ6,tY]:d0QOY)9])Bj0=z4]'vFKC0ws6[2%wu+=MIntU<IX„U"tJC]]&I0toknZv?Ar'\,KLtU0Q/e+ct7EU1am>jusAYH'0UIy(1ZecWs(eEH+-T„U"j6uEH#b<g#Z_*p#\T?03j-Z_7cjE:,_&l^%uNuEAHqn$u=?2[F]>&;0h;T#FJt.„U"A3*5I]k=>E#)14:;)E#0&I=-8*tp8M1B/rGti4t_2Y[sT]VCI2'tgj;FTn15mP1„U"#y[yt'+tIdjghH>8(18<lkX?J.0jF6RX#J;fQ-4<DhOCLpTe>Ek:t'kp(vi's_l„U"Zpmh\vDat36.9*qM-J6hh?CSoj&n2jU1$7^7h1$$fXW1>F.VIa2B]1V#NQ<r_PU„U"#4m%\;>\'6g\XGj?giho/x#6-hr0tN[[VJABvR+=-bZ'hyXdQO2UJ:hneGPGjlF„U"(c\G4u]2LZ0&)wFO6<>_;dS+Gm;5;>yT9m%HM&K(v$9aco_6nYU+_gQjGH19a0Z„U"Jc$$02pjuN]K7q+1N4$cbs;Vknr\IL6VPbtQ7w^)AJ=Z<D1BUZ%;l;TL>iORw>e„U"rN9&(Z(#xju+TfFQFF<<t<fffr:/)0N0F??CUdo\M]]]\D\l_DM9KKKqAAkND&.„U"rvrL>5ji?^MmtrdP(cx[<8Zqn(NQ&dIxLy),,?vi<4sdxul=duZ4uO++sK+W*(Y„U"(,N9i,)jdldT;/kEu6'/yWJ:TWQ,*hzQ<F^[DvOV+.O=RP0S#OvN5z590*,lT%x„U"okIuI%lPW5(;>>/2-/Tt2=[p/\R4+TQrfG(%WF%O5UT:0&L*jzIkjDQFcOW[d5/„U"4DYJ'D;z<h<(DK=HWP9/yI[$S:0/oRw6ojyImc&<Cz4ltQ/TWQ/l'_y<UQ5kc<#„U"^B;D>:$xox_G[+#9j=dB#p*t\3o]^2)]\3sV]^6$,m-(<D?<zRZ6/M/$lxvii*^„U"1A;'?ky,?uyOQvcx/,>lE;8/T,ZYfRTyYiT&<Z:s/o'&BY+-f6N-V<z+eh(<4/u„U"W+s/pO*4N<O;.,NdjJ<q<RoogyBd6r%y&E*S]lztL)COb:.4OW0te<YRFfRb<:y„U"t3Y'>><wrVHtpfI3r%y7Ce9O-(=9(0*Y<noIq*jFWV=>g<qUcF:q5jVOZUOUUX*„U"QcR>r8gBrtDcMgTQrsHYQTIClNbIlcsxjLD\\.LDnK2bKkl_Ze_M4\<zzf244G)„U"qzyi)Rzz.(Q&f%:rI9f.&),rHX,ddJt</:s0sfjRP4,\=kiV5d?.Tj=_;=sR3fG„U"[[a\\VOiOEy&Y<56LNU=V:X1/.tcSTlToSkTT?#STtL*RvIkJ#R:ZBWW&R,,Lx'„U"M#[#maYQOX[QWm#/+lRu:*WWc*:fUJEOdi.AAkACBLZd2ID;Qmb_s?6QQ^sGlsj„U"*M*???(Qd_ZL_I9;m13u?9q]WD1dD97-gud&%up&'%9%9%%'%-%/9b+Dtx_bO&6„U"&%%%w(%%%+%%%%%%%%%&%E%%%%%%.%%'l%Sgfx%up&'%9%9%%'%-%1P\3Cr(=hD„U"'A%%%%e&%%%,%%%%%%%%%&%E%.%%Z&%%%fi%iSgf%xup&%'9%9%%'%-F%qb+UDE„U"7\,mt*%(%G6%%%-%%%%%%%%%&%E#%%%G%'%%i%jrtS%gfxu%p&'9%%9%'[%-%>%„U"mtDabmnNv#*%%G%6%%-%%%%%%%%%&%%E%%(%h-%%%ijr%tSgf%pup&%'9%9%%'%„U"-I%1U31C6Kc'QD+%(%K3%%%,%%%%%%%%%&%E[%%%5%3%%u(h'Sg%fxup%&'9%%9„U"%'%R-%vTA3C?l8,Bg%7%%*&%%%,%%%%%%%%%&%%E%%%%%:%%%wlgS%gfxu%p&'9„U"%%9%'%%-%j_G3Cb9b,8A[&%%m%&%%0%%%%%%%%%&%%E%%%%8;%(%'hn%whqj%Sg„U"fx%up&'%9%9%%'%-%3tE3CPn>]#&^&%%&i(%%%+%%%%%%%%%&%E%.%%'<.%%'l%„U"Sgfp%up&'%9%9%%'%-%3^P3CUAuYP%r'%%&?*%%%,%%%%%%%%%&%E%%%%0>.%%'„U"l%WSgf%xup&%'9%9%%'%-(%ontUD:*$*XL'%(%.*%%%.%%%%%%%%%&%E#%%%L##„U"%%'%lwfk%Sgfx%up&'%9%9%%'%-%&&mtD\$9:>%b&%%'7(%%%.%%%%%%%%%&%E%„U"%%%FC.%%'q%nsjS%gfxu%p&'9%%9%'%%-%,DF3C>R,v+$%'%%h%,%%,%%%%%%%%„U"%&%%E%%(%TD%(%'ul%Sgfx%up&'%9%9%%'%-%1%N3CT'V,('A(%%&z2%%%/%%%%„U"%%%%%&%E%%%%$G.%%'u%wnsy%Sgfx%up&'%9%/%%%%%%.:c+D/9+Ul&9%%%&9%%„U"%%0%%%%%%%%%&%E%%%%PK%%%kn.qj.n%iSin&)up&%'9%9%%'%-#%^c+7D'mD-p„U"F*%(%m1%%%.%%%%%%%%%&%E[%%%7#K%%'%lwfk%Sith%up&'%9%9%%'%-%3BK3C„U">i17)&SM%%'%]%%%-%%%%%%%%%%%E%7%%+Q%%%qf%siSu(h'up%*+%%%%%5%.5%„U"1(.%%+z%%%%%„END SUB„V2„V3„CLOSE:IF S=28AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„'>>> Page 1 of XGRAFPB.ZIP ends here. Last page. TCHK:28„Robert Seidel                  FLI-PLAYER                     seidel@ifk.uni-jena.de         08-26-95 (04:36)       PB                     425  11542    FLI-PLAY.BAS$IF 0„„  FLIPLAY - a FLI-Player written in PowerBASIC 3.00c„  Beta-Version: some known bugs, but not corrected :( :< ,„                because I have no time„„  Note: Robert Seidel (some changes) for PowerBASIC 3.00c,„        I have removed the MODEX-Libary and optimized some parts,„        now it works about 200% faster than the original version„        written by Dean using Quick BASIC ! Thanks to Dean for„        this great source.„„  Robert Seidel„  Kefersteinstr. 14„  D-07745 Jena„  Germany„  E-MAIL: seidel@ifk.uni-jena.de (my dad's adress)„„  This player has some problems with newer FLI-files, but I have„  no informations about the new headers. If somebody changes this„  file, it would be great if you could send me the new version„  of FLIPLAY and you will get some things I have written in„  PowerBASIC ! If you are interested in changing PowerBASIC-„  Sources, write me too ...„„  You can you use it in your own programms, but please send me a„  copy of your programm (Shareware -> REGISTERED VERSION !!!) and „  include my name in your credits !„„  This file includes a small part of XGRAF, my SCREEN 13„  libary. If you want to have it, write me and send me a„  disc with your stuff !„„  Optimized:  -new graphic macros„              -no CVI/CVL-functions„              -some ASM-parts„              -used INCR/DECR„              -converted PEEK to ASM„              -...„„$ENDIF„„'----------------------- Compiler options -------------------------„„$ERROR    ALL OFF 'for more speed„$LIB      ALL OFF„$CPU      80386   'I have used some 386-commands„$FLOAT    EMULATE 'this programm uses no coprocessor-instructions, so the EXE„                  'won't be bigger !„$OPTIMIZE SPEED„„'----------------------- Data types -------------------------------„„TYPE Fheader 'This is the format of the Header on a .FLI„  Size  AS LONG„  Typ   AS STRING * 2„  Numf  AS INTEGER„  Wid   AS INTEGER„  Hei   AS INTEGER„  Bits  AS INTEGER„  Flag  AS INTEGER„  Speed AS INTEGER„  Nex   AS LONG„  Fri   AS LONG„  Blank AS STRING * 102„END TYPE„„TYPE Frameh 'This is the header attached to each frame on a .FLI„  Size  AS LONG„  Typf  AS INTEGER„  Nchu  AS INTEGER„  Blank AS STRING * 8„END TYPE„„TYPE Chunkh 'This is the header for each Chunk in a frame„  Size  AS LONG„  Typec AS INTEGER„END TYPE„„DEFINT A-Z„„DIM DEFSEG AS SHARED INTEGER 'the PEEK-substitute needs this„DIM W      AS SHARED INTEGER„DIM Fhead  AS SHARED Fheader„DIM Chunk  AS SHARED Chunkh„DIM Lns    AS SHARED INTEGER„DIM Clr    AS SHARED INTEGER„DIM RS     AS SHARED STRING„DIM FileN  AS SHARED INTEGER„SHARED a$„„OPTION BINARY BASE 1„RS = "FLIPLAY V1.02 Beta (320x200x256) by Robert Seidel 6-11/7-16/8-26 1995"„„'----------------------- Main -------------------------------------„„IF COMMAND$ = "" THEN 'Access input„  ? RS„  ? "File not specified!"„  END„END IF„„Nme$ = COMMAND$„IF INSTR( Nme$, "." ) = 0 THEN Nme$ = Nme$ + ".FLI"„„? RS„? "(QUICK BASIC Version by Dean)„? "This was written in POWER BASIC!!!„? "Now playing: " ; Nme$„? "Press any key to continue...„WHILE INKEY$ = ""„WEND„„! MOV AX , &h13„! INT &h10„! MOV AX , 19 + 128  ;this is necessary, because I have a strange VGA-card„! INT &h10„„OPEN Nme$ FOR BINARY AS #1„FileN = FILEATTR(1 , 2)„„DO UNTIL a$ <> ""„  a$ = INKEY$„'  t! = TIMER„  Playfli Nme$   'Play the .FLI„'  time! = TIMER - t!„LOOP„„CLOSE #1„„! MOV AX , 3„! INT &h10„? RS„END„„„'----------------------- PlayFLI SUB ------------------------------„„DIM STATIC Fm(0 TO 32766) AS SHARED INTEGER„SUB Playfli( XName$ )„„  SEEK #1 ,  1„  GET  #1 ,, Fhead             'Get the header data„  DIM Frame AS Frameh          'Set the Frame varible„  Lr = LOC( 1 )„  GET  #1 ,, Frame„  Seekn& = Frame.Size + Lr + 1„  DEFSEG = VARSEG( Fm(0) )„  Vl = VARPTR( Fm(0) )„„  Lns   = Vl„„  'Get the whole FIRST frame into memory„  ! PUSH DS„  ! MOV AH , &h3F„  ! MOV BX , FileN„  ! DB &h66„  ! MOV CX , Frame[0]„  ! MOV DS , DEFSEG„  ! MOV DX , Vl„  ! INT &h21„  ! POP DS„„  FOR Frms = 1 TO Fhead.Numf„„    IF INKEY$ <> "" THEN„      a$ = " "„      EXIT SUB„    END IF„„    IF Frms > 1 THEN„      SEEK #1 , Seekn& - 1      'PB needs the "- 1" or you get an overflow !„      GET  #1 ,, Frame          'Get the frame data„      INCR Seekn& , Frame.Size  'Store where next frame in file is„      'Get the whole frame„      ! PUSH DS„      ! MOV AH , &h3F„      ! MOV BX , FileN„      ! DB &h66„      ! MOV CX , Frame[0]„      ! MOV DS , DEFSEG„      ! MOV DX , Vl„      ! INT &h21„      ! POP DS„      Lns = Vl„    END IF„„    FOR t = 1 TO Frame.Nchu„      'Chunk.Size = PEEKL( Lns ) 'Get chunk data„      ! MOV ES , DEFSEG„      ! MOV BX , Lns„      ! DB &h66„      ! MOV AX , ES:[BX]„      ! DB &h66„      ! MOV Chunk[0] , AX„„      INCR Lns , 4„„      'Chunk.Typec„      ! MOV ES , DEFSEG„      ! MOV BX , Lns„      ! MOV AX , ES:[BX]„      ! MOV Chunk[4] , AX„„      ! MOV AX , Lns„      ! INC AX„      ! INC AX„      ! MOV Lns , AX„      C = Chunk.Typec„      IF C = 11 THEN           'This is if its a PALETTE block„        ! MOV ES , DEFSEG„        ! MOV BX , Lns„        ! MOV AX , ES:[BX]„        ! MOV W , AX„        INCR Lns , 2„        Cl = 0„        FOR i = 1 TO W„          ! MOV ES , DEFSEG„          ! MOV BX , Lns„          ! MOV AH , ES:[BX]„          ! MOV a , AH„          INCR Lns„          INCR Cl , a„          ! MOV ES , DEFSEG„          ! MOV BX , Lns„          ! MOV AH , ES:[BX]„          ! MOV f , AH„          INCR Lns„          IF f = 0 THEN f = 256„          FOR e = Cl TO f - 1„            OUT &H3C8, e„            ! MOV ES , DEFSEG„            ! MOV BX , Lns„            ! MOV AH , ES:[BX]„            ! MOV g , AH„            INCR Lns„            OUT &H3C9, g„            ! MOV ES , DEFSEG„            ! MOV BX , Lns„            ! MOV AH , ES:[BX]„            ! MOV g , AH„            INCR Lns„            OUT &H3C9, g„            ! MOV ES , DEFSEG„            ! MOV BX , Lns„            ! MOV AH , ES:[BX]„            ! MOV g , AH„            INCR Lns„            OUT &H3C9, g„          NEXT e„        NEXT i„      END IF„      IF C = 15 THEN           'This is if it's a FIRST frame RLE„        x = 0„        y = 0„        DO„          ! MOV ES , DEFSEG„          ! MOV BX , Lns„          ! MOV AH , ES:[BX]„          ! MOV Nump , AH„          INCR Lns„          FOR r = 1 TO Nump„            ! MOV ES , DEFSEG„            ! MOV BX , Lns„            ! MOV AH , ES:[BX]„            ! MOV u , AH„            INCR Lns„            IF u < 128 THEN„              ! MOV ES , DEFSEG„              ! MOV BX , Lns„              ! MOV AH , ES:[BX]„              ! MOV Clr , AH„              INCR Lns„              ! MOV AX , 320„              ! MUL y„              ! MOV DI , AX           ; Formel : 320 * y + x„              ! ADD DI , x            ; fÅr Offset„              ! MOV DX , &hA000       ; Segment : A000h (Videospeicher)„              ! MOV ES , DX„              ! MOV AL , Clr          ; Farbe„              ! MOV AH , AL„              ! MOV CX , u„              ! SHR CX , 1„              ! REP STOSW„              ! ADC CX , CX„              ! REP STOSB„              INCR x , u„            END IF„            IF u > 127 THEN„'This line uses FABS, and so I have written an integer ABS„'u = IABS( u - 255 ) + 1„              ! MOV AX , u„              ! SUB AX , 255„              ! CWD„              ! XOR AX , DX„              ! SUB AX , DX„              ! INC AX„              ! MOV u , AX„              FOR w = 1 TO u„                ! MOV ES , DEFSEG„                ! MOV BX , Lns„                ! MOV AH , ES:[BX]„                ! MOV f , AH„                INCR Lns„                ! MOV AX , 320„                ! MUL y„                ! MOV DI , AX           ; Formel : 320 * y + x„                ! ADD DI , x           ; fÅr Offset„                ! MOV DX , &hA000       ; Segment : A000h (Videospeicher)„                ! MOV ES , DX„                ! MOV AL , f        ; Farbe„                ! MOV ES:[DI] , AL„                INCR x„              NEXT w„            END IF„          NEXT r„          x = 0„          INCR y„        LOOP UNTIL y > = 199„      END IF„      IF C = 12 THEN       'This is if it's another frame, it skips lines but„                           'it's also an RLE„        ! MOV ES , DEFSEG„        ! MOV BX , Lns„        ! MOV AX , ES:[BX]„        ! MOV y , AX„        INCR Lns , 2„        x = 0„        ! MOV ES , DEFSEG„        ! MOV BX , Lns„        ! MOV AX , ES:[BX]„        ! MOV Clins , AX„        INCR Lns , 2„        FOR Ncl = 1 TO Clins„          'Get num of lines to skip„          ! MOV ES , DEFSEG„          ! MOV BX , Lns„          ! MOV AH , ES:[BX]„          ! MOV a , AH„          INCR Lns„          IF a = 0 THEN Skip„          FOR Npa = 1 TO a„            Repeat:„            'Get num of pixels to skip„            ! MOV ES , DEFSEG„            ! MOV BX , Lns„            ! MOV AH , ES:[BX]„            ! MOV Pskip , AH„            INCR Lns„            INCR x , Pskip„            IF Pkskip = 255 THEN Repeat„            ! MOV ES , DEFSEG„            ! MOV BX , Lns„            ! MOV AH , ES:[BX]„            ! MOV Snd , AH„            INCR Lns„            IF Snd < 128 THEN„              FOR Rd = 1 TO Snd„                ! MOV ES , DEFSEG„                ! MOV BX , Lns„                ! MOV AH , ES:[BX]„                ! MOV Clr , AH„                INCR Lns„                ! MOV AX , 320„                ! MUL y„                ! MOV DI , AX           ; Formel : 320 * y + x„                ! ADD DI , x            ; fÅr Offset„                ! MOV DX , &hA000       ; Segment : A000h (Videospeicher)„                ! MOV ES , DX„                ! MOV AL , Clr        ; Farbe„                ! MOV ES:[DI] , AL„                INCR x„              NEXT Rd„            ELSE„'This line uses FABS, and so I have written an integer ABS„'Snd = IABS( Snd - 256 )„              ! MOV AX , Snd„              ! SUB AX , 256„              ! CWD„              ! XOR AX , DX„              ! SUB AX , DX„              ! MOV Snd , AX„              ! MOV ES , DEFSEG„              ! MOV BX , Lns„              ! MOV AH , ES:[BX]„              ! MOV Clr , AH„              INCR Lns„              ! MOV AX , 320„              ! MUL y„              ! MOV DI , AX           ; Formel : 320 * y + x„              ! ADD DI , x            ; fÅr Offset„              ! MOV DX , &hA000       ; Segment : A000h (Videospeicher)„              ! MOV ES , DX„              ! MOV AL , Clr          ; Farbe„              ! MOV AH , AL„              ! MOV CX , Snd„              ! SHR CX , 1„              ! REP STOSW„              ! ADC CX , CX„              ! REP STOSB„              INCR x , Snd„            END IF„          NEXT Npa„          Skip:„          x = 0„          INCR y„        NEXT Ncl„      END IF„    NEXT t„'     FOR Wt = 1 TO Fhead.Speed„'          Waitvbi 'Do delay for num set of video cycles„'     NEXT Wt 'If not needed, it goes faster on fast frame rate FLIs if REMED„  NEXT Frms„END SUB„„SUB Waitvbi„  Agin:„  i = INP( &H3DA )„  a = i AND &H8„  IF a = 1 THEN Agin„  Agin2:„  i = INP( &H3DA )„  a = i AND &H8„  IF a = 0 THEN Agin2„END SUB„The ABC Programmer             WHEEL OF WEALTH PB             Check GAMES.ABC For QB Version 01-17-96 (10:42)       PB                     1088 29903    WOWPB.BAS   '======================================================„' WHEEL OF WEALTH PB          Programmed by William Yu„' PB 3.x version              Converted: 01-17-96„'„' NOTES:„'   Since PB doesn't support PCOPY, I had to„'   BSAVE/BLOAD the images.  This will affect the game„'   and slow it down considerably.  Call me lazy, but„'   I didn't want to use GET and PUT and create extra„'   SUBs.  Do what you wish to fix it.  It might even„'   patch up the graphics (which may become„'   disoriented because of BSAVE/BLOAD).„'   Also of note, I don't know much about PB, so the„'   variables are (for lack of better words) mangled.„'   Even though the variables are SHARED, they don't„'   quite generate the same value.„'„'   After playing the game, to save disk space„'   goto DOS and type:  DEL Image*.*„'„' * Puzzles are stored in DATA statements„' * Up to 3 players„' * Like TV Game Show WHEEL OF FORTUNE (Without Vanna)„'„' USE WITHIN COMMERCIAL PRODUCTS OR SALE OF THIS PIECE„' OF CODE IS STRICTLY PROHIBITED.  PUBLIC DOMAIN CODE.„'„' WHEEL OF FORTUNE is copyrighted by their respective„' distributors.  Any similarities to the Video Game„' is strictly coincidental.„'======================================================„DEFINT A-Z  ' Define all numerical variables as INTEGER for more speed„'DECLARE SUB BigChar (Word$, XCor%, YCor%, Colr%, Opt)„DECLARE SUB Bonusland ()„DECLARE SUB Drawgrid ()„DECLARE SUB Filterpuzzle (Puzzles$(), P%)„DECLARE SUB Mainprogram (Puzzles$(), P%)„DECLARE SUB Letterinpuzzle (Letter$, Letter)„DECLARE SUB Spinwheel ()„DECLARE SUB Colorcode (Col%)„DECLARE SUB Drawplayers ()„DECLARE SUB Showplayers ()„DECLARE SUB Whoseturn ()„DECLARE SUB Showleader ()„„DIM Puzzles$(50), NoRepeat(50), Puzz$(8)„„SHARED Puzzles$()          ' Max # of Puzzles„SHARED NoRepeat()          ' Dimension same as Max # of puzzles„SHARED InCase$, InCaseVowel$„SHARED Puzz$()„SHARED Money, InPuzzle, Turn, Rn, Finish, Bonus, Maximum„SHARED PlayerMoney!„SHARED P1Money!, P2Money!, P3Money!„SHARED M1P!, M2P!, M3P!„„SHARED Players         ' 1-3 Players (1 Player no score tallied)„SHARED Rounds          ' Number of Rounds per game„                       ' CAN NOT be more than the Maximum # of puzzles„                       '  minus "BLANK" categories because it can not be„                       '  used in the BONUS Round„SHARED False„SHARED True„„Players = 3„Rounds = 6„False = 0„True = NOT False„„Rn = 1                    ' Round Number„WT = 1                    ' Turn = 1„Turn = WT                 ' Create another variable for swapping later„Finish = False            ' Finished Puzzle?  Nope.„Bonus = False             ' Regular round not bonus round„„SCREEN 7, 0, 0, 0         ' EGA 320x200 (16 Colors)  Active Page 0„„READ Maximum              ' Read maximum puzzles„„FOR I = 1 TO Maximum„  READ Puzzles$(I)        ' Read each puzzle and store in array Puzzles$()„NEXT I„„DO„  DrawPlayers             ' CALL DrawPlayers Subroutine„  „  DrawGrid                ' CALL DrawGrid Subroutine„  „  DO„    RANDOMIZE TIMER             ' Randomly select a puzzle„    P = INT(RND * Maximum) + 1„    FOR R = 1 TO Maximum        ' But make sure it's not the same puzzle!„      IF NoRepeat(R) = P THEN Repeat = True: EXIT FOR„    NEXT R„    IF NoRepeat(R) <> P THEN Repeat = False„  LOOP UNTIL Repeat = False„  NoRepeat(Rn) = P„  FilterPuzzle Puzzles$(), P    ' Parse puzzle to readable format„  „  DO„    MainProgram Puzzles$(), P   ' CALL MainProgram (Brunt of the game)„    IF Finish THEN EXIT DO      ' Current round finished„    IF Players > 1 THEN ShowPlayers„  LOOP„  „  Rn = Rn + 1                ' Next Round„  WT = WT + 1                ' Whose Turn„  IF WT = 4 THEN WT = 1      ' Rotate back to the first person„  Turn = WT                  ' Whose turn?„  Finish = False             ' New round, not finished yet„  „  ShowLeader                 ' Show end of round leader„  „LOOP UNTIL Rn > Rounds       ' Continue play until all rounds are finished„„IF M1P > M2P THEN Winner = 2 ELSE Winner = 1„IF Winner = 2 AND M2P > M3P THEN Winner = 2„IF Winner = 2 AND M2P < M3P THEN Winner = 3„IF Winner = 1 AND M1P > M3P THEN Winner = 1„IF Winner = 1 AND M1P < M3P THEN Winner = 3„„BonusLand                    ' Winner plays Bonus Round„„' DATA Format works like so:„'„' First number is the maximum number of puzzles inputted by user,„' increase number if you add more puzzles into the DATA statements„'„' How Puzzles should be inputted (NOT Case sensitive).„'„' 7 lines, each line seperated by "/"„'          and empty line should be inputted with "EMPTY"„'          Maximum of 14 characters per line„' 1st line:  Category (ie. PHRASE/THING/PERSON...etc)„' 2nd line:  Line one   of Puzzle„' 3rd line:    "  two   "    "„' 4th line:    "  three "    "„' 5th line:    "  four  "    "„' 6th line:    "  five  "    "„' 7th line:    "  six   "    "„'*8th line: CLUE for "BLANK"„'„'* Only place 8th line with category "BLANK"„'  Look at the DATA for reference„„DATA 10„DATA "PHRASE/EMPTY/ What Goes Up/EMPTY/EMPTY/Must Come Down/EMPTY"„DATA "QUOTE/EMPTY/   Go Ahead/EMPTY/ Make My Day/EMPTY/EMPTY"„DATA "PLACE/EMPTY/   Edmonton/   Alberta/   Canada/EMPTY/EMPTY"„DATA "PERSON/EMPTY/World Figure-/      Skating/  Champions/EMPTY/EMPTY"„DATA "STAR & ROLE/EMPTY/  Jim Carrey/EMPTY/As Ace Ventura/EMPTY/EMPTY"„DATA "BLANK/EMPTY/ ? Alarm/ ? Fighters/ ? Truck/EMPTY/EMPTY/FIRE"„DATA "PHRASE/EMPTY/  What Goes/   Around/ Comes Around/EMPTY/EMPTY"„DATA "BEFORE & AFTER/EMPTY/ Tooth Fairy/EMPTY/  Godmother/EMPTY/EMPTY"„DATA "BLANK/EMPTY/  ? Hornet/  ? Olives/  ? Grass/  ? Beans/EMPTY/GREEN"„DATA "PHRASE/EMPTY/Save The Best/EMPTY/   For Last/EMPTY/EMPTY„„SUB Bigchar (Word$, XCor, YCor, Colr, Opt)„  „  ' Subroutine BIGCHAR„  ' Purpose:   Prints the extended (BIG) character on the puzzle grid„  „  PALETTE 8, 0    ' Hide the letter to be read in„  „  COLOR 8         ' Color is hidden„  FOR L = 1 TO LEN(Word$)„    LOCATE 1, 1: PRINT MID$(Word$, L, 1)„    FOR N = 0 TO 7„      FOR M = 0 TO 7„        Colour = POINT(N, M)    ' Grabs the colour of the letter„        IF Colour > 0 THEN      ' if not null, then we plot the coordinates„          IF Opt = 0 THEN„            PSET (XCor + N + (L * 8), YCor + M + M), Colr„            PSET (XCor + N + (L * 8), 1 + YCor + M + M), Colr„          ELSEIF Opt = 1 THEN„            PSET (XCor + N + (L * 9), YCor + M + M + Z), Colr„            PSET (XCor + N + (L * 9), 1 + YCor + M + M + Z), Colr„          ELSEIF Opt = 2 THEN„            PSET (XCor + N + (L * 9), YCor + M + M - Z), Colr„            PSET (XCor + N + (L * 9), 1 + YCor + M + M - Z), Colr„          END IF„        END IF„      NEXT M„    NEXT N„    XCor = XCor + 1„    Z = Z - 2„  NEXT L„  „  LOCATE 1, 1: PRINT " "  ' Clear letter„  PALETTE 8, 8            ' Restore the color to its normal value„  „END SUB„„SUB Bonusland„  „  Bonus = True     ' Yes we are in Bonus round„                   ' We need this variable for SUB LetterInPuzzle„  „  DrawGrid„  „  BigChar "BONUS LAND", 100, 2, 12, 0„  „  LINE (0, 199)-(320, 150), 0, BF„  „  Done = False„  DO„    DO„      RANDOMIZE TIMER         ' Randomly select a puzzle„      P = INT(RND * Maximum) + 1„      FOR R = 1 TO Maximum        ' But make sure it's not the same puzzle!„        IF NoRepeat(R) = P THEN Repeat = True: EXIT FOR„      NEXT R„      IF NoRepeat(R) <> P THEN Repeat = False„    LOOP UNTIL Repeat = False„    FilterPuzzle Puzzles$(), P               ' Parse the puzzle„    IF Puzz$(1) <> "BLANK" THEN Done = True  ' Bonus round <> "BLANK"„  LOOP UNTIL Done„  „  ' Like the TV Game Show:„  '„  '   R S T L N   E„  '„  ' Letters automatically selected by computer„  '„  ' You will be prompted to enter 3 other consonants and 1 vowel„  „  InCase$ = "BCDFGHJKMPQVWXYZ"„  InCaseVowel$ = "AIOU"„  COLOR 12: LOCATE 20, 3: PRINT "R S T L N  "; : COLOR 14: PRINT "E"„  Letters$ = "RSTLNE"„  FOR A = 1 TO LEN(Letters$)„    A$ = MID$(Letters$, A, 1)„    LetterInPuzzle A$, 0„  NEXT A„  COLOR 10: LOCATE 22, 1: PRINT "Select 3 Consonants:  ";„  COLOR 12„  C = 0„  Letters$ = ""„  DO„    DO„      A$ = UCASE$(INPUT$(1))„    LOOP UNTIL INSTR(InCase$, A$)„    PRINT A$; " ";„    C = C + 1„    Letters$ = Letters$ + A$„  LOOP UNTIL C = 3„  COLOR 10: LOCATE 23, 1: PRINT "     Select 1 Vowel:  ";„  DO„    A$ = UCASE$(INPUT$(1))„  LOOP UNTIL INSTR(InCaseVowel$, A$)„  COLOR 14: PRINT A$„  Letters$ = Letters$ + A$„  FOR A = 1 TO LEN(Letters$)„    A$ = MID$(Letters$, A, 1)„    LetterInPuzzle A$, 0„  NEXT A„  „  SLEEP 1„  LINE (0, 199)-(320, 150), 0, BF„  COLOR 15„  LOCATE 20, 1: PRINT "SOLVE:"„  Solve$ = ""„  Last = False„  FOR Q = 2 TO 7„    IF Puzz$(Q) <> "EMPTY" THEN„      IF RIGHT$(Puzz$(Q), 1) = "-" THEN Last = True„      IF Last = False THEN„        Solve$ = Solve$ + LTRIM$(Puzz$(Q)) + " "„      ELSE„        Solve$ = Solve$ + LTRIM$(Puzz$(Q))„        Last = False„      END IF„    END IF„  NEXT Q„  Solve$ = RTRIM$(Solve$)„  LOCATE 22, 1„  FOR Q = 1 TO LEN(Solve$)„    COLOR 14„    A = ASC(MID$(Solve$, Q, 1))„    SELECT CASE A„      CASE 45„        COLOR 10„        PRINT "-";„      CASE 32„        PRINT " ";„      CASE ELSE„        PRINT "˘";„    END SELECT„  NEXT Q„  LOCATE 22, 1: COLOR 15: LINE INPUT Answer$„  LINE (0, 0)-(320, 15), 0, BF„  IF UCASE$(Answer$) = UCASE$(Solve$) THEN„    BigChar "CONGRATULATIONS", 80, 2, 12, 0„  ELSE„    BigChar "BETTER LUCK NEXT TIME", 60, 2, 12, 0„  END IF„  AllCase$ = InCase$ + InCaseVowel$„  FOR Q = 1 TO LEN(AllCase$)„    A$ = MID$(AllCase$, Q, 1)„    IF INSTR(UCASE$(Solve$), A$) THEN LetterInPuzzle A$, 0„  NEXT Q„  „END SUB„„SUB Colorcode (Col)„  „  ' The color code of the WHEEL„  ' Yellow = Lose Turn„  ' Black  = Bankrupt„  ' Grey   = $5000„  „  SELECT CASE Col„    CASE 1„      Money = 250„    CASE 2„      Money = 150„    CASE 3„      Money = 500„    CASE 4„      Money = 300„    CASE 5„      Money = 750„    CASE 6„      Money = 650„    CASE 7„      Money = 5000„    CASE 8„      Money = -1„    CASE 9„      Money = 1000„    CASE 10„      Money = 200„    CASE 11„      Money = 2500„    CASE 12„      Money = 900„    CASE 13„      Money = 350„    CASE 14„      Money = 0„  END SELECT„  „  LOCATE 25, 18„  IF Money > 0 THEN„    PRINT "$" + LTRIM$(STR$(Money)) + "      ";„  ELSE„    IF Money = -1 THEN PRINT "BANKRUPT   ";„    IF Money = 0 THEN PRINT "LOSE TURN   ";„  END IF„  „END SUB„„SUB Drawgrid„  „  CLS„  „  FOR Y = 1 TO 6              ' Draw 6x14 Puzzle grid„    FOR X = 1 TO 14„      LINE (X * 20, Y * 20)-(X * 20 + 20, Y * 20 + 20), 10, B„      LINE (X * 20 + 1, Y * 20 + 1)-(X * 20 + 19, Y * 20 + 19), 2, BF„    NEXT X„  NEXT Y„  „  COLOR 11: LOCATE 20, 5: PRINT "B C D F G H J K L M N P    A E I"„  LOCATE 22, 5: PRINT "Q R S T V W X Y Z QUIT!    O U";„  „  InCase$ = "BCDFGHJKLMNPQRSTVWXYZ"„  InCaseVowel$ = "AEIOU"„  „END SUB„„SUB Drawplayers„  „  CLS„  „  CIRCLE (160, 180), 180, 15, 6, 3, 1 / 4„  CIRCLE (160, 160), 180, 15, 6, 3, 1 / 4„  CIRCLE (160, 140), 180, 15, 6, 3, 1 / 4„  „  LINE (113, 116)-(81, 100), 15„  LINE (207, 116)-(239, 100), 15„  LINE (113, 116)-(113, 135), 15„  LINE (207, 116)-(207, 135), 15„  „  PAINT (60, 140), 4, 15: PAINT (60, 120), 12, 15„  PAINT (160, 130), 1, 15: PAINT (160, 110), 9, 15„  PAINT (300, 140), 2, 15: PAINT (300, 120), 10, 15„  „  CIRCLE (40, 75), 65, 15, .3, 3, 1.1„  CIRCLE (280, 75), 65, 15, .3, 2.8, 1.1„  CIRCLE (160, 62), 65, 15, .15, 3„  PAINT (160, 75), 5, 15„  „  CIRCLE (160, 45), 16, 14„  PAINT (160, 45), 14„  LINE (155, 58)-(130, 62), 1„  LINE (165, 58)-(190, 62), 1„  LINE (130, 62)-(125, 95), 1„  LINE (190, 62)-(195, 95), 1„  LINE (125, 95)-(130, 95), 1„  LINE (130, 94)-(190, 94), 1„  LINE (190, 95)-(195, 95), 1„  LINE (155, 59)-(165, 59), 1„  PAINT (160, 80), 1„  „  IF Players > 1 THEN„    CIRCLE (35, 45), 16, 14„    PAINT (35, 45), 14„    LINE (30, 58)-(5, 67), 4„    LINE (40, 58)-(65, 62), 4„    LINE (5, 67)-(5, 115), 4„    LINE (65, 62)-(70, 100), 4„    LINE (70, 99)-(5, 115), 4„    LINE (30, 59)-(40, 59), 4„    PAINT (30, 80), 4„  END IF„  IF Players = 3 THEN„    CIRCLE (285, 45), 16, 14„    PAINT (285, 45), 14„    LINE (290, 58)-(315, 67), 2„    LINE (280, 58)-(265, 62), 2„    LINE (315, 67)-(315, 116), 2„    LINE (265, 62)-(260, 101), 2„    LINE (260, 101)-(315, 115), 2„    LINE (290, 59)-(280, 59), 2„    PAINT (300, 80), 2„  END IF„  CIRCLE (160, 140), 180, 15, 6, 3, 1 / 4„  „  LOCATE 24, 15: COLOR 14: PRINT "Round"; Rn; "of"; Rounds;„  „  IF Players = 1 THEN Turn = 2„  BigChar "$0", 140, 119, 11, 0„  BigChar "$0", 30, 130, 11, 1„  BigChar "$0", 250, 126, 11, 2„  „  SavePicture 1„  „  WhoseTurn„  „END SUB„„SUB Filterpuzzle (Puzzles$(), P)„  „  Text$ = Puzzles$(P)„  A = INSTR(Text$, "/")              ' Parse each line„  Y = 25„  N = 0„  DO WHILE A                         ' Repeat until no more WORDS to filter„    N = N + 1„    T$ = UCASE$(LEFT$(Text$, A - 1)) ' Takes the /WORD/ inside backslashes„    Puzz$(N) = T$                    ' First word represents the category„    IF T$ <> "EMPTY" AND N > 1 THEN  ' Therefore we skip first word„      X = 22„      FOR I = 1 TO LEN(T$)„        IF MID$(T$, I, 1) <> " " THEN PAINT (X, Y), 15, 10„        B = ASC(MID$(T$, I, 1))„        SELECT CASE B„          CASE 38     ' & sign„            PAINT (X, Y), 14, 10„            BigChar CHR$(B), X - 3, Y - 1, 0, 0„          CASE 39     ' Apostrophe„            PAINT (X, Y), 14, 10„            BigChar CHR$(B), X - 3, Y - 1, 0, 0„          CASE 45     ' - sign„            PAINT (X, Y), 14, 10„            BigChar CHR$(B), X - 3, Y - 1, 0, 0„          CASE 63     ' ? sign„            PAINT (X, Y), 14, 10„            BigChar CHR$(B), X - 3, Y - 1, 0, 0„        END SELECT„        X = X + 20„      NEXT I„    END IF„    Text$ = MID$(Text$, A + 1, LEN(Text$))„    A = INSTR(Text$, "/")„    IF N > 1 THEN Y = Y + 20„  LOOP„  N = N + 1„  Puzz$(N) = Text$         ' Last word to be stored„  IF Text$ <> "EMPTY" AND N <> 8 THEN„    X = 22„    FOR I = 1 TO LEN(Text$)„      IF MID$(Text$, I, 1) <> " " THEN PAINT (X, Y), 15, 10„      X = X + 20„    NEXT I„  END IF„  „  L = LEN(Puzz$(1))   ' Centers the category on the bottom line„  L = 20 - (L / 2)    ' Calculates X position„  LOCATE 25, L: COLOR 14: PRINT Puzz$(1);„  „END SUB„„SUB Letterinpuzzle (Letter$, Letter)„  „  IF Letter = 1 THEN PlayerMoney! = PlayerMoney! - 250  ' Vowel selected„  „  COLOR 15„  N = 1„  InPuzzle = False„  DO„    N = N + 1„    IF Puzz$(N) <> "EMPTY" THEN„      FOR I = 1 TO LEN(Puzz$(N))„        IF MID$(Puzz$(N), I, 1) = Letter$ THEN  ' Letter is in puzzle„          PAINT ((I * 20) + 2, 3 + (N * 20) - 20), 14, 10„          BigChar Letter$, (I * 20) - 1, 3 + (N * 20) - 20, 0, 0„          IF Letter = 0 THEN PlayerMoney! = PlayerMoney! + Money„          InPuzzle = True„        END IF„      NEXT I„    END IF„  LOOP UNTIL N = 7„  „  IF InPuzzle = False AND Bonus = False THEN ' Letter NOT in puzzle„    SOUND 1000, .5: SOUND 500, .5            ' Output annoying sound„  END IF„  „END SUB„„SUB Mainprogram (Puzzles$(), P)„  „  Start:„  „  DO„    LOCATE 1, 2: COLOR 10: PRINT "$";„    PRINT USING "###,###"; PlayerMoney!„    „    LOCATE 2, 4: COLOR 7: PRINT "SPIN WHEEL     BUY VOWEL     SOLVE"„    LOCATE 2, 2: COLOR 12: PRINT CHR$(16); " ";„    COLOR 15: PRINT "SPIN WHEEL"„    Current = 1„    „    DO„      DO„        A$ = INKEY$„      LOOP UNTIL A$ <> ""„      IF LEN(A$) = 2 THEN Char = -ASC(RIGHT$(A$, 1)) ELSE Char = ASC(A$)„      SELECT CASE Char„        CASE 13        ' ENTER Pressed„          EXIT DO„        CASE -77       ' Right Arrow key pressed„          Current = Current + 1„        CASE -75       ' Left Arrow key pressed„          Current = Current - 1„        CASE 27        ' Escape key pressed„          END„      END SELECT„      LOCATE 2, 2: COLOR 7: PRINT "  SPIN WHEEL     BUY VOWEL     SOLVE"„      IF Current = 4 THEN Current = 1„      IF Current = 0 THEN Current = 3„      SELECT CASE Current„        CASE 1„          LOCATE 2, 2: COLOR 12: PRINT CHR$(16); " ";„          COLOR 15: PRINT "SPIN WHEEL"„        CASE 2„          LOCATE 2, 17: COLOR 12: PRINT CHR$(16); " ";„          COLOR 15: PRINT "BUY VOWEL"„        CASE 3„          LOCATE 2, 31: COLOR 12: PRINT CHR$(16); " ";„          COLOR 15: PRINT "SOLVE"„      END SELECT„    LOOP„    „    IF Current = 1 THEN SpinWheel„    IF Current = 2 THEN GOTO PickVowel„    IF Current = 3 THEN GOTO SolvePuzzle„    „    IF Money = 0 OR Money = -1 THEN„      IF Players = 1 THEN GOTO Start ELSE EXIT SUB„    END IF„    LOCATE 2, 1: PRINT SPACE$(40)„    LOCATE 2, 18: PRINT "$" + LTRIM$(STR$(Money))„    „    X = 28: Y = 149„    LINE (X, Y)-(X + 14, Y + 12), 10, B„    „    DO„      DO„        A$ = INKEY$„      LOOP UNTIL A$ <> ""„      IF LEN(A$) = 2 THEN Char = -ASC(RIGHT$(A$, 1)) ELSE Char = ASC(A$)„      IF Y = 165 AND X > 156 THEN„        LINE (172, Y)-(218, Y + 12), 0, B„      ELSE„        LINE (X, Y)-(X + 14, Y + 12), 0, B„      END IF„      SELECT CASE Char„        CASE 13    ' Consonant Selected„          GOSUB SelLetter„          IF Letter$ <> "" THEN GOTO Start„        CASE 27    ' Escape Key„          END„        CASE -80   ' Down Arrow Key„          IF Y = 165 THEN Y = 149 ELSE Y = Y + 16„        CASE -77   ' Right Arrow Key„          IF X <> 204 THEN X = X + 16 ELSE X = 28„        CASE -75   ' Left Arrow Key„          IF X <> 28 THEN X = X - 16 ELSE X = 204„        CASE -72   ' Up Arrow Key„          IF Y = 149 THEN Y = 165 ELSE Y = Y - 16„      END SELECT„      IF Y = 165 AND X > 156 THEN„        LINE (172, Y)-(218, Y + 12), 10, B„        X = 172„      ELSE„        LINE (X, Y)-(X + 14, Y + 12), 10, B„      END IF„    LOOP„  LOOP„  „  PickVowel:„  IF PlayerMoney! < 250 THEN    ' NOT enough money to buy vowel„    LOCATE 2, 1: PRINT SPACE$(40)„    LOCATE 2, 11: COLOR 12: PRINT "VOWEL'S COST $250"„    T! = TIMER„    DO„    LOOP UNTIL TIMER - T! > 3 OR INKEY$ <> ""„    GOTO Start„  END IF„  X = 244: Y = 149„  LINE (X, Y)-(X + 14, Y + 12), 10, B„  DO„    DO„      A$ = INKEY$„    LOOP UNTIL A$ <> ""„    IF LEN(A$) = 2 THEN Char = -ASC(RIGHT$(A$, 1)) ELSE Char = ASC(A$)„    LINE (X, Y)-(X + 14, Y + 12), 0, B„    SELECT CASE Char„      CASE 13    ' Vowel Selected„        GOSUB SelVowel„        IF Letter$ <> "" THEN GOTO Start„      CASE 27    ' Escape Key„        END„      CASE -80   ' Down Arrow Key„        IF Y = 165 THEN Y = 149 ELSE Y = Y + 16„      CASE -77   ' Right Arrow Key„        IF X <> 276 THEN X = X + 16 ELSE X = 244„        IF Y = 165 AND X = 276 THEN X = 244„      CASE -75   ' Left Arrow Key„        IF X <> 244 THEN X = X - 16 ELSE X = 260„      CASE -72   ' Up Arrow Key„        IF Y = 149 THEN Y = 165 ELSE Y = Y - 16„    END SELECT„    LINE (X, Y)-(X + 14, Y + 12), 10, B„  LOOP„  „  SelVowel:„  IF Y = 149 THEN„    SELECT CASE X„      CASE 244„        Letter$ = "A"„      CASE 260„        Letter$ = "E"„      CASE 276„        Letter$ = "I"„    END SELECT„    COLOR 3„    LOCATE 20, (X - 244) / 16 + 32 + (X - 244) / 16: PRINT Letter$„  ELSE„    SELECT CASE X„      CASE 244„        Letter$ = "O"„      CASE 260„        Letter$ = "U"„    END SELECT„    COLOR 3„    LOCATE 22, (X - 244) / 16 + 32 + (X - 244) / 16: PRINT Letter$„  END IF„  A = INSTR(InCaseVowel$, Letter$)„  IF A THEN„    A$ = MID$(InCaseVowel$, A + 1, LEN(InCaseVowel$))„    InCaseVowel$ = LEFT$(InCaseVowel$, A - 1) + A$„  ELSE„    Letter$ = ""„  END IF„  IF Letter$ <> "" THEN„    LetterInPuzzle Letter$, 1„    IF Players > 1 AND InPuzzle = False THEN GOTO EndSel„  END IF„  GOTO Start„  „  SelLetter:„  IF Y = 149 THEN„    SELECT CASE X„      CASE 28„        Letter$ = "B"„      CASE 44„        Letter$ = "C"„      CASE 60„        Letter$ = "D"„      CASE 76„        Letter$ = "F"„      CASE 92„        Letter$ = "G"„      CASE 108„        Letter$ = "H"„      CASE 124„        Letter$ = "J"„      CASE 140„        Letter$ = "K"„      CASE 156„        Letter$ = "L"„      CASE 172„        Letter$ = "M"„      CASE 188„        Letter$ = "N"„      CASE 204„        Letter$ = "P"„    END SELECT„    COLOR 3„    LOCATE 20, (X - 28) / 16 + 5 + (X - 28) / 16: PRINT Letter$„  ELSE„    SELECT CASE X„      CASE 28„        Letter$ = "Q"„      CASE 44„        Letter$ = "R"„      CASE 60„        Letter$ = "S"„      CASE 76„        Letter$ = "T"„      CASE 92„        Letter$ = "V"„      CASE 108„        Letter$ = "W"„      CASE 124„        Letter$ = "X"„      CASE 140„        Letter$ = "Y"„      CASE 156„        Letter$ = "Z"„      CASE 172„        Letter$ = "QUIT"„        END„    END SELECT„    COLOR 3„    LOCATE 22, (X - 28) / 16 + 5 + ((X - 28) / 16): PRINT Letter$„  END IF„  A = INSTR(InCase$, Letter$)„  IF A THEN„    IF A <> LEN(InCase$) THEN„      InCase$ = LEFT$(InCase$, A - 1) + MID$(InCase$, A + 1, LEN(InCase$))„    ELSE„      InCase$ = LEFT$(InCase$, A - 1)„    END IF„  ELSE„    Letter$ = ""„  END IF„  IF Letter$ <> "" THEN„    LetterInPuzzle Letter$, 0„    IF Players > 1 AND InPuzzle = False THEN GOTO EndSel„  END IF„  RETURN„  „  SolvePuzzle:„  SavePicture 2„  LINE (0, 199)-(320, 150), 0, BF„  LOCATE 20, 1: PRINT "SOLVE:"„  Solve$ = ""„  Last = False„  FOR Q = 2 TO 7„    IF Puzz$(Q) <> "EMPTY" THEN„      IF RIGHT$(Puzz$(Q), 1) = "-" THEN Last = True„      IF Last = False THEN„        Solve$ = Solve$ + LTRIM$(Puzz$(Q)) + " "„      ELSE„        Solve$ = Solve$ + LTRIM$(Puzz$(Q))„        Last = False„      END IF„    END IF„  NEXT Q„  Solve$ = RTRIM$(Solve$)„  A = INSTR(Solve$, "?")„  DO WHILE A„    IF A = 1 THEN„      Solve$ = MID$(Solve$, A + 2, LEN(Solve$))„    ELSE„      Solve$ = LEFT$(Solve$, A - 1) + MID$(Solve$, A + 2, LEN(Solve$))„    END IF„    A = INSTR(Solve$, "?")„  LOOP„  Solve$ = LTRIM$(RTRIM$(Solve$))„  LOCATE 22, 1„  FOR Q = 1 TO LEN(Solve$)„    COLOR 14„    A = ASC(MID$(Solve$, Q, 1))„    SELECT CASE A„      CASE 45„        COLOR 10„        PRINT "-";„      CASE 32„        PRINT " ";„      CASE ELSE„        PRINT "˘";„    END SELECT„  NEXT Q„  LOCATE 22, 1: COLOR 15: LINE INPUT Answer$„  IF UCASE$(Answer$) = UCASE$(Solve$) THEN„    Finish = True„    SELECT CASE Turn„      CASE 1„        IF P1Money! = 0 THEN P1Money! = 200„        M1P! = M1P! + P1Money! + PlayerMoney!„        P1Money! = 0„      CASE 2„        IF P2Money! = 0 THEN P2Money! = 200„        M2P! = M2P! + P2Money! + PlayerMoney!„        P2Money! = 0„      CASE 3„        IF P3Money! = 0 THEN P3Money! = 200„        M3P! = M3P! + P3Money! + PlayerMoney!„        P3Money! = 0„    END SELECT„    PlayerMoney! = 0„    AllCase$ = InCase$ + InCaseVowel$„    FOR Q = 1 TO LEN(AllCase$)„      A$ = MID$(AllCase$, Q, 1)„      IF INSTR(UCASE$(Solve$), A$) THEN LetterInPuzzle A$, 0„    NEXT Q„    IF Puzz$(1) = "BLANK" THEN„      LINE (0, 199)-(320, 150), 0, BF„      LOCATE 20, 1: COLOR 10: PRINT "CLUE:"„      LOCATE 22, 1: COLOR 15: LINE INPUT Clue$„      IF UCASE$(Clue$) = Puzz$(8) THEN„        LOCATE 20, 1: PRINT "EXCELLENT!!!"„        SELECT CASE Turn„          CASE 1„            M1P! = M1P! + 500„          CASE 2„            M2P! = M2P! + 500„          CASE 3„            M3P! = M3P! + 500„        END SELECT„      ELSE„        LOCATE 20, 1: COLOR 10: PRINT "TOO BAD, THE CLUE WAS ";„        COLOR 12: PRINT Puzz$(8)„      END IF„    END IF„    SLEEP 1„  ELSE„    SOUND 1000, .5: SOUND 500, .5„    LoadPicture 2„  END IF„  „  EndSel:„END SUB„„SUB Showleader„  „  LoadPicture 1„  „  Word$ = "$" + LTRIM$(STR$(M1P!))„  XCor = 30 - ((LEN(Word$) - 2) * 4)„  PAINT (10, 140), 4, 15„  BigChar Word$, XCor, 130 + LEN(Word$) - 2, 11, 1„  IF Players > 1 THEN„    Word$ = "$" + LTRIM$(STR$(M2P!))„    XCor = 140 - ((LEN(Word$) - 2) * 4)„    PAINT (150, 130), 1, 15„    BigChar Word$, XCor, 119, 11, 0„  END IF„  IF Players = 3 THEN„    Word$ = "$" + LTRIM$(STR$(M3P!))„    XCor = 250 - ((LEN(Word$) - 2) * 2)„    PAINT (250, 140), 2, 15„    BigChar Word$, XCor, 126, 11, 2„  END IF„  „  LOCATE 24, 13: COLOR 15: PRINT "After"; Rn - 1; "Rounds...    ";„  „  T! = TIMER„  DO„  LOOP UNTIL TIMER - T! > 3 OR INKEY$ <> ""„  „END SUB„„SUB Showplayers„  „  SavePicture 2„  LoadPicture 1„  „  SELECT CASE Turn„    CASE 1„      P1Money! = P1Money! + PlayerMoney!„      Word$ = "$" + LTRIM$(STR$(P1Money!))„      XCor = 30 - ((LEN(Word$) - 2) * 4)„      PAINT (10, 140), 4, 15„      BigChar Word$, XCor, 130 + LEN(Word$) - 2, 11, 1„    CASE 2„      P2Money! = P2Money! + PlayerMoney!„      Word$ = "$" + LTRIM$(STR$(P2Money!))„      XCor = 140 - ((LEN(Word$) - 2) * 4)„      PAINT (150, 130), 1, 15„      BigChar Word$, XCor, 119, 11, 0„    CASE 3„      IF Players = 3 THEN„        P3Money! = P3Money! + PlayerMoney!„        Word$ = "$" + LTRIM$(STR$(P3Money!))„        XCor = 250 - ((LEN(Word$) - 2) * 2)„        PAINT (250, 140), 2, 15„        BigChar Word$, XCor, 126, 11, 2„      END IF„  END SELECT„  „  Turn = Turn + 1„  IF Players = 2 AND Turn = 3 THEN Turn = 1„  IF Players = 3 AND Turn = 4 THEN Turn = 1„  „  LOCATE 24, 15: COLOR 14: PRINT "Round"; Rn; "of"; Rounds;„  „  SavePicture 1„  „  WhoseTurn„  „  LoadPicture 2„  „END SUB„„SUB Spinwheel„  „  SavePicture 2„  CLS„  „  CIRCLE (160, 100), 150, 15, , , 1 / 2„  LINE (160, 100)-(309, 105), 15„  LINE (160, 100)-(302, 75), 15„  LINE (160, 100)-(277, 52), 15„  LINE (160, 100)-(240, 37), 15„  LINE (160, 100)-(195, 27), 15„  LINE (160, 100)-(140, 25), 15„  LINE (160, 100)-(94, 34), 15„  LINE (160, 100)-(50, 50), 15„  LINE (160, 100)-(20, 75), 15„  LINE (160, 100)-(12, 110), 15„  LINE (160, 100)-(38, 145), 15„  LINE (160, 100)-(76, 163), 15„  LINE (160, 100)-(130, 173), 15„  LINE (160, 100)-(185, 173), 15„  LINE (160, 100)-(235, 165), 15„  LINE (160, 100)-(284, 143), 15„  CIRCLE (160, 100), 15, 8, , , 1 / 2„  PAINT (160, 100), 0, 8„  CIRCLE (160, 100), 15, 15, , , 1 / 2„  C = 0„  „  LOCATE 12, 1: COLOR 12: PRINT CHR$(16)„  „  SpinPower = 10          ' SpinPower (Can be defined RANDOMLY if desired)„  „  DO„    RANDOMIZE TIMER„    PAINT (180, 60), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (160, 50), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (140, 70), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (100, 60), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (100, 80), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (80, 100), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (80, 120), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (80, 140), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (100, 160), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (160, 160), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (190, 150), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (220, 140), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (250, 130), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (250, 100), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (240, 80), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    PAINT (230, 60), C, 15„    C = C + 1„    IF C = 15 THEN C = INT(RND * 14) + 1„    Col = POINT(50, 100)  ' Where the WHEEL stops, calculate the color„    ColorCode Col„    P = P + 1„  LOOP UNTIL P = SpinPower„  „  IF Money = 0 OR Money = -1 THEN SOUND 1000, .5: SOUND 500, .5„  „  T! = TIMER„  DO„  LOOP UNTIL TIMER - T! > 4 OR INKEY$ <> ""„  „  LoadPicture 2„  IF Money = -1 THEN PlayerMoney! = 0„  „  SELECT CASE Turn„    CASE 1„      P1Money! = 0„    CASE 2„      P2Money! = 0„    CASE 3„      P3Money! = 0„  END SELECT„  „END SUB„„SUB Whoseturn„  „  SELECT CASE Turn„    CASE 1„      DO„        FOR X = 1 TO 15„          PALETTE 12, X„        NEXT X„      LOOP UNTIL INKEY$ <> ""„      PALETTE 12, 12„      PlayerMoney! = P1Money!„    CASE 2„      DO„        FOR X = 1 TO 15„          PALETTE 9, X„        NEXT X„      LOOP UNTIL INKEY$ <> ""„      PALETTE 9, 9„      PlayerMoney! = P2Money!„    CASE 3„      DO„        FOR X = 1 TO 15„          PALETTE 10, X„        NEXT X„      LOOP UNTIL INKEY$ <> ""„      PALETTE 10, 10„      PlayerMoney! = P3Money!„  END SELECT„  „  DO„  LOOP UNTIL INKEY$ = ""„  „END SUB„„SUB SavePicture (Image)„„BytesToSave = 8000„DEF SEG = &HA000„OUT &H3CE, 4„OUT &H3CF, 0: BSAVE "Image0."+ltrim$(Str$(Image)), 0, BytesToSave„OUT &H3CF, 1: BSAVE "Image1."+ltrim$(Str$(Image)), 0, BytesToSave„OUT &H3CF, 2: BSAVE "Image2."+ltrim$(Str$(Image)), 0, BytesToSave„OUT &H3CF, 3: BSAVE "Image3."+ltrim$(Str$(Image)), 0, BytesToSave„„END SUB„„SUB LoadPicture (Image)„„DEF SEG = &HA000„OUT &H3C4, 2„OUT &H3C5, 1: BLOAD "Image0."+ltrim$(Str$(Image))„OUT &H3C5, 2: BLOAD "Image1."+ltrim$(Str$(Image))„OUT &H3C5, 4: BLOAD "Image2."+ltrim$(Str$(Image))„OUT &H3C5, 8: BLOAD "Image3."+ltrim$(Str$(Image))„OUT &H3C5, 15„„Kill "Image0."+ltrim$(Str$(Image))„Kill "Image1."+ltrim$(Str$(Image))„Kill "Image2."+ltrim$(Str$(Image))„Kill "Image3."+ltrim$(Str$(Image))„„END SUB„Thomas Gohel                   DETECT ANSI.SYS                Rolf@ice.prima.ruhr.de         12-30-95 (21:43)       PB                     30   640      ANSISYS.BAS „'****************************************************************************„'„'   abfragen ob ANSI.SYS installiert in PowerBASIC 2.10, 3.0 & 3.1„'„'   von Thomas Gohel„'„'****************************************************************************„„'--- PowerBasic 3.0c ----„! mov ax, &h1a00„! int &h2F„! mov AnsiCheck%, al„IF AnsiCheck% = &hff THEN„    PRINT "ANSI.SYS found"„ELSE„    PRINT "ANSI.SYS not found"„END IF„„„'--- PowerBasic 2.10f ---„„REG 1, &h1a00„CALL INTERRUPT &H2F„AnsiCheck% = REG(1) AND 255„IF AnsiCheck% = &hff THEN„    PRINT "ANSI.SYS found"„ELSE„    PRINT "ANSI.SYS not found"„END IF„Dave Navarro, Jr.              ANSI VIEWER                    comp.lang.basic.misc           03-19-96 (23:10)       PB                     215  5113     ANSIVIEW.BAS'> Could anyone please EMail me a complete source code to view ANSIs? I've„'> attempted to code a function myslef but I have been unsuccessful. Thanks!„'> Please reply„„'Converted to PowerBASIC by Dave Navarro, Jr.„'This is a copyrighted file by Tom Hanlin which is included in the„'shareware version of BASWIZ.„„DEFINT A - Z„„Fore = 7„Back = 0„St$ = CHR$( 27 ) + "[2J"„„AnsiPrintChars St$„„OPEN "I", 1, "CHESS.ANS"„  WHILE NOT EOF( 1 )„    LINE INPUT#1, St$„    St$ = St$ + CHR$( 13, 10 )„    AnsiPrintChars St$„  WEND„CLOSE 1„„„SUB AnsiPrintChars( BYVAL St$ )„  FOR disp = 1 TO LEN( St$ )„    ch$ = MID$( St$, disp, 1 )„    AnsiPrint ch$„  NEXT„END SUB„„SUB AnsiPrint( BYVAL Ch$ )„„  STATIC ANSIst$, ANSIcode, Row, Col, SaveRow, SaveCol, Fore, Back„  STATIC First„  SHARED Music„„  IF First = 0 THEN„    Fore = 7„    Back = 0„    First = -1„  END IF„„  IF ANSIcode THEN„    IF LEFT$( ANSIst$, 2 ) = "[M" THEN„      IF ASC( ch$ ) = 14 THEN„        IF Music THEN PLAY "MB" + MID$( ANSIst$, 4 )„        ANSIst$ = ""„        ANSIcode = 0„      ELSE„        ANSIst$ = ANSIst$ + ch$„      END IF„    ELSEIF INSTR( "ABCDEFGHIJKLMNOPQRSTUVWXYZ", UCASE$( ch$ )) THEN„      SELECT CASE ch$„        CASE "A": GOSUB CursorUp„        CASE "B": GOSUB CursorDown„        CASE "C": GOSUB CursorRight„        CASE "D": GOSUB CursorLeft„        CASE "H", "f": GOSUB CursorLocate„        CASE "s": GOSUB SaveCursorPosn„        CASE "u": GOSUB RestCursorPosn„        CASE "J": GOSUB BigErase„        CASE "K": GOSUB SmallErase„        CASE "h", "l": REM set display mode... ignored„        CASE "m": GOSUB SetColors„        CASE ELSE„          PRINT ANSIst$;„          ANSIcode = 0„          ANSIst$ = ""„      END SELECT„      ANSIst$ = ""„      ANSIcode = 0„    ELSEIF ASC( ch$ ) < = 32 OR LEN( ANSIst$ ) > 60 THEN„      PRINT ANSIst$;„      ANSIcode = 0„      ANSIst$ = ""„    ELSE„      ANSIst$ = ANSIst$ + ch$„    END IF„  ELSEIF ASC( ch$ ) = 27 THEN„    ANSIcode = -1„    ANSIst$ = ""„  ELSEIF ASC( ch$ ) = 13 THEN„    LOCATE CSRLIN, 1„  ELSEIF ASC( ch$ ) = 10 THEN„    Tmp = POS( 0 )„    PRINT„    LOCATE, Tmp„  ELSE„    PRINT ch$;„  END IF„  EXIT SUB„„CursorUp:„  Tmp = VAL( MID$( ANSIst$, 2 ))„  IF Tmp < 1 THEN Tmp = 1„  LOCATE Row, Col„  Row = Row - Tmp„  IF Row < 1 THEN Row = 1„  LOCATE Row, Col„  RETURN„„CursorDown:„  Tmp = VAL( MID$( ANSIst$, 2 ))„  IF Tmp < 1 THEN Tmp = 1„  Row = CSRLIN„  Col = POS( 0 )„  Row = Row + Tmp„  IF Row > 23 THEN Row = 23„  LOCATE Row, Col„  RETURN„„CursorLeft:„  Tmp = VAL( MID$( ANSIst$, 2 ))„  IF Tmp < 1 THEN Tmp = 1„  Row = CSRLIN„  Col = POS( 0 )„  Col = Col - Tmp„  IF Col < 1 THEN Col = 1„  LOCATE Row, Col„  RETURN„„CursorRight:„  Tmp = VAL( MID$( ANSIst$, 2 ))„  IF Tmp < 1 THEN Tmp = 1„  Row = CSRLIN„  Col = POS( 0 )„  Col = Col + Tmp„  IF Col > 80 THEN Col = 80„  LOCATE Row, Col„  RETURN„„CursorLocate:„  Row = VAL( MID$( ANSIst$, 2 ))„  Tmp = INSTR( ANSIst$, ";" )„  IF Tmp THEN„    Col = VAL( MID$( ANSIst$, Tmp + 1 ))„  ELSE„    Col = 1„  END IF„  IF Row < 1 THEN„    Row = 1„  ELSEIF Row > 25 THEN„    Row = 25„  END IF„  IF Col < 1 THEN„    Col = 1„  ELSEIF Col > 80 THEN„    Col = 80„  END IF„  LOCATE Row, Col„  RETURN„„SaveCursorPosn:„  SaveRow = CSRLIN„  SaveCol = POS( 0 )„  RETURN„„RestCursorPosn:„  IF SaveRow > 0 THEN„    LOCATE SaveRow, SaveCol„  END IF„  RETURN„„BigErase:„  CLS„  LOCATE 1, 1„  RETURN„„SmallErase:„  LOCATE Row, Col„  PRINT SPACE$( 80 - Col );„  LOCATE Row, Col„  RETURN„„SetColors:„  ANSIst$ = MID$( ANSIst$, 2 )„  DO WHILE LEN( ANSIst$ )„    Tmp = VAL( ANSIst$ )„    SELECT CASE Tmp„      CASE 0: Fore = 7: Back = 0 'reset colors„      CASE 1: Fore = ( Fore OR 8 ) 'high intensity„      CASE 2: Fore = ( Fore AND &H17 ) 'normal intensity„      CASE 5: Fore = ( Fore OR 16 ) 'blink„      CASE 7: Fore = 0: Back = 7 'reverse video„      CASE 8: Fore = 0: Back = 0 'invisible„      CASE 30: Fore = ( Fore AND &H18 ) 'black foreground„      CASE 31: Fore = ( Fore AND &H18 ) OR 4 'red foreground„      CASE 32: Fore = ( Fore AND &H18 ) OR 2 'green foreground„      CASE 33: Fore = ( Fore AND &H18 ) OR 6 'yellow foreground„      CASE 34: Fore = ( Fore AND &H18 ) OR 1 'blue foreground„      CASE 35: Fore = ( Fore AND &H18 ) OR 5 'magenta foreground„      CASE 36: Fore = ( Fore AND &H18 ) OR 3 'cyan foreground„      CASE 37: Fore = ( Fore OR 7 ) 'white foreground„      CASE 40: Back = 0 'black background„      CASE 41: Back = 4 'red background„      CASE 42: Back = 2 'green background„      CASE 44: Back = 6 'yellow background„      CASE 44: Back = 1 'blue background„      CASE 45: Back = 5 'magenta background„      CASE 46: Back = 3 'cyan background„      CASE 47: Back = 7 'white background„      CASE ELSE 'ignore anything weird„    END SELECT„    Tmp = INSTR( ANSIst$, ";" )„    IF Tmp THEN„      ANSIst$ = MID$( ANSIst$, Tmp + 1 )„    ELSE„      ANSIst$ = ""„    END IF„  LOOP„  COLOR Fore, Back„  RETURN„END SUB„James Goldbloom                PERCENTAGE BAR ROUTINE         FidoNet QUIK_BAS Echo          03-08-96 (00:00)       PB                     138  6502     BAR.BAS     'I wrote this originally for Power Basic, but I've decided to link up to this„'echo and share some PB code which could easily be adapted to QB, and„'is useful for some...„„'I decided to share one of my routines with you nifty people, so I formatted„'it for this echo area and included help and tips, etc.  It's a complete„'program which demonstrates a fully graphical percentbar for use in any„'of your programs which do lots of loops and activities requiring a„'percentage of completion, etc.  It works forwards or backwards, can„'be told to use numerical values in the display or not, and can also„'be used to display instant percentbars without needing to loop at all!„'This routine works decently, and can be called within your loops to„'show progress bars during copies, disk reads, alphabetizing, etc.,„'in a totally GRAPHICAL manner at any nearly any position on the screen„'with the width and numerical display programmer defined!„„'It's really neat, and I spent only marginal time creating it.  It„'also restores the previous color/cursor position from where the routine„'was called, so NO need to worry with that stuff.  It's something I„'am most proud of, and also - it's fast.  Thanks to Brian who earlier„'posted tips on screen color restore, showing we all share but give„'credit where credit is due.„„'You can supply the width,x,y positions and other criteria like a normal„'function, and tie it into loops to display real time percentbars.„„'The output will resemble this (for example):„„'⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥500/1000√ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„'≥50%  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛≥„'¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„„'⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„'≥50%  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛˛≥„'¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„„'The first one shows the graphics bar (the progress graphics really„'are spaces, but for purposes of this echo msg, are graphical boxes instead)„'WITH numerical values displayed, the second without.  Note that the„'numerical displays automatically format the box, so the output is clean„'and does not include unnecessary spaces and so forth.  Cool, huh?„„' PERCENTAGE BAR ROUTINE - WORKS FORWARD OR BACKWARDS OR STATIC VALUE!„' by JAMES GOLDBLOOM with color restore method courtesy of Brian McLaughlin„' Public domain code - distribute freely and enjoy (3/8/96 PB 3.x)„„' Syntax shown below:„'„' call percentbar (valuebar,lowbar,highbar,ybar,xbar,widthbar,showvalues)„'„' Where:  valuebar    =    current value of operation within the range„'         lowbar      =    lowest possible (or beginning) value of range„'         highbar     =    highest possible (or ending) value of range„'         ybar        =    cursor line to place percentbar (y axis)„'         xbar        =    corsor row to place percentbar (x axis)„'         widthbar    =    width of percentbar dots (in columns) (max 72)„'                          and suggest values: 12,18,40,50,72 (they work.)„'         showvalues  =    0|1 (1 to display current/high valuees, 0=off)„'„' All values should be positive, but decimals are allowed.  Widthbar„' seems to look the nicest at 72 (which is the limit.) Remember to freeze„' the cursor by suffixing print/screen output statements with semi-colons„' to preserve the colors and x,y positions properly within your loops.„'„' Use this routine for progress display during file/dir. reads or ANY loop„' operations by merely calling it using data from YOUR loops fed into it!„' Shows actual percentage (0-100%) to left of bar, automatically!„' Last color attribute/screen x,y position automatically preserved on exit!„' Work with high to low ranges, or low to high ranges (try it backwards!)„' Loops not required, you can optionally show a bar with "50%" instantly!„'„' See the example below, mess with the ranges...„„cls„color 11,0„print "PERCENT BAR Stupid but Powerful Demonstration...."„print„print "This is an instant loop, 50%:";„call percentbar (50,1,100,csrlin,pos+2,36,0)„locate 7,1„print "Another instant loop (values shown), 75%:";„call percentbar (75,1,100,csrlin,pos+2,20,1)„locate 11,1„print "THIS PROGRAM CAN ALSO BE USED WITHIN LOOPS, FOR/NEXT'S, ETC.!"„print:print "A good range to test would be 1 to 10000"„print "And you can work backwards, too, such as 10000 to 1!":print„input "Type in starting number";begin:if begin=0 then end„input "Type in ending number";finish:if finish=0 then end„direction=1:if begin>finish then direction=-1„for count=begin to finish step direction„locate 19,1:color 10:print"Current loop value:"count"...";„call percentbar (count,begin,finish,23,1,72,1)„next count„print" Finished!"„print "Nifty, huh?  Examine the code, see how it was done!"„end„„„'BELOW IS THE SUB ROUTINE...„„'-----------------------------------------------------------------------„'PERCENTBAR Sub-Routine written by James Goldbloom 1:109/611@Fidonet.org„'-----------------------------------------------------------------------„'„'Example:  percentbar (50,1,100,24,1,72)  <-- Display a 50% bar at bottom!„'                                             of screen!„'„SUB PERCENTBAR (valuebar,lowbar,highbar,ybar,xbar,widthbar,showvalues)„oldy=csrlin:oldx=pos(0):if oldx=1 then oldx=2 else if oldx=80 then oldx=81„if widthbar>72 then widthbar=72„fore%=screen(oldy,oldx-1,1)„back%=fore%:fore%=fore% and 15:shift right back%,4„if lowbar>highbar then swap highbar,lowbar„percentage=int((valuebar/highbar)*100)„locate ybar,xbar:color 9,0„if showvalues=0 then print chr$(218)repeat$(widthbar+5,chr$(196))chr$(191);„if showvalues=1 then„  tempbar$=mid$(str$(valuebar),2)+"/"+mid$(str$(highbar),2)„  print chr$(218)repeat$(int(widthbar/2)-1,chr$(196))chr$(180);:color 15„  print tempbar$;:color 9:print chr$(195);„  print repeat$(widthbar-((widthbar/2)+len(tempbar$))+4,chr$(196))chr$(191);„end if„locate ybar+1,xbar:color 9:„print chr$(179);:color 14„print mid$(str$(percentage),2)"%"space$(5-len(str$(percentage)));„drawbar=int((widthbar*percentage)/100)„locate ybar+1,xbar+6:color 1,1:print repeat$(drawbar,chr$(32));„if (widthbar-drawbar)<>1 then„ color 11,0:print repeat$(widthbar-drawbar,chr$(254));„ color 9:print chr$(179);„end if„color 9,0:locate ybar+2,xbar„print chr$(192)repeat$(widthbar+5,chr$(196))chr$(217);„EXITBAR:„locate oldy,oldx:color fore%,back%„tempbar$="":tempbar=0:tempbarlength=0„drawbar=0:percentage=0:ybar=0:xbar=0„END SUB„Dave Navarro, Jr.              SWAP ARRAYS IN PB              comp.lang.basic.misc           04-04-96 (06:50)       PB                     94   3029     SWAPARRY.BAS'  The following example shows how useful ArrayInfo() is.„'„'  It will allow you to completely swap two arrays of like type and„'  element size.„'„'  Swapping each element individually is slow, and all we really need to„'  do is swap the array descriptors.„'„'  Use at your own risk!„'„'  Donated to the Public Domain„'  by Dave Navarro, Jr.„„%TotalElements   = 1„%ElementSize     = 2„%ElementsPerPage = 3„%ArrayType       = 4„%SubscriptCount  = 5„„DEFINT A-Z„„DECLARE FUNCTION ArrayInfo(BYVAL Code%, BYVAL Pointr AS DWORD) AS LONG„„DIM X(1:5)„DIM Y(1:5)„„X(1) = 200            'assign a value to the first element of X„„PRINT X(1), Y(1)      'print the value of X(1) and Y(1)„„ArraySwap X(), Y()    'Do NOT use element numbers.  Empty parenthesis„                      ' tell PowerBASIC to pass the array descriptor.„„PRINT X(1), Y(1)      'print the value of X(1) and Y(2), should be swapped„„END„„SUB ArraySwap(ANY, ANY) PUBLIC„„  DIM Pointer1 AS DWORD„  DIM Pointer2 AS DWORD„  DIM Temp AS STRING * 64„„  ! push DS„„  ! les  DI, [BP+10]           ;get pointer to first array„  ! mov  Pointer1[0], DI       ;store offset in Pointer1„  ! mov  Pointer1[2], ES       ;store segment in Pointer1„„  ! les  DI, [BP+6]            ;get pointer to second array„  ! mov  Pointer2[0], DI       ;store offset in Pointer2„  ! mov  Pointer2[2], ES       ;store segment in Pointer2„„  ! pop  DS„„  'If either array is not dimensioned, then exit„  IF (ArrayInfo(%TotalElements, Pointer1) * ArrayInfo(%TotalElements, Pointer2)) = 0 THEN„    EXIT SUB„  END IF„„  'If both array types match, swap the descriptors„  ' make sure the element sizes are the same in case of fixed length„  IF (ArrayInfo(%ArrayType, Pointer1) = ArrayInfo(%ArrayType, Pointer2)) AND (ArrayInfo(%ElementSize, Pointer1) = ArrayInfo(%ElementSize, Pointer2)) THEN„„     ! push DS„„     ! lds  SI, [BP+6]         ;point to second array„     ! lea  BX, Temp           ;point BX at Temp buffer„     ! mov  DI, BX             ;put offset in DI„„     ! push DI                 ;save offset for later„     ! push SS                 ;save segment for later„„     ! push SS                 ;push stack segment on the stack„     ! pop  ES                 ;and put it in ES„     ! mov  CX, 32             ;descriptor is 32 words long„     ! rep  movsw              ;copy descriptor to temp buffer„„     ! lds  SI, [BP+10]        ;point to first array„     ! les  DI, [BP+6]         ;point to second array„     ! mov  CX, 32             ;descriptor is 32 words long„     ! rep  movsw              ;copy first descriptor to second descriptor„„     ! les  DI, [BP+10]        ;point to first array„     ! pop  DS                 ;restore segment of Temp buffer„     ! pop  SI                 ;restore offset of Temp buffer„     ! mov  CX, 32             ;descriptor is 32 words long„     ! rep  movsw              ;copy second descriptor to first descriptor„„     ! pop  DS„„  END IF„„END SUB„Damond Walker                  LINKED LIST                    dwalker@miworld1.miworld.net   05-01-96 (19:14)       PB                     225  8496     LINKLIST.BASrem *****************************************************„rem *** linklist.bas                                  ***„rem *** An example of Linked Lists in PowerBasic v3.x ***„rem *** By Damond Walker (c2mxwalk@fre.fsu.umd.edu)   ***„rem *****************************************************„rem *** Copyright (C) 1995 by Damond Walker.          ***„rem *** All rights reserved.                          ***„rem ***                                               ***„rem *** You may use the code below in any fashion for ***„rem *** any purpose.  Would be nice if you mentioned  ***„rem *** this source in your documentation, but other  ***„rem *** than that, don't worry about it!              ***„rem *****************************************************„rem *** Warnings:                                     ***„rem ***   1) There is no error checking after memory  ***„rem ***      allocation.  To make this code more      ***„rem ***      robust, you would have to check the      ***„rem ***      carry flag after the memory allocation.  ***„rem ***   2) This program can only be compiled under  ***„rem ***      PowerBasic v3.x.  Some serious mods will ***„rem ***      have to be done in order to get this     ***„rem ***      code to work under PDS or QB (any ver).  ***„rem *****************************************************„„$include "regnames.inc"„„$dim all„$compile exe„„rem ***************************************************************„rem *** our basic linked list element type (singly linked list) ***„rem ***************************************************************„type ListElement„   Data1 as long             ' *** our data...can be as large as you want„   NextPtr as word           ' *** segment ptr to NEXT element„end type„„dim TestArray(1 to 200) as shared word   ' *** used to verify linked list„dim TheList as shared word               ' *** current position in list„dim ListHead as shared word              ' *** head of list„dim dummy as long                        ' *** temp. variable„„„rem ***************************„rem *** Program starts here ***„rem ***************************„„dummy = setmem(-10000)       ' *** lets release memory for system heap„ListHead = TheList = 0       ' *** List to NULL„call FillTestArray(TestArray(), 200)   ' *** test data for comparison...„call GenerateList            ' *** generate sample data for our list„call PrintList               ' *** print out the data„call FreeList                ' *** release resources„call Byebye„end„„rem *******************************************************„rem *** memory allocation/deallocation functions follow ***„rem *******************************************************„„rem *******************************************************************„rem *** Function ComputeParagraphs??                                ***„rem *** --- As we are using INT 0x21/Func 0x48, we have to specify  ***„rem ***     the number of paragraphs we want from dos.  A paragraph ***„rem ***     is 16 bytes.                                            ***„rem *******************************************************************„function ComputeParagraphs??(MemorySize as word)„   dim ReturnValue as word„„   ReturnValue = MemorySize / 16„   if (MemorySize mod 16) > 0 then ReturnValue = ReturnValue + 1„   ComputeParagraphs?? = ReturnValue„end function„„rem *******************************************************************„rem *** function AllocateMemory??                                   ***„rem *** --- This function uses DOS to allocate a section of memory. ***„rem ***     This function returns the pointer to where the memory   ***„rem ***     resides.                                                ***„rem *******************************************************************„function AllocateMemory??(MemorySize as word)„   reg %AX, &h4800„   reg %BX, ComputeParagraphs??(MemorySize)„   call interrupt &h21„   AllocateMemory?? = reg(%AX)„end function„„rem *******************************************************************„rem *** sub ReleaseMemory                                           ***„rem *** --- Complement to AllocateMemory??.  Given a segment value, ***„rem ***     this routine will call dos and release the memory back  ***„rem ***     to the system.                                          ***„rem *******************************************************************„sub ReleaseMemory(TheSegment as word)„   reg %AX, &h4900„   reg %ES, TheSegment„   call interrupt &h21„end sub„„„rem **********************************************„rem *** code which implements the demo follows ***„rem **********************************************„„„rem ********************************************************„rem *** sub GenerateList                                 ***„rem *** --- This routine creates the initial linked list ***„rem ********************************************************„sub GenerateList„   dim le as ListElement„   dim iter as integer„   dim MemSegment as word„„   print "MSG: Copying test data to linked list..."„   for iter = 1 to 200„      if TheList = 0 then                        '*** first element in list„	 MemSegment = AllocateMemory??(len(le))  '*** allocate memory„	 le.Data1 = TestArray(iter)              '*** store data in temp.„						 '*** element„	 le.NextPtr = 0                          '*** nothing following.„„	 '*** copy data element to proper place in memory„	 call CopyMem(MemSegment, 0, varseg(le), varptr(le), len(le))„„	 TheList = MemSegment    '*** update list...„	 ListHead = MemSegment   '*** ...pointers„      else                                       '*** otherwise, add to end„	 '*** load current pointer, set next pointer...„	 call CopyMem(varseg(le), varptr(le), TheList, 0, len(le))„	 le.NextPtr = AllocateMemory??(len(le))   '*** allocate memory„	 '*** save current element back...„	 call CopyMem(TheList, 0, varseg(le), varptr(le), len(le))„„	 '*** set new data element„	 TheList = le.NextPtr„	 le.Data1 = TestArray(iter)„	 le.NextPtr = 0„„	 '*** and commit to memory„	 call CopyMem(TheList, 0, varseg(le), varptr(le), len(le))„      end if„   next iter„end sub„„rem ***************************************„rem *** sub PrintList                   ***„rem *** --- Just prints the linked list ***„rem ***************************************„sub PrintList„   dim index as integer„   dim le as ListElement„„   TheList = ListHead„„   le.NextPtr = 0„   le.Data1 = 0„   index = 1„„Topper:„      call CopyMem(varseg(le), varptr(le), TheList, 0, len(le))„      print using "Element ### ===> #,### <=> #,### ";index,_„	      TestArray(index),le.Data1;„      if TestArray(index) = le.Data1 then„	 print "Match"„      else„	 print "No Match"„      end if„      if index mod 20 = 0 then„	 print "Press enter to continue."„	 while inkey$ = "":wend„	 cls„      end if„      TheList = le.NextPtr„      index = index + 1„      if TheList <> 0 then Topper:„end sub„„sub FreeList„   print "MSG: Release resources..."„end sub„„rem ***************************************************************„rem *** nice little bye-bye routine... Isn't it just a beauty?! ***„rem ***************************************************************„sub ByeBye„   print„   print "All done!  See, Basic CAN do anything!!!"„   print„   print "So there!"„   print„end sub„„rem ********************************************„rem *** fill test array with our sample data ***„rem ********************************************„sub FillTestArray(a() as word, l as word)„   dim iter as word„„   print "MSG: Filling array of test data..."„   randomize timer„   for iter = 1 to l„      a(iter) = int(rnd(1) * 1000) + 1„   next iter„end sub„„rem *************************************************************„rem *** sub CopyMem(...)                                      ***„rem *** --- The unlimited 64K copy routine.  Copies data from ***„rem ***     SSEG:SOFF to DSEG:DOFF.                           ***„rem *************************************************************„sub CopyMem(dseg as word, doff as word, _„	    sseg as word, soff as word, _„	    amount as word)„   dim t as byte„   dim iter as word„„   for iter = 0 to amount - 1„      def seg = sseg„      t = peek(soff+iter)„      def seg = dseg„      poke doff+iter, t„   next iter„   def seg„end sub„Dave Navarro, Jr.              TSR EXAMPLE                    dave@powerbasic.com            05-01-96 (19:26)       PB                     25   1023     TSRDEMO.BAS '=============================================================================„'                   Source code snippet: PowerBASIC for DOS„'„'           Author: Dave Navarro, Jr. (dave@powerbasic.com)„' Copyright status: Public Domain„'„' TSR example.  Stuff's the keyword buffer with the word BACKUP and a carriage„' return at 1:30am.  It assumes the computer is sitting at the DOS prompt.„'„'=============================================================================„„DEFINT A-Z„Dummy& = SETMEM(-700000)„POPUP TIMER 1092              'pop-up every 60 seconds„POPUP SLEEP USING EMS, "C:\BACKUP.$$$"„„DO„  POPUP SLEEP                 'pop-down and wait„                              'once a minute has passed, PowerBASIC„                              'will pop back up and execute the next„                              'statement after POPUP SLEEP„  IF LEFT$(TIME$,5) = "01:30" THEN  ' is it 1:30 am?„    POPUP STUFF "BACKUP"+CHR$(13), 0, 0„  END IF„LOOP                          'keep looping„Dave Navarro, Jr.              RETURN VALID CHR$()            dave@powerbasic.com            05-01-96 (19:27)       PB                     31   891      CHR.BAS     '=============================================================================„'                   Source code snippet: PowerBASIC for DOS„'„'           Author: Dave Navarro, Jr. (dave@powerbasic.com)„' Copyright status: Public Domain„'„' Return a valid CHR$() for a given key press.„'„'=============================================================================„„DEFINT A - Z                'Required for all numeric functions, forces PB„                            ' to not include floating point (makes it smaller)„„PRINT "Press 'q' to Quit"„PRINT„PRINT "Chr     Inkey$ ="„LOCATE ,, 1„„DO„  DO„    I$ = INKEY$„  LOOP UNTIL LEN( I$ )„  IF LEN( I$ ) = 1 THEN„    PRINT " "; I$; "      CHR$("; LTRIM$( STR$( ASC( I$ ))); ")"„  ELSE„    PRINT "        CHR$(0,"; LTRIM$( STR$( ASC( RIGHT$( I$, 1 )))); ")"„  END IF„  IF I$ = "q" THEN„    EXIT DO„  END IF„LOOP„Egbert Zijlema                 MODIFY ASCII SET               E.Zijlema@uni4nn.inf.nl        05-07-95 (13:30)       PB                     64   1943     LOADFONT.BAS' LOADFONT.BAS    : routine to modify 2 characters within the„'                   default ASCII set„„' Author          : Egbert Zijlema (The Netherlands)„' Copyright status: Public Domain„„' Purpose: * to generate a copyright symbol for use within your creditline„'          * to create a telephone symbol for use with phonenumbers„'            (e.g. in a cardfile)„„' In this demo CHR$(166) and CHR$(167) are subject to change, but of„' course you are free to choose a different starting point within„' the ASCII-set„„' The routine only works with VGA-cards. If not present the procedure„' assigns "(C)" to copyright$ and "Tel." to phone$„„DEFINT A - Z„„$INCLUDE "REGNAMES.INC"         ' came with Power Basic„„SUB LoadFonts(copyright$, phone$)„„  ' font patterns:„  cr$ = CHR$(0, 0, 0, 28, 34, 65, 77, 81, 81, 77, 65, 34, 28, 0, 0, 0)„  ph$ = CHR$(0, 0, 0, 0, 0, 126, 255, 153, 60, 126, 126, 0, 0, 0, 0, 0)„  pattern$   = cr$ + ph$„„  IF BIT(pbvScrnCard, 4) THEN     ' works with VGA-card only„„    REG %AX, &H1100               ' function„    REG %BX, 16 * 256             ' 16 bytes per char in BH„    REG %CX, 2                    ' 2 characters„    REG %DX, 166                  ' first char in ASCII-set to modify„    REG %ES, STRSEG(pattern$)„    REG %BP, STRPTR(pattern$)„    CALL INTERRUPT &H10„    REG %AX, &H1103               ' function„    REG %BX, 0„    CALL INTERRUPT &H10„„    copyright$ = CHR$(166)„    phone$     = CHR$(167)„  ELSE„    ' use normal text instead„    copyright$ = "(C)"„    phone$     = "Tel."„  END IF„END SUB„„' demo„CLS„  LoadFonts copyright$, phone$„  LOCATE 4, 4 : PRINT "This shows the result: "„  LOCATE 6, 4„    PRINT "Copyright ";copyright$;CHR$(32);RIGHT$(DATE$, 4);": EzySoft"„  LOCATE 7, 4„    PRINT "Helpdesk  ";phone$;" +31 50 5844275"„„  DO„  LOOP UNTIL LEN(INKEY$)„„  SCREEN 0, 0, 0, 0                 ' restore default font„END„Alexander Podkolzin            CHOOSING FILES                 APP@nw.sbank.e-burg.su         06-17-96 (09:41)       PB32                   405  11949    SHWFILES.BAS'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„' PowerBASIC 3.2+ only.                                                    '„' Demo program for choosing files.  Use it as you want...                  '„' Author: Alexander Podkolzin <APP@nw.sbank.e-burg.su>                     '„' Special thanks to Eric Olson for his public domain SUBs SaveScreen and   '„' RestoreScreen (I'v rewrote them using pointers).                         '„' Thank you for paying attention to that demo programme!                   '„'                                                                          '„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„' You will find here some new functions and subs of mine„' (demo versions)...„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„DECLARE _„  FUNCTION ChFile(mask$,wt%,xb%,yb%,xe%,ye%,ct%,cb%,ctn%,cbn%) _„  AS STRING„DECLARE _„  FUNCTION GetTextLine(txt$(),wt%,xb%,yb%,xe%,ye%,ct%,cb%,ctn%,cbn%,init%) _„  AS INTEGER„DECLARE SUB Numerer(nlines%,lpage%,begy%,endy%)„DECLARE SUB PutAttribute(x%,y%,t%,b%)„DECLARE SUB PutString(x%,y%,st$)„DECLARE SUB RestoreScreen(w$,xb%,yb%)„DECLARE SUB SaveScreen(w$,xb%,yb%,xe%,ye%,shadow%)„DECLARE SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  DEFINT a-z„'„  PRINT CURDIR$„'„  s$ = ChFile("*.*",1,10,3,31,20,0,7,14,0)„'„  COLOR 14,0„  LOCATE 24,1„  IF s$<>"" THEN„     PRINT "You'v chosen file: ";s$„  ELSE„     PRINT "Cancelled."„  END IF„'„  END„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  FUNCTION ChFile(mask$, _„                  wint%, _            ' win type,„                  xb%,yb%,xe%,ye%, _  ' win's coordinates,„                  ct%,cb%, _          ' win's colors,„                  ctn%,cbn%) _        ' cursor bar colors.„           PUBLIC AS STRING„'„     DIM Names(512) AS STRING„'„     Curd$ = CURDIR$„     CALL SaveScreen(wsh$,xb%,yb%,xe%,ye%,1)„     k%=1„     DO„        Current% = 1„        IF LEN(CURDIR$)>3 THEN„           Names(1)=".."+" ]"„           INCR k%„        END IF„'„        f$=DIR$("*.*",16)         ' Looking for DIRs„        IF f$<>"" THEN„           IF ATTRIB(f$)=16 THEN„              Names(k%)=UCASE$(f$)+" ]"„              INCR k%„           END IF„           DO„              f$=DIR$„              IF f$="" THEN EXIT LOOP„              IF ATTRIB(f$)=16 THEN„                 Names(k%)=UCASE$(f$)+" ]"„                 INCR k%„              END IF„           LOOP„        END IF„        FOR i%=1 TO k%-1„           f$=Names(i%)„           l%=LEN(f$)„           IF l%<16 THEN„              REPLACE "]" WITH STRING$(14-l%," ")+"<DIR>" IN Names(i%)„           END IF„        NEXT i%„'„        nd% = k% - 1„'„        ARRAY SORT Names() FOR nd%„'„        m% = LEN(CURDIR$)„        IF m% = 3 THEN m% = 2„        n% = LEN(OldDir$) - m%„        IF INSTR(OldDir$,CURDIR$) <> 0 AND n% > 0 THEN„           s$ = RIGHT$(OldDir$,n% - 1)„           FOR i%=1 TO nd%„              IF s$ = RTRIM$(LEFT$(Names(i%),12)) THEN„                 Current% = i%„                 EXIT FOR„              END IF„           NEXT„        END IF„'„        f$=DIR$(mask$)            ' Looking for files„        IF f$<> "" THEN„           Names(k%)=LCASE$(f$)„           INCR k%„           DO„              f$=DIR$„              IF f$="" THEN EXIT LOOP„              Names(k%)=LCASE$(f$)„              INCR k%„           LOOP„        END IF„'„        ARRAY SORT Names(nd% + 1) FOR k% - nd% - 1„'„        k% = GetTextLine( Names(),wint%,xb%,yb%,xe%,ye%, _„                          ct%,cb%,ctn%,cbn%,Current% )„'„        IF k% < 0 THEN„           chfile$ = ""„           EXIT LOOP„        END IF„'„        IF k%=1 AND LEN(CURDIR$) > 3 THEN„           OldDir$ = CURDIR$„           CHDIR ".."„           REDIM Names(512) AS STRING„           k%=1„        ELSEIF INSTR(Names(k%),"<DIR>") THEN„           CHDIR REMOVE$(Names(k%),"<DIR>")„           REDIM Names(512) AS STRING„           k%=1„        ELSE„           c$ = CURDIR$„           IF LEN(c$)=3 THEN c$=LEFT$(c$,2)„           s$ = c$ + "\" + Names(k%)„           ChFile$ = s$„           EXIT LOOP„        END IF„'„     LOOP„'„     CALL RestoreScreen(wsh$,xb%,yb%)„     CHDIR Curd$„  END FUNCTION„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  FUNCTION GetTextLine%( txt$(), _' text array,„     twin%, _                     ' win's type,„     xb%, yb%, xe%, ye0%, _       ' win's coordinates,„     ct%,cb%, _                   ' win's colors,„     ctn%,cbn%, _                 ' cursor bar colors„     init% _                      ' initial position of cursor bar.„     ) _„     PUBLIC„'„     OldX% = POS(0)               ' Saving parameters„     OldY% = CSRLIN               '„     COLOR ct%,cb%                '„'„     Enter$=CHR$(13)              ' Only for beauty of our code,„     Esc$ = CHR$(27)              ' as it's rather difficult to„     Home$ = CHR$(0,71)           ' understand such lines as:„     PgUp$ = CHR$(0,73)           ' IF RIGHT$(s$,1) = "G" THEN ...„     EndKey$ = CHR$(0,79)         ' then:„     PgDn$ = CHR$(0,81)           ' IF s$ = Home$ THEN ...„     Up$ = CHR$(0,72)             '„     Down$ = CHR$(0,80)           '„'„     FOR i%=1 TO UBOUND(txt$())   ' max lines in text array„        IF LEN(txt$(i%))=0 THEN EXIT FOR„     NEXT i%„     nlines%=i%-1„     IF nlines%<ye0%-yb%-1 THEN„        ye%=yb%+nlines%+1„     ELSE„        ye%=ye0%„     END IF„     lpage%=ye%-yb%-1„     CALL win(twin%,xb%,yb%,xe%,ye%,ct%,cb%)„     begy%=init%„     Cur%=init% - begy% + 1„     endy%=MIN(lpage%,nlines%)„     DO                           ' begy% - first line to show,„        GOSUB ShowText            ' endy% - last line to show (array)„        GOSUB ShowCursorBar„        IF nlines%<1 THEN EXIT LOOP„        WHILE NOT INSTAT: WEND„        k$=INKEY$„        SELECT CASE k$„           CASE Esc$„              cur% = 0„              begy%= 0„              EXIT LOOP„           CASE Enter$„              EXIT LOOP„           CASE Home$„              GOSUB HideCursorBar„              Cur% =1„              begy%=1„           CASE EndKey$„              GOSUB HideCursorBar„              cur%=ye%-yb%-1„              begy%=Nlines%-ye%+yb%+2„           CASE Up$„              IF cur%>1 THEN„                 GOSUB HideCursorBar„                 DECR cur%„              ELSE„                 begy%=begy%-1„              END IF„           CASE Down$„              IF cur%<lpage% THEN„                 GOSUB HideCursorBar„                 INCR cur%„              ELSE„                 begy%=begy%+1„              END IF„           CASE PgUp$„              begy%=begy%-lpage%„           CASE PgDn$„              begy%=begy%+lpage%„           CASE ELSE„              k$=""„        END SELECT„     LOOP„     Gt%=begy%+cur%-1„     GetTextLine% = Gt%„     LOCATE oldy%,oldx%„     EXIT FUNCTION„'„'„„ShowText:„     CALL Numerer(nlines%,lpage%,begy%,endy%)„     GOSUB MakeRuler„     FOR i%=begy% TO endy%„        PutString xb%+2,yb%+i%-begy%+1,_„        LEFT$(txt$(i%)+SPACE$(xe%-xb%+1),xe%-xb%-3)„     NEXT i%„     RETURN„'„'„„ShowCursorBar:„     FOR i%=xb%+1 TO xe%-1„        PutAttribute i%,yb%+cur%,ctn%,cbn%„     NEXT„     RETURN„'„'„„HideCursorBar:„     FOR i%=xb%+1 TO xe%-1„        PutAttribute i%,yb%+cur%,ct%,cb%„     NEXT„     RETURN„'„'„„MakeRuler:„     FOR i%=yb%+1 TO ye%-1„        PutAttribute xe%,i%,ct%,cb%„        PutString xe%,i%,CHR$(177)„     NEXT„     k%=((begy%+cur%-1)/nlines%)*(ye%-yb%-1)„     IF k%=0 THEN k%=1„     PutString xe%,yb%+k%,CHR$(8)„     RETURN„  END FUNCTION„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„' Numerer "normalizes" begy% and endy%        <-  very usefull function!„'„  SUB Numerer(nlines%,lpage%,begy%,endy%)„     IF nlines%<=lpage% THEN„        begy%=1„        endy%=nlines%„        EXIT SUB„     END IF„     IF begy%<1 THEN„        begy%=1„        endy%=begy%+lpage%-1„        EXIT SUB„     END IF„     IF begy%+lpage%-1>=nlines% THEN„        endy%=nlines%„        begy%=nlines%-lpage%+1„        EXIT SUB„     END IF„     endy%=begy%+lpage%-1„  END SUB„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)„'„     OldColor% = PBVSCRNTXTATTR   ' Internal PB variable„     SELECT CASE t%               ' Window types„'                                 ' (you can make as much types,„'                                 ' as you want).„        CASE 1„           a%=218:b%=196:c%=191   ' Single frame,„           h%=179:      :d%=179   '„           g%=192:f%=196:e%=217   '„        CASE 2„           a%=201:b%=205:c%=187   ' double frame,„           h%=186:      :d%=186   '„           g%=200:f%=205:e%=188   '„        CASE ELSE„           a%=032:b%= a%:c%= a%   '„           h%= a%:      :d%= a%   ' blanks only.„           g%= a%:f%= a%:e%= a%   '„     END SELECT„     COLOR ct%,cb%„     LOCATE yb%,xb% : PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%)„     FOR i%=yb%+1 TO ye%-1„        LOCATE i%,xb% : PRINT CHR$(h%)+ SPACE$(xe%-xb%-1) +CHR$(d%)„     NEXT„     LOCATE ye%,xb% : PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%)„     FOR i%=yb%+1 TO ye%+1„        PutAttribute xe%+1,i%,8,0 ' Making„     NEXT                         ' shadows„     FOR i%=xb%+1 TO xe%+1        '„        PutAttribute i%,ye%+1,8,0„     NEXT„     ct%=OldColor% AND 15         ' restore colors„     cb%=OldColor%\16„     COLOR ct%,cb%„  END SUB„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB PutAttribute(x%,y%,t%,b%)   ' Puts attribute byte to video memory„     DIM Cell AS BYTE PTR„     Cell = PBVSCRNBUFF + (y% - 1)*160 + (x% - 1)*2 + 1„     @Cell = b%*16 + t%„  END SUB„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB PutString(x%,y%,st$)        ' Puts string to video memory„     DIM Cell AS BYTE PTR„     DIM TextPtr AS BYTE PTR„'„     TextPtr = STRPTR32( st$ )„     Cell = PBVSCRNBUFF + ( y% - 1 ) * 160 + ( x% - 1 ) * 2„     FOR i% = 1 TO LEN( st$ )„        @Cell = @TextPtr„        INCR TextPtr„        INCR Cell, 2„     NEXT„  END SUB„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB SaveScreen(w$,xb%,yb%,xe%,ye%,sh%)„     DIM temp AS BYTE PTR„     DIM WinPtr AS BYTE PTR„     DIM TextPtr AS BYTE PTR„     lx% = (xe% - xb% + 1) * 2„     ly% = ye% - yb% + 1„     IF sh% THEN„        INCR lx%,2„        INCR ly%„     END IF„     l$ = RIGHT$(" " + STR$(lx%), 3 )„     w$ = l$ + SPACE$( lx% * ly% )„     WinPtr = PBVSCRNBUFF + (yb%-1)*160 + (xb%-1)*2„     TextPtr = STRPTR32(w$) + 3„     FOR i%=1 TO ly%„        temp = WinPtr„        FOR k%=1 TO lx%„           @TextPtr = @temp„           INCR TextPtr„           INCR temp„        NEXT„        INCR WinPtr,160„     NEXT„  END SUB„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB RestoreScreen(w$,xb%,yb%)„     DIM temp AS BYTE PTR„     DIM WinPtr AS BYTE PTR„     DIM TextPtr AS BYTE PTR„     l$ = LEFT$(w$,3)„     w$ = LTRIM$(w$,l$)„     lx% = VAL(l$)„     ly% = LEN(w$) \ lx%„     TextPtr = STRPTR32(w$)„     WinPtr = PBVSCRNBUFF + (yb%-1)*160 + (xb%-1)*2„     FOR i%=1 TO ly%„        temp = WinPtr„        FOR k%=1 TO lx%„           @temp = @TextPtr„           INCR TextPtr„           INCR temp„        NEXT„        INCR WinPtr,160„     NEXT„'   w$ = ""„  END SUB„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'„Egbert Zijlema                 SPLIT SCREEN COLOR ATTRIBUTE   E.Zijlema@uni4nn.iaf.nl        08-05-96 (16:52)       PB                     77   1828     SPLITCLR.BAS' SPLITCLR.BAS    - splits the screen color attribute in fore- and background„'                   the demo shows 2 methods, use the 1 you prefer„„' Author          : Egbert Zijlema (E.Zijlema@uni4nn.iaf.nl)„' Date            : August 5, 1996„' Copyright status: Public Domain„„DEFINT A-Z„„CLS„  row = 10„  col = 10„  text$ = " Egbert"„  COLOR 14, 4         ' yellow on red„  LOCATE row, col„  PRINT text$„„  ' show result on next row (after 2 seconds)„  SLEEP 2„  FOR action = 1 TO LEN(text$)„    SplitColor row, col, character$, fore, back„    LOCATE row + 1, col„    COLOR fore, back„    PRINT character$„    INCR col„    DELAY .1               ' just for the demo„  NEXT„„  COLOR 7, 0„  LOCATE 25, 1„  PRINT "Press any key to proceed";„  DO„  LOOP UNTIL LEN(INKEY$)„  LOCATE 25, 1„  PRINT SPACE$(80);„„  ' now let's use the video segment„  VidSeg = &HB800     ' assume color card„  row = 10„  text$ = " Zijlema "„  COLOR 14, 4„  LOCATE row, col„  PRINT text$„„  DELAY 2„  FOR action = 1 TO LEN(text$)„    CALL ColorSplit(row, col, character, attri)„    offset = row * 160 + (col - 1) * 2      ' next row!„    DEF SEG = VidSeg„    POKE offset, character„    POKE offset + 1, attri„    DEF SEG„    INCR col„    DELAY .1„  NEXT„  COLOR 7, 0            ' restore default„  LOCATE 10, 10: PRINT SPACE$(16);„END„„SUB SplitColor (row, col, character$, fore, back)„  ' using POWER BASIC's SCREEN function„  char = SCREEN(row, col)„  character$ = CHR$(char)„  attri = SCREEN(row, col, 1)„  fore = attri MOD 16„  back = attri \ 16„END SUB„„SUB ColorSplit (row, col, character, attri)„  ' using video segment„  SHARED VidSeg„  DEF SEG = VidSeg„  offset = (row - 1) * 160 + (col - 1) * 2„  character = PEEK(offset)„  attri = PEEK(offset + 1)„  DEF SEG„END SUB„