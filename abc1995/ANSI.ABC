Rich Geldreich                 ANSI EMULATOR                  ANSI,EMULATOR                  07/24/92 (00:00)       QB, PDS                681  21390    PANSI.BAS   'PANSI.BAS v1.50„'ANSI emulator for QuickBASIC 4.5 and PDS„'By Richard Geldreich July 24, 1992„'Don't forget that "CALL INTERRUPT" is used- load QB with "QB/l"„„'I have fixed up & improved the ANSI escape sequence state machine. It„'now works faster. I still don't know why I'm releasing this driver,„'because I'm going to release my all-assembly version very soon...„'(the assembly version of this driver is light years ahead of this program!)„'See the PrintANSI procedure for a list of bug fixes.„„'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!„'! Don't forget to modify the "SendStatus" procedure for your !„'!                       comm package!                        !„'!    You also should modify PrintString for QB4.5 or PDS     !„'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!„„'I welcome any suggestions or ideas about this program... It _should_„'emulate DOS's ANSI.SYS device driver... This program is in the public„'domain; do what you want with it! Have a ball!! Just try and give„'me some credit. Thanks. I have tested this driver out with many BBS's„'and door programs and it works fine. Please test this driver out before„'you release it in a program!!!„„'NOTE: This program assumes that the current segment is always„'pointing twards the video buffer!! If you change the current„'segment don't forget to change it back or sparks will fly when you„'write to the screen! (see GetVSeg)„„'Info:„'ClearScreen- used internally by the PrintAnsi procedure- you may„'use it to clear the current window(the current background color„'is used in the clear). The cursor is set to the upper left hand corner„'of the window after the window is cleared.„„'CursorControl A- if A is non-zero then the SetCursor routine(which„'is called by PrintAnsi) will update the cursor whenever it is moved.„'If it is zero then SetCursor won't touch the cursor's position.„„'GetVSeg- Returns the current video segment.„„'Init- Initializes the driver. This should be called before any other„'procedure. Completly resets the entire driver, sets the window to the„'current screen page & size and moves the cursor to the upper left hand„'corner of the screen.„„'Music A- if A is not zero, then ANSI music is enabled.„„'PrintAnsi Char- where Char is an ASCII code from 0-255. Recognizes„'ANSI escape sequences(of course!). Processes the character and„'updates the display, if needed„„'PrintString A$- prints a string to the display. Calls PrintAnsi for„'each character. Don't forget to modify this for PDS/QuickBASIC.„„'ScrollUpScreen- scrolls up the current window. Uses a BIOS call.„'Normally used internally by PrintAnsi.„„'SendStatus- sends a CPR sequence to the receiver.„'In other words, SendStatus will output the current X and Y coordinates„'of the cursor to the remote terminal. Used by some BBS's and doors„'to see if the user's terminal has ANSI capibilities. You must modify„'this procedure to output the status string to your comm package!„'(this is used internally by PrintAnsi)„„'SetCursor- moves the cursor to its correct position(it doesn't turn„'it on however- use the LOCATE , , 1 command to do that). This procedure„'should work on all adapters, but I haven't tested it out on many„'cards yet... Use this to restore the cursor to where it should be„'after you move it. If you want, change this procedure to use QB's„'LOCATE command instead of the OUT's.„„'SetWindow WorkPage, Lx,Ly,Hx,Hy- defines a window where all text„'is printed. if WorkPage is -1, then the BIOS data area is examined for„'the current screen page, otherwise WorkPage must indicate which page to„'write to. If Lx is -1, the the window will take up the entire screen„'otherwise Lx and Ly are the upper-left lines of the window(where„'1,1 is the upper corner of the screen) and Hx and Hy are the lower-right„'coordinates of the window.„'   The current cursor position is moved to the upper left corner of the„'new window. If the coordinates passed are invalid, the window is not„'modified.„„'   That's all! You can add more functions if you need them; I've„'documented the PrintAnsi procedure enough for you to get„'a good idea of how it works.„„DEFINT A-Z„„DECLARE SUB ClearScreen ()„DECLARE SUB CursorControl (A%)„DECLARE FUNCTION GetVSeg% ()„DECLARE SUB Init ()„DECLARE SUB Music (A%)„DECLARE SUB PrintANSI (Char%)„DECLARE SUB PrintString (B$)„DECLARE SUB ScrollUpScreen ()„DECLARE SUB SendStatus (X%, Y%)„DECLARE SUB SetCursor ()„DECLARE SUB SetWindow (WorkPage%, Lx%, Ly%, Hx%, Hy%)„„DECLARE SUB playme (A$)„„TYPE RegType„     Ax    AS INTEGER„     Bx    AS INTEGER„     Cx    AS INTEGER„     Dx    AS INTEGER„     bp    AS INTEGER„     si    AS INTEGER„     di    AS INTEGER„     flags AS INTEGER„END TYPE„„DIM SHARED Xpos, Ypos               'cursor's position„DIM SHARED MinX, MinY, MaxX, MaxY   'current window„DIM SHARED SaveX, SaveY             'used by SCR and RCP„DIM SHARED Colors(7), Attribute„DIM SHARED CursorOn, VideoSegment, VideoOffset, CursorAddress, BytesPerLine„DIM SHARED Monochrome, CRT          'monochrome adapter flag„DIM SHARED ANSIMusic, MusicLevel„DIM SHARED Level„„CONST True = -1, False = NOT True   'usefull stuff„„'The color translation table is used to translate an ANSI color„'to a screen color.„ColorTable:„    DATA 0,4,2,6,1,5,3,7„„'******START OF TEST PROGRAM„'The following code is not needed... It's only for testing!„„SCREEN 0„WIDTH 80, 25„CLS„LOCATE , , 1            'turn cursor on„„Init„ClearScreen             'clear the window„SetWindow -1, 1, 1, 80, 25 'set window at (1,2)-(80,25)„„'DO„'    A$ = INKEY$: IF A$ <> "" THEN PrintString A$„'LOOP„„'test ANSI music„PrintString CHR$(27) + "[MFO1CDEFGABC" + CHR$(14)„„'A! = TIMER„'PrintString STRING$(5000, 65)„'B! = TIMER„'PRINT 5000 / (B! - A!)„'END„„'a lame test„Esc$ = CHR$(27)„Up$ = CHR$(27) + "[A"„Down$ = CHR$(27) + "[B"„Lft$ = CHR$(27) + "[D"„Rgt$ = CHR$(27) + "[C"„Foreground = 31: Background = 40: Bold = 0„X = 1: Y = 1„DO„    A$ = CHR$(27) + "["„    IF NOT Bold THEN A$ = A$ + "0;" ELSE A$ = A$ + "1;"„    PrintString A$ + MID$(STR$(Foreground), 2) + ";" + MID$(STR$(Background), 2) + "m"„    „    Bold = NOT Bold„    Foreground = Foreground + 1„    IF Foreground > 37 THEN„        Foreground = 31„        Background = Background + 1„        IF Background > 47 THEN Background = 40„    END IF„    PrintString CHR$(27) + "[s" + CHR$(219) + CHR$(27) + "[u"„    IF Xdirect THEN„        X = X - 1„        PrintString Lft$„        IF X = 1 THEN Xdirect = 0„    ELSE„        X = X + 1„        PrintString Rgt$„        IF X = 80 THEN Xdirect = 1„    END IF„    IF Ydirect THEN„        Y = Y - 1„        PrintString Up$„        IF Y = 1 THEN Ydirect = 0„    ELSE„        Y = Y + 1„        PrintString Down$„        IF Y = 24 THEN Ydirect = 1„    END IF„„LOOP UNTIL INKEY$ <> ""„„END„'******END OF TEST PROGRAM„„'Clears the current window. The cursor is also set to the upper-left hand„'corner of the window.„SUB ClearScreen„    DIM Regs AS RegType„    Regs.Ax = &H600„    A& = Attribute * 256&„    IF A& > 32767 THEN A = A& - 65536 ELSE A = A&„    Regs.Bx = A„    Regs.Cx = (MinY * 256&) + MinX - 257„    Regs.Dx = (MaxY * 256&) + MaxX - 257„    CALL interrupt(&H10, Regs, Regs)„„    Xpos = MinX: Ypos = MinY„    SetCursor„„„END SUB„„'Enables or disables cursor updating.„SUB CursorControl (A)„    IF A THEN„        CursorOn = True„    ELSE„        CursorOn = False„    END IF„END SUB„„'Returns the current video segment.„FUNCTION GetVSeg„    GetVSeg = VideoSegment„END FUNCTION„„'Initializes everything.„SUB Init„    DIM Regs AS RegType„„    'default color, white on black (or black on white??)„    Attribute = 7„„    Level = 0: MusicLevel = 0   'reset levels„    ANSIMusic = True            'ANSI music enabled„    CursorOn = True             'cursor movement enabled„„    'read in color translation table„    RESTORE ColorTable„    FOR A = 0 TO 7: READ Colors(A): NEXT„   „    Regs.Ax = 15 * 256„    CALL interrupt(&H10, Regs, Regs)„    'if AL=7 then card is monochrome.„    IF (Regs.Ax AND 255) = 7 THEN„        VideoSegment = &HB000„        Monochrome = True„    ELSE„        VideoSegment = &HB800„        Monochrome = False„    END IF„    DEF SEG = &H40„    CRT = PEEK(&H63) + PEEK(&H64) * 256&„„    'Set segment to the screen.„    DEF SEG = VideoSegment„„    'window defaults to screen's page & size„    'Xpos, Ypos, SaveX, SaveY, MinX, MinY, MaxX, MaxY, VideoOffset and the„    'cursor are set up within this procedure„    SetWindow -1, -1, 0, 0, 0„„END SUB„„'Enables/Disables ANSI music...„SUB Music (A)„    ANSIMusic = A„END SUB„„'Prints an ASCII character on the screen; filters out„'ANSI escape sequences and parses them.„'Fixups from last version(howcome nobody told me about these errors?!):„' A chr$(27) would not be processed correctly if received from within„'   another escape sequence. This has been fixed.„' SetCursor now uses a BIOS variable to get the correct OUT address... It„'   should now work on monochrome and color monitors.„' The cursor set, up & down commands are now not ignored if the cursor is„'  set to a position that is invalid.„' The entire parameter table is set to 1 so special case tests do not„'  have to be performed. Parameters will now be interpeted as 1 if they„'  are zero in the cursor set commands(these two aren't bugs, just„'  improvements!)„' ESC[m now resets the attribute to 7. The new page command, CHR$(12), now„'  resets the screen to attribute 7 before clearing(not really a bug, but...)„' OOPS!! The cursor position command, ESC[H, was processed as an absolute„'  coordinate relative to the upper-left hand of the screen... It should of„'  been processed relative to the upper-left hand corner of the window! DUMB!„'  So if the window was set to (1,2)-(80,25), and an ESC[H was received, the„'  cursor would not move anywhere.... This of course has been fixed.„'„' I discovered almost all of these little bugs while coding the assembly„' version of the driver...„SUB PrintANSI (Char) STATIC„    DIM Parameters(10)„    „    SELECT CASE Level„    CASE 0„        'normal mode„        GOSUB ProcessChar„    CASE 1„        'Level=1 after a chr$(27) is received.„        'valid escape sequence?„„        IF Char <> 91 THEN„            Level = 0„            GOSUB ProcessChar„        ELSE„            'a valid escape sequence has been received„            Level = 2„            CurrentParameter = 0„            NumParameters = 0„            ValidParameter = False„            FOR A = 0 TO 10: Parameters(A) = 1: NEXT„        END IF„    CASE 2„„        'inside an escape sequence„        GOSUB ProcessCode„    END SELECT„EXIT SUB„„ProcessChar:„    'processes a non-ANSI code„    SELECT CASE Char„    'process new page code„    CASE 12„        Attribute = 7„        ClearScreen„    'process escape character„    CASE 27„        Level = 1„    'process enter„    CASE 13„        Xpos = MinX„        SetCursor„    'process line feed„    CASE 10„        Ypos = Ypos + 1„        IF Ypos > MaxY THEN Ypos = MaxY: ScrollUpScreen„        SetCursor„    'process backspace(non-destructive)„    CASE 8„        IF Xpos > MinX THEN„            Xpos = Xpos - 1„            SetCursor„        END IF„    'process tab key(tab stops=8)„    CASE 9„        Xpos = ((Xpos \ 8) + 1) * 8„        IF Xpos > MaxX THEN Xpos = MaxX„        SetCursor„    'process bell„    CASE 7„        'don't substitute a "BEEP" statement here!„        'BEEP resets the cursor to where QB thinks it is!„        SOUND 3140, 1.25„    'any other character is sent to the screen„    CASE ELSE„„        'prints a character to the screen„        POKE CursorAddress, Char: POKE CursorAddress + 1, Attribute„        CursorAddress = CursorAddress + 2„        Xpos = Xpos + 1„„        IF Xpos > MaxX THEN„„            Xpos = MinX„            Ypos = Ypos + 1„            IF Ypos > MaxY THEN„                Ypos = MaxY„                ScrollUpScreen„            END IF„            SetCursor„        ELSE„            IF CursorOn THEN„                Address = CursorAddress \ 2„                OUT CRT, &HE„                OUT CRT + 1, Address \ 256„                OUT CRT, &HF„                OUT CRT + 1, Address AND 255„            END IF„        END IF„    END SELECT„RETURN„'processes a character within an ansi escape sequence„'non-valid characters are sent to the screen„ProcessCode:„'handles ANSI music...„IF MusicLevel > 0 THEN„    SELECT CASE MusicLevel„    'see if the "F" in "ESC[MF" is received...„    CASE 1„        IF Char <> 70 THEN          '"F"„            MusicLevel = 0„            Level = 0„            GOSUB ProcessChar„        ELSE„            MusicLevel = 2„            MusicString$ = ""„        END IF„        'Either add a char to the music string or play it...„    CASE 2„        IF Char <> 14 THEN„            'fall out if an escape character is received...„            IF Char = 27 THEN„                MusicString$ = ""„                MusicLevel = 0„                Level = 0„                GOSUB ProcessChar„            'assume the character received to be part of the„            'PLAY string„            ELSE„                MusicString$ = MusicString$ + CHR$(Char)„            END IF„        ELSE„            IF ANSIMusic THEN„                'play the string- the PLAY command is in a seperate„                'module to keep error checking out of this module„                playme MusicString$„            END IF„            MusicString$ = ""„            MusicLevel = 0„            Level = 0„        END IF„    END SELECT„ELSE„    SELECT CASE Char„    CASE 77                             '"M"„        MusicLevel = 1„    CASE 48 TO 57                       '0-9„        'all parameters should be lower than 199...„        IF CurrentParameter < 199 THEN„            CurrentParameter = CurrentParameter * 10 + (Char - 48)„            ValidParameter = True„        ELSE„            Level = 0„            GOSUB ProcessChar„        END IF„    CASE 59„        GOSUB MakeParameter             '";"„    'CUP-set cursor's position„    CASE 72, 102                        'H or f„        GOSUB MakeParameter„        Ypos = MinY + A - 1„        A = Parameters(1): IF A = 0 THEN A = 1„        Xpos = MinX + A - 1„        IF Xpos > MaxX THEN Xpos = MaxX„        IF Ypos > MaxY THEN Ypos = MaxY„        SetCursor„        Level = 0„    'CUU- cursor up„    CASE 65                             'A„        GOSUB MakeParameter„        Ypos = Ypos - A„        IF Ypos < MinY THEN Ypos = MinY„        SetCursor„        Level = 0„    'CUD-cursor down„    CASE 66                             'B„        GOSUB MakeParameter„        Ypos = Ypos + A„        IF Ypos > MaxY THEN Ypos = MaxY„        SetCursor„        Level = 0„    'CUF-cursor forward„    CASE 67                             'C„        GOSUB MakeParameter„        Xpos = Xpos + A„        IF Xpos > MaxX THEN Xpos = MaxX„        SetCursor„        Level = 0„    'CUB-cursor backward„    CASE 68                              'D„        GOSUB MakeParameter„        Xpos = Xpos - A„„        IF Xpos < MinX THEN Xpos = MinX„        SetCursor„        Level = 0„    'SCR-save cursor position„    CASE 115                            's„        SaveX = Xpos: SaveY = Ypos„        Level = 0„    'RCP-restore cursor position„    CASE 117                            'u„        Xpos = SaveX: Ypos = SaveY„        Level = 0„        SetCursor„    'ED-erase display(ESC[2J and ESC[J work„    'both work)„    CASE 74                             'J„        ClearScreen„        Level = 0„    'EL-erase in line„    CASE 75                             'K„        A = CursorAddress„        FOR X = Xpos TO MaxX„            POKE A, 32: POKE A + 1, Attribute: A = A + 2„        NEXT„        Level = 0„    'SGR-sets new color„    CASE 109                            'm„        GOSUB MakeParameter„        'if no color codes then stuff 0 into the table„        IF NumParameters = 0 THEN Parameters(0) = 0: NumParameters = 1„        FOR A = 0 TO NumParameters - 1„            P = Parameters(A)„            SELECT CASE P„            CASE IS <= 8„                SELECT CASE P„                'all attributes off„                CASE 0„                    Attribute = 7„                'high-intensity„                CASE 1„                    Attribute = Attribute OR 8„                'blinking„                CASE 5„                    Attribute = Attribute OR 128„                'inverse„                CASE 7„                    Attribute = (Attribute AND 136) OR (Attribute AND 7) * 16 OR (Attribute AND 112) \ 16„                END SELECT„                'set foreground„            CASE 30 TO 37„                IF NOT Monochrome THEN„                    Attribute = (Attribute AND 248) OR Colors(P - 30)„                END IF„                'set background„            CASE 40 TO 47„                IF NOT Monochrome THEN„                    Attribute = (Attribute AND 143)„                    Attribute = Attribute OR Colors(P - 40) * 16„                END IF„            END SELECT„        NEXT„        Level = 0„    'DSR-outputs a CPR sequence„    'This function outputs the string "ESC[#;#R" where„    '#;# is the current Y and current X coordinate„    'to the receiver.„    'Calls SendStatus to do its dirty work...„    CASE 110„        SendStatus Xpos, Ypos„        Level = 0„    'any other code is assumed to be invalid;it's just sent to the„    'screen„    CASE ELSE„        Level = 0„        GOSUB ProcessChar„    END SELECT„END IF„RETURN„'stores a numeric parameter into the parameter table„MakeParameter:„    'check to see if a least one digit has been received„    'for this parameter and there's room left in the table„    IF ValidParameter AND NumParameters < 10 THEN„        'add parameter to table„        Parameters(NumParameters) = CurrentParameter„        NumParameters = NumParameters + 1„        CurrentParameter = 0„        ValidParameter = False„    END IF„„    'Set A equal to the first parameter and make it 1 if it's 0„    A = Parameters(0)„    IF A = 0 THEN A = 1„„RETURN„END SUB„„'Prints a string to the display.„SUB PrintString (B$)„    A& = SADD(B$)„    IF A& < 0 THEN A& = A& + 65536„„    STOP' You must change the next line if you're using QB4.5!„    'It is currently coded for PDS.„„    'Segment = VARSEG(B$) + A& \ 16„„    Segment = SSEG(B$) + A& \ 16    'change to VARSEG(B$) for QB4.5 & QBASIC„    „    Address = A& MOD 16„    FOR B = Address TO Address + LEN(B$) - 1„        DEF SEG = Segment„        A1 = PEEK(B)„        DEF SEG = VideoSegment„        PrintANSI A1„    NEXT„END SUB„„SUB ScrollUpScreen„    DIM Regs AS RegType„    Regs.Ax = &H601„   „    A& = Attribute * 256&„    IF A& > 32767 THEN A = A& - 65536 ELSE A = A&„    Regs.Bx = A„   „    Regs.Cx = (MinY * 256&) + MinX - 257„    Regs.Dx = (MaxY * 256&) + MaxX - 257„    CALL interrupt(&H10, Regs, Regs)„END SUB„„'Sends the screen's status to the receiver. You must modify the„'"PRINT #1, A$;" command to print to your comm package.„'Sends "ESC[##;##R" where ##;## is Y;X.„SUB SendStatus (X, Y)„    A$ = CHR$(27) + "[" + RIGHT$("0" + MID$(STR$(Y), 2), 2)„    A$ = A$ + ";" + RIGHT$("0" + MID$(STR$(X), 2), 2) + "R"„„'*****Change the next line to print this string out to your comm package!!****„    PRINT A$;           'DON'T insert a line feed!!„    „END SUB„„'Sets the cursor- uses OUT's for speed„SUB SetCursor„    'Must do this...„„    CursorAddress = (Xpos - 1) * 2 + (Ypos - 1) * BytesPerLine + VideoOffset„    IF CursorOn THEN„        Address = CursorAddress \ 2„        OUT CRT, &HE„        OUT CRT + 1, Address \ 256„        OUT CRT, &HF„        OUT CRT + 1, Address AND 255„    END IF„END SUB„„'Sets a new printing window.„SUB SetWindow (WorkPage, Lx, Ly, Hx, Hy)„    DEF SEG = &H40„    IF WorkPage = -1 THEN„        VideoOffset = PEEK(&H4E) + PEEK(&H4F) * 256&„    ELSE„        VideoOffset = (PEEK(&H4C) + PEEK(&H4D) * 256&) * WorkPage„    END IF„„    ScreenX = PEEK(&H4A)„    ScreenY = PEEK(&H84) + 1„„    IF Lx = -1 THEN„        MinX = 1: MinY = 1„        MaxX = ScreenX: MaxY = ScreenY„        BytesPerLine = MaxX * 2„    ELSE„        'change window size if coordinates are valid„        IF Lx <= Hx AND Ly <= Hy AND Hx <= ScreenX AND Hy <= ScreenY THEN„            MinX = Lx: MaxX = Hx: MinY = Ly: MaxY = Hy„        END IF„    END IF„    DEF SEG = VideoSegment„    Xpos = MinX: Ypos = MinY„    SaveX = MinX: SaveY = MinY„    SetCursor„END SUB„„„'-------------8<----[ Begin PLAYME.BAS ]---->8----------------„'A lone play command is present in this module so error trapping is„'seperate from the main module. This decreases the size of the driver.„DEFINT A-Z„ErrorHandler:„RESUME NEXT„„SUB playme (A$)„    ON ERROR GOTO ErrorHandler„    PLAY A$„    ON ERROR GOTO 0„END SUB„„'-------------8<----[ End PLAYME.BAS ]---->8----------------„Aaron Lapikas                  .ANS TO .BAS                   ANS,BAS                        Unknown Date (00:00)   QB, PDS                697  16004    ANSI2BAS.BAS'ANSI2BAS v3.1 was written by Aaron Lapikas of BCData Inc.  This program is„'designed to make the annoying job of creating graphical screens in screen„'mode 0 much easier.  This program is in public domain, and no fee is„'required to use it.  You can use it wherever you want, just maybe give me a„'little credit, like mentioning my name or something like that.  :)„„'To use the program, either complile it into an EXE, or modify the COMMAND$.„'If the program is started with no parameters, then the help screen is„'displayed.  I hope that you find this program helpful, and please, give me„'any comments about this program and let me know of any bugs (if there are„'any <gasp>).„„DECLARE SUB ANSIDriver (ANSICode$)„„DIM SHARED PosOfSC%(4), Color$(5), CColor%(1), Col%(1), RowA%(1), Attribute$(1)„DIM SHARED Blink$(1)„„DEFINT A-Z„„„ON ERROR GOTO HandleError„„„IF COMMAND$ = "" THEN„  COLOR 7, 0„  PRINT„  PRINT "ANSI2BAS v3.1 by BCData Inc.  Released on May 31, 1992"„  PRINT„  PRINT„  PRINT "Converts ANSI source code files to QuickBASIC version 4.5 ";„  PRINT "format.  Supports the"„„  PRINT "use of ansy ANSI files, as well as ASCII files."„  PRINT„  PRINT„  PRINT "USAGE:  ANSI2BAS InputFile.Ext OutputFile.Ext[/A]"„  PRINT„  PRINT„  PRINT "NOTE :  Extensions, as well as the output filename are optional, ";„  PRINT "and are not"„  PRINT "        needed in order for the program to run correctly.  If ";„  PRINT "no extension is"„  PRINT "        given, ANSI2BAS uses the default extension .ANS forthe ";„  PRINT "ANSI source"„  PRINT "        file, and .BAS for the QuickBASIC output file.  If no ";„  PRINT "output filename"„  PRINT "        is given, then ANSI2BAS names the output file the same ";„  PRINT "as the ANSI"„  PRINT "        filename, but with a .BAS extension.  The /A parameter ";„  PRINT "allows the ANSI"„  PRINT "        file to be displayed while being converted.  Note the ";„  PRINT "examples below:"„  PRINT„  PRINT„  PRINT "ANSI2BAS FILE.BAS  ->  Converts the ANSI file FILE.ANS to FILE.BAS"„  PRINT "ANSI2BAS FILE/A    -> Converts and displays the ANSI file FILE.ANS ";„  PRINT "to FILE.BAS"„„  END„END IF„„„Parameter$ = RIGHT$(COMMAND$, 2)„„IF UCASE$(Parameter$) = "/A" THEN„  LET ANSIView$ = "ON"„  LET Command2$ = LEFT$(COMMAND$, LEN(COMMAND$) - 2)„ELSE„  LET Command2$ = COMMAND$„END IF„„FOR y = 1 TO LEN(Command2$)„  IF MID$(Command2$, y, 1) = " " THEN EXIT FOR„NEXT y„„„FOR x = y TO 1 STEP -1„  IF MID$(Command2$, x, 1) = "\" THEN EXIT FOR„NEXT x„„IF x < LEN(Command2$) = 1 AND x < y THEN„  LET FILE$ = UCASE$(MID$(Command2$, x + 1, LEN(Command2$) - y + 3))„ELSE„  LET FILE$ = LEFT$(Command2$, y - 1)„END IF„„LET FullFile$ = UCASE$(LEFT$(Command2$, y - 1))„„IF LEN(FILE$) > 4 THEN„  IF MID$(FILE$, LEN(FILE$) - 3, 1) <> "." THEN„    LET FILE$ = FILE$ + ".ANS"„    LET FullFile$ = FullFile$ + ".ANS"„  END IF„ELSE„  LET FILE$ = FILE$ + ".ANS"„  LET FullFile$ = FullFile$ + ".ANS"„END IF„„IF y <> LEN(Command2$) + 1 THEN„  LET Output$ = MID$(Command2$, y + 1, LEN(Command2$) - y + 1)„„  IF LEN(Output$) < 5 THEN„    LET Output$ = Output$ + ".BAS"„  ELSEIF MID$(Output$, LEN(Output$) - 3, 1) <> "." THEN„    LET Output$ = Output$ + ".BAS"„  END IF„„ELSE„  LET Output$ = MID$(FILE$, 1, LEN(FILE$) - 4) + ".BAS"„END IF„„CLS„COLOR 7, 0„„PRINT "ANSI2BAS v3.1 - Released on May 31, 1992 by BCData Inc."„PRINT„PRINT„PRINT "ANSI Source File [.ANS]: "; UCASE$(FullFile$)„PRINT "QB45 Output File [.BAS]: "; UCASE$(Output$)„PRINT„PRINT„„„OPEN FullFile$ FOR INPUT AS 1„OPEN Output$ FOR OUTPUT AS 2„„PRINT "Accessing ANSI code...Please wait."„„„IF ANSIView$ = "ON" THEN„  FOR x! = 1 TO 7000„  NEXT x!„„  CLS„ELSE„  SCREEN , , 1, 0„END IF„„PRINT #2, "' "; UCASE$(Output$) + " - Prepared by ANSI2BAS v3.1 by BCData Inc."„PRINT #2, "' Released on May 31, 1992 by BCData Inc."„PRINT #2, ""„PRINT #2, ""„COLOR 7, 0„LET CColor%(1) = 7„„„DO„„„  IF Flag = 1 THEN„    LET Flag = 0„    GOTO SecondChar„  END IF„„  IF LOC(1) < 1 THEN„„    a = 0„„    DO„      a = a + 1„    LOOP UNTIL a = 100 OR LOC(1) > 0„„    IF a = 100 THEN END„„  END IF„„  IF Flag <> 31 THEN„    a$ = INPUT$(1, #1)„  ELSE„    LET Flag = 0„    LET a$ = CHR$(27)„  END IF„„  IF a$ = CHR$(27) THEN„„„SecondChar:„„    a = 0„„    DO„      a = a + 1„    LOOP UNTIL a = 100 OR LOC(1) > 0„„    IF a = 100 THEN END„„    B$ = INPUT$(1, #1)„    IF B$ = "[" THEN„„       LET ANSICode$ = ""„„       DO„„         a = 0„„         DO„            a = a + 1„         LOOP UNTIL a = 100 OR LOC(1) > 0„         IF a = 100 THEN END„„         C$ = INPUT$(1, #1)„„         ANSICode$ = ANSICode$ + C$„         IF ANSICode$ = "M" THEN„„           DO„             IF LOC(1) > 1 THEN„               D$ = INPUT$(1, #1)„               LET ANSICode$ = ANSICode$ + D$„             END IF„           LOOP UNTIL D$ = CHR$(14)„„         END IF„         SELECT CASE C$„            CASE "H", "A", "B", "C", "D", "f", "m", "s", "u", "k", "J", "M"„                 EXIT DO„         END SELECT„         ''IF C$ = "H" OR C$ = "A" OR C$ = "B" OR C$ = "C" OR C$ = "D" OR C$ = "f" OR C$ = "m" OR C$ = "s" OR C$ = "u" OR C$ = "k" OR C$ = "J" OR C$ = "M" THEN EXIT DO„„       LOOP„„„       LET ANSICode$ = CHR$(27) + "[" + ANSICode$„       ANSIDriver ANSICode$„„„    ELSEIF B$ <> CHR$(13) THEN„„      PRINT B$;„      PRINT #2, "PRINT " + CHR$(34) + B$ + CHR$(34) + ";"„      PRINT #2, ""„„„    ELSEIF B$ = CHR$(13) THEN„      LOCATE , 1„      PRINT #2, "LOCATE ,1"„    END IF„„„  ELSE„„    LET Print$ = ""„„    DO UNTIL EOF(1)„„      IF a$ = CHR$(13) OR a$ = CHR$(10) OR a$ = CHR$(27) THEN EXIT DO„      LET Print$ = Print$ + a$„„      a$ = INPUT$(1, #1)„„    LOOP„„    IF LEN(Print$) + POS(x) > 80 THEN„      LET Print1$ = ""„      LET Print2$ = ""„„      LET a = 81 - POS(x)„      LET Print1$ = LEFT$(Print$, a)„      PRINT #2, "PRINT " + CHR$(34) + Print1$ + CHR$(34)„„      PRINT Print1$„„      LET Print2$ = RIGHT$(Print$, LEN(Print$) - a)„      PRINT #2, "PRINT " + CHR$(34) + Print2$ + CHR$(34) + ";"„      PRINT #2, ""„„      PRINT Print2$;„    ELSE„      PRINT Print$;„      PRINT #2, "PRINT " + CHR$(34) + Print$ + CHR$(34) + ";"„      PRINT #2, ""„    END IF„„    IF a$ = CHR$(13) THEN„      LOCATE , 1„      PRINT #2, "LOCATE ,1"„    ELSEIF a$ = CHR$(10) THEN„      PRINT„      PRINT #2, "PRINT"„    ELSEIF a$ = CHR$(27) THEN„      LET Flag = 31„    END IF„  END IF„LOOP UNTIL EOF(1)„„IF ANSIView$ <> "ON" THEN„  SCREEN , , 0„  LOCATE 8, 1„  COLOR 7, 0„  PRINT "Conversion complete.  QuickBASIC source "; Output$;„  PRINT " has been created."„ELSE„  COLOR 7, 0„  PRINT„  PRINT "Conversion complete.  QuickBASIC source "; Output$;„  PRINT " has been created."„END IF„„COLOR 7, 0„„PRINT #2, ""„PRINT #2, "COLOR 7,0"„„END„„„HandleError:„„IF ERR = 76 THEN„  LOCATE 8, 1„  COLOR 7, 0„  BEEP„„  PRINT "Path not found.  Exiting program."„  PRINT„  END„ELSEIF ERR = 53 THEN„  BEEP„  LOCATE 8, 1„  COLOR 7, 0„„  PRINT "File not found or invalid parameters.  Exiting program."„  PRINT„  END„END IF„„RESUME„„'„SUB ANSIDriver (ANSICode$)„„„IF RIGHT$(ANSICode$, 1) = "m" THEN„    NumOfSC = 0„„    FOR x = 1 TO LEN(ANSICode$)„      IF MID$(ANSICode$, x, 1) = ";" THEN„        LET NumOfSC = NumOfSC + 1„        LET PosOfSC(NumOfSC) = x„      END IF„    NEXT x„„    IF NumOfSC = 0 THEN„      LET Color$(1) = MID$(ANSICode$, 3, LEN(ANSICode$) - 3)„      LET Color$(2) = ""„      LET Color$(3) = ""„      LET Color$(4) = ""„      LET SC = 1„    ELSEIF NumOfSC = 1 THEN„      LET Color$(1) = MID$(ANSICode$, 3, PosOfSC%(1) - 3)„      LET Color$(2) = MID$(ANSICode$, PosOfSC%(1) + 1, LEN(ANSICode$) - (PosOfSC%(1) + 1))„      LET Color$(3) = ""„      LET Color$(4) = ""„      LET SC = 2„    ELSEIF NumOfSC = 2 THEN„      LET Color$(1) = MID$(ANSICode$, 3, (PosOfSC%(1) - 3))„      LET Color$(2) = MID$(ANSICode$, PosOfSC%(1) + 1, PosOfSC%(2) - (PosOfSC%(1) + 1))„      LET Color$(3) = MID$(ANSICode$, PosOfSC(2) + 1, LEN(ANSICode$) - (PosOfSC%(2) + 1))„      LET Color$(4) = ""„      LET SC = 3„    ELSEIF NumOfSC = 3 THEN„      LET Color$(1) = MID$(ANSICode$, 3, PosOfSC%(1) - 3)„      LET Color$(2) = MID$(ANSICode$, PosOfSC%(1) + 1, PosOfSC(2) - (PosOfSC%(1) + 1))„      LET Color$(3) = MID$(ANSICode$, PosOfSC(2) + 1, PosOfSC(3) - (PosOfSC(2) + 1))„      LET Color$(4) = MID$(ANSICode$, PosOfSC(3) + 1, LEN(ANSICode$) - (PosOfSC(3) + 1))„      LET SC = 4„    ELSE„      GOTO ExitDriver„    END IF„„„    IF ANSICode$ = CHR$(27) + "[0m" THEN„      LET Attribute$(1) = "OFF"„      LET Blink$(1) = "OFF"„„      COLOR 7, 0„      PRINT #2, "COLOR 7,0"„„      LET CColor%(1) = 7„„    ELSEIF ANSICode$ = CHR$(27) + "[1m" THEN„      LET Attribute$(1) = "ON"„„      IF CColor%(1) < 8 THEN„        COLOR CColor%(1) + 8„        PRINT #2, "COLOR "; CColor%(1) + 8„„        LET CColor%(1) = CColor%(1) + 8„      END IF„    END IF„„    Span = SC \ 2„„    DO WHILE (Span > 0)„      FOR I = Span TO SC - 1„        j = I - Span + 1„„        FOR j = (I - Span + 1) TO 1 STEP -Span„          IF Color$(j) <= Color$(j + Span) THEN EXIT FOR„„          SWAP Color$(j), Color$(j + Span)„„        NEXT j„      NEXT I„      Span = Span \ 2„„    LOOP„„„    FOR w = 1 TO SC„„      IF Color$(w) = "0" THEN„        LET Attribute$(1) = "OFF"„        LET Blink$(1) = "OFF"„„        COLOR , 0„        PRINT #2, "COLOR ,0"„          LET CColor%(1) = 0„        ELSE„          COLOR 8„          PRINT #2, "COLOR 8"„„          LET CColor%(1) = 8„        END IF„        IF Color$(w) = "31" THEN„        IF Attribute$(1) = "OFF" THEN„          COLOR 4„          PRINT #2, "COLOR 4"„          LET CColor%(1) = 4„        ELSE„          COLOR 12„          PRINT #2, "COLOR 12"„„          LET CColor%(1) = 12„        END IF„      ELSEIF Color$(w) = "32" THEN„        IF Attribute$(1) = "OFF" THEN„          COLOR 2„          PRINT #2, "COLOR 2"„„          LET CColor%(1) = 2„        ELSE„          COLOR 10„          PRINT #2, "COLOR 10"„„          LET CColor%(1) = 10„        END IF„      ELSEIF Color$(w) = "33" THEN„        IF Attribute$(1) = "OFF" THEN„          COLOR 6„          PRINT #2, "COLOR 6"„„          LET CColor%(1) = 6„        ELSE„          COLOR 14„          PRINT #2, "COLOR 14"„„          LET CColor%(1) = 14„        END IF„      ELSEIF Color$(w) = "34" THEN„        IF Attribute$(1) = "OFF" THEN„          COLOR 1„          PRINT #2, "COLOR 1"„„          LET CColor%(1) = 1„        ELSE„          COLOR 9„          PRINT #2, "COLOR 9"„„          LET CColor%(1) = 9„        END IF„      ELSEIF Color$(w) = "35" THEN„        IF Attribute$(1) = "OFF" THEN„          COLOR 5„          PRINT #2, "COLOR 5"„„          LET CColor%(1) = 5„        ELSE„          COLOR 13„          PRINT #2, "COLOR 13"„„          LET CColor%(1) = 13„        END IF„      ELSEIF Color$(w) = "36" THEN„        IF Attribute$(1) = "OFF" THEN„          COLOR 3„          PRINT #2, "COLOR 3"„„          LET CColor%(1) = 3„        ELSE„          COLOR 11„          PRINT #2, "COLOR 11"„„         LET CColor%(1) = 11„        END IF„      ELSEIF Color$(w) = "37" THEN„        IF Attribute$(1) = "OFF" THEN„          COLOR 7„          PRINT #2, "COLOR 7"„„          LET CColor%(1) = 7„        ELSE„          COLOR 15„          PRINT #2, "COLOR 15"„„          LET CColor%(1) = 15„        END IF„      ELSEIF Color$(w) = "40" THEN„        COLOR , 0„        PRINT #2, "COLOR ,0"„„      ELSEIF Color$(w) = "41" THEN„        COLOR , 4„        PRINT #2, "COLOR ,4"„„      ELSEIF Color$(w) = "42" THEN„        COLOR , 2„„        PRINT #2, "COLOR ,2"„„      ELSEIF Color$(w) = "43" THEN„        COLOR , 6„        PRINT #2, "COLOR ,6"„„      ELSEIF Color$(w) = "44" THEN„        COLOR , 1„        PRINT #2, "COLOR ,1"„„      ELSEIF Color$(w) = "45" THEN„        COLOR , 5„        PRINT #2, "COLOR ,5"„„      ELSEIF Color$(w) = "46" THEN„        COLOR , 3„        PRINT #2, "COLOR ,3"„„      ELSEIF Color$(w) = "47" THEN„        COLOR , 7„        PRINT #2, "COLOR ,7"„      END IF„    NEXT w„„    IF Blink$(1) = "ON" THEN„      COLOR CColor%(1) + 16„      PRINT #2, "COLOR "; CColor%(1) + 16„    END IF„„„ELSEIF RIGHT$(ANSICode$, 1) = "J" THEN„  CLS 2„  LOCATE 1, 1„  PRINT #2, "CLS 2"„  PRINT #2, "LOCATE 1,1"„  PRINT #2, ""„ELSEIF RIGHT$(ANSICode$, 1) = "K" THEN„  Row = CSRLIN„  Column = POS(x)„„  NumOfSpace = 81 - POS(x)„  PRINT SPACE$(NumOfSpace)„  PRINT #2, "SPACE$("; NumOfSpace; ")"„  LOCATE Row, Column„  PRINT #2, "LOCATE"; Row; ","; Column; ""„„ELSEIF RIGHT$(ANSICode$, 1) = "H" OR RIGHT$(ANSICode$, 1) = "f" THEN„„  IF ANSICode$ = CHR$(27) + "[H" THEN„    PRINT #2, "LOCATE 1,1"„    LOCATE 1, 1„„    GOTO ExitDriver„  END IF„„  FOR x = 1 TO LEN(ANSICode$)„    IF MID$(ANSICode$, x, 1) = ";" THEN EXIT FOR„  NEXT x„„  IF x = LEN(ANSICode$) + 1 THEN„    LET HRow$ = MID$(ANSICode$, 3, LEN(ANSICode$) - 3)„„    LET HRow = VAL(HRow$)„    LOCATE HRow, 1„„    PRINT #2, "LOCATE "; HRow; ",1"„„  ELSEIF x = 3 THEN„    LET HCol$ = MID$(ANSICode$, 4, LEN(ANSICode$) - 4)„„    LET HCol = VAL(HCol$)„    LOCATE 1, HCol„„    PRINT #2, "LOCATE 1,"; HCol„„  ELSEIF x = LEN(ANSICode$) - 1 THEN„    HRow$ = MID$(ANSICode$, 3, LEN(ANSICode$) - 4)„„    LET HRow = VAL(HRow$)„    LOCATE HRow, 1„„    PRINT #2, "LOCATE "; HRow; ",1"„„  ELSE„    HColumn$ = RIGHT$(ANSICode$, LEN(ANSICode$) - x)„    HColumn$ = LEFT$(HColumn$, LEN(HColumn$) - 1)„    HRow$ = LEFT$(ANSICode$, x - 1)„    HRow$ = RIGHT$(HRow$, LEN(HRow$) - 2)„„    HRow = VAL(HRow$)„    HColumn = VAL(HColumn$)„„    IF HRow > 25 THEN LET HRow = 25„„    LOCATE HRow, HColumn„    PRINT #2, "LOCATE"; HRow; ","; HColumn„  END IF„„ELSEIF RIGHT$(ANSICode$, 1) = "C" THEN„  IF LEN(ANSICode$) = 3 THEN„    PRINT #2, "LOCATE ,"; POS(x) + 1„    LOCATE , POS(x) + 1„  END IF„„  Column$ = MID$(ANSICode$, 3, LEN(ANSICode$) - 3)„  LET Column = VAL(Column$)„„  IF POS(x) + Column < 81 THEN„    PRINT #2, "LOCATE,"; POS(x) + Column„    LOCATE , POS(x) + Column„  END IF„„ELSEIF RIGHT$(ANSICode$, 1) = "D" THEN„  IF LEN(ANSICode$) = 3 AND POS(x) <> 1 THEN„    PRINT #2, "LOCATE,"; POS(x) - 1„    LOCATE , POS(x) - 1„  ELSE„„    Back$ = MID$(ANSICode$, 3, LEN(ANSICode$) - 3)„    Back = VAL(Back$)„„    IF POS(x) > 1 AND Back < 80 THEN„      PRINT #2, "LOCATE,"; POS(x) - Back„      LOCATE , POS(x) - Back„    END IF„  END IF„„ELSEIF RIGHT$(ANSICode$, 1) = "A" THEN„  IF LEN(ANSICode$) = 3 THEN„„    PRINT #2, "LOCATE"; CSRLIN - 1; ","; POS(x)„    LOCATE CSRLIN - 1, POS(x)„  END IF„„  Up$ = MID$(ANSICode$, 3, LEN(ANSICode$) - 3)„  Up = VAL(Up$)„„  IF CSRLIN > 1 THEN„    PRINT #2, "LOCATE"; CSRLIN - Up; ","; POS(x)„    LOCATE CSRLIN - Up, POS(x)„  ELSE„    PRINT #2, "LOCATE 1,"; POS(x)„    LOCATE 1, POS(x)„  END IF„„ELSEIF RIGHT$(ANSICode$, 1) = "B" THEN„  IF LEN(ANSICode$) = 3 THEN„    PRINT #2, "LOCATE"; CSRLIN + 1; ","; POS(x)„    LOCATE CSRLIN + 1, POS(x)„  END IF„„  Down$ = MID$(ANSICode$, 3, LEN(ANSICode$) - 3)„  Down = VAL(Down$)„„  IF CSRLIN >= 24 THEN„    PRINT #2, "LOCATE 24,"; POS(x)„    LOCATE 24, POS(x)„  ELSE„    PRINT #2, "LOCATE"; CSRLIN + Down; ","; POS(x)„    LOCATE CSRLIN + Down, POS(x)„  END IF„„ELSEIF RIGHT$(ANSICode$, 1) = "s" THEN„  LET Col%(1) = POS(x)„  LET RowA%(1) = CSRLIN„„ELSEIF RIGHT$(ANSICode$, 1) = "u" THEN„  LOCATE RowA%(1), Col%(1)„  PRINT #2, "LOCATE"; RowA%(1); ","; Col%(1)„„ELSEIF RIGHT$(ANSICode$, 1) = CHR$(14) THEN„  LET ANSIMusic$ = MID$(ANSICode$, 3, (LEN(ANSICode$) - 3))„  PLAY ANSIMusic$„  LET ANSIMusic$ = ""„END IF„„ExitDriver:„END SUB„„Peter Barney                   ANSI ESCAPE CODES DEFINED      ANSI,ESCAPE CODES,DEFINED      03/23/93 (00:00)       INC                    72   4056     ANSI.INC    ' ANSI include file„' Peter Barney (03/23/93)„' I'm not oppressing these codes!  they're free!  be free!„' Note: Don't forget to change all \'s to ascii 27.„'„'Foreground colors only„CONST Blk = "\[0;30m", BrtBlk = "\[1;30m"„CONST red = "\[0;31m", BrtRed = "\[1;31m"„CONST grn = "\[0;32m", BrtGrn = "\[1;32m"„CONST yel = "\[0;33m", BrtYel = "\[1;33m"„CONST blu = "\[0;34m", BrtBlu = "\[1;34m"„CONST mag = "\[0;35m", BrtMag = "\[1;35m"„CONST Cyn = "\[0;36m", BrtCyn = "\[1;36m"„CONST Wht = "\[0;37m", BrtWht = "\[1;37m"„„'Low-Intensity foreground and background colors„CONST BlkBlk = "\[0;30;40m", BlkRed = "\[0;30;41m", BlkGrn = "\[0;30;42m"„CONST RedBlk = "\[0;31;40m", RedRed = "\[0;31;41m", RedGrn = "\[0;31;42m"„CONST GrnBlk = "\[0;32;40m", GrnRed = "\[0;32;41m", GrnGrn = "\[0;32;42m"„CONST YelBlk = "\[0;33;40m", YelRed = "\[0;33;41m", YelGrn = "\[0;33;42m"„CONST BluBlk = "\[0;34;40m", BluRed = "\[0;34;41m", BluGrn = "\[0;34;42m"„CONST MagBlk = "\[0;35;40m", MagRed = "\[0;35;41m", MagGrn = "\[0;35;42m"„CONST CynBlk = "\[0;36;40m", CynRed = "\[0;36;41m", CynGrn = "\[0;36;42m"„CONST WhtBlk = "\[0;37;40m", WhtRed = "\[0;37;41m", WhtGrn = "\[0;37;42m"„„CONST BlkYel = "\[0;30;43m", BlkBlu = "\[0;30;44m", BlkMag = "\[0;30;45m"„CONST RedYel = "\[0;31;43m", RedBlu = "\[0;31;44m", RedMag = "\[0;31;45m"„CONST GrnYel = "\[0;32;43m", GrnBlu = "\[0;32;44m", GrnMag = "\[0;32;45m"„CONST YelYel = "\[0;33;43m", YelBlu = "\[0;33;44m", YelMag = "\[0;33;45m"„CONST BluYel = "\[0;34;43m", BluBlu = "\[0;34;44m", BluMag = "\[0;34;45m"„CONST MagYel = "\[0;35;43m", MagBlu = "\[0;35;44m", MagMag = "\[0;35;45m"„CONST CynYel = "\[0;36;43m", CynBlu = "\[0;36;44m", CynMag = "\[0;36;45m"„CONST WhtYel = "\[0;37;43m", WhtBlu = "\[0;37;44m", WhtMag = "\[0;37;45m"„„CONST BlkCyn = "\[0;30;46m", BlkWht = "\[0;30;47m"„CONST RedCyn = "\[0;31;46m", RedWht = "\[0;31;47m"„CONST GrnCyn = "\[0;32;46m", GrnWht = "\[0;32;47m"„CONST YelCyn = "\[0;33;46m", YelWht = "\[0;33;47m"„CONST BluCyn = "\[0;34;46m", BluWht = "\[0;34;47m"„CONST MagCyn = "\[0;35;46m", MagWht = "\[0;35;47m"„CONST CynCyn = "\[0;36;46m", CynWht = "\[0;36;47m"„CONST WhtCyn = "\[0;37;46m", WhtWht = "\[0;37;47m"„„'Hi-Intensity foreground and background colors„CONST BrtBlkBlk = "\[1;30;40m", BrtBlkRed = "\[1;30;41m", BrtBlkGrn = "\[1;30;42„CONST BrtRedBlk = "\[1;31;40m", BrtRedRed = "\[1;31;41m", BrtRedGrn = "\[1;31;42„CONST BrtGrnBlk = "\[1;32;40m", BrtGrnRed = "\[1;32;41m", BrtGrnGrn = "\[1;32;42„CONST BrtYelBlk = "\[1;33;40m", BrtYelRed = "\[1;33;41m", BrtYelGrn = "\[1;33;42„CONST BrtBluBlk = "\[1;34;40m", BrtBluRed = "\[1;34;41m", BrtBluGrn = "\[1;34;42„CONST BrtMagBlk = "\[1;35;40m", BrtMagRed = "\[1;35;41m", BrtMagGrn = "\[1;35;42„CONST BrtCynBlk = "\[1;36;40m", BrtCynRed = "\[1;36;41m", BrtCynGrn = "\[1;36;42„CONST BrtWhtBlk = "\[1;37;40m", BrtWhtRed = "\[1;37;41m", BrtWhtGrn = "\[1;37;42„„CONST BrtBlkYel = "\[1;30;43m", BrtBlkBlu = "\[1;30;44m", BrtBlkMag = "\[1;30;45„CONST BrtRedYel = "\[1;31;43m", BrtRedBlu = "\[1;31;44m", BrtRedMag = "\[1;31;45„CONST BrtGrnYel = "\[1;32;43m", BrtGrnBlu = "\[1;32;44m", BrtGrnMag = "\[1;32;45„CONST BrtYelYel = "\[1;33;43m", BrtYelBlu = "\[1;33;44m", BrtYelMag = "\[1;33;45„CONST BrtBluYel = "\[1;34;43m", BrtBluBlu = "\[1;34;44m", BrtBluMag = "\[1;34;45„CONST BrtMagYel = "\[1;35;43m", BrtMagBlu = "\[1;35;44m", BrtMagMag = "\[1;35;45„CONST BrtCynYel = "\[1;36;43m", BrtCynBlu = "\[1;36;44m", BrtCynMag = "\[1;36;45„CONST BrtWhtYel = "\[1;37;43m", BrtWhtBlu = "\[1;37;44m", BrtWhtMag = "\[1;37;45„„CONST BrtBlkCyn = "\[1;30;46m", BrtBlkWht = "\[1;30;47m"„CONST BrtRedCyn = "\[1;31;46m", BrtRedWht = "\[1;31;47m"„CONST BrtGrnCyn = "\[1;32;46m", BrtGrnWht = "\[1;32;47m"„CONST BrtYelCyn = "\[1;33;46m", BrtYelWht = "\[1;33;47m"„CONST BrtBluCyn = "\[1;34;46m", BrtBluWht = "\[1;34;47m"„CONST BrtMagCyn = "\[1;35;46m", BrtMagWht = "\[1;35;47m"„CONST BrtCynCyn = "\[1;36;46m", BrtCynWht = "\[1;36;47m"„CONST BrtWhtCyn = "\[1;37;46m", BrtWhtWht = "\[1;37;47m"„„CONST Clr = "\[2J"„Quinn Tyler Jackson            ANSI.SYS DETECTION             ANSI.SYS,DETECTION             Unknown Date (00:00)   QB, PDS                34   592      CHKANSI.BAS DECLARE FUNCTION ChkANSI% ()„'$INCLUDE: 'qb.bi'„ „DEFINT A-Z„ „CONST FALSE = 0„CONST TRUE = NOT FALSE„ „ „DIM SHARED InReg AS RegType„DIM SHARED OutReg AS RegType„ „SELECT CASE ChkANSI„        CASE TRUE„                PRINT "ANSI.SYS installed!"„        CASE FALSE„                PRINT "ANSI.SYS not installed!"„END SELECT„ „FUNCTION ChkANSI„ „InReg.AX = &H1A00„Interrupt &H2F, InReg, OutReg„ „SELECT CASE OutReg.AX MOD 256„        CASE 0„                temp = FALSE„        CASE 255„                temp = TRUE„END SELECT„ „ChkANSI = temp„ „END FUNCTION„John Sneeringer                AUTO-ANSI SENSOR               AUTO,ANSI,SENSOR               Year of 1992 (00:00)   QB, QBasic, PDS        24   514      AUTOANSI.BASDEFINT A-Z„DECLARE SUB ansi.det (ansi%)„„' ===============================================„' Auto-ANSI Sensor by John Sneeringer, HPS 1992„' ===============================================„„SUB ansi.det (ansi%)„„PRINT #1, CHR$(27) + "[6n";   ' send code„„FOR X = 1 TO 2                ' pause for like 2 seconds„  A$ = TIME$„  DO: LOOP UNTIL A$ <> TIME$„NEXT X„„IF LOC(1) > 1 THEN„  IF LEFT$(INPUT$(1, 2), 2) = CHR$(27) + "[" THEN„    ansi% = 1„  ELSE„    ansi% = 0„  END IF„END IF„END SUB„Jim Morey                      ANSI COLORS                    ANSI,COLORS                    12/28/92 (00:00)       PDS, VBDOS             169  5585     ANSICOLR.BAS'ANSI color printing example 1„'„'The screen must be opened as a file for output and printed to.„'BASIC's PRINT statement prints directly, thus bypassing ANSI.SYS.„'„'Another point to note: A standard (of your choosing) must be„'established when combining various ANSI options.  The order of the„'colors and highlighting codes is unimportant, so long as the sequence„'begins with the escape and ends with the 'm' and is separated by a„';'.„'The standard chosen below is to insert the highlighting codes between„'the escape and the colors, with the colors containing the 'm'„'parameter, and the highlighting codes containing the ';' separator.„'Your milage may vary.„„DECLARE SUB printchar (char$)„„esc$ = CHR$(27) + "["„„normal$ = "0m"„blinking$ = "5;"„bold$ = "1;"„„red$ = "31m"„green$ = "32m"„yellow$ = "33m"„blue$ = "34m"„magenta$ = "35m"„cyan$ = "36m"„white$ = "37m"„„OPEN "O", #1, "cons:"„„CLS„PRINT #1, esc$ + red$ + "red"„PRINT #1, esc$ + green$ + "green"„PRINT #1, esc$ + yellow$ + "yellow"„PRINT #1, esc$ + blue$ + "blue"„PRINT #1, esc$ + magenta$ + "magenta"„PRINT #1, esc$ + cyan$ + "cyan"„PRINT #1, esc$ + white$ + "white"„PRINT #1, esc$ + normal$ + "normal"„PRINT #1,„„PRINT #1, esc$ + bold$ + red$ + "bold red"„PRINT #1, esc$ + bold$ + green$ + "bold green"„PRINT #1, esc$ + bold$ + yellow$ + "bold yellow"„PRINT #1, esc$ + bold$ + blue$ + "bold blue"„PRINT #1, esc$ + bold$ + magenta$ + "bold magenta"„PRINT #1, esc$ + bold$ + cyan$ + "bold cyan"„PRINT #1, esc$ + bold$ + white$ + "bold white"„PRINT #1, esc$ + normal$ + "normal"„PRINT #1,„PRINT #1, "Press a key..."„dummy$ = INPUT$(1)„„CLS„PRINT #1, esc$ + blinking$ + red$ + "blinking red"„PRINT #1, esc$ + blinking$ + green$ + "blinking green"„PRINT #1, esc$ + blinking$ + yellow$ + "blinking yellow"„PRINT #1, esc$ + blinking$ + blue$ + "blinking blue"„PRINT #1, esc$ + blinking$ + magenta$ + "blinking magenta"„PRINT #1, esc$ + blinking$ + cyan$ + "blinking cyan"„PRINT #1, esc$ + blinking$ + white$ + "blinking white"„PRINT #1, esc$ + normal$ + "normal"„PRINT #1,„„PRINT #1, esc$ + bold$ + blinking$ + red$ + "bold blinking red"„PRINT #1, esc$ + bold$ + blinking$ + green$ + "bold blinking green"„PRINT #1, esc$ + bold$ + blinking$ + yellow$ + "bold blinking yellow"„PRINT #1, esc$ + bold$ + blinking$ + blue$ + "bold blinking blue"„PRINT #1, esc$ + bold$ + blinking$ + magenta$ + "bold blinking magenta"„PRINT #1, esc$ + bold$ + blinking$ + cyan$ + "bold blinking cyan"„PRINT #1, esc$ + bold$ + blinking$ + white$ + "bold blinking white"„PRINT #1, esc$ + normal$ + "normal"„PRINT #1,„PRINT #1, "Press a key..."„dummy$ = INPUT$(1)„„LOCATE 20, 1„END„„'ANSI color printing example 2„'„'Another method of interfacing with ANSI.SYS is to use the DOS function„„'21/02.  This function will print one character at a time to the screen.„'A function to print an entire string is also available, but this„'example uses a secondary sub to parse the string and pass it to the„'first sub.„„cr$ = CHR$(13) + CHR$(10)„„esc$ = CHR$(27) + "["„„normal$ = "0m"„blinking$ = "5;"„bold$ = "1;"„„red$ = "31m"„green$ = "32m"„yellow$ = "33m"„blue$ = "34m"„magenta$ = "35m"„cyan$ = "36m"„white$ = "37m"„„CLS„call printstring$(esc$+red$+"red"+cr$)„call printstring$(esc$+green$+"green"+cr$)„call printstring$(esc$+yellow$+"yellow"+cr$)„call printstring$(esc$+blue$+"blue"+cr$)„call printstring$(esc$+magenta$+"magenta"+cr$)„call printstring$(esc$+cyan$+"cyan"+cr$)„call printstring$(esc$+white$+"white"+cr$)„call printstring$(esc$+normal$+"normal"+cr$)„call printstring$(cr$)„„call printstring$(esc$+bold$+red$+"bold red"+cr$)„call printstring$(esc$+bold$+green$+"bold green"+cr$)„call printstring$(esc$+bold$+yellow$+"bold yellow"+cr$)„call printstring$(esc$+bold$+blue$+"bold blue"+cr$)„call printstring$(esc$+bold$+magenta$+"bold magenta"+cr$)„call printstring$(esc$+bold$+cyan$+"bold cyan"+cr$)„call printstring$(esc$+bold$+white$+"bold white"+cr$)„call printstring$(esc$+normal$+"normal"+cr$)„call printstring$(cr$)„call printstring$("Press a key..."+cr$)„dummy$ = INPUT$(1)„„CLS„call printstring$(esc$+blinking$+red$+"blinking red"+cr$)„call printstring$(esc$+blinking$+green$+"blinking green"+cr$)„call printstring$(esc$+blinking$+yellow$+"blinking yellow"+cr$)„call printstring$(esc$+blinking$+blue$+"blinking blue"+cr$)„call printstring$(esc$+blinking$+magenta$+"blinking magenta"+cr$)„call printstring$(esc$+blinking$+cyan$+"blinking cyan"+cr$)„call printstring$(esc$+blinking$+white$+"blinking white"+cr$)„call printstring$(esc$+normal$+"normal"+cr$)„call printstring$(cr$)„„call printstring$(esc$+bold$+blinking$+red$+"bold blinking red"+cr$)„call printstring$(esc$+bold$+blinking$+green$+"bold blinking green"+cr$)„call printstring$(esc$+bold$+blinking$+yellow$+"bold blinking yellow"+cr$)„call printstring$(esc$+bold$+blinking$+blue$+"bold blinking blue"+cr$)„call printstring$(esc$+bold$+blinking$+magenta$+"bold blinking magenta"+cr$) ** EDITOR WRAPPED **„call printstring$(esc$+bold$+blinking$+cyan$+"bold blinking cyan"+cr$)„call printstring$(esc$+bold$+blinking$+white$+"bold blinking white"+cr$)„call printstring$(esc$+normal$+"normal"+cr$)„call printstring$(cr$)„call printstring$("Press a key..."+cr$)„dummt$ = INPUT$(1)„„LOCATE 20, 1„END„„SUB printchar (char$)„  reg 1, &H200„  reg 4, ASC(char$)„  call interrupt &h21„END SUB„„SUB printstring (temp$)„  FOR i = 1 TO LEN(temp$)„      t$ = MID$(temp$, i, 1)„      CALL printchar(t$)„  NEXT i„END SUB„„Unknown Author(s)              ANSI VIEWER                    ANSI,VIEWER                    Unknown Date           QB, QBasic, PDS        82   3005     CANSI.BAS   ''''' -=*=--=*=--=*=-  begin CANSI.BAS  -=*=--=*=--=*=-„DECLARE SUB ansi (a$)„ON ERROR GOTO botched„DEF SEG = &HB800: DIM SHARED SCR%(2): SCR%(1) = 80: SCR%(2) = 25„WIDTH 80, 25: F$ = COMMAND$: COLOR 7, 0: CLS„IF F$ = "" THEN INPUT "File to display"; F$„OPEN F$ FOR INPUT AS #1„WHILE NOT EOF(1): ansi (INPUT$(1, #1)): WEND: CLOSE #1„fini: COLOR 2, 0: FOR S% = 5 TO 35: SOUND S% * 200, .1: NEXT„   R$ = "": WHILE R$ = "": R$ = INKEY$: WEND: END„botched: COLOR 2, 0„   PRINT "file "; CHR$(34); F$; CHR$(34); " not found"„   PRINT "error"; ERR: RESUME fini„''''' -=*=--=*=--=*=-  end CANSI.BAS  -=*=--=*=--=*=-„„SUB ansi (a$)„DEFINT A-Z: STATIC H, W, R, E, L, C, F, B, O, V, E$„IF W < 40 THEN W = SCR%(1): H = SCR%(2) - 1: R = W - 1: C = 0: F = 7: B = 0„IF E <> 27 THEN„   IF ASC(a$) <> 27 THEN GOSUB CHRout:  ELSE E = 27: E$ = a$„   EXIT SUB„END IF„IF O <> 27 AND ASC(a$) = 34 THEN O = E: EXIT SUB„IF O = 27 THEN„   IF ASC(a$) = 34 THEN O = 0„   EXIT SUB„END IF: E$ = E$ + a$„IF LEN(E$) = 2 AND a$ <> "[" THEN E = 0: E$ = "": EXIT SUB„S = INSTR("HfABCDsuJKmhlp", a$)„SELECT CASE S„  CASE 0: EXIT SUB„  CASE 1: GOSUB CursorA„  CASE 2: GOSUB CursorA„  CASE 3: L = -1: GOSUB CursorL„  CASE 4: L = 1: GOSUB CursorL„  CASE 5: L = 1: GOSUB CursorC„  CASE 6: L = -1: GOSUB CursorC„  CASE 7: V = C„  CASE 8: C = V„  CASE 9: CLS : C = 0„  CASE 10: L = C: WHILE L MOD W <> 0: POKE L * 2, 32: L = L + 1: WEND„  CASE 11: GOSUB Colorz„END SELECT: E% = 0: E$ = "": EXIT SUB„CursorA: L = VAL(MID$(E$, INSTR(E$, "[") + 1)) - 1„   C = VAL(MID$(E$, INSTR(E$, ";") + 1)) - 1„   IF C < 0 THEN C = 0:  ELSE IF C > R THEN C = R„   IF L < 1 THEN L = 0:  ELSE IF L > H THEN L = H„   C = L * W + C: RETURN„CursorL: P = VAL(MID$(E$, INSTR(E$, "[") + 1)): IF P < 1 THEN P = 1„   L = INT(C / W) + P * L„   IF L < 0 THEN L = 0:  ELSE IF L > H THEN L = H„   C = (C MOD W) + L * W: RETURN„CursorC: P = VAL(MID$(E$, INSTR(E$, "[") + 1)): IF P < 1 THEN P = 1„   L = (C MOD W) + P * L: C = INT(C / W) * W„   IF L < 1 THEN L = 0:  ELSE IF L > R THEN L = R„   C = C + L: RETURN„Colorz: E$ = MID$(E$, INSTR(E$, "[") + 1)„  DO: E = VAL(E$)„  SELECT CASE E„     CASE 0: F = 7: B = 0„     CASE 1: F = (F AND 7) OR 8„     CASE 5: B = (B AND 7) OR 8„     CASE 8: F = B„     CASE 30 TO 37: P = E - 29: E = ASC(MID$("@DBFAECG", P)) AND 7„                    F = (F AND 248) OR E„     CASE 40 TO 47: P = E% - 39: E = ASC(MID$("@DBFAECG", P)) AND 7„                    B = (B AND 248) OR E„  END SELECT: P = INSTR(E$, ";"): E$ = MID$(E$, P + 1): LOOP WHILE P > 0„COLOR F, B: RETURN„CHRout: P = ASC(a$)„   IF P = 7 THEN BEEP: RETURN„   IF P = 13 THEN C = C - C MOD W: RETURN„   IF P = 10 THEN C = C + W„   IF P <> 10 THEN POKE C * 2, P: POKE C * 2 + 1, F + 16 * B: C = C + 1„   IF C >= W * (H + 1) THEN„      C = C - W: LOCATE H + 1, W: PRINT„      P = W * 2: L = (H - 1) * P„      FOR L = L TO L + P: POKE L, PEEK(L + P): POKE L + P, B: NEXT„   END IF„   RETURN„END SUB„„Jamshid Khoshrangi             PB ANSI-DRIVER                 qjackson@direct.ca             Year of 1993/95        PB                     1165 27347    LANSI_31.BAS$IF 0„„  LANSI.BAS               The FSA ANSI-Driver             LANSI.BAS„„                              Laleh's ANSI„„                              Version  3.1„„                LANSI.BAS is now PowerBASIC Compatible!„„        Written by Jamshid Khoshrangi (aka "Quinn Tyler Jackson")„„   Copyright (C)1993,95 by AhuraMazda(tm) Software.  ALL RIGHTS RESERVED.„„„  USAGE RIGHTS:„„  Although Jamshid Khoshrangi reserves all rights to LANSI.BAS, he grants„  others the right to use it in whole or in part as long as any product„  that uses it explicitly includes in its documentation or opening screen„  (this left to the discretion of the individual programmer) the notice:„„       "ANSI emulation provided by Laleh's ANSI (C)1993,95 by AMS."„„  DEDICATION:„„  This driver is dedicated to my wife Laleh, who has tolerated my sitting„  at a yucky computer terminal for thousands of hours with little or no„  direct return to her.„„  UPDATE NOTES:„„  UPDATE NOTES: (10 SEP 95)„„  I have upgraded LANSI to version 3.0 from version 2.0, and it is„  now compatible 100% with PowerBASIC 3.x.  The upgrade consisted„  mainly of changing a few dozen CONST x statements to %x, and the„  like, as well as using INCR x and DECR x instead of x = x + 1„  and x = x - 1.  During the upgrade, I discovered a few insidious„  glitches in some routines, which I have fixed....„„  TECHNICAL NOTES: (31 OCT 93)„„  LANSI.BAS was written as an exercise in my investigation into the„  the complexities of Finite State Automata (FSA's).  ANSI graphics„  are particularly suitable to an FSA model, since they rely on a finite„  set of commands and use a type of Reverse Polish Notation (RPN).„  Reverse Polish Notation lends itself amazingly well to efficient„  implementations of Finite State systems.„„  This driver includes non-ANSI "ANSI" music support, but this support„  can be turned off by setting the global variable GV.Music is set to„  %FALSE (0).  With this variable set to %FALSE, LANSI treats music strings„  in exactly the same manner a typical ANSI.SYS driver would: it prints„  them to the screen.  This option has been added for ANSI purists.  I have„  yet to call a BBS with such music anyway, but hey, why not have it all?„„  Note that the music supported here can be full background.  A 6.5 minute„  song can be downloaded as a series of music sequences in about 5 seconds„  and then played over then next 6.5 minutes in the background on a typical„  2400 baud modem using the system I have implemented here.  This system„  buffers up to 200 "lines" of music sequences.  Many terminals don't allow„  full background music, since they are not written in BASIC and therefore„  have to emulate the PLAY metalanguage.  BASIC has direct access to„  "MB", so this is no problem if double-buffering is used.„„  Also, LANSI.BAS supports a subset of the ANSI keyboard redefinition„  capabilities, unlike many other ANSI emulators that totally ignore„  this part of the ANSI standard.  Support for keyboard redefinition can„  be toggled on and off as well.  The only two formats allowed are:„„    ESC[{old_ascii_val};"some string"p„    ESC[{old_ascii_val};{new_ascii_val}p„„  Since keyboard redefinition is limited to the emulator, there is„  absolutely no chance of so-called ANSI bombs slipping past LANSI and„  into the DOS prompt.„„  This code is, for the most part, raw and undocumented.  I've done the„  hard coding; it's up to you to figure out what I've done.  My belief„  is simple in this regard:  if I cannot decipher the code without„  detailed English comments and remarks, then I probably should NOT„  be changing the code!„„  If you can understand the raw code, then you might want to go and„  tweak it.  I've found that I do best to leave code I don't "quite"„  understand well-enough-alone.  Be warned that FSA systems are quick,„  but prone to nastiness when incorrectly tweaked.  That's the nature„  of the finite state paradigm.„„  Also, you will notice the term "VisiPlex" from time to time.  Just„  ignore it.  This will follow much later, and is included in„  LANSI.BAS just for future compatibility.„„  I sincerely hope you find LANSI.BAS useful!„„  Jamshid Khoshrangi (aka "Quinn Tyler Jackson")„„$ENDIF„„%DEBUG = 0„„$IF %DEBUG„    $COMPILE MEMORY„    $CPU 80386„$ELSE„    $CODE SEG "AHURAMAZDA"„    $COMPILE UNIT "LANSI.PBU"„    $CPU 8086„$ENDIF„„$OPTIMIZE SPEED„„%TRUE   = -1„%FALSE  = NOT %TRUE„„DEFINT A-Z„„TYPE GlobalVarType„    STATE           AS INTEGER      ' What state is the FSA in?„„    X               AS INTEGER      ' Cursor ROW„    Y               AS INTEGER      ' Cursor COLUMN„    OldX            AS INTEGER      ' For saving ROW with $e[s„    OldY            AS INTEGER      ' For saving COLUMN with $e[s„    RemoteX         AS INTEGER      ' The remote's ROW„    RemoteY         AS INTEGER      ' The remote's COLUMN„„    ScreenHeight    AS INTEGER      ' What is the height of our screen?„    ScreenWidth     AS INTEGER      ' What is the width of our screen?„„    Bold            AS INTEGER      ' Bold attribute„    Blink           AS INTEGER      ' Blink attribute„    Reversed        AS INTEGER      ' Reversed attribute„    Concealed       AS INTEGER      ' Concealed attribute„„    DesBackspace    AS INTEGER      ' Set to %TRUE if <BACKSPACE>„                                    '     is destructive„„    ExpandTab       AS INTEGER      ' Set to %TRUE if <TAB> is expanded„    TabStep         AS INTEGER      ' Number of spaces to expand 1 tab„    LineWrap        AS INTEGER      ' Set to %TRUE if in linewrap mode„    CursorVis       AS INTEGER      ' Set to 1 if cursor is visible„    Music           AS INTEGER      ' Set to %FALSE if in ANSI only mode„    Speaker         AS INTEGER      ' Set to %FALSE if sound turned off„    BeepHz          AS INTEGER      ' Beep tone in Hertz„    BeepDur         AS INTEGER      ' Duration of Beep in ticks„„    MapActive       AS INTEGER„„    ForeColor       AS INTEGER„    BackColor       AS INTEGER„    ColorAttr       AS INTEGER„„    ScreenSeg       AS INTEGER      ' For direct screen writes„„    SavedFlag       AS INTEGER      ' Has a $e[s been previously executed?„„    VisiPlex        AS INTEGER      ' Are we in VisiPlex mode„    VisiVersion     AS INTEGER      ' If so, what is version of other?„END TYPE„„%LOW.LEVEL  = %FALSE„%HIGH.LEVEL = %TRUE„„%ANSI.F.BLACK       = 30„%ANSI.F.RED         = 31„%ANSI.F.GREEN       = 32„%ANSI.F.YELLOW      = 33„%ANSI.F.BLUE        = 34„%ANSI.F.MAGENTA     = 35„%ANSI.F.CYAN        = 36„%ANSI.F.WHITE       = 37„%ANSI.B.BLACK       = 40„%ANSI.B.RED         = 41„%ANSI.B.GREEN       = 42„%ANSI.B.YELLOW      = 43„%ANSI.B.BLUE        = 44„%ANSI.B.MAGENTA     = 45„%ANSI.B.CYAN        = 46„%ANSI.B.WHITE       = 47„„%STATE.NORMAL           = 0„%STATE.READ.ESC         = 1„%STATE.IN.ANSI          = 2„%STATE.IN.INT.PARAM     = 3„%STATE.READ.SEMICOLON   = 4„%STATE.READ.ANSI.COMMAND= 5„„%STATE.READ.OPEN.QUOTE  = 6„%STATE.IN.STRING.LITERAL= 7„%STATE.READ.CLOSE.QUOTE = 8„%STATE.READ.CONTROL.CODE= 9„%STATE.ERROR.RESET.ANSI = 10„„%STATE.IN.MUSIC         = 11„„%STATE.INTEGER.PUSH     = 12   ' push integer to integer stack„%STATE.STRING.PUSH      = 13   ' push string to string stack„„'   TOKEN TYPES:„    '„    '   e = ESC„%TOKEN.ESC          = 1„    '   [ = [„%TOKEN.BRACKET      = 2„    '   0 = 0,1,2,3,4,5,6,7,8,9„%TOKEN.DIGIT        = 3„    '   ; = ;„%TOKEN.SEMICOLON    = 4„    '   H = H,f,A,B,C,D,s,u,J,K,m,h,l,p,n„%TOKEN.ANSI.COMMAND = 5„    '   " = "„%TOKEN.QUOTE        = 6„    '   < = ASCII code less than 32„%TOKEN.CONTROL.CODE = 7„    '   A = Standard A-Z„%TOKEN.ASCII        = 8„    '   M = M„%TOKEN.MUSIC.STRING.START = 9„    '   # = ^N„%TOKEN.ANSI.MUSIC   = 10„„TokenTableData:„„'        ASCII   Type     ASCII   Type„„DATA      "",    01,      "[",    02„DATA      "0",    03,      "1",    03„DATA      "2",    03,      "3",    03„DATA      "4",    03,      "5",    03„DATA      "6",    03,      "7",    03„DATA      "8",    03,      "9",    03„DATA      ";",    04,      "H",    05„DATA      "f",    05,      "A",    05„DATA      "B",    05,      "C",    05„DATA      "D",    05,      "s",    05„DATA      "u",    05,      "J",    05„DATA      "K",    05,      "m",    05„DATA      "h",    05,      "l",    05„DATA      "p",    05,      "R",    05„DATA      "n",    05,      "",    10„DATA      "M",    09,      "",    07„DATA      " ",    08,      "",    07„DATA      "",    07,      "",    07„DATA      "",    07,      "",    07„DATA      "",    07       "",     -1„„StateShiftTableData:„„' WARNING:„'„'   Any tweaking of this table may be FATAL to the working„'   of this driver!  Unless you ABSOLUTELY understand what„'   you are doing, please DO NOT twiddle these bits!„„'            e   [   0   ;   H   "   <   A   M   #„DATA   00,  01, 00, 00, 00, 00, 00, 09, 00, 00, 00„DATA   01,  00, 02, 00, 00, 00, 00, 00, 00, 00, 00„DATA   02,  00, 10, 03, 04, 05, 06, 10, 10, 11, 10„DATA   03,  10, 10, 03, 12, 05, 10, 10, 10, 10, 10„DATA   04,  10, 10, 12, 10, 10, 06, 10, 10, 10, 10„DATA   06,  07, 07, 07, 07, 07, 08, 07, 07, 07, 10„DATA   07,  07, 07, 07, 07, 07, 08, 07, 07, 07, 07„DATA   08,  10, 10, 10, 11, 05, 10, 10, 10, 10, 10„DATA   09,  01, 00, 00, 00, 00, 00, 09, 00, 00, 00„DATA   11,  10, 10, 11, 10, 11, 10, 10, 11, 11, 05„„$IF %DEBUG„    DIM AnsiGv AS SHARED GlobalVarType„$ELSE„    DIM AnsiGv AS SHARED GlobalVarType„    EXTERNAL AnsiGv„$ENDIF„„DIM TokenTable(255)     AS SHARED INTEGER„DIM StateTable(13, 10)  AS SHARED INTEGER„DIM KeyTable(255)       AS SHARED STRING„DIM MapActive(255)      AS SHARED INTEGER„„DIM CharBuffer          AS SHARED STRING„DIM IntStack(10)        AS SHARED INTEGER„DIM StrStack(10)        AS SHARED STRING„DIM IntPtr              AS SHARED INTEGER„DIM StringPtr           AS SHARED INTEGER„„DIM MusicBuffer(200)    AS SHARED STRING„DIM BarPtr              AS SHARED INTEGER„DIM TopPtr              AS SHARED INTEGER„„'   DEBUG CODE STARTS HERE!„„$IF %DEBUG„„LansiSystemInit„„CLS„„OPEN "C:\DOS\TRM\UTILS\TERMINAT.LGO" FOR BINARY AS #1„„GET$ #1, LOF(1), Test$„„CLOSE #1„„FOR i = 1 TO LEN(Test$)„„    LansiByteInterpret ASC(MID$(Test$, i, 1))„„NEXT i„„DO„„LOOP UNTIL LEN(INKEY$)„„$ENDIF„„END„„'DEBUG CODE ENDS HERE!„„MusicHandler:„    INCR BarPtr„    INCR TotChar, LEN(MusicBuffer(BarPtr))„„    SELECT CASE BarPtr„        CASE 201„            BarPtr = 1„„        CASE TopPtr„            PLAY "MF" + MusicBuffer(BarPtr)„            OverFlag = %TRUE„            BarPtr = 0„            TopPtr = 0„            PLAY OFF„„    END SELECT„„    IF TopPtr > 1 THEN„        PLAY MusicBuffer(BarPtr)„    END IF„„    MusicBuffer(BarPtr) = ""„„RETURN  ' From MusicHandler:„„SUB LansiSystemInit () PUBLIC„„    StateTableInit„    TokenTableInit„„END SUB„„SUB BarPush (Score AS STRING)„„INCR TopPtr„„IF TopPtr = 201 THEN„    NotFirst = %TRUE„    TopPtr = 1„END IF„„MusicBuffer(TopPtr) = Score„„IF TopPtr = 1 AND NOT NotFirst THEN„    PLAY "MBT255N0N0N0T120"„END IF„„END SUB„„SUB ControlCodeReact (code AS INTEGER)„„%CONT.CTRL.D    = 4„%CONT.CTRL.E    = 5„%CONT.CTRL.G    = 7„%CONT.BACKSPACE = 8„%CONT.TAB       = 9„%CONT.PAGEFEED  = 12„%CONT.CTRL.S    = 19„%CONT.CTRL.X    = 24„„SELECT CASE code„    CASE %CONT.CTRL.E„        CursorUp 1„„    CASE %CONT.CTRL.X„        CursorDown 1„„    CASE %CONT.CTRL.D„        CursorRight 1„„    CASE %CONT.CTRL.S„        CursorLeft 1„„    CASE %CONT.CTRL.G„        IF AnsiGv.Speaker THEN„            SOUND AnsiGv.BeepHz, AnsiGv.BeepDur„        END IF„„    CASE %CONT.PAGEFEED„        LansiScreenClear„   „    CASE %CONT.BACKSPACE„        IF AnsiGv.DesBackspace THEN„            IF AnsiGv.Y > 1 THEN„                DECR AnsiGv.Y„                CursorLocate AnsiGv.X, AnsiGv.Y„                sqjPRINT 32, %HIGH.LEVEL' Print a space„                DECR AnsiGv.Y„                CursorLocate AnsiGv.X, AnsiGv.Y„            END IF„        END IF„„    CASE %CONT.TAB„        IF AnsiGv.ExpandTab THEN„            IF AnsiGv.Y + AnsiGv.TabStep < 79 THEN„                FOR i = 1 TO AnsiGv.TabStep„                    sqjPRINT 32, %LOW.LEVEL„                NEXT i„            END IF„        ELSE„            sqjPRINT 32, %HIGH.LEVEL„        END IF„END SELECT„„END SUB„„SUB CursorDown (RowsDown AS INTEGER)„„IF IntPtr = 0 THEN„    RowsDown = 1„END IF„„TempX = AnsiGv.X + RowsDown„„IF TempX > AnsiGv.ScreenHeight THEN„    TempX = AnsiGv.ScreenHeight„END IF„„AnsiGv.X = TempX„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB CursorLeft (ColsLeft AS INTEGER)„„IF IntPtr = 0 THEN„    ColsLeft = 1„END IF„„TempY = AnsiGv.Y - ColsLeft„IF TempY < 1 THEN„    TempY = 1„END IF„„AnsiGv.Y = TempY„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB CursorLocate (X AS INTEGER,_„                     Y AS INTEGER)„„IF Y > AnsiGv.ScreenWidth THEN„    Y = 1„    IF AnsiGv.LineWrap THEN„        INCR X„    END IF„ELSE„    IF Y < 1 THEN„        Y = 1„    END IF„END IF„„IF X > AnsiGv.ScreenHeight THEN„    EXIT SUB„ELSE„    IF X < 1 THEN„        X = 1„    END IF„END IF„„AnsiGv.X = X„AnsiGv.Y = Y„„IF AnsiGv.CursorVis THEN„    LOCATE AnsiGv.X, AnsiGv.Y, AnsiGv.CursorVis, 6, 7„END IF„„END SUB„„SUB CursorRestore„„IF AnsiGv.SavedFlag THEN„    CursorLocate AnsiGv.OldX, AnsiGv.OldY„END IF„„END SUB„„SUB CursorRight (ColsRight AS INTEGER)„„IF IntPtr = 0 THEN„    ColsRight = 1„END IF„„TempY = AnsiGv.Y + ColsRight„IF TempY > AnsiGv.ScreenWidth THEN„    TempY = AnsiGv.ScreenWidth„END IF„„AnsiGv.Y = TempY„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB CursorSave„„AnsiGv.SavedFlag = %TRUE„„AnsiGv.OldX = AnsiGv.X„AnsiGv.OldY = AnsiGv.Y„„END SUB„„SUB CursorUp (RowsUp AS INTEGER)„„IF IntPtr = 0 THEN„    RowsUp = 1„END IF„„TempX = AnsiGv.X - RowsUp„„IF TempX < 1 THEN„    TempX = 1„END IF„   „AnsiGv.X = TempX„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB EOLErase„„CursorSave„„CursorVis = AnsiGv.CursorVis„AnsiGv.CursorVis = %FALSE„„FOR Ptr = AnsiGv.Y TO AnsiGv.ScreenWidth„    sqjPRINT 0, %LOW.LEVEL„NEXT Ptr„„AnsiGv.CursorVis = CursorVis„CursorRestore„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB IntPush„„IF LEN(CharBuffer) THEN„    INCR IntPtr„    IntStack(IntPtr) = VAL(CharBuffer)„    CharBuffer = ""„END IF„„END SUB„„SUB KeyboardMap (KeyCode AS INTEGER,_„                    Redefinition AS STRING)„„SELECT CASE KeyCode„    CASE 8474   ' Not a key!  This is the VisiPlex flag!„                ' "8474" is "VISI" dialed on a phone...„„        IF LEFT$(Redefinition, 10) = "VisiPlex V" THEN„            AnsiGv.VisiPlex = %TRUE„            AnsiGv.MapActive = %FALSE„            AnsiGv.VisiVersion = VAL(MID$(Redefinition, 11))„        END IF„„    CASE ELSE„        SELECT CASE AnsiGv.VisiPlex„            CASE %TRUE„                VisiPlexComReact KeyCode, Redefinition„„            CASE %FALSE„                IF KeyCode < 256 THEN„                    KeyTable(KeyCode) = Redefinition„                    MapActive(KeyCode) = %TRUE„                END IF„„        END SELECT„END SELECT„„END SUB„„SUB LinewrapDisable„„AnsiGv.LineWrap = %FALSE„„END SUB„„SUB MusicPlay (Score AS STRING)„„SELECT CASE AnsiGv.Music„    CASE %TRUE„        IF AnsiGv.Speaker THEN„            sqjPLAY Score„        END IF„„    CASE %FALSE„        FOR i = 1 TO LEN(Score)„            sqjPRINT ASC(MID$(Score, i, 1)), %LOW.LEVEL„        NEXT i„        sqjPRINT 14, %LOW.LEVEL„„END SELECT„„END SUB„„SUB sqjPLAY (Score AS STRING)„„Score = UCASE$(MID$(Score,2))„„SELECT CASE INSTR(Score, "MB")„    CASE 0„        PLAY Score„„    CASE ELSE„        ON PLAY(3) GOSUB MusicHandler„        PLAY ON„        BarPush Score„„END SELECT„„END SUB„„SUB sqjPRINT (Bite AS INTEGER,_„              Level AS INTEGER)„„SELECT CASE Level * MapActive(Bite) * AnsiGv.MapActive„    CASE 0„        SELECT CASE Bite„            CASE 13„                AnsiGv.Y = 1„„            CASE 10„                IF AnsiGv.X < AnsiGv.ScreenHeight THEN„                    INCR AnsiGv.X„                ELSE„                    '   This forces a screen scroll„                    LOCATE AnsiGv.ScreenHeight + 1, 1„                    PRINT„                END IF„„            CASE ELSE„                FPRINT Bite„                INCR AnsiGv.Y„„        END SELECT„„    CASE ELSE„        FOR i = 1 TO LEN(KeyTable(Bite))„            sqjPRINT ASC(MID$(KeyTable(Bite), i, 1)), %LOW.LEVEL„        NEXT i„„END SELECT„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB RemoteCursorSet (X AS INTEGER,_„                        Y AS INTEGER)„„'   This information is mostly useless, and is received as„'   a result of sending a ESC[6n sequence....„„AnsiGv.RemoteX = X„AnsiGv.RemoteY = Y„„END SUB„„SUB ScreenAttrReact ()„„SELECT CASE AnsiGv.Reversed„    CASE %TRUE„        TempFore = AnsiGv.BackColor„        TempBack = AnsiGv.ForeColor„„    CASE %FALSE„        TempFore = AnsiGv.ForeColor„        TempBack = AnsiGv.BackColor„„END SELECT„„IF AnsiGv.Bold THEN„    TempFore = TempFore + 8„END IF„„IF AnsiGv.Concealed THEN„    TempFore = TempBack„    '   Version 3.1 fix... turns off cursor by force„    LOCATE , , 0„ELSE„    '   Otherwise, we must turn the cursor on by force„    LOCATE , , 1„END IF„„AnsiGv.ColorAttr = TempBack * 16 + TempFore„„IF AnsiGv.Blink THEN„    BIT SET AnsiGv.ColorAttr, 7„END IF„„COLOR TempFore, TempBack„„END SUB„„SUB ScreenAttrSet (Attribute AS INTEGER)„„SELECT CASE Attribute„    CASE 0„        AnsiGv.Bold     = %FALSE„        AnsiGv.Blink    = %FALSE„        AnsiGv.Reversed = %FALSE„        AnsiGv.Concealed= %FALSE„        AnsiGv.ForeColor= 7„        AnsiGv.BackColor= 0„„    CASE 1„        AnsiGv.Bold     = %TRUE„„    CASE 5„        AnsiGv.Blink    = %TRUE„„    CASE 7„        AnsiGv.Reversed = %TRUE„„    CASE 8„        AnsiGv.Concealed= %TRUE„„    CASE %ANSI.F.BLACK„        AnsiGv.ForeColor= 0„„    CASE %ANSI.F.RED„        AnsiGv.ForeColor= 4„„    CASE %ANSI.F.GREEN„        AnsiGv.ForeColor= 2„„    CASE %ANSI.F.YELLOW„        AnsiGv.ForeColor= 6„„    CASE %ANSI.F.BLUE„        AnsiGv.ForeColor= 1„„    CASE %ANSI.F.MAGENTA„        AnsiGv.ForeColor= 5„„    CASE %ANSI.F.CYAN„        AnsiGv.ForeColor= 3„„    CASE %ANSI.F.WHITE„        AnsiGv.ForeColor= 7„„    CASE %ANSI.B.BLACK„        AnsiGv.BackColor= 0„„    CASE %ANSI.B.RED„        AnsiGv.BackColor= 4„„    CASE %ANSI.B.GREEN„        AnsiGv.BackColor= 2„„    CASE %ANSI.B.YELLOW„        AnsiGv.BackColor= 6„„    CASE %ANSI.B.BLUE„        AnsiGv.BackColor= 1„„    CASE %ANSI.B.MAGENTA„        AnsiGv.BackColor= 5„„    CASE %ANSI.B.CYAN„        AnsiGv.BackColor= 3„„    CASE %ANSI.B.WHITE„        AnsiGv.BackColor= 7„„END SELECT„„AnsiGv.ColorAttr = AnsiGv.ForeColor + AnsiGv.BackColor * 16„„END SUB„„SUB LansiScreenClear () PUBLIC„„AnsiGv.X = 1„AnsiGv.Y = 1„„COLOR AnsiGv.ForeColor, AnsiGv.BackColor„„CLS TEXT„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB ScreenModeSet (Mode AS INTEGER)„„SELECT CASE Mode„    CASE 0, 1„        ScreenWidthSet 40„„    CASE 2, 3„        ScreenWidthSet 80„„    CASE 7„        AnsiGv.LineWrap = %TRUE„„END SELECT„„END SUB„„SUB ScreenWidthSet (Columns AS INTEGER)„„WIDTH Columns, 25„„AnsiGv.ScreenWidth = Columns„„END SUB„„SUB StateReact (Bite AS INTEGER)„„SELECT CASE AnsiGv.STATE„    CASE %STATE.NORMAL„        sqjPRINT Bite, %HIGH.LEVEL„„    CASE %STATE.READ.ESC„        ' No need to "do" anything.„„    CASE %STATE.IN.ANSI„        ' No need to "do" anything.„„    CASE %STATE.IN.INT.PARAM„        CharBuffer = CharBuffer + CHR$(Bite)„„    CASE %STATE.READ.SEMICOLON„        IntPush„        AnsiGv.STATE = %STATE.IN.ANSI„        StateReact 0„„    CASE %STATE.READ.ANSI.COMMAND„        SELECT CASE CHR$(Bite)„            CASE "H", "f"„                IntPush„                SELECT CASE IntPtr„                    CASE 2„                        CursorLocate IntStack(1), IntStack(2)„„                    CASE 1„                        '   I added this during the debugging of v3.0„                        '   since I had overlooked it for some reason....„                        CursorLocate IntStack(1), 1„„                    CASE 0„                        CursorLocate 1, 1„„                END SELECT„                IntPtr = 0„„            CASE "A"„                IntPush„                CursorUp IntStack(1)„                IntPtr = 0„„            CASE "B"„                IntPush„                CursorDown IntStack(1)„                IntPtr = 0„„            CASE "C"„                IntPush„                CursorRight IntStack(1)„                IntPtr = 0„„            CASE "D"„                IntPush„                CursorLeft IntStack(1)„                IntPtr = 0„„            CASE "s"„                CursorSave„„            CASE "u"„                CursorRestore„„            CASE "J"„                IntPush„                LansiScreenClear„                IntPtr = 0„„            CASE "K"„                EOLErase„„            CASE "m"„                IntPush„                FOR Ptr = 1 TO IntPtr„                    ScreenAttrSet IntStack(Ptr)„                    '   This was moved here to fix a glitch since„                    '   [0;xxx was not read properly„                    ScreenAttrReact„                NEXT Ptr„„                IntPtr = 0„„            CASE "h"„                IntPush„                ScreenModeSet IntStack(1)„                IntPtr = 0„„            CASE "l"„                IntPush„                '   Version 3.1 fix -- all modes except 7 act as„                '   with "h" command„                SELECT CASE InStack(1)„                    CASE 7„                        LinewrapDisable„„                    CASE ELSE„                        ScreenModeSet IntStack(1)„„                END SELECT„„            CASE "p"„                IntPush„                SELECT CASE IntPtr„                    CASE 1„                        KeyboardMap IntStack(1), StrStack(1)„                        StringPtr   = 0„„                    CASE 2„                        KeyboardMap IntStack(1), CHR$(IntStack(2))„„                END SELECT„„                IntPtr      = 0„„            CASE "n"„                IntPush„                SystemReqReact IntStack(1)„                IntPtr = 0„„            CASE ""„                StringPush„                MusicPlay StrStack(1)„                StringPtr = 0„„            CASE "R"„                IntPush„                RemoteCursorSet IntStack(1), IntStack(2)„                IntPtr = 0„„        END SELECT„„        AnsiGv.STATE = %STATE.NORMAL„„    CASE %STATE.READ.OPEN.QUOTE„„    CASE %STATE.IN.STRING.LITERAL„        CharBuffer = CharBuffer + CHR$(Bite)„„    CASE %STATE.READ.CLOSE.QUOTE„        StringPush„„    CASE %STATE.READ.CONTROL.CODE„        ControlCodeReact Bite„„    CASE %STATE.ERROR.RESET.ANSI„        IntPtr      = 0„        StringPtr   = 0„        CharBuffer  = ""„        sqjPRINT Bite, %LOW.LEVEL„        AnsiGv.STATE = %STATE.NORMAL„„    CASE %STATE.IN.MUSIC„        CharBuffer = CharBuffer + CHR$(Bite)„„    CASE %STATE.INTEGER.PUSH„        IntPush„        AnsiGv.STATE = %STATE.IN.ANSI„„    CASE %STATE.STRING.PUSH„        StringPush„        AnsiGv.STATE = %STATE.IN.ANSI„„END SELECT„„END SUB„„SUB StateTableInit ()„„RESTORE StateShiftTableData„„DIM Tkn(1 TO 10)„„FOR STATE = 0 TO 10„    READ STATE„    READ Tkn(1),_„         Tkn(2),_„         Tkn(3),_„         Tkn(4),_„         Tkn(5),_„         Tkn(6),_„         Tkn(7),_„         Tkn(8),_„         Tkn(9),_„         Tkn(10)„„    FOR TokenType = 1 TO 10„        StateTable(STATE, TokenType) = Tkn(TokenType)„    NEXT„„NEXT STATE„„END SUB„„SUB StringPush„„INCR StringPtr„StrStack(StringPtr) = CharBuffer„CharBuffer = ""„„END SUB„„SUB SystemReqReact (Request AS INTEGER)„„SELECT CASE Request„    CASE 6„        ' Request cursor position!„        ' Put code here that sends cursor position in format:„        '„        '       $e[xx;yyR„„    CASE ELSE„        ' DOS's %ANSI.SYS responds just as above!„„END SELECT„„END SUB„„SUB TokenTableInit ()„„' Set some default start up values for the global system variables„' These will suffice for most purposes.„„AnsiGv.X            = 1„AnsiGv.Y            = 1„AnsiGv.ScreenWidth  = 80„AnsiGv.ScreenHeight = 24„AnsiGv.DesBackspace = %TRUE„AnsiGv.ExpandTab    = %TRUE„AnsiGv.TabStep      = 5„AnsiGv.LineWrap     = %TRUE„AnsiGv.ForeColor    = 7„AnsiGv.BackColor    = 0„AnsiGv.ColorAttr    = &H07„AnsiGv.CursorVis    = 1„AnsiGv.Music        = %TRUE„AnsiGv.Speaker      = %TRUE„AnsiGv.BeepHz       = 300„AnsiGv.BeepDur      = 3„AnsiGv.MapActive    = %TRUE„„IF (pbvScrnCard AND 1) = 0 THEN„    AnsiGv.ScreenSeg = &HB800        ' color monitor„ELSE„    AnsiGv.ScreenSeg = &HB000        ' mono monitor„END IF„„RESTORE TokenTableData„„FOR i = 0 TO 255„    TokenTable(i) = %TOKEN.ASCII„    KeyTable(i) = CHR$(i)„    MapActive(i) = %FALSE„NEXT i„„TokenTable(9)  = 7„TokenTable(10) = 8„TokenTable(34) = 6„„DO„    READ Char$, TokenType„    IF TokenType > 0 THEN„        TokenTable(ASC(Char$)) = TokenType„    ELSE„        EXIT DO„    END IF„LOOP„„CursorLocate AnsiGv.X, AnsiGv.Y„„END SUB„„SUB VisiPlexComReact (ComType AS INTEGER,_„                         VisiCommand AS STRING)„„' VisiPlex driver goes here and responds to the specific VisiPlex„' commands that will be standardized later!  Until then, you'll just„' have to wait.„'„' It will be a simple matter of doing this here:„'„'       VisiDriver ComType, VisiCommand„'„' AND BINGO!  Instant support!„„END SUB„„SUB LansiByteInterpret (BYVAL Bite AS INTEGER) PUBLIC„„AnsiGv.STATE = StateTable(AnsiGv.STATE, TokenTable(Bite))„„StateReact Bite„„END SUB„„SUB FPRINT(BYVAL Char AS INTEGER)„„	ScrnSeg = AnsiGv.ScreenSeg„„	! push DS                 ; save DS for PowerBASIC„„	! mov  AX, ScrnSeg        ; put screen segment in AX„	! mov  ES, AX             ; move to ES„„	Row = AnsiGv.X„	! mov  AX, Row            ; put row in AX„	! dec  AX                 ; minus one„	! mov  CX, 160            ; AX =„	! mul  CX                 ;   AX * 160„	! mov  DI, AX             ; put it in DI„	Col = AnsiGv.Y„	! mov  AX, Col            ; put column in AX„	! dec  AX                 ; minus one„	! shl  AX, 1              ; times 2„	! add  DI, AX             ; add to DI„„	Attr = AnsiGv.ColorAttr„	! mov  AH, Attr           ; put attribute in AH„	! mov  AL, Char„„WriteChar:„	! stosw                   ; write char and attribute to screen„QPExit:„	! pop  DS                 ; restore DS for PowerBASIC„„END SUB„