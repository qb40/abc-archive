Robert M. Ryan                 EXPANDING KEYBOARD BUFFEER     EXPANDING,KEYBOARD,BUFFER      02/29/92 (00:00)       TASM, MASM             562  18175    BUF160.ASM  	title   BUF160„	page    58,132„; History:1,1„; Wed Oct 23 17:08:32 1991„;„; v1.6a, 2-29-92, Robert M. Ryan„; - Added CLI and STI in installation routine. (hgm)„;„; v1.6,  2-26-92, Robert M. Ryan„; - On conditional assembly of PRIVATESTACK, this program will create it's„;   own stack.  This was implemented due to problems on some older PCs.„; - Refine checking of segment boundries, based upon recommendation by„;   Harry McGavran (hgm@moki.lanl.gov)„; - Added missing a LES before stuffing data into driver header. (also hgm)„; - Eliminated unnecessary structures and generally cleaned up code.„; - Changed name to BUF160, rather than BUF160_4, BUF160_5, etc.„;„; v1.5 10-23-91 Robert M. Ryan„; - using PUSHA and SHL AX,4 on conditional assembly for 286„; - changed the default buffer status to have TRANSFER enabled, so that„;   keys pressed during initialization are preserved.„; - changed case of es and ds to be like the rest of the registers„; - added initialization of BX so Cmd_Init would work„; - slightly modified initialization message„;„; Rob Ryan, Brown University„; Robert_Ryan@brown.edu or 70324.227@CompuServe.Com„;„; v1.4 09-26-88 Toad Hall Tweak„; - Donno WHY all the public mess.  Leaving it, tho.„; - Donno why author commented out the buffer transfer code.„;   I guess, since we're loading as a driver right at system startup,„;   there shouldn't BE anything in the old keyboard buffer.„;   Driver works fine with TRANSFER enabled (1), but donno what good it„;   does.  Therefore leaving the default (and compiled driver) OFF (0).„; - Changed case: constants UPPERCASE, procedures mixed Upper_Lower,„;   variables remain lowercase.  (Helps to keep my head straight.)„; - Added some comments.„; - Moved Force inline (since only called once)„; - Using string commands in Transfer_Buffer (lodsw, stosw)„; - Just below Transfer_Done, recoded to use AX when stuffing words„;   into variables (faster than old code using CX).„;„; David Kirschbaum„; Toad Hall„; kirsch@braggvax.ARPA„;„; 09-21-87 09:31:17 v1.3, fix buf in Force().„; 09-16-87 16:07:46 v1.2, added publics„; 09-16-87 16:01:41 v1.1, comment out buffer transfer code with equate„;„; DJ Delorie„;„;„; To compile:„;„;   MICROSOFT ASSEMBLER         TURBO ASSEMBLER„;   -------------------         ---------------„;   masm BUF160;                tasm BUF160„;   link BUF160;                tlink BUF160„;   exe2bin BUF160.exe BUF160.sys       exe2bin BUF160.exe BUF160.sys„;„; To install, insert the following line in your config.sys:„;„;   DEVICE=<path>BUF160.SYS„;„; where "<path>" is the path of the directory containing the device driver„; (e.g., C:\BIN\).„„„;*****************************************************************************„; Compilation flags„;*****************************************************************************„„TRANSFER    equ 1   ;Enables keyboard buffer transfer   v1.4„				;  procedure if enabled (1)     v1.4„USE286      equ 0   ;Should we use 286 (and later)      v1.5„				;  CPU specific instructions?       v1.5„PRIVATESTACK    equ 1   ;Use own stack?             v1.6„„PROGNAME    equ 'BUF160'„VERSION     equ 'v1.6a, 29 January 1992'„„;*****************************************************************************„; General equates„;*****************************************************************************„„BUFSIZE equ 160     ;What is the size of the keyboard buffer„STACKSZ equ 100h        ;What is the size of the private buffer„SUCCESS equ 0100h„ERROR   equ 8100h„BUSY    equ 0300h„CR  equ 13      ;Carriage Return„LF  equ 10      ;Line Feed„TERM    equ '$'     ;DOS printing terminator character„„;*****************************************************************************„; Data structures„;*****************************************************************************„„dqq struc„ofs dw  ?„segw    dw  ?       ;changed from 'seg' to keep MASM 5.0 happy v1.4„dqq ends„„rqq struc           ;Request header structure„len db  ?       ;length of request block (bytes)„unit    db  ?       ;unit #„code    db  ?       ;driver command code„status  dw  ?       ;status return„q1  dd  ?       ;8 reserved bytes„q2  dd  ?„mdesc   db  ?       ;donno„trans   dd  ?„count   dw  ?„rqq ends„„;*****************************************************************************„; Pointers to BIOS data segment, v1.4„;*****************************************************************************„„BIOS_DATA_SEG   equ 40H     ;MASM had prob using BIOS_DATA in calculations,„				;   so this typeless constant introduced.  v1.6„„BIOS_DATA   SEGMENT AT BIOS_DATA_SEG„	org 1AH„BUFFER_GET  dw  ?   ;org    1ah„BUFFER_PUT  dw  ?   ;org    1ch„	org 80H„BUFFER_START    dw  ?   ;org    80h„BUFFER_END  dw  ?   ;org    82h„BIOS_DATA   ENDS„„„;*****************************************************************************„; The actual program„;*****************************************************************************„„Cseg    segment byte„	assume  cs:Cseg,ds:Cseg,es:Cseg,ss:Cseg„	org 0           ; no offset, it's a .SYS file„start   equ $           ; define start=CS:0000„„IF USE286               ;               v1.5„	.286„	%OUT Compiling 286 code ...„ELSE„	%OUT Compiling generic 8086 code ...„ENDIF„IF PRIVATESTACK„	%OUT Using private stack ...„ELSE„	%OUT Not using private stack ...„ENDIF„IF TRANSFER„	%OUT Including keyboard transfer code ...„ELSE„	%OUT Not including keyboard transfer code ...„ENDIF„„	public  header„header  label   near„	dd  -1          ;pointer to next device„	dw  8000h           ;type device„	dw  Strat           ;strategy entry point„	dw  Intr            ;interrupt entry point„	db  'KBUFFER '      ;device name„„	public  req„req dd  ?           ;store request header vector here„„	public  queue_start,queue_end„queue_start dw  BUFSIZE dup (0)     ;our expanded keyboard buffer„queue_end   equ $ - start       ;calculate offset as typeless constant„„IF PRIVATESTACK             ;               v1.6„„stack_end   db   STACKSZ dup (0)    ;use our own private data stack„stack_start equ  $„oldss   dw  0„oldsp   dw  0„oldax   dw  0„„ENDIF„„;*****************************************************************************„; Strategy procedure„;   Save the pointer to the request header for Intr in the req area.„;   Enters with pointer in es:bx„;*****************************************************************************„„	public  Strat„Strat   proc    far„	mov cs:[req].ofs,bx„	mov cs:[req].segw,es    ;               v1.4„	ret„Strat   endp„„;*****************************************************************************„; The main interrupt (driver)„;   This is the actual driver.  Processes the command contained in the„;   request header.  (Remember, req points to the request header.)„;*****************************************************************************„„	public  Intr„	ASSUME  ds:Cseg, es:NOTHING ;               v1.4„Intr    proc    far„„IF PRIVATESTACK             ;If using private stack, process„	mov cs:oldax, ax        ;               v1.6„	cli             ; turn ints off„	mov ax, ss„	mov cs:oldss, ax„	mov cs:oldsp, sp„	mov sp, offset stack_start„	mov ax, cs„	mov ss, ax„	sti             ; turn ints back on„	mov ax, cs:oldax„ENDIF„„	push    ds          ;save everything in sight„	push    es„IF USE286„	pusha               ;               v1.5„ELSE„	push    ax„	push    bx„	push    cx„	push    dx„	push    di„	push    si„ENDIF„„	mov ax,cs„	mov ds,ax           ;DS=code segment„„	les bx,req          ;point to request hdr       v1.4a„	mov si,offset cmd_table ;our function table„	mov cl,es:[bx].code     ;get command„	xor ch,ch           ;clear msb          v1.4„	shl cx,1            ;*2 for word addresses„	add si,cx           ;add to table base„„	call    word ptr [si]       ;call our function      v1.4a„	les bx,cs:req       ;get back request hdr vector„	mov es:[bx].status,ax   ;return status„IF USE286„	popa                ;               v1.5„ELSE„	pop si          ;clean everything up„	pop di„	pop dx„	pop cx„	pop bx„	pop ax„ENDIF„	pop es„	pop ds„„IF PRIVATESTACK„	mov ax, cs:oldss        ;               v1.6„	cli             ; turn ints off„	mov ss, ax„	mov sp, cs:oldsp„	mov ax, cs:oldax„	sti             ; turn ints on„ENDIF„„	ret„„	public  cmd_table„cmd_table:              ;command routing table„	dw  Cmd_Init        ;0=initialization (we do that)„	dw  Cmd_None        ;1=media check (always SUCCESS)„	dw  Cmd_None        ;2=build BIOS param block (ditto)„	dw  Cmd_None        ;3=IO control input (ditto)„	dw  Cmd_None        ;4=input from device (ditto)„	dw  Cmd_None        ;5=nondest input no-wait (ditto)„	dw  Cmd_None        ;6=input status (ditto)„	dw  Cmd_None        ;7=flush input queue (ditto)„	dw  Cmd_Output      ;8=output to device (we do that)„	dw  Cmd_Output      ;9=output with verify (same thing)„	dw  Cmd_Output_Status   ;A=output status (we do that)„	dw  Cmd_None        ;B=flush output queue (always SUCCESS)„	dw  Cmd_None        ;C=IO control output (ditto)„„„;*****************************************************************************„; Cmd_Output procedure„;*****************************************************************************„„	public  Cmd_Output„Cmd_Output  proc    near„	mov ax,BIOS_DATA„	mov ds,ax           ;BIOS data area„	ASSUME  ds:BIOS_DATA        ;keep MASM happy        v1.4„„	mov cx,es:[bx].count„	les bx,es:[bx].trans„Output_Loop:„	mov al,es:[bx]„	inc bx„	cli„	mov di,BUFFER_PUT       ;next free space        v1.4„	call    Buf_Wrap        ;add 2, check for wraparound„	cmp di,BUFFER_GET       ;is the buffer full?        v1.4„	sti             ;ints back on           v1.4„	je  Output_Error        ;buffer is full, error      v1.4„„	xchg    BUFFER_PUT,di       ;save the old, get the new  v1.4„	xor ah,ah„	mov [di],ax         ;               v1.4„	loop    Output_Loop„„	public  Cmd_None        ;               v1.4„Cmd_None:               ;share this code        v1.4„	mov ax,SUCCESS„	ret„„Output_Error:„	mov ax,ERROR„	ret„Cmd_Output  endp„„„;*****************************************************************************„; Buf_Wrap procedure„;*****************************************************************************„„	public  Buf_Wrap„Buf_Wrap    proc    near„	inc di„	inc di„	cmp di,BUFFER_END       ;hit end yet?           v1.4„	je  Wrap            ;>=, wrap around        v1.4„	ret„Wrap:„	mov di,BUFFER_START     ;force ptr to start     v1.4„	ret„Buf_Wrap    endp„„„;*****************************************************************************„; Cmd_Output_Status procedure„;*****************************************************************************„„	public  Cmd_Output_Status„Cmd_Output_Status   proc    near„	mov ax,BIOS_DATA„	mov ds,ax„	mov di,BUFFER_PUT       ;ptr to next free space     v1.4„	call    Buf_Wrap        ;wraparound if necessary„	cmp di,BUFFER_GET       ;same as next char to get?  v1.4„	jne Cmd_None        ;ok, return SUCCESS     v1.4a„	mov ax,BUSY„	ret„Cmd_Output_Status   endp„„	public  last_code„last_code   label   near„„;*****************************************************************************„; Initialization (installation) procedure„;*****************************************************************************„„	public  Cmd_Init„Cmd_Init    proc    near„	mov ax,cs„	mov ds,ax„	mov es,ax           ;               v1.4a„	ASSUME  ds:Cseg,es:Cseg     ;               v1.4a„„; Is our new keyboard buffer within reach of the near pointers in BIOS_DATA?„„	cmp ax,(0fffh+BIOS_DATA_SEG-queue_end/10h);         v1.6„	ja  Init_Error      ;No, too far away„„	mov dx,offset banner    ;Yes, 'Buf160 loaded'„	mov ah,9            ;DOS display msg„	int 21h„	mov bx,0            ;Initialize size of buf     v1.5„	mov cx,BIOS_DATA        ;PRESERVE THIS!         v1.4„	mov ds,cx           ;BIOS data area„	ASSUME  ds:BIOS_DATA        ;               v1.4„„	cli             ;turn off ints          v1.6a„„IF  TRANSFER„	public  Transfer_Buffer„Transfer_Buffer:„	mov si,BUFFER_GET       ;next key to read       v1.4„	mov dx,BUFFER_PUT       ;next empty space       v1.4a„„	mov di,offset queue_start   ;gonna stuff here       v1.4a„	cld             ;insure fwd         v1.4„Transfer_Loop:„	cmp si,dx           ;hit empty yet?         v1.4a„	je  Transfer_Done       ;yep, transfer complete„„	lodsw               ;snarf the kbd word„	stosw               ;stuff in OUR buffer        v1.4a„	inc bx          ;increment counter      v1.5„	inc bx          ;increment counter      v1.5„	cmp si,BUFFER_END       ;hit kbd buffer's end yet?  v1.4„	jne Transfer_Loop       ; nope, keep going„	mov si,BUFFER_START     ;yep, wrap around to start  v1.4„	jmp Transfer_Loop       ; and keep going„„	public  Transfer_Done„Transfer_Done:„ENDIF„„	mov ax,cs           ;Code Segment„	sub ax,cx           ; calculate difference b/w bios & this„IF USE286„	shl ax,4            ;               v1.5„ELSE„	shl ax,1            ;remainder * 16 (paras to bytes)„	shl ax,1„	shl ax,1„	shl ax,1„ENDIF„	mov cx,ax           ;CX = driver starting offset„	add ax,offset queue_start   ;AX = queue_start offset„	mov BUFFER_START,ax     ;init BIOS buffer pointers  v1.4„	mov BUFFER_GET,ax       ;               v1.4„	add ax,bx           ;here'e next free space„	mov BUFFER_PUT,ax       ;tell BIOS          v1.4„„	mov ax,cx           ;get back driver starting offset v1.4a„	add ax,queue_end        ;code start + queue end     v1.4a„	mov BUFFER_END,ax       ;tell BIOS          v1.4„„	sti             ;restore ints           v1.6a„„	les bx,cs:[req]     ;complete driver header„	mov es:[bx].trans.ofs,offset last_code  ;driver end„	jmp short Stuff_Seg     ;share code, return success v1.4a„„	public  Init_Error„	ASSUME  ds:Cseg,es:Cseg     ;               v1.4„Init_Error:„	mov dx,offset msg_err   ;'Buf160 too far...'„	mov ah,9            ;display msg„	int 21h„„	les bx,cs:[req]     ;complete driver header     v1.6„„	IF  0           ;not sure if it works.„	mov es:[bx].trans.ofs,0„	ELSE„	mov es:[bx].trans.ofs,offset last_code„	ENDIF„„Stuff_Seg:              ;               v1.4a„	mov es:[bx].trans.segw,cs   ;               v1.4„	mov ax,SUCCESS„	ret„„Cmd_Init    endp„„	public  banner, msg_err„banner  db  PROGNAME,' ',VERSION,' installed.',CR,LF        ;v1.4„	db  'Keyboard now has buffer of 160 characters.'„IF PRIVATESTACK„	db  '  Using private stack.'„ENDIF„	db  CR,LF,CR,LF,TERM„„msg_err db  PROGNAME,' too far from BIOS data area.'        ;v1.4„	db  CR,LF,CR,LF,TERM„„Intr    endp„„Cseg    ends„„	end„„„„------------8<-----[ Begin BUF160.DOC ]------>8----------------„BUF160 v1.6a„„BUF160 is a device driver which provides a 10-fold expansion of the„standard keyboard buffer.  Specifically, while the default keyboard„buffer is usually 16 characters, this becomes 160 characters after„installing this device driver.  The driver is installed by copying it„to ones hard disk and including the command:„„   DEVICE=<path>\BUF160.SYS„„where "<path>" is the path of the directory holding the driver.  It„is recommended that it be the first device driver installed (since it„needs to be in the same segment and the ROM BIOS).  It has been„tested under DOS 5.0 (loaded both high and not high) and DOS 3.3, and„no version incompatibilities are expected.„„This archive contains 3 files:„„   BUF160.DOC               This document„   BUF160.ASM               The source code„   BUF160.SYS               The device driver„„This release of the program was modified by Robert M. Ryan to support„DOS 5.0.  The previous release, v1.4, sometimes froze the system on„startup under DOS 5.0.  This corrects that problem.  This version also„corrects some minor coding errors.„„The original program was written by Donald "DJ" Delorie and was„further modified by David Kirschbaum (?).  While originally developed„to work with MASM, v1.6 was developed with TASM, but hopefully full„MASM compatibility has been retained.„„This program has probably outlived the lifespan originally envisaged„by its creator, but I nevertheless find it quite useful.  I provide„it with no guarantee of satisfaction, but hope that you find it as„helpful as I do.„„Robert M. Ryan, Robert_Ryan@brown.edu (internet)„				st802200@brownvm (bitnet)„				70324.227@compuserve.com (compuserve via internet)„„„The following text is the original BUF160.DOC text file:„„-----------------------------------------------------------------------------„„From: nelson@sun.soe.clarkson.edu (Russ Nelson)„Newsgroups: comp.binaries.ibm.pc„Subject: buf160.sys (device driver)„Date: 4 May 88 19:21:16 GMT„„This is a cheap 'n dirty keyboard buffer expander.  It works by installing„itself as the standard keyboard buffer in the bios.  It can only do this„if it is in the same segment as the bios, so you are well advised to„install it as the first device driver.„„While it's installing itself into the bios, it also installs a device„driver called KBUFFER.  Anything written to KBUFFER ends up in the„keyboard buffer.„„Written by Donald "Dj" Delorie:„UUCP: uunet!unh!dgdhm!dj„Internet: Delorie_D%DUR09.CEO.DG.COM@adam.DG.COM„„Toad Hall Notes:„I was using BUF160.COM (without source), loading it via AUTOEXEC.BAT,„and was pleasantly surprised to find this!„Tweaked it (naturally), now works a little faster, is a little smaller,„and the tweaked source has comments!„DJ's original code is still here (BUF160.ASM and BUF160.DVD), and my tweaked„version is BUF160_4.ASM and BUF160_4.DVD.„„This documentation says the product should be a .SYS file, while the source„says .DVD.  Doesn't matter .. just so your CONFIG.SYS file says the right„file name!  Rename it as you will.„„David Kirschbaum„Toad Hall„kirsch@braggvax.ARPA„------------8<-----[ End BUF160.DOC ]------>8----------------„Unknown Author(s)              KEYBOARD TEST CODES            KEYBOARD,TEST,CODES            Unknown Date (00:00)   QB, QBasic, PDS        28   920      USEKEYB.BAS 'To use cursor keys and function keys, etc ...„„DO„   'Get a key from the keyboard„   DO„      A$ = INKEY$„   LOOP UNTIL LEN(A$)„   'Check if it's a extended (special) key„   IF LEN(A$) = 2 THEN„      'If it is then, make the key code negative„      KY = -ASC(RIGHT$(A$, 1))„   ELSE„      'If normal (within ASCII 1 - 255 range), then make it positive„      KY = ASC(A$)„   END IF„„   'Un-comment the following line to test for keycodes„   'PRINT KY          'This will give you a specific number to put into your„                      '  SELECT CASE structure for the key you pressed„   „   'Use SELECT CASE structure to test for keys„   SELECT CASE KY„      CASE 27         'ESC key pressed„         EXIT DO      'bail out„      'Now you can do whatever you want to the key„      'CASE ..., etc ...„   END SELECT„LOOP                   'Infinite loop, bail out when ESC pressed (in SELECT)„Unknown Author(s)              DISABLE KEYBOARD               DISABLE,KEYBOARD               Unknown (00:00)        QB, QBasic, PDS        21   401      DISKEYB.BAS DECLARE SUB DisableKeyboard ()„DECLARE SUB EnableKeyboard ()„„SUB DisableKeyboard„   „   'Purpose : To disable the keyboard„   'Input   : none„   'Return  : none„„   OUT &H21, (INP(&H21) OR 2)„END SUB„„SUB EnableKeyboard„„   'Purpose : To enable keyboard use after being disabled by DisableKeyboard„   'Input   : none„   'Output  : none„„   OUT &H21, (INP(&H21) AND 253)„END SUB„„Unknown Author(s)              KEY IN BUFFER                  KEY,IN,BUFFER                  Unknown Date (00:00)   QB, PDS                44   1470     KEYINBUF.BASDEFINT A-Z„„'$INCLUDE: 'QB.BI'„„DECLARE FUNCTION KeyInBuf ()„„'***********************************************************************„'* FUNCTION KeyInBuf„'*„'* PURPOSE„'*    Uses BIOS ISR 16H, Service 01H (Report Whether Character Ready)„'*    to return a keypress if one is waiting in the keyboard buffer.„'*    If the key pressed is a normal key, this function will return the„'*    ASCII value for that key; if the key pressed is an extended key„'*    (such as F1) this function will return the ascii value for that„'*    key negated.  This function does not remove the key from the„'*    keyboard buffer.„'*„'* EXTERNAL ROUTINE(S)„'*    QBX.LIB:„'*    --------„'*    SUB Interrupt (IntNum, InRegs AS RegType, OutRegs AS RegType)„'***********************************************************************„FUNCTION KeyInBuf STATIC„   InRegs.ax = &H100„   Interrupt &H16, InRegs, OutRegs„„   IF ((OutRegs.flags AND 64) \ 64) = 0 THEN '0 if a key is pending„      'If the key pressed is a normal key, alReg holds the ASCII code for„      'that key and ahReg holds the standard PC-keyboard scan code;„      'otherwise, (a special key was pressed such as F1) alReg holds 0„      'and ahReg holds the character ID.„      alReg = OutRegs.ax AND &HFF„      ahReg = OutRegs.ax \ &HFF„„      IF alReg THEN„         KeyInBuf = alReg„      ELSE„         KeyInBuf = -ahReg„      END IF„   ELSE„      KeyInBuf = 0„   END IF„END FUNCTION„Dave Navarro                   GET KEY                        GET KEY                        02/24/92 (02:07)       PB                     44   1375     GETKEY.BAS  'Here is some PowerBASIC code to read a key from the keyboard (101 key„'aware).„„'The "zero" flag us actually bit 7 of the "flags" register..„„'GetKey - Check if a key is pending and return the key to your program„'         Extended keyboard aware.„„FUNCTION GetKey$ PUBLIC„   REG 1, &HC000                            'BIOS get configuration„   CALL INTERRUPT &H15„   DEF SEG=REG(9)„     ExKy%=(PEEK(REG(2)+5) AND 16)=16       'returns true if extended KB„   DEF SEG„   IF ExKy% THEN Extended„   REG 1, &H0100                            'regular BIOS check key routine„   CALL INTERRUPT &H16„   IF (REG(0) AND 64)=64 THEN EXIT FUNCTION 'if zero flag then no key„   REG 1, &H0000                            'regular BIOS read key routine„   CALL INTERRUPT &H16„   K1%=REG(1) AND &HFF                      'ASCII code in AL„   K2%=(REG(1)\2 AND &H7FFF)\128            'scan code in AH„   IF K1%=0 THEN„     GetKey$=CHR$(0,K2%)„    ELSE„     GetKey$=CHR$(K1%)„   END IF„   EXIT FUNCTION„ Extended:„   REG 1, &H1100„   CALL INTERRUPT &H16„   IF (REG(0) AND 64)=64 THEN EXIT FUNCTION„   REG 1, &H1000„   CALL INTERRUPT &H16„   K1%=REG(1) AND &HFF„   K2%=(REG(1)\2 AND &H7FFF)\128„   IF K1%=0 THEN„     GetKey$=CHR$(0,K2%)„    ELSEIF K1%=224 AND K2%>0 THEN„     GetKey$=CHR$(0,K2%)„    ELSE„     GetKey$=CHR$(K1%)„   END IF„END FUNCTION„Unknown Author(s)              SET KEYBOARD RATE              SET,KEYBOARD,RATE              Unknown Date (00:00)   QB, PDS                27   726      SETKB.BAS   '$INCLUDE: 'qb.bi'„„DECLARE SUB SetKBRate (InitDelay%, RepeatRate%)„„SetKBRate 10, 250„„SUB SetKBRate (InitDelay%, RepeatRate%) STATIC„'**********************************************************************„'* SUB SetKBRate„'*„'* PURPOSE„'*    Uses BIOS ISR 16H, Service 03H (Set Typematic Rate and Delay) to„'*    set the typematic rate of an AT keyboard.„'*„'* EXTERNAL ROUTINE(S)„'*    QBX.LIB„'*    -------„'*    SUB Interrupt (IntNum%, IRegs AS RegType, ORegs AS RegType)„'**********************************************************************„„   DIM IRegs AS RegType, ORegs AS RegType„„   IRegs.ax = &H305„   IRegs.bx = InitDelay% * 256 + RepeatRate%„   INTERRUPT &H16, IRegs, ORegs„END SUB„„The ABC Programmer             SPEED UP KEYBOARD INPUTS       SPEED,UP,KEYBOARD,INPUTS       04/10/95 (00:00)       TASM                   20   253      FASTKEY.ASM ;FASTKEY.ASM„;Purpose: To Increase Keyboard Input Rate   (Same as using MODE)„„IDEAL„MODEL SMALL„DATASEG„CODESEG„PUBLIC FastKey„EVEN„PROC    FastKey„„;DECLARE SUB FastKey      „„Mov Ax, $305„Xor Bx, Bx„Int $16„„ENDP    FastKey„END„ „Matt Hart                      ALT/CTRL/SHIFT/CAPS/NUM/SCRL   ALT,CTRL,SHIFT,CAPS,NUM,SCRL   Unknown Date (00:00)   QB, PDS                105  2924     KEYSTUFF.BAS'„' KEYSTUFF.BAS  by Matt Hart„' Uses Interrupt 16H for various keyboard operations.„'„' The scroll lock, num lock, caps lock, and insert„' key flags remain ON until pressed again, thus the need for„' the ?Flag variables in this demo program.„'„' Also see Keystuf.asm for assembly language equivilants.„'„    DEFINT A-Z„    TYPE RegTypeX„        ax    AS INTEGER„        bx    AS INTEGER„        cx    AS INTEGER„        dx    AS INTEGER„        bp    AS INTEGER„        si    AS INTEGER„        di    AS INTEGER„        flags AS INTEGER„        ds    AS INTEGER„        es    AS INTEGER„    END TYPE„    DECLARE FUNCTION RShift()„    DECLARE FUNCTION LShift()„    DECLARE FUNCTION CtrlKey()„    DECLARE FUNCTION AltKey()„    DECLARE FUNCTION ScrollLock()„    DECLARE FUNCTION NumLock()„    DECLARE FUNCTION CapsLock()„    DECLARE FUNCTION InsertKey()„    SFlag=0 : NFlag=0 : CFlag=0 : IFlag=0„    DO„        IF RShift     THEN PRINT "Right Shift Key"„        IF LShift     THEN PRINT "Left Shift Key"„        IF CtrlKey    THEN PRINT "Control Key"„        IF AltKey     THEN PRINT "Alt Key"„        IF ScrollLock AND NOT SFlag THEN„            PRINT "Scroll Lock Enabled"„            SFlag = NOT SFlag„        ELSEIF NOT ScrollLock AND SFlag THEN„            PRINT "Scroll Lock Disabled"„            SFlag = NOT SFlag„        ENDIF„        IF NumLock AND NOT NFlag THEN„            PRINT "Num Lock Enabled"„            NFlag = NOT NFlag„        ELSEIF NOT NumLock AND NFlag THEN„            PRINT "Num Lock Disabled"„            NFlag = NOT NFlag„        ENDIF„        IF CapsLock AND NOT CFlag THEN„            PRINT "Caps Lock Enabled"„            CFlag = NOT CFlag„        ELSEIF NOT CapsLock AND CFlag THEN„            PRINT "Caps Lock Disabled"„            CFlag = NOT CFlag„        ENDIF„        IF (InsertKey AND NOT IFlag) OR_„           (NOT InsertKey AND IFlag) THEN„            PRINT "Insert Key Toggled"„            IFlag = NOT IFlag„        ENDIF„    LOOP UNTIL INKEY$=CHR$(27)„    END„'„FUNCTION RShift„    CALL KeyInt(AL) : RShift = (AL AND 1) = 1„END FUNCTION„'„FUNCTION LShift„    CALL KeyInt(AL) : LShift = (AL AND 2) = 2„END FUNCTION„'„FUNCTION CtrlKey„    CALL KeyInt(AL) : CtrlKey = (AL AND 4) = 4„END FUNCTION„„FUNCTION AltKey„    CALL KeyInt(AL) : AltKey = (AL AND 8) = 8„END FUNCTION„'„FUNCTION ScrollLock„    CALL KeyInt(AL) : ScrollLock = (AL AND 16) = 16„END FUNCTION„'„FUNCTION NumLock„    CALL KeyInt(AL) : NumLock = (AL AND 32) = 32„END FUNCTION„'„FUNCTION CapsLock„    CALL KeyInt(AL) : CapsLock = (AL AND 64) = 64„END FUNCTION„'„FUNCTION InsertKey„    CALL KeyInt(AL) : InsertKey = (AL AND 128) = 128„END FUNCTION„'„SUB KeyInt(AL)„    DIM InRegs AS RegTypeX„    DIM OutRegs AS RegTypeX„    InRegs.AX = &H0200„    CALL InterruptX(&H16,InRegs,OutRegs)„    AL = OutRegs.AX MOD 256„END SUB„Brent Ashley                   QB SIMULTANEOUS KEY            QB,SIMULTANEOUS,KEY            Unknown Date (00:00)   ASM, QB, PDS           89   3020     KEYPRESS.BAS'BASIC test code:„DECLARE FUNCTION KeyPressed%(ScanCode%)„CALL InstKeyPress ' install resident code„CLS„DO„  LOCATE 1,1„  FOR i% = 2 TO 9 ' scancode of 1 to 8„    IF KeyPressed(i%) THEN PRINT CHR$(47+i%); ELSE PRINT " ";„  NEXT„  PRINT„LOOP UNTIL INKEY$=CHR$(27) ' escape to quit„CALL UnHookKeyPress ' unhook resident code - IMPORTANT!!!„END„„; KeyPress.ASM by Brent Ashley„;   checks the "pressed" status of any key„.model medium, basic„.code„Old09        Label Dword       ;Label for to old Int 09h handler„Old09Offset  dw ?              ;Offset part„Old09Segment dw ?              ;Segment part„Hooked       db 0              ;Our installed flag„KeyMap       db 80 dup(0)      ;map of kybd, one byte per scancode„InstKeyPress proc uses ds ax dx ; From BASIC: CALL InstKeyPress„                               ; REMEMBER to call UnhookKeyPress!„        cmp cs:Hooked,0        ;Are we already hooked?„        jnz InstallExit        ;If so, exit„        mov ax,3509h           ;Get current vector for int 09h„        int 21h„        mov cs:Old09Segment,es ;Remember it for later„        mov cs:Old09Offset,bx„        mov ax,2509h„        push ds„        push cs„        pop ds                 ;Point int 09h handler to our code„        mov dx, offset OurInt09„        int 21h„        pop ds„        mov cs:Hooked,-1       ;Set our installed flag„InstallExit:„        ret„OurInt09:                      ;Our Int 09h handler„        push ax„        push bx„        push dx„        push si„        in al, 60h„        test al, 080h          ;is "released" bit set?„        jnz Released           ;yup - go to it„        mov dl, 0FFh           ;nope - set key pressed flag„        jmp PutFlag„Released:„        and al, 07Fh           ;yes - clear bit for index„        mov dl, 0              ;and set flag for release„PutFlag:„        xor ah, ah„        mov si, ax             ;assign index„        mov cs:KeyMap[si], dl  ;put flag in place„        pop si„        pop dx„        pop bx„        pop ax„Continue:„        jmp dword ptr cs:[Old09];Transfer ctrl to orig Int 09h„InstKeyPress endp„KeyPressed proc uses bx si, ScanCode:WORD„        ; from BASIC: TrueOrFalse% = KeyPressed(ScanCode%)„        mov bx, ScanCode       ;get scan code addr„        mov si, [bx]           ;load value as index„        mov al, cs:KeyMap[si]  ;put flag in al„        cbw                    ;convert to word for integer value„        ret„KeyPressed endp„UnhookKeyPress proc            ; from BASIC: CALL UnHookKeyPress„        cmp cs:Hooked,0        ; are we installed?„        jz UnHooked            ; nope - exit„        push ax„        push ds„        mov ax,2509h           ;Unhook ourself„        mov ds,Old09Segment„        mov dx,Old09Offset„        int 21h                ;Point Int 09h back to orig hndlr„        pop ds„        pop ax„        mov cs:Hooked,0        ;Set installed flag back to zero„UnHooked:„        ret„UnhookKeyPress endp„END„Jeff Shantz                    HOTKEYS EXAMPLE                HOTKEYS,EXAMPLE                Unknown Date (00:00)   QB, QBasic, PDS        63   2349     EX_HOT.BAS  'Hotkeys Example By Jeff Shantz„'„'Programmer's Note„'„'Many Programmers In QuickBasic Have Wanted To Know How To Have Hotkeys„'In Their Programs For A Long Time But Have Struggled Over It.  This„'Example Demonstrates The Incorporation Of Hotkeys Into Your QuickBasic„'Programs.  It Uses 2 Main Commands, INKEY$ And ASC.  Of Course, There ARE„'Other Ways To Incorporate Hotkeys Into Your Programs But This Technique Is„'A Fast And Easy To Use Way To Use Hotkeys.   Hotkeys Improve The Feel Of„'Your Program And Make It More Professional.„'„Plays = 0  'sets a variable for maintaining the octave level.  See 3„CLS„X$ = STRING$(79, 196)  'sets the border as X$„COLOR 7„PRINT X$ 'prints the border„LOCATE 23, 1: PRINT X$ 'prints the lower border„„'Titles And Instructions„COLOR 4: LOCATE 5, 25: PRINT "Hotkey Example"„COLOR 14„LOCATE 9, 15: PRINT "[1] Hear 1 Beep"„LOCATE 9, 40: PRINT "[2] Hear 2 Beeps"„LOCATE 12, 13: PRINT "[M]ake Strange Noise"„LOCATE 12, 41: PRINT "[Q]uit Program"„LOCATE 18, 24: PRINT "Any Other Key Plays Music"„1 FOR N% = 1 TO 9999 'starts the hotkey loop„A$ = INKEY$: IF LEN(A$) = 0 THEN GOTO 2 'program acts upon keypress„IF ASC(A$) = 49 THEN BEEP: GOTO 1  'if 1 is pressed, 1 beep is heard„IF ASC(A$) = 50 THEN BEEP: BEEP: GOTO 1  'if 2 is pressed, 2 beeps are heard„'in the statement below, if M is pressed, a strange noise is made„IF ASC(A$) = 77 THEN PLAY "mf l64 t255 o4 A C E A C E A CE": GOTO 1„IF ASC(A$) = 81 THEN SYSTEM 'exits to dos if run from dos, Q„'in the statement below, if m is pressed, a strange noise is made„IF ASC(A$) = 109 THEN PLAY "mf l64 t255 o4A C E A C E A CE": GOTO 1„IF ASC(A$) = 113 THEN SYSTEM ELSE GOTO 3 'exits to dos if run from dos, q„2 NEXT N%„GOTO 1„„3 IF Plays = 4 THEN PLAY "o4": Plays = 0 'resets the octave level„PLAY "mf l12 t255 a c e < a c e" 'plays the music„Plays = Plays + 1 'adds another point to the plays variable„GOTO 1„„'Written by Jeff Shantz„'„'A catalogue of other public domain programming examples and other types of„'public domain software written by Jeff Shantz can be obtained by sending„'$2.00 (for shipping & handling) to:„'„'Programming Examples„'c/o Jeff Shantz„'162 Ann Street„'Kitchener,Ontario„'N2B 1Y3, CANADA„'„'or by setting your modem to 8,N,1 and calling The Crypt at 1-(519)-576-3127„„„„„„Daniel Trimble                 DISABLE CTRL+BREAK             FidoNet QUIK_BAS Echo          Year of 1995           QB, QBasic, PDS        35   1464     NOBREAK.BAS 'QBasic NoBreak v1.0a„'Copyright (c)1995 by Daniel Trimble„'Public Domain - use at your own risk.„„CLS„DO„   KEY 15, CHR$(4 + 128 + 32 + 64) + CHR$(70)„   ON KEY(15) GOSUB NoBreak: KEY(15) ON„   KEY 16, CHR$(4 + 128) + CHR$(70): ON KEY(16) GOSUB NoBreak: KEY(16) ON„   KEY 17, CHR$(4 + 128 + 32) + CHR$(70): ON KEY(17) GOSUB NoBreak„   KEY(17) ON: KEY 18, CHR$(4 + 128 + 64) + CHR$(70): ON KEY(18) GOSUB NoBreak„   KEY(18) ON: KEY 19, CHR$(4) + CHR$(70): ON KEY(21) GOSUB NoBreak„   KEY(21) ON: KEY 22, CHR$(4 + 64) + CHR$(70)„   ON KEY(22) GOSUB NoBreak: KEY(22) ON: KEY 23, CHR$(4 + 32) + CHR$(46)„   ON KEY(23) GOSUB NoBreak: KEY(23) ON: KEY 24, CHR$(4 + 64) + CHR$(46)„   ON KEY(24) GOSUB NoBreak: KEY(24) ON„   KEY 25, CHR$(4 + 32 + 64) + CHR$(46): ON KEY(25) GOSUB NoBreak: KEY(25) ON„„   LOCATE 1, 1, 0: PRINT "QBasic NoBreak v1.0a"„   LOCATE 2, 1, 0: PRINT "Copyright (c)1995 by Daniel Trimble"„   LOCATE 4, 1, 0: PRINT "This program and all source is public domain.  I will not be responsible"„   LOCATE 5, 1, 0: PRINT "for any damage this program may cause.  I am not at fault.  Use at your"„   LOCATE 6, 1, 0: PRINT "own risk - period!"„   LOCATE 15, 1, 0: PRINT "Try pressing either CTRL-BREAK or CTRL-C.  Nothing will happen."„   LOCATE 16, 1, 0: PRINT "To end the program, hit ENTER."„   IF INKEY$ = CHR$(13) THEN END„LOOP„„NoBreak: RETURN„„„'ctrl =4          extended keys=128„'num lock=32      c=46„'cap lock=64„„Unknown Author(s)              SET CURSOR TYPEMATIC KEYRATE   FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                16   470      KEYSPEED.BAS'$INCLUDE: 'QBX.BI' or QB.BI„„SUB KeySpeed (rate, delay)„ „'Sets the cursor typematic keyrate.  Rate is the speed at which„'the keys repeat, the range is from 0 to 31, 0 being fastest.„'Delay is the amount of time in 250 millisecond parts before the„'keys begin to repeat.  The range is from 0 to 3, 0 being the„'shortest wait.„ „DIM Regs AS RegType„Regs.ax = &H305„Regs.bx = (delay AND 3) * 256 + (rate AND 31)„CALL Interrupt(&H16, Regs, Regs)„END SUB„„Christy Gemmell                STUFF KEYBOARD BUFFER          Ethan Winer                    06-01-95 (13:01)       QB, QBasic, PDS        141  5579     KEYBUFF.BAS ' >> I've been trying to use an example program from Ethan Winer's„'  >> "Basic Tips and Tricks". I have successfully used other programs„'  >> of his, but I cannot get this example to work for love nor money..„„' >> ------------------------ ethan winers Stuff Buffer example--------„'  >> SUB StuffBuffer (Cmd$) STATIC„'  >>„'  >>   '----- Limit the string to 14 characters plus Enter and save„'  >>   '      the length.„'  >>   Work$ = LEFT$(Cmd$, 14) + CHR$(13)„'  >>   Length = LEN(Work$)„'  >>„'  >>   '----- Set the segment for poking, define the buffer head and tail,„'  >>   '      and then poke each character.„'  >>   DEF SEG = 0„'  >>   POKE 1050, 30„'  >>   POKE 1052, 30 + Length * 2„'  >>   FOR X = 1 TO Length„'  >>     POKE 1052 + X * 2, ASC(MID$(Work$, X))„'  >>   NEXT„'  >>„'  >> END SUB„„'There's nothing wrong with Ethan's code and the POKE addresses are the„'default ones for the keyboard buffer. However not all computers have„'the buffer in the usual place and if, for example, you have a keyboard„'enhancer program that gives you a larger typeahead buffer then it might„'have been moved elsewhere.„„'As a quick check try running this little program...„„'    DEF SEG = &H40„'    X& = PEEK(&H80) + (256& * PEEK(&H81))„'    PRINT X&„„'If your keyboard buffer is in the standard place then X& should be equal„'to thirty. If you get any other value than 30 your buffer has definitely„'been moved since the two bytes at 0040:0080 are a pointer to the start of„'the keyboard buffer taken as an offset from segment 0040 (Hex) - the BIOS„'DATA area.„„'Personally I would rewrite the second part of Ethan's procedure as„'follows:„„'    DEF SEG = &H40                      ' Switch to BIOS data segment„'    Head% = &H1A                        ' Buffer head pointer„'    Tail% = &H1C                        ' Buffer tail pointer„'    Start& = PEEK(&H80) + (256& * PEEK(&H81))„                                        ' Pointer to keyboard buffer„'    FOR X = 1 TO Length                 ' Stuff the buffer„'        POKE Start& + (X - 1) * 2, ASC(MID$(work$, X, 1))„'    NEXT„'    POKE Head%, Start&                  ' Set new head pointer„'    POKE Tail%, Start& + (X - 1) * 2    ' Set new tail pointer„„'This should work wherever the buffer is located.„„'If you want to see how the keyboard buffer works, try running the„'program below. It displays the contents in real time so you can„'watch as each keypress is inserted.„„'--- cut here ---------------------------------------------------------------„' KEYBUFF.BAS   continuously displays contents of keyboard buffer„'„'   Author:     Christy Gemmell„'   Date:       19/2/1990„'„    COLOR 15, 0: CLS : LOCATE , , 0„    READ Items%„    FOR I% = 1 TO Items%„        READ Row%, Col%, Text$„        LOCATE Row%, Col%: PRINT Text$;„    NEXT I%„    LOCATE 11, 68: COLOR 11„    DEF SEG = &H40„    Start& = &H400 + PEEK(&H80): Finish& = &H400 + PEEK(&H82)„    PRINT RIGHT$("0000" + HEX$(Start&), 4); " ";„    PRINT RIGHT$("0000" + HEX$(Finish&), 4);„    IF Start& <> &H41E THEN„       S& = Start& - &H400: Ix$ = ""„       FOR I% = 0 TO 15„           Ix$ = Ix$ + RIGHT$("0" + HEX$(S& + (I% * 2)), 2) + " "„       NEXT I%„       LOCATE 8, 17: COLOR 15: PRINT RTRIM$(Ix$);„    END IF„    DO„       LOCATE 11, 4: COLOR 11„       Head& = &H400 + PEEK(&H1A): Tail& = &H400 + PEEK(&H1C)„       PRINT RIGHT$("0000" + HEX$(Head&), 4); " ";„       PRINT RIGHT$("0000" + HEX$(Tail&), 4);„       COLOR 13: LOCATE 9, 17: PRINT SPACE$(48);„       LOCATE 9, 17 + ((Head& - &H41E) \ 2) * 3: PRINT CHR$(25);„       COLOR 12: LOCATE 13, 17: PRINT SPACE$(48);„       LOCATE 13, 17 + ((Tail& - &H41E) \ 2) * 3: PRINT CHR$(24);„       FOR I% = 0 TO 15„           Character% = PEEK((Start& - &H400) + (I% * 2))„           Scancode% = PEEK((Start& - &H400) + (I% * 2) + 1)„           IF Character% < 32 THEN„              Ky$ = "  "„           ELSE„              Ky$ = CHR$(Character%) + " "„           END IF„           LOCATE 11, 17 + (I% * 3): COLOR 14: PRINT Ky$;„           LOCATE 14, 17 + (I% * 3): COLOR 9„           PRINT RIGHT$("0" + HEX$(Character%), 2);„           LOCATE 15, 17 + (I% * 3): COLOR 10„           PRINT RIGHT$("0" + HEX$(Scancode%), 2);„'(Continued to next message)„'(Continued from previous message)„       NEXT I%„       IF Head& >= Tail& THEN„          Numkeys% = 16 - ((Head& - Tail&) \ 2)„       ELSE„          Numkeys% = (Tail& - Head&) \ 2„       END IF„       LOCATE 14, 76: IF Numkeys% = 16 THEN Numkeys% = 0„       PRINT RIGHT$(" " + LTRIM$(RTRIM$(STR$(Numkeys%))), 2);„       IF Numkeys% = 15 THEN„          LOCATE 15, 67: COLOR 28: PRINT "BUFFER FULL";„          Dummy$ = INPUT$(16)„          LOCATE , 67: PRINT SPACE$(11);„       END IF„    LOOP UNTIL PEEK((Tail& - &H400) - 2) = 27„    DEF SEG : COLOR 7, 0: LOCATE 20, 1, 1„    Dummy$ = INPUT$(Numkeys%)„END„„DATA  20„DATA  6, 4, "Head Tail", 6, 33, "Keyboard buffer"„DATA  6, 67, "Buffer Area", 8, 4, "041A 041C"„DATA  8, 17, "1E 20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C"„DATA  8, 68, "0480 0482", 10, 3, "-----|-----"„DATA  10, 16, "|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|"„DATA  10, 67, "-----|-----", 11, 3, "           ", 11, 16, " "„DATA  11, 64, " ", 11, 67, "           ", 12, 3, "-----|-----"„DATA  12, 16, "|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|"„DATA  12, 67, "-----|-----", 14, 3, "ASCII Codes"„DATA  14, 67, "Waiting", 15, 3, "Scan Codes"„DATA  24, 31, "Press <Esc> to quit"„„„Peter Norton                   RETURNS KEY(S) PRESSED         Advanced BASIC Book            Unknown Date           QB, PDS                52   1317     INKEY.BAS   ' Returns the key(s) pressed„' Useful to find value of combined keys„' ie.  CTRL+UP     =  CHR$(0)+CHR$(141)„'      CTRL+DOWN   =  CHR$(0)+CHR$(145)„„DECLARE FUNCTION InKeyNoEcho$ ()„TYPE RegType„        ax      AS INTEGER„        bx      AS INTEGER„        cx      AS INTEGER„        dx      AS INTEGER„        bp      AS INTEGER„        si      AS INTEGER„        di      AS INTEGER„        flags   AS INTEGER„END TYPE„„DECLARE SUB INTERRUPT (IntNo AS INTEGER, InRegs AS RegType, OutRegs AS RegType)„„        PRINT "Type a character: "„        DO„        TheKey$ = InKeyNoEcho$„        LOOP WHILE TheKey$ = ""„        PRINT "That character was: ", TheKey$„„END„„FUNCTION InKeyNoEcho$„„   DIM InRegs AS RegType, OutRegs AS RegType„   InRegs.ax = &H600„   InRegs.dx = &HFF„„   CALL INTERRUPT(&H21, InRegs, OutRegs)„„   REM No character ready if zero flag set„„   IF (OutRegs.flags AND 2 ^ 6) THEN„       InKeyNoEcho$ = ""„   ELSE„       IF (OutRegs.ax AND &HFF) <> 0 THEN„           InKeyNoEcho$ = CHR$(OutRegs.ax AND &HFF)„       ELSE    'Need one more call„           InRegs.ax = &H600„           InRegs.dx = &HFF„           CALL INTERRUPT(&H21, InRegs, OutRegs)„           InKeyNoEcho$ = CHR$(0) + CHR$(OutRegs.ax AND &HFF)„      END IF„   END IF„„END FUNCTION„„Unknown Author(s)              DISABLE/ENABLE KEYBOARD        QBFAQ                          Unknown Date           QB, QBasic, PDS        17   340      DISKEYB.BAS SUB DisableKeyboard ()„   „   'Purpose : To disable the keyboard„   'Input   : none„   'Return  : none„„   OUT &H21, (INP(&H21) OR 2)„END SUB„„SUB EnableKeyboard ()„„   'Purpose : To enable keyboard use after being disabled by DisableKeyboard„   'Input   : none„   'Output  : none„„   OUT &H21, (INP(&H21) AND 253)„END SUB„DISABLE PAUSE BUTTON           EDWARD LAM/BRENT ASHLEY        NANET-BASIC                    02-01-93               ASM, QB, PDS           127  4174     NOPAUSE.BAS '   Because B_OnExit might have too many routines registered already, I've made„'NoPause a function returning TRUE(-1) if everything is ok, otherwise FALSE(0).„'   The B_OnExit routine does look a little eratic to me in the environment but„'try it and see what happens.„„'cut here for NOPDEMO2.BAS„„'Example program for NoPause2 module.„'„DECLARE FUNCTION NoPause%„'„CLS„PRINT "Press N for NoPause, U to Unhook NoPause, ESC to exit"„DO„  I = (I + 1) MOD 1000„  LOCATE 5, 5: PRINT "     ";„  LOCATE 5, 5: PRINT I;„  A$ = UCASE$(INKEY$)„  IF A$ = "N" THEN„     IF NOT NoPause% THEN   'We call NoPause here„        LOCATE 2, 1„        PRINT "B_OnExit Full!  Can't stop pause key"„     END IF„  END IF„  IF A$ = "U" THEN„      CALL UnhookNoPause  'Have option to disable nopause from„                           'within program„      LOCATE 2, 1„      PRINT SPACE$(36)„  END IF„LOOP UNTIL A$ = CHR$(27)„'Note that we don't care the state of the vectors since B_OnExit will call„'UnHookNoPause for us.  You can call UnHookExit as many times as you like„„ ;NoPause2.ASM„„;Note that this file has been modified so that the UnHookNoPause routine„;does not need ever (or should it) to be called.  --EKL„„EXTRN   B_OnExit:FAR            ;QB's internal routine calls all clean„                                ;up routines registered with it ony„_any_ exit„„;„; NoPause.ASM by Brent Ashley  /  NoPause2.ASM modified by Edward Lam 01/31/93„;„.model medium, basic„.code„Old1C        Label Dword          ;Label for to old Int 1Ch„Old1COffset  dw ?                 ;Offset part„Old1CSegment dw ?                 ;Segment part„Hooked       db 0                 ;Our installed flag„„;Note that if an error occurs registering NoHookPause, NoPause will return„;FALSE.  Right, it's a function now instead of a sub -- EKL„NoPause proc uses ds dx           ;From BASIC: Ok% = NoPause%„                                  ;Use UnhookNoPause to disable NoPause„„        cmp cs:Hooked,0           ;Are we already hooked?„        jnz InstallExit           ;If so, exit„„        ;following section just cut&paste from EVENTCHN.ASM by Jim Mack„        mov     dx, offset UnHookNoPause„        push    cs                ; push far address of UnHookNoPause„        push    dx                ; to register the exit routine„        call    B_OnExit          ; so that we don't hang machine„        or      ax, ax            ; registered OK?„        jz      ErrorExit         ; error: too many registered routines„„        mov ax,351Ch              ;Get current vector for int 09h„        int 21h„„        mov cs:Old1CSegment,es    ;Remember it for later„        mov cs:Old1COffset,bx„        mov ax,251Ch„        push ds„        push cs„        pop ds                    ;Point int 1Ch to our code„        mov dx, offset OurInt1C„        int 21h„        pop ds„        mov cs:Hooked,-1          ;Set our installed flag„        mov ax, -1                ;return TRUE for ok„        jmp InstallExit„„ErrorExit:„        sub ax, ax                ;put 0 into ax to return with error„„InstallExit:„        ret„„OurInt1C:                         ;Our Int 1Ch handler„        push ds                   ;„        push bx„        push ax„        xor bx, bx                ;point DS to BIOS data area„        mov ds, bx                ;„        mov bx, 0418h„        mov al, [bx]„        and al, 0F7h              ;reset nopause flag„        mov [bx], al„        pop ax„        pop bx„        pop ds„        jmp dword ptr cs:[Old1C]  ;Transfer to orig Int 1Ch„„NoPause endp„„UnhookNoPause proc                ; from BASIC: CALL UnHookNoPause„        cmp cs:Hooked,0           ; are we installed?„        jz UnHooked               ; nope - exit„„        push ax„        push ds„        mov ax,251Ch              ;Unhook ourself„        mov ds,Old1CSegment„        mov dx,Old1COffset„        int 21h                   ;Point Int 1Ch back to original„        pop ds„        pop ax„        mov cs:Hooked,0           ;Set installed flag back to zero„„UnHooked:„        ret„UnhookNoPause endp„„END„