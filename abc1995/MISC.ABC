David Perry                    READ DBASE III                 READ,DBASE,III                 1/25/88 (00:00)        QB, PDS                197  8547     DB.BAS      '+==============================================+„'|   DB.BAS     1/25/88                         |„'|   David Perry                                |„'|   QuickBASIC 4.0 Source                      |„'|   Compile:  BC DB /O/D                       |„'|   Link: LINK /EX DB;                         |„'|   Opens dBASE III .DBF and .DBT files        |„'|   Reads and displays structure .DBF file     |„'|   Then reads and displays data to include    |„'|   up to first 4000 bytes of memo fields      |„'|   This can be redirected to file or printer  |„'|   by typing DB FILENAME.DBF>FILEDAT or       |„'|   DB FILENAME.DBF>PRN                        |„'|   Respects flag for deleted records (may     |„'|   be modified--see source below)             |„'|   This is a simple basis for building QB     |„'|   programs which require reading .DBF files  |„'+==============================================+„ „DECLARE SUB Stripchar (a$)„REM $DYNAMIC„DEFINT A-Z„TYPE dBHeader„   Version AS STRING * 1                               'dBaseIII file header„   Lastupdate AS STRING * 3                            '32 bytes„   NumRecs AS LONG„   NumBytesHeader AS INTEGER„   NumBytesRec AS INTEGER„   Trash AS STRING * 20„END TYPE„ „TYPE FieldDescriptor                                   'Field Descriptions„   FName AS STRING * 11                                '32 bytes * Number of Fields„   FType AS STRING * 1                                 ' Up to 128„   DataAddress AS STRING * 4„   Length AS STRING * 1„   DecimalCount AS STRING * 1„   Trash AS STRING * 14„END TYPE„ „CONST TRUE = -1: FALSE = NOT TRUE„DELETED = TRUE„ „DIM Header AS dBHeader, FieldDes AS FieldDescriptor    'Creating variables for user-defined types„DIM memo AS STRING * 512                               'Create a 512 byte fixed string variable„                                                       ' to read memo fields„IF COMMAND$ = "" THEN„   PRINT "Please enter the name of a database file  "; 'Parsing the command line„   LINE INPUT dbasename$„   IF dbasename$ = "" THEN END„ELSE„   dbasename$ = COMMAND$„END IF„dbasename$ = UCASE$(dbasename$)„dot = INSTR(dbasename$, ".")„IF dot THEN„   dbasename$ = LEFT$(dbasename$, dot - 1) + ".DBF"„ELSE„   dbasename$ = dbasename$ + ".DBF"„END IF„ „OPEN dbasename$ FOR BINARY AS #1                       'Binary file I/O„GET #1, , Header                                       'This reads the first 32 bytes„SELECT CASE Header.Version„   CASE CHR$(&H83)                                     'Be sure we're using a dBASE III file„      dot = INSTR(dbasename$, ".")„      dmemo$ = LEFT$(dbasename$, dot - 1) + ".DBT"     'Open a .DBT file if Header.Version=CHR(&H83)„      OPEN dmemo$ FOR BINARY AS #2„   CASE CHR$(&H3)„   CASE ELSE„      PRINT "This is not a dBASE III file"„      END„END SELECT„Year = ASC(MID$(Header.Lastupdate, 1, 1))              'Date of last update is stored in 3 bytes„Month = ASC(MID$(Header.Lastupdate, 2, 1))             'The value of year,month,day = ASCII value of the„Day = ASC(MID$(Header.Lastupdate, 3, 1))               'Bytes„ „NumFields = Header.NumBytesHeader \ 32 - 1             'Calculate the number of fields„ „REDIM FieldDes(1 TO NumFields) AS FieldDescriptor      'Create an array of Field Descriptors„ „PRINT "Structure for database: "; dbasename$„PRINT USING "\           \  ##########"; "Number of data records  :"; Header.NumRecs„PRINT USING "\           \    ##/##/##"; "Date of last update     :"; Month; Day; Year„PRINT "Field  Field Name     Type   Width  Dec"„FOR i = 1 TO (NumFields)„   GET #1, (32 * i) + 1, FieldDes(i)                   'Looping through NumFields by reading in 32 byte records„   SELECT CASE FieldDes(i).FType                       'Reading the dBASE Field Type„      CASE "C"„         PrintType$ = "Character"„      CASE "D"„         PrintType$ = "Date"„      CASE "N"„         PrintType$ = "Numeric"„      CASE "L"„         PrintType$ = "Logical"„      CASE "M"„         PrintType$ = "Memo"„   END SELECT„            'This prints out the field names, lengths, numeric, decimal values as appropriate„   PRINT USING "#####  \     \   \       \     ###  ###"; i; FieldDes(i).FName; PrintType$; ASC(FieldDes(i).Length); ASC(FieldDes(i).DecimalCount)„NEXT i„ „'The field names, lengths, and types are read.  Now read in the data„ „ „SEEK #1, Header.NumBytesHeader + 1                    'Advance the file pointer to the beginning of the data section„FOR i = 1 TO Header.NumRecs                           'Now loop through the number of records„ „   Record$ = STRING$(Header.NumBytesRec, " ")         'Create a variable string length of length= record length„   GET #1, , Record$                                  'Read in the number of bytes in one record„ „   Length = 2„   FOR j = 1 TO NumFields                             'Now display each field by extracting the correct number of„ „      IF LEFT$(Record$, 1) = "*" AND DELETED THEN EXIT FOR 'The leftmost character in each record is ASCII &H2A if record is„                                                      ' marked as deleted or &H20 if not deleted„                                                      ' change to NOT DELETED to view all records, DELETED to view only„                                                      ' non-deleted records„      a$ = MID$(Record$, Length, ASC(FieldDes(j).Length))   'Characters for each field„      SELECT CASE FieldDes(j).FType                   'Now assign the fields the correct type„         CASE "D"                                     'Date„            a$ = MID$(a$, 5, 2) + "/" + MID$(a$, 7, 2) + "/" + MID$(a$, 3, 2)„            PRINT a$„         CASE "C"                                     'Character„            PRINT a$„         CASE "N"                                     'Turn numeric fields into DOUBLE types„            IF FieldDes(j).DecimalCount <> " " THEN„               a# = VAL(a$) / 10 ^ VAL(FieldDes(j).DecimalCount)„            ELSE„               a# = VAL(a$)„            END IF„            PRINT a#„         CASE "L"                                     'assign an integer to logical types„            IF a$ = "T" OR a$ = "Y" THEN„               a% = -1„            ELSE„               a% = 0„            END IF„            PRINT a%„         CASE "M"„            a& = VAL(a$)                              'memo fields contain a pointer to the 512K block„            IF a& > 0 THEN                            ' of text in the accompanying .DBT file„               GET #2, (a& * 512 + 1), memo           ' read in 512 bytes offset 512*pointer+1„               a$ = memo„               Escape = INSTR(a$, CHR$(&H1A) + CHR$(&H1A))  'each .DBT record ends with &H1A&H1A„               IF Escape THEN                         'stop reading in the record if &H1A&H1A„                  a$ = LEFT$(a$, Escape - 1)„                  Stripchar a$„                  PRINT a$„               ELSE                                   'else keep reading„                  done = FALSE„                  b$ = a$„                  a& = a& + 1„                  DO„                     GET #2, (a& * 512 + 1), memo„                     a$ = memo„                     Escape = INSTR(a$, CHR$(&H1A) + CHR$(&H1A))„                     IF Escape THEN„                        done = TRUE„                        a$ = LEFT$(a$, Escape - 1)„                        Stripchar a$„                        b$ = b$ + a$„                        PRINT b$„                     ELSE„                        Stripchar a$„                        b$ = b$ + a$„                        IF LEN(b$) > 4000 THEN done = TRUE  'concatenate to length of 4000 bytes„                        a& = a& + 1                         ' which is length of memo text displayable„                     END IF                                 ' in dBASE MODIFY COMMAND editor„                  LOOP UNTIL done„               END IF„            END IF„      END SELECT„      Length = Length + ASC(FieldDes(j).Length)„   NEXT j„NEXT i„CLOSE„END„ „REM $STATIC„SUB Stripchar (a$) STATIC„a = INSTR(a$, CHR$(&HA))„DO WHILE a„   temp$ = LEFT$(a$, a - 1)„   temp1$ = RIGHT$(a$, LEN(a$) - a)„   a$ = temp$ + temp1$„   a = INSTR(a$, CHR$(&HA))„LOOP„a = INSTR(a$, CHR$(&H8D))„DO WHILE a„   temp$ = LEFT$(a$, a - 1)„   temp1$ = RIGHT$(a$, LEN(a$) - a)„   a$ = temp$ + CHR$(&HD) + temp1$„   a = INSTR(a$, CHR$(&H8D))„LOOP„END SUB„Robert Loggins                 NFL LOGO                       NFL,LOGO                       Year of 1989 (00:00)   QB, QBasic, PDS        13   1001     NFL.BAS     'LOGDOG SOFTWARE„'PROGRAMMED BY ROBERT LOGGINS 1989 S. LEX-SPRINGMILL MANSFIELD, OHIO 44904„CLS„SCREEN 12„PAINT (1, 1), 7„NFL$ = "UE2RER5ER10ER2E2U56G2L3GL9HLH8UBD2LG7LGL9HL3H2D56F2R2FR10FR5FRFBU2P1,1BE1C15ERER5ER10ER2U29L44D29R2FR10FR5FRBU2P15,15BR4C4LU14ER2F2U6G2L2HU7ER3F2RHULU2L10F2D23GRFRBU1P4,4BR7BD1UR10E3U5H2L2GD2RFD3GL2HU21E2L7F2D22"„NFL$ = NFL$ + "GLBR2P4,4BL18D2HL2HU4H2U4HU4HGD13FDFL3HLU2HUHREU17H2R6DFD3FD4BH3P4,4BF4D4BH1P4,4BF2EU13H2R6GD23BL2P4,4"„NFL$ = NFL$ + "BU17BH13C15EFBU2L2EBU4BL1EFBU2L2EBU4BL1EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBF3BR8EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBD10BL37EFBU2L2EBF3BR2EFBU2L2EBF3BR14EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2E"„NFL$ = NFL$ + "BD10BL37EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBF3BR2EFBU2L2EBL20ERE2UE2U5G4FG5D2EBU1P15,15BL2DHG2BE3E4HG7U4EUEUE3R2EUEF2RG4HG5DGU2BE4P15,15BU10EFBU2L2E"„NFL$ = NFL$ + "BR26BD63C0F2DEUED4BL4UEHDBG2BL1U3EL2" 'The TM thing„PSET (310, 260), 1„DRAW NFL$„„Quinn Tyler Jackson            NODELIST READER AND COMPILER   FidoNet QUIK_BAS Echo          02-13-93 (00:00)       PDS, VB                140  3600     NODELIST.BAS'NAME:          NODELIST.BAS„'DESC:          Nodelist reader and compiler„'DIALECT:       PDS 7.1 or VBDOS 1.0„'AUTHOR:        Quinn Tyler Jackson  13 Feb 1993„'       (With great thanks to Coridon Henshaw's original NODELIST.BAS)„'               (My version is 10 times faster than his was.)„'$DYNAMIC„ „DEFINT A-Z„TYPE NodelistType„		  Zone            AS INTEGER„		  Region          AS INTEGER„		  Net             AS INTEGER„		  Node            AS INTEGER„		  System          AS STRING * 36„		  Location        AS STRING * 36„		  Sysop           AS STRING * 36„		  Phone           AS STRING * 20„		  BPS             AS STRING * 5„		  Flags           AS STRING * 50„END TYPE„ „CONST ENTRY_BUFFER = 256„CONST DATA_FIELDS = 8„ „DIM SHARED BufferPtr AS INTEGER„ „CLS„ParseNodelist "NODELIST.022", "NODELIST.DBF"„ „REM $STATIC„FUNCTION BreakString% (OutArray() AS STRING * 50, InString AS STRING)„ „ON LOCAL ERROR GOTO HandleError„ „Ptr = 1„DO„	  Comma = INSTR(Ptr, InString, ",")„	  OutArray(OutArrayPtr) = MID$(InString, Ptr, (Comma - Ptr))„	  Ptr = Comma + 1„	  OutArrayPtr = OutArrayPtr + 1„	  IF OutArrayPtr = 7 THEN„		  OutArray(7) = MID$(InString, Ptr)„		  EXIT DO„	  END IF„LOOP UNTIL Comma = 0„ „BreakString = OutArrayPtr„EXIT FUNCTION„ „HandleError:„'BreakString = 0„RESUME ExitFunction„ „ExitFunction:„ „END FUNCTION„ „STATIC SUB FlushBuffers (FlushFileHandle, NodeList() AS NodelistType)„ „FOR Ptr = 0 TO BufferPtr„ „	 RecNum = RecNum + 1„	 PUT #FlushFileHandle, RecNum, NodeList(Ptr)„ „NEXT Ptr„ „REDIM NodeList(0 TO ENTRY_BUFFER) AS NodelistType„BufferPtr = 0„ „END SUB„ „SUB ParseNodelist (NodelistFile AS STRING, ParsedListFile AS STRING)„ „StartTime! = TIMER„IF DIR$(ParsedListFile) <> "" THEN„	 KILL ParsedListFile„END IF„ „'$STATIC„DIM NodelistBuffer(0 TO 7) AS STRING * 50„DIM NodeList(0 TO ENTRY_BUFFER) AS NodelistType„'$DYNAMIC„ „BufferPtr = 0„ „NodelistHandle = FREEFILE„OPEN NodelistFile FOR INPUT AS NodelistHandle LEN = 1024„ParsedListHandle = FREEFILE„OPEN ParsedListFile FOR RANDOM AS ParsedListHandle LEN = LEN(NodeList(0))„ „DO„		  LINE INPUT #NodelistHandle, Buffer$„ „					 Options = BreakString(NodelistBuffer(), Buffer$)„ „					 SELECT CASE LEFT$(Buffer$, 1)„								CASE "Z"„										  TempZone = VAL(NodelistBuffer(1))„								CASE "R"„										  TempRegion = VAL(NodelistBuffer(1))„								CASE "H"„										  SELECT CASE LEFT$(Buffer$, 3)„												CASE "Hos"„													 TempNet = VAL(NodelistBuffer(1))„												CASE "Hub"„													 TempNode = VAL(NodelistBuffer(1))„										  END SELECT„								CASE ","„										  TempNode = VAL(NodelistBuffer(1))„								CASE ELSE„									 GOTO JumpPast„					 END SELECT„ „					 NodeList(BufferPtr).Zone = TempZone„					 NodeList(BufferPtr).Region = TempRegion„					 NodeList(BufferPtr).Net = TempNet„					 NodeList(BufferPtr).Node = TempNode„					 NodeList(BufferPtr).System = NodelistBuffer(2)„					 NodeList(BufferPtr).Location = NodelistBuffer(3)„					 NodeList(BufferPtr).Sysop = NodelistBuffer(4)„					 NodeList(BufferPtr).Phone = NodelistBuffer(5)„					 NodeList(BufferPtr).BPS = NodelistBuffer(6)„					 NodeList(BufferPtr).Flags = NodelistBuffer(7)„ „					 REDIM NodelistBuffer(0 TO 7) AS STRING * 50„ „BufferPtr = BufferPtr + 1„ „IF BufferPtr = ENTRY_BUFFER THEN„	 FlushBuffers ParsedListHandle, NodeList()„END IF„ „JumpPast:„LOOP UNTIL EOF(NodelistHandle)„ „FlushBuffers ParsedListHandle, NodeList()„PRINT INT(TIMER - StartTime! + .5); "seconds."„ „END SUB„Jane Griscti                   PRINT SOURCE CODE LISTING      Night Owl v10 CD-ROM           Year of 1993           QB, QBasic, PDS        1167 39175    QBLISTER.BAS'****************************************************************************„'* QBLISTER.BAS  Program prints QBasic or QuickBasic source code listings.„'*               The output is formatted at 12cpi with a left margin, page„'*               breaks, title, and numbers.„'*               Lines which exceed 96 chrs are broken at logical points.„'*               The user can select:„'*                  a file from any drive or directory.„'*                  to print a complete, continuous listing„'*                  to print a full listing with subs and functions„'*                    printed on seperate pages, or„'*                  to print only one sub or function„'*„'*               Limitations: File read must be in ASCII„'*                            No way to intercept DOS drive access errors„'*                            No way to access print spooler„'*                    „'*               Usage Notes: Printer codes are for IBM/Epson compatibles„'*                            See PrintFile Sub-routine„'* Jane Griscti (c) 1993„'*  jgriscti@vnet.ibm.com  or jane.griscti@canrem.com„'****************************************************************************„DEFINT A-Z„„'******************************************„'*            Type Definitions            *„'******************************************„TYPE Lst„	Choice  AS INTEGER              'index of currently selected item„	LCol    AS INTEGER              'Starting column„	MaxLen  AS INTEGER              'width of list„	Rows    AS INTEGER              'number of rows to be displayed„	TopRow  AS INTEGER              'starting display line„	CurRow  AS INTEGER              'screen row of current selection„	TopEl   AS INTEGER              'first array element to be displayed„END TYPE„„'******************************************„'*  SubRoutine and Function Declarations  *„'******************************************„DECLARE SUB Backdrop (TitleColor)„DECLARE SUB BoxSL (TRRow, TRCol, BRRow, BRCol, Shadow, Title$)„DECLARE SUB CleanUp (OldDrv$, OldDir$)„DECLARE SUB DrawScreen1 ()„DECLARE SUB DrawScreen2 ()„DECLARE SUB GetCurrPath ()„DECLARE SUB GetDirNames (CurrDir$)„DECLARE SUB GetFiles (CurrDir$)„DECLARE SUB InitDrvs ()„DECLARE SUB InitDirs ()„DECLARE SUB InitFiles ()„DECLARE SUB InitSubsFuncs ()„DECLARE SUB PrintFile (FileName$, SepPages, SearchName$)„DECLARE SUB PrintHeader (Margin, Header$, Lines, PageNo)„DECLARE SUB ScrollLst (Array$(), Table AS Lst, Action%, Wnd%)„DECLARE SUB SelectDrv (Wnd)„DECLARE SUB SelectDir (Wnd)„DECLARE SUB SelectFile (FileName$)„DECLARE FUNCTION Answer% (Prompt$)„DECLARE FUNCTION LastEl% (a$())„„„'******************************************„'*     Define Variables and Arrays        *„'******************************************„COMMON SHARED FGColor AS INTEGER, BGColor AS INTEGER, OldColor AS INTEGER„COMMON SHARED CurrDir AS STRING, CurrDrv AS STRING„REDIM SHARED DirNames$(50), FileNames$(100), Funcs$(50), Subs$(50)„DIM SHARED DrvLst AS Lst, FileLst AS Lst, DirLst AS Lst, DrvNames$(5)„DIM SHARED SubLst AS Lst, FuncLst AS Lst„„' --------- Fill DrvNames$ array„DrvNames$(1) = " [ A ]"„DrvNames$(2) = " [ B ]"„DrvNames$(3) = " [ C ]"„DrvNames$(4) = " [ D ]"„DrvNames$(5) = " [ E ]"„„'******************************************„'*      Set up Error Handler              *„'******************************************„ON ERROR GOTO CheckError                    'if error goto this label„„„'******************************************„'*       Initialize and draw the screen   *„'******************************************„WIDTH 80, 25: SCREEN 0                  'set screen page and size„OldColor = SCREEN(CSRLIN, POS(0), -1)   'save original screen colors„ENVIRON "DIRCMD="                       'make sure no /P(AUSE) in dir command„FGColor = 8                             'foreground color - grey„BGColor = 3                             'bacground color - cyan„COLOR FGColor, BGColor                  'set colors„CLS                                     'clear screen„CALL GetCurrPath                        'get default drive and directory„CALL DrawScreen1                        'Draw display screen„OldDrv$ = CurrDrv$                      'save original drive„OldDir$ = CurrDir$                      'save original directory„„' ---------- Initialize lists„CALL InitDrvs„CALL InitDirs„CALL InitFiles„CALL InitSubsFuncs„		 „' ---------- Display default directory and files„DrvLst.Choice = ASC(CurrDrv$) - 65 + 1      'select current drive as default„CALL ScrollLst(DrvNames$(), DrvLst, 1, 1)„CALL GetDirNames(CurrDir$)„CALL ScrollLst(DirNames$(), DirLst, 1, 2)„CALL GetFiles(CurrDir$)„CALL ScrollLst(FileNames$(), FileLst, 1, 3)„„„'******************************************„'*          Main loop                     *„'******************************************„Wnd = 3                                 'set FileNames as active Window„„DO WHILE Wnd <> -1„   SELECT CASE Wnd„	  CASE 1„	CALL ScrollLst(DrvNames$(), DrvLst, 0, Wnd)„	  CASE 2„	CALL ScrollLst(DirNames$(), DirLst, 0, Wnd)„	  CASE 3„	CALL ScrollLst(FileNames$(), FileLst, 0, Wnd)„	  CASE 4„	CALL ScrollLst(Funcs$(), FuncLst, 0, Wnd)„	  CASE 5„	CALL ScrollLst(Subs$(), SubLst, 0, Wnd)„	  CASE 10„	CALL DrawScreen1„	CALL SelectDrv(Wnd)„	CALL ScrollLst(DrvNames$(), DrvLst, 1, 1)„	CALL ScrollLst(DirNames$(), DirLst, 1, 2)„	CALL ScrollLst(FileNames$(), FileLst, 1, 3)„	 „	  CASE 20„	CALL SelectDir(Wnd)„	CALL ScrollLst(DrvNames$(), DrvLst, 1, 1)„	CALL ScrollLst(DirNames$(), DirLst, 1, 2)„	CALL ScrollLst(FileNames$(), FileLst, 1, 3)„„	  CASE 30„	' ------ Setup Filename„	FileName$ = FileNames$(FileLst.Choice)„„	' ------ Make sure selected file is in ASCII„	OPEN FileName$ FOR INPUT AS #1„	LINE INPUT #1, LineBuffer$„	CLOSE #1„	   „	Char$ = LEFT$(LineBuffer$, 1)„	CharVal = ASC(Char$)„„	IF CharVal = 252 THEN                   'file is in Binary format„	  CALL Backdrop(0)„	  COLOR 7, 4„	  CALL BoxSL(10, 8, 15, 72, 1, "")„	  COLOR 7, 4„	  LOCATE 12, 10„	  PRINT FileName$; " is a binary file...please select an ASCII file"„	  LOCATE 13, 27„	  PRINT "Press any key to continue..."„	  BEEP: BEEP„	  WHILE INKEY$ = "": WEND„	  COLOR FGColor, BGColor„	  CLS„	  Wnd = 10„	END IF„	   „	IF Wnd <> 10 THEN               ' OK, file is ASCII„	  ' ------ Find out if user wants to print complete file„	  CALL Backdrop(0)„	  CALL BoxSL(9, 15, 13, 70, 1, "")„	  LOCATE 11, 18„	  IF Answer%("Print entire file?") THEN„		LOCATE 12, 18„		IF Answer%("Print FUNCTIONS and SUBS on seperate pages?") THEN„		  SepPages = 1„		ELSE„		  SepPages = 0„		END IF„		Wnd = 60„	  ELSE„		CALL SelectFile(FileName$)„		CALL DrawScreen2„		CALL ScrollLst(Funcs$(), FuncLst, 1, 4)„		CALL ScrollLst(Subs$(), SubLst, 1, 5)„		Wnd = 5„	  END IF„	END IF„„	  CASE 40, 50, 60„	IF Wnd = 40 THEN„	  SearchName$ = "FUNCTION " + Funcs$(FuncLst.Choice)„	ELSEIF Wnd = 50 THEN„	  SearchName$ = "SUB " + Subs$(SubLst.Choice)„	ELSE„	  SearchName$ = ""„	END IF„	   „	CALL PrintFile(FileName$, SepPages, SearchName$)„	   „	Wnd = 10                      'go back to drv,dir,filename display„	„	 END SELECT„LOOP„ „CALL CleanUp(OldDrv$, OldDir$)                  'reset orig colors,dir„„END                                             'end program„„'----------- Error handling routine„„CheckError:„	'----------- Printer not on„	IF ERR = 25 THEN„	   LOCATE 20, 25„	   COLOR 7, 4                      ' set colors to red and white„	   PRINT "Please turn on your printer"„	   COLOR FGColor, BGColor„	   RESUME„	END IF„	 „„	'----------- Input past end of file„	IF ERR = 62 THEN„	   EmptyFile = 1„	   FileNames$(1) = " < No Files Found >"„	   RESUME NEXT„	END IF„„		 „	'----------- Unexpected error„	COLOR 7, 4                          'set colors to red and white„	BEEP                                'make a noise to alert user„	LOCATE 23, 20„	PRINT "Unexpected Error: "; ERR;    'print error message„	PRINT "Press any key to End."„	CLOSE                               'force close of any open files„	WHILE INKEY$ = "": WEND             'pause to read message„	CALL CleanUp(OldDrv$, OldDir$)      'reset orig colors, dir„	END                                 'exit program„„FUNCTION Answer% (Prompt$)„'***************************************************************************„'* FUNCTION:            Answer„'*„'* PARAMETERS:          Prompt$    Question to be asked„'***************************************************************************„„' ------ Ask the question„PRINT Prompt$; " (Y/N)"„„' ------ Wait for Y or N to be pressed„DO„  Ky$ = INKEY$„  IF LEN(Ky$) AND INSTR("YyNn", Ky$) > 0 THEN EXIT DO„LOOP„„' ------ Return 0 for N, Non-zero for Yes„Answer% = INSTR("Yy", Ky$)„„END FUNCTION„„SUB Backdrop (TitleColor)„'****************************************************************************„'* SUB FUNCTION:    Backdrop„'*                  Draws the background screen by repeating a pattern of„'*                  characters.  Places a title on the bottom screen row.„'* PARAMETERS:      TitleColor  - color to use for printing screen title„'****************************************************************************„„LOCATE 1, 17                    'position cursor„COLOR TitleColor, BGColor       'print title in black instead of grey„PRINT "QBasic or QuickBasic Source Code Print Utility";„COLOR FGColor, BGColor„PRINT STRING$(1840, 177);       'fill the screen with CHR$(177)„LOCATE 25, 1                    'locate cursor„PRINT "QBLISTER  v1.00, (c) 1993, Jane Griscti";„„END SUB„„SUB BoxSL (TLRow, TLCol, BRRow, BRCol, Shadow, Title$) STATIC„'****************************************************************************„'* SUB FUNCTION:    BoxSL„'*                  Draws a solid box with a single line border, an„'*                  optional shadow and title.  Parameters define top left„'*                  and bottom right corners of box to be drawn.„'*„'* PARAMETERS:      TLRow       Top Left Row coordinate„'*                  TLCol       Top Left Column coordinate„'*                  BRRow       Bottom Right Row coordinate„'*                  BRCol       Bottom Right Column coordinate„'*                  Shadow      0 = do not draw shadow„'*                              1 = draw shadow„'*                  Title$      Blank string = no title„'*„'****************************************************************************„„	LOCATE TLRow, TLCol             'position cursor„„	'----- Draw the top of the box„	PRINT CHR$(218) + STRING$(BRCol - TLCol - 1, 196) + CHR$(191);„„	'----- Print the title„	IF Title$ <> "" THEN                            'if string is not empty„	  IF LEN(Title$) < (BRCol - TLCol + 2) THEN     'if string not too long„		LOCATE TLRow, TLCol + 1                     'position cursor„		PRINT CHR$(60) + Title$ + CHR$(62)          'print title string„	  END IF„	END IF„„	'----- Draw the middle of the box„	FOR i = TLRow + 1 TO BRRow - 1„	  LOCATE i, TLCol„	  PRINT CHR$(179) + STRING$(BRCol - TLCol - 1, 32) + CHR$(179);„	NEXT„„	'----- Draw the bottom of the box„	LOCATE BRRow, TLCol„	PRINT CHR$(192) + STRING$(BRCol - TLCol - 1, 196) + CHR$(217);„„	„	IF Shadow THEN                      'if Shadow flag = 1 then„					' draw right side of shadow„	FOR i = TLRow + 1 TO BRRow          'top of loop„	  Clr = SCREEN(i, BRCol + 1, 1)     'Get existing screen color„	  COLOR 0, Clr \ 16                 'Use hi byte for background color„	  LOCATE i, BRCol + 1               'Position the cursor„	  PRINT CHR$(177) + CHR$(177);      'Print Shadow character„	NEXT                                'bottom of loop„					' draw bottom shadow„	FOR i = TLCol + 2 TO BRCol + 2      'top of loop„	  Clr = SCREEN(BRRow + 1, i, 1)     'get existing screen color„	  COLOR 0, Clr \ 16                 'use hi byte for background color„	  LOCATE BRRow + 1, i               'position cursor„	  PRINT CHR$(177);                  'print shadow character„	NEXT                                'bottom of loop„„	END IF                              'end of shadow drawing„„END SUB                                 'exit this routine„„SUB CleanUp (OldDrv$, OldDir$)„'***************************************************************************„'* SUB:         CleanUp„'*                Resets the system to original colors, drive and directory„'*„'* PARAMETERS:  OldDrv$     Original Drive letter„'*              OldDir$     Original Directory Name„'***************************************************************************„„CLOSE                                   ' make sure all files are closed„COLOR OldColor AND 15, OldColor \ 16„CLS„DosCom$ = OldDrv$ + ":"„SHELL DosCom$„DosCom$ = "cd " + OldDir$„SHELL DosCom$„„END SUB„„SUB DrawScreen1„'***************************************************************************„'* SUB FUNCTION:        DrawScreen1„'*                      Draws the initial display screen„'* PARAMETERS:          None„'***************************************************************************„„CALL Backdrop(0)                        'draw background grey, cyan„CALL BoxSL(3, 5, 6, 75, 1, "")          'draw Instructions Box„LOCATE 4, 6                             'position cursor„PRINT "   [TAB] - Move between windows" 'print instruction„LOCATE 5, 6                             'position cursor„PRINT "[Arrows] - Highlight selection"  'print instruction„LOCATE 4, 40                             'position cursor„PRINT "[ENTER] - Accept selection"       'print instruction„LOCATE 5, 40                            'position cursor„PRINT "  [ESC] - EXIT"                  'display instruction„„CALL BoxSL(9, 5, 15, 20, 1, "Drives")   'draw Drive List Box„„CALL BoxSL(17, 5, 20, 20, 1, "Directory")  'draw Curr Dir box„LOCATE 17, 6„„CALL BoxSL(9, 25, 22, 45, 1, "Sub-Directories")'draw Directory List Box„LOCATE 9, 26                            ' position cursor„„CALL BoxSL(9, 50, 22, 75, 1, "Files")   'draw File List Box„LOCATE 9, 51                            'position cursor„„„END SUB„„SUB DrawScreen2„'***************************************************************************„'* SUB:         DrawScreen2„'*              Draw screen for display of Sub-Routine and Function Names„'*„'***************************************************************************„CALL Backdrop(0)„CALL BoxSL(3, 5, 6, 71, 1, "")„LOCATE 4, 10„PRINT "[TAB] to move between windows               [ESC] to exit"„LOCATE 5, 10„PRINT "[ENTER] to select Function or Sub-routine"„CALL BoxSL(9, 5, 22, 35, 1, "Functions")„CALL BoxSL(9, 40, 22, 71, 1, "Sub-Routines")„„END SUB„„SUB GetCurrPath„'***************************************************************************„'* SUB:                 GetCurrPath„'*                         Gets the current path name„'* PARAMETERS:          None„'* SHARED VARIABLES:    CurrDir$„'*                      CurrDrv$„'***************************************************************************„„  SHELL "dir *. > tmppath.dat"        'capture current dir info in file„  OPEN "tmppath.dat" FOR INPUT AS #1  'open file for input„  FOR i = 1 TO 4                      'loop to fourth line„  INPUT #1, x$                       'assign lines to temp variable„  NEXT i„  CLOSE 1„  Y = LEN(x$)                         'store the string length„  CurrDir$ = MID$(x$, 14, Y - 12)     'capture directory name„  CurrDrv$ = LEFT$(CurrDir$, 1)       'capture drive letter„  SHELL "del tmppath.dat"             'delete temporary file„„END SUB„„SUB GetDirNames (CurrDir$)„'***************************************************************************„' SUB ROUTINE:      GetDirNames„'*                  Displays the sub-directories assocated with current„'*                  directory and highlights the currently selected directory„'* PARAMETERS:      CurrDir$        Current directory„'***************************************************************************„„IF LEN(CurrDir$) > 3 THEN„  '---------- Write subdirectory names to temp file„  DosCom$ = "dir " + CurrDir$ + "\*.  /on >tmpdir.dat"    'set up DOS command„  SHELL DosCom$                                           'run DOS„ELSE„  DosCom$ = "dir *. /on >tmpdir.dat"„  SHELL DosCom$„END IF„„  '---------- Write names to an array, assumes no more than 50 dir names„  REDIM DirNames$(50)                        're-dimension array„  i = 0                                      'count variable„  OPEN "TMPDIR.DAT" FOR INPUT AS #1          'open file to read names„„  DO                                         'start of DO loop„	INPUT #1, x$                           'assign name to array„	IF INSTR(1, x$, "<DIR>") THEN          'make sure it's a dir name„	   i = i + 1                           'increment counter„	   DirNames$(i) = LEFT$(x$, 8)         'if it is, save name array„	END IF„  LOOP WHILE NOT (EOF(1))                    'while not end of file„„  CLOSE 1                                    'close file„  SHELL "del tmpdir.dat"                     'delete temporary file„„' ------------ Put current dir name on screen„LOCATE 19, 8„PRINT SPACE$(12)                             'clear old name„IF LEN(CurrDir$) > 3 THEN„  x = LEN(CurrDir$)                          'length of current path„  Y = 1                                      'position indicator„  WHILE (Y < x) AND (Y <> 0)                 'begin search for "\"„	Y = INSTR(Y, CurrDir$, "\")              'assign positon of "\"„	IF (Y <> 0) THEN                         'match found„	mark = Y                               'save position of "\"„	Y = Y + 1                              'start next search„	END IF„  WEND„  LOCATE 19, 8„  PRINT RIGHT$(CurrDir$, x - mark)„ELSE                                         'you're in the root directory„  LOCATE 19, 8„  PRINT " [ROOT] "„END IF„„END SUB„„SUB GetFiles (CurrDir$)„'***************************************************************************„'* SUB ROUTINE:     GetFiles„'*                  Get the names of all files with the ".BAS" extension„'*                  in the current directory and store them in an array„'* PARAMETERS:      CurrDir$    Current path name„'***************************************************************************„SHARED EmptyFile„EmptyFile = 0„„'---------- Write files names to temp file„IF LEN(CurrDir$) > 3 THEN„  DosCom$ = "dir " + CurrDir$ + "\*.bas /b /on >tmpfiles.dat"„ELSE„  DosCom$ = "dir *.bas /b /on >tmpfiles.dat"„END IF„„SHELL DosCom$                              'run DOS command„„'---------- Write names to an array, assumes no more than 100 file names„REDIM FileNames$(100)                      're-dimension array„i = 1                                      'count variable„„OPEN "TMPFILES.DAT" FOR INPUT AS #1        'open file to read names„IF EmptyFile = 0 THEN„	DO                                         'do„		INPUT #1, FileNames$(i)                'assign name to array„		i = i + 1                              'increment counter„	LOOP WHILE NOT (EOF(1))                    'while not end of file„END IF„„CLOSE 1                                    'close file„„SHELL "del tmpfiles.dat"                   'delete temporary file„„END SUB„„SUB InitDirs„'**************************************************************************„'* SUB:         InitDirs„'*                Sets up starting values for Directory Scroll List„'*„'* PARAMETERS:  None„'* SHARED:      DirLst()„'**************************************************************************„„DirLst.Choice = 1                   'starting array element„DirLst.LCol = 26                    'left column start position„DirLst.MaxLen = 19                  'width of list„DirLst.Rows = 12                    '# of display rows allowed„DirLst.TopEl = 1                    'first array element to be displayed„DirLst.TopRow = 10                  'starting display row„DirLst.CurRow = 1„„END SUB„„SUB InitDrvs„'***************************************************************************„'* SUB:         InitDrvs„'*                Sets up starting values for Drives Scroll List„'*„'* PARAMETERS:  None„'* SHARED:      DrvLst()„'***************************************************************************„„DrvLst.Choice = 1                   'starting array element„DrvLst.LCol = 6                     'left column start position„DrvLst.MaxLen = 14                  'width of list„DrvLst.Rows = 5                     '# of display rows allowed„DrvLst.TopEl = 1                    'first array element to be displayed„DrvLst.TopRow = 10                  'starting display row„DrvLst.CurRow = 1„„END SUB„„SUB InitFiles„'***************************************************************************„'* SUB:         InitFiles„'*                Sets up starting values for Files Scroll List„'*„'* PARAMETERS:  None„'* SHARED:      FileLst()„'**************************************************************************„„FileLst.Choice = 1                  'starting array element„FileLst.LCol = 51                   'left column start position„FileLst.MaxLen = 24                 'width of list„FileLst.Rows = 12                   '# of display rows allowed„FileLst.TopEl = 1                   'first array element to be displayed„FileLst.TopRow = 10                 'starting display row„FileLst.CurRow = 1„„END SUB„„SUB InitSubsFuncs„'***************************************************************************„'* SUB:         InitSubsFuncs„'*                Sets up starting values for Sub-routine and Function„'*                Scroll Lists„'*„'* PARAMETERS:  None„'* SHARED:      SubLst()„'*              FuncLst()„'****************************************************************************„„' ---------- Initialize parameters for Sub-routine List„„SubLst.Choice = 1                   'starting array element„SubLst.LCol = 41                    'left column start position„SubLst.MaxLen = 30                  'width of list„SubLst.Rows = 12                    '# of display rows allowed„SubLst.TopEl = 1                    'first array element to be displayed„SubLst.TopRow = 10                  'starting display row„SubLst.CurRow = 1„„' ---------- Initialize parameters for Function List„„FuncLst.Choice = 1                   'starting array element„FuncLst.LCol = 6                     'left column start position„FuncLst.MaxLen = 29                  'width of list„FuncLst.Rows = 12                    '# of display rows allowed„FuncLst.TopEl = 1                    'first array element to be displayed„FuncLst.TopRow = 10                  'starting display row„FuncLst.CurRow = 1„„END SUB„„FUNCTION LastEl% (a$()) STATIC„'**************************************************************************„'*  FUNCTION:       LastEl„'*                  Finds the last element in a string array„'*  PARAMETERS:     A$  Array being worked on„'**************************************************************************„FOR i = UBOUND(a$) TO 1 STEP -1             'start at the last element„  IF LEN(RTRIM$(a$(i))) THEN                'if it is not null„	LastEl% = i                             'assign function value„	EXIT FUNCTION„  END IF„NEXT                                        'otherwise keep looking„„END FUNCTION„„SUB PrintFile (FileName$, SepPages, SearchName$)„'**************************************************************************„'* SUB:         PrintFile„'*                Routine initializes the printer, opens the selected file„'*                reads, formats and prints each line.„'*„'* PARAMETERS:  FileName$       Name of file to be opened„'*              SepPages        Seperate page for subs/functions indicator„'*                              1 = print seperate pages„'*                              0 = do not print seperate pages„'*              SearchName$     Name of specific Sub or Function to be printed„'*                              Empty string means none selected„'**************************************************************************„„   ' ------ Set up Page and Line counter variables„   PageNo = 0„   Lines = 0„		 „   ' ---------- Make sure printer is online„	CALL Backdrop(0)„	COLOR 7, 4                              'set color to red and white„	CALL BoxSL(9, 15, 15, 70, 1, "")„	COLOR 7, 4„	LOCATE 11, 17„	PRINT "Please ensure your printer is ON and READY for input"„	LOCATE 12, 17„	IF SearchName$ <> "" THEN„	  INPUT "Starting page number"; PageNo„	  IF PageNo > 0 THEN PageNo = PageNo - 1„	END IF„	LOCATE 13, 17„	PRINT "Press any key to continue ..."„	BEEP: BEEP„	WHILE INKEY$ = "": WEND„	COLOR FGColor, BGColor                  ' reset colors„						   „„   ' ------------ Open file and initialize printer settings„	OPEN FileName$ FOR INPUT AS #1    ' open the file for input„„	' *************************************************************„	' * CHANGE THESE CODES IF PRINTER IS NOT IBM/EPSON COMPATIBLE *„	' * OR TO CHANGE CHARACTER SIZE.                              *„	' * Note:  If you change CPI, reconfigure the page header as  *„	' *        it's predefined for 96 CPI.                        *„	' *************************************************************„	CPIChr = 58                       ' 58 = 12 cpi„	PrnLen = 96 - 1                   ' at 12cpi line length=96 chars„	FFChar = 12                       ' Form Feed Character„	TenCPI = 18                       ' 18 = 10 cpi„	ESCChr = 27                       ' ESC code„	LPRINT CHR$(ESCChr); CHR$(CPIChr) ' initialize printer„	'***************************************************************„„	WIDTH LPRINT PrnLen + 1           ' set printer width for cpi„	Margin = 5                        ' left margin width„	Margin$ = STRING$(Margin, " ")    ' build margin string„„   ' ------ Build page title and print first page header„	IF LEN(FileName$) < 12 THEN„	  FileName$ = FileName$ + STRING$(12 - LEN(FileName$), " ")„	END IF„	Header$ = " FILENAME: " + FileName$ + SPACE$(7) + "DATE: " + DATE$„	Header$ = Header$ + SPACE$(8) + "TIME: " + TIME$ + SPACE$(10) + "Page: "„   „	CALL PrintHeader(Margin, Header$, Lines, PageNo)„	   „	   „   ' ------ Get first line to be printed, if entire file was selected„   '        then first line of file = first print line, otherwise, find„   '        the first line of the selected SUB or FUNCTION„	   „	TestStr = LEN(SearchName$)„	LINE INPUT #1, LineBuffer$„	IF TestStr > 1 THEN„	  IF LEFT$(SearchName$, 8) <> "SUB MAIN" THEN„	    DO„	      IF LEFT$(LineBuffer$, TestStr) = SearchName$ THEN„		EXIT DO„	      END IF„	      LINE INPUT #1, LineBuffer$„	    LOOP UNTIL EOF(1)„	  END IF„	END IF„„„	  ' ------ Read each line in the file and print it„„      DO UNTIL EOF(1)„	   „	Temp$ = Margin$ + LineBuffer$„„	  rspc = 0                              'right space marker„	  Temp1$ = ""                           'temp string holder„	  Margin1$ = ""                         'multiple line margin„	„	  DO WHILE LEN(Temp$) > PrnLen„		' ------ Get the first portion of the string„		Temp1$ = RTRIM$(LEFT$(Temp$, PrnLen))„„		' ------ Find the right most space„		i = 1„		DO WHILE i > 0„		  i = INSTR(rspc + 1, Temp1$, " ")„		  IF i > 0 THEN rspc = i„		LOOP„		„		' ------ Print the string portion„		IF Lines > 60 THEN„		  LPRINT CHR$(FFChar)„		  CALL PrintHeader(Margin, Header$, Lines, PageNo)„		END IF„		LPRINT LEFT$(Temp1$, rspc - 1)„		Lines = Lines + 1„	   „		' ------ Increase margin for multiple print lines„		Margin1$ = "  "„	   „		' ------ Assign remainder of original string to Temp$„		Temp$ = Margin$ + Margin1$ + RIGHT$(Temp$, LEN(Temp$) - rspc)„„	  LOOP„	 „	  ' ------ Print short line or last portion of long line„	  IF Lines > 60 THEN„		LPRINT CHR$(FFChar)„		CALL PrintHeader(Margin, Header$, Lines, PageNo)„	  END IF„	  LPRINT Temp$„	  Lines = Lines + 1„	 „	 „	  LINE INPUT #1, LineBuffer$              'get the next line in file„„	  ' ----------- If selected to print SUBS and FUNCTIONS on seperate„	  '             pages, check to see if a new one is encountered„„	IF SepPages = 1 THEN„	  IF LEFT$(LineBuffer$, 3) = "SUB" OR LEFT$(LineBuffer$, 8) = "FUNCTION" THEN„	    LPRINT CHR$(FFChar)                     'issue Form Feed instruction„	    CALL PrintHeader(Margin, Header$, Lines, PageNo)„	  END IF„	END IF„„	  „	  ' ----------- If printing a MAIN, SUB, or FUNCTION, exit loop when you„	  '             reach the end of the routine„„      IF TestStr > 1 THEN„	IF INSTR(SearchName$, "MAIN MODULE") THEN„	  IF LEFT$(LineBuffer$, 3) = "SUB" OR LEFT$(LineBuffer$, 8) = "FUNCTION" THEN„	    CLOSE„	    LPRINT CHR$(FFChar)„	    LPRINT CHR$(TenCPI)„	    EXIT SUB„	  END IF„	END IF„„	IF INSTR(LineBuffer$, "END SUB") OR INSTR(LineBuffer$, "END FUNCTION") THEN„	  EXIT DO„	END IF„      END IF„„   LOOP„	 „   CLOSE                                     'close files„   LPRINT Margin$ + LineBuffer$              'print last line in file„   LPRINT CHR$(FFChar)                       'send final form feed„   LPRINT CHR$(TenCPI);                      'set printer back to 10cpi„END SUB„„SUB PrintHeader (Margin, Header$, Lines, PageNo)„'***************************************************************************„'* SUB:         PrintHeader„'*                Prints the page title centered in a graphics box„'*„'* PARAMETERS:  Margin      left margin width„'*              Header$     title to be printed„'*              Lines       line counter„'*              PageNo      page counter„'***************************************************************************„„PageNo = PageNo + 1                     ' increase page counter„Lines = 5                               ' reset line counter„LPRINT SPC(Margin); CHR$(201) + STRING$(88, 205) + CHR$(187)„LPRINT SPC(Margin); CHR$(186); Header$;„LPRINT USING "##"; PageNo;„LPRINT SPC(2); CHR$(186)„LPRINT SPC(Margin); CHR$(200) + STRING$(88, 205) + CHR$(188);„LPRINT : LPRINT„„END SUB„„SUB ScrollLst (Array$(), Table AS Lst, Action, Wnd)„'***************************************************************************„'* SUB ROUTINE:         ScrollLst„'*                      Routines allows scrolling through a list of array„'*                      names„'*„'* PARAMETERS:          Array$()    Array of items to be scrolled„'*                      Table       Parameters applied to array„'*                      Action      0  bypass initial display„'*                                  1  display and poll for keypress„'*                      Wnd         1  Drives Window„'*                                  2  Directory Window„'*                                  3  File Window„'*                                  4  Functions Window„'*                                  5  Sub-Routine Window„'*„'**************************************************************************„„' ------ Set up parameters for list„TopRow = Table.TopRow                   ' start screen row for display„Rows = Table.Rows                       ' no. of rows to display„BotRow = Rows + TopRow - 1              ' bottom screen row of display„LastCh = Table.Choice                   ' current array element„LastCurRow = Table.CurRow               ' last array choice display row„Elements = LastEl%(Array$())            ' # of elements in Array$„„„' ------ Display the list„„	' ------ Are there more display rows than elements?„	IF Rows > Elements THEN„	   Rows = Elements                  ' reduce displayed rows„	   FOR i = Rows TO Table.Rows       ' blank out extra rows„	  LOCATE i + TopRow - 1, Table.LCol„	  PRINT STRING$(Table.MaxLen, 32);„	   NEXT i„	END IF„„	' ------ Are there more elements than display rows?„	IF Elements > Table.Rows AND Action = 0 THEN„	  LastPtrRow = BotRow„	  Ptr = -1„	  RSide$ = CHR$(176)„	  FOR i = 1 TO Rows„	LOCATE i + TopRow - 1, Table.LCol + Table.MaxLen„	PRINT RSide$;„	  NEXT i„	ELSE„	  RSide$ = CHR$(179)„	  Ptr = 0„	END IF„   „	GOSUB Scroll„„IF Action = 0 THEN„  Ptr = -1„  LOCATE Table.CurRow, Table.LCol + Table.MaxLen„  PRINT CHR$(17);„END IF„„DO WHILE Action = 0„  k$ = INKEY$„ „  SELECT CASE LEN(k$)„	CASE 0„	  KeyCode = 0„	  x = 0„	CASE 1„	  KeyCode = ASC(k$)„	CASE 2„	  KeyCode = ASC(RIGHT$(k$, 1))„  END SELECT„„  SELECT CASE KeyCode„	CASE 27                             'ESC„	  IF Wnd = 4 OR Wnd = 5 THEN        'if in Subs/Func screen return to„	Wnd = 10                        'main screen„	  ELSE                              'else„	Wnd = -1                        '  exit program„	  END IF„	  EXIT SUB„	„	CASE 13                             'ENTER„	   „	' ------ Erase pointer in current window„	LOCATE LastCurRow, Table.LCol„	Temp$ = Array$(LastCh)„	Temp$ = Temp$ + SPACE$(Table.MaxLen - LEN(Temp$)) + CHR$(176)„	PRINT Temp$;„	 „	  IF Wnd = 1 THEN Wnd = 10          'based on active Window„	  IF Wnd = 2 THEN Wnd = 20          'select actions to follow„	  IF Wnd = 3 THEN Wnd = 30„	  IF Wnd = 4 THEN Wnd = 40„	  IF Wnd = 5 THEN Wnd = 50„	  EXIT SUB„„	CASE 9                              'TAB„„	' ------ Erase pointer in current window„	LOCATE LastCurRow, Table.LCol„	Temp$ = Array$(LastCh)„	Temp$ = Temp$ + SPACE$(Table.MaxLen - LEN(Temp$)) + CHR$(176)„	PRINT Temp$;„	 „	  IF Wnd = 1 THEN                  'based on active Window„	Wnd = 2                        ' move to next Window„	EXIT SUB„	  ELSEIF Wnd = 2 THEN„	Wnd = 3„	EXIT SUB„	  ELSEIF Wnd = 3 THEN„	Wnd = 1„	EXIT SUB„	  ELSEIF Wnd = 4 THEN„	Wnd = 5„	EXIT SUB„	  ELSEIF Wnd = 5 THEN„	Wnd = 4„	EXIT SUB„	  END IF„„	CASE 72                             ' up  arrow„	  x = -1„	CASE 80                             ' down arrow„	  x = 1„  END SELECT„„  ' ------ Handle the direction keys„  IF x THEN„	Table.Choice = Table.Choice + x„„	' ------ Make sure choice is within array range„	IF Table.Choice > Elements THEN„	  BEEP„	  Table.Choice = Elements„	END IF„	IF Table.Choice < 1 THEN„	  BEEP„	  Table.Choice = 1„	END IF„	IF Table.Choice > Table.TopEl + Rows - 1 THEN„	  Table.TopEl = Table.TopEl + x„	END IF„	IF Table.Choice < LastCh AND Table.TopEl = LastCh THEN„	  Table.TopEl = Table.Choice„	END IF„„	IF Table.Choice <> LastCh THEN„	  GOSUB Scroll„	END IF„  END IF„LOOP„„EXIT SUB„„Scroll:„„' ------ Print array„LOCATE , , 0                            ' turn off the cursor„„' ------ Determine the Current display row„„Table.CurRow = TopRow + Table.Choice - Table.TopEl„„FOR i = 1 TO Rows„  LOCATE TopRow + i - 1, Table.LCol„  Temp$ = Array$(Table.TopEl + i - 1)„  Temp$ = Temp$ + SPACE$(Table.MaxLen - LEN(Temp$))„  PRINT Temp$„NEXT i„„' ------ If there's a pointer, display it„IF Ptr THEN„  „  ' ------ Erase the previous pointer, if the row is still in range„  LOCATE LastCurRow, Table.LCol„  Temp$ = Array$(LastCh)„  Temp$ = Temp$ + SPACE$(Table.MaxLen - LEN(Temp$)) + CHR$(176)„  PRINT Temp$;„„  '------ Draw the new pointer„  LOCATE Table.CurRow, Table.LCol + Table.MaxLen„  PRINT CHR$(17);„  LastCurRow = Table.CurRow„„END IF„ „' ------ Highlight the current array choice„COLOR BGColor, FGColor                  ' reverse colors for hi-light„LOCATE Table.CurRow, Table.LCol„Temp$ = Array$(Table.Choice)„Temp$ = Temp$ + SPACE$(Table.MaxLen - LEN(Temp$))„PRINT Temp$„LastCh = Table.Choice„LOCATE Table.CurRow, Table.LCol„COLOR FGColor, BGColor                  ' reset colors„„RETURN„„END SUB„„SUB SelectDir (Wnd)„'***************************************************************************„'* SUB:         SelectDir„'*                Changes to the directory chosen by the user„'*„'* PARAMETERS:  Wnd     Active window number„'***************************************************************************„„IF DirNames$(DirLst.Choice) = ".       " THEN    ' force change to parent„	 SHELL "cd .."„ELSE„	 DosCom$ = "cd " + DirNames$(DirLst.Choice)  ' change to new directory„	 SHELL DosCom$„END IF„„CALL GetCurrPath„CALL InitDirs„CALL InitFiles„CALL GetDirNames(CurrDir$)„CALL GetFiles(CurrDir$)„„Wnd = 2„„„END SUB„„SUB SelectDrv (Wnd)„'**************************************************************************„'* SUB:         SelectDrv„'*                Changes to the selected drive„'*„'* PARAMETERS:  Wnd     Active window„'**************************************************************************„„	SELECT CASE DrvLst.Choice„	  CASE 1„		LOCATE 7, 10„		COLOR 7, 4„		BEEP„		PRINT "Please insert Diskette in Drive A. ";„		PRINT "Press any key to continue..."„		COLOR FGColor, BGColor„		BEEP„		WHILE INKEY$ = "": WEND„		SHELL "a:"„	  CASE 2„		LOCATE 7, 10„		COLOR 7, 4„		BEEP„		PRINT "Please insert Diskette in Drive B. ";„		PRINT "Press any key to continue..."„		COLOR FGColor, BGColor„		BEEP„		WHILE INKEY$ = "": WEND„		SHELL "b:"„	  CASE 3„		SHELL "c:"„	  CASE 4„		SHELL "d:"„	  CASE 5„		SHELL "e:"„	END SELECT„„	CALL GetCurrPath„	CALL GetDirNames(CurrDir$)„	CALL GetFiles(CurrDir$)„	CALL InitDirs„	CALL InitFiles„	CALL ScrollLst(DirNames$(), DirLst, 1, 2)„	CALL ScrollLst(FileNames$(), FileLst, 1, 3)„	Wnd = 2„„END SUB„„SUB SelectFile (FileName$)„'**************************************************************************„'* SUB          SelectFile„'*                  Reads SUB and FUNCTION names from the user selected„'*                  file into the appropriate arrays.„'*„'* PARAMETERS:  FileName$   Name of user selected file„'*„'* SHARED:      Subs$()„'*              Funcs$()„'**************************************************************************„„REDIM Subs$(50), Funcs$(50)„„OPEN FileName$ FOR INPUT AS #1„	 „i = 1                                   'counter for SUB array„j = 1                                   'counter for FUNCTION array„„' -------- Assign MAIN as first name of SUB's array„Subs$(1) = "MAIN MODULE ONLY"„i = 2„„' --------  Search for SUB and FUNCTION names.  These are assigned„'           to arrays and displayed on the screen.„„DO UNTIL EOF(1)„  LINE INPUT #1, LineBuffer$„„  FoundSub = INSTR(LineBuffer$, "DECLARE SUB")„  FoundFunc = INSTR(LineBuffer$, "DECLARE FUNCTION")„„  IF FoundSub > 0 AND LEFT$(LineBuffer$, 7) = "DECLARE" THEN„	FOR k = 13 TO LEN(LineBuffer$)„	  Char$ = MID$(LineBuffer$, k, 1)„	  IF Char$ <> " " THEN„	SubName$ = SubName$ + Char$„	  ELSE„	EXIT FOR„	  END IF„	NEXT k„	Subs$(i) = SubName$„	i = i + 1„	SubName$ = ""„  END IF„„  IF FoundFunc > 0 AND LEFT$(LineBuffer$, 7) = "DECLARE" THEN„	FOR k = 18 TO LEN(LineBuffer$)„	  Char$ = MID$(LineBuffer$, k, 1)„	  IF Char$ <> " " THEN„	FuncName$ = FuncName$ + Char$„	  ELSE„	EXIT FOR„	  END IF„	NEXT k„	Funcs$(j) = FuncName$„	j = j + 1„	FuncName$ = ""„  END IF„„LOOP„„CLOSE #1„„END SUB„„Ethan Winer                    CREATE/MODIFY DBF FILES        PC Magazine BASIC Techniques   Year of 1992           QB, PDS                123  8118     DBF.BAS     '>>> Page 1 of DBF.ZIP begins here. TYPE:BINAA TLEN:5737„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"DBF.ZIP",4^6:Z&=5737:?STRING$(50,177);„U"%up()%9%%%%-%(uB&=DQ=CD$)7%%]5%%%1%%%%ig%fhhj%xxSgRfxF&9Xt\k^5M„U"l[/N=#S*Q_i]+^goJ7CAx%bz:f*XhZMfXMRmq.K]AAubqh4jX4-(_lTwn\pjm*Y„U"F7r5MEEE5hKE-xRfUmKmdqLW0Ipp0Q4vEjd<J;kW>MF/Ah<Uj6HR=,S436/j=:A„U".Y54\r*\rXdHX7;zOd7f/fHB?(H(t5e$X6Ti6TcT:7-.;MmsWi3?XiRDDHb5qk8„U"[6jg]PO&,(B;dePb0lN5'']p&CDC>7>O0(pp_5T&<BM4h8-v3E-<,l1h-k]u;&Z„U"02B1oJ5#5L4ur0[KxXgdD[*\Zd<0U'/#WsA0*<VG52>Xd8i+ZTb??hOj#?6f9>O„U"aM#^covshiPrh]0O2)j:k#QEqeFJv3sh,f>c'm&W/R_)?x4_UZ4L[1cN./Mlo3(„U"J&:L>YuJ]^2d5R]<I%gPYkw/TUefa%1A+vR0B6vk4*n0RAJ:]B4_B]evn/PnY3C„U"htG-1)VQl<o%4<U=;_[F;Q%9<uBRIs=:RjI<WYEYa?-hRKH$[p0kZ#N1>.cqfK8„U"gM2gjmet(JXJu3c[fp]7KqkK)-V+dn^m9+87g[W'k=D&=_3Qe*7D9VD_/]WBbLZ„U"#Uwk;TX%G-W05i&4)tF8CpZA8AWYX76uuUkZ9_3QD[=lU<98?*M/cUhF;K_O+g%„U"'LjDqpn/TI]qYj\Abot8Ag$;s_/''P9y?I^<j)*nTG.W.nW8#QU)8#5THLPEzk:„U"3<YgZAvOefayjt/DzKIh[qa^GZRP=XYi+_ZoqE5g*NNmakoI7H6DQ*S/_IFdmJg„U"6#o^>w_sn:Y^cNN8FpAM[fS1V'^v5YgJCxMT6kt.lneRl8aF6;K,'U8(39Dt.1'„U"X7#)/DguYcU:j4=5Z/cPxGpUYMYv_q9*VMp0kG)b6Q9Dn+z_T1\u.pw9.AJ<zpF„U"eIjrO%MVz)BC76DoNXARMbBhUO?7z;G%??UjdWNW_yRZ<h\WsGFHm*pNLZG/FrD„U"z.tHPD8M>A>H0QMDzc*Op.?1Rf/D&dW#KO=&P,TSB3_Hy;<nv]L5SvJ7nF]KTGV„U"JVQUC]j-h9O>r'0xbt,.6q$q61F/=NZZ0rFAEHKZC6+<0B%,qh\BxW&b\(S2yT7„U"zHeIal^IejF+(]wCX=s$G3D-i2M,:r5JNdI3$h-YNEJ*S.qFwbOU2%f]gls9)RM„U"Bgf4pRMD%adyzr^OJfgy'\-jS:-coTwgAh:HO:rC,$GVPGI'b>-4%'pKNz8OO.Y„U"*83zl,vaCoNH7-AXjR'WG3ncSa3SuJI.3PnfTei4E)/c]G)IP]A=ez&9mD\;>%M„U"j+o(?,=k[MT:W9PXxRLxGVLfK.6X:Vju89PJMW6eDcVdk,.)tRcO0Ze/z?.xKV1„U"9$u&d^[3%*9Q5L88[*JPvCn]V/DMWJ#u:iSPusQE/*RgF-]51jI9c#;=3K88J;*„U"U,W>>BsC6?u(j4fx^\oPp6'c&rIzBVK01]?iQYcRyPX=;uQPPE>0&dA?6\tNXs:„U"NGAKugz'5^bT-$M*efWbl/7BscXMFqBWvLK:iO%PFO09P)TrNnD4=q&xepls9_*„U"+D^dCCAS;\qT3QO)7[('<ujr'R\ouUUkew.#_U3^XDd9N%&up(%)9%%%%-%(Fu&„U"=yk;dg3#'%%)%,%%1%%%%i%ghwj%fyjS[gfx6Lz*^i.e9ML0Zdkug8t4Fu3BWP%„U"K_1N(N]#>FxT\Y',P.<_R;?x>L$;-4P'LPdc]kT<pL$1sXvHF+(g9RriS[Z8C7;„U"*0=JZO3/RW$(aGnwe5?uJOl>E.4K(j/F+*2rcttP9oNKCZ:la,wtS1Qlp.TB>pT„U"hIl../eS)MOcTpYksv,2\)FUAUC2%?M-r^HgHG7)Aw#:.2Y8I1cH-Ow)?-f*waC„U"Dr[bO0nM--b.pq<3pG'mI<(<A09?)[b[Z7a%\qq(X3JUGV'MZ0-u>W2:q+ibCN3„U"SqWXp_>WR>w&l5iU)tC6\Q*MbP>Hcb\Gs?<ac#sg'-]r9y*N$T7\sZHL6*mzO5/„U"d1qYsRw).XJ=Hna*w'4Tw15CUB%^*#a=&lcds[ij>BtmhX7>7eO:fMd38_+8nu\„U"D#=mdKl[u&CuWf)];uJe%Y4R/v>12G%qbP-Q4wc4l0b6aM2rCun/ey;2mzFK[%r„U"ykV5VT(G.pnVkcmCCC1.#0Z_P%#TUazveT:%jAa31v>dA-YP(I]w,&5QPAK)C*h„U"K]R24a7l)#eD'6_O5tp]-ImJA2V,qnDWJ(nGK#dJ'/K.pjgvoW&:;E\8g6VIO#7„U"Y,h*RD]ju:CUEmb$:BLIiD:xdE5%,=v5g)Cc[[KR\0>?cbH]Vw:TgMardds]4r5„U":.$XGM#X/nHPHds]>Y(-'(tq97Zv(7>2OqG.]C\V.==IfpDCWWWlO(HHidw4AVn„U"<)xFxl7Gtuu0Zd'\jLFi>dn;t)grrgf._/+;eNMOt$YxPb0%=)9n_jrwX-pEKS=„U"sHvHww?O:3^*_$UjBvr:s>pYK/E,rf<,3Ib4Kxk$>H(7cYLE8Gj^B%Y.'eKk'Cv„U",-dS^jy+<Lmu2LG=l)c$UxkZN%&up(%)9%%%%-%(Fu&=8%wZ3Z%(%%H%.%%/%%%„U"%i%gjin%ySgfOx>%,)>jo58Ll[d;[_hZH-=OL;ZlWP##;,X;O:)wNn\gD\[iE;V„U"'XxLhFE(9^;x?.pwH)oZ\EpkD(^dC[D]0[5Gj3VG^Y/7,iN,mqoqT+[oFPQrS(1„U")3DAyOnyW/D0$xdbrg:I0p+'PPqnPMtqsOt%&o:gA*[If1<lzh1ack'T0X]3/6\„U"m0\YHA?f5VBEpd4,#<bS6$1&tnoPb/wUDr1Xcc01zdZ*:*\<5JVQ]F)DekPjJ+q„U"=y>oHXzj6O8O<%[LV7swPh7X[U(Y]X%sfXv>N9OH4zj++>][.S8^qIKei&.Y=8=„U"0Idu:7JQe),Mn3U/J(yT)38GS0dEpL-nG8:SC5z,1[2$h,1DUP':;m;M#-&_[>B„U"b'\0'$cR1.3-]tfxWO>[\[pq7HrJ$hc.UJA5&p)E#JOCfjyUaim9\>?IgpnC28.„U"v'k-Tndvh,[S%4a:k<;yCFo_;0i>6#H_IA3F\8rrQU98,iDvx..h^(<u]XeH[#8„U"$+JmC6QYThm$XaDb;?X,e\F2)oXB')ifTg1h/jcjmj-1;$/'>jir'#8J88ImFhJ„U"?*d+JA&DV>tLDum98kFI/5LV0+TGwc_34Mb$[uDkNc>TK7Z=k2q'>?RXt?hSCq_„U"188%t^JV>tOh7cJdb/TBA<>Y\L(<&uS1T2F*q)RJoe+0a0-A_E5*[=8s()(V:[P„U"1s)^_IVSqXIIrx.&\.StDq-Ynx&kF_ZVq#J4.H((aiu;<r890\uf/rP01a:D(+c„U"slm/mU%6c/SK_f*fk]^&OeH.ke*ikLLAU>OOZLoUlE$[_Z^;]Xf,Ro,q,;WWFu&„U"9t&ZmnH*KjXYmg\8nO1d>2d.GVCx,%L_Ti[_^6APE.bq9HIn%)wgq#az64?_(#%„U"Z0X>9'BY$T.49.OHD5-TOFIeyBm.]<d2RNJ2_yCnX<Kq+*/,S)-)4#BUX%EAJV,„U"LFj]T'Q$[Lmx/$R/-73ZCeG>g2KCN)P6I0\+2lx\o>^,,?Z_;8/A0'^*=Y5Riw<„U"PB<1[7C1EF.,zVi9OKd34RNWQ[Fid'h,up%()9%%%%-%7#w&=]Oy5E'R'%%&v*%„U"%%/%%%%iguf%hpSg.fx4y2,>jo^5Ll[Ld[7=O1&Z;2zyci<pPYJ:k#**mirt/PT„U".\Q$:)[*cuh$,>O834q76oEnh^<e.3cn;IqDfmHxecI(.K*NQ/nV7.E<tu#Gl$z„U">4W9oWO*YWC2/zcB;Yq2ZYP4R+QO#*tE_9q*g='q)<G*d&Zom2\X;N4DV4NGpH/„U"DX1)A3=++n/3cn4)0D6Sd1[zp&kN6yY9(29xYW)bn)6k&Zq,oPpzI;ma2B*1F+Q„U":7e>a2e0.1^r%#<=?>ZlliQdsm.\RJ*XS5*HFrTnB-5CFN3'TMT3+0:PW%knlj>„U"D^8zpsAuQ-rs95(8G$oK[?urD9Bn3uc]t=3'qlmh,=IrpIn5tb(CJ:4_aZu&*/'„U"<\79+&uRM7sVlJ7t5Q0$ga#N,_$/hxh8=e[sR+H.fVs#0=$S[0/voOMLgVC6RU)„U"i7s/*m/x-V9KBNdPq[*#j4O_qXHUXg.k=/ika?EhU?Q^)+3u4H(m6QWd2]qJ5HU„U"MfI=?e8E)7/0OerL>:cV>sLyG/^Lt(UlH+ZnR]\ue%9x2jK4pH6\hEZBJ%d<:g,„U"mc_lPr2tIdMG'=QQ,[;*VUSEdJ5ds%Iyp/hgnOs7pnsGL-Tqrmj/LoOKu6F45$w„U"=Ce:nII[wByB^plMXsd-00$*.)WI#XxkW6us^3tY6mo;RT9Nuo<F6<<z::$RLl/„U"H?R:KshA#fF#y^=No6tq/s,Qq?mK6#[7M4c.48B\5-0d?.2H?$w/yFoU2xcd6GH„U"ZfeT7:YQL?.YgM9\h%z<A-;o>;G&pNNq$QR>?G5Y2\xX8;VQPg;8hLjd'#-^Sff„U"wz5m7zZk7L[YKHfFx=c/%#E5_K-Q7hcL1$j7jsBZROQb)M(g\qjK;22nmpS23oh„U"e&e#uP_c6fU0IDim2i0V^vn?MEp)QFHb('PW^TM]r_/D+Yw'u%p()9%%%%-[%ru„U"&d=qQh,=h&%%%V)%%%1%%%%igx%ywzh%ySgfLxTa,)^ie9bUhnq:4>Iit7N'6J*„U"[Jp(U3n5p\O&fTVi#d[i,(,X<wtmI&i99R_\EHTHX$bWJfTPT8m,3rf4L>aa>)4„U"]5_Dr)tQ_-pyyuUGyHwo*QR8?D/nDTq8g?A4PGfW]x]MQn*,,$l$h/cf9JM_^wc„U"?j8(5?>W_bXSX4<QZ0OcBV8qULja]3<$tm#K-6jM^6?A%EtFhQc&pGct;0:PqQC„U".fhjSYCWC/VCSp95.78^Jw6C)p\y\\/?.LuWYQQ9o1R/.XlBfgS]&C+Y5MZ/\M[„U">Q;qLl*:1wvIabY:<h_uIh+'2&E=CDi%k=5tO*R&8g1:9bh1n_6c*QYIfJIEPN(„U"S$0Jh+ZLeSf,;:aY)_#0n3JGEDW=nj#XSiI,JJ^O4=E?mLpib^Totap,MBl&Iia„U"Apdi(N^TCpY^nKuPg/AVFj5w'DnFY<V&2f-0e;.;IwBkfO3xub]WVc8<uVqJkGb„U"C=:%XQ;l^'Ax\yQH.'cEW54.rp3A=DGhNM-wINBDsMSwkfU6KKIw$-+P4Ykdh9l„U"8(SKf0Kb7O2YZ<tM[#CccWraq7.xtih*<b.J)z)j#5qw4Bhz'ti9V/X\G--6\qP„U"t=<uAl.raAve&4+MVr8=;=h,r(%up()%9%%%%-%(u'&=Gm(VUX&%%%;(%%%0%%%„U"%ig%fhhj%xxSg1nt$t,:;U=kVhQX]Zby&mh,TF_2i['IEz;4i)*e56L)gog?0Mt„U"5t3Dz.a9epQw5>mBX8WI'qB5lbSKIHCDr9uJ_?p^F7Zh8[)v?#/dv50h+:_h7i-„U"%O\_MY0rUxKmYJvWW2eVbz3TlRu5[Z8[qJU=fN1P&4HIOR#?;K%%pWL4e<aQ%8'„U"A\6u),%=l71g_H6,\M''>?jZXAXm(u]'NABp=qOn8n%^)v?1I^,uuDlURr1]2al„U"$hhtd&p9NY$<ZHZPOCoQ+,q&fc>uWUhdR47'_D*_pC.lZBGC$?S\\8PiED,CIa.„U"dqsWHRx/;;bJGq,5)[9[Xodm5eQC>9ClDrnofWQVrYBo7[i_YMJrj.#g[?+BCfH„U"kA(8>kt=)O;b:w';\>t+%up()%9%%%%-%ru]&=jT;gHa%7%%T&%%%+%%%%ig%kS„U"gnYDHF=';U5)iYJs5Q<U7$;)dW]=glLm:5y=OZ[aSjmK7QAU[V5L3fwqG;pJuYt„U"-hE_MNR3l+b(0aJpGp\eSI#],U4sP\Zk#1SeE8%:g_.U-s[_jU[][7rouH6Qb7*„U"Vj,jW>kArYMi.+0h[HKiQ'ZH2df58f.%X<6l]9L>d00(z?=jBKaf&'>bSs6_e=4„U"=FBrW9^SmNL5#;lCO><dK:67Xto\Q6RdH%Ut#w\b2Qd9aMfR2v4Qu3j)D-2,Z5J„U".dvGuE,yMB6E*G>Ykn$$O45:i?BZ<Rqr]7#;NFu%%up()%/%%%#%%%oB?;i%)X$„U"A%%%%A%%%%1%%%%ig%hwjf%yjSr%fpig%hwjf%yjSg%fx2/%igfh%hjxx%Sgfx%„U"2/up%()/%%%%%%:%o?;?9%wc%?%%%%?%%%%/%%%%igji%nySr%fpig%jiny%Sgf„U"x%2/ig%fhhj%xxSg%fx2/%up()%/%%%#%%%o0?;O6)Jq?%%%%?%%%%/%%%%ig%u„U"fhp%Srfp%iguf%hpSg%fx2/%igfh%hjxx%Sgfx%2/up%()/%%%%%%*k1:<,Kdr,„U"%A%%%%A%%%%1%%%%igxy%wzhy%Srfp%igxy%wzhy%Sgfx%2/ig%fhhj%xxSg%fx„U"2/%up&'%9%9%%%%-%7(u&=^DQCD'$)%%']5%%%1%%%%%%%%%&%E%%%%%%%%%ig%„U"fhhj%xxSg%fxup%&'9%%9%%%%-%(uK&=y;<dg3'.%%),%%%1%%%%%%%%%&%%E%%„U"%%6*%%%ighw%jfyj%Sgfx%up&'%9%9%%%%-%7(u&=&8wZ3%Z(%%%H.%%%/%%%%%„U"%%%%&%E%7%%n,%%%ig%jiny%Sgfx%up&'%9%9%%%%-%7#w&=]Oy5E'R'%%&v*%%„U"%/%%%%%%%%%&%E%%%%w0%%%ig%ufhp%Sgfx%up&'%9%9%%%%-%7ru&=UqQh='h&„U"%%%V)%%%1%%%%%%%%%&%E%%%%x3%%%ig%xywz%hySg%fxup%&'9%%9%%%%-%(u'„U"&=Gm(VUX&%%%;(%%%0%%%%%%%%%&%%E%%%&;5%%%igfh%hjxx%Sgnu%p&'9%%9%„U"%%%-%r+u&=jiTgHa[%%%T%&%%+%%%%%%%%%&%%E%%+%A6%%%igk%Sgnu%p&'9%%„U"/%%%%%%%,o?;i2%X$A%%%%A%%%%1%%%%%%%%%&%%E%%+%M7%%%igh%wjfy%jSrf„U"%pup&%'9%/%%%%%d%%o?s;9%w%c?%%%%?%%%%/%%%%%%%%%&%E%%%%?%8%%i%gj„U"in%ySrf%pup&%'9%/%%%%%d%%o?C;O6J&q?%%%%?%%%%/%%%%%%%%%&%E#%%%+%„U"8%%i%gufh%pSrf%pup&%'9%/%%%%%4%k1::<Kdr%,A%%%%A%%%%1%%%%%%%%%&%„U"E#%%%m%8%%i%gxyw%zhyS%rfpu%p*+%%%%%0#%0%>['%%]%8%%%%%„END SUB„CLOSE:IF S=249AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„'>>> Page 1 of DBF.ZIP ends here. Last page. TCHK:249„Ethan Winer                    READ/WRITE LOTUS 123 FILES     BASIC Techniques               Year of 1992           QB, QBasic, PDS        254  8121     LOTUS123.BAS'*********** LOTUS123.BAS - shows how to read and write Lotus 1-2-3 files„„'Copyright (c) 1992 Ethan Winer„„DEFINT A-Z„DECLARE SUB GetFormat (Format, Row, Column)„DECLARE SUB WriteColWidth (Column, ColWidth)„DECLARE SUB WriteInteger (Row, Column, ColWidth, Temp)„DECLARE SUB WriteLabel (Row, Column, ColWidth, Msg$)„DECLARE SUB WriteNumber (Row, Col, ColWidth, Fmt$, Num#)„„DIM SHARED CellFmt AS STRING * 1        'to read one byte„DIM SHARED ColNum(40)                   'max columns to write„DIM SHARED FileNum                      'the file number to use„„CLS„PRINT "Read an existing 123 file or ";„PRINT "Create a sample file (R/C)? ";„LOCATE , , 1„DO„   X$ = UCASE$(INKEY$)„LOOP UNTIL X$ = "R" OR X$ = "C"„LOCATE , , 0„PRINT X$„„IF X$ = "R" THEN„„  '----- read an existing file„  INPUT "Lotus file to read: ", FileName$„  IF INSTR(FileName$, ".") = 0 THEN„    FileName$ = FileName$ + ".WKS"„  END IF„  PRINT„„  '----- get the next file number and open the file„  FileNum = FREEFILE„  OPEN FileName$ FOR BINARY AS #FileNum„„  DO UNTIL Opcode = 1                   'until End of File code„„     GET FileNum, , Opcode              'get the next opcode„     GET FileNum, , Length              'and the data length„„     SELECT CASE Opcode                 'filter the Opcodes„„    CASE 0                              'Beginning of File record„      PRINT "Beginning of file, Lotus ";„      GET FileNum, , Temp„„      SELECT CASE Temp„        CASE 1028„          PRINT "1-2-3 version 1.0 or 1A"„        CASE 1029„          PRINT "Symphony version 1.0"„        CASE 1030„          PRINT "123 version 2.x"„        CASE ELSE„          PRINT "NOT a Lotus File!"„      END SELECT„„    CASE 1                                  'End of File„      PRINT "End of File"„„    CASE 12                                 'Blank cell„       'Note that Lotus saves blank cells only if they are formatted or„       'protected.„       CALL GetFormat(Format, Row, Column)„       PRINT "Blank:      Format ="; Format,„       PRINT "Row ="; Row,„       PRINT "Col ="; Column„„    CASE 13                                 'Integer„       CALL GetFormat(Format, Row, Column)„       GET FileNum, , Temp„       PRINT "Integer:    Format ="; Format,„       PRINT "Row ="; Row,„       PRINT "Col ="; Column,„       PRINT "Value ="; Temp„„    CASE 14                                 'Floating point„       CALL GetFormat(Format, Row, Column)„       GET FileNum, , Number#„       PRINT "Number:     Format ="; Format,„       PRINT "Row ="; Row,„       PRINT "Col ="; Column,„       PRINT "Value ="; Number#„„    CASE 15                                 'Label„       CALL GetFormat(Format, Row, Column)„       'Create a string to hold the label.  6 is subtracted to exclude the„       'Format, Column, and Row information.„„       Info$ = SPACE$(Length - 6)„       GET FileNum, , Info$                 'read the label„       GET FileNum, , CellFmt$              'eat the CHR$(0)„       PRINT "Label:      Format ="; Format,„       PRINT "Row ="; Row,„       PRINT "Col ="; Column, Info$„„    CASE 16                                 'Formula„       CALL GetFormat(Format, Row, Column)„       GET FileNum, , Number#               'read cell value„       GET FileNum, , Length                'and formula length„       SEEK FileNum, SEEK(FileNum) + Length 'skip formula„       PRINT "Formula:    Format ="; Format,„       PRINT "Row ="; Row,„       PRINT "Col ="; Column,„       PRINT "Value ="; Number#„„    CASE ELSE„       Dummy$ = SPACE$(Length)              'skip the record„       GET FileNum, , Dummy$                'read it in„       PRINT "Opcode: "; Opcode             'show its Opcode„„     END SELECT„„     '----- pause when the screen fills„     IF CSRLIN > 21 THEN„       PRINT„       PRINT "Press <ESC> to end or ";„       PRINT "any other key for more"„       DO„         K$ = INKEY$„       LOOP UNTIL LEN(K$)„       IF K$ = CHR$(27) THEN EXIT DO„       CLS„     END IF„„     NumRecs = NumRecs + 1                  'count the records„„  LOOP„  PRINT "Number of Records Processed ="; NumRecs„  CLOSE„„ELSE„„  '----- write a sample file„  FileNum = FREEFILE                        'as above„  OPEN "SAMPLE.WKS" FOR BINARY AS #FileNum„„  Temp = 0                                  'OpCode for Start of File„  PUT FileNum, , Temp                       'write that„  Temp = 2                                  'its data length is 2„  PUT FileNum, , Temp                       'since it's an integer„  Temp = 1030                               'Lotus version 2.x„  PUT FileNum, , Temp„„  Row = 0                                   'write this in Row 1„  DO„     CALL WriteLabel(Row, 0, 16, "This is a Label")„     CALL WriteLabel(Row, 1, 12, "So is this")„     CALL WriteInteger(Row, 2, 7, 12345)„     CALL WriteNumber(Row, 3, 9, "C2", 57.23#)„     CALL WriteNumber(Row, 4, 9, "F5", 12.3456789#)„     CALL WriteInteger(Row, 6, 9, 99)       'skip a column for fun„     Row = Row + 1                          'go on to the next row„  LOOP WHILE Row < 6„„  '----- Write the End of File record and close the file„  Temp = 1                                  'Opcode for End of File„  PUT FileNum, , Temp„  Temp = 0                                  'the data length is zero„  PUT FileNum, , Temp„  CLOSE„„END IF„END„„SUB GetFormat (Format, Row, Column) STATIC„  GET FileNum, , CellFmt$: Format = ASC(CellFmt$)„  GET FileNum, , Column„  GET FileNum, , Row„END SUB„„SUB WriteColWidth (Column, ColWidth) STATIC„„  '----- allow a column width only once for each column„  IF NOT ColNum(Column) THEN„    Temp = 8„    PUT FileNum, , Temp„    Temp = 3„    PUT FileNum, , Temp„    PUT FileNum, , Column„    Temp$ = CHR$(ColWidth)„    PUT FileNum, , Temp$„    '----- show we wrote this column's width„    ColNum(Column) = -1„  END IF„„END SUB„„SUB WriteInteger (Row, Column, ColWidth, Integ) STATIC„„  Temp = 13                                 'OpCode for an integer„  PUT FileNum, , Temp„  Temp = 7                                  'Length + 5 byte header„  PUT FileNum, , Temp„  Temp$ = CHR$(127)                         'the format portion„  PUT FileNum, , Temp$„  PUT FileNum, , Column„  PUT FileNum, , Row„  PUT FileNum, , Integ„  CALL WriteColWidth(Column, ColWidth)„„END SUB„„SUB WriteLabel (Row, Column, ColWidth, Msg$)„„  IF LEN(Msg$) > 240 THEN                   '240 is the maximum length„    Msg$ = LEFT$(Msg$, 240)„  END IF„„  Temp = 15                                 'OpCode for a label„  PUT FileNum, , Temp„  Temp = LEN(Msg$) + 7                      'Length plus 5-byte header„                                            'plus "'" plus CHR$(0)„  PUT FileNum, , Temp„  Temp$ = CHR$(127)                         '127 is the default format„  PUT FileNum, , Temp$„  PUT FileNum, , Column„  PUT FileNum, , Row„  Temp$ = "'" + Msg$ + CHR$(0)              'a "'" left-aligns a label„                                            'use "^" instead to center„  PUT FileNum, , Temp$„  CALL WriteColWidth(Column, ColWidth)„„END SUB„„SUB WriteNumber (Row, Col, ColWidth, Fmt$, Num#) STATIC„„  IF LEFT$(Fmt$, 1) = "F" THEN                    'fixed„    '----- specify the number of decimal places„     Format$ = CHR$(0 + VAL(RIGHT$(Fmt$, 1)))„  ELSEIF LEFT$(Fmt$, 1) = "C" THEN                'currency„     Format$ = CHR$(32 + VAL(RIGHT$(Fmt$, 1)))„  ELSEIF LEFT$(Fmt$, 1) = "P" THEN                'percent„     Format$ = CHR$(48 + VAL(RIGHT$(Fmt$, 1)))„  ELSE                                            'default„     Format$ = CHR$(127)                    'use CHR$(255) for protected„  END IF„„  Temp = 14                                 'Opcode for a number„  PUT FileNum, , Temp„  Temp = 13                                 'Length (8) + 5 = 13„  PUT FileNum, , Temp„„  PUT FileNum, , Format$„  PUT FileNum, , Col„  PUT FileNum, , Row„  PUT FileNum, , Num#„„  CALL WriteColWidth(Column, ColWidth)„„END SUB„