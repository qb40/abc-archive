Don Schullian                  SOUNDEX REPRESENTATION FOR PBCCd83@DASoftVSS.com              12-25-99 (19:12)       PBCC                   53   2987     SOUNDEXW.BAS#IF 0„    ----------------------------                      PowerBASIC/cc v2.0„ ---|          DASoft          |------------------------------------------„    ----------------------------         code           DATE: 1999-12-25„    | FILE NAME   SoundEX .bas |          by„    | DIRECTORY                |  Don Schullian, Jr.„    ----------------------------„„             This code released into the public domain.„„ -------------------------------------------------------------------------„  PURPOSE: CREATE a SoundEX representation of a given string„   PARMAS: TheWord$ - the string to be processed„  RETURNS: a LONG INTEGER in the range of 0 -> 656565656„ -------------------------------------------------------------------------„#ENDIF„„DECLARE FUNCTION fSoundex (BYVAL TheWord AS STRING) AS LONG„„FUNCTION fSoundex ( BYVAL TheWord AS STRING ) EXPORT AS LONG„„  DIM Char  AS LOCAL LONG                         ' character being processed„  DIM Last  AS LOCAL LONG                         ' last character processed„  DIM Temp  AS LOCAL ASCIIZ * 10                  ' buffer for outgoing value„  DIM T_ptr AS LOCAL BYTE PTR                     ' pointer to temp buffer„  DIM Tidx  AS LOCAL LONG                         ' index to temp pointer„  DIM W_ptr AS LOCAL BYTE PTR                     ' pointer to incoming data„  DIM Widx  AS LOCAL LONG                         ' index to incoming data pointer„                                                  '„  TheWord = UCASE$(TheWord)                       ' upper case for consistancy„  W_ptr   = STRPTR(TheWord)                       ' set ptr to incoming string„  T_ptr   = VARPTR(Temp)                          ' set ptr to temp buffer„                                                  '„  FOR Widx = 0 TO LEN(TheWord) -1                 ' process each char in incoming string„    SELECT CASE @W_ptr[Widx]                      '  by character value„      CASE 66, 70, 80, 86             : Char = 49 '„      CASE 67, 71, 74, 81, 83, 88, 90 : Char = 50 '„      CASE 68, 84                     : Char = 51 '„      CASE 76                         : Char = 52 '„      CASE 77, 78                     : Char = 53 '„      CASE 82                         : Char = 54 '„      CASE ELSE                       : ITERATE   '  skip everything else„    END SELECT                                    '„    IF Char = Last THEN ITERATE                   ' no doubles allowed„    @T_ptr[Tidx] = Char                           ' set new char in temp buffer„    IF Tidx = 8 THEN EXIT FOR                     ' if buffer is full then we're done„    INCR Tidx                                     ' next character position„    Last = Char                                   ' save this char's value for test„  NEXT                                            '„                                                  '„  FUNCTION = VAL(Temp)                            'RETURN LONG INTEGER VALUE„„END FUNCTION„Don Schullian                  PACK/UNPACK STRING TO/FROM QUADd83@DASoftVSS.com              01-14-00 (03:11)       PBCC                   145  5677     STR2QUAD.BAS$IF 0„    ----------------------------                      PowerBASIC/cc v2.0„ ---|          DASoft          |------------------------------------------„    ----------------------------         Code           DATE: 2000-01-14„    | FILE NAME   STR2QUAD.bas |          by„    | DIRECTORY                |  Don Schullian, Jr.„    ----------------------------„             This code is placed into the Public Domain„ -------------------------------------------------------------------------„  PURPOSE: pack and unpack strings into/from a QUAD integer„   PARMAS: TheString - A STRING of no more than 12 characters„           TheQuad   - A QUAD integer that carries a packed string„     NOTE: The incoming string will be UCASEd and all characters other„           than the 26 letters of the alphabet and the SPACE will be„           discarded„ -------------------------------------------------------------------------„  Similar routines to these were developed while I was building an anagram„game. The speed difference in locating a word in list of 80,000 strings„was prohibitive hence the use of QUAD integers. QUADs proved to be about 10„times faster than STRINGS.„„  These QUADs are packed to hold up to 12 characters with 4 bits left over„and sort alphabetically. One COULD use 3 of the left over bits as a flag and„still maintain alphabetical order by shifting the QUAD left 3 bits and ORing„the flag(s) onto the end then, when unpacking, remove the flag(s) first.„„  These routines could come in handy to create index keys.„„  PB/DOS users should make the following changes to the code:„    Change: LONGs  to INTEGERs in all cases„            STRPTR to STRPTR32 in fString2Quad„            VARPTR to VARPTR32 in fQuad2String„„    Remove: the following lines„            FUNCTION PBmain ()„            FORMAT$„            WAITKEY$„            END FUNCTION„„N'joy,„„   ____    _    ____      ____  _____„  |  _ \  / \  / ___) __ | ___)(_   _) Don Schullian„  | |_)  / _ \ \____\/  \|  _)   | |    d83@DASoftVSS.com„  |____//_/ \_\(____/\__/|_|     |_|    www.DASoftVSS.com„  ___________________________________   www.basicguru.com„      Vertical Software Solutions„„„$ENDIF„'„'-------------------------------------------------------------------------------„'„FUNCTION fString2Quad(BYVAL TheString AS STRING) AS QUAD„„  DIM C       AS LOCAL LONG„  DIM Offset  AS LOCAL LONG„  DIM S_ptr   AS LOCAL BYTE PTR„  DIM Slen    AS LOCAL LONG„  DIM TheQuad AS LOCAL QUAD„„  Slen  = MIN(12,LEN(TheString)) -1    ' length of string -1„  IF Slen < 0 THEN EXIT FUNCTION       ' nothing to do here„  S_ptr = STRPTR(TheString)            ' set string pointer„                                       '„  FOR Offset = 0 TO Slen               ' once for each character„    C = @S_ptr[Offset]                 '  glean ASCii value from string„    SELECT CASE C                      '  convert ASCii value„      CASE 65 TO  90 : C = C - 64      '   already UPPER CASE„      CASE 97 TO 122 : C = C - 96      '   UCASE the value„      CASE = 32      : GOTO NoORing    '   this is a space„      CASE ELSE      : ITERATE         '   not a valid character„    END SELECT                         '„    TheQuad = (TheQuad OR C)           '  OR the new value to the buffer„    NoORing:                           '„    IF Offset = Slen THEN EXIT FOR     '„    SHIFT LEFT TheQuad, 5              '„  NEXT                                 '„                                       '„  IF Slen < 11 THEN                    '„    C = 5 * ( 11 - Slen )              '„    SHIFT LEFT TheQuad, C              '„  END IF                               '„                                       '„  FUNCTION = TheQuad                   ' RETURN PACKED STRING„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION fQuad2String(BYVAL TheQuad AS QUAD) AS STRING„„  DIM C         AS LOCAL LONG„  DIM Offset    AS LOCAL LONG„  DIM S_ptr     AS LOCAL BYTE PTR„  DIM TheString AS LOCAL STRING * 12„„  IF TheQuad = 0 THEN EXIT FUNCTION    ' nothing to do here„  S_ptr = VARPTR(TheString)            ' set string pointer„                                       '„  FOR Offset = 11 TO 0 STEP -1         ' unpack 12 characters„    C = (TheQuad AND 31)               '  read value from 5 bits„    SHIFT RIGHT TheQuad, 5             '  move next 5 bits into line„    IF C > 0 THEN                      '   convert value into ASCii value„      @S_ptr[Offset] = C + 64          '„    END IF                             '„  NEXT                                 '„                                       '„  FUNCTION = RTRIM$(TheString)         ' RETURN THE UNPACKED STRING„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION PBmain ()                                 ' remove this line for„PB/DOS„„  DIM L     AS LOCAL LONG„  DIM Q(20) AS LOCAL QUAD„  DIM S(20) AS LOCAL STRING„  DIM X     AS LOCAL LONG„„  RANDOMIZE TIMER„  S(0) = "hello world"„  Q(0) = fString2Quad(S(0))„  FOR X = 1 TO 20„    L = RND(1,12)„    WHILE L > 0„      S(X) = S(X) & CHR$(RND(65,90))„      DECR L„    WEND„    Q(X) = fString2Quad(S(X))„  NEXT„„  ARRAY SORT S(0), COLLATE UCASE„  ARRAY SORT Q(0)„  FOR X = 0 TO 20„    PRINT S(X); TAB(14);„    PRINT fQuad2String(Q(X)); TAB(28);„    PRINT FORMAT$(Q(X),"###,###,###,###,###,###,###") ' remove this line„  NEXT„„  WAITKEY$                                            ' remove this line„„END FUNCTION                                          ' remove this line„Dave Navarro, Jr.              CONVERT IP ADDRESS TO STRING   dave@powerbasic.com            01-20-00 (14:27)       PBCC, PBDLL            11   308      IP.BAS      ' Convert a long integer representing an IP address to a displayable string„'„FUNCTION IpToString(BYVAL ip AS LONG) AS STRING„„   LOCAL b AS BYTE PTR„„   b = VARPTR(ip)„   FUNCTION = FORMAT$(@b[0]) & "." & FORMAT$(@b[1]) & "." & _„              FORMAT$(@b[2]) & "." & FORMAT$(@b[3])„„END FUNCTION„Dave Navarro, Jr.              2 IP ADDRESSES ON YOUR COMPUTERdave@powerbasic.com            01-20-00 (14:27)       PBCC, PBDLL            89   3476     2IPS.BAS    If your computer is connected to a network using a network card, and it has „a modem in it.  It's possible for your computer to have two IP addresses at „the same time.„„One IP address for the network connection and one IP address for your „dialup connection.„„When your computer boots up, the first IP address assigned to it is for the „network card.  So the following code will return the IP address for your „network connection:„„   HOST ADDR TO ip&„„When you connect to the internet using your modem, a second IP address is „assigned to your computer (by your ISP).  But the preceding code will still „return the address of your network card, not the new IP address for your „internet connection.„„In that situation you can use the following to get the IP address for your „modem connection:„„   HOST ADDR(2) TO ip&„„The reason that you would want to is because some mail servers are set up „so that they will only allow connections from authorized IP „addresses.  Most ISP's won't let anyone who is not dialed up through them „connect to their mail server to send a message.  This prevents non-users „from sending spam through their servers.„„In most cases, the SMTP server will simply look at the IP address of the „incoming connection to make that determination.  However, sometimes the „SMTP server looks at the IP address specified in the "HELO ..." command to „determine if you can connect to it.  In this case, sending the IP address „of your network card will cause the connection to fail.„„On Windows 95 and 98 machines, you can only have one IP address per network „connection.  (If you have two network cards in your computer, they'll each „get their own IP address).  So it's technically possible to have more than „two IP addresses on your machine.  Particularly with Windows NT where you „can actually assign more than one IP address to a single network card.„„Trying to use "HOST ADDR(n)" in those situations is practically useless „because there is no way to know which IP address in the sequence is being „used for the connection to the SMTP server.„„What should you do?  Use the WINSOCK API!   :)„„The trick is to use "TCP OPEN" to connect to the server.  This causes „PowerBASIC to create a valid socket for connection.  Once that's done, you „can use the socket handle to get the IP address of the connection.„„TCP OPEN uses the PowerBASIC file system, so the socket handle used in your „code is not a valid WINSOCK handle.  You need to use the FILEATTR() „function to obtain the actual WINSOCK handle.„„Once you've done that, you can use the API call getsockname() to get the IP „address that was used for the connection.  In the next reply, I'll post a „function that does this.„„-------------------------------[ code ]-------------------------------„„UNION in_addr„   s_addr AS LONG„   s AS STRING * 4„END UNION„„TYPE sockaddr_in„   sin_family AS WORD„   sin_port AS WORD„   sin_addr AS in_addr„   sin_zero AS STRING * 8„END TYPE„„DECLARE FUNCTION getsockname LIB "wsock32.dll" ALIAS "getsockname" _„    (BYVAL s AS LONG, sname AS sockaddr_in, namelen AS LONG) AS LONG„„FUNCTION TcpAddr(BYVAL s AS LONG) AS LONG„„   LOCAL sa AS sockaddr_in„   LOCAL l  AS LONG„„   s = FILEATTR(s,2) ' get winsock socket handle„   l = SIZEOF(sa)„„   IF getsockname(s, sa, l) = 0 THEN„     FUNCTION = sa.sin_addr.s_addr   'return IP address of connection„   END IF„„END FUNCTION„Dave Navarro, Jr.              EXTRACT LINKS FROM TEXT FILE   dave@powerbasic.com            01-20-00 (14:27)       PBCC, PBDLL            38   844      LINKS.BAS   'This is a quick & dirty little utility I wrote to extract all of the links „'in a text file and display them on the screen (redirectable).„„FUNCTION PbMain()„„   LOCAL htmlfile AS STRING„   LOCAL buffer   AS STRING„   LOCAL link     AS STRING„   LOCAL s        AS LONG„   LOCAL l        AS LONG„„   htmlfile = TRIM$(COMMAND$)„„   IF ISFALSE LEN(DIR$(htmlfile)) THEN„     PRINT "Error: "; htmlfile;" not found."„     EXIT FUNCTION„   END IF„„   OPEN htmlfile FOR BINARY AS #1„     GET$ #1, LOF(1), buffer„   CLOSE #1„„   STDOUT "File: " & htmlfile„   STDOUT ""„„   s = 1„   DO„     REGEXPR "<a href=.+>.+</a>" IN buffer AT s TO s, l„     IF ISFALSE s THEN„       EXIT DO„     ELSE„       link = REMOVE$(MID$(buffer, s, l), ANY CHR$(13,10))„     END IF„     STDOUT link„     s = s + l„   LOOP„„END FUNCTION„Egbert Zijlema                 RECYCLE BIN EXAMPLE            dave@powerbasic.com            01-20-00 (14:27)       PBCC, PBDLL            24   948      RECYCLE.BAS #COMPILE EXE„#INCLUDE "WIN32API.INC"„„FUNCTION RecycleBin(FilNam AS STRING) AS LONG„   LOCAL shfo AS SHFILEOPSTRUCT                 ' predefined structure„   LOCAL szSource AS ASCIIZ * 64„   szSource = FilNam + CHR$(0)                  ' convert to ASCIIZ„   shfo.wFunc = %FO_DELETE                      ' function delete file„   shfo.pFrom = VARPTR(szSource)                ' pointer to file„   shfo.fFlags = %FOF_ALLOWUNDO                 ' enable undo„   dummy& = SHFileOperation(shfo)               ' call funtion„   FUNCTION = shfo.fAnyOperationsAborted        ' return value, either 0 or non-zero„END FUNCTION„„FUNCTION PBMAIN()„   LOCAL RetVal AS LONG„   RetVal = RecycleBin("C:\MYFILE.TXT")„„   ' use the following lines only when the deleted file is part of an array or in a listbox„   IF RetVal = 0 THEN„     ARRAY DELETE StringArray(index)„     LISTBOX DELETE hDlg,  %IDLISTBOX,  position&„   END IF„END FUNCTION„Kispen                         INI FUNCTIONS FOR PBCC         kispen@mailpanda.com           02-01-00 (22:16)       PBCC                   320  11123    INI.BAS     $if 0„Uuhh... has something like this been done already? If it has... sorry... you'll probably want„to use the other one ;). This contains functions to work with INI files. Any bugs or anything,„e-mail me... the address is at the end of this if/endif block. Here are the functions:„***********************************************************************************************„ OpenINI(INIFile$) as Integer „     Opens the INI file... call this first, always„ 	returns 0 if it's ok, -1 if it's not.„ „ ReadKey$(Section$, Key$)„     Gets the value of Key$ in Section$„ 	returns the value of Key$ (if found)„ 	returns "Section not found" if Section$ isn't found„ 	returns "Key not found" if Key$ isn't found„ „ WriteKey(Section$, Key$, Value$) as Integer„     Writes Value$ to Key$ in Section$„ 	returns 0 if it's ok, -1 if Section$ wasn't found„ 	„ WriteSection(Section$) (this is a sub) <-- writes a section.„ „ DeleteKey(Section$, Key$) as Integer <-- Figure this one out ;-)„ 	returns 0 if it's ok„ 	returns -1 if Section$ wasn't found„ 	returns -2 if Key$ wasn't found„ 	„ DeleteSection(Section$) as Integer <-- hmm... wonder what this does....„ 	returns 0 if it's ok„ 	returns -1 if Section$ wasn't found„ 	„ SaveINI(INIFile$) as Integer <-- hmmmm......„ 	returns 0 if it's ok, -1 if it's not„***********************************************************************************************„ „Hopefully, this can help you out... a little :). I should add code to ignore a line (e.g. not„put the line into INIArray() if it's blank, but I want the INI file to be written exactly as„it was read... so I didn't. Erm... sorry for the messy code, I just sorta stick things in as„they come into my head. Oh, btw, I don't like ARRAY SCAN. I really don't. Oh, second btw... I„think this thing is pretty slow. Please, please, modify it... make it faster... It'd be cool to„get this thing going fast... Oh, third btw... I think there are API calls to write/read from„INI files, but from what I saw they only wrote/read to win.ini or the registry... Then again,„I could be wrong. I only looked at it for a couple of minutes.„„Oh yea, final warning: Don't use INIArray(), INISectionIndex(), or INISectionIndexMax in your„program. If you do, you could mess this up. Blah...„„Kispen (kispen@mailpanda.com)„$endif„„global INIArray() as string„global INISectionIndex() as integer„global INISectionIndexMax as long„„function OpenINI(INIFile$) as integer„$if 0„OK, here's how this little baby works...„1) Check to see if the file exists (if not, return -1)„2) Open the file„3) Put each line of the file into INIArray()„4) If the line begins with [ and ends with ] then it's a section, and we should put the number„   into INISectionIndex()... hence the name 'index' hehehe„5) End the function.„$endif„ local x as integer„ local NumberFree as integer„  „ INILine$ = "" „ x = 0„ NumberFree = 0„ „ ' Check to see if the file exists„ if dir$(INIFile$) = "" then function = -1: exit function„ „ ' Open the INI File„ NumberFree = Freefile„ open INIFile$ for input as NumberFree„ „ do until eof(NumberFree)„  x = x + 1„  line input #NumberFree, INILine$„  „  ' Check to see if it's a section, and update accordingly„  if left$(INILine$, 1) = "[" and right$(INILine$, 1) = "]" then„  	INISectionIndexMax = ubound(INISectionIndex) + 1„  	redim preserve INISectionIndex(0 to INISectionIndexMax)„  	INISectionIndex(INISectionIndexMax) = x„  end if„  „  ' Add another line to INIArray„  redim preserve INIArray(1 to x)„  INIArray(x) = INILine$„ loop„ close NumberFree„ function = 0„end function„„function ReadKey$(Section$, Key$)„$if 0„Here is how this one works:„1) Add [ or ] to Section$ if necessary„2) Use INISectionIndex() to match the section... if section isn't found, say so.„3) Scan INIArray() from the section to the next section (or the end of the array) for Key$„4) If Key$ isn't found, say so and exit„5) Get the value of Key$ and send it down... then exit.„$endif„   local FoundSection as integer„   local FoundKey as integer„   local x as integer„   local LenKey as integer„   local LowerScan as integer„   local UpperScan as integer„   local Counter as integer„   local tempKey as string„   „   FoundSection = 0„   x = 0„   LenKey = 0„   tempKey = ""„   „   ' Add [ or ] if needed„   IF LEFT$(Section$, 1) <> "[" THEN Section$ = "[" + Section$„   IF RIGHT$(Section$, 1) <> "]" THEN Section$ = Section$ + "]"„„   FOR x = 1 TO INISectionIndexMax„       IF INIArray(INISectionIndex(x)) = Section$ THEN„          FoundSection = INISectionIndex(x)„          ' Ok, we have to check to see if there's another section or not. If there is, then„          ' we should stop scanning at that number. If there isn't, then we should stop scanning„          ' at the last number of the file array (since, obviously, if there is no next section,„          ' it's the end of the file.„          if x = ubound(INISectionIndex) then„          	UpperScan = ubound(INIArray)„          else„          	UpperScan = INISectionIndex(x + 1)„          end if„          EXIT FOR„       END IF„   NEXT x„   if FoundSection = 0 then function = "Section not found": exit function„„   LenKey = LEN(Key$)„   LowerScan = FoundSection„   „   'I would love to use ARRAY SCAN, but I don't like its limitations...„   'ARRAY SCAN INIArray(FoundSection), FROM 1 TO LenKey, = Key$, TO i&„   „   FoundKey = 0„   for Counter = LowerScan to UpperScan„   	if left$(INIArray(Counter), LenKey) = Key$ then„   		FoundKey = Counter„   		exit for„   	end if„   next Counter„   if FoundKey = 0 then function = "Key not found": exit function„   tempKey = INIArray(FoundKey)„   tempKey = trim$(right$(tempKey, Len(tempKey) - LenKey)) ' Get rid of the Key string...„   „   ' If there is an "=", then get rid of it, and all surrounding spaces„   if left$(tempKey, 1) = "=" then tempKey = trim$(right$(tempKey, Len(tempKey) - 1))„   „   ' Send the string.. modified or not.„   function = tempKey„end function„„function WriteKey(Section$, Key$, Value$) as integer„$if 0„Hmm... k, flowchart for this one„1) Add [ and ] to Section$ if necessary„2) Find the section„3) ARRAY INSERT a line into it... and set it equal to Key$=Value$„4) End the function...„$endif„ local FoundSection as integer„ local x as integer„ „ if left$(Section$, 1) <> "[" then Section$ = "[" + Section$„ if right$(Section$, 1) <> "]" then Section$ = Section$ + "]"„ „ FOR x = 1 TO INISectionIndexMax„    IF INIArray(INISectionIndex(x)) = Section$ THEN„       FoundSection = INISectionIndex(x)„       EXIT FOR„    END IF„ NEXT x„ if FoundSection = 0 then function = -1: exit function„ „ redim preserve INIArray(1 to ubound(INIArray)+1) ' Make room for the new key„ NewKey$ = Key$ + "=" + Value$„ array insert INIArray(FoundSection + 1), NewKey$„ function = 0„end function„„sub WriteSection(Section$)„ if left$(Section$, 1) <> "[" then Section$ = "[" + Section$„ if right$(Section$, 1) <> "]" then Section$ = Section$ + "]"„ redim preserve INIArray(1 to ubound(INIArray)+1) ' Make room for the new section„ INIArray(ubound(INIArray)) = Section$„end sub„„function DeleteKey(Section$, Key$) as integer„'This works surprisingly like ReadKey... I wonder why. :P„„   local FoundSection as integer„   local FoundKey as integer„   local x as integer„   local LenKey as integer„   local LowerScan as integer„   local UpperScan as integer„   local Counter as integer„   local tempKey as string„   „   FoundSection = 0„   x = 0„   LenKey = 0„   tempKey = ""„   „   ' Add [ or ] if needed„   IF LEFT$(Section$, 1) <> "[" THEN Section$ = "[" + Section$„   IF RIGHT$(Section$, 1) <> "]" THEN Section$ = Section$ + "]"„„   FOR x = 1 TO INISectionIndexMax„       IF INIArray(INISectionIndex(x)) = Section$ THEN„          FoundSection = INISectionIndex(x)„          ' Ok, we have to check to see if there's another section or not. If there is, then„          ' we should stop scanning at that number. If there isn't, then we should stop scanning„          ' at the last number of the file array (since, obviously, if there is no next section,„          ' it's the end of the file.„          if x = ubound(INISectionIndex) then„          	UpperScan = ubound(INIArray)„          else„          	UpperScan = INISectionIndex(x + 1)„          end if„          EXIT FOR„       END IF„   NEXT x„   if FoundSection = 0 then function = -1: exit function„„   LenKey = LEN(Key$)„   LowerScan = FoundSection„   „   'I would love to use ARRAY SCAN, but I don't like its limitations...„   'ARRAY SCAN INIArray(FoundSection), FROM 1 TO LenKey, = Key$, TO i&„   „   FoundKey = 0„   for Counter = LowerScan to UpperScan„   	if left$(INIArray(Counter), LenKey) = Key$ then„   		FoundKey = Counter„   		exit for„   	end if„   next Counter„   if FoundKey = 0 then function = -2: exit function„   ARRAY DELETE INIArray(FoundKey)„   function = 0„end function„„function DeleteSection(Section$) as integer„' Look at all the cut-n-paste! Basically, it's a modified ReadKey$„„   local FoundSection as integer„   local FoundKey as integer„   local x as integer„   local LenKey as integer„   local LowerScan as integer„   local UpperScan as integer„   local Counter as integer„   local tempKey as string„   „   FoundSection = 0„   x = 0„   LenKey = 0„   tempKey = ""„   „   ' Add [ or ] if needed„   IF LEFT$(Section$, 1) <> "[" THEN Section$ = "[" + Section$„   IF RIGHT$(Section$, 1) <> "]" THEN Section$ = Section$ + "]"„„   FOR x = 1 TO INISectionIndexMax„       IF INIArray(INISectionIndex(x)) = Section$ THEN„          FoundSection = INISectionIndex(x)„          ' Ok, we have to check to see if there's another section or not. If there is, then„          ' we should stop scanning at that number. If there isn't, then we should stop scanning„          ' at the last number of the file array (since, obviously, if there is no next section,„          ' it's the end of the file.„          if x = ubound(INISectionIndex) then„          	UpperScan = ubound(INIArray)„          else„          	UpperScan = INISectionIndex(x + 1)„          end if„          EXIT FOR„       END IF„   NEXT x„   if FoundSection = 0 then function = -1: exit function„   LowerScan = FoundSection„„   for Counter = LowerScan to UpperScan - 1„   	' It's gotta be LowerScan since as soon as you delete it, the next one you want to„   	' delete is at LowerScan....„   	ARRAY DELETE INIArray(LowerScan)„   	redim preserve INIArray(1 to ubound(INIArray) - 1)     ' Get rid of the extra space„   next Counter„   function = 0„end function„„function SaveINI(INIFile$) as integer„$if 0„1) Open INIFile$„2) Write INIArray() to it.„3) Close INIFile$„$endif„ local NextFree as integer„ local x as integer„ „ NextFree = Freefile„ Open INIFile$ for output as #NextFree„ for x = 1 to ubound(INIArray)„  print #NextFree, INIArray(x)„ next x„ Close #NextFree„ function = 0„end function„Don Schullian                  FINPUT FOR PBCC                d83@DASoftVSS.com              03-17-00 (16:37)       PBCC                   260  8552     CC_INPUT.BASfInput% function for PowerBASIC Console Compiler„   coded by: Don Schullian  d83@DASoftVSS.com„   public domain„„Welcome,„„  This code is offered as an (better?) alternative to INPUT$. It„allows for cursoring around a field, deletion, insertion, overwrite,„scrolling, and bail out without saving the/any changes.„„  Its use is demonstrated below using an array to allow for editing„a screen full of data in one loop. This code could, very easily be„placed into it's own function and called several times in a single„program.„„  There are a series of CONSTANTS set that are used by the function„You may, of course, put their values into the function or, in some„cases, send the values to the function to allow for more control by„varied other functions.„„  This offering is just a starting point for those of you who are„more adventurous. Over the years I've developed 10 different„variations of this function that control and guide the users' input.„One of them works only for numerical input and looks & feels like„a calculator; another allows input of only specific characters;„while others handle hexadecimal input, masked fields, multiple lines„and other varied field types. A bit of imagination goes a LONG way!„„  fGetKey% is my basic keyboard input function and I never leave„home without it. There is a full discussion on how and why on„either of my web pages. www.basicguru.com/scullian or„www.DASoftVSS.com along with some other goodies.„„  If you have any questions, give me a shout.„„   ____    _    ____      ____  _____„  |  _ \  / \  / ___) __ | ___)(_   _) Don Schullian„  | |_)  / _ \ \____\/  \|  _)   | |    d83@DASoftVSS.com„  |____//_/ \_\(____/\__/|_|     |_|    www.DASoftVSS.com„  ___________________________________   www.basicguru.com„      Vertical Software Solutions„„„'----------------------------------------------------------------------„' fInput%(Datum$,Row&,Col&,VisCols&,MaxLen&,ExitKeys$)„'„' PURPOSE: Allow user input in an editable, friendly environment„'  PARAMS: Datum$     incoming the data already found in the field„'                     returning the edited data„'          Row&, Col& the left most screen position of the field„'          VisCols&   the number of visable characters on screen„'          MaxLen&    the maximum number of characters in the field„'          ExitKeys$  the MKI$(keyvalue%) of all the keys OTHER THAN„'                       <ESC> and <ENTER> that will return from the„'                       function„'    NOTE: If VisCols& =< MaxLen& then the value will be set to match„'          that of MaxLen&„'--------------------------------------------------------------------------„„%Esc_key   = &h001B             ' key codes returned by fGetKey%„%Enter_key = &h000D„%BkSpc_key = &h0008„%Del_key   = &h5300„%Up_key    = &h4800„%Down_key  = &h5000„%Ins_key   = &h5200„%Left_key  = &h4B00„%Right_key = &h4D00„%Ctrl_Del  = &h9300„%F10_key   = &h4400„%Home_key  = &h4700„%End_key   = &h4F00„„%Fgrnd    = 15                 ' editing foreground„%Bgrnd    =  1                 ' editing background„„DECLARE FUNCTION fInput(SEG D AS STRING,BYVAL Row AS LONG,BYVAL Col AS„LONG,BYVAL VisLen AS LONG,BYVAL MaxLen AS LONG,BYVAL ExitKeys AS STRING) AS„INTEGER„DECLARE FUNCTION fGetKey() AS INTEGER„„FUNCTION PBmain ()„„  DIM C        AS LOCAL LONG„  DIM Col      AS LOCAL LONG„  DIM D(5)     AS LOCAL STRING„  DIM ExitKeys AS LOCAL STRING„  DIM F(2,5)   AS LOCAL LONG„  DIM Fld      AS LOCAL LONG„  DIM G        AS LOCAL INTEGER„  DIM Prompt   AS LOCAL STRING„  DIM X        AS LOCAL LONG„„  COLOR 0, 15„  CLS„  D(0) = "Mary had a little lamb, its fleece was white as snow."„  G = fInput(D(0), 2, 10, 20, 70, "")„  LOCATE 2, 1: PRINT D(0);„„  FOR X = 1 TO 5„    INCR C : Prompt = READ$(C)„    INCR C : D(X)   = READ$(C)„    INCR C : F(0,X) = VAL(READ$(C))„    INCR C : F(1,X) = VAL(READ$(C))„    INCR C : F(2,X) = VAL(READ$(C))„    Col = F(1,X) - LEN(Prompt) - 1„    COLOR 8, 15„    LOCATE F(0,X), Col„    PRINT Prompt;„    COLOR 1, 15„    LOCATE F(0,X), F(1,X)„    PRINT LEFT$(D(X), F(2,X))„  NEXT„„  LOCATE 25, 1„  PRINT "Use Arrows to move - F-10 to save & exit - <ESC> to quit";„„  ExitKeys = MKI$(%F10_key) + MKI$(%Up_Key) + MKI$(%Down_Key)„„  Fld = 1„  DO„    IF Fld < 1 THEN„        Fld = 5„      ELSEIF Fld > 5 THEN„        Fld = 1„    END IF„    G = fInput( D(Fld), F(0,Fld), F(1,Fld), 0, F(2,Fld), ExitKeys)„    SELECT CASE G„      CASE %F10_key : EXIT LOOP„      CASE %Esc_Key : EXIT LOOP„      CASE %Up_Key  : DECR Fld„      CASE ELSE     : INCR Fld„    END SELECT„  LOOP„  FOR X = 1 TO 5„    LOCATE X + 10, 1„    PRINT D(X)„  NEXT„  WAITKEY$„„  DATA "Last Name:", "Schullian"   , 6, 20, 17„  DATA "Frst Name:", "Don"         , 7, 20, 17„  DATA "Street:"   , "My Street 27", 8, 20, 30„  DATA "City:"     , "Hometown"    , 9, 20, 30„  DATA "Zip:"      , "12345-2433"  , 9, 56, 10„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION fGetKey () EXPORT AS INTEGER„„  DIM G AS LOCAL STRING„„  G = WAITKEY$„„  IF LEN(G) = 1 THEN„      FUNCTION = ASC(G)„    ELSE„      FUNCTION = CVI(G)„  END IF„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION fInput (  SEG Datum    AS STRING, _„                 BYVAL Row      AS LONG  , _„                 BYVAL Col      AS LONG  , _„                 BYVAL VisLen   AS LONG  , _„                 BYVAL MaxLen   AS LONG  , _„                 BYVAL ExitKeys AS STRING  ) EXPORT AS INTEGER„„  DIM Bgrnd  AS LOCAL LONG          ' original background color„  DIM Cpos   AS LOCAL LONG          ' current cursor position within string„  DIM E      AS LOCAL LONG          ' temp variable„  DIM Fgrnd  AS LOCAL LONG          ' original foreground color„  DIM Inzert AS LOCAL LONG          ' insert state„  DIM KeyVal AS LOCAL LONG          ' incoming key-press value„  DIM MaxOff AS LOCAL LONG          ' maximum offset position„  DIM Offset AS LOCAL LONG          ' 1st character shown in field„  DIM Temp   AS LOCAL STRING * 256  ' working data string„„  Temp     = LTRIM$(Datum)„  Inzert   = 10„  ExitKeys = MKI$(%ESC_key) & MKI$(%Enter_Key) & ExitKeys$„  Bgrnd    = SCREENATTR(Row, Col)„  Fgrnd    = (Bgrnd AND 15)„  Bgrnd    = (Bgrnd  \  16)„  Offset   = 1„„  IF ( VisLen = 0      )   OR _„     ( VisLen > MaxLen ) THEN VisLen = MaxLen„  MaxOff = (MaxLen - VisLen + 1)„„  GOSUB fInputEOL„  COLOR %Fgrnd, %Bgrnd„  CURSOR ON, Inzert„„  DO„    IF Cpos < 1 THEN„        Cpos = 1„      ELSEIF Cpos > MaxLen THEN„        Cpos = MaxLen„    END IF„    IF Cpos < Offset THEN„        Offset = Cpos„      ELSEIF (Cpos - Offset + 2) > VisLen THEN„        Offset = MIN(MaxOff,(Cpos - VisLen + 1))„    END IF„    GOSUB fInputPrint„    LOCATE Row, (Col + Cpos - Offset)„    KeyVal = fGetKey„    E = INSTR(ExitKeys, MKI$(KeyVal))„    IF (E AND 1) = 1 THEN EXIT LOOP„    SELECT CASE KeyVal„      CASE 32 TO 255   : IF (Inzert > 10) OR (Cpos = MaxLen) THEN„                             ASC(Temp,Cpos) = KeyVal„                           ELSE„                             Temp = STRINSERT$(Temp,CHR$(KeyVal),Cpos)„                         END IF„                         INCR Cpos„      CASE %BkSpc_Key  : IF Cpos > 1 THEN„                          DECR Cpos„                          Temp = STRDELETE$(Temp,Cpos,1)„                         END IF„      CASE %Del_Key    : Temp = STRDELETE$(Temp,Cpos,1)„      CASE %Home_Key   : Cpos = 1„      CASE %End_Key    : GOSUB fInputEOL„      CASE %Left_Key   : DECR Cpos„      CASE %Right_Key  : INCR Cpos„      CASE %Ins_Key    : IF Inzert = 10 THEN Inzert = 50 ELSE Inzert = 10„                         CURSOR ON, Inzert„    END SELECT„  LOOP„„  Offset = 1„  IF KeyVal <> %Esc_Key THEN Datum = TRIM$(Temp)„  Temp = Datum„  COLOR Fgrnd, Bgrnd„  GOSUB fInputPrint„„  FUNCTION = KeyVal„  EXIT FUNCTION„  '-----------------------------------------------------------------„  '------------- local routines„  '-----------------------------------------------------------------„  fInputPrint:„    LOCATE Row, Col„    PRINT MID$(Temp, Offset, VisLen);„  RETURN„  '-----------------------------------------------------------------„  fInputEOL:„    FOR Cpos = MaxLen TO 1 STEP -1„      IF ASC(Temp, Cpos) <> 32 THEN EXIT FOR„    NEXT„    INCR Cpos„  RETURN„„END FUNCTION„Don Schullian                  SOUNDEX INDEXING SYSTEM        d83@DASoftVSS.com              04-11-00 (16:35)       PBCC                   532  31120    SNDEXKEY.BAS#if 0„    ----------------------------                      PowerBASIC/cc v2.0„ ---|          DASoft          |------------------------------------------„    ----------------------------         Code           DATE: 2000-04-08„    | FILE NAME   SndEXkey.bas |          by„    ----------------------------  Don Schullian, Jr.„„              This code is released into the Public Domain„       ----------------------------------------------------------„        No guarantee as to the viability, accuracy, or safety of„         use of this code is implied, warranted, or guaranteed„       ----------------------------------------------------------„                         Use at your own risk!„       ----------------------------------------------------------„                  CONTACT AUTHOR AT d83@DASoftVSS.com„ -------------------------------------------------------------------------„  PURPOSE: Create & maintain a SoundEX key file„ -------------------------------------------------------------------------„„  The theory behind all this is that the user requires to search on a„given data set for one or more keywords that are NOT included in any of„the other indexed fields of the record. These keywords are stored and„sorted in a separate file as SoundEX values along with the parent record„number.„„  There may be more than one record associated with any one keyword but in„the event that two or more keywords create identical SoundEX values then„only one of the values will be stored as multiple equal values linked to„the same record would be superfluous.„„  Also, if/when the user inputs duplicate keywords (humanly speaking)„these will be removed from the string to allow more room for other key„words and to remove confusion. (Users are generally confused enough„without further assistance;) Conversely, in the event that two or more of„the unique key words create identical SoundEX values they will remain in„ the user inputted string to, once again, stave off confusion.„  eg: USER INPUT "RED, BLUE,, GREEN, GREEN, GRIN"„      RETURNed   "BLUE,GREEN,GRIN,RED"„      Three keys will be created for "BLUE", "GREEN", and "RED" as„      "GRIN" and "GREEN" create equal SoundEX values„„  The series of routines, below, ass/u/me that the comma (,) is used to„parse the individual key words in the string. If you wish to use something„other than that character then you'll have to insert that value into all„instances of PARSE$ and PARSECOUNT.„„  The file buffer is currently set to 512,000 bytes. If more or less is„required the instance of the value can be changed in KeyFileMove.„„  Also, please note that the incoming OldKeys string is assumed to have„already been formatted!„„  There is test code at the bottom of the file.„'-------------------------------------------------------------------------------„'-----                                                                     -----„'-------------------------------------------------------------------------------„fKeyFileOpen (BYVAL FileSpec AS STRING,BYVAL FileNo AS LONG) AS LONG„   FileSpec = drive:\path\filename.ext of file to open„   FileNo   = if > 0 then this number is used else FREEFILE will be called„   RETURNS: ZERO if file was opened without error ELSE ERR„„ KeyFileClose ()„   Closes file, releases g_KeyFile value„„ KeyFileInsert (BYVAL TheWord AS STRING, BYVAL RecNo AS LONG)„ KeyFileDelete (BYVAL TheWord AS STRING, BYVAL RecNo AS LONG)„   TheWord = the word to be processed„   RecNo   = the associated record number„   NOTE: These two SUBs allow the programmer access to the data base on„         the level of the individual item.„„ KeyFileUpdate (OldKeys AS STRING, NewKeys AS STRING, RecNo AS LONG)„   OldKeys = Previously formatted string of key words„   RecNo   = associated record number for these keys„   NewKeys  INCOMING: unformatted user input„            RETURNING: formatted string„   NOTE: This is the only required entry point for parent routines„„fKeyFileSearch (BYVAL TheWord AS STRING, SEG RecNo() AS LONG) AS LONG„  TheWord = The word/phrase to be searched for„  RecNo() = RETURNING: a list of all record numbers that match the„                       SoundEX value for TheWord„  RETURNS: The number of elements used in RecNo() (BASE 1)„„#endif„'„'-------------------------------------------------------------------------------„'-----                         START OF CODE                               -----„'-------------------------------------------------------------------------------„'„TYPE KeyWordTYPE„  RecNo   AS LONG„  SoundEX AS LONG„END TYPE„„UNION KeyWordUNION„  tKey AS KeyWordTYPE„  Qkey AS QUAD„END UNION„„GLOBAL g_KeyLast AS LONG„GLOBAL g_KeyFile AS LONG„„DECLARE FUNCTION fKeyFileOpen     (BYVAL FileSpec AS STRING,BYVAL FileNo AS LONG) AS LONG„DECLARE FUNCTION fKeyFileSearch   (BYVAL TheWord AS STRING,SEG RecNo() AS LONG) AS LONG„DECLARE SUB       KeyFileClose    ()„DECLARE SUB       KeyFileUpdate   (BYVAL OldKeys AS STRING,SEG NewKeys AS STRING,BYVAL RecNo AS LONG)„DECLARE SUB       KeyFileInsert   (BYVAL TheWord AS STRING,BYVAL RecNo AS LONG)„DECLARE SUB       KeyFileDelete   (BYVAL TheWord AS STRING,BYVAL RecNo AS LONG)„'-------------------------------------------------------------------------------„'----------- PRIVATE ROUTINES --------------------------------------------------„'-------------------------------------------------------------------------------„DECLARE FUNCTION fKeyFileSoundEX  (SEG TheWord AS STRING) AS LONG„DECLARE FUNCTION fKeys2Array      (SEG TheKeys AS STRING,SEG Keys() AS LONG) AS LONG„DECLARE FUNCTION fKeyFileSeek     (SEG uKey AS KeyWordUNION,BYVAL Unique AS LONG) AS LONG„DECLARE SUB       KeyStringFormat (SEG TheKeys AS STRING )„DECLARE SUB       KeyFileMove     (BYVAL Offset AS LONG,BYVAL Bytes AS LONG)„'„'-------------------------------------------------------------------------------„'„FUNCTION fKeyFileOpen ( BYVAL FileSpec AS STRING, _„                        BYVAL FileNo   AS LONG    ) AS LONG„„  ON ERROR GOTO Oops                                   ' set local error trap„                                                       '„  IF FileNo = 0 THEN FileNo = FREEFILE                 ' get next unused number„                                                       '„  OPEN FileSpec FOR BINARY AS #FileNo BASE = 0         ' open file„  g_KeyLast = LOF(FileNo) \ 8                          ' compute nbr of keys„                                                       '„  ExitFunction:                                        ' Exit point„    g_KeyFile = FileNo                                 '  set global file number„    EXIT FUNCTION                                      '  We're outta here„                                                       '„  Oops:                                                ' ERROR TRAP„    IF FILEATTR(FileNo,0) THEN CLOSE #FileNo           '  close opened file„    FileNo    = 0                                      '  clear globals„    g_KeyLast = 0                                      '„    FUNCTION  = ERR                                    '  RETURN ERRor code„    RESUME ExitFunction                                '  jmp to exit point„                                                       '„END FUNCTION„'„'-------------------------------------------------------------------------------„'„SUB KeyFileClose () EXPORT„„  IF FILEATTR(g_KeyFile,0) THEN CLOSE g_KeyFile        ' if file is open„  g_KeyFile = 0                                        '„  g_KeyLast = 0                                        '„                                                       '„END SUB                                                '„'„'-------------------------------------------------------------------------------„'„SUB KeyFileInsert( BYVAL TheWord AS STRING, _„                   BYVAL RecNo   AS LONG    ) EXPORT„„  DIM uKey    AS LOCAL KeyWordUNION                    ' working record union„  DIM  Offset AS LOCAL LONG                            ' file offset„                                                       '„  uKey.tKey.RecNo   = RecNo                            ' set union values„  uKey.tKey.SoundEX = fKeyFileSoundEX(UCASE$(TheWord)) ' create SoundEX value„  Offset = fKeyFileSeek(uKey,-1)                       ' find unique key„  IF Offset < 0 THEN                                   ' if it doesn't exist„    Offset = -Offset                                   '  reverse sign on offset„    KeyFileMove Offset, 8                              '  open a hole for key„    PUT g_KeyFile, Offset, uKey                        '  stuff the key„    INCR g_KeyLast                                     '  increase the last #„  END IF                                               '„                                                       '„END SUB„'„'-------------------------------------------------------------------------------„'„SUB KeyFileDelete ( BYVAL TheWord AS STRING, _„                    BYVAL RecNo   AS LONG    ) EXPORT„„  DIM uKey    AS LOCAL KeyWordUNION                    ' working record union„  DIM  Offset AS LOCAL LONG                            ' file offset„                                                       '„  IF g_KeyLast < 1 THEN EXIT SUB                       ' oops! noting in the file„                                                       '„  uKey.tKey.RecNo   = RecNo                            ' set union values„  uKey.tKey.SoundEX = fKeyFileSoundEX(UCASE$(TheWord)) ' create SoundEX value„  Offset            = fKeyFileSeek(uKey,-1)            ' find unique key„                                                       '„  IF Offset < 0 THEN EXIT SUB                          ' not there! nothing to remove„                                                       '„  KeyFileMove Offset, -8                               ' close up the file„  DECR g_KeyLast                                       ' decrease the record count„  SEEK g_KeyFile, (g_KeyLast * 8)                      ' set EOF of file„  SETEOF g_KeyFile                                     '„„END SUB„'„'-------------------------------------------------------------------------------„'„SUB KeyFileUpdate ( BYVAL OldKeys AS STRING, _„                    SEG   NewKeys AS STRING, _„                    BYVAL RecNo   AS LONG    ) EXPORT„„  DIM uKey      AS KeyWordUNION                        ' record union„  DIM  N        AS LOCAL LONG                          ' new keys temp„  DIM  Ncount   AS LOCAL LONG                          ' # of individual new keys„  DIM  Nkeys(0) AS LOCAL LONG                          ' array for new keys„  DIM  O        AS LOCAL LONG                          ' old keys temp„  DIM  Ocount   AS LOCAL LONG                          ' # of old/existing keys„  DIM  Okeys(0) AS LOCAL LONG                          ' array for old keys„  DIM  Offset   AS LOCAL LONG                          ' file offset„  DIM  OldLast  AS LOCAL LONG                          ' current last key #„                                                       '„  KeyStringFormat NewKeys                              ' format the new key string„  IF OldKeys = NewKeys THEN EXIT SUB                   ' same old, same old„  uKey.tKey.RecNo = RecNo                              ' only need this once„  OldLast         = g_KeyLast                          ' current last record„                                                       '„  Ocount = fKeys2Array( OldKeys, Okeys() )             ' fill old keys array„  Ncount = fKeys2Array( NewKeys, Nkeys() )             ' fill new keys array„                                                       '„  FOR O = Ocount TO 1 STEP -1                          ' once for each old key„    IF Ncount > 0 THEN                                 '  if there are any new keys„      ARRAY SCAN Nkeys(1) FOR Ncount, = Okeys(O), TO N '   scan for match with old„      IF N > 0 THEN                                    '   if we've found a match„        ARRAY DELETE Nkeys(N)                          '    delete from new list„        DECR Ncount                                    '    decrease new count„        ITERATE                                        '    loop it„      END IF                                           '„    END IF                                             '„    IF g_KeyLast > 0 THEN                              ' this should be redundant!„      uKey.tKey.SoundEX = Okeys(O)                     '  set union SoundEX value„      Offset = fKeyFileSeek(uKey,-1)                   '  seek existing key offset„      IF Offset => 0 THEN                              '  got it!„        KeyFileMove Offset, -8                         '   close up file„        DECR g_KeyLast                                 '   decrease last record #„      END IF                                           '„    END IF                                             '„  NEXT                                                 '„                                                       '„  WHILE Ncount > 0                                     ' if any new keys left in list„    uKey.tKey.SoundEX = Nkeys(Ncount)                  '  set union SoundEX value„    Offset = fKeyFileSeek(uKey,0)                      '  seek file offset„    KeyFileMove Offset, 8                              '  open file„    PUT g_KeyFile, Offset, uKey                        '  stuff new key„    INCR g_KeyLast                                     '  increase last record #„    DECR Ncount                                        '  previous new key„  WEND                                                 '„                                                       '„  IF OldLast > g_KeyLast THEN                          ' if file is shorter then„    SEEK   #g_KeyFile, g_KeyLast * 8                   '  truncate file„    SETEOF #g_KeyFile                                  '„  END IF                                               '„                                                       '„END SUB                                                '„'„'-------------------------------------------------------------------------------„'„FUNCTION fKeyFileSearch ( BYVAL TheWord AS STRING, _„                          SEG   RecNo() AS LONG    ) EXPORT AS LONG„„  DIM  Count   AS LOCAL LONG                           ' found keys count„  DIM uKey     AS LOCAL KeyWordUNION                   ' record union„  DIM  Last    AS LOCAL LONG                           ' last ubound for RecNo array„  DIM  Offset  AS LOCAL LONG                           ' file offset„  DIM  SoundEX AS LOCAL LONG                           ' sought after SoundEX value„                                                       '„  TheWord           = UCASE$(TRIM$(TheWord))           ' strip and ucase key word„  SoundEX           = fKeyFileSoundEX(TheWord)         ' set SoundEX value„  uKey.tKey.RecNo   = -1                               ' create a SoundEX record 1 less„  uKey.tKey.SoundEX = SoundEX - 1                      '           than the one we want„  Offset            = fKeyFileSeek(uKey,0)             ' find starting file offset„                                                       '„  SEEK g_KeyFile, Offset                               ' set file pointer„  FOR Offset = (Offset \ 8) TO g_KeyLast               ' loop until end of file„    GET g_KeyFile, , uKey                              '  read next record„    IF uKey.tKey.SoundEX <> SoundEX THEN EXIT FOR      '  if SoundEX values don't match„    INCR Count                                         '  bump the counter„    IF Count > Last THEN                               '  if counter > ubound of array„      Last = Last + 10                                 '   add a few new elements to array„      REDIM PRESERVE RecNo(Last)                       '   redim holding array„    END IF                                             '„    RecNo(Count) = uKey.tKey.RecNo                     '  stuff item„  NEXT                                                 '„                                                       '„  IF Count > 1 THEN ARRAY SORT RecNo(1) FOR Count      ' if there's anyhting to sort„                                                       '„  FUNCTION = Count                                     ' RETURN number of found items„„END FUNCTION„'„'-------------------------------------------------------------------------------„'-------------- SUPPORTING ROUTINES --------------------------------------------„'-------------------------------------------------------------------------------„'„SUB KeyFileMove ( BYVAL Offset AS LONG, _„                  BYVAL Bytes  AS LONG  )„„  DIM BytesLeft AS LOCAL LONG                          ' bytes left to be moved„  DIM Buf       AS LOCAL STRING                        ' buffer to hold bytes being moved„  DIM Chunk     AS LOCAL LONG                          ' size of current bytes being moved„  DIM L         AS LOCAL LONG                          ' temp variable„                                                       '„  L         = LOF( g_KeyFile )                         ' length of file„  BytesLeft = L - Offset                               '„                                                       '„  IF Bytes > 0 THEN                                    ' opening a space„      Offset = L                                       '„    ELSE                                               ' closing up a gap„      Offset    = Offset - Bytes                       '„      BytesLeft = BytesLeft + Bytes                    '„  END IF                                               '„                                                       '„  DO                                                   '„    Chunk = MIN( 512000, BytesLeft )                   ' size of chunk„    IF Bytes > 0 THEN Offset = Offset - Chunk          ' fix seek position„    SEEK #g_KeyFile, Offset                            ' set get position„    GET$ #g_KeyFile, Chunk, Buf                        ' take a bite„    SEEK #g_KeyFile, Offset + Bytes                    ' set put position„    PUT$ #g_KeyFile, Buf                               ' spit it out„    IF Bytes < 0 THEN Offset = Offset + Chunk          ' fix seek position„    BytesLeft = BytesLeft - Chunk                      ' decr work load„  LOOP UNTIL BytesLeft =< 0                            '„„END SUB„'„'-------------------------------------------------------------------------------„'„FUNCTION fKeyFileSoundEX ( SEG TheWord AS STRING ) AS LONG„„  REGISTER SndX AS LONG                                '„  REGISTER Char AS LONG                                ' character value„                                                       '„  DIM      Last    AS LOCAL LONG                       ' last character processed„  DIM      Letters AS LOCAL LONG                       '„  DIM      Vals    AS LOCAL STRING * 27                ' SndX values„  DIM      V_ptr   AS LOCAL BYTE PTR                   ' pointer to values„  DIM      W_ptr   AS LOCAL BYTE PTR                   ' pointer to incoming data„  DIM      Widx    AS LOCAL LONG                       ' index to incoming data pointer„                                                       '„  Vals    = CHR$(0,0,1,2,3,0,1,2,0,0,2,2,4,5) & _      ' SndX values from _A -> M„            CHR$(5,0,1,2,6,2,3,0,1,0,2,0,2)            '                   N -> Z„  V_ptr   = VARPTR(Vals)                               ' pointer to above„  W_ptr   = STRPTR(TheWord)                            ' set ptr to incoming string„  Letters = 9                                          ' 1 letter & 9 numbers„                                                       '„  FOR Widx = 0 TO LEN(TheWord)-1                       ' once for each letter„    Char = @W_ptr[Widx]                                '  draw off the letter„    IF Char < 65   THEN ITERATE                        '  can't be a valid letter„    Char = ( Char AND &b11111 )                        '  ucase & subtract 64„    IF Char > 26 THEN ITERATE                          '  oops! this ain't a letter either„    IF SndX <> 0 THEN                                  '„        Char = @V_ptr[Char]                            '„        IF Char = Last THEN ITERATE                    '  same as last char„        Last = Char                                    '„        IF Char = 0 THEN ITERATE                       '„        SndX = (SndX OR Char)                          '  place value into buffer„        IF Letters = 0 THEN EXIT FOR                   '  check if buffer is full„      ELSE                                             '„        SndX = Char                                    '  A = 1  Z = 26„        Last = @V_ptr[Char]                            '„    END IF                                             '„    SHIFT LEFT SndX, 3                                 '„    DECR Letters                                       '  decr buffer counter„  NEXT                                                 '„                                                       '„  IF Letters > 0 THEN                                  ' add trailing zeros„    SHIFT LEFT SndX, ( Letters * 3 )                   '„  END IF                                               '„                                                       '„  FUNCTION = SndX                                      'RETURN SOUNDEX VALUE„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„SUB KeyStringFormat ( SEG KeyWords AS STRING )„„  DIM Count    AS LOCAL LONG                           ' # of keywords in string„  DIM Keys(25) AS LOCAL STRING                         ' individual keywords„  DIM X        AS LOCAL LONG                           ' loop counter„                                                       '„  IF LEN(KeyWords) = 0 THEN EXIT SUB                   ' nothing to do here„                                                       '„  KeyWords = UCASE$(KeyWords)                          ' convert to all uppercase„                                                       '„  Count = 1                                            ' assume at least 1 keyword„  FOR X = 1 TO PARSECOUNT(KeyWords)                    ' loop through pieces of $„    Keys(Count) = PARSE$(KeyWords,X)                   '  set new word value„    Keys(Count) = TRIM$(Keys(Count))                   '  strip any outside spaces„    IF LEN(Keys(Count)) > 0 THEN INCR Count            '  ok! we've got a word„  NEXT                                                 '„  DECR Count                                           ' back off by one„  KeyWords = ""                                        ' reset incoming/returning $„                                                       '„  IF Count = 0 THEN EXIT SUB                           ' no keywords found„                                                       '„  ARRAY SORT Keys(1) FOR Count                         '„                                                       '„  KeyWords = Keys(Count)                               ' start at the end„  DECR Count                                           '„  FOR X = Count TO 1 STEP -1                           ' rebuild KeyWords string„    IF Keys(X) <> Keys(X+1) THEN                       '  if this word not already„      KeyWords = Keys(X) & "," & KeyWords              '   in the string then add it„    END IF                                             '„  NEXT                                                 '„„END SUB„'„'-------------------------------------------------------------------------------„'„FUNCTION fKeys2Array ( SEG KeyWords AS STRING, _„                       SEG Keys()   AS LONG    ) AS LONG„„  DIM Count AS LOCAL LONG                              ' # of keywords in string„  DIM Temp  AS LOCAL STRING                            ' temp string„  DIM X     AS LOCAL LONG                              ' loop counter„                                                       '„  Count = PARSECOUNT(KeyWords)                         ' count the individual words„  REDIM Keys(Count)                                    ' establish SoundEX array„  FOR X = 1 TO Count                                   ' fill array„    Temp = PARSE$(KeyWords,X)                          '  get individual word„    Keys(X) = fKeyFileSoundEX(Temp)                    '  set/create SoundEX value„  NEXT                                                 '„                                                       '„  ARRAY SORT Keys(1) FOR Count, DESCEND                ' sort SoundEx values„  ARRAY SCAN Keys(1) FOR Count, = 0, TO X              ' find any zero values„  IF X > 0 THEN Count = X -1                           ' if any 0s found set new count„  IF Count = 0 THEN EXIT FUNCTION                      ' nothing left to do„                                                       '„  X = 2                                                ' remove any double values„  WHILE Count > 1                                      '„    IF Keys(X-1) = Keys(X) THEN                        '  if same SoundEx value„        ARRAY DELETE Keys(X)                           '   remove it from the array„        DECR Count                                     '   one less in the mess„      ELSE                                             '„        INCR X                                         '   next value„    END IF                                             '„    IF X > Count THEN EXIT LOOP                        '   all done„  WEND                                                 '„                                                       '„  FUNCTION = Count                                     ' RETURN number of SoundExs„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION fKeyFileSeek( SEG   uKey    AS KeyWordUNION, _„                       BYVAL  Unique AS LONG          ) AS LONG„„  DIM F    AS LOCAL LONG                               ' top record #„  DIM L    AS LOCAL LONG                               ' bottom record #„  DIM M    AS LOCAL LONG                               ' middle record #„  DIM Qval AS LOCAL QUAD                               ' middle record value„                                                       '„  IF g_KeyLast = 0 THEN EXIT FUNCTION                  ' oops! nothing to do here„  F = 0                                                ' first record #„  L = g_KeyLast -1                                     ' last record #„  DO                                                   ' start search„    M = ( F + L ) \ 2                                  '  compute half way mark„    GET g_KeyFile, M*8, Qval                           '  read record„    IF M = F THEN EXIT LOOP                            '  if we've hit the mean record„    IF uKey.Qkey =< Qval THEN L = M ELSE F = M         '  compute new half of list„  LOOP                                                 '„                                                       '„  WHILE uKey.Qkey > Qval                               ' if we've not quite there yet„    INCR M                                             '  next record #„    IF M => g_KeyLast THEN EXIT LOOP                   '  oops! run out of records!„    GET g_KeyFile, M*8, Qval                           '  read record„  WEND                                                 '„  SHIFT LEFT M, 3                                      '  compute file offset„                                                       '„  IF (Unique <> 0) AND (uKey.Qkey <> Qval) THEN M = -M ' if not unique or exact match„                                                       '„  FUNCTION = M                                         ' RETURN Offset value„                                                       '„END FUNCTION„'„'-------------------------------------------------------------------------------„'------------ TEST MESS! -------------------------------------------------------„'-------------------------------------------------------------------------------„'„#IF 1„FUNCTION PBmain ()„„  DIM  FileSpec AS LOCAL STRING„  DIM uKey      AS LOCAL KEYWORDUNION„  DIM  L        AS LOCAL LONG„  DIM  NewKeys  AS LOCAL STRING„  DIM  OldKeys  AS LOCAL STRING„  DIM  R(0)     AS LOCAL LONG„  DIM  RecNo    AS LOCAL LONG„  DIM  X        AS LOCAL LONG„„  FileSpec = "KEYTEST.DAT"                                   ' test file„  OldKeys  = "BLACK,GREEN,ORANGE,RED"                        ' existing formatted data„  NewKeys  = "RED,GREEN,BLUE,BLACK,,GREEN,black,PURPLE ,RED" ' user input„                                                             '„  IF LEN(DIR$(FileSpec)) > 0 THEN KILL FileSpec              ' kill test file„  X = fKeyFileOpen( FileSpec, 0 )                            '„  IF X <> 0 THEN                                             '„    PRINT "ERROR"; X                                         '„    WAITKEY$                                                 '„  END IF                                                     '„                                                             '„  FOR RecNo = 1 to 4 step 1                                  ' load up some data„    IF RecNo = 3 THEN ITERATE                                '„    KeyFileUpdate ""     , OldKeys, RecNo                    '„    KeyFileUpdate OldKeys, NewKeys, RecNo                    '„  NEXT                                                       '„  KeyFileInsert "Fire-Engine Red", 3                         ' load individual stuff„  KeyFileInsert "Blue", 3                                    '„  KeyFileDelete "Blue", 2                                    ' delete one„                                                             '„  PRINT NewKeys                                              ' returned goodies„  PRINT STRING$(79,45)                                       '„  PRINT g_KeyLast                                            '„  FOR X = 0 TO g_KeyLast -1                                  '„    GET #g_KeyFile, x*8, uKey                                '„    PRINT uKey.tKey.SoundEx, uKey.tKey.RecNo,                '„    PRINT FORMAT$(uKey.Qkey,"##################")            '„  NEXT                                                       '„  PRINT STRING$(79,45)                                       '„  L = fKeyFileSearch("purple",R())                           ' find all the matches for 'GRIN'„  FOR X = 1 TO L                                             '  these will be the same as for„    PRINT R(X)                                               '  GREEN„  NEXT                                                       '„  KeyFileClose                                               '„  WAITKEY$                                                   '„„END FUNCTION„„#ENDIF„Don Schullian                  SOUNDEX VERSION 2              d83@DASoftVSS.com              04-11-00 (16:35)       PBCC                   228  12408    SOUNDEX2.BAS#IF 0„    ----------------------------                      PowerBASIC/cc v2.0„ ---|          DASoft          |------------------------------------------„    ----------------------------         Code           DATE: 2000-04-10„    | FILE NAME   SoundEX2.bas |          by„    ----------------------------  Don Schullian, Jr.„„              This code is released into the Public Domain„       ----------------------------------------------------------„        No guarantee as to the viability, accuracy, or safety of„         use of this code is implied, warranted, or guaranteed.„       ----------------------------------------------------------„                         Use at your own risk!„       ----------------------------------------------------------„                  CONTACT AUTHOR AT d83@DASoftVSS.com„ -------------------------------------------------------------------------„„Hi,„„  There are 3 functions in this file along with a bit of test code. In any„one program you not use all of them as fSoundEXuscb is a stand alone item„and fSoundEX2str would not, particularly be required unless you wished to„display the results to the user.„„  Here's what I've learned (and think I know) about SoundEX:„„  1) only letters from A->Z are accepted„     a) I saw one augmentation that accepted the Spanish 'n' with the„        tone mark (as the third letter in Nina would be) that held the„        same value as the english "N"„„  2) the official version created for and used by the US Census Bureau„     consists of 1 letter A-Z and 3 numbers 0->6 where the zero would„     only be used to pad a string to 4 characters.„       eg: Schullian creates a soundex of "S45" but as 4 characters are„           required a trailing zero is added to create "S450"„„  3) The 4 character SoundEX can be extended up to 10 positions by„     packing the data into 5 bits for the leading letter and 3 bits„     for the following 9 numbers. This system follows exactly the„     same rules as the 'official' version but packs the values into„     bits and works on more characters. The values returned by this„     system use all 32 bits and would require a DWORD to keep„     everything in strict alphabetical order but:„     a) if the user never sees the code and your search/sort routines„        will work with negative values then a LONG INTEGER will do„        just fine„     b) you could request a 9 position SoundEX, store it in a LONG and„        not have to worry about negative values and/or force the use„        of DWORDs. (LONGs will process much faster than DWORDs)„„  Ok, down below are all three functions for your review. Which you use„and how you use any of them would depend, of course, on what your program„requires. fSoundEX&& allows you to select the number of bits your„SoundEX code will require. The rule is ((Characters * 3) + 2)bits so you„can store 4 characters in a 2byte INTEGER [ 4+3 = 12 + 2 = 14] and never„exceed 32k! By adding just one more character you'll surpass the 16bit„limit of a WORD and be required to either jump into a 3byte string (yuk!)„or move into a LONG.„„C'ya,„„d83„--------------------------------------------------------------------------------„fSoundEX&& (TheWord$,Letters&)„  PURPOSE: Create a SoundEX representation of a given STRING„   PARMAS: TheWord$ - the STRING to be processed„           Letters& - The maximum number of soundex letters to process„                      10 (max) will fill a 32bit integer„                       4 (min) will fill an 16bit integer„  RETURNS: ( (Letters * 3) + 2 ) significant bits„     NOTE: IF Letters& =< 4 then the value will never exceed 32k„           IF Letters& = 10 then a DWORD is required to keep all values positive„„fSoundEX2str$ (SndEX&&,Letters&)„  PURPOSE: Convert a SoundEX value into a humanized string„   PARAMS: SndEX&&  - The soundex value„           Letters& - The number of letters/positions in the returning string„  RETURNS: A string where the first character is a letter A -> Z followed by„           Letters-1 numbers from 0 -> 6„           EG: "S450" or "W363"„     NOTE: If the SndEX value was not created using the same number of„           Letters then the returning value may be incorrect or could even„           cause an error.„„fSoundEXuscb$ (TheName$)„  PURPOSE: To create a 4 character SoundEX string that is used by the„           US Census Beurough„   PARAMS: The name to be converted/computed„  RETURNS: A 4 character SoundEX string that has a leading letter from„           A -> Z followed by 3 numbers 0 -> 6„           eg: S450  W363„ -------------------------------------------------------------------------„#ENDIF„„FUNCTION fSoundEX ( BYVAL TheWord AS STRING, _„                    BYVAL Letters AS LONG    ) EXPORT AS DWORD„„  REGISTER SndX AS LONG                                '„  REGISTER Char AS LONG                                ' character value„                                                       '„  DIM      Last    AS LOCAL LONG                       ' last character processed„  DIM      Vals    AS LOCAL STRING * 27                ' SndX values„  DIM      V_ptr   AS LOCAL BYTE PTR                   ' pointer to values„  DIM      W_ptr   AS LOCAL BYTE PTR                   ' pointer to incoming data„  DIM      Widx    AS LOCAL LONG                       ' index to incoming data pointer„                                                       '„  Vals    = CHR$(0,0,1,2,3,0,1,2,0,0,2,2,4,5) & _      ' SndX values from _A -> M„            CHR$(5,0,1,2,6,2,3,0,1,0,2,0,2)            '                   N -> Z„  V_ptr   = VARPTR(Vals)                               ' pointer to above„  W_ptr   = STRPTR(TheWord)                            ' set ptr to incoming string„  Letters = MIN(9,Letters-1)                           ' 1 letter & n numbers„                                                       '„  FOR Widx = 0 TO LEN(TheWord)-1                       ' once for each letter„    Char = @W_ptr[Widx]                                '  draw off the letter„    IF Char < 65   THEN ITERATE                        '  can't be a valid letter„    Char = ( Char AND &b11111 )                        '  ucase & subtract 64„    IF Char > 26 THEN ITERATE                          '  oops! this ain't a letter either„    IF SndX <> 0 THEN                                  '„        Char = @V_ptr[Char]                            '„        IF Char = Last THEN ITERATE                    '  same as last char„        Last = Char                                    '„        IF Char = 0 THEN ITERATE                       '„        SndX = (SndX OR Char)                          '  place value into buffer„        IF Letters = 0 THEN EXIT FOR                   '  check if buffer is full„      ELSE                                             '„        SndX = Char                                    '  A = 1  Z = 26„        Last = @V_ptr[Char]                            '„    END IF                                             '„    SHIFT LEFT SndX, 3                                 '„    DECR Letters                                       '  decr buffer counter„  NEXT                                                 '„                                                       '„  IF Letters > 0 THEN                                  ' add trailing zeros„    SHIFT LEFT SndX, ( Letters * 3 )                   '„  END IF                                               '„                                                       '„  FUNCTION = SndX                                      'RETURN SOUNDEX VALUE„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION fSoundEX2str( BYVAL SndEx   AS DWORD, _„                       BYVAL Letters AS LONG   ) AS STRING„„  DIM Temp  AS LOCAL STRING * 10                       '„  DIM T_ptr AS LOCAL BYTE PTR                          '„                                                       '„  Temp  = STRING$(10,32)                               ' pad working string„  T_ptr = VARPTR(Temp)                                 ' set pointer to above„                                                       '„  DO                                                   ' start processing SndEX„    DECR Letters                                       ' back up one posn for offset„    IF Letters > 0 THEN                                ' if not 1st letter„        @T_ptr[Letters] = ( SndEx AND &b111 ) + 48     '   set 0 -> 6„        SHIFT RIGHT SndEx, 3                           '   shift off last 3 bits„      ELSE                                             ' 1st letter„        @T_ptr = ( SndEx + 64 )                        '   set A -> Z„        EXIT LOOP                                      '„    END IF                                             '„  LOOP                                                 '„                                                       '„  FUNCTION = RTRIM$(Temp)                              ' RETURN only used portion of $„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION fSoundEXuscb ( BYVAL TheWord AS STRING ) EXPORT AS STRING„„  DIM Char    AS LOCAL LONG                            ' character values„  DIM Last    AS LOCAL LONG                            ' last char processed„  DIM Letters AS LOCAL LONG                            ' letter counter„  DIM Temp    AS LOCAL STRING *  4                     ' working string„  DIM T_ptr   AS LOCAL BYTE PTR                        ' pointer to above„  DIM Vals    AS LOCAL STRING * 27                     ' SoundEX values„  DIM V_ptr   AS LOCAL BYTE PTR                        ' pointer to values„  DIM W_ptr   AS LOCAL BYTE PTR                        ' pointer to incoming data„  DIM Widx    AS LOCAL LONG                            ' index to incoming data pointer„                                                       '„           '  ABCDEFGHIJKLMNOPQRSTUVWXYZ"              ' corresponding letters„  Vals    = "001230120022455012623010202"              ' alignment byte + A -> Z„  V_ptr   = VARPTR(Vals)                               ' pointer to above„  W_ptr   = STRPTR(TheWord)                            ' set ptr to incoming string„  Temp    = "0000"                                     '„  T_ptr   = VARPTR(Temp)                               '„                                                       '„  FOR Widx = 0 TO LEN(TheWord)-1                       ' once for each letter„    Char = @W_ptr[Widx]                                '  draw off the letter„    IF Char < 65   THEN ITERATE                        '  can't be a valid letter„    Char = ( Char AND &b11111 )                        '  ucase & subtract 64„    IF Char > 90 THEN ITERATE                          '  oops! this ain't a letter either„    IF Letters > 0 THEN                                '„        Char = @V_ptr[Char]                            '„        IF Char = Last THEN ITERATE                    '  same as last char„        Last = Char                                    '„        IF Char = 48 THEN ITERATE                      '„        @T_ptr[Letters] = Char                         '  place value into buffer„        IF Letters = 3 THEN EXIT FOR                   '  check if buffer is full„      ELSE                                             '„        @T_ptr[0] = Char + 64                          '  A = 1  Z = 26„        Last = @V_ptr[Char]                            '„    END IF                                             '„    INCR Letters                                       '  decr buffer counter„  NEXT                                                 '„                                                       '„  FUNCTION = Temp                                      'RETURN SOUNDEX VALUE„„END FUNCTION„'„'-------------------------------------------------------------------------------„'„FUNCTION PBmain ()„„  DIM TheName AS LOCAL STRING„  DIM SoundEX AS LOCAL STRING * 4„  DIM SndEX   AS LOCAL DWORD„„  SndEX = fSoundEX("schullian",4)„  PRINT FORMAT$(SndEX,",#")„  PRINT BIN$(SndEX,32)„  PRINT fSoundEXstr(SndEX,4)„  PRINT fSoundEXuscb("WOODYARD")„  PRINT fSoundEXuscb("schullian")„  WAITKEY$„„END FUNCTION„Don Schullian                  LARGE PRIME NUMBER GENERATOR   d83@DASoftVSS.com              04-11-00 (16:35)       PBCC                   317  19274    PRIME.BAS   #if 0„    ----------------------------                      PowerBASIC/cc v2.0„ ---|          DASoft          |------------------------------------------„    ----------------------------         Code           DATE: 2000-04-08„    | FILE NAME   PrimeGEN.bas |          by„    ----------------------------  Don Schullian, Jr.„„              This code is released into the Public Domain„        ---------------------------------------------------------„         No guarentee as to the viability, accuracy, or safty of„          use of this code is implied, warrented, or guarenteed„        ---------------------------------------------------------„                         Use at your own risk!„        ---------------------------------------------------------„                  CONTACT AUTHOR AT d83@DASoftVSS.com„ -------------------------------------------------------------------------„„Hi,„„  First of all, I'm NOT a mathematician so bare with me here.„„  The code below contains ideas from, at least, three different sources plus one„or two of my own. The code is also optimized for speed over size as each clock„tick in the main loop could cost quadrillions of ticks throughout the run of„the program. And, lastly, when/if the user bails out or the program hits the„maximum number requested the next number in line to be checked will end in a„seven (7). This was done to facilitate restarting the program where it left off.„„  The overall theory of this prime number generator is to test only 40% of the„existing numbers. All even numbers (except 2) are NOT primes and all numbers„ending in 5 (except 5) are not primes. Hence only those numbers ending in 1, 3,„7 or 9 can qualify. Testing only odd numbers is quite common but I've added the„double loop that also skips those numbers divisible by 5.„„  Next, 1, 2, 3, and 5 are loaded and testing starts with 7. The generated file„then holds only 1/2 the difference between one prime and the following prime. This„assumes that no two prime numbers are more than 510 apart. (as both primes are odd,„the difference will always be even) So far, with all my testing this condition has„not even been neared and as I've gone past 40M primes I'd guess that it is safe.„There is an error test for this condition and the program will end if it is exceeded.„„  There are 2 constants (below) that manage the buffer sizes:„„%BufSize determines the size of the 'testing primes'. 4k was sufficient to test„the first 40M primes, with 100 values not used.„„%HoldSize determines how many new primes are found before the buffer is flushed„to the file. I'd suggest that you keep this value an increment of 4k to maximize„the speed which it will transfer the data.„„  If the highest prime you require will fit into a LONG INTEGER then change all„the QUADs to LONGs. (40Mth prime only in the range of 800M) This holds true also„for DWORDs (4B). Either of these simple changes will speed the program up by„quite a bit.„„  If you plan on running this program all night then make sure that you turn off„ALL screen savers, power savers, etc. or you'll end up with a program sitting around„doing nothing!„„The sub PrimeView is incomplete so you can fill in the pertinent print command(s)„that you will require. Remember, if you go to disk then make sure you've got some„space available! 40M primes printed out in text will require over 760M of file space„and reams of paper!„„#endif„'--------------------------------------------------'„'          PRIME NUMBER GENERATOR                  '„'--------------------------------------------------'„%BufSize        =   4096                           '  4k„%HoldSize       =  32768                           ' 32k„%DisplayReports = -1                               '„'--------------------------------------------------'„'                                                  '„'--------------------------------------------------'„DECLARE SUB PrimeGen  (BYVAL F AS STRING,BYVAL N AS QUAD,BYVAL S AS LONG)„DECLARE SUB PrimeView (BYVAL F AS STRING)„'--------------------------------------------------'„'                                                  '„'--------------------------------------------------'„FUNCTION PBmain ()                                 '„                                                   '„  DIM MaxNbr AS LOCAL QUAD                         '„                                                   '„  CONSOLE SCREEN 25, 80                            '„  CURSOR OFF                                       '„                                                   '„  MaxNbr = &h7FFFFFFFFFFFFFFF                      ' 4+ quintillian is max„                                                   '„  PrimeGen "TEST.DAT", MaxNbr, 0                   '„                                                   '„END FUNCTION                                       '„'--------------------------------------------------'„'                                                  '„'--------------------------------------------------'„SUB PrimeGen ( BYVAL FileSpec AS STRING, _„               BYVAL MaxNbr   AS QUAD  , _„               BYVAL Restart  AS LONG    )„„  DIM B             AS LOCAL LONG                  ' loop counter„  DIM Bdata         AS LOCAL STRING * %BufSize     ' temporary data buffer„  DIM Buf(%BufSize) AS LOCAL DWORD                 ' working buffer for primes„  DIM Boff          AS LOCAL LONG                  ' working buffer loop counter„  DIM B_ptr         AS LOCAL BYTE PTR              ' pointer to temp buffer„  DIM Count         AS LOCAL QUAD                  ' found/saved prime counter„  DIM D             AS LOCAL STRING                ' display string„  DIM Etime         AS LOCAL SINGLE                ' elapsed time storage„  DIM Hold          AS LOCAL STRING * %HoldSize    ' found prime # storage„  DIM H_ptr         AS LOCAL BYTE PTR              ' pointer to above„  DIM Hlast         AS LOCAL LONG                  ' %HoldSize -1„  DIM Hoff          AS LOCAL LONG                  ' offset for H_ptr„  DIM LastPrime     AS LOCAL QUAD                  ' previously found prime number„  DIM N             AS LOCAL QUAD                  ' working number loop counter„  DIM Nbr           AS LOCAL QUAD                  ' sub loop working number„  DIM S             AS LOCAL DWORD                 ' sqr value of working number„  DIM Start         AS LOCAL QUAD                  ' 1st number to start search (7 is default)„  DIM Ok            AS LOCAL LONG                  ' prime found flag„  DIM X             AS LOCAL LONG                  ' junk variable for testing, etc.„                                                   '„  B_ptr     = VARPTR(Bdata)                        ' working buffer pointer„  H_ptr     = VARPTR(Hold)                         ' holding buffer for primes„  Start     = 7                                    '„  LastPrime = 5                                    ' last 'found' prime number„                                                   '„  IF Restart = 0 THEN                              '„    IF LEN(DIR$(FileSpec)) > 0 THEN KILL FileSpec  ' clear the existing file„    OPEN FileSpec FOR BINARY AS #1 BASE=0          ' open new file„  ELSE                                             '„    OPEN FileSpec FOR BINARY AS #1 BASE=0          ' open existing file„    GET$ #1, 4, D                                  ' read signature characters„    N = LOF(1) - 4                                 ' get length of file„    IF (N < 0 ) OR ( D <> CHR$(0,0,0,1) ) THEN     ' test if our file or not„      CLOSE #1                                     '  no... it isn't„      PRINT FileSpec; "isn't one of my files"      '  print warning message„      WAITKEY$                                     '  wait for a keypress„      EXIT SUB                                     '  exit program„    END IF                                         '„    WHILE N > 0                                    ' while data in file„      Nbr = MIN(N,%HoldSize)                       '  compute next chunk size„      N   = N - Nbr                                '  decrease bytes left in file„      GET$ #1, Nbr, Hold                           '  read chunk into buffer„      FOR B = 0 TO Nbr-1                           '  read each byte of buffer„        LastPrime = LastPrime + ( 2 * @H_ptr[B] )  '   compute next prime number„      NEXT                                         '„    WEND                                           '„    Start = LastPrime                              ' the next starting prime will end in a 7„    DO                                             ' so we search it out„      Start = Start + 2                            '„    LOOP UNTIL (Start MOD 10) <> 7                 '„  END IF                                           '„                                                   '„  Buf(1)  =  3                                     ' we'll start here„  Boff    =  1                                     ' working buffer offset„  Ok      = -1                                     ' prime found flag„                                                   '„  FOR N = 7 TO &h7FFFFFFFFFFFFFFF STEP 10          ' create working primes„    FOR Nbr = N TO (N + 6) STEP 2                  '  7, 9, 11, 13 skip numbers divisible by 5„      S = SQR(Nbr)                                 '  get sqr of N s„      FOR B = 1 TO Boff                            '  check previous primes against N„        IF Buf(B) > S THEN EXIT FOR                '   this prime > SQR(N) so we're done„        IF (Nbr MOD Buf(B)) = 0 THEN               '   this N divides equally by Prime(B)„          Ok = 0                                   '    turn off  'found' flag„          EXIT FOR                                 '    bail out of testing loop„        END IF                                     '„      NEXT                                         '„      IF Ok = 0 THEN                               '„          Ok = -1                                  '  This ain't a prime„        ELSE                                       '„          INCR Boff                                '   set last found prime flag„          Buf(Boff) = Nbr                          '   store found value in array„          IF Boff = %BufSize THEN EXIT, EXIT       '   the buffer is full„      END IF                                       '„    NEXT                                           '„  NEXT                                             '„                                                   '„  Count = SEEK(1)                                  '„  Hold  = CHR$(0,0,0,1)                            ' 1,2,3,5„  Hoff  =  3                                       ' hold buffer offset„  Hlast = %HoldSize - 4                            ' last hold buffer offset„  Ok    = -1                                       ' prime found flag„  Boff  =  3                                       ' working prime buffer offset for file input„                                                   '„  Etime = TIMER                                    ' start the timer„                                                   '„  FOR N = Start TO MaxNbr STEP 10                  ' This can be one HUMUMGUS! number„    FOR Nbr = N TO (N + 6) STEP 2                  '  7, 9, 11, 13 skip numbers divisible by 5„      S = SQR(Nbr)                                 '  get sqr of N s„      DO                                           '„        FOR B = 1 TO %BufSize                      '  check previous primes against N„          IF Buf(B) > S THEN EXIT, EXIT            '   this prime > SQR(N) so we're done„          IF (Nbr MOD Buf(B)) = 0 THEN             '   this N divides equally by Prime(B)„            Ok = 0                                 '    turn off 'found' flag„            EXIT, EXIT                             '    bail out of testing loop„          END IF                                   '„        NEXT                                       '„        Boff   = Boff + %BufSize                   '  we've run out of buffered primes„        Buf(0) = Buf(%BufSize)                     '  set last known prime„        GET #1, Boff, Bdata                        '  load in data„        FOR B = 0 TO %BufSize -1                   '  compute new prime set„          Buf(B+1) = Buf(B) + (@B_ptr[B] * 2)      '„        NEXT                                       '„      LOOP                                         '„                                                   '„      IF Boff > 3 THEN                             '  if we've loaded a new set of primes„        Buf(1) = 3                                 '   back up to 1st set of primes„        Buf(2) = 7                                 '   notice that 5 is skipped„        GET #1, 4, Bdata                           '   load 1st %BufSize primes„        FOR B = 2 TO %BufSize -1                   '   reset buffer values„          Buf(B+1) = Buf(B) + (@B_ptr[B] * 2)      '„        NEXT                                       '„        SEEK #1, Count                             '   replace file pointer to end„        Boff = 3                                   '   reset flag„      END IF                                       '„                                                   '„      IF Ok = 0 THEN                               '  no, this number isn't a prime„        Ok = -1                                    '„        ITERATE                                    '„      END IF                                       '„                                                   '„      Ok = (Nbr - LastPrime)                       ' difference between last 2 primes„      IF Ok > 510 THEN                             ' oops! Houston, we have a problem!„        PRINT "Difference Overflow at"; Nbr        '„        EXIT, EXIT                                 '„      END IF                                       '„      INCR Hoff                                    '„      SHIFT RIGHT Ok, 1                            ' \ difference by 2„      LastPrime    = Nbr                           ' set new last prime found„      @H_ptr[Hoff] = Ok                            ' store difference„    NEXT                                           '„                                                   '„    IF Hoff => Hlast THEN                          ' if hold buffer is full, write to disk„      INCR Hoff                                    ' this is outside the Nbr loop to make„      PUT$ #1, LEFT$(Hold, Hoff)                   '  restarting easier to compute„      Count = Count + Hoff                         '„      Hoff  = -1                                   '„      IF INSTAT THEN                               ' if keyboard action„        IF INKEY$ = CHR$(27) THEN EXIT FOR         '  if such action was <ESC>„      END IF                                       '„      #if %DisplayReports                          '„        LOCATE 1, 1                                '„        PRINT FORMAT$(Count, ",# Primes in");      '„        PRINT FORMAT$(Nbr  ," ,# Nmbrs at ");      '„        PRINT LEFT$(TIME$,5);                      '„      #endif                                       '„    END IF                                         '„  NEXT                                             '„                                                   '„  IF Hoff > -1 THEN                                '„    INCR Hoff                                      ' clear out remaining primes in Hold buffer„    PUT$ #1,  LEFT$(Hold,Hoff)                     '„    Count = SEEK(1)                                ' prime count„  END IF                                           '„  SETEOF 1                                         '„  CLOSE #1                                         '„  '------------------------------------------------'„  '------------------------------------------------'END OF FUNCTIONAL PORTION OF CODE„  '------------------------------------------------'„  Etime = TIMER - Etime                            '„  IF Etime < 0 THEN Etime = Etime + 86400          '„  LOCATE 1, 1                                      '„  PRINT FORMAT$(Count, ",# Primes in");            '„  PRINT FORMAT$(Nbr  ," ,# Numbers at ");          '„  PRINT LEFT$(TIME$,5);                            '„  PRINT                                            '„  PRINT FORMAT$(Etime,"ELAPSED TIME ,#.####sec")   '„  INPUT FLUSH                                      '„  WAITKEY$                                         '„                                                   '„END SUB                                            '„'„'-------------------------------------------------------------------------------„'„SUB PrimeView ( BYVAL FileSpec AS STRING )„„  DIM Bytes          AS LOCAL QUAD                 '„  DIM D              AS LOCAL STRING               ' display string„  DIM Hold           AS LOCAL STRING * %HoldSize   ' found prime # stroage„  DIM H_ptr          AS LOCAL BYTE PTR             '„  DIM Hlast          AS LOCAL LONG                 '„  DIM Hoff           AS LOCAL LONG                 '„  DIM LastPrime      AS LOCAL QUAD                 '„                                                   '„  FileSpec = "TEST2.DAT"                           '„  H_ptr = VARPTR(Hold)                             '„                                                   '„  IF LEN(DIR$(FileSpec)) = 0 THEN                  '„    PRINT FileSpec; " has not been found."         '„    WAITKEY$                                       '„    EXIT SUB                                       '„  END IF                                           '„                                                   '„  OPEN FileSpec$ FOR BINARY AS #1                  '„    GET$ #1, 4, D                                  '„    IF D <> CHR$(0,0,0,1) THEN                     '„      CLOSE #1                                     '„      PRINT FileSpec; " is not our file."          '„      WAITKEY$                                     '„      EXIT SUB                                     '„    END IF                                         '„    SEEK #1, 4                                     '„    Bytes     = LOF(1) - 3                         '„    LastPrime = 3                                  '„  WHILE Bytes > 0                                  '„    Hlast = MIN(%HoldSize,Bytes)                   '„    GET$ #1, Hlast, Hold                           '„    FOR Hoff = 0 TO Hlast -1                       '„      LastPrime = LastPrime + ( @H_ptr[Hoff] * 2 ) '„      ' put print statement here                   '„    NEXT                                           '„    Bytes = Bytes - Hlast                          '„  WEND                                             '„  PRINT                                            '„  PRINT FORMAT$(LOF(1),   "COUNT: ,#")             '„  PRINT FORMAT$(LastPrime," LAST: ,#")             '„  CLOSE #1                                         '„  WAITKEY$                                         '„                                                   '„END SUB„Jerry Fielden                  COPY TEXT SCREEN FOR PBCC      fielden@pldi.net               04-16-00 (20:49)       PBCC                   190  7430     CCTXTGET.BAS  '----------------------------------------------------------„  '  Author: Jerry Fielden                  Date: 2000      |„  '                                                         |„  '---------------------------------------------------------- „  ' These SUBS are for PBCC. They copy Text screens and     |„  ' put them back in same or different locations with its   |„  ' original colors                                         |„  '----------------------------------------------------------„„DECLARE SUB TextPutz (R1&, C1&, R2&, C2&, Area$(), TxClr$())„DECLARE SUB TextGetz (R1&, C1&, R2&, C2&, Area$(), TxClr$())„DECLARE SUB MakeBox()„DECLARE SUB LoadFmFile (Area$(), TxClr$(), TotalChar&, FileNames$)„DECLARE SUB SaveToFile (Area$(), TxClr$(), TotalChar&, FileNames$)„„FUNCTION PBMAIN()„„„ DIM TxClr$(2000) : DIM  Area$(2000)„„ MakeBox '.....................Call the box maker„ SLEEP 500„„ R1& = 1  '......................Starting row„ C1& = 1  '......................Starting column„ r2& = 6  '......................Ending row„ c2& = 16  '.....................Ending column„„ TextGetz R1&, C1&, R2&, C2&, Area$(),TxClr$()  'put it in arrays„„ TextPutz 1, 34, 6, 49, Area$(), TxClr$()  'put it on the screen„ SLEEP 500„„'--------------- Put it into a file and load it back --------------„„ FileNames$ = "Area96.BNY"                              ' Give it a name„ TotalChar& = 96                                        ' Chars in area„ SaveToFile Area$(), TxClr$(), TotalChar&, FileNames$   ' Save it„ RESET Area$() : RESET TxClr$()'..........................Clear Arrays„ LoadFmFile Area$(), TxClr$(), TotalChar&, FileNames$   ' Load it back„„„'---------------------- Paste it at the bottom of screen ---------„ TextPutz 20, 34, 25, 49, Area$(), TxClr$()„ SLEEP 500„„'-------------------- Move it around ----------------„ C1& = 1 : c2& = 16„ FOR R1& = 1 TO 24 STEP 6„     r2& = r1& + 5„     TextPutz R1&, C1&, R2&, C2&, Area$(), TxClr$()„     C1& = C1& + 17„     c2& = c2& + 17„      SLEEP 500„ NEXT R1&„„ SLEEP 2000„„„ '--- Copying Full Screen, saving it in a file and loading it back„„ TextGetz 1, 1, 25, 80, Area$(),TxClr$()                ' Copy full screen„ FileNames$ = "Full2080.BNY"                            ' Give it a name„ TotalChar& = 2000                                      ' Chars in screen„ SaveToFile Area$(), TxClr$(), TotalChar&, FileNames$   ' Save it„ COLOR 7, 0„ RESET Area$() : RESET TxClr$() : CLS                  'Clear Arrays & screen„ LOCATE 12, 1„ PRINT "            Loading Full Screen from File and here it is "„ SLEEP 3000„ LoadFmFile Area$(), TxClr$(), TotalChar&, FileNames$   ' Load it back„ TextPutz 1, 1, 25, 80, Area$(), TxClr$()               ' Put it on Screen„ SLEEP 5000„ COLOR 7, 0„ CLS„ KILL "Full2080.BNY"„ KILL "AREA96.bny" '.........Get rid of temp files„„END FUNCTION„„  '--------------------------------------------------------------------„  ' TextGetz will copy any portion of the screen, even full |„  ' screen into Arrays                                      |„  '----------------------------------------------------------„„  SUB TextGetz (R1&, C1&, R2&, C2&, Area$(), TxClr$())„     row& = R1&: col& = c1&„     RESET Area$() : RESET TxClr$()'....Clear from last time„     Wide& = C2& - C1& + 1'.............get columns wide„     Tall& = R2& - R1&'.................get rows tall„     FOR x& = 1 TO Tall& + 1„        FOR y& = 1 TO Wide&„           INCR nbr&„           TxClr$(nbr&) = CHR$(SCREENATTR(row&, col&))'..Read in color„           Area$(nbr&) = CHR$(SCREEN(row&, col&))'.......Read in a char.„           INCR Col&'............................Setup to do another char.„        NEXT y&„        col& = c1&'............................Setup column for next row„        INCR Row&'.................................Setup to do next row„     NEXT x&„  END SUB„„„  '---------------------------------------------------------------------„  ' TextPutz will put screen portions back in different       |„  ' locations if needed. Portions can be obtained by using    |„  ' SUBs, TextGetz or LoadFmFile. TextPutz uses PCOPY AND     |„  ' PAGE to speed up for standard SCREEN modes Printing       |„  '------------------------------------------------------------„„  SUB TextPutz (R1&, C1&, R2&, C2&, Area$(), TxClr$())„    Col& = C1& : Row& = R1&          ' Get start column & row„    Wide& = C2& - C1& + 1            ' How wide is it„    Tall& = R2& - R1&                ' How tall is it„    PCOPY 1, 2 : PAGE 2, 1           '„    FOR x& = 1 TO Tall& + 1          ' Do the rows„      FOR y& = 1 TO wide&            ' Do the columns„        INCR nbr&„        ForGnd& = ASC(TxClr$(nbr&)) MOD 16&  'Get Forground color„        BackGnd& = ASC(TxClr$(nbr&)) \ 16&   'Get Background color„        COLOR ForGnd&, BackGnd&              'Change the colors„        LOCATE row&, Col&„        PRINT Area$(nbr&);                  ' Print a charecter„        INCR col&                           ' Moving to next column„      NEXT y&„      col& = c1& : INCR row&          ' Get start column & next row„    NEXT x&„    PCOPY 2, 1 : PAGE 1, 1            ' Make it visable„  END SUB„„„„„„'----------------------------------------------------------------------„' SaveToFile saves Full Screen or portions that    |„' was acquired by TextGetz to a binary file which  |„' is also compatible with PBDOS POKE$ statements   |„'---------------------------------------------------„„SUB SaveToFile (Area$(), TxClr$(), TotalChar&, FileNames$)„ OPEN FileNames$ FOR BINARY AS #1'....Put it in a file„   FOR x& = 1 TO TotalChar&„     PUT$ #1, Area$(x&)'...........Save 1 char of area„     PUT$ #1, TxClr$(x&)'..........Save it's colors„   NEXT x&              '..........Do it again„ CLOSE #1„END SUB„„„'---------------------------------------------------------------------„' LoadFmFile will Load a binary file into ARRAYs       |„' that can be used BY TextPutz to put on the screen.   |„' The file has to have alternating string charecters   |„' that represents color attributes like those that DOS |„' PB POKE$ uses.                                       |„'-------------------------------------------------------„„ SUB LoadFmFile (Area$(), TxClr$(), TotalChar&, FileNames$)„  OPEN FileNames$ FOR BINARY AS #1„    FOR x& = 1 TO TotalChar&„      GET$ #1, 1, Area$(x&)'...........get 1 char„      GET$ #1, 1, TxClr$(x&)'..........get 1 color attribute„    NEXT x&'...........................Go Do it again„  CLOSE #1„ END SUB„„'----------------------------------------------------------„„ SUB MakeBox()„  PCOPY 1, 2 : PAGE 2, 1„  COLOR 1, 11„  FOR r& = 1 TO 25                    'fill screen with chars .„    FOR c& = 1 TO 80„        PRINT CHR$(176);„    NEXT c&„  NEXT r&„„   COLOR 14, 1 : LOCATE 1, 1                               'make a box„   PRINT CHR$(201, 205, 205, 205, 205, 205, 205, 205, 205, _„              205, 205, 205, 205, 205, 205, 187)„   PRINT CHR$(186) + "  This is an  " + CHR$(186)„   PRINT CHR$(186) + "  Example of  " + CHR$(186)„   COLOR 11, 4„   PRINT CHR$(186) + " Screen parts " + CHR$(186)„   PRINT CHR$(186) + " Copy & Save  " + CHR$(186)„   PRINT CHR$(200, 205, 205, 205, 205, 205, 205, 205, 205, _„              205, 205, 205, 205, 205, 205, 188)„   PCOPY 2, 1 : PAGE 1, 1„ END SUB„Don Schullian                  KEEP MASKED CHARACTERS         d83@DASoftVSS.com              06-26-00 (07:45)       PBCC                   52   1748     KEEP.BAS    $IF 0„    ----------------------------                      PowerBASIC/cc v2.0„ ---|          DASoft          |------------------------------------------„    ----------------------------    Copyright 2000      DATE: 2000-02-02„    | FILE NAME   Keep    .bas |          by„    | DIRECTORY   NBcc         |  Don Schullian, Jr.„    ----------------------------„   A license is hereby granted to the holder to use this source code in„   any program, commercial or otherwise,  without receiving the express„   permission of the copyright holder and without paying any royalties.„ -------------------------------------------------------------------------„  PURPOSE: Retain only the characters from Text$ that are found in Mask$„   PARAMS: Text$ the working text„           Mask$ the list of characters to be kept„  RETURNS: string containing only the characters found in Mask$„     NOTE:„ -------------------------------------------------------------------------„$ENDIF„„„„FUNCTION fKeep ( BYVAL Text AS STRING, _„                 BYVAL Mask AS STRING  ) EXPORT AS STRING„„  DIM Char  AS LOCAL BYTE„  DIM M_ptr AS LOCAL BYTE PTR„  DIM Mlen  AS LOCAL LONG„  DIM Moff  AS LOCAL LONG„  DIM Noff  AS LOCAL LONG„  DIM T_ptr AS LOCAL BYTE PTR„  DIM Tlen  AS LOCAL LONG„  DIM Toff  AS LOCAL LONG„„  Mlen  = LEN(Mask) - 1 : IF Mlen < 0 THEN EXIT FUNCTION„  Tlen  = LEN(Text) - 1 : IF Tlen < 0 THEN EXIT FUNCTION„  M_ptr = STRPTR(Mask)„  T_ptr = STRPTR(Text)„„  FOR Toff = 0 TO Tlen„    Char = @T_ptr[Toff]„    FOR Moff = Mlen TO 0 STEP -1„      IF Char = @M_ptr[Moff] THEN„        @T_ptr[Noff] = Char„        INCR Noff„        EXIT FOR„      END IF„    NEXT„  NEXT„„  FUNCTION = LEFT$(Text,Noff)„„END FUNCTION„Jerry Fielden                  BSAVE AND BLOAD FOR PBCC       fielden@pldi.com               07-01-00 (20:47)       PBCC                   136  5240     BSAVE.BAS   Coded by Jerry Fielden„Public Domain„„„I made a stab at writting some BSAVE and BLOAD type routines„for PBCC. Run the program to see how long it takes for different„screen modes..„„Most Console Screen NON Standard modes I've tried worked properly„except 50x79 and only sometimes. I haven't tried them all yet.„All Standard modes seems to work well.„„You are welcome to use the routines at your own risk.„„„ '-------------------------------------------------------------------„ ' BSAVEs Copies the current screen to a file. It can be any screen„ ' mode size, 50x80, 70x80, 20x20, etc. The number of Screen rows is„ ' passed through the lRows Variable and the number of columns is„ ' passed through the lColumns Variable. The Global Variables and„ ' Global Arrays are used by both BLOADs and BSAVEs, they have to be„ ' included in your code.„ '„ ' BLOADs will copy the screen from the file back to the Screen.„ ' As with BSAVEs, you'll need to pass the Console Screen Size through„ ' the lRows and lColumns variables.„„„ DECLARE SUB BSAVEs (FileNames$)„ DECLARE SUB BLOADs (FileNames$)„ DECLARE SUB MakeBox ()„ FUNCTION PBMAIN„     DIM lRows AS GLOBAL LONG, lColumns AS GLOBAL LONG„     LOCATE 10, 1„     LINE INPUT "Enter the Screen Mode, 25x80, 26x75, etc. " Mode$„     lRows = VAL(LEFT$(Mode$, 2))     ' Get number of rows„     lColumns = VAL(RIGHT$(Mode$, 2)) ' Get number of columns„     Filenames$ = "Screens.bny"„„     CONSOLE SCREEN lRows, lColumns   'Setting the Screen size„„     DIM Colors(0 TO lRows*lColumns-1) AS GLOBAL LONG  'Arrays being„     DIM Area(0 TO lRows*lColumns-1) AS GLOBAL LONG    'pointed at„     MakeBox                                           ' Fill up the SCREEN„„     starttime$ = FORMAT$(TIMER, "#.###")              'Time the routines„     BSAVEs(FileNames$)                                ' Save screen to file„     RESET Colors() : RESET Area()                     ' Clear the Arrays„     CLS                                               ' Clear the screen„     BLOADs (FileNames$)                               ' Put the screen back„     endtime$ = FORMAT$(TIMER, "#.###")                'How long did it take„     LOCATE 1, 1 : COLOR 0, 11„     PRINT "It took "FORMAT$((VAL(endtime$)-VAL(starttime$)), "#.###")" Seconds"„„     SLEEP 7000„     KILL FileNames$„„ END FUNCTION„„'----------------------------------------------------------------------„' BSAVE Replacement for PBCC, it should do Most Console screen modes,  |„'----------------------------------------------------------------------„„SUB BSAVEs (FileNames$)„  DIM ColorAddr AS LONG PTR, AreaAddr AS LONG PTR„  DIM nbr AS LONG, row AS LONG, col AS LONG„  ColorAddr = VARPTR(Colors(0))„  AreaAddr = VARPTR(Area(0))„  FOR row = 1 TO lRows„     FOR col = 1 TO lColumns„        @ColorAddr[nbr] = SCREENATTR(row, col)    'Put color into array„        @AreaAddr[nbr] = SCREEN(row, col)         'Put Character into Array„        INCR nbr„     NEXT col„  NEXT row„  OPEN FileNames$ FOR BINARY AS #1   '..........Put it in a file„    FOR x& = 0 TO lColumns*lRows-1„      PUT$ #1, CHR$(@AreaAddr[x&])   '..........Save a Character„      PUT$ #1, CHR$(@ColorAddr[x&])  '..........Save it's colors„    NEXT x&                          '..........Go do it again„   CLOSE #1„END SUB„„'---------------------------------------------------------------„' BLOAD Replacement for PBCC, it should do most screen modes ?  |„'---------------------------------------------------------------„„ SUB BLOADs (FileNames$)„   DIM ColorAddr AS LONG PTR, AreaAddr AS LONG PTR„   DIM nbr AS LONG, sColour AS STRING, sChar AS STRING„   DIM row AS LONG, col AS LONG„   ColorAddr = VARPTR(Colors(0))     ' Pointers for Arrays DIMed in Main„   AreaAddr = VARPTR(Area(0))„   OPEN FileNames$ FOR BINARY AS #1„      FOR nbr = 0 TO lColumns*lRows-1   '„       GET$ #1, 1, sChar : @AreaAddr [nbr] = ASC(sChar)„       GET$ #1, 1, sColour : @ColorAddr[nbr] = ASC(sColour)„      NEXT nbr„   CLOSE #1„   nbr=0„   PCOPY 1,2 : PAGE 2, 1„   FOR row = 1 TO lRows„      FOR col = 1 TO lColumns„         LOCATE row, col„         ForGnd& = @ColorAddr[nbr] MOD 16&„         BackGnd& = @ColorAddr[nbr] \ 16&„         COLOR ForGnd&, BackGnd&„         PRINT CHR$(@AreaAddr[nbr]);„         INCR nbr„      NEXT col„    NEXT row„    PCOPY 2, 1 : PAGE 1, 1„ END SUB„„„„„ SUB MakeBox()„ PCOPY 1, 2 : PAGE 2, 1„   COLOR 1, 11„   FOR x& = 1 TO lColumns*lRows„     PRINT CHR$(176);                              'Fill up screen„   NEXT x&„  SLEEP 500„   COLOR 14, 1 : LOCATE 8, 30                      'make a box„   PRINT CHR$(201, 205, 205, 205, 205, 205, 205, 205, 205, _„              205, 205, 205, 205, 205, 205, 205, 187)„   LOCATE 9, 30 :PRINT CHR$(186) + "  This is one  " + CHR$(186)„   LOCATE 10, 30 :PRINT CHR$(186) + "  Example of   " + CHR$(186)„   COLOR 11, 4„   LOCATE 11, 30 :PRINT CHR$(186) + " Bsaves and    " + CHR$(186)„   LOCATE 12, 30 :PRINT CHR$(186) + " Bloads        " + CHR$(186)„   LOCATE 13, 30 :PRINT CHR$(200, 205, 205, 205, 205, 205, 205, 205, 205, _„              205, 205, 205, 205, 205, 205, 205, 188)„    PCOPY 2, 1 : PAGE 1, 1„ END SUB„Don Schullian                  CONVERT NUMBERS INTO WORDS     d83@DASoftVSS.com              10-14-00 (07:43)       PBCC                   83   4222     V2WRDCC.BAS '    ----------------------------                         PowerBASICcc v2„' ---|          DASoft          |------------------------------------------„'    ----------------------------    Public Domain       DATE: 2000-10-14„'    | FILE NAME   Val2Wrds.bas |       code by„'    | DIRECTORY                |  Don Schullian, Jr.„'    ----------------------------„'  PURPOSE: convert numbers into words for check printing, etc.„'   PARAMS: Number# incoming - any valid number„'  RETURNS: the number in text„'           eg: fValue2Words$ ( 100.10 ) returns„'              "ONE HUNDRED DOLLARS AND 10 CENTS"„'   NOTE: the function is not set-up to handle negative numbers as they„'          would not appear on a check„' -------------------------------------------------------------------------„„DECLARE FUNCTION fValue2Words (BYVAL Number AS DOUBLE) AS STRING„„FUNCTION fValue2Words ( BYVAL Number AS DOUBLE ) EXPORT AS STRING„„  DIM Cma  AS LOCAL STRING„  DIM I    AS LOCAL LONG„  DIM Last AS LOCAL LONG„  DIM Nbr  AS LOCAL STRING„  DIM Pce  AS LOCAL LONG„  DIM Temp AS LOCAL STRING„  DIM V    AS LOCAL LONG„„  Nbr  = FORMAT$( Number, "###############,.##" )         ' a number to work with„  I    = LEN(Nbr) - 2                                     ' decimal location„  IF ASC(Nbr,I) = 44 THEN Cma = "." ELSE Cma = ","        ' if decimal is a "." then.....„  Last = PARSECOUNT( Nbr, Cma )                           ' # of pieces„  '-------------------------------------------------------'„  FOR Pce = 1 TO Last                                     ' from left to right„    V = VAL( PARSE$(Nbr, Cma, Pce) )                      ' get the 000„    IF V = 0 THEN ITERATE                                 ' nada!„    IF V > 99 THEN                                        ' hundreds position„      I = ( V  \  100 )                                   '   # of hundreds„      V = ( V MOD 100 )                                   '   > 100„      Temp = Temp & READ$(I) & READ$(33)                  '   add words„    END IF                                                '„    IF ( V > 10 ) AND ( V < 20 ) THEN                     ' teens„        Temp = Temp & READ$(V)                            '   add words„      ELSEIF V > 0 THEN                                   ' anything left?„        IF V > 9 THEN                                     ' tens„          I = ( V  \  10 )                                '   # of tens - 1„          V = ( V MOD 10 )                                '   strip tens„          Temp = Temp & READ$(I+19)                       '   add words„        END IF                                            '„        IF V > 0 THEN Temp = Temp & READ$(V)              ' ones„    END IF                                                '„    IF Pce = Last THEN EXIT FOR                           ' all done„    Temp = Temp & READ$(Last - Pce + 28)                  ' thousands/mills/etc„  NEXT                                                    '„  '-------------------------------------------------------'„  IF LEN(Temp) = 0 THEN Temp = READ$(36)                  ' no ones!„  Temp = Temp & READ$(34) & RIGHT$(Nbr,2) & READ$(35)     ' add decimals„  '-------------------------------------------------------'-----------------------„  FUNCTION = Temp                                         ' RETURN STRING„                                                          '-----------------------„  DATA "ONE ", "TWO ", "THREE ", "FOUR ", "FIVE ", "SIX " '„  DATA "SEVEN ", "EIGHT ", "NINE ", "", "ELEVEN "         '„  DATA "TWELVE ", "THIRTEEN ", "FOURTEEN ", "FIFTEEN "    '„  DATA "SIXTEEN ", "SEVENTEEN ", "EIGHTEEN ", "NINETEEN " '„  DATA "TEN ", "TWENTY ", "THIRTY ", "FORTY ", "FIFTY "   '„  DATA "SIXTY ", "SEVENTY ", "EIGHTY ", "NINETY "         '„  DATA "THOUSAND ", "MILLION ", "BILLION ", "TRILLION "   '„  DATA "HUNDRED ", "DOLLARS AND ", " CENTS", "00 "        '„„END FUNCTION„'„'---------------------------------------------------------------------------------„'„FUNCTION PBmain ()„„  PRINT fValue2Words(32421009.34)„  PRINT„  PRINT fValue2Words(900132924462342.00)„  PRINT„  PRINT fValue2Words(123.10)„„  WAITKEY$„„END FUNCTION„