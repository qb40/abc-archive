Frans Hersbach                 VB-DOS CALENDAR                FidoNet QUIK_BAS Echo          10-27-95 (07:20)       VBDOS                  324  8467     VBCALNDR.BAS'FH_CLNDR.BAS  * VB-DOS required !!! *„'============  -----------------------„„ TYPE VideoType„   Mode    AS INTEGER „   Rows    AS INTEGER„   Cols    AS INTEGER„   Page    AS INTEGER„   Offs    AS INTEGER„   Segment AS INTEGER„   CRT     AS INTEGER„   Colour  AS INTEGER„   Scherm  AS INTEGER„   BlnkBit AS INTEGER„   FntBlk  AS INTEGER„ END TYPE„„ TYPE RegType„   AX    AS INTEGER„   BX    AS INTEGER„   CX    AS INTEGER„   DX    AS INTEGER„   BP    AS INTEGER„   SI    AS INTEGER„   DI    AS INTEGER„   FLAGS AS INTEGER„ END TYPE„„'-------------------------------------------------------„„ DECLARE FUNCTION Schrikkel% (Jaar%)„„ DECLARE SUB StartKalender ()„ DECLARE SUB EindeKalender ()„ DECLARE SUB DisplayScherm ()„ DECLARE SUB DisplayDagen ()„„ DECLARE SUB Interrupt (IntNum AS INTEGER, InReg AS RegType, OutReg AS RegType)„„ DECLARE SUB Display (Col%, Row%, Tekst$, Fore%, Back%)„ DECLARE SUB DisplayVertical (Col%, Row%, Tekst$, TxtLenStap%, Richting%, Fore%, Back%)„ DECLARE SUB Video80x30 ()„ DECLARE SUB VideoCenter (Text$, Row%, Fore%, Back%)„ DECLARE SUB VideoCLS (Kleur%)„ DECLARE SUB VideoSettings ()„ DECLARE SUB VideoScrnFill (StartRow%, StartCol%, BoxHg%, BoxBrd%, ASCIIchar%, Kleur%, Page%)„„'-------------------------------------------------------„„ CONST True = -1, False = 0„ CONST DagNaam = "SuMoTuWeThFrSa"„ CONST MndDagen = "31 28 31 30 31 30 31 31 30 31 30 31"„„ CONST Zwart = 0, Blauw = 1, Groen = 2, Cyaan = 3, Rood = 4, Paars = 5„ CONST Bruin = 6, Grijs = 7, DonkerGrijs = 8, LichtBlauw = 9„ CONST LichtGroen = 10, LichtCyaan = 11, LichtRood = 12, LichtPaars = 13„ CONST Geel = 14, Wit = 15„„ CONST ForeKleur = Geel„ CONST BackKleur = Rood„ CONST DagKleur = LichtCyaan„ CONST MndKleur = LichtGroen„ CONST WknKleur = Geel„ CONST CfrKleur = Wit„„'-------------------------------------------------------„„ DIM SHARED Video AS VideoType„ DIM SHARED SelectJaar AS INTEGER„„'-------------------------------------------------------„„ DEFINT A-Z„„ StartKalender„„SUB Display (Col%, Row%, Tekst$, Fore%, Back%)„„ SELECT CASE Video.Scherm„„   CASE 15„„         Location = ((Row - 1) * (Video.Cols * 2)) + ((Col - 1) * 2)„           Colour = (Fore AND 15) + (Back AND 7) * 16 + (Fore AND 16) * 8„         DEF SEG = &HB800 ' Assume VGAcolor„         FOR Char = 1 TO LEN(Tekst$)„           POKE Location + 0, ASC(MID$(Tekst$, Char, 1))„           POKE Location + 1, Colour„           Location = Location + 2„         NEXT Char„         DEF SEG„„ END SELECT„„END SUB„„SUB DisplayDagen ()„„   WeekNr = 1„ HoriOfst = 4„„   CrntDag = DAY(NOW)„ CrntMaand = MONTH(NOW)„  CrntJaar = YEAR(NOW)„„ FOR Maand = 1 TO 12„„  DagAantal = VAL(MID$(MndDagen, (Maand - 1) * 3 + 1, 2))„  IF Maand = 2 AND Schrikkel%(SelectJaar) = True THEN„    DagAantal = DagAantal + 1„  END IF„„  DagTeller = 1„  TellerOfst = WEEKDAY(DATEVALUE("1-" + FORMAT$(Maand) + "-" + FORMAT$(SelectJaar)))„  Teller = TellerOfst„„  SELECT CASE Maand„    CASE 1, 5, 9: WeekTeller = 1„  END SELECT„„  FOR Dag = 1 TO DagAantal„„  SELECT CASE Maand„       CASE 1 TO 4: Ofst = HoriOfst + ((WeekTeller - 1) * 3) + ((Maand - 1) * 6 + 1)„                    VertOfst = 3„       CASE 5 TO 8: Ofst = HoriOfst + ((WeekTeller - 1) * 3) + ((Maand - 1) * 6 + 1) - 104„                    VertOfst = 14„      CASE 9 TO 12: Ofst = HoriOfst + ((WeekTeller - 1) * 3) + ((Maand - 1) * 6 + 1) - 208„                    VertOfst = 25„    END SELECT„    „    Display Ofst, VertOfst, RIGHT$(" " + STR$(WeekNr), 2), WknKleur, Zwart„    Display Ofst, VertOfst + Teller, RIGHT$(" " + STR$(DagTeller), 2), CfrKleur, Zwart„„    IF CrntDag = Dag AND CrntMaand = Maand AND CrntJaar = SelectJaar THEN„      Display Ofst, VertOfst + Teller, RIGHT$(" " + STR$(DagTeller), 2), CfrKleur + 16, Zwart„    END IF„„    Display Ofst + 2, VertOfst + Teller, "≥", Grijs, Zwart„„    DagTeller = DagTeller + 1„    Teller = Teller + 1„    IF Teller > 7 THEN„     Teller = 1„     WeekNr = WeekNr + 1„     WeekTeller = WeekTeller + 1„    END IF„          „  NEXT Dag„„ NEXT Maand„   „END SUB„„SUB DisplayScherm ()„„ CLS„„ Video.Scherm = 15„ Video80x30„ VideoSettings„ „ Display 1, 1, SPACE$(Video.Cols), ForeKleur, BackKleur„ VideoCenter "Kalenderjaar: " + FORMAT$(SelectJaar), 1, ForeKleur, BackKleur„„  Display 10, 2, "Jan                Feb                 Mrt                Apr", MndKleur, Zwart„ Display 10, 12, "Mei                Jun                 Jul                Aug", MndKleur, Zwart„ Display 10, 22, "Sep                Okt                 Nov                Dec", MndKleur, Zwart„„ DisplayVertical 1, 4, DagNaam, 2, 1, DagKleur, Zwart„ DisplayVertical 1, 14, DagNaam, 2, 1, DagKleur, Zwart„ DisplayVertical 1, 24, DagNaam, 2, 1, DagKleur, Zwart„„ Display 1, 11, STRING$(80, 196), DonkerGrijs, Zwart„ Display 1, 21, STRING$(80, 196), DonkerGrijs, Zwart„„END SUB„„SUB DisplayVertical (Col%, Row%, Tekst$, TxtLenStap%, Richting%, Fore%, Back%)„„ Aantal = LEN(Tekst$) \ TxtLenStap„„ SELECT CASE Richting„   CASE IS < 0: FOR Stukje = 0 TO Aantal - 1„                  Display Col, Row + Stukje, MID$(Tekst$, (Aantal - Stukje - 1) * TxtLenStap + 1, TxtLenStap), Fore, Back„                NEXT Stukje„„   CASE IS > 0: FOR Stukje = 0 TO Aantal - 1„                  Display Col, Row + Stukje, MID$(Tekst$, Stukje * TxtLenStap + 1, TxtLenStap), Fore, Back„                NEXT Stukje„ END SELECT„„ „END SUB„„SUB EindeKalender ()„„ VideoCLS 0„ SCREEN 0, 0, 0, 0„ COLOR 7, 0„ WHILE INKEY$ <> "": WEND„ END„„END SUB„„FUNCTION Schrikkel% (Jaar%)„„ IF Jaar \ 4 = Jaar / 4 THEN„   Schrikkel = True„ ELSE„   Schrikkel = False„ END IF„„END FUNCTION„„SUB StartKalender ()„ „ IF INSTR(COMMAND$, "/?") THEN„   PRINT : PRINT "KALENDER.EXE jaartal  (tussen 1753 en 2078)": END„ END IF„ „ IF COMMAND$ <> "" THEN„   CmdJaar = VAL(COMMAND$)„   IF CmdJaar >= 1753 AND CmdJaar <= 2078 THEN„     SelectJaar = CmdJaar„   ELSE„     SelectJaar = VAL(RIGHT$(DATE$, 4))„   END IF„ ELSE„   SelectJaar = VAL(RIGHT$(DATE$, 4))„ END IF„„ DisplayScherm„ DisplayDagen„ SLEEP„ EindeKalender„„END SUB„„SUB Video80x30 ()„„ DIM CrtcData AS INTEGER, CrtcIndex AS INTEGER, CRTCreg(1 TO 16) AS INTEGER„ DIM InReg AS RegType, OutReg AS RegType, i AS INTEGER„„ CRTCreg(1) = &H11:   CRTCreg(2) = &HC:   CRTCreg(3) = &H6:   CRTCreg(4) = &HD„ CRTCreg(5) = &H7:    CRTCreg(6) = &H3E:  CRTCreg(7) = &H10:  CRTCreg(8) = &HEA„ CRTCreg(9) = &H11:  CRTCreg(10) = &H8C: CRTCreg(11) = &H12: CRTCreg(12) = &HDF„ CRTCreg(13) = &H15: CRTCreg(14) = &HE7: CRTCreg(15) = &H16: CRTCreg(16) = &H6„ „ DEF SEG = &H40„ POKE &H4C, 0: POKE &H4D, &H20: POKE &H84, 29„ CrtcIndex = PEEK(&H63) + 256 * PEEK(&H64)„ CrtcData = CrtcIndex + 1„ Cli = &HCBFA: DEF SEG : CALL Absolute(VARPTR(Cli))„ FOR i = 1 TO 16 STEP 2„   OUT CrtcIndex, CRTCreg(i)„   OUT CrtcData, CRTCreg(i + 1)„ NEXT i„ OUT &H3C2, ((INP(&H3CC) AND &H33) OR &HC4)„ Sti = &HCBFB: DEF SEG : CALL Absolute(VARPTR(Sti))„ InReg.AX = &H1200„ InReg.BX = &H20„ Interrupt &H10, InReg, OutReg„„END SUB„„SUB VideoCenter (Text$, Row%, Fore%, Back%)„„ Ofst = (Video.Cols \ 2) - LEN(Text$) \ 2„ Display Ofst, Row, Text$, Fore, Back„„END SUB„„SUB VideoCLS (Kleur%)„„ SELECT CASE Video.Scherm„   CASE 0, 16, 17: COLOR Grijs, Kleur: CLS„        CASE ELSE: VideoScrnFill 1, 1, Video.Cols, Video.Rows, 32, Zwart, 0„ END SELECT„„END SUB„„SUB VideoScrnFill (StartRow, StartCol, BoxHg, BoxBrd, ASCIIchar, Kleur, Page)„„ DIM InReg AS RegType, OutReg AS RegType„„ LOCATE 1, 1„ InReg.AX = &H9 * 256 + ASCIIchar„ InReg.BX = Page * 256 + Kleur„ InReg.CX = BoxHg * BoxBrd„ Interrupt &H10, InReg, OutReg„ „END SUB„„SUB VideoSettings ()„„ DIM r AS RegType„„ r.AX = &H1A00„ Interrupt &H10, r, r„ VideoSrt = VAL("&H" + RIGHT$(HEX$(r.BX), 2))„ IF VideoSrt = 0 OR VideoSrt = 255 THEN SOUND 1000, 1„ Video.CRT = VideoSrt„„ r.AX = &HF00„ r.BX = 0„ r.DX = 0„ Interrupt &H10, r, r„ Video.Cols = (CLNG(r.AX) - (r.AX < 0) * 65536) \ 256„„ r.AX = &H1130„ r.BX = 0„ r.DX = 0„ Interrupt &H10, r, r„ Video.Rows = r.DX + 1„„ DEF SEG = 0: VidMode = PEEK(&H449): DEF SEG„ SELECT CASE VidMode„   CASE 0, 2, 7: Video.Colour = 0   'Black & White 40/80 column & monochrome„      CASE ELSE: Video.Colour = -1  'Everything else... assume color„ END SELECT„„END SUB„„G. Balla                       BASE 64 ENCODING               artvil@ix.netcom.com           05-12-96 (14:15)       VBDOS                  289  10230    BASE64.BAS  '-------------------------------------------------------------------------„'This code has been placed in public domain.„'G Balla „'--------------------------------------------------------------------------„Option Explicit„„Dim Shared ic_ChopMask  As Integer  ' Constant 8-bit mask (Faster than using string constants)„Dim Shared ic_BitShift  As Integer  ' Constant shift mask (Faster than using string constants)„Dim Shared ic_StartMask As Integer  ' Initial mask value  (Faster than using string constants)„„Dim Shared i_RollOver   As Integer  ' Decoded Roll over value„Dim Shared i_HighMask   As Integer  ' Mask high bits of each char„Dim Shared i_Shift      As Integer  ' Multiplier shift value„Dim Shared i_LowShift   As Integer  ' Mask low bits of each char„„Dim Shared sz_Alphabet  As String   ' Decode/Encode Lookup Table„Dim Shared sz_Temp      As String   ' Working string„„'----------------------------------------------------------------------------------------------„' Name:         DECODE_64$„' Type:         String function„' Description:  decodes a string from BASE64 to binary format„'„' Arguements:   Source string to decode (sz_Encoded)„'               Last string in file to decode flag (i_EndOfText)„' Returns:      Un-Encoded binary string.„'„' Errors:       Generates an Error via ERROR statement.„' Error code:   253 = No string to decode„'                   -----------------------------------------------„' NOTES:    Must call INIT_DECODE_64 before sending 1st string of an encoded file.„'„'           A DOEVENTS occurs near the end of the FOR/NEXT loop„'                   -----------------------------------------------„' Global variables: sz_Alphabet         ' Decode/Encode lookup table„'                   sz_Temp             ' Working string„'„'                   i_RollOver          ' Decode/Encode rollover value„'                   i_HighMask          ' High bit mask„'                   i_Shift             ' Multiplier value„'„'„' Local variables:  i_Char              ' Ascii Char value from Encoded string„'                   i_Ptr               ' Lookup table pointer„'                   i_Counter           ' FOR/NEXT counter„'„'----------------------------------------------------------------------------------------------„Function DECODE_64$ (sz_Encoded As String, i_EndOfText As Integer)„„' Create variables„    Dim i_Ptr       As Integer„    Dim i_Char      As Integer„    Dim i_Counter As Integer„„' Check if empty decoded string.„' If Empty, return NUL and Generate error 254„    If Len(sz_Encoded) = 0 Then„        DECODE_64$ = ""„        Error 253„        Exit Function„    End If„„' Initialize working string„    sz_Temp = ""„„' Begin Decoding„    For i_Counter = 1 To Len(sz_Encoded)„„' Get next alphabet„        i_Char = Asc(Mid$(sz_Encoded, i_Counter, 1))„„' Get Decoded value„        i_Ptr = InStr(sz_Alphabet, Chr$(i_Char)) - 1„„' Check if character is valid„        If i_Ptr >= 0 Then„„' Char is valid, process it„            If i_Shift = ic_BitShift Then„„' 1st char in block of 4, keep high part of character„                i_RollOver = (i_Ptr * i_Shift) And ic_ChopMask„„' Reset masks for next character„                i_HighMask = &H30„                i_LowShift = ic_StartMask„                i_Shift = ic_StartMask„„            Else„„' Start saving decoded character„                sz_Temp = sz_Temp + Chr$(i_RollOver Or ((i_Ptr And i_HighMask) / i_LowShift))„„' Calculate next mask and shift values„                i_RollOver = (i_Ptr * i_Shift) And ic_ChopMask„                i_Shift = i_Shift * ic_BitShift„                i_HighMask = (i_HighMask \ ic_BitShift) Or &H30„                i_LowShift = i_LowShift / ic_BitShift„„                If i_Shift > 256 Then„                    i_Shift = ic_BitShift„                    i_LowShift = 0„                    DoEvents„                End If„            End If„„        End If„    Next„„' Concat last character if required„    If (i_Shift > ic_BitShift And i_Shift < 256) Then„„' Character remaining in    i_RollOver„        If i_EndOfText Then„„' Last string to decode in file„            sz_Temp = sz_Temp + Chr$(i_RollOver)„        End If„    End If„„' Exit wth decoded string„    DECODE_64$ = sz_Temp„End Function„„'----------------------------------------------------------------------------------------------„' Name:         ENCODE_64$„' Type:         String function„' Description:  Encodes a string into a BASE64 coded string„'„' Arguement:    Source string to encode (sz_UnEncoded)„' Returns:      Encoded BASE64 string.„'„' Errors:       Generates an Error via ERROR statement.„' Error code:   254 = No string to encode„'                       returns NUL string„'                   -----------------------------------------------„' NOTES:    If sending more than 1 string per file, ensure that each source string„'               is a multiple of 3 bytes or premature padded characters are added.„'               The last string of a file is exempt from this rule.„'„'           Each string can be 16383 bytes in length to satisfy VB's string capacity limitation.„'„'           Encoded blocks should be written as sub block lengths of about 76 characters and„'               added CR/LF added to each sub-block.„'               This is what WINCODE does and should satisfy most UUE browsers.„'„'           A DOEVENT occurs near the end of the FOR/NEXT loop„'„'                   -----------------------------------------------„' Global variables: sz_Alphabet     ' Encoding/Decoding lookup table„'                   sz_Temp         ' Working string„'                   ic_ChopMask     ' Constant 8-bit mask for speed„'                   ic_BitShift     ' Constant shift mask for speed„'„'                   i_RollOver      ' Decode/Encode rollover value„'                   i_HighMask      ' High bit mask„'                   i_Shift         ' Multiplier value„'„' Local variables:  ic_LowFill      ' Constant Low 2-bit fill value for speed„'„'                   i_LowMask       ' Low bits mask„'                   i_Char          ' Ascii char value from Un coded string„'                   i_Ptr           ' Lookup table pointer„'„'                   i_Counter       ' For/Next loop counter„'----------------------------------------------------------------------------------------------„Function ENCODE_64$ (sz_UnEncoded As String)„„' Create variables„    Dim ic_LowFill  As Integer„„    Dim i_Char      As Integer„    Dim i_LowMask   As Integer„    Dim i_Ptr       As Integer„„    Dim i_Counter As Integer„„„' Check if empty decoded string.„' If Empty, return NUL and Generate error 254„    If Len(sz_UnEncoded) = 0 Then„        ENCODE_64$ = ""„        Error 254„        Exit Function„    End If„„' Initialize lookup dictionary and constants„    sz_Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"„„    ic_BitShift = 4„    ic_ChopMask = 255„    ic_LowFill = 3„„„' Initialize Masks„    sz_Temp = ""„„    i_HighMask = &HFC„    i_LowMask = &H3„    i_Shift = &H10„    i_RollOver = 0„„„' Begin Encoding process„    For i_Counter = 1 To Len(sz_UnEncoded)„„' Fetch ascii character in decoded string„        i_Char = Asc(Mid$(sz_UnEncoded, i_Counter, 1))„„' Calculate Alphabet lookup pointer„        i_Ptr = ((i_Char And i_HighMask) \ (i_LowMask + 1)) Or i_RollOver„„' Roll bit patterns„        i_RollOver = (i_Char And i_LowMask) * i_Shift„„' Concatenate encoded character to working encoded string„        sz_Temp = sz_Temp + Mid$(sz_Alphabet, i_Ptr + 1, 1)„„' Adjust masks„        i_HighMask = (i_HighMask * ic_BitShift) And ic_ChopMask„        i_LowMask = i_LowMask * ic_BitShift + ic_LowFill„        i_Shift = i_Shift \ ic_BitShift„„' If last character in block, concat last RollOver and„'   reset masks„        If i_HighMask = 0 Then„            sz_Temp = sz_Temp + Mid$(sz_Alphabet, i_RollOver + 1, 1)„            i_RollOver = 0„            i_HighMask = &HFC„            i_LowMask = &H3„            i_Shift = &H10„            DoEvents„        End If„„    Next i_Counter„„' If RollOver remains, concat it to the working string„    If i_Shift < &H10 Then„        sz_Temp = sz_Temp + Mid$(sz_Alphabet, i_RollOver + 1, 1)„    End If„„' Pad encoded string with required '=' pad characters„    i_Ptr = (Len(sz_Temp) Mod 4)„    If i_Ptr Then sz_Temp = sz_Temp + String$(4 - i_Ptr, "=")„„' Return encoded string„    ENCODE_64$ = sz_Temp„End Function„„'----------------------------------------------------------------------------------------------„' Name:         INIT_DECODE_64„' Type:         Sub procedure„' Description:  Initializes local shared variables for DECODE_64$„'                   Required because many encoded files cannot be decoded in a single string„'„' Used:         Before decoding a BASE64 file.  (DECODE_64$)„' Arguements:   None„' Returns:      Nothing„'„' Errors:       None„'„' Global Variables used:„'               sz_Alphabet             Encode/Decode Table lookup„'„'               ic_ChopMask             Constant value in variable to speed process„'               ic_BitShift             Constant value in variable to speed process„'               ic_StartMask            Constant value in variable to speed process„'„'               i_Shift                 Multiplier shift value„'               i_LowShift              Mask Low bits of each char„'               i_RollOver              Decoded Roll over value from prev char in string„'               i_HighMask              Mask high bits of each char„'----------------------------------------------------------------------------------------------„Sub INIT_DECODE_64 ()„„' Initialize 2nd encoding pass lookup dictionary„    sz_Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"„„' Initialize Constants„    ic_ChopMask = 255„    ic_BitShift = 4„    ic_StartMask = &H10„„' Initialize Masks„    i_Shift = ic_BitShift„    i_LowShift = 0„    i_RollOver = 0„    i_HighMask = -1„End Sub„