Harold Koenig                  Floppy Disk Image Reader       harkon@shaw.ca                 06-16-02 (  :  )       QB, PDS                234  6754     Firead.bas  '===========================================================================„' Subject: FLOPPY DIS IMAGE READER            Date: 05-29-02 (10:00:00)   „'  Author: Harold Koenig                      Code: QB            „'  Origin: harkon@shaw.ca                   Packet: DISK.ABC„'===========================================================================„„'*******************************************************„'*                                                     *„'*          Floppy Image Reader (FIREAD)               *„'*                                                     *„'* This program was created by Harold Koenig (2002)    *„'*                                                     *„'* You are welcome to use any part of this code for    *„'*  your own purposes, but if you do, please give      *„'*  credit where it's due.                             *„'*                                                     *„'* FIREAD will read a floppy disk and write the image  *„'*  to the filename you specify. The image file is     *„'*  standard as for as image files go, and is          *„'*  compatible with RAWRITE. This is actually a sort   *„'*  of RAREAD clone, without the command line          *„'*  interface                                          *„'*                                                     *„'* The companion to this file is the FIWRITE program   *„'*  which is used to restore the image file created    *„'*  by FIREAD.                                         *„'*                                                     *„'* Somewhere along the way I intend to add the command *„'*  line interface, add some command line help and     *„'*  maybe add a GUI, maybe with VBDOS, do't know yet.  *„'*  I also intend to be able to make SFX image files,  *„'*  this would just eb a function of creating the SFX  *„'*  program, most of the FIWRITE code, and putting     *„'*  it in fron of the image file.                      *„'*                                                     *„'* This program should work to create an image of      *„'*  almost any floppy disk, but it has been tested     *„'*  only with 1.44MB disks and drives.                 *„'*                                                     *„'*                                                     *„'*******************************************************„„„„DEFINT A-Z„„'define regtype for interrupt call„  TYPE RegTypeX„     ax AS INTEGER„     bx AS INTEGER„     cx AS INTEGER„     dx AS INTEGER„     BP AS INTEGER„     SI AS INTEGER„     DI AS INTEGER„     flags AS INTEGER„     DS AS INTEGER„     es AS INTEGER„  END TYPE„„„'declare interrupt sub (in library)„DECLARE SUB interruptx (intnum AS INTEGER, InReg AS RegTypeX, OutReg AS RegTypeX)„„'declare subs and functions here„DECLARE SUB dinfo (drive, maxhead, maxsector, maxtrac)„DECLARE SUB dread (drive, Head, track, sector, maxsector, buffer$, flags)„DECLARE SUB dreset (drive)„„ON ERROR GOTO ErrorHandler„„CLS„„INPUT "Enter drive A or B "; drive$„drive$ = LTRIM$(RTRIM$(UCASE$(drive$)))„IF drive$ <> "A" AND drive$ <> "B" THEN„   PRINT "not a valid drive"„   PRINT "enter only the drive letter A or B"„   END„END IF„„„drive = ASC(drive$) - ASC("A")„„dinfo drive, maxhead, maxsector, maxtrac„„„PRINT "Drive data for "; drive$; ":"„PRINT "maxhead="; maxhead„PRINT "maxsector="; maxsector„PRINT "maxtrack="; maxtrac„„„'setup memory for buffer„buffersize = maxsector * 512„buffer$ = STRING$(buffersize, 21)„„„INPUT "Filename to save image to: "; filename$„„'this begins the floppydrive read process„„OPEN filename$ FOR OUTPUT AS #1„„sector = 1„Head = 0„„FOR track = 0 TO maxtrac„„LOCATE 8, 1„PRINT "Reading Track# "; USING "##"; track;„PRINT "   Head# "; Head;„PRINT "  ";„PRINT USING "###"; ((track / maxtrac) * 100);„PRINT "% Read";„„„dread drive, Head, track, sector, maxsector, buffer$, flags„'if an error is detected in the read it is recommended to try 3 times„IF flags <> 0 THEN„   dreset drive„   dread drive, Head, track, sector, maxsector, buffer$, flags„      IF flags <> 0 THEN„         dreset drive„         dread drive, Head, track, sector, maxsector, buffer$, flags„            IF flags <> 0 THEN„               dreset drive„               errdesc$ = "Error reading drive " + drive$ + ":"„               GOTO ErrorHandler„               END„            END IF„      END IF„END IF„„„IF Head = 0 THEN„   Head = 1„   track = track - 1„   ELSE Head = 0„END IF„„„PRINT #1, buffer$;„NEXT track„CLOSE #1„PRINT ""„PRINT "Use FIWrite to restore diskette image."„PRINT ""„END„„ErrorHandler:„  errnum = ERR„  IF errornum = 53 THEN RESUME„  PRINT ""„  PRINT "Error Number "; errnum; ":"; errdesc$„  CLOSE #1„END„„SUB dinfo (drive, maxhead, maxsector, maxtrac)„„DIM inregs AS RegTypeX, outregs AS RegTypeX„„inregs.ax = &H800„inregs.dx = drive„„CALL interruptx(&H13, inregs, outregs)„„„'extract only the DH value_DL contains number of drives„maxhead = (outregs.dx AND &HF00) / &H100„„'bits 0-5 are for max sector info„maxsector = outregs.cx AND &H3F„„'bits 0-7 CH are the low order info for # of tracks„maxtraclow = (outregs.cx AND &HFF00) / &H100„'bits 6&7 CL are the high order info for # of tracks„'bits need to be shifted left 2 bits for final add to work„maxtrachigh = (outregs.cx AND &HC0) * &H4„maxtrac = maxtrachigh + maxtraclow„„„„END SUB„„SUB dread (drive, Head, track, sector, maxsector, buffer$, flags)„„DIM inregs AS RegTypeX, outregs AS RegTypeX„„bufferseg = VARSEG(buffer$)„bufferadd = SADD(buffer$)„„'track information is in both CH bits 0-7 low order„' and CL bits 6-7 high order. This is only an issue„' should the drive have a tack count higher than &HFF„' This is doubtful, however, for the sake of precision„' we'll parse the number and distyribute the components„„'this line gets only the low order 8 bits„' we shift these left 8 bits in the inregs.cx= line„tracklow = track AND &HFF„'this line gets the 2 high order bits, and shifts them„' right 2 bits, adding the sector value (1) to this„' leaves bits 0-5 untouched and moves thee 2 bits„' into position 6&7„trackhigh = (track AND &H300) / &H4„„„inregs.ax = &H200 + maxsector„inregs.bx = bufferadd„'inregs.cx = (track * &H100) + sector„inregs.cx = (tracklow * &H100) + (trackhigh + sector)„inregs.dx = (Head * &H100) + drive„inregs.es = bufferseg„CALL interruptx(&H13, inregs, outregs)„„flags = outregs.flags„„flags = flags AND &H1„„„END SUB„„SUB dreset (drive)„„DIM inregs AS RegTypeX, outregs AS RegTypeX„„inregs.ax = &H0„inregs.dx = drive„„CALL interruptx(&H13, inregs, outregs)„„END SUB„„Harold Koenig                  Floppy Disk Image Writer       harkon@shaw.ca                 06-16-02 (  :  )       QB, PDS                247  7550     Fiwrite.bas '===========================================================================„' Subject: FLOPPY DISK IMAGE WRITER           Date: 05-29-02 (10:00:00)„'  Author: Harold Koenig                      Code: QB          „'  Origin: harkon@shaw.ca                   Packet: DISK.ABC„'===========================================================================„„'*******************************************************„'*                                                     *„'*          Floppy Image Writer (FIWRITE)              *„'*                                                     *„'* This program was created by Harold Koenig (2002)    *„'*                                                     *„'* You are welcome to use any part of this code for    *„'*  your own purposes, but if you do, please give      *„'*  credit where it's due.                             *„'*                                                     *„'* FIWRITE will write the floppy disk image created by *„'*  FIREAD or RAREAD for that matter. FIWRITE was      *„'*  designed to be compatible with these programs. It  *„'*  is kind of a RAWRITE clone without the command     *„'*  line interface. Ther are some things RAWRITE does  *„'*  however that I didn't implement, as the program    *„'*  fullfilled my requirement at the time I wrote it.  *„'*                                                     *„'*  1) FIWRITE does not format the disk in the drive   *„'*     It is assumed the disk is in the drive and it   *„'*     is already formatted                            *„'*  2) FIWRITE does not verify that the disk is good   *„'*  3) FIWRITE does not verify that the diskette in    *„'*     the target drive is of the correct capacity     *„'*     or that the drive is the correct format. Again  *„'*     it is assumed that the user knows the diskette  *„'*     type that the image was created from. It would  *„'*     not be too hard to verify the capacity of the   *„'*     destination disk, and then make sure it matches *„'*     the file size, but this was not done here.      *„'*                                                     *„'* The companion to this file is the FIREAD program    *„'*  which is used to create the image file to be       *„'*  written by FIWRITE.                                *„'*                                                     *„'* Somewhere along the way I intend to add the command *„'*  line interface, add some command line help and     *„'*  maybe add a GUI, maybe with VBDOS, do't know yet.  *„'*  I also intend to be able to make SFX image files,  *„'*  this would just be a function of creating the SFX  *„'*  program, most of the FIWRITE code, and putting     *„'*  it in fron of the image file.                      *„'*                                                     *„'* This program should work to create an image of      *„'*  almost any floppy disk, but it has been tested     *„'*  only with 1.44MB disks and drives.                 *„'*                                                     *„'*                                                     *„'*******************************************************„„„DEFINT A-Z„„'define regtype for interrupt call„  TYPE RegTypeX„     ax AS INTEGER„     bx AS INTEGER„     cx AS INTEGER„     dx AS INTEGER„     BP AS INTEGER„     SI AS INTEGER„     DI AS INTEGER„     flags AS INTEGER„     DS AS INTEGER„     es AS INTEGER„  END TYPE„„„'declare interrupt sub (in library)„DECLARE SUB interruptx (intnum AS INTEGER, InReg AS RegTypeX, OutReg AS RegTypeX)„„'declare subs and functions here„DECLARE SUB dinfo (drive, maxhead, maxsector, maxtrac)„DECLARE SUB dwrite (drive, Head, track, sector, maxsector, buffer$, flag)„DECLARE SUB dreset (drive)„„ON ERROR GOTO ErrorHandler„„CLS„„INPUT "Enter drive A or B "; drive$„drive$ = LTRIM$(RTRIM$(UCASE$(drive$)))„IF drive$ <> "A" AND drive$ <> "B" THEN„   PRINT "not a valid drive"„   PRINT "enter only the drive letter A or B"„   END„END IF„„„drive = ASC(drive$) - ASC("A")„„dinfo drive, maxhead, maxsector, maxtrac„„„PRINT "Drive data for "; drive$; ":"„PRINT "maxhead="; maxhead„PRINT "maxsector="; maxsector„PRINT "maxtrac="; maxtrac„„„'setup memory for buffer„buffersize = maxsector * 512„buffer$ = STRING$(buffersize, 21)„„INPUT "Filename to write image from: "; filename$„„'this begins the floppydrive read process„„OPEN filename$ FOR BINARY AS #1„„sector = 1„Head = 0„„FOR track = 0 TO maxtrac„„LOCATE 8, 1„PRINT "Writing Track# "; USING "##"; track;„PRINT "   Head# "; Head;„PRINT "  ";„PRINT USING "###"; ((track / maxtrac) * 100);„PRINT "% Written";„„buffer$ = INPUT$((maxsector * 512), 1)„„dwrite drive, Head, track, sector, maxsector, buffer$, flags„'if an error is detected in the write it is recommended to try 3 times„IF flags <> 0 THEN„   dreset drive„   dwrite drive, Head, track, sector, maxsector, buffer$, flags„      IF flags <> 0 THEN„         dreset drive„         dwrite drive, Head, track, sector, maxsector, buffer$, flags„            IF flags <> 0 THEN„               dreset drive„               errdesc$ = "Error reading drive " + drive$ + ":"„               GOTO ErrorHandler„               END„            END IF„      END IF„END IF„„„IF Head = 0 THEN„   Head = 1„   track = track - 1„   ELSE Head = 0„END IF„„„NEXT track„CLOSE #1„PRINT ""„PRINT ""„PRINT ""„END„„ErrorHandler:„  errnum = ERR„  IF errornum = 53 THEN RESUME„  PRINT ""„  PRINT "Error Number "; errnum; ":"; errdesc$„  CLOSE #1„END„„SUB dinfo (drive, maxhead, maxsector, maxtrac)„„DIM inregs AS RegTypeX, outregs AS RegTypeX„„inregs.ax = &H800„inregs.dx = drive„„CALL interruptx(&H13, inregs, outregs)„„„'extract only the DH value_DL contains number of drives„maxhead = (outregs.dx AND &HF00) / &H100„„'bits 0-5 are for max sector info„maxsector = outregs.cx AND &H3F„„'bits 0-7 CH are the low order info for # of tracks„maxtraclow = (outregs.cx AND &HFF00) / &H100„'bits 6&7 CL are the high order info for # of tracks„'bits need to be shifted left 2 bits for final add to work„maxtrachigh = (outregs.cx AND &HC0) * &H4„maxtrac = maxtrachigh + maxtraclow„„„„END SUB„„SUB dreset (drive)„„DIM inregs AS RegTypeX, outregs AS RegTypeX„„inregs.ax = &H0„inregs.dx = drive„„CALL interruptx(&H13, inregs, outregs)„„„END SUB„„SUB dwrite (drive, Head, track, sector, maxsector, buffer$, flag)„DIM inregs AS RegTypeX, outregs AS RegTypeX„„bufferseg = VARSEG(buffer$)„bufferadd = SADD(buffer$)„„'track information is in both CH bits 0-7 low order„' and CL bits 6-7 high order. This is only an issue„' should the drive have a tack count higher than &HFF„' This is doubtful, however, for the sake of precision„' we'll parse the number and distyribute the components„„'this line gets only the low order 8 bits„' we shift these left 8 bits in the inregs.cx= line„tracklow = track AND &HFF„'this line gets the 2 high order bits, and shifts them„' right 2 bits, adding the sector value (1) to this„' leaves bits 0-5 untouched and moves thee 2 bits„' into position 6&7„trackhigh = (track AND &H300) / &H4„„„inregs.ax = &H300 + maxsector„inregs.bx = bufferadd„'inregs.cx = (track * &H100) + sector„inregs.cx = (tracklow * &H100) + (trackhigh + sector)„inregs.dx = (Head * &H100) + drive„inregs.es = bufferseg„CALL interruptx(&H13, inregs, outregs)„„flags = outregs.flags„„flags = flags AND &H1„„„„END SUB„„Antoni Gual                    Detect if a disk drive is readyagual@eic.ictnet.es            09-15-02 (  :  )       QB, Qbasic, PDS        230  7645     Moufsel.bas DECLARE FUNCTION Driveready% (d$)„DECLARE FUNCTION mouseint% (func%, c%, r%)„DECLARE FUNCTION MFilesel$ ()„'$INCLUDE: 'QB.BI'„DEFINT A-Z„A$ = MFilesel$„PRINT "File: "; A$; " selected"„END„fileselerr: errata% = ERR: RESUME NEXT„„FUNCTION Driveready% (d$)„'Check if a disk is ready.„'by Antoni Gual 9/2002 agual@eic.ictnet.es„' 53 if disk is ready„' 71 if disk exists but is not ready„' 76 if disk is not ready„' 64 if disk letter is out of range„' 0  if disk is ready but is an audio CD!„'you need to setup this error handler at the end of the main module:„'fileselerr: errata% = ERR: RESUME NEXT„'--------------------------------------------------------------------„ SHARED errata%„ 'If disk B is disabled, don't check for it!„ IF d$ = "B:" THEN„   OUT &H70, &H10: IF (INP(&H71) AND 7) = 0 THEN Driveready% = 64: EXIT FUNCTION„ END IF„ ON ERROR GOTO fileselerr„ F% = FREEFILE„ OPEN d$ + "\track01.cda" FOR INPUT AS F%„ IF errata% = 0 THEN CLOSE F%„ Driveready% = errata%„ errata% = 0„ ON ERROR GOTO 0„END FUNCTION„„FUNCTION MFilesel$„'returns file selected by user„'by Antoni Gual 9/2002 agual@eic.ictnet.es„'uses :„' my all-in-one mouse function or any mouse function returning cursor pos in text lines and cols„' Driveready function„'--------------------------------------------------------„SHARED errata„'create a string with all available drivers„aa$ = " "„FOR i = 65 TO 90„ B$ = CHR$(i) + ":"„ SELECT CASE Driveready(B$)„  CASE 53, 71, 0: aa$ = aa$ + B$ + "  "„  CASE 64, 76:„  CASE ELSE: STOP„ END SELECT„NEXT„SCREEN 0: WIDTH 80, 50: CLS„'selection loop„DO„ fil$ = ""„ 'refresh directory display„ COLOR 7, 0:„ CLS„ 'format screen„ SHELL ("dir *.bas  /z/w")„ 'get last line with directory entries„ bttm = CSRLIN - 2„ COLOR 7, 12:„ LOCATE 5, 1: PRINT SPACE$(80); : LOCATE , 1: PRINT aa$ + "--CANCEL--";„ LOCATE 1, 1: PRINT SPACE$(80); : LOCATE , 1: PRINT "Select drive, dir or file";„   „ 'get mouse running„ dummy = mouseint(0, 0, 0)„ dummy = mouseint(1, 0, 0)„ 'get the word in screen the  user has  clicked„ DO„   DO„	 click = mouseint(3, c, r)„	 IF LEN(INKEY$) THEN dummy = mouseint(2, 0, 0): EXIT FUNCTION„   LOOP UNTIL click„   'returns only words in a certain area„   IF SCREEN(r, c) <> 32 AND r < bttm AND r > 4 THEN„	 B$ = "": C1 = c„	 DO„	   A = SCREEN(r, C1): B$ = B$ + CHR$(A): C1 = C1 + 1:„	 LOOP UNTIL A = 32 OR C1 = 80„	 IF c > 1 THEN„	   C1 = c - 1„	   DO„		 A = SCREEN(r, C1): B$ = CHR$(A) + B$: C1 = C1 - 1„	   LOOP UNTIL A = 32 OR C1 = 0„	 END IF„	 B$ = LTRIM$(RTRIM$(B$))„   END IF„ LOOP UNTIL LEN(B$)„   „ 'depending on the word clicked„ SELECT CASE LCASE$(B$)„ CASE "[..]": SHELL "cd.."„ CASE "a:", "b:", "c:", "d:", "e:", "f:", "g:", "h:", "i:", "j:", "k:", "l:", "m:", "n:", "o:", "p:", "q:", "r:", "s:", "t:", "u:", "v:", "x:", "y:", "z:"„   DO„	 A% = Driveready%(B$)„	 SELECT CASE A%„	 CASE 53: SHELL B$: EXIT DO„	 CASE 71, 0: LOCATE 1, 60: INPUT "Retry/Abort"; c$:„	   IF UCASE$(c$) = "A" THEN : LOCATE 1, 60: PRINT SPACE$(20); : EXIT DO„	 CASE ELSE: STOP„	 END SELECT„   LOOP„ CASE "--cancel--":„   dummy = mouseint(2, 0, 0): EXIT DO„ CASE ELSE„   IF LEFT$(B$, 1) = "[" AND RIGHT$(B$, 1) = "]" THEN„	 SHELL "cd " + MID$(B$, 2, LEN(B$) - 2)„   ELSE„	 fil$ = B$„	 END IF„   END SELECT„   dummy = mouseint(2, 0, 0)„LOOP UNTIL LEN(fil$)„MFilesel$ = fil$„COLOR 7, 0: CLS„END FUNCTION„„FUNCTION mouseint% (func%, c%, r%) STATIC„'---------------------------------------------------------------------------'„'QBASIC MOUSE ROUTINE BY ANTONI GUAL agual@eic.ictnet.es            „'Needs only 'Include QB.BI' in the main module„'Can work with user (integer) scaling and offset or automatic scaling„'---------------------------------------------------------------------------'„'DOS Mouse Interrupt requires first call to be to Func 0 (mouse init)„' You should call also Func 0 after changing screen mode!„'Functions implemented:                       „'   Func%=-2  C%=Hoffset factor R%=Voffset factor. Sets user's offsets factors„'„'   Func%=-1  C%=Hscale factor  R%=Vscale factor.  Sets user's scale factors„'„'   Func%=0   Mouse init.  Mouseint returns 0 if mouse not present„'             If called with c%=-1 does'nt change user scale factors„'             if called with c%=0  sets scale factors matching text positions„'             if called with c%=SCREEN mode sets scale factors for graph mode„'„'   Func%=1   Show Cursor. No params taken.Returns nothing                                  '„'„'   Func%=2   Hide Cursor. no params taken.Returns nothing.                                 '„'             (You should hide cursor before writing or drawing to the screen)       '„'„'   Func%=3   Get status. Returns coords of the cursor in c% r% and„'               button status in the function name„'               Mouseint AND 1 => left button pressed„'               Mouseint AND 2 => right button pressed„'               Mouseint AND 4 => middle button pressed (if allowed by Mouse Driver)„'„'   Func%=4   Set mouse position to c% . r%. (scale units)„'„'   Func%=7   Set mouse pos limits between columns c% at left and r% at right„'„'   Func%=8   Set mouse pos limits between rows c% at top and r% at bottom„'„'   Func%=9   Change graph mode cursor shape c%= varseg(mask) r%=varptr(mask)„'             Hot spot defaults to top left corner!„'„'   Func%=10  Change text mode cursor shape c%= AND mask, r%= XOR mask„'             Examples: c = &H0   r=&Hxyzz   back color x fore y character zz„'                       c = &Hff  r=&Hxy00   back color x fore y preserve char„'-----------------------------------------------------------------------------„STATIC hsc%, vsc%, hoff%, voff%„SHARED regs AS RegTypeX„„ regs.ax% = func%„ SELECT CASE regs.ax%„ CASE 1, 2: GOSUB imouse                         'show, hide„„ CASE 3                                          'Get params„	GOSUB imouse„	c% = regs.cx% \ hsc% + hoff%„	r% = regs.dx% \ vsc% + voff%„	mouseint% = regs.bx%„ CASE 0                                          'reset„	GOSUB imouse: mouseint% = regs.ax%           'mouse reset result„	IF regs.ax% = 0 THEN EXIT FUNCTION„	SELECT CASE c%                               'set default scaling„	CASE -1 'do nothing with scale, if it's not 0„		IF vsc% = 0 THEN vsc% = 1„		IF hsc% = 0 THEN hsc% = 1„	CASE 0  'text scaling„		DEF SEG = &H40: hsc% = 640 / PEEK(&H4A): hoff% = 1: voff% = 1„		SELECT CASE PEEK(&H49)„		CASE 15, 16:  vsc% = 16: IF PEEK(&H84) = 42 THEN vsc% = 8„		CASE 17, 18: vsc% = 16: IF PEEK(&H84) = 59 THEN vsc% = 8„		CASE ELSE: vsc% = 8„		END SELECT„	CASE 2:  'graph mode scaling„		DEF SEG = &H40: hoff% = 1: voff% = 1: vsc% = 1: dummy = PEEK(&H4A)„		SELECT CASE PEEK(&H49)„		CASE 4, 13, 19: hsc% = 2„		CASE ELSE: hsc% = 1„		END SELECT„	END SELECT„	DEF SEG„ CASE 4                                          'set pos„	regs.cx% = (c% - hoff%) * hsc%„	regs.dx% = (r% - voff%) * vsc%„	GOSUB imouse„ CASE 7„	regs.cx% = (c% - voff%) * vsc% + vsc% \ 2      'set limits„	regs.dx% = (r% - voff%) * vsc% + vsc% \ 2„	GOSUB imouse„ CASE 8„	regs.cx% = (c% - hoff%) * hsc% + hsc% \ 2       'set limits„	regs.dx% = (r% - hoff%) * hsc% + hsc% \ 2„	GOSUB imouse„ CASE 9„	regs.bx = 0„	regs.cx = 0„	regs.es = c%„	regs.dx = r%„	GOSUB imouse„ CASE 10, -10„	IF func% > 0 THEN regs.bx = 0 ELSE regs.bx = 1„	regs.cx = c%„	regs.dx = r%„	GOSUB imouse„ CASE -1„	hsc% = c%: vsc% = r%„ CASE -2„	hoff% = c%: voff% = r%„ END SELECT„EXIT FUNCTION„„imouse: CALL INTERRUPTX(&H33, regs, regs): RETURN„END FUNCTION„„Dave Thomas                    CD Drive Demo                  TknSoft2002@yahoo.com          12-11-02 (  :  )       LIBERTY                39   1428     CDDrvDmo.bas ' # A program which controls cd-rom driver (open & close)„ '  * Program Title               : CD_Drive_Demo.bas„ '  * Subject                     : How To Open & Close The CD Drive in Liberty BASIC„ '  * Author                      : Dave Thomas„ '  * E-Mail Adderss              : TknSoft2002@yahoo.com„ '  * Date Written                : 11-NOV-2002„ '  * Code                        : Liberty BASIC„ '  * Packet                      : Demo.ABC„ '  * Title of the attachment     : CD_Drive_Demo„ '  * List of attachment contents : CD_Drive_Demo.bas„ WindowWidth = 188„ WindowHeight = 50„ UpperLeftX=1„ UpperLeftY=1„ BackgroundColor$ = "buttonface"„ ForegroundColor$ = "black"„ button #DEMO.OPEN, "OPEN", [OPEN], UL, 1, 1, 60, 20„ button #DEMO.CLOSE, "CLOSE", [CLOSE], UL, 61, 1, 60, 20„ button #DEMO.EXIT, "EXIT", [EXIT], UL, 121, 1, 60, 20„ open "CD_Drive_Demo" for dialog_modal as #DEMO„ #DEMO,"font ms_sans_serif 0 10"„ #DEMO,"trapclose [LOOP]"„[LOOP]„ SCAN„ WAIT„[OPEN]„ OPEN "winmm.dll" FOR DLL AS #WinMM„ CALLDLL #WinMM,"mciSendStringA","set CDAudio door open" as ptr,lpstrReturnString$ as ptr,127 as long,0 as long,Result as long„ CLOSE #WinMM„ WAIT„[CLOSE]„ OPEN "winmm.dll" FOR DLL AS #WinMM„ CALLDLL #WinMM,"mciSendStringA","set CDAudio door closed" as ptr,lpstrReturnString$ as ptr,127 as long,0 as long,Result as long„ CLOSE #WinMM„ WAIT„[EXIT]„ CLOSE #DEMO„ NOMAINWIN„ END„Fred Buffington                Create PIF file                oasys@sbcglobal.net            12-22-02 (  :  )       QB,PDS,PB              57   2611     makepif.bas 'Fred Buffington„'Create PIF file„'QB,PDS,QBASIC„„'Make a Pif file for a dos program link „'author:Fred Buffington „'for QB,PBdos „'10/03/2002 „'below is a list of offsets from pif.txt from Wotsit.org „'OFFSET              Count TYPE   Description „'0000h                   1 byte   reserved „'0001h                   1 byte   Checksum „'0002h                  30 char   Title for the window „'0020h                   1 word   Maximum memory reserved for program „'0022h                   1 word   Minimum memory reserved for program „'0024h                  63 char   Path and filename of the program „'0063h                   1 byte   0 - Do not close window on exit „'                                 other - Close window on exit „'0064h                   1 byte   Default drive (0=A: ??) „'0065h                  64 char   Default startup directory „'00A5h                  64 char   Parameters for program „'00E5h                   1 byte   Initial screen mode, 0 equals mode 3 ? „'00E6h                   1 byte   Text pages to reserve for program „'00E7h                   1 byte   First interrupt used by program „'00E8h                   1 byte   Last interrupt used by program „'00E9h                   1 byte   Rows on screen „'00EAh                   1 byte   Columns on screen „'00EBh                   1 byte   X position of window „'00ECh                   1 byte   Y position of window „'00EDh                   1 word   System memory ?? whatever „'00EFh                  64 char   ?? Shared program path „'012Fh                  64 char   ?? Shared program data file „'016Fh                   1 word   Program flags „' „OPEN "qbtest.pif" FOR OUTPUT AS #1 „PRINT #1, CHR$(0); CHR$(0); 'reserved and checksum „PRINT #1, "testing pif" + SPACE$(19); 'Title „PRINT #1, CHR$(0); CHR$(184); 'B800 46k 'max mem „PRINT #1, CHR$(0); CHR$(0); 'min mem „PRINT #1, "C:\QB45\QB.EXE" + SPACE$(49);    'path and program name „PRINT #1, "1"; 'close window „PRINT #1, "2"; 'drive „PRINT #1, "c:\qb45" + SPACE$(57); 'startup dir „PRINT #1, SPACE$(64); 'parameters „PRINT #1, "0"; 'screen mode „PRINT #1, "4"; 'pages „PRINT #1, CHR$(0); CHR$(0); 'first interrupt last interrupt „PRINT #1, CHR$(25); 'rows „PRINT #1, CHR$(80); 'columns „PRINT #1, CHR$(0); 'x position of window „PRINT #1, CHR$(0); 'y position of window „PRINT #1, CHR$(0); 'CHR$(0); 'system memory looks like should be another chr „'but another chr$(0) causes it to not find it. „PRINT #1, SPACE$(64); 'shared path „PRINT #1, SPACE$(64); 'shared data file „PRINT #1, CHR$(0) 'flags „CLOSE #1 „