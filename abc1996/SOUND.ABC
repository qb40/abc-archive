Unknown Author(s)              BASIC MUSIC COLLECTION         FidoNet QUIK_BAS Echo          11-01-95 (23:22)       QB, QBasic, PDS        107  5768     BASMUSIC.BASCLS : PRINT "The GhostBusters Theme"„PLAY "MNT150L8O3CCL16D+EL8GL4A+AL8CCL16D+EL8GL4A+AP8L16CCL8E"„PLAY "CD<A+P2>CL16CCL8<A+>CL4<AP4L16>CCL8D+CD<A+P8L4A+L8A+>C"„PLAY "P2L16CCL8D+CL4D+P4P8L16C<A+L8>CCL4CP2L16D+CD+CL4D+P4<A+"„PLAY "L8A+>CP2P8L16CCL8D+CL4D+P4P8L16C<A+L8>CCL4CP2L16D+CD+"„PLAY "CL4D+P4<A+L8A+>CP2P4L4D+L8CL4D+L8CL4D+L8CL4D+L8CD+CL16<A+"„PLAY "BL8>CL4D+L8CL4D+L8CL4D+L8CL4D+L8CD+CL16<A+BL8>CL4GL8D+"„PLAY "L4GL8D+L4GL8D+L4GL8D+GD+L16C+DL8D+L4GL8D+L4GL8D+L4GL8D+"„PLAY "L4GL8D+GD+L16C+DL8D+CCL16D+EL8GL4A+AL8CCL16D+EL8GL4A+"„PLAY "AP8L16CCL8ECD<A+P2>CL16CCL8<A+>CL4<AP4L16>CCL8D+CD<A+"„PLAY "P8L4A+L8A+>CP2L16CCL8D+CL4D+P4P8L16C<A+L8>CCL4CP2L16D+"„PLAY "CD+CL4D+P4<A+L8A+>CP2P8L16CCL8D+CL4D+P4P8L16C<A+L8>CC"„PLAY "L4CP2L16D+CD+CL4D+P4<A+L8A+>CP2P4L16D+CD+CL4D+P4<A+L8A+"„PLAY ">CL16D+EL8GL4>CP4"„„CLS : PRINT "The Entertainer"„PLAY "MNT100L8O4DEC<AABGGDEC<AABGGDEC<AABAG+GGG>G>GG<DD+E>C"„PLAY "C<E>CC<E>CCCCCC>CDD+ECDEE<B>DDCCCCCCO2DD+E>CC<E>CC<E>C"„PLAY "CCCCCCAGF+A>CEEDC<A>DDDDDDO2DD+E>CC<E>CC<E>CCCCCC>CDD+"„PLAY "ECDEE<B>DDCCCCCCCDECDEECDCECDEECDCECDEE<B>DDCCCCCCO2D"„PLAY "D+E>CC<E>CC<E>CCCCCC>CDD+ECDEE<B>DDCCCCCCO2DD+E>CC<E>C"„PLAY "C<E>CCCCCCCAGF+A>CEEDC<A>DDDDDDO2DD+E>CC<E>CC<E>CCCCC"„PLAY "C>CDD+ECDEE<B>DDCCCCCCCDECDEECDCECDEECDCECDEE<B>DDCCC"„PLAY "CC<EFF+GGAGGEFF+GGAGGEC<GAB>CDEDCD<G>EFGAGEFGGAGGEFF+"„PLAY "GGAGGGAA+BBBBBAF+DGGGGGEFF+GGAGGEFF+GGAGGEC<GAB>CDEDC"„PLAY "DCCCCC<GF+G>CC<A>CC<A>C<AG>CEGGEC<GAA>CCEDDCCCCCC>EFF+"„PLAY "GGAGGEFF+GGAGGEC<GAB>CDEDCD<G>EFGAGEFGGAGGEFF+GGAGGGA"„PLAY "A+BBBBBAF+DGGGGGEFF+GGAGGEFF+GGAGGEC<GAB>CDEDCDCCCCC<G"„PLAY "F+G>CC<A>CC<A>C<AG>CEGGEC<GAA>CCEDDCCCCCCCO2DD+E>CC<E"„PLAY ">CC<E>CCCCCC>CDD+ECDEE<B>DDCCCCCCO2DD+E>CC<E>CC<E>CCC"„PLAY "CCCCAGF+A>CEEDC<A>DDDDDDO2DD+E>CC<E>CC<E>CCCCCC>CDD+E"„PLAY "CDEE<B>DDCCCCCCCDECDEECDCECDEECDCECDEE<B>DDCCCCCCO1CC"„PLAY "O3AG+AAAA>CCDDDDDDDD<FEFFFFAAA+A+A+A+A+A+A+GDDGDDGDDC"„PLAY "CCCFFFFEG+B>DDC<B>C<AAAAA+A+A+A+AG+AAAA>CCDDDDDDDD<FE"„PLAY "FFFFAAA+A+A+A+A+A+A+GDDGDDGDDCCCCFFFFA>CC<GGCDEFF<B>C"„PLAY "DEFGAG+AAAA>CCDDDDDDDD<FEFFFFAAA+A+A+A+A+A+A+GDDGDDGD"„PLAY "DCCCCFFFFEG+B>DDC<B>C<AAAAA+A+A+A+AG+AAAA>CCDDDDDDDD<F"„PLAY "EFFFFAAA+A+A+A+A+A+A+GDDGDDGDDCCCCFFFFA>CC<GGCDEFFO1F"„PLAY "FO4FFO1FFO3CC<A>CC<A>C<AG>CEGGEC<GAA>CCEDDCCCCC>CCO1C"„PLAY "C>FFEFFEFF<F>A>D<A>CDC<AGGF+GGF+GG<GO3CECDEDCDDC+DDC+"„PLAY "DDO1DO3FAFGAGF>CCCCCC<AAGG<GGGGGGFFEFFEFF<F>A>D<A>CDC"„PLAY "<AGGF+GGF+GG<GO3CECDEDC<AG+A>GGFFCED+EAA>C<GECCCCEDDC"„PLAY "CC<GGGGGGFFEFFEFF<F>A>D<A>CDC<AGGF+GGF+GG<GO3CECDEDCD"„PLAY "DC+DDC+DDO1DO3FAFGAGF>CCCCCC<AAGG<GGGGGGFFEFFEFF<F>A>D"„PLAY "<A>CDC<AGGF+GGF+GG<GO3CECDEDC<AG+A>GGFFCED+EAA>C<GECC"„PLAY "CCEDDCCCCC>CC"„„CLS : PRINT "Alfred Hitcock Presents"„PLAY "MNT150L8O2DP8>DL32EL8DC+<B>C+P8DEP8<ADP8>DL32EL8DC+<B"„PLAY ">C+P8DEP8<ADP8>FL4AL8GFP8AL4>CL8<A+AP8>CL4EL8DC+<A+AG"„PLAY "FE<DP8>DL32EL8DC+<B>C+P8DEP8<ADP8>DL32EL8DC+<B>C+P8DE"„PLAY "P4FP8AL4>CL8<A+AGFD+GA+DC+DEP8FL4E.L8D"„„CLS : PRINT "The Double-Oh-Seven Theme"„PLAY "MNT150L4O1BL8EBL4>CL8<E>CL4C+L8<E>C+L4CL8<E>CL4<BL8EB"„PLAY "L4>CL8<E>CL4C+L8<E>C+L4CL8<E>C>EL16F+F+L8F+L4F+.L8<EE"„PLAY "E>EL16GGL8GL4G.L8<F+F+F+>EL16F+F+L8F+L4F+.L8<EEE>EL16G"„PLAY "GL8GL4G.L8<F+F+F+>EL16F+F+L8F+L4F+.L8<EEE>EL16GGL8GL4G."„PLAY "L8<F+F+EO4D+L64<BL8>DL2DL64O2GL8BL64F+L8AL32G.L1B.L8E"„PLAY "L16F+F+L8F+L4F+.L8>EEE<EL16GGL8GL4G.L8>F+F+F+<EL16F+F+"„PLAY "L8F+L4F+.L8>EEE<EL16GGL8GL4G.L8>F+F+F+<EL16F+F+L8F+L4F+."„PLAY "L8>EEE<EL16GGL8GL4G.L8>F+F+E>D+L64<BL8>DL2DL64<GL8BL64F+"„PLAY "L8AL32G.L1B.L4O1BL8EBL4>CL8<E>CL4C+L8<E>C+L4CL8<E>CL4<B"„PLAY "L8EBL4>CL8<E>CL4C+L8<E>C+L4CL8<E>C>EL64EL4GL8>D+L64<G"„PLAY "BL4>D.L8<GL64FL8A+L64GL2B.L8GL32AGL4F+.L8<B>EC+L2C+L64<G"„PLAY "BL8>F+.P16L64<GBL4>F+L8EL64EL4GL8>D+L64<GBL4>D.L8<GL64F"„PLAY "L8A+L64GL2B.L8GL32AGL4F+.L8<B>D+EL2EL64<GBL8>C+.P16L64<G"„PLAY "BL4>C+L8EL64EL4GL8>D+L64<GBL4>D.L8<GL64FL8A+L64GL2B.L8G"„PLAY "L32AGL4F+.L8<B>EC+L2C+L64<GBL8>F+.P16L64<GBL4>F+L8EL64E"„PLAY "L4GL8>D+L64<GBL4>D.L8<GL64FL8A+L64GL2B.L8GL32AGL4F+.L8<B"„PLAY ">D+EL2EL64<GBL8>C+.P16L64<GBL4>C+L64<GBL8>EL64<GBL4>E"„PLAY "L64<GBL8>EL64<A>D+L8F+.L16EL64<A>D+L4F+L64<B>EL8GL64<B"„PLAY ">EL4GL64<B>EL8GL64<A>D+L8F+.L16EL64<A>D+L4F+L64<GBL8>E"„PLAY "L64<GBL4>EL64<GBL8>EL64<A>D+L8F+.L16EL64<A>D+L4F+L64<B"„PLAY ">EL8GL64<B>EL4GL64<B>EL8GL64<A>D+L8F+.L16EL64<A>D+L4F+"„PLAY "L64C+EGL8BL64C+EGL8BP8L2O1BL8BL64O3C+EGL8BL64C+EGL8BP8"„PLAY "L4O1B.BL64O3C+EGL16BL8BL16BL8BL64C+EGL8BL4O1BL8EBL4>C"„PLAY "L8<E>CL4C+L8<E>C+L4CL8<E>C>EL16F+F+L8F+L4F+.L8EEEEL16G"„PLAY "GL8GL4G.L8F+F+F+EL16F+F+L8F+L4F+.L8EEEEL16GGL8GL4G.L8F+"„PLAY "F+F+EL16F+F+L8F+L4F+.L8EEEEL16GGL8GL4G.L8F+F+E>D+L64<B"„PLAY "L8>DL2DL64GL8BL64F+L8AL32G.L1B.P16L8O2EL4GL8>D+L4DL8<G"„PLAY "BB>F+L4FL8<BL4>DL8A+L4AL8FAL4AL8D+DDP8P4L64O1EB>GB>C+"„PLAY "L2F+."„„CLS„PRINT "The Looney Tunes Theme"„PLAY "MST200L8O3E.L16DL8CDED+ECDDDL2D.L8D.L16CL8<B>CDC+D<B>C"„PLAY "CCL2C.L8<G.L16G+L8A.L16G+L8G.L16G+L8A.L16G+L8G>DDL2D."„PLAY "L8<AG+AL4>DEL2G"„„CLS : PRINT "The Original Star Trek Theme"„PLAY "MNT255L1O4B.D.F.<A.P8L2GL8G>C.L2FFL4E.L8EL4C<A>DL2GP8"„PLAY "L4GL1BP4L2CL8CF.L2A+A+L4A.L8AL4FDGL2>CP8L4CL1EP1L2O3G"„PLAY ">F.L4EDC<BL2A+L1A+L2G>G.L4FEDCL2<BL1BL4A+L2A.L4B>C+DE"„PLAY "F+GL2AL1A+.L2<A+.L4>CDD+FGG+L2A+L1BL2<G>F.L4EDC<BL2A+"„PLAY "L1A+L4G+L2G>G.L4FEDCL2<BL1BL4A+L2A.L4B>CDEFEL2G.L4GL2A+."„PLAY "L4AL2GL1CL4D.F.A.L1>C"„„CLS : PRINT "The Star Wars Theme"„PLAY "MNT100L2O3CGP16L16FEDL2>C<GP16L16FEDL2>C<GP16L16FEFL2D"„PLAY "P16L16<GGGL2>CGP32L16FEDL2>C<GP16L16FEDL2>C<GP16L16A+"„PLAY "AA+L1GL2G.L8<G.L16GL4A.L8A>FEDCL16CDEDP16L8<AL4BL8G.L16G"„PLAY "L4A.L8A>FEDCGP8L4D.P8L8<G.L16GL4A.L8A>FEDCL16CDEDP16L8<A"„PLAY "L4BP16L8>G.L16GL8>C.L16<A+L8G+.L16GL8F.L16D+L8D.L16CL1G"„PLAY "L2G.P16L16GGGL8>CP8L16<CCCL2C."„SYSTEM„„David Godding                  BACH'S "MENUET"                FidoNet QUIK_BAS Echo          11-16-95 (19:25)       QB, QBasic, PDS        21   576      MENUET.BAS  '*** Excerpt from 'Menuet,' by Johann Sebastian Bach ****„„CLS„DIM MEASURE$(1 TO 8)      'Measure$ contains the notes to be„                          'played in each measure.„„MEASURE$(1) = "O4D4O3MLGABO4C"„MEASURE$(2) = "O4D4O3MNG4MLG4"„MEASURE$(3) = "O4MNE4MLCDEF#"„MEASURE$(4) = "O4G4O3MNG4MLG4"„MEASURE$(5) = "O4MNC4MLDCO3BA"„MEASURE$(6) = "O3MNB4MLO4CO3BAG"„MEASURE$(7) = "O3MNA4MLBAGF#"„MEASURE$(8) = "G2.MN"„„PRINT : PRINT " ***  An excerpt from 'Menuet,' by Johann Sebastian Bach  ***"„„PLAY "T180L803MN"„FOR I = 1 TO 8„   PLAY MEASURE$(I)„NEXT I„Unknown Author(s)              BACKGROUND MUSIC PLAY          BACKGROUND,MUSIC,PLAY          03-30-93 (06:58)       QB, QBasic, PDS        42   668      MUSICAL.BAS ON PLAY(2) GOSUB MORE„SCREEN 1„„PLAY ON„„PLAY "T160 MB ML L8 O4 E E- E E- E <B >D C <A"„PLAY "O2 E A >C E A B"„PLAY "O2 E G# >E G# B >C"„„PLAY "O2 E A >E"„STANZA% = 1„„DO„X1 = RND * 320„X2 = RND * 320„Y1 = RND * 200„Y2 = RND * 200„COL = INT(RND * 4)„LINE (X1, Y1)-(X2, Y2), COL, B„LOOP WHILE INKEY$ = ""„„PLAY OFF„DO„LOOP WHILE PLAY(0) > 0„CLS„END„„MORE:„IF STANZA% = 1 THEN„STANZA% = 2„PLAY "MB ML L8 O4 E E- E E- E <B >D C A<"„PLAY "O2 E A >C E A B"„PLAY "O2 E G# >E >C <B A2. L8 N0"„ELSE„SATNZA% = 1„PLAY "MB ML L8 O4 E E- E E- E <B >D C <A"„PLAY "O2 E A >C E A B"„PLAY "O2 E G# >E G# B >C"„PLAY "O2 E A >E"„END IF„RETURN„„Edward Schlunder               SOUNDBLASTER VOC DIRECT        FidoNet QUIK_BAS Echo          09-28-93 (00:00)       PDS                    185  5340     SBVOCDIR.BAS'======================================================================„'                          SoundBlaster VOC Direct„'                  Release 1.11 (9-28-93) By Edward Schlunder„'              Filename: SBVOCDIR.BAS    Archive: !SBDIR11.ARJ„'„'        Released into the public domain. Do what you wish with it, but I'm„'   not liable for any undesirable outcomes. Also, common certesy suggests„'   that you give me credit in your program and/or your documents.„'„'               GTPN:       009/009„'               FidoNet:    1:114/151.0„'               Internet:   zilym@hndymn.fidonet.org„'               Snail Mail: Edward Schlunder„'                           554 N. Acacia Rd„'                           Apache Junction, AZ 85219-4313„'                           USA„'„'======================================================================„„DEFINT A-Z„DECLARE SUB WriteDAC (DVal%)„DECLARE SUB SetVoice (ONOFF%)„DECLARE SUB PlayByte (BYVAL DVal%)„„TYPE SoundSrcType„ Name     AS STRING * 13„ Han      AS INTEGER„ Addr     AS INTEGER„END TYPE„„COMMON SHARED SdDevs()  AS SoundSrcType, SoundDev„DIM SdDevs(5)  AS SoundSrcType', SoundDev„SdDevs(0).Name = "PC-Speaker   ": SdDevs(0).Han = 0: SdDevs(0).Addr = &H42„SdDevs(1).Name = "LPT1-DAC     ": SdDevs(1).Han = 1: SdDevs(1).Addr = &H378„SdDevs(2).Name = "LPT2-DAC     ": SdDevs(2).Han = 1: SdDevs(2).Addr = &H278„SdDevs(3).Name = "LPT3-DAC     ": SdDevs(3).Han = 1: SdDevs(3).Addr = &H3BC„SdDevs(4).Name = "LPT4-DAC     ": SdDevs(4).Han = 1: SdDevs(4).Addr = &H37B„SdDevs(5).Name = "Sound Blaster": SdDevs(5).Han = 2: SdDevs(5).Addr = &H220„„LastBeg = 1„Parm = INSTR(LastBeg, COMMAND$, "-")„IF Parm THEN„FileName$ = RTRIM$(LEFT$(COMMAND$, Parm))„ELSE„FileName$ = COMMAND$„END IF„DO„Parm = INSTR(LastBeg, COMMAND$, "-")„IF Parm THEN„P$ = MID$(COMMAND$, Parm, 2)„SELECT CASE P$„CASE "-C"                               'Playback device„SoundDev = VAL(MID$(COMMAND$, Parm + 2, 1))„CASE "-P"                               'Playback address„SdDevs(SoundDev).Addr = VAL("&H" + MID$(COMMAND$, Parm + 2, 3))„CASE "-S"                               'Playback slowdown„SlowDown = VAL(MID$(COMMAND$, Parm + 2, 2))„END SELECT„END IF„LastBeg = Parm + 2„LOOP UNTIL Parm = 0„„IF SoundDev = 0 THEN„COLOR 14, 1„CLS„PRINT "Sound Device: "„FOR J = 0 TO 5„PRINT J; ":  "; SdDevs(J).Name„NEXT„LOCATE , , 1, 6, 8„DO„G$ = INKEY$„LOOP UNTIL LEN(G$)„PRINT G$„SoundDev = VAL(G$)„„SELECT CASE SoundDev„CASE 5„PRINT "I/O Address of Sound Blaster:"„PRINT "1 :  210h"„PRINT "2 :  220h"„PRINT "3 :  230h"„PRINT "4 :  240h"„DO„G$ = INKEY$„LOOP UNTIL LEN(G$)„PRINT G$„Addr = VAL(G$)„„SdDevs(SoundDev).Addr = &H200 + Addr * &H10„END SELECT„„IF LEN(FileName$) = 0 THEN INPUT "Path and filename of file to play: ", FileName$„END IF„„OPEN FileName$ FOR BINARY AS 1„SCREEN 12„„VOCBytes& = LOF(1)„VOCSByte& = 1„VOCLeng = 32767„DO„LOCATE 30, 35                          'Print the output device name.„PRINT SdDevs(SoundDev).Name„„IF VOCBytes& > 32767 THEN              '>32767 byte file handling„VOCLeng = 32767„VOCBytes& = VOCBytes& - 32767„ELSE„VOCLeng = VOCBytes&„VOCBytes& = 0„END IF„VOC$ = SPACE$(VOCLeng)„GET #1, VOCSByte&, VOC$„VOCSByte& = VOCSByte& + 32767„„VSeg = SSEG(VOC$)                 'This needs to be changed for QB. I use„                                  'PDS. It should be VARSEG instead of SSEG„                                  'if you are using QB.„VOff& = SADD(VOC$)„VOff2& = VOff& - 640„SetVoice 1„DEF SEG = VSeg„FOR J& = 1 TO VOCLeng„              'You may need to add a delay loop in here if the VOC sounds„              'like it being played too fast.„'FOR K = 1 TO SlowDown: NEXT„VOff2& = VOff2& + 1„PRESET (ByteLoc + 1, PEEK(VOff2&))„VOff& = VOff& + 1„PlayByte PEEK(VOff&)„ByteLoc = ByteLoc + 1„PSET (ByteLoc, PEEK(VOff&)), 13„IF ByteLoc = 640 THEN ByteLoc = 0„NEXT„LOOP UNTIL VOCLeng = 0 OR LEN(INKEY$)„SetVoice 0„CLOSE 1„SCREEN 0: WIDTH 80„END„„SUB PlayByte (BYVAL DVal)„SELECT CASE SdDevs(SoundDev).Han„ CASE 0„  OUT SdDevs(SoundDev).Addr, DVal \ 3„ CASE 1„  OUT SdDevs(SoundDev).Addr, DVal„ CASE 2„  DO                                    'This loops until the SoundBlaster is„  LOOP WHILE INP(SdDevs(SoundDev).Addr) AND &H80  'ready for data.„  OUT SdDevs(SoundDev).Addr, &H10„  DO                                    'This loops until the SoundBlaster is„  LOOP WHILE INP(SdDevs(SoundDev).Addr) AND &H80  'ready for data.„  OUT SdDevs(SoundDev).Addr, DVal„END SELECT„END SUB„„SUB SetVoice (ONOFF)„IF ONOFF THEN„ SELECT CASE SdDevs(SoundDev).Han„  CASE 0„   OUT &H43, &HB6„   OUT &H42, &HFF„   OUT &H42, 0„   OUT &H43, &H90„   OUT &H61, INP(&H61) OR 3„  CASE 1„  CASE 2„   DO                                    'This loops until the SoundBlaster is„   LOOP WHILE INP(SdDevs(SoundDev).Addr) AND &H80        'ready for data.„   OUT SdDevs(SoundDev).Addr, &HD1„ END SELECT„ELSE„ SELECT CASE SdDevs(SoundDev).Han„  CASE 0„   OUT &H43, &HB6„   OUT &H61, INP(&H61) AND &HFC„  CASE 1„  CASE 2„   DO                                    'This loops until the SoundBlaster is„   LOOP WHILE INP(SdDevs(SoundDev).Addr) AND &H80        'ready for data.„   OUT SdDevs(SoundDev).Addr, &HD3„ END SELECT„END IF„END SUB„Brandon Callison               PLAY NOTE VIA SB CARD          QBTIPS                         Unknown Date           QB, QBasic, PDS        84   2616     SBSOURCE.BAS'                        Sound Blaster Source Code„'                         Made by Brandon Callison„'        Register 388h is the address/status port, and 389h is the data port.„'This is, of course, only for the FM music.  (The cannels 1-11)  which are„'compatible with Ad-Lib, Sound Blaster, SB Pro, Thunder Board, and many„'others.  All boards advertised as compatible with Ad-Lib or Sound Blaster„'are compatible with this.  Explainations of the mysterious code will be„'throughout the program.„„DEFINT A-Z„„DECLARE SUB SBStop ()„DECLARE SUB SBReset ()„DECLARE SUB SBOutPort (reg, x)„DECLARE SUB SBPlayNote (freq#, oct)„„' vvvvvvvvvvvvvvvvvvvvvvv„' The following are his variable declarations; I'm leaving them in so you„' can see what all the variables are for:„'„'float freq;                          /* Frequency                */„'int oct;                             /* Octave                   */„'int reg;                             /* Register no.             */„'int x;                               /* Poke number to register  */„'int i;                               /* GLOBAL Dummy loop signal */„'„' ^^^^^^^^^^^^^^^^^^^^^^^„„SBReset„SBPlayNote 277.2, 5                  'Middle C sharp on octave 5„SLEEP 2„SBStop                               'Must be called to cut sound„„END„„SUB SBOutPort (reg, x)„„OUT &H388, reg              'Outputs the register to be written to„„FOR I = 1 TO 6„„    reg = INP(&H388)„„NEXT I„„'   ^- This loop requires some explaining.  The sound card must allow time„'to process it's code.  6 reads from the status port will cause it to wait„'for 2.3 microseconds.  You MUST NOT make any outputs to the sound card port„'without waiting at least this amount of time in-between calls.  The same„'applies below, except the wait is 23 microseconds, by 35 reads from the data„'port.„„OUT &H389, x„FOR I = 1 TO 35                 'Outputs the data into the register„    reg = INP(&H389)„NEXT I„„END SUB„„SUB SBPlayNote (freq#, oct)„„freq2 = INT(1.31 * freq#)          'Convert from hz to raw frequency?!?!„SBOutPort &H60, &HF0„SBOutPort &HC0, 1„SBOutPort &HA0, freq2 AND &HFF„SBOutPort &HB0, ((freq2 AND &HFF00) / &H100) OR (oct * 4) OR 32„       '   ^- for different channels, do anywhere from the register„       '   0xB0 to 0xBA.  (channels 1-11)„END SUB„„SUB SBReset„„FOR I = 1 TO 244         ' The sound card has 244 data ports.  Just clears„    OUT &H388, 0         ' all of them.„NEXT I„„END SUB„„SUB SBStop„„  SBOutPort &HB0, 0       ' As I said earlier for different channels„„END SUB„„Jarno Peschier                 PLAYING MUSIC (JURASSIC PARK)  alt.lang.basic                 11-30-95 (08:27)       PB                     138  4975     PBMUSIC.BAS '>  I'm looking for music written in the MS basic PLAY language.  Does anyone „'>know of an FTP site where I could find songs for basic?  Also If you have „'>music for Basic maybe you could E-mail them to me.„„'Making PLAY-music in Basic isn't that difficult (if you can read sheet„'music). Just take a piece of sheet music and translate it almost„'litterally into PLAY commands. Easy...„„'I've written a few pieces of PLAY music myself (even own adaptions of„'known songs, by just trying to play it on my electronic keyboard, then„'translating it into PLAY statements).„„'I'll include an example below in PB 3.0c. I hope you don't mind all„'text and comments in the source are in Dutch. If you want, I could„'translate. And look how easy you can get *real* background music with„'PLAY statements for the actual music in Basic! This is PB, but I've„'even used the same principle in GWBasic before I knew about Basic„'compilers.„„„%No = 0„%Yes = NOT %No„„DIM Muziek AS SHARED INTEGER        'Achtergrondmuziek aan of uit?„DIM VolgendeMaat AS SHARED INTEGER  'Volgende maat voor in de buffer„„ON PLAY(8) GOSUB MuziekBufferBijvullen  'Bijvullen als nog 8 noten in buffer„KEY 15, CHR$(&H08,50,&H77)      'Alt+M = hotkey voor muziek aan/uit„ON KEY(15) GOSUB MuziekHotkey„StartMuziek„„'=== Zet hier je eigen programma„CLS„PRINT„PRINT„PRINT"Dit is een dummy programma in een loop."„PRINT„PRINT"Op de achtergrond loopt nu een muziekje."„PRINT"Zet de muziek aan/uit met Alt+M."„PRINT„PRINT"Gebruik hiervan is uit de source hopelijk wel duidelijk."„PRINT"Het enige waarop je letten moet is dat je in de SUB"„PRINT"SpeelVolgendeMaat de muziek in blokjes opslaat in de"„PRINT"SELECT-CASE in stukjes die allemaal ongeveer even lang zijn!"„PRINT"Neem bijvoorbeeld, zoals de naam van de SUB aangeeft, echt"„PRINT"maten van de bladmuziek."„PRINT„PRINT"Druk op een toets om te stoppen."„DO„  LOCATE 1,1„  PRINT TIME$„LOOP WHILE INKEY$=""„CLS„PRINT"Dit is werkelijk alles..."„'=== Einde eigen programma„„StopMuziek„END„„„'ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ„' Routines voor de achtergrondmuziek„'‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹„„„MuziekHotKey:„  KEY(15) STOP              'Vang maar ÇÇm Alt+M tegelijk„  Muziek = NOT Muziek           'Toggle muziek flag„  IF Muziek THEN„	StartMuziek             'Zet muziek (weer) aan als nodig„  ELSE„	StopMuziek              'Zet muziek (weer) uit als nodig„	KEY(15) ON              'En kijk weer naar Alt+M„  END IF„RETURN„„„MuziekBufferBijvullen:„  SpeelVolgendeMaat         'Volgende maat in buffer zetten„RETURN„„„SUB StartMuziek INLINE„  Muziek = %Yes             'Muziek nu aan„  PLAY"MBT116L8O2MN"            'Instellingen (MB, tempo, octaaf)„  PLAY"O1MSE16P.E16P.E16P.E16P.O2MN"    'Intro spelen„  VolgendeMaat = 1          'De volgende maat is de eerst„  SpeelVolgendeMaat         'Zet die maar in de buffer„  PLAY ON               'Muziek loopt (bekijk bufferlengte)„  KEY(15) ON                'Bekijk Alt+M ook natuurlijk„END SUB„„„SUB SpeelVolgendeMaat INLINE„  PLAY"MB"              'De maat moet in de achtergrond!„  SELECT CASE VolgendeMaat      'Hier zet je de eigenlijke muziek„	CASE 1: PLAY"EF4G#A4B4 >C<B4>C<B>C16<B16AF"„	CASE 2: PLAY"MLE1MSEMN E4DC#DEC#"„	CASE 3: PLAY"D1 F4.C#D4F4 E1.F4D4"„  END SELECT„  INCR VolgendeMaat         'Hoog de teller op„  IF VolgendeMaat > 3 THEN VolgendeMaat = 1 'En begin muziek„opnieuw„END SUB„„„SUB StopMuziek INLINE„  PLAY OFF              'Kijk niet meer naar muziekbuffer„  KEY(15) OFF               'Kijk niet meer naar Alt+M„  SOUND 0,0             'Stop muziek in de buffer direct„END SUB„„„'And here is another example of PLAY music; my own adaption of the„'Jurassic Park movie theme. It's just the data you should play with„'PLAY. And yes, it's cut up in 20 chunks because this was part of a„'GWBasic program that had background music that you could turn on/off„'with a hotkey.„„„DATA 20„DATA"mlt110o2l8c<b>l4c<gf>l8c<b>l4c<g","f>l8c<mnbmlb>c4.<l4gcl8mnb-2.ml>"„DATA"c<b>l4c<gf>l8c<b>l4c<gf>l8c<mnbml","b>c4mndmld4.mnfmlf2.ecd4.<mngml"„DATA"g4>ecd2.gcf4.mnemle4.mndd2.mlc<b",">l4c<gf>l8c<b>l4c<gf>l8c<mnbmlb>"„DATA"c4.<l4gcl8mnb-2.ml>c<b>l4c<gf>l8","c<b>l4c<gf>l8c<mnbmlb>c4mndmld4.."„DATA"mnfmlf2.ecd4.<mngmlg4>ecd2.gcf4.","mnemle4.mndmld4.mncc4mlc<b>l2mn"„DATA"c.mll8c<b>l2mnc.mll8c<b>c4.mndml","d4.mnfmlf2.ecd4.<mngmlg4>ecd2.gc"„DATA"f4.mnemle4.mndmld2.ecd4.<mngmlg4",">ecd2.t105gcf4.mnt100emlt97e4.mn"„DATA"t95dmlt92d4.mnt90ct87c4mlt100>c<","b>t110l4c<gf>l8c<b>l4c<gf>l8c<mn"„DATA"bmlb>c4.<l4gcl8mnb-2.ml>c<b>l4c<","gf>l8c<b>l4c<gf>l8c<mnbmlb>c<gf#"„DATA"g4>fef2.c<mnbmlb>c<gf#g4>fed2d4.mncmsc8p4.p2p2.","p1p1"„„'Happy music!„„'          Jarno Peschier, jpeschie@cs.ruu.nl, 2:2802/245.1@Fido„'      162:100/100.1@Agora, 74:3108/102.1@QuaZie, 27:2331/214.1@SigNet„„„Joe Shay                       SCAN MIDI FILE STRUCTURES      FidoNet QUIK_BAS Echo          01-06-96 (01:27)       QB, QBasic, PDS        160  4239     MIDISCAN.BAS'MIDI001.BAS  By Joe Shay„'Released to the Public Domain, January 1996„'(presently intended)„'A program ^ to - scan the MIDI file structure.„'               - identify  MIDI Format, Tempo, Key,„'                     Track name, instrument name„'               - generally display file contents„'„'Note: I have directed the program to examine a„'      .MID file included with Windows.„'„' This code is 'AS IS' so if anyone can improve my„'methods to accomplish the above stated I would„'appreciate it. My thanx to Chad Beck for directing me„'towards  the correct ball park.„'„„DEFINT A-Z„DECLARE FUNCTION Int2Hex$ (Dec%)„DECLARE FUNCTION KeeOTune$ (sfnum$, minum%)„„TYPE midi„ headchunk AS STRING * 4„  headsize AS STRING * 4„     f4mat AS STRING * 2„    totrax AS STRING * 2„  deltatix AS STRING * 2„END TYPE„„TYPE midigutz„  trakchunx AS STRING * 4„   chunklen AS STRING * 4„END TYPE„„DIM midfylhead AS midi„DIM miditrax(1 TO 100) AS midigutz„„WIDTH 80, 50„CLS„„OPEN "c:\sb16\playmidi\minuet.mid" FOR BINARY AS #1„GET 1, , midfylhead„  IF midfylhead.headchunk <> "MThd" THEN„   CLOSE„    PRINT "Non .MID file or corrupted file"„   END„  END IF„ COLOR 0, 2„  PRINT " File Format = "; ASC(RIGHT$(midfylhead.f4mat, 1));„  IF ASC(RIGHT$(midfylhead.f4mat, 1)) > 0 THEN PRINT "[Multi Trax]" ELSE PRINT "[Single Trax]"„„ COLOR 0, 3„    ttrx = ASC(LEFT$(midfylhead.totrax, 1)) + ASC(RIGHT$(midfylhead.totrax, 1))„  PRINT " Total Tracks = "; ttrx - 1;„'PRINT " Delta Ticks / PPQ = "; ASC(RIGHT$(midfylhead.deltatix, 1));„  PRINT„ COLOR 3, 0„ Tempo$ = SPACE$(8)„ timsig$ = SPACE$(5)„ keysig$ = SPACE$(3)„ a$ = SPACE$(1)„ B$ = SPACE$(1)„„DO UNTIL EOF(1)„  GET 1, , a$„    SELECT CASE a$„     CASE CHR$(255) '&HFF meta event marker„       GET 1, , B$„        bb$ = HEX$(ASC(B$))„         IF LEN(bb$) < 2 THEN bb$ = "0" + bb$„            SELECT CASE bb$„             CASE "01", "02", "03", "04", "05", "06", "07"„               GET 1, , B$„                tot = ASC(B$)„                GOSUB grabyte„             CASE "20"„              cc$ = "MIDI Ch. Prefix.."„             CASE "2F"„              cc$ = "-=End Trk=-" + CHR$(13)„             CASE "51"„              cc$ = "Set tempo"„              GET 1, , Tempo$„               Byte1 = VAL(HEX$(ASC(MID$(Tempo$, 3, 2))))„               Byte2 = VAL(HEX$(ASC(MID$(Tempo$, 5, 2))))„               Byte3 = VAL(HEX$(ASC(MID$(Tempo$, 7, 2))))„              Tempo& = Byte1 + (Byte2 * 256&) + (Byte3 * 65537)„              PRINT Tempo&„             CASE "58"„              cc$ = "Time Sig.."„              GET 1, , timsig$„                num = ASC(MID$(timsig$, 2, 1))„                den = ASC(MID$(timsig$, 3, 1))„                den = 2 ^ den„                COLOR 15, 3„               LOCATE 1, 42: PRINT num; "/"; den„             CASE "59"„              cc$ = "Key Sig.."„               GET 1, , keysig$„               sf = ASC(MID$(keysig$, 2, 1))„               mi = ASC(MID$(keysig$, 3, 1))„„                 IF sf > 7 THEN     '='='convert to negative„                   sf = sf - 256„                 END IF„                 sf$ = LTRIM$(RTRIM$(STR$(sf)))„„               ' PRINT sf   'temp for tests„               COLOR 15, 3„                LOCATE 1, 65: PRINT KeeOTune$(sf$, mi)„„             CASE ELSE„              cc$ = "===="„              END SELECT„             PRINT bb$; " "; cc$„     CASE ELSE„     END SELECT„ LOOP„  CLOSE„   END„„grabyte:„COLOR 1, 15„FOR i = 1 TO tot„  a$ = INPUT$(1, #1)„  IF a$ <> CHR$(0) OR a$ <> CHR$(12) THEN„   PRINT a$;„  END IF„  NEXT„ COLOR 3, 0„RETURN„„DEFSNG A-Z„FUNCTION Int2Hex$ (Dec%)„ IF Dec% = 0 THEN„  t2Hex$ = "00"„ ELSE„  t2Hex$ = HEX$(Dec%)„  IF LEN(t2Hex$) < 2 THEN t2Hex$ = "0" + t2Hex$„ END IF„ Int2Hex$ = t2Hex$„END FUNCTION„„DEFINT A-Z„'„ FUNCTION KeeOTune$ (sfnum$, minum%)„  keyz$ = "Bb-5DbF -4AbC -3EbG -2BbD -1F A 0 C E +1G B +2D F#+3A C#+4E G#+5B D#+6F#"„ scan1 = INSTR(keyz$, sfnum$)„ IF minum% = 0 THEN„  scan1 = scan1 + 2„  mm$ = " Major"„ ELSE„  scan1 = scan1 - 2„  mm$ = " Minor"„ END IF„„ tunekee$ = MID$(keyz$, scan1, 2)„ KeeOTune$ = tunekee$ + mm$„„ END FUNCTION„„Aaron Scott Zabudsky           GRAPHICALLY DISPLAYS WAV FILES zabudsk@ecf.toronto.edu        05-10-94 (17:01)       QB, QBasic, PDS        40   466      WAVVIEW.BAS „DEFINT D, G„DEFLNG H„SCREEN 12„CLS„„OPEN "c:\windows\ding.wav" FOR BINARY AS #1„s = 45„g = 0„d = 0„px = 0„py = 240„np = 0„ns = 5„„„WHILE NOT (EOF(1)) AND s < 300000„c = 0„h = 0„WHILE c < ns„GET 1, s, g„g = ABS(g MOD 256)„h = h + g„s = s + 1„c = c + 1„IF EOF(1) THEN END„WEND„h = h / ns„„LINE (np, h + 112)-(px, py)„PSET (np, 240), 2„py = h + 112„px = np„np = np + 1„IF np > 640 THEN np = 0: SLEEP: CLS : px = 0„WEND„„„CLOSE„„Rich Dersheimer                CREATIVE MUSIC FILE PLAYER     SB CMF PLAYER                  05/93 (00:00)          QB, PDS                281  11122    RPLAY.BAS   '============================================================================„' If you want to use QuickBASIC, you will have to remove statements that PDS„' uses that QB doesn't, like DIR$, SADD, and SSEG, and substitute QB code.„„' If you use this code in your programs, remember that the DEF SEG is not„' reset until the music is done playing, so don't do anything to change„' the SEG while the music is playing.  Also, if the SBFMDRV.COM is not„' loaded, then your system may lock up.  I have put in a simple test to„' see if interrupt 80h is not being used, this MAY stop lockups.„„' Feel free to modify ANY of the code, it's yours to keep!„„' I'm putting this code in the public domain for any sound/music programmers.„' Needless to say (but I'm still gonna say it), use RPLAY code at your„' own risk, I will not be held responsible for ANYTHING that happens when„' you hack this code.  Send comments, questions, love notes to:„„' Rich Dersheimer„' 72123,1521 on CIS„'============================================================================„„        ' ***************************************„        ' *             RPLAY.BAS               *„        ' *   QuickBASIC/PDS source code for a  *„        ' *   program to play CMF files on the  *„        ' *   Sound Blaster sound card.         *„        ' *                                     *„        ' *   Written in May of 1993 by Rich    *„        ' *   Dersheimer.  72123,1521 on CIS    *„        ' *                                     *„        ' *   WARNING: You must start QB/PDS    *„        ' *   with the /L switch to load the    *„        ' *   proper library for InterruptX!    *„        ' *                                     *„        ' *   MORE WARNING: You must already    *„        ' *   have loaded SBFMDRV.COM to run    *„        ' *   RPLAY.EXE!  Or risk lockup!       *„        ' ***************************************„        „        DEFINT A-Z„        „        TYPE RegTypeX„                ax      AS INTEGER„                bx      AS INTEGER„                cx      AS INTEGER„                dx      AS INTEGER„                bp      AS INTEGER„                si      AS INTEGER„                di      AS INTEGER„                flags   AS INTEGER„                ds      AS INTEGER„                es      AS INTEGER„        END TYPE„„        DECLARE SUB InterruptX (intnum%, iReg AS RegTypeX, oReg AS RegTypeX)„„        DIM iReg AS RegTypeX„        DIM oReg AS RegTypeX„„        RANDOMIZE -TIMER„„        '********* Check for the SBFMDRV driver ***************„        DEF SEG = 0„        SegmentCheck = PEEK(512) + PEEK(513) * 256„        AddressCheck = PEEK(514) + PEEK(515) * 256„        DEF SEG„„        IF SegmentCheck = 0 AND AddressCheck = 0 THEN„            PRINT                                ' This is a check of„            PRINT                                ' the interrupt vector„            PRINT "  SBFMDRV.COM is not loaded!" ' at address 80h.  It„            PRINT                                ' MAY keep your program„            END                                  ' from locking up if„        END IF                                   ' SBFMDRV is not loaded„        '******************************************************„„„        '********* Get the file name **************************„        FileName$ = COMMAND$„„        IF FileName$ = "" THEN„            PRINT„            PRINT„            PRINT "     RPLAY written by Rich Dersheimer"„            PRINT "     usage: RPLAY FILENAME"„            PRINT "     WARNING!  SBFMDRV.COM *MUST* be loaded!"„            PRINT„            END„        END IF„„        IF INSTR(FileName$, ".") = 0 THEN„            FileName$ = FileName$ + ".CMF"„        END IF„„                                             '***„        IF DIR$(FileName$) = "" THEN           '*„            PRINT                              '*„            PRINT                              '*„            PRINT "     File ";                '*„            PRINT FileName$; " not found!"     '**** Take this code out„            PRINT                              '*    For QuickBASIC 4.5„            END                                '*„        END IF                                 '*„                                             '***„„        '******************************************************„„„        '********* Load in the file ***************************„        OPEN FileName$ FOR BINARY AS #1„        FileLength& = LOF(1)„„        IF FileLength& > 32767 THEN„            PRINT„            PRINT„            PRINT "     "; FileName$;„            PRINT " is too big for RPLAY!"„            PRINT„            END„        END IF„„        A$ = STRING$(FileLength&, "r")„        GET #1, 1, A$„        CLOSE #1„„        IF LEFT$(A$, 4) <> "CTMF" THEN„            PRINT„            PRINT„            PRINT "     "; FileName$;„            PRINT " does not appear to be a CMF file!"„            PRINT„            END„        END IF„        '******************************************************„„        „        '********* Find the file in memory ********************„        Offset = SADD(A$)           ' offset in the segment„        Segment = SSEG(A$)          ' segment of the file„                                    ' this is different QB 4.5„„        DEF SEG = Segment           ' DON'T change the segment„                                    ' while the music is playing!„„        NumberIns = PEEK(Offset + &H24) + PEEK(Offset + &H25) * 256„        InsOffset = PEEK(Offset + 6) + PEEK(Offset + 7) * 256„        InsStart = Offset + InsOffset„        MusicOffset = PEEK(Offset + 8) + PEEK(Offset + 9) * 256„        MusicStart = Offset + MusicOffset„        Ticks = PEEK(Offset + &HC) + PEEK(Offset + &HD) * 256„        '******************************************************„„„        '***** Tell soundblaster where to return info *********„        iReg.bx = 1                     ' I'm sending the return„        iReg.dx = Segment               ' info to the first byte„        iReg.ax = Offset                ' of the music file area„        InterruptX &H80, iReg, oReg„        '******************************************************„„        „        '************ Setup instruments ***********************„        'IF NumberIns > 0 AND NumberIns < 17 THEN„            iReg.bx = 2„            iReg.cx = NumberIns         ' if you get an invalid„            iReg.dx = Segment           ' # of instruments, use„            iReg.ax = InsStart          ' default instruments„            InterruptX &H80, iReg, oReg„        'END IF„        '******************************************************„„„        '************* Set System Clock Rate ******************„        iReg.bx = 3                     ' I'm not really sure„        iReg.ax = &HFFFF                ' you have to do this„        InterruptX &H80, iReg, oReg     ' but it doesn't hurt„        '******************************************************„„„        '************* Set Driver Clock Rate ******************„        iReg.bx = 4„        iReg.ax = (1193180 / Ticks)„        InterruptX &H80, iReg, oReg„        '******************************************************„„„        '************* Play some music! ***********************„        iReg.bx = 6„        iReg.dx = Segment„        iReg.ax = MusicStart„        InterruptX &H80, iReg, oReg„        '******************************************************„„„        '*********** Music should be playing by now ***********„        COLOR 9, 0„        CLS„        PRINT TAB(20); "RPLAY CMF Music Player by Rich Dersheimer"„        PRINT„        PRINT„        PRINT„        PRINT "                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„        PRINT "                         ≥ ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø ≥"„        PRINT "                         ≥ ≥                        ≥ ≥"„        PRINT "                         ≥ ≥                        ≥ ≥"„        PRINT "                         ≥ ≥                        ≥ ≥"„        PRINT "                         ≥ ≥                        ≥ ≥"„        PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø     ≥ ≥                        ≥ ≥";„        PRINT "     ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„        PRINT "≥                ≥     ≥ ≥                        ≥ ≥";„        PRINT "     ≥                ≥"„        PRINT "√ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥     ≥ ≥                        ≥ ≥";„        PRINT "     √ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥"„        PRINT "≥         ≥     ≥ ≥                        ≥ ≥";„        PRINT "     ≥         ≥"„        PRINT "≥         ≥     ≥ ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ ≥";„        PRINT "     ≥         ≥"„        PRINT "≥         ≥     ≥  ˛˛˛            o o  €€€›  ≥";„        PRINT "     ≥         ≥"„        PRINT "≥         ≥     ¿ƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒŸ";„        PRINT "     ≥         ≥"„        PRINT "≥         ≥         ⁄ƒƒƒƒƒŸ        ¿ƒƒƒƒƒø    ";„        PRINT "     ≥         ≥"„        PRINT "≥         ≥⁄ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒ";„        PRINT "ƒƒƒƒø≥         ≥"„        PRINT "≥         ≥≥ ⁄ƒƒƒø                 ƒƒƒ€€€€€€ƒƒ";„        PRINT "ƒƒƒ ≥≥         ≥"„        PRINT "≥         ≥≥ ≥   ≥                  ƒ‹‹‹‹‹‹‹‹ƒ";„        PRINT "    ≥≥         ≥"„        PRINT "≥         ≥≥ ¿ƒƒƒŸ                            ";„        PRINT "    ≥≥         ≥"„        PRINT "≥         √¥                                  ";„        PRINT "    √¥         ≥"„        PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ";„        PRINT "ƒƒƒƒŸ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ";„„        K$ = ""„        DO UNTIL K$ <> ""„„            K$ = INKEY$„„            RandC = INT(RND(1) * 15 + 1)        ' Groovy light show„            RandX = INT(RND(1) * 12 + 1)„            RandY = INT(RND(1) * 4 + 1)„„            COLOR RandC„„            LOCATE 10 + RandY, 40 + RandX„            PRINT "˛";„            LOCATE 10 + RandY, 41 - RandX„            PRINT "˛";„            LOCATE 11 - RandY, 40 + RandX„            PRINT "˛";„            LOCATE 11 - RandY, 41 - RandX„            PRINT "˛";„„            IF PEEK(Offset) = 0 THEN EXIT DO   ' Check for end„                                               ' of music file„        LOOP„        '******************************************************„„„        '********* Stop music *********************************„        iReg.bx = 7„        InterruptX &H80, iReg, oReg„        '******************************************************„„„        '********* Reset driver *******************************„        iReg.bx = 8„        InterruptX &H80, iReg, oReg„        '******************************************************„„        DEF SEG„„        COLOR 7, 0„„        END„„                                          „„Unknown Author(s)              30 WACKY MUSIC SAMPLES         kwmelvin@nr.infi.net           09-09-95 (17:17)       QB, QBasic, PDS        171  4011     MUSICSAM.BASCLS„PRINT "Press a key after each tune to continue."„PRINT "Press Ctrl-Break to exit"„„PRINT "playing... 1 Mull of Kintyre (sort of)"„    PLAY "l4t200mlo1go2cde..p16msemledcdco1ap48go2cde..p16msemledcd.d"„    PLAY "p32l4t200mlo1go2cde2ceo2dcdefgegfdo1bo2c..mn"„SLEEP„„PRINT "playing... 2 Coda"„    PLAY "l8t192o1cp32cl4p32cd#l8gp32gap32al4gl2d"„SLEEP„„PRINT "playing... 3 You gotta join."„    PLAY "mbl8t255o2efeg..efeg..efeg.o3c.o2b.a.egmf"„SLEEP„„PRINT "playing... 4 You're in the army now."„    PLAY "mbl8t255mso2ea.o3co2b.ae.p8ea.o3co2b.ao3emfmn"„SLEEP„„PRINT "playing... 5 Dead March from 'Saul'"„    PLAY "l8t200mlo1c..p16c.p32cp32c.p8e..dp32d.cp32c.o0bo1c..mn"„SLEEP„„PRINT "playing... 6 Pink Panther theme."„    PLAY "o2t120l16mbmsel4f.l16el4bl16t100ef.eb.de.db.ao2l4b.l8"„    PLAY "t240gabagemn"„SLEEP„„PRINT "playing... 7 Cheerful interludes."„    PLAY "o2l8t255egaageddbcaageccaao3bagfeecco2l4msg..cmn"„„    PLAY "o2l8t255gfeddefggfeddefgffddccl4t180f"„„    PLAY "o2t255l8eefefeefgfedfeedcbggfedccp8o3cc"„SLEEP„„PRINT "playing... 8 Tippy -toe."„    PLAY "o2t255l24cccp32fffp64eeep64gggfffp64aaao3p64cccc"„SLEEP„„PRINT "playing... 9 In the Hall of the Mountain King."„    PLAY "o2l4t240;defgafaa;a-ea-a-ge-gg;defgafa;o3dc;o2afa;o3c..p16"„SLEEP„„PRINT "playing...10 Pack up your troubles."„    PLAY "o3t255l6cp16l8cp16l16dl8co2b-ab-o3l4cl8ap8l4agl2fdc"„SLEEP„„PRINT "playing...11 Rule Britannia."„„    PLAY "o3l6t120gt240ga-a-p4t180l8gt180a-gfe-l2dp16l5a+g+l17gfg+fa+"„    PLAY "l16g+gfe-"„SLEEP„„PRINT "playing...12 Silly SoftWare Theme"„„    PLAY "l8t255o3bo4cdo3bo4co3abgaf#t120gbt200dp8t255o4cdecdo3bo4co3abg"„    PLAY "t120f#at200dp8t255ef#gdef#gef#g#aef#g#ag#abo4co3bo4cdeco3af#gd"„    PLAY "gbt120g"„SLEEP„„PRINT "playing...13 I know an Old Lady."„„    PLAY "t200o2l8cffaffcl10ff.p64al4fl8gggl4gl8feccl4cl8cl4dl8el3f"„SLEEP„„PRINT "playing...14 Hoop-La!"„„    PLAY "t240o3l8d#fgl8b-p8l8gl2b-"„SLEEP„„PRINT "playing...15 For (s)he's a jolly good fellow."„„    PLAY "t240o3l8gfl4el8eedel3fl4el8el4dl8ddcdl3el4cl8dl4e"„    PLAY "l8eedel4fl8gl4al8al4gl8fl4el8dl4c"„SLEEP„„PRINT "playing...16 Heigh-ho, said Rowley."„„    PLAY "t255o2l8fl4b-l8b-l4fl8fdcdo1l4b-p8o2l3b-o3l4dl8o2b-ao3l4c"„SLEEP„„PRINT "playing...17 Dragnet."„„    PLAY "t255o2l2cl8dd#p8cp8l2f#"„SLEEP„„PRINT "playing...18 Oh my darling, Clementine."„„    PLAY "t255o2l8ggl4gdl8bbl4bgl8gbo3l4ddl8co2bl2al8abo3l4cc"„    PLAY "o2l8bal4bgl8bgl4adl8f#al4g"„SLEEP„„PRINT "playing...19 The Wedding March."„„    PLAY "t240o2l8ggl2gp8l8gggl2gp8l8gggl4bl8bbbl4bl8bbbo3l4dl8ddd"„    PLAY "l4dl8dddl2gl3f#l8c#l4edco2agl8f#gl4al8gal4g"„SLEEP„„PRINT "Sound Effects..............................................."„„PRINT "playing...20 Assorted Warbles...."„„    PLAY "l64t120o3deg#f#ggc#d#edc#ccaa#g#fc#"„„    PLAY "t255l16o1abeo2fda"„„    PLAY "t255l16o2df#eg#a"„„    PLAY "l62o4t250dggdg#aao3dggdaa#a#o2dggda#bb"„„    PLAY "mll32o2t255egfd#d#cccc#gc#mn"„SLEEP„„PRINT "playing...21 Success."„„    PLAY "l8o2t240d..e.p16mlagb."„SLEEP„„PRINT "playing...22 Failure (dirge)."„„    PLAY "t200o3l4gcdel2fl4ecl2dp64dl4el1c"„SLEEP„„PRINT "playing...23 Slither."„„    PLAY "t255l15o1adcefao2defaec"„SLEEP„„PRINT "playing...24 Discords...."„„    PLAY "t255l24o1aaao2bbbo3ccco4dddo5eeeo4dddo3ccco2bbbo1aaa"„„    PLAY "t255l16o2cbacbacbacbacbacba"„„    PLAY "t255o2l16adadadadadadad"„SLEEP„„PRINT "playing...25 Ascending Trill."„„    PLAY "t255o1l15deffedo2deffedo3deffedo4deffedo5deffed"„SLEEP„„PRINT "playing...26 Descending Trill."„„    PLAY "o4l12t255ba#ag#gf#fed#dc#c"„SLEEP„„PRINT "playing...27 Up and Down."„„    PLAY "t32l64o2cdefgabagfedcdefgabagfed"„SLEEP„„PRINT "playing...28 Plunk!"„„    PLAY "t255l16o1fo4d#o2fc"„SLEEP„„PRINT "playing...29 Plonk!"„„    PLAY "t255l16o1bo4dg#o2f"„SLEEP„„PRINT "playing...30 Spangle."„„    PLAY "O5 L8 T120 F F F F B F B F B F B F B F B F"„END„„„Mike Huff                      MIDI CODE FOR THE SBSIM        FidoNet QUIK_BAS Echo          03-23-96 (00:04)       QB, PDS                28   998      MIDI.BAS    'Here's some of the MIDI code for the SBSIM (Sound Blaster Simplified Interface„'Module) driver. It plays in the background (of course).„'Make sure to load SBMIDI.EXE first then load SBSIM.COM next.„'Ohh, and also make sure SBSIM say driver using interrupt 81h or whatever, but„'make sure you see an "81h" when you load SBSIM or your machine will probably„'crash. This code can easily be modified to play CMFs, VOCs, and can be used to„'control the mixer.„„' $INCLUDE: 'QB.BI'„DIM InRegs AS RegType, OutRegs AS RegType„Filename$ = "JAZZ.MID" + CHR$(0) 'make ASCIIZ string„„' this initializes the driver and loads the MIDI.„InRegs.ax = SADD(Filename$)„InRegs.bx = 0 + 5 * 256„InRegs.dx = VARSEG(Filename$)„Interrupt &H81, InRegs, OutRegs„IF NOT OutRegs.ax THEN PRINT "MIDI sucessfully started!"„„' this starts playing the MIDI.„InRegs.bx = 1 + 5 * 256„Interrupt &H81, InRegs, OutRegs„„SLEEP„„' this stops the MIDI.„InRegs.bx = 2 + 5 * 256„Interrupt &H81, InRegs, OutRegs„Dave Navarro, Jr.              PB .WAV PLAYER                 www.powerbasic.com/source      03-27-96 (00:00)       PB                     107  3757     PLAYWAVE.BAS'=============================================================================„'                   Source code snippet: PowerBASIC for DOS„'„' Original found at http://www.fys.ruu.nl/~bergmann/basic.html„' converted to PowerBASIC by Dave Navarro, Jr.„' additional work by unknown author on CompuServe„'„' Play wave files through the SoundBlaster.„'„'=============================================================================„„DEFINT A-Z„„MaxTicks& = 1193180„SHARED WritePort%, MaxTicks&„„'-Div.Init (maybe you get the filename from command line?„CLS„FILES ("*.WAV")„INPUT "Select Wave File"; VocFile$„VocFile% = FREEFILE„„'-open the voc-file„OPEN VocFile$ FOR BINARY AS #VocFile%„„TestPort$ = ENVIRON$("BLASTER")„IF TestPort$ > "" THEN„  PortAddress$ = "&H" + MID$(TestPort$, 2, 3)„  PortAddress = VAL(PortAddress$)„  WritePort = PortAddress + 12„ELSE„  WritePort = &H22C„END IF„„'-parameters for copy-to-soundblaster„Bytes& = LOF(VocFile%)                 'number of bytes„X$ = SPACE$(40) 'riff file header stuff„GET #VocFile, , X$„Speed = ASC(MID$(X$, 26, 1)) * 256 OR ASC(MID$(X$, 25, 1))„„'Playrate in Bytes per second.„'We are assuming an 8 bit *.Wav File Here„' And my 386-16 will hang in there at 11025 BPS under DOS„Clocks = MaxTicks& \ Speed 'using an integer divide. Close enough„                           'and doesn't pull in floating point math pack„                           'Maxticks are for the "normal" PC Clock at„                           '18.206 + ticks per second.„                           'We'll use this to time the play rate.„Bytes& = Bytes& - 40„BytesRemaining& = Bytes&               'number of remaining bytes„BufferMax% = &H3F00                    'largest buffer„Buffer$ = SPACE$(BufferMax%)           'create buffer„SetVoice 1                             'Soundblaster on„„'-read {BufferMax%} bytes from disc, output on SB„DO„  BytesRemaining& = BytesRemaining& - BufferLen%„  IF BytesRemaining& = 0 THEN EXIT DO  'nothing left over?„  IF BytesRemaining& > BufferMax% THEN 'how many bytes?„    BufferLen% = BufferMax%„  ELSE„    BufferLen% = BytesRemaining&       'remaining (<BufferMax%)..„    Buffer$ = SPACE$(BufferLen%)       '..throw it into SB :-)„  END IF„„  GET #VocFile%, , Buffer$             'read buffeer„  T = 0„  DEF SEG = STRSEG(Buffer$)„  K = STRPTR(Buffer$)„  OUT &H43, &H34 'PIT Timer select one shot then we can let the„  OUT &H40, 0  'clock keep up.„  OUT &H40, 0  ' set the clock to 0 and start the count down„  Rate& = 65536 - Clocks 'First count down stopping value„                         ' "zero" - Rate„  DO             'output od {bufferlen%}„     Char = PEEK(K + T)„     WAIT WritePort, &H80, &HFF             'wait for data-ready„     OUT WritePort, &H10„     WAIT WritePort, &H80, &HFF„     OUT WritePort, Char 'Direct DAC method„     T = T + 1„     DO„      C& = (INP(&H40) + INP(&H40) * 256&) 'check the ticker„    LOOP UNTIL C& <= Rate& 'end if it's at or below the ticks we alloted„    Rate& = Rate& - Clocks„    IF Rate& < 0 THEN„        OUT &H40, 0  'reset the ticker to 0„        OUT &H40, 0  'both bytes„        Rate& = 65536 - Clocks  'Reset the Rate& value„    END IF„  LOOP UNTIL T = BufferLen 'This is faster than a for next loop„  OUT &H43, 4„LOOP UNTIL Forever„SetVoice 0                             'SB off„CLOSE #VocFile%                        'close file„END                                    '.. good bye :-)„„' Turns Speaker on and off„SUB SetVoice (OnOff%)„  IF OnOff% THEN„    WAIT WritePort%, &H80, &HFF             'wait for data-ready on SB„    OUT WritePort%, &HD1 'ON„  ELSE„    WAIT WritePort%, &H80, &HFF„    OUT WritePort%, &HD3 'OFF„  END IF„END SUB„Mike Huff                      BACKGROUND WAV/VOC PLAY/RECORD MHuff@gnn.com                  03-30-96 (23:48)       QB, QBasic, PDS, VBDOS 377  10169    DMAPLAY.BAS ' DMA Play„' By Mike Huff (1996)„' Audio file player that plays using the DMA channels.„' Runs in QBASIC, QuickBASIC, PDS, VBDOS, and even GW-BASIC!!! (If you add„' line numbers and remove the SUBs, FUNCTIONS, and do a few other things.)„' Use DMADone% to detect the end of a transfer.„' Tested on a 486DX4-120mHz with a Reveal Sound FX card.„DECLARE FUNCTION SpeakerStatus% ()„DECLARE FUNCTION DMAStatus% ()„DECLARE FUNCTION DMADone% ()„DECLARE FUNCTION ResetDSP% ()„DECLARE SUB FMVolume (Right%, Left%, Getvol%)„DECLARE SUB VocVolume (Right%, Left%, Getvol%)„DECLARE SUB MasterVolume (Right%, Left%, Getvol%)„DECLARE SUB MicVolume (Gain%, Getvol%)„DECLARE SUB LineVolume (Right%, Left%, Getvol%)„DECLARE SUB CDVolume (Right%, Left%, Getvol%)„DECLARE SUB InputSource (InputSrc%, GetSrc%)„DECLARE SUB WriteDSP (byte%)„DECLARE SUB SetStereo (OnOff%)„DECLARE FUNCTION ReadDSP% ()„DECLARE SUB WriteDAC (byte%)„DECLARE SUB SpeakerState (OnOff%)„DECLARE SUB DMAState (StopGo%)„DECLARE FUNCTION ReadDAC% ()„DECLARE SUB DMAPlay (Segment&, Offset&, Length&, Freq&)„DECLARE SUB DMARecord (Segment&, Offset&, Length&, Freq&)„DECLARE SUB GetBLASTER (DMA%, BasePort%, IRQ%)„DECLARE FUNCTION DSPVersion! ()„COMMON SHARED BasePort%, LenPort%, Channel%„„CLS„PRINT "DMAPlay"„PRINT "By Mike Huff"„PRINT "The first background WAV/VOC/etc player/recorder in BASIC I've ever seen"„PRINT "Use freely"„PRINT "Comments, etc. can be sent to MHuff@gnn.com or on FidoNet in the QUIK_BAS echo"„GetBLASTER Channel%, BasePort%, IRQ% ' Parses BLASTER environment„PRINT STRING$(80, 196)„IF ResetDSP% THEN 'resets DSP (returns true if sucessful)„   PRINT "DSP reset sucessfully!"„ELSE„   PRINT "DSP failed to reset, try another port."„END IF„„SpeakerState 1 'turn the speaker on„PRINT "Sound Card DSP version:"; DSPVersion!„„MasterVolume Right%, Left%, -1 'this puts the mixer volumes in Right% and Left%„PRINT "Master volume is set at: Right-"; Right%; " Left-"; Left%„MasterVolume 15, 15, 0 'this cranks the master volume all the way up.„„DIM WavBuffer(1 TO 1) AS STRING * 32767 'Make a 32k buffer for file.„INPUT "WAV/VOC/SND file to play: ", Filename$„OPEN Filename$ FOR BINARY AS #1„GET #1, 44, WavBuffer(1) 'Get 32k from file (skip header on WAV)„„Length& = LOF(1) - 44„IF Length& > 32767 THEN Length& = 32767 'Adjust length if needed to 32k„„INPUT "Frequency to play at: (1000-41000Hz)", Freq&„DMAPlay VARSEG(WavBuffer(1)), VARPTR(WavBuffer(1)), Length&, Freq&„„'Use DMARecord to record in the background.„'and use DMAPlay to playback the same buffer you recorded to or you could„'even write the buffer to a file.„'DMARecord VARSEG(WavBuffer(1)), VARPTR(WavBuffer(1)), Length&, Freq&„„DO„COLOR RND * 15„PRINT "Check it out! It's playing in the background!"„LOOP UNTIL DMADone%„„CLS„COLOR 7„PRINT "DMA transfer completed!"„„SUB CDVolume (Right%, Left%, Getvol%)„OUT BasePort% + 4, &H28„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   Right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (Right% + Left% * 16) AND &HFF„END IF„END SUB„„FUNCTION DMADone%„Count% = INP(LenPort%)„Count2% = INP(LenPort%)„Count& = CLNG(Count% + 1) * CLNG(Count2% + 1)„IF (Count& - 1) >= &HFFFF& THEN junk% = INP(DSPDataAvail%): DMADone% = -1„END FUNCTION„„SUB DMAPlay (Segment&, Offset&, Length&, Freq&)„' Transfers and plays the contents of the buffer.„Length& = Length& - 1„Page% = 0„MemLoc& = Segment& * 16 + Offset&„SELECT CASE Channel%„    CASE 0„       PgPort% = &H87„       AddPort% = &H0„       LenPort% = &H1„       ModeReg% = &H48„    CASE 1„       PgPort% = &H83„       AddPort% = &H2„       LenPort% = &H3„       ModeReg% = &H49„    CASE 2„       PgPort% = &H81„       AddPort% = &H4„       LenPort% = &H5„       ModeReg% = &H4A„    CASE 3„       PgPort% = &H82„       AddPort% = &H6„       LenPort% = &H7„       ModeReg% = &H4B„    CASE ELSE„       PRINT "DMA channels 0-3 only are supported."„       EXIT SUB„END SELECT„„OUT &HA, &H4 + Channel%„OUT &HC, &H0„OUT &HB, ModeReg%„OUT AddPort%, MemLoc& AND &HFF„OUT AddPort%, (MemLoc& AND &HFFFF&) \ &H100„IF (MemLoc& AND 65536) THEN Page% = Page% + 1„IF (MemLoc& AND 131072) THEN Page% = Page% + 2„IF (MemLoc& AND 262144) THEN Page% = Page% + 4„IF (MemLoc& AND 524288) THEN Page% = Page% + 8„OUT PgPort%, Page%„OUT LenPort%, Length& AND &HFF„OUT LenPort%, (Length& AND &HFFFF&) \ &H100„OUT &HA, Channel%„„IF Freq& < 23000 THEN„   TimeConst% = 256 - 1000000 \ Freq&„   WriteDSP &H40„   WriteDSP TimeConst%„   WriteDSP &H14„   WriteDSP (Length& AND &HFF)„   WriteDSP ((Length& AND &HFFFF&) \ &H100)„ELSE„   IF DSPVersion! >= 3 THEN„      TimeConst% = ((65536 - 256000000 \ Freq&) AND &HFFFF&) \ &H100„      WriteDSP &H40„      WriteDSP TimeConst%„      WriteDSP (Length& AND &HFF)„      WriteDSP ((Length& AND &HFFFF&) \ &H100)„      WriteDSP &H91„   ELSE„      PRINT "You need a Sound Blaster with a DSP v3.x+ to play at high speed."„      EXIT SUB„   END IF„END IF„END SUB„„SUB DMARecord (Segment&, Offset&, Length&, Freq&)„Length& = Length& - 1„MemLoc& = Segment& * 16 + Offset&„Page% = 0„SELECT CASE Channel%„    CASE 0„       PgPort% = &H87„       AddPort% = &H0„       LenPort% = &H1„       ModeReg% = &H44„    CASE 1„       PgPort% = &H83„       AddPort% = &H2„       LenPort% = &H3„       ModeReg% = &H45„    CASE 2„       PgPort% = &H81„       AddPort% = &H4„       LenPort% = &H5„       ModeReg% = &H46„    CASE 3„       PgPort% = &H82„       AddPort% = &H6„       LenPort% = &H7„       ModeReg% = &H47„    CASE ELSE„       EXIT SUB„END SELECT„„OUT &HA, &H4 + Channel%„OUT &HC, &H0„OUT &HB, ModeReg%„OUT AddPort%, MemLoc& AND &HFF„OUT AddPort%, (MemLoc& AND &HFFFF&) \ &H100„IF (LongByte& AND 65536) THEN Page% = Page% + 1„IF (LongByte& AND 131072) THEN Page% = Page% + 2„IF (LongByte& AND 262144) THEN Page% = Page% + 4„IF (LongByte& AND 524288) THEN Page% = Page% + 8„OUT PgPort%, Page%„OUT LenPort%, Length& AND &HFF„OUT LenPort%, (Length& AND &HFFFF&) \ &H100„OUT &HA, Channel%„„IF Freq& <= 23000 THEN„   TimeConst% = 256 - 1000000 \ Freq&„   WriteDSP &H40„   WriteDSP TimeConst%„   WriteDSP &H24„   WriteDSP (Length& AND &HFF)„   WriteDSP ((Length& AND &HFFFF&) \ &H100)„ELSE„   IF DSPVersion! >= 3 THEN„      TimeConst% = ((65536 - 256000000 / Freq&) AND &HFFFF&) \ &H100„      WriteDSP &H40„      WriteDSP TimeConst%„      WriteDSP (Length& AND &HFF)„      WriteDSP ((Length& AND &HFFFF&) \ &H100)„      WriteDSP &H99„   ELSE„      PRINT "You need a Sound Blaster with a DSP 3.x+ to record at high speed."„      EXIT SUB„   END IF„END IF„„END SUB„„SUB DMAState (StopGo%)„' Stops or continues DMA play.„IF StopGo% THEN WriteDSP &HD4 ELSE WriteDSP &HD0„„END SUB„„FUNCTION DSPVersion!„' Gets the DSP version.„WriteDSP &HE1„Temp% = ReadDSP%„Temp2% = ReadDSP%„DSPVersion! = VAL(STR$(Temp%) + "." + STR$(Temp2%))„END FUNCTION„„SUB FMVolume (Right%, Left%, Getvol%)„OUT BasePort% + 4, &H26„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   Right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (Right% + Left% * 16) AND &HFF„END IF„END SUB„„SUB GetBLASTER (DMA%, BasePort%, IRQ%)„' This subroutine parses the BLASTER environment string and returns settings.„IF LEN(ENVIRON$("BLASTER")) = 0 THEN PRINT "BLASTER environment variable not set.": EXIT SUB„FOR Length% = 1 TO LEN(ENVIRON$("BLASTER"))„   SELECT CASE MID$(ENVIRON$("BLASTER"), Length%, 1)„      CASE "A"„        BasePort% = VAL("&H" + MID$(ENVIRON$("BLASTER"), Length% + 1, 3))„      CASE "I"„        IRQ% = VAL(MID$(ENVIRON$("BLASTER"), Length% + 1, 1))„      CASE "D"„        DMA% = VAL(MID$(ENVIRON$("BLASTER"), Length% + 1, 1))„   END SELECT„NEXT„„END SUB„„SUB InputSource (InputSrc%, GetSrc%)„OUT BasePort% + 4, &HC„IF GetSrc% THEN„   InputSrc% = INP(BasePort% + 5) AND 2 + INP(BasePort% + 5) AND 4„ELSE„   OUT BasePort% + 5, InputSrc% AND 7„END IF„END SUB„„SUB LineVolume (Right%, Left%, Getvol%)„OUT BasePort% + 4, &H2E„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   Right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (Right% + Left% * 16) AND &HFF„END IF„END SUB„„SUB MasterVolume (Right%, Left%, Getvol%)„OUT BasePort% + 4, &H22„'PRINT BasePort%„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   Right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (Right% + Left% * 16) AND &HFF„END IF„END SUB„„SUB MicVolume (Volume%, Getvol%)„OUT BasePort% + 4, &HA„IF Getvol% THEN„   Volume% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, Volume% AND &HF„END IF„END SUB„„FUNCTION ReadDAC%„' Reads a byte from the DAC.„WriteDSP &H20„ReadDAC% = ReadDSP%„„END FUNCTION„„FUNCTION ReadDSP%„' Reads a byte from the DSP„DO„LOOP UNTIL INP(BasePort% + 14) AND &H80„ReadDSP% = INP(BasePort% + 10)„END FUNCTION„„FUNCTION ResetDSP%„' Resets the DSP„OUT BasePort% + 6, 1„FOR Count% = 1 TO 4„   junk% = INP(BasePort% + 6)„NEXT„OUT BasePort% + 6, 0„IF INP(BasePort% + 14) AND &H80 = &H80 AND INP(BasePort% + 10) = &HAA THEN„   ResetDSP% = -1„ELSE„   ResetDSP% = 0„END IF„END FUNCTION„„SUB SetStereo (OnOff%)„OUT BasePort% + 4, &HE„IF OnOff% THEN OUT BasePort% + 5, 2 ELSE OUT BasePort% + 5, 0„END SUB„„SUB SpeakerState (OnOff%)„' Turns speaker on or off.„IF OnOff% THEN WriteDSP &HD1 ELSE WriteDSP &HD3„END SUB„„FUNCTION SpeakerStatus%„OUT BasePort% + 4, &HD8„IF INP(BasePort% + 5) = &HFF THEN SpeakerStatus% = -1 ELSE SpeakerStatus% = 0„END FUNCTION„„SUB VocVolume (Right%, Left%, Getvol%)„OUT BasePort% + 4, &H4„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   Right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (Right% + Left% * 16) AND &HFF„END IF„END SUB„„SUB WriteDAC (byte%)„' Writes a byte to the DAC.„WriteDSP &H10„WriteDSP byte%„END SUB„„SUB WriteDSP (byte%)„' Writes a byte to the DSP„DO„LOOP WHILE INP(BasePort% + 12) AND &H80„OUT BasePort% + 12, byte%„END SUB„Andrew Jones                   SOUND BLASTER OSCILLISCOPE     FidoNet QUIK_BAS Echo          04-14-96 (14:48)       QB, QBasic, PDS        88   1619     SBOSCILL.BAS'And here's my sound blaster oscilliscope.„„DEFINT A-Z„CLS„COLOR 9„PRINT "NanoSoft Osci-Trip"„COLOR 15„PRINT "Sound Blaster routines by Gary Maddox, obtained from SB-Digest Issue #5"„PRINT„ BPORT = &H210„ XPORT = &H216„ WPORT = &H21C„ RPORT = &H21A„ APORT = &H21E„ READY = &HAA„DO„   OUT XPORT, 1„ „   FOR t = 0 TO 10„   ll! = TIMER„   DO„   LOOP WHILE ll! = TIMER„   NEXT„   OUT XPORT, 0„   loopctr = 0„   DO„     byte = INP(RPORT)„     loopctr = loopctr + 1„   IF byte = &HAA THEN EXIT DO„   IF loopctr > 100 THEN EXIT DO„   LOOP„   IF byte <> &HAA THEN„     BPORT = BPORT + &H10„     XPORT = XPORT + &H10„     WPORT = WPORT + &H10„     RPORT = RPORT + &H10„ „     APORT = APORT + &H10„   END IF„ IF byte = &HAA THEN EXIT DO„ IF RPORT = &H270 THEN EXIT DO„ LOOP„ „ IF BPORT = &H270 THEN„   PRINT "Sound Blaster Not Found!"„   STOP„ ELSE„   PRINT "Sound Blaster Installed at Port:"; HEX$(BPORT)„ END IF„  PRINT "Press a key, press escape to quit."„  DO„  LOOP UNTIL LEN(INKEY$)„  SCREEN 13„  ext = FALSE„FOR t = 0 TO 199„LINE (0, t)-(319, t), t„NEXT„FOR x = 0 TO 319 STEP 40„FOR y = 0 TO 199 STEP 40„FOR v = 0 TO 20„CIRCLE (x + 20, y + 20), v, 200 - (v + y)„CIRCLE (x + 21, y + 20), v, 200 - (v + y)„NEXT„NEXT„NEXT„ „DO„    OUT &H3C8, 1„    FOR t = 1 TO 200 STEP 10„    OUT WPORT, &H20„ „byte = INP(RPORT)„FOR x = 0 TO 10„OUT &H3C9, byte + (x * 6)„OUT &H3C9, (byte + (x * 6)) \ 2„OUT &H3C9, (byte + (x * 6)) \ 4„NEXT„NEXT„ „IF INKEY$ = CHR$(27) THEN ext = 1„'lastbyte = byte„LOOP UNTIL ext„SCREEN 0„WIDTH 80„CLS„PRINT "Bye."„END„„Daniel Minty                   SOUND AFFECTS                  bminty@agso.gov.au             04-23-96 (07:15)       QB, QBasic, PDS        131  3150     SAFFECTS.BAS'Sound Effects„'Mostly made by Daniel Minty e-mail:  bminty@agso.gov.au„'OR home page: (http://wsite.com/Daniel/index.html)„CLS„PRINT "0"„0 PLAY "MBO0L32EFGEFDC"„SLEEP„PRINT "1"„1 PLAY "T120L16MLO3BF#"„SLEEP„PRINT "2"„2 PLAY "T255L64MLO4BAGFEDC<BAGFEDEC<BAGFEDC<BAGFEDC<BAGFEDC"„SLEEP„PRINT "3"„3 PLAY "T255L32O4mlDGD<G>DGDDGDGBAGF#EE"„SLEEP„PRINT "4"„4 PLAY "T255L64MLO2BCADGEFEGDACBCADGEFEGDACB"„SLEEP„PRINT "5"„5 PLAY "T255L64MLO3BCADGEFEGDACBCADGEFEGDACB"„SLEEP„PRINT "6"„6 PLAY "T255L64MLO4BCADGEFEGDACBCADGEFEGDACB"„SLEEP„PRINT "7"„7 PLAY "T255L64MLO5BCADGEFEGDACBCADGEFEGDACB"„SLEEP„PRINT "8"„8 PLAY "T150L64MSO4BGEC<AFL16D"„SLEEP„PRINT "9"„9 PLAY "T150L64MSO4BFC<GD<AL16E"„SLEEP„PRINT "10"„10 PLAY "T150L64MSO4BE<AD<GC<L32F"„SLEEP„PRINT "11"„11 PLAY "T150L64MSO3DFA>CEGL16B"„SLEEP„PRINT "12"„12 PLAY "T120L64MSO2E.A.>D.G.>C.F.B."„SLEEP„PRINT "13"„13 PLAY "T150L64MSO0F>CG>DA>EB."„SLEEP„PRINT "14"„14 PLAY "T240L64MLO4EGEGEGCFCFCFGEGEGE"„SLEEP„PRINT "15"„15 PLAY "T255L64O4CDEFGABO3CDEFGABO2CDEFGAB"„SLEEP„PRINT "16"„16 PLAY "T255L64MLO1BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„SLEEP„PRINT "17"„17 PLAY "T255L64MLO2BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„SLEEP„PRINT "18"„18 PLAY "T255L64MLO3BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„SLEEP„PRINT "19"„19 PLAY "T255L64MLO4BAGFEDC<BAGFEDCP16>CDEFGAB>CDEFGABP32"„SLEEP„PRINT "20"„20 PLAY "T255L64MLO1CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„SLEEP„PRINT "21"„21 PLAY "T255L64MLO2CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„SLEEP„PRINT "22"„22 PLAY "T255L64MLO3CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„SLEEP„PRINT "23"„23 PLAY "T255L64MLO4CDEFGAB>CDEFGABP16<BAGFEDC<BAGFEDCP32"„SLEEP„PRINT "24"„24 PLAY "T120L16O4C#.P16T255L64mlC#DD#EFF#GG#AA#BO5CC#DD#EF"„SLEEP„PRINT "25"„25 PLAY "T255L32mlO3CD<CD>>CD<<CD>>CD<<CD>CD"„SLEEP„PRINT "26"„26 PLAY "T240L64MLO4EGEGEGEGEGEGEGEGEGEGEGEGEGEGEG"„SLEEP„PRINT "27"„27 PLAY "O4T255L64MLB-BB-BAGAG.>EGG>EGG"„SLEEP„PRINT "28"„28 PLAY "T200L64MLO4C#DD#EFF#GG#AA#B>CC#DD#EFP8.<C#DD#EFF#GG#AA#B>CC#DD#EFED#DC#"„SLEEP„PRINT "29"„29 PLAY "T255L64MsO4C#DD#EFF#GG#AA#B>CC#DD#EF"„SLEEP„PRINT "30"„30 PLAY "MBO0L32EFGEFDC"„SLEEP„PRINT "31"„31 PLAY "MBO2l32abebcfdfg"„SLEEP„PRINT "32"„32 PLAY "T120L16O4C#.P16T255L64mlC#DD#EFF#GG#AA#BO5CC#DD#EF#T120L16O4C.P16T255L64mlCDDEFFGGAABO5CCDDEF"„SLEEP„PRINT "33"„33 PLAY "T2553L64MSO4CDDEFFGGAABCCDDEF"„SLEEP„PRINT "34"„34 PLAY "T240L64MLO4CECECECECECECADADADADADADADADADFGFGFGFGFGFGFG"„SLEEP„PRINT "35"„35 PLAY "T2553L64MSO4CDEFGACDEFGACDEFGACDEFGACDEFGACDEFGACDEFGA"„SLEEP„PRINT "36"„36 PLAY "T240L64MLO4CECECECECECECECECECP2CECECECECECECECECECP1ECECECCECECECECECECP2CECECECECECECECECEC"„SLEEP„PRINT "37"„37 PLAY "T255L64MLO3ABCDEFG<ABCDEFG<ABCDEFG<ABCDEFG<ABCDEFG<ABCDEFG"„SLEEP„PRINT "38"„38 PLAY "T255L64MLO3ABCDEFGFEDCBABCDEFGFEDCBABCDEFGFEDCBABCDEFGFEDCBABCDEFGFEDCBA"„SLEEP„PRINT "39"„39 PLAY "MBO0L32cdcdcdcdcdcdcdcdcdcdcd"„SLEEP„PRINT "40"„40 PLAY "O4T255L64MLaaaabbbbccccddddeeeeffffggggffffeeeeddddccccbbbbaaaa"„SLEEP„PRINT "41"„41 PLAY "T255L32mlO3abcdefgabcdefgabcdefgabcdefgabcdefgabcdefg"„SLEEP„„Ryan White                     MUSIC MAKER                    BIGFOOT@SunBelt.Net            02-19-96 (15:01)       QB, QBasic, PDS        74   2350     MUSICMAK.BASCLS„SCREEN 0„LOCATE 15, 25„y = 4„lopear:„SCREEN 0„COLOR 4, 0„CLS„LOCATE 1, 25: PRINT "RYAN'S "„LOCATE 2, 5: PRINT "**      **     **     **      *****     ******      *****"„LOCATE 3, 5: PRINT "** **** **     **     **     **           **       **   **"„LOCATE 4, 5: PRINT "**  **  **     **     **      ****        **       **"„LOCATE 5, 5: PRINT "**  **  **      *** ***          **       **       **   **"„LOCATE 6, 5: PRINT "**      **       *****        *****     ******      *****"„LOCATE 17, 18: PRINT "PRESS ANY WHITE KEY TO MAKE MUSIC"„LOCATE 23, 20: PRINT "PRESS <SPACE> TO QUIT"„DO„   USER.KEY$ = INKEY$„   SELECT CASE UCASE$(USER.KEY$)„      CASE "1": PLAY "O0 L16 A"„      CASE "2": PLAY "O0 L16 B"„      CASE "3": PLAY "O0 L16 C"„      CASE "4": PLAY "O0 L16 D"„      CASE "5": PLAY "O0 L16 E"„      CASE "6": PLAY "O0 L16 F"„      CASE "7": PLAY "O0 L16 G"„      CASE "8": PLAY "O1 L16 A"„      CASE "9": PLAY "O1 L16 B"„      CASE "0": PLAY "O1 L16 C"„      CASE "-": PLAY "O1 L16 D"„      CASE "=": PLAY "O1 L16 E"„      CASE "\": PLAY "O1 L16 F"„      CASE "Q": PLAY "O1 L16 G"„      CASE "W": PLAY "O2 L16 A"„      CASE "E": PLAY "O2 L16 B"„      CASE "R": PLAY "O2 L16 C"„      CASE "T": PLAY "O2 L16 D"„      CASE "Y": PLAY "O2 L16 E"„      CASE "U": PLAY "O2 L16 F"„      CASE "I": PLAY "O2 L16 G"„      CASE "O": PLAY "O3 L16 A"„      CASE "P": PLAY "O3 L16 B"„      CASE "[": PLAY "O3 L16 C"„      CASE "]": PLAY "O3 L16 D"„      CASE "A": PLAY "O3 L16 E"„      CASE "S": PLAY "O3 L16 F"„      CASE "D": PLAY "O3 L16 G"„      CASE "F": PLAY "O4 L16 A"„      CASE "G": PLAY "O4 L16 B"„      CASE "H": PLAY "O4 L16 C"„      CASE "J": PLAY "O4 L16 D"„      CASE "K": PLAY "O4 L16 E"„      CASE "L": PLAY "O4 L16 F"„      CASE ";": PLAY "O4 L16 G"„      CASE "'": PLAY "O5 L16 A"„      CASE "Z": PLAY "O5 L16 B"„      CASE "X": PLAY "O5 L16 C"„      CASE "C": PLAY "O5 L16 D"„      CASE "V": PLAY "O5 L16 E"„      CASE "B": PLAY "O5 L16 F"„      CASE "N": PLAY "O5 L16 G"„      CASE "M": PLAY "O6 L16 A"„      CASE ",": PLAY "O6 L16 B"„      CASE ".": PLAY "O6 L16 C"„      CASE "/": PLAY "O6 L16 D"„      CASE "`": PLAY "L16 ABCDEFGFEDCBA"„      CASE " ": EXIT DO„END SELECT„„x = INT(RND * 14) + 1„PALETTE y, x„x = y„LOOP UNTIL (UCASE$(USER.KEY$) = " ")„„Mervyn Baldwin                 PLAY LARGE .WAV FILES          comp.lang.basic.misc           06-08-96 (17:33)       QB, QBasic, PDS        78   2702     WAVPLAY.BAS 'Some time ago somebody posted here (or alt.basic) a program which „'played  Ding.WAV in QuickBASIC. Didn't work for bigger files than „'DING and didn't work at all in QBasic. Here's a fix. Plays the „'biggest WAV file I have (almost 2MB) in QBasic.„„'------------------------------------------------------„DECLARE SUB SetVoice (OnOff%)„  CLS„ VocFile$ = "g:\audio\admz9515.WAV"       ' input-file„„'NB a WAV file on CD. Almost 2Mb.„„  VocFile% = FREEFILE„  delay% = 11                      ' value for delay„ OPEN VocFile$ FOR BINARY AS #VocFile%„ Bytes& = LOF(VocFile%)          ' number of bytes„ BytesRemaining& = Bytes&        ' number of remaining bytes „ BufferMax% = 19000             ' largest buffer„„'The maximum buffer size in QBasic is about 19K.„' in QB45 this can be at least &H7F00 bytes (over 32K).„ „  Buffer$ = SPACE$(BufferMax%)    ' create buffer„  SetVoice 1                      ' Soundblaster on„„  DO„     BytesRemaining& = BytesRemaining& - BufferLen%„     IF BytesRemaining& = 0 THEN EXIT DO ' nothing left over?„     IF BytesRemaining& > BufferMax% THEN ' how many bytes?„        BufferLen% = BufferMax%          '„     ELSE„        BufferLen% = BytesRemaining&     ' remaining (<BufferMax%)..„        'Buffer$ = SPACE$(BufferLen%)     ' ..throw it into SB :-)„„'NB line remmed out - works OK without it.„    „     END IF„„     GET #VocFile%, , Buffer$            ' read buffer„     DEF SEG = VARSEG(Buffer$)           ' get address of buffer„     Voff& = SADD(Buffer$)               ' .„„'NB Voff% changed to Voff& throughout  „    „     FOR t% = 1 TO BufferLen%            ' output od {bufferlen%}„         'FOR qq% = 1 TO Delay: NEXT qq% ' delay„         WAIT &H22C, &H80, &HFF         ' wait for data-ready„         OUT &H22C, &H10„         WAIT &H22C, &H80, &HFF„         OUT &H22C, PEEK(Voff&)„         Voff& = Voff& + 1„     NEXT t%„„  LOOP WHILE INKEY$ = ""„„  SetVoice 0                            ' SB off„  CLOSE #VocFile%                       ' close file„  END                                   ' .. good bye :-)„„SUB SetVoice (OnOff%)„    IF OnOff% THEN„       WAIT &H22C, &H80, &HFF       ' wait for data-ready on SB„       OUT &H22C, &HD1              ' ON„    ELSE„       WAIT &H22C, &H80, &HFF„       OUT &H22C, &HD3              ' OFF„    END IF„END SUB„'--------------------------------------------------------„'Apologies to whoever devised this that I have forgotton his name.„'If anybody can figure out how to avoid the occasional hiccup as, I „'guess, the buffer is filled, I would be pleased to hear of it.„„'-- „'Best wishes,„'Mervyn Baldwin.„'vyn@abaldwin.demon.co.uk„„Tony Cave                      MAKE A WAV FILE                FidoNet QUIK_BAS Echo          06-21-96 (22:03)       QB, QBasic, PDS        97   2677     MAKEWAV.BAS 'This program makes WAV files by using formulas for the data„'Run as is, it will create a wave file called MOCK.WAV, but„'you can change it to make whatever sounds you want.„'You must specify the size of the output file.  If you're not„'sure how long it will be then go ahead and run it, and see„'how big it is then run it with the correct FileSize.  Some„'WAV players can't play it if the FileSize is incorrect.„„ID$ = "SOBLA3.BAS (c)1996 by tony cave"„WavFile$ = "mock.wav"„FileSize = 4952                 'in bytes„„DIM RiffID           AS STRING * 4„DIM RiffLength       AS LONG„DIM WavID            AS STRING * 4„DIM FmtID            AS STRING * 4„DIM FmtLength        AS LONG„DIM wavformattag     AS INTEGER„DIM Channels         AS INTEGER„DIM SamplesPerSec    AS INTEGER„DIM BytesPerSec      AS INTEGER„DIM BlockAlign       AS INTEGER„DIM FmtSpecific      AS INTEGER„DIM Padding          AS STRING * 4„DIM DataID           AS STRING * 4„DIM DataLength       AS LONG„„RiffID = "RIFF"                 'must be "RIFF"„RiffLength = FileSize - 8       'FileSize - 8„WavID = "WAVE"                  'must be "WAVE"„FmtID = "fmt "                  'must be "fmt "„FmtLength = 16„wavformattag = 1                '1=PCM„Channels = 1                    '1=stereo, 2=stereo„SamplesPerSec = 11025           '11025 22050 -21436(44100)„BytesPerSec = 0„BlockAlign = 11025„FmtSpecific = 0„Padding = CHR$(1) + CHR$(0) + CHR$(8) + CHR$(0)„                                'only if FmtLength = 16„„DataID = "data"                 'must be "data"„DataLength = FileSize - 44      'FileSize - 44„                                'the header is 44 bytes„OPEN WavFile$ FOR BINARY AS #1„PUT #1, , RiffID„PUT #1, , RiffLength„PUT #1, , WavID„PUT #1, , FmtID„PUT #1, , FmtLength„PUT #1, , wavformattag„PUT #1, , Channels„PUT #1, , SamplesPerSec„PUT #1, , BytesPerSec„PUT #1, , BlockAlign„PUT #1, , FmtSpecific„PUT #1, , Padding„PUT #1, , DataID„PUT #1, , DataLength„„'The following is the formula for my wave, but you don't have to„'use SIN(), you can use anything, even random numbers, but random„'numbers probably won't sound very good.  Have fun!„„ont$ = CHR$(192)„sf$ = CHR$(64)„a$ = " "„t$ = CHR$(128)„„FOR t = 1 TO 60„FOR x = 0 TO 255 STEP t„x$ = CHR$((SIN(x * .0245) + 1) * 64 + 64)„PUT #1, , x$„NEXT„NEXT„„FOR t = 1 TO 60„FOR x = 0 TO 255 STEP t„PUT #1, , t$„NEXT„NEXT„„FOR t = 1 TO 60„FOR x = 0 TO 255 STEP t„x$ = CHR$((SIN(x * .0245) + 1) * 64 + 64)„PUT #1, , x$„NEXT„NEXT„„FOR t = 1 TO 60„FOR x = 0 TO 255 STEP 61 - t„x$ = CHR$((SIN(x * .0245) + 1) * 64 + 64)„PUT #1, , x$„NEXT„NEXT„„SYSTEM„John Fischer                   HAPPY BIRTHDAY SONG            FidoNet QUIK_BAS Echo          07-10-96 (23:52)       QB, QBasic, PDS        7    274      HAPBIRTH.BAS' > I was wondering if you could give some source code for Qbasic that„' > will play "happy birthday"...„„'Happy Birthday to You„PLAY "MNT150L8O4CCL4DCFL2EL8CCL4DCGL2FL8CCL4>C<AFEL2DL8A+A+"„PLAY "L4AFGL2FL8CCL4DCFL2EL8CCL4DCGL2FL8CCL4>C<AFEL2DL8A+A+"„PLAY "L4AFGL2F"„John Fischer                   MORE THEME SONGS               FidoNet QUIK_BAS Echo          07-14-96 (00:47)       QB, QBasic, PDS        61   3127     THEMES.BAS  ' > Do any of you know how to play QUICKBASIC music in the background of a„' > program?„„'I believe that MB in the play statement switches it to BACKGROUND and MF„'switches it to FOREGROUND playing.  Check out your HELP on PLAY.„„' > Also, do any of you got any good QUICKBASIC music with the PLAY„' > command, (Like the Happy Birthday thing I saw)„„REM The Adaams Family Movie Theme„PLAY "MNT200L8O3CDEFP4L4FP8FP8L8DEF+GP4L4O1GP8GP8L8O3DEF+GP4"„PLAY "DEF+GP4CDEFP4L4O1FP8FP8P4L8O3CF.AF.D<A+.>GP4FE.GE.C<A."„PLAY ">FP4CF.AF.D<A+.>GP4FL64EFL8E.CD.EFP4CDEFP4L4FP8FP8L8D"„PLAY "EF+GP4L4O1GP8GP8L8O3DEF+GP4DEF+GP4CDEFP4L4O1FP8FP8P4L8O3C"„PLAY "F.AF.D<A+.>GP4FE.GE.C<A.>FP4CF.AF.D<A+.>GP4FL64EFL8E."„PLAY "CD.EFP4"„„REM Flash Dance Theme„PLAY "MNT150L2O3E.L8DCL2D.L8DEL2F.L8EEEDL2CL8DCL2A.L8GFL2G."„PLAY "L8FGFEL2DL4CL2D.L8CDL2E.L8DCL2D.L8DEL2F.L8EEEDL4CP4L8D"„PLAY "CL2A.L8GFL2G.L8FGFEL4DL8>DCL4CL8DDL2D.P4L4CL8CCP4DDL4D"„PLAY "P4L8<CDL2E.L8DCL4DL2<GL8>DDL2F.L8EDEDL2CL8DCL2A.L8>C<A"„PLAY "L2G.L8FEFEL4DL8>DCL4CP4CDP8L8<GBL4>CCL8C<BL4BL8BAL4AG"„PLAY "L8GBL4>CCL8C<BL4BL8BAL4AGL8GB>CL4CDL8CL4<BL8>CL4C.L8D"„PLAY "L4<GG.P4L8GB>CCL4<AL8>C<BL4BL8BAAAL4>DCL8CCL4<AL8>C<B"„PLAY "L4BL8BAL4AL8GB>CL4C.L8DCL4<BL8>CL4C.L8D<GL4GG>C<BL8BB"„PLAY "AAL4AGL8GBL4>CCL8C<BL4BL8BAL4AGL8GBL4>CCL8C<BL4BL8BAL4A"„PLAY "GL8GBL4>CCL8C<BL4BL8BAL4AGL8GBL1C"„„REM Ave Maria„PLAY "MLT100L16O1A+.>D.F.<A+.>D.F.<A+.>D.F.<A+.>D.F.A+.D.F.<A+.>D.F.<A+.>"„PLAY "D.E.A.D.A+.>D.<D.F.<F.A+.>D.<F.A.>D+.<F.A.O3C.<A+.<A+.>D.<G.A+.>D.<"„PLAY "G.A+.>D.<G.A+.>D.>C.O1G.>C.<D+.G.>C.>DC<A+.C.A.G.C.A.A+.D.F.<A+.>D."„PLAY "F.<A+.>D.F.>D.<D.F.<A+.>D.F+.<A+.O3C.<A+.A.D.G.>D.<D.>E.D.<D.E.<A+."„PLAY ">D.E.>C+.<C+.G.<A.>C+.A.>C.<D+.F+.<A.>D+.A+.A.>C.D.D+.C.<A.A+.D.G.<"„PLAY "A+.>D.G.<A+.>D.E.>D.<D.>C.O1A.>C.F.<A.>C.A.G.B.>D.F.D.<B.>C.<C.F.<A.>"„PLAY "C.F.<A+.>G.A.A+.A.G.F.C.F.<A.>C.F.<A.>C.F.P64F.C.F.>C.O1A.>D+.<F.A."„PLAY "O3C.P64C.O1A.>B.>C.O1A.O3D.C.O1A+.O3D.<A+.<A+.>D.<F.A+.>D.<F.A+.>A+."„PLAY ">C.O1A.>D+.<F.A.O3C.P64C.<B.>C.D+.D.C.<A+.<A+.>D.<G.A+.>D.<G.A+.>D.A+.<"„PLAY "A+.>D.>C.O1A.>C.<F.A.O3C.D.O1A.O3D.P64D.D+.D.C.D.F.<C.D+.>D+.<C.D+.<G."„PLAY ">C.D+.G.C.D+.>D.O1G.>C.>C.O1G.O3C.<A+.A.A+.>C+.C.<A+.>C.O1A.>C.<F.A.>"„PLAY "C.<F.A.>D+.<F.A.>D+.A+.D.F.<A+.>D.F.<A+.>D.E.A.D.A+.>D.O1A+.>D.<F.A+.>"„PLAY "D.<F.A.>D+.<F.A.O3C.<A+.D.F.<A+.>D.F.>D.<D.F.>F.<D.F.L2>A+P4"„„REM Star Trek TOS Theme„PLAY "MNT255L1O4B.D.F.<A.P8L2GL8G>C.L2FFL4E.L8EL4C<A>DL2GP8"„PLAY "L4GL1BP4L2CL8CF.L2A+A+L4A.L8AL4FDGL2>CP8L4CL1EP1L2O3G"„PLAY ">F.L4EDC<BL2A+L1A+L2G>G.L4FEDCL2<BL1BL4A+L2A.L4B>C+DE"„PLAY "F+GL2AL1A+.L2<A+.L4>CDD+FGG+L2A+L1BL2<G>F.L4EDC<BL2A+"„PLAY "L1A+L4G+L2G>G.L4FEDCL2<BL1BL4A+L2A.L4B>CDEFEL2G.L4GL2A+."„PLAY "L4AL2GL1CL4D.F.A.L1>C"„„'I hope these are the type of thing you are looking for.  If you want to„'test out the background command, just add:„„'PLAY "MB"   'before the song and„'PLAY "MF"   'after the song.„„'I have MANY more of these if you are interested.  I didn't write them and„'have absolutely NO idea who did.  I had them in an old ZIP file on archive„'and it doesn't contain any credits in it.„Charles Godard                 FLUTE BOOK MUSIC COLLECTION    FidoNet QUIK_BAS Echo          07-16-96 (00:05)       QB, QBasic, PDS        39   2055     FLUTEMUS.BAS'  >Do any of you know how to play QUICKBASIC music in the background of a„'  >program?„„'I never could figure out how to play more than about 32 notes in the„'background (the best I can remember).  Had to keep looping back ever„'so often to keep it playing in bg... the MB command does it.„„'  >Also, do any of you got any good QUICKBASIC music with the PLAY command,„'  >(Like the Happy Birthday thing I saw)„„'I copied these from a flute book, and played with the tempo, octaves,etc.„„REM ABC SONG:„PLAY "O3 l4ccggaal2g l4ffeel8ddddl2c l4ggffee l2dl8ggl4gffeel2d l4ccggaal2g l4ffee l4dd l2c"„„REM BINGO:„  PLAY "mb O3 L8GGDDEEDDGGAAL4BGBBL8>CCL4C<AAL8BBL4BGGL8AAAGF+DEF+L4GG"„REM SWEET BETSY FROM PIKE:„  PLAY "T220 O3  L4CCEGGFDDCCL2CL4CCEG>CCC<BGG L2G L4G  >CCC <BGEFGA L2G L8CD L4EEE GFD DCCL3C" '1st time thru song„  PLAY "L8CD L4EEE GFD DCC L2C L8CD L4EEE GFD DCC L2C L4C"  'this line is 1st CHORUS„  PLAY "O3  L4CEGGFDDCCL2CL4CCEG>CCC<BGG L2G L4G  >CCC <BGEFGA L2G L8CD L4EEE GFD DCCL3C"  '2nd time thru song„  PLAY "L8CD L4EEE GFD DCC L2C L8CD L4EEE GFD  L4DCCL2C"    '2nd time thur CHORUS„REM shortnin' bread :„ PLAY "T120 O3 <L4F>L8DDL4CD<L8FF>L4DL2CL4<F>DCL8DD<L8AAL4GFN0 "„ PLAY "T180 O4 < F >L8DDL4CD <F> DL2C <L4F >DL8CCL4D <AGF>N0"„ PLAY "T200 O5 <L8FF> DD CC L4D <F> DCD   L8<FF>DDCC L4D <AGFN0"„ PLAY "T250 O5 <L8FF>DDCCL4D<F>DCD L8<FF>DDCCL4D <AGFN0"„REM down at the station:„ PLAY "T 180 O3 L4G L8GA L4BB L8AG AB L4GG L8BB B>CDDDDC<B>CD<L2B"„ PLAY "O3 L8 GGGAL4BBL8AGABL4GG GG>DD <AB> <L2G"„REM Jingle Bells:„ PLAY "T150 O3 L8BBL4BL8BBL4BL8B>D<GAL2B L8>CCCCC<BBBBAABL4A>D<"„ PLAY "O3 L8BBL4BL8BBL4BL8B>D<GAL2B L8>CCCCC<BBB>DDC<AL2G"„REM merrily we roll along:„ PLAY "T 200 O3 L4BAGABBL2BL4AAL2AL4BBL2BL4BAGABBL2BL4AABAL1G"„ PLAY "T 200 O3 L4BAGABBL2BL4AAL2AL4BBL2BL4BAGABBL2BL4AABAL1G"„REM MICHAEL, ROW THE BOAT ASHORE:„ PLAY "O3 L4FA MS L2ML>C<L8AL8>CDL2CL4<A>CL1DL2CL4<A>CMS L2MLC<L8A> L4C<AL2GL4FGL2AGF"„ PLAY "O3 L4 FA MS L2ML>C<L8AL8>CDL2CL4<A>CL1DL2CL4<A>CMS L2MLC<L8A> L4C<AL2GL4FGL2AGF"„John Fischer                   PLAY MUSICAL HELPER            FidoNet QUIK_BAS Echo          07-17-96 (20:51)       QB, QBasic, PDS        319  10518    PLAYHELP.BAS'  > paid any attention to the PLAY syntax.  Now I've been looking around„'  > and I find an alarming paucity of available programs written to show„'  > off the PLAY function, so I'm contributing this one as a public„'  > service: „„'I agree, and although sound cards are much better, PLAY *IS* a part of QB„'(either flavor).  Here's a hastily written (and I mean HASTY) chuck of code„'that anyone is welcome to PLAY with.  BASICally, it will give you a very„'generic menu and let you input play commands into a buffer (sort of) and„'then play them back for you, save them, etc..  I have NOT put an editor„'into it, and probably won't, since I was just wanting to get more familiar„'with PLAY.  One last thing, I forgot that the . (period) after a note DOES„'make it a dotted note, even though that is NOT in the help section,„'therefore, I did not code for it.  IF anyone plays with this and makes„'something of it, all I ask is for a copy it to poke around in.  The„'following is original and by posting it here I release it to the public„'domain. „„DECLARE FUNCTION Music$ (A$)„CLEAR„ON ERROR GOTO Ooops„IF COMMAND$ = "" THEN„     FileName$ = "MUSIC.SND"„     ELSE FileName$ = COMMAND$„END IF„OPEN FileName$ FOR OUTPUT AS #1„CONST F1 = 59, F2 = 60, F3 = 61, F4 = 62, F10 = 68„Null$ = CHR$(0)„Temp$ = "O3 L4 T120 MN "„L = 4: O = 3: T = 120: T$ = " 7/8"„TopMenu:„CLS : COLOR 11„PRINT , "Input Keys to Play", "F10 = Help/Other Keys"„PRINT : COLOR 15„PRINT , "A - G)  Corresponding Note"„PRINT , "+ / -)  PREVIOUS Note SHARP or FLAT"„PRINT , "L)  Set Length of NEXT Notes (1-64)"„PRINT , "N)  Play a Note by it's Number (0-84)"„PRINT , "O)  Set Octave of NEXT Notes (0-6)"„PRINT , "P)  Pause for n ¨ Notes"„PRINT , "T)  Set # of ¨ Notes/Minute (32-255)"„PRINT , "< or > DOWN or UP 1 Octave"„PRINT , "1, 3, 7) Each Note FULL, 3/4, 7/8"„PRINT : COLOR 13„PRINT , "F1)  Play Your Tune", "F3) List Your Tune"„PRINT , "F2)  Start Over", "F4) PRINT Your Tune"„PRINT : COLOR 12„PRINT , "ESC)  Save and End Program"„COLOR 14„LOCATE 5, 53: PRINT L„LOCATE 7, 53: PRINT O„LOCATE 9, 53: PRINT T„LOCATE 11, 53: PRINT T$„COLOR 7„GetChoice: CHOICE$ = INKEY$„SELECT CASE UCASE$(CHOICE$)„     CASE IS = "/"„          CLS : SHELL: GOTO TopMenu„     CASE IS = "*"„          CLS : SHELL "LIST": GOTO TopMenu„     CASE IS = "`"„          CLS : SHELL "MUSIC.BAT": GOTO TopMenu„     CASE IS = "1"„          Temp$ = Music$("ML")„          T$ = " Full ML"„          GOTO TopMenu„     CASE IS = "3"„          Temp$ = Music$("MS")„          T$ = " 3/4 MS"„          GOTO TopMenu„     CASE IS = "7"„          Temp$ = Music$("MN")„          T$ = " 7/8 MN"„          GOTO TopMenu„     CASE IS = "A"„          Temp$ = Music$("A")„     CASE IS = "B"„          Temp$ = Music$("B")„     CASE IS = "C"„          Temp$ = Music$("C")„     CASE IS = "D"„          Temp$ = Music$("D")„     CASE IS = "E"„          Temp$ = Music$("E")„     CASE IS = "F"„          Temp$ = Music$("F")„     CASE IS = "G"„          Temp$ = Music$("G")„     CASE IS = "<"„          Temp$ = Music$("<")„          O = O - 1„          IF O < 0 THEN O = 0„          IF O > 6 THEN O = 6„          GOTO TopMenu„     CASE IS = ","„          Temp$ = Music$("<")„          O = O - 1„          IF O < 0 THEN O = 0„          IF O > 6 THEN O = 6„          GOTO TopMenu„     CASE IS = ">"„          Temp$ = Music$(">")„          O = O + 1„          IF O < 0 THEN O = 0„          IF O > 6 THEN O = 6„          GOTO TopMenu„     CASE IS = "."„          Temp$ = Music$(">")„          O = O + 1„          IF O < 0 THEN O = 0„          IF O > 6 THEN O = 6„          GOTO TopMenu„     CASE IS = "+"„          Temp$ = Music$("+")„     CASE IS = "-"„          Temp$ = Music$("-")„     CASE IS = "L"„          LOCATE 18, 20: PRINT "Range: 1 - 64"„          LOCATE 19, 20: INPUT "Length"; A„          IF A < 1 OR A > 64 THEN A = 4„          L = A„          Temp$ = Music$("L" + RTRIM$(LTRIM$(STR$(A))))„          GOTO TopMenu„     CASE IS = "N"„          LOCATE 18, 20: PRINT "Range: 0 - 84"„          LOCATE 19, 20: INPUT "Note"; A„          IF A < 0 OR A > 84 THEN A = 4„          Temp$ = Music$("N" + RTRIM$(LTRIM$(STR$(A))))„          GOTO TopMenu„     CASE IS = "O"„          LOCATE 18, 20: PRINT "Range: 0 - 6"„          LOCATE 19, 20: INPUT "Octave"; A„          IF A < 0 OR A > 6 THEN A = 0„          O = A„          Temp$ = Music$("O" + RTRIM$(LTRIM$(STR$(A))))„          GOTO TopMenu„     CASE IS = "P"„          LOCATE 18, 20: PRINT "Range: 1 - 64"„          LOCATE 19, 20: INPUT "Pause Time"; A„          IF A < 1 OR A > 64 THEN A = 4„          Temp$ = Music$("P" + RTRIM$(LTRIM$(STR$(A))))„          GOTO TopMenu„     CASE IS = "T"„          LOCATE 18, 20: PRINT "Range: 32 - 255"„          LOCATE 19, 20: INPUT "¨ Notes/Minute"; A„          IF A < 32 OR A > 255 THEN A = 120„          T = A„          Temp$ = Music$("T" + RTRIM$(LTRIM$(STR$(A))))„          GOTO TopMenu„     CASE IS = Null$ + CHR$(F1)„          IF LEN(Temp$) > 0 THEN PRINT #1, Temp$„          Temp$ = "": CLOSE #1„          OPEN FileName$ FOR INPUT AS #1„          LOCATE 18„          DO UNTIL EOF(1)„               LINE INPUT #1, X$„               PRINT X$„               'PLAY "MB" + X$„               PLAY X$„          LOOP„          CLOSE #1„          OPEN FileName$ FOR APPEND AS #1„          COLOR 15„          PRINT : PRINT "Press the SPACEBAR to resume"„          COLOR 7„          SLEEP„          DO UNTIL INKEY$ = "": LOOP„          GOTO TopMenu„     CASE IS = Null$ + CHR$(F2)„          Temp$ = "O3 L4 T120 MN "„          CLOSE #1„          OPEN FileName$ FOR OUTPUT AS #1„          LOCATE 18, 20„          COLOR 15„          PRINT "All Music Cleared"„          COLOR 7„          SLEEP 1„          L = 4: O = 3: T = 120: T$ = " 7/8"„          GOTO TopMenu„     CASE IS = Null$ + CHR$(F3)„          IF LEN(Temp$) > 0 THEN PRINT #1, Temp$„          Temp$ = ""„          CLOSE #1„          OPEN FileName$ FOR INPUT AS #1„          LOCATE 18„          DO UNTIL EOF(1)„               LINE INPUT #1, X$„               PRINT X$„          LOOP„          CLOSE #1„          OPEN FileName$ FOR APPEND AS #1„          COLOR 15„          PRINT : PRINT "Press the SPACEBAR to resume"„          COLOR 7„          SLEEP„          DO UNTIL INKEY$ = "": LOOP„          GOTO TopMenu„     CASE IS = Null$ + CHR$(F4)„          IF LEN(Temp$) > 0 THEN PRINT #1, Temp$„          Temp$ = ""„          CLOSE #1„          OPEN FileName$ FOR INPUT AS #1„          OPEN "PRN" FOR OUTPUT AS #2„          DO„               LINE INPUT #1, X$„               PRINT #2, X$„          LOOP UNTIL EOF(1)„          PRINT #2, ""„          CLOSE #2„          CLOSE #1„          OPEN FileName$ FOR APPEND AS #1„          GOTO TopMenu„     CASE IS = Null$ + CHR$(F10)„          CLS„          COLOR 14„          PRINT„          PRINT , "T20  = 1/2 time", "T40 = 2/2 time"„          PRINT , "T80  = 2/4 time", "T120 = 3/4 time"„          PRINT , "T160 = 4/4 time", "T240 = 6/8 time"„          PRINT„          PRINT , "L1 = Whole Note", "L2 = Half Note"„          PRINT , "L4 = Quarter Note", "L8 = Eighth Note"„          PRINT , "L16 = Sixteenth Note", "L32 = Thirty-Second Note"„          PRINT„          PRINT , "Octave: Higher the number, higher the pitch"„          PRINT„          COLOR 3„          PRINT , "Other MAIN MENU Commands Available"„          PRINT , "` Run file MUSIC.BAT if it exists"„          PRINT , "~ create MUSIC_QB.BAS (PLAYable)"„          PRINT , "* Run LIST"„          PRINT , "/ DOS Shell"„          COLOR 15„          PRINT : PRINT , "Press the SPACEBAR to continue"„          COLOR 7„          SLEEP„          DO UNTIL INKEY$ = "": LOOP„          CLS„          COLOR 14„          PRINT , "Central Octave Chart"„          COLOR 2„          PRINT„          PRINT , "                     B"„          PRINT , "                  ƒƒ A ƒƒ"„          PRINT , "                     G"„          PRINT , "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ F ƒƒƒƒƒƒƒ   Octave #4"„          PRINT , "                     E"„          PRINT , "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ D ƒƒƒƒƒƒƒ"„          PRINT , "                     C"„          COLOR 10„          PRINT , "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ B ƒƒƒƒƒƒƒƒƒƒƒƒ"„          PRINT , "                A"„          PRINT , "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ G ƒƒƒƒƒƒƒƒƒƒƒƒ"„          PRINT , "                F                Octave #3"„          PRINT , "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ E ƒƒƒƒƒƒƒƒƒƒƒƒ   (Default)"„          PRINT , "                D"„          PRINT , "             ƒƒ C ƒƒ"„          COLOR 15„          PRINT : PRINT , "You MUST shift octaves to use the entire scale"„          PRINT : PRINT , "Press the SPACEBAR to continue"„          COLOR 7„          SLEEP„          DO UNTIL INKEY$ = "": LOOP„          GOTO TopMenu„     CASE IS = CHR$(27)„          PRINT #1, Temp$„          CLOSE #1„          LOCATE 22„          END„     CASE IS = "~"„          PRINT #1, Temp$: Temp$ = ""„          CLOSE #1„          OPEN FileName$ FOR INPUT AS #1„          OPEN "MUSIC_QB.BAS" FOR OUTPUT AS #2„          PRINT #2, "CLS : CLEAR"„          PRINT #2, "PLAY " + CHR$(34) + "MB" + CHR$(34)„          PRINT #2, "'The Above line switches to BACKGROUND playing"„          DO UNTIL EOF(1)„               LINE INPUT #1, Bas$„               IF Bas$ <> "" THEN„                    Bas1$ = "PRINT " + CHR$(34) + Bas$ + CHR$(34)„                    Bas2$ = "PLAY " + CHR$(34) + Bas$ + CHR$(34)„                    PRINT #2, Bas1$„                    PRINT #2, Bas2$„               END IF„          LOOP„          PRINT #2, "PLAY " + CHR$(34) + "MF" + CHR$(34)„          PRINT #2, "'The Above line switches back to FOREGROUND playing"„          PRINT #2, "END"„          CLOSE #2„          CLOSE #1„          OPEN FileName$ FOR APPEND AS #1„     CASE ELSE„          GOTO GetChoice„END SELECT„GOTO GetChoice„LOCATE 22„END„Ooops:„COLOR 7„CLS„CLOSE„OPEN "MUSIC.ERR" FOR APPEND AS #1„PRINT #1, TIME$, DATE$, ERR„CLOSE #1„PRINT : PRINT "An error has occured: #"; ERR„PRINT "See file MUSIC.ERR for QB4.5 error number"„END„„FUNCTION Music$ (Add$)„SHARED Temp$„Kill$ = "ABCDEFG"„IF INSTR(Kill$, Add$) > 0 THEN„     Temp$ = Temp$ + Add$„     ELSE Temp$ = Temp$ + Add$„          IF LEN(Temp$) >= 50 THEN PRINT #1, Temp$: Temp$ = ""„END IF„Music$ = Temp$„END FUNCTION„Lloyd Chang                    ADLIB SOUND EFFECTS            FidoNet QUIK_BAS Echo          08-05-96 (18:39)       QB, QBasic, PDS        358  12335    ADLIBFX.BAS ' > Anyway,  I really need to get adlib sound into my Qb4.5 programs. „„'I hope ADLIB.BAS will help.  It's included at the bottom of this„'message.„„'As to making your own sound effects (in non-mathematical form),„'I have not yet figured out how to do that.  Tim Truman's„'defender game comes with six sound effects.  Perhaps you want„'to examine those first.„„'Just in case you want to contact Tim Truman, his AOL account„'is "Tim Truman" and his Compuserve address is "74734,2203"„„'I have not contacted him yet but the addresses should still„'work since his Defender game was written in 1995 and revised„'in 1996.„„'I believe you can also reach him via the internet through his„'Compuserve address (but I don't really know how Compuserve„'converts its user addresses into Internet addresses).„„'------------------------------ CUT HERE ------------------------------„„'ADLIB.BAS„'Written by Lloyd Chang„„'ADLIB.BAS is meant to provide„'a skeleton to the use of an adlib„'sound effects in QuickBASIC„„'.---------.„'| NOTICE: |„'`---------'„'The functions, sub-routines, and adlib detection„'are stripped from Defender, a QuickBASIC game„'written by Tim Truman (based on the Defender„'game on the Atari 2600).„„DECLARE FUNCTION adlib ()               ' detects presence of adlib„DECLARE SUB WriteReg (reg, value)       ' write to adlibs registers„DECLARE SUB adlibfx (num)               ' plays the sounds„„DEFINT A-Z„„IF adlib THEN„  adlibsound = TRUE„  PRINT "Adlib detected"„  SLEEP (1)„END IF„„adlibfx (0)„SLEEP 1„adlibfx (1)„SLEEP 2„adlibfx (0)„SLEEP 3„adlibfx (1)„SLEEP 4„adlibfx (0)„SLEEP 5„adlibfx (1)„SLEEP 6„„DEFSNG A-Z„FUNCTION adlib„„  '  Detects an AdLib-compatible card.„  '  Returns 1 (true) if detected and 0 (false) if not.„  „ „   CALL WriteReg(&H4, &H60)  '  Resets both Timers„   CALL WriteReg(&H4, &H80)  '  Enables Interrupts„   b = INP(&H388)            '  Store the result„   CALL WriteReg(&H2, &HFF)  '  Write FFh to register 2 (Timer 1)„   CALL WriteReg(&H4, &H21)  '  Start Timer 1„„   FOR x = 0 TO 130          '  Delay for 80 Microseconds„      a = INP(&H388)„   NEXT x„„   c = INP(&H388)                 '  Store the result„   CALL WriteReg(&H4, &H60)       '  Reset Timers„   CALL WriteReg(&H4, &H80)       '  Reset Interrrupts„   Success = 0„   IF (b AND &HE0) = &H0 THEN     '  Test result„     IF (c AND &HE0) = &HC0 THEN  '  Test Result„       Success = 1„       FOR q = 1 TO &HF5          '  clear registers„         CALL WriteReg(q, 0)„       NEXT q„     END IF„   END IF„   adlib = Success„„„END FUNCTION„„SUB adlibfx (num)„„ SELECT CASE (num)„„ CASE (0)                    '   mutant exploding„„ „   WriteReg &HB0, &H0„   numberl = 60„   numberh = 1„   block = 0„                                 ' Modulator„   CALL WriteReg(&H20, &H0)      ' Multiple - 0 to F„   CALL WriteReg(&H40, &H0)      ' Attenuation Level -  0 to 3F„   CALL WriteReg(&H60, &HA5)     ' Attack: (High byte)    Decay: (Low byte)„   CALL WriteReg(&H80, &H0)      ' Sustain: (High byte)   Release: (Low byte)„   CALL WriteReg(&HE0, &HF0)     ' Waveform select  0 to 3„                                ' Carrier„   CALL WriteReg(&H23, &H0)      ' Multiple  - 0 to F„   CALL WriteReg(&H43, &H0)      ' Attenuation level -  0 to 3F„   CALL WriteReg(&H63, &HA6)     ' Attack: (High byte)   Decay:(low byte)„   CALL WriteReg(&H83, &HAA)     ' Sustain: (High Byte)  Release:(low byte)„   CALL WriteReg(&HE1, &HF0)     ' Waveform select  0 to 3„„   keyon% = &H20„„   Byte = keyon% + (block * 4) + numberh%„„   CALL WriteReg(&HA0, numberl)     ' F-Number(L)  0 to 255„   CALL WriteReg(&HB0, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„„„ CASE 1                 'hero firing„„  WriteReg &HB1, &H0„„  numberl = 230„  numberh = 1„  block = 1„                              ' Modulator„  CALL WriteReg(&H21, &H10)    ' Multiple - 0 to F„  CALL WriteReg(&H41, &H0)    ' Attenuation Level -  0 to 3F„  CALL WriteReg(&H61, &H66)   ' Attack: (High byte)    Decay: (Low byte)„  CALL WriteReg(&H81, &HF6)   ' Sustain: (High byte)   Release: (Low byte)„  CALL WriteReg(&HE1, &HF2)   ' Waveform select  0 to 3„                              ' Carrier„  CALL WriteReg(&H24, &H0)    ' Multiple  - 0 to F„  CALL WriteReg(&H44, &H6)    ' Attenuation level -  0 to 3F„  CALL WriteReg(&H64, &H63)   ' Attack: (High byte)   Decay:(low byte)„  CALL WriteReg(&H84, &HF8)    ' Sustain: (High Byte)  Release:(low byte)„  CALL WriteReg(&HE4, &HF0)   ' Waveform select  0 to 3„„  keyon = &H20„„  Byte = keyon + (block * 4) + (numberh)„„  CALL WriteReg(&HC1, 0)            ' conection„  CALL WriteReg(&HC1, 0)            ' conection„  CALL WriteReg(&HA1, numberl)     ' F-Number(L)  0 to 255„  CALL WriteReg(&HB1, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„„  '  WriteReg &HB1, &H0          ' stop noise„„  '  numberl = 10„  '  numberh = 0„   ' block = 7„                                ' Modulator„  '  CALL WriteReg(&H21, &H3)     ' Multiple - 0 to F„  '  CALL WriteReg(&H41, &H0)    ' Attenuation Level -  0 to 3F„  '  CALL WriteReg(&H61, &H99)   ' Attack: (High byte)    Decay: (Low byte)„  '  CALL WriteReg(&H81, &HFF)   ' Sustain: (High byte)   Release: (Low byte)„  '  CALL WriteReg(&HE1, &HF0)   ' Waveform select  0 to 3„                                ' Carrier„  '  CALL WriteReg(&H24, &H1)    ' Multiple  - 0 to F„  '  CALL WriteReg(&H44, &H0)    ' Attenuation level -  0 to 3F„  '  CALL WriteReg(&H64, &HAD)   ' Attack: (High byte)   Decay:(low byte)„   ' CALL WriteReg(&H84, &H55)   ' Sustain: (High Byte)  Release:(low byte)„  '  CALL WriteReg(&HE4, &HF0)   ' Waveform select  0 to 3„„  '  keyon% = &H20„„  '  Byte = keyon% + (block * 4) + numberh„„  ' CALL WriteReg(&HA1, numberl)     ' F-Number(L)  0 to 255„  ' CALL WriteReg(&HB1, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„„„„ CASE 2                       ' colonist pick up warning„„  WriteReg &HB2, &H0          ' stop noise„„  numberl = 255„  numberh = 3„  block = 2„                              ' Modulator„  CALL WriteReg(&H22, &H3)    ' Multiple - 0 to F„  CALL WriteReg(&H42, &H0)    ' Attenuation Level -  0 to 3F„  CALL WriteReg(&H62, &H5F)   ' Attack: (High byte)    Decay: (Low byte)„  CALL WriteReg(&H82, &HFF)   ' Sustain: (High byte)   Release: (Low byte)„  CALL WriteReg(&HE2, &HF0)   ' Waveform select  0 to 3„                              ' Carrier„  CALL WriteReg(&H25, &H0)    ' Multiple  - 0 to F„  CALL WriteReg(&H45, &H9)    ' Attenuation level -  0 to 3F„  CALL WriteReg(&H65, &H5F)   ' Attack: (High byte)   Decay:(low byte)„  CALL WriteReg(&H85, &HFF)   ' Sustain: (High Byte)  Release:(low byte)„  CALL WriteReg(&HE5, &HF0)   ' Waveform select  0 to 3„„  keyon% = &H20„„  Byte = keyon% + (block * 4) + numberh„„  CALL WriteReg(&HA2, numberl)     ' F-Number(L)  0 to 255„  CALL WriteReg(&HB2, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„„„ CASE 3                         ' mutant converted„    WriteReg &HB3, &H0„„    numberl = 10„    numberh = 0„    block = 5„                                ' Modulator„    CALL WriteReg(&H28, &H5)     ' Multiple - 0 to F„    CALL WriteReg(&H48, &H0)    ' Attenuation Level -  0 to 3F„    CALL WriteReg(&H68, &H99)   ' Attack: (High byte)    Decay: (Low byte)„    CALL WriteReg(&H88, &HFF)   ' Sustain: (High byte)   Release: (Low byte)„    CALL WriteReg(&HE8, &HF0)   ' Waveform select  0 to 3„                                ' Carrier„    CALL WriteReg(&H2B, &H0)    ' Multiple  - 0 to F„    CALL WriteReg(&H4B, &H0)    ' Attenuation level -  0 to 3F„    CALL WriteReg(&H6B, &HAD)   ' Attack: (High byte)   Decay:(low byte)„    CALL WriteReg(&H8B, &H55)   ' Sustain: (High Byte)  Release:(low byte)„    CALL WriteReg(&HEB, &HF0)   ' Waveform select  0 to 3„„    keyon% = &H20„ „    Byte = keyon% + (block * 4) + numberh„„   CALL WriteReg(&HA3, numberl)     ' F-Number(L)  0 to 255„   CALL WriteReg(&HB3, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„„ CASE 4           ' mutant firing„„    WriteReg &HB4, &H0          ' stop noise„„    numberl = 10„    numberh = 0„    block = 1„                                ' Modulator„    CALL WriteReg(&H29, &H5)     ' Multiple - 0 to F„    CALL WriteReg(&H49, &H0)    ' Attenuation Level -  0 to 3F„    CALL WriteReg(&H69, &H87)   ' Attack: (High byte)    Decay: (Low byte)„    CALL WriteReg(&H89, &HFF)   ' Sustain: (High byte)   Release: (Low byte)„    CALL WriteReg(&HE9, &HF0)   ' Waveform select  0 to 3„                                ' Carrier„    CALL WriteReg(&H2C, &H1)    ' Multiple  - 0 to F„    CALL WriteReg(&H4C, &H9)    ' Attenuation level -  0 to 3F„    CALL WriteReg(&H6C, &HA5)   ' Attack: (High byte)   Decay:(low byte)„    CALL WriteReg(&H8C, &H55)   ' Sustain: (High Byte)  Release:(low byte)„    CALL WriteReg(&HEC, &HF0)   ' Waveform select  0 to 3„„    keyon% = &H20„„    Byte = keyon% + (block * 4) + numberh„„   CALL WriteReg(&HA4, numberl)     ' F-Number(L)  0 to 255„   CALL WriteReg(&HB4, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„ „ CASE 5„„   'PRINT " bomer noise"„   WriteReg &HB5, &H0          ' stop noise„„    numberl = 60„    numberh = 1„    block = 2„                                ' Modulator„    CALL WriteReg(&H2A, &H0)    ' Multiple - 0 to F„    CALL WriteReg(&H4A, &H0)    ' Attenuation Level -  0 to 3F„    CALL WriteReg(&H6A, &H55)   ' Attack: (High byte)    Decay: (Low byte)„    CALL WriteReg(&H8A, &HAA)   ' Sustain: (High byte)   Release: (Low byte)„    CALL WriteReg(&HEA, &HF3)   ' Waveform select  0 to 3„                                ' Carrier„    CALL WriteReg(&H2D, &H0)    ' Multiple  - 0 to F„    CALL WriteReg(&H4D, &H0)    ' Attenuation level -  0 to 3F„    CALL WriteReg(&H6D, &HFF)   ' Attack: (High byte)   Decay:(low byte)„    CALL WriteReg(&H8D, &HAA)   ' Sustain: (High Byte)  Release:(low byte)„    CALL WriteReg(&HED, &HF3)   ' Waveform select  0 to 3„„„   CALL WriteReg(&HC5, 1)            ' conection„„   keyon% = &H20„„   Byte = keyon% + (block * 4) + numberh„„   CALL WriteReg(&HA5, numberl)     ' F-Number(L)  0 to 255„   CALL WriteReg(&HB5, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„„„  CASE 6„„   WriteReg &HB4, &H0„   numberl = 130„   numberh = 0„   block = 0„                                 ' Modulator„   CALL WriteReg(&H29, &H0)      ' Multiple - 0 to F„   CALL WriteReg(&H49, &H0)      ' Attenuation Level -  0 to 3F„   CALL WriteReg(&H69, &HA5)     ' Attack: (High byte)    Decay: (Low byte)„   CALL WriteReg(&H89, &H0)      ' Sustain: (High byte)   Release: (Low byte)„   CALL WriteReg(&HE9, &HF0)     ' Waveform select  0 to 3„                                ' Carrier„   CALL WriteReg(&H2C, &H0)      ' Multiple  - 0 to F„   CALL WriteReg(&H4C, &H0)      ' Attenuation level -  0 to 3F„   CALL WriteReg(&H6C, &HA6)     ' Attack: (High byte)   Decay:(low byte)„   CALL WriteReg(&H8C, &H55)     ' Sustain: (High Byte)  Release:(low byte)„   CALL WriteReg(&HEC, &HF0)     ' Waveform select  0 to 3„„   keyon% = &H20„„   Byte = keyon% + (block * 4) + numberh%„„   CALL WriteReg(&HA4, numberl)     ' F-Number(L)  0 to 255„   CALL WriteReg(&HB4, Byte)     ' Sound voice ,Set block ,Set F-Number(H)„„„„ END SELECT„„END SUB„„SUB WriteReg (reg, value)„„' Writes to AdLib's registers the delays required when writing to these„' ports are present.„'„' Reg is the register to write to. Value is the data to send.„„„OUT &H388, reg     '  388h = Register/Status port„                   '  Tells the SB what register we want to write to„„                   '  Calling the register port 6 times creates an„                   '  accurate delay of 3.3ms. This delay is required„FOR x = 0 TO 5     '  after writing to the register port.„   a = INP(&H388)„NEXT x„„OUT &H389, value   '  389h = data port„                   '  send data that corrisponds with the requested register.„„                   '  Calling the data port 35 times creates an„                   '  accurate delay of 23ms. This delay is required.„FOR x = 0 TO 34    '  after writing to the data port.„   a = INP(&H388)„NEXT x„„„END SUB„borg953@aol.com                PLAY ADLIB                     comp.lang.basic.misc           08-04-96 (22:16)       QB, QBasic, PDS        158  5401     PADLIB.BAS  'You say you wanted SoundBlaser code?  I've written a SUB that works with„'an AdLib-compatible speaker.  I think a SoundBlaster works too (at least,„'mine does).  It is very easy to use.  It uses the same command string that„'the PLAY command does.  The only difference is that at the top of your„'program you have to do a„„CALL PlayAdLib("{INIT}")„„'to set the variables.  Here's the code:„„SUB PlayAdLib (comand$)„  STATIC tempo, length, music, octave„„  IF comand$ = "{INIT}" THEN„    tempo = 120„    length = 4„    music = 7 / 8„    octave = 4„    EXIT SUB„  END IF„„  comand$ = UCASE$(comand$)„  FOR i% = 0 TO 224„    WriteReg i%, 0 'Clear all registers„  NEXT i%„  WriteReg &H20, &H1 'Plays carrier note at specified octave ch. 1„  WriteReg &H23, &H1 'Plays modulator note at specified octave ch. 1„  WriteReg &H40, &H1F 'Set carrier total level to softest ch. 1„  WriteReg &H43, &H0 'Set modulator level to loudest ch. 1„  WriteReg &H60, &HE4 'Set carrier attack and decay ch. 1„  WriteReg &H63, &HE4 'Set modulator attack and decay ch. 1„  WriteReg &H80, &H9D 'Set carrier sustain and release ch. 1„  WriteReg &H83, &H9D 'Set modulator sustain and release ch. 1„ „  c% = 1„  max% = LEN(comand$)„  WHILE c% <= max%„    x$ = MID$(comand$, c%, 1): c% = c% + 1    'extract subcommand„    IF INSTR("ABCDEFG", x$) <> 0 AND (c% <> max% AND INSTR("+#-", MID$(comand$, c%, 1))) THEN„      x$ = x$ + MID$(comand$, c%, 1): c% = c% + 1„      IF RIGHT$(x$, 1) = "+" THEN x$ = LEFT$(x$, 1) + "#"„      IF x$ = "D-" THEN x$ = "C#"„      IF x$ = "E-" THEN x$ = "D#"„      IF x$ = "G-" THEN x$ = "F#"   'convert all flats into equivalent sharps„      IF x$ = "A-" THEN x$ = "G#"„      IF x$ = "B-" THEN x$ = "A#"„    ELSEIF x$ = "O" THEN„      adj% = VAL(MID$(comand$, c%, 1)): c% = c% + 1„      IF adj% >= 0 AND adj% <= 6 THEN octave = adj%„    ELSEIF x$ = "<" AND octave > 0 THEN„      octave = octave - 1„    ELSEIF x$ = ">" AND octave < 6 THEN„      octave = octave + 1„    ELSEIF x$ = "L" THEN„      num$ = ""„      WHILE INSTR("0123456789", MID$(comand$, c%, 1))„        num$ = num$ + MID$(comand$, c%, 1): c% = c% + 1„      WEND„      IF VAL(LTRIM$(num$)) >= 1 AND VAL(LTRIM$(num$)) <= 64 THEN length = VAL(LTRIM$(num$))„    ELSEIF x$ = "P" THEN„      dotfac = 1„      num$ = ""„      WHILE INSTR("0123456789", MID$(comand$, c%, 1))„        num$ = num$ + MID$(comand$, c%, 1): c% = c% + 1„      WEND„      WHILE MID$(comand$, c%, 1) = "."„        dotfac = dotfac * 1.5: c% = c% + 1„      WEND„      IF VAL(num$) >= 1 AND VAL(num$) <= 64 THEN„        start! = TIMER„        ender! = start! + (((1 / VAL(num$)) * dotfac) * ((tempo / 120) * 2) * music)„        DO„        LOOP UNTIL TIMER >= ender!  'start! + (1 / VAL(num$))„      END IF„    ELSEIF x$ = "M" THEN„      next$ = MID$(comand$, c%, 1): c% = c% + 1„      x$ = x$ + next$„      IF x$ = "MN" THEN music = 7 / 8„      IF x$ = "MS" THEN music = 3 / 4„      IF x$ = "ML" THEN music = 1„„    END IF„    IF INSTR("ABCDEFG", LEFT$(x$, 1)) THEN„      dotfac = 1„      WHILE MID$(comand$, c%, 1) = "."„        dotfac = dotfac * 1.5: c% = c% + 1„      WEND„      SELECT CASE x$„      CASE "C#"„        WriteReg &HA0, &H6B                 'Set note number„        WriteReg &HB0, &H21 + 4 * octave    'Set octave and turn on voice„      CASE "D"„        WriteReg &HA0, &H81„        WriteReg &HB0, &H21 + 4 * octave„      CASE "D#"„        WriteReg &HA0, &H98„        WriteReg &HB0, &H21 + 4 * octave„      CASE "E"„        WriteReg &HA0, &HB0„        WriteReg &HB0, &H21 + 4 * octave„      CASE "F"„        WriteReg &HA0, &HCA„        WriteReg &HB0, &H21 + 4 * octave„      CASE "F#"„        WriteReg &HA0, &HE5„        WriteReg &HB0, &H21 + 4 * octave„      CASE "G"„        WriteReg &HA0, &H2„        WriteReg &HB0, &H22 + 4 * octave„      CASE "G#"„        WriteReg &HA0, &H20„        WriteReg &HB0, &H22 + 4 * octave„      CASE "A"„        WriteReg &HA0, &H41„        WriteReg &HB0, &H22 + 4 * octave„      CASE "A#"„        WriteReg &HA0, &H63„        WriteReg &HB0, &H22 + 4 * octave„      CASE "B"„        WriteReg &HA0, &H87„        WriteReg &HB0, &H22 + 4 * octave„      CASE "C"„        WriteReg &HA0, &HAE„        WriteReg &HB0, &H22 + 4 * (octave - 1)„      END SELECT„      start! = TIMER„      ender! = start! + (((1 / length) * dotfac) * ((tempo / 120) * 2) * music)„      DO„      LOOP UNTIL TIMER >= ender!  '(start! + (1 / length))„      WriteReg &HB0, 0„    END IF„  WEND„END SUB„„SUB WriteReg (reg AS INTEGER, value AS INTEGER)„                      '&H is QBASIC hexadecimal prefix„  OUT &H388, reg      '&H388 is AdLib register/status port„                      'tells what register to write to„ „  FOR c% = 0 TO 5     'reading hardware port 6 times creates manditory 3.3 ms„    a% = INP(&H388)   'delay„  NEXT c%„„  OUT &H389, value    '&H389 is AdLib data port„                      'sends data to the register specified above„                     „  FOR c% = 0 TO 34    'reading reg/stat port 35 times creates manditory„    a% = INP(&H388)   '23 ms delay„  NEXT c%„END SUB„„'(The WriteReg SUB is needed for PlayAdLib to work.)„„'I have a few other SUBs on my WWW site.  The address is in my signature.„'Glad I could help.„„'- Borg953@aol.com„'  http://home.aol.com/Borg953„Tony Cave                       BOTTLES OF BEER ON THE WALL FidoNet QUIK_BAS Echo          08-13-96 (20:58)       QB, QBasic, PDS        25   786      BEER.BAS    'Here's something for your computer to do when it gets bored.„„CLS„song$ = "l8T255<<n25n25n25p8n20n20n20p8n25n25n25n25p8n24n25n26"„song$ = song$ + "n27n27n27p8n22n22n22n27p8n27n25p8n24p8n22p8"„song$ = song$ + "n24p8n24p8n24p8p8p8n24n24n24n24p8p8p8p8n20n20n20p8"„song$ = song$ + "n22n22n24p8n25n25n25n25"„up$ = "p8n20n22n24"„DO„FOR x = 99 TO 1 STEP -1„CLS„LOCATE RND * 22 + 1, 1„PRINT x; "bottles of beer on the wall,"; x; "bottles of beer."„PRINT " Take one down; pass it around. ";„IF x - 1 <> 0 THEN PRINT x - 1;  ELSE PRINT " No ";„PRINT "bottles of beer on the wall."„PLAY song$„IF x - 1 <> 0 THEN PLAY up$„a$ = INKEY$: IF a$ <> "" THEN SYSTEM„NEXT„CLS : LOCATE 1, 1„PRINT "One more time"„SLEEP 2&: m$ = INKEY$„IF m$ <> "" THEN DO: LOOP UNTIL m$ <> ""„LOOP„Kurt Eckhardt                  SOUND BLASTER PIANO            king@shadow.net                08-20-96 (00:00)       QB, QBasic, PDS        332  11389    SBPIANO.BAS 'Coded by Kurt Eckhardt 08/20/96„'The graphics are sketchy, but this program was designed more for example„'that anything else. Try Decay rates of 0-5, they sound best.„„'I have a generic sound card and the program seems to work fine.„'However, tested on a friends computer who has a true SBpro, produced mixed„'results (actually it sounded like crap). Sorry if it doesn't work on your„'Cpu, but it is Version 1.0„„DEFINT A-Z„DECLARE SUB legal ()„DECLARE SUB info ()„DECLARE SUB pressakey ()„DECLARE SUB Menu ()„DECLARE SUB SBDrum (num%)„DECLARE SUB SBPlay (channel%, n$, Octa%)„DECLARE SUB WriteReg (Reg%, value%)„DECLARE SUB InitCard ()„DECLARE SUB Scale ()„DECLARE SUB pause (secs!)„DECLARE SUB center (text$, row!)„DECLARE FUNCTION offset1% (channel%)„DECLARE FUNCTION offset2% (channel%)„DECLARE FUNCTION DetectCard% ()„DECLARE FUNCTION note% (n$)„CONST StatusP = &H388            'Status port„CONST DataP = &H389              'Data port„CONST TRUE = 1„DIM SHARED tst, vst„DIM SHARED dcay„„CLS : CALL info„CALL legal: CLS„IF DetectCard = TRUE THEN„   PRINT "We have a soundcard!"„ELSE„   PRINT "Go buy yourself a soundcard!"„   SYSTEM: END„END IF„PRINT "Initalizing Card...": InitCard„PRINT "Ok"„PRINT "Press any key to continue": pressakey„„CALL Menu„„'Make sure all registers are cleared before closing„CALL WriteReg(&HB0, 0)„CALL InitCard„SYSTEM: END„„DEFSNG A-Z„SUB center (text$, row)„text$ = RTRIM$(text$)„LOCATE row, 40 - LEN(text$) / 2„PRINT text$„END SUB„„DEFINT A-Z„FUNCTION DetectCard„CALL WriteReg(&H4, &H60)        'Reset both timers„CALL WriteReg(&H4, &H80)„stat1 = INP(&H388)              'Store result„CALL WriteReg(&H2, &HFF)„CALL WriteReg(&H4, &H21)„pause .08                       'Wait 80msecs„stat2 = INP(&H388)              'Store result„CALL WriteReg(&H4, &H60)        'Reset both timers„CALL WriteReg(&H4, &H80)„IF (stat1 AND &HE0) = &H0 THEN„   IF (stat2 AND &HE0) = &HC0 THEN„      found = TRUE„   END IF„END IF„DetectCard = found„END FUNCTION„„SUB info„CLS„PRINT "Coded and Designed by Kurt Eckhardt"„PRINT "Copyrite 1996   All Rights Reserved"„PRINT "V1.0 Completed on 8/20/96"„PRINT "Channels 1 through 3 appear to be working correctly as do the drums (I think)"„PRINT "But channels 4-9 only produce muted/distorted sounds, if any at all."„PRINT "Vibrato and Tremolo are operational, but the effect cannot be heard"„PRINT "If the decay is set too short."„PRINT "Sorry about the sharps, they work, but no keyboard interface yet."„PRINT "You'll have to wait until I put in mouse support."„PRINT "If you find any info in this program useful for your own programming endevours,"„PRINT„PRINT "I would greatly appreciate you sending me 1$ so I can make my way through"„PRINT "college. I bet you can look around right now and find that within 10 feet"„PRINT "of yourself- if not, you are as broke as I am."„PRINT "Any comments or questions, send me some email at <king@shadow.net>"„PRINT "Here's the address for that measly buck: "„PRINT„PRINT "Kurt Eckhardt"„PRINT "1820 West Oak Knoll Circle"„PRINT "Ft. Lauderdale FL 33324"„PRINT„PRINT "Thanks!"„pressakey„END SUB„„SUB InitCard„'Set all 244 registers to 0 to initalize„FOR lp = 1 TO 2„FOR Regis = 1 TO &HF5„CALL WriteReg(Regis, 0)„NEXT Regis„NEXT lp„„'Set variables„dcay = 5: vst = 0: tst = 0„END SUB„„SUB legal„CLS„center "Legal Stuff", 1„PRINT„PRINT "1. This program may be freely distributed so long as no changes have been made."„PRINT "2. This program, or any part of it, may not be used in another program"„PRINT "   without my written consent."„PRINT "3. I take no responsibilty for any adverse affects that may be caused by"„PRINT "   usage of this program upon your machine."„                     „center "By possessing this program you agree with these terms.", 10„pressakey„END SUB„„SUB Menu„SCREEN 12: CLS„„COLOR 2: center "One Really Bad Music Machine", 1„center "By: Kurt Eckhardt  V1.0", 2: COLOR 15„„„LOCATE 5, 1: COLOR 11: PRINT "6: "; : COLOR 3: PRINT "Tremolo: OFF"„LOCATE 6, 1: COLOR 11: PRINT "7: "; : COLOR 3: PRINT "Vibrato: OFF"„LOCATE 5, 66: COLOR 11: PRINT "8: "; : COLOR 3: PRINT "Decay: "; HEX$(dcay)„LOCATE 15, 8: COLOR 11: PRINT "0: "; : COLOR 9: PRINT "Quit"„LOCATE 16, 8: COLOR 11: PRINT "1: "; : COLOR 9: PRINT "Hi Hat"„LOCATE 17, 8: COLOR 11: PRINT "2: "; : COLOR 9: PRINT "Symbol"„LOCATE 18, 8: COLOR 11: PRINT "3: "; : COLOR 9: PRINT "Tom Drum"„LOCATE 19, 8: COLOR 11: PRINT "4: "; : COLOR 9: PRINT "Snare Drum"„LOCATE 20, 8: COLOR 11: PRINT "5: "; : COLOR 9: PRINT "Bass Drum"„„COLOR 11„LOCATE 26, 8: PRINT "C  D  E   F  G  A  B"„LOCATE 26, 30: PRINT "C  D  E   F  G  A  B"„LOCATE 26, 52: PRINT "C  D  E   F  G  A  B  C"„LOCATE 22, 8: PRINT "C# D#    F# G#  A#"„LOCATE 22, 30: PRINT "C# D#    F# G#  A#"„LOCATE 22, 52: PRINT "C# D#    F# G#  A#    C#"„„COLOR 9„FOR x = 50 TO 575 STEP 25„LINE (x, 330)-(x + 25, 420), , B„NEXT x„LINE (50, 365)-(600, 365)„„DO„   key$ = UCASE$(INKEY$)„   SELECT CASE key$„   CASE "Z": CALL SBPlay(1, "C", 4): xpos = 8: char$ = "C"„   CASE "X": CALL SBPlay(1, "D", 4): xpos = 11: char$ = "D"„   CASE "C": CALL SBPlay(1, "E", 4): xpos = 14: char$ = "E"„   CASE "V": CALL SBPlay(1, "F", 4): xpos = 18: char$ = "F"„   CASE "B": CALL SBPlay(1, "G", 4): xpos = 21: char$ = "G"„   CASE "N": CALL SBPlay(1, "A", 4): xpos = 24: char$ = "A"„   CASE "M": CALL SBPlay(1, "B", 4): xpos = 27: char$ = "B"„   CASE "A": CALL SBPlay(2, "C", 5): xpos = 30: char$ = "C"„   CASE "S": CALL SBPlay(2, "D", 5): xpos = 33: char$ = "D"„   CASE "D": CALL SBPlay(2, "E", 5): xpos = 36: char$ = "E"„   CASE "F": CALL SBPlay(2, "F", 5): xpos = 40: char$ = "F"„   CASE "G": CALL SBPlay(2, "G", 5): xpos = 43: char$ = "G"„   CASE "H": CALL SBPlay(2, "A", 5): xpos = 46: char$ = "A"„   CASE "J": CALL SBPlay(2, "B", 5): xpos = 49: char$ = "B"„   CASE "Q": CALL SBPlay(3, "C", 6): xpos = 52: char$ = "C"„   CASE "W": CALL SBPlay(3, "D", 6): xpos = 55: char$ = "D"„   CASE "E": CALL SBPlay(3, "E", 6): xpos = 58: char$ = "E"„   CASE "R": CALL SBPlay(3, "F", 6): xpos = 62: char$ = "F"„   CASE "T": CALL SBPlay(3, "G", 6): xpos = 65: char$ = "G"„   CASE "Y": CALL SBPlay(3, "A", 6): xpos = 68: char$ = "A"„   CASE "U": CALL SBPlay(3, "B", 6): xpos = 71: char$ = "B"„   CASE "I": CALL SBPlay(3, "C", 7): xpos = 74: char$ = "C"„   CASE "1": CALL SBDrum(1)„   CASE "2": CALL SBDrum(2)„   CASE "3": CALL SBDrum(3)„   CASE "4": CALL SBDrum(4)„   CASE "5": CALL SBDrum(5)„   CASE "6": tst = tst + 1: IF tst > 1 THEN tst = 0„   CASE "7": vst = vst + 1: IF vst > 1 THEN vst = 0„   CASE "8": dcay = dcay + 1: IF dcay > &HF THEN dcay = 0„   CASE ";": CALL Scale„END SELECT„„IF INSTR(" ZXCVBNMASDFGHJQWERTYUI678", key$) > 1 THEN„   COLOR 3„   IF tst = 1 THEN tst$ = "ON " ELSE tst$ = "OFF"„   IF vst = 1 THEN vst$ = "ON " ELSE vst$ = "OFF"„   LOCATE 5, 4: PRINT "Tremolo: "; tst$„   LOCATE 6, 4: PRINT "Vibrato: "; vst$„   LOCATE 5, 69: PRINT "Decay: "; HEX$(dcay)„   IF xold <> 0 THEN LOCATE 26, xold: COLOR 11: PRINT ochar$„   IF xpos <> 0 THEN LOCATE 26, xpos: COLOR 4: PRINT char$„   ochar$ = char$: xold = xpos„END IF„LOOP WHILE key$ <> "0"„COLOR 11„END SUB„„FUNCTION note% (n$)„'These appear to be the correct frequency numbers„IF n$ = "C" THEN note% = &H209„IF n$ = "C#" THEN note% = &H219„IF n$ = "D" THEN note% = &H229„IF n$ = "D#" THEN note% = &H23B„IF n$ = "E" THEN note% = &H24E„IF n$ = "F" THEN note% = &H261„IF n$ = "F#" THEN note% = &H277„IF n$ = "G" THEN note% = &H28D„IF n$ = "G#" THEN note% = &H2A4„IF n$ = "A" THEN note% = &H2BD„IF n$ = "A#" THEN note% = &H2D8„IF n$ = "B" THEN note% = &H2F4„END FUNCTION„„FUNCTION offset1 (channel)„'These are the offsets for each of the nine channels„'For operator number 1„IF channel = 1 THEN offset1 = &H0„IF channel = 2 THEN offset1 = &H1„IF channel = 3 THEN offset1 = &H2„IF channel = 4 THEN offset1 = &H8„IF channel = 5 THEN offset1 = &H9„IF channel = 6 THEN offset1 = &HA„IF channel = 7 THEN offset1 = &H10„IF channel = 8 THEN offset1 = &H11„IF channel = 9 THEN offset1 = &H12„END FUNCTION„„„FUNCTION offset2 (channel)„'These are the offsets for each of the nine channels„'For operator number 2„IF channel = 1 THEN offset2 = &H3„IF channel = 2 THEN offset2 = &H4„IF channel = 3 THEN offset2 = &H5„IF channel = 4 THEN offset2 = &HB„IF channel = 5 THEN offset2 = &HC„IF channel = 6 THEN offset2 = &HD„IF channel = 7 THEN offset2 = &H13„IF channel = 8 THEN offset2 = &H14„IF channel = 9 THEN offset2 = &H15„END FUNCTION„„SUB pause (secs!)„start! = TIMER„DO: LOOP WHILE TIMER - start! < secs!„END SUB„„SUB pressakey„DO: LOOP WHILE INKEY$ = ""„END SUB„„SUB SBDrum (num%)„IF num% = 1 THEN CALL WriteReg(&HBD, &H21) 'HHat„IF num% = 2 THEN CALL WriteReg(&HBD, &H22) 'Cymb„IF num% = 3 THEN CALL WriteReg(&HBD, &H24) 'TomT„IF num% = 4 THEN CALL WriteReg(&HBD, &H28) 'Snre„IF num% = 5 THEN CALL WriteReg(&HBD, &H30) 'Bass„CALL WriteReg(&HBD, &H0)„END SUB„„SUB SBPlay (channel%, n$, Octa%)„IF Octa% = 1 THEN octave = &H21                  'These are the octave bits„IF Octa% = 2 THEN octave = &H25„IF Octa% = 3 THEN octave = &H29„IF Octa% = 4 THEN octave = &H2D„IF Octa% = 5 THEN octave = &H31„IF Octa% = 6 THEN octave = &H35„IF Octa% = 7 THEN octave = &H39„offs1 = offset1(channel)                         'Get offsets depending„offs2 = offset2(channel)                         'on channel„IF tst = 1 THEN trem = &H80 ELSE trem = &H0„IF vst = 1 THEN vibr = &H40 ELSE vibr = &H0„„CALL WriteReg(&HB0 + offs1, &H0)              'Clear previous note„CALL WriteReg(&H20 + offs1, &H0 + trem + vibr)   'Amp/Vib/EG/KSR/Octave(0-F)„CALL WriteReg(&H40 + offs1, &HA)                 'Scale Lev/Volume(0-3F)„CALL WriteReg(&H60 + offs1, &HF0 + dcay)         'Attack/Decay„CALL WriteReg(&H80 + offs1, &H1A)                'Sustain/Release„CALL WriteReg(&HA0 + offs1, note(n$))            'Note„CALL WriteReg(&HE0 + offs1, &H0)                 'Waveform (00-03) Default 00„„CALL WriteReg(&H20 + offs2, &H0 + trem + vibr)   'Amp/Vib/EG/KSR/Octave(0-F)„CALL WriteReg(&H40 + offs2, &HA)                 'Scale Lev/Volume(0-3F)„CALL WriteReg(&H60 + offs2, &HF0 + dcay)         'Attack/Decay„CALL WriteReg(&H80 + offs2, &H1A)                'Sustain/Release„CALL WriteReg(&HB0 + offs1, octave)              'Octave(21-39)„CALL WriteReg(&HE0 + offs2, &H0)                 'Waveform (00-03) Default 00„END SUB„„SUB Scale„FOR octave = 1 TO 7„CALL SBPlay(3, "C", octave): pause .1„CALL SBPlay(1, "C#", octave): pause .1„CALL SBPlay(2, "D", octave): pause .1„CALL SBPlay(3, "D#", octave): pause .1„CALL SBPlay(1, "E", octave): pause .1„CALL SBPlay(2, "F", octave): pause .1„CALL SBPlay(3, "F#", octave): pause .1„CALL SBPlay(1, "G", octave): pause .1„CALL SBPlay(2, "G#", octave): pause .1„CALL SBPlay(3, "A", octave): pause .1„CALL SBPlay(1, "A#", octave): pause .1„CALL SBPlay(2, "B", octave): pause .1„NEXT octave„END SUB„„DEFSNG A-Z„SUB WriteReg (Reg%, value%)„OUT StatusP, Reg%           'Register to write at port &H388„FOR lp = 1 TO 6             'Wait 3.3 msec„wat = INP(&H388)„NEXT lp„OUT DataP, value%           'Now write data to port &H389„FOR lp = 1 TO 35            'Now wait 23 msec„wat = INP(&H389)„NEXT lp„END SUB„„