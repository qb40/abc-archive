Kurt Kuzba                     GET PRINTER STATUS             FidoNet QUIK_BAS Echo          07-17-96 (00:00)       QB, QBasic, PDS        33   1534     PRNTEST.BAS '>   Does anyone know how to tell if there is an incoming„'>   character for a LPT port?  I checked in the QB help, and„'>   LOF is not valid for any device except COMn.„'>.....„'   You can just read the port itself.„„'_|_|_|   PRNTEST.BAS„'_|_|_|   This program will test your printer. First remove paper„'_|_|_|   and take printer offline. Run program. Add paper and„'_|_|_|   go online in individual steps. Program will locate the„'_|_|_|   printer status port and test conditions. (updated 7/17)„'_|_|_|   No warrantees or guarantees are given or implied.„'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (7/17/96)„DEF SEG = &H40„PRN& = PEEK(9) AND 255„PRN& = PRN& * 256 + (PEEK(8) AND 255) + 1„'_|_|_|   Printer Status port is Printer I/O port + 1„DO„   t% = INP(PRN&): E% = 16„   IF (t% AND 16) = 16 THEN PRINT "Printer Online": E% = E% XOR 16„   IF (t% AND 32) = 32 THEN PRINT "Out of Paper": E% = E% OR 32„   IF (t% AND 128) = 0 THEN PRINT "Printer Busy": E% = E% OR 128„   IF E% > 0 THEN„      PRINT "Fix Printer and try again."„      WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND„   END IF„LOOP WHILE (E% > 0) AND (INKEY$ <> CHR$(27))„'_|_|_|   end   PRNTEST.BAS„'There should be nothing coming in on the printer port, usually.„'You will need to poll both the data port and the status port to„'see which one has data coming in on it when using the parallel„'port for something other than a printer. It is done all the„'time, I know. Iomega Zip drives use it, and some LAN setups.„Xtance Coders Alliance         ADDRESS BOOK                   harrys@castel.nl               01-12-97 (17:42)       QB, QBasic, PDS        947  24837    ADDRESS.BAS DECLARE SUB Reg ()„DECLARE SUB NOFilesFound ()„DECLARE SUB CLSScreen ()„DECLARE FUNCTION CHeckBestand! (Welke$)„DECLARE SUB noBackup ()„DECLARE SUB RESTOREBackup ()„DECLARE SUB Backup ()„DECLARE SUB Copy (Bestand1$, Bestand2$, FileCopyShow%, regel%, waar%, BKleur%, FKleur%, car%)„DECLARE SUB FileRead (filename$, LIneCount%, VNaam$(), ANaam$(), Straat$(), Hnummer$(), PCode$(), Tel$(), Stad$(), GDatum$(), Extra1$(), Extra2$())„DECLARE FUNCTION ED$ (z%, x%, m%, n%)„DECLARE SUB editLine (a$, ExitCode, Ascii)„DECLARE FUNCTION ScanCode! ()„DECLARE SUB info.MrSnow ()„DECLARE SUB inFO.Prog ()„DECLARE SUB expand (UpRow%, LtColum%, LoRow%, RtColum%)„DECLARE SUB Drawbox (UpRow%, LtColum%, LoRow%, RtColum%)„DECLARE SUB pause (ticks%)„DECLARE SUB Shadow (UpRow%, LtColum%, LoRow%, RtColum%)„DECLARE SUB CheckShell ()„DECLARE SUB DeleteAdres.Lijst (Welke%, Ect%)„DECLARE SUB NewDataFIle ()„DECLARE SUB DeleteAdres (Welke%, Ect%)„DECLARE SUB Show.KeuseLijst (aDres$(), BackADRES$(), til%)„DECLARE SUB KeuseLijst ()„DECLARE SUB COL (b!, c!, k$, e!, d!)„DECLARE SUB ShowFile (t%)„DECLARE SUB inPutFile (laatste%)„DECLARE FUNCTION DAtaFile.Exist% ()„DECLARE FUNCTION keycode% ()„CONST LST$ = "ADRES.LST"„TYPE Fixed„  Str AS STRING * 100                          'kopieerbuffer 16384„END TYPE„DIM SHARED VNaam$(500), ANaam$(500), Straat$(500), Hnummer$(500), PCode$(500), Tel$(500), Stad$(500), GDatum$(500), Extra1$(500), Extra2$(500)„ON ERROR GOTO fout„„'       This program is made by yours Mr. SN()W From„'„'               Xtance Coders Alliance 1997„'„'       E-mail: Mrsnow@freemail.nl„'       or„'       harryst@castel.nl„'„' Please send mail if you use any thing of this or if you have any comments„'„' For All BASIC Code from William Yu 1997„'„' --------------------------------------------------------------------------„„„„„CLS„„IF DAtaFile.Exist = 1 THEN„	PRINT "CReating new DATA File ..": NewDataFIle„ELSE„FileRead "ADRES.DAT", LIneCount%, VNaam$(), ANaam$(), Straat$(), Hnummer$(), PCode$(), Tel$(), Stad$(), GDatum$(), Extra1$(), Extra2$()„END IF„„Start:„CALL KeuseLijst„„„neetoch:„CLS„KEY(9) OFF„KeuseLijst„END„„fout:„COLOR 7, 0: CLS : PRINT "ERROR #"; ERR; "Found"„END„RESUME„„Existfout:„RESUME NEXT„„„Backupnee:„CALL noBackup„„GOTO Start„„SUB Backup„ON ERROR GOTO Existfout„„'(Bestand1$, Bestand2$, FileCopyShow%, Regel%, Waar%, BKleur%, FKleur%, Car%)„a = CHeckBestand("ADRES.BAK\ADRES.DAT")„b = CHeckBestand("ADRES.BAK\ADRES.EXE")„c = CHeckBestand("ADRES.BAK\ADRES.LST")„IF a = 0 OR b = 0 OR c = 0 THEN CALL NOFilesFound„IF a = 0 OR b = 0 OR c = 0 THEN EXIT SUB„„expand 4, 5, 12, 75„LOCATE 4, 35: PRINT "[ Backup ]"„„MKDIR "ADRES.BAK"„Copy "ADRES.DAT", "ADRES.BAK\ADRES.DAT", 1, 7, 15, 7, 1, 254„Copy LST$, "ADRES.BAK\ADRES.LST", 1, 7, 15, 7, 1, 254„Copy "ADRES.EXE", "ADRES.BAK\ADRES.EXE", 1, 7, 15, 7, 1, 254„LOCATE 10, 12: PRINT "Press 'Y' to return to the menu ..."„DO: LOOP UNTIL UCASE$(INKEY$) = "Y"„ON ERROR GOTO fout„„„END SUB„„FUNCTION CHeckBestand (Welke$)„OPEN Welke$ FOR APPEND AS #5„i = LOF(5)„CLOSE„IF i = 0 THEN CHeckBestand = 0„IF i >= 1 THEN CHeckBestand = 1„END FUNCTION„„SUB CheckShell STATIC„OPEN "ADres.Dat" FOR APPEND AS #1„OPEN LST$ FOR APPEND AS #2„a = LOF(1): b = LOF(2)„CLOSE 1, 2„IF a < 30 AND b < 10 THEN CALL NewDataFIle„END SUB„„SUB CLSScreen„FOR i = 1 TO 24„LOCATE i, 1: PRINT STRING$(80, 32);„NEXT i„END SUB„„SUB COL (b, c, k$, e, d) STATIC„COLOR b, c„PRINT k$„COLOR e, d„END SUB„„DEFINT A-Z„SUB Copy (Bestand1$, Bestand2$, FileCopyShow%, regel%, waar%, BKleur%, FKleur%, car%)„COLOR BKleur%, FKleur%„LOCATE regel%, waar%„PRINT STRING$(52, 32);„COLOR BKleur%, FKleur%„LOCATE regel%, waar%„PRINT STRING$(51, 32);„„„Add% = 0  '0 = overschrijven. -1 = Toevoegen„CopyDate% = 1 '0 = huidige datum. -1 = datum van bronbestand„REDIM Buffer(0) AS Fixed                         ' fixed string in far heap„„f1% = FREEFILE                                   ' handle #F1%„OPEN Bestand1$ FOR BINARY AS #f1% LEN = 4096     ' open bronbestand„„f2% = FREEFILE                                   ' handle #F2%„IF NOT Add% THEN                                 ' overschrijven„  OPEN Bestand2$ FOR OUTPUT AS #f2%              ' voor alle zekerheid...„  CLOSE #f2%                                     '„  KILL Bestand2$                                 ' wissen„END IF„„OPEN Bestand2$ FOR BINARY AS #f2% LEN = 4096     ' open doelbestand„„IF Add% THEN                                     ' Toevoegen„  TotalBytes& = LOF(f1%) + LOF(f2%)              ' tel op„  SEEK #f2%, LOF(f2%) + 1                        ' append„ELSE„  TotalBytes& = LOF(f1%)„END IF„„DO„  GET #f1%, , Buffer(0)                          ' lees dan 16Kb„  IF NOT EOF(f1%) THEN„    PUT #f2%, , Buffer(0)                        ' schrijf naar 2„  ELSE                                           ' hoeveel rest ?„    FOR x% = 1 TO (TotalBytes& - LOF(f2%)) STEP 4096„	IF TotalBytes& - LOF(f2%) >= 4096 THEN     ' blokken van 4Kb„	Temp$ = MID$(Buffer(0).Str, x%, 4096)„	ELSE„	Temp$ = MID$(Buffer(0).Str, x%, (TotalBytes& - LOF(f2%)))„	END IF„	PUT #f2%, , Temp$                          ' schrijf rest„  „    NEXT x%„  END IF„IF FileCopyShow = 1 THEN„COLOR BKleur%, FKleur%„'LOCATE regel%, waar%„'PRINT STRING$(FIX(LOF(f2%) / (LOF(f1%) / 100)) / 2, Car%); '219„„LOCATE regel%, waar% + (FIX(LOF(f2%) / (LOF(f1%) / 100)) / 2)„COLOR 10, 1„PRINT "->"„COLOR BKleur%, FKleur%„LOCATE regel% + 1, waar% + 18: PRINT FIX(LOF(f2%) / (LOF(f1%) / 100)); "% Done  "„LOCATE regel - 2, waar% - 8: PRINT "File: "; Bestand1$; " -->-> "; Bestand2$„END IF„„LOOP UNTIL EOF(f1%)„CLOSE 1, 2„SLEEP 1„„COLOR BKleur%, FKleur%„END SUB„„FUNCTION DAtaFile.Exist STATIC„OPEN "ADRES.DAT" FOR APPEND AS #9„IF LOF(9) < 1 THEN DAtaFile.Exist = 1„IF LOF(9) > 1 THEN DAtaFile.Exist = 2„IF LOF(9) < 1 THEN GOTO nee„„CLOSE 9„„EXIT FUNCTION„nee:„CLOSE 9„KILL "ADRES.DAT"„„END FUNCTION„„DEFSNG A-Z„SUB DeleteAdres (Welke%, Ect%) STATIC„'PRINT Welke%, Ect%: END„„OPEN "ADRES.DAT" FOR INPUT AS #1„OPEN "ADres.TMP" FOR OUTPUT AS #2„„IF Welke% = Ect% THEN GOTO EindeWeg„IF Welke% = 1 THEN GOTO beginWeg„„FOR t% = 1 TO Welke% - 1„INPUT #1, VNaam$(t%), ANaam$(t%), Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), Tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„WRITE #2, VNaam$(t%), ANaam$(t%), Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), Tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„NEXT t%„„INPUT #1, VNaam$(Welke% + 1), ANaam$(Welke% + 1), Straat$(Welke% + 1), Hnummer$(Welke% + 1), PCode$(Welke% + 1), Stad$(Welke% + 1), Tel$(Welke% + 1), GDatum$(Welke% + 1), Extra1$(Welke% + 1), Extra2$(Welke% + 1)„„FOR t% = Welke% + 1 TO Ect%„INPUT #1, VNaam$(t%), ANaam$(t%), Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), Tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„WRITE #2, VNaam$(t%), ANaam$(t%), Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), Tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„NEXT t%„CLOSE 1, 2„KILL "ADRES.DAT"„NAME "ADRES.TMP" AS "ADRES.DAT"„EXIT SUB„„EindeWeg:„FOR i% = 1 TO Ect% - 1„INPUT #1, VNaam$(i%), ANaam$(i%), Straat$(i%), Hnummer$(i%), PCode$(i%), Stad$(i%), Tel$(i%), GDatum$(i%), Extra1$(i%), Extra2$(i%)„WRITE #2, VNaam$(i%), ANaam$(i%), Straat$(i%), Hnummer$(i%), PCode$(i%), Stad$(i%), Tel$(i%), GDatum$(i%), Extra1$(i%), Extra2$(i%)„NEXT i%„„CLOSE 1, 2„KILL "ADRES.DAT"„NAME "ADRES.TMP" AS "ADRES.DAT"„EXIT SUB„„beginWeg:„INPUT #1, VNaam$(i%), ANaam$(i%), Straat$(i%), Hnummer$(i%), PCode$(i%), Stad$(i%), Tel$(i%), GDatum$(i%), Extra1$(i%), Extra2$(i%)„„FOR i% = 2 TO Ect%„INPUT #1, VNaam$(i%), ANaam$(i%), Straat$(i%), Hnummer$(i%), PCode$(i%), Stad$(i%), Tel$(i%), GDatum$(i%), Extra1$(i%), Extra2$(i%)„WRITE #2, VNaam$(i%), ANaam$(i%), Straat$(i%), Hnummer$(i%), PCode$(i%), Stad$(i%), Tel$(i%), GDatum$(i%), Extra1$(i%), Extra2$(i%)„NEXT i%„CLOSE 1, 2„KILL "ADRES.DAT"„NAME "ADRES.TMP" AS "ADRES.DAT"„EXIT SUB„„END SUB„„SUB DeleteAdres.Lijst (Welke%, Ect%) STATIC„'PRINT Welke%, Ect%: END„OPEN LST$ FOR INPUT AS #1„OPEN "ADres.TMP" FOR OUTPUT AS #2„„IF Welke% = Ect% THEN GOTO EindeWegLijst„IF Welke% = 1 THEN GOTO beginWegLijst„„FOR i% = 1 TO Welke% - 1„INPUT #1, VNaam$(i%), ANaam$(i%)„WRITE #2, VNaam$(i%), ANaam$(i%)„NEXT i%„„INPUT #1, VNaam$(Welke% + 1), ANaam$(Welke% + 1)„„FOR i% = Welke% + 1 TO Ect%„INPUT #1, VNaam$(i%), ANaam$(i%)„WRITE #2, VNaam$(i%), ANaam$(i%)„NEXT i%„CLOSE 1, 2„KILL LST$„NAME "ADRES.TMP" AS LST$„EXIT SUB„„EindeWegLijst:„FOR i% = 1 TO Ect% - 1„INPUT #1, VNaam$(i%), ANaam$(i%)„WRITE #2, VNaam$(i%), ANaam$(i%)„NEXT i%„„CLOSE 1, 2„KILL LST$„NAME "ADRES.TMP" AS LST$„EXIT SUB„„beginWegLijst:„INPUT #1, VNaam$(1), ANaam$(1)„„FOR i% = 2 TO Ect%„INPUT #1, VNaam$(i%), ANaam$(i%)„WRITE #2, VNaam$(i%), ANaam$(i%)„NEXT i%„CLOSE 1, 2„KILL LST$„NAME "ADRES.TMP" AS LST$„EXIT SUB„„„END SUB„„ SUB Drawbox (UpRow%, LtColum%, LoRow%, RtColum%) STATIC„    Wide% = (RtColum% - LtColum%) - 1„    LOCATE UpRow%, LtColum%„    PRINT CHR$(201); STRING$(Wide%, CHR$(205)); CHR$(187);„    FOR i% = UpRow% + 1 TO LoRow% - 1„	LOCATE i%, LtColum%„	PRINT CHR$(186); SPACE$(Wide%); CHR$(186);„    NEXT i%„    LOCATE LoRow%, LtColum%„    PRINT CHR$(200); STRING$(Wide%, CHR$(205)); CHR$(188);„ END SUB„„FUNCTION ED$ (z%, x%, m%, n%)„Erik$ = STRING$(25, 32)„COLOR z%, x%„editLine Erik$, ExitCode, 32„COLOR m%, n%„ED$ = Erik$„END FUNCTION„„SUB editLine (a$, ExitCode, Ascii) STATIC„    CONST FALSE = 0, TRUE = NOT FALSE„    CONST BACKSPACE = 8„    CONST DELETEKEY = -83„    CONST ENDKEY = -79„    CONST ENTER = 13„    CONST ESCAPE = 27„    CONST HOME = -71„    CONST INSERTKEY = -82„    CONST LEFTARROW = -75„    CONST RIGHTARROW = -77„    CONST TABKEY = 9„ „    row = CSRLIN„    Coli% = POS(0)„    length = LEN(a$)„    Ptr = 0„    insirt = TRUE„    quit = FALSE„    original$ = a$„    DO„„    LOCATE row, Coli%, 0„	PRINT a$;„	IF insirt THEN„	    LOCATE row, Coli% + Ptr, 1, 6, 7„	ELSE„	    LOCATE row, Coli% + Ptr, 1, 1, 7„	END IF„	 „	kee = ScanCode„	SELECT CASE kee„	    CASE INSERTKEY„		IF insirt THEN„		    insirt = FALSE„		ELSE„		    insirt = TRUE„		END IF„	    CASE BACKSPACE„		IF Ptr THEN„		    a$ = a$ + CHR$(Ascii)„		    a$ = LEFT$(a$, Ptr - 1) + MID$(a$, Ptr + 1)„		    Ptr = Ptr - 1„		END IF„	    CASE DELETEKEY„		a$ = a$ + CHR$(Ascii)„		a$ = LEFT$(a$, Ptr) + MID$(a$, Ptr + 2)„	    CASE UPARROW„		ExitCode = 1„		quit = TRUE„	    CASE DOWNARROW„		ExitCode = -1„		quit = TRUE„	    CASE LEFTARROW„		IF Ptr THEN„		    Ptr = Ptr - 1„		END IF„	    CASE RIGHTARROW„		IF Ptr < length - 1 THEN„		    Ptr = Ptr + 1„		END IF„	    CASE ENTER„		a$ = LEFT$(a$, Ptr)„		ExitCode = 0„		quit = TRUE„	    CASE HOME„		Ptr = 0„	    CASE ENDKEY„		Ptr = lengte + LEN(RTRIM$(a$))„	    CASE CTRLRIGHTARROW„		DO UNTIL MID$(a$, Ptr + 1, 1) = " " OR Ptr = length - 1„		    Ptr = Ptr + 1„		LOOP„		DO UNTIL MID$(a$, Ptr + 1, 1) <> " " OR Ptr = length - 1„		    Ptr = Ptr + 1„		LOOP„	    CASE CTRLLEFTARROW„		DO UNTIL MID$(a$, Ptr + 1, 1) = " " OR Ptr = 0„		    Ptr = Ptr - 1„		LOOP„		DO UNTIL MID$(a$, Ptr + 1, 1) <> " " OR Ptr = 0„		    Ptr = Ptr - 1„		LOOP„		DO UNTIL MID$(a$, Ptr + 1, 1) = " " OR Ptr = 0„		    Ptr = Ptr - 1„		LOOP„		IF Ptr THEN„		    Ptr = Ptr + 1„		END IF„	    CASE CTRLY„		a$ = SPACE$(length)„		Ptr = 0„	    CASE ESCAPE„		a$ = original$„		Ptr = 0„		insirt = TRUE„	    CASE IS > 255„				„	    CASE IS < 32„		„	    CASE ELSE„		kee$ = CHR$(kee)„		IF insirt THEN„		    a$ = LEFT$(a$, Ptr) + kee$ + MID$(a$, Ptr + 1)„		    a$ = LEFT$(a$, length)„		ELSEIF Ptr < length THEN„		    MID$(a$, Ptr + 1, 1) = kee$„		END IF„		IF Ptr < length THEN„		    Ptr = Ptr + 1„		ELSE„		„		END IF„		ctrlQflag = FALSE„	END SELECT„    LOOP UNTIL quit„a$ = a$„„END SUB„„ SUB expand (UpRow%, LtColum%, LoRow%, RtColum%) STATIC„    RowCenter% = ((LoRow% - UpRow%) / 2) + UpRow%„    ColCenter% = ((RtColum% - LtColum%) / 2) + LtColum%„    UprRow% = RowCenter%: LeftColum% = ColCenter%„    LwrRow% = RowCenter%: RghtColum% = ColCenter%„    DO„	LeftColum% = LeftColum% - 1„	RghtColum% = RghtColum% + 1„	IF LeftColum% < LtColum% THEN LeftColum% = LtColum%„	IF RghtColum% > RtColum% THEN RghtColum% = RtColum%„	Drawbox UprRow%, LeftColum%, LwrRow%, RghtColum%„	IF LeftColum% = LtColum% AND RghtColum% = RtColum% THEN EXIT DO„    LOOP„    DO„	UprRow% = UprRow% - 1„	LwrRow% = LwrRow% + 1„	IF UprRow% < UpRow% THEN UprRow% = UpRow%„	IF LwrRow% >= LoRow% THEN LwrRow% = LoRow%„	Drawbox UprRow%, LeftColum%, LwrRow%, RghtColum%„	IF UprRow% = UpRow% AND LwrRow% = LoRow% THEN EXIT DO„	pause 1„    LOOP„    Shadow UpRow%, LtColum%, LoRow%, RtColum%„ END SUB„„DEFINT A-Z„SUB FileRead (filename$, LIneCount%, VNaam$(), ANaam$(), Straat$(), Hnummer$(), PCode$(), Tel$(), Stad$(), GDatum$(), Extra1$(), Extra2$()) STATIC„ filenumber% = FREEFILE„ OPEN filename$ FOR INPUT AS filenumber%„ IF LOF(1) <= 10 THEN GOTO theend„ DO„  LIneCount% = LIneCount% + 1„  l% = LIneCount%„  INPUT #filenumber%, VNaam$(l%), ANaam$(l%), Straat$(l%), Hnummer$(l%), PCode$(l%), Stad$(l%), Tel$(l%), GDatum$(l%), Extra1$(l%), Extra2$(l%)„		  „ LOOP UNTIL EOF(1)„theend:„CLOSE„EXIT SUB„ „END SUB„„DEFSNG A-Z„SUB info.MrSnow STATIC„CLS„COLOR 14, 1„expand 1, 1, 24, 78„LOCATE 1, 33: PRINT "[ MrSnow '95 ]"„LOCATE 7, 10: PRINT "Things that I have Made in QuickBasic '4.5'"„LOCATE 8, 10: PRINT "--------------------------------------------"„LOCATE 9, 10: PRINT "PICME.EXE <-- GIF/PCX Viewer"„LOCATE 10, 10: PRINT "PCX2GIF.EXE <-- PCX to GIF converter"„LOCATE 11, 10: PRINT "REBOOT.EXE <-- Nice REBOOT programm"„LOCATE 12, 10: PRINT "FASTVIEW.EXE <-- Fast TEXT file viewer"„LOCATE 13, 10: PRINT "QSyS.EXE <-- QuickSySinformation "„LOCATE 14, 10: PRINT "TXT2BAS.EXE <-- Converts a TXT file to .BAS file+Viewer"„LOCATE 15, 10: PRINT "CD_INST.EXE <-- CD-ROM Installer '95"„LOCATE 16, 10: PRINT "TCP.QLB/LIB <-- Nice Quickbasic Libery"„LOCATE 18, 10: PRINT "Ect,Ect I have made much more"„LOCATE 22, 20: PRINT "Press 'Q' to Return to the menu ..."„COLOR 7, 1„DO„LOOP UNTIL UCASE$(INKEY$) = CHR$(81)„„END SUB„„SUB inFO.Prog STATIC„CLS„COLOR 14, 1„expand 1, 1, 18, 78„LOCATE 1, 33: PRINT "[ ADRES.EXE ]"„LOCATE 5, 10: PRINT "Made on 1995-8-27/28"„LOCATE 6, 10: PRINT "This programm is made by: Mr. Snow"„LOCATE 7, 10: PRINT "It's made in QuickBasic 4.5"„LOCATE 8, 10: PRINT "On a BAD Day"„LOCATE 10, 10: PRINT "INclude Files are:"„LOCATE 11, 28: PRINT "ADRES.EXE"„LOCATE 12, 28: PRINT "ADRES.DAT "„LOCATE 13, 28: PRINT "ADRES.LST"„LOCATE 16, 20: PRINT "Press 'Q' to Return to the menu ..."„DO„LOOP UNTIL UCASE$(INKEY$) = CHR$(81)„COLOR 7, 1„END SUB„„SUB inPutFile (laatste%) STATIC„b$ = "                    "„ON KEY(9) GOSUB neetoch„KEY(9) ON„'<-- Met EDitLine of LineEdit ??? >>092ouldhekurdkj7y857rq8_*&(@^JDGHUFD"„t% = laatste%„expand 1, 1, 15, 50„LOCATE 1, 51: PRINT "F9 to Abort"„LOCATE 3, 5: PRINT "VoorNaam :";„VNaam$(t%) = ED$(14, 0, 7, 1)„LOCATE 4, 5: PRINT "AchterNaam :";„ANaam$(t%) = ED$(14, 0, 7, 1)„LOCATE 5, 5: PRINT "Straat :";„Straat$(t%) = ED$(14, 0, 7, 1)„LOCATE 6, 5: PRINT "HuisNummer :";„Hnummer$(t%) = ED$(14, 0, 7, 1)„LOCATE 7, 5: PRINT "PostCode :";„PCode$(t%) = ED$(14, 0, 7, 1)„LOCATE 8, 5: PRINT "Plaats (Stad) :";„Stad$(t%) = ED$(14, 0, 7, 1)„LOCATE 9, 5: PRINT "Telefoon :";„Tel$(t%) = ED$(14, 0, 7, 1)„LOCATE 10, 5: PRINT "GeboorteDatum :";„GDatum$(t%) = ED$(14, 0, 7, 1)„LOCATE 12, 5: PRINT "EXtra: ";„Extra1$(t%) = ED$(14, 0, 7, 1)„LOCATE 13, 5: PRINT "EXtra: ";„Extra2$(t%) = ED$(14, 0, 7, 1)„OPEN "ADRES.DAT" FOR APPEND AS #1„„WRITE #1, VNaam$(t%), ANaam$(t%), Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), Tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„CLOSE 1„„OPEN "ADRES.LST" FOR APPEND AS #1„WRITE #1, VNaam$(t%), ANaam$(t%)„CLOSE„CLS„„END SUB„„DEFINT A-Z„SUB KeuseLijst STATIC„DIM aDres$(1500), BackADRES$(1500)„OPEN LST$ FOR INPUT AS #1„i = LOF(1)„CLOSE 1„IF i <= 8 THEN LOCATE 20, 20: PRINT "NO Adresses Found !": CALL NewDataFIle„OPEN LST$ FOR INPUT AS #1„„l% = 10„„DO„l% = l% + 1„INPUT #1, aDres$(l%), BackADRES$(l%)„LOOP UNTIL EOF(1)„CLOSE 1„„FOR b = l% + 1 TO l% + 15„aDres$(b) = "": BackADRES$(b) = ""„NEXT b„Show.KeuseLijst aDres$(), BackADRES$(), l%„EXIT SUB„„END SUB„„FUNCTION keycode% STATIC„ DO„ k$ = INKEY$„ LOOP UNTIL k$ <> ""„ keycode% = CVI(k$ + CHR$(0))„END FUNCTION„„DEFSNG A-Z„SUB NewDataFIle„OPEN "ADRES.DAT" FOR OUTPUT AS #9„OPEN LST$ FOR OUTPUT AS #10„    ' VNaam$(t%), ANaam$(t%),    Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„WRITE #9, "Mr.", "Snow", "Heaven", "102", "9736 AD", "Holland", "06-9666", "1980-7-3", "From Xtance Coders All-", "iance 1997"„„WRITE #10, "Mr.", "Snow"„CLOSE 9, 10„„END SUB„„SUB noBackup„expand 4, 5, 13, 75„LOCATE 6, 15: PRINT "You don't have made any BACKUP!!"„LOCATE 8, 15: PRINT "Sleep tyde and you better can "„LOCATE 9, 15: PRINT "Think first....."„LOCATE 11, 15: PRINT "Press [Enter] to return to the menu.."„DO: LOOP UNTIL INKEY$ = CHR$(13)„CLOSE„„END SUB„„SUB NOFilesFound„expand 4, 5, 13, 75„LOCATE 6, 15: PRINT "Can't Finde one of the FIles to Backup"„LOCATE 8, 15: PRINT "Files: ADRES.DAT ADRES.LST ADRES.EXE"„LOCATE 9, 15: PRINT "Think first....."„LOCATE 11, 15: PRINT "Press [Enter] to return to the menu.."„DO: LOOP UNTIL INKEY$ = CHR$(13)„CLOSE„„END SUB„„ SUB pause (ticks%) STATIC„    DEF SEG = 0„    DO UNTIL TestTick% > ticks%„	IF LEN(INKEY$) THEN EXIT SUB„	LastTick% = GetTick%„	GetTick% = PEEK(&H46C)„	IF LastTick% <> GetTick% THEN„	    TestTick% = TestTick% + 1„	END IF„    LOOP„„„    DEF SEG„ END SUB„„SUB Reg„END SUB„„SUB RESTOREBackup„ON ERROR GOTO Existfout„'(Bestand1$, Bestand2$, FileCopyShow%, Regel%, Waar%, BKleur%, FKleur%, Car%)„a = CHeckBestand("ADRES.BAK\ADRES.DAT")„b = CHeckBestand("ADRES.BAK\ADRES.EXE")„c = CHeckBestand("ADRES.BAK\ADRES.LST")„IF a = 0 OR b = 0 OR c = 0 THEN CALL noBackup„IF a = 0 OR b = 0 OR c = 0 THEN EXIT SUB„„expand 4, 5, 10, 75„LOCATE 4, 35: PRINT "[ RESTORE ]"„„CHDIR "ADRES.BAK"„CHDIR ".."„„„Copy "ADRES.BAK\ADRES.DAT", "ADRES.DAT", 1, 7, 15, 7, 1, 254„Copy "ADRES.BAK\ADRES.LST", LST$, 1, 7, 15, 7, 1, 254„Copy "ADRES.BAK\ADRES.EXE", "ADRES.EXE", 1, 7, 15, 7, 1, 254„„ON ERROR GOTO fout„END SUB„„FUNCTION ScanCode STATIC„    DO„	a$ = INKEY$„    LOOP WHILE a$ = ""„    IF ASC(LEFT$(a$, 1)) = 0 THEN„	ScanCode = -ASC(RIGHT$(a$, 1))„    ELSE„	ScanCode = ASC(a$)„    END IF„END FUNCTION„„ SUB Shadow (UpRow%, LtColum%, LoRow%, RtColum%) STATIC„    DEF SEG = &H40„    mono% = PEEK(&H10)„    IF (mono% AND 48) = 48 THEN„	EXIT SUB            '*** Forget the Shadow if it's monochrome.„    ELSE„	DEF SEG = &HB800„    END IF„„ attr% = SCREEN(LoRow% + 1, RtColum% + 1, -1)  ' Get the attribute.„    attr% = attr% AND 15                     ' Calculate forground.„    attr% = attr% - 8                        ' Remove bright.„    IF attr% < 1 THEN attr% = 8              ' In case color wasn't bright.„„„    FOR row% = UpRow% + 1 TO LoRow% + 1       '***** right edge locations.„	FOR Colum% = RtColum% + 1 TO RtColum% + 2   '***** make it 2 chars Wide.„	    offset% = (row% - 1) * 160 + (Colum% - 1) * 2 + 1„	    POKE offset%, attr%„	NEXT„    NEXT„    row% = LoRow% + 1                        '***** now POKE along the„    FOR Colum% = LtColum% + 2 TO RtColum% + 2      '***** bottom edge„	offset% = (row% - 1) * 160 + (Colum% - 1) * 2 + 1„	POKE offset%, attr%„    NEXT„    DEF SEG„ END SUB„„DEFINT A-Z„SUB Show.KeuseLijst (aDres$(), BackADRES$(), til) STATIC„IF til = 0 THEN PRINT "NO ADresses": SLEEP 2: EXIT SUB„'IF Til < 11 THEN Til = Til„Begin:„BKleur = 7: FKleur = 1„COLOR BKleur, FKleur„CLSScreen„„StartFile = 1 '2„„StartOver:„CLSScreen„GOSUB lijn„GOSUB FilePRintLinks„„„StartToets:„LOCATE 5, 10: PRINT "["; til - 10; "Adresses Found ]"„„LOCATE , , 0„DO„a$ = INKEY$„LOOP UNTIL a$ <> ""„'PRINT a$: END„SELECT CASE UCASE$(a$)„CASE CHR$(8)„„IF LEN(Toetsen$) > 0 THEN„Toetsen$ = LEFT$(Toetsen$, LEN(Toetsen$) - 1)„END IF„„CASE CHR$(13) '<--- Enter„ShowFile TagFIle„GOTO StartOver„„CASE CHR$(27)        '<--- Esc„Toetsen$ = ""„LOCATE 23, 2: PRINT STRING$(30, 205); '<--- HELUPPPP„a$ = ""„„CASE CHR$(0) + ";" '<-- F1„inPutFile til + 1 - 10„KeuseLijst„„CASE CHR$(0) + "<" '<-- F2„expand 10, 20, 15, 60„LOCATE 11, 25: PRINT "Kill the DATA from:"„LOCATE 12, 30: PRINT "--> "; tagBack$; " "; tag$; "<--"„LOCATE 14, 27: PRINT "Keuse [Y/N]:";„DO: a$ = INKEY$: LOOP UNTIL a$ <> ""„PRINT UCASE$(a$)„IF UCASE$(a$) = "Y" OR UCASE$(a$) = "J" THEN„CALL DeleteAdres(TagFIle, til - 10)„CALL DeleteAdres.Lijst(TagFIle, til - 10)„KeuseLijst„ELSE„GOTO StartOver„„END IF„„CASE CHR$(0) + "=" '<-- F3„expand 9, 20, 11, 60„LOCATE 10, 23: PRINT "Realy! (Kill the LIST) [Y/N]: ";„DO: a$ = INKEY$: LOOP UNTIL a$ <> ""„IF UCASE$(a$) = "Y" OR UCASE$(a$) = "J" THEN„KILL "ADres.DAT": KILL "ADRES.LST"„NewDataFIle„KeuseLijst„ELSE„GOTO Begin„END IF„„CASE CHR$(0) + ">"„Backup„GOTO Begin„„CASE CHR$(0) + "?" '<-- F5„RESTOREBackup„CALL KeuseLijst„„CASE CHR$(0) + "@" '<-- F6„inFO.Prog„GOTO StartOver„„CASE CHR$(0) + "A"'<-- F7„info.MrSnow„GOTO StartOver„„CASE CHR$(0) + "B" '<-- F8„COLOR 7, 0: CLS„PRINT "Type EXIT to return to the menu ..."„SHELL„CALL CheckShell„KeuseLijst„„CASE CHR$(0) + "D" '<-- F10„COLOR 7, 0„CLS : PRINT "Thanks for using ADRES.EXE by Mr. Snow"„Reg„END„		    „„CASE CHR$(0) + "P"„o = StartFile„StartFile = StartFile + 1„IF StartFile > til - 10 THEN StartFile = til - 10„„„CASE CHR$(0) + "H"„o = StartFile„StartFile = StartFile - 1„IF StartFile < 1 THEN StartFile = 1„„CASE ELSE„o = StartFile„END SELECT„IF o <> StartFile THEN GOSUB FilePRintLinks„GOTO StartToets„„„„„„„FilePRintLinks:„COLOR 4, 7„LOCATE 10, 2: PRINT " --->                             <---"„„COLOR BKleur, FKleur„„FOR i = 7 TO 21„IF i = 10 THEN COLOR 4, 7 ELSE COLOR 7, 1„LOCATE i, 8: PRINT SPC(28);„LOCATE i, 8: PRINT aDres$(StartFile + i); " "; BackADRES$(StartFile + i)„„IF i = 10 THEN tag$ = aDres$(StartFile + i): tagBack$ = BackADRES$(StartFile + i)„IF i = 10 THEN TagFIle = StartFile + i - 10„„NEXT i„RETURN„„lijn:„LOCATE , , 0„COLOR BKleur, FKleur„FOR lijn = 6 TO 23„LOCATE lijn, 1: PRINT CHR$(179); SPC(38); CHR$(179);„NEXT lijn„„LOCATE 5, 1: PRINT CHR$(213); STRING$(38, 205); CHR$(184);„LOCATE 23, 1: PRINT CHR$(212); STRING$(38, 205); CHR$(190);„LOCATE 1, 1: PRINT CHR$(213); STRING$(78, 205); CHR$(184);„FOR lijn = 2 TO 3„LOCATE lijn, 1: PRINT CHR$(179); SPC(78); CHR$(179);„NEXT lijn„„LOCATE 4, 1: PRINT CHR$(212); STRING$(78, 205); CHR$(190);„„COLOR 0, 0„LOCATE 25, 1: PRINT SPACE$(80);„COLOR BKleur, FKleur„LOCATE 1, 30: PRINT "[ Done by MrSnow '95 ]"„LOCATE 7, 50: PRINT "F1 - Input new adres"„LOCATE 8, 50: PRINT "F2 - Remove adres"„LOCATE 9, 50: PRINT "F3 - Clear List"„LOCATE 10, 50: PRINT "F4 - Make BACKup of LIST"„LOCATE 11, 50: PRINT "F5 - REstore BACKup of LIST"„LOCATE 12, 50: PRINT "F6 - Info About Programm"„LOCATE 13, 50: PRINT "F7 - Info About MrSnow '95"„LOCATE 14, 50: PRINT "F8 - Shell to Dos"„„LOCATE 17, 50: PRINT "F10 - Exit Menu"„COLOR BKleur, 0„RETURN„„„END SUB„„DEFSNG A-Z„SUB ShowFile (t%) STATIC„COLOR 7, 1„OPEN "ADRES.DAT" FOR INPUT AS #1„„FOR i = 1 TO t% - 1„INPUT #1, VNaam$(t%), ANaam$(t%), Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), Tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„NEXT i„INPUT #1, VNaam$(t%), ANaam$(t%), Straat$(t%), Hnummer$(t%), PCode$(t%), Stad$(t%), Tel$(t%), GDatum$(t%), Extra1$(t%), Extra2$(t%)„CLOSE 1„expand 5, 8, 20, 55„LOCATE 6, 10: PRINT "VoorNaam :";„CALL COL(14, 1, VNaam$(t%), 7, 1)„LOCATE 7, 10: PRINT "AchterNaam :";„CALL COL(14, 1, ANaam$(t%), 7, 1)„LOCATE 8, 10: PRINT "Straat :";„CALL COL(14, 1, Straat$(t%), 7, 1)„LOCATE 9, 10: PRINT "HuisNummer :";„CALL COL(14, 1, Hnummer$(t%), 7, 1)„LOCATE 10, 10: PRINT "PostCode :";„CALL COL(14, 1, PCode$(t%), 7, 1)„LOCATE 11, 10: PRINT "Plaats (Stad) :";„CALL COL(14, 1, Stad$(t%), 7, 1)„LOCATE 12, 10: PRINT "TeleFoon :";„CALL COL(14, 1, Tel$(t%), 7, 1)„LOCATE 13, 10: PRINT "GeboorteDatum :";„CALL COL(14, 1, GDatum$(t%), 7, 1)„„LOCATE 15, 10: PRINT "Extra :";„CALL COL(14, 1, Extra1$(t%), 7, 1)„LOCATE 16, 10: PRINT "Extra :";„CALL COL(14, 1, Extra2$(t%), 7, 1)„„LOCATE 18, 10: PRINT "Press [Enter] to return to the ADRES Menu"„DO: LOOP UNTIL INKEY$ = CHR$(13)„END SUB„Nick Kochakian                 EXAMPLE LIST SEARCHER          NickK@worldnet.att.net         01-19-97 (17:00)       QB, QBasic, PDS        103  2544     LISTER.BAS  DECLARE SUB BUILDLST ()„„'----------------------------------------------------------------------------„'Program Name:  Example list searcher„'„'Date made:  1/19/97, 1997„'„'Author:  - Nick Kochakian -„'„'E-mail: nickK@worldnet.att.net„'„'Author's comments: This was very easy for me to make. Too easy infact.„'Fell free to use this program, and you don't have to include my name„'if you do use this code! :)„'----------------------------------------------------------------------------„„CLS„PRINT "Building list... Please wait..."„CALL BUILDLST 'Build an example list„SLEEP 1„CLS„LIST$ = "LIST.TMP" 'List name„OPEN LIST$ FOR INPUT AS #1„LISTS:„'You can take this out if you make your own list:„PRINT "Words stored in list:"„PRINT "A"„PRINT "B"„PRINT "BYE"„PRINT "CD"„PRINT "EXAMPLE"„PRINT "MOUSE"„PRINT ""„SEARCHAGAIN:„KY$ = ""„INPUT "Type in a keyword or a word: ", KY$„PRINT ""„PRINT "Looking up word..."„PRINT ""„IF KY$ = "" THEN KY$ = "A"„KY$ = UCASE$(KY$)„LENOKY = LEN(KY$)„CNT = 0„DO„INPUT #1, INPT$„IF INPT$ = "!" THEN INPUT #1, DEFINI$„IF LEFT$(INPT$, LENOKY) = KY$ THEN PRINT INPT$: CNT = CNT + 1„LOOP UNTIL INPT$ = "[END]"„„PRINT ""„PRINT CNT; "words that match: " + KY$ + " were found"„PRINT ""„CLOSE #1„OPEN LIST$ FOR INPUT AS #1„PRINT "See a definition for a word? (Y)es / (N)o >";„DO„A$ = INKEY$„IF UCASE$(A$) = "Y" THEN PRINT A$: GOTO LOOKDEFI:„LOOP UNTIL UCASE$(A$) = "Y" OR UCASE$(A$) = "N"„PRINT A$„PRINT ""„QUESTIONS:„PRINT "Press 1 to start over, press 2 to keep going, or press 3 to exit."„DO„A$ = INKEY$„LOOP UNTIL A$ = "1" OR A$ = "2" OR A$ = "3"„IF A$ = "1" THEN CLS : GOTO LISTS:„IF A$ = "2" THEN PRINT "": GOTO SEARCHAGAIN:„IF A$ = "3" THEN CLS : PRINT "See you later! :)": END„END„„LOOKDEFI:„PRINT ""„KY$ = ""„INPUT "Type in a word or key word to see a definition for: ", KY$„„KY$ = UCASE$(KY$)„LENOKY = LEN(KY$)„CNTOK = 1„DO„INPUT #1, INPT$„IF LEFT$(INPT$, LENOKY) = KY$ THEN PRINT INPT$; : CNTOK = 2„IF INPT$ = "!" AND CNTOK = 2 THEN INPUT #1, DEFINI$: PRINT DEFINI$: CNTOK = 1: INPT$ = "[END]"„LOOP UNTIL INPT$ = "[END]"„„CLOSE #1„OPEN LIST$ FOR INPUT AS #1„„PRINT ""„GOTO QUESTIONS:„„SUB BUILDLST„OPEN "LIST.TMP" FOR OUTPUT AS #1„PRINT #1, "A,!, - The letter A"„PRINT #1, "MOUSE,!, - Mouse: A computer hardware device"„PRINT #1, "CD,!, - CD: Compact disc"„PRINT #1, "EXAMPLE,!, - Example: Example, exalple, ex."„PRINT #1, "B,!, - The letter B"„PRINT #1, "BYE,!, - Bye: Bye"„PRINT #1, "[END]"„CLOSE #1„END SUB„„Nick Kochakian                 BOUNCING FACES                 NickK@worldnet.att.net         02-12-97 (15:23)       QB, QBasic, PDS        115  2483     FACES.BAS   '----------------------------------------------------------------------------„'Face bounce„'„'1/20/97 - 2/12/97„'1997 By: - Nick Kochakian -„'„'„'My e-mail: nickK@worldnet.att.net„'----------------------------------------------------------------------------„„DEFINT A-Z„„CLS„RANDOMIZE TIMER„„DELY = 999'The delay„„FACES = 50 'The number of faces on the screen at a time„fx = FACES 'X location„fy = FACES 'Y location„fcf = FACES 'Foreground color„fcb = FACES 'Background color„FACC = FACES 'Type of face„dir = FACES 'Face direction„„DIM x(fx)„DIM y(fy)„DIM cf(fcf)„DIM cb(fcb)„DIM FAC(FACC)„DIM d(dir)„fx = 1„fy = 1„fcf = 1„fcb = 1„FACC = 1„dir = 1„„'Place the faces in their random spots for the first time„FOR I = 1 TO FACES„x(fx) = INT(RND * 23) + 1„y(fy) = INT(RND * 80) + 1„cf(fcf) = INT(RND * 15) + 1„cb(fcb) = INT(RND * 7) + 1„FAC(FACC) = INT(RND * 2) + 1„IF FAC(FACC) < 1 THEN FAC(FACC) = 1„d(dir) = INT(RND * 8) + 1„LOCATE x(fx), y(fy): COLOR cf(fcf), cb(fcb): PRINT CHR$(1)„fx = fx + 1„fy = fy + 1„fcf = fcf + 1„fcb = fcb + 1„dir = dir + 1„FACC = FACC + 1„NEXT I„„fx = 1„fy = 1„fcf = 1„fcb = 1„FACC = 1„dir = 1„„'The main loop„DO„LOCATE x(fx), y(fy): COLOR 0, 0: PRINT CHR$(FAC(FACC)): COLOR cf(fcf), cb(fcb)„„IF d(dir) = 1 THEN x(fx) = x(fx) - 1„IF d(dir) = 2 THEN y(fy) = y(fy) + 1: x(fx) = x(fx) + 1„IF d(dir) = 3 THEN x(fx) = x(fx) + 1„IF d(dir) = 4 THEN y(fy) = y(fy) - 1„IF d(dir) = 5 THEN y(fy) = y(fy) - 1: x(fx) = x(fx) - 1„IF d(dir) = 6 THEN y(fy) = y(fy) + 1:  x(fx) = x(fx) - 1„IF d(dir) = 7 THEN y(fy) = y(fy) - 1:  x(fx) = x(fx) + 1„IF d(dir) = 8 THEN y(fy) = y(fy) + 1„„IF x(fx) < 1 THEN x(fx) = 1: GOSUB RERAND:„IF x(fx) > 23 THEN x(fx) = 23: GOSUB RERAND:„IF y(fy) < 1 THEN y(fy) = 1: GOSUB RERAND:„IF y(fy) > 80 THEN y(fy) = 80: GOSUB RERAND:„„LOCATE x(fx), y(fy): COLOR cf(fcf), cb(fcb): PRINT CHR$(FAC(FACC))„„fx = fx + 1„fy = fy + 1„fcf = fcf + 1„fcb = fcb + 1„FACC = FACC + 1„dir = dir + 1„„FOR I = 1 TO DELY„NEXT I„„„IF fx > FACES THEN fx = 1„IF fy > FACES THEN fy = 1„IF fcf > FACES THEN fcf = 1„IF fcb > FACES THEN fcb = 1„IF FACC > FACES THEN FACC = 1„IF dir > FACES THEN dir = 1„„LOOP UNTIL INKEY$ <> ""„END„„RERAND:„d(dir) = INT(RND * 8) + 1„IF d(dir) = 1 THEN d(dir) = 3„IF d(dir) = 2 THEN d(dir) = 5„IF d(dir) = 4 THEN d(dir) = 8„IF d(dir) = 6 THEN d(dir) = 7„„IF d(dir) = 8 THEN d(dir) = 4„IF d(dir) = 7 THEN d(dir) = 6„„RETURN„Steven Edwards                 PASCAL REAL TO QBASIC DOUBLE   Charles Quante                 02-24-97 (00:00)       QB, QBasic, PDS        148  5980     REAL2DBL.BAS'This little routine I came up with proved to be very useful to me. I hope you think it 'would be very useful to others as well.„'„'  From:  Steven Edwards„'  Date:  02/24/97„'  Re:    Converting Pascal Random Access files REAL data types„'         to QBASIC usable DOUBLE data type„'„'„'This was the original pascal data structure from the source code:„'„'    EmployeeType = record„'                 EmpName      : string[30];„'                 Number    : integer;„'                 Wage      : real;„'               end; {record}„'„'This Record structure was used to build a random access file.„'The Pascal string is easy to convert:„'  EmployeeType.EmpName is actually 31 bytes.„'  The first byte is the number of chars in the 30 that the EmpName„'  actually occupies;  the remaining 30 are alpha-numeric chars„'  that make up the actual EmpName plus any garbage left over from„'  previous strings.  Use the number from the first byte to strip„'  out the valid sting from the remaining 30 bytes.„'„'The Pascal real was not so easy to convert:„'  The pascal real is contained in the following layout:„'„'  765432107654321076543210765432107654321076543210  <- bit structure„'  |------|--------------------------------^------|„'  |      |                                ^      |„'  exponent          Significand           ^„'  as byte           as 5 bytes            this is the pos/neg bit„'„'  After searching long and hard for a conversion routine and not„'  finding one, I set about creating my own.  Using the Borland„'  Pascal Language Guide and some old Turbo Pascal source code as„'  a guide, I managed to convert over the information with the„'  following routines.  They basically do the following:„'„'  765432107654321076543210765432107654321076543210„'  |------|-------|-------|-------|-------|-------|„'   byte1   byte2   byte3   byte4   byte5   byte6  <- held as string * 6„'„'  1. Check bit 7 of byte 6 for pos/neg flag„'  2. Check each bit (0-7) of each byte (2-6) of the significand and„'     multiply it out by its respective power„'     (Ex.: byte 2 bit 0 is power of 1 ; byte 6 bit 7 is power of 40)„'  3. Normalize the final number (divide by 2 to the power of 40)„'  4. Calculate in the exponent (from the pascal book : * 2 to the power„'     of the exponent-128)„'  5. Adjust the sign„'„'  Here is a sample of the source I am using.  It only calculates out for„'  reading of the real number.  Maybe someone with more„DECLARE FUNCTION power# (x!, y AS INTEGER)„DECLARE SUB RealConv (RealCost AS ANY, NewCost#)„'  the QBASIC equivalent of the above Pascal struct:„TYPE PASdataRecord„        EmpNameLength AS STRING * 1„        EmpName AS STRING * 30„        Number AS INTEGER„        Wage AS STRING * 6„END TYPE„'  set up the file to be opened and read from QBASIC„DIM EmployeeDAT AS PASdataRecord„OPEN "EMPLOY.DAT" FOR RANDOM ACCESS READ LOCK WRITE AS #1 LEN = LEN(EmployeeDAT)„'  read the file a record at a time until the end„DO WHILE NOT EOF(1)„   CLS„   Count = Count + 1„   SEEK #1, Count„   GET #1, , EmployeeDAT„'  strip out the actual string using the first length byte„   EmployeeDAT.EmpName = MID$(EmployeeDAT.EmpName, 1, ASC(EmployeeDAT.EmpNameLength))„'  the following routine converts the pascal real to Qbasic double„   CALL RealConv(EmployeeDAT.Wage, BASwage#)„   PRINT "Employee number = "; EmployeeDAT.Number„   PRINT "Employee EmpName   = "; EmployeeDAT.EmpName„   PRINT "Employee wage   = "; BASwage„LOOP„„„FUNCTION power# (x, y AS INTEGER)„'  simple x to the power of y function„   power# = EXP(y * LOG(x))„END FUNCTION„„SUB RealConv (Real$, NewCost#)„'  create an array to hold each byte of the real string„   DIM RealHold(6)„   RealHold(1) = ASC(MID$(Real$, 1, 1))„   RealHold(2) = ASC(MID$(Real$, 2, 1))„   RealHold(3) = ASC(MID$(Real$, 3, 1))„   RealHold(4) = ASC(MID$(Real$, 4, 1))„   RealHold(5) = ASC(MID$(Real$, 5, 1))„   RealHold(6) = ASC(MID$(Real$, 6, 1))„'  if positive contains a number then its negative„   positive = &H80 AND RealHold(6)„'  clear the Pos/Neg bit from byte 6„   RealHold(6) = &H80 OR RealHold(6)„'  set up the significand as 1.0„   Significand# = 1#„'  check each individual bit for on/off;  if on then multiply out the„'  number (2,4,8,16,32,64,128, etc.)„   FOR bytecheck = 2 TO 6„'  bit 0 of byte„      IF (RealHold(bytecheck) AND &H1) = 1 THEN„         Significand# = Significand# + power(2, (0 + (bytecheck - 2) * 8))„      END IF„'  bit 1 of byte„      IF (RealHold(bytecheck) AND &H2) = 2 THEN„         Significand# = Significand# + power(2, (1 + (bytecheck - 2) * 8))„      END IF„'  bit 2 of byte„      IF (RealHold(bytecheck) AND &H4) = 4 THEN„         Significand# = Significand# + power(2, (2 + (bytecheck - 2) * 8))„      END IF„'  bit 3 of byte„      IF (RealHold(bytecheck) AND &H8) = 8 THEN„         Significand# = Significand# + power(2, (3 + (bytecheck - 2) * 8))„      END IF„'  bit 4 of byte„      IF (RealHold(bytecheck) AND &H10) = 16 THEN„         Significand# = Significand# + power(2, (4 + (bytecheck - 2) * 8))„      END IF„'  bit 5 of byte„      IF (RealHold(bytecheck) AND &H20) = 32 THEN„         Significand# = Significand# + power(2, (5 + (bytecheck - 2) * 8))„      END IF„'  bit 6 of byte„      IF (RealHold(bytecheck) AND &H40) = 64 THEN„         Significand# = Significand# + power(2, (6 + (bytecheck - 2) * 8))„      END IF„'  bit 7 of byte„      IF (RealHold(bytecheck) AND &H80) = 128 THEN„         Significand# = Significand# + power(2, (7 + (bytecheck - 2) * 8))„      END IF„NEXT„'  normalize the number by dividing calculated number by a number with all„'  bits turned on: 2 to the power of 40„Significand# = Significand# / power(2, 40)„'  calculate in the exponent„Number# = Significand# * power(2, (RealHold(1) - 128))„'  set the pos/neg sign„IF positive > 0 THEN Number# = Number# * -1„NewCost# = Number#„END SUB„John Gallas                    CATALOG BASIC FILES            harryst@castel.nl              05-23-93 (00:00)       QB, PDS                1013 25792    CATALOG.BAS ' CATALOG.BAS   -   By John Gallas   -   Completed on 5/23/1993„'„' You can do whatever you want with this program, but please remember who„' really wrote it.„'„' Its a directory catalogger!  I use it for keeping track of all my„' QB/PDS/PB/etc source code.  I have a directory devoted to source,„' and whenever I get a new file, I just zip it up and copy it into the„' directory.  Then once in awhile, I go into the program and [S]can„' for new files, and it locates all the files that aren't in the database„' that are in the directory, I type in descriptions, and they're added.„' Then I S[o]rt the database using an extremely fast shell sort.  I can„' easily go through all my files and search for certian ones that I want,„' and I can change any of the descriptions with the touch of a button.„' This could be a nice basis for a file system for a BBS if anyone wanted„' to expand on it.„„DEFINT A-Z„„DECLARE SUB Scroll (Direction%, Top%, Left%, Bottom%, Right%, Lines%, Attr%)„DECLARE SUB RemoveRecords ()„DECLARE SUB FastSortI (Inarray() AS ANY, Lower AS INTEGER, Upper AS INTEGER)„DECLARE SUB FindFiles ()„DECLARE SUB ScanForNew ()„DECLARE SUB ScrollDN ()„DECLARE SUB ScrollUP ()„DECLARE SUB ExtractFile ()„DECLARE SUB Sort ()„DECLARE SUB SpecifyNewRecords ()„DECLARE SUB UpdateRecords ()„„DECLARE FUNCTION AllFiles$ ()„DECLARE FUNCTION EditString$ (Text$, MaxX%)„DECLARE FUNCTION TruncateFile% (Handle%, NewLength&)„DECLARE FUNCTION Choice$ (Choices$)„DECLARE FUNCTION DIR$ (Path$)„DECLARE FUNCTION GetSize& (file$)„DECLARE FUNCTION Match% (Filename$, WildCard$)„DECLARE FUNCTION YesNo$ ()„„'-----  Some constants that DIR$ uses„CONST DOS = &H21„CONST SetDTA = &H1A00, FindFirst = &H4E00, FindNext = &H4F00„„'used for the scrolling routines„CONST sUP = &H600, sDOWN = &H700„„CONST True = -1, False = 0„„' Don't forget to load QB.QLB/QBX.QLB!„' $INCLUDE: '\QB45\QB.BI'„„TYPE CatalogType„   Filename   AS STRING * 12„   FileSize   AS LONG„   Description  AS STRING * 60„END TYPE„„DIM SHARED Filename$  'the catalog file name„DIM SHARED Cat AS CatalogType„„CLS„„IF COMMAND$ = "" THEN„   PRINT "Data file: ";„   Filename$ = ""„   Filename$ = EditString$(Filename$, 40)„   IF Filename$ = "" THEN END„ELSE„   Filename$ = COMMAND$„END IF„„OPEN Filename$ FOR RANDOM AS #1 LEN = LEN(Cat)„„'turn off the blinking cursor„LOCATE , , 0, 12, 13„„'prepare the screen„CLS„LOCATE 4, 1„PRINT STRING$(80, 196);„LOCATE 25, 1„PRINT STRING$(80, 196);„„GOSUB PrintHelp„„Total = LOF(1) \ LEN(Cat)„„Down = 5„„StartLine = 1„GOSUB PrintPage„„Selected = 1„Down = 5„„LOCATE , , 0„„DO„„   x$ = "[" + LTRIM$(STR$(Selected)) + "/" + LTRIM$(STR$(Total)) + "]"„   LOCATE 3, 75 - LEN(x$)„   PRINT SPACE$(5) + x$;„   LOCATE Down, 13„   PRINT CHR$(17);„„   DO„      x$ = INKEY$„   LOOP UNTIL LEN(x$)„„   LOCATE Down, 13„   PRINT " ";„„   SELECT CASE x$„   CASE CHR$(0) + CHR$(72) 'up key„      IF Selected > 1 THEN„         Selected = Selected - 1„         Down = Down - 1„         IF Down = 4 THEN„            ScrollDN„            Down = 5„            GET #1, Selected, Cat„            LOCATE Down, 1„            GOSUB PrintLine„         END IF„      END IF„   CASE CHR$(0) + CHR$(80) 'down key„      IF Selected < Total THEN„         Selected = Selected + 1„         Down = Down + 1„         IF Down = 25 THEN„            ScrollUP„            Down = 24„            GET #1, Selected, Cat„            LOCATE Down, 1„            GOSUB PrintLine„         END IF„      END IF„   CASE CHR$(0) + CHR$(73)  'page up„      IF Selected - 20 < Down - 4 THEN„         Selected = Down - 4„      ELSE„         Selected = Selected - 20„      END IF„      'find out which record # is at the top of the screen„      StartLine = Selected - (Down - 5)„      GOSUB PrintPage„   CASE CHR$(0) + CHR$(81)  'page down„      StartLine = Selected - (Down - 5)„      'if we're not on the last page then..„      IF Total - StartLine > 19 THEN„         Selected = Selected + 20„         IF Selected > Total THEN„            Down = Down - (Selected - Total)„            Selected = Total„         END IF„         StartLine = Selected - (Down - 5)„         GOSUB PrintPage„      END IF„   CASE CHR$(0) + CHR$(71)  'home„      Selected = 1„      Down = 5„      StartLine = Selected - (Down - 5)„      GOSUB PrintPage„   CASE CHR$(0) + CHR$(79)  'end„      IF Total < 20 THEN„         Selected = Total„         Down = 5 + Selected„         StartLine = 1„      ELSE„         StartLine = Total - 19„         Selected = Total„         Down = 24„      END IF„      GOSUB PrintPage„   CASE CHR$(13)  'return, edit the description field„      GET #1, Selected, Cat„      Temp$ = RTRIM$(Cat.Description)„      LOCATE Down, 20„      PRINT ">";„      Temp$ = EditString$(Temp$, 60) '60 is the maximum length allowed.„      'Now fill in what they wrote.  If they wrote something different from„      'the origional, but then aborted it, editstring$ will return the„      'unchanged string.„      LOCATE Down, 20, 0„      PRINT " ";„      Cat.Description = Temp$„      PUT #1, Selected, Cat„      LOCATE Down, 1„      GOSUB PrintLine„      Temp$ = ""„   CASE CHR$(27), "Q", "q"„      EXIT DO„   CASE "R", "r" 'remove files„      RemoveRecords„      GOSUB PrintHelp„      Total = LOF(1) \ LEN(Cat)„      IF Selected > Total THEN„         Selected = Selected - 1„         Down = Down - 1„         IF Down = 4 THEN„            ScrollDN„            Down = 5„            GET #1, Selected, Cat„            LOCATE Down, 1„            GOSUB PrintLine„         END IF„      END IF„      StartLine = Selected - (Down - 5)„      GOSUB PrintPage„   CASE "S", "s" 'scan for new files in the directory„      ScanForNew„      LOCATE , , 0„      StartLine = Selected - (Down - 5)„      GOSUB PrintPage„      GOSUB PrintHelp„   CASE "F", "f", "\" 'look for files, the \ is for LIST users .. :-)„      FindFiles„      LOCATE , , 0„      StartLine = Selected - (Down - 5)„      GOSUB PrintPage„      GOSUB PrintHelp„   CASE "O", "o" 'sort records„      Sort„      GOSUB PrintPage„      GOSUB PrintHelp„   CASE "U", "u"  'update records„      UpdateRecords„      GOSUB PrintPage„      GOSUB PrintHelp„„   END SELECT„„LOOP„„LOCATE 25, 1: PRINT SPACE$(80);„LOCATE 24, 1„„END„„„PrintLine:„PRINT USING "\          \ ###### \                                                          \"; Cat.Filename; Cat.FileSize; Cat.Description;„RETURN„„PrintPage:„Dn = 5„FOR x = StartLine TO Total„   GET #1, x, Cat„   LOCATE Dn, 1„   PRINT USING "\          \ ###### \                                                          \"; Cat.Filename; Cat.FileSize; Cat.Description;„   Dn = Dn + 1„   IF Dn = 25 THEN EXIT FOR„NEXT x„IF Dn < 25 THEN 'fill the rest with blanks„   FOR x = Dn TO 24„      LOCATE x, 1„      PRINT SPACE$(80);„   NEXT x„END IF„RETURN„„PrintHelp:„LOCATE 1, 1„PRINT "[Catalog 1.0  By John Gallas]     [S]can for new files  [F]ind file(s)         "„PRINT "                                  [R]emove files        [U]pdate records       "„PRINT "  Filename    Size  Description   S[o]rt database       [Q]uit                 "„RETURN„„FUNCTION AllFiles$„' Returns a string of all the files in our database, seperated by plus's.„' This is used with INSTR to check for new files.„„Temp$ = ""„x = LOF(1) \ LEN(Cat)  'find the total # of records„FOR I = 1 TO x„   GET #1, I, Cat„   Temp$ = Temp$ + "+" + RTRIM$(Cat.Filename)„NEXT I„IF LEN(Temp$) THEN Temp$ = Temp$ + "+"„AllFiles$ = Temp$„„END FUNCTION„„FUNCTION Choice$ (Choices$)„„DO„   B$ = INKEY$„   B$ = LCASE$(B$)„   IF LEN(B$) THEN„      IF INSTR(LCASE$(Choices$), B$) THEN EXIT DO„   END IF„LOOP„Choice$ = B$„„END FUNCTION„„FUNCTION DIR$ (FileSpec$) STATIC„' this function was written by Dave Cleary„„DIM DTA AS STRING * 44, Regs AS RegTypeX„Null$ = CHR$(0)„„'-----  Set up our own DTA so we don't destroy COMMAND$„Regs.ax = SetDTA                    'Set DTA function„Regs.dx = VARPTR(DTA)               'DS:DX points to our DTA„Regs.ds = -1                        'Use current value for DS„INTERRUPTX DOS, Regs, Regs          'Do the interrupt„„'-----  Check to see if this is First or Next„IF LEN(FileSpec$) THEN              'FileSpec$ isn't null, so„   'FindFirst„   FileSpecZ$ = FileSpec$ + Null$   'Make FileSpec$ into an ASCIIZ„   'string„   Regs.ax = FindFirst              'Perform a FindFirst„   Regs.cx = 0                      'Only look for normal files„   Regs.dx = SADD(FileSpecZ$)       'DS:DX points to ASCIIZ file„   Regs.ds = -1                     'Use current DS„ELSE                                'We have a null FileSpec$,„   Regs.ax = FindNext               'so FindNext„END IF„„INTERRUPTX DOS, Regs, Regs          'Do the interrupt„„'-----  Return file name or null„IF Regs.flags AND 1 THEN            'No files found„   DIR$ = ""                        'Return null string„ELSE„   Null = INSTR(31, DTA, Null$)     'Get the filename found„   DIR$ = MID$(DTA, 31, Null - 30)  'It's an ASCIIZ string starting„END IF                              'at offset 30 of the DTA„„END FUNCTION„„FUNCTION EditString$ (Text$, MaxX)„„' heres my cheap little string editor„„OldText$ = Text$ 'incase they want to abort later„Down = CSRLIN„across = POS(0)„OrgAc = across„in = LEN(Text$) + 1„IF in > 1 THEN across = across + in - 1„FT = True  ' first time through flag„„DO„   LOCATE Down, OrgAc„   PRINT Text$ + STRING$(MaxX - LEN(Text$), 32);„   IF InsOn THEN„      IF across <= 80 THEN„         LOCATE Down, across, 1, 1, 30„      ELSE„         LOCATE Down, 80, 1, 1, 30„      END IF„   ELSE„      IF across <= 80 THEN„         LOCATE Down, across, 1, 12, 30„      ELSE„         LOCATE Down, 80, 1, 12, 30„      END IF„   END IF„   DO„      x$ = INKEY$„      IF LEN(x$) THEN„         IF ASC(x$) < 32 THEN„            IF x$ <> CHR$(8) AND x$ <> CHR$(9) AND x$ <> CHR$(13) AND x$ <> CHR$(27) AND LEN(x$) = 1 THEN x$ = ""„         END IF„      END IF„   LOOP UNTIL LEN(x$)„„   IF LEN(x$) = 2 THEN„      SELECT CASE x$„      CASE CHR$(0) + CHR$(77)  'right„         FT = False„         IF in < MaxX AND in <= LEN(Text$) THEN„            across = across + 1„            in = in + 1„         END IF„      CASE CHR$(0) + CHR$(75) 'left„         FT = False„         IF in > 1 THEN„            in = in - 1„            across = across - 1„         END IF„      CASE CHR$(0) + CHR$(83)  'del„         Text$ = LEFT$(Text$, in - 1) + MID$(Text$, in + 1)„         FT = False„      CASE CHR$(0) + CHR$(82)  'insrt„         FT = False„         InsOn = (InsOn = False)„      CASE CHR$(0) + CHR$(71)  'home„         FT = False„         in = 1„         across = OrgAc„      CASE CHR$(0) + CHR$(79) 'end„         FT = False„         n = LEN(Text$) + 1„         d = n - in„         in = n„         across = across + d„      CASE ELSE„      END SELECT„   ELSE„      SELECT CASE x$„      CASE CHR$(8)„         IF in > 1 THEN„            FT = False„            Text$ = LEFT$(Text$, in - 2) + MID$(Text$, in)„            across = across - 1„            in = in - 1„         END IF„      CASE CHR$(27)„         EditString$ = OldText$  'restore it„         EXIT FUNCTION„      CASE CHR$(13)„         LOCATE , , 1, 12, 13„         EditString$ = Text$„         EXIT FUNCTION„      CASE ELSE„         IF FT = True THEN„            Text$ = ""„            across = OrgAc„            in = 1„            FT = False„         END IF„         IF in <= MaxX THEN„            IF FT = True THEN Text$ = ""„            IF LEN(Text$) < in THEN Text$ = Text$ + SPACE$(in - LEN(Text$))„            IF InsOn THEN„               IF LEN(Text$) < MaxX THEN„                  Text$ = LEFT$(Text$, in - 1) + x$ + MID$(Text$, in)„                  in = in + 1„                  across = across + 1„               END IF„            ELSE„               MID$(Text$, in) = x$„               in = in + 1„               across = across + 1„            END IF„         END IF„      END SELECT„   END IF„LOOP„„END FUNCTION„„SUB FastSortI (Inarray() AS CatalogType, Lower AS INTEGER, Upper AS INTEGER)„„' This routine was writen by Ryan Wellman.„' Copyright 1992, Ryan Wellman, all rights reserved.„' Released as Freeware October 22, 1992.„' You may freely use, copy & modify this code as you see„' fit.  Under the condition that I am given credit for„' the original sort routine, and partial credit for modifided„' versions of the routine.„„' vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv„'„' Ok, heres your partial credit Ryan.  I changed it to„' specifically sort my Catalog array by Filename.„'„' ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^„„Increment = (Upper + Lower)„L2 = Lower - 1„„DO„   ' The Increment variable is used to check how far apart the„   ' program will check.  Also cut the size of increment in half„   ' to decrese Increment which makes the sorted array more„   ' accurate.„„   Increment = Increment \ 2„   I2 = Increment + L2„„   ' Step through the array 1 element at a time and compare the„   ' elements 'Increment' entries away.„„   FOR Index = Lower TO Upper - Increment„      IF Inarray(Index).Filename > Inarray(Index + Increment).Filename THEN„         SWAP Inarray(Index), Inarray(Index + Increment)„„         ' If the the current pointer for Index is greater„         ' than Increment then step back by increment - 1„         ' so that the variable can be put as close as it„         ' can get to it's final point.„„         IF Index > I2 THEN„„            ' Store a pointer to the curent position so„            ' that it can be restored when this entry is„            ' in it's place.  Causes it to run over 10„            ' times faster on large random arrays.  If„            ' CutPoint has a value then set a new one.„„            CutPoint = Index„            StopNow = 0„            DO„               Index = Index - Increment„               IF Inarray(Index).Filename > Inarray(Index + Increment).Filename THEN„„                  SWAP Inarray(Index), Inarray(Index + Increment)„                  ' Reduce the array pointer so that you can slide„                  ' the current number almost to it's finished„                  ' position.„„               ELSE„                  StopNow = -1„                  Index = CutPoint„               END IF„            LOOP UNTIL StopNow„„            ' Reduce the array pointer so that you can slide„            ' the current number almost to it's finished„            ' position.„„         END IF„      END IF„„   NEXT Index„„LOOP UNTIL Increment <= 1„„END SUB„„SUB FindFiles„„' Used in searching for a certian file„„SHARED Selected, Down, Total„SHARED DescPattern$, WildCard$„„FOR x = 1 TO 3„   LOCATE x, 1„   PRINT SPACE$(80);„NEXT x„„LOCATE 1, 1, 1, 12, 13„PRINT "Search for Filename or Description? ";„x$ = Choice$("FDQ" + CHR$(27))„„IF x$ = "q" OR x$ = CHR$(27) THEN EXIT SUB„„LOCATE 1, 1„„PRINT SPACE$(80)„„IF x$ = "f" THEN GOTO FilenameSearch„„LOCATE 1, 1„PRINT "[Description Search]"„PRINT "Search pattern: ";„x$ = DescPattern$„DescPattern$ = EditString$(DescPattern$, 60)„IF LEN(DescPattern$) = 0 THEN EXIT SUB„„PRINT„PRINT "Searching..";„„FOR x = Selected + 1 TO Total„   GET #1, x, Cat„   IF INSTR(RTRIM$(UCASE$(Cat.Description)), UCASE$(DescPattern$)) THEN„      'found it„      Selected = x„      Down = 5„      LOCATE , , 0„      EXIT SUB„   END IF„NEXT x„„LOCATE 3, 1„PRINT SPACE$(80);„LOCATE 3, 1„PRINT "Not found.  Press a key..";„x$ = INPUT$(1)„EXIT SUB„„„„FilenameSearch:„„LOCATE 1, 1„PRINT "[Filename Search]"„PRINT "Enter filename to search for (WildCards are allowed)"„PRINT ":";„„WildCard$ = EditString$(WildCard$, 12)„IF WildCard$ = "" THEN EXIT SUB„WildCard$ = UCASE$(WildCard$)„„'look for it from this point„„LOCATE 2, 1: PRINT SPACE$(160);„LOCATE 2, 1„PRINT "Searching for: " + WildCard$„„FOR x = Selected + 1 TO Total„   GET #1, x, Cat„   Temp$ = RTRIM$(Cat.Filename)„   IF Match(Temp$, WildCard$) THEN„      'found a match„      Selected = x„      Down = 5„      EXIT SUB„   END IF„NEXT x„„'didn't find any„LOCATE 2, 1„PRINT "File not found." + SPACE$(12)„PRINT "Press a key..";„x$ = INPUT$(1)„„END SUB„„FUNCTION GetSize& (file$)„'returns the size of a file„„OPEN file$ FOR BINARY AS #2„GetSize& = LOF(2)„CLOSE #2„„END FUNCTION„„FUNCTION Match% (Filename$, WildCard$)„„'checks to see if Filename$ matches Wildcard$„„'first seperate the first part and extention in filename$„x = INSTR(Filename$, ".")„„IF x THEN„   Ext$ = MID$(Filename$, x + 1)„   First$ = LEFT$(Filename$, x - 1)„ELSE„   Ext$ = "   "„   First$ = Filename$„END IF„„IF LEN(First$) < 8 THEN First$ = First$ + STRING$(8 - LEN(First$), "?")„IF LEN(Ext$) < 3 THEN Ext$ = Ext$ + STRING$(3 - LEN(Ext$), "?")„„'put them back together with ?'s added where there are blanks„FiName$ = First$ + "." + Ext$„„'now change wildcard from (for instance) "TE*.*" to "TE??????.???"„„IF INSTR(WildCard$, ".") = 0 THEN„   WildCard$ = WildCard$ + ".*"„END IF„IF RIGHT$(WildCard$, 1) = "." THEN WildCard$ = WildCard$ + "*"„IF LEFT$(WildCard$, 1) = "." THEN WildCard$ = "*" + WildCard$„„Temp$ = UCASE$(WildCard$)„Temp2$ = ""„InExt = 0„„'go through Temp$ (wildcard$) byte by byte, and when we come upon a *, add„'the appropriate amount of ?'s„FOR x = 1 TO LEN(Temp$)„   t$ = MID$(Temp$, x, 1)„   IF t$ <> "*" THEN 'assume that its good„      IF t$ = "." THEN„         Dot = x„         IF LEN(Temp2$) < 8 THEN Temp2$ = Temp2$ + STRING$(8 - LEN(Temp2$), "?")„      END IF„      Temp2$ = Temp2$ + t$„   ELSE„      'fill it with ?'s„      'if we're in the filename part, add 8-len(temp$) ?'s„      IF LEN(Temp2$) < 8 THEN„         Temp2$ = Temp2$ + STRING$(8 - LEN(Temp2$), "?")„      ELSE„         'otherwise add 3-len(temp$)„         Temp2$ = Temp2$ + STRING$(3 - LEN(MID$(Temp$, Dot + 1)), "?")„      END IF„      'and continue on..„   END IF„NEXT x„„'trim off any extra ?'s we might've added accidentally if they put in more„'than 1 * on the same half of the period.„IF LEN(Temp2$) > 12 THEN Temp2$ = LEFT$(Temp2$, 12)„„Temp$ = Temp2$: Temp2$ = ""„„'now compare Temp$ (the fixed up wildcard) and Filename$„FOR x = 1 TO LEN(Temp$)„„   a$ = MID$(Temp$, x, 1)„   B$ = MID$(FiName$, x, 1)„   IF a$ <> B$ THEN„      IF a$ <> "?" THEN„         'No match„         Match = 0„         EXIT FUNCTION„      END IF„   END IF„„NEXT x„„'found a match!„Match = -1„„END FUNCTION„„SUB RemoveRecords„„SHARED Selected, Total„„GET #1, Selected, Cat„„'clear the top„FOR x = 1 TO 3„   LOCATE x, 1„   PRINT SPACE$(80);„NEXT x„„LOCATE 1, 1„PRINT "[Remove " + RTRIM$(Cat.Filename) + "]  ";„PRINT "[File is ";„IF DIR$(RTRIM$(Cat.Filename)) = "" THEN„   PRINT "not ";„END IF„PRINT "on disk]";„„LOCATE 3, 1„LOCATE , , 1, 12, 13„PRINT "Are you sure you want to remove this record? ";„x$ = YesNo$„LOCATE , , 0„„GET #1, Selected, Cat„Temp$ = RTRIM$(Cat.Filename)„„' this part is really neat!  It grabs all the records in front of the one„' you're about to delete, and it pulls them all forward.. then (heres the„' REALLY neato party) it chops the length of the file using an interrupt,„' so the record is actually physically removed from the file!!„IF x$ = "Y" THEN„   'bring all the files in front of it down 1..„   FOR I = Selected TO Total - 1„      GET #1, I + 1, Cat„      PUT #1, I, Cat„   NEXT I„   Handle = FILEATTR(1, 2)„   x = TruncateFile(Handle, LOF(1) - LEN(Cat)) 'subtract 1 record„„   IF DIR$(RTRIM$(Temp$)) <> "" THEN„      LOCATE 3, 1„      LOCATE , , 1, 12, 13„      PRINT SPACE$(80);„      LOCATE 3, 1„      PRINT "Delete file too? ";„      x$ = YesNo$„      LOCATE , , 0„      IF x$ = "Y" THEN„         KILL RTRIM$(Temp$)„      END IF„   END IF„„END IF„„END SUB„„SUB ScanForNew„'Scans for new files in the directory that aren't in the database„„SHARED Total„„'clear the top„LOCATE 1, 1„PRINT SPACE$(240);„„LOCATE 1, 1, 1, 12, 13„PRINT "[Scanning for new files]"„„'get a list of all the files on record„FileList$ = AllFiles$„„'get each file„x$ = DIR$("*.*")„DO WHILE LEN(x$)„   TempFile$ = UCASE$(LEFT$(x$, LEN(x$) - 1))„   'search the database for it„   x = INSTR(FileList$, "+" + TempFile$ + "+")„   IF x = 0 AND TempFile$ <> UCASE$(RTRIM$(Filename$)) THEN 'new file„„      'found one!„      LOCATE 2, 1„      PRINT "Found file: " + TempFile$„      PRINT "Add to database? ";„      DO„         x$ = UCASE$(INKEY$)„         IF LEN(x$) THEN„            IF INSTR("YN" + CHR$(27), x$) THEN EXIT DO„         END IF„      LOOP„      IF x$ = CHR$(27) THEN LOCATE , , 0: EXIT SUB„      PRINT x$„      x$ = UCASE$(x$)„      IF x$ = "Y" THEN„         LOCATE 3, 1„         PRINT "Description: [" + SPACE$(60) + "]";„         LOCATE , 15„         De$ = EditString$("", 60)„         Cat.Description = De$ + SPACE$(60)  'fill the rest with spaces„         'get the size„         Cat.FileSize = GetSize&(TempFile$)„         Cat.Filename = TempFile$ + SPACE$(12)„         'save the record„         Total = Total + 1„         PUT #1, Total, Cat„      ELSE„         LOCATE 3, 1„         PRINT SPACE$(80);„         LOCATE 3, 1„         PRINT "Do you want me to delete it? ";„         x$ = YesNo$„         IF x$ = "Y" THEN„            KILL TempFile$„         END IF„      END IF„      'clear the top„      FOR x = 1 TO 3„         LOCATE x, 1„         PRINT SPACE$(80);„      NEXT x„      LOCATE 1, 1„      PRINT "[Scanning for new files]"„   END IF„„   x$ = DIR$("")„„LOOP„„END SUB„„SUB Scroll (Direction%, Top%, Left%, Bottom%, Right%, Lines%, Attr%)„„DIM Reg AS RegType  'need $include qb.bi„Top% = Top% - 1„Left% = Left% - 1„Bottom% = Bottom% - 1„Right% = Right% - 1„Reg.ax = Direction% + Lines%     'zero lines will clear viewport„Reg.bx = Attr% * 256             'attribute for blank area„Reg.cx = Top% * 256 + Left%      'Top Left Coords„Reg.dx = Bottom% * 256 + Right%  'Bottom Right Coords„INTERRUPT &H10, Reg, Reg„„END SUB„„SUB ScrollDN„„Scroll sDOWN, 5, 1, 24, 80, 1, 0„„END SUB„„SUB ScrollUP„„Scroll sUP, 5, 1, 24, 80, 1, 0„„END SUB„„SUB Sort„„LOCATE 1, 1: PRINT SPACE$(240);„„LOCATE 1, 1„PRINT "[Sorting Records]"„„x = LOF(1) \ LEN(Cat)„„DIM Temp(1 TO x) AS CatalogType„„PRINT "Reading...";„„FOR I = 1 TO x„„   GET #1, I, Temp(I)„„NEXT I„„PRINT "Sorting...";„„FastSortI Temp(), 1, x„„PRINT "Writing...";„„FOR I = 1 TO x„„   PUT #1, I, Temp(I)„„NEXT I„„ERASE Temp„„END SUB„„FUNCTION TruncateFile% (Handle%, NewLength&)„'Edits the length of a file„„'Handle% = FILEATTR(1, 2)  'filenumber, 2„„DIM Reg AS RegTypeX„„'First, position the file read/write pointer to the place where the„'truncation should take place. We can't trust BASIC's SEEK statement„'because the movement is sometimes held until the next read/write.„„Reg.ax = &H4200             'DOS "Set file pointer" function„Reg.bx = Handle%„„'We go through these steps to prevent "overflow" errors when„'NewLength& > 32767. The high word of the file position goes in CX„'and the low word goes in DX. Since BASIC treats integers and longs„'"signed" variables, we need to take to extra steps to prevent„'an overflow error as we break the long integer down.„„DEF SEG„Addr% = VARPTR(NewLength&)„Reg.cx = CVI(CHR$(PEEK(Addr% + 2)) + CHR$(PEEK(Addr% + 3)))„Reg.dx = CVI(CHR$(PEEK(Addr%)) + CHR$(PEEK(Addr% + 1)))„CALL INTERRUPTX(&H21, Reg, Reg)„IF Reg.flags AND 1 THEN„   Status% = Reg.ax„   GOTO TruncateExit„END IF„„'Now, write 0 bytes.„Reg.ax = &H4000                 'Dos "Write file or device"„Reg.bx = Handle%„Reg.cx = 0                      'Write 0 bytes„Reg.dx = 0                      'These are not needed, but make„Reg.ds = 0                      ' sure they're zero, just in case„CALL INTERRUPTX(&H21, Reg, Reg)„IF Reg.flags AND 1 THEN„   Status% = Reg.ax„END IF„„TruncateExit:„TruncateFile% = Status%„„END FUNCTION„„SUB UpdateRecords„'Goes through all the records and makes sure their sizes are correct and that„'the file is still there.„„SHARED Total„„Removed = 0„„LOCATE 1, 1: PRINT SPACE$(240);„LOCATE 1, 1„„PRINT "[Update Records]"„PRINT "Scanning: ";„„FOR x = 1 TO Total„„   LOCATE 2, 11„   GET #1, x, Cat„   PRINT Cat.Filename + SPACE$(2);„   x$ = DIR$(RTRIM$(Cat.Filename))„   IF LEN(x$) = 0 THEN„      PRINT " [File not on disk] ";„      LOCATE , , 1, 12, 13„      d = CSRLIN: a = POS(0)„      LOCATE 3, 1„      PRINT "Description: "; Cat.Description„      LOCATE d, a„      PRINT "Remove? ";„      x$ = YesNo$„      IF x$ = "Y" THEN  'remove this record„         FOR x2 = x + 1 TO Total„            GET #1, x2, Cat„            PUT #1, x2 - 1, Cat„         NEXT x2„         Removed = Removed + 1„      END IF„      LOCATE , , 0„      LOCATE 3, 1: PRINT SPACE$(80);„      GOTO SkipToEnd„   END IF„   PRINT "Size: ";„   x2& = GetSize&(RTRIM$(Cat.Filename))„   PRINT x2&;„   PRINT SPACE$(6 - LEN(STR$(x2&)));„   Cat.FileSize = x2&„   PUT #1, x, Cat„„SkipToEnd:„„NEXT x„„Handle = FILEATTR(1, 2)„x = TruncateFile(Handle, LOF(1) - (Removed * LEN(Cat))) 'erase removed„'records„Total = Total - Removed„„END SUB„„FUNCTION YesNo$„„DO„   x$ = UCASE$(INKEY$)„   IF LEN(x$) THEN IF INSTR("YN", x$) THEN YesNo$ = x$: EXIT FUNCTION„LOOP„„END FUNCTION„Jason Lashua                   DOCTOR STUPID (REALLY STUPID)  rms015911@interramp.com        03-04-97 (21:54)       QB, QBasic, PDS        122  4604     DRSTUPID.BAS'„'„'„'„'                  DOCTOR STUPID - A WEIRD A.I. GAME BY„'             JASON LASHUA (AKA NEURALFRAUD) . PRESS F5 TO RUN„'„'            IF YOU MODIFY THIS, GIVE ME CREDIT WHERE IT IS DUE!„'           I WASTED 17 MINUTES ON THIS THING. .. SOOO... LIKE IT!„'„'             YOU CANNOT TYPE COMMA'S IN THE PHRASES.. ..„'„'„'„'„'„'„' All this does, is setup the random numbers.„'„RANDOMIZE TIMER„t = RND * 100„d = RND * 10„I = TIMER * RND„RANDOMIZE TIMER + d + RND * 10„FOR u = 1 TO RND * 100: j = RND * 5: NEXT„RANDOMIZE t + TIMER„'„' the game starts here.„'„CLS                                      ' clear screen„DIM n$(200)                              ' max #of replies = 200„FOR a = 1 TO 49                          ' cycle through all 49 replies„READ n$(a)                               ' read reply #n (0 to 49)„NEXT a                                   ' do it again„PRINT "DOCTOR STUPID V1.0 - LOADING DATA."; : SLEEP 1: PRINT "...READY"„PRINT„PRINT "Hi there, I'm Doctor Stupid, How are you doing today?"„PRINT "to exit, type 'CAN I GO NOW DOCTOR STUPID?'"„DO                                       ' setup the game loop.„COLOR 8 + RND * 7                        ' random colors„INPUT "", a$                             ' get input from user„a$ = UCASE$(a$)                          ' make all input upper-case„IF a$ = "CAN I GO NOW DOCTOR STUPID?" THEN GOTO leave  ' magic phrase„COLOR 1 + INT(RND * 8)                   ' more random colors„40 g$ = n$(1 + INT(RND * a))             ' try to avoid repeating„IF INSTR(h$, g$) > 0 THEN GOTO 40        ' try to avoid repeating„IF LEN(h$) > 1000 THEN h$ = MID$(h$, 50) ' shorten„h$ = h$ + g$                             '„PRINT g$                                 ' print the reply„FOR f = 1 TO d: NEXT                     ' cycle through numbers„LOOP                                     ' loop„'„' the exit procedure....„'„leave:„PRINT "why do you want to go?"„INPUT a$„'„' if  the word "because" or "none of your" is found.. give the user bullshit„'„IF INSTR(a$, "because") > 0 THEN PRINT "Because isnt good enough.. now, let's try again..": SLEEP 2: GOTO leave„IF INSTR(a$, "none of your") > 0 THEN PRINT "Wanna get smart? ok.. i see... fine.. leave.. muthafukka!": SLEEP 2: CLS : PRINT "THANK YOU FOR TRYING DOCTOR STUPID! (C)1997 JASON LASHUA": END„IF a$ = "" THEN PRINT "i need a REAL reason before i can let you go.....": SLEEP 2: GOTO leave ELSE PRINT "OK, fine.. buh-bye ... come back again!": SLEEP 2: CLS : PRINT "THANK YOU FOR TRYING DOCTOR STUPID! (C)1997 JASON LASHUA": END„GOTO leave„'„'This is where Doctor stupid get's his replies....„'„DATA "oh, and why not?"„DATA "intreguing..."„DATA "don't SNAP at ME!"„DATA "don't you have anything intelligent to say?"„DATA "i was unaware of that, please explain more..."„DATA "i am really getting sick of this, go away."„DATA "talk about not getting the point...gesh"„DATA "i think so..."„DATA "Look!, it's cap'n crunch... and he's inviting you to lunch!"„DATA "i like it here, do you like it here?"„DATA "i'm not certain that's feasible"„DATA "do you suck dicks?"„DATA "are you a peter puffer?"„DATA "i bet you're the type of guy that'd fuck a person up the ass and not even        have the common decency to give him a reach around. i'll be watching you"„DATA "only steers and queers come from texas, and you dont look to much like a steer    to me..."„DATA "can i shoot you and get it over with?"„DATA "what's wrong?"„DATA "do you feel ashamed by your actions?"„DATA "what do you think?"„DATA "sorry, cant help you there"„DATA "i could arrange that"„DATA "i see that happening REAL soon..."„DATA "yup"„DATA "yes"„DATA "no"„DATA "ahahaha"„DATA "jungle bunny."„DATA "oh c'mon baby!"„DATA "wanna kill somebody?"„DATA "thats illegal you know"„DATA "you can go to jail for that.."„DATA "your death"„DATA "do i have to give you a reason??"„DATA "what the fuck do you expect from me negroid?„DATA "go eat some twinkies"„DATA "do you interract with other beings?"„DATA "what are the voices in your head telling you...?"„DATA "don't we all?"„DATA "that doesn't supprise me for some reason"„DATA "oh god, you're giving me an errection!!! Stop it!"„DATA "lickedy lick lick lickedy lick lick"„DATA "balls..."„DATA "spem..."„DATA "muff..."„DATA "cheese"„DATA "vaginal blood fart"„DATA "it's illegal to do that.."„DATA "have phun."„DATA "cool"„DATA "i'm bored"„DATA "here, have a beer, you need it"„DATA "what is your favorate color"„DATA "my dick hurts.. "„DATA "my balls hurt"„„Angelo Ken Pesce               NUMBER TO LITERAL (ITALIAN)    us0082@uniserv.uniplan.it      03-19-97 (15:00)       QB, QBasic, PDS        273  5490     NUMBER.BAS  DECLARE SUB readdata ()„DECLARE FUNCTION u$ (i!)„DECLARE FUNCTION d$ (i!)„DECLARE FUNCTION d1$ (i!)„DECLARE FUNCTION c$ (i!)„DECLARE FUNCTION m$ (i!)„DECLARE FUNCTION m1$ (i$)„DECLARE FUNCTION m2$ (i$)„DECLARE FUNCTION decod$ (i$)„DECLARE SUB init ()„REM ----------------------------------------------------------„DEFLNG A-Z„DIM SHARED unit(9) AS STRING„DIM SHARED dec(9) AS STRING„DIM SHARED dec1(8) AS STRING„DIM SHARED millepre(2) AS STRING„DIM SHARED miliopre(2) AS STRING„DIM SHARED miliapre(2) AS STRING„REM ----------------------------------------------------------„DATA "zero","uno","due","tre","quattro","cinque","sei","sette","otto","nove","."„DATA "dieci", "undici", "dodici", "tredici", "quattordici", "quindici", "sedici", "diciassette", "diciotto", "diciannove","."„DATA "venti","trenta","quaranta","cinquanta","sessanta","settanta","ottanta","novanta","."„DATA "mille","mila","."„DATA "unmilione","milioni","."„DATA "unmiliardo","miliardi","."„REM ----------------------------------------------------------„CALL init„DO„INPUT "Numero (premi invio per uscire)"; i$„PRINT : PRINT "----"„PRINT "Cifre:"; LEN(i$): PRINT„dd$ = decod(i$)„PRINT "> "; dd$„IF dd$ = "**ERR.2**" THEN PRINT : PRINT "Errore n.2: Numero fuori limite"„PRINT "----": PRINT : PRINT„LOOP„„DEFSNG A-Z„FUNCTION c$ (i)„REM da 100 a 999„i$ = STR$(i)„pre$ = LEFT$(i$, 2)„pre1$ = RIGHT$(i$, 2)„pr = VAL(pre$)„pr1 = VAL(pre1$)„IF pr = 1 THEN d11$ = "" ELSE d11$ = u$(pr)„SELECT CASE pr1„CASE IS = 0„c$ = d11$ + "cento"„CASE IS <= 9„c$ = d11$ + "cento" + u$(pr1)„CASE IS <= 19„c$ = d11$ + "cento" + d$(pr1)„CASE ELSE„IF VAL(LEFT$(pre1$, 1)) = 8 THEN add$ = "cent" ELSE add$ = "cento"„c$ = d11$ + add$ + d1$(pr1)„END SELECT„END FUNCTION„„FUNCTION d$ (i)„REM da dieci a diciannove„d$ = dec(i - 10)„END FUNCTION„„FUNCTION d1$ (i)„REM da venti a novantanove„i$ = STR$(i)„decimal$ = LEFT$(i$, 2)„unit1$ = RIGHT$(i$, 1)„IF VAL(unit1$) = 0 THEN GOTO vz1„IF VAL(unit1$) = 1 OR VAL(unit1$) = 8 THEN„d11$ = LEFT$(dec1(VAL(decimal$) - 1), LEN(dec1(VAL(decimal$) - 1)) - 1)„ELSE d11$ = dec1(VAL(decimal$) - 1)„END IF„d1$ = d11$ + u(VAL(unit1$))„GOTO ve1„vz1:„d1$ = dec1(VAL(decimal$) - 1)„GOTO ve1„ve1:„END FUNCTION„„FUNCTION decod$ (i$)„IF i$ = "" THEN END„i = VAL(i$)„SELECT CASE i„CASE IS <= 9„decod$ = u$(i)„CASE IS <= 19„decod$ = d$(i)„CASE IS <= 99„decod$ = d1$(i)„CASE IS <= 999„decod$ = c$(i)„CASE IS <= 999999„decod$ = m$(i)„CASE ELSE„l = LEN(i$)„SELECT CASE l„CASE IS < 10„decod$ = m1$(i$)„CASE IS < 16„decod$ = m2$(i$)„CASE ELSE„decod$ = "**ERR.2**"„END SELECT„END SELECT„END FUNCTION„„SUB init„WIDTH 80, 50: CLS„COLOR 10„PRINT "--------------------------------------"„PRINT "======================================"„PRINT "Angelo KEN Pesce 1997"„PRINT "Convertitore Cifre > Lettere": PRINT„PRINT "Versione 1.7": PRINT : PRINT„PRINT "Limite massimo corrente: 999.999.999.999.999 (15 cifre, 24 passaggi)": PRINT : PRINT„CALL readdata„PRINT "======================================"„PRINT "--------------------------------------": PRINT : PRINT„COLOR 2„END SUB„„FUNCTION m$ (i)„REM fino a 999999„i$ = STR$(i)„r$ = RIGHT$(i$, 3)„l$ = LEFT$(i$, LEN(i$) - 3)„rr = VAL(r$)„SELECT CASE rr„CASE IS = 0„r1$ = ""„CASE IS <= 9„r1$ = u(rr)„CASE IS <= 19„r1$ = d(rr)„CASE IS <= 99„r1$ = d1(rr)„CASE ELSE„r1$ = c(rr)„END SELECT„rl = VAL(l$)„IF rl = 1 THEN l1$ = "": k1$ = millepre(1): GOTO ex1 ELSE k1$ = millepre(2)„SELECT CASE rl„CASE IS <= 9„l1$ = u(rl)„CASE IS <= 19„l1$ = d(rl)„CASE IS <= 99„l1$ = d1(rl)„CASE ELSE„l1$ = c(rl)„END SELECT„ex1:„m$ = l1$ + k1$ + r1$„END FUNCTION„„FUNCTION m1$ (i$)„REM fino a 999999999„r$ = RIGHT$(i$, 6)„l$ = LEFT$(i$, LEN(i$) - 6)„rr = VAL(r$)„SELECT CASE rr„CASE IS = 0„r1$ = ""„CASE IS <= 9„r1$ = u(rr)„CASE IS <= 19„r1$ = d(rr)„CASE IS <= 99„r1$ = d1(rr)„CASE IS <= 999„r1$ = c(rr)„CASE ELSE„r1$ = m(rr)„END SELECT„rl = VAL(l$)„IF rl = 1 THEN l1$ = "": k2$ = miliopre(1): GOTO ex11 ELSE k2$ = miliopre(2)„SELECT CASE rl„CASE IS <= 9„l1$ = u(rl)„CASE IS <= 19„l1$ = d(rl)„CASE IS <= 99„l1$ = d1(rl)„CASE ELSE„l1$ = c(rl)„END SELECT„ex11:„m1$ = l1$ + k2$ + r1$„END FUNCTION„„FUNCTION m2$ (i$)„REM fino a 999.999.999.999.999„REM Passaggi massimi: 24„r$ = RIGHT$(i$, 9)„l$ = LEFT$(i$, LEN(i$) - 9)„rr = VAL(r$)„SELECT CASE rr„CASE IS = 0„r1$ = ""„CASE IS <= 9„r1$ = u(rr)„CASE IS <= 19„r1$ = d(rr)„CASE IS <= 99„r1$ = d1(rr)„CASE IS <= 999„r1$ = c(rr)„CASE IS <= 999999„r1$ = m(rr)„CASE ELSE„r1$ = m1(r$)„END SELECT„rl = VAL(l$)„IF rl = 1 THEN l1$ = "": k3$ = miliapre(1): GOTO ex111 ELSE k3$ = miliapre(2)„SELECT CASE rl„CASE IS <= 9„l1$ = u(rl)„CASE IS <= 19„l1$ = d(rl)„CASE IS <= 99„l1$ = d1(rl)„CASE IS <= 999„l1$ = c(rl)„CASE ELSE„l1$ = m(rl)„END SELECT„ex111:„m2$ = l1$ + k3$ + r1$„END FUNCTION„„SUB readdata„PRINT "Lettura dati:";„FOR i = 0 TO 9„READ unit(i)„NEXT„GOSUB err1„FOR i = 0 TO 9„READ dec(i)„NEXT„GOSUB err1„FOR i = 1 TO 8„READ dec1(i)„NEXT„GOSUB err1„FOR i = 1 TO 2„READ millepre(i)„NEXT„GOSUB err1„FOR i = 1 TO 2„READ miliopre(i)„NEXT„GOSUB err1„FOR i = 1 TO 2„READ miliapre(i)„NEXT„GOSUB err1„GOTO ext3„err1:„READ a$„n = n + 1„IF a$ <> "." THEN PRINT "Errore n.1: Errore lettura dati": END ELSE PRINT n; ":OK  ";„RETURN„ext3:„PRINT„END SUB„„FUNCTION u$ (i)„REM da zero a nove„u$ = unit(i)„END FUNCTION„Nick Lala                      SCREEN SAVER/PASSWORD PROGRAM  dork1@toke.com                 03-22-97 (14:48)       QB, QBasic, PDS        89   3382     LOCKDOUT.BAS' *∞∞±±≤≤: LoCkOuT :≤≤±±∞∞*„' This is my first ACTUAL program...I'm just learning QBasic so it's not much...„' This is a very simple program but I learned alot from it...maybe u will too..„' Be sure to look for more and much better programs soon...„' Please send my all your thoughts and comments...„' By NiCk LaLa (dork1@toke.com)„DECLARE SUB PasswordSub ()„DECLARE SUB WrongPass ()„	CLS                                       ' Clears screen.„	SCREEN 12                                 ' High Resolution.„	LOCATE 14, 29                             ' Where the words go.„	FOR i% = 1 TO 700                         ' How many pixels„	 PSET (i%, 220), 7                        '  to move across the screen.„	 PSET (i%, 210), 8„	FOR delay% = 1 TO 500                     ' How fast it goes.„	NEXT delay%„	NEXT i%„	SLEEP 1                                   ' How long it pauses.„	PRINT "ScreenSaver By Nick Lala"          ' Prints on the screen.      „	SLEEP 1„	DO                                        ' Do the do....for your loop.„	FOR j% = 100 TO 300„	RANDOMIZE TIMER                           ' Makes Random Numbers.„	 x% = INT(RND * 600) + 1„	 y% = INT(RND * 600) + 1„	 c% = INT(RND * 15) + 1„	CIRCLE (j%, x%), y%, c%                   ' Random Circle Sizes.„	LINE (y%, x%)-(x%, y%), c%, BF            ' Random Sized/Filled Circles.„	FOR delay% = 1 TO 200: NEXT delay%„	NEXT j%„	LOOP UNTIL INKEY$ = CHR$(27)              ' Keeps going until ESCAPE is pressed.„	CALL PasswordSub                          ' Goes to my subroutine PasswordSub.„END„„SUB PasswordSub                                   ' My subroutine PasswordSub.„10 SCREEN 12                                      ' I like high resolution.„CLS„checkpass$ = "nicklala"                           ' Defines what the password is.„LOCATE 5, 14„INPUT "Enter Password:         ", password$       ' Where the user types in the password.„IF password$ = checkpass$ THEN                    ' Checks to see if the password is right.„CLS„LOCATE 14, 35„PRINT "Nick Lala"„LOCATE 16, 33„PRINT "dork1@toke.com"„SLEEP 1„END                                               ' Ends the program.„ELSE                                              ' The "other" option.„	CLS„	SCREEN 1                                  ' Low resolution is cool too.„	VIEW (10, 10)-(300, 180), , 2             ' Makes cool(and easy) squares..„	VIEW (80, 80)-(250, 100), , 1             ' My other square„	LOCATE 12, 16„	PRINT "YoU'rE WrOnG!"„	SLEEP 1„	CALL WrongPass                            ' Goes back to screensaver.„END IF„„END SUB„„SUB WrongPass                                     ' My subroutine WrongPass.„	CLS                                       ' This is all the same stuff„	SCREEN 12                                 '     as the main code.„	LOCATE 14, 25„	FOR i% = 1 TO 700„	 PSET (i%, 220), 7„	 PSET (i%, 210), 8„	 FOR delay% = 1 TO 500„	NEXT delay%„	NEXT i%„	SLEEP 1„	PRINT "**You Have Entered The Wrong Password**"„	SLEEP 1„	DO„	FOR j% = 100 TO 300„	RANDOMIZE TIMER„	 x% = INT(RND * 600) + 1„	 y% = INT(RND * 600) + 1„	 c% = INT(RND * 15) + 1„	CIRCLE (j%, x%), y%, c%„	LINE (y%, x%)-(x%, y%), c%, BF„	FOR delay% = 1 TO 200: NEXT delay%„	NEXT j%„	LOOP UNTIL INKEY$ = CHR$(27)„	CALL PasswordSub                          ' Take another stab at it.„END„„END SUB„Kurt Kuzba                     OBJECT ORIENTED PROGRAMMING    FidoNet QUIK_BAS Echo          04-03-97 (11:45)       QB, QBasic, PDS        78   3089     OOP.BAS     '>   Is there a version of basic that is object oriented?„'>....„'   Not really.„'You can emulate some object techniques, however.„'Inheritance and polymorphism are out, but encapsulation is„'rather possible, using STATIC variables. You cannot put code„'within an object, but you may place the controls within a module„'and use command words as arguments.„'For example... consider a simple UserData class structure.„'This example does not undertake the constructor or destructor„'functions for the data, nor does it attempt to protect the data„'in any way. It does provide a public interface for the access to„'private data. This could be compiled as a module and„'distributed as a separate .OBJ file for linking without giving„'away your coding or methods, just as with a C++ class. There„'would, naturally be an include file with the DECLARE SUB„'prototype so your program could properly access the SUB.„„'_|_|_|   OOP.BAS„'_|_|_|   Example of data encapsulation in QB„'_|_|_|   No warrantee or guarantee is given or implied.„'_|_|_|   Released   PUBLIC DOMAIN   by Kurt Kuzba.  (4/3/97)„DECLARE SUB Users (C$, D$, U%)„TYPE UserData„   UName AS STRING * 40„   Age AS INTEGER„   Address AS STRING * 40„   City AS STRING * 25„   State AS STRING * 2„   Zip AS STRING * 9„   Phone AS STRING * 10„END TYPE„CLS„Users "initarray", "", 100„Users "setname", "Your Name Here", 1„Users "setage", STR$(275), 1„Users "setaddress", "1234 Upda Street", 1„Users "setcity", "Anytown_USA", 1„Users "setstate", "ZZ", 1„Users "setzip", "12345-6789", 1„Users "setphone", "(555) 123-4567", 1„Users "getname", Cmd$, 1: PRINT Cmd$; "  (Age:";„Users "getage", Cmd$, 1: PRINT Cmd$; ")"„Users "getaddress", Cmd$, 1: PRINT Cmd$„Users "getcity", Cmd$, 1: PRINT Cmd$; "  ";„Users "getstate", Cmd$, 1: PRINT Cmd$; "  ";„Users "getzip", Cmd$, 1: PRINT Cmd$„Users "getphone", Cmd$, 1: PRINT "Phone: "; Cmd$„Users "cleararray", "", 0„SYSTEM„'_|_|_|   end   OOP.BAS„„SUB Users (C$, D$, U%)„   STATIC USR() AS UserData„   SELECT CASE UCASE$(C$)„      CASE "GETNAME": D$ = RTRIM$(USR(U%).UName)„      CASE "GETAGE": D$ = STR$(USR(U%).Age)„      CASE "GETADDRESS": D$ = RTRIM$(USR(U%).Address)„      CASE "GETCITY": D$ = RTRIM$(USR(U%).City)„      CASE "GETSTATE": D$ = RTRIM$(USR(U%).State)„      CASE "GETZIP": a$ = USR(U%).Zip„         D$ = LEFT$(a$, 5) + "-" + MID$(a$, 6)„      CASE "GETPHONE": a$ = USR(U%).Phone„         t$ = "(" + LEFT$(a$, 3) + ") " + MID$(a$, 4, 3)„         D$ = t$ + "-" + MID$(a$, 7)„      CASE "SETNAME": USR(U%).UName = D$„      CASE "SETAGE": USR(U%).Age = VAL(D$)„      CASE "SETADDRESS": USR(U%).Address = D$„      CASE "SETCITY": USR(U%).City = D$„      CASE "SETSTATE": USR(U%).State = D$„      CASE "SETZIP": USR(U%).Zip = LEFT$(D$, 5) + MID$(D$, 7)„      CASE "SETPHONE": USR(U%).Phone = MID$(D$, 2, 3)„         MID$(USR(U%).Phone, 4) = MID$(D$, 7, 3)„         MID$(USR(U%).Phone, 7) = MID$(D$, 11)„      CASE "INITARRAY": DIM USR(1 TO U%) AS UserData„      CASE "CLEARARRAY": ERASE USR„   END SELECT„END SUB„Davey W. Taylor                RESITOR COLORS                 audio.squad@mailbox.swipnet.se 04-15-97 (21:55)       QB, QBasic, PDS        77   3927     RESISTOR.BAS'⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ--ƒƒƒ--ƒ -˘  ˘„'≥ RESISTOR COLORS„'≥ Davey W Taylor„'≥„'≥ If you have any comments / suggestions / questions, my email is:„'≥ audio.squad@mailbox.swipnet.se„'≥„'≥ do whatever you wish with this code, just as„'≥ long as you mention my name in your program„'¿ƒƒƒƒƒ--ƒƒ˘-  ˘   ˘„„'- program starts here -'„CLS„COLOR 7„PRINT "resistor colors                          use k for kilo / m for mega / o for ohm"„PRINT "press <enter> to quit                    format ex: 1.2 ko        Davey W Taylor"„PRINT„DO„new:„ LINE INPUT "enter value: ", v$                         'get a resistor value„ IF LTRIM$(RTRIM$(v$)) = "" THEN END„ IF INSTR(v$, " ") = 0 THEN                             '-„  d$ = v$                                               '| separate the„  t$ = "o"                                              '| actual value from„ ELSE                                                   '| the "suffix"„  d$ = LEFT$(v$, INSTR(v$, " ") - 1)                    '|„  t$ = MID$(v$, INSTR(v$, " ") + 1)                     '|„ END IF                                                 '-„ ok% = 1„ FOR n% = 1 TO LEN(d$)„  IF INSTR("0123456789.", MID$(d$, n%, 1)) = 0 THEN     '-„   COLOR 12                                             '| check for errors„   LOCATE , 13 + n%                                     '| in the digits and„   PRINT "^";                                           '| print them to the„   COLOR 7                                              '| screen„   ok% = 0                                              '|„  END IF                                                '|„ NEXT n%                                                '-„ FOR n% = 1 TO LEN(t$)                                  '-„  IF INSTR("kmo", MID$(t$, n%, 1)) = 0 THEN             '|„   COLOR 12                                             '| check for errors„   LOCATE , 14 + LEN(d$) + n%                           '| in the "suffix"„   PRINT "^";                                           '|„   COLOR 7                                              '|„   ok% = 0                                              '|„  END IF                                                '|„ NEXT n%                                                '-„ IF ok% = 0 THEN PRINT : GOTO new„ '-„ '| the below line is to check for errors in the "suffix"„ '-„ IF t$ = "km" OR t$ = "mk" OR t$ = "ok" OR t$ = "om" OR t$ = "mm" OR t$ = "kk" OR t$ = "oo" THEN PRINT "format error!": GOTO new„ SELECT CASE LEFT$(t$, 1)                               '-„  CASE "k": v$ = LTRIM$(STR$(VAL(d$) * 1000))           '| check "suffix"„  CASE "m": v$ = LTRIM$(STR$(VAL(d$) * 1000000))        '| and multiply„  CASE ELSE: v$ = d$                                    '|„ END SELECT                                             '-„ PRINT "ohm: "; v$„ IF LEFT$(v$, 2) = "00" THEN PRINT "invalid entry!": GOTO new„ IF VAL(v$) <> INT(VAL(v$)) THEN PRINT "invalid entry!": GOTO new„ RESTORE colors                                        '-„ FOR n% = 0 TO VAL(LEFT$(v$, 1))                       '| get the three„  READ x1$                                             '| colors from the„ NEXT n%                                               '| data block and„ RESTORE colors                                        '| print them to„ FOR n% = 0 TO VAL(MID$(v$, 2, 1))                     '| the screen„  READ x2$                                             '|„ NEXT n%                                               '|„ RESTORE colors                                        '|„ FOR n% = 2 TO LEN(v$)                                 '|„  READ x3$                                             '|„ NEXT n%                                               '|„ PRINT x1$; " "; x2$; " "; x3$                         '-„LOOP„'- data block -'„colors:„ DATA black,brown,red,orange,yellow,green,blue,violet,gray,white„Aaron Koehl                    PREFIX CONVERSION TABLE        akoehl@ccsinc.com              04-29-97 (17:57)       QB, QBasic, PDS        72   2527     PREFIX.BAS  '                    RELEASED TO PUBLIC DOMAIN 4-29-97„'                        Scenix Designs Incorporated„'                      Aaron Koehl - akoehl@ccsinc.com„'+----+------+------+------+------+------+------+------+------+------+----+„' Abbr2Wrd$ FUNCTION„'     Converts SI abbreviations (ie. k, M, Ê) to standard form:„'       Number$    - Data to convert        <800k>  ]ƒø„'       Action     - Customize action       <1>       √ <800 kilobytes>„'       DataType$  - Word(s) to add to end  <bytes> ]ƒŸ„'+----+------+------+------+------+------+------+------+------+------+----+„„DECLARE FUNCTION Abbr2Wrd$ (Number$, Action, DataType$)„DECLARE SUB Center (Text$)„„SCREEN 0: CLS„COLOR 15, 0„Center "Prefix Conversion Table DEMO"„Center "By Aaron M. Koehl"„COLOR 14: PRINT STRING$(34, 196); : PRINT "'Q' to quit"; :„PRINT STRING$(35, 196): COLOR 15: PRINT„VIEW PRINT 4 TO 25„„'+------+------+------+------+------+------+------+------+------+------+„DataType$ = "bytes"     ' Leave blank for simple conv.„Action = 1              ' <1> Convert Abbrevs. to full form„„DO„   COLOR 15: PRINT "Input data in form: (.77p)--> "; : COLOR 14„   INPUT "", A$: IF UCASE$(A$) = "Q" THEN EXIT DO„   COLOR 10: PRINT "Program Output: "; : COLOR 14„   PRINT Abbr2Wrd$(A$, Action, DataType$): PRINT„LOOP„PRINT : PRINT : PRINT„Center "PUBLIC DOMAIN"„Center "Scenix Designs Incorporated"„Center "Aaron Koehl - akoehl@ccsinc.com"„END„„PrefixData:„DATA E,P,T,G,M,k,h,da,d,c,m,Ê,n,p,f,a„DATA exa,peta,tera,giga,mega,kilo,hecto,deka,deci,centi,milli„DATA micro,nano,pico,femto,atto„„„FUNCTION Abbr2Wrd$ (Number$, Action, DataType$)„„'         PUBLIC DOMAIN„'   Scenix Designs Incorporated„' Aaron Koehl - akoehl@ccsinc.com„„SELECT CASE Action„   CASE 1   ' Convert abbreviations to whole words„      RESTORE PrefixData„      REDIM Temp$(16): FOR Temp = 1 TO 16: READ Temp$(Temp): NEXT„      REDIM Temp2$(16): FOR Temp = 1 TO 16: READ Temp2$(Temp): NEXT„      FOR Temp = 1 TO 16„         IF INSTR(Number$, Temp$(Temp)) THEN„            Temp3$ = MID$(Number$, 1, INSTR(Number$, Temp$(Temp)) - 1)„            Temp4$ = MID$(Number$, INSTR(Number$, Temp$(Temp)) + LEN(Temp$(Temp)))„            Number$ = Temp3$ + " " + Temp4$ + Temp2$(Temp)„            Flag = 1: Abbr2Wrd$ = Number$ + DataType$„            EXIT FUNCTION„         END IF„         'IF Flag THEN EXIT FOR„      NEXT„END SELECT„END FUNCTION„„SUB Center (Text$)„LOCATE CSRLIN, (80 - LEN(Text$)) \ 2„PRINT Text$„END SUB„Nick Kochakian                 TEXT FILE TO .BAS              NickK@worldnet.att.net         05-20-97 (15:00)       QB, QBasic, PDS        32   559      ASC2BAS.BAS DECLARE SUB asc2bas (filn$, outn$)„„'Convert any Ascii file to a .BAS file!„'„'1997„'4/12/97 By: - Nick Kochakian -„'„'Any comments or questions should be e-mailed to: nickK@worldnet.att.net„„filn$ = "c:\thedraw\ad2.asc" 'Input file„outn$ = "ad2.bas" 'Output file„„CALL asc2bas(filn$, outn$)„„SUB asc2bas (filn$, outn$)„„„OPEN filn$ FOR INPUT AS #1„OPEN outn$ FOR OUTPUT AS #2„„cnt = 1„„DO„LINE INPUT #1, ascline$„PRINT #2, "PRINT " + CHR$(34) + ascline$ + CHR$(34)„cnt = EOF(1)„LOOP UNTIL cnt = -1„„CLOSE #1„CLOSE #2„„END SUB„Ian Campbell                   VISUAL PASSWORD PROGRAM        dm.campbell@ns.sympatico.ca    05-30-97 (21:06)       QB, QBasic, PDS        59   2318     PASSWORD.BAS'PASSWORD.BAS„'28 May, 1997„'Ian Campbell„'„'       This is a compact visual password program. It's fairly fast and can„' easily be changed to suit anyones needs. To change positioning adjust the„' X and Y variables. To change the password, change the Password$ string. To„' change the Max password length, you also might have to change the display„' but it shouldn't be too difficult.„'„' This source can be used anywhere but please give credit where credit is due„'„„CLS„„0„placehold$ = "*"           'Placeholder„password$ = "mouse"        'Password„pass$ = ""                 'Don't change this...„plen = 0                   'or this...„maxlen = 10                'feel free to change this...„x = 11                     'this...„y = 11                     'or this.„LOCATE x - 3, y: PRINT "…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª"„LOCATE x - 2, y: PRINT "∫  Password Protected  ∫"„LOCATE x - 1, y: PRINT "ÃÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕº"„LOCATE x - 0, y: PRINT "∫            ∫"„LOCATE x + 1, y: PRINT "»ÕÕÕÕÕÕÕÕÕÕÕÕº"„„1„DO                                     'This is the main loop where it waits„a$ = INKEY$                            'For [ENTER], [BACKSPACE] or any other„IF a$ = CHR$(13) THEN GOSUB pfreeze    'key, It's pretty simple.„IF a$ = CHR$(8) THEN GOSUB del„IF a$ <> "" THEN GOTO 10„LOOP„„10„IF ASC(a$) = 8 THEN GOTO 1           'If you remove this line, it makes the„plen = LEN(pass$)                    'password different if backspace is„IF plen = maxlen - 1 THEN            'pressed. Don't touch. The rest of this„pass$ = pass$ + a$                   'is easy to understand. It just adds the„GOTO pfreeze                         'pressed key to pass$„END IF„pass$ = pass$ + a$„LOCATE x, y + 2 + plen: PRINT placehold$  'Print placeholder.„GOTO 1„„del:                                'This is the tricky part.„plen = LEN(pass$)„IF plen = 0 THEN RETURN             'There's nothing to delete.„plen = plen - 1                     'Adjust plen„pass$ = LEFT$(pass$, plen)          'Delete one character of pass$„LOCATE x, y + 2 + plen: PRINT " "   'Get rid of placeholder„RETURN„„pfreeze:                            'Enter was pressed...„IF pass$ = password$ THEN END       'If it was right then end.„IF pass$ <> password$ THEN GOTO 0   'If not go back to loop...„Erika Schulze                  CPU DETECTION                  100775.2275@CompuServe.com     05-31-97 (07:01)       QB, QBasic, PDS, PB    115  7553     CPU.BAS     DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"CPU.ZIP",4^6:Z&=5395:?STRING$(50,177);„U"%up()%9%%%I-%$3K8Gw_3]\?)7%%J2%%%,%%%%hu%zSfxOr&&<+t\]5$w;IwN<K„U"2Fl(Dd/LywW*6Qo=zd.fD914?anW\,#]_;V'8Ew5A7[Nr6eBZ4EtRXt_h)f6AFK„U"o4^USd5[')9<<u1^DzYBGV(42K?D?JcZMFC,-AE6B&Ru=EEI)Uzf];sxmW3srll„U"D?jRr:2kma#1?h7)e<xx:iXfXNWmQVlQ\(K/YElvK+_7'kbnR*3ih6&L%V#-vNN„U"X%xNqP0+QNu7ADELKS*#HnV2WTD>BMC4U<I';Cs#e*^#a0WB1g3X=6;]5+Pn7L=„U"OMmJ.%8:ePkRKPE%WlIEYF/]&%WvK^KP[pG4XmxxUz/c$E?vDb6dHzuiI3$ErqA„U"kpqzP*:FC8eI).fMwFd[ll*E^=NsK]D#mBgt$3_1Kb665OKYLitVlJ'txIZ71QC„U"&,nxDZlE>,tKVRu\RFwI#uuuky<7r$A''sQ6<7f)DG3L6hYS(hP?.6U8eJ-Fac'„U"k;kku*jlVrZtnm$a)NpBQKJ3]US>lSQiO*qnmc%&84idN%3S/X[oq%-<al-lF\p„U"gA7F:.*<*1]+Xe6.#q[;ikt=<$CxKxdE+kAPPm+3Kg?X;Ipk[TDbfNF[b1JaKZ+„U"g_%iKfW/YJGbWDJ;HZYPCwH/J=x(Rygch1Ydv/e#0l&l*A8WCFg(7Kf5?Ll1bS(„U"_?++a8e(*dzK_G_&+hwTX&RrKVLUyHcZ]o-wV*bD0/Dph7MN&e=]5=.9aTqg^0H„U"LX<]g>siUppjNS1'0Deof(g#ZPK?RJs3#oX\v0l52^X$L6$?#s^Tmt?rIudmbbe„U"KVz8*_\RYPRKaeQxDs4eZp,7j5Q\N$y(WBmZK&OQ<_x+zt=g=3Z&1ei841Msv4.„U"r&S?t&MZ</>n)%N^=R5*I<j/(JzjPpKQxJ(hh'OTcu*IeDSse9S:2Z).Go9YSEU„U"PDA:aD55p+f*BD$bOUXEP4&2%%Hwp*rERQE2MzxWe8hVcRnNnpu*f.RGI3fWRa7„U"&QGR_c#Z%&E-A+B[,cL+7BPL96]eNAE3VH--fMO1%z=u7.ZTR8<JTmHq(/fzJLT„U"]>\l-&*Hv$XVPGYK'^k33HpwXA6_n7PlGa1X)AL76p3%Fn7?EESJ)2J%bueYt;;„U"kCYS9rZU-/]8\$6fSfsJwEFC76<v;Uir1tB*l.v<Nf=A_?bjVNS(ktfwARwhS3P„U"w5OLo*B<P_8i:[rGzqi/d74KoUxRJ=pP((#H9+sj%-^/cc2q>YY09-5H*tbtR09„U"\(gj*E2UH>6*o-OJ:O,QZDK0F#L*Y'L(vOaG%KVad&l1es-OI0Kc]vQ:Am/Q5.e„U"&0K0Joyb%*=UgZ+Wb_3zIAGqr50<Lu7I3ow2[,xazj5ARm=(xf._c8.eV,K6eRq„U"xo=rH;3%kb$VB'iIw(,Q]X^)7<XGdoL4DWG;_,n$3jlrNJ^e5tApE;>&51BGUNk„U"vgT[9nPTJK>u=xui%dup(%)9%%#%-%$,38Gw$Pq#7[%%%C%%%%,%%%%h%uzStdg„U"o:Y)3/tS+MNpQHGV^\DXPFrVRh:0iZc8U#1QS]1F]/gAH+$R%,#(8%XHTmuURX>„U"#:qMQB=h='/'>FtNY4//21BF2A#3-4h//gUu:;Y)VW#[QI-+ohWVF3^mYdr,XvZ„U"kZL7f_W%:q#=^p<Aq+>R==4?e'>WwfavTF&;W(YoFOC18&8YB:5R%T)yyOoq<'1„U"oGFUaWiTcp_q;xDi8(BuSUg#nvdFZ&3]G>*;Gi[5SjB<*Ia7%%up()%9%%%I-%:„U"498G=+:(4**.%%g8%%%.%%%%hu%zugS[gfx.h'*BSI]9MEb5kDGk5SpVP8QSugr„U"ihE[S=LnPeT?8NSLb<d&?;R[HpnbQ(XB3eo3S_]',5/-7hABhljwuNrK2FbvKxb„U"si*]MM#Jr-5rSw4QY:RGJUQnlI_sb:B'7FH:3ICf]HX3b-QG8K(I3O22Hmv/i'T„U"mSi$a.(k'OW<EEW-SHE.Wp1;xSVmG.M\.w0b%PbJ9]q*xWI0Brbq3=+l_66miPr„U"Ujh;<t9f%uW]LMK=6+vh9%7K5:Yj(KD<?\2jG*G,y$^ta'DY%O4S?SXPX-8Des6„U"NF0p#eQBa8y9kx#x51?/5Rsrub,**<kc[G9q]jtV2PZ##+DN?/Vm,,##XDWN9T#„U"Dgxi=a/fe$T#DGadJ48dMx.$JOK$NcY&#9s#/pjJI5k<M8,^UAMsCDKf/*MGix3„U"JilG/(KWj-WFc5uL/rkR6IhO*A5V0[/UMd:72fE7R3Kxr-=LnZCl>AqMv3TRXhr„U"=h:kZH&5,W)CNvaMA&HJyOL8CvyM4HIO?&?g3$klbXje/?ZuV^qALD0FOZ,$O<b„U"F$:Ruo]Y],r\]ppr<iKgXKLWlcOVIidF,(j^cJ157EA2K\]4)KA.3x/_?16UMu_„U"ec)T#s,<xd4++mv?.sJ0X71FA8F;#51Uiau=?4$0aZi7V'jqDfcKa9^lU;'wu0P„U"=,el4WRgHrrrO.[o1;^#2/D8/qI._f+V+Tq/R:a9XJ-%xNay'AU[6$315j'9qE\„U"D(eO<?>/u+Go'JgIx7WyIKkY_p:V4)glDX4qw>:JX#ms;FO;2co0:^v=+nn+oc+„U"edh>/n6-74j?u_3I=S'M/0>*6Z;_7u)^_ztFPqPM(h5F/0RIWx'vMqQvSsk5Pht„U"FtIa8]_Ff,hZ<f\_?>^.5sH]Lh&,0p_r/P?pVTfKKI+0FgTeD38IL1YUDT00b:&„U"=j8Pj1Z:)gMZR+>+N,?%Q+9Z%,B)c5cYB6g4eP>^J'1=CWcNLga_/WK6,O<2+%p„U"5XZTZ=7gJVMGB[fJr\fcT\2]_;sS0O3]scOZVPAdAMzpXwR^7UEn.:iV)NDa3ws„U"tb9=]k7MT;;(i$'_zC6GnM#cv>MvtKF?LuWi[c1l)kE>uY$Yt$Q9Enr7*].%01-„U"XALo.'dK$51yp-wEiYWQ8F$c<ad2*CrA?-Y7;%]luY&fQFb9$5jVOX*-4$-=,Uu„U"G)NaPJn.v-2E#mSTlh9+:h\9A6XweKx5I(NL-owmia=<?]/#?gZVdu*VAXy4M(g„U"7gQog6,J5evZ*fY:C]rCTg35xGJyPsqmhR$[QYIvb&txuuV/u11H*ZT/r0EVhcU„U"<Mp#=Tv[q*M$DdC?vS><u4lMeXTk;(ZZ(P*JEFVimTy'pb]DVD+dfU<+4htHv_&„U"GB<P'9J0HVua^=)p.)XAf)MT4L$=:/RrD?kg:6qr#4q1pH[USwTedXoLKWak/dh„U",5V4TAIu:<#wtBd/m6P,TF9BQPxLqZsnW9O31mGKpvbjO35be$3:o&45[<SRdP(„U"jLwa).s1MNWnPDhN9twE;^8IL&/Z-P83VbZZ_6ZRIpTUOfJ]lOyp=?/>K+$auUF„U".D=^5T]1Z>.=gxSHC.:#Soh0;p&^IiA417$fYiXOgS^/_r#lWD<P6WA4nzQh,*o„U"Gca7gS%XT%.wG;V/5m4<I^t16-5NX9i)k1<M=xXj6NQdpKwX60*PxYjB*j5nXhn„U"P_DubVv.F%F(R+rB?wJG9SMvLpgSQ[eoz14a43v<Yc^MDe/W\eT^8p+W6l>fbhJ„U"mLUNi*VSzwIC,\/atoQCJYmra0CG/lBwWM7t.KHh(mMM'zPPx,C7f6vr^Q4]xfY„U"nbsVtTHtwic;>HFc+s2W6?MG<gCxd%up()%9%%%I-%J498Gc:=b-'-7%%KH%%%.„U"%%%%hu%zvgS[gfx._)*xT.m;MCGyq46Cxb6;4A#&UdyVX*jr[)#q01QE\%O43$-„U"<*V4oVQ]r8MHb5eeeH&P%tdP/B%NN$M:0NuJF:YNH1[f<j;sqvoOYuks(l3sHN+„U"M^-SEk4kjL*F&hK>'e4&0\Ee10=O15ZG^.>B3&i#n7XG<j=g+*bcX,e;=\/j$9]„U"7P7&\YGUs;ZU4&E#LP<33P\?8DEN9(.rG/nA>.8X'Ii_QtuEvTg]U,Y)>9Sp]7l„U"eI0iTiG-MgGe0E^X0l*qJ2;E8-KWtOKrGn4)A)1k2hv4eG-<dPz:GEa/Fk\Qq1*„U":<.]4uJL:o\a(-g9.i+(LiAFEadl.6jpRz\^Lb7.1A&-;3DaMY&'Ia^^,U#Tg1#„U"UPNqgBsTh41H'42<_aSp3PkJPP9/J)nI4.J'kUIU)'m]bXmqK8Yk8UMg_8G&a*$„U"qA4YDaUjA1+0\#U.*?2jJ=R\Q7cl0Q<1D\UciJzcX7frpW--tJrtJ<J>/Kxa>QR„U"n^eKV,Z%+0]]NUKN#IbB+\7drZbC8RMH(NNi[<GE05WF0/6]?qkAuniCY,wV][h„U"&+y[iO[,L'kUYDq-64_)<Nt+'lp]HAnQG8Y3u&R)k;m>;3Nh\\+k71eM9AgKKX+„U"gf*e$5GSv(Y-uQDtgP7x;'s,9^PgUnzO2T2u3Ko/dC)?$5LQ_)IQ64T7<oaR\Ja„U"3t76LlgHt<oqnYIP58$gejUW/egeJgOW,s<<\OnCbk660-D[Di[+&=UaHkt_;]0„U"+k*#-&W>ta%f#eb^$mF21kPGkH(J$IhRNImsQ9^$cjmo4/S<o73S%\IfG'oFqOF„U"-8Nw1j-i,g-,GFmY)61j&G$&1G&/v78:(68<8/8dd-q=SRXts2ZX98wd9FxdadP„U")$-9mj*VAd?<8T]gx-<X[=(cP^gr[URbSI9mQc_5[[/Y(BQ/HYh*sb-B3Q;ijBV„U"8lB->W?)NLX#AwJAcT>;>gFXU\2^/ADQ)Nl,qp;hl5gQ37qJ(jJj$=;p';6T4))„U"VjAoB_4WHeZs3*ICAqU7k/Vfl^6[24(Qu(df7<<E^CpAvfdV9*>(ypf+<Enbe.F„U"VIyS,odHJsnkXXkk%YtV*/A7L&pcI)%L#-IRh#x$;bP790S]W7M$DH.u&aNJ[\9„U"$NPrKNr=mxTp>p^7GN-m]u2c)4Nf-tXQ1U6=IVBC&&o9QY&p&'TxMSDhO$cz%&2„U"hp0S&N)w.A)Ph:Tf'&lPp.FP?OBI_94edOf-Yz6n$.nb&7l^YNC$>3kQ%[oBu%r„U"fDYJoL>6khPp=Kqu-t:DDH3V,1QB9P#2Xn%y5PdqzOg1FM-12>2tM^;ir<*s-Jq„U"?^yAOAD8.\lV^=5gOygO$9^=S5wXIpJdo+lSrTa4fMa2mQEI--E&zJO,lAH:FDx„U"9Y+N*ol,^K.E1MWaQ.YEA0[2?Py^g5TDm.DUBF-jL0t?R&?mbv[R-*-F:.-q454„U"*s5R-R8K.(%g%)3:<Lo?8Nmyeh52x$7ZoCj,6V)z*c0MyYGLc?=,*)GxEm]3ng;„U"+cI?<_3d:?I[D]:zrfn:wMaI\--m2C+=B'G,n#mCL^B3Y^fKp^:lD96mL4.N^2,„U"$_l5&^ohd^$W4FVUgI[lFhu^fR]6+;,Rr_n7u09;XVtwMK-A7+D]wv;)DlY&j$s„U"]oS:Mv>)\%P^goALIE2y7(1ZN9]f/4YJ4]K1HsUy+\+-^Sp7j>t]5^(d5a<pC#N„U":EUv2%<i%B1lBj$>Ha,YS>>O1Te%b?RLP?4=cSImCZZm4ZZ$NipOsRUl=OX]&(4„U"zjY=JNOBTLj=76m8MhAZAQTGhF]oZ+/]G&bClI<bWZEnczQhJ$&<_U-kG$YgEj&„U"BS2=SX=7A&&J^T1YlQ+]0M(bBScC7=\3/S(S3;[n;dSAb4&)DZA7cMSzZ_BAdVu„U"6ogk50Uzq-D#vFo&q[n;p'=TP[1lIL^1Ny'9^gBlnB=^X//vxV>?2bUXg<g2gh+„U"jlgYQGU\'2??aGb;#<CF?3o5e8%*o8M-,275xp2#5VyJ>g'/sF;+\A&fC9iP\ad„U"S%LpR8s;??aPAg&WN8Y)T'PZGFMDjN2oc(n0CkX;#\wc7VW0*q#w$-U;4Sqf.0Q„U"+s\uUVbM0SZ,PgR#l*FHMsuAk?;Y$rf]b[u5=+eH6H(b,\xW4t^%jR+*,Cv%tA_„U"5>:.1e8.g6b7bj\LmC'S(DD5khjB:eNvc]ZP:X%i:>jmWKPUZH2k:]i-t;X]v)H„U"E,1dmStpRO,e*v$G]K#/N3RqXgt(^/ERnX5&2i]aKR-tl;uXL,^t;27WU)[O]2y„U"IwB1]8br8TWLTZ%ekG#z'xE%F,D4$Dyn8t9deNFq^[gd>.%>dG[OE5bgR&R?jM=„U"g*X>*hg&#M7gdS]q927f/wJoH&L%My<BF^M8K>?GCZyfmD)%VAmbrtwhmul/4tK„U"$2O'(%VKgtNy-e)QH[#yyD_?JLrg[ocTr(]t&ke.c*AZ_zV;'O<n;'L??,DDB*[„U",DPC#nu_:DEZG>S*Bm8\dF1sKr1pf(iT5XHc1et;Vv8GiS)9q]XAdG?s<Z&VAuB„U"2n;3bK7hun]/<A]SJ/[I^s#xTxn[<2&f+GB/5oGjCquB$Bs)s$,Utbdz<JP-wUR„U"j.:d><VbI0bjuLTy45fr>qGphX_PH?D=pObR*n-,;H^rBG:bIMB*6Yv#kTHRl4.„U"oO0JmZ0<H*4*xIf]9A7EfBoxm/yDvH>]3=;#B,HIU4M<%kjx$AGp^s-L&up'(c$„U"rgiDld;_BSK->:G1KBbY)mA'VKDEr^K^:jJ7N3P:NtmXN2Vnf4\Bs-?Lx>[wp$6„U"sWZ<Tkpr-ag772mcL0s%dup&%'9%9%%%%-g%$38gGw_])\?)%+%J2%%%,%%%%%%„U"%%%&%E%%%%%%%%%h%uzSf%xrup%&'9%%9%%%I-%$3]8GwP8q#7%7%%C%%%%,%%%„U"%%%%%%%%%E%%%&d)%%%huzS%tgou%p&'9%%9%%#%-%:b48G=d+(4*#*%%g%8%%.„U"%%%%%%%%%&%%E%%(%G*%%%huz%ugSg%fxup%&'9%%9%%%I-%J498Gc:=b-'-7%%„U"KH%%%.%%%%%%%%%&%%E%%%%u0%%%huzv%gSgf%xup*%+%%%%%)%)+%Q%%%%J9%%„U"%%%„END SUB„CLOSE:IF S=106AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Kurt Kuzba                     BUNDLE MULTIPLE FILES          FidoNet QUIK_BAS Echo          05-28-97 (00:44)       QB, QBasic, PDS        85   3693     FILEBAG.BAS '>   I am trying to track down some code that would allow a„'>   program of mine to archive a few files, much like PKZIP„'>   does and of course unarchive the files.  Does anyone know„'>   of or have any such code they would be willing to part with?„'>....„'   Here are some simple routines to bundle files in a single„'archival file. The interface is a bit unfriendly, but the thing„'works like a charm. You can add whatever interface suits you„'and fits the program you are writing. Have a look at it.„'_|_|_|   FILEBAG.BAS„'_|_|_|   Simple file bundler routines for QB and QBasic.„'_|_|_|   No warrantee or guarantee is given or implied.„'_|_|_|   PUBLIC DOMAIN   by Kurt Kuzba.  (5/28/1997)„DECLARE SUB BAGit ()„DECLARE SUB UnBAGit ()„ON ERROR GOTO BooBoo„DO„   CLS : COLOR 15, 1„   LOCATE 5, 29: PRINT "  __----~~~~~~~~~~~~~~----__  "„   LOCATE 6, 29: PRINT " |  [ I ]=> Include files.  | "„   LOCATE 7, 29: PRINT " |  [ E ]=> Extract files.  | "„   LOCATE 8, 29: PRINT " |  [ Q ]=> Quit Program.   | "„   LOCATE 9, 29: PRINT "  ~~----______________----~~  "„   DO: k% = INSTR(" IEQ" + CHR$(27), UCASE$(INKEY$)): LOOP WHILE k% < 2„   SELECT CASE k%„      CASE 4, 5: EXIT DO„      CASE 2: BAGit„      CASE 3: UnBAGit„   END SELECT„LOOP:SYSTEM„BooBoo: Ferror$ = STR$(ERR): RESUME NEXT„SUB BAGit„   SHARED Ferror$: COLOR 10, 0: CLS„   INPUT "File to include => ", BagItem$„   INPUT ".BAG to hold it => ", Bagfile$„   Bag% = FREEFILE: Ferror$ = "ok": OPEN Bagfile$ FOR APPEND AS #Bag%„   IF Ferror$ <> "ok" THEN„      PRINT "File error. Unable to open "; Bagfile$„      WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND: EXIT SUB„   END IF: Itm% = FREEFILE: OPEN BagItem$ FOR INPUT AS #Itm%„   IF Ferror$ <> "ok" THEN„      PRINT "File error. Unable to open "; BagItem$„      WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND„      CLOSE Bag%: EXIT SUB„   END IF: CLOSE Itm%: OPEN BagItem$ FOR BINARY AS #Itm%„   DO: slash% = INSTR(BagItem$, "\")„      IF slash% > 0 THEN BagItem$ = MID$(BagItem$, slash% + 1)„   LOOP WHILE slash% > 0„   PRINT #Bag%, LEFT$(BagItem$ + "            ", 12);„   PRINT #Bag%, LEFT$(STR$(LOF(Itm%)) + "          ", 12);„   WHILE NOT EOF(Itm%): it$ = INPUT$(512, Itm%): PRINT #Bag%, it$;„   WEND: CLOSE Bag%: CLOSE Itm%„END SUB„SUB UnBAGit„   SHARED Ferror$: COLOR 10, 0: CLS„   INPUT ".BAG to unpack => ", Bagfile$„   Bag% = FREEFILE: Ferror$ = "ok": OPEN Bagfile$ FOR INPUT AS #Bag%„   IF Ferror$ <> "ok" THEN„      PRINT "File error. Unable to open .BAG "; Bagfile$„      WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND: EXIT SUB„   END IF: CLOSE Bag%: OPEN Bagfile$ FOR BINARY AS #Bag%„   IF Ferror$ <> "ok" THEN„      PRINT "File error. Unable to open .BAG "; Bagfile$„      WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND: EXIT SUB„   END IF: PRINT "Unpacking "; Bagfile$:„   PRINT "=============================="„   PRINT "File name      length     ===="„   DO: BagItem$ = INPUT$(12, Bag%): IL& = VAL(INPUT$(12, Bag%))„      IF LOC(Bag%) >= LOF(Bag%) THEN EXIT DO„      PRINT BagItem$, IL&„      Itm% = FREEFILE: OPEN BagItem$ FOR OUTPUT AS #Itm%„      IF Ferror$ <> "ok" THEN„         PRINT "File error. Unable to open "; BagItem$„         WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND„         CLOSE Bag%: EXIT SUB„      END IF„      FOR t& = 1 TO IL& \ 512„         it$ = INPUT$(512, Bag%): PRINT #Itm%, it$; : NEXT„      it$ = INPUT$(IL& MOD 512, Bag%): PRINT #Itm%, it$;„      CLOSE Itm%„   LOOP WHILE NOT EOF(Bag%): CLOSE Bag%„   PRINT "==== done ===================="„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND„END SUB„'_|_|_|   end   FILEBAG.BAS„Brian Bacon                    STORE USER RECORDS W/GET & PUT kyberteknik@geocities.com      06-03-97 (23:56)       QB, QBasic, PDS        169  6993     RECORDS.BAS 'RECORD.BAS  by Brian Bacon„'„' This is a simple demo of using basic's GET and PUT (file i/o) commands„' for keeping User/Player databases.  It isn't commented well, but it„' should be fairly easy to understand.„'„' If you wish to use this code (or any parts of it) in a program„' of your own, then do so, but realize this is under no warranty„' of any kind. The only thing I ask you to do is visit my web page„' if you can (some people still aren't on the net).„'   www.geocities.com/SiliconValley/Lakes/2213„' It will eventually contain some usefull BASIC related stuff..„' but right now it only has a few links and some BASIC files you„' can download (like a paint program and a few other cool things)„'„'   oh and E-mail me if you want to:  kyberteknik@geocities.com„'„TYPE UserIndex   'Just an index (keep only important stuff here)„         UserID AS LONG„       UserName AS STRING * 30„       Password AS STRING * 15„END TYPE„„TYPE UserRecord 'this one can have other information„         UserID AS LONG„       UserName AS STRING * 30„       Password AS STRING * 15„        TimesOn AS INTEGER„END TYPE„„DIM UsrIdx AS UserIndex„DIM User AS UserRecord„„Top:                                    ' All this just waits for a logon„CLS                                     ' or and exit command from the„PRINT "Waiting for logon..."            ' keyboard„PRINT "(L)ogin (E)xit"„DO„  DO: A$ = INKEY$: LOOP UNTIL LEN(A$)„  SELECT CASE UCASE$(A$)„         CASE "L": GOTO Login„         CASE "E": CLS : END„  END SELECT„LOOP„„Login:„CLS                                     ' first, lets greet the user„PRINT "Welcome to this system."„PRINT "Please enter your user name.  If you have never logged on before, enter"„PRINT "the name you would like to use in the future(max 30 char)."„PRINT„LoginNoCls:„LINE INPUT "Enter your name:", uname$   ' get user's name„                                        ' then open the index file„OPEN "ALLUSERS.IDX" FOR RANDOM LOCK WRITE AS #1 LEN = LEN(UsrIdx)„found = 0                               ' not found yet„FOR I = 1 TO LOF(1)                     ' if you use len=len(var) then„                                        ' lof(#) will return the number„                                        ' of records in the file„    GET #1, , UsrIdx                    ' get next record and compare„                                        ' names, if found, exit the loop„    IF RTRIM$(UCASE$(UsrIdx.UserName)) = UCASE$(uname$) THEN found = 1: EXIT FOR„NEXT I„CLOSE 1„IF found = 0 THEN                       ' if they aren't found after going„                                        ' through the entire index file then„                                        ' they must be new or they misspelled„                                        ' their name, lets ask them.„AskIfnewUser:„   INPUT "Are you a new user?(Y/N)", yn$„   IF UCASE$(LEFT$(LTRIM$(yn$), 1)) = "N" THEN GOTO LoginNoCls„   IF UCASE$(LEFT$(LTRIM$(yn$), 1)) <> "Y" THEN GOTO AskIfnewUser„   PRINT "Welcome " + uname$ + " this is your first login."„   UsrIdx.UserName = LTRIM$(uname$)     ' if they are new, then put the„   UsrIdx.UserID = I + 1                ' new name and ID in the index var„   LINE INPUT "Enter a password(max 15 char):", psw$    ' get new password„   UsrIdx.Password = psw$                               ' put it in index„   PRINT "Please write down your name and password and dont forget them."„   OPEN "ALLUSERS.IDX" FOR RANDOM LOCK READ AS #1 LEN = LEN(UsrIdx)„        PUT #1, UsrIdx.UserID, UsrIdx   ' open the index and put new record„   CLOSE 1„  „   User.UserName = UsrIdx.UserName      ' next we copy the index info„   User.UserID = UsrIdx.UserID          ' into the other type that„   User.Password = UsrIdx.Password      ' holds everything (this isn't„   User.TimesOn = 0                     ' manditory)„   OPEN "ALLUSERS.DAT" FOR RANDOM LOCK READ AS #1 LEN = LEN(User)„        PUT #1, UsrIdx.UserID, User     ' open the database file and„   CLOSE 1                              ' store the new user„ELSE„   pwa = 0                              ' password attempts„   DO„     PRINT "Enter your password:";      ' ask for password„     COLOR 0                            ' change to color 0 (so others„     LINE INPUT "", psw$                ' can't see the password)„     COLOR 7„     IF UCASE$(RTRIM$(UsrIdx.Password)) = UCASE$(psw$) THEN„        PRINT "Logging on..."           ' If the entered password is the„        EXIT DO                         ' same as the one in the index„                                        ' then go logon„     ELSE„        PRINT "Wrong password"          ' otherwise tell them and„        pwa = pwa + 1                   ' increment the password attempts„     END IF„     IF pwa = 3 THEN                    ' if they have had 3 attempts„        PRINT "Illeagal logon attempt." ' then boot them off„        CLOSE 1„        SLEEP 1„        GOTO Top„     END IF„  LOOP„  OPEN "ALLUSERS.DAT" FOR RANDOM LOCK WRITE AS #1 LEN = LEN(User)„       GET #1, UsrIdx.UserID, User      ' now they are logged in, so„                                        ' get the users info from the„                                        ' database„  CLOSE 1„END IF„„'„'  From this point down, the program is just fancy demo stuff...„'  If any changes are made to the Index or Record variables, make„'  sure to save them.„'„CLS„PRINT "Welcome " + RTRIM$(User.UserName) + " you have logged on"; User.TimesOn; "time(s) before."„User.TimesOn = User.TimesOn + 1„DO„  LINE INPUT "*>", Cmd$„  Cmd$ = LTRIM$(RTRIM$(Cmd$))„  IF UCASE$(Cmd$) = "BYE" THEN„     OPEN "ALLUSERS.IDX" FOR RANDOM LOCK READ AS #1 LEN = LEN(UsrIdx)„          PUT #1, UsrIdx.UserID, UsrIdx„     CLOSE 1„     OPEN "ALLUSERS.DAT" FOR RANDOM LOCK READ AS #1 LEN = LEN(User)„          PUT #1, UsrIdx.UserID, User„     CLOSE 1„     GOTO Top„  END IF„  IF UCASE$(Cmd$) = "HELP" THEN„     PRINT "----------------------------------------------------"„     PRINT " HELP         - Show help"„     PRINT " BYE          - Logoff"„     PRINT " NAMECHNG     - Change your logon name"„     PRINT " PWCHNG       - Change your logon password"„     PRINT "----------------------------------------------------"„  END IF„  IF UCASE$(Cmd$) = "NAMECHNG" THEN„     LINE INPUT "Enter your new name:", uname$„     uname$ = LTRIM$(RTRIM$(uname$))„     IF uname$ <> "" THEN„        User.UserName = uname$„        UsrIdx.UserName = uname$„        PRINT "Logon name changed"„     ELSE„        PRINT "Name change aborted."„     END IF„  END IF„  IF UCASE$(Cmd$) = "PWCHNG" THEN„     LINE INPUT "Enter a new password(max 15 char):", pw$„     pw$ = LTRIM$(RTRIM$(pw$))„     IF pw$ <> "" THEN„        User.Password = pw$„        UsrIdx.Password = pw$„        PRINT "Logon password changed"„     ELSE„        PRINT "Password change aborted."„     END IF„  END IF„LOOP„Brian Bacon                    RANDOMLY GENERATED NAMES       kyberteknik@geocities.com      06-16-97 (16:37)       QB, QBasic, PDS        54   1837     NAMCREAT.BAS'I originally wrote this program to create names for characters (in„'games or whatever) but it can also be used to create words for„'different languages (incase you are writting a book or game and you„'need to create a language)  I do admit you have to look through pages„'and pages of these words to find good ones, it is still easier then„'trying to think them all up (especially when you have friends that„'will sit in front of the screen for hours doing this for you). „'I have used up all my creative names playing D&D, it was starting to„'be hard to make up some good names, but this solved that. It isn't the„'best program, but it works..„'„'  (c) 1997, Brian Bacon„'  No warrenty implied or given.. blah blah blah.. you know the rest..„'„' Some of the best names I have gotten from here are:„'     Kezler    Jinil    Kovan    Porte    Rozin    Lenn„'     Civon     Ivry     Wesco    Sanikar  Cevvun   Kyne„' „RANDOMIZE TIMER„CLS„h$ = "abcdefghijklmnopqrstuvwxyz"  'all letters„v$ = "aeiouy"                      'vowls only„c$ = "bcdfghjklmnpqrstvwxyz"       'constanants only„'SWAP c$, v$     'for some more cool words try this„DO„length = INT(RND(1) * 6 + 1) + 3   'change this line to vary the„a$ = ""                            'name/word length„curr = LEN(h$)„curr$ = h$„p$ = ""„FOR I = 1 TO length„    lett = INT(RND(1) * curr) + 1„    b$ = MID$(curr$, lett, 1)„    a$ = a$ + b$„    IF INSTR(v$, b$) THEN„       curr$ = c$„       curr = LEN(c$)„    ELSEIF INSTR(c$, p$) THEN„       curr$ = v$„       curr = LEN(v$)„    ELSE„       curr$ = h$„       curr = LEN(h$)„    END IF„    p$ = b$„NEXT I„PRINT a$, ;„IF CSRLIN = 23 THEN„   PRINT "press any key to continue (q) to quit...";„   DO: k$ = INKEY$: LOOP UNTIL LEN(k$)„   IF UCASE$(k$) = "Q" THEN END„   CLS„END IF„LOOP„Michael G. Stewart             DAILY JOURNAL RECORDER         mikegs@juno.com                06-24-97 (21:26)       QB, QBasic, PDS        221  5233     JOURNAL.BAS DECLARE SUB newentry ()„DECLARE SUB center (row!, text$)„DECLARE SUB sparklepause ()„DECLARE SUB openfile ()„DECLARE SUB newfile ()„DECLARE SUB Intro ()„CLS„Intro„openfile„CLOSE #1„END„„„errorhandler:„SELECT CASE ERR„ CASE 53„   PRINT "QJournal File Not Found. (*.jrn)"„   INPUT "Create a New One? <y,n> ", e53$„   LET e53$ = UCASE$(e53$)„   IF e53$ = "Y" THEN newfile„   END„   RESUME„END SELECT„„ends:„KEY(10) OFF„CLOSE #1„END„„SUB center (row, text$)„    LOCATE row, 41 - LEN(text$) / 2„    PRINT text$;„END SUB„„SUB Intro„COLOR 9, 0„center 2, "Q B a s i c"„COLOR 12, 0„LOCATE 2, 1„PRINT TAB(36); "Q"„COLOR 10, 0„center 4, "Q J O U R N A L"„COLOR 12, 0„LOCATE 4, 1„COLOR 13, 0„center 10, "QJournal: A Journal Recording Program Written in QBasic"„center 11, "Written by: Mike Stewart"„COLOR 9, 0„center 14, "MS-DOS Qbasic"„center 15, "Version 1.1"„center 16, "Copyright (C) Microsoft Corporation, 1987-1992"„COLOR 10, 0„center 18, "QJournal"„center 19, "Version 1.0"„center 20, "Copyright (C) Granite Hill Computer Systems, 1997"„center 21, "Public Domain"„COLOR 27, 0„center 23, "Press Any Key To Begin"„sparklepause„END SUB„„SUB newentry„CLS„PRINT "When you are done, press F10 to save and exit."„COLOR 15, 0„PRINT "File: "; fln$„PRINT "Date: "; DATE$„PRINT #1, "Date: "; DATE$„PRINT #1, STRING$(80, 196)„PRINT STRING$(80, 196)„ON KEY(10) GOSUB ends„KEY(10) ON„p = 4„DO„  LET p = p + 1„  LOCATE p, 2„  LINE INPUT "", m$„  PRINT #1, m$„LOOP„„„END SUB„„SUB newfile„CLS„INPUT "First Name: ", fsn$„LET fsna$ = MID$(fsn$, 1, 1)„LET fsnb$ = MID$(fsn$, 2)„fsna$ = UCASE$(fsna$)„fsnb$ = LCASE$(fsnb$)„LET fsn$ = fsna$ + fsnb$„CLS„PRINT "Hello "; fsn$;„PRINT "!  This is the QJournal Setup Utility."„PRINT "We need to know some information from you."„PRINT "Fill it in below, press ENTER to go to the next line."„COLOR 15, 0„PRINT "PERSONAL INFORMATION:"„PRINT "First Name: "; fsn$„INPUT "Middle Name: ", mn$„INPUT "Last Name: ", ln$„INPUT "Date of Birth: <mm/dd/yyyy> ", db$„INPUT "Password: ", p$„n$ = fsn$ + " " + mn$ + " " + ln$„fln$ = MID$(n$, 1, 7) + ".jrn"„LOCATE 9, 11: PRINT SPACE$(69)„PRINT "Filename: "; fln$„OPEN fln$ FOR OUTPUT AS #1„PRINT #1, p$„PRINT #1, "Name: "; n$„PRINT #1, "Birthdate: "; db$„PRINT "FAMILY INFORMATION:"„INPUT "Father's Name: ", fatn$„INPUT "Mother's Name: <Maiden> ", motn$„PRINT #1, "Father: "; fatn$„PRINT #1, "Mother: "; motn$„INPUT "Number of Brothers: ", nb„FOR a = 1 TO nb STEP 1„  IF nb = 0 THEN EXIT FOR„  PRINT "Brother #"; a; : INPUT "'s Name: ", bn$„  PRINT #1, "Brother #"; a; ":"; bn$„NEXT a„INPUT "Number of Sisters: ", ns„FOR a = 1 TO ns STEP 1„  IF nb = 0 THEN EXIT FOR„  PRINT "Sister #"; a; : INPUT "'s Name: ", sn$„  PRINT #1, "Sister #"; a; ":"; sn$„NEXT a„CLOSE #1„OPEN fln$ FOR INPUT AS #1„CLS„COLOR 10, 0„center 1, "Entries in your file:"„DO WHILE NOT EOF(1)„  LINE INPUT #1, rec$„  PRINT rec$„LOOP„CLOSE #1„OPEN fln$ FOR APPEND AS #1„CLS„COLOR 7, 0„PRINT "O.K. "; fsn$; ", We are ready to make your first entry."„PRINT "It will automaticly display the filename and the date at the top"„PRINT "of the entry. When typing, to move to the next line, hit enter,"„PRINT "and the line you just finished will be saved automaticly."„PRINT "when you are done, print 'End of Entry' on one line, to save and exit."„COLOR 15, 0„PRINT "File: "; fln$„PRINT "Date: "; DATE$„PRINT #1, "Date: "; DATE$„PRINT #1, STRING$(80, 196)„PRINT STRING$(80, 196)„p = 8„DO„  LET p = p + 1„  LOCATE p, 2„  LINE INPUT "", m$„  IF m$ = "End of Entry" THEN EXIT DO„  PRINT #1, m$„LOOP„COLOR 7, 0„PRINT "Now that wasn't too hard was it."„PRINT "Just remember to do this every day."„COLOR 11„PRINT "QJournal (C) 1997 Mike Stewart."„CLOSE #1„END„END SUB„„SUB openfile„  CLS„  COLOR 7, 0„  ON ERROR GOTO errorhandler„  FILES "*.jrn"„  INPUT "C:\DOS>", o$„  LET ext$ = RIGHT$(o$, 4)„  ext$ = UCASE$(ext$)„  IF ext$ <> ".JRN" THEN LET o$ = o$ + ".jrn"„  OPEN o$ FOR INPUT AS #1„  ON ERROR GOTO 0„  INPUT "Password: ", p$„  LINE INPUT #1, fp$„  IF p$ <> fp$ THEN END„  CLOSE #1„  OPEN o$ FOR APPEND AS #1„  newentry„  CLOSE #1„  COLOR 11„  PRINT "QJournal (C) 1997 Mike Stewart."„END SUB„„SUB sparklepause„    COLOR 11, 0„    a$ = "*    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    "„    WHILE INKEY$ <> "": WEND 'Clear keyboard buffer„„    WHILE INKEY$ = ""„        FOR a = 1 TO 5„            LOCATE 1, 1                             'print horizontal sparkles„            PRINT MID$(a$, a, 80);„            LOCATE 22, 1„            PRINT MID$(a$, 6 - a, 80);„„            FOR b = 2 TO 21                         'Print Vertical sparkles„                c = (a + b) MOD 5„                IF c = 1 THEN„                    LOCATE b, 80„                    PRINT "*";„                    LOCATE 23 - b, 1„                    PRINT "*";„                ELSE„                    LOCATE b, 80„                    PRINT " ";„                    LOCATE 23 - b, 1„                    PRINT " ";„                END IF„            NEXT b„        NEXT a„    WEND„„END SUB„Michael G. Stewart             E-MAIL PROGRAM                 mikegs@juno.com                06-24-97 (21:26)       QB, QBasic, PDS        508  13564    EMAIL.BAS   DECLARE SUB clearm ()„DECLARE SUB writem ()„DECLARE SUB choice ()„DECLARE SUB readm ()„DECLARE SUB mainscreen ()„DECLARE SUB login ()„DECLARE SUB quit ()„DECLARE SUB center (row%, text$)„DECLARE SUB button (x1%, y1%, x2%, y2%, UpDown%)„DECLARE SUB intro ()„DECLARE SUB getmouse (mode%)„DECLARE SUB initmouse ()„DECLARE SUB mouse (OnOff%)„DECLARE SUB readdata ()„DECLARE FUNCTION Interupt% (Num%, ax%, bx%, cx%, dx%)„DIM SHARED xcoord%, ycoord%, click%„DIM SHARED ml%(45)„DIM SHARED fln$„DIM SHARED n$„DEFINT A-Z„readdata„initmouse„getmouse mode%„intro„login„choice„„„„„„MS.Data:               '<!--- WARNING - Do not change this... ---!>„ DATA 55,8b,ec,56,57„ DATA 8b,76,0c,8b,04„ DATA 8b,76,0a,8b,1c„ DATA 8b,76,08,8b,0c„ DATA 8b,76,06,8b,14„ DATA cd,21  „ DATA 8b,76,0c,89,04„ DATA 8b,76,0a,89,1c„ DATA 8b,76,08,89,0c„ DATA 8b,76,06,89,14„ DATA 5f,5e,5d„ DATA ca,08,00„ DATA #„„SUB button (x1, y1, x2, y2, UpDown)„   SELECT CASE UpDown„      CASE 1 'unpushed„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„      CASE 2 'pushed„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 8„         LINE (x1, y1)-(x1, y2 + 1), 8„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 15„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 15„      CASE 3 '[]„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 0„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y2 - 2), 8, B„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y1 + 1), 8, BF„      CASE 4 '_„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 2, y2 - 2)-(x2 - 2, y2 - 1), 8, BF„      CASE 5 'X„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 4, y1 + 3)-(x1 + 7, y1 + 6), 8, BF„         LINE (x1 + 3, y1 + 2)-(x1 + 4, y1 + 3), 8, BF„         LINE (x1 + 2, y1 + 1)-(x1 + 3, y1 + 2), 8, BF„         LINE (x1 + 7, y1 + 2)-(x1 + 8, y1 + 3), 8, BF„         LINE (x1 + 8, y1 + 1)-(x1 + 9, y1 + 2), 8, BF„         LINE (x1 + 3, y1 + 6)-(x1 + 4, y1 + 7), 8, BF„         LINE (x1 + 2, y1 + 7)-(x1 + 2, y1 + 8), 8, BF„         LINE (x1 + 7, y1 + 6)-(x1 + 8, y1 + 7), 8, BF„         LINE (x1 + 8, y1 + 7)-(x1 + 9, y1 + 8), 8, BF„      CASE 6 '\/„         a = (x2 - x1) / 2„         b = (y2 - y1) / 2„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + a, y2 - 2)-(x1 + 2, y1 + 2), 8„         LINE (x1 + a, y2 - 2)-(x2 - 2, y1 + 2), 8„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y1 + 2), 8„         PAINT (x1 + 5, y1 + 5), 8, 8„      CASE 50 'X disabled„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 4, y1 + 3)-(x1 + 7, y1 + 6), 15, BF„         LINE (x1 + 3, y1 + 2)-(x1 + 4, y1 + 3), 15, BF„         LINE (x1 + 2, y1 + 1)-(x1 + 3, y1 + 2), 15, BF„         LINE (x1 + 7, y1 + 2)-(x1 + 8, y1 + 3), 15, BF„         LINE (x1 + 8, y1 + 1)-(x1 + 9, y1 + 2), 15, BF„         LINE (x1 + 3, y1 + 6)-(x1 + 4, y1 + 7), 15, BF„         LINE (x1 + 2, y1 + 7)-(x1 + 2, y1 + 8), 15, BF„         LINE (x1 + 7, y1 + 6)-(x1 + 8, y1 + 7), 15, BF„         LINE (x1 + 8, y1 + 7)-(x1 + 9, y1 + 8), 15, BF„      CASE 30 '[] Disabled„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 0„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y2 - 2), 15, B„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y1 + 1), 15, BF„      CASE 40 '_ Disabled„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 2, y2 - 2)-(x2 - 2, y2 - 1), 15, BF„ „   END SELECT„„„END SUB„„SUB center (row%, text$)„    LOCATE row%, 41 - LEN(text$) / 2„    PRINT text$;„„END SUB„„SUB choice„mainscreen„button 150, 125, 490, 225, 1„LINE (151, 126)-(489, 224), 1, BF„center 17, "Your E-Mail Options Are:"„button 200, 172, 250, 187, 1„LINE (201, 173)-(249, 186), 1, BF„LOCATE 23, 27„PRINT "Read"„button 290, 172, 340, 187, 1„LINE (291, 173)-(339, 186), 1, BF„center 23, "Write"„button 380, 172, 430, 187, 1„LINE (381, 173)-(429, 186), 1, BF„LOCATE 23, 49„PRINT "Clear"„mouse 1„DO„ getmouse 0„ IF click% = 1 AND xcoord% >= 200 AND xcoord% <= 250 AND ycoord% >= 172 AND ycoord% <= 187 THEN button 200, 172, 250, 187, 2: readm„ IF click% = 1 AND xcoord% >= 290 AND xcoord% <= 340 AND ycoord% >= 172 AND ycoord% <= 187 THEN button 290, 172, 340, 187, 2: writem„ IF click% = 1 AND xcoord% >= 380 AND xcoord% <= 430 AND ycoord% >= 172 AND ycoord% <= 187 THEN button 380, 172, 430, 187, 2: clearm„ IF click% = 1 AND xcoord% >= 629 AND xcoord% <= 639 AND ycoord% >= 1 AND ycoord% <= 10 THEN button 629, 1, 639, 10, 2: SLEEP 1: button 629, 1, 639, 10, 5: quit„LOOP„mouse 0„END SUB„„SUB clearm„fln$ = n$ + ".eml"„OPEN fln$ FOR OUTPUT AS #7„CLOSE #7„choice„END SUB„„SUB getmouse (mode%)„„  R% = Interupt%(&H33, 3, bx%, cx%, dx%)„„  click% = bx%„„  IF mode% THEN„   xcoord% = cx% / 16 + 1„   ycoord% = dx% / 16 + 1„  ELSE„   xcoord% = cx%„   ycoord% = dx%„  END IF„„„END SUB„„SUB initmouse„„'Calls mouse interrupts...„„ R% = Interupt%(&H33, 0, bx%, cx%, dx%)„„END SUB„„FUNCTION Interupt% (Num%, ax%, bx%, cx%, dx%)„„ IF ml%(0) = 0 THEN   'Error, no MS.Data statment...„ BEEP„ BEEP„ END„ END IF„„ DEF SEG = VARSEG(ml%(0))„ POKE VARPTR(ml%(0)) + 26, Num%„„ CALL ABSOLUTE(ax%, bx%, cx%, dx%, VARPTR(ml%(0)))„„ Interupt% = ax%„„„END FUNCTION„„SUB intro„LOGO$ =  _„"C14 D30 R30 U30 L30 BF4 P14,14 C0 BD20 U4 R1 F3 D1 L4 BE2 P0,0 BG2 BU4 E10 F4 G10 H2 E10 BH2 C12 E3 F4 G3 H4 BR3 P12,12 C3 BL3 BG10 BD5 BL1 L2 D2 R2 BL2 D2 R2 BU2 BR2 R2 BR2 BD2 U4 F2 E2 D4 BR2 U3 E1 F1 D3 U2 L1 R1 BR2 BU2 R1 D4 L1 R2 L1 U4 R1 BR2 D4 R2 C4 BD5 L2 R1 D4 U4 BR2 BD4 U4 F2 E2 D4" _„„SCREEN 12: WIDTH 80, 30„PAINT (71, 1), 3, 3„button 200, 180, 440, 300, 1„LINE (202, 182)-(438, 298), 15, B„LINE (204, 184)-(436, 296), 0, BF„LINE (205, 185)-(435, 295), 4, B„LINE (199, 179)-(442, 302), 3, B„COLOR 4„center 13, "QBasic E-Mail"„center 14, "      for Windows 95"„COLOR 14„center 16, "Press any key or click mouse"„COLOR 4„center 17, "(C) 1997 Gascan Inc."„center 18, "All Rights Reseved"„DRAW "BM210,190"„DRAW "X" + VARPTR$(LOGO$)„mouse 1„DO„ getmouse 0„ IF click% = 1 OR click% = 2 THEN EXIT DO„ IF INKEY$ <> "" THEN EXIT DO„LOOP WHILE INKEY$ = ""„mouse 0„END SUB„„SUB login„SCREEN 9„WIDTH 80, 43„CLS„COLOR 15, 1„button 200, 85, 440, 200, 1„LINE (199, 84)-(442, 202), 3, B„LINE (201, 86)-(439, 98), 1, BF„LOCATE 12, 28„PRINT "QBasic E-Mail - Login"„button 427, 87, 437, 97, 50„button 202, 98, 438, 198, 2„LINE (204, 100)-(436, 196), 1, BF„PAINT (1, 1), 3, 3„COLOR 14„center 22, "To Create a New Account,"„center 23, "Type 'Create' at the Prompt."„COLOR 15„LOCATE 14, 28„PRINT "Account Name: "„button 323, 101, 390, 111, 2„LINE (324, 102)-(389, 111), 1, BF„LOCATE 16, 28„PRINT "Password:     "„button 323, 118, 390, 128, 2„LINE (324, 119)-(389, 128), 1, BF„LOCATE 14, 42„INPUT "", n$„IF n$ = "Mike" THEN„  pass$ = "2928751"„ELSEIF n$ = "justin" THEN„  pass$ = "123"„ELSEIF n$ = "ginanne" THEN„  pass$ = "8484"„ELSEIF n$ = "Kim" THEN„  pass$ = "sew"„ELSEIF n$ = "Quit" THEN„ quit„ELSE„  COLOR 4„  center 18, "Incorrect Login"„  SLEEP 2„  login„END IF„LOCATE 16, 42„b = LEN(pass$)„FOR a = 1 TO b„ PRINT "*";„NEXT a„LOCATE 16, 42„COLOR 1„INPUT "", p$„COLOR 15„IF p$ <> pass$ THEN„  COLOR 4„  center 18, "Password Incorrect!"„  SLEEP 2„  login„ELSE„  center 18, "Login Correct!"„  center 19, "Loading Account:"„  nme$ = UCASE$(n$)„  acc$ = nme$ + "@GASCAN.QBASIC.EML"„  center 20, acc$„  LOCATE 21, 32„  PRINT "Please Wait";„  FOR a = 1 TO 5„    PRINT ".";„    SLEEP 1„  NEXT a„END IF„fln$ = n$ + ".eml"„END SUB„„SUB mainscreen„CLS„COLOR 15, 1„LOCATE 1„PRINT "  QBasic E-Mail - "; fln$„button 629, 1, 639, 10, 5„FOR a% = 3 TO 41„ LOCATE a%, 1„ PRINT SPACE$(80)„NEXT a%„LOCATE 3, 1„PRINT STRING$(80, 205)„END SUB„„SUB mouse (OnOff%)„„ IF OnOff% = 0 THEN OnOff% = 2 ELSE OnOff% = 1„ R% = Interupt%(&H33, OnOff%, bx%, cx%, dx%)„„END SUB„„SUB quit„mouse 0„SYSTEM„END SUB„„SUB readdata„„'Reads machine language thingy MS.Data...„„RESTORE MS.Data„ DEF SEG = VARSEG(ml%(0))„„ FOR i% = 0 TO 99„  READ Octet$„  IF Octet$ = "#" THEN EXIT FOR„  POKE VARPTR(ml%(0)) + i%, VAL("&H" + Octet$)„ NEXT i%„„END SUB„„SUB readm„mainscreen„COLOR 15„fln$ = n$ + ".eml"„OPEN fln$ FOR INPUT AS #2„a% = 3„DO UNTIL EOF(2)                     'do untill end of file„  DO WHILE rec$ <> "End of Message"       'do untill end of message„    DO WHILE a% <> 40                       'do untill end of screen„      a% = a% + 1„      LINE INPUT #2, rec$„      LOCATE a%, 2„      PRINT rec$„      IF rec$ = "End of Message" THEN EXIT DO„    LOOP„    IF rec$ = "End of Message" THEN EXIT DO„    LOCATE a% + 1, 2„    PRINT "Press Esc to view next page."„    a% = 3„    SLEEP„    mainscreen„  LOOP„  rec$ = ""„  LOCATE a% + 2, 2„  a% = 3„  PRINT "Press any key to view next message."„  SLEEP„  mainscreen„LOOP„a% = 3„CLOSE #2„OPEN "all.eml" FOR INPUT AS #2„DO UNTIL EOF(2)                     'do untill end of file„  DO WHILE rec$ <> "End of Message"       'do untill end of message„    DO WHILE a% <> 40                       'do untill end of screen„      a% = a% + 1„      LINE INPUT #2, rec$„      LOCATE a%, 2„      PRINT rec$„      IF rec$ = "End of Message" THEN EXIT DO„    LOOP„    IF rec$ = "End of Message" THEN EXIT DO„    LOCATE a% + 1, 2„    PRINT "Press Esc to view next page."„    a% = 3„    SLEEP„    mainscreen„  LOOP„  rec$ = ""„  IF EOF(2) THEN EXIT DO„  LOCATE a% + 2, 2„  a% = 3„  PRINT "Press any key to view next message."„  SLEEP„  mainscreen„LOOP„CLOSE #2„COLOR 12„center 42, "End of E-Mail File, Or No E-Mail In File."„center 43, "Press Enter to Continue."„SLEEP„choice„END SUB„„SUB writem„mouse 0„mainscreen„COLOR 14„center 4, "To Write Mail, you will be using MS-DOS edit."„center 5, "When you are done writing your E-Mail,"„center 6, "Press Alt, F, X, Enter."„center 7, "Do Not Write Past Column 78"„center 8, "Try to Keep your Message to 40 Lines."„COLOR 15„center 10, "Choose the person to write to:"„COLOR 14„center 12, "E-Mail Address                           (Name)"„COLOR 15„center 13, "Mike@GASCAN.QBASIC.EML     (Michael G. Stewart)"„center 14, "justin@GASCAN.QBASIC.EML    (Justin C. Stewart)"„center 15, "ginanne@GASCAN.QBASIC.EML  (Ginanne K. Stewart)"„center 16, "Kim@GASCAN.QBASIC.EML             (Kim Stewart)"„center 17, "Internet@GASCAN.QBASIC.EML        (Anyone Else)"„center 18, "All@GASCAN.QBASIC.EML               (All Users)"„mouse 1„DO„ getmouse 0„ LOCATE 10, 1: PRINT ycoord%„ IF click% = 1 AND ycoord% >= 96 AND ycoord% < 104 THEN wrto$ = "Mike": EXIT DO„ IF click% = 1 AND ycoord% >= 104 AND ycoord% < 112 THEN wrto$ = "justin": EXIT DO„ IF click% = 1 AND ycoord% >= 112 AND ycoord% < 120 THEN wrto$ = "ginanne": EXIT DO„ IF click% = 1 AND ycoord% >= 120 AND ycoord% < 128 THEN wrto$ = "Kim": EXIT DO„ IF click% = 1 AND ycoord% >= 128 AND ycoord% < 136 THEN wrto$ = "Internet": EXIT DO„ IF click% = 1 AND ycoord% >= 136 AND ycoord% < 144 THEN wrto$ = "All": EXIT DO„LOOP„mouse 0„COLOR 14„IF wrto$ = "Mike" THEN„ center 13, "Mike@GASCAN.QBASIC.EML     (Michael G. Stewart)"„ELSEIF wrto$ = "justin" THEN„ center 14, "justin@GASCAN.QBASIC.EML    (Justin C. Stewart)"„ELSEIF wrto$ = "ginanne" THEN„ center 15, "ginanne@GASCAN.QBASIC.EML  (Ginanne K. Stewart)"„ELSEIF wrto$ = "Kim" THEN„ center 16, "Kim@GASCAN.QBASIC.EML             (Kim Stewart)"„ELSEIF wrto$ = "Internet" THEN„ center 17, "Internet@GASCAN.QBASIC.EML        (Anyone Else)"„ COLOR 15„ LOCATE 19, 30„ INPUT "E-Mail Address: ", iadd$„ELSEIF wrto$ = "All" THEN„ center 18, "6) All@GASCAN.QBASIC.EML               (All Users)"„END IF„LOCATE 21, 30„INPUT "Subject: ", sub$„SLEEP 5„SCREEN 0„WIDTH 80, 25„COLOR 7, 0„CLS„SHELL "edit temp.eml"„fln$ = wrto$ + ".eml"„frm$ = n$ + "@GASCAN.QBASIC.EML"„OPEN "temp.eml" FOR INPUT AS #6„OPEN fln$ FOR APPEND AS #4„PRINT #4, "Date: "; DATE$„PRINT #4, "Time: "; TIME$„PRINT #4, "Subject: "; sub$„PRINT #4, "From: "; frm$„PRINT #4, STRING$(78, 196)„DO WHILE NOT EOF(6)„  LINE INPUT #6, mess$„  PRINT #4, mess$„LOOP„PRINT #4, "End of Message"„CLOSE #4„CLOSE #6„KILL "temp.eml"„SCREEN 9„WIDTH 80, 43„CLS„COLOR 15, 1„choice„END SUB„Michael G. Stewart             DAILY PLANNER                  mikegs@juno.com                06-24-97 (21:26)       QB, QBasic, PDS        424  10405    PLANNER.BAS DECLARE SUB printtimes (DTE$)„DECLARE SUB planner ()„DECLARE SUB opens ()„DECLARE SUB new ()„DECLARE SUB title (n$)„DECLARE SUB clearm ()„DECLARE SUB writem ()„DECLARE SUB choice ()„DECLARE SUB readm ()„DECLARE SUB mainscreen ()„DECLARE SUB login ()„DECLARE SUB quit ()„DECLARE SUB center (row%, text$)„DECLARE SUB button (x1%, y1%, x2%, y2%, UpDown%)„DECLARE SUB intro ()„DECLARE SUB getmouse (mode%)„DECLARE SUB initmouse ()„DECLARE SUB mouse (OnOff%)„DECLARE SUB readdata ()„DECLARE FUNCTION Interupt% (Num%, ax%, bx%, cx%, dx%)„DIM SHARED xcoord%, ycoord%, click%„DIM SHARED ml%(45)„DIM SHARED fl$„DEFINT A-Z„ON ERROR GOTO errors„readdata„initmouse„getmouse mode%„intro„SCREEN 9„WIDTH 80, 43„CLS„COLOR 15, 1„title "Untitled"„choice„„errors:„RESUME NEXT„„„MS.Data:               '<!--- WARNING - Do not change this... ---!>„ DATA 55,8b,ec,56,57„ DATA 8b,76,0c,8b,04„ DATA 8b,76,0a,8b,1c„ DATA 8b,76,08,8b,0c„ DATA 8b,76,06,8b,14„ DATA cd,21„ DATA 8b,76,0c,89,04„ DATA 8b,76,0a,89,1c„ DATA 8b,76,08,89,0c„ DATA 8b,76,06,89,14„ DATA 5f,5e,5d„ DATA ca,08,00„ DATA #„„SUB button (x1, y1, x2, y2, UpDown)„   SELECT CASE UpDown„      CASE 1 'unpushed„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„      CASE 2 'pushed„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 8„         LINE (x1, y1)-(x1, y2 + 1), 8„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 15„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 15„      CASE 3 '[]„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 0„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y2 - 2), 8, B„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y1 + 1), 8, BF„      CASE 4 '_„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 2, y2 - 2)-(x2 - 2, y2 - 1), 8, BF„      CASE 5 'X„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 4, y1 + 3)-(x1 + 7, y1 + 6), 8, BF„         LINE (x1 + 3, y1 + 2)-(x1 + 4, y1 + 3), 8, BF„         LINE (x1 + 2, y1 + 1)-(x1 + 3, y1 + 2), 8, BF„         LINE (x1 + 7, y1 + 2)-(x1 + 8, y1 + 3), 8, BF„         LINE (x1 + 8, y1 + 1)-(x1 + 9, y1 + 2), 8, BF„         LINE (x1 + 3, y1 + 6)-(x1 + 4, y1 + 7), 8, BF„         LINE (x1 + 2, y1 + 7)-(x1 + 2, y1 + 8), 8, BF„         LINE (x1 + 7, y1 + 6)-(x1 + 8, y1 + 7), 8, BF„         LINE (x1 + 8, y1 + 7)-(x1 + 9, y1 + 8), 8, BF„      CASE 6 '\/„         a = (x2 - x1) / 2„         b = (y2 - y1) / 2„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + a, y2 - 2)-(x1 + 2, y1 + 2), 8„         LINE (x1 + a, y2 - 2)-(x2 - 2, y1 + 2), 8„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y1 + 2), 8„         PAINT (x1 + 5, y1 + 5), 8, 8„      CASE 50 'X disabled„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 4, y1 + 3)-(x1 + 7, y1 + 6), 15, BF„         LINE (x1 + 3, y1 + 2)-(x1 + 4, y1 + 3), 15, BF„         LINE (x1 + 2, y1 + 1)-(x1 + 3, y1 + 2), 15, BF„         LINE (x1 + 7, y1 + 2)-(x1 + 8, y1 + 3), 15, BF„         LINE (x1 + 8, y1 + 1)-(x1 + 9, y1 + 2), 15, BF„         LINE (x1 + 3, y1 + 6)-(x1 + 4, y1 + 7), 15, BF„         LINE (x1 + 2, y1 + 7)-(x1 + 2, y1 + 8), 15, BF„         LINE (x1 + 7, y1 + 6)-(x1 + 8, y1 + 7), 15, BF„         LINE (x1 + 8, y1 + 7)-(x1 + 9, y1 + 8), 15, BF„      CASE 30 '[] Disabled„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 0„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y2 - 2), 15, B„         LINE (x1 + 2, y1 + 2)-(x2 - 2, y1 + 1), 15, BF„      CASE 40 '_ Disabled„         LINE (x1, y1)-(x2, y2), 7, BF„         LINE (x1, y1)-(x2 - 1, y1), 15„         LINE (x1, y1)-(x1, y2 + 1), 15„         LINE (x1, y2 + 1)-(x2 + 1, y2 + 1), 8„         LINE (x2 + 1, y2 + 1)-(x2 + 1, y1), 8„         LINE (x1 + 2, y2 - 2)-(x2 - 2, y2 - 1), 15, BF„ „   END SELECT„„„END SUB„„SUB center (row%, text$)„    LOCATE row%, 41 - LEN(text$) / 2„    PRINT text$;„„END SUB„„SUB choice„COLOR 15„mainscreen„button 150, 125, 490, 225, 1„LINE (151, 126)-(489, 224), 1, BF„button 200, 172, 250, 187, 1„LINE (201, 173)-(249, 186), 1, BF„LOCATE 23, 28„PRINT "New"„button 290, 172, 340, 187, 1„LINE (291, 173)-(339, 186), 1, BF„center 23, "Open "„button 380, 172, 430, 187, 1„LINE (381, 173)-(429, 186), 1, BF„LOCATE 23, 50„PRINT "Quit"„mouse 1„DO„ getmouse 0„ IF click% = 1 AND xcoord% >= 200 AND xcoord% <= 250 AND ycoord% >= 172 AND ycoord% <= 187 THEN button 200, 172, 250, 187, 2: new„ IF click% = 1 AND xcoord% >= 290 AND xcoord% <= 340 AND ycoord% >= 172 AND ycoord% <= 187 THEN button 290, 172, 340, 187, 2: opens„ IF click% = 1 AND xcoord% >= 380 AND xcoord% <= 430 AND ycoord% >= 172 AND ycoord% <= 187 THEN button 380, 172, 430, 187, 2: quit„ IF click% = 1 AND xcoord% >= 629 AND xcoord% <= 639 AND ycoord% >= 1 AND ycoord% <= 10 THEN button 629, 1, 639, 10, 2: SLEEP 1: button 629, 1, 639, 10, 5: quit„LOOP„mouse 0„END SUB„„SUB getmouse (mode%)„„  R% = Interupt%(&H33, 3, bx%, cx%, dx%)„„  click% = bx%„„  IF mode% THEN„   xcoord% = cx% / 16 + 1„   ycoord% = dx% / 16 + 1„  ELSE„   xcoord% = cx%„   ycoord% = dx%„  END IF„„„END SUB„„SUB initmouse„„'Calls mouse interrupts...„„ R% = Interupt%(&H33, 0, bx%, cx%, dx%)„„END SUB„„FUNCTION Interupt% (Num%, ax%, bx%, cx%, dx%)„„ IF ml%(0) = 0 THEN   'Error, no MS.Data statment...„ BEEP„ BEEP„ END„ END IF„„ DEF SEG = VARSEG(ml%(0))„ POKE VARPTR(ml%(0)) + 26, Num%„„ CALL ABSOLUTE(ax%, bx%, cx%, dx%, VARPTR(ml%(0)))„„ Interupt% = ax%„„„END FUNCTION„„SUB intro„logo$ = "C0 BD6 BR2 E4 R6 F4 E4 R6 F4 D20 H4 L6 G4 H4 L6 G4 U20 BR14 D20 L16 R32 U21 L3 BL26 L3 D21 BE4 P15,0 BE15 P15,0 BU4 BD22 P0,0 BL14 P0,0 BH4 P4,0 BR30 P4,0"„SCREEN 12: WIDTH 80, 30„PAINT (71, 1), 3, 3„button 200, 180, 440, 300, 1„LINE (202, 182)-(438, 298), 15, B„LINE (204, 184)-(436, 296), 0, BF„LINE (205, 185)-(435, 295), 4, B„LINE (199, 179)-(442, 302), 3, B„COLOR 4„center 13, "QBasic Planner"„center 14, "     for Windows 95"„COLOR 14„center 16, "Press any key or click mouse"„COLOR 4„center 17, "(C) 1997 Gascan"„center 18, "All Rights Reseved"„LOCATE 13, 28„button 209, 189, 243, 223, 1„DRAW "BM210,190"„DRAW "X" + VARPTR$(logo$)„mouse 1„DO„ getmouse 0„ IF click% = 1 OR click% = 2 THEN EXIT DO„ IF INKEY$ <> "" THEN EXIT DO„LOOP WHILE INKEY$ = ""„mouse 0„END SUB„„SUB mainscreen„FOR a% = 3 TO 41„ LOCATE a%, 1„ PRINT SPACE$(80)„NEXT a%„LOCATE 3, 1„PRINT STRING$(80, 205)„END SUB„„SUB mouse (OnOff%)„„ IF OnOff% = 0 THEN OnOff% = 2 ELSE OnOff% = 1„ R% = Interupt%(&H33, OnOff%, bx%, cx%, dx%)„„END SUB„„SUB new„title "New"„mainscreen„LOCATE 4, 2: INPUT "First Name: ", f$„LOCATE 5, 2: INPUT "Middle Initial: ", m$„LOCATE 6, 2: INPUT "Last Name: ", l$„LOCATE 7, 2: INPUT "File Name: ", fl$„fl$ = fl$ + ".pln"„OPEN "members.pln" FOR APPEND AS #1„PRINT #1, "Name: "; l$; ", "; f$; " "; m$; ".", "File: "; fl$„CLOSE #1„planner„END SUB„„SUB opens„title "Open"„mainscreen„OPEN "members.pln" FOR INPUT AS #1„a% = 4„DO WHILE NOT EOF(1)„ LINE INPUT #1, mem$„ LOCATE a%, 2: PRINT mem$„ a% = a% + 1„LOOP„LOCATE a%, 2: INPUT "File to Open"; fl$„fl$ = fl$ + ".pln"„title fl$„OPEN fl$ FOR INPUT AS #2„CLOSE #1„DO WHILE NOT EOF(2)„ mainscreen„ LINE INPUT #2, a$„ printtimes a$„ FOR a = 1 TO 33„  b% = a + 4„  LINE INPUT #2, rec$„  LOCATE b%, 10: PRINT rec$„ NEXT„ center 38, "Press Esc to view next schedule, or Shift+PrintScreen to Print."„ DO: LOOP WHILE INKEY$ <> CHR$(27)„ IF EOF(2) THEN EXIT DO„LOOP„CLOSE #2„center 39, "Press Spacebar to Plan, or Esc to End."„DO„ kbd$ = ""„ kbd$ = INKEY$„ IF kbd$ = CHR$(27) THEN quit„ IF kbd$ = " " THEN planner„LOOP„END SUB„„SUB planner„title fl$„mainscreen„LOCATE 4, 2„INPUT "Plan What Date"; DTE$„mainscreen„printtimes DTE$„b% = 5„OPEN fl$ FOR APPEND AS #2„PRINT #2, DTE$„FOR a = 1 TO 16„ COLOR 15„ LOCATE b%, 10: INPUT "", a$„ COLOR 14„ LOCATE b% + 1, 10: INPUT "", b$„ PRINT #2, a$„ PRINT #2, b$„ b% = b% + 2„NEXT a„COLOR 15„LOCATE b%, 10: INPUT "", a$„PRINT #2, a$„CLOSE #2„center 40, "Press Esc to work with another file, or press Shift+PrintScreen to Print"„DO: LOOP WHILE INKEY$ <> CHR$(27)„choice„END SUB„„SUB printtimes (DTE$)„center 4, DTE$„b% = 5„FOR a = 6 TO 12„ IF a < 10 THEN„  COLOR 15„  LOCATE b%, 2„  PRINT a; " :00"„  COLOR 14„  LOCATE b% + 1, 2„  PRINT a; " :30"„ ELSEIF a >= 10 THEN„  COLOR 15„  LOCATE b%, 2„  PRINT a; ":00"„  COLOR 14„  LOCATE b% + 1, 2„  PRINT a; ":30"„ END IF„ LET b% = b% + 2„NEXT a„FOR a = 1 TO 9„ IF a < 10 THEN„  COLOR 15„  LOCATE b%, 2„  PRINT a; " :00"„  COLOR 14„  LOCATE b% + 1, 2„  PRINT a; " :30"„ ELSEIF a >= 10 THEN„  COLOR 15„  LOCATE b%, 2„  PRINT a; ":00"„  COLOR 14„  LOCATE b% + 1, 2„  PRINT a; ":30"„ END IF„ LET b% = b% + 2„NEXT a„COLOR 15„LOCATE b%, 3„PRINT "10 :00"„„END SUB„„SUB quit„mouse 0„title "Quitting..."„mainscreen„mouse 1„SLEEP 3„mouse 0„SYSTEM„END SUB„„SUB readdata„„'Reads machine language thingy MS.Data...„„RESTORE MS.Data„ DEF SEG = VARSEG(ml%(0))„„ FOR i% = 0 TO 99„  READ Octet$„  IF Octet$ = "#" THEN EXIT FOR„  POKE VARPTR(ml%(0)) + i%, VAL("&H" + Octet$)„ NEXT i%„„END SUB„„SUB title (n$)„LOCATE 1„PRINT SPACE$(80)„LOCATE 1„PRINT "  QBasic Planner - "; n$„button 629, 1, 639, 10, 5„END SUB„Brian Bacon                    BRIAN'S FILE PACKER            kyberteknik@geocities.com      07-03-97 (17:48)       QB, PDS                206  6362     BPAK.BAS    'Ok, here is what I made this for: I needed a way to store files„'(compressed preferably) so I can unstore them with an installation„'program. Well, PKWare wants like hundreds of dollars to use their„'compression routines and they are even the same ones used in PKZIP„'so, I found a LZW compressor written by Rich Geldreich, but it only„'compresses one file at a time.  I needed a way to make lots of files„'into one file.  So I made this program.  All it does is store lots„'of files in one bigger file (it adds like 20 bytes per file, but„'I think that is ok if your gonna compress the output anyways).„'So, I used this to make a bunch of files into one, then compressed„'it with Rich's program, then made an uninstall program that uses„'Rich's decompressor and my unpacker together, (changed the way the„'output looks on both programs (just edited some print statements)„'give credit where it is due, and I had a nice install program for„'a game I am working on.  You can do it to! :)„'„'This program is written in the most part by Brian Bacon„'DIR.BAS is by Dave Cleary, ErrorMsgs was written by someone„'(sorry I forgot the name), and ComLine is one of QuickBASIC's„'exmaple programs.„'„'Note - This program does NO compression„'„DEFINT A-Z„DECLARE FUNCTION DIR$ (FileSpec$)„DECLARE SUB ComLine (N, A$())„DECLARE SUB ErrorMsgs ()„„'$INCLUDE: 'QB.BI'„„ON ERROR GOTO ErrHandler„„DIM Argv$(30), InFiles$(30)„DIM SHARED EFlag%, VErr$„„PRINT "BPAK - Brian's file PAcKing utility v1.0"„ComLine Argc, Argv$()„„Outf = 0„FOR I = 1 TO Argc„    SELECT CASE LEFT$(UCASE$(Argv$(I)), 2)„	   CASE "-H", "-?", "/H", "/?": 'GOTO Usage„	   CASE ELSE„		IF Outf = 0 THEN„		   OutFile$ = Argv$(I)„		ELSE„		   InFiles$(Outf) = Argv$(I)„		   IF DIR$(Argv$(I)) = "" THEN ERROR 255„		END IF„		Outf = Outf + 1„    END SELECT„NEXT I„„PRINT "Output file: " + OutFile$„OPEN OutFile$ FOR BINARY AS #1„IF LOF(1) THEN ERROR 254„CurFil = 1„DO UNTIL InFiles$(CurFil - 1) = "!!" AND InFile$(CurFil) = ""„   InFile$ = DIR$(InFiles$(CurFil))„   IF InFile$ <> "" THEN„      InFiles$(CurFil) = ""„      InFile$ = LEFT$(InFile$, LEN(InFile$) - 1)„      OPEN InFile$ FOR BINARY AS #2„	   PRINT "(  0%) - " + InFile$;„	   InFile$ = InFile$ + SPACE$(12 - LEN(InFile$))„	   PUT #1, , InFile$„	   flof& = LOF(2)„	   PUT #1, , flof&„	   W$ = SPACE$(100)„	   FOR I = 1 TO flof& \ 100„	       LOCATE , 2: PRINT USING "###"; 100 * (LOC(2) / LOF(2));„	       GET #2, , W$„	       PUT #1, , W$„	   NEXT I„	   W$ = SPACE$(flof& MOD 100)„	   GET #2, , W$„	   PUT #1, , W$„	   LOCATE , 2: PRINT USING "###"; 100 * (LOC(2) / LOF(2))„      CLOSE 2„   ELSE„      InFiles$(CurFil) = "!!"„      CurFil = CurFil + 1„   END IF„LOOP„CLOSE 1„END„„ErrHandler:„CLOSE„EFlag% = ERR„CALL ErrorMsgs„PRINT VErr$: PRINT„END„„SUB ComLine (NumArgs, Args$()) STATIC„  CONST TRUE = -1, FALSE = 0„  IF Init = FALSE THEN MaxArgs = UBOUND(Args$): Init = TRUE„  NumArgs = 0: In = FALSE„   Cl$ = COMMAND$„   L = LEN(Cl$)„   FOR I = 1 TO L„      c$ = MID$(Cl$, I, 1)„      IF (c$ <> " " AND c$ <> CHR$(9)) THEN„	 IF NOT In THEN„	    IF NumArgs = MaxArgs THEN EXIT FOR„	    NumArgs = NumArgs + 1„	    In = TRUE„	 END IF„	 Args$(NumArgs) = Args$(NumArgs) + c$„      ELSE„	 In = FALSE„      END IF„   NEXT I„END SUB„„FUNCTION DIR$ (FileSpec$) STATIC„   DIM DTA AS STRING * 44, Regs AS RegTypeX„   Null$ = CHR$(0)„   Regs.AX = &H1A00„   Regs.DX = VARPTR(DTA)„   Regs.DS = -1„   InterruptX &H21, Regs, Regs„   IF LEN(FileSpec$) THEN„	 FileSpecZ$ = FileSpec$ + Null$„	 Regs.AX = &H4E00„	 Regs.CX = 0„	 Regs.DX = SADD(FileSpecZ$)„	 Regs.DS = -1„   ELSE„	 Regs.AX = &H4F00„   END IF„   InterruptX &H21, Regs, Regs„   IF Regs.Flags AND 1 THEN„	 DIR$ = ""„   ELSE„	 Null = INSTR(31, DTA, Null$)„	 DIR$ = MID$(DTA, 31, Null - 30)„   END IF„END FUNCTION„„SUB ErrorMsgs„IF EFlag% = 0 THEN EXIT SUB„SELECT CASE EFlag%„	CASE 1:  VErr$ = "SHARE not active"„	CASE 2:  VErr$ = "Syntax Error"„	CASE 3:  VErr$ = "Return w/o gosub"„	CASE 4:  VErr$ = "Out of Data"„	CASE 5:  VErr$ = "Illegal Function Call"„	CASE 6:  VErr$ = "Overflow"„	CASE 7:  VErr$ = "Out of Memory"„	CASE 8:  VErr$ = "Label not defined"„	CASE 9:  VErr$ = "Subscript out of range"„	CASE 10: VErr$ = "Duplicate Definition"„	CASE 11: VErr$ = "Division by Zero"„	CASE 12: VErr$ = "Illegal in direct mode"„	CASE 13: VErr$ = "Type Mismatch"„	CASE 14: VErr$ = "Out of string space"„	CASE 15: VErr$ = "Fossil not available"„	CASE 16: VErr$ = "String formula too complex"„	CASE 17: VErr$ = "Carrier Dropped!"„	CASE 18: VErr$ = "Function not defined"„	CASE 19: VErr$ = "No RESUME"„	CASE 20: VErr$ = "RESUME w/o error"„	CASE 24: VErr$ = "Modem or Device Timeout"„	CASE 25: VErr$ = "Modem or Device fault"„	CASE 26: VErr$ = "FOR w/o NEXT"„	CASE 27: VErr$ = "Out of paper"„	CASE 29: VErr$ = "WHILE w/o WEND"„	CASE 30: VErr$ = "WEND w/o WHILE"„	CASE 33: VErr$ = "Duplicate Label"„	CASE 35: VErr$ = "Subprogram not defined"„	CASE 37: VErr$ = "Aurgument-count mismatch"„	CASE 38: VErr$ = "Array not defined"„	CASE 39: VErr$ = "CASE ELSE expected"„	CASE 40: VErr$ = "Variable Required"„	CASE 50: VErr$ = "Buffer or Field overflow"„	CASE 51: VErr$ = "System error"„	CASE 52: VErr$ = "Bad file name or number"„	CASE 53: VErr$ = "File not found"„	CASE 54: VErr$ = "Bad file mode"„	CASE 55: VErr$ = "File already open"„	CASE 56: VErr$ = "Field statement active"„	CASE 57: VErr$ = "Modem or Device I/O error"„	CASE 58: VErr$ = "File already exists"„	CASE 59: VErr$ = "Bad record length"„	CASE 61: VErr$ = "Disk full"„	CASE 62: VErr$ = "Input past end of file"„	CASE 63: VErr$ = "Bad record number"„	CASE 64: VErr$ = "Invalid filename"„	CASE 67: VErr$ = "Too many files"„	CASE 68: VErr$ = "Drive/Device Unavailable"„	CASE 69: VErr$ = "Comm buffer overflow"„	CASE 70: VErr$ = "Permission denied"„	CASE 71: VErr$ = "Disk/Printer not ready"„	CASE 72: VErr$ = "Disk media error"„	CASE 73: VErr$ = "Feature not available"„	CASE 74: VErr$ = "Rename across disks"„	CASE 75: VErr$ = "Path/File access error"„	CASE 76: VErr$ = "Path not found"„	CASE 254: VErr$ = "Output file already exists"„	CASE 255: VErr$ = "Input file not found"„„	CASE ELSE: VErr$ = "UNIDENTIFIED ERROR"„END SELECT„VErr$ = VErr$ + "!"„END SUB„Brian Bacon                    BRIAN'S FILE UNPACKER          kyberteknik@geocities.com      07-03-97 (17:48)       QB, PDS                147  4216     BUNPAK.BAS  'This program is written in the most part by Brian Bacon„'but ComLine is one of QuickBASIC's exmaple programs.„'„DEFINT A-Z„DECLARE SUB ComLine (N, A$())„DECLARE SUB ErrorMsgs ()„„ON ERROR GOTO ErrHandler„„DIM Argv$(30), InFiles$(30)„DIM SHARED EFlag%, VErr$„„PRINT "BUNPAK - Brian's file UNPAcKing utility v1.0"„ComLine Argc, Argv$()„„Outf = 0„FOR I = 1 TO Argc„    SELECT CASE LEFT$(UCASE$(Argv$(I)), 2)„	   CASE "-H", "-?", "/H", "/?": 'GOTO Usage„	   CASE ELSE„		IF Outf = 0 THEN„		   OutFile$ = Argv$(I)„		   Outf = 1„		ELSE„		   ERROR 255„		END IF„    END SELECT„NEXT I„„PRINT "Input file: " + OutFile$„OPEN OutFile$ FOR BINARY AS #1„IF LOF(1) = 0 THEN ERROR 53„DO UNTIL LOF(1) = LOC(1)„   InFile$ = SPACE$(12)„   GET #1, , InFile$„   GET #1, , FileLen&„   InFile$ = RTRIM$(InFile$)„   OPEN InFile$ FOR BINARY AS #2„	PRINT "(  0%) - " + InFile$;„	IF LOF(2) THEN ERROR 58„	W$ = SPACE$(100)„	FOR I = 1 TO FileLen& \ 100„	    LOCATE , 2: PRINT USING "###"; 100 * (LOC(2) / FileLen&);„	    GET #1, , W$„	    PUT #2, , W$„	NEXT I„	W$ = SPACE$(FileLen& MOD 100)„	GET #1, , W$„	PUT #2, , W$„	LOCATE , 2: PRINT USING "###"; 100 * (LOC(2) / FileLen&)„   CLOSE 2„LOOP„END„„ErrHandler:„CLOSE„EFlag% = ERR„CALL ErrorMsgs„PRINT VErr$: PRINT„END„„SUB ComLine (NumArgs, Args$()) STATIC„  CONST TRUE = -1, FALSE = 0„  IF Init = FALSE THEN MaxArgs = UBOUND(Args$): Init = TRUE„  NumArgs = 0: In = FALSE„   Cl$ = COMMAND$„   L = LEN(Cl$)„   FOR I = 1 TO L„      c$ = MID$(Cl$, I, 1)„      IF (c$ <> " " AND c$ <> CHR$(9)) THEN„	 IF NOT In THEN„	    IF NumArgs = MaxArgs THEN EXIT FOR„	    NumArgs = NumArgs + 1„	    In = TRUE„	 END IF„	 Args$(NumArgs) = Args$(NumArgs) + c$„      ELSE„	 In = FALSE„      END IF„   NEXT I„END SUB„„SUB ErrorMsgs„IF EFlag% = 0 THEN EXIT SUB„SELECT CASE EFlag%„	CASE 1:  VErr$ = "SHARE not active"„	CASE 2:  VErr$ = "Syntax Error"„	CASE 3:  VErr$ = "Return w/o gosub"„	CASE 4:  VErr$ = "Out of Data"„	CASE 5:  VErr$ = "Illegal Function Call"„	CASE 6:  VErr$ = "Overflow"„	CASE 7:  VErr$ = "Out of Memory"„	CASE 8:  VErr$ = "Label not defined"„	CASE 9:  VErr$ = "Subscript out of range"„	CASE 10: VErr$ = "Duplicate Definition"„	CASE 11: VErr$ = "Division by Zero"„	CASE 12: VErr$ = "Illegal in direct mode"„	CASE 13: VErr$ = "Type Mismatch"„	CASE 14: VErr$ = "Out of string space"„	CASE 15: VErr$ = "Fossil not available"„	CASE 16: VErr$ = "String formula too complex"„	CASE 17: VErr$ = "Carrier Dropped!"„	CASE 18: VErr$ = "Function not defined"„	CASE 19: VErr$ = "No RESUME"„	CASE 20: VErr$ = "RESUME w/o error"„	CASE 24: VErr$ = "Modem or Device Timeout"„	CASE 25: VErr$ = "Modem or Device fault"„	CASE 26: VErr$ = "FOR w/o NEXT"„	CASE 27: VErr$ = "Out of paper"„	CASE 29: VErr$ = "WHILE w/o WEND"„	CASE 30: VErr$ = "WEND w/o WHILE"„	CASE 33: VErr$ = "Duplicate Label"„	CASE 35: VErr$ = "Subprogram not defined"„	CASE 37: VErr$ = "Aurgument-count mismatch"„	CASE 38: VErr$ = "Array not defined"„	CASE 39: VErr$ = "CASE ELSE expected"„	CASE 40: VErr$ = "Variable Required"„	CASE 50: VErr$ = "Buffer or Field overflow"„	CASE 51: VErr$ = "System error"„	CASE 52: VErr$ = "Bad file name or number"„	CASE 53: VErr$ = "File not found"„	CASE 54: VErr$ = "Bad file mode"„	CASE 55: VErr$ = "File already open"„	CASE 56: VErr$ = "Field statement active"„	CASE 57: VErr$ = "Modem or Device I/O error"„	CASE 58: VErr$ = "File already exists"„	CASE 59: VErr$ = "Bad record length"„	CASE 61: VErr$ = "Disk full"„	CASE 62: VErr$ = "Input past end of file"„	CASE 63: VErr$ = "Bad record number"„	CASE 64: VErr$ = "Invalid filename"„	CASE 67: VErr$ = "Too many files"„	CASE 68: VErr$ = "Drive/Device Unavailable"„	CASE 69: VErr$ = "Comm buffer overflow"„	CASE 70: VErr$ = "Permission denied"„	CASE 71: VErr$ = "Disk/Printer not ready"„	CASE 72: VErr$ = "Disk media error"„	CASE 73: VErr$ = "Feature not available"„	CASE 74: VErr$ = "Rename across disks"„	CASE 75: VErr$ = "Path/File access error"„	CASE 76: VErr$ = "Path not found"„	CASE 255: VErr$ = "Invalid command line parameter"„„	CASE ELSE: VErr$ = "UNIDENTIFIED ERROR"„END SELECT„VErr$ = VErr$ + "!"„END SUB„Brian Mahocker                 ADD COMMAS TO LARGE NUMBERS    Kain121182@aol.com             07-03-97 (12:01)       QB, QBasic, PDS        17   532      COMMAS.BAS  DECLARE SUB AddCommas (InputS$, OutPutS$)„'AddComma By Brian Mahocker„'what this does, is add commas to a string of numbers. you can put letter in„'it, but then it will look funny :). use and distribute this freely!!„„LET as$ = "123342673568256613512"„AddCommas as$, ou$„PRINT ou$„„SUB AddCommas (InputS$, OutPutS$)„WHILE LEN(InputS$) > 3„   LET CurStr$ = RIGHT$(InputS$, 3)„   LET InputS$ = LEFT$(InputS$, LEN(InputS$) - 3)„   LET OutPutS$ = "," + CurStr$ + OutPutS$„WEND„LET OutPutS$ = InputS$ + OutPutS$„END SUB„Tika Carr                      RECOMMENT YOUR SOURCE CODES    t.carr@pobox.com               07-05-97 (15:34)       QB, PDS                263  9163     RECOM11.BAS '                      ******* ReCom 1.1 *******„'„'ReCom 1.1: Utility to recomment source files„'March 4, 1997, July 1, 1997 by Tika Carr (some code by Joe Negron)„'„'No warranties or guarantees are expressed or implied. Free for your own„'use & modification, just give the author(s) proper credit.„'„'NOTES: This Source will work only in QuickBasic 4.5.„'       Start with QB /L QB.QLB„'„'Recomments C/C++/ASM/BASIC Headers and Source Files, as well as GW-BASIC,„'*.SYS (ie. CONFIG.SYS), BATch and Windows INI files. Example: You want„'to comment each line of a C program so you can load it into QuickBasic and„'work on each line to convert it to QuickBasic. You would do this:„'„'                    recom /qs hello.c„'„'This says to take the file hello.c and recomment each line with a ' and„'have the output file named hello.bas. The original source is supposed to„'be (and usually is) left untouched (unless some unforseen error I refuse„'to be held responsible for happens).„'„'History & Credits:„'„'1.0„'   I lost the original source code to this one and it didn't have any file„'   checking capabilities.„'1.1„'   I rewrote this from memory (not the computer's :) and I think I added„'   some more user error checking and file checking (can't recomment a C„'   file to a C Source file, for example). Thanks goes to Joe Negron who wrote „'   the Exist code (checks to see if a file exists). „'„'QUIRKS in the source/operation:„'  /g, /b, /i, /s: if you pass another letter with it (ie. /gh) then the„'  file is processed and the second letter ignored. However, due to some„'  parameter checking, you will get a help screen and no conversion if„'  you pass a /ss (since both the Lang$ and Source$ are the same). Some may„'  prefer to fix this quirk. I didn't think it would be a problem though„'  as you're really only supposed to use the one letter anyway. :)„'„'  If you are converting an ANSI C source to an ANSI C header, no conversion„'  is made. Basically, it just copies the file to another *.H file. I„'  figured for that, you might not even use this utility, just rename or„'  copy the source. It would take more code to parse out comments in the„'  C Source and adjust while commenting the header. Something I'm not up„'  to but if anyone else would like to add it in, feel free to do so.„'„'USAGE: recom /switch infile.ext„'„'infile.ext is the filename and extension of the source code file you want„'to convert. The output file is determined by the use of one of the„'following switches (only one switch can be used):„'„'/qx  QBasic/QuickBasic 4.5„'/cx  ANSI C„'/px  C++„'/ax  Assembly Language„'/g   GWBASIC„'/b   Batch File (.BAT)„'/i   .INI File„'/s   .SYS File„'„'NOTE: x must be either an 's' (for source) or 'h' (for header)„'„'Here's a chart of what can be converted:„'(Note that QB stands for QuickBasic 4.5 or QBasic 1.1)„'„'Destination File      Switch Used„'QB *.BAS              /qs„'QB *.BI               /qh„'ANSI C *.c            /cs„'ANSI C *.h            /ch„'C++ *.CPP             /ps„'C++ Header *.H        /ph„'Assembly *.ASM        /as„'Assebmly *.INC        /ah„'GW-BASIC  *.BAS       /g„'Batch File *.BAT      /b„'Windows *.INI         /i„'CONFIG.SYS (or *.sys) /s„'„'DISCLAIMER:„'ReCom 1.1 is distributed on an "AS IS" basis. The author(s) disclaim all„'warranties, expressed or implied, including but not limited to the„'warranties of merchantability and of fitness for any purpose. The author(s) „'assume no liability for damages, direct or consequential, which may„'result from use of this program or any accompanying source(s).„„DEFINT A-Z„„'$INCLUDE: 'qb.bi'„„DECLARE FUNCTION Exist% (FileName$)„DECLARE SUB Help ()„„DIM arg$(1 TO 85)„„'Program ID„PRINT„PRINT "ReCom 1.1: Utility to recomment your source files"„PRINT "March 4, 1997, July 1, 1997 by Tika Carr"„PRINT„„'Get Paramters:„„IF COMMAND$ <> "" THEN„    I = 1: j = 1„    DO UNTIL I >= LEN(COMMAND$)„        WHILE MID$(COMMAND$, I, 1) <> " " AND MID$(COMMAND$, I, 1) <> ""„            arg$(j) = arg$(j) + MID$(COMMAND$, I, 1)„            I = I + 1„        WEND„        I = I + 1: j = j + 1„    LOOP„END IF„„'Check Paramters„IF arg$(1) = "" THEN Help       ' No paramters found„IF INSTR("/-", LEFT$(arg$(1), 1)) = 0 THEN„    Help  'First parameter a switch?„ELSE    'Parse Parameter„    Lang$ = MID$(arg$(1), 2, 1)„    Source$ = RIGHT$(arg$(1), 1)„    IF Lang$ = Source$ AND LEN(arg$(1)) > 2 THEN Help   ' Bad format„    IF INSTR("QCPA", Lang$) = 0 THEN Source$ = "" 'One-letter switch„END IF„„'Check Filename„IF Exist(arg$(2)) >= 0 THEN PRINT arg$(2); " not found.": Help„„'All tests pass. Figure new filename based on Lang$ and arg$(2)„„'Check for a "." and if there, chop off extension„I = INSTR(arg$(2), ".")„IF I THEN„    OutFile$ = LEFT$(arg$(2), I)„ELSE„    OutFile$ = arg$(2) + "."„END IF„'Check filename size (8-char filename plus ".")„IF LEN(OutFile$) > 9 THEN Help„„'Check Lang$ and add extension, and set up comment string„„'QBasic/QuickBasic 4.5/GWBASIC„IF INSTR("QGCPABIS", Lang$) = 0 THEN Help     ' Wrong Language Parameter„IF INSTR("QG", Lang$) THEN„    ' No Header/Source Specified„    IF Lang$ = "Q" AND INSTR("SH", Source$) = 0 OR LEN(Source$) = 0 AND Lang$ <> "G" THEN Help„    IF Source$ = "H" THEN OutFile$ = OutFile$ + "BI" ELSE OutFile$ = OutFile$ + "BAS"„END IF„IF Lang$ = "Q" THEN„    Comment$ = "'"„ELSEIF Lang$ = "G" THEN Comment$ = "REM"„END IF„„'C/C++ Header/Source„'Note that a * is used for ANSI C and will be fixed as needed for /**/_„' later.„IF INSTR("CP", Lang$) THEN„    ' No Header/Source specified„    IF INSTR("SH", Source$) = 0 OR LEN(Source$) = 0 THEN Help„    IF Source$ = "H" THEN„        IF Lang$ = "P" THEN Comment$ = "//" ELSE Comment$ = "*"„        OutFile$ = OutFile$ + "H"„    ELSE„        IF Lang$ = "C" THEN„            OutFile$ = OutFile$ + "C": Comment$ = "*"„        ELSE OutFile$ = OutFile$ + "CPP": Comment$ = "//"„        END IF„    END IF„END IF„„'Assembly Language„IF Lang$ = "A" THEN„    ' No Header/Source specified„    IF INSTR("SH", Source$) = 0 OR LEN(Source$) = 0 THEN Help„    Comment$ = "#"„    IF Source$ = "H" THEN„        OutFile$ = OutFile$ + "INC"„    ELSE OutFile$ = OutFile$ + "ASM"„    END IF„END IF„„IF Lang$ = "B" THEN OutFile$ = OutFile$ + "BAT": Comment$ = "REM" 'BAT File„IF Lang$ = "I" THEN OutFile$ = OutFile$ + "INI": Comment$ = ";"   'INI File„IF Lang$ = "S" THEN OutFile$ = OutFile$ + "SYS": Comment$ = "REM" 'SYS File„„'Check to be sure input and output files are not the same„IF arg$(2) = OutFile$ THEN„    PRINT "*** ERROR ***"„    PRINT "Switch used was: "; arg$(1)„    PRINT "Input File to operate on is: "; arg$(2)„    PRINT "File conversion was to be output to: "; OutFile$„    PRINT "Cannot write to input file!": PRINT„    Help„END IF„„'All set, now open files„OPEN arg$(2) FOR INPUT AS #1: OPEN OutFile$ FOR OUTPUT AS #2„„    ' Parse sources and comment accordingly„    I = 0: y = CSRLIN„    WHILE NOT EOF(1)„        LINE INPUT #1, a$„        'Show line # being worked on:„        LOCATE y, 1: PRINT STRING$(79, 32);„        LOCATE y, 1: PRINT "Processing Line #"; I; : I = I + 1„        ' Neater source listing, parses out blank lines/comments„        IF LEN(a$) > 1 THEN„            IF Lang$ = "C" THEN„                'If its to be a header file, then no commenting is needed.„                IF Source$ = "H" THEN PRINT #2, a$ ELSE PRINT #2, "/* "+ a$ + " */"„            ELSE PRINT #2, Comment$ + " " + a$„            END IF„        ELSE PRINT #2, ""„        END IF„    WEND„CLOSE„LOCATE y, 1: PRINT STRING$(79, 32): LOCATE y, 1: PRINT "Done."„„'***********************************************************************„'* FUNCTION Exist%„'*„'* PURPOSE„'*    Uses DOS ISR 21H, Function 4EH (Find First Matching Directory„'*    Entry) to determine the existence of FileName$.„'***********************************************************************„FUNCTION Exist% (FileName$) STATIC„     DIM IRegsX AS RegTypeX, ORegsX AS RegTypeX„„     IRegsX.ax = &H4E00„     IRegsX.cx = &H3F                          'search for all files„     FileName$ = FileName$ + CHR$(0)           'must end with null byte„„     IRegsX.ds = VARSEG(FileName$)             'load DS:DX with„     IRegsX.dx = SADD(FileName$)               '  address of FileName$„„     INTERRUPTX &H21, IRegsX, ORegsX„     Exist% = ORegsX.ax = 0                    'if ax contains a value,„                                               '  remove the null byte„     FileName$ = LEFT$(FileName$, LEN(FileName$) - 1)„END FUNCTION„„SUB Help„PRINT "USAGE: recom /switch infile.ext"„PRINT„PRINT "These switches determine the output file and filename:"„PRINT "/qx  QBasic/QuickBasic 4.5"„PRINT "/cx  ANSI C"„PRINT "/px  C++"„PRINT "/ax  Assembly Language"„PRINT "/g   GWBASIC"„PRINT "/b   Batch File (.BAT)"„PRINT "/i   .INI File"„PRINT "/s   .SYS File"„PRINT„PRINT "NOTE: x must be either an 's' (for source) or 'h' (for header)"„PRINT„END„END SUB„Michael G. Stewart             ARROWHEAD CO. ADDRESS BOOK     mikegs@juno.com                07-19-97 (14:43)       QB, QBasic, PDS        389  8386     ADDRESS.BAS DECLARE SUB edits ()„DECLARE SUB views ()„DECLARE FUNCTION incen$ (row%, text$)„DECLARE SUB enters ()„DECLARE SUB drawformat ()„DECLARE SUB center (row%, text$)„DECLARE SUB intro ()„DECLARE SUB mainmenu ()„DECLARE SUB coolbox ()„DECLARE FUNCTION key$ ()„DECLARE SUB opens ()„DECLARE SUB new ()„CONST true = 1„CONST false = NOT true„TYPE newfile„ person AS STRING * 7„ names AS INTEGER„ adds AS INTEGER„ csz AS INTEGER„ phone AS INTEGER„ mail AS INTEGER„END TYPE„TYPE info„ names AS STRING * 36„ address AS STRING * 30„ city AS STRING * 10„ state AS STRING * 2„ zip AS STRING * 10„ phonearea AS STRING * 3„ phonepre AS STRING * 3„ phonesuf AS STRING * 4„ phoneext AS STRING * 4„ mail AS STRING * 36„END TYPE„DIM SHARED options AS newfile„DIM SHARED form AS info„intro„mainmenu„„SUB center (row%, text$)„LOCATE row%, 41 - (LEN(text$) / 2)„PRINT text$„END SUB„„SUB coolbox„LOCATE 1„PRINT "    €"; STRING$(70, "ﬂ"); "€"„PRINT "  €ﬂ€"; STRING$(70, "ﬂ"); "€ﬂ€"„PRINT "€ﬂ€ﬂﬂ"; SPACE$(70); "ﬂﬂ€ﬂ€"„FOR a% = 4 TO 20„ LOCATE a%, 1: PRINT "€ €"; SPACE$(74); "€ €"„NEXT a%„PRINT "€‹€‹‹"; SPACE$(70); "‹‹€‹€"„PRINT "  €‹€"; STRING$(70, "‹"); "€‹€"„PRINT "    €"; STRING$(70, "‹"); "€"„END SUB„„SUB drawformat„title$ = "Address Book For " + options.person„center 4, title$„IF options.names = true THEN„ LOCATE 6, 20„ PRINT "Name: ____________________________________"„END IF„IF options.adds = true THEN„ LOCATE 7, 20„ PRINT "Address: _________________________________"„END IF„IF options.csz = true THEN„ LOCATE 8, 20„ PRINT "City: __________ State: __ Zip: _____-____"„END IF„IF options.phone = true THEN„ LOCATE 9, 20„ PRINT "Phone: (___) ___-____ Ext. ____"„END IF„IF options.mail = true THEN„ LOCATE 10, 20„ PRINT "E-Mail: __________________________________"„END IF„END SUB„„SUB edits„COLOR 12„coolbox„COLOR 13„OPEN "files.add" FOR RANDOM AS #1 LEN = LEN(options) * 10„a$ = incen$(4, "Your Name: ")„DO„ a% = a% + 1„ GET #1, a%, options„ IF options.person = a$ THEN EXIT DO„LOOP„COLOR 12„coolbox„CLOSE #1„filename$ = options.person + ".add"„OPEN filename$ FOR RANDOM AS #1 LEN = LEN(form) * 100„DO„ COLOR 13„ drawformat„ a$ = incen$(5, "Number To Change: ")„ a% = VAL(a$)„ COLOR 14„ IF options.names = true THEN„  LOCATE 6, 20: INPUT "Name: ", name$„  form.names = name$„ END IF„ IF options.adds = true THEN„  LOCATE 7, 20: INPUT "Address: ", address$„  form.address = address$„ END IF„ IF options.csz = true THEN„  LOCATE 8, 20: INPUT "City: ", city$„  form.city = city$„  LOCATE 8, 37: INPUT "State: ", state$„  form.state = state$„  LOCATE 8, 47: INPUT "Zip: ", zip$„  form.zip = zip$„ END IF„ IF options.phone = true THEN„  LOCATE 9, 20: INPUT "Phone: (", phone$„  form.phonearea = phone$„  LOCATE 9, 31: INPUT ") ", phone$„  form.phonepre = phone$„  LOCATE 9, 36: INPUT "-", phone$„  form.phonesuf = phone$„  LOCATE 9, 41: INPUT " Ext. ", phone$„  form.phoneext = phone$„ END IF„ IF options.mail = true THEN„  LOCATE 10, 20: INPUT "E-Mail: ", mail$„  form.mail = mail$„ END IF„ PUT #1, a%, form„ center 12, "<E>dit Another | <N>ew Entry | <M>ain Menu"„ DO„  a$ = UCASE$(key$)„  IF a$ = "E" THEN EXIT DO„  IF a$ = "N" THEN enters„  IF a$ = "M" THEN CLOSE #1: mainmenu„ LOOP„LOOP„„„END SUB„„SUB enters„COLOR 12„coolbox„COLOR 13„OPEN "files.add" FOR RANDOM AS #1 LEN = LEN(options) * 10„a$ = incen$(4, "Your Name: ")„DO„ a% = a% + 1„ GET #1, a%, options„ IF options.person = a$ THEN EXIT DO„LOOP„COLOR 12„coolbox„CLOSE #1„filename$ = options.person + ".add"„OPEN filename$ FOR RANDOM AS #1 LEN = LEN(form) * 100„a% = 1„DO„ COLOR 13„ drawformat„ COLOR 14„ IF options.names = true THEN„  LOCATE 6, 20: INPUT "Name: ", name$„  form.names = name$„ END IF„ IF options.adds = true THEN„  LOCATE 7, 20: INPUT "Address: ", address$„  form.address = address$„ END IF„ IF options.csz = true THEN„  LOCATE 8, 20: INPUT "City: ", city$„  form.city = city$„  LOCATE 8, 37: INPUT "State: ", state$„  form.state = state$„  LOCATE 8, 47: INPUT "Zip: ", zip$„  form.zip = zip$„ END IF„ IF options.phone = true THEN„  LOCATE 9, 20: INPUT "Phone: (", phone$„  form.phonearea = phone$„  LOCATE 9, 31: INPUT ") ", phone$„  form.phonepre = phone$„  LOCATE 9, 36: INPUT "-", phone$„  form.phonesuf = phone$„  LOCATE 9, 41: INPUT " Ext. ", phone$„  form.phoneext = phone$„ END IF„ IF options.mail = true THEN„  LOCATE 10, 20: INPUT "E-Mail: ", mail$„  form.mail = mail$„ END IF„ PUT #1, a%, form„ a% = a% + 1„ center 12, "<N>ew Entry | <E>dit Entry | <M>ain Menu"„ DO„  a$ = UCASE$(key$)„  IF a$ = "N" THEN EXIT DO„  IF a$ = "E" THEN edits„  IF a$ = "M" THEN CLOSE #1: mainmenu„ LOOP„LOOP„END SUB„„FUNCTION incen$ (row%, text$)„LOCATE row%, 41 - ((LEN(text$) + 5) / 2)„PRINT text$;„INPUT "", temp$„incen$ = temp$„END FUNCTION„„SUB intro„CLS„COLOR 1„coolbox„COLOR 2„center 5, "Arrowhead Corporation's"„COLOR 3„center 7, "‹‹‹‹‹ ‹‹‹‹  ‹‹‹‹  ‹‹‹‹  ‹‹‹‹‹  ‹‹‹‹  ‹‹‹‹"„center 8, "€   € €   € €   € €   € €     €     €    "„center 9, "€ﬂﬂﬂ€ €   € €   € €€ﬂﬂ  €ﬂﬂﬂ   ﬂﬂﬂ‹  ﬂﬂﬂ‹"„center 10, "€   € €   € €   € € ﬂ‹  €         €     €"„center 11, "ﬂ   ﬂ ﬂﬂﬂﬂ  ﬂﬂﬂﬂ  ﬂ   ﬂ ﬂﬂﬂﬂﬂ ﬂﬂﬂﬂ  ﬂﬂﬂﬂ "„center 13, "‹‹‹‹   ‹‹‹   ‹‹‹  ‹   ‹"„center 14, "€   € €   € €   € € ‹ﬂ "„center 15, "€ﬂﬂﬂ‹ €   € €   € €€   "„center 16, "€   € €   € €   € € ﬂ‹ "„center 17, "ﬂﬂﬂﬂ   ﬂﬂﬂ   ﬂﬂﬂ  ﬂ   ﬂ"„COLOR 20„center 19, "Press Any Key"„DO WHILE INKEY$ = "": LOOP„END SUB„„FUNCTION key$„DO„ kbd$ = ""„ kbd$ = INKEY$„ IF kbd$ <> "" THEN EXIT DO„LOOP„key$ = kbd$„END FUNCTION„„SUB mainmenu„COLOR 5„coolbox„COLOR 6„center 4, "MAIN MENU"„center 5, "-------------"„COLOR 7„center 6, "<N>ew "„center 7, "<O>pen"„center 8, "<Q>uit"„DO„ a$ = UCASE$(key$)„ IF a$ = "N" THEN new„ IF a$ = "O" THEN opens„ IF a$ = "Q" THEN COLOR 8: coolbox: center 12, "Copyright (C) 1997, Arowhead Corporation": SYSTEM„ BEEP„LOOP„END SUB„„SUB new„COLOR 8„coolbox„COLOR 9„center 4, "New Address Book"„center 5, "--------------------"„COLOR 10„person$ = incen$(6, "Your Name: ")„options.person = person$„name$ = LCASE$(incen$(7, "Name Line? [y,n] "))„IF name$ = "y" THEN„ options.names = true„ELSE„ options.names = false„END IF„add$ = LCASE$(incen$(8, "Address Line? [y,n] "))„IF add$ = "y" THEN„ options.adds = true„ELSE„ options.adds = false„END IF„ctstzp$ = LCASE$(incen$(9, "City,State,Zip Line? [y,n] "))„IF ctstzp$ = "y" THEN„ options.csz = true„ELSE„ options.csz = false„END IF„phone$ = LCASE$(incen$(10, "Phone Line? [y,n] "))„IF phone$ = "y" THEN„ options.phone = true„ELSE„ options.phone = false„END IF„mail$ = LCASE$(incen$(11, "E-Mail Line? [y,n] "))„IF mail$ = "y" THEN„ options.mail = true„ELSE„ options.mail = false„END IF„OPEN "files.add" FOR RANDOM AS #1 LEN = LEN(options) * 10„DO„ a% = a% + 1„ GET #1, a%, a$„ IF a$ = "" THEN EXIT DO„LOOP„PUT #1, a%, options„CLOSE #1„COLOR 11„coolbox„COLOR 12„center 12, "File Created!"„center 13, "Press Any Key To Begin Entering People"„a$ = key$„enters„„END SUB„„SUB opens„COLOR 12„coolbox„COLOR 13„OPEN "files.add" FOR RANDOM AS #1 LEN = LEN(options) * 10„a$ = incen$(4, "Your Name: ")„DO„ a% = a% + 1„ GET #1, a%, options„ IF options.person = a$ THEN EXIT DO„LOOP„COLOR 12„coolbox„CLOSE #1„filename$ = options.person + ".add"„OPEN filename$ FOR RANDOM AS #1 LEN = LEN(form) * 100„a% = 1„DO„ GET #1, a%, form„ COLOR 13„ drawformat„ COLOR 14„ IF options.names = true THEN„  LOCATE 6, 26„  PRINT form.names„ END IF„ IF options.adds = true THEN„  LOCATE 7, 29„  PRINT form.address„ END IF„ IF options.csz = true THEN„  LOCATE 8, 26„  PRINT form.city„  LOCATE 8, 44„  PRINT form.state„  LOCATE 8, 52„  PRINT form.zip„ END IF„ IF options.phone = true THEN„  LOCATE 9, 28„  PRINT form.phonearea„  LOCATE 9, 33„  PRINT form.phonepre„  LOCATE 9, 37„  PRINT form.phonesuf„  LOCATE 9, 47„  PRINT form.phoneext„ END IF„ IF options.mail = true THEN„  LOCATE 10, 28„  PRINT form.mail„ END IF„ center 12, "<N>ext Entry | <P>revious Entry | <M>ain Menu"„ DO„  a$ = UCASE$(key$)„  IF a$ = "N" THEN a% = a% + 1: EXIT DO„  IF a$ = "P" THEN„   a% = a% - 1„   IF a% = 0 THEN a% = 1„   EXIT DO„  END IF„  IF a$ = "M" THEN CLOSE #1: mainmenu„ LOOP„LOOP„END SUB„Sami Kyostila                  PACK/UNPACK V1.0               hiteck@mail.freenet.hut.fi     09-12-97 (12:55)       QB, QBasic, PDS        731  20248    PACK.BAS    '----------------------------------------------------------------------------„'               Pack/UnPack v1.0 by Sami KyîstilÑ - 1997„'----------------------------------------------------------------------------„'        You may use this program freely, but give me some credit„'  I take no responsibility for any possible damage this program may cause.„'----------------------------------------------------------------------------„'„' Here is a useful program that archives files into a single file, so you„' don't have to mess with hundreds of data files. It can run in "NoPrint"-„' mode, so you can use it in your programs without the user noticing anything.„'„' A single archive can hold a maximum of 999 files, each one up to„' 999,999,999,999 bytes in size. See sub Pack for the archive structure„' description.„'„' Use FUNCTION Pack to add files to an archive/create new archive and FUNCTION„' UnPack to extract files from archives. Extracting each file everytime„' you need it in your programs can be very slow, so I've included FUNCTION„' PackOffset, which returns the start byte offset of a file in an archive,„' so you can read the file directly from the archive without having to„' extract it first.„'----------------------------------------------------------------------------„„„„DECLARE FUNCTION FixFileName$ (File$, Extension$)„DEFINT A-Z„DECLARE FUNCTION PackList% (Archive$)„DECLARE FUNCTION PackOffset! (Archive$, Filename$, Length!)„DECLARE FUNCTION Pack (Archive$, Filename$, NoPrint)„DECLARE FUNCTION Unpack (Archive$, Filename$, NoPrint)„DECLARE FUNCTION Exist% (File$)„„„„CLS„COLOR 8„PRINT STRING$(80, CHR$(196))„COLOR 10„PRINT "                   Pack/UnPack v1.0 by Sami KyîstilÑ - 1997"„COLOR 8„PRINT STRING$(80, CHR$(196))„PRINT "          You may use this program freely, but give me some credit"„COLOR 12„PRINT "  I take no responsibility for any possible damage this program may cause."„COLOR 8„PRINT STRING$(80, CHR$(196))„PRINT„COLOR 7„PRINT " Here is a useful program that archives files into a single file, so you"„PRINT " don't have to mess with hundreds of data files. It can run in NoPrint-"„PRINT " mode, so you can use it in your programs without the user noticing anything."„PRINT„PRINT " A single archive can hold a maximum of";„COLOR 14: PRINT 999; : COLOR 7„PRINT "files, each one up to";„COLOR 14: PRINT " 999,999,999,999 ";„COLOR 7„PRINT "bytes in size. See sub Pack for the archive structure"„PRINT " description."„PRINT„PRINT " Use ";„COLOR 14„PRINT "FUNCTION Pack";„COLOR 7„PRINT " to add files to an archive/create new archive and";„COLOR 14„PRINT " FUNCTION"„PRINT " UnPack ";„COLOR 7„PRINT "to extract files from archives. Extracting each file everytime"„PRINT " you need it in your programs can be very slow, so I've included ";„COLOR 14„PRINT "FUNCTION"„PRINT " PackOffset";„COLOR 7„PRINT ", which returns the start byte offset of a file in an archive,"„PRINT " so you can read the file directly from the archive without having to"„PRINT " extract it first."„PRINT„COLOR 9„PRINT "                                         Press any key to continue"„DO: LOOP UNTIL INKEY$ <> ""„CLS„COLOR 7„PRINT " Enter a temporary archive filename to be used in this demo:"„PRINT " If the file exists, it will be overwritten. The default extension"„PRINT " is .PAK"„PRINT„COLOR 14„INPUT "> ", Archive$„IF LTRIM$(RTRIM$(Archive$)) = "" THEN END„LOCATE 5, 3„PRINT FixFileName$(Archive$, "PAK")„COLOR 7„„PRINT„PRINT " Enter an existing filename to be used in this demo:"„PRINT " The file can be a binary or a plain ASCII one."„PRINT„PRINT„COLOR 14„INPUT "> ", File1$„IF LTRIM$(RTRIM$(File1$)) = "" THEN END„COLOR 7„„PRINT„PRINT " Enter a second existing filename to be used in this demo:"„PRINT " The file can be a binary or a plain ASCII one."„PRINT„COLOR 14„INPUT "> ", File2$„IF LTRIM$(RTRIM$(File2$)) = "" THEN END„COLOR 7„„„„ON ERROR GOTO OhGreat„„CONST True = 1„CONST False = NOT True„„TYPE PakHeader„  Version AS STRING * 5             'Version„  Total AS STRING * 3               'Total files in archive„END TYPE„„DIM SHARED CurrentVersion AS STRING * 5„CurrentVersion = "Pak10"            'Current version signature„„„IF Exist(Archive$) = True THEN KILL Archive$„„ErrorFlag = Pack(Archive$, File1$, 0)               'Add file 1 to archive„IF ErrorFlag <> 0 THEN PRINT " Error"; ErrorFlag: END„„ErrorFlag = Pack(Archive$, File2$, 0)               'Add file 2 to archive„IF ErrorFlag <> 0 THEN PRINT " Error"; ErrorFlag: END„„ErrorFlag = PackList(Archive$)                      'View contents„IF ErrorFlag <> 0 THEN PRINT " Error"; ErrorFlag: END„SLEEP„„ErrorFlag = Unpack(Archive$, "*", 0)                'Extract both files„IF ErrorFlag <> 0 THEN PRINT " Error"; ErrorFlag: END„„IF Exist(Archive$) = True THEN KILL Archive$„„„END„„„OhGreat:„CLS„PRINT " - Error number";„COLOR 14„PRINT ERR;„COLOR 7„PRINT "has occured."„PRINT "   Program execution";„COLOR 14„PRINT " aborted."„END„„FUNCTION Exist% (File$)„'----------------------------------------------------------------------------„'                  Checks if a file exists - Sami KyîstilÑ 1997„'----------------------------------------------------------------------------„'„'    File$ - File to check„'„'----------------------------------------------------------------------------„'  Returns True if file exists, else False„'----------------------------------------------------------------------------„„„IF File$ = "" THEN Exist = False: EXIT FUNCTION„Checkfile = FREEFILE„OPEN File$ FOR BINARY AS #Checkfile„IF LOF(Checkfile) = 0 THEN„  Exist = False„  CLOSE #Checkfile„  KILL File$„ELSE„  Exist = True„  CLOSE #Checkfile„END IF„„END FUNCTION„„FUNCTION FixFileName$ (File$, Extension$)„'----------------------------------------------------------------------------„'                  Fixes the filename extension„'----------------------------------------------------------------------------„'„'      File$ - Filename„' Extension$ - Extension„'„'----------------------------------------------------------------------------„'„' If File$'s extension is different than Extension$, then it will be changed„'„' Example:„'„'   File$ = "c:\temp\temp.abc"„'   Extension$ = "exe"„'   Returns: "c:\temp\temp.exe"„'„'----------------------------------------------------------------------------„„„„IF INSTR(File$, ".") > 0 AND INSTR(File$, ".") < LEN(File$) THEN„  IF RIGHT$(UCASE$(File$), LEN(Extension$)) <> UCASE$(Extension$) THEN„    File$ = LEFT$(File$, INSTR(File$, ".")) + Extension$„  END IF„ELSEIF INSTR(File$, ".") = LEN(File$) THEN„  File$ = File$ + Extension$„ELSE„  File$ = File$ + "." + Extension$„END IF„„FixFileName$ = File$„„END FUNCTION„„FUNCTION Pack (Archive$, Filename$, NoPrint)„'----------------------------------------------------------------------------„'   Packs files into an archive, binary or plain text - Sami KyîstilÑ 1997„'----------------------------------------------------------------------------„'„'  Archive$ - Filename of the archive, if the archive exists, then it will„'             be appended. (Max number of files in an archive is 999)„' Filename$ - File to be added to archive. May include a path, but it will„'             be stored without the path. (Max file size 999,999,999,999„'             bytes, should be enough :)„'   NoPrint - If 1, then no text will be printed„'„'----------------------------------------------------------------------------„'                        Returned error codes„'----------------------------------------------------------------------------„'„' 1 = Input file not found„' 2 = Input file is already in archive„'„'----------------------------------------------------------------------------„'                           Archive structure„'----------------------------------------------------------------------------„'„' Header:„'„'   Version (5 bytes)                    - "Pak10"„'   Number of files in archive (3 bytes) - "001"„'„' Data:„'„'   Filename (12 bytes)                  - "MYFILE.EXE  "„'   File size (12 bytes)                 - "000000001234"„'   ...„'   Data area (length indicated above)„'   ...„'„' Next file data (header not repeated)„'„'----------------------------------------------------------------------------„„„DIM Buffer AS STRING * 1000„BufferSize = LEN(Buffer)„„DIM byte AS STRING * 1„DIM Pak AS PakHeader„„„IF NoPrint = 0 THEN„  CLS„  COLOR 8„  PRINT STRING$(80, CHR$(196))„  COLOR 7„  PRINT "                 Pack/UnPack Freeware by ";„  COLOR 15„  PRINT "Sami KyîstilÑ ";„  COLOR 7„  PRINT "- 1997"„  PRINT "                        Version signature: ";„  COLOR 14„  PRINT CurrentVersion„  COLOR 4„  PRINT "             Use this program as you wish, but give me some credit."„  COLOR 8„  PRINT STRING$(80, CHR$(196))„  COLOR 7„  PRINT„END IF„„IF Exist(Filename$) = False THEN Pack = 1: EXIT FUNCTION„IF Exist(Archive$) = False THEN„  new = 1„  f1 = FREEFILE„  OPEN Archive$ FOR BINARY AS #f1„  PUT #f1, 1, CurrentVersion„  Dummy$ = "000"„  PUT #f1, , Dummy$„  CLOSE #f1„  new = 1„ELSE„  new = 0„END IF„„„f1 = FREEFILE„OPEN Archive$ FOR BINARY AS #f1„f2 = FREEFILE„OPEN Filename$ FOR BINARY AS #f2„Row = CSRLIN + 1„„FOR i = LEN(Filename$) TO 1 STEP -1„  IF MID$(Filename$, i, 1) = "\" THEN Filename$ = MID$(Filename$, i + 1, 255)„NEXT„Filename$ = UCASE$(Filename$)„„„  IF NoPrint = 0 THEN„    IF new = 0 THEN PRINT " "; CHR$(254); " Appending to archive "; Archive$; " at position"; : COLOR 14: PRINT ; LOF(f1): COLOR 7„    IF new = 1 THEN PRINT " "; CHR$(254); " Creating archive "; Archive$: COLOR 7„  END IF„„  IF PackOffset(Archive$, Filename$, -1) <> -1 THEN„    IF NoPrint = 0 THEN PRINT " "; CHR$(254); " "; Filename$; " is already in archive "; Archive$„    Pack = 2„    CLOSE #f1„    CLOSE #f2„    EXIT FUNCTION„  END IF„„  GET #f1, 1, Pak„  TotalFiles = VAL(Pak.Total)„  TotalFiles = TotalFiles + 1„  Total$ = STRING$(3 - LEN(LTRIM$(RTRIM$(STR$(TotalFiles)))), "0") + LTRIM$(RTRIM$(STR$(TotalFiles)))„„  IF NoPrint = 0 THEN PRINT "   Adding "; Filename$; "...";„„  PUT #f1, 6, Total$„„  Length$ = STRING$(12 - LEN(LTRIM$(RTRIM$(STR$(LOF(f2))))), "0") + LTRIM$(RTRIM$(STR$(LOF(f2))))„  File2$ = Filename$ + STRING$(12 - LEN(Filename$), " ")„„  CLOSE f1„  OPEN Archive$ FOR BINARY AS #f1„„  SEEK #f1, LOF(f1)„„  PUT #f1, SEEK(f1) + 1, File2$„  PUT #f1, , Length$„  PPos = POS(0)„  COLOR 14„„  FOR i! = 1 TO LOF(f2) STEP BufferSize„    GET #f2, , Buffer„    Clip! = LOF(f2) + 1 - i!„    IF Clip! <= BufferSize THEN„      Buffer2$ = LEFT$(Buffer, LOF(f2) + 1 - i!)„      PUT #f1, , Buffer2$„    ELSE„      PUT #f1, , Buffer„    END IF„    IF NoPrint = 0 THEN„      IF i! \ BufferSize MOD 50 = 0 THEN LOCATE Row, PPos: PRINT LTRIM$(RTRIM$(STR$(INT((i! / LOF(f2)) * 100)))); "%"„    END IF„  NEXT„„„  IF NoPrint = 0 THEN LOCATE Row, PPos: COLOR 14: PRINT LTRIM$(STR$(LOF(f2))); : COLOR 7: PRINT " bytes"„  CLOSE #f1„  CLOSE #f2„„END FUNCTION„„FUNCTION PackList (Archive$)„'----------------------------------------------------------------------------„'              List contents of an archive - Sami KyîstilÑ 1997„'----------------------------------------------------------------------------„'„' Archive$ - The archive to be scanned„'„'----------------------------------------------------------------------------„'                        Returned error codes„'----------------------------------------------------------------------------„'„' 1 - Archive not found„'„'----------------------------------------------------------------------------„„DIM Pak AS PakHeader„„„CLS„COLOR 8„PRINT STRING$(80, CHR$(196))„COLOR 7„PRINT "                 Pack/UnPack Freeware by ";„COLOR 15„PRINT "Sami KyîstilÑ ";„COLOR 7„PRINT "- 1997"„PRINT "                        Version signature: ";„COLOR 14„PRINT CurrentVersion„COLOR 4„PRINT "             Use this program as you wish, but give me some credit."„COLOR 8„PRINT STRING$(80, CHR$(196))„COLOR 7„PRINT„„IF Exist(Archive$) = False THEN PackList = 1: EXIT FUNCTION„f1 = FREEFILE„OPEN Archive$ FOR BINARY AS #f1„DIM byte AS STRING * 1„„„GET #f1, 1, Pak„„DIM File AS STRING * 12„DIM FileLen AS STRING * 12„„„offset! = 9„CFile = 1„„IF NoPrint = 0 THEN„  PRINT " - Archive version signature: ",„  COLOR 14„  PRINT Pak.Version„  COLOR 7„  PRINT " - Total files in archive: ", ,„  COLOR 14„  PRINT VAL(Pak.Total)„  COLOR 7„  PRINT " - Archive size:",„  COLOR 14„  PRINT USING " ###,###,###,###,###"; LOF(f1);„  PRINT " bytes"„  COLOR 7„  PRINT " "; CHR$(254); " Contents of archive "; Archive$„END IF„„COLOR 9„PRINT "   File          Length       Start         End"„COLOR 7„„DO„  GET #f1, , File„  GET #f1, , FileLen„  offset! = offset! + 24„„  PRINT "   "; File; CHR$(179); VAL(FileLen), ; CHR$(179); SEEK(f1), ; CHR$(179); SEEK(f1) + VAL(FileLen)„„  CFile = CFile + 1„  offset! = offset! + VAL(FileLen)„  SEEK #f1, offset!„  IF CFile > VAL(Pak.Total) THEN EXIT DO„LOOP„CLOSE #f1„„END FUNCTION„„FUNCTION PackOffset! (Archive$, Filename$, Length!)„'----------------------------------------------------------------------------„' Returns the offset of a file in an archive created by Pack - Sami KyîstilÑ„' Use this to find out where a file starts in an archive, so you can read it„' without extracting it first.„'----------------------------------------------------------------------------„'„'  Archive$ - Filename of the archive„' Filename$ - Filename to search for„'    Length - Returns the length of the file„'„'----------------------------------------------------------------------------„'                           Returned error codes„'----------------------------------------------------------------------------„'„' If returns -1, then the file has not been found in the archive„'„'----------------------------------------------------------------------------„„Filename$ = UCASE$(LTRIM$(RTRIM$(Filename$)))„„IF Exist(Archive$) = False THEN EXIT FUNCTION„DIM Pak AS PakHeader„„f1 = FREEFILE„OPEN Archive$ FOR BINARY AS #f1„„DIM byte AS STRING * 1„DIM File AS STRING * 12„DIM FileLen AS STRING * 12„„GET #f1, , Pak„„offset! = 9„CFile = 1„„DO„  GET #f1, , File„  GET #f1, , FileLen„  offset! = offset! + 24„„  IF Filename$ = RTRIM$(File) THEN EXIT DO„  CFile = CFile + 1„  offset! = offset! + VAL(FileLen)„  SEEK #f1, offset!„  IF CFile > VAL(Pak.Total) THEN offset! = -1: EXIT DO„LOOP„„CLOSE #f1„„PackOffset! = offset!„Length! = VAL(FileLen)„„END FUNCTION„„FUNCTION Unpack (Archive$, Filename$, NoPrint)„'----------------------------------------------------------------------------„'   UnPacks files from an archive created by Pack - Sami KyîstilÑ 1997„'----------------------------------------------------------------------------„'„'  Archive$ - Filename of the archive„' Filename$ - File to extracted from the archive. If includes a "*", then„'             all files are extracted„'   NoPrint - If 1, then no text will be printed and if a file exists, the„'             process will be aborted automatically.„'„'----------------------------------------------------------------------------„'                        Returned error codes„'----------------------------------------------------------------------------„'„' 1 = File exists and NoPrint-mode on„' 2 = User abort„' 3 = Archive not found„'„'----------------------------------------------------------------------------„„DIM Buffer AS STRING * 1000„BufferSize = LEN(Buffer)„„„IF NoPrint = 0 THEN„  CLS„  COLOR 8„  PRINT STRING$(80, CHR$(196))„  COLOR 7„  PRINT "                 Pack/UnPack Freeware by ";„  COLOR 15„  PRINT "Sami KyîstilÑ ";„  COLOR 7„  PRINT "- 1997"„  PRINT "                        Version signature: ";„  COLOR 14„  PRINT CurrentVersion„  COLOR 4„  PRINT "             Use this program as you wish, but give me some credit."„  COLOR 8„  PRINT STRING$(80, CHR$(196))„  COLOR 7„  PRINT„END IF„„IF Exist(Archive$) = False THEN Unpack = 3: EXIT FUNCTION„f1 = FREEFILE„OPEN Archive$ FOR BINARY AS #f1„DIM byte AS STRING * 1„GlobalYes = 0„„„IF INSTR(Filename$, "*") > 0 THEN All = 1 ELSE All = 0„„DIM Pak AS PakHeader„„„GET #f1, 1, Pak„„DIM File AS STRING * 12„DIM FileLen AS STRING * 12„„„offset! = 9„CFile = 1„„IF NoPrint = 0 THEN„  PRINT " - Archive version signature: ",„  COLOR 14„  PRINT Pak.Version„  COLOR 7„  PRINT " - Total files in archive: ", ,„  COLOR 14„  PRINT VAL(Pak.Total)„  COLOR 7„  PRINT " - Archive size:",„  COLOR 14„  PRINT USING " ###,###,###,###,###"; LOF(f1);„  PRINT " bytes"„  COLOR 7„  PRINT " "; CHR$(254); " Unpacking archive "; Archive$„END IF„„„IF All = 1 THEN„  DO„    GET #f1, , File„    GET #f1, , FileLen„    offset! = offset! + 24„„    IF Exist(RTRIM$(File)) = True THEN„      IF NoPrint = 1 THEN CLOSE #f1: CLOSE #f2: Unpack = 1: EXIT FUNCTION„      COLOR 4„      PRINT "     Overwrite "; RTRIM$(File); "? [Yes/No/All/Quit] ";„      COLOR 12„      IF GlobalYes = 1 THEN PRINT "Yes": GOTO ProcessFile„Again:„      k$ = UCASE$(INPUT$(1))„      IF k$ <> "Y" AND k$ <> "N" AND k$ <> "Q" AND k$ <> "A" THEN GOTO Again„      IF k$ = "Q" THEN PRINT "Quit": CLOSE #f1: CLOSE #f2: Unpack = 2: EXIT FUNCTION„      IF k$ = "A" THEN PRINT "Yes": GlobalYes = 1: KILL RTRIM$(File)„      IF k$ = "Y" THEN PRINT "Yes": KILL RTRIM$(File)„      IF k$ = "N" THEN PRINT "No": GOTO NextFile„    END IF„„ProcessFile:„    Row = CSRLIN„    f2 = FREEFILE„    OPEN RTRIM$(File) FOR BINARY AS #f2„    „    IF NoPrint = 0 THEN„      LOCATE Row, 1„      COLOR 7„      PRINT "   "; CHR$(250); " Extracting file "; RTRIM$(File); "...";„    END IF„„    PPos = POS(0)„    COLOR 14„„    FOR i! = 1 TO VAL(FileLen) STEP BufferSize„      GET #f1, , Buffer„      Clip! = VAL(FileLen) + 1 - i!„      IF Clip! <= BufferSize THEN„        Buffer2$ = LEFT$(Buffer, VAL(FileLen) + 1 - i!)„        PUT #f2, , Buffer2$„      ELSE„        PUT #f2, , Buffer„      END IF„      IF NoPrint = 0 THEN„        IF i! \ BufferSize MOD 50 = 0 THEN LOCATE Row, PPos: PRINT LTRIM$(RTRIM$(STR$(INT((i! / VAL(FileLen)) * 100)))); "%"„      END IF„    NEXT„„    CLOSE f2„„    IF NoPrint = 0 THEN„      COLOR 14„      LOCATE Row, PPos„      PRINT VAL(FileLen);„      COLOR 7„      PRINT "bytes"„    END IF„„NextFile:„    CFile = CFile + 1„    offset! = offset! + VAL(FileLen)„    SEEK #f1, offset!„    IF CFile > VAL(Pak.Total) THEN EXIT DO„  LOOP„ELSE„  File = UCASE$(Filename$)„  IF Exist(RTRIM$(File)) = True THEN„    IF NoPrint = 1 THEN CLOSE #f1: Unpack = 1: EXIT FUNCTION„    COLOR 4„    PRINT "     Overwrite "; RTRIM$(File); "? [Yes/No/Quit] ";„    COLOR 12„Again2:„    k$ = UCASE$(INPUT$(1))„    IF k$ <> "Y" AND k$ <> "N" AND k$ <> "Q" THEN GOTO Again2„    IF k$ = "Q" THEN PRINT "Quit": CLOSE #f1: CLOSE #f2: Unpack = 2: EXIT FUNCTION„    IF k$ = "Y" THEN PRINT "Yes": KILL RTRIM$(File)„    IF k$ = "N" THEN PRINT "No": CLOSE #f1: CLOSE #f2: Unpack = 2: EXIT FUNCTION„  END IF„„  Row = CSRLIN„  f2 = FREEFILE„  OPEN RTRIM$(File) FOR BINARY AS #f2„  SEEK #f1, PackOffset(Archive$, Filename$, Length!)„  IF NoPrint = 0 THEN„    LOCATE Row, 1„    COLOR 7„    PRINT "   "; CHR$(250); " Extracting file "; RTRIM$(File); "...";„  END IF„   „  PPos = POS(0)„  COLOR 14„„„  FOR i! = 1 TO Length! STEP BufferSize„    GET #f1, , Buffer„    Clip! = Length! + 1 - i!„    IF Clip! <= BufferSize THEN„      Buffer2$ = LEFT$(Buffer, Length! + 1 - i!)„      PUT #f2, , Buffer2$„    ELSE„      PUT #f2, , Buffer„    END IF„    IF NoPrint = 0 THEN„      IF i! \ BufferSize MOD 50 = 0 THEN LOCATE Row, PPos: PRINT LTRIM$(RTRIM$(STR$(INT((i! / Length!) * 100)))); "%"„    END IF„  NEXT„„  CLOSE f2„„  IF NoPrint = 0 THEN„    COLOR 14„    LOCATE Row, PPos„    PRINT Length!;„    COLOR 7„    PRINT "bytes"„  END IF„„END IF„„„CLOSE #f1„„END FUNCTION„Xtance Coders Alliance         SINUS SCROLL TEST              mrsnow@freemail.nl             09-05-97 (00:00)       QB, QBasic, PDS        111  3121     SINUS.BAS   '             s $$$$$$$$$$ s        $$$$$ s        $$$$$ $$$$$   $$$$$„'               $$$$$$$$$$          $$$$$          $$$$$$$$$$$   $$$$$„'               $$$$$$$$$$          $$$$$          $$$$$ $$$$$   $$$$$„'               $$$$$$$$$$          $$$$$          $$$$$ $$$$$   $$$$$„'               $$$$$$$$$$          $$$$$          $$$$$ $$$$$   $$$$$„'            s  $$$$$$$$$$  s       $$$$$  s       $$$$$ $$$$$   $$$$$„'          s$$  $$$$$$$$$$  $$s     $$$$$  $$s     $$$$$ $$$$$   $$$$$„'         $$$$  $$$$$$$$$$  $$$$    $$$$$  $$$$    $$$$$ $$$$$    S$S„'        $$$$$  $$$$$$$$$$  $$$$$   $$$$$  $$$$$   $$$$$ $$$$$     .„'        $$$$$$$$$$$$$$$$$$$$$$$$   $$$$$$$$$$$$   $$$$$ $$$$$    s$s„'        .$$$$$$$$$$$$$$$$$$$$$$.   .$$$$$$$$$$.   .$$$. .$$$.   $$$$$„'„'                Xtance               Coders         Alliance„'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~„'       This program is made by Mr. Snow from Xtance Coders Alliance and„'                                             DeeJee'z Team 1997„'„'               for All Basic Programmers in the Big Fat World„'„'       E-Mail to mrsnow@freemail.nl or djt@freemail.nl or Harryst@castel.nl„'       Subject Mr. Snow's Programming FAQ: [ Your question ]„'„'       Our pages at http://www.page4life.nl/mrsnow/„'       or at„'                    http://www.page4life.nl/xca-djt/„'„'„' Thats all, greets me..„'„'The Xtance Form Generator by Mr. Snow Again..„„DECLARE SUB LeftSinusWave (Lines%)„DECLARE SUB RightSinusWave (Lines%)„DECLARE SUB SinusWave (Lines%)„DEFINT A-Z„'$DYNAMIC„RANDOMIZE TIMER„„„DIM SHARED SinusText(25) AS STRING * 79„DIM SHARED SinusPos(25)„CONST Delay = .1„„SinusText(1) = "Sinus test version 1.0 by Mr. Snow            line: 1"„SinusText(2) = "-----------------------------------------------------"„SinusText(3) = ""„SinusText(4) = "Test it out."„SinusText(5) = ""„SinusText(6) = "Snow productions 1997, Source code by Mr. Snow"„SinusText(7) = "http://www.page4life.nl/mrsnow/"„SinusText(8) = "http://www.page4life.nl/xca-djt/"„SinusText(9) = ""„SinusText(10) = "E-Mailing"„SinusText(11) = "----------"„SinusText(12) = ""„SinusText(13) = "harryst@castel.nl"„SinusText(14) = "mrsnow@freemail.nl"„FOR z = 1 TO 9„	SinusText(14 + z) = STRING$(79, 196)„NEXT z„„„„„CALL LeftSinusWave(24)„SLEEP 1„„CALL RightSinusWave(24)„SLEEP 1„„REM $STATIC„SUB LeftSinusWave (Lines)„CLS„	FOR z = 1 TO Lines„		SinusPos(z) = 1„	NEXT z„„DO„	FOR z = 1 TO Lines„		SinusPos(z) = SinusPos(z) + (RND * 1.5)„	NEXT z„„	FOR z = 1 TO Lines„		LOCATE z, 1:„		PRINT RIGHT$(SinusText(z), SinusPos(z));„		FOR w = 1 TO 10000: NEXT w„	NEXT z„LOOP UNTIL INKEY$ <> ""„„END SUB„„SUB RightSinusWave (Lines)„CLS„	FOR z = 1 TO Lines„		SinusPos(z) = 1„	NEXT z„„DO„	FOR z = 1 TO Lines„		SinusPos(z) = SinusPos(z) + (RND * 1.5)„	NEXT z„„	FOR z = 1 TO Lines„		LOCATE z, 80 - LEN(LEFT$(SinusText(z), SinusPos(z))):„		PRINT LEFT$(SinusText(z), SinusPos(z));„		FOR w = 1 TO 10000: NEXT w„	NEXT z„„LOOP UNTIL INKEY$ <> ""„„END SUB„Sami Kyostila                  INCLUDE SUB/FUNCTIONS          hiteck@mail.freenet.hut.fi     09-19-97 (15:43)       QB, QBasic, PDS        552  13143    INCLUDE.BAS '---------------------------------------------------------------------„'               iNCLUDE.BAS - v1.1 (c) Sami KyîstilÑ 1997„'---------------------------------------------------------------------„'                          F R E E W A R E„'---------------------------------------------------------------------„„„„'---------------------------------------------------------------------„'                       D E S C R I P T I O N„'---------------------------------------------------------------------„'Have you ever found a useful SUB/FUNCTION you'd like to copy into„'your own code? But then you find out how awkward it is to copy the„'subs and functions manually, one at a time. That's just what this„'useful program is for!„'---------------------------------------------------------------------„„„„„'---------------------------------------------------------------------„'                            U S A G E„'---------------------------------------------------------------------„'This program queries you for the input and output files. You don't need„'to type in extensions, .BAS is added if no other extension is found.„'You can safely add the subs/functions to existing programs, because the„'data is appended, so the existing data is not erased. Then it parses„'the files for subs and functions and checks if there are any duplicates.„'If a QBasic source file has duplicated subs or functions, then QBasic„'won't even load it. iNCLUDE prevents this by removing the duplicate subs„'and functions from the list. After this the program displays a list of„'subs and functions it has found in the input file. Press arrows to move„'the red cursor and Space to mark/unmark the sub/function for copying.„'After you have selected the necessary subs and functions then press Enter„'to start the process. Then the program will start copying the selected„'subs and functions. NOTE: The copying process involves a lot of calculation„'and data transfer, therefore it may take a while on slow computers. Load„'Smartdrive or similar software to speed up the process.„'---------------------------------------------------------------------„„„„„'---------------------------------------------------------------------„'This code may be used freely, as long as the original author is credited„'---------------------------------------------------------------------„„„„„„„DECLARE SUB Duplicate ()„DECLARE SUB Doit ()„DECLARE SUB MarkSUB ()„DECLARE SUB WaitKey ()„DECLARE SUB Parse (File$, Quiet)„DECLARE FUNCTION Lines% (File$)„DECLARE SUB Center (Text$)„DECLARE FUNCTION FileSelector$ (XStart!, YStart!, XEnd!, YEnd!, Dir$, FileSpecs$, Topic$, FileHelp$)„ON ERROR GOTO Errorhandler„„SCREEN 0: CLS„WIDTH 80, 25„„„DIM SHARED Virhe„DIM SHARED Sourcedir$„DIM SHARED Total, DestTotal„DIM SHARED Inp$, Out$„DIM SHARED DestSUB$(200)„„„„„Total = 0„TYPE Subtype„  Desc AS STRING * 255„  First AS LONG„  Last AS LONG„  Selected AS LONG„END TYPE„„DIM SHARED Sb(200) AS Subtype„DIM SHARED ku$, kd$, kl$, kr$„„'define cursor keys„ku$ = CHR$(0) + CHR$(72)  'up„kr$ = CHR$(0) + CHR$(77)  'left„kd$ = CHR$(0) + CHR$(80)  'down„kl$ = CHR$(0) + CHR$(75)  'right„„„„„„„COLOR 14, 0: CLS„COLOR 15, 4„LOCATE 1, 1: PRINT STRING$(80, " ")„LOCATE 1, 1„Center "- iNCLUDE v1.1 (C) Sami KyîstilÑ 1997 - Distribute freely -"„VIEW PRINT 2 TO 25„„COLOR 8, 0„LOCATE 3, 1„„PRINT " This program appends SUBS/FUNCTIONS into your programs"„PRINT " from other programs, so you don't have to manually copy them."„PRINT " It scans the input file for SUBS/FUNCTIONS and appends the"„PRINT " ones of your choice to the output file."„PRINT " An extension of .BAS is assumed. This program can only handle"„PRINT " 200 SUBS/FUNCTIONS per file."„PRINT„COLOR 14„PRINT " ˛ Press Ctrl-C to quit"„PRINT„COLOR 7„„„INPUT "  Enter input file: ", Inp$„„IF Inp$ = "" THEN„  COLOR 12„  PRINT„  PRINT "    * [Error] File not found or null file ("; Inp$; ")"„  END„END IF„„IF INSTR(Inp$, ".") = 0 THEN Inp$ = Inp$ + ".BAS"„Inp$ = UCASE$(Inp$)„LOCATE 12, 21:  PRINT Inp$„PRINT„„INPUT "  Enter output file: ", Out$„ „IF Out$ = "" THEN„  COLOR 12„  PRINT„  PRINT "    * [Error] Null file ("; Out$; ")"„  END„END IF„„„IF INSTR(Out$, ".") = 0 THEN Out$ = Out$ + ".BAS"„Out$ = UCASE$(Out$)„LOCATE 14, 22:  PRINT Out$„PRINT„IF Inp$ = Out$ THEN COLOR 12: PRINT " * [Error] Source equals destination": END„COLOR 14„PRINT " ˛ Verifying input file "; Inp$; "...";„„OPEN Inp$ FOR BINARY AS #1„IF LOF(1) = 0 THEN„  CLOSE„  KILL Inp$„  COLOR 12„  PRINT„  PRINT "    * [Error] File not found or null file ("; Inp$; ")"„  END„END IF„„PRINT "Done"„COLOR 7„PRINT "     - File size:"; LOF(1); "bytes"„PRINT "     - Number of lines:"; Lines%(Inp$)„CLOSE„„PRINT„COLOR 14„PRINT " ˛ Verifying output file "; Out$; "...";„„OPEN Out$ FOR BINARY AS #1„IF LOF(1) = 0 THEN„  CLOSE„  KILL Out$„  COLOR 12„  PRINT„  PRINT "    * [Warning] File not found or null file ("; Out$; ")"„ELSE„  PRINT "Done"„  COLOR 7„  PRINT "     - File size:"; LOF(1); "bytes"„  PRINT "     - Number of lines:"; Lines%(Out$)„  CLOSE„END IF„  WaitKey„„„COLOR 14„PRINT„PRINT " ˛ Parsing output file "; Out$; "..."„Parse Out$, 1„DestTotal = Total„FOR i = 0 TO Total„  DestSUB$(i) = Sb(i).Desc$„  Sb(i).Desc$ = ""„  Sb(i).First = 0„  Sb(i).Last = 0„NEXT„„„COLOR 14„PRINT " ˛ Parsing input file "; Inp$; "..."„Parse Inp$, 0„COLOR 14„PRINT " ˛ Searching for duplicate SUBS/FUNCTIONS..."„Duplicate„CLS„COLOR 7„PRINT„Center " Choose the SUBS/FUNCTIONS to be added to the file " + Out$ + "."„Center " Mark/Unmark with <SPACE> - Confirm with <ENTER> - Cancel with <ESC>"„LOCATE 23, 1„COLOR 14„Center Inp$ + " > " + Out$„MarkSUB„Doit„VIEW PRINT: CLS„COLOR 7„Center "˙ Thank you for using iNCLUDE v1.1 by Sami KyîstilÑ 1997 ˙"„END„„„END„Errorhandler: Virhe = ERR: RESUME NEXT„„SUB Center (Text$)                 'Centers text on screen„LOCATE , 40 - (LEN(Text$) \ 2)„PRINT Text$„END SUB„„SUB Doit          'Copies the SUBS and FUNCTIONS to the file Out$ from Inp$„CLOSE„„OPEN Inp$ FOR INPUT AS #1„OPEN Out$ FOR APPEND AS #2„„IF Total = 0 THEN Sb(0).Selected = 1„„WritingSub = -1„„COLOR 0, 0„CLS„COLOR 14, 0„PRINT„PRINT " ˛ Appending to file "; Out$; "..."„OldRow = CSRLIN„OldCol = POS(1)„VIEW PRINT„COLOR 14, 4„LOCATE 1, 1: PRINT STRING$(80, " ")„LOCATE 1, 1: PRINT " Processing file "; Inp$; " > "; Out$; " - Line:"; Rivi; "/"; Totallines - 1„COLOR 7, 1„LOCATE 1, 71„PRINT STRING$(10, "∞")„COLOR 7, 0„VIEW PRINT 2 TO 25„LOCATE OldRow, OldCol„„COLOR 7„„„„Totallines = Lines%(Inp$)„„FOR Rivi = 0 TO Totallines - 1„  OldRow = CSRLIN„  OldCol = POS(1)„  VIEW PRINT„  COLOR 14, 4„  LOCATE 1, 1: PRINT " Processing file "; Inp$; " > "; Out$; " - Line:"; Rivi; "/"; Totallines - 1; "  "; INT(Rivi / (Totallines - 1) * 100); "%"„  COLOR 15, 1„  LOCATE 1, 71„  PRINT STRING$(INT(Rivi / (Totallines - 1) * 100) \ 10, "€")„  COLOR 7, 0„  VIEW PRINT 2 TO 25„  LOCATE OldRow, OldCol„„  LINE INPUT #1, Line$„  IF WritingSub = -1 THEN„    FOR i = 0 TO Total„      IF Rivi = Sb(i).First - 1 AND Sb(i).Selected = 1 THEN„        PRINT " ˙ Adding "; LEFT$(Sb(i).Desc, 68)„        COLOR 8„        PRINT "      - Start:";„        COLOR 2„        PRINT "   Line"; Rivi„        COLOR 7„        WritingSub = i„      END IF„    NEXT„  END IF„  IF WritingSub <> -1 THEN„    PRINT #2, Line$„    IF Rivi = Sb(WritingSub).Last THEN„      COLOR 8„      PRINT "      - End:";„      COLOR 2„      PRINT "     Line"; Rivi„      COLOR 7„      WritingSub = -1„    END IF„  END IF„„„NEXT„„CLOSE„„WaitKey„END SUB„„SUB Duplicate     'Searches for duplicate SUBS/FUNTIONS„COLOR 7„Found = 0„„FromTotal = Total„FOR i = 0 TO FromTotal - 1„  FOR i2 = 0 TO DestTotal - 1„    Sub$ = UCASE$(RTRIM$(Sb(i).Desc))„    Sub2$ = UCASE$(RTRIM$(DestSUB$(i2)))„„„    IF LEFT$(Sub$, 3) = "SUB" THEN„      IF INSTR(Sub$, "(") = 0 THEN„        SubName$ = MID$(Sub$, 5, 255)„      ELSE„        SubName$ = MID$(Sub$, 5, INSTR(5, Sub$, " ") - 5)„      END IF„    END IF„„    IF LEFT$(Sub$, 8) = "FUNCTION" THEN„      IF INSTR(Sub$, "(") = 0 THEN„        SubName$ = MID$(Sub$, 10, 255)„      ELSE„        SubName$ = MID$(Sub$, 10, INSTR(5, Sub$, " ") - 10)„      END IF„    END IF„„„    IF LEFT$(Sub2$, 3) = "SUB" THEN„      IF INSTR(Sub2$, "(") = 0 THEN„        SubName2$ = MID$(Sub2$, 5, 255)„      ELSE„        SubName2$ = MID$(Sub2$, 5, INSTR(5, Sub2$, " ") - 5)„      END IF„    END IF„„    IF LEFT$(Sub2$, 8) = "FUNCTION" THEN„      IF INSTR(Sub2$, "(") = 0 THEN„        SubName2$ = MID$(Sub2$, 10, 255)„      ELSE„        SubName2$ = MID$(Sub2$, 10, INSTR(5, Sub2$, " ") - 10)„      END IF„    END IF„„    IF SubName$ = SubName2$ THEN„      Found = 1„      COLOR 7„      PRINT "   ˙ Found duplicate SUB/FUNCTION: ";„      COLOR 2: PRINT SubName$„      Sb(i).Desc = STRING$(255, " ")„      Sb(i).First = 0„      Sb(i).Last = 0„      Sb(i).Selected = 0„    END IF„„  NEXT„NEXT„DIM DummyDesc$(200)„DIM DummyFirst(200)„DIM DummyLast(200)„„„Index = 0„FOR i = 0 TO FromTotal - 1„  IF LEFT$(Sb(i).Desc, 1) <> " " THEN„    DummyDesc$(Index) = RTRIM$(Sb(i).Desc)„    DummyFirst(Index) = Sb(i).First„    DummyLast(Index) = Sb(i).Last„    Sb(i).Desc = ""„    Index = Index + 1„  END IF„NEXT„„„Total = Index„„FOR i = 0 TO Total„  Sb(i).Desc = DummyDesc$(i)„  Sb(i).First = DummyFirst(i)„  Sb(i).Last = DummyLast(i)„NEXT„„ERASE DummyDesc$, DummyFirst, DummyLast„IF Found = 0 OR DestTotal <= 0 THEN COLOR 7: PRINT "   ˙ None found"„„IF Total < 0 THEN„  COLOR 12„  PRINT " * [Error] No SUBS/FUNCTIONS left to copy"„  END„END IF„„WaitKey„END SUB„„FUNCTION Lines% (File$)         'Count number of lines in File$„„Lin% = 0„„CountFile = FREEFILE„OPEN File$ FOR INPUT AS #CountFile„„DO„  IF EOF(CountFile) THEN EXIT DO„  LINE INPUT #CountFile, Dummy$„  Lin% = Lin% + 1„LOOP„Lines% = Lin%„CLOSE CountFile„„END FUNCTION„„SUB MarkSUB               'Displays the SUB and FUNCTION list and allows the„Sel = 0                   'user to select/deselect SUBS/FUNCTIONS„Scroll = 0„YStart = 6„YEnd = 22„LOCATE YStart, 1„„FOR i = 0 TO 200„  Sb(i).Selected = 0„NEXT„„„YLen = YEnd - YStart - 1„„LOCATE YStart, 1„FOR i = Scroll TO YLen + Scroll„  IF i >= 200 THEN EXIT FOR„  IF i = Sel THEN COLOR 15, 4 ELSE COLOR 7, 1„  PRINT "  "; LEFT$(Sb(i).Desc, 78)„NEXT„„DO„  k$ = INKEY$„  IF k$ <> "" THEN„    IF k$ = ku$ THEN Sel = Sel - 1„    IF k$ = kd$ THEN Sel = Sel + 1„    IF k$ = CHR$(27) THEN COLOR 7, 0: END„    IF k$ = CHR$(13) THEN EXIT SUB„    IF k$ = " " THEN„      IF Sb(Sel).Selected = 1 THEN Sb(Sel).Selected = 0: GOTO Add„      IF Sb(Sel).Selected = 0 THEN Sb(Sel).Selected = 1„Add:„      Sel = Sel + 1„    END IF„    IF Sel > Scroll + YLen THEN Scroll = Scroll + 1„    IF Sel < Scroll THEN Scroll = Scroll - 1„„    IF Scroll < 0 THEN Scroll = 0„    IF Scroll >= Total - YLen - 1 THEN Scroll = Total - YLen - 1„    IF Sel < 0 THEN Sel = 0„    IF Sel > Total - 1 THEN Sel = Total - 1„„    LOCATE YStart, 1„    FOR i = Scroll TO YLen + Scroll„      IF i >= 200 THEN EXIT FOR„      IF i = Sel THEN COLOR 15, 4 ELSE COLOR 7, 1„      IF i > -1 THEN„        IF Sb(i).Selected = 1 THEN PRINT CHR$(16) + " ";  ELSE PRINT "  ";„        PRINT LEFT$(Sb(i).Desc, 78)„      END IF„    NEXT„  END IF„LOOP„„END SUB„„SUB Parse (File$, Quiet)        'Parses File$ for SUBS/FUNCTIONS„COLOR 7                         'If Quiet = 1 then doesn't print list„Total = 0„„FOR i = 0 TO 200„  Sb(i).Selected = 0„NEXT„„„OPEN File$ FOR INPUT AS #1„Lin! = 0„FoundSub = 0„„DO„  IF EOF(1) THEN EXIT DO„  LINE INPUT #1, Line$„  Line$ = LTRIM$(Line$)„  Lin! = Lin! + 1„  IF LEFT$(Line$, 4) = "SUB " OR LEFT$(Line$, 9) = "FUNCTION " THEN„    IF FoundSub = 0 THEN„      IF Quiet = 0 THEN„        PRINT "    ˙ Found "; LEFT$(Line$, 68)„        COLOR 8„        PRINT "      - Start:";„        COLOR 2„        PRINT " Line"; Lin!„      END IF„      Sb(Total).Desc = Line$„      Sb(Total).First = Lin!„„      LastSub$ = Line$„      FoundSub = 1„    ELSE„      COLOR 12„      PRINT„      PRINT Line$„      PRINT "    * [Error] Did not find end of "; LastSub$; ""„      END„    END IF„  END IF„„  IF LEFT$(UCASE$(Line$), 7) = "END SUB" OR LEFT$(UCASE$(Line$), 12) = "END FUNCTION" THEN„    IF Quiet = 0 THEN„      COLOR 8„      PRINT "      - End:";„      COLOR 2„      PRINT "   Line"; Lin!„      COLOR 7„    END IF„    Sb(Total).Last = Lin!„    Total = Total + 1„    FoundSub = 0„  END IF„„LOOP„CLOSE„IF Total = 0 AND Quiet = 0 THEN COLOR 12: PRINT " * [Error] No SUBS/FUNCTIONS found": END„COLOR 14„PRINT " ˛ Found"; Total; "SUBS/FUNCTIONS in file "; File$„WaitKey„„„END SUB„„SUB WaitKey             'Displays a prompt and waits for keypress„PRINT„COLOR 8„PRINT " ˙ Press any key to continue"„PRINT„DO: LOOP UNTIL INKEY$ <> ""„CLS„END SUB„Michael S. Halpin              ERROR TRAPPING                 calvarygames@juno.com          09-24-97 (12:42)       QB, QBasic, PDS        314  5205     ERROR.BAS   'I release this program to public domain.„'Anyone who wishes to use this program may as long as they give credit to me„'and Calvary Games in the credits.  If you weren't planning credits start„'planning them now.„'„'-=> ERROR.BAS <=-„'Copyright 1997-98„'Calvary Games„'Allrights Reserved„„DECLARE SUB ErrorTrap (ErrorCode)„„ON ERROR GOTO ErrTrap„„'========Erase everthing between these lines before Before Programming==========„'These are just example lines that simulates an error trap when using„'this program.  Delete them before starting.„„        CLS„        INPUT "Enter a value between 0-255:  ", A„        ErrorTrap A„        PRINT„        PRINT "Press any key to continue..."„        A$ = INPUT$(1)„„'===============================================================================„„„ErrTrap:„ErrorTrap ERR„„SUB ErrorTrap (ErrorCode)„„SCREEN 0„WIDTH 80„COLOR 7, 0„CLS„PRINT "SYSTEM ERROR!"„PRINT "Error Code:  " + LTRIM$(RTRIM$(STR$(ErrorCode)))„PRINT "Description:  ";„IF ErrorCode = 1 THEN„     PRINT "NEXT without FOR."„     END„END IF„„IF ErrorCode = 2 THEN„     PRINT "Syntax error."„     END„END IF„„IF ErrorCode = 3 THEN„     PRINT "RETURN without GOSUB."„     END„END IF„„IF ErrorCode = 4 THEN„     PRINT "Out of DATA."„     END„END IF„„IF ErrorCode = 5 THEN„     PRINT "Illegal function call."„     END„END IF„„IF ErrorCode = 6 THEN„     PRINT "Overflow."„     END„END IF„„IF ErrorCode = 7 THEN„     PRINT "Out of memory."„     END„END IF„„IF ErrorCode = 8 THEN„     PRINT "Label not defined."„     END„END IF„„IF ErrorCode = 9 THEN„     PRINT "Subscript out of range."„     END„END IF„„IF ErrorCode = 10 THEN„     PRINT "Duplicate definition."„     END„END IF„„IF ErrorCode = 11 THEN„     PRINT "Division by zero."„     END„END IF„„IF ErrorCode = 12 THEN„     PRINT "Illegal in direct mode."„     END„END IF„„IF ErrorCode = 13 THEN„     PRINT "Type mismatch."„     END„END IF„„IF ErrorCode = 14 THEN„     PRINT "Out of string space."„     END„END IF„„IF ErrorCode = 15 THEN„     PRINT "String formula too complex."„     END„END IF„„IF ErrorCode = 16 THEN„     PRINT "Cannot continue."„     END„END IF„„IF ErrorCode = 17 THEN„     PRINT "Function not defined."„     END„END IF„„IF ErrorCode = 18 THEN„     PRINT "No RESUME."„     END„END IF„„IF ErrorCode = 19 THEN„     PRINT "RESUME without error."„     END„END IF„„IF ErrorCode = 20 THEN„     PRINT "Device timeout."„     END„END IF„„IF ErrorCode = 24 THEN„     PRINT "Device fault."„     END„END IF„„IF ErrorCode = 25 THEN„     PRINT "FOR without NEXT."„     END„END IF„„IF ErrorCode = 26 THEN„     PRINT "Out of paper."„     END„END IF„„IF ErrorCode = 27 THEN„     PRINT "WHILE without WEND."„     END„END IF„„IF ErrorCode = 29 THEN„     PRINT "WEND without WHILE."„     END„END IF„„IF ErrorCode = 30 THEN„     PRINT "Duplicate label."„     END„END IF„„IF ErrorCode = 33 THEN„     PRINT "Subprogram not defined."„     END„END IF„„IF ErrorCode = 35 THEN„     PRINT "Argument-count mismatch."„     END„END IF„„IF ErrorCode = 37 THEN„     PRINT "Array not defined."„     END„END IF„„IF ErrorCode = 38 THEN„     PRINT "Variable required."„     END„END IF„„IF ErrorCode = 40 THEN„     PRINT "FIELD overflow."„     END„END IF„„IF ErrorCode = 50 THEN„     PRINT "Internal error."„     END„END IF„„IF ErrorCode = 51 THEN„     PRINT "Bad file name or number."„     END„END IF„„IF ErrorCode = 52 THEN„     PRINT "File not found."„     END„END IF„„IF ErrorCode = 53 THEN„     PRINT "Bad file mode."„     END„END IF„„IF ErrorCode = 54 THEN„     PRINT "File already open."„     END„END IF„„IF ErrorCode = 55 THEN„     PRINT "FIELD statement active."„     END„END IF„„IF ErrorCode = 56 THEN„     PRINT "Device I/O error."„     END„END IF„„IF ErrorCode = 57 THEN„     PRINT "File already exists."„     END„END IF„„IF ErrorCode = 58 THEN„     PRINT "Bad record length."„     END„END IF„„IF ErrorCode = 59 THEN„     PRINT "Disk full."„     END„END IF„„IF ErrorCode = 62 THEN„     PRINT "Input past end of file."„     END„END IF„„IF ErrorCode = 63 THEN„     PRINT "Bad record number."„     END„END IF„„IF ErrorCode = 64 THEN„     PRINT "Bad file name."„     END„END IF„„IF ErrorCode = 67 THEN„     PRINT "Too many files."„     END„END IF„„IF ErrorCode = 68 THEN„     PRINT "Device unavailable."„     END„END IF„„IF ErrorCode = 69 THEN„     PRINT "Communication-buffer overflow."„     END„END IF„„IF ErrorCode = 70 THEN„     PRINT "Permission denied."„     END„END IF„„IF ErrorCode = 71 THEN„     PRINT "Disk not ready."„     END„END IF„„IF ErrorCode = 72 THEN„     PRINT "Disk-media error."„     END„END IF„„IF ErrorCode = 73 THEN„     PRINT "Feature unavailable."„     END„END IF„„IF ErrorCode = 74 THEN„     PRINT "Rename across disks."„     END„END IF„„IF ErrorCode = 75 THEN„     PRINT "Path/File access error."„     END„END IF„„IF ErrorCode = 76 THEN„     PRINT "Path not found."„     END„END IF„„PRINT "Unknown error."„END„„END SUB„Phillip Jay Cohen              FAST JOYSTICK ROUTINES         cohennet@erols.com             10-08-97 (03:47)       QB, QBasic, PDS        100  4124     FASTJOY.BAS ' ***************************************************************************„' ****************************** FastJoy ************************************„' ****              Coded 10/08/97 by Phillip Jay Cohen                  ****„' ****                                                                   ****„' ****   I was working on my game of Pac-Man which will probably never   ****„' **** be finished, and I got very frustrated when coding the joystick   ****„' **** routines.  You know, when you've been programming for long enough ****„' **** a millisecond gets to be just too darn long!  Anyway, I made no   ****„' **** real progress in solving the problem until I found the following  ****„' **** info in Wim Osterholt's list of port addresses:                   ****„' ****                                                                   ****„' **** 0201 r  read joystick position and status                         ****„' ****          bit 7  status B joystick button 2 / D paddle button      ****„' ****          bit 6  status B joystick button 1 / C paddle button      ****„' ****          bit 5  status A joystick button 2 / B paddle button      ****„' ****          bit 4  status A joystick button 1 / A paddle button      ****„' ****          bit 3  B joystick Y coordinate    / D paddle coordinate  ****„' ****          bit 2  B joystick X coordinate    / C paddle coordinate  ****„' ****          bit 1  A joystick Y coordinate    / B paddle coordinate  ****„' ****          bit 0  A joystick X coordinate    / A paddle coordinate  ****„' ****                                                                   ****„' **** So, I asked the folks at comp.lang.basic.misc and alt.lang.basic  ****„' **** if any of them knew how to use this, and all I got back was that  ****„' **** I should just use the STICK and STRIG functions. Helpful - NOT!   ****„' **** I searched for further info on the WWW, and came across a pretty  ****„' **** informative page of C++ which allowed me to write this code. It's ****„' **** faster than STICK and I hope some of you guys can use it. If you  ****„' **** do, please give me some credit, and if you REALLY like it, e-mail ****„' **** me at cohennet@erols.com, and tell me.  Also, if you're an expert ****„' **** coder and manage to speed it up, please let me know. -- P. Cohen  ****„' ***************************************************************************„' ***************************************************************************„„DECLARE SUB FastJoy (JoyX%, JoyY%, JoyNum%)„' Pretty badly programmed demo, don't you think?„SCREEN 13„COLOR 22„PRINT "FastJoy: joystick routine"„PRINT„FOR V = 0 TO 7„FOR H = 0 TO 55„IF POINT(H, V) THEN„LINE (H * 4, V * 4 + 130)-(H * 4 + 3, V * 4 + 130), 15„LINE (H * 4 + 1, V * 4 + 131)-(H * 4 + 4, V * 4 + 131), 40„LINE (H * 4 + 2, V * 4 + 132)-(H * 4 + 5, V * 4 + 132), 4„END IF„NEXT„NEXT„COLOR 1„LOCATE 5, 4„PRINT "X Coord"„PRINT„PRINT SPACE$(12); "Y Coord:"„COLOR 144„PRINT : PRINT : PRINT : PRINT SPACE$(18); "Coded by:"„COLOR 2„PRINT : PRINT SPACE$(23); "Phillip Jay Cohen"„LOCATE 23: COLOR 15„PRINT "WAY faster than QB's STICK function!"„IF STICK(1) < 2 THEN„COLOR 4„LOCATE 3: PRINT "Joystick not found!"„END„END IF„COLOR 9: LOCATE 3: PRINT "Using Joystick 1"„COLOR 44„DO„FastJoy X%, Y%, 1„LOCATE 7, 5„PRINT X%„LOCATE 9, 15„PRINT Y%„LOOP WHILE INKEY$ = ""„END„„SUB FastJoy (JoyX%, JoyY%, JoyNum%)„' Fast joystick routines by Phillip Jay Cohen„„' JoyX% returns vertical postion of specified joystick„' JoyY% returns horizontal postion of specified joystick„' JoyNum% specifies whether joystick number one or two is to be read„„SELECT CASE JoyNum% ' Choose appropriate bitmasks„CASE 1„XMask% = 1„YMask% = 2„CASE 2„XMask% = 4„YMask% = 8„CASE ELSE„EXIT SUB„END SELECT„JoyX% = 1: JoyY% = 1„OUT &H201, 0 ' Reset joystick port„DO„  Joy% = INP(&H201) ' Poll joystick port„  IF Joy% AND XMask% THEN JoyX% = JoyX% + 1„  IF Joy% AND YMask% THEN JoyY% = JoyY% + 1„LOOP UNTIL (Joy% AND XMask%) = 0 AND (Joy% AND YMask%) = 0„END SUB„Brian Wilkins                  MESSAGE ENCODER                sonic@digital.net              10-24-97 (19:23)       QB, QBasic, PDS        22   726      MSGENC.BAS  ' **** Message Encoder„' **** Program (c) 1997-98 Brian Wilkins„' **** This program will encode any message you type into the computer into a„' **** spy type encoded message which can be decoded with another program„' **** called MSGDEC.BAS„' ****                  If you find a use for this program, then please„' ****                  give me credit. Thanks!„„„„CLS                                              „LET C$ = "": PRINT„PRINT "Type in the message you want to encode:"„INPUT M$: LET l = LEN(M$)„IF INT(l / 2) <> l / 2 THEN LET M$ = M$ + " "„FOR K = 1 TO LEN(M$) STEP 2„LET C$ = C$ + MID$(M$, K + 1, 1)„LET C$ = C$ + MID$(M$, K, 1)„NEXT K„CLS„PRINT : PRINT "ENCODED MESSAGE:"„PRINT : PRINT C$„Brian Wilkins                  MESSAGE DECODER                sonic@digital.net              10-24-97 (19:23)       QB, QBasic, PDS        21   660      MSGDEC.BAS  ' **** Message DEcoder„' **** Program (c) 1997-98 Brian Wilkins„' **** This program will decode any message you type into the computer into a„' **** readable message which can also be encoded by another program„' **** called MSGENC.BAS„' ****                  If you find a use for this program, then please„' ****                  give me credit. Thanks!„„„CLS„LET C$ = "": PRINT„PRINT "Type in the CODED message:"„INPUT M$: LET l = LEN(M$)„IF INT(l / 2) <> l / 2 THEN LET M$ = M$ + " "„FOR K = 1 TO LEN(M$) STEP 2„LET C$ = C$ + MID$(M$, K + 1, 1)„LET C$ = C$ + MID$(M$, K, 1)„NEXT K„CLS„PRINT : PRINT "DECODED MESSAGE:"„PRINT : PRINT C$„