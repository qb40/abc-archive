Quinn Tyler Jackson            DESQVIEW AWARENESS             DESQVIEW,AWARENESS             06-10-92 (16:48)       QB, PDS                56   1064     DESQVIEW.BAS'Here is a program that will detect if it is running under DESQview.„'Have fun with it.„'„DEFINT A-Z„DECLARE SUB qjDVINIT ()„DECLARE FUNCTION qjDVINST% ()„„'  QJDV.BAS v1.0 Released into the Public Domain„'  Written by Quinn Tyler Jackson„„'$INCLUDE: 'qb.BI'„„DEFINT A-Z„„CONST TRUE = -1„CONST FALSE = NOT TRUE„„DIM SHARED InRegs AS RegTypeX„DIM SHARED OutRegs AS RegTypeX„„' The code that follows is merely a test.  To make this program into„' a support module, you must erase this silly code.„„qjDVINIT„CLS„PRINT "Hello, and welcome to QJDV version 1.0"„PRINT„„IF qjDVINST THEN„	   PRINT "This test is running under DESQView"„	   END„ELSE„	   PRINT "This test is not running under DESQview...."„	   END„END IF„END„„SUB qjDVINIT„    nul = qjDVINST„END SUB„„FUNCTION qjDVINST„	SHARED IN.DV„„	InRegs.AX = &H2B01„	InRegs.cx = &H4445„	InRegs.dx = &H5351„	CALL InterruptX(&H21, InRegs, OutRegs)„	IF OutRegs.AX MOD 256 <> &HFF THEN„	   IN.DV = TRUE„	   ELSE IN.DV = FALSE„	END IF„	qjDVINST = IN.DV„„END FUNCTION„„Harry F. Harrison              DETECT NOVELL INFORMATION      DETECT,NOVELL,INFORMATION      09-20-93 (00:00)       PDS                    144  4919     NOVELL.BAS  DECLARE FUNCTION GetNovellUserStats! (NovellInfo AS ANY)„DECLARE FUNCTION GetNovellVersion! (NovellInfo AS ANY)„'----------[ Network User Status ]----------„'$INCLUDE: '..\include\qbx.bi'„„TYPE NovellConnectionInfo„    ServerName AS STRING * 48„    NetVer AS SINGLE„    MajVer AS INTEGER„    MinVer AS INTEGER„    MaxCon AS INTEGER„    MaxVol AS INTEGER„    ConInUse AS INTEGER„    UserName AS STRING * 48„    Connection AS INTEGER„    NodeAddress AS STRING * 12 'Hex„    LoginDate AS STRING * 10„    LoginTime AS STRING * 8„END TYPE„„„    TYPE NovellConnectionIn„        Length AS INTEGER„        Function AS STRING * 1„        station AS STRING * 1„    END TYPE„    TYPE NovellConnectionOut„        Length AS INTEGER„        ID AS LONG„        IDType AS INTEGER„        UserName AS STRING * 48„        LogTime AS STRING * 8„    END TYPE„„„'----------[ Network Name ]----------„'$INCLUDE: '..\include\qbx.bi'„„    TYPE NovellInPacket„        Length AS INTEGER„        Function AS STRING * 1„    END TYPE„    TYPE NovellOutPacket„        Length AS INTEGER„        ServerName AS STRING * 48„        MajorVer AS STRING * 1„        MinorVer AS STRING * 1„        NumCon AS STRING * 2„        NumConUsed AS STRING * 2„        MaxVol AS STRING * 2„        undef AS STRING * 90„    END TYPE„„FUNCTION GetNovellUserStats (NovellInfo AS NovellConnectionInfo)„'returns connection information on user.  Returns 0 if successful„„DIM InRegs AS RegTypeX, OutRegs AS RegTypeX„„IF NovellInfo.NetVer = 0 THEN„    x = GetNovellVersion!(NovellInfo)„END IF„IF x > 0 THEN„    InRegs.ax = &HDC00„    CALL InterruptX(&H21, InRegs, OutRegs)„    NovellInfo.Connection = (OutRegs.ax AND &HFF)„    InRegs.ax = &HEE00„    CALL InterruptX(&H21, InRegs, OutRegs)„    NovellInfo.NodeAddress = RIGHT$("0000" + HEX$(OutRegs.cx), 4) + RIGHT$("0000" + HEX$(OutRegs.bx), 4) + RIGHT$("0000" + HEX$(OutRegs.ax), 4)„    DIM InPacket AS NovellConnectionIn„    DIM OutPacket AS NovellConnectionOut„    InPacket.Length = 4„    InPacket.Function = CHR$(22)„    InPacket.station = CHR$(NovellInfo.Connection)„    InRegs.ax = &HE300„    InRegs.ds = VARSEG(InPacket)„    InRegs.si = VARPTR(InPacket)„    InRegs.es = VARSEG(OutPacket)„    InRegs.di = VARPTR(OutPacket)„    OutPacket.Length = LEN(OutPacket)„    CALL InterruptX(&H21, InRegs, OutRegs)„    a$ = TIME$„    Yr% = (1900 + (CVI(MID$(OutPacket.LogTime, 1, 2)) AND &HFF))„    Mnth% = (CVI(MID$(OutPacket.LogTime, 2, 2)) AND &HFF)„    Daay% = (CVI(MID$(OutPacket.LogTime, 3, 2)) AND &HFF)„    Hr% = (CVI(MID$(OutPacket.LogTime, 4, 2)) AND &HFF)„    Min% = (CVI(MID$(OutPacket.LogTime, 5, 2)) AND &HFF)„    Sec% = (CVI(MID$(OutPacket.LogTime, 6, 2)) AND &HFF)„    NovellInfo.UserName = OutPacket.UserName„    x = INSTR(NovellInfo.UserName, CHR$(0))„    WHILE x„        MID$(NovellInfo.UserName, x, 1) = " "„        x = INSTR(In$, CHR$(0))„    WEND„    NovellInfo.LoginDate = RIGHT$("0" + LTRIM$(STR$(Mnth%)), 2) + CHR$(45) + RIGHT$(CHR$(48) + LTRIM$(STR$(Daay%)), 2) + CHR$(45) + LTRIM$(STR$(Yr%))„    NovellInfo.LoginTime = RIGHT$("0" + LTRIM$(STR$(Hr%)), 2) + CHR$(58) + RIGHT$(CHR$(48) + LTRIM$(STR$(Min%)), 2) + CHR$(58) + RIGHT$(CHR$(48) + LTRIM$(STR$(Sec%)), 2)„ELSE„    NovellInfo.ServerName = "Novell NetWare Not Installed"„    NovellInfo.UserName = "Not Logged In"„END IF„GetNovellUserStats% = OutRegs.ax AND &HFF„„END FUNCTION„„FUNCTION GetNovellVersion! (NovellInfo AS NovellConnectionInfo)„    DIM InPack AS NovellInPacket„    DIM OutPack AS NovellOutPacket„    DIM inreg AS RegTypeX„    DIM outreg AS RegTypeX„    DIM ExitValue!„„    InPack.Length = LEN(InPack)   ' Packet length of 3 bytes„    InPack.Function = CHR$(17)     ' Get File Server Information„    OutPack.Length = LEN(OutPack)„    inreg.ax = &HE300„„    inreg.ds = VARSEG(InPack)„    inreg.si = VARPTR(InPack)„„    inreg.es = VARSEG(OutPack)„    inreg.di = VARPTR(OutPack)„„    CALL InterruptX(&H21, inreg, outreg)„„    IF (outreg.ax AND &HFF) = 0 THEN„        NovellInfo.NetVer = ASC(OutPack.MajorVer) + (ASC(OutPack.MinorVer) / 100)„        NovellInfo.MajVer = ASC(OutPack.MajorVer) / 100„        NovellInfo.MinVer = ASC(OutPack.MinorVer)„        ExitValue! = ASC(OutPack.MajorVer) + (ASC(OutPack.MinorVer) / 100)„    ELSE„        NovellInfo.NetVer = -1„        ExitValue! = -1„    END IF„    NovellInfo.ServerName = OutPack.ServerName„    x = INSTR(NovellInfo.ServerName, CHR$(0))„    WHILE x„        MID$(NovellInfo.ServerName, x, 1) = " "„        x = INSTR(In$, CHR$(0))„    WEND„    NovellInfo.MaxCon = CVI(RIGHT$(OutPack.NumCon, 1) + LEFT$(OutPack.NumCon, 1))„    NovellInfo.ConInUse = CVI(RIGHT$(OutPack.NumConUsed, 1) + LEFT$(OutPack.NumConUsed, 1))„    NovellInfo.MaxVol = CVI(RIGHT$(OutPack.MaxVol, 1) + LEFT$(OutPack.MaxVol, 1))„    GetNovellVersion = ExitValue!„END FUNCTION„„Tony Elliott                   RETURN NETWORK ID              RETURN,NETWORK,ID              05-22-92 (12:20)       QB, PDS                50   1766     NETID.BAS   '> Does anybody have a routine to check either the network node ID or the„'> card id on a NetBios based network, such as LanTastic?„„'Here's a little routine you can use to return the machine name and ID„'on NetBios compatible networks. It'll return a null string if a„'compatible network is not running. Hope it helps.„„'-------------------„DEFINT A-Z„„DECLARE FUNCTION MachineName$ (MachineNumber%)„REM $INCLUDE: 'QB.BI'                           'Use QB.BI for QB4.x„„ThisMachine$ = MachineName$(MachineNumber%)„IF LEN(ThisMachine$) THEN„    PRINT "Machine Name: "; ThisMachine$„    PRINT "   Machine #:"; MachineNumber%„ELSE„    PRINT "NetBIOS compatible network not installed."„END IF„„'-------------„„FUNCTION MachineName$ (MachineNumber%)„„    'If a NetBIOS compatible network is installed, this function returns„    'the machine name as a result of the function and the machine's NetBIOS„    'ID number in the MachineNumber% parameter.„„    'If a network is not detected, the function returns a null string.„„    DIM Reg AS RegTypeX                 'In QB.BI (or QBX.BI if using PDS)„    DIM Temp AS STRING * 16             'Buffer to hold machine name„    MachineNumber% = 0                  'Make sure it is zero„    Reg.ax = 0                          'Use function 0 of interrupt 2ah„    CALL INTERRUPTX(&H2A, Reg, Reg)„    IF Reg.ax AND &HFF00 THEN           'If AH <> 0 then network was found„	   Reg.ax = &H5E00„	   Reg.ds = VARSEG(Temp)„	   Reg.dx = VARPTR(Temp)„	   CALL INTERRUPTX(&H21, Reg, Reg)„	   IF Reg.flags AND 1 THEN         'Did an error occur?„		  EXIT FUNCTION„	   END IF„	   MachineNumber% = Reg.cx AND &HFF    'Machine # in CL„	   MachineName$ = RTRIM$(Temp)„    END IF„„END FUNCTION„„Ethan Winer                    NETWORK NAME/ID                NETWORK,NAME,ID                Unknown Date (00:00)   QB, PDS                75   1926     NETNAME.BAS '  ≥Does anybody have a routine to check either the network node ID or the„'  ≥card id on a NetBios based network, such as LanTastic?„„'There is a couple of things in Ethan Winer's book BASIC Techniques„'and Utilities (Ziff Davis Press, ISBN 1-56276-008-4).  First, an„'include file, REGTYPE.BI:„„        TYPE RegType„         AX    AS INTEGER„         BX    AS INTEGER„         CX    AS INTEGER„         DX    AS INTEGER„         BP    AS INTEGER„         SI    AS INTEGER„         DI    AS INTEGER„         Flags AS INTEGER„         DS    AS INTEGER„         ES    AS INTEGER„        END TYPE„„'Then, a short program fragment with three functions:„„'NETCHECK.BAS, identifies which network is running„„DEFINT A-Z„''$INCLUDE: 'regtype.bi'„„DIM SHARED Registers AS RegType„„DECLARE FUNCTION NWThere% ()„DECLARE FUNCTION BVThere% ()„DECLARE FUNCTION MSThere% ()„„„'NOTE: Do not change the order in which these„'      tests are performed.„„PRINT "I think the network is ";„„IF NWThere% THEN„  PRINT "Novell Netware"„ELSEIF BVThere% THEN„  PRINT "Banyon Vines"„ELSEIF MSThere% THEN„  PRINT "Lantastic or other MS compatible"„ELSE„  PRINT "Something I don't recognize, or no network"„END IF„'----------------------------------------------------„'The book is a very good one; I heartily recommend it.„„FUNCTION BVThere% STATIC„BVThere% = -1„Registers.AX = &HD701„CALL Interrupt(&H2F, Registers, Registers)„  AL = Registers.AX AND 255„  IF AL <> 0 THEN BVThere% = 0„END FUNCTION„„FUNCTION MSThere% STATIC„  MSThere% = -1„  Registers.AX = &HB800„    CALL Interrupt(&H2F, Registers, Registers)„    AL = Registers.AX AND 255„    IF AL = 0 THEN MSThere% = 0„END FUNCTION„„FUNCTION NWThere% STATIC„  NWThere% = -1„  Registers.AX = &H7A00„  CALL Interrupt(&H2F, Registers, Registers)„    AL = Registers.AX AND 255„    IF AL <> &HFF THEN NWThere% = 0„END FUNCTION„„Chip Morrow                    LANTASTIC FUNCTION CALLS       LANTASTIC,FUNCTION,CALLS       Unknown Date (00:00)   QB, PDS                325  10652    LANSTAT.BAS ' LANSTAT.BAS - LANTastic function calls for QB. - Chip Morrow„'„' Compile/Link via:„'„'    QB LANSTAT /O;„'    LINK LANSTAT,,NUL,QB;„'„' $INCLUDE: 'QB.BI'                       ' INTERRUPT Types/Declares„'„DEFINT A-Z                                ' Everybody's an integer„„DECLARE FUNCTION NetBios% ()„DECLARE FUNCTION NetCancel% (DevName$)„DECLARE FUNCTION NetName% (Machine$)„DECLARE SUB GetDevice (DeviceNum%, DevName$, NetPath$)„DECLARE SUB Inactive (EntryNum%, Returned$)„DECLARE SUB LoggedIn (EntryNum%, LogName$)„DECLARE SUB NetVersion (Major%, Minor%)„DECLARE SUB Redirect (DevType%, DevName$, NetPath$)„DECLARE SUB Strip (A$, B$)„„COMMON SHARED Registers AS RegType        ' Pass Registers TYPE variable to„                                          ' all subs/functions.„„' Sample implementation of most of these routines follows.„' (Similar to LANTastic's "NET SHOW" command).„„PRINT "LANStat - your current status on a LANTastic network."„PRINT„„IF NetBios THEN                            ' Determine if netbios is present.„   Q = NetName(Machine$)                   ' Get machine name.„   NetVersion Major, Minor                 ' Get major and minor version #'s.„   PRINT "   LANTastic version is: ";                     ' Display results..„   PRINT LTRIM$(STR$(Major)); "."; LTRIM$(STR$(Minor))    ' ...„   PRINT "Current machine name is: "; Machine$            ' ...„   PRINT                                                  ' ...„„   ' ---------------------------------------------------------------------„   ' First, get a list of devices that you are redirecting to this station.„   ' ---------------------------------------------------------------------„„   Index = 0                            ' Always start at zero.„„   DO                                   ' Start looping...„     GetDevice Index, D$, N$               ' Get current device redirection.„     IF D$ = "" THEN EXIT DO               ' Jump out if nothing on this pass„     PRINT D$; " is redirected to "; N$    ' Display results from GetDevice.„     Index = Index + 1                     ' Increment index.„   LOOP                                 ' Get next device entry.„„   ' ------------------------------------------------------------------„   ' Next, get a list of server names that you're currently logged into.„   ' ------------------------------------------------------------------„„   PRINT„   Index = 0                            ' Reset our index„„   DO                                   ' Start looping...„     LoggedIn Index, Log$                  ' Get a server name„     IF Log$ = "" THEN EXIT DO             ' Jump out if nothing on this pass„     PRINT "Logged into: "; Log$           ' Display result from LoggedIn.„     Index = Index + 1                     ' Increment index.„   LOOP                                 ' Get next server name.„„   ' --------------------------------------------------------------------„   ' Now get a list of available servers that you haven't yet logged into.„   ' --------------------------------------------------------------------„„   PRINT„   Index = 0                            ' Reset our index„„   DO                                   ' Start looping...„     Inactive Index, Log$                  ' Get inactive server name„     IF Log$ = "" THEN EXIT DO             ' If nothing, jump out„     PRINT "Available: "; Log$             ' Display result from Inactive„     Index = Index + 1                     ' Increment index„   LOOP                                 ' Get next server name„„ELSE                                    ' No netbios present, so get out.„„   PRINT "NetBios not installed."„   END„„END IF„„' --------------------------------------------------------------------„' Quickie implementation of Redirect and NetCancel routines.„' Device name to redirect or cancel should be c:, d:, prn, lpt:, etc.„' Server's path should be full path, such as \\node1\cdrive„' --------------------------------------------------------------------„„DO„„  PRINT "R)edirect, C)ancel redirection, or Q)uit : ";„„  DO„    Z$ = UCASE$(INKEY$)„    SELECT CASE Z$„      CASE "R", "C", "Q": EXIT DO„    END SELECT„  LOOP„„       PRINT Z$„„       SELECT CASE Z$:„„	 CASE "R":                                            ' Redirect„	    PRINT "Drive letter or logical device ---> ";„	    LINE INPUT "", ReDir$„	    PRINT "Server's path to use -------------> ";„	    LINE INPUT "", SPath$„	    PRINT "Device type = P)rinter, or D)isk -> ";„	    DO„	      Z$ = UCASE$(INKEY$)„	      SELECT CASE Z$„		CASE "P", "D": EXIT DO„	      END SELECT„	    LOOP„	    PRINT Z$„	    SELECT CASE Z$„	      CASE "P":  DevType = 3            ' 3 = printer„	      CASE ELSE: DevType = 4            ' 4 = disk„	    END SELECT„„	    Redirect DevType, ReDir$, SPath$    ' Do it.„„	    IF DevType > 0 THEN                 ' Devtype = 0 if no error.„	       PRINT "Error"; DevType;„	       PRINT " - no redirection performed."„	    ELSE„	       PRINT "Redirection successful."„	    END IF„	    PRINT„„	 CASE "C":                                          ' Cancel„	    PRINT "Drive letter or logical device --> ";„	    LINE INPUT "", DevName$„„	    Z = NetCancel(DevName$)            ' Do it.„„	    IF Z > 0 THEN                      ' Z = 0 if no error.„	       PRINT "Error"; Z; " - unable to cancel redirection."„	    ELSE„	       PRINT "Redirection successfully cancelled."„	    END IF„	    PRINT„„	 CASE "Q", CHR$(27):            ' Quit„	   EXIT DO„„       END SELECT„„LOOP„„END„„' End sample.  Subs & functions follow.„„' **************************************************************************„„SUB GetDevice (DeviceNum%, DevName$, NetPath$)   ' Get redirected device entry.„  '„  ' DeviceNum% begins at zero (for first entry).„  ' DevName$ is returned as the name of the redirected device.„  ' NetPath$ is returned as the name of the server's network path.„  '„  ' DevName$ is returned as a nul string if DeviceNum is invalid.„  '„  DIM DevNam AS STRING * 16„  DIM NetPat AS STRING * 128„  Registers.ax = &H5F02„  Registers.bx = DeviceNum„  Registers.si = VARPTR(DevNam)„  Registers.di = VARPTR(NetPat)„  INTERRUPT &H21, Registers, Registers„  Strip DevNam, DevName$„  Strip NetPat, NetPath$„END SUB„„SUB Inactive (EntryNum%, Returned$)„  '„  ' Display a list of servers that are available, but that you haven't„  ' logged into.„  '„  ' EntryNum% is input to the routine, and begins at zero (for first entry).„  ' Returned$ is returned as the name of the server, or as "" if an invalid„  '           EntryNum is passed.„  '„  DIM CurrentEntry AS STRING * 16„  Registers.ax = &H5F84„  Registers.bx = EntryNum„  Registers.di = VARPTR(CurrentEntry)„  INTERRUPT &H21, Registers, Registers„  Strip CurrentEntry, Returned$„  IF Returned$ <> "" THEN„     Returned$ = "(" + Returned$ + ")"„  END IF„END SUB„„SUB LoggedIn (EntryNum%, Logged$)„  '„  ' Display a list of servers that you're currently logged into.„  ' EntryNum% begins at zero (for first entry).„  ' Logged$ returns the server name, or a nul string if invalid EntryNum.„  '„  DIM CurrentEntry AS STRING * 16„  Registers.ax = &H5F80„  Registers.bx = EntryNum„  Registers.di = VARPTR(CurrentEntry)„  INTERRUPT &H21, Registers, Registers„  Strip CurrentEntry, Logged$„END SUB„„FUNCTION NetBios%                     ' Determine if NetBios is present.„   '„   ' NetBios =  0 (Not installed), or„   '           -1 (Installed).„   '„   Registers.ax = 0„   INTERRUPT &H2A, Registers, Registers„   AH = Registers.ax \ 256„   IF AH = 0 THEN„      NetBios% = 0„   ELSE„      NetBios% = -1„   END IF„END FUNCTION„„FUNCTION NetCancel% (DevName$)                  ' Cancel device redirection.„  '„  ' Cancel redirection of a device.„  ' DevName$ is device name to cancel redirection for,„  ' NetCancel% returns an error code if unsuccessful, zero otherwise.„  '„  Registers.ax = &H5F04„  Registers.si = SADD(DevName$)„  INTERRUPT &H21, Registers, Registers„  IF Registers.flags AND 1 THEN„     NetCancel% = Registers.ax„  ELSE„     NetCancel% = 0„  END IF„END FUNCTION„„FUNCTION NetName% (Machine$)          ' Get current machine name.„  '„  ' This routine takes no inputs.  It returns:„  '„  ' NetName% is the machine number (or zero if error)„  ' Machine$ is the current machine name.„  '„  DIM MName AS STRING * 16„  Registers.ax = &H5E00„  Registers.dx = VARPTR(MName)„  INTERRUPT &H21, Registers, Registers„  IF Registers.flags AND 1 THEN       ' Carry flag is set. (Error)„     NetName% = 0„     LSET MName = "N/A"„     Strip MName, Machine$„     EXIT FUNCTION„  END IF„  CH = Registers.cx \ 256„  IF CH = 0 THEN„     NetName = 0„     EXIT FUNCTION„  END IF„  NetName = Registers.cx - (CH * 256)    ' CL„  Strip MName, Machine$„END FUNCTION„„SUB NetVersion (Major%, Minor%)          ' Determine LANTastic version.„  '„  ' Nothing is input to the routine.„  ' Major%  and  Minor% are returned as the version numbers.„  ' (Version 2.57 would be returned as Major = 2, Minor = 57)„  '„  Registers.ax = &HB809„  INTERRUPT &H2F, Registers, Registers„  Major% = Registers.ax \ 256            ' AH„  Minor% = Registers.ax - (Major * 256)  ' AL„END SUB„„SUB Redirect (DevType%, DevName$, NetPath$)      ' Redirect a device„  '„  ' Inputs:„  '„  ' DevType% = 3 for Printer device, or„  '            4 for disk device.„  '            DevName$ = "C:", "D:", "LPT1:", etc.„  '            NetPath$ = Server's network path to redirect, in the format:„  '                       \\server_name\device_name„  ' -----------------------------------------------------------------------„  ' OutPut:„  '„  ' DevType% returns zero if no error, or error number if one occurred.„  '„  DIM DevNam AS STRING * 16„  DIM NetPat AS STRING * 128„  LSET DevNam = DevName$ + CHR$(0)„  LSET NetPat = NetPath$ + CHR$(0)„  Registers.ax = &H5F03„  Registers.bx = DevType„  Registers.cx = 0„  Registers.si = VARPTR(DevNam)„  Registers.di = VARPTR(NetPat)„  INTERRUPT &H21, Registers, Registers           ' Duitoit.„  DevType = 0„  IF Registers.flags AND 1 THEN                  ' Carry flag indicates error.„     DevType = Registers.ax„  END IF„END SUB„„SUB Strip (A$, B$)                         ' Kludge to trim down fixed-length„					   ' strings.„   B$ = ""„   FOR Z = 1 TO LEN(A$)„      C$ = MID$(A$, Z, 1)„      IF C$ <> " " AND C$ <> CHR$(0) THEN„	 B$ = B$ + C$„      END IF„   NEXT„„END SUB„„