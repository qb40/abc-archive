Alexander Podkolzin            EDIT/INPUT STRING              app@sbank.e-burg.su            11-09-95 (11:16)       PB                     154  6402     INPSTR.BAS  '------------------------------ Demo here ----------------------------------„  DEFINT a-z„  CLS„  COLOR 0,7„  LOCATE 25,1„  PRINT "        You can use Backspace-,Ins-,Home-,Del-,End- keys and arrow keys.        ";„  s$=InputStr$("I am a string, edit me, please.",3,10,40,15,4)„  COLOR 14,1„  LOCATE 12,10„  PRINT s$„  END„'---------------------------------------------------------------------------„'⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„'≥ FUNCTION : InputStr$                                                    ≥„'≥ CALL     : s$ = InputStr$(Ed$,y%,x%,n%,textcolor%,backcolor%)           ≥„'≥ Where    : Ed$   - string to edit,                                      ≥„'≥          : y%,x% - place to edit/input string from,                     ≥„'≥          : n%    - number of characters to edit/input.                  ≥„'≥ RETURNS  : edit/input string, or null-string, if <Esc> is pressed.      ≥„'≥ AUTHOR   : Alexander Podkolzin (app@sbank.e-burg.su).                   ≥„'¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„' Source code is formatted by my program "PBB".„'---------------------------------------------------------------------------„'„  FUNCTION InputStr$(Ed$,y%,x%,n%,textcolor%,backcolor%)„'„     STATIC Ins%                        ' Switcher of Ins-mode.„'„     Enter$ = CHR$(13)                  ' List of keys, we need in„     Esc$ = CHR$(27)                    ' our function.„     BcSp$ = CHR$( 8)                   '„     Ins$ = CHR$(0,82)                  ' Equals to CHR$(0)+CHR$(82)„     Home$ = CHR$(0,71)                 '„     Del$ = CHR$(0,83)„     EndKey$ = CHR$(0,79)„     LeftKey$ = CHR$(0,75)„     RightKey$= CHR$(0,77)„'„     OldX% = POS(0)                     ' As well-bred programmers, :)„     OldY% = CSRLIN                     ' we have to save screen parameters.„     OldColor% = pbvScrnTxtAttr         ' Internal PB variables: color,„     Vis%=pbvCursorVis                  ' coursor is visiable (TRUE or FALSE),„     Sl1%=pbvCursor1                    ' top line of cursor,„     Sl2%=pbvCursor2                    ' bottom line.„'„     Ptr% = x%                          ' Current cursor position.„     COLOR textcolor%,backcolor%        ' Colors we'll use in our function.„     LOCATE y%,x%„     PRINT Ed$„'„     Edit$=GetString$(y%,x%,n%)„     LOCATE y%,x%„     PRINT Edit$„     DO                                 ' Main loop:„        IF Ptr%<x% THEN                 ' First of all we„           Ptr%=x%                      ' have„           ITERATE LOOP                 ' to„        END IF                          ' normalize„        IF Ptr%>x%+n%-1 THEN            ' the„           Ptr%=x%+n%-1                 ' cursor position.„           ITERATE LOOP„        END IF„        IF Ins%=0 THEN„           LOCATE y%,Ptr%,1,7,8         ' Usual cursor„        ELSE                            '„           LOCATE y%,Ptr%,1,5,8         ' "Ins" cursor„        END IF„        WHILE NOT INSTAT: WEND„        s$ = INKEY$„$IF 1   '----------------------------------------------------------------„'„' This < $IF...$ENDIF > block is for Russian PB-users only, as INKEY$„' does not distinguish lowercase Russian character "‡". (PB3.0)„'„        IF LEN(s$)=2 AND ASC(LEFT$(s$,1))=0 AND ASC(RIGHT$(s$,1))=0 THEN„           s$=CHR$(224)„        END IF„'„$ENDIF  '----------------------------------------------------------------„        SELECT CASE s$„           CASE Esc$„              InputStr$=""„              EXIT LOOP„           CASE Enter$„              InputStr$=RTRIM$(GetString(y%,x%,n%))„              EXIT LOOP„           CASE Ins$„              Ins% = Ins% XOR 1„              ITERATE LOOP„           CASE Home$„              Ptr%=x%„              ITERATE LOOP„           CASE EndKey$„              Ptr%=x%+LEN(RTRIM$(GetString(y%,x%,n%)))„              ITERATE LOOP„           CASE LeftKey$„              DECR Ptr%„              ITERATE LOOP„           CASE RightKey$„              INCR Ptr%„              ITERATE LOOP„           CASE Del$„              m%=Ptr%-x%„              k%=x%+n%-Ptr%„              Edit$=GetString$(y%,x%,m%)+GetString$(y%,Ptr%+1,k%)„           CASE BcSp$                   ' Exception!„              DECR Ptr%                 '„              IF Ptr%<x% THEN           ' So, normalize the cursor„                 Ptr%=x%                ' position here.„                 ITERATE LOOP           '„              END IF„              m%=Ptr%-x%„              k%=x%+n%-Ptr%„              Edit$=GetString$(y%,x%,m%)+GetString$(y%,Ptr%+1,k%)„           CASE ELSE„              IF LEN(s$)=1 THEN„                 m%=Ptr%-x%             ' Symbols before cursor„                 k%=x%+n%-Ptr%-1        ' Symbols after cursor„                 IF Ins%=1 THEN         ' Editing in Ins-mode„                    Edit$=GetString$(y%,x%,m%)+ s$ +GetString$(y%,Ptr%,k%)„                    Edit$=LEFT$(Edit$,n%)„                 ELSE                   ' Editing in usual mode„                    Edit$=GetString$(y%,x%,m%)+ s$ +GetString$(y%,Ptr%+1,k%)„                 END IF„                 INCR Ptr%„              END IF„        END SELECT„        LOCATE y%,x%,0,0,0              ' Make cursor invisiable„        PRINT Edit$                     '„     LOOP                               ' End of main loop.„     IF Vis% THEN                       ' Now we have„        Vis%=0                          ' to„     ELSE                               ' restore„        Vis%=1                          ' our parameters.„     END IF                             '„     ct%=OldColor% AND 15„     cb%=OldColor%\16„     COLOR ct%,cb%„     LOCATE Oldy%,OldX%,Vis%,Sl1%,Sl2%„  END FUNCTION                          ' BYE !„'---------------------------------------------------------------------------„' This function is not fast, but we don't need speed here.„'„  FUNCTION GetString$(y%,x%,n%)         ' Reads string from the screen.„     s$=""                              ' y%,x% - string coordinates,„     FOR i%=0 TO n%-1                   ' n% - characters to read.„        s$ = s$ + CHR$(SCREEN(y%,x%+i%))„     NEXT„     GetString$ = s$„  END FUNCTION„'---------------------------------------------------------------------------„„„„Brent Ashley                   WORD COUNTER                   QBFAQ                          05-11-92 (22:51)       QB, QBasic, PDS        63   2279     WC.BAS      'Speaking of contests...„„'I got a call today from none other than Ethan Winer, saying I've won„'Crescent's "word count" programming contest!  The idea was to write„'the fastest all-qb program to count the words in a text file.  This one„'does it on a 350k file in 1.4 seconds on my SX.  Ethan said I could post„'it about, so here goes:„„' Compile:  BC /o/a wc,,wc;„' Link:     LINK /ex/noe wc+nocom;„'„DEFINT A-Z„DIM FBuf AS STRING * 8192              ' Use fixed string to fix„                                       ' position„„WCount% = -32768                       ' Init count to bottom of integer„                                       ' range„                                       ' to get 65535 counts available„„DEF SEG = VARSEG(FBuf)                 ' Point to fixed buffer in memory„BufStart% = VARPTR(FBuf)„BufLen% = 8192„„NotOnWord = -1                         ' Assume not on word to start„„OPEN COMMAND$ FOR BINARY AS #1         ' Open file and store length„AmtLeft& = LOF(1)„„DO                                     ' Process file„„  IF AmtLeft& >= BufLen% THEN GOTO NotLastBlock„„  BufLen% = AmtLeft&                   ' Last block - size accordingly„  Done% = -1                           '  and flag end of loop„  GOTO GetBuf                          ' Less likely event gets GOTO„„NotLastBlock:                          ' More likely event falls thru to„                                       ' GetBuf„  AmtLeft& = -BufLen% + AmtLeft&       ' Negative first saves bytes„„GetBuf:„  GET #1, , FBuf                       ' Fill buffer„„  FOR Ofs% = BufStart% TO BufStart% + BufLen% - 1  ' Traverse buffer„„    IF PEEK(Ofs%) > 32 THEN GOTO NotWhiteSpace„„    IF NotOnWord% THEN GOTO NextByte   ' If already white space...„„    NotOnWord% = -1                    ' Trailing edge of word„    WCount% = WCount% + 1              '  triggers counter„    GOTO NextByte„„NotWhiteSpace:                         ' Not white space is more likely„    NotOnWord% = 0                     '  so comparison done on white„                                       '  space„„NextByte:„  NEXT„LOOP UNTIL Done%                       ' post-compare saves bytes„„PRINT WCount% + 32768                  ' display word count„„Alexander Podkolzin            GET TEXT                       app@sbank.e-burg.su            11-20-95 (17:41)       PB                     242  8663     GETTEXT.BAS '------------------------- Demo here --------------------------------„defint a-z„dim m$(100)„%MAXLINES = 1000„' Dymmy array (for testing):„m$(1)="1aaa It's a dummy text zzzaaaaaaa ---------- First line"„m$(2)="2bbbbbbdddddddddddddddbbbbbbbbddddb"„m$(3)="3ccccccccccaaaazzzzzzaaaaaa"„m$(4)="4bbbbbbbbbbbbb"„m$(5)="5aaaaaaaaaaeeaaazzzzzzaaaaa"„m$(6)="6bbbbwwwwwwwbbbbbbbbbbb"„m$(7)="7aaaaaaaaaataaazzzzzzdffaaaaaa"„m$(8)="8bbbbbbaaaaaaaaaaaaabbbbbbbbb"„m$(9)="9aaaaaaaaazzzzzzaaaaaaa"„m$(10)="10bbbbbbbbbbbbbbbww"„m$(11)="11aaaazzzzzzaaaaaaawwwwwwwwwwwwaaaaaaa"„m$(12)="12bbbbbbbbbbbbbbb"„m$(13)="13aaaaaaaaazzzzzzaaaaaaaaa"„m$(14)="14bbbbbbbbbbbbbbb ------------- Last line "„'„cls„print string$(2000,176);„color 0,7„locate 1,1„print space$(80);„locate 1,16„print "Using navigation keys,choose a line from text array..."„locate 25,1„print space$(80);„s$ = gettext(m$(),1,22,7,58,13,12,1,0,7) '0,7)„if s$="" then s$=" You have pressed ESC-key"„locate 25,2„print "You chose line: "; s$;„end„„'--------------------------------------------------------------------------„' GetText$:„' Returns a string, you chose from an array. It can be used for menuing„' as well. If you don't want cursor bar, make ct%=ctn%, cb%=cbn% and it„' will be a kind of simple browser.„'--------------------------------------------------------------------------„' Author: Alexander Podkolzin <APP@nw.sbank.e-burg.su>„'--------------------------------------------------------------------------„'„  FUNCTION GetText$( txt$(),_           ' text array,„     twin%,_                            ' win type,„     xb%, yb%, xe%, ye0%,_              ' window coordinates,„     ct%,cb%,_                          ' window colors,„     ctn%,cbn%)_                        ' cursor bar colors„     PUBLIC„'„     OldX% = POS(0)                     ' Saving parameters have to be„     OldY% = CSRLIN                     ' your habit :)„     OldColor% = pbvScrnTxtAttr         ' (internal PB variable)„     COLOR ct%,cb%                      '„'„     Enter$=CHR$(13)                    ' Only for beauty of our code,„     Esc$ = CHR$(27)                    ' as it's rather difficult to„     Home$ = CHR$(0,71)                 ' understand such lines as:„     PgUp$ = CHR$(0,73)                 ' IF RIGHT$(s$,1) = "G" THEN ...„     EndKey$ = CHR$(0,79)               ' then:„     PgDn$ = CHR$(0,81)                 ' IF s$ = Home$ THEN ...„     Up$ = CHR$(0,72)                   '„     Down$ = CHR$(0,80)                 '„'„     FOR i%=1 TO %MAXLINES              ' max lines in text array„        IF LEN(txt$(i%))=0 THEN EXIT FOR„     NEXT i%„     nlines%=i%-1„     IF nlines%<ye0%-yb%-1 THEN„        ye%=yb%+nlines%+1„     ELSE„        ye%=ye0%„     END IF„     lpage%=ye%-yb%-1„     CALL win(twin%,xb%,yb%,xe%,ye%,ct%,cb%)„     begy%=1„     Cur%=1„     endy%=MIN(lpage%,nlines%)„     GOSUB ShowText„     GOSUB ShowCursorBar„     DO                                 ' begy% - first line to show,„        IF nlines%<1 THEN EXIT LOOP     ' endy% - last line to show (array)„        k$=INKEY$                       ' cur%  - the cursor bar line„        SELECT CASE k$                  ' lpage%- length of window (page)„           CASE "" : ITERATE LOOP„           CASE Esc$ : cur%=0 : begy%=1:EXIT LOOP„           CASE Enter$ : EXIT LOOP„           CASE Home$ : begy%=1 : endy%=nlines%„           CASE EndKey$: begy%=nlines%-ye%+yb%+2 : endy%=nlines%„           CASE Up$„              IF cur%>1 THEN„                 GOSUB HideCursorBar„                 DECR cur%„                 GOSUB ShowCursorBar„              ELSE„                 begy%=begy%-1„                 endy%=endy%-1„              END IF„           CASE Down$„              IF cur%<lpage% THEN„                 GOSUB HideCursorBar„                 INCR cur%„                 GOSUB ShowCursorBar„              ELSE„                 begy%=begy%+1„                 endy%=endy%+1„              END IF„           CASE PgUp$ : begy%=begy%-lpage% : endy%=endy%-lpage%„           CASE PgDn$ : begy%=begy%+lpage% : endy%=endy%+lpage%„           CASE ELSE  : k$=""„        END SELECT„        GOSUB ShowText„     LOOP„     Gt%=begy%+cur%-1„     IF Gt%<>0 THEN„        GetText$=txt$(Gt%)„     ELSE„        GetText$=""„     END IF„     ct%=OldColor% AND 15               ' restore parameters„     cb%=OldColor%\16                   '„     COLOR ct%,cb%                      '„     LOCATE oldy%,oldx%                 '„     EXIT FUNCTION„„ShowText:„     CALL Numerer(nlines%,lpage%,begy%,endy%)„     GOSUB MakeRuler„     FOR i%=begy% TO endy%„        PutString xb%+2,yb%+i%-begy%+1,_„                  LEFT$(txt$(i%)+SPACE$(xe%-xb%+1),xe%-xb%-3)„     NEXT i%„     RETURN„„ShowCursorBar:„     FOR i%=xb%+1 TO xe%-1„        PutAttribute i%,yb%+cur%,ctn%,cbn%„     NEXT„     RETURN„„HideCursorBar:„     FOR i%=xb%+1 TO xe%-1„        PutAttribute i%,yb%+cur%,ct%,cb%„     NEXT„     RETURN„„MakeRuler:„    FOR i%=yb%+1 TO ye%-1„       PutAttribute xe%,i%,ct%,cb%„       PutString xe%,i%,CHR$(177)„    NEXT„    k%=((begy%+cur%-1)/nlines%)*(ye%-yb%-1)„    IF k%=0 THEN k%=1                   ' Correction "Kill insect"„    PutString xe%,yb%+k%,CHR$(219)„    RETURN„  END FUNCTION„'„' A few words about correction "Kill insect". :)„' Probable, it is not mine invention.         :)„' Sometimes in my programs appears difficult  :)„' points, in which I have hardly to think to  :)„' write "universal" formula for all possible  :)„' cases. As I'm a LAZY person, I write simple :)„' formula and correct its wrong results by    :)„' additional line (sometimes not one) of code.:)„' Such corrections I name "Kill insect".      :)„'--------------------------------------------------------------------------„' Numerer "normalizes" begy% and endy%        <-  very usefull function!„'„  SUB Numerer(nlines%,lpage%,begy%,endy%)„     IF nlines%<=lpage% THEN„        begy%=1„        endy%=nlines%„        EXIT SUB„     END IF„     IF begy%<1 THEN„        begy%=1„        endy%=begy%+lpage%-1„        EXIT SUB„     END IF„     IF begy%+lpage%-1>=nlines% THEN„        endy%=nlines%„        begy%=nlines%-lpage%+1„        EXIT SUB„     END IF„     endy%=begy%+lpage%-1„  END SUB„'--------------------------------------------------------------------------„  SUB PutString(x%,y%,st$)„     k%=160*(y%-1)+x%+x%-2„     DEF SEG = &HB800                   ' This is system dependent!„     FOR i%=0 TO LEN(st$)-1„        POKE$ k%+i%+i%,MID$(st$,i%+1,1)„     NEXT„     DEF SEG„  END SUB„'--------------------------------------------------------------------------„  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)„'„     OldColor% = pbvScrnTxtAttr         ' Internal PB variable„     SELECT CASE t%                     ' Window types„'                                       ' (you can make as much types,„'                                       '  as you want):„        CASE 1„           a%=218:b%=196:c%=191         '⁄ƒƒƒƒƒƒƒø„           h%=179:      :d%=179         '≥   1   ≥„           g%=192:f%=196:e%=217         '¿ƒƒƒƒƒƒƒŸ„        CASE 2„           a%=201:b%=205:c%=187         '…ÕÕÕÕÕÕÕª„           h%=186:      :d%=186         '∫   2   ∫„           g%=200:f%=205:e%=188         '»ÕÕÕÕÕÕÕº„        CASE ELSE„           a%=032:b%= a%:c%= a%         '„           h%= a%: :d%= a%              ' Blanks only„           g%= a%:f%= a%:e%= a%         '„     END SELECT„     COLOR ct%,cb%„     LOCATE yb%,xb%   : PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%)„     FOR i%=yb%+1 TO ye%-1„        LOCATE i%,xb% : PRINT CHR$(h%)+     SPACE$(xe%-xb%-1)     +CHR$(d%)„     NEXT„     LOCATE ye%,xb%   : PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%)„     FOR i%=yb%+1 TO ye%+1„        PutAttribute xe%+1,i%,8,0       ' Maiking„     NEXT                               ' shadows„     FOR i%=xb%+1 TO xe%+1              '„        PutAttribute i%,ye%+1,8,0       '„     NEXT„     ct%=OldColor% AND 15               ' restore colors„     cb%=OldColor%\16„     COLOR ct%,cb%„  END SUB„'--------------------------------------------------------------------------„  SUB PutAttribute(x%,y%,t%,b%)         ' Puts attribute byte to video memory„     LOCAL c%                           ' directly to Colomn, Row position„     c% = b%*16+t%                      '„     DEF SEG = &hb800                   ' NOTE: This is system depending !„     POKE 160*(y%-1)+x%+x%-1,c%„     DEF SEG„  END SUB„'--------------------------------------------------------------------------„Kenneth W. Melvin              EDITING RANDON ACCESS FILE     kwmelvin@nr.infi.net           11-24-95 (00:00)       QB, QBasic, PDS        548  21776    KEN-ED03.BAS'+------------------------------------------------------------------+„'| Filename: KEN-ED03.BAS                                           |„'|     Date: 11-24-95                                               |„'|  Purpose: Simple example of editing a random access file using   |„'|         : structured Qbasic. This is part of an ongoing series   |„'|         : of personal programming examples for learning QBasic   |„'|  Version: 0.03   ( added Ethan Winer's Editor subprocedure )     |„'|   Author: kwmelvin@nr.infi.net <Kenneth W. Melvin>               |„'|    Kudos: Thanks to Phil Wright for his patient tutorials, and to|„'|         : Dave Gjessing for encouragement and support, and to    |„'|         : Ethan Winer for _BASIC Techniques and Utilities_       |„'| Language: QBasic 1.1      drive:\> QBASIC /RUN KEN-ED03          |„'|    Notes: Documentation (started 11-21-95)                       |„'|         : Add graphics routines from DEMOSCRN.BAS                |„'|         : Add sorting routine                                    |„'|    * New: Now choose a record to Edit from the display list      |„'|         : Note the use of the FRE() function to measure memory   |„'|         : If user presses 0 or >NumRec, she's taken back to Menu |„'|         : Editor subprocedure added to EnterRecord and EditRecord|„'+------------------------------------------------------------------+„'===================================================================+„'---- PSEUDOCODE version 0.03                                       |„'1. Open the random access file                                     |„'2. Display beginning file statistics                               |„'3. LOOP until menu option "Q" is chosen                            |„'   3.1 Display the menu and input choice                           |„'   3.2 Execute the correct subprocedure                            |„'       3.2.1  Enter a record                                       |„'       3.2.2  List a record                                        |„'       3.2.3  Edit a record                                        |„'       3.2.4  Quit                                                 |„'4. Display ending file statistics                                  |„'5. Close the random access file                                    |„'6. Stop                                                            |„'                                                                   |„'---- Enter a Record                                                |„'1. Input the data for the new record using Editor                  |„'2. Ask if there's another new record to Enter                      |„'3. IF the answer is Yes THEN LOOP                                  |„'   ELSE                                                            |„'4. End Sub                                                         |„'                                                                   |„'---- List a Record                                                 |„'1. Define the keystrokes and capture them                          |„'2. Display the records to the screen and wait for user input       |„'   2.1 If Right Arrow is pressed, increment record shown           |„'   2.2 If Left Arrow is pressed, decrement record shown            |„'   2.3 If Enter is pressed, Edit the record shown                  |„'       2.3.1 Enter editing sub and print chosen record to screen   |„'       2.3.2 Ask which line to edit (menu right now)               |„'       2.3.3 Use Editor sub to edit each line.                     |„'       2.3.4 Edit another line?                                    |„'       2.3.5 If Yes, loop to 2.3.3                                 |„'       2.3.6 If No, Edit another record?                           |„'       2.3.7 If Yes, get record number to edit and loop to 2.3.1   |„'       2.3.8 If No, go back to main menu.                          |„'   2.4 If Esc is pressed, return to the main menu.                 |„'                                                                   |„'---- Edit a Record                                                 |„'1. Ask for record number to edit                                   |„'   1.1 If record number entered is 0, ask again                    |„'   1.2 If record number does not exist                             |„'       1.2.1 Show a brief error message                            |„'       1.2.2 Return to main menu                                   |„'2. Edit the record chosen                                          |„'   2.1 Enter the editing sub and print the chosen record to screen |„'   2.2 Ask user to choose which line to edit (menu right now)      |„'   2.3 Use Editor sub to edit each line.                           |„'   2.4 Edit another line?                                          |„'   2.5 If Yes, loop to 2.3                                         |„'   2.6 If No, Edit another record?                                 |„'   2.7 If Yes, get record number to edit and loop to 2.1           |„'   2.8 If No, go back to main menu.                                |„'                                                                   |„'---- File Statistics                                               |„'1. Display data file statistics for learning purposes only         |„'   These routines may be removed when no longer needed             |„'   1.1 Show data file length at start and end of program           |„'   1.2 Show record size                                            |„'   1.3 Show number of records in file                              |„'   1.4 Show total heap space available                             |„'   1.5 Show total string space available                           |„'2. The MemAvail sub is called from several locations               |„'                                                                   |„'---- End of Program                                                |„'1. Display final file statistics                                   |„'2. Close all open files.                                           |„'===================================================================+„„' *** Declarations ***„DECLARE SUB EnterScreen (NumRec%)„DECLARE SUB Kprint (Text$, Row%, Col%, Fg%, Bg%)„DECLARE SUB EditARecord (RecordToEdit%)„DECLARE SUB Editor (Text$, LeftCol%, RightCol%, KeyCode%)„DECLARE SUB EnterRecord (NumRec%)„DECLARE SUB DataFileStats (FileLen%, RecSize%, NumRec%)„DECLARE SUB DisplayRecord (NumRec%)„DECLARE SUB MemAvail (Row%, Col%)„DECLARE SUB PrintTheMenu ()„„REM $DYNAMIC 'for use by MemAvail„„DEFINT A-Z„' *** TYPE Structure ***„TYPE MyFriends„    LastName AS STRING * 14„    FirstName AS STRING * 14„    StreetAdd AS STRING * 28„    City AS STRING * 14„    State AS STRING * 2„    ZipCode AS STRING * 10„    Phone AS STRING * 14„    Birthday AS STRING * 10„    Comments AS STRING * 50„END TYPE„„' *** Dimension variable of TYPE MyFriends ***„DIM Friend AS MyFriends„„' *** Open a random access file ***„OPEN "KEN-ED03.DAT" FOR RANDOM AS #1 LEN = LEN(Friend)„„' *** Define some variables ***„FileLen = LOF(1)„RecSize = LEN(Friend)„NumRec = LOF(1) / LEN(Friend)„„' *** Show Datafile statistics ***„CALL DataFileStats(FileLen, RecSize, NumRec)„CALL Kprint("Press any key to continue", 25, 1, 7, 0)„SLEEP„„' *** MAIN PROGRAM LINE ***„BeginHere:„DO„  CALL PrintTheMenu„  Sel$ = INPUT$(1)„  SELECT CASE Sel$„    CASE "E", "e"„        CALL EnterRecord(NumRec)„    CASE "L", "l"„        CALL DisplayRecord(NumRec)„    CASE "D", "d"„        CALL EditARecord(RecordToEdit)„    CASE "Q", "q"„        GOTO EndProgram„    CASE ELSE„        GOTO BeginHere„  END SELECT„LOOP UNTIL UCASE$(Sel$) = "Q"„„EndProgram:„CLS„FileLen = LOF(1)„RecSize = LEN(Friend)„NumRec = LOF(1) / LEN(Friend)„CALL DataFileStats(FileLen, RecSize, NumRec)„CLOSE„END„„'*** END OF PROGRAM ***„„REM $STATIC„SUB DataFileStats (FileLen, RecSize, NumRec)„    CLS„    CALL Kprint("DATABASE FILE STATISTICS", 10, 27, 3, 0): COLOR 7, 0„    LOCATE 12, 30: PRINT "FileSize:"; FileLen; "bytes"„    LOCATE 13, 28: PRINT "RecordSize:"; RecSize; "bytes"„    LOCATE 14, 27: PRINT "No. Records:"; NumRec„    CALL MemAvail(15, 21)„END SUB„„SUB DisplayRecord (NumRec)„CLS„DIM Friend AS MyFriends  'this DIM statement has to be here, or QBasic„                            'shows an error message:"Identifier cannot„                            'include period."  Highlight on Friend.LastName.„X = 1                   'initialize record number„DO                      'begin display loop„    Ky$ = INKEY$        'capture a keypress„    IF Ky$ <> "" THEN„        IF Ky$ = CHR$(0) + "M" THEN X = X + 1   '-> arrow key - next„        IF Ky$ = CHR$(0) + "K" THEN X = X - 1   '<- arrow key - previous„        IF Ky$ = CHR$(13) THEN CALL EditARecord(X): EXIT SUB '<Enter> - edit„        IF Ky$ = CHR$(27) THEN EXIT SUB         ' <Esc> key - exit„    END IF„   „    IF X = 0 THEN X = NumRec                    ' wrap-around when record„    IF X > NumRec THEN X = 1                    ' goes past end or beginning„    IF X < 1 THEN X = 1„„    GET #1, X, Friend       'get #filenum, recordnumber, variable„    LOCATE 5, 30: COLOR 3, 0: PRINT "Record No."; X: COLOR 7, 0„    LOCATE 7, 25: PRINT Friend.LastName, Friend.FirstName„    LOCATE 8, 25: PRINT Friend.StreetAdd„    LOCATE 9, 25: PRINT Friend.City; Friend.State; " "; Friend.ZipCode„    LOCATE 10, 25: PRINT Friend.Phone,„    LOCATE 11, 25: PRINT Friend.Birthday„    LOCATE 12, 25: PRINT Friend.Comments„    „    'Screen Legend„    LOCATE 14, 25: COLOR 4, 0: PRINT "< ";CHR$(26);" >"; : COLOR 7, 0: PRINT " = Next Record"„    LOCATE 15, 25: COLOR 4, 0: PRINT "<  >"; : COLOR 7, 0: PRINT " = Previous Record"„    LOCATE 16, 25: COLOR 4, 0: PRINT "<ƒŸ>"; : COLOR 7, 0: PRINT " = Edit Record"„    LOCATE 17, 25: COLOR 4, 0: PRINT "<Esc>"; : COLOR 7, 0: PRINT " = Exit";„    CALL MemAvail(20, 25)„    SLEEP: CLS„LOOP„END SUB„„SUB EditARecord (RecordToEdit)„    DIM Friend AS MyFriends„„'****** Main editing loop ***„DO„    CLS„    NumRec = LOF(1) / LEN(Friend)„    IF RecordToEdit >= 1 THEN GOSUB PrintExistingRecord„    IF RecordToEdit = 0 THEN„        LOCATE 12, 20: COLOR 7, 0„        INPUT "Edit which record number?: ", RecordToEdit„    ELSEIF RecordToEdit > NumRec THEN„TryAgain:„        CALL Kprint("ERROR - That record doesn't exist!", 12, 25, 3, 0)„        RecordToEdit = 0„        SLEEP 5„    END IF„    GOSUB PrintExistingRecord„   „StartLineEdit:„    LOCATE 15, 1: PRINT "[press zero (0) to exit]": CALL MemAvail(20, 25)„    LOCATE 16, 1: INPUT "Choose a line to edit (1-9): ", Choice„        IF Choice = 0 THEN EXIT SUB„    SELECT CASE Choice„       „        CASE 1„            LOCATE 3, 26: COLOR 14, 0„            CALL Editor(Friend.LastName, 26, 40, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 2„            LOCATE 4, 26: COLOR 14, 0„            CALL Editor(Friend.FirstName, 26, 40, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 3„            LOCATE 5, 26: COLOR 14, 0„            CALL Editor(Friend.StreetAdd, 26, 54, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 4„            LOCATE 6, 26: COLOR 14, 0„            CALL Editor(Friend.City, 26, 40, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 5„            LOCATE 7, 26: COLOR 14, 0„            CALL Editor(Friend.State, 26, 28, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 6„            LOCATE 8, 26: COLOR 14, 0„            CALL Editor(Friend.ZipCode, 26, 36, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 7„            LOCATE 9, 26: COLOR 14, 0„            CALL Editor(Friend.Phone, 26, 40, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 8„            LOCATE 10, 26: COLOR 14, 0„            CALL Editor(Friend.Birthday, 26, 36, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE 9„            LOCATE 11, 26: COLOR 14, 0„            CALL Editor(Friend.Comments, 26, 76, KeyCode)„            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecord„       „        CASE ELSE„            BEEP: GOTO StartLineEdit„    END SELECT„    „    'clear lines from screen„    LOCATE 16, 1: PRINT STRING$(70, CHR$(32))„    LOCATE 17, 1: PRINT STRING$(70, CHR$(32))„   „    LOCATE 16, 1: PRINT "Edit another line? Y/N"; : Ans$ = INPUT$(1)„    IF UCASE$(Ans$) = "Y" THEN GOTO StartLineEdit„   „    CALL Kprint("Edit another record? Y/N", 18, 1, 4, 0)       'ask user for„    Ans$ = INPUT$(1): COLOR 7, 0: RecordToEdit = 0             'input...„    IF UCASE$(Ans$) = "N" THEN EXIT SUB      'get out of here if answer is No„LOOP WHILE UCASE$(Ans$) = "Y"                'loop as long as they answer Yes„„„'---- this routine is used to show the edits made and is also a menu„'     for selection of which line to edit.„PrintExistingRecord:„    „    CLS„    NumRec = LOF(1) / LEN(Friend)„    IF RecordToEdit > NumRec THEN GOTO TryAgain„    IF RecordToEdit = 0 THEN EXIT SUB„    GET #1, RecordToEdit, Friend„    LOCATE 2, 1: COLOR 3, 0: PRINT "Edit Record #"; RecordToEdit: COLOR 7, 0„    PRINT "1) Last Name           : "; Friend.LastName„    PRINT "2) First Name          : "; Friend.FirstName„    PRINT "3) Street Address      : "; Friend.StreetAdd„    PRINT "4) City                : "; Friend.City„    PRINT "5) State               : "; Friend.State„    PRINT "6) Zip Code            : "; Friend.ZipCode„    PRINT "7) Phone               : "; Friend.Phone„    PRINT "8) Birthday            : "; Friend.Birthday„    PRINT "9) Comments            : "; Friend.Comments„    COLOR 7, 0„RETURN„„END SUB„„SUB Editor (Text$, LeftCol, RightCol, KeyCode) STATIC„  '---- Editor is a single line text editor„  '---- Find the cursor's size„  DEF SEG = 0„  IF PEEK(&H463) = &HB4 THEN„        CsrSize = 12                'mono uses 13 scan lines„  ELSE„        CsrSize = 7                 'color uses 8„  END IF„„  '----Work with a temporary copy„  Edit$ = SPACE$(RightCol - LeftCol + 1)„  LSET Edit$ = Text$„„  '---- See where to begin editing and print the string.„  TxtPos = POS(0) - LeftCol + 1„  IF TxtPos < 1 THEN TxtPos = 1„  IF TxtPos > LEN(Edit$) THEN TxtPos = LEN(Edit$)„„  LOCATE , LeftCol„  PRINT Edit$;„„  '---- This is the main loop for handling key presses„  DO„        LOCATE , LeftCol + TxtPos - 1, 1„„        DO„          Ky$ = INKEY$„        LOOP UNTIL LEN(Ky$)             'wait for a keypress„„        IF LEN(Ky$) = 1 THEN            'create a key code„          KeyCode = ASC(Ky$)            'regular character key„        ELSE                            'extended key„          KeyCode = -ASC(RIGHT$(Ky$, 1))„        END IF„„        '---- Branch according to the key pressed„        SELECT CASE KeyCode„„          '---- Backspace: decrement the pointer and the„          '     cursor, and ignore if in the first column.„          CASE 8„                TxtPos = TxtPos - 1„                LOCATE , LeftCol + TxtPos - 1, 0„                IF TxtPos > 0 THEN„                  IF InsStatus THEN„                        MID$(Edit$, TxtPos) = MID$(Edit$, TxtPos + 1) + " "„                  ELSE„                        MID$(Edit$, TxtPos) = " "„                  END IF„                        PRINT MID$(Edit$, TxtPos);„                END IF„„          '---- Enter or Escape: this block is optional in„          '     case you want to handle these separately.„          CASE 13, 27„                EXIT DO                 'exit the subprogram„„          '---- Letter keys: turn off the cursor to hide„          '     the printing, handle Insert mode as needed.„          CASE 32 TO 254„                LOCATE , , 0„                IF InsStatus THEN       'expand the string„                  MID$(Edit$, TxtPos) = Ky$ + MID$(Edit$, TxtPos)„                  PRINT MID$(Edit$, TxtPos);„                ELSE                    'else insert character„                  MID$(Edit$, TxtPos) = Ky$„                  PRINT Ky$;„                END IF„                TxtPos = TxtPos + 1     'update position counter„„          '---- Left arrow: decrement the position counter.„          CASE -75„                TxtPos = TxtPos - 1„„          '---- Right arrow: increment position counter.„          CASE -77„                TxtPos = TxtPos + 1„„          '---- Home: jump to the first character position.„          CASE -71„                TxtPos = 1„„          '---- End: search for the last non-blank, and„          '     make that the current editing position.„          CASE -79„                FOR N = LEN(Edit$) TO 1 STEP -1„                  IF MID$(Edit$, N, 1) <> " " THEN EXIT FOR„                NEXT„                TxtPos = N + 1„                IF TxtPos > LEN(Edit$) THEN TxtPos = LEN(Edit$)„„          '---- Insert key: toggle the Insert state and„          '     adjust the cursor size.„          CASE -82„                InsStatus = NOT InsStatus„                IF InsStatus THEN„                  LOCATE , , , 0, CsrSize„                ELSE„                  LOCATE , , , CsrSize - 1, CsrSize„                END IF„          „          '---- Delete: delete the current character and„          '     reprint what remains in the string.„          CASE -83„                MID$(Edit$, TxtPos) = MID$(Edit$, TxtPos + 1) + " "„                LOCATE , , 0„                PRINT MID$(Edit$, TxtPos);„„          '---- All other keys: exit the subprogram„          CASE ELSE„                EXIT DO„        END SELECT„  '---- Loop until the cursor moves out of the field.„  LOOP UNTIL TxtPos < 1 OR TxtPos > LEN(Edit$)„„  Text$ = RTRIM$(Edit$)         'trim the text„„END SUB„„SUB EnterRecord (NumRec)„CLS„DIM Friend AS MyFriends     'this DIM statement has to be here, or QBasic„                            'shows an error message:Identifier cannot include„                            'period.    Highlight on Friend.LastName.„DO„    GOSUB InitializeScreen„    CALL MemAvail(20, 25)„            LOCATE 3, 1: COLOR 14, 0„            CALL Editor(Friend.LastName, 26, 40, KeyCode): COLOR 7, 0„          „            LOCATE 4, 1: COLOR 14, 0„            CALL Editor(Friend.FirstName, 26, 40, KeyCode): COLOR 7, 0„          „            LOCATE 5, 1: COLOR 14, 0„            CALL Editor(Friend.StreetAdd, 26, 54, KeyCode): COLOR 7, 0„          „            LOCATE 6, 1: COLOR 14, 0„            CALL Editor(Friend.City, 26, 40, KeyCode): COLOR 7, 0„          „            LOCATE 7, 1: COLOR 14, 0„            CALL Editor(Friend.State, 26, 28, KeyCode): COLOR 7, 0„          „            LOCATE 8, 1: COLOR 14, 0„            CALL Editor(Friend.ZipCode, 26, 36, KeyCode): COLOR 7, 0„          „            LOCATE 9, 1: COLOR 14, 0„            CALL Editor(Friend.Phone, 26, 40, KeyCode): COLOR 7, 0„          „            LOCATE 10, 1: COLOR 14, 0„            CALL Editor(Friend.Birthday, 26, 36, KeyCode): COLOR 7, 0„          „            LOCATE 11, 1: COLOR 14, 0„            CALL Editor(Friend.Comments, 26, 76, KeyCode): COLOR 7, 0„            PUT #1, NumRec, Friend„           „    NumRec = LOF(1) / LEN(Friend)„    LOCATE 13, 1: PRINT "Enter another record? Y/N ";   'ask user for input„    Ans$ = INPUT$(1)„    GOSUB EnterANewRecord: CLS„LOOP WHILE UCASE$(Ans$) = "Y"               'loop as long as they answer Yes„GOTO ThisIsTheEnd„„InitializeScreen:„    NumRec = NumRec + 1„    CALL EnterScreen(NumRec)„RETURN„„EnterANewRecord:„    IF NumRec = 0 THEN EXIT SUB„    GET #1, NumRec, Friend„    Friend.LastName = ""„    Friend.FirstName = ""„    Friend.StreetAdd = ""„    Friend.City = ""„    Friend.State = ""„    Friend.ZipCode = ""„    Friend.Phone = ""„    Friend.Birthday = ""„    Friend.Comments = ""„RETURN„„ThisIsTheEnd:„END SUB„„SUB EnterScreen (NumRec)„    DIM Friend AS MyFriends„    LOCATE 2, 1: COLOR 3, 0: PRINT "Enter Record #"; NumRec: COLOR 7, 0„    PRINT "Last Name              : "„    PRINT "First Name             : "„    PRINT "Street Address         : "„    PRINT "City                   : "„    PRINT "State                  : "„    PRINT "Zip Code               : "„    PRINT "Phone                  : "„    PRINT "Birthday               : "„    PRINT "Comments               : "„    COLOR 7, 0„END SUB„„SUB Kprint (Text$, Row, Col, Fg, Bg)„    LOCATE Row, Col„    COLOR Fg, Bg„    PRINT Text$;„END SUB„„SUB MemAvail (Row, Col)„    LOCATE Row, Col„    PRINT "  Free heap space:"; FRE(-1)„    LOCATE (Row + 1), Col„    PRINT "Free string space:"; FRE(0)„    LOCATE , , 0„END SUB„„SUB PrintTheMenu„  CLS„  CALL Kprint("Main Menu", 5, 31, 4, 0)„  CALL Kprint("E", 7, 31, 4, 0): CALL Kprint("nter a Record", 7, 32, 7, 0)„  CALL Kprint("L", 9, 31, 4, 0): CALL Kprint("ist Records", 9, 32, 7, 0)„  CALL Kprint("E", 11, 31, 7, 0): CALL Kprint("d", 11, 32, 4, 0)„  CALL Kprint("it Records", 11, 33, 7, 0)„  CALL Kprint("Q", 13, 31, 4, 0): CALL Kprint("uit", 13, 32, 7, 0)„  CALL Kprint("Choose", 15, 31, 4, 0): CALL Kprint(" E, L, D, ", 15, 37, 7, 0)„  CALL Kprint("or ", 15, 47, 4, 0): CALL Kprint("Q", 15, 50, 7, 0)„  CALL MemAvail(20, 25)„END SUB„„Sami Laine                     PASSWORD FUNCTION              oh1jkt@mea.cc.utu.fi           11-14-95 (21:25)       QB, QBasic, PDS        61   1443     PASSWORD.BAS' PASSWORD.BAS - demonstration of basic input routines, when hiding„'        typed characters (plus this will handle backspace).„'„' PASSWORD.BAS is hereby donated to public domain by Sami Laine.„'„' You can contact original author as <oh1jkt@mea.cc.utu.fi> or from FidoNet„' point 2:222/130.69.„'„' Password$ will return string "(NULL)" in any error (there are only few,„' actually just one - too long ( > 1 ) Repl$ string).„'„' Sample call:„'„'       secret$ = Password$("Secret word: ", "*", 8)„'„DECLARE FUNCTION Password$ (Prompt$, Repl$, MaxLength%)„„FUNCTION Password$ (Prompt$, Repl$, MaxLength%)„'„' Make sure user is using only 1 character as replacement.„'„IF LEN(Repl$) > 1 THEN„	Password$ = "(NULL)"„	EXIT FUNCTION„END IF„„PRINT Prompt$;„OrigRow% = CSRLIN„OrigColumn% = POS(1)„Column% = OrigColumn%„„DO„	' Read character.„	C$ = INPUT$(1)„	SELECT CASE ASC(C$)„		' Handle ENTER (stop reading characters).„		CASE 13„			EXIT DO„		' Handle BACKSPACE key.„		CASE 8„			IF Column% > OrigColumn% THEN„				Column% = Column% - 1„				LOCATE OrigRow%, Column%„				PRINT " ";„				LOCATE OrigRow%, Column%„				IF LEN(TmpStr$) THEN„					TmpStr$ = MID$(TmpStr$, 1, (LEN(TmpStr$) - 1))„				END IF„			END IF„		CASE ELSE„			IF LEN(TmpStr$) < MaxLength% THEN„				TmpStr$ = TmpStr$ + C$„				PRINT Repl$;„			END IF„			Column% = Column% + 1„	END SELECT„LOOP„„Password$ = TmpStr$„„END FUNCTION„Rick Pedley                    SHUFFLING DATA IN AN ARRAY     FidoNet QUIK_BAS Echo          10-03-93 (10:42)       QB, QBasic, PDS        78   2563     SHUFFLE.BAS ' > I'm looking for a code to shuffle data so that I get a list of the„„' Here's a way to shuffle each number exactly once, in _one_ array:„ „DEFINT A-Z „RANDOMIZE TIMER „ „MaxNum = 1000 „DIM Array (1 TO MaxNum) „FOR x = 1 TO MaxNum „   Array(x) = x „NEXT x „Top = 1 „Bottom = MaxNum „WHILE Bottom > Top „   RandNum = INT((Bottom - Top + 1) * RND + 1) „   SWAP Array(RandNum), Array(Bottom) „   Bottom = Bottom - 1 „WEND „ „'With five numbers, here's a picture of how it works: „ „'1            1            4            3            3 < Bottom „'2            5            5            5 < Bottom   5   (exit) „'3            3            3 < Bottom   4            4 „'4            4 < Bottom   1            1            1 „'5 < Bottom   2            2            2            2 „ „'Sometimes the Bottom value swaps with itself, as I did purposely „'in the last column. And as you can see, although 4 moved twice, „'the shuffle is always completed in MaxNum times through the loop. „'It's very fast, no index array is needed, and it doesn't slow „'down near the end the way some other methods do. Here's a semi- „'practical application for a sort like this (shuffling a deck of „'cards is another obvious use). If you compare this method with „'filling an index array with flag values, you'll see the difference. „ „'Turn text screen from white to black randomly, „'one location at a time. „ „DEFINT A-Z „RANDOMIZE TIMER „Rows = 25                 'or 43 or 50 „MaxNum = Rows * 80 „DIM ScrnEl(MaxNum) „Block$ = CHR$(219) „BlockLine$ = STRING$(80, Block$)„FOR X = 1 TO MaxNum       'initialize array „   ScrnEl(X) = X „NEXT X „Top = 1: Bot = MaxNum „DO                        'shuffle all screen pos'ns „   RandNum = INT(Bot * RND + 1) „   SWAP ScrnEl(RandNum), ScrnEl(Bot) „   Bot = Bot - 1 „LOOP WHILE Bot > Top „CLS „COLOR 15 „FOR X = 1 TO Rows         'fill in screen „   PRINT BlockLine$; „NEXT X „DO UNTIL LEN(INKEY$): LOOP „„COLOR 0 „FOR X = 1 TO 2000 „   C = ScrnEl(X) MOD 80: IF C = 0 THEN C = 80 'calc screen pos'n „   R = ScrnEl(X) \ 80 - (C < 80) „   LOCATE R, C: PRINT Block$; „NEXT X „END „ „'You can use this method easily with file records. You would do the „'shuffle first, so all the values held in Array() are out of order. „'Then, step through the file records: „ „FOR Y = 1 TO 3000                ' 3000 records, already DIM'd „   GET #x, RecordNumber(Array(y))' the _value_ of Array(x) points to the„NEXT Y                           ' record you're going to read. „Jim Broadbent                  TEXT INSIDE A BOX              FidoNet QUIK_BAS Echo          11-25-95 (23:36)       QB, QBasic, PDS        118  3690     BOXTEXT.BAS ' > I am in need of some help. I want to open a text„' > file & place the text from that file with a drawn„' > box. The box's size should be determined by the„' > amount of text from the imported file.„„ „'Well one way to do it is to use TEXT graphics.„ „'There are several considerations to take into account.„'These include:„ „'1.  The maximum number of lines (rows) of text to be„'    printed within the box is 21 since we require one„'    row for the top and bottom of the box PLUS a blank„'    line at the top and bottom to look nice.„ „'2.  Similarly the maximum width of a character line„'    is 76 characters (columns)(eliminating 2 for the„'    sides of the box and 2 more for blank spaces at„'    either side.„ „'3.  We shall assume the TEXT file is a sequential file.„'    and we have an 80 column screen.„ „ „'   ***** STEP # 1......develope a BOX Subroutine *****„ „        DECLARE SUB BOX (H!, W!, R!, C!)„ „'       This statement is at start of the main program„ „'       H is the height of the box in rows„'       W is the width of the box in columns„'       R is the row of the upper LHS of the box„'       C is the column of the upper LHS of the box„ „ „'   ***** STEP #2  -  Input the text file, count number of„'                     lines and determine the maximum width„'                     the lines.„ „        SCREEN 0: WIDTH 80„        DIM TEXT$(25)            ' ARBITARY 25 LINES OF TEXT„      „START:„        CLS„        LINEMAX = 0: COLUMNMAX = 0„        LOCATE 9, 19„        PRINT "Enter the filename of the text to be boxed"„        LOCATE 11, 35„        LINE INPUT A$             ' you should make„                                  ' this bulletproof„        „        OPEN A$ FOR INPUT AS #1   ' DITTO for this as well„ „        DO WHILE NOT EOF(1)„           INPUT #1, B$„           LINEMAX = LINEMAX + 1„           IF LINEMAX > 21 THEN     ' Too many lines„              LINEMAX = LINEMAX - 1„              EXIT DO„           END IF„           CMAX = LEN(B$)            ' You should check to see„                                     ' if it is over 76 chars„ „           IF CMAX > COLUMNMAX THEN COLUMNMAX = CMAX„           TEXT$(LINEMAX) = B$„        LOOP„        CLOSE #1„ „'   ******* STEP #3 - Calculate the H, W, R, C values ******„ „'       Hopefully this will centre the box in the screen„ „        H = LINEMAX + 4          ' We add 4 to take in the lines„                                 ' and spaces of the box„ „        W = COLUMNMAX + 4        ' Add 4 for the 4 extra box chars„ „        R = INT((25 - H) / 2)„        C = INT((80 - W) / 2)„ „        CLS„        CALL BOX(H, W, R, C)     ' Draw the box„ „        FOR I = 1 TO LINEMAX„           LOCATE R + I + 1, C + 2   ' Print text to box„           PRINT TEXT$(I);„        NEXT I„ „        LOCATE 25, 1: PRINT "Do it again <Y/N>? ";„        DO                           ' Do it again?„           A$ = INKEY$„           IF A$ = "Y" OR A$ = "y" THEN EXIT DO„           IF A$ = "N" OR A$ = "n" THEN END„        LOOP„        GOTO START„ „'You should improve it by making the stages bulletproof„'and able to handle file with over 21 lines.„„SUB BOX (H, W, R, C)„ „'       MAKE A BOX SUBROUTINE (TEXT FORMAT)„'       H = HEIGHT; W = WIDTH; R = UPPER ROW; C = LHS COLUMN„ „        LOCATE R, C„        PRINT CHR$(201); STRING$(W - 2, 205); CHR$(187)„        FOR L = 1 TO H - 1„        T = L + R„        LOCATE T, C: PRINT CHR$(186)„        LOCATE T, C + W - 1: PRINT CHR$(186)„        NEXT L„        LOCATE R + H, C„        PRINT CHR$(200); STRING$(W - 2, 205); CHR$(188);„ „END SUB„„Christopher Pinder             MASKED INPUT ROUTINES          comp.lang.basic.misc           12-01-95 (23:15)       QB, QBasic, PB, PDS    172  4131     MASKEDIT.BASREM BIT OF CODE BY C.PINDER - Donated to the PUBLIC DOMAIN„REM DISCLAIMER - If it doesn't work - I didn't say it would„REM Tested with PowerBasic and QBasic„„„REM run this first to get the feel of it, then„REM port the two functions into your own code (if you want to )„„DECLARE FUNCTION getasc%()„DECLARE FUNCTION getusing%(answer$, row%, col%, picture$)„„REM templated input functions„REM getusing% returns an integer corresponding to how the input was„REM terminated, 13 = RET ,27 = ESC, 328 = UP ARROW, 336 = DOWN ARROW„„REM the rule for creating a MASK.„REM Where there's a '~' you can input a character, otherwise you can't„REM This works for embedded spaces too - see examples„REM If you need to use the tilde character you'll have to substitue„REM a character of your choice > 127 or so as the MASK CHAR„REM If you've got the patience, you might want to tidy up the delete„REM for 'ordinary' input you can use all ~'s i.e. "~~~~~~~~~~", 10 chars„REM this code does no TYPE CHECKING, any old char will do„REM if you need type checking, YOU write it„„REM Lets test the blighter !!!!!!!!!!!!!!!!„„CLS„„v = getusing(x$, 1, 1, "~~-~~~-~~~~")„	LOCATE 1, 40: PRINT "x$ = "; x$„„    REM now that x$ is valid, lets make sure a subsequent call won't„    REM bugger it up, we'll edit it a second time !„„v = getusing(x$, 2, 1, "~~-~~~-~~~~")„	LOCATE 2, 40: PRINT "x$ = "; x$„„„x$ = ""„„v = getusing(x$, 3, 1, "~~/~~/~~~~")„	LOCATE 3, 40: PRINT "x$ = "; x$„„x$ = ""„„v = getusing(x$, 4, 1, "ú~~~.~~")„	LOCATE 4, 40: PRINT "x$ = "; x$„„x$ = ""„„v = getusing(x$, 5, 1, "$~~.~~ - ~~%")„	LOCATE 5, 40: PRINT "x$ = "; x$„„x$ = ""„„v = getusing(x$, 6, 1, "Name:~~~~~~~~~~~~~~~~~~~~")„	LOCATE 6, 40: PRINT "x$ = "; x$„„x$ = ""„„v = getusing(x$, 7, 1, "A(~~),B(~~),[~~.~~]")„	LOCATE 7, 40: PRINT "x$ = "; x$„„„END„„„„FUNCTION getasc%„	x$ = ""„    WHILE (LEN(x$) = 0)„		x$ = INKEY$„		WEND„    m% = (LEN(x$) - 1) * 256„    getasc% = ASC(RIGHT$(x$, 1)) + (1 * m%)„END FUNCTION„„FUNCTION getusing% (answer$, row%, col%, picture$)„	imask$ = ""„    FOR i% = 1 TO LEN(picture$)„	temp$ = MID$(picture$, i%, 1)„	IF temp$ = "~" THEN„		imask$ = imask$ + " "„	ELSE„		imask$ = imask$ + temp$„	END IF„    NEXT i%„„	la% = LEN(answer$)„    lp% = LEN(picture$)„    IF la% < lp% THEN„	answer$ = answer$ + RIGHT$(imask$, lp% - la%)„    ELSE„	IF la% > lp% THEN„		answer$ = LEFT$(answer$, lp%)„	END IF„    END IF„„    FOR i% = 1 TO LEN(picture$)„	temp$ = MID$(picture$, i%, 1)„	IF temp$ <> "~" THEN„		MID$(answer$, i%, 1) = temp$„	END IF„	NEXT i%„	done% = 0:„„    spos% = 1„	WHILE spos% < LEN(answer$) AND MID$(picture$, spos%, 1) <> "~"„	spos% = spos% + 1„	WEND„„	DO WHILE NOT done„„	REM rather inelegant 'catch boundary conditions'„	IF RIGHT$(picture$, 1) <> "~" AND spos% = LEN(answer$) THEN„		WHILE spos% > 1 AND MID$(picture$, spos%, 1) <> "~"„			spos% = spos% - 1„        WEND„    END IF„	IF LEFT$(picture$, 1) <> "~" AND spos% = 1 THEN„	WHILE spos% < len(answer$) AND MID$(picture$, spos%, 1) <> "~"„		spos% = spos% + 1„    WEND„    END IF„„	LOCATE row%, col%, 1„	PRINT answer$;„	LOCATE row%, col% + spos% - 1, 1„	x% = getasc%„„	IF x% = 13 OR x% = 27 OR x% = 328 OR x% = 336 THEN„		getusing% = x%: EXIT FUNCTION„	    END IF„„	IF x% > 31 AND x% < 128 THEN„		MID$(answer$, spos%, 1) = CHR$(x%)„	    IF spos% < LEN(answer$) THEN„		spos% = spos% + 1„		WHILE spos% < LEN(answer$) AND MID$(picture$, spos%, 1) <> "~"„			spos% = spos% + 1„			WEND„		END IF„		END IF„„		IF x% = 331 AND spos% > 1 THEN„		spos% = spos% - 1„			WHILE spos% > 1 AND MID$(picture$, spos%, 1) <> "~"„		spos% = spos% - 1„		WEND„		END IF„„„    IF x% = 8 THEN„	MID$(answer$, spos%, 1) = " "„	IF spos% > 1 THEN„		spos% = spos% - 1„        WHILE spos% > 1 AND MID$(picture$, spos%, 1) <> "~"„		spos% = spos% - 1„		WEND„		END IF„	END IF„„		IF x% = 333 AND spos% < LEN(answer$) THEN„		spos% = spos% + 1„			WHILE spos% < LEN(answer$) AND MID$(picture$, spos%, 1) <> "~"„		spos% = spos% + 1„		WEND„		END IF„	LOOP„END FUNCTION„„Kurt Kuzba                     K.I.S.S. EDITOR                FidoNet QUIK_BAS Echo          12-02-95 (00:00)       QB, QBasic, PDS        967  24018    KISSED.BAS  '_|_|_|   KISSED.BAS„'_|_|_|   Keep It Simple, Stupid EDitor  [ Qbasic / QuickBasic ]„'_|_|_|   Released to the   PUBLIC DOMAIN   by Kurt Kuzba  (12/02/95)„  CLEAR ' $DYNAMIC„  TYPE TXT„    L AS STRING * 80„  END TYPE„  TYPE PARMS„    INS AS INTEGER„    TOP AS INTEGER„    LIN AS INTEGER„    CRS AS INTEGER„    TOT AS INTEGER„    MLA AS INTEGER„    MCA AS INTEGER„    MLZ AS INTEGER„    MCZ AS INTEGER„    WID AS INTEGER„  END TYPE„  DIM SHARED D0(800) AS TXT„  DIM SHARED D1(800) AS TXT„  DIM SHARED D2(800) AS TXT„  DIM SHARED CFG(3) AS PARMS„  DIM SHARED DOC$(6)„  DOC$(1) = COMMAND$„  DOC$(2) = ""„  DOCINIT 0„  DOCINIT 1„  DOCINIT 2„  DOC$(4) = ""„  DOC$(5) = "INS"„  IF DOC$(1) <> "" THEN„    DOCOPN DOC$(1), 1„  ELSE„    DOC$(1) = "text1.txt"„  END IF„  ED% = 1„  WHILE ED% <> 0„    ED% = EDDOC%(ED%)„  WEND„„  COLOR 2, 0„  CLS„  SYSTEM„WHATTHE:„  DOC$(3) = STR$(ERR)„RESUME NEXT„„REM $STATIC„'„SUB ALARM„  FOR T% = 0 TO 25„    SOUND 2200 + 2 * T%, .1„    SOUND 2225 + T%, .05„  NEXT„END SUB„„SUB CHECKMARK (D%, SH%)„  IF SH% THEN„    IF CFG(D%).MCA = 0 THEN„      CFG(D%).MLA = CFG(D%).LIN„      CFG(D%).MLZ = CFG(D%).LIN„      CFG(D%).MCA = CFG(D%).CRS„      CFG(D%).MCZ = CFG(D%).CRS„    END IF„   ELSE„    CFG(D%).MCA = 0„  END IF„END SUB„„SUB CLIPBOARD„  CFG(0).LIN = 0„  CFG(0).CRS = 1„  K% = 0„  DOC$(0) = "CLIPBOARD    [ESC] TO EXIT"„  WHILE K% <> 27„    L% = CFG(0).LIN„    CFG(0).MCA = 1„    CFG(0).MCZ = 80„    CFG(0).MLA = L%„    CFG(0).MLZ = L%„    SHOWDOC 0„    INFOBAR 0„    K% = GETKEY%„    SELECT CASE K%„       CASE -71                                                   '__HOME*„      CFG(0).LIN = 0„      CFG(0).TOP = 0„       CASE -79                                                    '__END*„      L% = CFG(0).TOT - 23„      IF L% < 0 THEN L% = 0„      CFG(0).TOP = L%„      CFG(0).LIN = CFG(0).TOT - 1„CASE -73:„      IF L% <> 0 THEN„        C% = L% - 24„        CFG(0).LIN = -C% * (C% >= 0)„        C% = CFG(0).TOP - 24„        CFG(0).TOP = -C% * (C% >= 0)„      END IF„       CASE -81                                              '__PAGE DOWN*„      T% = CFG(D%).TOT - 1„      P% = T% - 23„      L% = L% + 24„      IF L% <= (T% + 23) THEN„        IF L% > T% THEN L% = T%„        CFG(0).LIN = L%„        L% = CFG(0).TOP + 24„        IF L% > P% THEN L% = P%„        CFG(0).TOP = -L% * (L% >= 0)„      END IF„       CASE -72                                                '__CRSR UP*„      L% = L% - 1„      IF L% >= 0 THEN„        CFG(0).LIN = L%„        IF CFG(0).TOP > L% THEN CFG(0).TOP = L%„      END IF„       CASE -80                                            '__CURSOR DOWN*„      L% = L% + 1„      IF L% < CFG(0).TOT THEN„        CFG(0).LIN = L%„        T% = CFG(0).TOP„        IF L% > (T% + 23) THEN CFG(0).TOP = T% + 1„      END IF„    END SELECT„  WEND„END SUB„„SUB CUTTEXT (D%)„  IF CFG(D%).MCA = 0 THEN„    T% = MSG%("No Text Marked", "")„    EXIT SUB„  END IF„  ORDERMARK D%, LA%, LZ%, CA%, CZ%„  DOCINIT 0„  R% = CFG(D%).LIN„  I% = LZ% - LA%„  CFG(0).TOT = I% + 1„  FOR L% = 0 TO I%„    CFG(0).LIN = L%„    CFG(D%).LIN = LA% + L%„    T$ = GETLINE$(D%)„    IF L% = I% THEN T$ = LEFT$(T$, CZ%)„    IF L% = 0 THEN T$ = MID$(T$, CA%)„    D0(L%).L = T$„  NEXT„  CFG(D%).LIN = R%„  NOISE„END SUB„„SUB DELETETEXT (D%)„  IF CFG(D%).MCA = 0 THEN„    T% = MSG%("No Text Marked", "")„    EXIT SUB„  END IF„  ORDERMARK D%, LA%, LZ%, CA%, CZ%„  L% = LZ% - LA%„  R% = LA%„  CFG(D%).CRS = CA%„  CFG(D%).MCA = 0„  CFG(D%).LIN = LA%„  T$ = MID$(LEFT$(" " + GETLINE$(D%), CA%), 2)„  CFG(D%).LIN = LZ%„  P$ = RTRIM$(MID$(GETLINE$(D%), CZ% + 1))„  B$ = T$ + P$„  IF LA% = LZ% THEN„    IF B$ = "" THEN„      B$ = DELLINE$(D%)„    ELSE„      PUTLINE D%, B$„    END IF„  END IF„  IF LZ% > LA% THEN„    IF P$ = "" THEN„      LZ% = LZ% + 1„     ELSE„      PUTLINE D%, P$„    END IF„    IF T$ <> "" THEN„      CFG(D%).LIN = LA%„      LA% = LA% + 1„      PUTLINE D%, T$„    END IF„  END IF„  IF LA% < LZ% THEN„    L% = LZ% - LA%„    Z% = CFG(D%).TOT - L%„    CFG(D%).TOT = Z%„    FOR T% = LA% TO Z%„      IF D% = 1 THEN D1(T%).L = D1(T% + L%).L„      IF D% = 2 THEN D2(T%).L = D2(T% + L%).L„    NEXT„    FOR T% = Z% TO 799„      IF D% = 1 THEN D1(T%).L = ""„      IF D% = 2 THEN D2(T%).L = ""„    NEXT„  END IF„  CFG(D%).LIN = R%„  R% = R% - 1„  IF CFG(D%).TOT < 0 THEN CFG(D%).TOT = 1„  IF R% + 25 > CFG(D%).TOT THEN R% = CFG(D%).TOT - 24„  CFG(D%).TOP = R% * -(R% >= 0)„  NOISE„END SUB„„FUNCTION DELLINE$ (D%)„  L% = CFG(D%).LIN„  E% = CFG(D%).TOT - 1„  IF D% = 1 THEN„    DELLINE$ = RTRIM$(D1(CFG(1).LIN).L)„    FOR T% = L% TO E% - 1„      D1(T%).L = D1(T% + 1).L„    NEXT„    D1(E%).L = SPACE$(80)„  END IF„  IF D% = 2 THEN„    DELLINE$ = RTRIM$(D2(CFG(2).LIN).L)„    FOR T% = L% TO E% - 1„      D2(T%).L = D2(T% + 1).L„    NEXT„    D2(E%).L = SPACE$(80)„  END IF„  CFG(D%).TOT = E% - (E% = L%)„  SHOWDOC D%„END FUNCTION„„SUB DOCINIT (D%)„  FOR T% = 0 TO 799„    IF D% = 0 THEN D0(T%).L = ""„    IF D% = 1 THEN D1(T%).L = ""„    IF D% = 2 THEN D2(T%).L = ""„  NEXT„  PARMSINIT D%„END SUB„„SUB DOCOPN (F$, D%)„  ON ERROR GOTO WHATTHE„  T% = 1„  DOC$(3) = "ok"„  IF F$ <> "" THEN OPEN F$ FOR INPUT AS #1„  T$ = "File Error :: " + F$ + " :: Hit a Key"„  IF DOC$(3) <> "ok" THEN„    T% = MSG%(T$, "")„    EXIT SUB„  END IF„  WHILE T% = 1„    L% = 0„    DOCINIT D%„    WHILE ((L% < 800) AND (NOT EOF(1)))„      LINE INPUT #1, P$„      P$ = RTRIM$(P$)„      CFG(D%).LIN = L%„      WHILE INSTR(P$, CHR$(9)) <> 0„        P% = INSTR(P$, CHR$(9))„        T$ = MID$(P$, P% + 1)„        T$ = "   " + T$„        IF P% > 1 THEN T$ = LEFT$(P$, P% - 1) + T$„        P$ = T$„      WEND„      IF LEN(P$) > 79 THEN„        IF L% < 799 THEN„          PUTLINE D%, LEFT$(P$, 79)„          P$ = MID$(P$, 80)„          L% = L% + 1„          CFG(D%).LIN = L%„        END IF„        P$ = LEFT$(P$, 79)„      END IF„      PUTLINE D%, P$„      L% = L% + 1„    WEND„    T$ = "File too large. Load next section (Y/N)?"„    IF (NOT EOF(1)) THEN„      T% = MSG%(T$, "yn")„     ELSE„      T% = 0„    END IF„  WEND„  CLOSE 1„  CFG(D%).TOT = L%„  CFG(D%).LIN = 0„  ALARM„  DOC$(D%) = UCASE$(F$)„END SUB„„FUNCTION EDDOC% (D%)„  DEF SEG = 0„  EDDOC% = D%„  IF D% = 0 THEN GOTO CYCLE„  SHOWDOC D%„  EDIT$ = "YES"„  S$ = SPACE$(80)„  WHILE EDIT$ = "YES"„    T$ = GETLINE$(D%) + S$„    L% = CFG(D%).LIN„    C% = CFG(D%).CRS„    SHOWDOC D%„    INFOBAR D%„    LOCATE L% - CFG(D%).TOP + 2, C%, 1, 13 * CFG(D%).INS, 13„    K% = GETKEY%„    SH% = ((PEEK(&H417) AND 3) <> 0)„    W% = CFG(D%).WID„    IF K% = 9 THEN„      T$ = LEFT$(T$, C% - 1) + SPACE$(9) + MID$(T$, C%)„      K% = 32„      C% = C% + 9„    END IF„    SELECT CASE K%„     CASE 32 TO 254                                               '__TEXT*„      IF CFG(D%).INS <> 0 THEN MID$(T$, C% + 1) = MID$(T$, C%)„      MID$(T$, C%) = CHR$(K%)„      T$ = RTRIM$(T$)„      IF (LEN(T$) > W%) THEN„        P$ = MID$(T$, W% + 1)„        T$ = LEFT$(T$, W%)„        T% = 0„        WHILE T% = 0„          R$ = RIGHT$(T$, 1)„          L% = LEN(T$)„          T% = INSTR("*+\]}:)/- ", R$) - (L% < (W% * .75))„          IF T% = 0 THEN„            P$ = R$ + P$„            T$ = LEFT$(T$, L% - 1)„          END IF„        WEND„        PUTLINE D%, T$„        L% = CFG(D%).LIN„        T% = LEN(T$)„        IF L% < 799 THEN„          CFG(D%).LIN = L% + 1„          INSLINE D%, P$„        END IF„        IF C% > W% AND L% < 799 THEN„          C% = C% - T%„          L% = L% + 1„        END IF„        CFG(D%).LIN = L%„        IF C% > W% AND L% > 788 THEN C% = T%„       ELSE„        PUTLINE D%, T$„      END IF„      CFG(D%).CRS = C% + 1„     CASE 8                                                  '__BACKSPACE*„      L% = CFG(D%).LIN„      T% = LEN(RTRIM$(T$))„      IF (C% = 1) AND (L% = 0) THEN GOTO CYCLE„      IF C% > 1 THEN„        IF T% <> 0 THEN MID$(T$, C% - 1) = MID$(T$, C%) + " "„        CFG(D%).CRS = C% - 1„        PUTLINE D%, T$„       ELSE„        LINECAT D%, L% - 1„      END IF„       CASE -83                                                 '__DELETE*„      T% = LEN(RTRIM$(T$))„      IF C% <= T% THEN„        MID$(T$, C%) = MID$(T$, C% + 1) + " "„        PUTLINE D%, T$„       ELSE„        LINECAT D%, CFG(D%).LIN„      END IF„       CASE -82                                                 '__INSERT*„      T$ = DOC$(6)„      IF SH% THEN„        IF T$ <> "" THEN„          INSLINE D%, T$„          CFG(D%).CRS = 1„        END IF„       ELSE„        CFG(D%).INS = ABS(CFG(D%).INS - 1)„        NOISE„      END IF„     CASE 13                                                     '__ENTER*„      L% = CFG(D%).LIN„      IF L% >= 799 THEN GOTO CYCLE„      IF C% = 1 THEN„        P$ = ""„       ELSE„        P$ = LEFT$(T$, C% - 1)„      END IF„      PUTLINE D%, P$„      CFG(D%).LIN = L% + 1„      INSLINE D%, MID$(T$, C%)„      CFG(D%).CRS = 1„       CASE -61, -38                                       '__ALT/L or F3*„      SAVEQRY D%„      LOADDOC D%„      GOTO CYCLE„       CASE -60, -31                                       '__ALT/S or F2*„      SAVEDOC D%„     CASE 27, -45                       '__ESCAPE or CTRL/X : exit editor*„      EDIT$ = "NO"„       CASE -94                         '__CTRL/F1 : switch to Document 1*„      IF DOC$(1) = "" THEN DOC$(1) = "text1.txt"„      EDDOC% = 1„      GOTO CYCLE„       CASE -95                         '__CTRL/F2 : switch to Document 2*„      IF DOC$(2) = "" THEN DOC$(2) = "text2.txt"„      EDDOC% = 2„      GOTO CYCLE„       CASE -96                                                '__CTRL/F3*„      CLIPBOARD„     CASE 25                                                    '__CTRL/Y*„      DOC$(6) = DELLINE$(D%)„      CFG(D%).CRS = 1„       CASE -71                                                   '__HOME*„      CHECKMARK D%, SH%„      CFG(D%).CRS = 1„      SETMARK D%, SH%„       CASE -79                                                    '__END*„      CHECKMARK D%, SH%„      C% = LEN(RTRIM$(T$)) + 1„      CFG(D%).CRS = -C% * (C% < 81) - 80 * (C% > 80)„      SETMARK D%, SH%„       CASE -119                                             '__CTRL/HOME*„      CHECKMARK D%, SH%„      CFG(D%).CRS = 1„      CFG(D%).LIN = CFG(D%).TOP„      SETMARK D%, SH%„       CASE -117                                              '__CTRL/END*„      CHECKMARK D%, SH%„      C% = CFG(D%).TOP + 23„      T% = CFG(D%).TOT - 1„      IF C% >= T% THEN C% = T%„      CFG(D%).LIN = C%„      T$ = RTRIM$(GETLINE$(D%))„      T% = LEN(T$)„      CFG(D%).CRS = T% - (T% < 80)„      SETMARK D%, SH%„       CASE -132                                          '__CTRL/PAGE UP*„      CHECKMARK D%, SH%„      CFG(D%).TOP = 0„      CFG(D%).LIN = 0„      CFG(D%).CRS = 1„      SETMARK D%, SH%„       CASE -118                                        '__CTRL/PAGE DOWN*„      CHECKMARK D%, SH%„      C% = CFG(D%).TOT„      CFG(D%).TOP = -(C% - 24) * (C% > 23)„      CFG(D%).LIN = C% - 1„      CFG(D%).CRS = 1„      SETMARK D%, SH%„       CASE -73                                                '__PAGE UP*„      CHECKMARK D%, SH%„      IF L% = 0 THEN GOTO CYCLE„      C% = L% - 24„      CFG(D%).LIN = -C% * (C% >= 0)„      C% = CFG(D%).TOP - 24„      CFG(D%).TOP = -C% * (C% >= 0)„      SETMARK D%, SH%„       CASE -81                                              '__PAGE DOWN*„      CHECKMARK D%, SH%„      T% = CFG(D%).TOT - 1„      P% = T% - 23„      L% = CFG(D%).LIN + 24„      IF L% > (T% + 23) THEN GOTO CYCLE„      IF L% > T% THEN L% = T%„      CFG(D%).LIN = L%„      L% = CFG(D%).TOP + 24„      IF L% > P% THEN L% = P%„      CFG(D%).TOP = -L% * (L% >= 0)„      SETMARK D%, SH%„       CASE -72                                                '__CRSR UP*„      CHECKMARK D%, SH%„      L% = L% - 1„      IF L% < 0 THEN GOTO CYCLE„      CFG(D%).LIN = L%„      IF CFG(D%).TOP > L% THEN CFG(D%).TOP = L%„      SETMARK D%, SH%„       CASE -80                                            '__CURSOR DOWN*„      CHECKMARK D%, SH%„      L% = L% + 1„      IF L% >= CFG(D%).TOT THEN GOTO CYCLE„      CFG(D%).LIN = L%„      T% = CFG(D%).TOP„      IF L% > (T% + 23) THEN CFG(D%).TOP = T% + 1„      SETMARK D%, SH%„       CASE -75                                            '__CURSOR LEFT*„      CHECKMARK D%, SH%„      IF C% = 1 THEN GOTO CYCLE„      CFG(D%).CRS = C% - 1„      SETMARK D%, SH%„       CASE -77                                           '__CURSOR RIGHT*„      CHECKMARK D%, SH%„      IF C% > 79 THEN GOTO CYCLE„      CFG(D%).CRS = C% + 1„      SETMARK D%, SH%„       CASE -46                                      '__ALT/C :: CUT TEXT*„      CUTTEXT D%„       CASE -32                                   '__ALT/D :: DELETE TEXT*„      DELETETEXT D%„       CASE -25                                    '__ALT/P :: PASTE TEXT*„      PASTETEXT D%„       CASE -59, -35                               '__ALT/H OR F1 :: HELP*„      HELP„       CASE -115                                             '__CTRL/LEFT*„      CFG(D%).WID = W% + (W% > 10)„       CASE -116                                            '__CTRL/RIGHT*„      CFG(D%).WID = W% - (W% < 79)„    END SELECT„  WEND„  T$ = CHR$(13) + "yn " + CHR$(27)„  SAVEQRY D%„  EDDOC% = -D% * (MSG("Exit KISSED (Y/N)?", T$) > 2)„CYCLE:„  NOISE„  DEF SEG„END FUNCTION„„FUNCTION GETKEY%„  T$ = ""„  WHILE T$ = ""„    T$ = INKEY$„  WEND„  GETKEY% = ASC(T$)„  IF ASC(T$) = 0 THEN GETKEY% = -ASC(MID$(T$, 2))„END FUNCTION„„FUNCTION GETLINE$ (D%)„  GETLINE$ = ""„  IF D% = 1 THEN GETLINE$ = D1(CFG(1).LIN).L„  IF D% = 2 THEN GETLINE$ = D2(CFG(2).LIN).L„END FUNCTION„„FUNCTION GETSTR$ (P$, D$, M%)„  PCOPY 0, 1„  SCREEN , , 1, 1„  L% = 7 + LEN(P$) + M%„  INS% = 1„  Y% = 40 - L% \ 2„  X% = 11„  COLOR 9, 1„  LOCATE X%, Y%„  FOR T% = 1 TO 3„    LOCATE , Y%„    PRINT STRING$(L%, CHR$(176))„  NEXT„  LOCATE X% + 1, Y% + 2„  COLOR 15, 4„  PRINT " "; P$; " ";„  X% = CSRLIN„  Y% = POS(0)„  PRINT SPACE$(M% + 1);„  D$ = LEFT$(D$ + SPACE$(M%), M%)„  B$ = CHR$(29)„  P% = (LEN(RTRIM$(D$)) MOD M%) + 1„  WHILE T% <> 13„    LOCATE , Y%, 0„    COLOR 14, 4„    PRINT D$;„    COLOR 1, 7„    LOCATE , Y% + P% - 1, INS%, 13, 13„    PRINT MID$(D$, P%, 1); B$;„    T% = GETKEY%„    SELECT CASE T%„     CASE 32 TO 127„      IF INS% <> 0 THEN D$ = LEFT$(LEFT$(D$, P%) + MID$(D$, P%), M%)„      MID$(D$, P%) = CHR$(T%)„      IF P% < M% THEN P% = (P% MOD M%) + 1„     CASE 8„      IF P% > 1 THEN MID$(D$, P% - 1) = MID$(D$, P%) + " "„      P% = P% + (P% > 1)„      IF P% = 1 THEN SOUND 1000, .1„     CASE 27„      D$ = ""„      T% = 13„       CASE -82„      INS% = ABS(INS% - 1)„       CASE -83„      MID$(D$, P%) = MID$(D$, P% + 1) + " "„       CASE -75„      P% = ((P% - 2 + M%) MOD M%) + 1„       CASE -77„      P% = (P% MOD M%) + 1„     CASE 25„      D$ = SPACE$(M%)„      P% = 1„       CASE -71„      P% = 1„       CASE -79„      P% = LEN(RTRIM$(D$))„      P% = P% - (P% <> M%)„    END SELECT„  WEND„  SCREEN , , 0, 0„  GETSTR$ = RTRIM$(D$)„END FUNCTION„„SUB HELP„  SCREEN , , 1, 1„  COLOR 11, 1„  CLS„  T$ = STRING$(80, CHR$(177))„  FOR T% = 1 TO 25„    LOCATE T%, 1„    PRINT T$;„  NEXT„  COLOR 14, 0„  LOCATE 3, 7, 0„  PRINT "____NORMAL KEYS_______________"„  LOCATE , 7„  PRINT " Left Arrow     (Cursor Left) "„  LOCATE , 7„  PRINT " Right Arrow   (Cursor Right) "„  LOCATE , 7„  PRINT " Up Arrow         (Cursor Up) "„  LOCATE , 7„  PRINT " Down Arrow     (Cursor Down) "„  LOCATE , 7„  PRINT " Page Up     (Cursor Page UP) "„  LOCATE , 7„  PRINT " Page Down (Cursor Page Down) "„  LOCATE , 7„  PRINT " Home           (Cursor Home) "„  LOCATE , 7„  PRINT " End             (Cursor End) "„  LOCATE , 7„  PRINT " Insert       (Toggle Insert) "„  LOCATE , 7„  PRINT " Delete              (Delete) "„  LOCATE , 7„  PRINT " F1                    (Help) "„  LOCATE , 7„  PRINT " F2               (Load Text) "„  LOCATE , 7„  PRINT " F3               (Save Text) "„  LOCATE , 7„  PRINT " ESCAPE        (EXIT  EDITOR) "„  LOCATE 19, 7„  PRINT "____SHIFT KEYS________________"„  LOCATE , 7„  PRINT " Insert  (Insert CTRL/Y Line) "„  LOCATE , 7„  PRINT "    Any Cursor movement key   "„  LOCATE , 7„  PRINT "   with SHIFT will mark text. "„  LOCATE 3, 45„  PRINT "____CONTROL KEYS______________"„  LOCATE , 45„  PRINT " F1              (Document 1) "„  LOCATE , 45„  PRINT " F2              (Document 2) "„  LOCATE , 45„  PRINT " F3          (View Clipboard) "„  LOCATE , 45„  PRINT " Home              (Page Top) "„  LOCATE , 45„  PRINT " End            (Page Bottom) "„  LOCATE , 45„  PRINT " Page Up           (Text top) "„  LOCATE , 45„  PRINT " Page Down      (Text Bottom) "„  LOCATE , 45„  PRINT " Left Arrow    (-line length) "„  LOCATE , 45„  PRINT " Right Arrow   (+line length) "„  LOCATE , 45„  PRINT " CTRL/Y         (Delete Line) "„  LOCATE 17, 45„  PRINT "____ALT KEYS__________________"„  LOCATE , 45„  PRINT " ALT/H                 (Help) "„  LOCATE , 45„  PRINT " ALT/C    (Copy To Clipboard) "„  LOCATE , 45„  PRINT " ALT/D   (Delete Marked Text) "„  LOCATE , 45„  PRINT " ALT/P      (Paste ClipBoard) "„  LOCATE , 45„  PRINT " ALT/X                 (EXIT) "„  T% = GETKEY%„  SCREEN , , 0, 0„END SUB„„SUB INFOBAR (D%)„  P$ = SPACE$(80)„  MID$(P$, 7) = "l" + MID$(STR$(CFG(D%).LIN + 1), 2)„  MID$(P$, 27) = STR$(CFG(D%).TOT) + " lines"„  MID$(P$, 40) = DOC$(D%)„  MID$(P$, 24) = CHR$(64 + D%)„  MID$(P$, 18) = DOC$(CFG(D%).INS + 4)„  MID$(P$, 13) = "w" + MID$(STR$(CFG(D%).WID), 2)„  LOCATE 1, 1„  MID$(P$, 2) = "c" + MID$(STR$(CFG(D%).CRS), 2)„  COLOR 15, 1„  PRINT P$;„END SUB„„SUB INSLINE (D%, S$)„  L% = CFG(D%).LIN„  IF D% = 1 THEN„    FOR T% = 799 TO L% + 1 STEP -1„      D1(T%).L = D1(T% - 1).L„    NEXT„    D1(CFG(1).LIN).L = S$„  END IF„  IF D% = 2 THEN„    FOR T% = 799 TO L% + 1 STEP -1„      D2(T%).L = D2(T% - 1).L„    NEXT„    D2(CFG(2).LIN).L = S$„  END IF„  IF CFG(D%).TOT < 800 THEN CFG(D%).TOT = CFG(D%).TOT + 1„  SHOWDOC D%„END SUB„„SUB LINECAT (D%, L%)„  R% = CFG(D%).LIN„  CFG(D%).LIN = L% + 1„  P$ = RTRIM$(GETLINE$(D%))„  C% = CFG(D%).CRS„  CFG(D%).LIN = L%„  T$ = GETLINE$(D%)„  IF R% = L% THEN T$ = LEFT$(T$, C% - 1)„  IF R% <> L% THEN„    T$ = RTRIM$(T$)„    CFG(D%).CRS = LEN(T$) + 1„  END IF„  T$ = T$ + P$„  T% = LEN(T$)„  IF T% < 80 THEN P$ = DELLINE$(D%)„  IF LEN(T$) > 79 THEN„    CFG(D%).LIN = L% + 1„    PUTLINE D%, MID$(T$, 80)„  END IF„  CFG(D%).LIN = L%„  PUTLINE D%, LEFT$(T$, 79)„  SHOWDOC D%„END SUB„„SUB LOADDOC (D%)„  DN$ = GETSTR$("Load File?", "", 32)„  IF DN$ <> "" THEN DOCOPN DN$, D%„END SUB„„FUNCTION MSG% (M$, P$)„  M% = LEN(M$)„  P$ = UCASE$(P$)„  PCOPY 0, 1„  SCREEN , , 1, 1„  IF P$ = "" THEN P$ = CHR$(13) + CHR$(27) + " "„  WHILE INKEY$ <> ""„  WEND„  C% = 37 - (M% + 1) \ 2„  LOCATE 10, C%„  COLOR 9, 1„  LOCATE 11, C%, 0„  PRINT STRING$(M% + 6, CHR$(176))„  LOCATE , C%„  PRINT CHR$(176); CHR$(176);„  COLOR 14, 4„  PRINT " "; M$; " ";„  COLOR 9, 1„  PRINT CHR$(176); CHR$(176)„  LOCATE , C%„  PRINT STRING$(M% + 6, CHR$(176))„  ALARM„  T% = 0„  WHILE INSTR(P$, UCASE$(CHR$(T%))) < 1„    T% = GETKEY%„  WEND„  SCREEN , , 0, 0„  MSG% = INSTR(P$, UCASE$(CHR$(T%)))„END FUNCTION„„SUB NOISE„  SOUND 1000, .1„END SUB„„SUB ORDERMARK (D%, LA%, LZ%, CA%, CZ%)„  CA% = CFG(D%).MCA„  LA% = CFG(D%).MLA„  CZ% = CFG(D%).MCZ„  LZ% = CFG(D%).MLZ„  LA& = LA%„  LZ& = LZ%„  LA& = LA& * 80 + CA%„  LZ& = LZ& * 80 + CZ%„  IF LA& > LZ& THEN„    SWAP LA%, LZ%„    SWAP CA%, CZ%„  END IF„END SUB„„SUB PARMSINIT (D%)„  CFG(D%).INS = 1„  CFG(D%).TOP = 0„  CFG(D%).LIN = 0„  CFG(D%).CRS = 1„  CFG(D%).TOT = 1„  CFG(D%).MLA = 0„  CFG(D%).MCA = 0„  CFG(D%).MLZ = 0„  CFG(D%).MCZ = 0„  CFG(D%).WID = 70„END SUB„„SUB PASTETEXT (D%)„  IF CFG(0).TOT = 1 AND RTRIM$(D0(0).L) = "" THEN„    T% = MSG%("No text in Clipboard", "")„    EXIT SUB„  END IF„  L% = CFG(D%).LIN„  R% = L%„  C% = CFG(D%).CRS„  CFG(D%).MCA = 0„  O% = CFG(0).TOT„  I% = O% - 1„  E% = CFG(D%).TOT„  IF (C% > 1) AND (I% = 0) THEN„    T$ = GETLINE$(D%) + SPACE$(80)„    T$ = RTRIM$(LEFT$(T$, C% - 1) + RTRIM$(D0(0).L) + MID$(T$, C%))„    PUTLINE D%, LEFT$(T$, 79)„    IF LEN(T$) > 79 AND L% < 799 THEN„      CFG(D%).LIN = L% + 1„      INSLINE D%, MID$(T$, 80)„      CFG(D%).LIN = L%„    END IF„    NOISE„    EXIT SUB„  END IF„  FOR T% = 799 TO L% STEP -1„    IF T% - 0 >= 0 THEN„      IF D% = 1 THEN D1(T%).L = D1(T% - O%).L„      IF D% = 2 THEN D2(T%).L = D2(T% - O%).L„    END IF„  NEXT„  FOR T% = 0 TO I%„    IF D% = 1 THEN D1(T% + L%).L = D0(T%).L„    IF D% = 2 THEN D2(T% + L%).L = D0(T%).L„  NEXT„  CFG(D%).TOT = E% + O%„  IF E% + O% > 800 THEN CFG(D%).TOT = 800„  NOISE„END SUB„„SUB PUTLINE (D%, T$)„  IF D% = 1 THEN D1(CFG(D%).LIN).L = LEFT$(T$ + SPACE$(80), 80)„  IF D% = 2 THEN D2(CFG(D%).LIN).L = LEFT$(T$ + SPACE$(80), 80)„END SUB„„SUB SAVEDOC (D%)„  ON ERROR GOTO WHATTHE„  DOC$(3) = "ok"„  L% = CFG(D%).LIN„  CFG(D%).LIN = 0„  T% = CFG(D%).TOT„  P$ = RTRIM$(GETLINE$(D%))„  IF P$ = "" AND T% = 1 THEN„    T% = MSG%("No Text", "")„    EXIT SUB„  END IF„  DN$ = DOC$(D%)„  DN$ = GETSTR$("Save As?", DN$, 32)„  IF DN$ = "" THEN„    CFG(D%).LIN = L%„    EXIT SUB„  END IF„  DOC$(D%) = DN$„  OPEN DN$ FOR OUTPUT AS #1„  IF DOC$(3) <> "ok" THEN„    T% = MSG%("File Error :: Hit a Key", "")„   ELSE„    FOR P% = 0 TO T% - 1„      CFG(D%).LIN = P%„      P$ = RTRIM$(GETLINE$(D%))„      IF P$ = "" THEN P$ = " "„      PRINT #1, P$„    NEXT„    CFG(D%).LIN = L%„    ALARM„    CLOSE 1„  END IF„END SUB„„SUB SAVEQRY (D%)„  L% = CFG(D%).LIN„  CFG(D%).LIN = 0„  T% = CFG(D%).TOT„  CFG(D%).LIN = L%„  P$ = RTRIM$(GETLINE$(D%))„  IF P$ = "" AND T% = 1 THEN„    NOISE„    EXIT SUB„  END IF„  T% = MSG%("Save Current Document (Y:N)?", " ny" + CHR$(13))„  IF T% > 2 THEN„    NOISE„    SAVEDOC D%„   ELSE„    ALARM„  END IF„END SUB„„SUB SETMARK (D%, SH%)„  IF SH% = 0 THEN EXIT SUB„  L% = CFG(D%).LIN„  C% = CFG(D%).CRS„  L& = L%„  L& = L& * 80 + C%„  A% = CFG(D%).MLA„  A& = A%„  A& = A% * 80 + CFG(D%).MCA„  CFG(D%).MLZ = L%„  CFG(D%).MCZ = C%„END SUB„„SUB SHOWDOC (D%)„  L% = CFG(D%).LIN„  T% = CFG(D%).TOP„  COLOR 10, 0„  LOCATE , , 0„  IF T% + 23 < L% THEN„    T% = L% - 23„    CFG(D%).TOP = T%„  END IF„  FOR B% = 0 TO 23„    L% = B% + T%„    IF L% > 799 THEN„      LOCATE 2 + B%, 1„      PRINT SPACE$(80);„     ELSE„      SHOWLINE D%, L%, 2 + B%„    END IF„  NEXT„END SUB„„SUB SHOWLINE (D%, L%, S%)„  LA% = 0„  LZ% = 0„  CA% = 0„  CZ% = 0„  IF CFG(D%).MCA <> 0 THEN ORDERMARK D%, LA%, LZ%, CA%, CZ%„  IF D% = 0 THEN T$ = D0(L%).L + SPACE$(80)„  IF D% = 1 THEN T$ = D1(L%).L + SPACE$(80)„  IF D% = 2 THEN T$ = D2(L%).L + SPACE$(80)„  LOCATE S%, 1„  COLOR 10, 0„  IF CA% = 0 OR (LA% > L%) OR (LZ% < L%) THEN„    PRINT LEFT$(T$, 80);„   ELSE„    IF LA% = LZ% THEN„      IF CA% > 1 THEN PRINT LEFT$(T$, CA% - 1);„      COLOR 0, 3„      PRINT MID$(T$, CA%, CZ% - CA% + 1);„      COLOR 10, 0„      PRINT MID$(T$, CZ% + 1, 80 - CZ%);„     ELSE„      IF (L% > LA%) AND (L% < LZ%) THEN„        COLOR 0, 3„        PRINT LEFT$(T$, 80);„       ELSE„        IF L% = LA% THEN„          IF CA% > 1 THEN PRINT LEFT$(T$, CA% - 1);„          COLOR 0, 3„          PRINT MID$(T$, CA%, 81 - CA%);„         ELSE„          COLOR 0, 3„          PRINT LEFT$(T$, CZ%);„          COLOR 10, 0„          PRINT MID$(T$, CZ% + 1, 80 - CZ%);„        END IF„      END IF„    END IF„  END IF„END SUB„„Dave Gjessing                  ASCII HELL                     dgjess@freenet.columbus.oh.us  10-22-95 (00:00)       QB, QBasic, VBDOS      42   855      ASKYHELL.BAS'file ASKYHELL.BAS  DG - 10/22/95„'Qbasic, VBDOS„'have a few too many beers and fart around trying to write something„'that you can't remember why you started, and this is what happens...„'„'(comments available ONLY with the * professional version)„CLS„F = 0„B = 0„Y = 1„X = 1„Q = 9„top:„COLOR F, B„M = VAL(MID$(TIME$, 5, 1))„F = VAL(RIGHT$(TIME$, 1))„IF F > 8 THEN F = F + 1„IF F > 15 THEN F = 0„B = VAL(MID$(TIME$, 7, 1))„IF B > 8 THEN B = B + 1„IF B > 15 THEN B = 0„IF B = F THEN B = B + M„LOCATE Y, X„Y = Y + B + 1„IF Y > 25 THEN Y = 1„X = X + M / Y + M„IF X > 80 THEN X = 1„IF X = 5 AND Y = 6 THEN F = 1: B = 1: X = 1: Y = 1: Q = 1„IF B < 1 THEN B = 1„Q = Q + F * 5 / B„IF Q > 255 THEN Q = 8„PRINT CHR$(Q);„cutitout$ = INKEY$„IF cutitout$ = "c" THEN GOTO last„GOTO top„last:„COLOR 7, 0„CLS„END„'* he he :)„„„Hauke Daempfling               SUPER TEXT PACKER              hcd@berlin.snafu.de            01-04-96 (00:58)       QB, QBasic, PDS        107  5023     TEXTPACK.BASDECLARE SUB PackTxt (text$)„' Super Text/String Packer/Unpacker for QB4.5„'     Originally by Greg Estabrooks„'  Slightly changed by Hauke Daempfling„„'(small note: all documentation is by Hauke :) )„„'This program (or rather the PackTxt sub) packs/unpacks„' strings to about 52% of their original size. All I can say is„' that this is one of the best code snippets I've ever seen. :)„' Actually, it's brilliant :).„„' I changed it from its original version in the following ways:„' 1) The sub adds CHR$(255) to a packed string to indicate that„'    it is packed. (For automatic packing/unpacking)„' 2) The sub checks if the values of the characters in the string are„'    between 32 and 127 to reduce errors while packing.„' 3) Last but not least, I've added some documatation.„„'Usage is very simple. Take a string (A$, for example) and call PackTxt:„' A$ = "This is a test string for the text packer."„' PackTxt A$„'The string will be packed and CHR$(255) added to the beginning to indicate„'that it is packed. To unpack a string just call PackTxt again:„' PackTxt A$„'There. That's all there is to it. Have fun :)„„'PackTxt SUB begins here„DEFINT A-Z„'This sub packs strings to about 52% of their original size. The sub„' automatically checks if the string is packed or not and unpacks/packs„' it accordingly. (neat, huh?)„' Don't play around with the dictionary or you can lower the packing„' ratio (when I got it there was a single space missing and that„' reduced the ratio by about 10%!).„' NOTE: text$ may only contain ASCII characters with the values 32-127!„SUB PackTxt (text$)„'the commets here are cluttered up... delete them if you want„  „   'The dictionary... it may look like junk, but it is prerry much the heart„   ' of the packer (so don't mess it up :) )„   d1$ = "  e  as  tinthouerhet anreesr d onn or o i y wo tontyo. neisarte"„   d2$ = "ed,  ctiy  bat snd fal pensestvengitu talehaurllcousa  mf dfoof "„   d3$ = "siril  hmeg om Icehironsasiossbedepe rli Tetel nicho lilprcactut"„   d4$ = "Thpaeceachh wige ebuaisursulmawaotowtsmploI solyee Cunm rtieno S"„   d5$ = "diwhs.rafincademe.irplk  ury Pwoacos gams,duayavucColamowe Aoopu"„   Dict$ = d1$ + d2$ + d3$ + d4$ + d5$„   IF LEN(Dict$) <> 320 THEN              'just to check...„     PRINT "PACKING ERROR: Dictionray has the wrong size"„     EXIT SUB„   END IF„  „   IF NOT LEFT$(text$, 1) = CHR$(255) THEN 'check if the string is packed„     'the string isn't packed so pack it...„     IF LEN(text$) < 4 THEN EXIT SUB 'no use with strings less than 4 chars.„    „     FOR a = 1 TO LEN(text$)              'check if there are any characters„       v = ASC(MID$(text$, a, 1))         ' with values out of range (they„       IF v < 32 OR v > 127 THEN EXIT SUB ' _cannot_ be packed otherwise)„     NEXT a„    „     DO„      „       cnt = cnt + 1               'read pointer in text$„       char$ = MID$(text$, cnt, 2) 'characters to be checked for in Dict$„      „       IF cnt = LEN(text$) THEN    'if the end of the string has been reached„         text$ = CHR$(255) + temp$ + CHR$(ASC(MID$(text$, cnt, 1)) - 32)„         EXIT SUB                   '^^^^ add the last character„       END IF„      „       xx = 1 'read pointer in Dict$„ReDo:„       x = INSTR(xx, Dict$, char$)4;1;120;1;0xp„       IF x THEN           'if the characters from text$ are in Dict$„         IF (x \ 2) = (x / 2) THEN 'if the instr of the characters can't be„           xx = x + 1              ' divided by 2 then look again (it needs„           GOTO ReDo               ' to be divided so it can be packed)„         END IF„         temp$ = temp$ + CHR$((x \ 2) + 96) 'add the instr of the characters„         cnt = cnt + 1                      ' in Dict$ to temp$ (note that„              '^^^ characters shouldn't     ' it's stored so that it's more„                 ' be compressed twice      ' than 95)„       ELSE„         'if the characters aren't found store the first character„         '(note that it's less than 95 and that cnt is only moved up _1_)„         temp$ = temp$ + CHR$(ASC(MID$(text$, cnt, 1)) - 32)„       END IF„     LOOP WHILE cnt < LEN(text$)„     text$ = CHR$(255) + temp$ 'copy temp$ into text$ and add CHR$(255)„     EXIT SUB                  ' to indicate a packed string„   ELSE„     'text$ is packed so unpack it„     comp$ = RIGHT$(text$, LEN(text$) - 1) 'remove CHR$(255)„     text$ = ""                            're-init text$„     FOR x = 1 TO LEN(comp$)„       char = ASC(MID$(comp$, x, 1))„       IF char > 95 THEN 'if char > 95 then char is the instr of the„                         ' unpacked characters in Dict$, remember?„         text$ = text$ + MID$(Dict$, (char - 96) * 2 + 1, 2)„       ELSE 'if the characters weren't found in Dict$ they were stored„            ' with a value less than 95 (most are found, though)„         text$ = text$ + CHR$(ASC(MID$(comp$, x, 1)) + 32)„       END IF„     NEXT x„   END IF„END SUB„Scott Hoopes                   NEW TEXT FONT                  FidoNet QUIK_BAS Echo          03/95 (00:00)          QB, PDS                101  3448     NEWFONT.BAS 'NEWTXT.BAS - by Scott Hoopes Compuserve 73304,274„'placed into the public domain March 1995„„'demonstrates how to create your own characters in text mode„„'the default character for VGA is a 8x16 cell like the following:„'                  00000000„'                  00000000„'                  11111111„'                  11011011„'                  10011001„'                  00011000„'                  00011000„'                  00011000„'                  00011000„'                  00011000„'                  00011000„'                  00011000„'                  01111110„'                  00000000„'                  00000000„'                  00000000„'the above might be how a 'T' is represented.„'for demonstration, we will change the definition of ASCII 255 which by„'default would look like all zeros in the above example.„„'first we need to access BIOS interrupts so the next few lines are„'neccessary„DEFINT A-Z„'$INCLUDE: 'qb.bi'„DIM inregs AS RegTypeX, outregs AS RegTypeX„„'clear the screen and put some ASCII 255's on the screen„CLS„PRINT STRING$(80, 255);                    'so we can see it„„DIM holder AS STRING * 16   'this is where we put our new ASCII 255„					   'must be a multiple of 16 bytes since„					   'each character is 16 bytes long„„'now we develop a new character to replace ASCII 255„'                  00000000  0„'                  00000000  0„'                  00011000  24„'                  00100100  36„'                  01011010  90„'                  10100101  165„'                  10100001  161„'                  10100001  161    <-- these are the numbers we must„'                  10100101  165        put in 'holder' to represent„'                  01011010  90         our new char„'                  00100100  36„'                  00011000  24„'                  00000000  0„'                  00000000  0„'                  00000000  0„'                  00000000  0„„DEF SEG = VARSEG(holder)      'set default segment to that of our„						'new character„						'we must poke each of the above values„						'into 'holder'„POKE VARPTR(holder), 0        'VARPTR(holder) is the offset of 'holder'„POKE VARPTR(holder) + 1, 0„POKE VARPTR(holder) + 2, 24„POKE VARPTR(holder) + 3, 36„POKE VARPTR(holder) + 4, 90„POKE VARPTR(holder) + 5, 165„POKE VARPTR(holder) + 6, 161„POKE VARPTR(holder) + 7, 161„POKE VARPTR(holder) + 8, 165„POKE VARPTR(holder) + 9, 90„POKE VARPTR(holder) + 10, 36„POKE VARPTR(holder) + 11, 24„POKE VARPTR(holder) + 12, 0„POKE VARPTR(holder) + 13, 0„POKE VARPTR(holder) + 14, 0„POKE VARPTR(holder) + 15, 0„„DEF SEG                       'reset the default segment to BASIC„„ inregs.ax = &H1100           'BIOS function to load new char definition„ inregs.bx = 16 * 256         '16 bytes/char - for 256 characters„ inregs.cx = 1                'number of characters to change„ inregs.dx = 255              'the character to change„ inregs.es = VARSEG(holder)   'segment of holder„ inregs.bp = VARPTR(holder)   'offset of holder„ CALL INTERRUPTX(&H10, inregs, outregs)„„ SLEEP                        'so we see it until a key press„„„'now we must reset the video state so the BIOS resumes using the correct„'character definitions„„ inregs.ax = &H3     'BIOS function to reset the video display to 80„				 'cols x 25 lines„ CALL INTERRUPTX(&H10, inregs, outregs)„„END„„David J. Arigan                UUENCODER                      FidoNet QUIK_BAS Echo          02-04-96 (19:14)       QB, QBasic, PDS        39   1362     UUENCODE.BAS'Here is a UUEncoder program I wrote for no particular reason whatsoever.„'It is fairly small and simple (pretty quick also).  Enjoy.„„'David Arigan„„  IF LEN(COMMAND$) = 0 THEN PRINT "Usage: UUENCODE <filename>": END„  file$ = COMMAND$„  IF INSTR(file$, " ") THEN file$ = LEFT$(file$, INSTR(file$, " ") - 1)„  unam$ = file$„  IF INSTR(unam$, ".") THEN unam$ = LEFT$(file$, INSTR(file$, ".") - 1)„  pnam$ = file$„  IF INSTR(pnam$, "\") THEN pnam$ = MID$(pnam$, INSTR(file$, "\") + 1)„  OPEN file$ FOR BINARY AS #1„  IF LOF(1) = 0 THEN„    PRINT "File '"; file$; "' does not exist."„    CLOSE #1: KILL file$: END„  END IF„  OPEN unam$ + ".uue" FOR OUTPUT AS #2„  PRINT #2, "begin 644 " + pnam$„  bl& = 45: fl& = LOF(1): bf$ = SPACE$(bl&)„  WHILE fl&„    IF fl& < bl& THEN bl& = fl&: bf$ = SPACE$(bl&)„    GET #1, , bf$: fl& = fl& - bl&„    IF bl& MOD 3 <> 0 THEN bf$ = bf$ + STRING$(3 - bl& MOD 3, 0)„    FOR i = 1 TO bl& STEP 3„      c1 = ASC(MID$(bf$, i, 1))„      c2 = ASC(MID$(bf$, i + 1, 1))„      c3 = ASC(MID$(bf$, i + 2, 1))„      l$ = l$ + CHR$(c1 \ 4 + 32)„      l$ = l$ + CHR$((c1 * 16 + c2 \ 16 AND &H3F) + 32)„      l$ = l$ + CHR$((c2 * 4 + c3 \ 64 AND &H3F) + 32)„      l$ = l$ + CHR$((c3 AND &H3F) + 32)„    NEXT„    PRINT #2, CHR$(32 + bl&); l$: l$ = ""„  WEND„  PRINT #2, : PRINT #2, "end"„  CLOSE #1, #2„„„David J. Arigan                UUDECODER                      FidoNet QUIK_BAS Echo          02-04-96 (19:14)       QB, QBasic, PDS        63   2310     UUDECODE.BAS'This is the UUDecoder that goes along with my UUEncoding program.  If you„'like them let me know.  If you decide to use either of them (or portions of„'them m in your programs, remember to include my name in the credits. Thanx.„„'David J. Arigan„„  DEFINT A-Z„  IF LEN(COMMAND$) = 0 THEN PRINT "Usage: UUDECODE <filename>": END„  file$ = COMMAND$„  IF INSTR(file$, " ") THEN file$ = LEFT$(file$, INSTR(file$, " ") - 1)„  unam$ = file$„  IF INSTR(pnam$, "\") THEN pnam$ = MID$(pnam$, INSTR(file$, "\") + 1)„  OPEN file$ FOR BINARY AS #1„  IF LOF(1) = 0 THEN„    PRINT "File '"; file$; "' does not exist."„    CLOSE #1: KILL file$: END„  END IF„  CLOSE #1„  OPEN unam$ FOR INPUT AS #1„  WHILE EOF(1) = 0„    LINE INPUT #1, l$: lc = lc + 1„    IF LCASE$(LEFT$(l$, 5)) = "begin" THEN„      n = INSTR(l$, " ")„      IF n <> 0 AND INSTR(n + 1, l$, " ") <> 0 THEN„        onam$ = RTRIM$(MID$(l$, INSTR(n + 1, l$, " ") + 1))„        OPEN onam$ FOR BINARY AS #2„        DO„          LINE INPUT #1, l$: lc = lc + 1„          IF LCASE$(LEFT$(l$, 3)) = "end" THEN success = -1: EXIT DO„          IF LEN(l$) THEN„            ls = (ASC(l$) - 32) MOD 64: o$ = ""„            IF ls < 0 OR ls > 45 OR ls > ((LEN(l$) - 1) * 3 \ 4) THEN„              PRINT "*** Error in line #"; lc; " (Bad length)": EXIT DO„            END IF„            FOR i = 1 TO ls„              p = ((i - 1) \ 3) * 4„              SELECT CASE (i - 1) MOD 3„                CASE 0„                  c% = (ASC(MID$(l$, p + 2)) - 32) * 4„                  c% = c% + (ASC(MID$(l$, p + 3)) - 32) \ 16„                CASE 1„                  c% = ((ASC(MID$(l$, p + 3)) - 32) * 16) AND &HF0„                  c% = c% + (ASC(MID$(l$, p + 4)) - 32) \ 4„                CASE 2„                  c% = ((ASC(MID$(l$, p + 4)) - 32) * 64) AND &HC0„                  c% = c% + (ASC(MID$(l$, p + 5)) - 32)„              END SELECT„              o$ = o$ + CHR$(c)„            NEXT i„            PUT #2, , o$„          END IF„        LOOP UNTIL EOF(1)„        CLOSE #2„        IF success = 0 THEN„          PRINT "*** UUDecoding '"; onam$; " was not succesful."„        ELSE„          PRINT "Finished UUDecoding '"; onam$; "'"„          success = 0„        END IF„      END IF„    END IF„  WEND„  CLOSE #1„Dave Gjessing                  TEXT USER INTERFACE            dgjess@freenet.columbus.oh.us  02-11-96 (18:35)       QB, QBasic, PDS        254  8034     TUI.BAS     DECLARE SUB CommandPointer (firstline%, Col%, BotLimit%, Fgc%, Bgc%, DoLine%)„DECLARE SUB DLBox (TLine%, LCol%, BLine%, RCol%, FieldNo%, border%, Fgc%, Bgc%, shadow%)„DECLARE SUB MenuBar (message%, Fgc%, Bgc%)„„DEFINT A-Z„„'IFACE_06.BAS - a text user interface - Dave Gjessing 1996„'Copy IFACE_06.BAS to [yourprog].BAS, erase the demonstration below,„'and put in your own code instead.„'The demonstration is all black and white, and seems to work fine„'on Hercules, MCGA, and color VGA.„„'demonstration„top:„DLBox 2, 1, 23, 80, 0, 2, 7, 0, 0„MenuBar 1, 7, 0„CommandPointer 3, 3, 22, 7, 0, DoLine%„„SELECT CASE DoLine%„   CASE IS < 100„   LOCATE DoLine%, 5„   PRINT "the pointer is on line "; DoLine%„   SLEEP 2: GOTO top„   CASE 100„   DLBox 10, 25, 14, 55, 0, 1, 7, 0, 1    'single border, shadow„   LOCATE 12, 32: PRINT "page down pressed"„   SLEEP 2: GOTO top„   CASE 200„   DLBox 10, 25, 14, 55, 0, 2, 7, 0, 0    'double border, no shadow„   LOCATE 12, 33: PRINT "page up pressed"„   SLEEP 2: GOTO top„   CASE 601 TO 609„   DLBox 10, 25, 14, 55, 0, 1, 7, 0, 1    'single border, shadow„   LOCATE 12, 33„   DoLineStr$ = STR$(DoLine%)„   PRINT "F"; RIGHT$(DoLineStr$, 1); " key pressed"„   SLEEP 2: GOTO top„   CASE 610„   DLBox 10, 25, 14, 55, 0, 2, 7, 0, 1    'double border, shadow„   LOCATE 12, 33: PRINT "F10 key pressed"„   SLEEP 2: GOTO top„   CASE 900„   CLS : END„   CASE ELSE„   GOTO top„„END SELECT„„SUB CommandPointer (firstline%, Col%, BotLimit%, Fgc%, Bgc%, DoLine%)„'this is where the user reacts to menu choices...„„COLOR Fgc%, Bgc%„DoLine% = firstline%    'set aside the first line (sent with the sub call)„                        'as the upper limit to the list. (Work with DoLine%)„LOCATE firstline%, Col% 'go to the line and column called for in the„                        'subroutine call„PRINT CHR$(16)          'and print the line pointer on the screen„„DO                      'run around in circles awaiting instructions„selection$ = INKEY$„selection$ = UCASE$(selection$)„„'the next two IF's move the pointer up and down...„IF selection$ = CHR$(0) + "H" THEN           'UpArrow„   LOCATE DoLine%, Col%: PRINT CHR$(0)       'first blank out old pointer„   DoLine% = DoLine% - 1                     'move up one line„   IF DoLine% < firstline% THEN DoLine% = BotLimit% 'jump to bottom if at top„   LOCATE DoLine%, Col%                      'go to where directed„   PRINT CHR$(16)                            'print new pointer on screen„   END IF„IF selection$ = CHR$(0) + "P" THEN           'DnArrow„   LOCATE DoLine%, Col%: PRINT CHR$(0)       'cover the last pointer„   DoLine% = DoLine% + 1                     'move down one line„   IF DoLine% > BotLimit% THEN DoLine% = firstline% 'jump to top if at bottom„   LOCATE DoLine%, Col%                      'go to where directed„   PRINT CHR$(16)                            'new pointer„   END IF„„'this IF reacts to the user pressing the ENTER key. The sub ends with a new„'value for DoLine%, equal to the line that the pointer was on.„IF selection$ = CHR$(13) THEN„    DoLine% = DoLine%„    EXIT SUB„    END IF„„'these other IF's return a value for DoLine% which is not a valid screen„'coordinate. It is up to the SELECT CASE statements that follow the line„'that called CommandPointer to determine what to do with the returned value„„IF selection$ = CHR$(0) + CHR$(81) THEN      'page down key„   DoLine% = 100„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(73) THEN      'page up key„   DoLine% = 200„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(59) THEN      'F1 key„   DoLine% = 601„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(60) THEN      'F2 key„   DoLine% = 602„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(61) THEN      'F3 key„   DoLine% = 603„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(62) THEN      'F4 key„   DoLine% = 604„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(63) THEN      'F5 key„   DoLine% = 605„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(64) THEN      'F6 key„   DoLine% = 606„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(65) THEN      'F7 key„   DoLine% = 607„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(66) THEN      'F8 key„   DoLine% = 608„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(67) THEN      'F9 key„   DoLine% = 609„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(68) THEN      'F10 key„   DoLine% = 610„   EXIT SUB„   END IF„IF selection$ = CHR$(27) THEN                'escape key„   DoLine% = 900„   EXIT SUB„   END IF„LOOP„'break out of the loop and return to the calling module with a new variable„'called DoLine%, equal to the line number on screen where the selected item„'was being displayed, or else with a number beyond the screen size (100, 200,„'etc.), which will be used to convey special instructions„END SUB„„SUB DLBox (TLine, LCol, BLine, RCol, FieldNo, border, Fgc, Bgc, shadow)„'DLBOX (DeLuxe Box) is a fancy box sub-routine that includes„'a user-defined background character parameter, single or double-„'line border (or no border), and foreground and background color parameters,„'plus shadow or no shadow option.„'„'The no-border option makes this "box" routine able to replace "background"„'routines.„COLOR Fgc, Bgc„   IF border = 0 THEN    'no border at all„      ULC = FieldNo„      URC = FieldNo„      LLC = FieldNo„      LRC = FieldNo„      HORIZ = FieldNo„      VERT = FieldNo„         END IF„   IF border = 1 THEN   'single line border„      ULC = 218         'upper left corner„      URC = 191         'upper right corner„      LLC = 192         'lower left corner„      LRC = 217         'lower right corner„      HORIZ = 196       'horizontal lines„      VERT = 179        'vertical lines„         END IF„   IF border = 2 THEN   'double line border„      ULC = 201         'ditto all above„      URC = 187„      LLC = 200„      LRC = 188„      HORIZ = 205„      VERT = 186„         END IF„„LOCATE TLine, LCol„PRINT CHR$(ULC) + STRING$(((RCol - LCol) - 1), CHR$(HORIZ)) + CHR$(URC)„FOR x = 1 TO (BLine - TLine) - 1„LOCATE ((TLine + 1) + NextLine), LCol„   NextLine = NextLine + 1„PRINT CHR$(VERT) + STRING$(((RCol - LCol) - 1), CHR$(FieldNo)) + CHR$(VERT);„NEXT x„LOCATE BLine, LCol„PRINT CHR$(LLC) + STRING$(((RCol - LCol) - 1), CHR$(HORIZ)) + CHR$(LRC);„ „„IF shadow = 1 THEN   'for consistancy, use 1 for shadows, 0 for no shadow„   IF BLine > 24 OR RCol > 79 THEN GOTO badshadow„COLOR 7, 0           'shadows are dark„„LOCATE BLine + 1, LCol + 1                 'across the„PRINT STRING$((RCol - LCol), CHR$(176));  'bottom...„ „FOR I = TLine + 1 TO BLine + 1              'on the„LOCATE I, RCol + 1: PRINT CHR$(176);         'right side„NEXT„„END IF„COLOR Fgc, Bgc       'restore original colors„badshadow:„„END SUB„„SUB MenuBar (message, Fgc, Bgc)„COLOR Bgc%, Bgc%                             'nothing but background„LOCATE 1, 1: PRINT STRING$(80, 219);           'color bar 1 at top„LOCATE 24, 1: PRINT STRING$(80, 219);          'color bar 2 at bottom„LOCATE 25, 1: PRINT STRING$(80, 219);          'color bar 3 at very bottom„COLOR Fgc%, Bgc%                             'activate foreground color„progname$ = "IFACE_06.BAS - a text user interface for QBasic, etc."„title1$ = "title for MenuBar 1"„LOCATE 25, (40 - (LEN(progname$) / 2)): PRINT progname$;   'prog name„„IF message% = 1 THEN„    LOCATE 1, 1: PRINT " <ESC> QUIT "; CHR$(4); " arrows & enter to select "; CHR$(4); " <F> keys as needed";„    LOCATE 24, (40 - (LEN(title1$) / 2)): PRINT title1$;„END IF„„IF message% = 2 THEN„END IF„„IF message% = 3 THEN„END IF„„IF message% = 4 THEN„END IF„„IF message% = 5 THEN„END IF„„IF message% = 6 THEN„END IF„„IF message% = 7 THEN„END IF„„IF message% = 8 THEN„END IF„„IF message% = 9 THEN„END IF„„IF message% = 10 THEN„END IF„„END SUB„„The ABC Programmer             TEXT POP-UP BUTTONS            Like the ABC Reader buttons    02-14-96 (11:20)       QB, QBasic, PDS        125  4253     BUTTONS.BAS '========================================„'  Nice looking TEXT Pop-up Buttons„'  Programmed by William Yu  (02-14-96)„'„'  Features:„'    One subroutine call„'    Shadow can be placed on either side„'    Up/Down button position„'    User defined colours (colors USA)„'    Multiple high-lightable characters„'    EASY to use!„'„'  This routine was not used within the„'  ABC Reader v1.00, I programmed this„'  subroutine after.„'„'  You may wish to cut down or abbr. the„'  variables later.  I used the huge„'  variable names for easy reference.„'========================================„„DEFINT A-Z„DECLARE SUB TextButton (Position%, XButton%, YButton%, Button$, ButtonForeColour%, ButtonBackColour%, ButtonHiLightChar%, ShadowColour%, ShadowBackGround%, Shadow%)„DECLARE SUB Pause (Seconds!)„„SCREEN 0, , 0, 0„„COLOR , 1: CLS      ' Create a coloured background for demonstration purposes„„CONST Right = -1    ' Whatever number you want, but RIGHT <> LEFT„CONST Left = 0„CONST Up = -1       ' Whatever number you want, but UP <> DOWN„CONST Down = 0„„X = 35: Y = 11                ' X and Y coordinates of button„HelpButton$ = "~Help (~F~1)"  ' Spaces not required, automatically included„ButtonForeColour = 0          ' Letters colour are BLACK„ButtonBackColour = 7          ' Colour of button is GREY„ButtonHiLightChar = 15        ' High-lighted character is WHITE„ButtonShadowColour = 0        ' Button shadow is DARK GREY„ShadowBackGround = 1          ' Shadow's background colour is BLACK„Shadow = Right                ' Place shadow to the RIGHT of button„„DO       ' Drive user crazy with this loop!„  TextButton Up, X, Y, HelpButton$, ButtonForeColour, ButtonBackColour, ButtonHiLightChar, ButtonShadowColour, ShadowBackGround, Shadow„  Pause .3„  TextButton Down, X, Y, HelpButton$, ButtonForeColour, ButtonBackColour, ButtonHiLightChar, ButtonShadowColour, ShadowBackGround, Shadow„  Pause .4„LOOP UNTIL INKEY$ <> ""„„' Equivalent lines without all the variables:„'„' TextButton Up, 40, 10, "~Help", 0, 7, 15, 8, 0, Right„' TextButton Down, 40, 10, "~Help", 0, 7, 15, 8, 0, Right„„SUB Pause (Seconds!)„„T! = TIMER                        ' Pause routine„WHILE NOT TIMER - T! > Seconds!   ' Delay for how many Seconds!„WEND                              ' WHILE...WEND or DO...LOOP  Whatever„„END SUB„„SUB TextButton (Position, XButton, YButton, Button$, ButtonForeColour, ButtonBackColour, ButtonHiLightChar, ShadowColour, ShadowBackGround, Shadow)„„XCor = XButton„„IF (Shadow = Left) AND (Position = Up) THEN      ' Place shadows on the„  LOCATE YButton, XButton - 1                    ' left side of button„  COLOR ShadowColour, ShadowBackGround„  PRINT "‹";„  LOCATE YButton + 1, XButton - 1: PRINT "ﬂﬂ";„END IF„„IF Position = Down THEN        ' This routine removes the shadows„  LOCATE YButton, XButton„  COLOR , ShadowBackGround„  PRINT " ";„  IF Shadow = Right THEN XCor = XCor + 1 ELSE XCor = XCor - 1„  LOCATE YButton + 1, XCor: PRINT " ";„END IF„„LOCATE YButton, XCor„COLOR ButtonForeColour, ButtonBackColour„PRINT " ";              ' Spaces are automatically inserted, remove if desired„„Length = LEN(Button$)   ' Number of characters in BUTTON$„FOR I = 1 TO Length     ' Parse them all„  IF MID$(Button$, I, 1) = "~" THEN„    COLOR ButtonHiLightChar„  ELSE„    XCor = XCor + 1„    LOCATE YButton, XCor„    PRINT MID$(Button$, I, 1);„    COLOR ShadowColour, ShadowBackGround„    IF Position = Up THEN„      LOCATE YButton + 1, XCor: PRINT "ﬂ";„    ELSE„      LOCATE YButton + 1, XCor: PRINT " ";„    END IF„    COLOR ButtonForeColour, ButtonBackColour„  END IF„NEXT I„„IF Position = Down THEN        ' This routine also removes the shadows„  LOCATE YButton + 1, XCor + 1„  COLOR ShadowColour, ShadowBackGround„  PRINT " ";„  IF Shadow = Left THEN„    LOCATE YButton, XCor + 2: PRINT " ";„  END IF„END IF„„COLOR ButtonForeColour, ButtonBackColour„LOCATE YButton, XCor + 1„PRINT " ";              ' Spaces are automatically inserted, remove if desired„„IF (Shadow = Right) AND (Position = Up) THEN„  COLOR ShadowColour, ShadowBackGround„  PRINT "‹";„  LOCATE YButton + 1, XCor + 1: PRINT "ﬂﬂ";„END IF„„END SUB„„Alexander Podkolzin            SIMPLE FILE BROWSER            APP@nw.sbank.e-burg.su         02-29-96 (14:39)       PB32                   267  7463     BRWSFILE.BAS'--------------------------------------------------------------------------„' Simple File Browser. Author: Alexander Podkolzin <APP@nw.sbank.e-burg.su>„' Use it as you want...„' PowerBASIC 3.2„'--------------------------------------------------------------------------„$CPU 8086„$OPTIMIZE SIZE„$COMPILE EXE„$DEBUG MAP OFF„$DEBUG PBDEBUG OFF„$LIB ALL       OFF„$ERROR ALL     OFF„$COM    0„$STRING 4„$STACK  2048„$SOUND  1„$DIM ARRAY„$DYNAMIC„$OPTION CNTLBREAK OFF„'--------------------------------------------------------------------------„  %MaxLines = 5000                      ' Max strings to show„  %MaxLen=240                           ' Max LEN of a string„'„  DEFINT a-z„  DIM txt$(%MaxLines)„'„  InsKey$=CHR$(0,82)                    ' Key codes„  Enter$=CHR$(13)„  Esc$ = CHR$(27)„  Home$ = CHR$(0,71)„  PgUp$ = CHR$(0,73)„  EndKey$ = CHR$(0,79)„  PgDn$ = CHR$(0,81)„  Up$ = CHR$(0,72)„  Down$ = CHR$(0,80)„  LeftKey$ = CHR$(0,75)„  RightKey$ = CHR$(0,77)„  CtrlPgUp$ = CHR$(0,132)„  CtrlPgDn$ = CHR$(0,118)„  CtrlHome$ = CHR$(0,119)„  CtrlEnd$ = CHR$(0,117)„'„  Twin%=1                               ' Win type„  xb%=1 : yb%=2 : xe%=80 : ye%=24       ' Edit window coordinates„'„  ct%=7                                 ' Main colors„  cb%=0                                 '„'„  FileName$ = COMMAND$                  ' File to edit„'„  IF NOT FileExists(FileName$) THEN„     PRINT "Command line <FileName> not found..."„     BEEP„     END„  END IF„'„  src% = FREEFILE„  OPEN FileName$ FOR INPUT AS src%„  i%=0„  DO WHILE EOF(src%)=0 AND i% < %MaxLines„     INCR i%„     LINE INPUT #src%,txt$(i%)„     IF txt$(i%)="" THEN txt$(i%)=" "„     REPLACE CHR$(9) WITH "        " IN txt$(i%)„  LOOP„  CLOSE src%„  nlines%=i%„'„  COLOR 0,7„  LOCATE 1,1„  PRINT SPACE$(80);„  LOCATE 1,4„  PRINT "File = ";FileName$;„  LOCATE 25,1„  PRINT SPACE$(80);„'„  COLOR ct%,cb%„'„  lpage%=ye%-yb%-1„  CALL win(twin%,xb%,yb%,xe%,ye%,ct%,cb%)„  Aprint 3,ye%,"¥     :   =   √"„'„  begx%=1„  begy%=1„  endy%=MIN(lpage%,nlines%)„  CurY%=1„  CurX%=1„  GOSUB ShowText„  GOSUB ShowCursor„  DO„     GOSUB ShowCursor„     WHILE NOT INSTAT: WEND             ' begy% - first line to show,„     IF nlines%<1 THEN EXIT LOOP        ' endy% - last line to show (array)„     k$=INKEY$                          ' CurY%  - the cursor bar line„     SELECT CASE k$                     ' lpage%- length of window (page)„        CASE InsKey$„           : ITERATE LOOP„        CASE Esc$„           : CurY%=0 : begy%=1:EXIT LOOP„        CASE Enter$„           : EXIT LOOP„        CASE Home$„           : CurX%=2 : begx%=1„        CASE EndKey$„           : l%=LEN(txt$(begy%+CurY%-1))„           : CurX%=MIN(l%+1,78)+1„           : endx%=MAX(l%+1,78)+1„           : begx%=endx%-78„        CASE Up$„           IF CurY%>1 THEN„              DECR CurY%„           ELSE„              begy%=begy%-1„              endy%=endy%-1„           END IF„        CASE Down$„           IF CurY%<lpage% THEN„              INCR CurY%„           ELSE„              begy%=begy%+1„              endy%=endy%+1„           END IF„        CASE LeftKey$„           IF CurX%>2 THEN„              DECR CurX%„           ELSE„              begx%=begx%-1„              IF begx%<1 THEN begx%=1„           END IF„        CASE RightKey$„           IF CurX% < 79 THEN„              INCR CurX„              Show=0„           ELSE„              INCR begx„              IF begx >%MaxLen-79 THEN begx=%MaxLen-79„           END IF„        CASE PgUp$„           : begy%=begy%-lpage%„           : endy%=endy%-lpage%„        CASE PgDn$„           : begy%=begy%+lpage%„           : endy%=endy%+lpage%„        CASE CtrlPgUp$„           : begy%=1„           : endy%=begy%+lpage%-1„           : CurX%=2„           : CurY%=1„        CASE CtrlPgDn$„           : endy%=nlines%„           : begy%=endy%-lpage%+1„           : CurX%=2„           : CurY%=21„        CASE CtrlHome$„           : CurY%=1„        CASE CtrlEnd$„           : CurY%=21„        CASE ELSE„           : k$=""„     END SELECT„     GOSUB ShowText„  LOOP„  CLS„  END„'--------------------------------------------------------------------------„„ShowText:„  CALL Numerer(nlines%,lpage%,begy%,endy%)„  GOSUB MakeRuler„  FOR i%=begy% TO endy%„     Aprint xb%+1,yb%+i%-begy%+1,_„     MID$(txt$(i%)+SPACE$(xe%-xb%+1),begx%,78)„  NEXT i%„  RETURN„'--------------------------------------------------------------------------„„ShowCursor:„  LOCATE ye%,4,0„  PRINT RIGHT$("0000"+LTRIM$(STR$(begy%+CurY%-1)),5)„  LOCATE ye%,10,0„  PRINT RIGHT$("00"+LTRIM$(STR$(begx%+Curx%-2)),3)„  IF CurX%< 2 THEN CurX%= 2„  IF CurX%>79 THEN CurX%=79„  LOCATE ye%,14,0„  PRINT RIGHT$("00"+LTRIM$(STR$(SCREEN(CurY%+2,CurX%))),3)„  LOCATE yb%+CurY%,CurX,1„  RETURN„'--------------------------------------------------------------------------„„MakeRuler:„  FOR i%=yb%+1 TO ye%-1„     Aprint xe%,i%,CHR$(177)„  NEXT„  k%=((begy%+CurY%-1)/nlines%)*(ye%-yb%-1)„  IF k%=0 THEN k%=1„  Aprint xe%,yb%+k%,CHR$(219)„  RETURN„'--------------------------------------------------------------------------„  SUB Numerer(nlines%,lpage%,begy%,endy%)„     IF nlines%<=lpage% THEN„        begy%=1„        endy%=nlines%„        EXIT SUB„     END IF„     IF begy%<1 THEN„        begy%=1„        endy%=begy%+lpage%-1„        EXIT SUB„     END IF„     IF begy%+lpage%-1>=nlines% THEN„        endy%=nlines%„        begy%=nlines%-lpage%+1„        EXIT SUB„     END IF„     endy%=begy%+lpage%-1„  END SUB„'--------------------------------------------------------------------------„  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)„'„     OldColor% = pbvScrnTxtAttr         ' Internal PB variable„     SELECT CASE t%                     ' Window types„'                                       ' (you can make as much types,„'                                       '  as you want):„        CASE 1„           a%=218:b%=196:c%=191         '⁄ƒƒƒƒƒƒƒø„           h%=179:      :d%=179         '≥   1   ≥„           g%=192:f%=196:e%=217         '¿ƒƒƒƒƒƒƒŸ„        CASE 2„           a%=201:b%=205:c%=187         '…ÕÕÕÕÕÕÕª„           h%=186:      :d%=186         '∫   2   ∫„           g%=200:f%=205:e%=188         '»ÕÕÕÕÕÕÕº„        CASE ELSE„           a%=032:b%= a%:c%= a%         '„           h%= a%:      :d%= a%         ' Blanks only„           g%= a%:f%= a%:e%= a%         '„     END SELECT„     COLOR ct%,cb%„     LOCATE yb%,xb%„     PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%);„     FOR i%=yb%+1 TO ye%-1„        LOCATE i%,xb%„        PRINT CHR$(h%)+ SPACE$(xe%-xb%-1) +CHR$(d%);„     NEXT„     LOCATE ye%,xb%„     PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%);„     ct%=OldColor% AND 15               ' restore colors„     cb%=OldColor%\16„     COLOR ct%,cb%„  END SUB„'--------------------------------------------------------------------------„  SUB Aprint(x%,y%,st$)„     ox%=POS(0)„     oy%=CSRLIN„     LOCATE y%,x%,0„     PRINT st$;„     LOCATE oy%,ox%,1„  END SUB„'--------------------------------------------------------------------------„FUNCTION FileExists%(FileName$)„  S$=DIR$(FileName$)„  IF LEN(S$) = 0 THEN„     FileExists% =  0„  ELSE„     FileExists% = -1„  END IF„END FUNCTION„'--------------------------------------------------------------------------„Douglas H. Lusher              80X28 TEXT MODE                FidoNet QUIK_BAS Echo          03-21-96 (16:01)       QB, PDS                30   895      80X28.BAS   ' > How can I put the screen in 80x28 textmode?„„ DEFINT A-Z„ '$INCLUDE: 'qb.bi'„ DIM Reg AS RegType„„ WIDTH , 43          'this is necessary so that BASIC will not„                     '   complain if we attempt to use the„                     '   LOCATE command on a row greater than 25„„ Reg.AX = &H1202                 'set up 400 scan lines„ Reg.BX = &H30„ CALL Interrupt(&H10, Reg, Reg)„ Reg.AX = &H3                    'set up normal text mode„ CALL Interrupt(&H10, Reg, Reg)„ Reg.AX = &H1111                 'load ega character set (8 x 14)„ Reg.BX = 0„ CALL Interrupt(&H10, Reg, Reg)„„ 'show that we now have 28 lines„ Lines% = 28„ FOR Row% = 1 TO Lines%„   LOCATE Row%, 1: PRINT USING "###"; Row%;„ NEXT„ SLEEP„ 'you can increase the value of Lines in the above loop,„ '   but you will see that only 28 appear on screen„„ SCREEN 0: WIDTH 80, 25: CLS„ END„Ethan Winer                    FAST LINE INPUT REPLACEMENT    FidoNet QUIK_BAS Echo          03-24-96 (01:24)       QB, QBasic, PDS        78   3248     BUFIN.BAS   '> Has anybody else been working with or using the Bufin$ routine„'> written by Ethan Winer that was posted a few days ago as a„'> fast substitute for the LINE INPUT command? Has anyone„'> else noticed that it returns an extra blank line at the end„'> of the file unless the final line had no carriage return/line„'> feed at the end? Has anyone found a work-around for this bug?„'> Thanks.„„'No, but I would love to see the code from Bufin$, then maybe I can help„'you out...I missed the code the first time around...! :(„„DEFINT A-Z„FUNCTION BufIn$ (FileName$, Done) STATIC„'********* BUFIN.BAS - fast LINE INPUT replacement„'Copyright (c) 1992 Ethan Winer„„IF NOT Reading THEN            'if the first time through„  Reading = -1                 'show that we're now reading„  Done = 0                     'clear Done just in case„  CR = 0                       'no return found yet.„  CR$ = CHR$(13)               'define for speed later„„  FileNum = FREEFILE           'open the file„  OPEN FileName$ FOR BINARY AS #FileNum„  Remaining& = LOF(FileNum)    'byte count to be read„„  BufSize = 4096               'bytes to read each pass„  Buffer$ = SPACE$(BufSize)    'assume BufSize bytes„END IF„„'---- This is the main outer loop.„DO WHILE Remaining&              'while more in the file„„  IF CR = 0 THEN                 'if no Return was found„    IF Remaining& < BufSize THEN 'read only what remains„      BufSize = Remaining&       'resize the buffer„      IF BufSize < 1 THEN EXIT DO'possible only if EOF 26„      Buffer$ = SPACE$(BufSize)  'create the file buffer„    END IF„    GET #FileNum, , Buffer$      'read a block„    BufPos = 1                   'start at the beginning„  END IF                         '  of that block„„  DO                                 'walk through buffer„    CR = INSTR(BufPos, Buffer$, CR$) 'look for a Return„    IF CR THEN                       'we found one„      SaveCR = CR                    'save where„      BufIn$ = MID$(Buffer$, BufPos, CR - BufPos)„      BufPos = CR + 2                'skip inevitable LF„      EXIT FUNCTION                  'all done for now„    ELSE                             'back up in the file„      '---- If we reached the end of the file and no 13„      '     was found, return what remains in the string.„      IF SEEK(FileNum) >= LOF(FileNum) THEN„        Output$ = MID$(Buffer$, SaveCR + 2)„        '---- Trap a trailing CHR$(26) EOF marker.„        IF RIGHT$(Output$, 1) = CHR$(26) THEN„          Output$ = LEFT$(Output$, LEN(Output$) - 1)„        END IF„        BufIn$ = Output$             'assign the function„        Remaining& = BufSize         'set to fall out„        EXIT DO                      'and exit now„      END IF„      Slop = BufSize - SaveCR - 1    'calc buffer excess„      Remaining& = Remaining& + Slop 'calc file excess„      SEEK #FileNum, SEEK(FileNum) - Slop  'seek to start„    END IF„„  LOOP WHILE CR                'while more in buffer„  Remaining& = Remaining& - BufSize„„LOOP„„Reading = 0                    'we're not reading anymore„Done = -1                      'show that we're all done„CLOSE #FileNum                 'final cleanup„„END FUNCTION„Peter Cooper                   SMOOTH VERTICAL SCROLL         comp.lang.basic.misc           04-08-96 (23:03)       QB, QBasic, PDS        46   965      SCROLLUP.BAS' There may be a small amount of flicker in some speed cases.. if you adjust„' the delay% loop in 'upwholeline' you can eliminate this.. it is set for my„' machine at the mo.. mail me  peter@trenham.demon.co.uk„' DONT EXIT BEFORE ITS FINISHED. your display will look strange , Peco_„„DEF SEG = &HB800„„SCREEN 0„CLS„FOR a% = 1 TO 23„        LOCATE a%„        COLOR a% MOD 15 + 1„        PRINT STRING$(80, CHR$(a% + 64))„NEXT a%„„FOR a% = 1 TO 23„        upwholeline„NEXT a%„DEF SEG„COLOR 15„„SUB scrollup„„' you should've seen this procedure about 10 mins ago.. it was a whole scroll„' routine using pokes etc when I realized all I had to do was this!„„LOCATE 24„PRINT„„END SUB„„SUB textvert (vpos%)„OUT &H3D4, 8„OUT &H3D5, vpos%„END SUB„„SUB upwholeline„FOR a% = 0 TO 15„WAIT &H3DA, 8„textvert a%„FOR delay% = 1 TO 8500: NEXT delay%  ' this is 8500 in PDS and 7800 in QBasic for me„NEXT a%„scrollup„„textvert 0„END SUB„Carl Gorringe                  GET/PUT IN TEXT                FidoNet QUIK_BAS Echo          04-10-96 (11:31)       QB, QBasic, PDS        227  7796     GETPUT.BAS  '>Is it possible to wipe from one screen to another in text mode? (Looks like„'>one screen is raised or pulled off to the side revealing  another screen„'>underneath.)„„'Following is a program that will allow you to GET any portion of the„'Text screen into an array, and then PUT it back anywhere on screen. If„'the image goes off the edge, then it is simply clipped, so I believe you„'can get the effect you are looking for by using them. Enjoy!„„'--- Carl Gorringe --- <carl.gorringe@rhosoft.com>„„'----------------------------------„'  GETPUT.BAS - (c) Carl Gorringe„'----------------------------------„' Released to the public domain„' You may use this or modify it any way you want, just remember„'  to give me credit if you use it in your programs.„„'---- Must Keep All of the Following! ----„„DECLARE SUB TextGetPutLoad ()„DECLARE SUB TextGetPut (Xlen%, Ylen%, SorcSeg%, SorcOff%, SorcSkip%, DestSeg%, DestOff%, DestSkip%)„DECLARE SUB TextGet (X1%, Y1%, X2%, Y2%, Image%())„DECLARE SUB TextPut (X1%, Y1%, Image%())„„COMMON SHARED TextGetPutRoutine%()„„DIM SHARED TextGetPutRoutine%(30)„CALL TextGetPutLoad„„'--------- Begin Program ----------„„' Put Whatever you want here.„' Just remember that the GET/PUT routines ONLY work for„' SCREEN 0; WIDTH 80,25; and Text Page 0„' You can switch to other modes, just don't call these routines in them.„„END„'---------- End Program -----------„„SUB TextGet (X1%, Y1%, X2%, Y2%, Image%())„„' ::: (c) Carl Gorringe 6/13/93 ::: << v2.1 >>„'--------------------------------------------------------„' This gets the text region from (X1%,Y1%) to (X2%,Y2%)„' and stores it in Image%(). Make sure Image%() is a„' DYNAMIC array because this SUB will REDIM it.„' Coordinates start at (1,1) for the upper-left corner.„'--------------------------------------------------------„„ScrWidth% = 80„ScrLength% = 25„„IF X1% < 1 OR X1% > X2% OR Y1% < 1 OR Y1% > Y2% THEN EXIT SUB„„Num% = (X2% - X1% + 1) * (Y2% - Y1% + 1) + 1„REDIM Image%(Num%)„„Image%(0) = X2% - X1% + 1„Image%(1) = Y2% - Y1% + 1„„'<*>--------- Machine Language Varibles ----------<*>„IF X2% > ScrWidth% THEN„	TableSkip% = (X2% - ScrWidth%) * 2„	X2% = ScrWidth%„ELSE„	TableSkip% = 0„END IF„„IF Y2% > ScrLength% THEN„	Y2% = ScrLength%„END IF„„Xcount% = X2% - X1% + 1: Ycount% = Y2% - Y1% + 1„ScrStart% = (ScrWidth% * (Y1% - 1) + (X1% - 1)) * 2„NextLine% = (ScrWidth% * 2) - (Xcount% * 2)„„PageSegment% = &HB800    '-- Screen 0, Page 0 --„TableSegment% = VARSEG(Image%(0))„TableOffset% = VARPTR(Image%(0)) + 4„„CALL TextGetPut(Xcount%, Ycount%, PageSegment%, ScrStart%, NextLine%, TableSegment%, TableOffset%, TableSkip%)„„END SUB„„SUB TextGetPut (Xlen%, Ylen%, SorcSeg%, SorcOff%, SorcSkip%, DestSeg%, DestOff%, DestSkip%)„„' ::: (c) Carl Gorringe 6/13/93 ::: << v1.3 >>„'--------------------------------------------------------„' This Should NOT be Used by itself!„' It should ONLY be used within TextGet() and TextPut()!„'--------------------------------------------------------„„IF TextGetPutRoutine%(0) <> &HBB06 THEN„	CALL TextGetPutLoad„END IF„„'<*>------- Pass Machine Language Arguments -------<*>„„Low% = LBOUND(TextGetPutRoutine%)„DEF SEG = VARSEG(TextGetPutRoutine%(Low%))   '--Set Segment--„P% = VARPTR(TextGetPutRoutine%(Low%))        '--Set Offset--„„POKE (P% + &H2), ASC(LEFT$(MKI$(SorcSeg%), 1))„POKE (P% + &H3), ASC(RIGHT$(MKI$(SorcSeg%), 1))„„POKE (P% + &H5), ASC(LEFT$(MKI$(DestSeg%), 1))„POKE (P% + &H6), ASC(RIGHT$(MKI$(DestSeg%), 1))„„POKE (P% + &H8), ASC(LEFT$(MKI$(DestOff%), 1))„POKE (P% + &H9), ASC(RIGHT$(MKI$(DestOff%), 1))„„POKE (P% + &HB), ASC(LEFT$(MKI$(SorcOff%), 1))„POKE (P% + &HC), ASC(RIGHT$(MKI$(SorcOff%), 1))„„POKE (P% + &HE), ASC(LEFT$(MKI$(Ylen%), 1))„POKE (P% + &H10), ASC(LEFT$(MKI$(Xlen%), 1))„„POKE (P% + &H26), ASC(LEFT$(MKI$(SorcSkip%), 1))„POKE (P% + &H27), ASC(RIGHT$(MKI$(SorcSkip%), 1))„„POKE (P% + &H2B), ASC(LEFT$(MKI$(DestSkip%), 1))„POKE (P% + &H2C), ASC(RIGHT$(MKI$(DestSkip%), 1))„„'<*>--------- Run Machine Language Routine ---------<*>„„CALL ABSOLUTE(P%)„„DEF SEG„„END SUB„„SUB TextGetPutLoad„„' ::: (c) Carl Gorringe 6/13/93 ::: << v1.0 >>„'--------------------------------------------------------„' This only needs to be called once in the beginning of the„' program to store the Assembly language code into the„' global array TextGetPutRoutine%().„'--------------------------------------------------------„„Low% = LBOUND(TextGetPutRoutine%)„DEF SEG = VARSEG(TextGetPutRoutine%(Low%))   '--Set Segment--„P% = VARPTR(TextGetPutRoutine%(Low%))        '--Set Offset--„„'<*>------ Start Assembly Language Code ------<*>„'         --- 41 bytes long ---„„POKE (P% + &H0), &H6                              '  Push ES„POKE (P% + &H1), &HBB                             '  Mov  BX , ????„POKE (P% + &H4), &HBA                             '  Mov  DX , ????„POKE (P% + &H7), &HBF                             '  Mov  DI , ????„POKE (P% + &HA), &HBE                             '  Mov  SI , ????„POKE (P% + &HD), &HB5                             '  Mov  CH , ??„POKE (P% + &HF), &HB1                             '  Mov  CL , ??„POKE (P% + &H11), &H8E: POKE (P% + &H12), &HC3    '  Mov  ES , BX„POKE (P% + &H13), &H26                            ' ES:„POKE (P% + &H14), &H8B: POKE (P% + &H15), &H4     '  Mov  AX ,[SI]„POKE (P% + &H16), &H8E: POKE (P% + &H17), &HC2    '  Mov  ES , DX„POKE (P% + &H18), &H26                            ' ES:„POKE (P% + &H19), &H89: POKE (P% + &H1A), &H5     '  Mov [DI], AX„POKE (P% + &H1B), &H83: POKE (P% + &H1C), &HC6    '  Add  SI ,+02„	POKE (P% + &H1D), &H2„POKE (P% + &H1E), &H83: POKE (P% + &H1F), &HC7    '  Add  DI ,+02„	POKE (P% + &H20), &H2„POKE (P% + &H21), &HFE: POKE (P% + &H22), &HC9    '  Dec  CL„POKE (P% + &H23), &H75: POKE (P% + &H24), &HEC    '  Jnz  &H11„POKE (P% + &H25), &HB8                            '  Mov  AX , ????„POKE (P% + &H28), &H1: POKE (P% + &H29), &HC6     '  Add  SI , AX„POKE (P% + &H2A), &HB8                            '  Mov  AX , ????„POKE (P% + &H2D), &H1: POKE (P% + &H2E), &HC7     '  Add  DI , AX„POKE (P% + &H2F), &HFE: POKE (P% + &H30), &HCD    '  Dec  CH„POKE (P% + &H31), &H75: POKE (P% + &H32), &HDC    '  Jnz  &HF„POKE (P% + &H33), &H7                             '  Pop  ES„POKE (P% + &H34), &HCB                            '  Retf„„'--------------------------------„DEF SEG„„END SUB„„SUB TextPut (X1%, Y1%, Image%())„„' ::: (c) Carl Gorringe 6/13/93 ::: << v2.1 >>„'--------------------------------------------------------„' This puts the image stored in Image%() back to the screen„' with the upper-left corner of the image at (X1%,Y1%).„' Coordinates start at (1,1) for the upper-left corner of„' the screen. If the image goes outside of bounds then it„' will be automatically clipped.„'--------------------------------------------------------„„ScrWidth% = 80„ScrLength% = 25„„X2% = Image%(0) - 1 + X1%„Y2% = Image%(1) - 1 + Y1%„„IF X1% < 1 OR X1% > X2% OR Y1% < 1 OR Y1% > Y2% THEN EXIT SUB„„Num% = (X2% - X1% + 1) * (Y2% - Y1% + 1) + 1„„'<*>--------- Machine Language Varibles ----------<*>„„IF X2% > ScrWidth% THEN„	TableSkip% = (X2% - ScrWidth%) * 2„	X2% = ScrWidth%„ELSE„	TableSkip% = 0„END IF„„IF Y2% > ScrLength% THEN„	Y2% = ScrLength%„END IF„„Xcount% = X2% - X1% + 1: Ycount% = Y2% - Y1% + 1„ScrStart% = (ScrWidth% * (Y1% - 1) + (X1% - 1)) * 2„NextLine% = (ScrWidth% * 2) - (Xcount% * 2)„„PageSegment% = &HB800    '-- Screen 0, Page 0 --„TableSegment% = VARSEG(Image%(0))„TableOffset% = VARPTR(Image%(0)) + 4„„CALL TextGetPut(Xcount%, Ycount%, TableSegment%, TableOffset%, TableSkip%, PageSegment%, ScrStart%, NextLine%)„„END SUB„„Douglas H. Lusher              TEXT EDITOR                    FidoNet QUIK_BAS Echo          03-11-96 (01:10)       QB, PDS                1214 35257    EDITOR.BAS  'A few comments are called for, in no particular order:„'1) this text editor works by loading a file into a string array„'and allowing the user to manipulate it there. The limit on file„'size, then, is the amount of string memory available. In compiled„'form, this will be about 57K. Run in the environment, this will„'be about 40K. I have worked quite hard to prevent "Out of memory"„'errors from crashing the program, but it may not be„'quite perfect yet. You will note a variable named "MemPad"„'at various places in the code. The program always leaves a„'small amount of memory free for use by QB's built-in routines.„'I am working on an editor that will handle much larger file„'sizes, but that code is still very buggy and I will not„'inflict my buggy code on the world.„„'2) when compiled as-is for a stand-alone text editor, it will„'produce about a 56K file. I am working on eliminating all use„'of the LINE INPUT command, and when successful, the compiled„'size should go down about 10K because the floating point emula-„'tion routines will no longer be linked in.„„'3) please understand that I wrote this editor for my own use.„'I needed something for doing mail, small batch files, etc. I„'don't have very much money, so I didn't want to buy something.„'For a while I was using TED, the editor from PC magazine, but„'I do so much of my work in QB and am so accustomed to the way„'the QB editor works that I found using TED to be quite annoying.„'My fingers just naturally wanted to go where they were accustommed„'to for QB. So finally, fancying myself a moderately competent„'programmer, I decided to write an editor for myself that worked„'like QB's. This code is the result. I will listen to suggestions„'for improvement, but please understand that I will make only„'such changes as suit *me*. If you want it to work differently,„'you'll have to rework the code to suit yourself. (Bug reports,„'of course, are always welcome.)„„'4) There are, unfortunately, a dearth of comments, remarks, and„'explanations in the code. I'm sorry. I have worked for quite a„'while on this code and it is very familiar to me, so comments„'were just getting in my way. And I have done everything possible„'to give names to variables and procedures that make clear their„'purpose in the code. I fancy the code is quite readable without„'many comments, but then, as I said, I'm very familiar with it,„'so I'm probably not a good judge.„„'5) The whole trick to doing a text editor is that there are two„'things that you must keep track of: the location of the cursor„'on the screen, and the location of where you are in the file.„'Variables having to do with locations on the screen are given„'names that contain "Row" or "Col" depending on whether they„'refer to a row or a column on the screen. Variables with names„'containing "Ln" or "Line" have to do with the lines in the„'file (the same as the elements of the string array which contain„'the text). Variables whose names contain "Char" refer to„'character positions in the lines of the text. CursRow%, CursCol%„'are the current location of the cursor on the screen. ActLn%„'is the line being edited. ActChar% is the character within that„'line where editing is taking place. Note that the active line„'is copied to a scalar string variable (named ActLn$) for speed„'and ease of reference. Variable names that contain„'the letters "Ptr" are just generic pointers to lines or„'characters. Hopefully, this information will help you to follow„'the flow of the code.„'   These variables control how much of the screen the editor„'covers:„'  TopRow% = 1: BotRow% = 25: LeftCol% = 1: RiteCol% = 80„'these values, of course, make it take the whole screen. Simply„'by changing these values you can edit text on only part of the„'screen if you wish. Note, however, that code assumes that„'dialog boxes can be centered in the editing area of the screen.„'If the screen window for editing is made too small, the dialog„'boxes will be chopped off. So if you want a very small editing„'area, you will have to rework that part of the code. As written,„'the screen window must be at least 72 columns wide and the„'total number of screen rows should not be less than 3.„'Oh, and when you shell out to DOS, it automatically takes the„'whole screen, so changes would have to be made there as well.„„'6) You can load a file from the command line or from within„'the editor. Enter text from the keyboard. The arrow keys„'move the cursor from line to line or character to„'character. Home takes the cursor to the begining of the„'current line, the End key takes it to the end.„'PageUp and PageDn move the cursor the number of lines in the„'editing window. Control+Home takes you to the beginning of the„'file, Control+End takes you to the end. To mark a block, hold„'down a shift key and use the above listed keys to move the cursor„'as desired. When a block is marked, you can delete it using the„'delete key, or Shift+delete deletes it and moves it to the„'clipboard. Text in the clipboard can be inserted anywhere using„'Shift+Insert. If a block is marked, it can be printed by„'pressing Alt+P. A marked block can be saved to a file by„'pressing Alt+S. When no block is marked, pressing Alt+S„'saves the entire file to disk. Pressing Alt+L allows you to„'load a file into the editor. Alt+F allows you to search for„'text in the file. Alt+R displays a ruler on the screen that you„'can move up and down using the arrow keys. Pressing F10 will„'shell you out to DOS. F1 is the help key, for what it's worth.„'Use Alt+X or Alt+Q to quit. Alt+X assumes you will want to„'save the file, while Alt+Q gives you the option of exiting„'without saving the changes you made. I forgot to mention„'the Tab key and the Backspace key, they both work. The insert„'key toggles you between insert mode and overstrike mode. When„'there is a dialog box on screen, you can abort and return to„'the editor by pressing Escape.„„'code for a text editor, written completely in QuickBASIC 4.5„'by Douglas H. Lusher, 03-11-1996„DEFINT A-Z„'$INCLUDE: 'qb.bi'„CONST False = 0, True = NOT False„CONST Black = 0, Blue = 1, Brown = 6, Grey = 7„CONST AltF = -33, AltL = -38, AltP = -25, AltQ = -16„CONST AltR = -19, AltS = -31, AltX = -45„CONST ESC = 27, ENTER = 13, BkSpc = 8, TabKey = 9„CONST F1Key = -59, F10Key = -68„CONST InsertKey = -82, DeleteKey = -83„CONST HomeKey = -71, CtrlHome = -119„CONST EndKey = -79, CtrlEnd = -117„CONST PgUpKey = -73, PgDnKey = -81„CONST UpArrow = -72, DnArrow = -80, LArrow = -75, RArrow = -77„„DIM SHARED TopRow%, BotRow%, LeftCol%, RiteCol%„DIM SHARED ScrnRows%, MidRow%, ScrnWidth%„DIM SHARED FirstLn%, LastLn%, MaxLines%, FirstChar%, MaxChars%„DIM SHARED CursRow%, CursCol%, ActLn%, ActChar%„DIM SHARED FG%, BG%, BoxFG%, BoxBG%„DIM SHARED CursSize%, TabLen%, MemPad%, Null$„„TopRow% = 1: BotRow% = 25: LeftCol% = 1: RiteCol% = 80„ScrnRows% = (BotRow% - TopRow%) + 1„MidRow% = TopRow% + (ScrnRows% \ 2)„ScrnWidth% = (RiteCol% - LeftCol%) + 1„„FirstLn% = 1: LastLn% = 0: MaxLines% = 800„FirstChar% = 1: MaxChars% = 255„„CursRow% = TopRow%: CursCol% = LeftCol%„ActLn% = FirstLn%: ActChar% = FirstChar%„„FG% = Grey: BG% = Black: BoxFG% = Grey: BoxBG% = Brown„IF ColorMonitor% THEN„  CursSize% = 12: BG% = Blue„ELSE„  CursSize% = 7„END IF„TabLen% = 8: Null$ = "": MemPad% = 1024„„DIM Text$(FirstLn% TO MaxLines% + 1)„„ Cmd$ = RTRIM$(COMMAND$)„ Ptr% = INSTR(Cmd$, "/L:")„ IF Ptr% THEN„   Ptr2% = INSTR(Ptr% + 3, Cmd$, " ")„   IF Ptr2% THEN„	L$ = MID$(Cmd$, Ptr% + 3, Ptr2% - (Ptr% + 3))„	IF LEN(L$) THEN MaxLines% = VAL(L$)„	Cmd$ = MID$(Cmd$, 1, Ptr% - 1) + MID$(Cmd$, Ptr2% + 1)„   ELSE„	L$ = MID$(Cmd$, Ptr% + 3)„	IF LEN(L$) THEN MaxLines% = VAL(L$)„	Cmd$ = RTRIM$(MID$(Cmd$, 1, Ptr% - 1))„   END IF„ END IF„ File$ = Cmd$„ IF INSTR(File$, "*") OR INSTR(File$, "?") THEN„   BEEP: PRINT "No wildcards allowed in file specification": END„ END IF„„IF LEN(File$) THEN„  IF FileExists(File$) THEN„    File = FREEFILE„    OPEN File$ FOR INPUT AS File„	 IF LOF(File) THEN„	   LnPtr% = 0„	   DO UNTIL EOF(File)„		LnPtr% = LnPtr% + 1„		IF LnPtr% > MaxLines% THEN„		  BEEP: PRINT "File has too many lines"„		  CLOSE File: END„		END IF„		LINE INPUT #File, Text$(LnPtr%)„		CALL Filter(Text$(LnPtr%))„		IF FRE(Null$) < MemPad% THEN„		  BEEP: PRINT "Not enough memory"„		  CLOSE File: END„		END IF„	   LOOP„	   LastLn% = LnPtr%„	 END IF„    CLOSE File„  ELSE„    IF NOT LegalFileName(File$) THEN„	 BEEP: PRINT "Bad file name": END„    END IF„  END IF„END IF„„SCREEN 0, 1, 0: WIDTH 80„COLOR FG%, BG%, BG%: CLS„„FileChanged% = False„DO„CALL Edit(Text$(), ExitKey%, FileChanged%)„SELECT CASE ExitKey%„  CASE AltS„    IF FileChanged% THEN„	 IF LEN(File$) THEN„	   GOSUB SaveFile„	 ELSE„	   GOSUB GetFileName„	   IF KeyCode% = ENTER THEN GOSUB SaveFile„	 END IF„    END IF„  CASE AltQ„    IF FileChanged% THEN„	 CALL MsgBox("Save file changes? (Y/N) ", "YyNn", KeyCode%)„	 SELECT CASE KeyCode%„	   CASE 89, 121                  '"Y", "y"„		IF LEN(File$) THEN„		  GOSUB SaveFile„		ELSE„		  GOSUB GetFileName„		  IF KeyCode% = ENTER THEN GOSUB SaveFile: EXIT DO„		END IF„	   CASE 78, 110                  '"N", "n"„		EXIT DO„	   CASE ESC„		'do nothing to return to edit mode„	 END SELECT„    ELSE„	 EXIT DO„    END IF„  CASE AltX„    IF FileChanged% THEN„	 GOSUB GetFileName„	 IF KeyCode% = ENTER THEN GOSUB SaveFile: EXIT DO„    ELSE„	 EXIT DO„    END IF„END SELECT„LOOP„CLS : END„„GetFileName:„DO„  CALL InputBox("File name: ", File$, KeyCode%)„  IF KeyCode% = ENTER THEN„    IF LegalFileName(File$) THEN EXIT DO ELSE BEEP„  ELSE 'IF KeyCode% = ESC THEN„    EXIT DO„  END IF„LOOP„RETURN„„SaveFile:„File = FREEFILE„OPEN File$ FOR OUTPUT AS File„  IF LastLn% > 0 THEN„    FOR LnPtr% = FirstLn% TO LastLn%„	 PRINT #File, Text$(LnPtr%)„    NEXT„  END IF„CLOSE File„FileChanged% = False„RETURN„„FUNCTION ColorMonitor%„ColorMonitor% = True„DEF SEG = 0„IF PEEK(&H463) <> &HD4 THEN ColorMonitor% = False„DEF SEG„END FUNCTION„„SUB DrawBox (TopRow%, NumRows%, LCol%, NumCols%)„„Top$ = STRING$(NumCols%, "Õ")„MID$(Top$, 1, 2) = " …": MID$(Top$, NumCols% - 1, 2) = "ª "„Side$ = SPACE$(NumCols%)„MID$(Side$, 1, 2) = " ∫": MID$(Side$, NumCols% - 1, 2) = "∫ "„Bot$ = Top$„MID$(Bot$, 2, 1) = "»": MID$(Bot$, NumCols% - 1, 1) = "º"„„LOCATE TopRow%, LCol%, 0: PRINT Top$„FOR Row% = 3 TO NumRows%„  LOCATE , LCol%: PRINT Side$„NEXT„LOCATE , LCol%: PRINT Bot$;„„END SUB„„SUB Edit (Text$(), KeyCode%, FileChanged%)„'code for a text editor, written completely in QuickBASIC 4.5„'by Douglas H. Lusher, 03-11-1996„„'when marking a block involving multiple lines:„BlkStartLn = 0        'is the starting line of the block„BlkLines = 0          'the number of lines in the block.„				  'If zero, then not in this block marking mode„„'when marking a block of characters within a single line:„BlkStartChar = 0      'this is the starting character„BlkChars = 0          'the number of characters in the block.„				  'If zero, then not in this block marking mode„„Refresh$ = SPACE$(ScrnWidth)       'scratch space„InsertMode = True„LOCATE , , 0, CursSize - 1, CursSize„GOSUB RefreshScreen„DO„  ActLn$ = Text$(ActLn): ActLnLen = LEN(ActLn$)„  LOCATE CursRow, CursCol, 1„  DO WHILE LEN(INKEY$): LOOP„  DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)„  DEF SEG = 0: ShiftByte = PEEK(&H417): DEF SEG„  ShiftPressed = ((ShiftByte AND 3) <> 0)„  KeyCode = ASC(Ky$): IF KeyCode = 0 THEN KeyCode = -ASC(MID$(Ky$, 2))„  SELECT CASE KeyCode„    CASE 32 TO 255, 1 TO 6, 14 TO 27: GOSUB DoLetterKey„    CASE BkSpc: GOSUB DoBackSpaceKey„    CASE TabKey: GOSUB DoTabKey„    CASE ENTER: GOSUB DoCarriageReturn„    CASE InsertKey: GOSUB DoInsertKey„    CASE DeleteKey: GOSUB DoDeleteKey„    CASE UpArrow: GOSUB DoUpArrow„    CASE DnArrow: GOSUB DoDnArrow„    CASE PgUpKey: GOSUB DoPgUpKey„    CASE PgDnKey: GOSUB DoPgDnKey„    CASE LArrow: GOSUB DoLArrow„    CASE RArrow: GOSUB DoRArrow„    CASE HomeKey: GOSUB DoHomeKey„    CASE EndKey: GOSUB DoEndKey„    CASE CtrlHome: GOSUB DoCtrlHome„    CASE CtrlEnd: GOSUB DoCtrlEnd„    CASE F1Key: GOSUB DoHelp„    CASE F10Key: CLS : SHELL: GOSUB RefreshScreen„    CASE AltF: GOSUB FindText„    CASE AltL: GOSUB LoadFile„    CASE AltP: GOSUB DoPrint„    CASE AltR: GOSUB DoRuler„    CASE AltS: IF BlkLines THEN GOSUB SaveLines ELSE EXIT DO„    CASE AltQ, AltX: EXIT DO„    CASE ELSE: BEEP„  END SELECT„LOOP„„EXIT SUB„„DoCarriageReturn:„IF BlkLines OR BlkChars THEN BEEP: RETURN„IF LastLn = MaxLines THEN BEEP: RETURN„IF ActLn < LastLn THEN„  FOR LnPtr = LastLn TO ActLn + 1 STEP -1„    SWAP Text$(LnPtr), Text$(LnPtr + 1)„  NEXT„  Text$(ActLn) = LEFT$(ActLn$, ActChar - 1)„  Text$(ActLn + 1) = MID$(ActLn$, ActChar)„END IF„ActLn = ActLn + 1„ActChar = FirstChar„IF CursRow <> BotRow THEN CursRow = CursRow + 1„CursCol = LeftCol„LastLn = LastLn + 1„GOSUB RefreshScreen„FileChanged = True„RETURN„„DoTabKey:„IF BlkLines OR BlkChars THEN BEEP: RETURN„IF ActLn > MaxLines THEN BEEP: RETURN„TabChars = TabLen - (ActChar MOD TabLen)„IF ActLnLen + TabChars > MaxChars THEN BEEP: RETURN„IF ActChar - 1 + TabChars > MaxChars THEN BEEP: RETURN„IF ActChar <= ActLnLen THEN„  Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + SPACE$(TabChars) + MID$(ActLn$, ActChar)„ELSE„  Text$(ActLn) = ActLn$ + SPACE$((ActChar - ActLnLen - 1) + TabChars)„END IF„ActChar = ActChar + TabChars„IF CursCol + TabChars <= RiteCol THEN„  CursCol = CursCol + TabChars„  GOSUB RefreshLine„ELSE„  GOSUB RefreshScreen„END IF„IF ActLn > LastLn THEN LastLn = ActLn„FileChanged = True„RETURN„„DoDeleteKey:„IF BlkLines THEN„  IF BlkLines > 0 THEN„    ActLn = BlkStartLn„    CursRow = Greater(CursRow - BlkLines, TopRow)„  END IF„  ClipLines = ABS(BlkLines)„  BytesNeeded& = 0„  FOR LnPtr = ActLn TO ActLn + ClipLines - 1„    BytesNeeded& = BytesNeeded& + LEN(Text$(LnPtr)) + 6„  NEXT„  IF BytesNeeded& + MemPad > FRE(Null$) THEN ClipLines = 0: BEEP: RETURN„  REDIM ClipBoard$(ClipLines - 1)„  FOR LnPtr = 0 TO ClipLines - 1„    SWAP ClipBoard$(LnPtr), Text$(ActLn + LnPtr)„  NEXT„  FOR LnPtr = ActLn TO LastLn - ClipLines„    SWAP Text$(LnPtr), Text$(LnPtr + ClipLines)„  NEXT„  BlkLines = 0: ClipChars = 0„  LastLn = LastLn - ClipLines„  IF NOT ShiftPressed THEN ClipLines = 0: ERASE ClipBoard$„  GOSUB RefreshScreen„ELSEIF BlkChars THEN„  IF BlkChars > 0 THEN„    ActChar = BlkStartChar„    CursCol = Greater(CursCol - BlkChars, LeftCol)„  END IF„  ClipChars = ABS(BlkChars)„  ClipBoard$ = MID$(ActLn$, ActChar, ClipChars)„  Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + MID$(ActLn$, ActChar + ClipChars)„  BlkChars = 0: ClipLines = 0„  IF NOT ShiftPressed THEN ClipChars = 0: ClipBoard$ = Null$„  GOSUB RefreshScreen„ELSE 'no blocks marked„  IF ShiftPressed THEN BEEP: RETURN„  IF ActChar <= ActLnLen THEN„    Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + MID$(ActLn$, ActChar + 1)„    GOSUB RefreshLine„  ELSE 'IF ActChar > ActLnLen THEN„    IF ActLn >= LastLn THEN BEEP: RETURN„    IF ActChar > MaxChars THEN BEEP: RETURN„    IF (ActChar - 1) + LEN(Text$(ActLn + 1)) > MaxChars THEN BEEP: RETURN„    Text$(ActLn) = ActLn$ + SPACE$(ActChar - ActLnLen - 1) + Text$(ActLn + 1)„    Text$(ActLn + 1) = Null$„    FOR LnPtr = ActLn + 1 TO LastLn„	 SWAP Text$(LnPtr), Text$(LnPtr + 1)„    NEXT„    LastLn = LastLn - 1„    GOSUB RefreshScreen„  END IF„END IF„FileChanged = True„RETURN„„DoInsertKey:„IF ShiftPressed THEN„  IF ClipLines THEN„    IF LastLn + ClipLines > MaxLines THEN BEEP: RETURN„    BytesNeeded& = 0„    FOR LnPtr = 0 TO ClipLines - 1„	 BytesNeeded& = BytesNeeded& + LEN(ClipBoard$(LnPtr))„    NEXT„    IF BytesNeeded& + MemPad > FRE(Null$) THEN BEEP: RETURN„    IF ActLn <= LastLn THEN„	 FOR LnPtr = LastLn TO ActLn STEP -1„	   SWAP Text$(LnPtr), Text$(LnPtr + ClipLines)„	 NEXT„    END IF„    FOR LnPtr = 0 TO ClipLines - 1„	 Text$(ActLn + LnPtr) = ClipBoard$(LnPtr)„    NEXT„    LastLn = LastLn + ClipLines„    GOSUB RefreshScreen„    FileChanged = True„  ELSEIF ClipChars THEN„    IF ActLn > MaxLines THEN BEEP: RETURN„    IF ActLnLen + ClipChars > MaxChars THEN BEEP: RETURN„    IF ActChar + ClipChars - 1 > MaxChars THEN BEEP: RETURN„    IF ActChar <= ActLnLen THEN„	 Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + ClipBoard$ + MID$(ActLn$, ActChar)„    ELSE„	 Text$(ActLn) = ActLn$ + SPACE$(ActChar - ActLnLen - 1) + ClipBoard$„    END IF„    IF ActLn > LastLn THEN LastLn = ActLn„    GOSUB RefreshLine„    FileChanged = True„  END IF„ELSE 'IF NOT ShiftPressed THEN„  InsertMode = NOT InsertMode„  IF InsertMode THEN„    LOCATE , , , CursSize - 1, CursSize„  ELSE„    LOCATE , , , CursSize \ 2, CursSize„  END IF„END IF„RETURN„„DoBackSpaceKey:„IF BlkLines OR BlkChars THEN BEEP: RETURN„IF ActChar = FirstChar THEN„  IF ActLn = FirstLn THEN BEEP: RETURN„  IF ActLnLen + LEN(Text$(ActLn - 1)) > MaxChars THEN BEEP: RETURN„  ActChar = LEN(Text$(ActLn - 1)) + 1„  Text$(ActLn - 1) = Text$(ActLn - 1) + ActLn$„  Text$(ActLn) = Null$„  FOR LnPtr = ActLn TO LastLn„    SWAP Text$(LnPtr), Text$(LnPtr + 1)„  NEXT„  IF LastLn >= ActLn THEN LastLn = LastLn - 1„  ActLn = ActLn - 1„  IF CursRow <> TopRow THEN CursRow = CursRow - 1„  CursCol = Lesser(ActChar, RiteCol)„  GOSUB RefreshScreen„ELSE 'IF ActChar > FirstChar THEN„  IF ActChar <= ActLnLen + 1 THEN„    Text$(ActLn) = LEFT$(ActLn$, ActChar - 2) + MID$(ActLn$, ActChar)„  END IF„  ActChar = ActChar - 1„  IF CursCol <> LeftCol THEN„    CursCol = CursCol - 1„    GOSUB RefreshLine„  ELSE„    GOSUB RefreshScreen„  END IF„END IF„FileChanged = True„RETURN„„DoLetterKey:„IF BlkLines OR BlkChars THEN BEEP: RETURN„IF ActLn > MaxLines THEN BEEP: RETURN„IF ActChar > MaxChars THEN BEEP: RETURN„IF ActChar <= ActLnLen THEN„  IF InsertMode THEN„    IF ActLnLen = MaxChars THEN BEEP: RETURN„    Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + " " + MID$(ActLn$, ActChar)„  END IF„  MID$(Text$(ActLn), ActChar) = Ky$„ELSE 'IF ActChar > ActLnLen THEN„  Text$(ActLn) = ActLn$ + SPACE$(ActChar - ActLnLen - 1) + Ky$„END IF„ActChar = ActChar + 1„IF CursCol <> RiteCol THEN„  CursCol = CursCol + 1„  GOSUB RefreshLine„ELSE„  GOSUB RefreshScreen„END IF„IF ActLn > LastLn THEN LastLn = ActLn„FileChanged = True„RETURN„„DoUpArrow:„BlkChars = 0„IF ShiftPressed THEN„  IF BlkLines = 0 THEN BlkStartLn = ActLn„  IF ActLn > FirstLn THEN BlkLines = BlkLines - 1„ELSE„  BlkLines = 0„END IF„IF ActLn <> FirstLn THEN„  ActLn = ActLn - 1„  IF CursRow <> TopRow THEN CursRow = CursRow - 1„END IF„GOSUB RefreshScreen„RETURN„„DoDnArrow:„BlkChars = 0„IF ShiftPressed THEN„  IF BlkLines = 0 THEN BlkStartLn = ActLn„  IF ActLn <= LastLn THEN BlkLines = BlkLines + 1„ELSE„  BlkLines = 0„END IF„IF ActLn <= LastLn THEN„  ActLn = ActLn + 1„  IF CursRow <> BotRow THEN CursRow = CursRow + 1„END IF„GOSUB RefreshScreen„RETURN„„DoPgUpKey:„BlkChars = 0„IF ShiftPressed THEN„  IF BlkLines = 0 THEN BlkStartLn = ActLn„  BlkLines = Greater(BlkLines - ScrnRows, FirstLn - BlkStartLn)„ELSE„  BlkLines = 0„END IF„ActLn = Greater(ActLn - ScrnRows, FirstLn)„IF ActLn < CursRow THEN CursRow = TopRow + ActLn - 1„GOSUB RefreshScreen„RETURN„„DoPgDnKey:„BlkChars = 0„IF ShiftPressed THEN„  IF BlkLines = 0 THEN BlkStartLn = ActLn„  BlkLines = Lesser(BlkLines + ScrnRows, (LastLn + 1) - BlkStartLn)„ELSE„  BlkLines = 0„END IF„ActLn = Lesser(ActLn + ScrnRows, LastLn + 1)„IF (LastLn + 1) - ActLn < BotRow - CursRow THEN„  CursRow = Lesser(BotRow - ((LastLn + 1) - ActLn), TopRow + LastLn)„END IF„GOSUB RefreshScreen„RETURN„„DoLArrow:„IF ShiftPressed THEN„  IF BlkLines THEN BEEP: RETURN„  IF BlkChars = 0 THEN BlkStartChar = ActChar„  BlkChars = Greater(BlkChars - 1, FirstChar - BlkStartChar)„ELSE„  BlkLines = 0: BlkChars = 0„END IF„IF ActChar <> FirstChar THEN„  ActChar = ActChar - 1„  IF CursCol <> LeftCol THEN CursCol = CursCol - 1„END IF„GOSUB RefreshScreen„RETURN„„DoRArrow:„IF ShiftPressed THEN„  IF BlkLines THEN BEEP: RETURN„  IF BlkChars = 0 THEN BlkStartChar = ActChar„  IF ActChar <= MaxChars THEN BlkChars = BlkChars + 1„ELSE„  BlkLines = 0: BlkChars = 0„END IF„IF ActChar <= MaxChars THEN„  ActChar = ActChar + 1„  IF CursCol <> RiteCol THEN CursCol = CursCol + 1„END IF„GOSUB RefreshScreen„RETURN„„DoHomeKey:„IF ShiftPressed THEN„  IF BlkLines THEN BEEP: RETURN„  IF BlkChars = 0 THEN BlkStartChar = ActChar„  BlkChars = FirstChar - BlkStartChar„ELSE„  BlkLines = 0: BlkChars = 0„END IF„ActChar = FirstChar„CursCol = LeftCol„GOSUB RefreshScreen„RETURN„„DoEndKey:„IF ShiftPressed THEN„  IF BlkLines THEN BEEP: RETURN„  IF BlkChars = 0 THEN BlkStartChar = ActChar„  BlkChars = (ActLnLen + 1) - BlkStartChar„ELSE„  BlkLines = 0: BlkChars = 0„END IF„LeftChar = ActChar - CursCol + 1„ActChar = ActLnLen + 1„IF ActChar <= LeftChar THEN„  CursCol = Lesser(ActChar, RiteCol)„ELSE„  CursCol = Lesser(ActChar - LeftChar + 1, RiteCol)„END IF„GOSUB RefreshScreen„RETURN„„DoCtrlHome:„BlkChars = 0„IF ShiftPressed THEN„  IF BlkLines = 0 THEN BlkStartLn = ActLn„  BlkLines = FirstLn - BlkStartLn„ELSE„  BlkLines = 0„END IF„ActLn = FirstLn„CursRow = TopRow„GOSUB RefreshScreen„RETURN„„DoCtrlEnd:„BlkChars = 0„IF ShiftPressed THEN„  IF BlkLines = 0 THEN BlkStartLn = ActLn„  BlkLines = (LastLn + 1) - BlkStartLn„ELSE„  BlkLines = 0„END IF„ActLn = LastLn + 1„CursRow = Lesser(BotRow, TopRow + LastLn)„GOSUB RefreshScreen„RETURN„„RefreshScreen:„LOCATE , , 0„LnPtr = ActLn - (CursRow - TopRow)„CharPtr = ActChar - (CursCol - LeftCol)„IF BlkLines THEN„  StartLn = BlkStartLn: StopLn = BlkStartLn + BlkLines„  IF StartLn > StopLn THEN SWAP StartLn, StopLn„  FOR Row = TopRow TO BotRow„    LSET Refresh$ = MID$(Text$(LnPtr), CharPtr, ScrnWidth)„    LOCATE Row, LeftCol„    IF LnPtr >= StartLn AND LnPtr < StopLn THEN„	 COLOR BG, FG: PRINT Refresh$; : COLOR FG, BG„    ELSE„	 PRINT Refresh$;„    END IF„    LnPtr = LnPtr + 1„  NEXT„ELSEIF BlkChars THEN„  StartChar = BlkStartChar: StopChar = BlkStartChar + BlkChars„  IF StartChar > StopChar THEN SWAP StartChar, StopChar„  LCol = Greater(StartChar - CharPtr, 0)„  RCol = StopChar - CharPtr„  FOR Row = TopRow TO BotRow„    LSET Refresh$ = MID$(Text$(LnPtr), CharPtr, ScrnWidth)„    LOCATE Row, LeftCol„    IF LnPtr = ActLn THEN„	 PRINT LEFT$(Refresh$, LCol);„	 COLOR BG, FG„	 PRINT MID$(Refresh$, LCol + 1, RCol - LCol);„	 COLOR FG, BG„	 PRINT MID$(Refresh$, RCol + 1);„    ELSE„	 PRINT Refresh$;„    END IF„    LnPtr = LnPtr + 1„  NEXT„ELSE„  FOR Row = TopRow TO BotRow„    LSET Refresh$ = MID$(Text$(LnPtr), CharPtr, ScrnWidth)„    LOCATE Row, LeftCol„    PRINT Refresh$;„    LnPtr = LnPtr + 1„  NEXT„END IF„RETURN„„RefreshLine:„LSET Refresh$ = MID$(Text$(ActLn), ActChar - CursCol + LeftCol, ScrnWidth)„LOCATE CursRow, LeftCol, 0„IF BlkChars THEN„  StartChar = BlkStartChar: StopChar = BlkStartChar + BlkChars„  IF StartChar > StopChar THEN SWAP StartChar, StopChar„  LCol = Greater(StartChar - CharPtr, 0)„  RCol = StopChar - CharPtr„  PRINT LEFT$(Refresh$, LCol);„  COLOR BG, FG„  PRINT MID$(Refresh$, LCol + 1, RCol - LCol);„  COLOR FG, BG„  PRINT MID$(Refresh$, RCol + 1);„ELSE„  PRINT Refresh$;„END IF„RETURN„„DoHelp:„Temp$ = STR$(ActChar): MID$(Temp$, 1, 1) = ":"„Msg$ = "Cursor" + STR$(ActLn) + Temp$ + " | Bytes free:" + STR$(FRE(Null$))„D = (ScrnWidth - LEN(Msg$)) \ 2 - 4„COLOR BoxFG, BoxBG„CALL DrawBox(MidRow% - 1, 3, LeftCol + D, LEN(Msg$) + 8)„LOCATE MidRow%, LeftCol + D + 4: PRINT Msg$;„DO UNTIL ASC(INPUT$(1)) = ESC: LOOP„Temp$ = Null$: Msg$ = Null$„COLOR FG, BG„GOSUB RefreshScreen„RETURN„„LoadFile:„IF BlkLines OR BlkChars THEN BEEP: RETURN„IF ActLn > MaxLines THEN BEEP: RETURN„CALL InputBox("File name: ", LoadFile$, KeyCode)„GOSUB RefreshScreen„IF KeyCode <> ENTER THEN RETURN„LoadFile$ = LTRIM$(RTRIM$(LoadFile$))„IF LEN(LoadFile$) = 0 THEN RETURN„IF FileExists(LoadFile$) THEN„  FileLines = FileLineCount(LoadFile$)„  IF FileLines = 0 THEN RETURN„  IF LastLn + FileLines > MaxLines THEN„    CALL MsgBox("File has too many lines", Null$, KeyCode)„    GOSUB RefreshScreen: RETURN„  ELSEIF FileSize&(LoadFile$) + MemPad > FRE(Null$) THEN„    CALL MsgBox("Not enough memory", Null$, KeyCode)„    GOSUB RefreshScreen: RETURN„  END IF„ELSE„  BEEP: CALL MsgBox("File not found", Null$, KeyCode)„  GOSUB RefreshScreen: GOTO LoadFile„END IF„„IF ActLn <= LastLn THEN„  FOR LnPtr = LastLn TO ActLn STEP -1„    SWAP Text$(LnPtr), Text$(LnPtr + FileLines)„  NEXT„END IF„File = FREEFILE„OPEN LoadFile$ FOR INPUT AS #File„  FOR LnPtr = ActLn TO ActLn + FileLines - 1„    LINE INPUT #File, FileLn$„    CALL Filter(FileLn$)„    Text$(LnPtr) = FileLn$„  NEXT„  FileLn$ = Null$„CLOSE File„LastLn = LastLn + FileLines„FileChanged = True„GOSUB RefreshScreen„RETURN„„SaveLines:„CALL InputBox("File name: ", SaveFile$, KeyCode)„GOSUB RefreshScreen„IF KeyCode = ENTER THEN„  SaveFile$ = LTRIM$(RTRIM$(SaveFile$))„  IF LEN(SaveFile$) THEN„    IF FileExists(SaveFile$) THEN„	 CALL MsgBox("Specified file already exists: [A]ppend [O]verwrite [C]ancel? ", "AaOoCc", KeyCode)„	 GOSUB RefreshScreen„	 SELECT CASE KeyCode„	   CASE 65, 97: Mode$ = "A": GOSUB DoFileSave„	   CASE 79, 111: Mode$ = "O": GOSUB DoFileSave„	   CASE 67, 99, ESC    'do nothing to cancel the save„	 END SELECT„    ELSE„     IF LegalFileName(SaveFile$) THEN„	   Mode$ = "O": GOSUB DoFileSave„	 ELSE„	   CALL MsgBox("Bad file name", Null$, KeyCode)„	   GOSUB RefreshScreen: GOTO SaveLines„	 END IF„    END IF„  END IF„END IF„RETURN„„DoFileSave:„File = FREEFILE„OPEN Mode$, File, SaveFile$„  StartLn = Lesser(ActLn, BlkStartLn)„  FOR LnPtr = StartLn TO StartLn + ABS(BlkLines) - 1„    PRINT #File, Text$(LnPtr)„  NEXT„CLOSE File„RETURN„„FindText:„IF BlkLines THEN BEEP: RETURN„IF BlkChars THEN„  CharPtr = Lesser(BlkStartChar, BlkStartChar + BlkChars)„  Search$ = MID$(ActLn$, CharPtr, ABS(BlkChars))„  GOSUB Search„ELSE„  CALL InputBox("Find: ", Search$, KeyCode)„  GOSUB RefreshScreen„  IF KeyCode = ENTER THEN„    IF LEN(Search$) THEN GOSUB Search„  END IF„END IF„RETURN„„Search:„Count = 0„LnPtr = ActLn: CharPtr = ActChar„DO„  CharPtr = INSTR(CharPtr, Text$(LnPtr), Search$)„  IF CharPtr THEN„    BlkStartChar = CharPtr„    BlkChars = LEN(Search$)„    ActChar = BlkStartChar + BlkChars„    CursCol = Lesser(LeftCol + ActChar - 1, RiteCol)„    TopLn = ActLn - (CursRow - TopRow)„    ActLn = LnPtr„    CursRow = MidRow„    IF ActLn >= TopLn AND ActLn < TopLn + ScrnRows THEN„	 CursRow = TopRow + (ActLn - TopLn)„    ELSEIF ActLn <= ScrnRows THEN„	 CursRow = TopRow + ActLn - 1„    ELSEIF (LastLn + 1) - ActLn < BotRow - CursRow THEN„	 CursRow = BotRow - ((LastLn + 1) - ActLn)„    END IF„    GOSUB RefreshScreen: EXIT DO„  ELSE„    Count = Count + 1„    IF Count > LastLn THEN„	 CALL MsgBox("Search string not found", Null$, KeyCode)„	 GOSUB RefreshScreen: EXIT DO„    END IF„    LnPtr = LnPtr + 1: IF LnPtr > LastLn THEN LnPtr = FirstLn„    CharPtr = 1„  END IF„LOOP„RETURN„„DoPrint:„IF BlkLines THEN„  StartLn = Lesser(ActLn, BlkStartLn)„  StopLn = StartLn + ABS(BlkLines) - 1„ELSE„  StartLn = FirstLn„  StopLn = LastLn„END IF„FOR LnPtr = StartLn TO StopLn„  LPRINT Text$(LnPtr)„NEXT„BlkLines = 0„GOSUB RefreshScreen„RETURN„„DoRuler:„IF BlkLines OR BlkChars THEN RETURN„Ruler$ = SPACE$(MaxChars)„FOR CharPtr = 1 TO MaxChars„  MID$(Ruler$, CharPtr, 1) = "¬"„  IF CharPtr MOD 5 = 0 THEN MID$(Ruler$, CharPtr) = "≈"„  IF CharPtr MOD 10 = 0 THEN„    MID$(Ruler$, CharPtr - 1) = CHR$(((CharPtr \ 10) MOD 10) + 48)„  END IF„NEXT„Ruler$ = MID$(Ruler$, ActChar - CursCol + LeftCol, ScrnWidth)„„RulerRow = TopRow„DO„  GOSUB PrintRuler„  DO WHILE LEN(INKEY$): LOOP„  DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)„  KeyCode = ASC(Ky$): IF KeyCode = 0 THEN KeyCode = -ASC(MID$(Ky$, 2))„SELECT CASE KeyCode„    CASE UpArrow„	 IF RulerRow > TopRow THEN RulerRow = RulerRow - 1„    CASE DnArrow„	 IF RulerRow < BotRow THEN RulerRow = RulerRow + 1„    CASE PgUpKey„	 IF RulerRow <> TopRow THEN RulerRow = TopRow„    CASE PgDnKey„	 IF RulerRow <> BotRow THEN RulerRow = BotRow„    CASE ESC„	 EXIT DO„    CASE ELSE„	 BEEP„  END SELECT„LOOP„Ruler$ = Null$„GOSUB RefreshScreen„RETURN„„PrintRuler:„GOSUB RefreshScreen„LOCATE RulerRow, LeftCol, 0„COLOR BG, FG: PRINT Ruler$; : COLOR FG, BG„RETURN„„END SUB„„FUNCTION FileExists% (FileName$)„DIM XRegister AS RegTypeX„„'save the current DTA„XRegister.AX = &H2F00„CALL InterruptX(&H21, XRegister, XRegister)„OldDTASeg% = XRegister.ES„OldDTAOff% = XRegister.BX„„'set up a new DTA„DTA$ = SPACE$(43)„XRegister.AX = &H1A00„XRegister.DS = VARSEG(DTA$)„XRegister.DX = SADD(DTA$)„CALL InterruptX(&H21, XRegister, XRegister)„„'get first matching file„Temp$ = FileName$ + CHR$(0)„XRegister.AX = &H4E00„XRegister.CX = &H6„XRegister.DS = VARSEG(Temp$)„XRegister.DX = SADD(Temp$)„CALL InterruptX(&H21, XRegister, XRegister)„'if the carry flag is clear then the file exists„FileExists% = ((XRegister.Flags AND 1) = 0)„'restore the old DTA„XRegister.AX = &H1A00„XRegister.DS = OldDTASeg%„XRegister.DX = OldDTAOff%„CALL InterruptX(&H21, XRegister, XRegister)„„END FUNCTION„„FUNCTION FileLineCount% (FileName$)„lines% = 0„File = FREEFILE„OPEN FileName$ FOR INPUT AS File„  DO UNTIL EOF(File)„    lines% = lines% + 1„    LINE INPUT #File, FileLine$„  LOOP„CLOSE File„FileLineCount% = lines%„END FUNCTION„„FUNCTION FileSize& (FileName$)„File = FREEFILE„OPEN FileName$ FOR BINARY AS File„  FileSize& = LOF(File)„CLOSE File„END FUNCTION„„SUB Filter (Dirty$)„„Char$ = CHR$(7): GOSUB FilterIt       'beep„BadChr$ = CHR$(12): GOSUB FilterIt    'Form feed„„BadChr$ = CHR$(9)                     'tab„Ptr% = 1„DO„  Ptr% = INSTR(Ptr%, Dirty$, BadChr$)„  IF Ptr% THEN„    TabChars% = TabLen - (Ptr% MOD TabLen%)„    Dirty$ = MID$(Dirty$, 1, Ptr% - 1) + SPACE$(TabChars%) + MID$(Dirty$, Ptr% + 1)„  ELSE„    EXIT DO„  END IF„LOOP„Dirty$ = LEFT$(Dirty$, MaxChars%)„EXIT SUB„„FilterIt:„Ptr% = 1„DO„  Ptr% = INSTR(Ptr%, Dirty$, Char$)„  IF Ptr% THEN„    MID$(Dirty$, Ptr%, 1) = " "„  ELSE„    EXIT DO„  END IF„LOOP„RETURN„„END SUB„„FUNCTION Greater% (Var1%, Var2%) STATIC„Greater% = Var1%: IF Var2% > Var1% THEN Greater% = Var2%„END FUNCTION„„SUB InputBox (Prompt$, InputText$, KeyCode%)„„COLOR BoxFG%, BoxBG%„CALL DrawBox(MidRow% - 1, 3, LeftCol% + 3, ScrnWidth% - 6)„DO„  LOCATE MidRow%, LeftCol% + 7: PRINT Prompt$;„  CALL InputLine(InputText$, ScrnWidth% - 15 - LEN(Prompt$), KeyCode%)„LOOP UNTIL KeyCode% = ENTER OR KeyCode% = ESC„COLOR FG%, BG%„„END SUB„„SUB InputLine (Text$, ViewWidth%, KeyCode%)„„MaxLnLen% = 128„LCol% = POS(0): RCol% = LCol% + ViewWidth% - 1„View$ = SPACE$(ViewWidth%)„Work$ = LEFT$(Text$, MaxLnLen%)„LnLen% = LEN(Work$)„CCol% = Lesser(LCol% + LnLen%, RCol%)„AChar% = LnLen% + 1„„LOCATE , , 0, CursSize% - 1, CursSize%„Insert% = True„DO„  LOCATE , LCol%„  LSET View$ = MID$(Work$, AChar% - (CCol% - LCol%), ViewWidth%)„  PRINT View$;„  LOCATE , CCol%, 1„  LnLen% = LEN(Work$)„  DO„    DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)„    KeyCode% = ASC(Ky$): IF KeyCode% = 0 THEN KeyCode% = -ASC(MID$(Ky$, 2))„  LOOP UNTIL KeyCode% <> BadKey%: BadKey% = 0„  LOCATE , , 0„  SELECT CASE KeyCode%„    CASE BkSpc„	 IF AChar% = 1 THEN„	   BEEP: BadKey% = KeyCode%„	 ELSE„	   IF AChar% <= LnLen% + 1 THEN„		Work$ = LEFT$(Work$, AChar% - 2) + MID$(Work$, AChar%)„	   END IF„	   AChar% = AChar% - 1„	   IF CCol% <> LCol% THEN CCol% = CCol% - 1„	 END IF„    CASE ENTER„	 Text$ = Work$„	 EXIT DO„    CASE ESC„	 EXIT DO„    CASE 32 TO 255      ' letter keys„	 IF AChar% > MaxLnLen% THEN„	   BEEP: BadKey% = KeyCode%„	 ELSE„	   IF AChar% <= LnLen% THEN„		IF Insert% THEN„		  IF LnLen% = MaxLnLen% THEN„		    BEEP: BadKey% = KeyCode%„		  ELSE„		    Work$ = LEFT$(Work$, AChar% - 1) + Ky$ + MID$(Work$, AChar%)„		    AChar% = AChar% + 1„		    IF CCol% <> RCol% THEN CCol% = CCol% + 1„		  END IF„		ELSE 'IF NOT Insert% THEN (in overstrike mode)„		  MID$(Work$, AChar%, 1) = Ky$„		  AChar% = AChar% + 1„		  IF CCol% <> RCol% THEN CCol% = CCol% + 1„		END IF„	   ELSE 'IF AChar% > LnLen% THEN„		Work$ = Work$ + SPACE$(AChar% - LnLen% - 1) + Ky$„		AChar% = AChar% + 1„		IF CCol% <> RCol% THEN CCol% = CCol% + 1„	   END IF„	 END IF„    CASE LArrow„	 IF AChar% = 1 THEN„	   BEEP: BadKey% = KeyCode%„	 ELSE 'IF AChar% > 1 THEN„	   AChar% = AChar% - 1„	   IF CCol% <> LCol% THEN CCol% = CCol% - 1„	 END IF„    CASE RArrow„	 IF AChar% > MaxLnLen% THEN„	   BEEP: BadKey% = KeyCode%„	 ELSE„	   AChar% = AChar% + 1„	   IF CCol% <> RCol% THEN CCol% = CCol% + 1„	 END IF„    CASE HomeKey„	 AChar% = 1„	 CCol% = LCol%„    CASE EndKey„	 AChar% = LnLen% + 1„	 CCol% = Lesser(LCol% + LnLen%, RCol%)„    CASE InsertKey„	 Insert% = NOT Insert%„	 IF Insert% THEN„	   LOCATE , , , CursSize% - 1, CursSize%„	 ELSE„	   LOCATE , , , CursSize% \ 2, CursSize%„	 END IF„    CASE DeleteKey„	 IF AChar% <= LnLen% THEN„	   Work$ = LEFT$(Work$, AChar% - 1) + MID$(Work$, AChar% + 1)„	 END IF„    CASE ELSE„	 BEEP: BadKey% = KeyCode%„  END SELECT„ LOOP„ LOCATE , , , CursSize% - 1, CursSize%„„END SUB„„ FUNCTION LegalFileName% (FileName$)„ DIM XRegister AS RegTypeX„ LegalFileName% = False„ IF FileExists%(FileName$) THEN„  LegalFileName% = True„ ELSE„  'attempt to create the file„  Temp$ = FileName$ + CHR$(0)„  XRegister.AX = &H3C00„  XRegister.CX = 0„  XRegister.DS = VARSEG(Temp$)„  XRegister.DX = SADD(Temp$)„  CALL InterruptX(&H21, XRegister, XRegister)„  IF (XRegister.Flags AND 1) = 0 THEN„    'if carry flag is clear, then file was created OK„    LegalFileName% = True„    'delete the file„    XRegister.AX = &H4100„    CALL InterruptX(&H21, XRegister, XRegister)„  END IF„ END IF„„ END FUNCTION„„ FUNCTION Lesser% (Var1%, Var2%) STATIC„ Lesser% = Var1%: IF Var2% < Var1% THEN Lesser% = Var2%„ END FUNCTION„„SUB MsgBox (Msg$, ValidKeys$, KeyCode%)„„ W% = LEN(Msg$) + 8„ M% = ScrnWidth% - 6„ IF W% > M% THEN W% = M% - 4„ D% = (ScrnWidth% - W%) \ 2„ COLOR BoxFG%, BoxBG%„ CALL DrawBox(MidRow% - 1, 3, LeftCol% + D%, ScrnWidth% - (D% * 2))„ LOCATE MidRow%, LeftCol% + D% + 4: PRINT LEFT$(Msg$, W%);„ COLOR FG%, BG%„„ DO WHILE LEN(INKEY$): LOOP„ IF LEN(ValidKeys$) THEN„  LOCATE , , 1„  DO„    DO: VK$ = INKEY$: LOOP UNTIL LEN(VK$)„    IF ASC(VK$) = ESC THEN EXIT DO„    IF INSTR(ValidKeys$, VK$) THEN EXIT DO ELSE BEEP„  LOOP„  LOCATE , , 0„  KeyCode% = ASC(VK$)„ ELSE„  DO UNTIL LEN(INKEY$): LOOP„ END IF„END SUB„„SUB SetVGABorderColor (Colour%)„ 'Colour must be in the range 0 - 255„ DIM Register AS RegType„ Register.AX = &H1001„ Register.BX = Colour% * &H100„ CALL Interrupt(&H10, Register, Register)„END SUB„„Naushir Patuck                 STRING EDIT/INPUT ROUTINE      naushir@pl.jaring.my           04-21-96 (21:25)       QB, QBasic, PDS        250  6532     INPUT.BAS   'This is a useful string Editing/Input routine I wrote„'to get rid of the horrors of Input forever :-)„„DECLARE SUB enter (text$, min!, max!, permitted$, caps!, justify!, password!, insert!, cursorvisible!, fillchar$)„„CLS„LOCATE 1, 4„PRINT "Name : [" + STRING$(20, " ") + "]";„LOCATE , 12„„'Text to be edited.  If left as "", a new string will be created„text$ = "Jack"„„'Minimum number of characters„min = 2„„'Maximum number of characters„max = 20„„'All the characters which are„'allowed to be entered„'NOTE : Space should also be included here (if needed).„permitted$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz "„„'Set case of text$„'0 = As is entered„'1 = All characters changed are upper case„caps = 0„„'Justification of text$„'0 = None„'1 = Left Justify„'2 = Right Justify„justify = 0„„'Set password type display„'0 = Off„'1 = On„password = 0„„'Set insert state„'0 = Off„'1 = On„'Note : Insert can be toggled on and off with the„'       INSERT Key when the subroutine is running„insert = 1„„'Is cursor visible or not„'0 = No„'1 = Yes„cursorvisible = 1„„'This fills the rest of the string (the empty part)„'with the character provided by fillchar$ during display.„'NOTE : This is just for the display of the string on the screen„'       and will not actually be added text$„fillchar$ = "˘"„„'Calling routine„enter text$, min, max, permitted$, caps, justify, password, insert, cursorvisible, fillchar$„„LOCATE 3, 4„PRINT "The Name you entered was '" + text$ + "'"„LOCATE 4, 4„PRINT "Length of string :"; LEN(text$)„                „'Pls send comments/suggestions to :„'Naushir Patuck„'naushir@pl.jaring.my„„SUB enter (text$, min, max, permitted$, caps, justify, password, insert, cursorvisible, fillchar$)„„oldxpos = POS(0)„oldypos = CSRLIN„cursorposn = LEN(text$) + 1„ended = 0„xpos = oldxpos„ypos = oldypos„„IF caps THEN text$ = UCASE$(text$)„„IF cursorvisible = 1 THEN„  IF insert = 1 THEN„    LOCATE ypos, xpos, 1, 7, 7„  ELSE„    LOCATE ypos, xpos, 1, 0, 7„  END IF„ELSE„  cursorvisible = 0„END IF„„IF password = 1 THEN„  PRINT STRING$(LEN(text$), 254) + (STRING$(max - LEN(text$), fillchar$))„ELSE„  PRINT text$ + STRING$(max - LEN(text$), fillchar$)„END IF„„xpos = xpos + LEN(text$)„oldtext$ = text$„„DO„  „  LOCATE ypos, xpos, cursorvisible„  „  x$ = ""„  WHILE LEN(x$) = 0„    x$ = INKEY$„  WEND„  „  SELECT CASE x$„      „    CASE CHR$(27)                                 ' ESC Key„      IF oldtext$ <> "" THEN„        text$ = oldtext$„        cursorposn = LEN(text$) + 1„        xpos = oldxpos + LEN(text$)„      ELSE„        SOUND 600, 2„      END IF„      „    CASE CHR$(0) + CHR$(82)                       ' Insert Key„      IF cursorvisible THEN„        IF insert = 1 THEN„          LOCATE ypos, xpos, 1, 0, 7„          insert = 0„        ELSE„          LOCATE ypos, xpos, 1, 7, 7„          insert = 1„        END IF„      ELSE„        SOUND 600, 2„      END IF„      „    CASE CHR$(0) + CHR$(75)                       ' Left Key„      IF (cursorvisible) AND (password <> 1) AND (cursorposn <> 1) THEN„        cursorposn = cursorposn - 1„        xpos = xpos - 1„      ELSE„        SOUND 600, 2„      END IF„      „    CASE CHR$(0) + CHR$(77)                       ' Right Key„      IF (cursorvisible) AND (password <> 1) THEN„        IF cursorposn <= LEN(text$) THEN„          cursorposn = cursorposn + 1„          xpos = xpos + 1„        ELSE„          SOUND 600, 2„        END IF„      ELSE„        SOUND 600, 2„      END IF„      „    CASE CHR$(8)                                  ' Backspace„      IF NOT (cursorposn = 1) THEN„        IF cursorposn <= LEN(text$) THEN„          text$ = LEFT$(text$, cursorposn - 2) + RIGHT$(text$, LEN(text$) - cursorposn + 1)„        ELSEIF cursorposn = (LEN(text$) + 1) THEN„          text$ = LEFT$(text$, LEN(text$) - 1)„        END IF„        cursorposn = cursorposn - 1„        xpos = xpos - 1„      ELSE„        SOUND 600, 2„      END IF„      „    CASE CHR$(0) + CHR$(83)                       ' Delete Key„      IF (password <> 1) AND cursorposn <= LEN(text$) THEN„        text$ = LEFT$(text$, cursorposn - 1) + RIGHT$(text$, LEN(text$) - cursorposn)„      ELSE„        SOUND 600, 2„      END IF„      „    CASE CHR$(13)                                 ' Enter Key„      IF (LEN(text$) >= min) THEN„        ended = 1„      ELSE„        SOUND 600, 2„        ended = 0„      END IF„      „    CASE CHR$(0) + CHR$(71)                       ' Home Key„      IF (cursorvisible) AND (password <> 1) THEN„        cursorposn = 1„        xpos = oldxpos„      ELSE„        SOUND 600, 2„      END IF„      „    CASE CHR$(0) + CHR$(79)                       ' End Key„      IF (cursorvisible) AND (password <> 1) THEN„        cursorposn = LEN(text$) + 1„        xpos = oldxpos + LEN(text$)„      ELSE„        SOUND 600, 2„      END IF„      „    CASE ELSE                                     ' Any Other Key„      IF INSTR(permitted$, x$) THEN„        IF (insert) THEN„          IF LEN(text$) <> max THEN„            text$ = LEFT$(text$, cursorposn - 1) + x$ + RIGHT$(text$, LEN(text$) - cursorposn + 1)„            cursorposn = cursorposn + 1„            xpos = xpos + 1„          ELSE„            SOUND 600, 2„          END IF„        ELSE„          IF cursorposn - 1 <> max THEN„            IF cursorposn = LEN(text$) + 1 THEN„              text$ = text$ + x$„            ELSE„              text$ = LEFT$(text$, cursorposn - 1) + x$ + MID$(text$, cursorposn + 1, LEN(text$) - cursorposn)„            END IF„            cursorposn = cursorposn + 1„            xpos = xpos + 1„          ELSE„            SOUND 600, 2„          END IF„        END IF„      ELSE„        SOUND 600, 2„      END IF„      „  END SELECT„  „  IF caps THEN text$ = UCASE$(text$)„  „  LOCATE oldypos, oldxpos„  PRINT SPACE$(max)„  „  LOCATE oldypos, oldxpos, cursorvisible„  „  IF password = 1 THEN„    PRINT STRING$(LEN(text$), 254) + (STRING$(max - LEN(text$), fillchar$))„  ELSE„    PRINT text$ + STRING$(max - LEN(text$), fillchar$)„  END IF„  „LOOP UNTIL ended„„IF justify = 2 THEN                               ' Right Justify„  text$ = STRING$(max - LEN(text$), " ") + text$„ELSEIF justify = 1 THEN                           ' Left Justify„  text$ = text$ + (STRING$(max - LEN(text$), " "))„END IF„„LOCATE ypos, xpos, 1, 7, 7„„END SUB„Alexander Podkolzin            PB EDITOR                      APP@nw.sbank.e-burg.su         04-24-96 (10:58)       PB32                   588  16050    PBEDIT.BAS  '„' Simple Editor. Author: Alexander Podkolzin <APP@nw.sbank.e-burg.su>„' Use it as you want...„' PowerBASIC 3.2+„' I'v deleted all block operations from the Editor, as they were„' very ... don't know how to name them (may be "dummy": initial file„' was 2 times longer).„' PLEASE, share with me your experience if you'll rewrite this code !„' I'll appreciate any respond of You !„' Thanks for paying attention to that Editor!„'„'----------------------------------------------------------------------„  $LIB ALL OFF„'----------------------------------------------------------------------„'„  %FALSE=0„  %TRUE=NOT %FALSE„  %MaxLines= 10000„  %MaxLen= 240„  %FastCur= 8„  %NormAttrib = &H07„  %BlockAttrib= &H17„  %KeyAttrib = &H1B„  %PathAttrib = &H0B„  %BlnkAttrib = %BlockAttrib +&H80„  %HelpAttrib = &H17„  %HotAttrib = &H15„  %LineAttrib = &H0A„'„  DEFINT a-z„'„  DIM Txt(%MaxLines) AS SHARED STRING„  DIM Ins AS SHARED INTEGER„  DIM nlines AS SHARED INTEGER„  DIM ScrnSeg AS INTEGER„'„  IF (pbvScrnCard AND 1) = 0 THEN„    ScrnSeg = &HB800              ' color monitor„  ELSE„    ScrnSeg = &HB000              ' mono monitor„  END IF„'„  y=CSRLIN„  x=POS(0)„  FileName$=COMMAND$„  IF LEN(FileName$)=0 THEN„     Cprint x,y,"USING: PBEDIT <File Name>",%NormAttrib„     END„  END IF„'„  IF NOT FileHere(FileName$) then„     Cprint x,y,"File not found !",%NormAttrib„     END„  END IF„'„  InsKey$=CHR$(0,82)„  Esc$=CHR$(27)„  Home$=CHR$(0,71)„  PgUp$=CHR$(0,73)„  PgDn$=CHR$(0,81)„  Up$=CHR$(0,72)„  Down$=CHR$(0,80)„  LeftKey$=CHR$(0,75)„  RightKey$=CHR$(0,77)„  CtrlPgUp$=CHR$(0,132)„  CtrlPgDn$=CHR$(0,118)„  CtrlHome$=CHR$(0,119)„  CtrlEnd$=CHR$(0,117)„  TabKey$=CHR$(9)„  EndKey$=CHR$(0,79)„  AltX$=CHR$(0,45)                ' Quit„'„  BcSp$ = CHR$(8)„  Enter$=CHR$(13)„  DelKey$=CHR$(0,83)„'„  CtrlB$=CHR$(2)„  CtrlC$=CHR$(3)„  CtrlK$=CHR$(11)„  CtrlL$=CHR$(12)„  CtrlN$=CHR$(14)„  CtrlQ$=CHR$(17)„  CtrlV$=CHR$(22)„  CtrlY$=CHR$(25)„'„  Ins=1„  IsChanged=%FALSE„'„  xb=1 : yb=1 : xe=80 : ye=24     ' Editor's window coordinates„'                                 ' "ye" has to be less then 25!„'„  Cprint 1,ye+1,space$(80),%BlockAttrib„'„  Win 1,xb,yb,xe,ye,7,0„'„  FOR i=yb+1 to ye-1„     Cprint xe,i,CHR$(177),%NormAttrib„  NEXT„'„  MYXA=1„'„  GOSUB LoadFile„'„  Cprint 3,ye,"<     :   =   >",%NormAttrib„'„  Cprint xe,yb+MYXA,CHR$(219),%NormAttrib„  DO„     Numerer nlines,lpage,begy,endy„     GOSUB PrepareScreen„     GOSUB ShowPage               ' lpage- length of window (page)„     Show=1                       ' begy - first line to show,„     IF nlines <1 then exit loop  ' endy - last line to show (array)„     WHILE NOT INSTAT: WEND       ' CurY - the cursor line„     Simb$=INKEY$„     DEF SEG=0„     POKE &H41C , peek(&H41A)     ' clear keyboard buffer„     DEF SEG„     SELECT CASE Simb$„        CASE InsKey$„           Ins = Ins xor 1„           Show=0„        CASE Home$„           CurX=2„           begx=1„        CASE EndKey$„           l=LEN(Txt(LineN))„           CurX=MIN(l+1,wpage)+1„           endx=MAX(l+1,wpage)+1„           begx=endx-wpage„        CASE Up$„           IF CurY >1 then„              decr CurY„              Show=0„           ELSE„              IF begy=1 then„                 Show=0„              END IF„              begy=begy-1„              endy=endy-1„              EXIT SELECT„           END IF„        CASE Down$„           IF CurY <lpage then„              INCR CurY„              Show=0„           ELSE„              IF endy=nlines then exit SELECT„              INCR begy„              INCR endy„           END IF„        CASE PgUp$„           begy=begy-lpage„           IF begy<=0 then begy=1„        CASE PgDn$„           begy=begy+lpage„           IF begy>=nlines-lpage+1 THEN begy=nlines-lpage+1„        CASE LeftKey$„           IF CurX >2 then„              decr CurX„              Show=0„           ELSE„              decr begx„              IF begx <1 then„                 begx=1„                 Show=0„              END IF„           END IF„        CASE TabKey$„           IF CurX <79-%FastCur then„              INCR CurX,%FastCur„              Show=0„           ELSE„              begx=begx+%FastCur„              IF begx >%MaxLen-79 then begx=%MaxLen-79„           END IF„        CASE RightKey$„           IF CurX <79 then„              INCR CurX„              Show=0„           ELSE„              INCR begx„              IF begx >%MaxLen-79 then begx=%MaxLen-79„           END IF„        CASE CtrlPgUp$„           begy=1„           CurX=2„           CurY=1„        CASE CtrlPgDn$„           begy=nlines-lpage+1„           CurX=xb+1„           CurY=ye-2„        CASE CtrlHome$„           CurY=1„           Show=0„        CASE CtrlEnd$„           CurY=ye-2„           Show=0„        CASE AltX$,Esc$„           EXIT LOOP„'„'~~~~~~~~~~~~~~   All other chars will change Txt()   ~~~~~~~~~~~~~~„        CASE Enter$„           IF Ins=1 then          ' IF "Ins" is ON„              IsChanged=%TRUE         ' Txt() is changed„              IF nlines=%MaxLines then„                 BEEP             ' too many strings„                 EXIT SELECT„              END IF„              BreakLine LineN,SimbN„           END IF„           CurX=2„           IF CurY < lpage then„              INCR CurY„           ELSE„              INCR begy„           END IF„           begx=1„'„        CASE DelKey$„           IsChanged=%TRUE„           l=LEN(Txt(LineN))„           IF SimbN=1 and l=0 then„              IF nlines>1 and LineN<>nlines THEN„                 DelLine LineN„                 INCR nlines„                 CurX=2„              END IF„           ELSEIF SimbN>l and LineN=nlines THEN„              EXIT SELECT„           ELSE„              IF SimbN>l then„                 f$=Txt(LineN)+space$(SimbN-l-1)„                 IF len(f$+Txt(LineN+1))>%MaxLen THEN„                    BEEP„                    EXIT SELECT„                 END IF„                 Txt(LineN)=f$+Txt(LineN+1)„                 INCR LineN„                 DelLine LineN„              ELSEIF l=1 then„                 Txt(LineN)=""„              ELSE„                 DelChar LineN,SimbN„              END IF„           END IF„'„        CASE BcSp$„           IsChanged=%TRUE„           IF SimbN=1 AND LineN=1 THEN EXIT SELECT„           IF SimbN=1 THEN„              IF nlines>1 THEN„                 sa$=Txt(LineN-1)„                 sb$=Txt(LineN)„                 DelLine LineN„                 Txt(LineN-1)=sa$+sb$„                 CurX=LEN(sa$)+2„                 IF LineN>1 THEN„                    IF endy=<nlines THEN DECR CurY„                    IF CurY<1 then„                       INCR CurY„                       DECR begy„                    END IF„                 END IF„              END IF„           ELSEIF SimbN>LEN(Txt(LineN))+1 THEN„              DECR CurX„           ELSE„              DECR SimbN„              DelChar LineN,SimbN„              DECR CurX„           END IF„'„        CASE CtrlY$„           IsChanged=%TRUE„           DelLine LineN„           begx=1„           CurX=2„'„        CASE CtrlN$„           IsChanged=%TRUE„           InsLine LineN„'„        CASE CtrlK$„           Cprint xb+1,ye+1,"^K",%BlockAttrib„           Cprint xb+4,ye+1,"more...",%BlnkAttrib„           LOCATE ye+1,xb+3„           WHILE NOT INSTAT: wend„           k$=INKEY$„           Cprint xb+1,ye+1,SPACE$(10),%BlockAttrib„           SELECT CASE k$„'„           END SELECT„        CASE CtrlQ$„'„        CASE ELSE„           IF LEN(Simb$)=1 and asc(Simb$)>31 THEN„              IsChanged=%TRUE„              Txt(LineN)=Txt(LineN)+space$(%MaxLen)„              IF Ins=1 THEN„                 InsChar LineN,SimbN,Simb$„              ELSE„                 ReplaceChar LineN,SimbN,Simb$„              END IF„              INCR CurX„              IF CurX=xe THEN„                 INCR begx„                 CurX=xe-1„              END IF„              Txt(LineN)=RTRIM$(Txt(LineN))„           END IF„„'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~„     END SELECT„  LOOP„  IF IsChanged THEN„     Win 1,xb+1,yb+1,xe-1,yb+3,7,1„     Cprint xb+3,yb+2,"File is changed, save ? (Y/N) ",%HelpAttrib„     DO„        WHILE NOT INSTAT: wend„        s$=INKEY$„        SELECT CASE s$„           CASE "Y","y"„              GOSUB SaveFile„              EXIT LOOP„           CASE "N","n"„              EXIT LOOP„        END SELECT„     LOOP„  END IF„'„' Clear screen before exit„'„  Cprint 1,1,space$(2000),%NormAttrib„  LOCATE ,,,11,12„  END„'----------------------------------------------------------------------„„ShowPage:„  IF Show=0 THEN RETURN„  FOR i=1 TO lpage„     n = begy+i-1„     Txt(n)=RTRIM$(Txt(n))„     l = LEN(Txt(n))„     s$=MID$(Txt(n)+space$(%MaxLen - l),begx,wpage)„     Cprint xb+1,yb+i,s$,%NormAttrib„  NEXT i„  RETURN„'----------------------------------------------------------------------„„PrepareScreen:„'„' Show Cursor:„'„  LineN=begy+CurY-1„  SimbN=begx+Curx-2„  Cprint 4,ye,RIGHT$("0000"+LTRIM$(STR$(LineN)),5),%PathAttrib„  Cprint 10,ye,RIGHT$("00"+LTRIM$(STR$(SimbN)),3),%PathAttrib„  Cprint 14,ye,RIGHT$("00"+LTRIM$(STR$(SCREEN(CurY+1,CurX ))),3),%PathAttrib„  IF CurX < xb+1 THEN CurX= xb+1„  IF CurX >xe-1 THEN CurX=xe-1„  IF CurY >nlines then CurY=nlines„  LOCATE yb+CurY,CurX,1„'„' Make Ruler:„'„  IF Nlines > lpage then„     om=MYXA„     MYXA=((begy+CurY-1)/nlines )*(ye-yb-1)„     IF MYXA=0 then MYXA=1„     IF om <> MYXA then„        Cprint xe,yb+om,CHR$(177),%NormAttrib„        Cprint xe,yb+MYXA,CHR$(219),%NormAttrib„     END IF„  END IF„'„' Show Keys:„'„  IF Ins=1 THEN„     LOCATE ,,,4,12„     sa$="INS"„  ELSE„     locate ,,,11,12„     sa$ = "   "„  END IF„  Cprint 71,ye+1,sa$,%BlockAttrib„'„' Show Size:„'„  Size&=-1„  FOR i=1 to nlines„     Size&=Size&+LEN(Txt(i))+2„  NEXT„  Cprint 35,ye,"<Lines:     >",%NormAttrib„  Cprint 65,ye,"<Size:",%NormAttrib„  Cprint 78,ye,">",%NormAttrib„  Cprint 42,ye,RIGHT$("      "+STR$(nlines),5),%PathAttrib„  Cprint 71,ye,RIGHT$("      "+STR$( Size&),7),%PathAttrib„'„' Check if the editor file is changed„'„  IF NOT IsChanged THEN„     Cprint 19,ye,"=",%NormAttrib„  ELSE„     Cprint 19,ye,"ˆ",%PathAttrib„  END IF„  RETURN„'----------------------------------------------------------------------„  FUNCTION FileHere (FileNAME$)„     S$=DIR$(FileNAME$)„     IF LEN(S$)=0 THEN„        FileHere = 0„     ELSE„        FileHere =-1„     END IF„  END FUNCTION„'----------------------------------------------------------------------„  SUB BreakLine(LineN,SimbN)      ' Separates LineN-th string for two„'                                 ' at SimbN-th position„     sa$=MID$(Txt(LineN),1,SimbN-1)„     sb$=MID$(Txt(LineN),SimbN,%MaxLen)„     ARRAY INSERT Txt(LineN)„     Txt(LineN)=sa$„     Txt(LineN+1)=sb$„     INCR nlines„  END SUB„'----------------------------------------------------------------------„  SUB DelLine(LineN)              ' Deletes LineN-th line„     ARRAY DELETE Txt(LineN)„     DECR nlines„  END SUB„'----------------------------------------------------------------------„  SUB InsLine(LineN)„     BreakLine LineN,LEN(Txt(LineN))+1„  END SUB„'----------------------------------------------------------------------„  SUB InsChar(LineN,SimbN,Simb$)„     s$=Txt(LineN)„     Txt(LineN)=LEFT$(s$,SimbN-1)+Simb$+RIGHT$(s$,LEN(s$)-SimbN+1)„  END SUB„'----------------------------------------------------------------------„' Replacement of a char„  SUB ReplaceChar(LineN,SimbN,Simb$)„     MID$(Txt(LineN),SimbN)=Simb$„  END SUB„'----------------------------------------------------------------------„  SUB DelChar(LineN,SimbN)„     s$=Txt(LineN)„     Txt(LineN)=LEFT$(s$,SimbN-1) + RIGHT$(s$,LEN(s$)-SimbN)„  END SUB„'---------------------------------------------------------------------------„„SaveFile:„  IF NOT IsChanged THEN RETURN„  Cprint 3,ye+1,"Saving...",%BlnkAttrib„  n=INSTR(FileName$,".")„  IF n<>0 THEN„     n$=LEFT$(FileName$,n-1)      '„     e$=".APP"                    ' Extension for changed file.„  ELSE                            '„     n$=FileName$„     e$=".APP"„  END IF„  IF FileHere(n$+e$) THEN„     KILL n$+e$„  END IF„  DestFile=FREEFILE„  OPEN n$+e$ FOR OUTPUT AS DestFile„  FOR i=1 to nlines„     PRINT #DestFile,Txt(i)„  NEXT„  CLOSE DestFile„  Cprint 3,ye+1,SPACE$(10),%BlockAttrib„  IsChanged=%FALSE„  GOSUB PrepareScreen„  RETURN„'---------------------------------------------------------------------------„„LoadFile:„  redim Txt(%MaxLines)„  Cprint 3,yb+1,"Loading...",%NormAttrib + &H80„  src=FREEFILE„  OPEN FileName$ FOR INPUT as src„  i=0„  DO WHILE EOF(src )=0 AND i < %MaxLines„     INCR i„     LINE INPUT #src,Txt(i)„' Double load time„     REPLACE CHR$(9) with "        " IN Txt(i )„  LOOP„  Size&= LOF(src )+1„  CLOSE src„  nlines=i+1„  Txt(nlines )=""„'„  x=(80- LEN(FileName$)) \ 2„  Cprint x-1,yb,repeat$(LEN(FileName$)+2,CHR$(196)),%NormAttrib„  Cprint x,yb,UCASE$(FileName$),%PathAttrib„  begx=1„  begy=1„  lpage=ye-yb-1„  wpage=xe-xb-1„  endy=MIN(lpage,nlines )„  CurY=1„  CurX=2„  SimbN=1„  Show=1„  LOCATE yb+1,xb+1„  RETURN„'---------------------------------------------------------------------------„' "Numerer" normalizes begy% and begx%„  SUB Numerer(nlines%,lpage%,begy%,endy%)„     IF nlines%<=lpage% THEN„        begy%=1„        endy%=nlines%„        EXIT SUB„     END IF„     IF begy%<1 THEN„        begy%=1„        endy%=begy%+lpage%-1„        EXIT SUB„     END IF„     IF begy%+lpage%-1>=nlines% THEN„        endy%=nlines%„        begy%=nlines%-lpage%+1„        EXIT SUB„     END IF„     endy%=begy%+lpage%-1„  END SUB„'----------------------------------------------------------------------------„  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)„'„     OldColor% = pbvScrnTxtAttr   ' Internal PB variable„'„     SELECT CASE t%               ' Window types„'                                 ' (you can make as much types,„'                                 ' as you want):„        CASE 1„           a%=218:b%=196:c%=191   ' Single frame„           h%=179:      :d%=179„           g%=192:f%=196:e%=217„        CASE 2„           a%=201:b%=205:c%=187   ' Double frame„           h%=186:      :d%=186„           g%=200:f%=205:e%=188„        CASE ELSE„           a%=032:b%= a%:c%=a%    ' Blanks only„           h%= a%:      :d%=a%„           g%= a%:f%= a%:e%=a%„     END SELECT„'„     COLOR ct%,cb%„'„     LOCATE yb%,xb%„     PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%);„'„     FOR i%=yb%+1 TO ye%-1„        LOCATE i%,xb%„        PRINT CHR$(h%) + SPACE$(xe%-xb%-1) +CHR$(d%);„     NEXT„'„     LOCATE ye%,xb%„     PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%);„'„     ct%=OldColor% AND 15         ' restore colors„     cb%=OldColor% \ 16„     COLOR ct%,cb%„  END SUB„'----------------------------------------------------------------------------„  SUB PutAttribute(x%,y%,t%,b%)   ' Puts attribute byte to video memory„     LOCAL c%                     ' directly to Colomn, Row position„     c% = b%*16+t%„     DEF SEG = ScrnSeg„     POKE 160*(y%-1)+x%+x%-1,c%„     DEF SEG„  END SUB„'----------------------------------------------------------------------------„  SUB Cprint(x%,y%,s$,attr%)      ' Color printing„     LOCATE ,,0                   ' For more speed better to use„     REG 1,&H1300                 ' ASSEMBLER subroutine„     REG 2,attr%„     REG 3,LEN(s$)„     REG 4,(y%-1)*256+x%-1„     REG 9,STRSEG(s$)„     REG 7,STRPTR(s$)„     CALL INTERRUPT &H10„     LOCATE ,,1„  END SUB„'----------------------------------------------------------------------„Dave Navarro, Jr.              FIND POSITION OF WORD IN STRINGdave@powerbasic.com            05-01-96 (19:29)       PB                     64   1712     WORDPOS.BAS '=============================================================================„'                   Source code snippet: PowerBASIC for DOS„'„'           Author: Dave Navarro, Jr. (dave@powerbasic.com)„' Copyright status: Public Domain„'„' Returns the position of a word in a string.  It must be a complete word,„' and not part of another word (such as "BOB" in "BOBBY").„'„'=============================================================================„„DIM Text AS STRING„DIM Find AS STRING„„Text = "Main$ = UCASE$(Main$)"„Find = "UCASE$"„„PRINT Find„PRINT Text„x = IsWord(0, Text, Find)„IF x THEN PRINT SPACE$(x-1);"^"„„'****************************************************************************„'IsWord - Return the position of the specified complete word in a string„'„FUNCTION IsWord(BYVAL Start AS INTEGER, BYVAL Main AS STRING, BYVAL Search AS STRING)„„  DIM Delimeters AS STRING„  DIM FrontChr   AS STRING„  DIM BackChr    AS STRING„  DIM Where      AS INTEGER„„  Delimeters = " ()+-*\/<>;=:',^" + CHR$(34)„„  Main   = UCASE$(Main)„  Search = UCASE$(Search)„„  IF Start < 1 THEN„    Start = 1„  END IF„„  Where   = INSTR(Start, Main$, Search$)„„  IF Where THEN„    IF Where > 1 THEN„      FrontChr = MID$(Main, Where-1, 1)„    END IF„    IF Where + LEN(Search) <= LEN(Main) THEN„      BackChr = MID$(Main, Where+LEN(Search), 1)„    END IF„„    IF (LEN(FrontChr) = 0) OR (INSTR(FrontChr, ANY Delimeters) > 0) THEN„      Front = -1„    END IF„    IF (LEN(BackChr) = 0) OR (INSTR(BackChr, ANY Delimeters) > 0) THEN„      Back  = -1„    END IF„„    IF (Front = -1) AND (Back = -1) THEN„      FUNCTION = Where„    END IF„  END IF„„END FUNCTION„Dave Gjessing                  FILE BROWSER                   dgjess@freenet.columbus.oh.us  05-25-96 (00:00)       QB, QBasic, PDS        139  3583     BF.BAS      'Needed a subroutine to replace -> SHELL "type [filespec] | more"„'BF seems to work pretty well. It writes a copy of the text file to a„'temporary structured file, which can then be jumped around in with„'ease and speed.„„'Please note that this is mainly intended as a subroutine to deal with„'text files from known sources (in my case, ones created by the program„'using the sub). I have run into unexpected problems with certain text„'files when using BF as a stand-alone program. This particular version„'will (for instance) fly off the handle at a CHR$(12)... <G>. But, as„'long as you know what files BF will run into, it seems to be pretty„'stable.„„'Shameless plug: BF is incorporated in my program ShareCon, which can be„'found at http://www.simtel.net/pub/simtelnet/msdos/database/sc1-2e.zip„'end of plug„„'define data type for temporary file...„„TYPE txline„ln AS STRING * 80„END TYPE„DIM text AS txline„„filename$ = COMMAND$„„IF filename$ = "" OR filename$ = "?" OR filename$ = "/?" THEN„PRINT "(B)rowse (F)ile.BAS    Dave Gjessing 5/25/96"„PRINT "A smooth-scrolling text file viewer subroutine (or complete program"„PRINT "as presented here)."„PRINT "BF can only handle lines 80 characters in length (or less)."„PRINT„PRINT "to use, type -> BF [filespec]"„END„END IF„„ON ERROR GOTO fail  'it is assumed that error will be bad file name„OPEN filename$ FOR INPUT AS #1„„spread = 23     'pass the spread as an argument when using BF as a subroutine„„low = 1„high = spread„counter = 1„tl = 1„„CLS     'if no error, clear the screen and begin„„COLOR 2, 0„LOCATE 25, 1: PRINT CHR$(4); " PGUP - PGDN - ARROWS - HOME - END - ESC "; CHR$(4);„COLOR 15, 0„PRINT " "; RIGHT$(filename$, 35); " ";„COLOR 7, 0„„OPEN "temp.$$$" FOR RANDOM AS #2 LEN = LEN(text)„„DO UNTIL EOF(1)             'copy file 1 (a plain ASCII text file)„LINE INPUT #1, line$        'into a nice neat structured file for„text.ln = line$             'random access (file 2)„PUT #2, counter, text„counter = counter + 1„LOOP„„CLOSE 1     'done with actual file we want to look at (browse temp file)„„size = LOF(2) / LEN(text)   'find size of file„„again:      'display selected screenful of file on screen„tl = 1„IF low < 1 THEN low = 1„FOR x = low TO high„GET #2, x, text„LOCATE tl, 1: PRINT text.ln„tl = tl + 1„NEXT x„tl = 1„„'move around within the temporary file...„„DO„op$ = INKEY$„op$ = UCASE$(op$)„  „   IF op$ = CHR$(0) + CHR$(71) THEN 'home key„   low = 1„   high = spread„   GOTO again„   END IF„„   IF op$ = CHR$(0) + CHR$(79) THEN 'end key„   high = size„   low = (high - spread) + 1„   GOTO again„   END IF„„   IF op$ = CHR$(0) + CHR$(81) THEN 'page down key„   low = low + spread„   high = high + spread„    IF high > size THEN„    high = size„    low = (high - spread) + 1„    END IF„   GOTO again„   END IF„  „   IF op$ = CHR$(0) + CHR$(73) THEN 'page up key„   low = low - spread„   high = high - spread„      IF low < 1 THEN low = 1: high = (low + spread) - 1„   GOTO again„   END IF„„   IF op$ = CHR$(0) + "P" THEN 'down arrow„   low = low + 1„   high = high + 1„   GOTO again„   END IF„„   IF op$ = CHR$(0) + "H" THEN 'up arrow„   low = low - 1„   high = high - 1„      IF low < 1 THEN low = 1: high = spread„   GOTO again„   END IF„   „   IF op$ = CHR$(27) THEN           'escape key„   CLOSE„   KILL "temp.$$$"„   CLS„   END„   END IF„„LOOP„„fail:       'report expected error - don't clear the screen„PRINT„PRINT "file -> "; filename$; " not found"„END„„John Wantland                  UFO SCREEN SAVER               kwantlan@coffey.com            05-26-96 (14:47)       QB, QBasic, PDS        106  3609     UFO.BAS     1 k = 2„10 REM ufo„15 CLS„16 COLOR 15, 0„17 RANDOMIZE TIMER„18 n = INT(RND * 8 + 1)„20 a$ = "‹‹‹‹" + CHR$(8) + CHR$(8) + CHR$(8) + CHR$(8) + CHR$(8) + CHR$(8) + "‹‹‹‹"„30 x = 12: y = 31„31 r = INT(RND * 15 + 1)„32 c = INT(RND * 60 + 1)„33 u = INT(RND * 15 + 1)„34 v = INT(RND * 60 + 1)„35 w = INT(RND * 15 + 1)„36 e = INT(RND * 60 + 1)„40 COLOR 7, 0: LOCATE r, c: PRINT "   €€€€€€€€€€€€ "„41 LOCATE r + 1, c: PRINT " €€€€€€€€€€€€€€€€"„42 LOCATE u, v: PRINT "   €€€€€€€€€€€€ "„43 LOCATE u + 1, v: PRINT " €€€€€€€€€€€€€€€€"„44 LOCATE w, e: PRINT "   €€€€€€€€€€€€ "„45 LOCATE w + 1, e: PRINT " €€€€€€€€€€€€€€€€"„FOR t = 1 TO 79„COLOR k, 0„LOCATE 23, t: PRINT "€";„NEXT t„49 LOCATE x, y„50 RANDOMIZE TIMER„55 COLOR 9, 0„60 PRINT a$„70 IF y <= 1 OR y >= 64 OR x <= 1 OR x >= 23 THEN 100„80 IF y = 20 OR y = 40 OR y = 60 OR x = 12 THEN n = INT(RND * 8 + 1)„100 IF y <= 1 THEN n = 1„110 IF y >= 64 THEN n = 2„120 IF x <= 1 THEN n = 3„130 IF x >= 22 THEN n = 4„140 IF y <= 1 AND x <= 1 THEN n = 5„150 IF y <= 1 AND x >= 22 THEN n = 6„160 IF y >= 64 AND x <= 1 THEN n = 7„170 IF y >= 64 AND x >= 22 THEN n = 8„180 FOR t = 1 TO 1000: NEXT t„190 LOCATE x, y: PRINT "               "„200 IF n = 1 THEN y = y + 1„210 IF n = 2 THEN y = y - 1„220 IF n = 3 THEN x = x + 1„230 IF n = 4 THEN x = x - 1„240 IF n = 5 THEN y = y + 1: x = x + 1„250 IF n = 6 THEN y = y + 1: x = x - 1„260 IF n = 7 THEN y = y - 1: x = x + 1„270 IF n = 8 THEN y = y - 1: x = x - 1„275 COLOR 0, 0„280 b$ = INKEY$: IF b$ <> "" THEN 300„285 c = c + 1: IF c >= 64 THEN CLS : c = 1: r = INT(RND * 15 + 1)„286 v = v + 1: IF v >= 64 THEN CLS : v = 1: u = INT(RND * 15 + 1)„287 e = e + 1: IF e >= 64 THEN CLS : e = 1: w = INT(RND * 15 + 1)„288 i = i + 1: IF i >= 100 THEN GOSUB 510: i = 0„290 GOTO 40„300 FOR t = 1 TO 1000: NEXT t„305 COLOR 8, 0„310 CLS„320 PRINT "       €€€€€€€€€€€€€€€€€€€€€€€€€€€€"„330 PRINT "      €€€€€€€€€€€€€€€€€€€€€€€€€€€€€€"„340 PRINT "     €€€€€€        €€€€        €€€€€€"„350 PRINT "    €€€€€€€        €€€€        €€€€€€€"„360 PRINT "   €€€€€€€€        €€€€        €€€€€€€€"„370 PRINT "  €€€€€€€€€        €€€€        €€€€€€€€€"„380 PRINT "  €€€€€€€€€        €€€€        €€€€€€€€€"„390 PRINT "  €€€€€€€€€        €€€€        €€€€€€€€€"„400 PRINT "   €€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€"„410 PRINT "    €€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€"„420 PRINT "     €€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€"„430 PRINT "      €€€€€€€€€€€€€€€€€€€€€€€€€€€€€€"„440 PRINT "       €€€€€€€€            €€€€€€€€"„450 PRINT "        €€€€€€€€€€€€€€€€€€€€€€€€€€"„460 PRINT "         €€€€€€€€€€€€€€€€€€€€€€€€"„470 PRINT "          €€€€€€€€€€€€€€€€€€€€€€"„480 PRINT "           €€€€€€€€€€€€€€€€€€€€"„490 PRINT "            €€€€€€€€€€€€€€€€€€"„495 COLOR 15, 0: PRINT "                 BELIEVE!"„500 END„510 s = 2100„519 FOR h = x TO 21„520 LOCATE h - 1, y: PRINT "              "„530 LOCATE h, y: COLOR 9, 0: PRINT a$„b$ = INKEY$: IF b$ <> "" THEN 300„540 FOR t = 1 TO 1000: NEXT t„s = s - 100: SOUND s, 1„545 x = x + 1„550 NEXT h„560 LOCATE 21, y: PRINT "              "„570 FOR h = 7 TO 20„575 ON ERROR GOTO 1„580 LOCATE x, y + h: COLOR 8, 0: PRINT CHR$(1)„590 LOCATE x, y: COLOR 9, 0: PRINT a$„b$ = INKEY$: IF b$ <> "" THEN 300„600 FOR t = 1 TO 1000: NEXT t„605 LOCATE x, y + h: PRINT " "„610 NEXT h„620 LOCATE 21, y + 16: PRINT " "„630 FOR h = x TO 12 STEP -1„640 IF x <> 22 THEN LOCATE h + 1, y: PRINT "              "„650 LOCATE h, y: PRINT a$„b$ = INKEY$: IF b$ <> "" THEN 300„660 FOR t = 1 TO 1000: NEXT t„670 x = x - 1„680 NEXT h„690 CLS„700 RETURN„The ABC Programmer             SWITCH TEXT MODE W/O CLEARING  Convert from PASCAL Code       06-12-96 (11:10)       QB, PDS                31   730      SWITCH.BAS  '{ Switching without clearing test, by Bas van Gaalen, Holland, PD }„' Converted to BASIC by William Yu (06-12-96)„„'$INCLUDE: 'QB.BI'„DIM SHARED InRegs AS RegType„„CLS„PRINT "Select from the following option please:"„PRINT "0 - Quit": PRINT "1 - 25 Lines": PRINT "2 - 50 Lines"„„DO„  A$ = INPUT$(1)„  IF A$ = "1" THEN Lines.25„  IF A$ = "2" THEN Lines.50„LOOP UNTIL A$ = "0"„„END„„SUB Lines.25„  InRegs.ax = &H83„  CALL INTERRUPT(&H10, InRegs, InRegs)„END SUB„„SUB Lines.50„  InRegs.ax = &H1202„  InRegs.bx = &H30      ' assembly:  mov bl, 30h„  CALL INTERRUPT(&H10, InRegs, InRegs)„  InRegs.ax = &H1112„  InRegs.bx = &H0       ' assembly:  mov bl, 0„  CALL INTERRUPT(&H10, InRegs, InRegs)„END SUB„Edward Blake                   PLAIN TEXT EDITOR              eblake2@quebectel.com          06-28-96 (08:37)       QB, PDS                580  17640    EDITOR7.BAS '„' 1996 Edward Blake (14 years old), Plain Text Editor v7.0„' maybe its called Editor7.bas, I called it like that because I have a„' Editor1 , Editor2, Editor3... all very limited and bug infested!!„' But this shouldnt have too many bugs, but you might want to use it„' for something.. I modifie it for certain purposes, I made a version„' for my Turbo Assembler, I simply changed the Custom command and rename„' it to "Assemble" (i'm too lazy to type Tasm then Tlink all the time).„' Can serve as a IDE or a not-so-convenient editor.„' used Microsoft QuickBasic 4.5 as Compiler, Minor\Major Change might„' be needed to Interpret\Compile under another Implementation.„' Remember to have the QB library, because I need to make interrupts„' for the mouse.„'„' Declarations of sub routines„DECLARE SUB BCKGND ()                     ' BackGround Routine„DECLARE SUB WIN (X1!, Y1!, X2!, Y2!, A$)  ' Text Windowing routine„DECLARE SUB LOADEDIT ()          ' Procedure called when the editor loads„DECLARE SUB MAINEDIT ()          ' Where most of the stuff goes„DECLARE SUB FILEMENU ()          ' Called when you press the File menu„DECLARE SUB NEW ()               ' The File\New command„DECLARE SUB SAVE ()              ' The File\Save command„DECLARE SUB PRINTF ()            ' The File\Print command„DECLARE SUB SHUTDOWN ()          ' The File\Exit command„DECLARE SUB REPAINT ()           ' Repainting after a dialog box disappears„DECLARE SUB SAVEBEFORE ()        ' Save Before Dialog Box„DECLARE SUB SBHELP ()            ' Save Before Help„DECLARE SUB SBREPAINT ()         ' Save Before Repaint„DECLARE SUB OPENF ()             ' The File\Open command„DECLARE SUB SAVEAS ()            ' Called if no filename„DECLARE SUB OPTIONFL ()          ' The File\(Custom) command„' $INCLUDE: 'QB.BI'„' Custom Settings Hard-Wired at run-time„CONST EDITORNAME$ = "Editor's Title" ' Title appearing in the window„CONST MAXLINES = 2000                    ' Maximum number of lines capable„CONST OPTIONFILE$ = "(Custom)"           ' Custom File Command„CONST OPTIONFLHOT$ = "C"                 ' Custom command 's Letter„CONST OPTIONXHOTPOS = 1                  ' Position of custom letter„DIM FILE$(MAXLINES)                      ' Array for editable text„TITLE$ = COMMAND$                        ' Open a file„IF COMMAND$ <> "" THEN            ' The Guy putted something as a parameter„OPEN TITLE$ FOR INPUT AS #1       ' It must be a file he wants to open„DO UNTIL EOF(1)                   ' Do the loop until The End of the file„LINE INPUT #1, FILE$(I)„I = I + 1„LOOP„CLOSE #1„END IF„LOADEDIT                                 ' Startup„MAINEDIT                                 ' Main program„END„„SUB BCKGND„FOR I = 1 TO 24„LOCATE I, 1: PRINT STRING$(80, 177);„NEXT I„LOCATE 25, 1: PRINT STRING$(80, 177);„END SUB„„SUB FILEMENU„SHARED NOMS„DIM REGS AS RegType„REGS.ax = 2„IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„COLOR 15, 1„LOCATE 1, 2: PRINT " File "„COLOR 0, 7„LOCATE 2, 1: PRINT "  New Document   "„LOCATE 3, 1: PRINT "  Open Document  "„LOCATE 4, 1: PRINT "  Save Document  "„LOCATE 5, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"„LOCATE 6, 1: PRINT "                 "„LOCATE 7, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"„LOCATE 8, 1: PRINT "  Print          "„LOCATE 9, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"„LOCATE 10, 1: PRINT "  Exit           "„LOCATE 6, 1: PRINT OPTIONFILE$„COLOR 15, 7„LOCATE 2, 3: PRINT "N"„LOCATE 3, 3: PRINT "O"„LOCATE 4, 3: PRINT "S"„LOCATE 6, 1 + OPTIONXHOTPOS: PRINT OPTIONFLHOT$„LOCATE 8, 3: PRINT "P"„LOCATE 10, 3: PRINT "E"„REGS.ax = 1„IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„SH = 1„DO„I$ = UCASE$(INKEY$)„REGS.ax = 3„IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„PM = REGS.bx„XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1„IF I$ <> "" THEN„IF I$ = "N" THEN NEW„IF I$ = "O" THEN OPENF„IF I$ = "S" THEN SAVE„IF I$ = "P" THEN PRINTF„IF I$ = "E" THEN SHUTDOWN„IF I$ = "A" THEN OPTIONFL„IF I$ = CHR$(27) THEN EXIT DO„EXIT DO„END IF„IF SH = 1 AND PM = 0 THEN SH = 0„IF XM > 1 AND XM < 18 AND YM < 11 AND SH = 0 THEN„IF YM = 1 AND PM = 1 THEN EXIT DO„IF YM = 2 AND PM = 1 THEN„NEW„EXIT DO„END IF„IF YM = 3 AND PM = 1 THEN„OPENF„EXIT DO„END IF„IF YM = 4 AND PM = 1 THEN„SAVE„EXIT DO„END IF„IF YM = 6 AND PM = 1 THEN„OPTIONFL„EXIT DO„END IF„IF YM = 8 AND PM = 1 THEN„PRINTF„END IF„IF YM = 10 AND PM = 1 THEN SHUTDOWN„END IF„LOOP„REGS.ax = 2„IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„REPAINT„REGS.ax = 1„IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„END SUB„„SUB LOADEDIT„DIM REGS AS RegType„REGS.ax = 0„INTERRUPT 51, REGS, REGS„IF REGS.ax = 0 THEN NOMS = 1„REGS.cx = 0„REGS.dx = 0„COLOR 1„BCKGND„COLOR 7, 1„WIN 1, 2, 80, 24, EDITORNAME$„„REGS.ax = 1„IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„COLOR 15, 7„LOCATE 25, 1: PRINT "  Edward Blake, 1996                                                            ";„COLOR 0, 7„LOCATE 1, 1: PRINT "  File                                                                          ";„COLOR 15, 5„END SUB„„SUB MAINEDIT„SHARED FILE$(), Y, X, Z, NOMS„DIM LINETRCK%(MAXLINES)„DIM REGS AS RegType„REGS.ax = 0„INTERRUPT 51, REGS, REGS„IF REGS.ax = 0 THEN NOMS = 1„DO„    ' Extended Keyboard„    IF I$ = CHR$(0) + CHR$(33) THEN FILEMENU„    IF I$ = CHR$(0) + CHR$(80) THEN Y = Y + 1„    IF I$ = CHR$(0) + CHR$(72) THEN Y = Y - 1„    IF I$ = CHR$(0) + CHR$(75) THEN Z = Z - 1„    IF I$ = CHR$(0) + CHR$(77) THEN Z = Z + 1„    IF I$ = CHR$(0) + CHR$(71) THEN Z = 0„    IF I$ = CHR$(0) + CHR$(79) THEN Z = LINETRCK%(X + Y)„    IF Y < 0 THEN„	Y = 0„	X = X - 1„    END IF„    IF Y > 20 THEN„	Y = 20„	X = X + 1„    END IF„„    IF Z < 0 THEN Z = 0„    IF Z > 77 THEN Z = 77„„    IF X < 0 THEN X = 0„    IF X > MAXLINES THEN X = MAXLINES„„    IF I$ > CHR$(1) AND I$ <= CHR$(255) THEN  ' Non-Extended Keyboard„	LOCATE 25, 1: PRINT "             ";„	LOCATE 25, 1: PRINT ASC(I$); I$;„	IF I$ = CHR$(13) THEN                 ' Enter„	    Y = Y + 1„	    Z = 0„	    I$ = ""„	    IF Y > 20 THEN„		Y = 20„		X = X + 1„	    END IF„	    IF X > MAXLINES THEN X = MAXLINES„	END IF„	IF I$ = CHR$(127) THEN                ' Delete Procedure„	END IF„	IF I$ = CHR$(8) THEN                  ' BackSpace Procedure„	    IF Z > 0 THEN„	    IF FILE$(X + Y) <> "" AND NOT (Z > LEN(FILE$(X + Y))) THEN FILE$(X + Y) = LEFT$(FILE$(X + Y), Z - 1) + RIGHT$(FILE$(X + Y), LEN(FILE$(X + Y)) - Z)„	    IF Z >= 0 THEN Z = Z - 1„	    LINETRCK%(Y + X) = Z„	    END IF„	END IF„	IF I$ >= CHR$(32) AND I$ <= CHR$(255) AND I$ <> CHR$(127) THEN 'Printable Characters„	    IF Z + 1 > LEN(FILE$(X + Y)) THEN FILE$(X + Y) = FILE$(X + Y) + STRING$(ABS(LEN(FILE$(X + Y)) - Z) + 1, 32)„	    MID$(FILE$(Y + X), Z + 1, 1) = I$„	    Z = Z + 1„	    LINETRCK%(Y + X) = Z„	END IF„    END IF„„    IF Y < 0 THEN„	Y = 0„	X = X - 1„    END IF„    IF Y > 20 THEN„	Y = 20„	X = X + 1„    END IF„„    IF Z < 0 THEN Z = 0„    IF Z > 77 THEN Z = 77„„    IF X < 0 THEN X = 0„    IF X > MAXLINES THEN X = MAXLINES„„    REGS.ax = 2„    IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„    FOR I = 0 TO 20„	LOCATE I + 3, 2, 0: PRINT FILE$(X + I) + STRING$(78 - LEN(FILE$(X + I)), 32)„    NEXT I„    LOCATE Y + 3, 2 + Z, 1„    REGS.ax = 1„    IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„    DO„	REGS.ax = 1„	IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„	I$ = INKEY$„	IF I$ <> "" THEN EXIT DO„	REGS.ax = 3„	INTERRUPT 51, REGS, REGS„	PM = REGS.bx„	XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1„	IF PM = 0 THEN SH = 0„	IF PM = 1 AND SH = 0 THEN„	IF YM = 1 THEN„	IF XM > 2 AND XM < 8 THEN FILEMENU„	END IF„	SH = 1„	END IF„    LOOP„LOOP„END SUB„„SUB NEW„SHARED FILE$(), TITLE$„SAVEBEFORE„FOR I = 0 TO MAXLINES„FILE$(I) = ""„NEXT I„TITLE$ = ""„END SUB„„SUB OPENF„SHARED FILE$(), TITLE$, NOMS„DIM REGS AS RegType„REGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„WIN 4, 3, 76, 8, "  Open  "„WIN 6, 4, 74, 6, ""„COLOR 15, 1„LOCATE 5, 7: PRINT SPACE$(67)„LOCATE 7, 14: PRINT "    OK    "„LOCATE 7, 34: PRINT "  CANCEL  "„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„DO„    IF Z < 0 THEN Z = 0„    IF I$ > CHR$(1) AND I$ <= CHR$(255) THEN„	IF I$ = CHR$(8) THEN„	    IF Z > 0 THEN„	    IF VTITLE$ <> "" AND NOT (Z > LEN(VTITLE$)) THEN VTITLE$ = LEFT$(VTITLE$, Z - 1) + RIGHT$(VTITLE$, LEN(VTITLE$) - Z)„	    IF Z >= 0 THEN Z = Z - 1„	    END IF„	END IF„	IF I$ >= CHR$(32) AND I$ <= CHR$(255) THEN„	    IF Z + 1 > LEN(VTITLE$) THEN VTITLE$ = VTITLE$ + STRING$(ABS(LEN(VTITLE$) - Z) + 1, 32)„	    MID$(VTITLE$, Z + 1, 1) = I$„	    Z = Z + 1„	END IF„    END IF„    IF Z < 0 THEN Z = 0„    LOCATE 5, 7: PRINT RIGHT$(VTITLE$, 66) + " "„    DO„	REGS.ax = 1„	IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„	I$ = INKEY$„	IF I$ = CHR$(27) THEN CANCEL = 1„	IF I$ = CHR$(13) THEN OK = 1„	IF I$ <> "" THEN EXIT DO„	REGS.ax = 3„	INTERRUPT 51, REGS, REGS„	PM = REGS.bx„	XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1„	IF PM = 1 AND YM = 7 THEN„	IF XM > 13 AND XM < 25 THEN OK = 1„	IF XM > 33 AND XM < 45 THEN CANCEL = 1„	IF OK = 1 OR CANCEL = 1 THEN EXIT DO„	END IF„    LOOP„IF OK = 1 OR CANCEL = 1 THEN EXIT DO„LOOP„„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„IF OK = 1 THEN TITLE$ = VTITLE$„IF CANCEL = 1 THEN EXIT SUB„I = 0„OPEN TITLE$ FOR INPUT AS #1„DO UNTIL EOF(1)„LINE INPUT #1, FILE$(I)„I = I + 1„LOOP„CLOSE #1„END SUB„„'„' Custom File Command Pushed„'„SUB OPTIONFL„END SUB„„SUB PRINTF„SHARED FILE$()„FOR I = 0 TO MAXLINES„IF FILE$(I) <> "" THEN MXFILE = I + 1„NEXT I„I = 0„OPEN "LPT1:" FOR OUTPUT AS #1„DO UNTIL I = MXFILE„PRINT #1, FILE$(I)„I = I + 1„LOOP„CLOSE #1„END SUB„„SUB REPAINT„SHARED FILE$(), Y, Z„COLOR 7, 1„WIN 1, 2, 80, 24, EDITORNAME$„COLOR 15, 7„LOCATE 25, 1: PRINT "  Edward Blake, 1996                                                            ";„COLOR 0, 7„LOCATE 1, 1: PRINT "  File                                                                          ";„COLOR 15, 5„    FOR I = 0 TO 20„	LOCATE I + 3, 2, 0: PRINT FILE$(X + I) + STRING$(78 - LEN(FILE$(X + I)), 32)„    NEXT I„    LOCATE Y + 3, 2 + Z, 1„END SUB„„SUB SAVE„SHARED TITLE$, FILE$()„DIM REGS AS RegType„IF TITLE$ <> "" THEN„FOR I = 0 TO MAXLINES„IF FILE$(I) <> "" THEN MXFILE = I + 1„NEXT I„I = 0„OPEN TITLE$ FOR OUTPUT AS #1„DO UNTIL I = MXFILE„PRINT #1, FILE$(I)„I = I + 1„LOOP„CLOSE #1„END IF„IF TITLE$ = "" THEN SAVEAS„REGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„REPAINT„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„END SUB„„SUB SAVEAS„SHARED FILE$(), TITLE$, NOMS„DIM REGS AS RegType„REGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„WIN 4, 3, 76, 8, "  Save as  "„WIN 6, 4, 74, 6, ""„COLOR 15, 1„LOCATE 5, 7: PRINT SPACE$(67)„LOCATE 7, 14: PRINT "    OK    "„LOCATE 7, 34: PRINT "  CANCEL  "„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„DO„    IF Z < 0 THEN Z = 0„    IF I$ > CHR$(1) AND I$ <= CHR$(255) THEN„	IF I$ = CHR$(8) THEN„	    IF Z > 0 THEN„	    IF VTITLE$ <> "" AND NOT (Z > LEN(VTITLE$)) THEN VTITLE$ = LEFT$(VTITLE$, Z - 1) + RIGHT$(VTITLE$, LEN(VTITLE$) - Z)„	    IF Z >= 0 THEN Z = Z - 1„	    END IF„	END IF„	IF I$ >= CHR$(32) AND I$ <= CHR$(255) THEN„	    IF Z + 1 > LEN(VTITLE$) THEN VTITLE$ = VTITLE$ + STRING$(ABS(LEN(VTITLE$) - Z) + 1, 32)„	    MID$(VTITLE$, Z + 1, 1) = I$„	    Z = Z + 1„	END IF„    END IF„    IF Z < 0 THEN Z = 0„    LOCATE 5, 7: PRINT RIGHT$(VTITLE$, 66) + " "„    DO„	REGS.ax = 1„	IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„	I$ = INKEY$„	IF I$ = CHR$(27) THEN CANCEL = 1„	IF I$ = CHR$(13) THEN OK = 1„	IF I$ <> "" THEN EXIT DO„	REGS.ax = 3„	INTERRUPT 51, REGS, REGS„	PM = REGS.bx„	XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1„	IF PM = 1 AND YM = 7 THEN„	IF XM > 13 AND XM < 25 THEN OK = 1„	IF XM > 33 AND XM < 45 THEN CANCEL = 1„	IF OK = 1 OR CANCEL = 1 THEN EXIT DO„	END IF„    LOOP„IF OK = 1 OR CANCEL = 1 THEN EXIT DO„LOOP„„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„IF OK = 1 THEN„TITLE$ = VTITLE$„FOR I = 0 TO MAXLINES„IF FILE$(I) <> "" THEN MXFILE = I + 1„NEXT I„I = 0„IF INSTR(TITLE$, ".") = 0 THEN TITLE$ = TITLE$ + ".ASM"„OPEN TITLE$ FOR OUTPUT AS #1„DO UNTIL I = MXFILE„PRINT #1, FILE$(I)„I = I + 1„LOOP„CLOSE #1„END IF„END SUB„„SUB SAVEBEFORE„SHARED NOMS„DIM REGS AS RegType„REGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„COLOR 7, 1„WIN 10, 11, 70, 14, ""„LOCATE 12, 11: PRINT "               Do you want to save before?                 "„LOCATE 13, 11: PRINT "                                                           "„COLOR 0, 7„LOCATE 13, 19: PRINT "   YES    "„LOCATE 13, 35: PRINT "    NO    "„LOCATE 13, 51: PRINT "   HELP   "„COLOR 15, 7„LOCATE 13, 22: PRINT "Y"„LOCATE 13, 39: PRINT "N"„LOCATE 13, 54: PRINT "H"„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„DO„I$ = UCASE$(INKEY$)„REGS.ax = 3: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„PM = REGS.bx„XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1„IF I$ = "Y" THEN OK = 1„IF I$ = "N" THEN CANCEL = 1„IF I$ = "H" THEN SBHELP„IF PM = 1 AND YM = 13 THEN„IF XM > 18 AND XM < 30 THEN OK = 1„IF XM > 34 AND XM < 45 THEN CANCEL = 1„IF XM > 51 AND XM < 62 THEN SBHELP„END IF„IF OK = 1 OR CANCEL = 1 THEN EXIT DO„LOOP„IF OK = 1 THEN SAVE„END SUB„„SUB SBHELP„SHARED NOMS„DIM REGS AS RegType„REGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„COLOR 15, 0„WIN 3, 2, 78, 24, "  Help On Before Save  "„COLOR 7, 0„LOCATE 3, 4: PRINT " This prompt appears about anywhere when your file can get destroyed      ";„LOCATE 4, 4: PRINT " like using the new or exit command.                                      ";„LOCATE 5, 4: PRINT " This prompt will open anyway even after you saved your file.             ";„LOCATE 6, 4: PRINT " If you press YES, then either:                                           ";„LOCATE 7, 4: PRINT "      -You see the Save as command box if it is untitled                  ";„LOCATE 8, 4: PRINT "      -It will be saved automatically if it already as a name             ";„LOCATE 9, 4: PRINT " If you press NO, then changes to your file after its last save is        ";„LOCATE 10, 4: PRINT " destroyed                                                                ";„LOCATE 11, 4: PRINT "                                                                          ";„LOCATE 12, 4: PRINT "                                                                          ";„LOCATE 13, 4: PRINT "                                                                          ";„LOCATE 14, 4: PRINT "                                                                          ";„LOCATE 15, 4: PRINT "                                                                          ";„LOCATE 16, 4: PRINT "                                                                          ";„LOCATE 17, 4: PRINT "                                                                          ";„LOCATE 18, 4: PRINT "                                                                          ";„LOCATE 19, 4: PRINT "                                                                          ";„LOCATE 20, 4: PRINT "                                                                          ";„'LOCATE 21, 4: PRINT "                                                                          ";„'LOCATE 22, 4: PRINT "                                                                          ";„'LOCATE 23, 4: PRINT "                                                                          ";„COLOR 15, 7„LOCATE 21, 4: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø";„LOCATE 22, 4: PRINT "≥       R            ";„COLOR 0, 7„PRINT "≥";„LOCATE 23, 4: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ";„COLOR 0, 7„LOCATE 22, 13: PRINT "eturn";„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„DO„I$ = UCASE$(INKEY$)„REGS.ax = 3: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„PM = REGS.bx„XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1„IF YM > 20 AND YM < 24 AND PM = 1 AND XM > 3 AND XM < 26 THEN EXIT DO„IF I$ = "R" THEN EXIT DO„LOOP„REGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„REPAINT„SBREPAINT„REGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGS„END SUB„„SUB SBREPAINT„COLOR 15, 1„WIN 10, 11, 70, 14, ""„LOCATE 12, 11: PRINT "               Do you want to save before?                 "„LOCATE 13, 11: PRINT "                                                           "„COLOR 0, 7„LOCATE 13, 19: PRINT "   YES    "„LOCATE 13, 35: PRINT "    NO    "„LOCATE 13, 51: PRINT "   HELP   "„COLOR 15, 7„LOCATE 13, 22: PRINT "Y"„LOCATE 13, 39: PRINT "N"„LOCATE 13, 54: PRINT "H"„END SUB„„SUB SHUTDOWN„DIM REGS AS RegType„COLOR 15, 1„LOCATE 10, 1: PRINT "  Exit           "„SAVEBEFORE„REGS.ax = 0: INTERRUPT 51, REGS, REGS„COLOR 7, 0„CLS„SYSTEM„END SUB„„SUB WIN (X1, Y1, X2, Y2, A$)„FOR I = Y1 TO Y2„LOCATE I, X1: PRINT STRING$(X2 - X1, 32);„NEXT I„LOCATE Y1, X1 + 1: PRINT STRING$(X2 - X1 - 1, 196);„LOCATE Y2, X1 + 1: PRINT STRING$(X2 - X1 - 1, 196);„FOR I = Y1 + 1 TO Y2 - 1„LOCATE I, X1: PRINT CHR$(179);„LOCATE I, X2: PRINT CHR$(179);„NEXT I„LOCATE Y1, X1: PRINT CHR$(218);„LOCATE Y1, X2: PRINT CHR$(191);„LOCATE Y2, X1: PRINT CHR$(192);„LOCATE Y2, X2: PRINT CHR$(217);„IF A$ <> "" THEN„LOCATE Y1, ((X2 + X1) / 2) - ((LEN(A$) + 2) / 2): PRINT CHR$(180) + A$ + CHR$(195)„END IF„END SUB„Edward Blake                   TEXT WINDOW DESIGNER           eblake2@quebectel.com          06-28-96 (09:08)       QB, PDS                436  11690    WNDESIGN.BAS' 1995-96 Edward Blake (14 years old), QuickBasic Windowing designer„' Programming tool for creating a acceptable text based Windowing Interface„' looks quite primitive a the side of other, more sophisticated tools„' But can always make a good interface, Keeps everything in RAM until„' You want to save your work to a .BAS file, push ESC to go to the menu„'„DECLARE SUB EXITP ()„DECLARE SUB NEW ()„DECLARE SUB SAVE ()„DECLARE FUNCTION ZDIGIT$ (A%)„DECLARE SUB MOUSE (A!)„DECLARE SUB BACKCLRED (ACTT!)„DECLARE SUB FORECLRED (ACTT!)„DECLARE SUB PROPERTY (ACTTOOL!)„DECLARE SUB TOOLBAR (X3!, Y3!)„DECLARE SUB MENU ()„DECLARE SUB RECONSTRUCT ()„DECLARE SUB BCKGND ()„DECLARE SUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)„' $INCLUDE: 'QB.BI'„TYPE OBJECT„X1 AS INTEGER„Y1 AS INTEGER„X2 AS INTEGER„Y2 AS INTEGER„BACKCLR AS INTEGER„FORECLR AS INTEGER„CAPTION AS STRING * 32„END TYPE„DIM INDEX AS INTEGER„DIM REGS AS RegType„DIM OBJ(300) AS OBJECT„CLS„BCKGND„COLOR 15, 1„REGS.ax = 10„REGS.bx = 0„REGS.cx = &HFFFF„REGS.dx = &H4700„INTERRUPT 51, REGS, REGS„REGS.ax = 1„REGS.bx = 0„REGS.cx = 1„REGS.dx = 1„INTERRUPT 51, REGS, REGS„DO„I$ = INKEY$„REGS.ax = 3„INTERRUPT 51, REGS, REGS„„IF REGS.bx = 1 THEN„   IF PD = 0 THEN„   PD = 1„   LSTX% = INT((80 / 640) * REGS.cx) + 1„   LSTY% = INT((25 / 200) * REGS.dx) + 1„   END IF„   IF PD = 1 THEN„   WIN LSTX%, LSTY%, INT((80 / 640) * REGS.cx) + 1, INT((25 / 200) * REGS.dx) + 1, ""„   END IF„END IF„IF REGS.bx = 0 THEN„LSPD = PD„PD = 0„   IF LSPD = 1 THEN„   WIN LSTX%, LSTY%, INT((80 / 640) * REGS.cx) + 1, INT((25 / 200) * REGS.dx) + 1, "Untitled"„      IF LSTX% <> INT((80 / 640) * REGS.cx) + 1 THEN„	 IF LSTY% <> INT((25 / 200) * REGS.dx) + 1 THEN„	 OBJ(INDEX).X1 = LSTX%„	 OBJ(INDEX).Y1 = LSTY%„	 OBJ(INDEX).X2 = INT((80 / 640) * REGS.cx) + 1„	 OBJ(INDEX).Y2 = INT((25 / 200) * REGS.dx) + 1„	 OBJ(INDEX).BACKCLR = 1„	 OBJ(INDEX).FORECLR = 15„	 OBJ(INDEX).CAPTION = "Untitled"„	 INDEX = INDEX + 1„	 LSTX% = 0'INT((80 / 640) * REGS.cx) + 1„	 LSTY% = 0'INT((25 / 200) * REGS.dx) + 1„	 LSTPH = 0„	 RECONSTRUCT„	 END IF„      END IF„	 LSTPH = 0„   END IF„END IF„IF REGS.bx = 0 THEN„IF LSTX% = INT((80 / 640) * REGS.cx) + 1 THEN„IF LSTY% = INT((25 / 200) * REGS.dx) + 1 THEN„IF LSTPH = 0 THEN„'„'  PLACE ROUTINES HERE THE USER CLICKS (NOT DRAG)„'„TOOLBAR INT((80 / 640) * REGS.cx) + 1, INT((25 / 200) * REGS.dx) + 1„RECONSTRUCT„LSTPH = 1„END IF„END IF„END IF„END IF„IF I$ = CHR$(13) OR I$ = CHR$(27) OR I$ = CHR$(9) THEN MENU„LOOP„„SUB BACKCLRED (ACTT)„SHARED OBJ() AS OBJECT, INDEX AS INTEGER„DIM REGS AS RegType„COLOR 0, 15„LOCATE 9, 18: PRINT "<" + ZDIGIT$(OBJ(ACTT).BACKCLR) + ">"„Z% = OBJ(ACTT).BACKCLR„DO„I$ = INKEY$„IF I$ = CHR$(0) + CHR$(77) THEN Z% = Z% + 1„IF I$ = CHR$(0) + CHR$(75) THEN Z% = Z% - 1„IF Z% > 15 THEN Z% = 15„IF Z% < 0 THEN Z% = 0„OBJ(ACTT).BACKCLR = Z%„LOCATE 9, 18: PRINT "<" + ZDIGIT(Z%) + ">"„IF I$ = CHR$(13) THEN„COLOR 15, 1„LOCATE 9, 18: PRINT " " + ZDIGIT(Z%) + " "„EXIT SUB„END IF„IF I$ = CHR$(27) THEN„COLOR 15, 1„LOCATE 9, 18: PRINT " " + ZDIGIT(Z%) + " "„EXIT SUB„END IF„LOOP„END SUB„„SUB BCKGND„FOR I = 1 TO 24„LOCATE I, 1: PRINT STRING$(80, 177);„NEXT I„LOCATE 25, 1: PRINT STRING$(80, 177);„END SUB„„SUB EXITP„MOUSE 2„COLOR 7, 0„CLS„SYSTEM„END SUB„„SUB FORECLRED (ACTT)„SHARED OBJ() AS OBJECT, INDEX AS INTEGER„DIM REGS AS RegType„COLOR 0, 15„LOCATE 10, 18: PRINT "<" + ZDIGIT$(OBJ(ACTT).FORECLR) + ">"„Z% = OBJ(ACTT).FORECLR„DO„I$ = INKEY$„IF I$ = CHR$(0) + CHR$(77) THEN Z% = Z% + 1„IF I$ = CHR$(0) + CHR$(75) THEN Z% = Z% - 1„IF Z% > 15 THEN Z% = 15„IF Z% < 0 THEN Z% = 0„OBJ(ACTT).FORECLR = Z%„LOCATE 10, 18: PRINT "<" + ZDIGIT(Z%) + ">"„IF I$ = CHR$(13) THEN„COLOR 15, 1„LOCATE 10, 18: PRINT " " + ZDIGIT(Z%) + " "„EXIT SUB„END IF„IF I$ = CHR$(27) THEN„COLOR 15, 1„LOCATE 10, 18: PRINT " " + ZDIGIT(Z%) + " "„EXIT SUB„END IF„LOOP„END SUB„„SUB MENU„DIM REGS AS RegType„COLOR 15, 1„WIN 1, 1, 40, 25, ""„COLOR 0, 15„LOCATE 1, 2: PRINT "        QB Fixed Window Design        "„COLOR 15, 1„LOCATE 2, 2: PRINT " New                                  "„LOCATE 3, 2: PRINT " Save in QuickBasic                   "„LOCATE 4, 2: PRINT " Exit                                 "„LOCATE 5, 1: PRINT "√ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥"„LOCATE 6, 2: PRINT "                                      "„LOCATE 7, 2: PRINT "                                      "„LOCATE 8, 2: PRINT "                                      "„LOCATE 9, 2: PRINT "                                      "„LOCATE 10, 2: PRINT "                                      "„LOCATE 11, 2: PRINT "                                      "„LOCATE 12, 2: PRINT "                                      "„LOCATE 13, 2: PRINT "                                      "„LOCATE 14, 2: PRINT "                                      "„DO„REGS.ax = 3„INTERRUPT 51, REGS, REGS„X4 = INT((80 / 640) * REGS.cx) + 1„Y4 = INT((25 / 200) * REGS.dx) + 1„IF REGS.bx = 1 THEN„   IF X4 < 40 THEN„   IF Y4 = 2 THEN NEW„   IF Y4 = 3 THEN SAVE„   IF Y4 = 4 THEN EXITP„   END IF„   END IF„   IF X4 > 40 THEN„   EXIT SUB„   END IF„LOOP„END SUB„„SUB MOUSE (A)„DIM REGS AS RegType„REGS.ax = A„INTERRUPT 51, REGS, REGS„END SUB„„SUB NEW„SHARED OBJ() AS OBJECT, INDEX AS INTEGER„FOR I = 0 TO 300„OBJ(I).X1 = 0„OBJ(I).Y1 = 0„OBJ(I).X2 = 0„OBJ(I).Y2 = 0„OBJ(I).BACKCLR = 0„OBJ(I).FORECLR = 0„OBJ(I).CAPTION = ""„NEXT I„INDEX = 0„END SUB„„SUB PROPERTY (ACTTOOL)„SHARED OBJ() AS OBJECT, INDEX AS INTEGER„DIM REGS AS RegType„COLOR 15, 1„WIN 3, 6, 60, 15, ""„COLOR 0, 15„LOCATE 6, 4: PRINT "Property            "„COLOR 15, 1„LOCATE 8, 6: PRINT "           ⁄ƒƒƒƒø"„LOCATE 9, 6: PRINT "Back Color ≥    ≥"„LOCATE 10, 6: PRINT "Fore Color ≥    ≥"„LOCATE 11, 6: PRINT "           ¿ƒƒƒƒŸ"„LOCATE 12, 6: PRINT "           ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 13, 6: PRINT "Caption    ≥                                       ≥"„LOCATE 14, 6: PRINT "           ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„LOCATE 9, 19: PRINT ZDIGIT$(OBJ(ACTTOOL).BACKCLR)„LOCATE 10, 19: PRINT ZDIGIT$(OBJ(ACTTOOL).FORECLR)„LOCATE 13, 18: PRINT LEFT$(OBJ(ACTTOOL).CAPTION, 39)„DO„REGS.ax = 3„INTERRUPT 51, REGS, REGS„X4 = INT((80 / 640) * REGS.cx) + 1„Y4 = INT((25 / 200) * REGS.dx) + 1„IF REGS.bx = 1 THEN„IF X4 > 17 AND X4 < 57 AND Y4 > 12 AND Y4 < 14 THEN„LOCATE 13, 18: INPUT "", OBJ(ACTTOOL).CAPTION„END IF„IF X4 > 5 AND X4 < 22 AND Y4 > 8 AND Y4 < 11 THEN„IF Y4 = 9 THEN BACKCLRED ACTTOOL„IF Y4 = 10 THEN FORECLRED ACTTOOL„END IF„IF Y4 < 6 OR Y4 > 15 OR X4 < 7 OR X4 > 60 THEN EXIT SUB„END IF„LOOP„END SUB„„SUB RECONSTRUCT„SHARED OBJ() AS OBJECT„COLOR 7, 0„CLS„BCKGND„FOR I = 0 TO 300„IF OBJ(I).X1 = 0 THEN EXIT FOR„COLOR OBJ(I).FORECLR, OBJ(I).BACKCLR„WIN OBJ(I).X1, OBJ(I).Y1, OBJ(I).X2, OBJ(I).Y2, RTRIM$(OBJ(I).CAPTION)„NEXT I„MOUSE 1„END SUB„„SUB SAVE„SHARED OBJ() AS OBJECT„COLOR 0, 7„LOCATE 5, 6: PRINT " Save as QuickBasic 4.5 File  "„COLOR 15, 1„LOCATE 6, 2: PRINT "FileName:                             "„LOCATE 7, 2: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 8, 2: PRINT "≥                                    ≥"„LOCATE 9, 2: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„LOCATE 8, 3: INPUT "", A$„IF A$ = "" THEN EXIT SUB„OPEN A$ FOR OUTPUT AS #1„PRINT #1, "DECLARE SUB BCKGND ()"„PRINT #1, "DECLARE SUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)"„PRINT #1, "DECLARE SUB WININTRO()"„PRINT #1, "SUB WININTRO"„„FOR I% = 0 TO 300„X = I%„IF OBJ(X).X1 = 0 THEN EXIT FOR„PRINT #1, "COLOR " + STR$(OBJ(X).FORECLR) + "," + STR$(OBJ(X).BACKCLR)„PRINT #1, "WIN "; STR$(OBJ(X).X1); ","; STR$(OBJ(X).Y1); ","; STR$(OBJ(X).X2); ","; STR$(OBJ(X).Y2); ","; CHR$(34); RTRIM$(OBJ(X).CAPTION); CHR$(34)„NEXT I%„„PRINT #1, "END SUB"„PRINT #1, "SUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)"„PRINT #1, "FOR I% = Y1% + 1 TO Y2% - 1"„PRINT #1, "LOCATE I%, X1 + 1: PRINT STRING$(X2 - X1, 32);"„PRINT #1, "Next I%"„PRINT #1, "LOCATE Y1, X1 + 1: PRINT STRING$(X2 - X1, 196);"„PRINT #1, "LOCATE Y2, X1 + 1: PRINT STRING$(X2 - X1, 196);"„PRINT #1, "FOR I = Y1 + 1 TO Y2 - 1"„PRINT #1, "LOCATE I, X1: PRINT CHR$(179);"„PRINT #1, "LOCATE I, X2: PRINT CHR$(179);"„PRINT #1, "NEXT I"„PRINT #1, "LOCATE Y1, X1: PRINT CHR$(218);"„PRINT #1, "LOCATE Y1, X2: PRINT CHR$(191);"„PRINT #1, "LOCATE Y2, X1: PRINT CHR$(192);"„PRINT #1, "LOCATE Y2, X2: PRINT CHR$(217);"„PRINT #1, "IF A$ <> " + CHR$(34) + CHR$(34) + " THEN"„PRINT #1, "LOCATE Y1, X1 + 1: PRINT A$;"„PRINT #1, "END IF"„PRINT #1, "END SUB"„PRINT #1, "SUB BCKGND"„PRINT #1, "FOR I = 1 TO 24"„PRINT #1, "LOCATE I, 1: PRINT STRING$(80, 177);"„PRINT #1, "NEXT I"„PRINT #1, "LOCATE 25, 1: PRINT STRING$(80, 177);"„PRINT #1, "END SUB"„CLOSE #1„COLOR 15, 1„LOCATE 5, 6: PRINT "                              "„LOCATE 6, 2: PRINT "                                      "„LOCATE 7, 2: PRINT "                                      "„LOCATE 8, 2: PRINT "                                      "„LOCATE 9, 2: PRINT "                                      "„END SUB„„SUB TOOLBAR (X3, Y3)„SHARED OBJ() AS OBJECT, INDEX AS INTEGER„DIM REGS AS RegType„FOR I = 0 TO 300„IF OBJ(I).X1 = 0 THEN EXIT FOR„IF OBJ(I).X1 <= X3 THEN„IF OBJ(I).Y1 <= Y3 THEN„IF OBJ(I).X2 >= X3 THEN„IF OBJ(I).Y2 >= Y3 THEN„ACTTOOL = I„TOOLFOUND = 1„LOCATE 1, 1: PRINT I„END IF„END IF„END IF„END IF„NEXT I„IF TOOLFOUND = 0 THEN EXIT SUB„COLOR 0, 15„WIN OBJ(ACTTOOL).X1, OBJ(ACTTOOL).Y1, OBJ(ACTTOOL).X2, OBJ(ACTTOOL).Y2, RTRIM$(OBJ(ACTTOOL).CAPTION)„COLOR 15, 1„WIN 3, 2, 24, 7, "ToolBar"„„LOCATE 3, 4: PRINT LEFT$(OBJ(ACTOOL).CAPTION, 12); " ("; ACTTOOL; ")"„LOCATE 4, 3: PRINT "√ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥"„LOCATE 5, 4: PRINT "Delete              "„LOCATE 6, 4: PRINT "Property            "„DO„REGS.ax = 3„INTERRUPT 51, REGS, REGS„'INT((80 / 640) * REGS.cx) + 1„'INT((25 / 200) * REGS.dx) + 1„X4 = INT((80 / 640) * REGS.cx) + 1„Y4 = INT((25 / 200) * REGS.dx) + 1„IF REGS.bx = 1 THEN„IF X4 > 3 AND Y4 > 4 AND X4 < 24 AND Y4 < 8 THEN„IF Y4 = 5 THEN„COLOR 0, 15„LOCATE 5, 4: PRINT "Delete              "„FOR I = ACTTOOL + 1 TO 300„OBJ(I - 1).X1 = OBJ(I).X1„OBJ(I - 1).Y1 = OBJ(I).Y1„OBJ(I - 1).X2 = OBJ(I).X2„OBJ(I - 1).Y2 = OBJ(I).Y2„OBJ(I - 1).BACKCLR = OBJ(I).BACKCLR„OBJ(I - 1).FORECLR = OBJ(I).FORECLR„OBJ(I - 1).CAPTION = OBJ(I).CAPTION„NEXT I„INDEX = INDEX - 1„EXIT SUB„END IF„IF Y4 = 6 THEN„COLOR 0, 15„LOCATE 6, 4: PRINT "Property            "„PROPERTY ACTTOOL„EXIT SUB„END IF„END IF„„IF X4 < 3 OR Y4 < 2 OR X4 > 24 OR Y4 > 8 THEN„EXIT SUB„END IF„END IF„LOOP„END SUB„„SUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)„IF X1 > X2 THEN„SWAP X1, X2„END IF„IF Y1 > Y2 THEN„SWAP Y1, Y2„END IF„IF X2 - X1 = 0 THEN„EXIT SUB„END IF„IF Y2 - Y1 = 0 THEN„EXIT SUB„END IF„„FOR I% = Y1% + 1 TO Y2% - 1„LOCATE I%, X1 + 1: PRINT STRING$(X2 - X1, 32);„NEXT I%„LOCATE Y1, X1 + 1: PRINT STRING$(X2 - X1, 196);„LOCATE Y2, X1 + 1: PRINT STRING$(X2 - X1, 196);„FOR I = Y1 + 1 TO Y2 - 1„LOCATE I, X1: PRINT CHR$(179);„LOCATE I, X2: PRINT CHR$(179);„NEXT I„LOCATE Y1, X1: PRINT CHR$(218);„LOCATE Y1, X2: PRINT CHR$(191);„LOCATE Y2, X1: PRINT CHR$(192);„LOCATE Y2, X2: PRINT CHR$(217);„IF A$ <> "" THEN„LOCATE Y1, X1 + 1: PRINT A$;„END IF„END SUB„„FUNCTION ZDIGIT$ (A%)„IF A% < 10 THEN ZDIGIT$ = "0" + RTRIM$(LTRIM$(STR$(A%)))„IF A% >= 10 THEN ZDIGIT$ = RTRIM$(LTRIM$(STR$(A%)))„END FUNCTION„Charles Godard                 PERCENT BOX                    FidoNet QUIK_BAS Echo          06-22-96 (00:00)       QB, QBasic, PDS        149  4264     PERCENT.BAS 'Percent.bas by Charles Godard 06/22/96„'Opens, maintains, then closes a popup box to be used when„'copying a file or performing other task, to pacify the user„'while he waits.„„'Switch% = 0 turns it on„'Switch% = 1 maintains it„'Switch% = 2 closes it„'Pass to it, a number between 1 and 100 and the proper switch„'PercentBox 0, 0  'you must 1st open the box„'PercentBox 1, (Percent%) 'maintain it with this.  Percent%„'    MUST be in parenthesis or else MUST be a numeric value.„'PercentBox 2, 0 'close it with this„'give it a number between 0 and 100, and increment it as needed„'the delay's, STEP, and for/next are for demo only„„'I haven't tested this except in this program.  It could need some„'modification when run in a real program. <Oh well> :)„„'inspired by reading in the conference.. Wellerstein to Goldbloom„'BTW, Alex, I liked yours, never got James' to run. PB, I guess :)„„'I feel like the shipwrecked sailor, sending messages in a bottle.„'If anyone sees this message in a bottle, I sure would like to„'hear about it.  I've been posting messages since feb, and the„'only response that I have gotten was the one the other day from„'Joe.  I'm hoping that I am now making the trip! :)„„DEFINT A-Z„DECLARE SUB printScreen (Tr, Lc, H, W, Fg, Bg)„DECLARE SUB copyScreen (Tr, Lc, H, W)„DECLARE SUB PercentBox (Switch%, Percent%)„„TYPE Sdata„   Char  AS STRING * 1„   Attr AS STRING * 1„END TYPE„REDIM SHARED x(25, 80) AS Sdata„DIM SHARED Bg, Fg„CLS„SCREEN 0„'put stuff on screen„COLOR &H7, 1: FOR i = 292 TO 678: PRINT i; : NEXT i„„PercentBox 0, 0„„Dly = 1: GOSUB delay„   FOR Percent% = 1 TO 100 STEP 9„      PercentBox 1, (Percent%)  'you can change the name of„      GOSUB delay               'Percent% and remove the ()„   NEXT Percent%„GOSUB delay„„PercentBox 2, 0„„END„„delay:„T& = TIMER: DO WHILE (ABS(T& - TIMER) < Dly) AND INKEY$ = "": LOOP„RETURN„„SUB copyScreen (Tr, Lc, H, W)„„'Attr = SCREEN(Tr + 1, Lc + 1, 1)„'Fg = Attr AND &HF„'Bg = Attr \ &H10„„FOR cr = Tr TO Tr + H„   FOR cc = Lc TO Lc + W„      x(cr, cc).Char = CHR$(SCREEN(cr, cc))„      x(cr, cc).Attr = CHR$(SCREEN(cr, cc, 1))„   NEXT cc„NEXT cr„„END SUB„„SUB PercentBox (Switch%, Percent%)„Tr = 11: Lc = 20: W = 43: H = 4: 'Fg = &H4: Bg = &H4:„„STATIC boxOpen„„SELECT CASE Switch%„  CASE IS = 0  'open the box„      'read data from the screen„      CALL copyScreen(Tr, Lc, H, W)„      'put popup on screen„      FOR cr = Tr TO Tr + H„            LOCATE cr, Lc„            COLOR 4, 4„            PRINT STRING$(W, " ")„      NEXT cr„     „      boxOpen = 1„        „            'set up border styles„            BDRtl = 218: BDRtr = 191: BDRlc = 192: BDRrc = 217: 'corners„            BDRv = 179: BDRh = 196:          'horizontal, vertical sides„„         'Bdr top left„         COLOR &HE, 4„         LOCATE Tr, Lc: PRINT CHR$(BDRtl);  'top lt corner BDR„         'top BDR top horizontal„         FOR i = Tr TO Tr + W - 2: PRINT CHR$(BDRh); : NEXT i„         'top BDR Rt corner„         LOCATE Tr, Lc + W: PRINT ; CHR$(BDRtr);„         'Lt BDR vertical„         FOR i = Tr + 1 TO Tr + H - 1: LOCATE i, Lc: PRINT CHR$(BDRv); : LOCATE i, Lc + W: PRINT CHR$(BDRv); : NEXT i„         'bottom rt corner„         LOCATE Tr + H, Lc + W: PRINT CHR$(BDRrc);„         'left corner„         LOCATE Tr + H, Lc: PRINT CHR$(BDRlc)„         'right horizontal„         LOCATE Tr + H, Lc + 1: FOR i = Lc TO Lc + W - 2:„         PRINT CHR$(BDRh); : NEXT„„  CASE IS = 1 'maintain box„         IF boxOpen = 1 THEN„             LOCATE Tr, Lc + 19: PRINT STR$(Percent%); "%"„             Percent% = (Percent% / 100) * 40„             LOCATE Tr + 2, Lc + 2: PRINT STRING$(Percent%, "€")„         END IF„ „  CASE IS = 2„      'Close PercentBox„      IF boxOpen = 1 THEN„       boxOpen = 0„       CALL printScreen(Tr, Lc, H, W, Fg, Bg)„      END IF„  CASE ELSE„END SELECT„„END SUB„„SUB printScreen (Tr, Lc, H, W, Fg, Bg)„„COLOR Fg, Bg„„FOR cr = Tr TO Tr + H„   FOR cc = Lc TO Lc + W„      LOCATE cr, cc„      Attr = ASC(x(cr, cc).Attr)„      Fg = Attr AND &HF„      Bg = Attr \ &H10„      COLOR Fg, Bg„      PRINT x(cr, cc).Char;„   NEXT cc„NEXT cr„„END SUB„Darryl Schneider               ENCODE/DECODE MESSAGE          fish2@datanet.ab.ca            07-17-96 (19:37)       QB, QBasic, PDS        463  12945    QCODE.BAS   'QCode - Version 1.0„'„'Messages can be encoded and decoded„'with QCode. A password is required to„'view a message, and is specified when„'writing a message. Make sure everything„'is in the C:\ directory and you will„'have no problem. Enjoy!„'„'Written by Darryl Schneider„'fish2@datanet.ab.ca„'The QBasic Zone„'http://www.geocities.com/SiliconValley/8191/„'„SCREEN 12                              'set screen mode to 12 and„DEFSTR A-B, D-M, R, U                  'give some standard variable„DEFINT N-Q, S-T, V-W                   'settings„DEFLNG X-Z„„DIM CURSOR(1 TO 500)                    'draw the triangle cursor„LINE (50, 50)-(50, 66), 3„LINE (50, 50)-(66, 58), 3„LINE (50, 66)-(66, 58), 3„PAINT (55, 55), 6, 3„GET (50, 50)-(66, 66), CURSOR„„ENTER = CHR$(13)                        'define all of the arrow keys„UP = CHR$(0) + CHR$(72)„DOWN = CHR$(0) + CHR$(80)„LEFT = CHR$(0) + CHR$(75)„RIGHT = CHR$(0) + CHR$(77)„„MAINMENU:                               'just look at the label to„CLS                                     'find out what this section„LINE (160, 48)-(480, 230), 11, BF       'is about„LINE (160, 48)-(480, 63), 12, BF„LOCATE 4, 38: COLOR 14: PRINT "QCode"„COLOR 15„LOCATE 7, 35: PRINT "Write a message"„LOCATE 9, 35: PRINT "View a message"„LOCATE 11, 35: PRINT "About QCode"„LOCATE 13, 35: PRINT "Quit"„„MM1:                                     'write a message„LINE (240, 70)-(270, 220), 11, BF„PUT (250, 95), CURSOR„DO„A1 = INKEY$„IF A1 = ENTER THEN GOSUB WRITEMESSAGE„IF A1 = UP THEN GOSUB MM4„IF A1 = DOWN THEN GOSUB MM2„LOOP„„MM2:                                     'view a message„LINE (240, 70)-(270, 220), 11, BF„PUT (250, 126), CURSOR„DO„A2 = INKEY$„IF A2 = ENTER THEN GOSUB VIEWMESSAGE„IF A2 = UP THEN GOSUB MM1„IF A2 = DOWN THEN GOSUB MM3„LOOP„„MM3:                                     'go to the about screen„LINE (240, 70)-(270, 220), 11, BF„PUT (250, 159), CURSOR„DO„A3 = INKEY$„IF A3 = ENTER THEN GOSUB ABOUT„IF A3 = UP THEN GOSUB MM2„IF A3 = DOWN THEN GOSUB MM4„LOOP„„MM4:                                     'quit„LINE (240, 70)-(270, 220), 11, BF„PUT (250, 191), CURSOR„DO„A4 = INKEY$„IF A4 = ENTER THEN GOSUB QUIT„IF A4 = UP THEN GOSUB MM3„IF A4 = DOWN THEN GOSUB MM1„LOOP„„WRITEMESSAGE:„CLS„MNAME = ""„MPASSWORD = ""„MESSAGE = ""„MESSAGE1 = ""„SSAVE = 0„„OPEN "C:\UNTITLED.MSG" FOR OUTPUT AS #1„WRITE #1, MPASSWORD„WRITE #1, MESSAGE„CLOSE #1„„OPEN "C:\UNTITLED.MSG" FOR OUTPUT AS #2„LINE (0, 0)-(640, 17), 12, BF„COLOR 14„LOCATE 1, 28: PRINT "QCode - Writing a Message"„COLOR 15„LOCATE 3, 10: INPUT "Message Name (max. 8 characters): ", MNAME„LOCATE 4, 10: INPUT "Message Password: ", MPASSWORD„MNAME = UCASE$(MNAME)„MPASSWORD = UCASE$(MPASSWORD)           'create a message name and„WRITE #2, MPASSWORD                     'password„LOCATE 6, 10: PRINT "Enter Message: "„N1 = 8„N2 = 1„NEXTLETTER1:„DO                                      'message is entered„B1 = UCASE$(INKEY$)„IF B1 = "A" THEN B2 = "^"               'these are all of the character„IF B1 = "B" THEN B2 = "Z"               'representations„IF B1 = "C" THEN B2 = "<"„IF B1 = "D" THEN B2 = ":"„IF B1 = "E" THEN B2 = "W"„IF B1 = "F" THEN B2 = "Y"„IF B1 = "G" THEN B2 = "~"„IF B1 = "H" THEN B2 = "#"„IF B1 = "I" THEN B2 = "N"„IF B1 = "J" THEN B2 = "F"„IF B1 = "K" THEN B2 = "I"„IF B1 = "L" THEN B2 = "."„IF B1 = "M" THEN B2 = "P"„IF B1 = "N" THEN B2 = "X"„IF B1 = "O" THEN B2 = "*"„IF B1 = "P" THEN B2 = "&"„IF B1 = "Q" THEN B2 = "V"„IF B1 = "R" THEN B2 = "H"„IF B1 = "S" THEN B2 = "C"„IF B1 = "T" THEN B2 = "-"„IF B1 = "U" THEN B2 = "%"„IF B1 = "V" THEN B2 = "L"„IF B1 = "W" THEN B2 = "E"„IF B1 = "X" THEN B2 = "A"„IF B1 = "Y" THEN B2 = "B"„IF B1 = "Z" THEN B2 = "?"„IF B1 = "1" THEN B2 = "9"„IF B1 = "2" THEN B2 = "6"„IF B1 = "3" THEN B2 = "4"„IF B1 = "4" THEN B2 = "3"„IF B1 = "5" THEN B2 = "1"„IF B1 = "6" THEN B2 = "7"„IF B1 = "7" THEN B2 = "8"„IF B1 = "8" THEN B2 = "2"„IF B1 = "9" THEN B2 = "5"„IF B1 = "." THEN B2 = "G"„IF B1 = "," THEN B2 = "$"„IF B1 = "!" THEN B2 = "("„IF B1 = "$" THEN B2 = ")"„IF B1 = "@" THEN B2 = "="„IF B1 = "-" THEN B2 = "+"„IF B1 = "*" THEN B2 = "\"„IF B1 = "?" THEN B2 = "/"„IF B1 = "0" THEN B2 = "S"„IF B1 = " " THEN B2 = " "„IF B1 = "'" THEN B2 = "K"„IF B1 = ENTER THEN GOSUB SAVEMESSAGE„LOOP UNTIL B1 <> ""„LOCATE N1, N2: PRINT B1„N2 = N2 + 1„IF N2 = 60 THEN„        N2 = 1„        N1 = N1 + 1„END IF„MESSAGE1 = MESSAGE1 + B1             'puts all of the letters into„MESSAGE = MESSAGE + B2               'one string„B1 = ""„GOSUB NEXTLETTER1„„SAVEMESSAGE:„CLS„LINE (0, 0)-(640, 17), 12, BF„COLOR 14„LOCATE 1, 28: PRINT "QCode - Writing a Message"„COLOR 15„LOCATE 3, 10: PRINT MESSAGE1„LINE (100, 405)-(540, 440), 11, BF„LINE (100, 405)-(540, 440), 12, B„LOCATE 27, 18: PRINT "Save Message"„LOCATE 27, 36: PRINT "Print Message"„LOCATE 27, 55: PRINT "Main Menu"„„WM1:                               'saves the message in .msg format„PUT (115, 415), CURSOR„DO„E1 = INKEY$„IF E1 = ENTER THEN„              WRITE #2, MESSAGE„              CLOSE #2„              FILENAME = "C:\" + MNAME + ".MSG"„              NAME "C:\UNTITLED.MSG" AS FILENAME„              CLOSE #2„              SSAVE = 1„              GOSUB WM1„END IF„IF E1 = LEFT THEN„         LINE (115, 415)-(131, 431), 11, BF„         GOSUB WM3„END IF„IF E1 = RIGHT THEN„         LINE (115, 415)-(131, 431), 11, BF„         GOSUB WM2„END IF„LOOP„„WM2:                                'prints the message„PUT (260, 415), CURSOR„DO„E2 = INKEY$„IF E2 = ENTER THEN„         LPRINT "QCode Message"„         LPRINT ""„         IF SSAVE = 1 THEN LPRINT "File: "; FILENAME„         LPRINT ""„         LPRINT "Original Message:"„         LPRINT ""„         LPRINT "   "; MESSAGE1„         LPRINT ""„         LPRINT "Coded Message:"„         LPRINT ""„         LPRINT "   "; MESSAGE„         LPRINT ""„         LPRINT ""„         LPRINT "QCode was written by Darryl Schneider"„         LPRINT ""„         LPRINT ""„         LPRINT ""„         GOSUB WM2„END IF„IF E2 = LEFT THEN„         LINE (260, 415)-(276, 431), 11, BF„         GOSUB WM1„END IF„IF E2 = RIGHT THEN„         LINE (260, 415)-(276, 431), 11, BF„         GOSUB WM3„END IF„LOOP„„WM3:                                     'return to main menu„PUT (412, 415), CURSOR„DO„E3 = INKEY$„IF E3 = ENTER THEN„         IF SSAVE = 0 THEN„                CLOSE #2„                KILL "C:\UNTITLED.MSG"„         END IF„         GOSUB MAINMENU„END IF„IF E3 = LEFT THEN„         LINE (412, 415)-(428, 431), 11, BF„         GOSUB WM2„END IF„IF E3 = RIGHT THEN„         LINE (412, 415)-(428, 431), 11, BF„         GOSUB WM1„END IF„LOOP„„VIEWMESSAGE:„CLS„N3 = 8„N4 = 1„N5 = 8„N6 = 1„MNAME = ""„MPASSWORD = ""„MESSAGE = ""„MP1 = ""„MP2 = ""„„LINE (0, 0)-(640, 17), 12, BF„COLOR 14„LOCATE 1, 28: PRINT "QCode - Viewing a Message"„COLOR 15„LOCATE 3, 10: INPUT "Message Name (max. 8 characters): ", DNAME„LOCATE 4, 10: INPUT "Message Password: ", DPASSWORD„DNAME = UCASE$(DNAME)„DPASSWORD = UCASE$(DPASSWORD)„JFILE = "C:\" + DNAME + ".MSG"„OPEN JFILE FOR INPUT AS #3              'opens a QCode file for„INPUT #3, MPASSWORD                     'viewing„„VIEWME:„LOCATE 6, 10: PRINT "Message: "; JFILE„INPUT #3, MESSAGE„Y = LEN(MESSAGE)„S = 1„IF DPASSWORD = MPASSWORD THEN                'if password is correct,„        DO                                   'displays decoded message„        B3 = MID$(MESSAGE, S, 1)„        IF B3 = "^" THEN B4 = "A"            'these are all of the„        IF B3 = "Z" THEN B4 = "B"            'character representations„        IF B3 = "<" THEN B4 = "C"„        IF B3 = ":" THEN B4 = "D"„        IF B3 = "W" THEN B4 = "E"„        IF B3 = "Y" THEN B4 = "F"„        IF B3 = "~" THEN B4 = "G"„        IF B3 = "#" THEN B4 = "H"„        IF B3 = "N" THEN B4 = "I"„        IF B3 = "F" THEN B4 = "J"„        IF B3 = "I" THEN B4 = "K"„        IF B3 = "." THEN B4 = "L"„        IF B3 = "P" THEN B4 = "M"„        IF B3 = "X" THEN B4 = "N"„        IF B3 = "*" THEN B4 = "O"„        IF B3 = "&" THEN B4 = "P"„        IF B3 = "V" THEN B4 = "Q"„        IF B3 = "H" THEN B4 = "R"„        IF B3 = "C" THEN B4 = "S"„        IF B3 = "-" THEN B4 = "T"„        IF B3 = "%" THEN B4 = "U"„        IF B3 = "L" THEN B4 = "V"„        IF B3 = "E" THEN B4 = "W"„        IF B3 = "A" THEN B4 = "X"„        IF B3 = "B" THEN B4 = "Y"„        IF B3 = "?" THEN B4 = "Z"„        IF B3 = "9" THEN B4 = "1"„        IF B3 = "6" THEN B4 = "2"„        IF B3 = "4" THEN B4 = "3"„        IF B3 = "3" THEN B4 = "4"„        IF B3 = "1" THEN B4 = "5"„        IF B3 = "7" THEN B4 = "6"„        IF B3 = "8" THEN B4 = "7"„        IF B3 = "2" THEN B4 = "8"„        IF B3 = "5" THEN B4 = "9"„        IF B3 = "S" THEN B4 = "0"„        IF B3 = "G" THEN B4 = "."„        IF B3 = "$" THEN B4 = ","„        IF B3 = "(" THEN B4 = "!"„        IF B3 = ")" THEN B4 = "$"„        IF B3 = "=" THEN B4 = "@"„        IF B3 = "+" THEN B4 = "-"„        IF B3 = "\" THEN B4 = "*"„        IF B3 = "/" THEN B4 = "?"„        IF B3 = " " THEN B4 = " "„        IF B3 = "K" THEN B4 = "'"„        LOCATE N3, N4: PRINT B4„        MP1 = MP1 + B4„        N4 = N4 + 1„        S = S + 1„                IF N4 = 60 THEN„                        N4 = 1„                        N3 = N3 + 1„                END IF„        LOOP UNTIL S = Y + 1„END IF„„IF NOT DPASSWORD = MPASSWORD THEN          'if password is incorrect,„        DO                                 'displays encoded message„        B5 = MID$(MESSAGE, S, 1)„        LOCATE N5, N6: PRINT B5„        MP2 = MP2 + B5„        N6 = N6 + 1„        S = S + 1„                IF N6 = 60 THEN„                        N6 = 1„                        N5 = N5 + 1„                END IF„        LOOP UNTIL S = Y + 1„END IF„       „CLOSE #3„„LINE (170, 405)-(470, 440), 11, BF„LINE (170, 405)-(470, 440), 12, B„LOCATE 27, 28: PRINT "Print Message"„LOCATE 27, 48: PRINT "Main Menu"„„VM1:                                     'prints the message„PUT (195, 415), CURSOR„DO„E4 = INKEY$„IF E4 = ENTER THEN„         LPRINT "QCode Message"„         LPRINT ""„         IF SSAVE = 1 THEN LPRINT "File: "; FILENAME„         LPRINT ""„         LPRINT "Original Message:"„         LPRINT ""„         IF MP1 <> "" THEN LPRINT "   "; MP1„         IF MP2 <> "" THEN LPRINT "    Sorry, you need the password!"„         LPRINT ""„         LPRINT "Coded Message:"„         LPRINT ""„         LPRINT "   "; MESSAGE„         LPRINT ""„         LPRINT ""„         LPRINT "QCode was written by Darryl Schneider"„         LPRINT ""„         LPRINT ""„         LPRINT ""„         GOSUB VM1„END IF„IF E4 = LEFT THEN„         LINE (195, 415)-(211, 431), 11, BF„         GOSUB VM2„END IF„IF E4 = RIGHT THEN„         LINE (195, 415)-(211, 431), 11, BF„         GOSUB VM2„END IF„LOOP„„VM2:                                    'returns to main menu„PUT (355, 415), CURSOR„DO„E5 = INKEY$„IF E5 = ENTER THEN„         GOSUB MAINMENU„END IF„IF E5 = LEFT THEN„         LINE (355, 415)-(371, 431), 11, BF„         GOSUB VM1„END IF„IF E5 = RIGHT THEN„         LINE (355, 415)-(371, 431), 11, BF„         GOSUB VM1„END IF„LOOP„„ABOUT:                                'the infamous about screen„CLS„LINE (0, 0)-(640, 17), 12, BF„COLOR 14„LOCATE 1, 35: PRINT "About QCode"„COLOR 15„PRINT ""„PRINT ""„PRINT "QCode was written in Microsoft QuickBasic by Darryl Schneider. The"„PRINT "program is a message encoder/decoder. To use the program, first write"„PRINT "a message. All message files are saved to the C:\ drive. The message"„PRINT "name that you choose can be a maximum of 8 characters. No file extension"„PRINT "or drive specification is required in the message name. The password"„PRINT "is the key to opening the message. You must know the password to that"„PRINT "particular message in order to decode it. Once you have finished writing"„PRINT "the message, you may view it by selecting the option at the main menu."„PRINT "Then just type in the message name and the password for that message,"„PRINT "and it will be decoded. I included a print option so you can print"„PRINT "out each of the messages. I hope you like the program. Enjoy!"„PRINT ""„PRINT "Darryl Schneider"„PRINT "fish2@datanet.ab.ca"„PRINT "The QBasic Zone"„PRINT "http://www.geocities.com/SiliconValley/8191/"„„LINE (270, 405)-(370, 440), 11, BF          'draw the box at the„LINE (270, 405)-(370, 440), 12, B           'bottom of the screen„LOCATE 27, 38: PRINT "Main Menu"„„PUT (275, 415), CURSOR„DO„G1 = INKEY$„IF G1 = ENTER THEN GOSUB MAINMENU           'return to the main menu„LOOP„„QUIT:„END„„'End of QCode„Jonathan Leger                 FAST PRINT REPLACEMENT         leger@mail.dtx.net             08-01-96 (11:34)       QB, QBasic, PDS        230  9505     XPRINT.BAS  ' This is a TWO part snippet (XPRINT.BAS and XPRINT.8 to follow)„„'******************„'*** XPRINT.BAS ***„'****************************************************************************„'*** This program will demonstrate the superior speed of Xprint over      ***„'*** Qbasic and QuickBASIC's PRINT, COLOR and LOCATE statements.          ***„'*** Xprint is typically about 350% - 400% faster than Qbasic and from    ***„'*** 30% - 60% faster than QuickBASIC.                                    ***„'***                                                                      ***„'*** HOWEVER!  Please note that Xprint() performs _no_ error checking     ***„'*** except for making sure the string is longer than 0 bytes, while      ***„'*** QuickBASIC wont let you print off the screen, etc.  If this program  ***„'*** did that error checking, it would be as slow as QuickBASIC, which    ***„'*** would defeat the purpose! Absence of this error checking is not      ***                                         „'*** dangerous unless you're printing a string that's longer than 16,000  ***„'*** bytes to the screen (and I'm not even sure if that's completely      ***„'*** dangerous...), which will go outside the bounds of your screen       ***„'*** memory.  Anyone, however, who would do this is clearly not too swift ***„'*** (mentally speaking) and probably needs to have his computer crash on ***„'*** him every now and again to wake him up.                              ***„'****************************************************************************„'*** This demonstration program and the Xprint() routines were written by ***„'*** Jonathan Leger (leger@mail.dtx.net), and may be freely distributed   ***„'*** to anybody.  These routines are 100% absolutely no lies or nothin'   ***„'*** FREE to the general public.  You can send me e-mail to praise my     ***„'*** genious if you want, but I require nothing more. *grin*              ***„'****************************************************************************„„DEFINT A-Z„„'*** The declaration of Absolute() is required for QB, which must be loaded„'*** with "/L QB" for it to work.  The declartion in Qbasic is optional.„DECLARE SUB Absolute (arg1%, arg2%, arg3%, arg4%, arg5%, arg6%, arg7%, offset%)„„'*** readyXprint() stores the machine language Xprint() routine, and must be„'*** called before using the Xprint.  Note, though, that it only needs to be„'*** called _once_.„DECLARE SUB readyXprint ()„„'*** The actual Xprint() routine.  Prints s$ to coordintes (x%,y%) on the„'*** screen in color fore%, back%.  Notice, though, that to keep the feel„'*** of BASIC's LOCATE, which is in the format LOCATE Y, X, the Y precedes„'*** the X in the Xprint() routine also.„DECLARE SUB Xprint (s$, y%, x%, fore%, back%)„„'*** This sub is used only in the demonstration, so you can trash it if you„'*** don't want it.„DECLARE SUB testXprint ()„„SCREEN 0„WIDTH 80, 25„„readyXprint       'This routine must be called before using Xprint!„                  'You only have to call it once though. :)„„testXprint        'Lessee some comparisons...„„DEFSNG A-Z„'**********************„'*** readyXprint()    *„'**************************************************************************„'*** This routine loads the xprint machine-language program into the    ***„'*** xprint.asm$ string for use by the Xprint() routine.  This program  ***„'*** _must_ be called before using the Xprint() routine, or the program ***„'*** will crash!                                                        ***„'**************************************************************************„'*** All questions and comments welcome.  Send inquries to the me at    ***„'*** leger@mail.dtx.net                                                 ***„'**************************************************************************„SUB readyXprint„„SHARED asm$„„'*** This is the actual X-print program.„'*** It was written using A86--a truly beautiful assembler!„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(131)„asm$ = asm$ + CHR$(126) + CHR$(10) + CHR$(0) + CHR$(116) + CHR$(66)„asm$ = asm$ + CHR$(139) + CHR$(126) + CHR$(14) + CHR$(131) + CHR$(239)„asm$ = asm$ + CHR$(1) + CHR$(137) + CHR$(251) + CHR$(193) + CHR$(231)„asm$ = asm$ + CHR$(7) + CHR$(193) + CHR$(227) + CHR$(5) + CHR$(3)„asm$ = asm$ + CHR$(251) + CHR$(131) + CHR$(110) + CHR$(12) + CHR$(1)„asm$ = asm$ + CHR$(209) + CHR$(102) + CHR$(12) + CHR$(3) + CHR$(126)„asm$ = asm$ + CHR$(12) + CHR$(139) + CHR$(86) + CHR$(18) + CHR$(193)„asm$ = asm$ + CHR$(226) + CHR$(4) + CHR$(3) + CHR$(86) + CHR$(16)„asm$ = asm$ + CHR$(30) + CHR$(142) + CHR$(94) + CHR$(8) + CHR$(139)„asm$ = asm$ + CHR$(118) + CHR$(6) + CHR$(80) + CHR$(184) + CHR$(0)„asm$ = asm$ + CHR$(184) + CHR$(142) + CHR$(192) + CHR$(88) + CHR$(139)„asm$ = asm$ + CHR$(78) + CHR$(10) + CHR$(138) + CHR$(4) + CHR$(38)„asm$ = asm$ + CHR$(136) + CHR$(5) + CHR$(38) + CHR$(136) + CHR$(85)„asm$ = asm$ + CHR$(1) + CHR$(70) + CHR$(71) + CHR$(71) + CHR$(226)„asm$ = asm$ + CHR$(242) + CHR$(31) + CHR$(93) + CHR$(203)„„END SUB„„DEFINT A-Z„SUB testXprint„„LOCATE , , 0„CLS„„LOCATE 1, 1„COLOR 7, 0„PRINT "XPRINT"„„t.xprint# = TIMER„FOR redraw = 1 TO 100„   back = INT(RND * 7) + 1„   FOR y = 2 TO 25„       Xprint STRING$(80, " "), y, 1, 7, back„   NEXT y„NEXT redraw„t.xprint# = TIMER - t.xprint#„„CLS„LOCATE 1, 1„COLOR 7, 0„PRINT "BASIC"„t.basic# = TIMER„FOR redraw = 1 TO 100„   COLOR 7, INT(RND * 7) + 1„   FOR y = 2 TO 25„      LOCATE y, 1„      PRINT STRING$(80, " ");„   NEXT y„NEXT redraw„t.basic# = TIMER - t.basic#„„COLOR , 0„CLS„PRINT "XPrint redrew the screen 100 times in"; t.xprint#; "seconds."„PRINT "BASIC redrew the screen 100 times in"; t.basic#; "seconds."„PRINT„PRINT "XPrint was approximately"; INT((t.basic# / t.xprint#) * 100); "% faster."„END SUB„„'*****************„'*** Xprint()    *„'**************************************************************************„'*** Arguments:                                                         ***„'***     s$       =     string to print                                 ***„'***     y%       =     line to print at                                ***„'***     x%       =     column to print at                              ***„'***     fore%    =     foreground color (normal BASIC numbering used)  ***„'***     back%    =     background color (normal BASIC numbering used)  ***„'**************************************************************************„'*** This routine was written by Jonathan Leger (leger@mail.dtx.net)    ***„'*** using the A86 assembler.  The assembly-language file can be viewed ***„'*** for further study (XPRINT.8).                                      ***„'**************************************************************************„'*** All questions and comments welcome.  Send inquries to the above    ***„'*** e-mail address.                                                    ***„'**************************************************************************„SUB Xprint (s$, y%, x%, fore%, back%)„„SHARED asm$„„DEF SEG = VARSEG(asm$)„   CALL Absolute(BYVAL back%, BYVAL fore%, BYVAL y%, BYVAL x%, BYVAL LEN(s$), BYVAL VARSEG(s$), BYVAL SADD(s$), SADD(asm$))„DEF SEG„„END SUB„„;--------------------8<----[ Begin XPRINT.8 ]---->8---------------------„„;*** Xprint for BASIC.„;*** Prints a string to coordintes y%, x%, with color f%, b%, real fast. :)„;*** call like this:„;***„;*** Call Absolute (b%, f%, y%, x%, len(s$), sadd(s$), varptr(s$), offset%)„;***„;*** WARNING:  This routine does _no_ error checking to see if you're going„;***           off-screen with the string (for speed purposes), so please„;***           be sure to check that in your program!„„PUSH BP     ;preserve BP!„MOV BP,SP„„STRUC [BP]„  JUNK1   DW  ?„  JUNK2   DW  ?„  JUNK3   DW  ?             ;the junk we don't need!„  STR_OFF DW  ?             ;our string pointer [bp+6]„  STR_SEG DW  ?             ;our string segment [bp+8]„  LEN     DW  ?             ;our string length [bp+0a]„  X       DW  ?             ;our x location [bp+0c]„  Y       DW  ?             ;our y location [bp+0e]„  FORE    DW  ?             ;foreground color [bp+10]„  BACK    DW  ?             ;background color [bp+12]„ENDS„„CMP LEN,00„JE Done„„MOV DI,Y                    ;get the offset for the starting character„SUB DI,1                    ;using the formula:„MOV BX,DI                   ;     ( ( ( Y - 1 ) * 80 ) + X )„SHL DI,7„SHL BX,5„ADD DI,BX„SUB X,1„SHL X,1„ADD DI,X                    ;DI now contains the starting offset.„„MOV DX,BACK                 ;calculate the color value using the formula:„SHL DX,4                    ;     ( FOREGROUND + ( BACKGROUND * 16 ) )„ADD DX,FORE„„PUSH DS„„MOV DS,STR_SEG              ;string segment„MOV SI,STR_OFF              ;string offset„MOV ES,0B800                ;screen offset for color scren 0„MOV CX,LEN„„PrintChar:„MOV AL,DS:[SI]              ;put next character into AL„MOV ES:B[DI],AL             ;write it to screen„MOV ES:B[DI+1],DL           ;write color value to screen„INC SI                      ;next character„INC DI,2                    ;next screen coordinate„LOOP PrintChar„„Done:„„POP DS                     ;restore DS for BASIC„POP BP                     ;restore BP for BASIC„RETF                       ;return to BASIC!„Kurt Kuzba                     LINE INPUT REPLACEMENT         FidoNet QUIK_BAS Echo          03-21-96 (00:00)       QB, QBasic, PDS        82   3422     ELVIS.BAS   '>   Is here a way to get rig of cntrl-break?„'>................„'   Use INKEY$ instead of INPUT. Have a look at this.„'_|_|_|   ELVIS.BAS„'_|_|_|   This program allows the input of 'larger than life'„'_|_|_|   strings with limited editing windows on the screen.„'_|_|_|   BACKSPACE, HOME, END, LEFT, RIGHT, INSERT, DELETE,„'_|_|_|   and ESCAPE are all active in the input routine.„'_|_|_|   No warrantees or guarantees are given or implied.„'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (3/21/96)„DECLARE SUB Elvus (prompt$, max%, winsiz%, S$, sequins%)„DECLARE FUNCTION Elvis$ (prompt$, max%, winsiz%, S$, sequins%)„PRINT„Path$ = "C:\": p$ = "Please Enter Your Path =>"„Mystr$ = Elvis$(p$, 32, 8, Path$, 0)„PRINT : PRINT UCASE$(Path$): PRINT Mystr$„Pass$ = "": p$ = "Please Enter Your Password =>"„Mystr$ = Elvis$(p$, 32, 8, Pass$, 1)„PRINT : PRINT UCASE$(Pass$): PRINT Mystr$„IF Mystr$ <> "friend" THEN PRINT "Wrong Password":  ELSE PRINT "OK"„FUNCTION Elvis$ (prompt$, max%, winsiz%, S$, sequins%)„   Elvus prompt$, max%, winsiz%, S$, sequins%: Elvis$ = S$„END FUNCTION„SUB Elvus (prompt$, max%, winsiz%, S$, sequins%)„   S$ = LTRIM$(RTRIM$(S$)): Cursor% = LEN(S$) - (Cursor% < max%)„   F$ = "_": IF sequins% <> 0 THEN F$ = " "„   Fill$ = STRING$(max%, F$)„   S$ = LEFT$(S$ + Fill$, max%): INS% = -1: PRINT prompt$; " ";„   Ybase% = POS(0)„   WHILE done$ <> "DONE"„      Sbase% = Cursor% - winsiz% + 1: IF Sbase% < 1 THEN Sbase% = 1„      LOCATE , Ybase%, 0: Hid$ = STRING$(LEN(RTRIM$(S$)), "*")„      IF sequins% = 0 THEN„         PRINT MID$(S$ + Fill$, Sbase%, winsiz%); " ";„      ELSE„         PRINT MID$(Hid$ + Fill$, Sbase%, winsiz%); " ";„      END IF„      LOCATE , Ybase% + Cursor% - Sbase%, 1„      k$ = "": WHILE k$ = "": k$ = INKEY$: WEND„      k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))„      SELECT CASE k%„         CASE 32 TO 127„            IF INS% AND Cursor% < max% THEN„               MID$(S$, Cursor% + 1) = MID$(S$, Cursor%)„               S$ = LEFT$(S$, max%)„            END IF„            MID$(S$, Cursor%, 1) = k$„            IF Cursor% = max% THEN SOUND 999, 1„            Cursor% = Cursor% - (Cursor% < max%)„         CASE 13: IF S$ = Fill$ THEN S$ = ""„            IF INSTR(S$, F$) > 0 THEN S$ = LEFT$(S$, INSTR(S$, F$) - 1)„            EXIT SUB„         CASE 8„            IF Cursor% > 1 THEN„               Cursor% = Cursor% - 1„               MID$(S$, Cursor%) = MID$(S$, Cursor% + 1)„               MID$(S$, max%) = F$„            ELSE„               SOUND 999, .7„            END IF„         CASE 27: S$ = "": EXIT SUB„         CASE -71: Cursor% = 1„         CASE -79: Cursor% = INSTR(S$, F$)„            IF Cursor% = 0 THEN Cursor% = max%„         CASE -82: INS% = -(INS% + 1): SOUND 1500 + 800 * INS%, .5„         CASE -83„            IF Cursor% < max% THEN„               MID$(S$, Cursor%) = MID$(S$, Cursor% + 1)„               MID$(S$, max%) = F$„            ELSE„               SOUND 999, .7„            END IF„         CASE -75: Cursor% = Cursor% - 1„            lim% = INSTR(S$, F$): lim% = lim% - max% * (lim% = 0)„            IF Cursor% < 1 THEN Cursor% = lim%„         CASE -77: Cursor% = Cursor% + 1„            lim% = INSTR(S$, F$): lim% = lim% - max% * (lim% = 0)„            IF Cursor% > lim% THEN Cursor% = 1„      END SELECT„   WEND„END SUB„'_|_|_|   end   ELVIS.BAS„Ryan White                     R-RAD TYPER                    BIGFOOT@InfoAve.Net            09-21-96 (17:53)       QB, QBasic, PDS        131  3934     KRAD.BAS    'Rrad typer...  Kinda like krad, only made by me so I can understand it.„'By Ryan White„'Feel free to change and mess with it.„'Suggested edits: make colors 1-15 more intense with out-commands, put in a„'                 text menu like interface, make the characters where U can„'                 read them your way, make it where you type a normal page,„'                 and the program converts the page to Rrad.„' Warning to newbies  DONT use ASC #'s 0 to 32!!!   Just dont.„SCREEN 0, 0, 0, 0„CLS„WIDTH 80, 50„COLOR 15, 0„ON KEY(1) GOSUB chngcol: KEY(1) ON„ON KEY(2) GOSUB clr: KEY(2) ON„ON KEY(3) GOSUB redo: KEY(3) ON„ON KEY(4) GOSUB enditnow: KEY(4) ON„PRINT "This is R-rad typer.    Just type the letter and it's done."„PRINT "Commands: Press F1 to change colors, F2 to clear screen, F3 to restart,"„PRINT "and F4 to quit.  ****  To get the effect of pressin enter.. you must type"„PRINT "an appostrophe(`)  The thing next to the 1.": PRINT„INPUT "Enter new filename and extension:", fle$„OPEN fle$ FOR OUTPUT AS #1„CLS„st:„DO„Ans$ = INKEY$„LOOP UNTIL Ans$ <> ""„IF col >= 75 THEN col = 0: PRINT : PRINT #1,„SELECT CASE UCASE$(Ans$)„ CASE "A"„  PRINT "í"; : PRINT #1, "í"; : col = col + 1„ CASE "B"„  PRINT "·"; : PRINT #1, "·", : col = col + 1„ CASE "C"„  PRINT "<"; : PRINT #1, "<"; : col = col + 1„ CASE "D"„  PRINT "|)"; : PRINT #1, "|)"; : col = col + 2„ CASE "E"„  PRINT "‰"; : PRINT #1, "‰"; : col = col + 1„ CASE "F"„  PRINT "ü"; : PRINT #1, "ü"; : col = col + 1„ CASE "G"„  PRINT "G"; : PRINT #1, "G"; : col = col + 1„ CASE "H"„  PRINT "]-["; : PRINT #1, "]-["; : col = col + 3„ CASE "I"„  PRINT "≥"; : PRINT #1, "≥"; : col = col + 1„ CASE "J"„  PRINT "ı"; : PRINT #1, "ı"; : col = col + 1„ CASE "K"„  PRINT "]<"; : PRINT #1, "]<"; : col = col + 2„ CASE "L"„  PRINT "ú"; : PRINT #1, "ú"; : col = col + 1„ CASE "M"„  PRINT "/\/\"; : PRINT #1, "/\/\"; : col = col + 4„ CASE "N"„  PRINT "¸"; : PRINT #1, "¸"; : col = col + 1„ CASE "O"„  PRINT "()"; : PRINT #1, "()"; : col = col + 2„ CASE "P"„  PRINT "û"; : PRINT #1, "û"; : col = col + 1   'just imaging the t wasn't there„ CASE "Q"„  PRINT "q"; : PRINT #1, "q"; : col = col + 1„ CASE "R"„  PRINT "‚"; : PRINT #1, "‚"; : col = col + 1„ CASE "S"„  PRINT "$"; : PRINT #1, "$"; : col = col + 1„ CASE "T"„  PRINT "—"; : PRINT #1, "—"; : col = col + 1„ CASE "U"„  PRINT "Å"; : PRINT #1, "Å"; : col = col + 1„ CASE "V"„  PRINT "\/"; : PRINT #1, "\/"; : col = col + 2„ CASE "W"„  PRINT "\/\/"; : PRINT #1, "\/\/"; : col = col + 4„ CASE "X"„  PRINT "><"; : PRINT #1, "><"; : col = col + 2„ CASE "Y"„  PRINT "ù"; : PRINT #1, "ù"; : col = col + 1„ CASE "Z"„  PRINT "z"; : PRINT #1, "z"; : col = col + 1„ CASE "!"„  PRINT "≠"; : PRINT #1, "≠"; : col = col + 1„ CASE "?"„  PRINT "®"; : PRINT #1, "®"; : col = col + 1„ CASE "1"„  PRINT "I"; : PRINT #1, "I"; : col = col + 1„ CASE "2"„  PRINT "II"; : PRINT #1, "II"; : col = col + 1„ CASE "3"„  PRINT "III"; : PRINT #1, "III"; : col = col + 1„ CASE "4"„  PRINT "IV"; : PRINT #1, "IV"; : col = col + 1„ CASE "5"„  PRINT "V"; : PRINT #1, "V"; : col = col + 1„ CASE "6"„  PRINT "VI"; : PRINT #1, "VI"; : col = col + 1„ CASE "7"„  PRINT "VII"; : PRINT #1, "VII"; : col = col + 1„ CASE "8"„  PRINT "VIII"; : PRINT #1, "VIII"; : col = col + 1„ CASE "9"„  PRINT "IX"; : PRINT #1, "IX"; : col = col + 1„ CASE "0"„  PRINT "ß"; : PRINT #1, "ß"; : col = col + 1„ CASE "`"„  PRINT : PRINT #1, : col = 0„ CASE "."„  PRINT "."; : PRINT #1, "."; : col = col + 1„ CASE " "„  PRINT " "; : PRINT #1, " "; : col = col + 1„END SELECT„GOTO st„„chngcol:„c = INT(RND * 15) + 1„COLOR c„RETURN„clr:„CLS     'WOW„RETURN„redo:„CLOSE #1„OPEN fle$ FOR OUTPUT AS #1„CLS : PRINT "Filename is empty..."„PRINT "Type on...": PRINT : PRINT„RETURN„enditnow:„CLOSE #1„PRINT "Done editing.  "; fle$; "is alive now.   Have fun.  Byebye"„END„Kurt Kuzba                     FAST GET/PUT TEXT              FidoNet QUIK_BAS Echo          09-24-96 (00:00)       QB, PDS                105  6894     GPTXT.BAS   DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"GPTXT.ZIP",4^6:Z&=4898:?STRING$(50,177);„U"%up()%9%%%R-%=d7qFg\6+GF'.%%k(%%%.%%%%lu(y'yS#tgoD&atm9mvA#8q>E„U"ofleesTe99GI3<5_v<W3buQth<Q9gSg]CMahD%MmGm\pho[H>bnCJaUr\$'lab.„U"J-QGf5mVw8kIcEYIQ<1[pQs82lE%.nIU8ruwWhp3WKNDE_p3<Zsw-L?lgr#>']9„U"pYe/)KR.uLT:q%FIEF3U,<AfEe8yyKiPA==;tT\jK3q?yUOy[h;)Y3MCO\#Z(dT„U"JP^7fiEVHLG:<.X$5+6f<ZyVj=[hfUm0-HapYy.kxJrJIXp%ma2ZCA:;vg\v%HY„U"hz2y(iSQmcd&gi(T;_<1j<9IwQ,)qpTVzUODz1ZQmM$'=I'B9Ue]*P$0vx'1I(T„U"UU7+xbQSe_9B2(b[fQ,f:1?cW&N,ou>1g=dJlSJ+WZ#_MA/&LH/NY1Kc+[&RlM=„U"Adp+Gr6[8+j6bK/90BViE/0'+8L92jTc-Ml5Ax3d(a#l939skj68E/i/hw4&Hh/„U"h?_.740hK:0;qum_9fwic>p0k52l?Ss<#xN6NN,I&Z0/^3,,_4'n.C8fVdp<5e&„U"ytIp7qsYQd5wfBZ/BzM0;E(-C_*p*:)\r&H6AJ2IU0E/V=a]MT#wG2T=/N^1-An„U"*aoa&roX7#.8gn2le5#^EHzDr\NFjxGTM'A()aSRB\5wjR,NSS-Zr_lB7S\K=j9„U"Q/I+UPHcsg1Qt(__2YjPOXoOBgZ>qBun[(Fle5b*r^arGB:.bwiHXO4izmWI&Cc„U"OpK,>>=%fSyG>MIgy)sX]OSXNG8uqtjb1F8Wkr)]QXk=:8Q0-==]wI?F]xj<iXv„U"EKbrAlF2Y1j[*CNa'#Dup%()9%%%%-%*\dqFTpCRe'32%%'N:%%%.%%%#luy'%y„U"SvqOgfgJACyze$?FzVW3d'c^FR=b[1KR<XiSQw%N*F8(3H:5#hmw_C/_s(\HfE(„U"H'3:Kq1oSOGGbeR/R=D;%'_S98*-V8RCh^P1+XVV]I-F/OGS)pD7if-WK(MKHpM„U"*+fwXNHe)xxXlvoHfbBoc$iWj3G9;5vX/xYRG'qAX6YLjY<N-TaW]Ae8bbgb&iC„U"-g&5&Pgu/%C(pe^8GA-SO<9)0)6;';>Rpf+La&L3:8?&\+(k<%VxG=a4g*L7e;A„U"(E>/Fw.%pP<Ia.%Pa<:[)+8e&b'Y5].^sR0929S>UaCU0K09Y_*BkeV'7-O9wBY„U"*tQazYj)j3-RF8/#Q.EoOC?%-A&L?:PYQB1-kOe3_5+/PV/A8g%g(14PN&[^EDE„U"1(4o/'M&*aC2M2%VRf9://PG<oe't9+&iVU1FN#E(C[+.n/A)K,0MDk*V0xXsJK„U"<]5tb/;.M':2GX-6;g'>RpIfL'WH/41-]CWKK\zE-sN9nO;LosI?+5AwGfV&i9_„U"NQCie[^$wlxlNl^X.b4lk%\sdAHSD>DcUBgty2-S)W_2Z&2N#u..]Sn=(c[3MaG„U"v26?+2B%=rM4^)11(N2(P2;s[3Q%)a140%WFa*nWrktZd-.[w/zXBOVThC4GY,c„U":V74N)x3Dj)5bbIierWNO\yLVtDc*c_xB3Oj40ak-_%B<xUv6&N#V,k%_S^3kwD„U"jlMQdeu8<VUNy^%W$W\qicWhcu1qmY=o#AKAY]UrOaN0L9?Y5dYqw^f5V[rVc?x„U"]?>jjuELkz)104:2A6r&P:$j)QHY7*A$_Qgs=KKEZ/OUh\DSgQ&]WDgpVG4%p=G„U"DAG]qg%#rP?k\%NNqek7D]&lAC7682#k&B_fv_G*X[hk]QxBk0F];ykqw(fV&bL„U"brG$x+:_7xm&Dp#\FI.2<RtShd$TIwM61j3vL4sEJ3LM0JohTK^UdapmLZA\LY\„U"5=='hgGGGbHvX_zwUncDOn$.MGn,B0#Gb59e7AOSLAD/5Bm,dJnTh/*hzH\<h#e„U"=hcJ*WT24ckSm=XPwm->ZesfM4N6v^]5SASFCwpAueI3k,-SpTF2x,DXqGaG(Mr„U"H[kr<kJt0Ca)q3CEG<a_LGZ<(K-uDSiNMdL68jw]]w>dV$m^Bk92:LaMhZgWAsE„U"v3H^P878YKrH8^9Z>\*9\J\)&rPm9-wE:YFwqx&:uqiL$'oqZ4h'/1ST41QS%/h„U"F^*<9g8C*\MH5L:[tvi4'$Y7/8K^/]p0iK&UtP;f'$Y'/8']/Kw-1F:AFlZ<+]:„U"I/(/A*NkB<tj+c:jY%ReKI?IbITUA:E88TQ22fAUpHJkXGSiaiVPb1?rzriPG,#„U"di:h-qFTk'upB+:+m&nVSU\%U5eb#+lk$(8Bo$cc]\16.2+%6?pzf->D77r_j1>„U"p$<'>*>R;K.l:yb[MR>$uKNx&X)?0tN4.wB&xpBfj>NgyvYMZUNANvfV[BSqWIo„U"=3ZOGJOmMDBnhEKQ$;$>52v/YmX*,SMNoWlklqI^Z)yQ.KDteS>qCPYhKcmUuWO„U"dVuMK;rF7)tn2'P]f^KJPXPdf,j;V#YN%SB[fJ8F1YZMH?\f]FG?;ojk[T*3AKc„U".Dcoc[/)UnMLVp;Fob+p8RD3bj8I:OC/L&rtlq)0C6lBudjbl,vQoFkJ;0#DonF„U"i>(K?6n(oF1yE,$o^kc);5CQUDBX0vr?x>YDPjjTF#)U<)g9x:TUhBP)?[;kqO$„U"kLO9n(2OvBF>SdTiV[xCVtE8Xkv]oT/>t-01D4Z8z,.x,EmIltjI2IFg_+LShTa„U"xa]nu4]DkIU>dglorG6_TUNB?+4>Cjyexx,4h?=HwgBnD0j[<;YiiX2+aaM&trC„U"l0o-AWS9\.KupGcgne4[Tu3lux?&od(R_#eJ494IMWn/YJ_HHgt;5R/0qY46SA2„U"_?ekrF*o]I;#.jKerEAe]QpDBib3pGZ48r=doP(2lKO#ONiyPlff_K*jPhIkx7)„U"83h-=SIEkA's:JS'i\nZH#_?dp0$4;9$oDr0$<kc?a?L%AvVbxq[eTSe5?FFE_F„U",I>ti2cB21\(MnKvP6AKZ)ULxL^:x/s5e$w7h1O;n%<P9UV/YBIrS$w8G5Mi\FW„U"]rfSBvW'JrL6QsE31Z,^U,xtdx4N07zsO8DbwJ53%eg)S9psYagf9/Q/8WooTd;„U"hX,BQP0Wg6v9*[\#c#-q]8w,flfo3q$d-obT0]F3y2lKkWi.X=2DL2QtZpYmERN„U"8MRkJ8sIswmp#A7H<^>S\NfaZgPEhjSH47h8=q%0<QO<f^?I>:vQmP/s&q5OZ8H„U"ZvoD1oh7-6nJxX43NRi1Z_rHWaRMGfk<XXnZpxqLrR8A$PFxoel,,kvtd,AvTY&„U"i/9t9uO7*H&b%8kdQhJJ--NcpE6rMGqEF[ZaIQE.Fv]x6a=$Ma=UY;,ue]I'a0o„U"<*c]gWitu7([s[sZ#Qc\WP.FqoAX]r9VKCrd4]<5,ff$gH$&;3xsm1*m]?=rSP\„U".n:;8TL$k],t=71'Lz9l6_;TDUlKgAU50v9fMkI49f76>dSw#xTZh<pxmLr\5sN„U"cJ/cgmPw_gxnt3AFJ]+fqA-n:d4kuYN5g\HnBaH>+8a?HmYFVV/idj^,?oF8Gk#„U"JE$62m]p\EHGRhkXbER3iGu?o(-6x^5j:(Kh6(k^YA_Y;:K6,]5jF(CM6^A%E9(„U"F6Cjk:BZ_]%SIX<6tSkRY;1F6Z]YzY%aT,OGyU^zZ;U.6.k4R^;>26DkZt?O=RT„U"(]lAc_\qZ6EH(XG6D^JYQ,X?Koa6zF^tR6e:]*DHRh]*HHRpk0vP6#g]Jh,h\k<„U"ZJ;P6>GAo;6ZxGREZGW\;(,6$^6dY;<q6NYeq^kf^e;D6Vkkn?OcDR&G=cYeh?G„U")XD,B?^$HER%6[l]$C3RvkBH$e)6hRkl]q;W,HF]tX6;nBo*_6v]tYa,LktL<R0„U";klZQcER^GLS?EXc,h^4&U8H&.XemHRV%B]5':<EO3urMsCh-L4Eo4%<u+TD$3l„U"o$q5dGF7RREOaRERFoGOFG1Rllz#_$\JEgk^BL03i0cxjF8Xhuu>8nXj]fEkNVG„U"GSlnr\Px3iovn^bDJ;6+?a8x[^_>aGSb3R)uvqS=vw?9XTm%-5NBcPBC+N)V>bC„U"S;]$g:)IfyE'mCN_2MacS2CicGdYlYGrpwm.*I1Nr0MTaK(.,Qb&Xdw19mPbV)R„U"e:H#bJb5qNlEm)QcK8hC\c*;(zXE<n2nk/Iza2P)t%XY)-sFks*E&qMfWW#N>jJ„U"Z0mbvlSq^>(/[YMN.WMnIp[RufXo%Juh5Ww5Fbw=^Tjna5<_N8hi/%=u14EDgjH„U"QRFMmfBPhIx5bjIQ6)k>S<M)1MjOYx=B3SD<B:Z5uZ+4&\\Y>M_JcU5rmM*4M&<„U"a9,z9aklW;pj>_6Emm^mRsdxO,ll1uVtF+,whXxhf%NQmAHC#NF84iuxHFJGG7Z„U"FbYs0_o-)&ui6Hbi2:_&.?.BH/Lrc*SCsc#T1saNTYC+u:>pL^Wg6Nm5(uwpD3h„U"eNHqCXg#PztH)8-Nm^l6wFkPJJLb9X<3zIS<MMgT>]gkfu[I-vkxgHt]LSUC$TT„U")mcpjrx>^Pc=bZJ$X37s5FRU$a.x#*O5GaX23ZeVp8\KnUs,#(b1il0kX?*%IY%„U"lWTk6aLZ3W(zb,PN3jsLD3r'(3_fc_*P(gZilYplZ.TLj3%L-d7X.Js78csv.n=„U"ta3g9Pz3c_v:POH&vH0A\uGFMTF(tmwlgcE#zPj8zZ&zWA,hxn<E0(?B,5fhzCJ„U"c;LZnKl0#.$dxa-F6%MzO8fQlNfDYr/OfBh,I'p>#WE#GCHHDRlj,4uBP*fz%q7„U"5g5DHwMkITiz&*5mK=s2w33TCJNdlDA(&lEH<'P=I+3a:HTAdRSU^6o]3z>IccO„U"he$2/6,1w-6[K3g(s5[zr1z6WHs?OA<]X//?puu7,^Pl8J=YIy05Iky4Zse\pj6„U"oq/ezH9I4'>w5Yoyhla;7i$PZc7HS>2ms_ZHrXi6,I7V^$b#_0X/pqB&0g6hyOD„U"L/ur1[Tvs#fg?jE>Km#bb'o>drhs.W+u/pgk[w%3(y:e^ahG%daF).Y&jty,zmC„U"c]E20LQW)_4i0&8IV;s7yr/(,-Oas9nW%U4;oV4sPDXHu.-^<)\:?c?K\.8__+i„U"DZr0nC4.h[Yu%,;0XXm0r2JbuCJ.GDSg_f5##;t;'oODJe[I2>d9#:ix?x&XP;J„U"nI[MMTOzd*BazU--0*4]#aM-vOgnm\K7#M00bc0Z&%j#V5b(%pu64*2r'uG,C]9„U"Z&k&cmns(Q-1+C#pXSKrJ:om9qdu*lFQY%&0Ft#^&ncMMRO(Pj.,9Mb,UqIO,$c„U"_]wM_C3;4SBW$4m/HDbqsQrror9&CU;&5<X&72S8fU9<S5[E;)KBNLFpm8r-,$;„U"]N$$m>%FyULIXdN==[^WUmil5N=&72]VQhR^VaB:kZ%2rG,1v4u%p()9%%%%-4%„U"KdqLFK\\,z6&%%%h(%%%0%%%%ljy&.uzy%SgfxJdx,>Aje5KFl[d[5qQP+m6hf/„U"c1c(Y(0pFe*YkKt=;'(SAa(NkrttwqdC5;#atfF&qEVR2/l:kR]wY4=fj-,=DBy„U"$E[Op,1G*'=G4.G93Wwd:2tkw]ASY:[<Vj%^ef$*zn^<\.tH/FP%<<Zbb9NH$H9„U"+?036m9Fu5%I>(B$jl'0[l%zG(:>:j-d<ob+]ZO3rF%Yt7wq-uBRcqT+2D9*/9K„U"*c[28qUS5J\NfVq-uw;n/T[Gu-J5_o's<_q;qIrCKP[1PlL5sBv)Fu]4MFEOCVw„U"pDqt,/r;p,LGDVvP/_:JpX&WNIxAY(k:$usl+wah66i)>_N8gxTl;74Njm.Gp=9„U"Ii.[X.+heSaj3>Y7(1I-N_slwm&dh9)Fr;9LLW+js7:P=9dN[i>7;6o#s:F#lW-„U"k\W.x7>TrF2vZ+M>CsM=geIIJma#NHzl,Y:$M&un,.A%Y46')Qpq4[>vPddE1c5„U":k?O&wLL'FGZqe0sjvh^zR7.b#+0?i1XeSBtYZ[hu?Rmbnn#pkK8aGtL8x<dp8p„U"op/>#;?.*(2kz&Jd(,n>Pt%#8C&.up&%'9%9%%%%-4%=dqaFg\+*GF'%(%k(%%%„U".%%%%%%%%%%%E%%%%%%%%%l.uy'y%Stgo%up&'%9%9%%%%-%*\dqFTpCRe'32%%„U"'N:%%%.%%%%%%%%%%%E%.%%m'%%%lu(y'yS%vqgu%p&'9%%9%%[%-%KAdqFKh\\„U"z6%&%%h%(%%0%%%%%%%%%&%%E%%(%N5%%%ljy&.uzy%Sgfx%up*+%%%%%%(%(%&„U"v%%%&47%%%%%„END SUB„CLOSE:IF S=116AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Kurt Kuzba                     FILE SEARCH TO FIND TEXT       FidoNet QUIK_BAS Echo          02-28-96 (00:00)       QB, QBasic, PDS        50   1947     FINDTEXT.BAS'>   I want to write a program that searchs through a file„'>   to find a specified string.  This program is pretty„'>   common to those who want to test their programming„'>   knowledge, but I've never attempted it.„'>   I need suggestions/guidance.„'>........„'   How about a working example?„'_|_|_|   FINDTEXT.BAS„'_|_|_|   This program performs a fast file search for any given„'_|_|_|   text, selectively allowing case sensitivity.„'_|_|_|   Full overlapping is implemented for instances where the„'_|_|_|   text might span the input buffer boundaries.„'_|_|_|   No guarantees or warrantees are given or implied.„'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (2/28/96)„ON ERROR GOTO OOps„FileToSearch$ = "": COLOR 2, 0: CLS : LOCATE 3, 1„INPUT " Enter file name => ", FileToSearch$„IF FileToSearch$ = "" THEN CLOSE 1: END„INPUT " Enter text to find => ", text$„PRINT " Search case sensitive (y/n)? ";„IF text$ = "" THEN END:  ELSE L% = LEN(text$): Overlap$ = ""„DO„   sensitive% = INSTR(" YN", UCASE$(INKEY$))„LOOP WHILE sensitive% < 2„PRINT MID$(" YN", sensitive%, 1)„IF sensitive% = 3 THEN text$ = UCASE$(text$)„OPEN FileToSearch$ FOR BINARY AS #1„PRINT TIME$„WHILE NOT EOF(1)„   test$ = Overlap$ + INPUT$(4096, 1): TL% = LEN(test$): strpos% = 0„   IF sensitive% = 3 THEN test$ = UCASE$(test$)„   WHILE strpos% < TL%„      found% = INSTR(strpos% + 1, test$, text$)„      IF found% THEN„         strpos% = found%„         PRINT "Text found at"; LOC(1) - LEN(test$) + found%;„         PRINT "   O>=* hit a key *=<O"„         WHILE INKEY$ <> "": WEND„         k$ = "": WHILE k$ = "": k$ = INKEY$: WEND„         IF k$ = CHR$(27) THEN CLOSE 1: END„      ELSE„         Overlap$ = RIGHT$(test$, L%): strpos% = TL%„      END IF„   WEND„WEND: CLOSE 1„PRINT "end of file": PRINT TIME$: END„OOps:„ PRINT " Disk error or bad file name ["; ERR; "]"„ CLOSE 1: END„'_|_|_|   end   FINDTEXT.BAS„