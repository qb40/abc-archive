Mike Ginger                    QB ERROR CODES EXPLAINED       FidoNet QUIK_BAS Echo          11-13-96 (01:29)       Text                   29   1887     ERRCODES.TXT Code    Message                    ∫  Code    Message„                                    ∫„ 1       NEXT without FOR           ∫  37      Argument-count mismatch„ 2       Syntax error               ∫  38      Array not defined„ 3       RETURN without GOSUB       ∫  40      Variable required„ 4       Out of DATA                ∫  50      FIELD overflow„ 5       Illegal function call      ∫  51      Internal error„ 6       Overflow                   ∫  52      Bad file name or number„ 7       Out of memory              ∫  53      File not found„ 8       Label not defined          ∫  54      Bad file mode„ 9       Subscript out of range     ∫  55      File already open„ 10      Duplicate definition       ∫  56      FIELD statement active„ 11      Division by zero           ∫  57      Device I/O error„ 12      Illegal in direct mode     ∫  58      File already exists„ 13      Type mismatch              ∫  59      Bad record length„ 14      Out of string space        ∫  61      Disk full„ 16      String formula too complex ∫  62      Input past end of file„ 17      Cannot continue            ∫  63      Bad record number„ 18      Function not defined       ∫  64      Bad file name„ 19      No RESUME                  ∫  67      Too many files„ 20      RESUME without error       ∫  68      Device unavailable„ 24      Device timeout             ∫  69      Communication-buffer overflow„ 25      Device fault               ∫  70      Permission denied„ 26      FOR without NEXT           ∫  71      Disk not ready„ 27      Out of paper               ∫  72      Disk-media error„ 29      WHILE without WEND         ∫  73      Feature unavailable„ 30      WEND without WHILE         ∫  74      Rename across disks„ 33      Duplicate label            ∫  75      Path/File access error„ 35      Subprogram not defined     ∫  76      Path not found„Kurt Kuzba                     SPLIT/CONCATENATE FILE         FidoNet QUIK_BAS Echo          11-29-96 (09:43)       QB, QBasic, PDS        57   2133     SPLITTER.BAS'I recently had a use for a program to split files apart and„'restore them to the original again afterwards, hence these two„'programs. You might include a real menu and put them into a„'single program with all sorts of bells and whistles, but I„'didn't take the time to since they served my needs as is.„'If anybody has questions or suggestions, feel free. :)„'First, to take the files apart into manageable segments:„'_|_|_|   SPLITTER.BAS„'_|_|_|   Splits a file into 1MB segments.„'_|_|_|   No warrantee or guarantee given or implied.„'_|_|_|   Released   PUBLIC DOMAIN   by Kurt Kuzba.  (11/29/96)„ON ERROR GOTO OOps„CLOSE„INPUT "enter name of file to split => ", NFile$„PRINT "enter name of file sections"„INPUT "(EX. game > 'gamex.tmp')    => ", NTemp$„NoSeg% = 0: Source% = FREEFILE„OPEN NFile$ FOR BINARY AS #Source%„Destination% = FREEFILE„WHILE NOT EOF(Source%)„   F$ = NTemp$ + LTRIM$(STR$(NoSeg%)) + ".tmp"„   OPEN F$ FOR OUTPUT AS #Destination%„   accum& = 0„   WHILE (NOT EOF(Source%)) AND (accum& < 1048576)„      dat$ = INPUT$(1024, Source%): ln& = LEN(dat$)„      accum& = accum& + ln&: PRINT #Destination%, dat$;„   WEND„   CLOSE Destination%: NoSeg% = NoSeg% + 1„WEND: CLOSE Source%: END„OOps:„   CLOSE : PRINT ERR: END„'_|_|_|   end   SPLITTER.BAS„„'And then, to restore the original file from the segments:„'_|_|_|   CONCAT.BAS„'_|_|_|   Restores files split using SPLITTER.BAS to one file.„'_|_|_|   No warrantee or guarantee given or implied.„'_|_|_|   Released   PUBLIC DOMAIN   by Kurt Kuzba.  (11/29/96)„ON ERROR GOTO OOps„INPUT "Files to concatenate => ", Pieces$„INPUT "Name of output file  => ", Whole$„W% = FREEFILE: OPEN Whole$ FOR OUTPUT AS #W%„IF BooBoo% <> 0 THEN CLOSE : END„P% = FREEFILE: Part% = 0„DO„   F$ = Pieces$ + LTRIM$(STR$(Part%)) + ".tmp"„   OPEN F$ FOR INPUT AS #P%„   IF BooBoo% <> 0 THEN CLOSE : END:  ELSE CLOSE P%„   OPEN F$ FOR BINARY AS #P%„   WHILE NOT EOF(P%)„      dat$ = INPUT$(1024, P%): PRINT #W%, dat$;„   WEND„   CLOSE P%: Part% = Part% + 1„LOOP: END„OOps:„   BooBoo% = ERR: RESUME NEXT„'_|_|_|   end   CONCAT.BAS„Dave Shea                      ANIMATION                      FidoNet QUIK_BAS Echo          11-23-96 (12:09)       Text, QB, QBasic       173  7706     ANIMATE.BAS '>> Hello.  I've tried making simple animation in qbasic but with no„'>> success.  The command i use to simulate the movements is CLS, but it„'>> doesn't seem to work.  Is there another way or command i can use to„'>> make simple animation??  Thanks. =)„„'>Use GET and PUT XOR.„„'...And I'll bet that helped you a WHOLE lot.„„„Here is a preview of the newest addition to the code FAQ. It explains in„(I hope) enough detail to get a beginner started with animation in QB.„Take a look, ask a question if you don't understand.„„8) HOW CAN I ANIMATE SPRITES IN QB?„„   First thing, what's a sprite? Good question. Basically, it's a„   rectangle box that has a picture in it. In something like„   cartoon animation, they would be referred to as frames. So when„   you're animating in QB, you're essentially doing the same thing„   that you would do if you were to create a cartoon, just on a„   smaller scale.„„   So how do you create sprites? QB has a variety of graphics„   functions (DRAW, LINE, CIRCLE, PSET etc.) that are at your„   disposal. They are quite cumbersome to draw with, so you might„   find it difficult to get started. You may want to keep your„   eyes open for a QB graphics editor, which there seem to be„   quite few of. So, here we go... plug for one of my own programs.„   Spectra.13 was designed specifically for drawing graphics in QB.„   It is totally mouse-controlled, has a handy pop-up menu,„   features many handy utilities (draw, erase, paint, line, circle,„   filled circle, box, filled box, text, Bitmap loading, palette„   manipulation, save & load pictures, save & load icons, on-line„   help, etc. etc. etc.) It's probably the most comprehensive QB„   drawing program available, but as of yet, is not widely„   available. It was just released in late November '96, so if you„   can't find it anywhere, get in touch with me, Dave Shea, and„   I'll see what I can do to hook you up with it.„„   Back to animation...„„   The first thing you have to do is set aside memory for your„   sprite using the DIM command. This can be done like this:„„   DIM Array%(NumberOfBytes)„„   Where Array% is the name of the array you're storing the sprite„   data in. For our purposes in this section of the FAQ, I won't„   explain what an array is. Just think of it as a really big„   variable that we will store our picture in. How do you determine„   the number of bytes you need to set aside? It depends on your„   screen mode. We will assume SCREEN 13 from now on, in which each„   pixel requires exactly one byte of memory. So, to determine the„   amount of memory needed, the formula would be:„„   NumberOfBytes = ((XValue * YValue) / 2) + 12„„   The extra 12 bytes are to store the (x,y) dimensions of the„   array. You must divide by two because each element of Array%„   is an integer value, 16 bytes, and we only need 8. If you don't„   understand, don't worry. Just follow the formula.„„   So where do the XValue and YValue come from? Like I said, a„   sprite is a rectangle, so the XValue is the number of pixels„   across the sprite horizontally (Left to right), and Y is the„   number of pixels going up and down. Once you have your graphic„   on the screen, try drawing a box around it. Once you have a box„   that completely surrounds the graphic, use the X and Y values„   for the box as the same for your graphic. If you're having„   troubles with this, use the following formula for a box that„   completely surrounds your graphic:„„   LINE (x1, y1) - (x2, y2), 31, B„   x = (x2 - x1) : y = (y2 - y1)„„   Okay, so now I have everything set up, how do I store my picture„   in the array? Using the GET command. It's as easy as this:„„   GET (x1, y1) - (x2, y2), Array%„„   The x1, y1 etc. are the exact same as in the LINE command above,„   and the array Array% is the one we dimensioned above. So, now„   you have the graphic in memory, you can clear the screen so it's„   not still on there.„„   Animation starts here. Once you have all the sprites stored in„   memory, you will most likely want to stick them back on the„   screen at a certain time in your program. This is done through„   the PUT command. Try this:„„   PUT (50,50), Array%„„   That will stick the graphic you have in Array% at position„   (50, 50) on the screen. Easy as that.„„   So, now I have this going for me, how do I actually animate?„„   It's quite simple from here. Basically, you stick your picture„   on the screen, delay for a bit, erase it and immediatly stick„   another picture on the screen at a different location, and so„   on. The one problem with this is that, for a very short time,„   there is no picture on the screen. This will cause the animation„   to flash a certain amount, no matter how fast your computer is.„   There is one way that slightly avoids this problem, but it's not„   a complete solution. This will work only if you are using small„   sprites, and only if you don't animate near the top of the„   screen. What you do is add a line AFTER you have placed your„   sprite, but BEFORE you erase it. (As it slows down the program a„   bit, it can also be used in place of a delay loop) This command„   is called the vertical retrace, and it goes like this:„„   WAIT 986, 8    (or WAIT &H3DA, 8....)„„   That will help, but only a little bit. The following example is„   a little animation of a guy running, and it uses the techniques„   described above.„„[...........................Cut Here..............................]„   ' =-=-=-=-=-=-=-=-=-=-=-=-=-=-=„   '   RUN.BAS   by   Dave Shea„   '   Released to Public Domain„   '   on November 22nd, 1996. No„   '   Warantees expressed or„   '   implied.„   ' =-=-=-=-=-=-=-=-=-=-=-=-=-=-=„„   CLS : SCREEN 13               'Set Screen 13, of course!„„„   PSET (25, 71), 31: DRAW "rdld2l2ngr3fnehld3rfrdngulhlg2lh"„   PSET (45, 71), 31: DRAW "rdld2lgnder2dnr2ld2rfdnguhld2lg"„   PSET (65, 71), 31: DRAW "rdld2ldrnednrddrfndhldlg"„   PSET (85, 71), 31: DRAW "rdld2lgnderdnr2d2rfdnguhlgdl2"„„                                 'The above will draw four„                                 'different frames of a Stick man„                                 'running.„„   DIM Guy1%(134), Guy2%(134), Guy3%(134), Guy4%(134)„„                                 'Set aside the memory required for„                                 'each frame.„„   GET (16, 69)-(34, 82), Guy1%  'Stick each frame into memory„   GET (36, 69)-(54, 82), Guy2%  '(X and Y values calculated by„   GET (56, 69)-(74, 82), Guy3%  ' pure trial and error. =u)„   GET (76, 69)-(94, 82), Guy4%„„   CLS                           'Guess what THIS does!„„   FOR a = 1 TO 300 STEP 2                'Begin Loop„    b = b + 1: IF b = 5 THEN b = 1        'Increase b until it„                                          'reaches a value of 5,„                                          'reset it to 1„„    IF b = 1 THEN PUT (a, 100), Guy1%     'Determine which frame to„    IF b = 2 THEN PUT (a, 100), Guy2%     'PUT, then PUT it.„    IF b = 3 THEN PUT (a, 100), Guy3%„    IF b = 4 THEN PUT (a, 100), Guy4%„„    WAIT 986, 8                           'Wait for Vertical„                                          'Retrace„„    Start = TIMER                         'Small delay loop to„    WHILE TIMER < Start + .1: WEND        'slow it down a bit.„„    IF b = 1 THEN PUT (a, 100), Guy1%     'Erase current frame by„    IF b = 2 THEN PUT (a, 100), Guy2%     'PUTting it again.„    IF b = 3 THEN PUT (a, 100), Guy3%„    IF b = 4 THEN PUT (a, 100), Guy4%„„   NEXT                                   'Loop!„Benjamin L. McGee              HOW TO USE POKE                FidoNet QUIK_BAS Echo          03-17-97 (11:35)       QB, QBasic, PDS        46   1298     POKEUSE.BAS ' > ... I'm a little paranoid about using the POKE and PEEK „' > commands (mainly POKE, though). How will I know where to „' > POKE into and exactly what can I accomplish by POKEing there? „ „'From Ralf Brown's Interrupt list MEMORY.LST „ „' ----------M0400072-------------------------- „' MEM 0040h:072h - POST RESET FLAG „' Size:   WORD „' Desc:   speify the action the BIOS should take at the beinning of the „'         power-on self-test when the machine is reset „ „'(Table M020) „'Values for POST reset flag: „'     0000h  cold boot „'     0064h  Burn-n mode „'     1234h  to bypass memory test (warm boot) „'     4321h  [PS/2 except Mod 25,30] to preserve mmory „'     5678h  [Conv] system suspended „'     9ABCh  [Conv] manufacturing test mode „'     ABCDh  [Conv] POST loop mode „ „ „' ---------- WARMBOOT.BAS ---------- „'$INCLUDE: 'qbx.bi' „ „DEF SEG = &H40 „POKE &H72, &H34 „POKE &H73, &H12 „ „DEF SEG = &HFFFF „CALL Absolute(&H0) „ „' ---------- COLDBOOT.BAS ---------- „'$INCLUDE: 'qbx.bi' „ „DEF SEG = &H40 „POKE &H72, &H0 „POKE &H73, &H0 „ „DEF SEG = &HFFFF „CALL Absolute(&H0) „ „'There are, no doubt, many other useful memory locations that „'you can POKE values into.  A good reference is as valuable as „'gold.  Hope that helps... „The ABC Programmer             READING CHARACTER OFF SCREEN   voxel@freenet.edmonton.ab.ca   03-01-97 (12:28)       QB, QBasic, PDS        116  4265     PEEK.BAS    ' Question:„'   How can I read a character and attribute off the screen (text), and can„'   you explain how it works?„„' Answer:„'   The bytes are stored in memory, so to access them, you must first„'   know where the screen memory address is (where h = hex):„'     b800h:0000 is where we should start looking.„'     b000h:0000 if you have a monochrome card/adapter.„'„'   BASIC equivalent is: DEF SEG = &HB800„„DEFINT A-Z„DEF SEG = &HB800  ' &HB000 for mono (&H = Hex)„„' Okay, we know where the information is stored... so now we have to„' get them.  For BASIC, that command is PEEK (look it up in HELP).„„' For one thing, we know that there are 2,000 possible locations on an 80x25„' text screen.  It's given that each location occupies one word (or two„' bytes).  The first byte is the ASCII value of the character on the virtual„' screen, and the following is the attribute (colour?) of the character.„' I say colour? because it's not a definitive colour, it's actually the„' foreground and background colour kind of combined if you like to look at„' it that way... I'll go into how to decode the attribute later on.„„' so let's see:  b800h:0000 is a character„'                b800h:0001 would be the attribute... and so on.„„' Now with some fine tuning, we can come up with an algorithm to find„' the character and the attribute.„„' Since there are 160 bytes per row (80 words = 2 bytes)„' - we can say that (Row% - 1) * 160„'     the second row starts at 160, then the next at 320... and so on.„' - and so the column is (Col% - 1) * 2„'     multiply by 2 because there are 2 bytes per location, and we want„'     the character which is every even number.„' - That means (Col% - 1) * 2 + 1 would give us the attribute.„' - Minus 1 because the segment starts at 0000 but QB's row, column starts„'     at (1,1)„„'  Putting this all together, we get the complete equation:„'„'  CharAddress = (Row% - 1) * 160 + (Col% - 1) * 2„'  AttrAddress = (Row% - 1) * 160 + (Col% - 1) * 2 + 1„'„' Using (Row%, Col%)„' The top left corner is (1,1) and the bottom right is (25,80)„„'------------------------ DEMO1 -----------------------------„Row% = 1       ' Let's read the upper left corner and return its character„Col% = 1       ' and attribute if you want to as well.„„CLS„COLOR 7, 0„LOCATE Row%, Col%: PRINT "Hello"„„Char = PEEK((Row% - 1) * 160 + (Col% - 1) * 2)     ' Get first byte (even)„Attr = PEEK((Row% - 1) * 160 + (Col% - 1) * 2 + 1) ' Get next byte (odd)„„' Char is an ASCII value, so if you wanted the string equivalent:„„Char$ = CHR$(Char)„„PRINT "Character at (1,1) is: "; Char$„„ForeGround = Attr MOD 16„BackGround = (Attr - ForeGround) / 16„„' How does the algorithm above work?„' Because only one byte is stored, the computer encodes the foreground„' and background colour into just one byte... so to undo what the computer„' has done we must first know what the heck it has done:„'   Computer:  Foreground = 12  BackGround = 3„'              So 3 * 16 + 12 = 60„'„'              Why 16?  Because (0,1,2,3,...,15) = 16 different colours!„'„'   Intelligent human being:  Okay, now I'll reverse the evil procedure!„'       ForeGround = 60 / 16 = 3 with Remainder 12„'       But luckily we have the function MOD (look it up in HELP)„'       So 60 MOD 16 will yield the remainder we want, which it 12.„'„'       Therefore, with some work: 60 - 12 = 3 * 16     (Learn your math)„'                                 (60 - 12) / 16 = 3„'„'   So BackGround = (60 - ForeGround) / 16     = 3„'   or BackGround = (60 - ForeGround) MOD 15   = 3„„PRINT "Attribute (Colour): "; ForeGround; ","; BackGround„„' Let's try another one...„'------------------------ DEMO2 -----------------------------„„Row% = 7      ' Select new locations„Col% = 10„„COLOR 15, 5„LOCATE Row%, Col%: PRINT "Bye!"„„Char$ = CHR$(PEEK((Row% - 1) * 160 + (Col% - 1) * 2))  ' One step process„Attr = PEEK((Row% - 1) * 160 + (Col% - 1) * 2 + 1)„„COLOR , 0„PRINT "Character at (7,10) is: "; Char$„„ForeGround = Attr MOD 16„BackGround = (Attr - ForeGround) MOD 15„„PRINT "Attribute (Colour): "; ForeGround; ","; BackGround„„END„„' William Yu (voxel@freenet.edmonton.ab.ca)„' 03-01-97„Kurt Kuzba                     COMBINE LOW & HIGH BITS        FidoNet QUIK_BAS Echo          05-18-97 (22:31)       QB, QBasic, PDS        19   555      LOWHIGH.BAS '>   If I have a certain number in hex (say, &H10FF), I can„'>   get the high bit (&H10) by dividing by 256, and the low„'>   bit(&HFF) by doing &H10FF MOD 256, but here is the problem.„'>   If I have a high bit (lets take &H10 again), and a low„'>   bit (&HFF again), how do I combine them into one hex„'>   number? (back to &H10FF)„'>....„' Try something like this once.„CLS„th$ = "&H1234"„t& = VAL(th$)„t1% = INT(t& \ &H100)„t2% = INT(t& AND &HFF)„PRINT th$; t&; t1%; t2%„t& = t1%„t& = t& * &H100„t& = t& + t2%„PRINT "&H"; HEX$(t&)„„Ian Campbell                   .ZIP FILE HEADER               dm.campbell@ns.sympatico.ca    06-07-97 (00:00)       Text                   79   2897     PKHEAD.TXT  ' Ever wondered what was in the zip file header? Here it is, straight from the„' Pkware homepage. Have Fun!„'„' Ian Campbell„„„  A.  Local file header:„„        local file header signature     4 bytes  (0x04034b50)„        version needed to extract       2 bytes„        general purpose bit flag        2 bytes„        compression method              2 bytes„        last mod file time              2 bytes„        last mod file date              2 bytes„        crc-32                          4 bytes„        compressed size                 4 bytes„        uncompressed size               4 bytes„        filename length                 2 bytes„        extra field length              2 bytes„„        filename (variable size)„        extra field (variable size)„„„  B.  Data descriptor:„„        crc-32                          4 bytes„        compressed size                 4 bytes„        uncompressed size               4 bytes„„      This descriptor exists only if bit 3 of the general„      purpose bit flag is set (see below).  It is byte aligned„      and immediately follows the last byte of compressed data.„„  C.  Central directory structure:„„      [file header] . . .  end of central dir record„„      file header:„„        central file header signature   4 bytes  (0x02014b50)„        version made by                 2 bytes„        version needed to extract       2 bytes„        general purpose bit flag        2 bytes„        compression method              2 bytes„        last mod file time              2 bytes„        last mod file date              2 bytes„        crc-32                          4 bytes„        compressed size                 4 bytes„        uncompressed size               4 bytes„        filename length                 2 bytes„        extra field length              2 bytes„        file comment length             2 bytes„        disk number start               2 bytes„        internal file attributes        2 bytes„        external file attributes        4 bytes„        relative offset of local header 4 bytes„„        filename (variable size)„        extra field (variable size)„        file comment (variable size)„„      End of central dir record:„„        end of central dir signature    4 bytes  (0x06054b50)„        number of this disk             2 bytes„        number of the disk with the„        start of the central directory  2 bytes„        total number of entries in„        the central dir on this disk    2 bytes„        total number of entries in„        the central dir                 2 bytes„        size of the central directory   4 bytes„        offset of start of central„        directory with respect to„        the starting disk number        4 bytes„        zipfile comment length          2 bytes„        zipfile comment (variable size)„„Ian Campbell                   REMAP KEYBOARD USING ANSI CODESdm.campbell@ns.sympatico.ca    06-07-97 (00:00)       Text                   62   2315     ANSI.TXT    „                   Remapping The Keyboard Using Ansi Codes.„                  ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ„           NOTE: Make sure that ANSI.SYS is loaded in your CONFIG.SYS„„Ian Campbell„bigfeetz@bigfoot.com„„„        Ever wanted to remap the keyboard? To customize it to your liking?„perhaps even convert it to a Dvorak keyboard for speed? Here's your chance.„ANSI codes can be used to tell BIOS how to handle keystrokes. The example „below changes the keyboard so that when ever [spacebar] is pressed;„„- Not actually give a space„- Do a dir command„- Do a version command„- Print "Hello" on the screen„„                ESC[32;27;"dir";13;"ver";13;"rem Hello!";13p„        „        In a real ANSI program, the ESC would be replaced with the ASCII „symbol for escape. All ANSI codes MUST include ESC (ASCII symbol) and "p" at „the end. A breakdown of the above code is as follows.„„                ESC[32;27;"dir";13;"ver";13;"rem Hello!";13pƒƒƒ The end„                 ≥   ≥  ≥   ≥   ≥   ≥    ≥    ≥„             Start   ≥  ≥   ≥   ≥   ≥    ≥    Prints hello„                     ≥  ≥   ≥   ≥   ≥    all dos...„                     ≥  ≥   ≥   ≥   Version command„                     ≥  ≥   ≥   Must be put in fron of all dos commands„                     ≥  ≥   The dir command„                     ≥  Cancels the space„                   Shows what key to remap„„„        Here is a list of keystrokes and their ANSI equivalent.„„Code(s) Meaning„_______ ______________________________________________„15      Shift-Tab„16-25   Alt- Q,W,E,R,T,Y,U,I,O,P„30-38   Alt- Z,X,C,V,B,N,M„59-68   F1-F10„71      Home„73      PgUp„79      End„81      PgDn„82      Ins„83      Del„84-93   F11-F20  (Shift-  F1-F10)„94-103  F21-F30  (Ctrl-   F1-F10)„„        Unfortunately, such ANSI programs can be damaging. It is quite easy„to take this knowledge and write malicious programs that damage programs. To„protect against such a threat take these simple precautions.„„- NEVER under any circumstances use type command. This will execute the code!„„- NEVER use pegasus mail if you are expecting attachments. It will execute „  all code, malicious or not, and theirs nothing you can do about it because„  it's external viewer cannot be turned off.„James S. Baughn                GRAPHICS FILE FORMATS          jbaughn@ldd.net                06-22-97 (21:29)       Text                   829  36644    GFX.TXT     GRAPHIC FILE FORMATS...IN REAL BASIC CODE!„-------------------------------=====------„By James S. Baughn„„TABLE OF CONTENTS„-----------------„Introduction„Some useful graphics routines„Some background„PCX (PC Paintbrush)„BMP (Windows bitmaps)„ICO (Windows icons)„GIF (Graphics Interchange Format) -- Don't get too excited„TGA (Truevision Targa)„MAP (Fractint palette files)„Other sources of information„How to contact me„Obligatory copyright and other legalese„Shameless plug for my homepage„Conclusion„„„INTRODUCTION„------------„We've all seen them:  the fancy graphics file format specifications that„have NO code and very terse explanations.  Or the code snippets that load„only one particular size file, and have little or no comments.  No more!„„This file is an attempt to explain the various graphics file formats.„And unlike other documents, this has REAL BASIC CODE!  The file headers„are coded in BASIC...so it's as easy as cut-and-paste.  I have various„sample routines for loading the graphics and palettes.  But, note that„these are just samples...you'll have to write better code yourself.„I can't do ALL the work!  But, hopefully, this document will help you„write the code without much trouble...and you'll have the satisfied„feeling that YOU wrote it.„„I haven't had the chance to thoroughly test all the code snippets„(not to mention spelling and grammar).  So, there many be a few„(hopefully insignificant) bugs.  Get the bug spray ready!  Anyone„who can spot a bug or mistake will receive a coupon worth $0 towards„their next Internet access bill OR one million hand-picked electrons. „(Offer not valid in 99.99% of the world.)„„ „SOME USEFUL GRAPHICS ROUTINES„-----------------------------„Many of the code snippets in this document make use of the following „three general purpose functions and subroutines.  They may be of some „use in your own programs.„„MakePalette„- - - - - -„This routine uses the send commands to the VGA's ports to quickly change„the palette.  This is *MUCH* faster than BASIC's PALETTE USING.„„The routine expects there to be a SHARED array called PalStr, declared as„DIM PalStr AS STRING * 768 for 256 colors or„DIM PalStr AS STRING * 48 for 16 colors„„PalStr is composed of three byte triples for each color.  Each triple„is in red, green, blue format.  So, the triple for intense red would be„CHR$(255) + CHR$(0) + CHR$(0)„„Here is the sub:„„SUB MakePalette (Colors)„   FOR i = 1 TO Colors„      OUT &H3C8, i         'Tell the VGA the color index we want to change„      OUT &H3C9, (VAL(MID$(PalStr, (3 * i - 2), 1)) \ 4)   'Red„      OUT &H3C9, (VAL(MID$(PalStr, (3 * i - 1), 1)) \ 4)   'Green„      OUT &H3C9, (VAL(MID$(PalStr, (3 * i - 0), 1)) \ 4)   'Blue„   NEXT„END SUB„„The Colors specifies how many colors to change.  If you specify 16,„the first 48 (16 * 3) bytes of PalStr will be used to change the„palette.„„ReturnNibble„- - - - - - -„This function splits a byte into two nibbles.  This is useful for„loading 16-color graphics because the information for two pixels is„stored in one bytes.  The argument Byte is the actual byte you are„interested in, and WhichOne specifies which nibble (the first or second)„you want returned.„„FUNCTION ReturnNibble (Byte, WhichOne)„   IF WhichOne = 1 THEN„      IF Byte AND 128 THEN Total = Total + 8„      IF Byte AND 64 THEN Total = Total + 4„      IF Byte AND 32 THEN Total = Total + 2„      IF Byte AND 16 THEN Total = Total + 1„   ELSE„      IF Byte AND 8 THEN Total = Total + 8„      IF Byte AND 4 THEN Total = Total + 4„      IF Byte AND 2 THEN Total = Total + 2„      IF Byte AND 1 THEN Total = Total + 1„   END IF„   ReturnNibble = Total„END FUNCTION„„ReturnBit„- - - - -„This function returns a single bit from a byte.  The argument Byte„is the byte you're interested in, and WhichOne is the bit you want„returned.  This is useful for 2 color pictures.„„FUNCTION ReturnBit(Byte, WhichOne)„   SELECT CASE Which„      CASE 1: IF (Byte AND 128) THEN ReturnBit = 1„      CASE 2: IF (Byte AND 64) THEN ReturnBit = 1„      CASE 3: IF (Byte AND 32) THEN ReturnBit = 1„      CASE 4: IF (Byte AND 16) THEN ReturnBit = 1„      CASE 5: IF (Byte AND 8) THEN ReturnBit = 1„      CASE 6: IF (Byte AND 4) THEN ReturnBit = 1„      CASE 7: IF (Byte AND 2) THEN ReturnBit = 1„      CASE 8: IF (Byte AND 1) THEN ReturnBit = 1„   END SELECT„END FUNCTIN„„„SOME BACKGROUND„---------------„There are generally five steps in displaying a graphic file.„„STEP 1:  Define and load the header„- - - - - - - - - - - - - - - - - -„You must find out the structure of a graphics file, in particular the„header.  In BASIC you can use a TYPE structure, DIM a variable as this„TYPE, and load the header in all at once with GET.  This is fairly„straightforward once you know the layout of the header.  See the individual„format sections below for the BASIC code to define each format's header.„„STEP 2:  Select a video mode„- - - - - - - - - - - - - - -„Using the header information, you need to determine what video mode the„image will look best in.  You can use the following pseudo-code for this.„„Colors = Total number of unique colors in file„Width = Width of image (note that you can't use Width as a real variable,„        it's a reserved BASIC statement)„Height = Height of image„„IF Width <= 640 and Height <= 480 and Colors <= 16 THEN ScreenMode = 12„IF Width <= 640 and Height <= 350 and Colors <= 16 THEN ScreenMode = 9„IF Width <= 640 and Height <= 480 and Colors > 16 THEN„   You could:„      - Set a SVGA mode using SetVideoMode (see above) - You'll have„        to find a way to output to the screen on your own„      - Use ScreenMode = 12 and remap the palette to only 16 colors„      - Use ScreenMode = 13 and scale the picture or allow the user„        to pan it„      - Use a nonstandard VGA mode ("ModeX") supporting 256 colors„        You'll have to figure this out on your own„IF Width > 640 and Width > 480 and Colors <= 16 THEN„   ScreenMode = 12, allow user to pan the image„IF Width > 640 and Width > 480 and Colors > 16 THEN„   Either ScreenMode = 13 (with panning) or a SVGA mode„IF Width <= 320 and Height <= 200 and Colors = 256 THEN ScreenMode = 13„IF Width <= 320 and Height <= 200 and Colors <= 16 THEN„   IF you want the picture to fill the screen THEN ScreenMode = 13„   ELSE you can center the image and use ScreenMode = 12, 9, 7, or another„„STEP 3:  Load palette information„- - - - - - - - - - - - - - - - -„You'll have to parse the palette information from the file depending on„the format.  If the number of colors is less than the number available,„simply load the palette into PalStr and use MakePalette.„„If the number of unique colors is greater than that available, you'll have„to improvise.  You'll have to create an optimized palette that will try„to balance the colors well.  This can be tricky!„„You can take the easy way out and convert it to greyscale.„For 24-bit files (like TGA), you can use this simple logic:„„   '-- First, make the greyscale palette --„   PalStr = STRING$(768, " ")      'Empty out palette„   FOR I = 0 TO 63„      MID$(PalStr, I * 3 + 1, 3) = CHR$(I) + CHR$(I) + CHR$(I)„   NEXT                            '^ Combine colors so R = G = B, making it„                                   '  all grey„   MakePalette 256                 'Send to VGA card„„   '-- After loading the picture, parse a byte --„   'At this point we assume Red, Green, and Blue hold the intensities for„   'a single byte.„„   'We have to convert it from 0-255 to BIOS-usable 0-63„   Red = Red \ 4: Green = Green \ 4: Blue = Blue \ 4„   'Now average these intensities together„   Output = (Red + Green + Blue) \ 3„   'And output the pixel „   PSET (X, Y), Output„„   '-- And then loop back around and handle the next byte... --„„OR, you can use a "3-2-2" palette that contains a rainbow of colors, and„then match each pixel to this palette.  Here's the code:  (Note that„I haven't had a chance to test this routine.  "So many electrons to push,„so little time!")„„   '-- First, make "3-2-2" palette --„   Index = 1                       'Current color index„   FOR Red = 0 TO 63 STEP 9        'Loop through the three colors„      FOR Green = 0 TO 63 STEP 9„         FOR Blue = 0 TO 63 STEP 21„            OUT &H3C8, Index       'Send color index to VGA„            OUT &H3C9, Red         'Send red intensity to VGA„            OUT &H3C9, Green       'Ditto„            OUT &H3C9, Blue        'Ditto„            Index = Index + 1      'Increment color index„         NEXT„      NEXT„   NEXT                            '...done!„„   '-- After we load the file and parse a byte... --„   „   'Use this formula:„   Output = Red + (Green \ 8) + (Blue \ 64)„   'And then output the color„   PSET (X, Y), Output„„Fancy graphics programs use quantization and dithering to reduce„the color depth.  Unfortunately, none of these techniques have been„programmed in BASIC (afaik).„„STEP 4:  Load the image into memory„- - - - - - - - - - - - - - - - - -„There are a couple ways to do this.  You can load the WHOLE thing„into EMS or XMS memory if available.  You'll have to access HIMEM.SYS„through interrupts to do this.„„You could also load a line at a time from the file while displaying„it.  This is easier to program, but much slower.  If the image is small,„you may be able to simply load it into a huge or dynamic array in„conventional memory.„„STEP 5:  Display it!„- - - - - - - - - - -„Now loop through the image and display each pixel.  The process behind„this is different for each format.  You may have to decode the bytes,„possibly from run-length encoding (RLE, used in BMPs and PCXs) or„LZW (GIFs).  This can sometimes be tricky to program.„„And hopefully you'll have an image on the screen!  This document doesn't„detail saving graphics to disk, but the process is almost the exact„opposite.  You'll have to fiddle and hack a little on your own to do„this.„„„PCX„---„(Designed by ZSoft, Corp. for their PC Paintbrush program.)„„PCX files are supported by most DOS-based programs.  They use a fairly„efficient run-length encoding algorithm, that is, fortunately for us,„easy to use.„„* PCX code snippet„„TYPE PCXHeader„   Manufacturer AS STRING * 1  'Identification - will always be 10 for PCX„   Version AS STRING * 1       'PCX version:„                               '0 - Version 2.5„                               '2 - Version 2.8 w/palette information„                               '3 - Version 2.8 w/o palette information„                               '5 - Version 3.0 - 256 colors„   Encoding AS STRING * 1      'Will be 1 if run length encoding is used„                               '(almost always used)„   BitsPerPixel AS STRING * 1  'Number of bits needed to represent one pixel„                               'Generally,„                               '1 - 2 colors (usually black and white)„                               '2 - 4 colors„                               '4 - 16 colors„                               '8 - 256 colors„   xMin AS INTEGER             '\„   yMin AS INTEGER             ' \ Windows coordinates of this picture,„   xMax AS INTEGER             ' / these numbers can be used to figure the„   yMax AS INTEGER             '/  image's height and width, see below„   xRes AS INTEGER             'Horizontal resolution of creating device„   yRes AS INTEGER             'Vertical resolution of creating device„                               'These two numbers usually specify the„                               'screen resolution used when this picture„                               'was created.  So, this can be useful to„                               'determine which screen mode should be used„                               'to display this picture.  Note: Some programs„                               'won't use these, they'll just set them to 0.„   ColorMap AS STRING * 48     'Palette information used with Version 3„                               '(see below)„   Reserved AS STRING * 1      'Wasted space„   Planes AS STRING * 1        'Number of planes„                               'For 16 colors this will be 4„                               'For 256 colors this will be 1„   BytesPerLine AS INTEGER     'Number of bytes per line per plane.  Will„                               'always be even„   PaletteInfo AS INTEGER      '1 - color or black and white„                               '2 - greyscale„   Filler AS STRING * 58       'Filler used to make the header 128 bytes.„                               'Note that all PCX files are 58 bytes larger„                               'than they need to be.  However, this filler„                               'area could be used to embed information„                               'in the file, such as a copyright.„„END TYPE„„DIM PCX As PCXHeader           'Define a place to put the header„„OPEN FileName$ FOR BINARY AS 1 'Open file„GET #1, , PCX                  'Load header„„'-- Determine picture's size --„ImageWidth = PCX.xMax - PCX.xMin + 1   'Width„ImageHeight = PCX.yMax - PCX.yMin + 1  'Height„„'-- Set screen mode --„'Based on the header information you'll have to decide which screen mode„'to use.  (see Step 2 in "Some background" above)„SCREEN ScreenMode„„'-- Load the palette --„'We need to determine the number of colors.  Use BitsPerPixel for this.„SELECT CASE PCX.BitsPerPixel„ CASE 4:                           '16 color mode„   'The 16 color palette is stored in PCX.ColorMap„   MID$(PalStr, 1, 48) = PCX.ColorMap   'Load it into memory„   MakePalette 16                  'Send to VGA card...and done.„ CASE 8:                           '256 color mode„   'The 256 color map is stored at the END of the file.„   SEEK #1, LOF(1) - 767           'Set file pointer to beginning of„                                   'palette table.  The character before„                                   'this (LOF(1) - 768) should be 12.„   GET #1, , PalStr                'Load entire palette into memory.„   MakePalette 256                 'Send to VGA card...done.„ CASE ELSE:                        'Something else?„   'This may be some kind of CGA-specific file.  Loading the„   'palette and displaying this is complicated, and since this is hardly„   'ever used, I won't mess with it.„END SELECT„„'* End snippet„„Now you'll have to decide how to load the picture into memory.  See„Step 4 in the "Some backround" section above.„„The pseudo-code for displaying a PCX file is:„„FOR each byte Foo read from the file„   IF the top two bits of Foo are 1's THEN„      Count = 6 lowest bits of Foo„      Data = next byte following Foo„   ELSE„      Count = 1„      Data = Foo„   END IF„   LINE (X, Y)-(X + Count, Y), Foo„   (assuming X and Y are the current screen coordinates)„NEXT„„* Here is an example snippet for displaying a 256 color PCX.„Note that this code is VERY slow and inefficient.  This is just an„example, I'll leave it up to you do write a better routine that is„faster and supports 2, 4, and 16 color modes.„„SEEK #1, 129                       'Move file pointer to start of data„Foo$ = STRING$(1, " ")             'We will only load 1 byte at a time...„                                   '...VERY SLOW!!!!  In real world programs„                                   'you would load a line at a time or load„                                   'the whole thing into memory and go„                                   'from there.„X = 0: Y = 0                       'We'll start from the upper left corner„DO                                 'Loop through file„   GET #1, , Foo$                  'Retrieve ONE character...SLOW!„   Bar = ASC(Foo$)                 'Get its ASCII code„   IF (Bar AND 192) <> 192 THEN    'If its top 2 bits are not set, then„                                   'this is just a normal byte, no run„                                   'length encoding„      PSET (X, Y), Bar             'Display pixel„      X = X + 1                    'Update current screen location„      IF X > ImageWidth THEN       'If at end of line,„         X = 0: Y = Y + 1          'Move to left of next line„         IF Y > ImageHeight THEN EXIT DO   'Done!„      END IF„   ELSE                            'Must be RLE encoded„      Bar = Bar AND 63             'Get lower 6 bits.  This will be the„                                   'number of times this color is repeated„      GET #1, , Foo$               'Retrieve next byte„      Foobar = ASC(Foo$)           'Get ASCII equivalent„      LINE (X, Y)-(X + Bar), Foobar  'Display it„      X = X + Bar + 1              'Update screen location„      IF X > ImageWidth THEN       'If at end of line„         X = 0: Y = Y + 1          'Move to left of next line„         IF Y > ImageHeight THEN EXIT DO   'Done!„      NEXT„   END IF„LOOP UNTIL EOF(1)                  'EOF shouldn't ever be reached, but...„CLOSE 1                            'Can't forget this„„'At this point the picture SHOULD be loaded.  Famous last words...„„* End of snippet„„I'll leave it up to you to improve on the above snippet.  (Or, you can„simply copy the code from another ABC snippet - he he)„„„BMP„---„(Designed by Microsoft as a standard format for Windows)„„Microsoft developed this format to store device-independent data for„Windows.  There is also a variation for OS/2.„„* Start of BMP header„„TYPE BMPHeader             „   Ident AS STRING * 2             'Will be 'BM' if this is a bitmap„   FileSize AS LONG                'Size of the file in bytes„                                   'Not really necessary, use LOF instead„   Reserve AS STRING * 4           'Wasted space„   Offset AS LONG                  'Number of bytes from the end of the„                                   'header to the actual data„   Version AS LONG                 '40 - Windows 3.x„                                   '12 - OS/2„                                   'Actually, this is the size of the„                                   '"BMPInfoHeader", which is the entire„                                   'header minus the first four elements,„                                   'Ident to Offset.  These 4 elements are„                                   'actually part of the "BMPFileHeader"„                                   'according to the convuluted specification„   Cols AS LONG                    'Width of image„   Rows AS LONG                    'Height of image„   Planes AS INTEGER               'Number of planes - should be 1„   BitsPerPixel AS INTEGER         'Pretty obvious„'-- Note, the following is for a Windows BMP.  For OS/2, the„'header ends here and is followed by a colormap of BGR values (not RGB!)„   Compression AS LONG             'Type of compression used,„                                   '0 - None„                                   '1 - 8 bit run length encoding„                                   '2 - 4 bit run length encoding„   CompressedSize AS LONG          'Size of image compressed image„   xScale AS LONG                  'Horizontal scale, in pixels per meter„   yScale AS LONG                  'Vertical scale, in pixels per meter„                                   'Not very useful, why such an odd unit?„   Colors AS LONG                  'Number of colors actually used,„                                   'if this is 0 then all possible colors„                                   'are used„   ImportantColors AS LONG         'Number of colors that are considered„                                   '"important."  If 0 then all colors„                                   'are "important."„END TYPE„DIM BMP AS BMPHeader               'Define header„„OPEN FileName$ FOR BINARY AS 1     'Open file„GET #1, , BMP                      'Load header quickly„„'-- Load palette„'The next part of the file is the colormap.  Its length is:„Length = 4 * 2^BMP.BitsPerPixel„„'Each color is represented by four values: blue, green, red, and an„'unused value.  (Note that the OS/2 colormap doesn't have the„'wasted unused value)„„Foo$ = STRING$(Length, 32)         'Get ready to hold palette info„GET #1, , Foo$                     'Load it all into memory at once„FOR i = 1 TO Length                'Loop through it„   Blue$ = MID$(Foo$, (i * 4) - 3, 1)„   Green$ = MID$(Foo$, (i * 4) - 2, 1)„   Red$ = MID$(Foo$, (i * 4) - 1, 1)„   MID$(PalStr, ((i * 3) - 2), 3) = Blue$ + Green$ + Red$„NEXT„„* End of snippet„„Now you need to set the video mode and then load the BMP.  Displaying„non-compressed BMPs is incredibly easy.  Below is a snippet for displaying„BMPs that are not RLE compressed (BMP.Compression = 0).  This snippet„is slightly faster than the PCX snippet above because it loads one„scan line at a time from the file, instead of one byte at a time.„„* Begin snippet„„'First we need to determine how many bytes are in each scan line.„Length = (LOF(1) - BMP.Offset) \ BMP.Rows„          '|                   ^ This trancutes any remainders„          '+- You could also use BMP.FileSize„'The above line is a quick way to determine the size of each row.  However,„'it may not work if there are excess bits at the end of each scan line.„'Files with 2 or 4 bits per pixel and odd widths sometimes have to be„'padded with extra bits at the end of each scan line.  This may fool this„'simple routine.„„Foo$ = STRING$(Length, 32)         'Allocate space in memory for each row„„FOR Y = BMP.Rows TO 1 STEP -1      'Rows are stored bottom to top in BMPs„   GET #1, , Foo$                  'Load row into memory„   Ptr = 1                         'Pointer into memory„   FOR X = 1 TO BMP.Cols STEP (8 \ BMP.BitsPerPixel)  'Loop through columns„                                   '^ Number of columns per byte„      Bar = ASC(MID$(Foo$, Ptr, 1) 'Extract byte„      Ptr = Ptr + 1                'Increment pointer„      IF BitsPerPixel = 8 THEN     'If one byte per pixel...„         PSET (X - 1, Y - 1), Bar  '...simply output that byte„      ELSEIF BitsPerPixel = 4 THEN 'If one nibble (4 bits) per pixel...„         PSET (X - 1, Y - 1), ReturnNibble(Bar, 1) '...Extract nibbles...„         PSET (X, Y - 1), ReturnNibble(Bar, 2)     '...and output both„      ELSEIF BitsPerPixel = 1 THEN 'If only one bit per pixel...„         FOR I = 1 TO 8            '...loop through the 8 bits and...„            PSET (X - 1 + I, Y - 1), ReturnBit(Bar, I)  '...extract each...„         NEXT                      '...and output them„      END IF„   NEXT                            'Loop to next column„NEXT                               'Done with that row, move to next„CLOSE 1                            'Done!„„* End snippet„„Parsing and displaying compressed BMPs is a little bit more involved.„I'll have to let you discover how to do this on your own.  The BMP„specification, available at http://www.wotsit.demon.co.uk, explains„the RLE compression scheme.„„„ICO„---„(Designed by Microsoft for Windows icons)„ „Windows icons have the same format as BMP files.  They can be 16x16,„32x32 or 64x64 according to the specification, but almost all icons are„32x32.  They can be 2, 8, or 16 colors, but almost all of them are„16 colors.  It is possible for multiple icons to be stored in ICO files,„but almost always only one is stored.„„The layout of a ICO file is:„„Name            Bytes    Description„----            -----    -----------„Header           126     The header is a modified version of a BMP header.„                         If if we assume all icons are 32x32 with 16 colors,„                         we can safely ignore the header.„Icon bitmap      512     The actual icon image.  It is stored as four„("AND" bitmap)           bits per pixel.  There are 32 rows, and each row„                         is 16 bytes, so this adds up to 512.„                         (Tech note:  Windows applies this bitmap to the„                         screen using an AND operation.  This way parts of„                         the icon can be transparent.)„B&W bitmap       128     A monochrome bitmap of the icon stored as 1 bit„("OR" bitmap)            per pixel.  This bitmap is visible in Windows„                         when you drag an icon - instead of the color bitmap„                         showing, this simpler monochrome bitmap is shown.„                         For simply displaying icons, this bitmap can„                         be safely ignored.  (Tech note:  Windows applies„                         this bitmap using an OR operation.)„TOTAL        --> 766     126 + 512 + 128 = 766, which is why all ICOs„                         are always this size.  Only the middle 512 bytes„                         are really necessary, though.„„* Loading and displaying an icon is easy.  Here is a snippet:„„OPEN FileName$ FOR BINARY AS 1     'Open file„SEEK #1, 127                       'Ignore header„Foo$ = STRING$(512, 32)            'Allocated memory for entire icon„GET #1, , Foo$                     'Load icon into memory„CLOSE 1                            'Don't need the file now„SCREEN 12                          'Change to whatever mode you want„Ptr = 1                            'Pointer into memory (Foo array)„„FOR Y = 32 TO 0 STEP -1            'Like BMPs, icon are stored bottom to top„   FOR X = 0 TO 32 STEP 2          'Column loop„      Bar = ASC(MID$(Foo$, Ptr, 1))'Extract byte„      Ptr = Ptr + 1                'Increment pointer„      PSET (X, Y), ReturnNibble(Bar, 1)      'Output pixels to screen„      PSET (X + 1, Y), ReturnNibble(Bar, 2)„   NEXT                            'Loop to next byte„NEXT                               'Loop to next row„„* End snippet„„Writing an icon to disk is a little harder.  You have to come up with„a header and an "OR" bitmap.  Other than that, though, it's just the„reverse of above.„„GIF„---„(Designed by CompuServe as a way to transfer files on their system,„stands for Graphics Interchange Format)„„Unfortunately, a license with UniSys is required in any commericial„or shareware programs that use GIF files.  Actually, GIF itself isn't„patented, it's the LZW compression scheme.  (You probably already knew„this, though.)  There really isn't any point in explaining this file„format since we can't use it legally in our programs.  And frankly, our„efforts would be better spent trying to write JPEG or PNG graphics„programs.  However, I don't have a clue how to display these„formats because of the compression scheme they use.  If you can„figure out how to display PNG graphics, you would be the first person„(afaik) in the world to write a PNG decoder in BASIC!„„Choosy programmers DON'T choose GIF!„„„TGA„---„(Truevision Targa)„„TGA are another useful format for storing bitmapped graphics.  They„are usually 8 bit (256 colors) or 24 bit (16+ million colors), but„they don't have to be.„„* Begin TGA snippet„„TYPE TGAHeader            „   InfoLength AS STRING * 1        'Length of image information block. „                                   'This block is stored after the header,„                                   'and usually contains copyright info.„                                   'TGA decoders will have to be smart„                                   'enough to skip over the info block.„   MapType AS STRING * 1           '0 - All pixels are in RGB triples„                                   '1 - Colormap ("DAC table")„   FileType AS STRING * 1          '1 - Uncompressed with a colormap„                                   '2 - Uncompress without colormap„                                   '9 - Compressed (RLE) with colormap„                                   '10- Compressed (RLE) without colormap„   MapOrigin AS INTEGER            'Color index of the first entry in„                                   'the colormap.  Usually 0„   MapLength AS INTEGER            'Number of colors in the colormap„   MapSize AS STRING * 1           'Size of an entry in the colormap.„                                   'Can be 16, 24, or 32 bits.„   XOrigin AS INTEGER              'The X coordinate of the left corner„                                   'of the image.  Usually 0„   YOrigin AS INTEGER              'Y coordinate of left corner.  Usually 0„   Cols AS INTEGER                 'Width of image in pixels„   Rows AS INTEGER                 'Height of image in pixels„   BitsPerPixel AS STRING * 1      'If their is a colormap, this can be„                                   '8 or 16.  Without a colormap, this can„                                   'be 16, 24, or 32.„   Flags AS INTEGER                'Additional information about the image„   'Bit 0, 1, 2, 3:  Wasted filler bits„   '         Bit 4:  Reserved, it is always 0„   '         Bit 5:  0 - Origin in lower left corner„   '                 1 - Origin in upper left corner„   '   Bit 6 and 7:  00 - Rows stored one after another. (1,2,3,4,5,6,7,8...)„   '                 01 - Even rows are stored first, then odd rows.„   '                      (2,4,6,...,1,3,5...)  A primitive form of„   '                      interlacing?„END TYPE„  „DIM TGA AS TGAHeader„OPEN FileName$ FOR BINARY AS 1„GET #1, , TGA„„'After the header is the information block of length TGA.InfoLength.  This„'should be skipped.„„SEEK #1, 19 + TGA.InfoLength       'The header is 18 bytes.  Add one more„                                   'to skip past the info block„'Next is the colormap (aka "DAC table"), if one is present.„„IF TGA.MapType = 1 THEN            'Is there a colormap?„   Length = TGA.MapLength * ASC(TGA.MapSize) / 8„                                   '^ Figure length of colormap„   Foo$ = STRING$(Length, 32)      'Allocate memory„   GET #1, , Foo$                  'Read palette from disk„   PalStr = Foo$                   '***** Move into palette array„   MakePalette TGA.MapLength       'Send palette to VGA card„END IF„„* End snippet„„At this point we are ready to display the picture.  The following„snippet shows how to load an uncompressed TGA with 256 colors.  It„is very similar to the one for loading BMP files, it loads one row„into memory at a time and displays it.„„* Begin snippet„„Foo$ = STRING$(TGA.Cols, 32)       'Allocated space for one row„FOR Y = 0 TO TGA.Rows              'Loop through rows -- this„                                   'ignores the some of the stuff in the„                                   'header, which may not work well„                                   'for some images„   GET #1, , Foo$                  'Load in one row„   FOR X = 0 TO TGA.Cols           'Loop through columns„      Bar = ASC(MID$(Foo$, X + 1, 1) 'Extract byte„      PSET (X, Y), Bar             'Output the byte„   NEXT                           „NEXT                               '...done!„„* This snippet shows how to handle uncompressed TGA files with  „  16 million colors.„  „Foo$ = STRING$(TGA.Cols * 3, 32)   'Allocated memory - 3 bytes for each       „                                   'pixel in the row„FOR Y = 0 TO TGA.Rows              'Loop through rows, ignoring header info„   GET #1, , Foo$                  'Load row into memory„   Ptr = 1                         'Set pointer„   FOR X = 0 TO TGA.Cols           'Loop through columns„      Red = ASC(MID$(A$, BufPtr, 1))        'Extract red value„      Green = ASC(MID$(A$, BufPtr + 1, 1))  'Ditto„      Blue = ASC(MID$(A$, BufPtr + 2, 1))   'Ditto„      Ptr = Ptr + 3                'Increment pointer„„      '* Now you'll have to do something with the color values.  You„      'can convert them to greyscale or use an optimized palette.  See„      'Step 3 in the "Some background" section for some sample code„      'snippets.„   NEXT                           „NEXT                               '...done!„„* End snippet„„You'll have to figure out how to use compressed TGA files on your own.„(In other words, you'll have to snag the code from the ABC packets.)„„„MAP„---„(Fractint palette files)„„MAP files are an easy way to store palette information for 256„color modes.  They are simply a series of RGB values separated by„spaces, like this:„„  0   0 255„255   0   0„127   0 127 Comments can be placed after the numbers like this„127 127 127 Another comment that should be ignored by the parsing program„...„123  45   6 End of file, should be 256 lines„„* Here is the code snippet to handle MAP files.„„OPEN FileName$ FOR INPUT AS 1      'Don't have to use BINARY for these„FOR I = 1 TO 256„   INPUT #FileNum, Foo$            'INPUT may not be the best choice, you„                                   'can use another function that loads in„                                   'one line at a time.„   Foo$ = RTRIM$(LTRIM$(Foo$))     'Trim it„   Bar = INSTR(1, A$, " ")         'Figure out where first number is„   Red = VAL(LEFT$(A$, Bar))       'Extract red value„   Foo$ = RTRIM$(LTRIM$(RIGHT$(Foo$, LEN(Foo$) - Bar)))„                                   '^ Parse rest of line (scary code, huh?)„   Bar = INSTR(1, Foo$, " ")       'Figure out where 2nd number is„   Green = VAL(LEFT$(B$, Sp2))     'Extract green value„   Foo$ = RTRIM$(LTRIM$(RIGHT$(Foo$, LEN(Foo$) - Bar)))„   Bar = INSTR(1, C$, " ")         'Where is 3rd number?„   IF Bar = 0 THEN„      Blue = VAL(C$)               'Load blue value directly„   ELSE„      Blue = VAL(LEFT$(C$, Sp3))   'Extract blue value (in case there is„   END IF                          'a comment after it)„   MID$(PalStr, ((I - 1) * 3) + 1) = CHR$(Red) + CHR$(Green) + CHR$(Blue)„                                   '^ Insert it into palette„NEXT                               'Loop to next line in MAP file„CLOSE 1                            'Can't forget to close the file„„* End MAP file snippet„„„OTHER SOURCES OF INFORMATION„----------------------------„The X2 FTP site in Finland has lots of information on graphics and„game programming.  ftp://x2ftp.oulu.fi/„„Wotsit has a large archive of file format specifications.„http://www.wotsit.demon.co.uk„„C source code for JPEG files can be found in the directory„ftp://ftp.uu.net/graphics/jpeg„(also has code for GIF and BMP loading)„„„HOW TO CONTACT ME„-----------------„Direct all positive feedback to jbaughn@ldd.net or jbaughn@geocities.com„This includes suggestions for improvements, questions, praise, job„offers, etc.„„Direct all negative feedback (i.e. flames) to billg@microsoft.com„„„OBLIGATORY COPYRIGHT AND LEGALESE„---------------------------------„Since everyone else plasters this stuff all over their work, I guess I„will too.„„This document is (C) COPYRIGHT 1997, James S. Baughn.  All rights„reserved.  This document is protected by international statues (Ha!„That ought to scare most people away from plagerizing this...)„„All trademarks, etc., are the property of their respective holder.„(Whatever that means...)„„If you use any of the code snippets in your own programs, here's what„you need to do:„   1.  Email me at jbaughn@ldd.net telling me how great this document„       is.  This is a required step.  (Just kidding)„   2.  You should give me credit somewhere in your program or documentation.„       Yeah, right!„   3.  Visit my homepage (see below) and reload the counter over and„       over again to inflate my statistics.  (Just kidding)„„DISCLAMER:  If any harm results from the viewing or use of this„document (i.e. your dog bites you, you become infected with the Good„Times virus, the IRS says you owe more taxes, etc.), I AM NOT „RESPONSIBLE!!!  You are.„„„SHAMELESS PLUG FOR MY HOMEPAGE„------------------------------„No file is complete without a mention of the author's homepage.„http://baughn.home.ml.org„„And you may be interested in a QuickBASIC program I wrote called„"Microsoft Simulator"  It lets you play the part of Bill Gates and„control the day-to-day activities of Microsoft.  (i.e. hostile takeovers,„releasing upgrades every day, inventing new slogans like "Where do„WE want you to go today?", etc.)„http://baughn.home.ml.org/mssim.htm„„„CONCLUSION„----------„I hope you find this document useful.  If not, well, then maybe you„should write your own.„„Enjoy!„Tika Carr                      LINKING C TO BASIC             t.carr@pobox.com               07-15-97 (16:03)       Text                   262  12662    C2QB.TXT                    ========================================„               [         QuickBasic 4.5 Tutorial        ]„               [ Interfacing QuickBasic with C Programs ]„               [    Copyright (c) 1997 by Tika Carr     ]„                ========================================„        (Please read disclaimer at the end of this tutorial.)„„While QuickBasic is quite powerful for most applications, there are„times when a programmer would get more speed or efficiency when using a„C function, but would rather not write the whole program in C. In this„tutorial, I hope to cover some of the basics of interfacing C programs„with QuickBasic 4.5. This can't be done as easily with QBasic because„QBasic cannot use .OBJ files of compiled C programs. It MIGHT be done„somehow, but the methods are beyond the scope of this tutorial. If you „would like to use your QuickBasic .OBJ files in your C programs, „unfortunately this isn't possible. Reason is because the .OBJ files that „QuickBasic creates contains calls to QuickBasic functions, statements „and keywords (like PRINT, CLS and so on). The code for that is in the „run time library and therefore cannot be transferred in the .OBJ file „for use in a C compiler. However, you CAN use .OBJ files from some C „compilers and assemblers in QuickBasic. This tutorial will focus on „how to use C functions in QuickBasic.„„INFORMING QUICKBASIC OF A C FUNCTION„====================================„Keep in mind that C doesn't really have any SUBroutines, only functions.„Subroutines can be written as 'void' functions which will behave as a„QuickBasic SUB (does not return a value).„„To let QuickBasic know you want to use an external routine, you still„have to DECLARE it. For example, let's suppose we have a C function„called PrintIt and passing to it 3 variables:„„void PrintIt(int x, int y, char *text)„„Some knowledge of how C handles passing of parameters is necessary when„interfacing with QuickBasic. For variables that you are passing just the„value of (not a pointer, ie. the variable doesn't have an asterisk (*)„preceding it), you must let QuickBasic know its being passed by value by„using BYVAL. SEG is used for parameter variables that are pointers (as„in char *text above) SEGment, meaning pass the segment ADDRESS of the„variable, not the value). Here's an example using our above PrintIt„function:„„DECLARE SUB PrintIt(BYVAL x AS INTEGER, BYVAL y AS INTEGER,_„SEG text AS STRING)„„(Note that the underscore _ is used to indicate that the second line is„really part of the first, and should be joined there. Just wasn't enough„room on a line to fit it all in.)„„This example won't work yet but we'll get to why in a moment. This„example just shows how to pass the parameter's value or address. It is„also important to be sure and state what type of variable is used:„„  If declared in C as        use this in QuickBasic„ -----------------------------------------------------„       int                     AS INTEGER„       char                    AS STRING„         (note that QB doesn't accept AS STRING * n in a DECLARE)„       double                  AS DOUBLE„       float                   AS SINGLE„       long                    AS LONG„„In the case of a C function that passes a value:„„int PrintIt(int x, int y, char *text)„„You would use:„„DECLARE FUNCTION PrintIt% (BYVAL x AS INTEGER, BYVAL y AS INTEGER,_„SEG text AS STRING)„„Here note the % after PrintIt. This tells you its an INTeger. See the„QuickBasic online help and Manual for the symbols for different variable„types and match them accordingly. A type of 'void' is to be declared as„a SUB and not a function.„„Now that we know how to declare the parameters, we have to be sure they„are in the right order. When QuickBasic sees a function written in„C, it reads the parameters in _backwards_. For instance, taking our„example:„„void PrintIt(int x, int y, char *text)„„QuickBasic looks at it like this:„„SUB PrintIt(text$, y%, x%)„„There are two ways to get QuickBasic to see the parameters in the right„order. If you wrote the C program yourself, you can use the pascal or,„on some compilers, _pascal keyword to tell the C Compiler that the„parameters are to be passed in Pascal order (which is the same way„QuickBasic uses). Here's how we'd rewrite the above C function:„„void pascal PrintIt(int x, int y, char *text)„„Some C compilers (namely Borland and some others) also let you set all„the parameters to be passed using Pascal order by a setting in the„compiler's IDE configuration. This can cause some problems, though, if„you have other functions in the C source that are going to also use the„same function that is to be used in QuickBasic. When doing this type of„programming, you will have to be sure when you use pascal only on the„functions that are not used by other ones in the C source, or else leave„it off and declare it as CDECL in the QuickBasic program (discussed in a„moment). There are other ways around this too, which is beyond the scope„of this tutorial. Most C programmers would know of these other options.„„When you compile the function in C that you used the pascal keyword in,„it will be all set so that QuickBasic can read it. Then just declare it„in QuickBasic as:„„DECLARE SUB PrintIt(BYVAL x AS INTEGER, BYVAL y AS INTEGER,_„SEG text AS STRING)„„However, there are times when you are told an .OBJ file was compiled in„C but you may not have the actual source code to it, and therefore can't„make any changes. So, do we just declare the parameters in backwards„order? Well, not quite. QuickBasic has CDECL which will let you tell it„that you are using a C function:„„C function:  void PrintIt(int x, int y, char *text)„„QuickBasic Declaration:„„  DECLARE SUB PrintIt CDECL (BYVAL x AS INTEGER, BYVAL y AS INTEGER,_„  SEG text AS STRING)„„This lets QuickBasic know that the parameters are actually being passed„in reverse order, or CDECLare (C-DECLARE).„„COMPILING AND LINKING IN THE C FUNCTION„========================================„If you are writing the C function yourself, you may want to be double„sure that you don't have it compile in any debug information. Some„compilers have IDEs that are set to add in debug info so that you can„step through your C program, much like the Debug in QuickBasic does. To„be best compatible with QuickBasic, you will want this turned off. Also„be sure your compiler will create Microsoft-compatible .OBJ files.„Microsoft products like Quick C will do this but some other compilers„may also be Microsoft compatible. Sometimes you may need to compile the„program using the assembler that comes with the compiler, and not the„compiler itself (as sometimes may be the case with Borland C++ 3.1, for„example). You'll need to be familiar with your compiler and its IDE„and/or other configurations (if any) to get the best results. If nothing„works, then its probably because the .OBJ files are just not compatible.„„After you created (or obtained) an .OBJ file of the C function, you will„need to link them into your program. First be sure that LINK.EXE and„LIB.EXE are in your PATH or current directory where the .OBJ files are„and also the BQLB45.LIB, and possibly the QB.LIB (if you plan to use„INTERRUPTs in your program too).„„I normally make the QLB file first:„„LINK /Q CPROG1.OBJ CPROG2.OBJ CPROG2.OBJ, CPROG.QLB,,BQLB45.LIB;„„This creates the CPROG.QLB file and a .MAP file that you can delete (but„sometimes may be helpful to look at in case of problems).„„If you are going to use interrupts, change the BQLB45.LIB; above to:„BQLB45.LIB+QB.LIB;„„Next make the Library so that you can also compile your program:„„LIB CPROG.LIB+CPROG1.OBJ+CPROG2.OBJ+CPROG3.OBJ;„„Or, if planning to use interrupts too:„„LIB CPROG.LIB+CPROG1.OBJ+CPROG2.OBJ+CPROG3.OBJ+QB.LIB;„„This makes your CPROG.LIB file. Now just start QB with: QB /L CPROG.QLB„and make the declarations as explained earlier in this tutorial. Its„best to create this as a .BI file and '$INCLUDE: 'CPROG.BI' for example,„in your program. You can also use more than one $INCLUDE in your„program. This is useful if you need to also use QB.BI for INTERRUPTs.„„PROBLEMS IN LINKING THE OBJ FILE TO A QLB„-----------------------------------------„L1101  invalid object module„„This is probably one of the more common ones, and most of the time is„because your OBJ file is not compatible somehow with QuickBasic.„Normally, it may be because you inadvertently included some of the C„compiler's Debug information (as explained previously). If this don't„help, try compiling using the assembler or compiling to assembly source„and using a Microsoft compatible assembler to compile the .OBJ file, if„possible. There are times though when there doesn't seem to be a fix.„Those are the ones that just aren't compatible. Best try another C„compiler and/or assembler if that happens.„„L2029 unresolved externals„„This is another common problem when linking. This occurs for basically„the same reason as the L1101 error above does, but may also be something„in your C program. Does anything in your C program call any external„functions that are not included in the compiling? Perhaps from another„program or source? You will have to compile that source too and include„the OBJ file in.„„Another common problem is you may find "printf" or other standard„library functions to be one of the unresolved externals. This means that„the .OBJ file is made so that the C Compiler knows where and what printf„is. But, QuickBasic does not. One solution you may want to try if your„compiler supports it, is to compile to an assembly language source, then„compile that to an .OBJ file with an assembler. Basically, you want to„be sure that the .OBJ is pure machine language, and nothing external„being called that isn't going to be included in your QuickBasic library.„„L2041 stack plus data exceed 64K„„This sometimes occurs if you compiled the program using an incompatible„memory model. For best results, use the medium, compact or small memory„model to compile C functions that will be used in QuickBasic.„„These are the most common ones you might run into. For other linker„errors (and more detailed descriptions of these) see your QuickBasic„manual, section 2, pp. 420 - 431.„„ERRORS IN RUNNING THE QUICKBASIC PROGRAM„----------------------------------------„One of the most common ones is that QuickBasic will say that the sub or„function is not found in the Quick Library. In that case, be sure you„loaded the Quick Library. You may also want to double check all your„steps and try compiling and linking again. If you used an assembler to„compile the source, perhaps the assembler did not specify the function„as '.public'. You may have to use a text editor to make that change in„the assembly source code and re-assemble it.„„Another common error is that QuickBasic may find something wrong with„the list of parameters. Be sure you have it declared right, and are sure„of the way the parameters are seen in QuickBasic. Maybe you didn't use„CDECL in QuickBasic or pascal in your C function. You can't do both. You„can only use CDECL in QuickBasic's DECLARE =OR= use the pascal keyword„in the C function. Doing both puts us in the same position of one seeing„the list of parameters in reverse order than what was intended.„„                    ******* DISCLAIMER *******„„The author of this article cannot guarantee the usability or„suitability of the information presented herein for any particular„purpose. In addition, the user of the information in this article„agrees not to hold the author, moderator or any other direct or„indirect agent liable in any way for any damages, loss of data, or„other consequences arising from use of this information. If laws in your„area do not allow this type of disclaimer than DON'T USE THIS„INFORMATION! While I have made every conscious effort to ensure the„information in this tutorial is accurate, the end result depends on„the person making use of the information presented here. Use the„information in this tutorial at your own risk.„„                  ******* CONTACT INFORMATION *******„„As of 7/11/1997, comments, questions and suggestions, can be directed„to:„„ FidoNet: Tika Carr 1:2613/601 or 1:2613/313„Internet: t.carr@pobox.com„„=====================================================================„All compilers and products mentioned are copyright and/or trademarks of„their respective owners.„Robert Fortune                 SHARE DATA BETWEEN SUBS        FidoNet QUIK_BAS Echo          10-23-97 (00:12)       Text                   90   2672     SHARE.BAS   '>I've been studying QBasic for a while [...]„'>Anyhoo, I can't figure out how to transfer data between subs.„'>explain this.„„   If you mean you want to share data *between* SUBs you can make the„   variables that you want all of your SUBs (and\or FUNCTIONs) to share„   global by using DIM SHARED in your main module. As in:„„   DIM SHARED MyVariable%, Total&, FullName$„„   You would put that DIM SHARED statement in your program's main module„   (not in a SUB or FUNCTION). Doing that means that any SUB (or FUNCTION)„   in your program can share those variables with your main module.„„      If you only want a single SUB to share specific variables with the„   main module you can use:„„   DECLARE SUB Hello()„   Text$ = "Hello"„   Hello           ' Call the Hello SUB„   END             ' End of main program„„   SUB Hello       ' The Hello SUB„    SHARED Text$   ' Text$ from your main module is shared with this sub„    PRINT Text$„   END SUB„„     Or you can pass the variable when you call the SUB as in:„„   DECLARE SUB AMessage(Text$)„   Text$ = "A fair disposition is essential to a successful life."„   CALL AMessage(Text$)  ' pass the variable to the SUB AMessage„   END      ' End of main program„„   SUB AMessage(Text$)„      PRINT AMessage$„   END SUB„„   Here's some code that uses each of the 3 methods I described above.„„' ------------- CUT HERE ----------------- CUT HERE ----------------------„REM SHRDATA.BAS„REM Different ways that you can share data with your SUBs and\or FUNCTIONs„REM 10/23/1997„DEFINT A-Z        ' All untyped variables default to type integer„DECLARE SUB Hello ()„DECLARE SUB WhatUp ()„DECLARE SUB Goodbye (Bye$)„„' 1) Share the string variable Text$ with all SUBs (and\or FUNCTIONs)„„DIM SHARED Text$  ' string variable Text$ is shared with all SUBs\FUNCTIONs„CLS„PRINT„„Text$ = "Hello World!"„Hello             ' call the Hello SUB„„„' 2) Share the string variable Message$ with just the Whatup SUB„„Message$ = "What's up with that?"„WhatUp            ' see the WhatUp SUB where Message$ is declared SHARED„„„' 3) Share the string variable Bye$ by passing it when the SUB is called„„Bye$ = "Goodbye world!"„Goodbye (Bye$)    ' Bye$ is passed to be shared with the Goodbye SUB„PRINT„PRINT "Thethethe... that's all folks! <g>"„END„„SUB Goodbye (Bye$)„ PRINT Bye$„END SUB„„DEFINT A-Z„SUB Hello„ PRINT Text$„END SUB„„DEFINT A-Z„SUB WhatUp„ SHARED Message$  ' Share Message$ (from main module) with this SUB„ PRINT Message$„END SUB„' ------------- CUT HERE ----------------- CUT HERE ----------------------„„ Hope that helps. Good luck!„