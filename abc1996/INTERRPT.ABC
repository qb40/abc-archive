Barton Paul Levenson           QBASIC SCREEN SCROLL           FidoNet QUIK_BAS Echo          01-06-96 (09:50)       QBasic                 55   1986     SCRNSCRL.BASDECLARE SUB Background (Row%, Col%, Row2%, Col2%)„DECLARE SUB Scroll (Dir$, Num%, Att%, Row%, Col%, Row2%, Col2%)„'----------„' SCROLLER tests a routine to scroll a rectangular portion of the screen.„'----------„        CALL Background(3, 10, 7, 20)„        LOCATE 24, 1: X$ = INPUT$(1)„„        CALL Scroll("U", 1, 112, 3, 10, 7, 20)„        LOCATE 24, 1: X$ = INPUT$(1)„„        COLOR 7, 0„END ' Main module„„SUB Background (Row%, Col%, Row2%, Col2%)„„'----------„' Background writes a traceable pattern to the screen.„'----------„        CLS„        Size% = Col2% - Col% + 1„        COLOR 0, 3„„        FOR I% = Row% TO Row2%„                LOCATE I%, Col%„                PRINT STRING$(Size%, "*")„        NEXT I%„„END SUB ' Background„„'----------„' Scroll scrolls a rectangular portion of the screen up or down.„'----------„SUB Scroll (Dir$, Num%, Att%, Row%, Col%, Row2%, Col2%)„DIM Code(1 TO 9) AS INTEGER             ' Array to hold machine code.„„        DEF SEG = VARSEG(Code(1))       ' Switch to data area.„        S% = VARPTR(Code(1))            ' Get the offset.„„        IF Dir$ = "U" THEN D% = 6 ELSE D% = 7„„        POKE (S% + 0), &HB4: POKE (S% + 1), D%          ' MOV AH, Direction.„        POKE (S% + 2), &HB0: POKE (S% + 3), Num%        ' MOV AL, # of lines.„        POKE (S% + 4), &HB7: POKE (S% + 5), Att%        ' MOV BH, Attribute.„        POKE (S% + 6), &HB5: POKE (S% + 7), Row% - 1    ' MOV CH, upper left.„        POKE (S% + 8), &HB1: POKE (S% + 9), Col% - 1    ' MOV CL, "„        POKE (S% + 10), &HB6: POKE (S% + 11), Row2% - 1 ' MOV DL, lower right.„        POKE (S% + 12), &HB2: POKE (S% + 13), Col2% - 1 ' MOV DH, "„        POKE (S% + 14), &HCD: POKE (S% + 15), &H10      ' INT 10h (BIOS).„        POKE (S% + 16), &HCB                            ' RETF.„„        CALL ABSOLUTE(S%)               ' Do it.„        DEF SEG                         ' Go back where we started from.„END SUB ' Scroll„„Unknown Author(s)              QB SCREEN SCROLL               Rolf@ice.prima.ruhr.de         01-14-89 (23:21)       QB, PDS                58   1783     SCROLL.BAS  DECLARE SUB Scroll (Direction%, NumRows%, Tlrow%, Tlcol%, Brrow%, Brcol%, Fore%, Back%)„TYPE RegType„  AX AS INTEGER„  BX AS INTEGER„  CX AS INTEGER„  DX AS INTEGER„  BP AS INTEGER„  SI AS INTEGER„  DI AS INTEGER„  FLAGS AS INTEGER„END TYPE„„SHELL "dir/w"„„SLEEP 1„„DO„  Scroll 7, 1, 1, 1, 25, 80, 7, 0„  SLEEP 1„LOOP„„DEFINT I-N„SUB Scroll (Direction%, NumRows%, Tlrow%, Tlcol%, Brrow%, Brcol%, Fore%, Back%)„'„''''''''''„'„'  SCROLL  Scrolls an Individual window on the Screen„'„''''''''''„'„'  Parameters:„'     Direction% = 6 for scroll up, 7 for scroll down„'     NumRows%   = # rows to scroll, 0 for clear area„'     Tlrow%     = top left row of window to be cleared„'     Tlcol%     = top left column of window to be cleared„'     Brrow%     = bottom right row of window to be cleared„'     Brcol%     = bottom right column of window to be cleared„'     Fore%      = foreground color of window„'     Back%      = background color of window„'„'  Interrupt x'10' user for video interface:„'„'      Ah = 6 for scroll window up, 7 for scroll window down„'      Al = # lines to scroll window, 0 for clear window„'      ch,cl = Row,Col of upper left corner of window„'      dh,dl = Row,Col of lower right corner of window„'      bh = clear screen attribute„'„'„  DIM InRegs AS RegType, OutRegs AS RegType„  IF (Direction% < 6 OR Direction% > 7) THEN EXIT SUB  'bad direction code„  InRegs.AX = Direction% * 256 + NumRows          'ah=up/dn, al=# lines„  InRegs.BX = Fore% * &H100 + Back% * &H1000      'bh=clear attribute„  InRegs.CX = (Tlrow% - 1) * &H100 + Tlcol% - 1   'cx=row,col of upper left„  InRegs.DX = (Brrow% - 1) * &H100 + Brcol% - 1   'dx=row,col of lower right„  CALL Interrupt(&H10, InRegs, OutRegs)„END SUB„„Tyler Barnes                   MONITOR INTERRUPTS             FidoNet QUIK_BAS Echo          04-15-96 (02:22)       QB, PDS                88   2710     TRAPINT.BAS 'Well, this code may be kind of useless, but it's something that I was messing„'with, and decided to post. I don't really have a use for it, maybe someone„'else does... It could probably be written better as well. You can see I don't„'have a high opinion on this code. <G>„'It allows you to monitor interrupts... Sort of pseudo-trapping.„„DECLARE FUNCTION CalledInterrupt% (intnum%)„DECLARE SUB TrapInterrupt (intnum%, ExitProc%)„DECLARE SUB RestoreInterrupt (intnum%)„'$INCLUDE: 'qb.bi'„DIM SHARED InregX AS RegTypeX, OutregX AS RegTypeX„DIM IntSegs(0 TO 255) AS INTEGER, IntOffs(0 TO 255) AS INTEGER„DIM IntCode(0 TO 255) AS STRING * 25„ „CONST Abort = 0, Continue = 1, All = -1„ „'Pseudo interrupt trapper„'Future enhancements: Decrease memory used?„'                     Return Registers„ „ „TrapInterrupt 5, Abort„DO„LOOP UNTIL CalledInterrupt(5)„RestoreInterrupt All„„DEFINT A-Z„FUNCTION CalledInterrupt (intnum%)„SHARED Interrupts AS STRING * 256„IF MID$(Interrupts, intnum% + 1, 1) = CHR$(2) THEN„MID$(Interrupts, intnum% + 1, 1) = CHR$(1)„CalledInterrupt = -1„ELSE„CalledInterrupt = 0„END IF„END FUNCTION„„SUB RestoreInterrupt (intnum)„SHARED Interrupts AS STRING * 256, IntSegs() AS INTEGER, IntOffs() AS INTEGER„IF intnum < 0 THEN„FOR I% = 1 TO 256„IF MID$(Interrupts, I%, 1) <> CHR$(0) THEN„InregX.Ax = &H2500 + (I% - 1)„InregX.DS = IntSegs(I% - 1)„InregX.Dx = IntOffs(I% - 1)„CALL INTERRUPTX(&H21, InregX, OutregX)„END IF„NEXT I%„ELSE„InregX.Ax = &H2500 + intnum„InregX.DS = IntSegs(intnum)„InregX.Dx = IntOffs(intnum)„CALL INTERRUPTX(&H21, InregX, OutregX)„END IF„END SUB„„SUB TrapInterrupt (intnum, ExitProc)„SHARED IntCode() AS STRING * 25, Interrupts AS STRING * 256„SHARED IntSegs() AS INTEGER, IntOffs() AS INTEGER„STATIC FirstTime„IF FirstTime = 0 THEN„FirstTime = 1„FOR I% = 0 TO 255„MID$(Interrupts, I% + 1, 1) = CHR$(0)„NEXT I%„END IF„InregX.Ax = &H3500 + intnum„CALL INTERRUPTX(&H21, InregX, OutregX)„IntSegs(intnum) = OutregX.ES„IntOffs(intnum) = OutregX.Bx„MID$(Interrupts, intnum + 1) = CHR$(1)„IC$ = CHR$(6) + CHR$(&H55) + CHR$(&H50) + CHR$(&HB8)„IC$ = IC$ + MKI$(VARSEG(Interrupts))„IC$ = IC$ + CHR$(&H8E) + CHR$(&HC0) + CHR$(&HBD) + MKI$(VARPTR(Interrupts) + intnum)„IC$ = IC$ + CHR$(&HB0) + CHR$(2) + CHR$(&H26) + CHR$(&H88) + CHR$(&H46)„IC$ = IC$ + CHR$(0) + CHR$(&H58) + CHR$(&H5D) + CHR$(7)„IF ExitProc = 0 THEN„IC$ = IC$ + CHR$(&HCF)„ELSE„IC$ = IC$ + CHR$(&HEA) + MKI$(IntOffs(intnum)) + MKI$(IntSegs(intnum))„END IF„IntCode(intnum) = IC$„InregX.Ax = &H2500 + intnum„InregX.DS = VARSEG(IntCode(intnum))„InregX.Dx = VARPTR(IntCode(intnum))„CALL INTERRUPTX(&H21, InregX, OutregX)„END SUB„„Tika Carr                      INTERRUPT TUTOR                FidoNet QUIK_BAS Echo          08-03-96 (17:07)       Text, QB, PDS          313  13212    INTUTOR.BAS  =================================„[     QuickBasic 4.5 Tutorial     ]„[      How To Use Interrupts      ]„[ Copyright (c) 1996 by Tika Carr ]„ =================================„(Please read disclaimer at the end of this tutorial.)„„This tutorial hopes to cover the basics of how to use Interrupts in„QuickBasic. Note that this method only works in QuickBasic 4.5. I hope„to do a tutorial for those who use QBasic (which comes with MS-DOS 5.0„and higher).„„1. Getting Started„„You will need to have started QuickBasic 4.5 by typing the following„at the MS-DOS prompt:„„QB /L QB.QLB„„This QuickLiBrary will load in what you need to use interrupts.„„Many new programmers avoid using interrupts because they are afraid to„damage their computer. I've noticed people mess up thier system„*without* using interrupts. Sections 7 - 9 have some tips on safe„debugging and what to do if you have a crash. Further,  BACK UP YOUR„HARD DRIVES! This is MOST important! And save your programs onto„floppy diskette before you run them. Ultimately, its still up to you„to protect your system. This goes for any type of programming.„„2. Your First Interrupt„„Type in the following and save it, then run it. We'll look at the„program and see how it all works in a moment.„„=======>8 Snip 8<=======„„'Example Program for CALL INTERRUPT Tutorial„'by Tika Carr„„'$INCLUDE: 'QB.BI'„„DIM Inregs AS RegType, Outregs AS RegType„„'Int 10h (interrupt 10 hexidecimal) controls the video part.„'0Ah tells the computer to write a character on the screen.„'We'll put the letter 'A' on the screen in this example.„„CLS„„Inregs.ax = &HA41  'load high and low bytes into ax register (&H0A01)„Inregs.cx = 1      'write only 1 character„„CALL INTERRUPT(&H10, Inregs, Outregs) 'put the character on the screen„„=======>8 Snip 8<=======„„'$INCLUDE: 'QB.BI' defines the type structures used for the„interrupts.„„DIM Inregs AS RegType, Outregs AS RegType„„The INCLUDE statement defines the type structures that is used for„interrupts. These are found in the QB.BI file that comes with„QuickBasic 4.5. The DIM Statement lets you specify what variable to„put the registers defined in RegType in, so that its easy to pass all„the registers to the interrupt.„„3. What are registeres and what do they do?„„A register is a place where you store values, and is a more direct way„to communicate with the computer. The computer looks into registers„for specific values, and uses them to perform different tasks. For„example, we gave the computer some information in the AX register,„telling it we wanted to write something on the screen, and what we„wanted to write to the screen (the letter 'A'). We also put a value„into the CX register, telling the computer we wanted to write only one„copy of the letter 'A'. When you call an interrupt, you send all that„information along to the computer (int 10h, which accesses your„video). Basically, we just told the computer to PRINT "A" on the„screen. Registers also let the computer send information back to your„program. For example, INT 33 can give your program the X and Y„coordinates of where the mouse currently is located.„„For CALL INTERRUPT: ax, bx, cx, dx, bp, si, di, flags„Defined as RegType„„FOR CALL INTERRUPTX: ax, bx, cx, dx, bp, si, di, flags, ds, es„Defined as RegTypeX„„Depending on the interrupt you want to use, you will need to pick the„type of call that suits it. For instance, if you don't use the es„register, then using CALL INTERRUPT would work fine. However, if the„computer will be looking into the es register for something, or if you„will need to know what is in the ds register, you will want to use the„CALL INTERRUPTX.„„These definitions are all in the QB.BI file. You '$INCLUDE: 'QB.BI' in„your program, then you DIM Inregs AS RegyType, OutRegs AS RegType.„These will set up your variables so that you can access the registers.„„To put something into the registers, you use Inregs, and to read the„registers, you use the OutRegs variable:„„Inregs.ax  is where you would put something in the AX register.„Outregs.cx is where you can find what the computer put in the CX„           register.„„4. Storing Values into Registers:„„Since the registers take information in bytes only, you may have to do„some converting to load the registers properly. Many times an„interrupt listing will show something like:„„Interrupt 10h: Video„        Entry: ah = 0A write a character to the screen„               al = value of character to write„               bh = video page„               bl = attribute or color of character„               cx = number of times to write the character„„This can seem confusing. How do you load the AX register? Where IS it?„There's an AH and an AL. These mean the High and Low bytes of the AX„register, respectively. Here's how you would put a value into the AX„register:„„Inregs.ax = &HA41  'load high and low bytes into ax register (&H0A01)„„(Note that QuickBasic likes to take away the leading 0s. Initially, we„typed it as: Inregs.ax = &H0A41)„„The values go into the registers as:  0A41„                                      HiLo„„Most of the time, you probably will run into this situation:„„Video$ = "0A"              ' Tell computer to write to video„Character$ = "A"           ' Character to write on screen„„Here is how you would get it all into one register:„„Character$ = HEX$(ASC(A))  ' Convert 'A' into its ASCII value in„                           ' Hexidecimal.„„Since Video$ already is in Hexidecimal, we won't need to change it.„Now, we put them together:„„AX$ = Video$ + Character$      ' AX$ now contains 0A41 PRINT AX$ to„                                ' see for yourself.„„Now that we got the full hexidecimal value to put into the AX„register, we still have to convert this into a *number*:„„Inregs.ax = VAL("&H" + AX$)„„This makes the string now say "&H0A41" and it also converts it into a„numeric value (using VAL). Now you have the high and low bytes„converted and stored into the AX register that will go into the„computer (Inregs). When you do the CALL INTERRUPT (&H10, Inregs,„Outregs), the values will be correctly loaded where the computer can„find them.„„5. Reading the Registers„„Outregs also holds register values. After you make a CALL INTERRUPT,„you can read, let's say, the high and low bytes of the BX register and„use it in your own program:„„BX$ = HEX$(Outregs.bx)      ' Convert the value to hexidecimal, its„                            ' easier to extract the high and low bytes„                            ' this way.„„Since the computer likes to truncate leading 0s, we have to convert„the value of BX$:„„' Get Low and High Byte of BX„' BH$ is the high byte, BL$ is the low byte, both in Hexidecimal.„„L = LEN(BX$)„IF L = 1 THEN BH$ = "0" + BX$: BL$ = "00"„IF L = 2 THEN BH$ = LEFT$(BX$, 2): BL$ = "00"„IF L = 3 THEN BH$ = "0" + LEFT$(BX$, 1): BL$ = RIGHT$(BX$, 2)„IF L = 4 THEN BH$ = LEFT$(BX$, 1): BL$ = RIGHT$(BX$, 2)„„bh = VAL("&H" + BH$)        ' Decimal Value of high byte of BX„bl = VAL("&H" + BL$)        ' Decimal Value of low byte of BX„„Note that this is only applicable for any register you need to get„specifically the low and high bytes of. Sometimes a register is a„pointer to a memory address. If that is the case, you can just use„that value directly, without any type of conversion. For example:„„Address = Outregs.es„Value = Outregs.dx„POKE Address, Value„' Or do whatever you need to with the address returned.„„6. Calling the Interrupt„„When you do a CALL INTERRUPT you access a certain function within the„computer. For example, in CALL INTERRUPT(&H10, Inregs, Outregs) you„called the video interrupt 10h (&H10). Its best of course, to know„what interrupt does what, what to put into the registers, and what the„registers may return to your program that you may be able to use. The„best Interrupt source I've found is Ralph Brown's Interrupt List,„found on some programming BBSs and on the internet on different FTP„sites (like Oakland, SimTel, and Garbo, which you can get current„addresses for by searching Lycos at http://lycos.cs.cmu.edu)„„7. What To Do About Crashes„„a) BACKUP YOUR PROGRAMS BEFORE RUNNING THEM!„First and foremost, its good practice to save your program onto a„floppy diskette before you run it. When your system crashes and you„get back in, just reload the program into QuickBasic.„„b) System Crashes„If your system crashes, or seems to hang, first try hitting CTRL-C or„CTRL-Pause (which is also CTRL-Break). You may have to hit ENTER„afterward to get back to the QuickBasic Interactive Debugging Editor„(IDE) to look at your program. If this don't work, reboot the computer„with CTRL-ALT-DEL (or hit the RESET button on the computer if that„didn't work). Then reload and take a look at your program. If worse„comes to worse, you can shut off the computer, wait a few moments and„turn it back on. Personally, I have always been able to recover by„breaking out of the program with CTRL-Break.„„c) Disk FAT crashes„This is one situation that could occur if you are using interrupts to„access the disk drives or hard disk, and you didn't get things loaded„in right. Best to have your hard drive backed up before each„programming session if you know you'll be using interrupts that will„access the disk drives (ie. may have potential of writing to sectors„or the FAT). Another good thing to have on hand is some utilities that„repair damaged FAT tables and such. There are a number of good„commercial programs out there, and some shareware ones as well. Put„one of these on a bootable floppy.„„d) Video, Sound and other hardware„Its rare that you can actually damage hardware with an interupt call.„If something goes "haywire" the best bet is to just hit the reset„button on the PC right away. Usually, things will then reset and„recover.„„8. Safe Debugging„„Once you get your program written, put a remark before the CALL„INTERRUPT:„„'CALL INTERRUPT (&H10, Inregs, Outregs)„„Then set up the Debug to watch your variables:„„HEX$(Inregs.ax)„HEX$(Outresg.bx)„„Or whatever variables you are working with. Then ALT-R R to restart.„NOW SAVE THE PROGRAM TO FLOPPY DISK! Remove the disk from the drive.„Hit F8 to step through your program one instruction at a time, paying„close attention to the values in the variables. Are they loading„properly? Once you think its working, you can again save the program„and then remove the remark from the call. Step through again and pay„attention to the Outregs registers if you are using them.„„It may seem like a lot to go through, but watching how your program„works step by step, especially if you're first learning to use„interrupts, will show you how the computer uses them, and how your„programs behave (for better or for worse).„„9. In Closing....„„Interrupts are a great way to do things in QuickBasic that you can't„find a command for. Normally, they don't hurt anything and at worse,„just make you have to restart the computer. While a risk is there to„mess up things like hard drives, its rare you'll run into that, if at„all, as long as you don't use disk interrupts until you are„comfortable with how interrupts work and how to use them. Stick with„writing for video, mouse, printer, sound card for starters. Video is„easiest, as is the mouse. And if wierd things happen, don't panic -„reset. :)„„                    ******* DISCLAIMER *******„„The author of this article cannot garantee the usability or„suitability of the inforamtion presented herein for any particular„purpose. In addition, the user of the information in this article„agrees not to hold the author, moderator or any other direct or„indirect agent liable in any way for any damages, loss of data, or„other consequenses arising from use of this information. While I have„made every conscious effort to ensure the information in this tutorial„is accurate and safe to use on any PC compatible in the QuickBasic 4.5„environment, the end result depends on the person making use of the„intformation presented here. Use the information in this tutorial at„your own risk.„„                  ******* CONTACT INFORMATION *******„„As of 8/3/96, comments, questions and suggestions, can be directed to:„„ FidoNet: Tika Carr 1:2613/601„Internet: kari@rochgte.fidonet.org„„=====================================================================„Tika Carr, former staff writer and later editor of GEnieLamp PC„Multimedia Magazine, has been writing QuickBasic 4.5 programs since„1989, and is a frequent contributor to the QUICK_BAS FidoNet Echo. Her„area of specialty is in "tools that make tools" (Steven Levy,„"Hackers"), meaning anything that will make things easier for„programmers to take control of the computer, and make their„imaginations come alive.„=====================================================================„Microsoft, QuickBasic 4.5, and QBasic are trademarks of Microsoft„Corporation. MS-DOS is a registered trademark of Microsoft„Corporation.„Richard J. Backus              INTERRUPTS IN QBASIC           FidoNet QUIK_BAS Echo          12-27-95 (00:00)       QBasic                 139  5942     BASICDOS.BAS'Thought I'd repost this as its been awhile since I last posted:„„'A tutorial for Richard Backus' BASICDOS.BAS code.  Here is„'the code in the original form that he sent to me:„„'===========>8 CLIP 8<============„„'       BASICDOS.BAS„' written: Richard J Backus     27dec95„' purpose: to provide a BASIC BIOS/DOS call interface„' method: using the CALL interface, get registers, call the interrupt, and„'       return the registers. Based on QuickBasic's CALL INTERRUPT routine.„' Warning: Calls requiring segment registers cannot be used.„„' QBasic syntax: CALL ABSOLUTE(intnum%, callregs, retregs, VARPTR(asmcode)))„'   intnum%   a valid DOS interrupt number between 0 and 255, type INTEGER„'   callregs  register values required by call, type REGS„'   retregs   register values returned from call, type REGS„TYPE REGS       'Typedef for DOS registers„   ax  AS INTEGER„   bx  AS INTEGER„   cx  AS INTEGER„   dx  AS INTEGER„   bp  AS INTEGER„   si  AS INTEGER„   di  AS INTEGER„   flg AS INTEGER„END TYPE„'       DOS call code„DATA &H55, &H06, &H1E, &H8B, &HEC, &H9C, &H8B, &H7E, &H0E, &H8A„DATA &H05, &H8B, &H7E, &H0C, &HB4, &H35, &HCD, &H21, &H8B, &H46„DATA &HF8, &H05, &H20, &H00, &H0E, &H50, &H06, &H53, &H8B, &H05„DATA &H8B, &H5D, &H02, &H8B, &H4D, &H04, &H8B, &H55, &H06, &H8B„DATA &H6D, &H08, &H8B, &H75, &H0A, &H8B, &H7D, &H0C, &HFA, &HCB„DATA &H1F, &H07, &H57, &H9C, &H8B, &HFC, &H36, &H8B, &H7D, &H0A„DATA &H89, &H05, &H89, &H5D, &H02, &H89, &H4D, &H04, &H89, &H55„DATA &H06, &H89, &H6D, &H08, &H89, &H75, &H0A, &H58, &H89, &H45„DATA &H0E, &H58, &H89, &H45, &H0C, &H5D, &HCA, &H06, &H00„'       Load DOS/BIOS interface routine„DIM dos%(45)                    'get some memory space„DEF SEG = VARSEG(dos%(0))„FOR i% = 0 TO 88„   READ d%„   POKE VARPTR(dos%(0))+i%, d%  'copy code into memory„NEXT i%„„'       Message string„DATA &H48, &H65, &H6C, &H6C, &H6F, &H20, &H57, &H6F, &H72, &H6C„DATA &H64, &H0D, &H0A„'       use DOS to output the message„DIM dosregs AS REGS„FOR i% = 0 TO 12„   intnum% = &H21               'parameters for call„   dosregs.ax% = &H200„   READ dosregs.dx%„   DEF SEG = VARSEG(dos%(0))    'set call seg„   CALL ABSOLUTE(intnum%, dosregs, dosregs, VARPTR(dos%(0)))„NEXT i%„END„„'=============>8 CLIP 8<================„„'TYPE REGS will set up the variable REGS to access all the registers„'you need to make a BIOS call.  This goes in hand with teh DIM dosregs„'as REGS.  Dosregs will contain the information of the registers.  For„'example, if you want to send a value to the AX register, you can set„'dosregs.ax=value.  I'm not great at explaining how TYPE works, so best„'consult some books (or the help file) on that one. :)„„'Next he has his assembly routine that emulates CALL INTERRUPT.  This„'and the code under it that pokes the routine into memory is the heart„'of the whole thing.„„'Next, he creates the data for each character in the string "Hello„'World" and he uses a BIOS video call to place each character on the„'screen (much the same way my GPrint routine does in my GUI interface).„'„'Note how he used CALL ABSOLUTE.  Lets compare it with QB45's CALL„'INTERRUPT syntax:„„'QB45:   CALL INTERRUPT (intnum%, dosregs, dosregs)„'QBASIC: CALL ABSOLUTE (intnum%, dosregs, dosregs, VARPTR(dos%(0)))„„'Notice all is basically the _same_, you just add the VARPTR at the„'end! And don't forget to change INTERRUPT to ABSOLUTE.  This makes it„'very easy to change a QB45 code to work with QBasic.„„'Now, I will try and explain how you can convert QB45 code that uses„'CALL INTERRUPT so that it will work in QBasic.  Of course, you'll need„'the code written by Richard Backus (which was posted in the previous„'message).  Also note this works only for the CALL INTERRUPT calls.  If„'you see CALL INTERRUPTX or CALL INT86, I'm not sure how it will work„'with those, as they take slightly different parameters.„„'First off, the QB45 program will have a '$INCLUDE statemtent in it.„'You must delete that statement.  Next, put the TYPE REGS in AFTER the„'DECLARE SUB and DECLARE FUNCTION statements (if any). You'll want to„'more than likely change REGS to RegType, as that is what the qb.bi was„'using.  This will replace it.„„'Now, put the DIM SHARED Inregs as RegType, Outregs as RegType with the„'DIM statements, if there isn't one there already.  Most often than„'not, it may not need changing.  Also add in DIM SHARED dos%(45) and„'DEF SEG = VARSEG(dos%(0)).  It should look something like this:„„'DIM and CONST, etc. here„'DIM SHARED Inregs as RegType, Outregs as RegType„'DIM SHARED dos%(45)„'DEF SEG = VARSEG(dos%(0))„„'Once you have the variables all set up, next slip the DOS Call Code„'data statements and teh Load DOS/BIOS interface routine just before„'the main code of the program starts.  Most of the time, there's a CLS„'or SCREEN statement there.„„'Now just one more step.  Look through the code (may want to do a„'search for CALL INTERRUPT).  You will need to change each occurance of„'INTERRUPT to ABSOLUTE.  And, you will need to add to the end of each„'CALL ABSOLUTE (which was a CALL INTERRUPT) the VARPTR statement.  For„'example, suppose the QB45 code read:„„'  CALL INTERRUPT (intnum%, Inregs, Outregs)„„'You would change it to read:„„'  CALL ABSOLUTE (intnum%, Inregs, Outregs, VARPTR(dos%(0)))„„'Be sure to get all the parenthesis right!  There's _3_ of them at the„'end of the ABSOLUTE statement (I say this because I'm bad at it and„'forget alot! :)„„'Now you can save the new code to a new file name (for safe keeping)„'and run it.  It should work!„„'If you have any questions, let me know.  I can't promise I'll be able„'to have an answer every time but I'll try.  If you need to contact„'Richard, net mail me and I'll forward your question or whatever to„'him.  Just a short note that he does most of his programming in„'assembly. :)„