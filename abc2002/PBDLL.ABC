Walt Decker                    DOS Commands for LB and IBASIC lydia2hg@yahoo.com             06-16-02 (  :  )       pbdll                  640  14931    doscmd32.bas'DOSCMD32.DLL„'FUNCTION DosCmd ALIAS "Cmd"(lpCmd AS ASCIIZ) AS LONG„„'USAGE:„'DOSCMD.DLL provides directory and subdirectory listings along with redirection to a file,„'default drive changing, and default directory changeing.  It does not have to be in the„'windows directory, but a full path must be provided for loading. The first return value is„'the number of files found.  Each subsequent request decreases the return value by one„'„'SYNTAX:„'lpCmd is a null-terminated string.  If redirection is not in effect, the string must be„'long enough to accomodate complete path and file name, probably between 128 and 132 characters.„'lpCmd must have the following syntax:„'DIRECTORY LISTING:„'„' DIR [path]filespec [flag(s)][options][> redirction [path]filename]„' [path], [flag(s)], [options], and [> redirection] are optional„„' [path] can be a full or partial path, eg C:\MyDir, D:„' If [path] is partial the default path is used„'„'  Filespec can be any valid filename including wildcard characters (* and ?)„„' [flag(s)]:„'    /s        searches sub-directories„'    /o[d][f]  sort in ascending order on path„'    /od       sort in descending order on path„'    /of       sort in ascending order on file name„'    /odf      sort in descending order on file name„'    /a        show file attributes„„' [options] can be any one or a combination of +H, +S, -R, -A.„'  +H returns HIDDEN files„'  +S returns SYSTEM files„'  -R Do NOT return READ-ONLY files„'  -A Do NOT return ARCHIVE files„„'  Specifiying no options will return only files that are read-only, archive„'  or normal (not archive, not hidden, not system).„'„' [> redirection] must be preceeded by ">" followed by either an optional full or partial path„' and a valid file name„'„' EXAMPLE: DIR D:*.BAS /S > c:\M$List.T$X„'          DIR C:\*.hlp /s /od /a > a:\Mylist.txt„'„' If redirection is not in effect, multiple calls to "Cmd" will return the files via lpCmd.„' The return value of each call is the number of files left.„' With multiple calls, lpCmd must evaluate to a null string.  When there are no files left,„' lpCmd will contain "Total Files = " + then number of files found and the return value will be„' zero.„' If redirection is in effect, lpCmd will return "REDIRECTION COMPLETE : Total Files =" when the„'operation is finished.„„'DIRECTORY CHANGING:„'„' CD path„'„' EXAMPLE: CD D:\MyDir\MySubDir„'          CD ..\MyDir„'„'DRIVE CHANGING:„'„' drive„'„' EXAMPLE: A:„'          A„'------------------------------------------------------------------„'            IBASIC SAMPLE FOLLOWS„'------------------------------------------------------------------„'DECLARE "c:\pbdll61\61proj\doscmd32.dll",Cmd(sCmd:STRING), INT„„'OPENCONSOLE„'DEF sCmd:STRING„'DEF R:INT„„„'DEF M:INT„„'sCmd = "DIR c:\*.ini /s +s +h" + CHR$(0)„'LABEL Again„'R = Cmd(sCmd)„'sCmd = LTRIM$(RTRIM$(sCmd))„'PRINT sCmd„'sCmd = " "„'IF R = 0 THEN GOTO endit„'GOTO Again„„'LABEL endit„'INPUT M„'closeconsole„„'----------------------------------------------------------------------------------------------„'  FOR LibertyBASIC users, see the example code below„'----------------------------------------------------------------------------------------------„'sZero$ = CHR$(0)„'A$ = "DIR c:\pbdll60\*.inc /s/o" + sZero$„'A$ = A$ + SPACE$(128 - LEN(A$))„'OPEN "c:\liberty3\projects\doscmd32.dll" FOR DLL AS #Dos„„'[AGAIN]„'calldll #Dos, "Cmd", A$ AS PTR, R AS LONG„'J = INSTR(A$, sZero$)„'IF J THEN„'    A$ = LEFT$(A$, J - 1) + MID$(A$, J + 1)„'    A$ = TRIM$(A$)„'END IF„'PRINT A$„'IF R = 0 THEN GOTO [endit]„'A$ = SPACE$(127) + sZero$„'GOTO [AGAIN]„„'[endit]„„'A$ = "DIR c:\pbdll60\*.inc /s/o > Temp.txt" + sZero$„'A$ = A$ + SPACE$(128 - LEN(A$))„'Calldll #Dos, "Cmd", A$ AS PTR, r AS LONG„'PRINT A$„„'CLOSE #Dos„„'+++++++++++++++++++++++ END OF SAMPLE CODE +++++++++++++++++++++++++„„'======================= CREDITS ====================================„'FUNCTION LIBMAIN PROVIDED BY: POWERBASIC„'EQUATES PROVIDED BY: POWERBASIC in WIN32API.INC„'====================================================================„'                     PB/DLL CODE FOLLOWS„'====================================================================„„'„#COMPILE DLL "DosCmd32.DLL"„„%DLL_PROCESS_DETACH = 0„%DLL_PROCESS_ATTACH = 1„%DLL_THREAD_ATTACH  = 2„%DLL_THREAD_DETACH  = 3„„DECLARE SUB DosDir(lpPath AS STRING, lpCount AS LONG)„DECLARE SUB DosSort(bSort AS BYTE, lCount AS LONG, Dirs() AS STRING)„DECLARE SUB Gdirs(Count AS LONG, Path AS STRING, Dirs() AS STRING)„DECLARE SUB CngDrv(lpDrive AS STRING)„DECLARE SUB CngDir(lpDir AS STRING)„„DECLARE FUNCTION DosCmd ALIAS"Cmd"(lpCmd AS ASCIIZ) AS LONG„„GLOBAL sZero AS STRING * 2„„FUNCTION LIBMAIN (BYVAL hInstance   AS LONG, _„                  BYVAL fwdReason   AS LONG, _„                  BYVAL lpvReserved AS LONG) AS LONG„„„    SELECT CASE fwdReason„„    CASE %DLL_PROCESS_ATTACH„        'Indicates that the DLL is being loaded by another process (a DLL„        'or EXE is loading the DLL).  DLLs can use this opportunity to„        'initialize any instance or global data, such as arrays.„        ' MSGBOX ("process attach")„„         sZero = " " + CHR$(0)„„         FUNCTION = 1   'success!„„         'FUNCTION = 0   'failure!„„    CASE %DLL_PROCESS_DETACH„        'Indicates that the DLL is being unloaded or detached from the„        'calling application.  DLLs can take this opportunity to clean„        'up all resources for all threads attached and known to the DLL.„„         FUNCTION = 1   'success!„„         'FUNCTION = 0   'failure!„„    CASE %DLL_THREAD_ATTACH„        'Indicates that the DLL is being loaded by a new thread in the„        'calling application.  DLLs can use this opportunity to„        'initialize any thread local storage (TLS).„„         FUNCTION = 1   'success!„„         'FUNCTION = 0   'failure!„„    CASE %DLL_THREAD_DETACH„        'Indicates that the thread is exiting cleanly.  If the DLL has„        'allocated any thread local storage, it should be released.„„         FUNCTION = 1   'success!„„         'FUNCTION = 0   'failure!„„    END SELECT„„END FUNCTION„„FUNCTION DosCmd ALIAS "Cmd"(lpCmd AS ASCIIZ) EXPORT AS LONG„„LOCAL sTemp AS STRING„LOCAL sCmd  AS STRING„„LOCAL L AS LONG„„sTemp = TRIM$(lpCmd, ANY sZero)„„L = LEN(sTemp)„„IF L = 0 THEN„  CALL DosDir(sTemp, L)„  lpCmd = sTemp„  DosCmd = L„  EXIT FUNCTION„END IF„„IF (L = 1) OR (L = 2) THEN„  CALL CngDrv(sTemp)„  DosCmd = 1„END IF„„IF L > 2 THEN„  sCmd = UCASE$(LTRIM$(LEFT$(sTemp, 3)))„  SELECT CASE sCmd„    CASE "DIR"„      L = INSTR(sTemp, " ")„      sTemp = MID$(sTemp, L + 1)„      CALL DosDir(sTemp, L)„      lpCmd = sTemp„      DosCmd = L„    CASE "CD"„      L = INSTR(sTemp, " ")„      sTemp = MID$(sTemp, L + 1)„      CALL CngDir(sTemp)„      DosCmd = 1„    CASE ELSE„      DosCmd = -2„  END SELECT„END IF„END FUNCTION„„SUB DosDir(lpPath AS STRING, lpCount AS LONG)„„STATIC lFCount   AS LONG, lFcntr  AS LONG„„STATIC sFile() AS STRING„„LOCAL bRedirect AS BYTE, bAttr AS BYTE„LOCAL bSort AS BYTE, bSubDir AS BYTE„„LOCAL lAttr() AS LONG, lAtrCk() AS LONG„LOCAL DirCount AS LONG, DirCntr AS LONG„„LOCAL sAray() AS STRING, sDir() AS STRING„LOCAL sTemp   AS STRING, sPMask AS STRING„LOCAL sFMask  AS STRING, sBMask AS STRING„LOCAL sRedPath AS STRING, sAttrMask AS STRING„„LOCAL I AS LONG, J AS LONG, K AS LONG„LOCAL L AS LONG, M AS LONG, N AS LONG„„sTemp = lpPath„„sTemp = TRIM$(sTemp, ANY sZero)„„IF sTemp = "" THEN GOTO DosDir_End„„IF lFcount > 0 THEN„  lFcount = 0„  lFcntr = 0„  ERASE sFile()„END IF„I = 1„J = 6„„REDIM lAttr(I TO J), lAtrCk(I TO J)„„lAttr(1) = 1„lAttr(2) = 2„lAttr(3) = 4„lAttr(4) = 8„lAttr(5) = 16„lAttr(6) = 32„„lAtrCk(1) = 1„lAtrCk(5) = 5„lAtrCk(6) = 6„„'look for redirection tag. Must be last in string„„I = INSTR(sTemp, ">")„IF I THEN„  bReDirect = 1„  sRedPath = TRIM$(MID$(sTemp, I + 1))„  sTemp = LEFT$(sTemp, I - 1)„END IF„„'look for subdirectory search tag„„I = INSTR(UCASE$(sTemp), "/S")„IF I THEN„  bSubDir = 1„  sTemp = LEFT$(sTemp, I - 1) + MID$(sTemp, I + 2)„END IF„„'look for display file attributes tag„„I = INSTR(UCASE$(sTemp), "/A")„IF I THEN„  bAttr = 1„  sTemp = LEFT$(sTemp, I - 1) + MID$(sTemp, I + 2)„END IF„„'look for sort order tag„„I = INSTR(UCASE$(sTemp), "/O")„IF I THEN„  sBMask = "/"„  MID$(sTemp, I, 1) = " "„  J = I + 1„  DO„    sFMask = UCASE$(MID$(sTemp, J, 1))„    SELECT CASE sFMask„      CASE " ", "/", ">", "+", "-"„        EXIT DO„      CASE "O", "D", "F"„        sBMask = sBMask + sFMask„        MID$(sTemp, J, 1) = " "„      CASE ELSE„        EXIT DO„    END SELECT„    INCR J„  LOOP„  SELECT CASE sBMask„    CASE "/O"„      bSort = 1„    CASE "/OF"„      bSort = 2„    CASE "/OD"„      bSort = 3„    CASE "/ODF", "/OFD"„      bSort = 4„    CASE ELSE„      bSort = 1„  END SELECT„  sBMask = ""„  sFMask = ""„END IF„„J = 0„DO„  I = INSTR(-1, sTemp, "+")„  IF I = 0 THEN I = INSTR(-1, sTemp, "-")„  IF I = 0 THEN EXIT DO„  INCR J„  REDIM PRESERVE sAray(1 TO J)„  sAray(J) = MID$(sTemp, I , 2)„  sTemp = LEFT$(sTemp, I - 1) + MID$(sTemp, I + 2)„  sAray(J) = UCASE$(sAray(J))„LOOP„„FOR I = 1 TO J„  IF sAray(I) = "+R" THEN lAtrCk(1) = 1„  IF sAray(I) = "+H" THEN lAtrCk(2) = 2„  IF sAray(I) = "+S" THEN lAtrCk(3) = 3„  IF sAray(I) = "+A" THEN lAtrCk(6) = 6„  IF sAray(I) = "-R" THEN lAtrCk(1) = 0„  IF sAray(I) = "-H" THEN lAtrCk(2) = 0„  IF sAray(I) = "-S" THEN lAtrCk(3) = 0„  IF sAray(I) = "-A" THEN lAtrCk(6) = 0„NEXT I„„ERASE sAray„„sTemp = TRIM$(sTemp)„„I = INSTR(-1, sTemp, "\")„IF I THEN„  IF I = 3 THEN„    sPMask = LEFT$(sTemp, I)„    sFMask = MID$(sTemp, I + 1)„  ELSE„    sPMask = LEFT$(sTemp, I - 1)„    sFMask = MID$(sTemp, I + 1)„  END IF„ELSEIF I = 0 THEN„  I = INSTR(sTemp, ":")„  IF I THEN„    sPMask = LEFT$(sTemp, I)„    sFMask = MID$(sTemp, I + 1)„  ELSE„    sFMask = sTemp„    sPMask = CURDIR$„    IF RIGHT$(sPMask, 1) = "\" THEN„      sPMask = LEFT$(sPMask, LEN(sPMask) - 1)„    END IF„  END IF„END IF„„IF bSubDir THEN„  DirCntr = 1„  REDIM sDir(DirCntr TO DirCntr)„  DirCntr = 0„  CALL GDirs(DirCount, sPMask, sDir())„END IF„„sBMask = SPMask + "\" + sFMask„IF (LEN(sPMask) = 2) OR (LEN(sPMask) = 3) THEN„  sBMask = sPMask + sFMask„  IF LEN(sPMask) = 3 THEN sPMask = LEFT$(sPMask, 2)„END IF„„I = 0„First_File: '„„sTemp = DIR$(sBMask, 23)„„IF sTemp = "" THEN GOTO Check_SubDirs„„INCR I„REDIM PRESERVE sAray(1 TO I)„sAray(I) = sPMask + "\" + sTemp„„DO„  sTemp = DIR$„  IF sTemp = "" THEN EXIT DO„  INCR I„  REDIM PRESERVE sAray(1 TO I)„  sAray(I) = sPMask + "\" + sTemp„LOOP„„'Find_Next: '„„'sTemp = DIR$„'IF sTemp <> "" THEN GOTO File_Attr„„Check_SubDirs: '„„IF bSubDir THEN„  IF DirCount THEN„    INCR DirCntr„    IF DirCntr > DirCount THEN GOTO File_Attr: '„    sPMask = sDir(DirCntr)„    sBMask = sDir(DirCntr) + "\" + sFMask„    GOTO First_File„  END IF„END IF„„File_Attr: '„„DirCntr = 0„„IF bSort THEN„  CALL DosSort(bSort, I, sAray())„END IF„„FOR L = 1 TO I„  sAttrMask = ""„  J = GETATTR(sAray(L))„„  IF (J = 0) OR (J = 128) THEN„    sAttrMask = " Normal"„    GOTO File_Check„  END IF„„  IF (J AND lAttr(5)) = lAttr(5) THEN sAttrMask = " DIRECTORY "„„  FOR M = 1 TO 6„    IF M = 5 THEN GOTO Skip_Attrck„    K = lAtrCk(M)„    IF K THEN„      IF (J AND lAttr(K)) = lAttr(K) THEN„        IF K = 1 THEN sAttrMask = sAttrMask + " R "„        IF K = 2 THEN sAttrMask = sAttrMask + " H "„        IF K = 3 THEN sAttrMask = sAttrMask + " S "„        IF K = 4 THEN sAttrMask = sAttrMask + " V "„        IF K = 6 THEN sAttrMask = sAttrMask + " A "„      END IF„    END IF„Skip_Attrck: '„  NEXT M„„File_Check: '„„  IF sAttrMask <> "" THEN„    IF bAttr = 0 THEN„      IF INSTR(sAttrMask, "DIRECTORY") THEN„        sAttrMask = "DIRECTORY"„      ELSE„        sAttrMask = ""„      END IF„    END IF„    INCR lFcount„    REDIM PRESERVE sFile(1 TO lFcount)„    sFile(lFcount) = sAray(L) + sAttrMask„  END IF„„NEXT L„„DosDir_End: '„„IF bReDirect THEN„  OPEN sRedPath FOR OUTPUT AS #1„  FOR I = 1 TO lFcount„    PRINT #1, sFile(I)„  NEXT I„  PRINT #1, "Total Files = " + STR$(lFcount)„  CLOSE #1„  lpPath = "REDIRECTION COMPLETE : Total Files = " + STR$(lFcount)„  lpCount = 0„ELSE„  INCR lFcntr„  IF lFcntr > lFcount THEN„    lpPath = "Total files = " + STR$(lFcount)„    lpCount = 0„  ELSE„    lpPath = sFile(lFcntr)„    lpCount = lFcount - lFcntr + 1„    EXIT SUB„  END IF„END IF„„lFCount = 0„lFcntr = 0„„ERASE sFile()„„END SUB„„SUB Gdirs(Count AS LONG, Path AS STRING, Dirs() AS STRING)„„LOCAL sCurPath AS STRING„LOCAL sNewPath AS STRING„LOCAL sMask AS STRING„LOCAL sTemp AS STRING„„LOCAL I AS LONG„LOCAL J AS LONG„„sCurPath = CURDIR$„IF LEN(Path) = 2 THEN„  CHDIR Path„  sNewPath = CURDIR$„ELSE„  CHDIR Path„  sNewPath = CURDIR$„END IF„„I = INSTR(-1, sNewPath, "\")„IF I = LEN(sNewPath) THEN„  sNewPath = LEFT$(sNewPath, I - 1)„END IF„„sMask = sNewPath + "\*.*"„„First_Dir: '„„sTemp = DIR$(sMask, 23)„IF sTemp = "" THEN GOTO Next_Dir„„Dir_Attrib: '„„I = GETATTR(sNewPath + "\" + sTemp)„IF (I AND 16) = 16 THEN„  INCR Count„  REDIM PRESERVE Dirs(1 TO Count)„  Dirs(Count) = sNewPath + "\" + sTemp„END IF„„sTemp = DIR$„IF sTemp <> "" THEN GOTO Dir_Attrib„„Next_Dir: '„„IF Count THEN„  INCR J„  IF J > Count THEN GOTO Set_Path„  sNewPath = Dirs(J)„  sMask = Dirs(J) + "\*.*"„  GOTO First_Dir„END IF„„Set_Path: '„„CHDRIVE LEFT$(sCurPath, 2)„CHDIR sCurPath„END SUB„„SUB CngDrv(lpDrive AS STRING)„„  IF LEN(lpDrive) = 1 THEN lpDrive = lpDrive + ":"„  CHDRIVE lpDrive„„END SUB„„SUB CngDir(lpDir AS STRING)„„  CHDIR lpDir„END SUB„„SUB DosSort(bSort AS BYTE, lCount AS LONG, Dirs() AS STRING)„„LOCAL I AS LONG, J AS LONG„„LOCAL sTag() AS STRING„„DIM sTag(1 TO lCount)„„IF (bSort = 1) OR (bSort = 2) THEN„  IF bSort = 1 THEN„    FOR I = 1 TO lCount„      J = INSTR(-1, Dirs(I), "\")„      sTag(I) = UCASE$(LEFT$(Dirs(I), J - 1))„    NEXT J„    ARRAY SORT sTag(), TAGARRAY Dirs()„  ELSE„    DIM sTag(lCount)„    FOR I = 1 TO lCount„      J = INSTR(-1, Dirs(I), "\")„      sTag(I) = UCASE$(MID$(Dirs(I), J + 1))„    NEXT I„    ARRAY SORT sTag(), TAGARRAY Dirs()„  END IF„  EXIT SUB„END IF„„IF bSort = 3 THEN„  FOR I = 1 TO lCount„    J = INSTR(-1, Dirs(I), "\")„    sTag(I) = UCASE$(LEFT$(Dirs(I), J - 1))„  NEXT J„  ARRAY SORT sTag(), TAGARRAY Dirs(), DESCEND„ELSE„  DIM sTag(lCount)„  FOR I = 1 TO lCount„    J = INSTR(-1, Dirs(I), "\")„    sTag(I) = UCASE$(MID$(Dirs(I), J + 1))„  NEXT I„  ARRAY SORT sTag(), TAGARRAY Dirs(), DESCEND„END IF„END SUB„Patrice Terrier                MCI Encapsulation              pterrier@zapsolution.com       12-15-02 (  :  )       PBWIN/DLL              146  9616     MMENGINE.BAS'>>> Page 1 of MMENGINE.ZIP begins here. TYPE:BINAA TLEN:6438„'-------------------------------------------------------------„'                  INSTRUCTIONS FOR DECODING„'If there are multiple parts to this file, merge them into one„'file using  COPY PART1.EXT+PART2.EXT FILENAME.EXT  Remove all„'message header and footer information (everything outside the„'">>> Page x of..." lines),  load the result into your version„'of Basic (QBASIC, QuickBASIC, etc.) then RUN it. The original„'file will be decoded into the current directory on your disk.„'-------------------------------------------------------------„DEFINT A-Z:DIM SHARED K,S,B&:V1 'Created by PostIt! 7.4„SUB V1:OPEN "O",1,"MMENGINE.ZIP",4^6:?STRING$(50,177);„U"%up()%9%'%#-%mFn\RcB8fdY67%%1l%%%1%%%%rrLj=68D=4S1;0B^A;:>Tkck4„U"&x_VTSO[Hv9RZ2mSoJ=t$78j]6E0CsL]UeoBd]>0j+:I4>ftNuFe:Sf49dJpXJP„U"-h[op7f4,llSHeh[)JnZsRw-RBDNMXHHoF>KmTc%%,(?EUJ&LU[OHSWZ/^vWWO3„U"mIr+,bZI9*rY3^Tx7<+xB1=5N\#Ys5xrL%4vs,jiH2zTlz03-2WZ/LQBCMh?b)X„U"8q3a(qbbATp#D3Qt377_0tcC-R;H?tvpEY$g;-mkU[J2g_Zn,6QZ3?9i#jnikhX„U"r5((PK&ToP,p8g2n;^Zkbv(FSeG2gsfhncKd]+cwA-%oMYKl1K0L2fvPgInvZZr„U"/XuNTTlsDW.xDE%22Yf?$=013ynp=v$',lKOQ7dd&cMGCL=S&<MElHhMs0<4\8U„U"k^*F]8mnV;8_,[^m6D:$x84F7]3xrDlcIx:BvMJS/IWboo4(H^s.X[u8kIm'fIJ„U"VGLi7Oirmk/>.0p'-q5)D4Dvt$p?[F7:fIvc\x1+?-iKA?gRGyYfd?Hrna=709m„U"'Im]+/'coII*\Xl+-lI]q]^Fs?D5?VgTX&AssnD\KYVG>H_2$,434n;(qe,.p1w„U"avXyMg<A&w7'fo$?0_i7]BcL]gR]C'^Rrl=KA>['lLJGE;V/]9gkUrbA;Y[UCUG„U"s-enGsDHwahvIt;5_8szr]+=E;DC(&#g$#?CN8PYMC$F39J7EDsWJ,ks2Z:8'8<„U"wb5It6h7<RBT'V*Vx^?5a7F\1%R%J9n40\r)o$t)WTB]H-SIK8;gfIU1c#So?4M„U"&m[eS?XT\J3eYE$=..rzeQNBCAM<32e9J\3x6Kf'kd+NJ>B?seYl,j3MdZQ:O\h„U"s$V%P55/KSpWltu/,iMQJaUCI,u1E4=1qdJn3<S(3$O#'3$z(]ufo\q]iB86#)d„U"*G%epetrHXQfm$Fk5Ytnf?K9LqzXJbD4g&97B7IZdE8R&7hAhM?[$9HAmaT/&GC„U"D:Lu9<TfUXAAm^ysRIp>+nrSPxQ'Km7M\*Y*(.;s7)hJbI4f*^tdqRDXG<hKhNY„U"AJoLKUxo[,71y/JOvTA#fJI-Yia;GI;1\0%tMq[RGZnk\8<3\Ds;=n-&d4w\MIx„U"AF?%*iR7o_zK9f.e8_*nHTk='WC\6D:F#](Y3.Q(m8mp$[p)Rirg%mQ<Z9jA]]f„U"J*p(mePUVWFR;nkjK#nW7Xt=iXl*qRWWXAGS2jpIp8'LEks#bbQ4Wd(D+Tj4M-2„U"CCKJ;-An7L>rO5%doS8Sr\gmQs;nC9C=.Wgnd+rj.Lw(_ZW(bf&e#dy?AmC=X/'„U"OWm^L6Q;Jo*[7J-L7csAA;jF=-'R+##FH:R&o)naA19*fY#FQS5F=6l*FLU>97O„U"\]uj>zAOz#Ze1cL78(UInO0G=5==NIox_51,?Ww6+oKDEufhP[J.xhd)N9BVT%1„U"s>wgpEq/g))qRJCp^5Ou)o]<-kLp_z+u#YHrQEIPruGmB*s(?dAB0D.;O+caIgp„U"e(E^bnKSMAuOW'X'9'8K;vA&P,,0.'v'=4LrHUUTEcUedN('1#oFtibUk+E0=m4„U"nMkfAM#>9Wj\ou7-lY:3U+k-v_Wfxo[Kc$7s/fRI]PvSj)=9m<p-6_irsR_*d,(„U"Cj<;,,%&pnSa\N-;cpj5wIH^pc]=K6E3MQi55#5a9Gs;Tp7^u]]0S1FP)B]k'Y-„U"aFbuK>1=Z<<04f/;2]RSXgI0rZcZQo1cl?i;)qXD*J&3:/YT(:sOuQFm;wWB><-„U"gcMd7nIK0%iT=Wx8n[ScqWI_g'E'I&MU%.j0797$M/]P5hB'pDLKCga^QO%J43o„U"J3YA04\u;4Ma#VKi,CDv0T3Ue_4spg-jQKb:Kl;qT#6eD$KJ]jb5wV/Oh]M^5Y>„U"$\N::10K>rRLTc[SP2kyK;6R[lJl,)b9[Z#/%7l*VOON1h\n/(0KUugd358UltZ„U"lfYb4NKUs22WU*X)w%RlEoWEn:\uwulHKi1I6?J9.EmT/gdEn[.\+QI$>>-ptr6„U"KOm#'k]o]5<nw6%J1:&b=jMdISB/c^^DjXX^DF-SLTn]aNIhJ'WPs?&cGmvDv2j„U"LqP9Z\B2?,wV$o=/'>hy'-7/z7SX%$gIN7GPlX=b4/R)gbm2xT8]9eGJO-b^UVf„U"*a'0>&vG8'Rh%kD9<GU%oe<oiS7cP-mru400Q;&:UE]=DFT7AqV3yUwEgi5oGjW„U"*Xq]::-xL:nm([LfYc,e4.+wm\i7NEneOM0t[+pV?wi+3;OtBuEn<Tx(qPPDmC,„U"O:eAn2T0rIwk\he'3XoJ%Q/<qw(X_?\M&S'ce.Qw3%8iLOY\d*]61($P8(Sf%/P„U"f:+[^wrUj[=;4/N8Q\'^%0LB[/e3%TOfk.Ww.DM+1Ws]TJ0)f8&YG8EW8-hR(ah„U"48>EG0NPXCoE;H_79sfYQ2&)J5^MyLO1+U7lA%V37IZ,l.kynqN.%pk#_.XX,08„U"BoX=h3ME86SZy4B]-ffV_6/E/T+M^#7^6S;07EsDi4)ZX2>b^y;Uc.EK89%m*P+„U"C4wzGd=5cm9s>a+70?Ku8L&Y#T^3_zG+lsdV6hoMXsM:xPXmSY&vN]jC;epNE(#„U"YZGLLUa52.fZC[;lmKN\[#uv%&U1.;4eMTp]$]O[+Yi>)=&NCEIz<gs>MQfFoJI„U"0,$efv=g93ES()T5$:oq1z4WdsZ=0kZa[]V,5G-9fPl-_vMXG5;<>iSIgJpof#g„U"ZEU>kjt>r&ED-tD(]OHADK$clv*KzasB<mcKuwa2bhqizhT\:>I*>McL3B1X#N,„U"6[98Xm/m%'nB0XcuI0Tnp7GDd3<GdvA1K0cg769?S4S*H>KZjh/1jhQO:$IN1vx„U"A$bWq7?QxnKK=-B33?Sb4p+MD%8\-Db7vEp961,ysF4)>a#Q\EVf6JeneJ]R**C„U"I>B0p^8OvsXTY-2Vf%-c#xi/TL;RDz7Xqxg.,sUhYqL]2xW:7dUo1^pTu)w[1pp„U"khDIht*1E.Wlo;sDsqXU<K/ACD-6ehrqsh\Yis9CzWg^T/-Fk*4:2P^*xpI[Ji$„U"PhW1$+gmZJ.?rf+0clVgehA8[<B(<Ik:-xfQ7.:[aOcS5A]0J32Fm,xE7e[k,1L„U"\2?O$9\>9[G4Z\[]EtkmkS'9nZReLS%LA4c'43L??[VuNnTQHBQz&G67IvI5u$N„U"G8i?JIlw7wg$a$[cl2R/Al;QEi/^9*T8Ova5OG$24_Tcy&uaPNbjB=%5pjUXWqt„U"U:f$j)Jonb&=AKD%=N*JV>E8b'4C;F=I;)Z0P:J+FS;,A7CUQT;QX[Wf9t*/8F7„U"c9]v_&/Xb'-4WA\l=YW<QbL5;ft53,pS2y8#b-X%xN9Q63lq9A4-R;B%rxcGifQ„U"w'D<=ckS$-7*cq(AWAl(=(pCXGur'GsL.'xBMhvSgj\xG7D0+o4T)4p_-fj]3sB„U"6k:mD+B6uug2?.(Cfa:E?Pqe52lXl\QJ9S=6BAb-#l0FsgCZ$.:RX9FIBN(7HS0„U"r.3'XIIoA.t-)OY10y?EAu=v*uLGMeX;CRo=FBcS^3&No/oJ:Ts*:k\P7ld',5#„U"=.8rzY#sMIa[sgFO,:BY0D,[8K8R$E?m?cE^7d;SQ/%\n<%t^L1'.mhm%'nAVKC„U"nO^buwZr7j'2xEP95&fIAD<3Q^TY0[#JfGCmtyr[C\-8HFk(F)ntyJ0.e**:LhR„U"XO,]Zwq'f-QAwjTm%:KbTnu3)xi*-)co;:%aACsKOQ$YTgTO>Wa9g:]2Hf_46g2„U"EZm-(]Vn?b+^*V-t1h1u;_3g+1(54Zai5b/Nz7.Yn4=d+Qk_Ih=;4+]j6v,dTqy„U"3+/)q<Tx^tBAL$wk=uoF;Kpo<>dbxOT;+=St'0OMX=-EpiB=)npi&RahFeYUWc2„U"epj]oeCKjvLb[<w5TL3QP<^(/-d_(f;?Z#tbMf_0;Oog(a2'58?FA1?4w[;o09O„U"b/noVR>/t;Q*IAY-6VDTBkLPL2K[>RgD(PPS6.IDn81E>DrRf89+_T*?s$?IsLr„U"Mb=cDQ,accCk%Wp)NA*kB*7me55b?pTdoVbE-:?U4UA;+Af)b97'kzx%bG2j=u)„U"6CeG*rIOr84GeMI7hfshEwq/CsLCU-h<9D,[VB-U9u-lEFFh*W4p5nT;aSaWH4R„U"Y_4gA8Qqe^/SFDiYh$UPCa&sY:cOD5SV#S[4CL_IAn'IX+#e?;'&U_&e>I9KnH-„U"<048E%0EOZJ4l0gf%beFEMMz&N<+\N2y[AG$#SPTcVEGv_RYrZS,]QfeR.a68%R„U"MEvUEZ?SSk,F_hSU6hN1%z1hSAPgJ</2G3a('?IgJg^%\Twl+GXT98KZ#Qq>>g9„U"fT#3+S8xaE7]+75dfcv?JD+kUL;i(?y3PxZ>3YB<YYC<#'&E6xogYmPLl_4m9X6„U"5.[*B3[AE:NVuBW7iZOcH,#0m.ZT]ps0:*'?B<%I<4dVNC)8(bOE4I$X/Cc,lgt„U"p8ZKQ+<lpqOmg:EBR1$Tf<:t%TS<WP(Y'v4Y#TT3i-CjZr$gmFnpF)*B-NijeaD„U"E8Zm9s\BubCB&TzUrM6,uXuQuBAs%wp:<.i:ajQdwiC'-$5-51(\=qisSLPHA'O„U"c35M+0H=H[0k*6,%/wZ$S&9s$KgG>Q_i1CaV<;i-JI=sPv02rN%5EA,0t.b(qhv„U"%3^+C?fsIFFc)^+M;f^>ngg>$L,h7:[[8X7&9IMi%E>Sziirdcg_2-J5H>Y.r)Y„U"_09Xk/U-gZzRUUi?D)'gKya,ZcIn.Svx5K.JUk(JeyM)Lan7R_Cdz25$l2q9V&,„U"4qB)7nxr&CbEMYDoRy&e<5,EeT.cU92yDO?j:F15*C*%zNHa(I3b++mcl*/<ppU„U"AM[zqz)I*DRk6G%oK0-RQzM>ZmAj%th$:RpR[qziTMN\r<%?nw2HN*,#'d2HN7G„U"j/(.gCMap+C3D7RYcZ8$AXYLl36in?%bE?1#lN=18:.Uj'rhq23?=klvdPj.Y)M„U"GuR0K1uGFXg.8Bek[xpZQRQ+&<P4p\gRvqD#Uu23jEG3alUMBC+#lnmS=Oacl_K„U"F]-P#8l0fx+Rcc0h?[PatXj#Nan./EyzfkrR[%&lpaKH5tD;.f)M9DCmdQ:x4H=„U"5(UCLuq[qATn7t](Z_HmrJEeu-3ki\bg)Ke:G%1+h#1IWr6fSw>:j\(Hoj_K5o*„U">d1[(x=+\Zc_r:%ri+c9GW*d;dc77MhQrGDfA67lKT_4lTQ+(H.aN%mr%6$);/[„U"/pP3JdzzyYkb1pt/QSoZKCLl.Itfyon'[OB1;73eC,_._,^vegk>edZ#W0iuP:L„U"S5bHa?%)t&xhWvCZ'qm)/ooa>-L*0I8&MZQ9PZVGu:#isdo'hP:V+9Jn:xL)Wp4„U"k'Dh=aR3UmsX4;4*Ojc[+ED#J0+U*nbI*ZXDgLdeh+_VP&:uj4W%k3vWtN_3E7'„U"51$_WiweI(mE#6F8Jn3wg#&hX&d2TMctuG([v'2d?;\G)eDn(O%I:']98z;PP4H„U"l:NwI7T02TYa6n%Tm7Y4f9umjJ'huG(1WDtFIGJmso_6eYX]\>IFBQE)\Q%Y.n8„U"(&+r>ECkyGd8e4r$Q,?hNv]jcdhPwWTlevsNtv9jgcaw0DDpv#oF2kL6Z-'E^a^„U"]%(?h)j]7VMGp5ipk9Jm84rBMt%H$dod9JjLlwC.'QMMe*4$;[S\:Y<8DDarO)L„U"t^un82%_XCgjy%yMJBW40]4&<65#522'm^j\/r7T8)'&geAE1%XnQE$<7qqPv/(„U"^Vw.'I(b'Q:,)i(Ea/t&Y(&*eEvn]sMH2='BhSy*=0lh%\Z\>k1\&g;oMybMPYG„U",?FCn-QaBUE\(cKzUR5p0J?ug7bSGZq&WMT\r'x%up%()9%%'%-%14F\Rj()0k&„U"7+%%%>#%%%1%%%Irr4=M68=4LS8=23N'<t]Tm5wRCNx0az..-R*'aC:R9C>i#OD„U"/b2R+CDLXAJOho3J5LdDmUuNu\]X7LQmnmJnD9_EjhLmlVhhH5O]f4,(3oK7[ZS„U"XJzsbF?pNFSyY\R,7Y[h7](4gq9;Yy*#X2Y,1H(zc63IA$[16H_S+Bx40Z9$;,M„U"sVcq)HLrn6HqdkpF5lV4+m0^HI3ke3j=+35b[i8c4vXUM%kSk+>D?ohCeRhCHsb„U"8GRiATM%-H)X&SS2fC8t<'Wq4EHhGECmlqqGq[)6m6:]X9hPVs.F6S.C%2uI6M$„U"]gV)Eb^:%lm^7_:DXM4;8SHRlS&jQZ38hMuw&lt(nZW<-,'pD)R%i>ch3[#LROF„U"^/*8QDN4E:[b<0$uusL,?PpZ[$AVVlJ]Gc_bqOJ/j0uTjZL_rN2hVrWTD[2<Pgo„U"kpGi$Rb\;RCl$25\1l%AVaFL6?mpH\Gf6jP;&WOUuyyVs,BiJCM:14_Kbi#jUIC„U"MHrXelUPo;'mhAEFj7e>Q_,JYTk+f,-UX//F?X*=9dH3Iqm5tq'fc7qjU0FPL\I„U"dCr36HO$I,WcM.2UP.W#7[LQ9\bV$c3mKq/BZYAT43\/ly2jiCom<.z.)s;jj>I„U"qZFom5bAsqI+6j:KvZSO]V]F>*I9vlehSM)2Ml'D_zZ-ekOG=IpSk(LYkNkKW6f„U"^f$D6P1]$crTgzbsuSUf<H<][^)F[1VA51,+Sv$[DoEA9h++Gg?mMqeI69VPiq/„U"'YK257y[s*W52#mg8BtwkM9=F/r?/nLb=U3*tDZ4aZ$12,04YSH::)Wi2c(0#[R„U"9L8LWW]IdEf[RqH_4bJuZTvC4r]OMq<'A0>>fUTJ]8S>?dt$4_Fr)$%)1[WZqIG„U"4_m%2EHlHH:vM:aitT$.8c6cdYitae;StkB8TaGd:c530]oiLApCU*yRw</Df'e„U"h?-TbPdzhIdR$4_mEzb])hC,PDj*c<QT%sMdTY)CJLR8ZdK3D.$upFc:e;3NLia„U"?=V4.b=YoB9l,mguVxbiy9k\B5iti4mDd\Oe$jZYY;[Id_bY>WRhObCLU&GTQru„U"lhF?ZED,h-;\2NFm&\hx't)q4aK-(oZ[#KhyDo+P;bMj<cqL8Ke1VJtCQPqb;9-„U"-s33HM,CkO;i\pd]mY#[3.o,n6A3eqa.B?3chX=a+sOstp),Gs05D,GZr*gD%N$„U"/*8]QLq267A;4h8+iNUqP<^lX]I'J''r&DW<gRc(4^.bA#7t323=WIM;[hqpl-3„U"D=870]Bm;V7b?o#-zpf'Iv[N(*qbW9C,o0I7*=p,oS:IS#ewXOVka::O#J-OS68„U"3eOfXMJ6)r[&p'4,+%F,c[G&Ev3EKJm)2mW;-DXieA'&k<Df$.K:<TQF4H[o7[t„U"&;DJ(w58-Hl,J7*UT(Bm6&+S<G=8Tga17*<_<b^\oB=0w5%,Tp^>secIY<:5=%v„U"N:_#QCrzI45UKsbH1^k3Ba:3?VA#Q/[hV.S%6cKv0b-rL&B1+J(Whu-SuMDNYpp„U"a,^?E(l33>'(.rut&2sX0;>o3rnFO(s>hJp4,C,kkHZwXlv2,+[0-h%_*e<(i01„U"6:OPAol:qCXhT:_eCzpCO5:sC(785R:Ybt:V(5c/zV#*79bbfbIQvrN)T>IPACY„U"s#b(n)d4J),o%^2u2=clg/GmOS)5KFeFpqID3KWy_oaGjlqozHvI^pdv-T^z,6r„U"X3$5RbC_3P]qY,%At:EwA&EZKP&phV4]vG6BleYF69z^\YJd^/7V_Ex,',0I]?x„U"jH<0onN['[?=$r<3rV;&[tJ&jb28M(+#[8:9LL/<W\Q;mE7WGn2-q/=i]HQVZ6\„U"GMObFQqPg8wCBIiip8,DOnP,El2S=6TDQJvk5Cr4p8>Y+/\P1M._7A;1qGnT)qh„U"z-ZS0^iQAP(CWdLIx58m<l0;EM;y?'&N;M)zIVy<5A6-MpRRu16Tc)c^C\Ec#0a„U"\=&MKfhT]So;QvuR-K&iwZTb+o1?kq6J06.me3X5HJe(rK.*:8]Fx*t(?wketcB„U"II^KmI:%.*jUj9X=Up8=sRa;706UrbxYqtaMMg#dGT+9-nbe]Wo4Lo0P>w?:Tx'„U"%up&'%;09%%'%-%1mF\R6cBfd'Y6%%'1l%%%1%%%%%%%%%&%E%)OP%%%%%rrLj=„U"68D=4S1)0Bup%&';0%9%'%#-%4F\\R()50k7+%%%>#%%%1%%%%%%%%%&%IE%OP%„U"/7%%Irr4=M68=4LS8=2%up*+%%%%%%'%'%&C%%%&k=%%%%%„END SUB„CLOSE:IF S=204AND B&=6438THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\6438,219);:END SUB„'>>> Page 1 of MMENGINE.ZIP ends here. Last page. TCHK:204„Stuart McLachlan               Reflex Test                    stuart@lexacorp.com.pg         12-22-02 (  :  )       PBDLL                  117  4059     pbreflex.bas'Test Reflexes - StuartMcl„'PB code„„#COMPILE EXE „#DIM ALL „#INCLUDE "WIN32API.INC" „ „GLOBAL hdlg AS LONG „GLOBAL accum AS DOUBLE „GLOBAL mintime AS DOUBLE „GLOBAL maxtime AS DOUBLE „GLOBAL tries AS LONG „GLOBAL runningstate AS LONG „ „STATIC FUNCTION ElapsedMicroSeconds() AS LONG „    DIM freq AS QUAD, overhead AS QUAD „    DIM count AS QUAD, prevCount AS QUAD „    DIM microseconds AS QUAD „    DIM fStarted AS LONG „ „    IF fStarted THEN „   QueryPerformanceCounter count „   microseconds = (count - prevCount - overhead) / freq * 1000000 „   IF microseconds > 2147483647 THEN EXIT FUNCTION „   ElapsedMicroSeconds = microseconds „    ELSE „   IF QueryPerformanceFrequency(freq) = 0 OR freq < 100 THEN „  ElapsedMicroSeconds = -1 „  EXIT FUNCTION „   END IF „   QueryPerformanceCounter prevCount „   QueryPerformanceCounter count „   overhead = count - prevCount „   fStarted = %True „    END IF „    prevCount = count „END FUNCTION „ „FUNCTION DelayTimer(BYVAL hWnd AS DWORD, BYVAL uiMsg AS DWORD, _ „   BYVAL idEvent AS DWORD, BYVAL dwTime AS DWORD) AS LONG „    DIM temptick AS LONG „    IF runningstate = 1 THEN „   runningstate = 2 „   CONTROL SET COLOR HDLG,1,%BLACK,%GREEN „   CONTROL SET TEXT HDLG,1,"GO" „   temptick = elapsedmicroseconds „   END IF „   FUNCTION = 0 „END FUNCTION „ „CALLBACK FUNCTION Getclick() „    DIM temptick AS LONG „    DIM delay AS LONG „    DIM TimerProcPtr  AS DWORD „ „    IF CBMSG =  %WM_LBUTTONDOWN THEN „     temptick = elapsedmicroseconds „     SELECT CASE runningstate „    CASE 2  'Go „    CONTROL SET COLOR HDLG,1,%BLACK,%RED „    CONTROL SET TEXT HDLG,1,FORMAT$((temptick/1000000),"0.000")  & " - Click here again to retry" „    INCR tries „    IF mintime = 0 OR (temptick) < mintime THEN mintime = temptick „    IF  (temptick) > maxtime THEN maxtime = temptick „    accum = accum + temptick „    runningstate = 0 „  CASE 1 'Standby „    CONTROL SET COLOR HDLG,1,%BLACK,%RED „    CONTROL SET TEXT HDLG,1,"WAIT FOR IT! - Click here again to retry" „    runningstate = 0 „      CASE 0  'Waiting for Start click „   CONTROL SET TEXT HDLG,1,"STANDBY" „   Delay = 3000 + RND(0,2000) „   TimerProcPtr = CODEPTR(DelayTimer) „   SetTimer hdlg, 1, Delay, TimerProcPtr „   runningstate = 1 „     END SELECT „   END IF „END FUNCTION „ „CALLBACK FUNCTION showresults() „    LOCAL strResults AS STRING „    strresults = STR$(tries) & " attempts:" & CHR$(13,10) „    strresults =  strresults & "Min: " & FORMAT$(mintime/1000000,"0.000") & CHR$(13,10) „    strresults =  strresults & "Max: " & FORMAT$(maxtime/1000000,"0.000") & CHR$(13,10) „    strresults =  strresults & "Avg: " & FORMAT$(accum/tries/1000000,"0.000") & CHR$(13,10) „    MSGBOX strResults,, "[b]reflex[/b] Tester Results" „END FUNCTION „ „CALLBACK FUNCTION resetresults() „    tries = 0 „    accum = 0 „    mintime = 0 „    maxtime = 0 „END FUNCTION „ „FUNCTION PBMAIN() AS LONG „    LOCAL lRslt AS LONG „    RANDOMIZE TIMER „    DIALOG NEW 0, "Response Timer", 195, 88, 258, 140, %WS_POPUP OR _ „   %WS_BORDER OR %WS_CAPTION OR %WS_SYSMENU OR %WS_CLIPSIBLINGS OR _ „   %WS_VISIBLE OR %DS_MODALFRAME OR %DS_3DLOOK OR %DS_NOFAILCREATE OR _ „   %DS_SETFONT, %WS_EX_WINDOWEDGE OR %WS_EX_CONTROLPARENT OR %WS_EX_LEFT _ „   OR %WS_EX_LTRREADING OR %WS_EX_RIGHTSCROLLBAR, TO hDlg „    CONTROL ADD LABEL, hDlg, 1, "CLICK MOUSE TO START", 25, 30, _ „   215, 50, %WS_CHILD OR %WS_VISIBLE OR %SS_CENTER OR %SS_CENTERIMAGE, _ „   %WS_EX_LEFT OR %WS_EX_LTRREADING „    CONTROL SET COLOR hDlg, 1, -1, %RED „    CONTROL ADD LABEL, hDlg,2, "Click the mouse button in the box when it " + _ „   "turns green.", 45, 0, 200, 10 „    CONTROL ADD LABEL, hDlg,3, "Your response time in milliseconds " + _ „   "will displayed", 55, 10, 155, 15 „    CONTROL ADD BUTTON, hdlg,5,"Results",100,90,60,14 CALL showresults „    CONTROL ADD BUTTON, hdlg,6,"Reset",100,110,60,14 CALL resetresults „ „     DIALOG SHOW MODAL hDlg, CALL Getclick TO lRslt „END FUNCTION  „Edwin Knoppert                 Byte to hex conversion         ebknoppert@hotmail.com         12-22-02 (  :  )       PBWIN,PBDLL            48   1084     byte2hex.bas'Byte to Hex Function„'Edwin Knoppert„'pbwin„„'// Simplistic but very fast converter. „'// Converts ascii values to 2byte hex strings „'// Used:   PB/WIN „'// By:     ebknoppert @ hotmail.com „  „#Compile Exe „  „Option Explicit „  „Function ByteToHex( ByVal sByteBuffer As String ) As String „  „    Dim a  As Long „    Dim sOut    As String „    Dim pByt    As Byte Ptr „    Dim pStr    As String Ptr * 2 „  „    If sByteBuffer = "" Then Exit Function „  „    '// Output buffer, twice as large as the byte buffer. „    sOut = String$( Len( sByteBuffer ) * 2, 0 ) „    pByt = StrPtr( sByteBuffer ) „    pStr = StrPtr( sOut ) „  „    For a = 1 To Len( sByteBuffer ) „   @pStr[a-1] = Hex$( @pByt[a-1], 2 ) „    Next a „  „    Function = sOut „  „End Function „  „Function WinMain( ByVal hCurInstance  As Long, _ „   ByVal hPrevInstance As Long, _ „   lpszCmdLine    As Asciiz Ptr, _ „   ByVal nCmdShow As Long ) As Long „  „    Dim T As String „  „    T = Chr$( 0 To 255 ) „    MsgBox ByteToHex( T ) „  „    Function = 1 „  „End Function „Edwin Knoppert                 Get ICON from  Name            ebknoppert@hotmail.com         12-22-02 (  :  )       PBWIN,PBDLL            94   2522     IconName.bas'Icon from Name„'Edwin Knoppert Email:  ebknoppert@hotmail.com „„#Compile Exe „  „Option Explicit „  „#Include "win32api.inc" „#Include "IcoByNam.inc" „  „CallBack Function DlgProc() As Long „  „    Static hIcon As Long „  „    Select Case CbMsg „    Case %WM_INITDIALOG „  „   hIcon = IcoByName( "*.doc", 1, 0 ) „'   hIcon = IcoByName( "c:\windows\calc.exe", 1, 0 ) „'   hIcon = IcoByName( curdir$, 1, 1 ) „   If hIcon Then „  SendMessage CbHndl, %WM_SETICON, %ICON_BIG, hIcon „  SendMessage CbHndl, %WM_SETICON, %ICON_SMALL, hIcon „   End If „  „    Case %WM_DESTROY „  „   If hIcon Then DestroyIcon hIcon „  „    End Select „  „End Function „  „Function WinMain ( ByVal hCurInstance  As Long, _ „    ByVal hPrevInstance As Long, _ „    lpszCmdLine    As Asciiz Ptr, _ „    ByVal nCmdShow As Long ) As Long „  „    Dim a  As Long „    Dim hDlg    As Long „    Dim Result  As Long „  „    Dialog New 0, "Icon by name",,, 240, 180 _ „   ,  %WS_OVERLAPPED _ „   Or %WS_SYSMENU _ „   Or %WS_MINIMIZEBOX _ „   Or %WS_MAXIMIZEBOX _ „   Or %WS_THICKFRAME _ „   Or %WS_CLIPSIBLINGS _ „   Or %WS_CLIPCHILDREN _ „   To hDlg „  „    If hDlg = 0 Then Exit Function „  „    Dialog Show Modal hDlg Call DlgProc To Result „  „    Function = 1 „  „End Function „'-----------------------------------------------------------------„'// Retrieve a system icon from a file or extension. „'// Examples: „  „'hIcon = IcoByName( "*.doc", 1, 1 ) „'Or „'hIcon = IcoByName( "c:\windows\calc.exe", 1, 0 ) „'Or „'hIcon = IcoByName( CurDir$, 1, 1 ) „  „'// Set to dialog (Use both) „'SendMessage CbHndl, %WM_SETICON, %ICON_BIG, hIcon „'SendMessage CbHndl, %WM_SETICON, %ICON_SMALL, hIcon „  „'// You must destroy the icon yourself by using: „'If hIcon Then DestroyIcon hIcon „  „Function IcoByName( ByVal sExtension As String, ByVal bSmall As Long, ByVal bOpen As Long ) As Long „  „    Dim dwFlags     As Dword „    Dim sfi    As SHFILEINFO „  „    sExtension = Trim$( Trim$( Trim$( sExtension ), Chr$( 34 ) ) ) „    If sExtension = "" Then Exit Function „  „    dwFlags = %SHGFI_ICON „    If Left$( sExtension, 1 ) = "*" Then dwFlags = dwFlags Or %SHGFI_USEFILEATTRIBUTES „    If bSmall Then dwFlags = dwFlags Or %SHGFI_SMALLICON „    If bOpen  Then dwFlags = dwFlags Or %SHGFI_OPENICON „  „    sfi.dwAttributes = %FILE_ATTRIBUTE_NORMAL „    SHGetFileInfo ByVal StrPtr( sExtension ), 0, sfi, Len( sfi ), dwFlags „    Function = sfi.hIcon „  „End Function „Fred Buffington                No Frills Calculator           oasys@sbcglobal.net            12-22-02 (  :  )       PBWIN,PBDLL            269  10940    NFCalc.bas  'Fred Buffington„'oasys@sbcglobal.net„'„'No Frills Calculator„'PBWIN„'----------------------------------------------------------- „'Name: calcsm.bas no frills calculator (calculator small). * „'Section:PBdll.abc                                         * „'Author:Fred Buffington 9/2002.                            * „'                                                          * „'can be compiled as an exe or as a dll (or in another dll) * „'see notes about remming certain statements                * „'exit by using exit button or Esc key.                     * „'                                                          * „'Pressing Enter assume ADD (+). use number plus function   * „'i.e. 123+ adds 123 to total 123- subtracts 123 from total * „'+ - * /. Check for divide by 0.                           * „'Returns the total to calling program. (when comp as dll)  * „'See items to be remmed/changed for dll/exe use.           * „'Author: <c> Fred Buffington 2002. all rights reserved     * „'designed to be used with keypad entry of values for quick * „'calculations where a total is needed.                     * „'Pbdll 6.x, pbwin 7, probably works with pbdll 5 also      * „'although some dialog statements may need to be changed for* „'pbdll 5.0                                                 * „'hInstance& is designed to be the handle of the calling    * „'program in order to more easily display this on top       * „'----------------------------------------------------------- „'For dll use unrem below and rem $compile exe „'#COMPILE DLL „$COMPILE EXE „'#DIM ALL „#INCLUDE  "Win32Api.Inc" „GLOBAL hDlg AS LONG „GLOBAL total AS CUX „GLOBAL amount AS CUX „GLOBAL UserName AS STRING „GLOBAL Test$ „GLOBAL hFont& „'_______________________________________________________________________ ________________________ „ „CALLBACK FUNCTION CalcDlgProc „ LOCAL cid& „ LOCAL test1$ „ LOCAL x$ „ LOCAL denom@@ „ SELECT CASE CBMSG „    CASE %WM_COMMAND „      SELECT CASE LOWRD(CBWPARAM) „ „        'Process Enter key „ „        CASE %IDOK „          IF CBCTLMSG = %BN_CLICKED THEN „             x$=LEFT$(test$,1) „             SELECT CASE x$ „               CASE "+","-" „                 total=total+VAL(test$) „               CASE "*","x","X" „                 total=total*VAL(MID$(test$,2)) „               CASE "/" „                 denom@@=VAL(MID$(test$+SPACE$(2),2)) „                 IF denom@@<>0 THEN „                   total=total/denom@@ 'VAL(MID$(test$,2)) „                 END IF „               CASE ELSE „                 x$=RIGHT$(test$,1) „                 SELECT CASE x$ „                   CASE "+","-" „                     total=total+VAL(test$) „                   CASE "*" „                     total=total*VAL(MID$(test$,2)) „                   CASE "/" „                     denom@@=VAL(MID$(test$+SPACE$(2),2)) „                     IF denom@@<>0 THEN „                       total=total/denom@@ 'VAL(MID$(test$,2)) „                     END IF „                   CASE "x","X" „                     total=total*VAL(MID$(test$,2)) „ „                   CASE ELSE „                     IF INSTR(test$,"^")>0 AND INSTR(test$,"^")<LEN(test$) THEN „                        L%=INSTR(test$,"^") „                        total=total+VAL(MID$(test$,1,L%-1))^VAL(MID$(test$,L%+1)) „                     ELSE „                        total=total+VAL(test$) „                     END IF „                 END SELECT „             END SELECT „             CONTROL SET TEXT hDlg,102,FORMAT$(total,"###,###,###.##") „             Test$="" „             CONTROL SET TEXT hDlg,101,test$ „             EXIT FUNCTION „          END IF „ „        'Process Escape key „        CASE %IDCANCEL „          IF CBCTLMSG = %BN_CLICKED THEN „            'MSGBOX "Escape pressed." „            DIALOG END CBHNDL, 0 „          END IF „      END SELECT „'Process number entry, or exit button „      CID&=CBCTL „      SELECT CASE CID& „          CASE 101 'testbox „             CONTROL GET TEXT CBHNDL, 101 TO UserName „             test$=UserName „             IF LEN(test$)>1 THEN „               IF RIGHT$(test$,1)="+" OR RIGHT$(test$,1)="-" OR RIGHT$(test$,1)="*" OR RIGHT$(test$,1)="/" OR RIGHT$(UCASE$(test$),1)="X" THEN „                 test1$=RIGHT$(test$,1) „                 IF test1$="+" THEN „                   Total=Total+VAL(MID$(test$,1,LEN(test$)-1)) „                   CONTROL SET TEXT hDlg,102,FORMAT$(total,"###,###,###.##") „                   Test$="" „                   CONTROL SET TEXT hDlg,101,test$ „                   CONTROL SET FOCUS hdlg, 101 „                 ELSEIF test1$="-" THEN „                   Total=Total-VAL(MID$(test$,1,LEN(test$)-1)) „                   CONTROL SET TEXT hDlg,102,FORMAT$(total,"###,###,###.##") „                   Test$="" „                   CONTROL SET TEXT hDlg,101,test$ „                   CONTROL SET FOCUS hdlg, 101 „ „                 ELSEIF test1$="*" THEN „                   Total=Total*VAL(MID$(test$,1,LEN(test$)-1)) „                   CONTROL SET TEXT hDlg,102,FORMAT$(total,"###,###,###.##") „                   Test$="" „                   CONTROL SET TEXT hDlg,101,test$ „                   CONTROL SET FOCUS hdlg, 101 „                 ELSEIF UCASE$(test1$)="X" THEN „                   Total=Total*VAL(MID$(test$,1,LEN(test$)-1)) „                   CONTROL SET TEXT hDlg,102,FORMAT$(total,"###,###,###.##") „                   Test$="" „                   CONTROL SET TEXT hDlg,101,test$ „                   CONTROL SET FOCUS hdlg, 101 „ „                 ELSEIF test1$="/" OR test1$="\" THEN „                   IF VAL(MID$(test$,1,LEN(test$)-1))<>0 THEN „                      Total=Total/VAL(MID$(test$,1,LEN(test$)-1)) „                   END IF „                   CONTROL SET TEXT hDlg,102,FORMAT$(total,"###,###,###.##") „                   Test$="" „                   CONTROL SET TEXT hDlg,101,test$ „                   CONTROL SET FOCUS hdlg, 101 „                 END IF „               END IF „             END IF „'           CASE 201 'exit button pressed no longer used „'             DIALOG END CBHNDL, 0 „           CASE 201 'Decimal „               test$=test$+"." „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „ „           CASE 202 'C button i.e. Clear „               Total=0 „               Test$="" „               CONTROL SET TEXT hDlg,102,FORMAT$(total,"###,###,###.##") „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg,101 „           CASE 301 „               test$=test$+"7" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 302 „               test$=test$+"8" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 303 „               test$=test$+"9" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 304 „               test$=test$+"4" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 305 „               test$=test$+"5" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 306 „               test$=test$+"6" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 307 „               test$=test$+"1" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 308 „               test$=test$+"2" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 309 „               test$=test$+"3" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 310 „               test$=test$+"0" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 311 „               test$=test$+"+" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 312 „               test$=test$+"-" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 313 „               test$=test$+"*" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „           CASE 314 „               test$=test$+"/" „               CONTROL SET TEXT hDlg,101,test$ „               CONTROL SET FOCUS hdlg, 101 „      END SELECT „ END SELECT „ „END FUNCTION „'_______________________________________________________________________ __________________________ „ „'for dll use unrem below and rem pbmain „'FUNCTION calcit(hInstance&) EXPORT AS STRING „'rem above and use PBMAIN for exe use or for testing. „FUNCTION PBMAIN AS LONG „'unrem below when using pbmain rem if using as dll „  DIM hInstance& „ ' LOCAL hFont& „ „  total=0 „ „  DIALOG NEW hInstance&, "Quick-Calc", , ,  123,  120, %WS_POPUP  OR %WS_CAPTION OR %WS_MINIMIZEBOX _ „             OR %WS_SYSMENU OR %DS_CENTER TO hDlg „  CONTROL ADD TEXTBOX,hDlg,101,"",10,30,100,14 „  CONTROL ADD LABEL,hDlg,102,"",65,12,48,12,%SS_RIGHT „  CONTROL ADD LABEL,hDlg,103,"Total",10,12,50,12 „  CONTROL ADD FRAME, hDlg,104,"Calculator",5,2,112,25 „  CONTROL ADD FRAME, hDlg,104,"",5,24,112,90 „  CONTROL ADD BUTTON, hDlg,202,"C",62,95,20,14 „  CONTROL ADD BUTTON,hDlg,301,"7",20,50,20,14 „  CONTROL ADD BUTTON,hDlg,302,"8",41,50,20,14 „  CONTROL ADD BUTTON,hDlg,303,"9",62,50,20,14 „  CONTROL ADD BUTTON,hDlg,304,"4",20,65,20,14 „  CONTROL ADD BUTTON,hDlg,305,"5",41,65,20,14 „  CONTROL ADD BUTTON,hDlg,306,"6",62,65,20,14 „  CONTROL ADD BUTTON,hDlg,307,"1",20,80,20,14 „  CONTROL ADD BUTTON,hDlg,308,"2",41,80,20,14 „  CONTROL ADD BUTTON,hDlg,309,"3",62,80,20,14 „  CONTROL ADD BUTTON,hDlg,201,".",20,95,20,14 „  CONTROL ADD BUTTON,hDlg,310,"0",41,95,20,14 „  CONTROL ADD BUTTON,hDlg,311,"+",83,50,20,14 „  CONTROL ADD BUTTON,hDlg,312,"-",83,65,20,14 „  CONTROL ADD BUTTON,hDlg,313,"x",83,80,20,14 „  CONTROL ADD BUTTON,hDlg,314,"/",83,95,20,14 „  hFont& = GetStockObject(%SYSTEM_FIXED_FONT) „  CONTROL SEND hDlg, 311, %WM_SETFONT, hFont&, %TRUE „  CONTROL SEND hDlg, 312, %WM_SETFONT, hFont&, %TRUE „  CONTROL SEND hDlg, 313, %WM_SETFONT, hFont&, %TRUE „  CONTROL SEND hDlg, 314, %WM_SETFONT, hFont&, %TRUE „  CONTROL SEND hDlg, 201, %WM_SETFONT, hFont&, %TRUE „  CONTROL SEND hDlg, 101, %WM_SETFONT, hFont&, %TRUE „  CONTROL SET FOCUS hdlg,101 „  DIALOG SHOW MODAL hDlg CALL CalcDlgProc „ „REM below when USING PBMAIN TO RETURN total TO caller „'  FUNCTION =STR$(total) „END FUNCTION „Fred Buffington                Get Windows Version            oasys@sbcglobal.net            12-22-02 (  :  )       PBWIN,PBDLL            77   2226     getwinvr.bas'Fred Buffington„'Get Windows Version„'Pbwin„„$COMPILE EXE „$INCLUDE "win32api.inc" „'These constants enumerate the different possible Windows OS platforms „%WinUnknown      = 0 „%Win95           = 1 „%Win98           = 2 „%WinME           = 3 „%WinNT           = 4 „%Win2K           = 5 „%WinXP           = 6 „%WinDotNetServer = 7 „DECLARE FUNCTION GetWindowsVersion() AS LONG „ „FUNCTION PBMAIN() AS LONG „   lResult&=GetWindowsVersion „   SELECT CASE lResult& „        CASE %WinUnknown „              op$="Unknown" „        CASE %Win95 „              op$="Windows 95" „        CASE %Win98 „              op$="Windows 98" „        CASE %WinME „              op$="Windows ME" „        CASE %WinNT „              op$="Windows NT" „        CASE %Win2K „              op$="Windows 2K" „        CASE %WinXP „              op$="Windows XP" „        CASE %WinDotNetServer „              op$="WindotNet Server" „   END SELECT „   IF op$<>"" THEN MSGBOX op$,,"the OS is:" „END FUNCTION „ „FUNCTION GetWindowsVersion() AS LONG „   'Original function by Scott Turchin.  Modified by Bernard Ertl. „   'Original posting can be found here: „   'http://www.powerbasic.com/support/forums/Forum4/HTML/002310.html „ „   LOCAL osinfo   AS OSVERSIONINFO „ „   osinfo.dwOsVersionInfoSize = SIZEOF(osinfo) „ „   IF ISFALSE GetVersionEx( osinfo) THEN EXIT FUNCTION ' Function = %WinUnknown „ „   IF osinfo.dwPlatformId = %VER_PLATFORM_WIN32_NT THEN „      SELECT CASE osinfo.dwMajorVersion „         CASE < 5 „              FUNCTION = %WinNT „         CASE 5 „              SELECT CASE osinfo.dwMinorVersion „                 CASE 0 „                     FUNCTION = %Win2K „                 CASE 1 „                     FUNCTION = %WinXP „                 CASE 2 „                     FUNCTION = %WinDotNetServer „            END SELECT „      END SELECT „   ELSEIF osinfo.dwPlatformId = %VER_PLATFORM_WIN32_WINDOWS THEN „      SELECT CASE osinfo.dwMinorVersion „           CASE < 10 „               FUNCTION = %Win95 „           CASE 10 „               FUNCTION = %Win98 „           CASE 90 „               FUNCTION = %WinME „      END SELECT „   END IF „ „END FUNCTION „