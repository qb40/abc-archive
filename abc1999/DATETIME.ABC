Nigel Traves                   LEAP YEAR ALGORITHM UPDATE     tarot@ihalliwell.freeserve.co.u03-09-99 (19:05)       QB, QBasic, PDS        24   1135     LEAP.BAS    'Some time ago I submitted a set of routines that were inspired by„'similar ones that are part of ansi C.  Unfortunately the algorithm„'that I found for determining if a year was in fact a leap year was„'wrong and meant that overall the package would not be Y2K compliant„'(the dreaded millennium bug strikes again!).  Having now got the„'correct algorithm for determining leap years I have produced this„'update.  Serendipitously (oooo, big woid - just means happy accident),„'leap year determination was limited to a single SUB, so all that needs„'doing is to replace the existing SUB with the one below.„'„'                          N. Traves 3/1999„„SUB ThisInstant ( Now AS When )„    GetDate Now.Year, Now.Month, Now.MonthDay, Now.WeekDay„    Now.IsLeapYear = FALSE%„    IF (Now.Year MOD 400) = 0 THEN„        Now.IsLeapYear = TRUE%„    ELSEIF ((Now.Year MOD 4) = 0) AND ((Now.Year MOD 100) <> 0) THEN„        Now.IsLeapYear = TRUE%„    END IF„    DayOfYear Now.Month, Now.MonthDay, Now.IsLeapYear, Now.YearDay„    WeekOfYear Now.YearDay, Now.YearWeek„    GetTime Now.Hour, Now.Minute, Now.Second„END SUB„Nick Kochakian                 DELAY ROUTINE                  nickk@worldnet.att.net         03-29-99 (23:21)       QB, QBasic, PDS        75   1728     DELAY1.BAS  'DELAY1.BAS„'„'This program should provide a good enough base to write some sufficient„'delay routines. (Note: If you want to use this in a game, i'd strongly„'                 recommend that you adjust to frame rates.. Just an idea :)„'„'„'3/29/99 By: - Nick Kochakian -„'web:    http://come.to/dn3„'e-mail: nickk@worldnet.att.net„„DIM Timer.Whole.Second AS LONG    'This is where we store the result of the„                                  'second.„DIM Timer.Half.Second AS LONG„DIM Timer.Quater.Second AS LONG„„Timer.Flag = 0         'Tells when to break out of the loop„Timer.Whole.Second = 0„„TIMER ON                        'Turn the timer on„ON TIMER(1) GOSUB Timer.Release:„„PRINT "Timing second..."„„DO„ Timer.Whole.Second = Timer.Whole.Second + 1„LOOP WHILE Timer.Flag = 0„„Timer.Half.Second = Timer.Whole.Second / 2„Timer.Quarter.Second = Timer.Half.Second / 2„„'Some example:„CLS„PRINT "I have known for some time now that timing in QBasic has been a"„PRINT "problem. Which is why I've whiped up some basic timer routines."„PRINT "This demo program will show you the differences between pausing"„PRINT "for a Qtr second , and a half second."„PRINT ""„PRINT "Press SPACE"„„DO„LOOP UNTIL INKEY$ = CHR$(32)„„CLS„PRINT "Timing 3 times..."„PRINT ""„„FOR t = 1 TO 3„    FOR Timer.count = 1 TO Timer.Quarter.Second„    NEXT Timer.count„„    PRINT ".25 seconds"„NEXT t„„FOR t = 1 TO 3„    FOR Timer.count = 1 TO Timer.Half.Second„    NEXT Timer.count„„    PRINT ".5 seconds"„NEXT t„„FOR t = 1 TO 3„    FOR Timer.count = 1 TO Timer.Whole.Second„    NEXT Timer.count„„    PRINT "1 second"„NEXT t„„END„„Timer.Release:„„Timer.Flag = 1„TIMER OFF„RETURN„Roger W. Sinnott               CALCULATE SUNRISE/SUNSET TIMES www.gnomehome.demon.nl         05-31-99 (17:23)       QB, QBasic, PDS        141  4676     SUNRISE.BAS 310 DIM A(2), D(2)„10 '         Sunrise-Sunset„20 GOSUB 300„30 INPUT "Lat, Long (deg)"; B5, L5„40 INPUT "Time zone (hrs)"; H„50 L5 = L5 / 360: Z0 = H / 24„60 GOSUB 1170: T = (J - 2451545) + F„70 TT = T / 36525 + 1: ' TT = centuries„80 '               from 1900.0„90 GOSUB 410: T = T + Z0„100 '„110 '       Get Sun's Position„120 GOSUB 910: A(1) = A5: D(1) = D5„130 T = T + 1„140 GOSUB 910: A(2) = A5: D(2) = D5„150 IF A(2) < A(1) THEN A(2) = A(2) + P2„160 Z1 = DR * 90.833: ' Zenith dist.„170 S = SIN(B5 * DR): C = COS(B5 * DR)„180 Z = COS(Z1): M8 = 0: W8 = 0: PRINT„190 A0 = A(1): D0 = D(1)„200 DA = A(2) - A(1): DD = D(2) - D(1)„210 FOR C0 = 0 TO 23„220 P = (C0 + 1) / 24„230 A2 = A(1) + P * DA: D2 = D(1) + P * DD„240 GOSUB 490„250 A0 = A2: D0 = D2: V0 = V2„260 NEXT„270 GOSUB 820: '  Special msg?„280 END„290 '„300 '        Constants„„320 P1 = 3.14159265#: P2 = 2 * P1„330 DR = P1 / 180: K1 = 15 * DR * 1.0027379#„340 S$ = "Sunset at  "„350 R$ = "Sunrise at "„360 M1$ = "No sunrise this date"„370 M2$ = "No sunset this date"„380 M3$ = "Sun down all day"„390 M4$ = "Sun up all day"„400 RETURN„410 '     LST at 0h zone time„420 T0 = T / 36525„430 S = 24110.5 + 8640184.812999999# * T0„440 S = S + 86636.6 * Z0 + 86400 * L5„450 S = S / 86400: S = S - INT(S)„460 T0 = S * 360 * DR„470 RETURN„480 '„490 '  Test an hour for an event„500 L0 = T0 + C0 * K1: L2 = L0 + K1„510 H0 = L0 - A0: H2 = L2 - A2„520 H1 = (H2 + H0) / 2: '  Hour angle,„530 D1 = (D2 + D0) / 2: '  declination,„540 '                at half hour„550 IF C0 > 0 THEN 570„560 V0 = S * SIN(D0) + C * COS(D0) * COS(H0) - Z„570 V2 = S * SIN(D2) + C * COS(D2) * COS(H2) - Z„580 IF SGN(V0) = SGN(V2) THEN 800„590 V1 = S * SIN(D1) + C * COS(D1) * COS(H1) - Z„600 A = 2 * V2 - 4 * V1 + 2 * V0: B = 4 * V1 - 3 * V0 - V2„610 D = B * B - 4 * A * V0: IF D < 0 THEN 800„620 D = SQR(D)„630 IF V0 < 0 AND V2 > 0 THEN PRINT R$;„640 IF V0 < 0 AND V2 > 0 THEN M8 = 1„650 IF V0 > 0 AND V2 < 0 THEN PRINT S$;„660 IF V0 > 0 AND V2 < 0 THEN W8 = 1„670 E = (-B + D) / (2 * A)„680 IF E > 1 OR E < 0 THEN E = (-B - D) / (2 * A)„690 T3 = C0 + E + 1 / 120: ' Round off„700 H3 = INT(T3): M3 = INT((T3 - H3) * 60)„710 PRINT USING "##:##"; H3; M3;„720 H7 = H0 + E * (H2 - H0)„730 N7 = -COS(D1) * SIN(H7)„740 D7 = C * SIN(D1) - S * COS(D1) * COS(H7)„750 AZ = ATN(N7 / D7) / DR„760 IF D7 < 0 THEN AZ = AZ + 180„770 IF AZ < 0 THEN AZ = AZ + 360„780 IF AZ > 360 THEN AZ = AZ - 360„790 PRINT USING ",  azimuth ###.#"; AZ„800 RETURN„810 '„820 '   Special-message routine„830 IF M8 = 0 AND W8 = 0 THEN 870„840 IF M8 = 0 THEN PRINT M1$„850 IF W8 = 0 THEN PRINT M2$„860 GOTO 890„870 IF V2 < 0 THEN PRINT M3$„880 IF V2 > 0 THEN PRINT M4$„890 RETURN„900 '„910 '   Fundamental arguments„920 '     (Van Flandern &„930 '     Pulkkinen, 1979)„940 L = .779072 + .00273790931# * T„950 G = .993126 + .0027377785# * T„960 L = L - INT(L): G = G - INT(G)„970 L = L * P2: G = G * P2„980 V = .39785 * SIN(L)„990 V = V - .01 * SIN(L - G)„1000 V = V + .00333 * SIN(L + G)„1010 V = V - .00021 * TT * SIN(L)„1020 U = 1 - .03349 * COS(G)„1030 U = U - .00014 * COS(2 * L)„1040 U = U + .00008 * COS(L)„1050 W = -.0001 - .04129 * SIN(2 * L)„1060 W = W + .03211 * SIN(G)„1070 W = W + .00104 * SIN(2 * L - G)„1080 W = W - .00035 * SIN(2 * L + G)„1090 W = W - .00008 * TT * SIN(G)„1100 '„1110 '    Compute Sun's RA and Dec„1120 S = W / SQR(U - V * V)„1130 A5 = L + ATN(S / SQR(1 - S * S))„1140 S = V / SQR(U): D5 = ATN(S / SQR(1 - S * S))„1150 R5 = 1.00021 * SQR(U)„1160 RETURN„1165 '„1170 '     Calendar --> JD„1180 INPUT "Year, Month, Day"; Y, M, D„1190 G = 1: IF Y < 1583 THEN G = 0„1200 D1 = INT(D): F = D - D1 - .5„1210 J = -INT(7 * (INT((M + 9) / 12) + Y) / 4)„1220 IF G = 0 THEN 1260„1230 S = SGN(M - 9): A = ABS(M - 9)„1240 J3 = INT(Y + S * INT(A / 7))„1250 J3 = -INT((INT(J3 / 100) + 1) * 3 / 4)„1260 J = J + INT(275 * M / 9) + D1 + G * J3„1270 J = J + 1721027 + 2 * G + 367 * Y„1280 IF F >= 0 THEN 1300„1290 F = F + 1: J = J - 1„1300 RETURN„1310 '„1320 '   This program by Roger W. Sinnott calculates the times of sunrise„1330 '   and sunset on any date, accurate to the minute within several„1340 '   centuries of the present.  It correctly describes what happens in the„1350 '   arctic and antarctic regions, where the Sun may not rise or set on„1360 '   a given date.  Enter north latitudes positive, west longitudes„1370 '   negative.  For the time zone, enter the number of hours west of„1380 '   Greenwich (e.g., 5 for EST, 4 for EDT).  The calculation is„1390 '   discussed in Sky & Telescope for August 1994, page 84.„Don Schullian                  DATES ROUTINES FOR QB          d83@DASoftVSS.com              07-02-99 (13:31)       QB, QBasic, PDS        156  4549     DATES-QB.BAS  Hi,„„  These routines are Y5M compliant!„„  This code was reworked from code I was given by Eustice Frilingos so most of„  the credit goes to him.„„  These two functions pack the three date elements (Y,M,D) into a long integer„  by counting the number of days since 1-1-0001 then unpacking that number into„  the three date elements. The last possible date is in the year 5.8M so it's„  safe to say that the Y2K thingie isn't a problem!„„  The fly in the ointment is that somewhere in the 12th century 11 days were„  cut or added to the calendar (don't remember which) so if you're an historian„  you'll need to modify the routines to work around that little chronological„  blip. The reason I've not messed with it is two fold:„    1) I don't plan on going back that far„    2) that 11 day blip is ONLY good in so many countries.„  Other countries and/or religious and/or ethnic groups did things differently„  so the whole sheebang gets totally mind boggling if one wants to make this„  routine work 100% for all conditions.„„  The benefits of storing dates in this manner are many fold and not limited to„  the list below:„    1) DayOfTheWeek = (Days MOD 7) ' Sunday = 0 and Saturday = 6„    2) The system is country independent„    3) ToDay +  7 = SameDay_NextWeek„       ToDay + 28 = SameDay_NextMonth (4 weeks)„    4) Validation of an incoming date is fast and quick using the same„       two routines and comparing the returned Y,M,D with what was„       sent. (You need to build such a checking routine)„„  fYMD2Days&  returns the number of days since 1-1-0001„  fDays2YMD%  returns the year, month, day and day of the week for a day number„  fJulianDay& returns the day number in a given year„  fLeapYear%  returns 0 or 1 if the year is, in fact, a leap year.„„  Hope these routines help you out.„„  d83)„„---------------------------------------------------------------„-------------------------<CUT HERE>----------------------------„---------------------------------------------------------------„„DEFINT A-Z„DECLARE FUNCTION fLeapYear% (Year%)„DECLARE FUNCTION fYMD2Days& (Year%, Month%, Day%)„DECLARE FUNCTION fDays2YMD% (Days&, Year%, Month%, Day%)„„CLS„„T1! = TIMER„FOR Y1% = 400 TO 2400„  PRINT USING "#,###"; Y1%„  DoM& = &H3DFF7F9F„  IF fLeapYear%(Y1%) THEN DoM& = (DoM& + 32)„  FOR M1% = 1 TO 12„    FOR D1% = 1 TO (DoM& AND 31)„      IF LEN(INKEY$) THEN GOTO BailOut„      Dz1& = fYMD2Days&(Y1%, M1%, D1%)„      DoW% = fDays2YMD%(Dz1&, Y2%, M2%, D2%)„      IF (Y1% <> Y2%) OR (M1% <> M2%) OR (D1% <> D2%) THEN PRINT "ERROR": END„    NEXT„    DoM& = DoM& \ 32„    IF DoM& = 0 THEN DoM& = &H3FEFFBFF„  NEXT„NEXT„„BailOut:„  T1! = TIMER - T1!„  PRINT„  PRINT USING "###.####"; T1!„  PRINT "<<DONE>>";„END„„FUNCTION fDays2YMD% (Daze&, Year%, Month%, Day%)„„  Year% = 1„  Month% = 1„  Days& = Daze& - 1„„  IF Days& > 146096 THEN„    Year% = Year% + (Days& \ 146097) * 400„    Days& = (Days& MOD 146097)„  END IF„  IF Days& > 36523 THEN„    D% = (Days& \ 36524)„    IF D% < 4 THEN„        Year% = Year% + (D% * 100)„        Days& = (Days& MOD 36524)„      ELSE„        Year% = Year% + 300„        Days& = 36524„    END IF„  END IF„  IF Days& > 1460 THEN„    Year% = Year% + (Days& \ 1461) * 4„    Days& = (Days& MOD 1461)„  END IF„  IF Days& > 364 THEN„    D% = (Days& \ 365)„    IF D% < 4 THEN„        Year% = Year% + D%„        Days& = (Days& MOD 365)„      ELSE„        Year% = Year% + 3„        Days& = 365„    END IF„  END IF„„  Day% = Days& + 1„  DoM& = &H3DFF7F9F„  IF Day% > 58 AND fLeapYear%(Year%) THEN DoM& = (DoM& + 32)„  DO„    D% = (DoM& AND 31)„    IF D% >= Day% THEN EXIT DO„    Day% = Day% - D%„    Month% = Month% + 1„    DoM& = (DoM& \ 32)„    IF DoM& = 0 THEN DoM& = &H3FEFFBFF„  LOOP„„  fDays2YMD% = (Daze& MOD 7)„„END FUNCTION„„FUNCTION fLeapYear% (Year%)„„  IF ((Year% MOD 4) = 0) AND ((Year% MOD 100) > 0) OR ((Year% MOD 400) = 0) THEN fLeapYear% = 1„„END FUNCTION„„FUNCTION fYMD2Days& (Y%, M%, D%)„„  Days& = D%„„  IF M% > 1 THEN„    Month% = M%„    DoM& = &H3DFF7F9F„    IF Month% > 2 AND fLeapYear%(Y%) THEN DoM& = (DoM& + 32)„    DO„      Days& = Days& + (DoM& AND 31)„      IF Month% = 2 THEN EXIT DO„      Month% = Month% - 1„      DoM& = DoM& \ 32„      IF DoM& = 0 THEN DoM& = &H3FEFFBFF„    LOOP„  END IF„„  Year% = (Y% - 1)„  Days& = Days& + (CLNG(Year%) * 365) + (Year% \ 4) - (Year% \ 100) + (Year% \ 400)„„  fYMD2Days& = Days&„„END FUNCTION„Laz500@aol.com                 SECONDS LEFT UNTIL YEAR 2000   santa@tir.com                  07-25-99 (12:02)       QB, QBasic, PDS        62   2244     2000AD.BAS  '                            ∫    Millenium    ∫                        „'                            »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº„'„'  E-Mail:   Graham_Lally@o14amiga.demon.co.uk               …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ„'      Or:   Laz500@aol.com                                  ∫≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤„'                                                            ∫±±±±±±±±±±±±±±±±„'     WWW:   http://www.kingston.ac.uk/~lr_s536/Qbasic.html  ∫∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞∞„'ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº„„„DIM total.secs.left AS LONG       'to stop getting those nasty E numbers :]„„Year = VAL(RIGHT$(DATE$, 4))      '\„month = VAL(LEFT$(DATE$, 2))      ' \„day = VAL(MID$(DATE$, 4, 2))      '  Gets the values from the Date$ and Time$.„                                  '  The VAL just turns what is usually a„Hours = VAL(LEFT$(TIME$, 2))      '  string into a number. Pretty useful...„Mins = VAL(MID$(TIME$, 4, 2))     ' /„Secs = VAL(RIGHT$(TIME$, 2))      '/„                                  „Years.left = (1999 - Year) * 365 * 24 * 60 * 60„„'The above line works out the number of seconds in the years left.„„'This next SELECT works out how many days have gone past in the completed„'months of this year.„„SELECT CASE month„    CASE 1: daysgone = 0„    CASE 2: daysgone = 31„    CASE 3: daysgone = 59„    CASE 4: daysgone = 90„    CASE 5: daysgone = 120„    CASE 6: daysgone = 151„    CASE 7: daysgone = 181„    CASE 8: daysgone = 212„    CASE 9: daysgone = 243„    CASE 10: daysgone = 273„    CASE 11: daysgone = 304„    CASE 12: daysgone = 334„END SELECT„daysgone = daysgone + day  'Now we add the number of days gone in this month.„Days.left = (364 - daysgone) * 24 * 60 * 60  'And work out the seconds...„„Hours.left = (23 - Hours) * 60 * 60„Mins.left = (59 - Mins) * 60„Secs.left = (60 - Secs)„„                                    'Yep, all pretty straightforward...„„total.secs.left = Years.left + Days.left + Hours.left + Mins.left + Secs.left„„                                    'Add it all up...„„PRINT„PRINT "Seconds left till the Year 2000:";„COLOR 14„PRINT total.secs.left„PRINT„COLOR 7„„                        'And print it. All done. Easy peasy pudding and pie.„Wayne Henderson                SEASONS CALCULATOR             whenders@becon.org             10-29-99 (22:14)       QB, QBasic, PDS        127  5394     SEASONS.BAS '„'   SEASONS CALCULATOR (approximate) times within Ò minute for years„'                                      from +1000 to +3000 or more„'„' from algorithms presented in 'Astronomical Algorithms' by„' Jean Meeus, 1991  ISBN 0-943396-35-2 (get it at the library to see how„'                                       this complicated algorithm works.)„' More accurate methods exist and are mentioned in the book's bibliography„'„DEFINT A-Z„DECLARE FUNCTION dcos# (deg#) 'convert degrees to radians, get cos„DECLARE FUNCTION jd2date$ (month, day AS DOUBLE, y&) 'Julian Day to Calendar date„DIM yr AS DOUBLE, day AS DOUBLE, jde AS DOUBLE, Lambda AS DOUBLE„DIM March AS DOUBLE, June AS DOUBLE, September AS DOUBLE, December AS DOUBLE„DIM c AS INTEGER, b(72) AS DOUBLE„CONST rad# = 3.141592653589793# / 180„'„start: PRINT : INPUT "Year ", q$: yr = VAL(q$): IF yr = 0 THEN SYSTEM„yr = (yr - 2000) / 1000: PRINT„'„' step 1  calculate:„'„'         JDE0 - 2451545.0„'    T =  ----------------, # of Julian centuries since Jan. 1, 2000 noon UT„'               36525„'„'    W = 35999.373T - 2.47 (degrees)„'„'    Lambda = 1 + 0.0334 cos W + 0.0007 cos 2W„'„'  jde0 values„March = 2451623.80984# + 365242.37404# * yr + .05169 * yr * yr„March = March - .00411 * yr * yr * yr - .00057 * yr * yr * yr * yr„June = 2451716.56767# + 365241.62603# * yr + .00325 * yr * yr„June = June + .00888 * yr * yr * yr - .0003 * yr * yr * yr * yr„September = 2451810.21715# + 365242.01767# * yr - .11575 * yr * yr„September = September + .00337 * yr * yr * yr + .00078 * yr * yr * yr * yr„December = 2451900.05952# + 365242.74049# * yr - .06223 * yr * yr„December = December - .00823 * yr * yr * yr + .00032 * yr * yr * yr * yr„'„' step 2  get the 24 terms of the series A cos (B + CT)„'         and calculate their sum in subroutine kalk.„'„RESTORE: FOR c = 1 TO 72: READ a$: b(c) = VAL(a$): NEXT„'  terms of the series:  A cos (B + CT),  S = ‰ { A cos (B + CT) }„'                 eg: 485 * cos (324.96 + 1934.136 * T) + 203 * ...„DATA 485,324.96,1934.136,203,337.23,32964.467,199,342.08,20.186„DATA 182,27.85,445267.112,156,73.14,45036.886,136,171.52,22518.443„DATA 77,222.54,65928.934,74,296.72,3034.906,70,243.58,9037.513„DATA 58,119.81,33718.147,52,297.17,150.678,50,21.02,2281.226„DATA 45,247.54,29929.562,44,325.15,31555.956,29,60.93,4443.417„DATA 18,155.12,67555.328,17,288.79,4562.452,16,198.04,62894.029„DATA 14,199.76,31436.921,12,95.39,14577.848,12,287.11,31931.756„DATA 12,320.81,34777.259,9,227.73,1222.114,8,15.45,16859.074„'„'........ Change TZ and TZ1$, TZ2$ to the correct values for your time zone:„'........ 8 for PST 7 for PDT, 7 for MST 6 for MDT, 6 for CST 5 for CDT, etc.„'„tz1$ = " EST": tz2$ = " EDT"„jde = March: tz = 5: GOSUB kalk: PRINT "Spring: ";„GOSUB jddate: PRINT jd2date$(month, day, y&); tz1$„jde = June: tz = 4: GOSUB kalk: PRINT "Summer: ";„GOSUB jddate: PRINT jd2date$(month, day, y&); tz2$„jde = September: tz = 4: GOSUB kalk: PRINT "Autumn: ";„GOSUB jddate: PRINT jd2date$(month, day, y&); tz2$„jde = December: tz = 5: GOSUB kalk: PRINT "Winter: ";„GOSUB jddate: PRINT jd2date$(month, day, y&); tz1$„GOTO start„'„' step 3„'                           0.00001S„'             JDE = jde0 + ----------„'                            Lambda„'„kalk:„   t# = (jde - 2451545) / 36525„   w# = 35999.373# * t# - 2.47#„   Lambda = 1 + .0334 * dcos(w#) + .0007 * dcos(2 * w#)„   sum# = 0„   FOR c = 1 TO 72 STEP 3„      sum# = sum# + b(c) * dcos(b(c + 1) + b(c + 2) * t#)„   NEXT„   jde = jde + (.00001 * sum#) / Lambda - tz / 24 'UT to local - tz/24„RETURN„'„jddate: 'algorithm from Peter Baum (pbaum@capecod.net)„   r$ = "312831303130313130313031": s& = INT(jde - 1721118.5#)„   H# = jde - 1721118.5# - s&: m# = 100 * s& - 25„   a = m# \ 3652425: b = a - a \ 4: y& = (100 * b + m#) \ 36525„   c = b + s& - 365 * y& - y& \ 4: month = (5 * c + 456) \ 153„   day = c - (153 * month - 457) \ 5 + H#„   IF month > 12 THEN y& = y& + 1: month = month - 12„   IF y& / 400 = y& \ 400 THEN MID$(r$, 4, 1) = "9"„   IF (y& / 100 <> y& \ 100) AND (y& / 4 = y& \ 4) THEN„      MID$(r$, 4, 1) = "9"„   END IF„RETURN„'„' by Wayne Henderson    Oct. 29, 1999 (Fri)   10:00 pm EDT„„DEFSNG A-Z„FUNCTION dcos# (deg#)„   dcos# = COS(deg# * rad#)„END FUNCTION„„DEFINT A-Z„FUNCTION jd2date$ (month, day AS DOUBLE, y&)„   r$ = "312831303130313130313031"„   hr! = (day - INT(day)) * 24 'fraction of a day„   min! = (hr! - INT(hr!)) * 60 'fraction of an hour„   sec = CINT((min! - INT(min!)) * 60) 'fraction of a minute„   min! = INT(min!): day = INT(day): hr! = INT(hr!)„   IF sec = 60 THEN sec = 0: min! = min! + 1„   IF min! = 60 THEN min! = 0: hr! = hr! + 1„   IF hr! = 24 THEN hr! = 0: day = day + 1„   IF day > VAL(MID$(r$, month * 2 - 1, 2)) THEN day = 1: month = month + 1„   IF month > 12 THEN month = 1: year = year + 1„   IF month < 10 THEN u$ = "0" ELSE u$ = ""„   IF day < 10 THEN w$ = "0" ELSE w$ = ""„   IF hr! < 10 THEN v$ = "0" ELSE v$ = ""„   IF min! < 10 THEN x$ = "0" ELSE x$ = ""„   IF sec < 10 THEN p$ = "0" ELSE p$ = ""„   u$ = u$ + LTRIM$(STR$(month)) + "-": w$ = w$ + LTRIM$(STR$(day)) + "-"„   v$ = v$ + LTRIM$(STR$(hr!)) + ":": x$ = x$ + LTRIM$(STR$(min!)) + ":"„   p$ = p$ + LTRIM$(STR$(sec))„   jd2date$ = u$ + w$ + LTRIM$(STR$(y&)) + " " + v$ + x$ + p$„END FUNCTION„