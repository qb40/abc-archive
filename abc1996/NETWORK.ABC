Erik Olson                     PB NET STUFF                   Rolf@ice.prima.ruhr.de         06-07-93 (4:47)        PB                     262  7754     NETSTUFF.BASCLS„PRINT "NetStuff - based on QuickBASIC code by Chip Morrow"„PRINT "Adapted to PowerBASIC (6/7/93) by Erik Olson"„PRINT„PRINT "--------------------------------------------------"„PRINT„„SOUND 5000,.5„„IF NOT NetBios% THEN PRINT "NetBIOS Not Installed.":END„   PRINT "NetBIOS is installed."„„   '........................................... Get the Local Machine Name„   Q% = NetName%(Machine$)„   PRINT "Current machine name is: "; Machine$„„„   '............................................ List current redirections„   Index% = 0„   DO„     GetDevice Index%, D$, N$„     IF D$ = "" THEN EXIT DO„     PRINT D$; " is redirected to "; N$„     INCR Index%„   LOOP„   PRINT„„   '.................................................. List logged servers„   ' this routine uses sub function 80 of function 5F of int 21, which„   ' is not documented, so I assume that it's proprietary to LANtastic„   Index% = 0„   DO„     LoggedIn Index%, Logg$„     IF Logg$ = "" THEN EXIT DO„     PRINT "Logged into: "; Logg$„     INCR Index%„   LOOP„   IF Index%=0 THEN PRINT "You are not logged into any servers. (Lantastic only?)"„   PRINT„„   '.................................. List available (not logged) servers„   ' this routine uses sub function 84 of function 5F of int 21, which„   ' is not documented, so I assume that it's proprietary to LANtastic„   Index% = 0„   DO„     Inactive Index%, Logg$„     IF Logg$ = "" THEN EXIT DO„     PRINT "Available: "; Logg$„     INCR index%„   LOOP„   IF Index%=0 THEN PRINT "All availabler servers are logged in. (Lantastic only?)"„   PRINT„„DELAY 1:SOUND 1000,.5„„' --------------------------------------------------------------------„' Quickie implementation of Redirect and NetCancel routines.„' Device name to redirect or cancel should be c:, d:, prn, lpt:, etc.„' Server's path should be full path, such as \\node1\cdrive„' --------------------------------------------------------------------„„  PRINT "R)edirect, C)ancel redirection, or Q)uit : ";„  DO„    Z$ = UCASE$(INKEY$)„    SELECT CASE Z$„      CASE "R", "C", "Q": EXIT DO„    END SELECT„  LOOP„       PRINT Z$„       SELECT CASE Z$:„	 CASE "R":                                            ' Redirect„	    PRINT "Drive letter or logical device ---> ";„	    LINE INPUT "", ReDir$„	    PRINT "Server's path to use -------------> ";„	    LINE INPUT "", SPath$„	    PRINT "Device type = P)rinter, or D)isk -> ";„	    DO„	      Z$ = UCASE$(INKEY$)„	      SELECT CASE Z$„		CASE "P", "D": EXIT DO„	      END SELECT„	    LOOP„	    PRINT Z$„	    SELECT CASE Z$„	      CASE "P":  DevType% = 3            ' 3 = printer„	      CASE ELSE: DevType% = 4            ' 4 = disk„	    END SELECT„	    Redirect DevType%, ReDir$, SPath$     ' Do it.„	    IF DevType% > 0 THEN                  ' Devtype = 0 if no error.„	       PRINT "Error"; DevType%;„	       PRINT " - no redirection performed."„	    ELSE„	       PRINT "Redirection successful."„	    END IF„	    PRINT„	 CASE "C":                                          ' Cancel„	    PRINT "Drive letter or logical device --> ";„	    LINE INPUT "", DevName$„	    Z% = NetCancel%(DevName$)            ' Do it.„	    IF Z% > 0 THEN                       ' Z = 0 if no error.„	       PRINT "Error"; Z%; " - unable to cancel redirection."„	    ELSE„	       PRINT "Redirection successfully cancelled."„	    END IF„	    PRINT„	 CASE "Q", CHR$(27):            ' Quit„	   END„       END SELECT„SOUND 1000,.5:DELAY 1:SOUND 100,.5„RUN„„' End sample.  Subs & functions follow.„„' **************************************************************************„„SUB GetDevice (DeviceNum%, DevName$, NetPath$)   ' Get redirected device entry.„  '„  ' DeviceNum% begins at zero (for first entry).„  ' DevName$ is returned as the name of the redirected device.„  ' NetPath$ is returned as the name of the server's network path.„  '„  ' DevName$ is returned as a nul string if DeviceNum is invalid.„  '„  DevNam$ = SPACE$(16)„  NetPat$ = SPACE$(128)„  REG 1, &H5F02„  REG 2, DeviceNum%„„  REG 8, STRSEG(DevNam$) 'DS„  REG 5, STRPTR(DevNam$) 'SI„  REG 9, STRSEG(NetPat$) 'ES„  REG 6, STRPTR(NetPat$) 'DI„  CALL INTERRUPT &H21„  Strip DevNam$, DevName$„  Strip NetPat$, NetPath$„END SUB„„SUB Inactive (EntryNum%, Returned$)„  '„  ' Display a list of servers that are available, but that you haven't„  ' logged into.„  '„  ' EntryNum% is input to the routine, and begins at zero (for first entry).„  ' Returned$ is returned as the name of the server, or as "" if an invalid„  '           EntryNum is passed.„  '„  CurrentEntry$=SPACE$(16)„  Reg 1, &H5F84„  Reg 2, EntryNum%„  Reg 9, STRSEG(CurrentEntry$)  ' ES„  REG 6, STRPTR(CurrentEntry$)  ' DI„  CALL INTERRUPT &H21„  Strip CurrentEntry$, Returned$„  IF Returned$ <> "" THEN„     Returned$ = "(" + Returned$ + ")"„  END IF„END SUB„„SUB LoggedIn (EntryNum%, Logged$)„  '„  ' Display a list of servers that you're currently logged into.„  ' EntryNum% begins at zero (for first entry).„  ' Logged$ returns the server name, or a nul string if invalid EntryNum.„  '„  CurrentEntry$=SPACE$(16)„  REG 1, &H5F80„  REG 2, EntryNum%„  REG 9, STRSEG(CurrentEntry$) 'ES„  REG 6, STRPTR(CurrentEntry$) 'DI„  CALL INTERRUPT &H21„  Strip CurrentEntry$, Logged$„END SUB„„FUNCTION NetBios%                     ' Determine if NetBios is present.„   Reg 1, 0„   CALL INTERRUPT &H2A„   AH = Reg(1) \ 256„   IF AH = 0 THEN„      NetBios% = 0„   ELSE„      NetBios% = -1„   END IF„END FUNCTION„„FUNCTION NetCancel% (DevName$)                  ' Cancel device redirection.„  '„  ' Cancel redirection of a device.„  ' DevName$ is device name to cancel redirection for,„  ' NetCancel% returns an error code if unsuccessful, zero otherwise.„  '„  Reg 1, &H5F04„  Reg 8, STRSEG(DevName$) 'DS„  Reg 5, STRPTR(DevName$) 'SI„  CALL INTERRUPT &H21„  IF (REG(0) AND 1) THEN„     NetCancel% = REG(1)„  ELSE„     NetCancel% = 0„  END IF„END FUNCTION„„FUNCTION NetName% (Machine$)          ' Get current machine name.„  '„  ' This routine takes no inputs.  It returns:„  '„  ' NetName% is the machine number (or zero if error)„  ' Machine$ is the current machine name.„  '„  MName$ = SPACE$(16)„  REG 1, &H5E00„  REG 8, STRSEG(MName$) 'DS„  REG 4, STRPTR(MName$) 'DX (that's right)„  CALL INTERRUPT &H21„  IF (REG(0) AND 1) THEN       ' Carry flag is set. (Error)„     NetName% = 0„     LSET MName$ = "N/A"„     Strip MName$, Machine$„     EXIT FUNCTION„  END IF„  CH = REG(3) \ 256„  IF CH = 0 THEN„     NetName% = 0„     EXIT FUNCTION„  END IF„  NetName% = REG(3) - (CH * 256)    ' CL„  Strip MName$, Machine$„END FUNCTION„„SUB Redirect (DevType%, DevName$, NetPath$)      ' Redirect a device„  '„  ' Inputs:„  '„  ' DevType% = 3 for Printer device, or„  '            4 for disk device.„  '            DevName$ = "C:", "D:", "LPT1:", etc.„  '            NetPath$ = Server's network path to redirect, in the format:„  '                       \\server_name\device_name„  ' -----------------------------------------------------------------------„  ' OutPut:„  '„  ' DevType% returns zero if no error, or error number if one occurred.„  '„  DevNam$ = DevName$ + CHR$(0,0,0)„  NetPat$ = NetPath$ + CHR$(0,0,0)„  REG 1, &H5F03„  REG 2, DevType%„  REG 3, 0„  REG 8, STRSEG(DevNam$) ' DS„  REG 5, STRPTR(DevNam$) ' SI„  REG 9, STRSEG(NetPat$) ' ES„  REG 6, STRPTR(NetPat$) ' DI„  CALL INTERRUPT &H21„  DevType% = 0„  IF (REG(0) AND 1) THEN     ' Carry flag indicates error.„     DevType%=REG(1)„  END IF„END SUB„„SUB Strip (A$, B$)„   B$=REMOVE$(A$, ANY CHR$(0,9,32,255))„END SUB„„Greg Shultz/Dave Navarro, Jr.  NOVELL NETWARE ROUTINES        comp.lang.basic.misc           04-06-96 (00:00)       PB32                   231  7052     NETWARE.BAS 'Novell Netware programming seeems to be a more and more important issue these „'days with many programmers.  Users are demanding direct network support in „'many applications.„„'As a result, Greg Schultz and I are working on a public domain Novell Netware „'library for PowerBASIC.  Most of the work is being done on CompuServe in the „'PowerBASIC forum.  However, I'll try to post updates here whenever possible.„„'Greg has Netware set up and running at his office and home and I am in the „'process of setting up Netware at home (we use LANtastic at work).„„'If you have any code you would like to contribute, please email it to me and „'I'll make sure to review it.„„'I hope you find the following code useful:„„'We've tested this code on Netware 3.11, 3.12 and 4.01.„„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'   Novell Netware routines for PowerBASIC 3.2 or later„'   Donated to the Public Domain„'   Last Revision:  April 6, 1996„'„'   Contributions by:  Greg Shultz          71223.431@compuserve.com„'                      Dave Navarro, Jr.    dave@powerbasic.com„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„$CPU 8086          'make compatible with XT systems„$LIB ALL OFF       'turn off all PowerBASIC libraries„$ERROR ALL OFF     'turn off all PowerBASIC error checking„$OPTIMIZE SIZE     'optimize for smaller code„$COMPILE UNIT      'compile to a UNIT (.PBU)„$DIM ALL           'force all variables and arrays to be declared„„„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovellAPI„' AUTHOR:  Dave Navarro, Jr.„' DECLARE: FUNCTION NovellAPI(BYVAL integer, ANY, ANY) AS INTEGER„' DESC:    Make a call to the Novell API.  Return's true (-1) if call was„'          successful.„' EXAMP:   Success = NovellAPI(Service%, RequestType, ReplyType)„'„FUNCTION NovellAPI(BYVAL service AS INTEGER, ANY, ANY) AS INTEGER„„  !     push    DS                      ;„„  !     lds     SI, [BP+8]              ; point DS:SI to request packet„  !     les     DI, [BP+12]             ; point ES:DI to reply packet„  !     mov     AH, Byte Ptr Service    ; put service in AH„  !     xor     AL, AL                  ; clear AL„  !     int     &H21                    ; call API through DOS„„  !     xor     BX, BX                  ; clear BX„  !     mov     AH, BH                  ; clear AH„  !     or      AL, AL                  ; we're we successful?„  !     jnz     Done                    ; yes, exit„  !     dec     BX                      ; make it -1„Done:„  !     mov     AX, BX                  ; put return code in AX„„  !     pop     DS                      ;„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovCVI„' AUTHOR:  Dave Navarro, Jr.„' DECLARE: FUNCTION NovCVI(BYVAL string) AS INTEGER„' DESC:    Converts a Novell style integer into an IEEE integer.„' EXAMP:   User = NovCVI( User.Object )„'„FUNCTION NovCVI(BYVAL x AS STRING) AS INTEGER„„  DIM y AS LOCAL INTEGER„„  y = CVI(x)„„  ! mov  AX, y„  ! xchg AL, AH„  ! mov  y, AX„„  FUNCTION = y„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovCVL„' AUTHOR:  Dave Navarro, Jr.„' DECLARE: FUNCTION NovCVL(BYVAL string) AS LONG„' DESC:    Converts a Novell style long into an IEEE long.„' EXAMP:   User = NovCVL( User.Object )„'„FUNCTION NovCVL(BYVAL x AS STRING) AS LONG„„  DIM y AS LOCAL LONG„„  y = CVL(x)„„  ! mov  AX, y[0]„  ! mov  BX, y[2]„  ! mov  y[0], BX„  ! mov  y[2], AX„„  FUNCTION = y„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovMKI„' AUTHOR:  Dave Navarro, Jr.„' DECLARE: FUNCTION NovMKI(BYVAL integer) AS STRING„' DESC:    Converts an IEEE style integer into a Novell integer.„' EXAMP:   User.Object = NovMKI(255)„'„FUNCTION NovMKI(BYVAL x AS INTEGER) AS STRING„„  ! mov  AX, x„  ! xchg AL, AH„  ! mov  x, AX„„  FUNCTION = MKI$(x)„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovMKL„' AUTHOR:  Dave Navarro, Jr.„' DECLARE: FUNCTION NovMKL(BYVAL long) AS STRING„' DESC:    Converts an IEEE style long into a Novell long.„' EXAMP:   User.Object = NovMKL(255)„'„FUNCTION NovMKL(BYVAL x AS LONG) AS STRING„„  ! mov  AX, x[0]„  ! mov  BX, x[2]„  ! mov  x[0], BX„  ! mov  x[2], AX„„  FUNCTION = MKL$(x)„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovConnection„' AUTHOR:  Greg Shultz„' DECLARE: FUNCTION NovConnection() AS INTEGER„' DESC:    Return the connection number for the current workstation.  If„'          zero is returned, the workstation is not logged into a server.„' EXAMP:   PRINT "Current connection number:"; NovConnection„'„FUNCTION NovConnection () AS INTEGER„„  ! mov  AX, &HDC00              ; get connection id„  ! int  &H21                    ; through DOS„  ! xor  AH, AH                  ; clear AH„  ! mov  FUNCTION, AX            ; return result„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovOpenBindery„' AUTHOR:  Greg Shultz„' DECLARE: FUNCTION NovOpenBinery() AS INTEGER„' DESC:    Returns true (-1) if the bindery was successfully opened.„'„TYPE OpenBinderyRequest„  Length  AS WORD   '0001„  Service AS BYTE   'subfunc 45h„END TYPE„„TYPE OpenBinderyReply„  Empty   AS WORD   'nothing is returned„END TYPE„„FUNCTION NovOpenBindery () AS INTEGER„„  DIM Request AS OpenBinderyRequest„  DIM Reply   AS OpenBinderyReply„„  Request.Length  = 1„  Request.Service = &H45„  Reply.Empty     = 0„„  FUNCTION = NovellAPI(&HE3, Request, Reply)„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovCloseBindery„' AUTHOR:  Greg Shultz„' DECLARE: FUNCTION NovCloseBinery() AS INTEGER„' DESC:    Returns true (-1) if the bindery was successfully closed.„'„TYPE CloseBinderyRequest„  Length  AS WORD   '0001„  Service AS BYTE   'subfunc 44h„END TYPE„„TYPE CloseBinderyReply„  Empty   AS WORD   'nothing is returned„END TYPE„„FUNCTION NovCloseBindery () AS INTEGER„„  DIM Request AS CloseBinderyRequest„  DIM Reply   AS CloseBinderyReply„„  Request.Length  = 1„  Request.Service = &H44„  Reply.Empty     = 0„„  FUNCTION = NovellAPI(&H3E, Request, Reply)„„END FUNCTION„„„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' PROC:    NovLogOutAll„' AUTHOR:  Dave Navarro, Jr.„' DECLARE: FUNCTION NovLogOutAll() AS INTEGER„' DESC:    Logs the current workstation out of all attached servers.  Returns„'          true (-1) if successful.„' EXAMP:   CALL NovLogOutAll„'„FUNCTION NovLogOutAll () AS INTEGER„„  ! mov  AX, &HD700„  ! int  &H21„  ! xor  AH, AH„  ! mov  FUNCTION, AX„„END FUNCTION„Dave Navarro, Jr.              RETURNS DESQVIEW VERSION       comp.lang.basic.misc           04-16-96 (06:58)       PB32                   40   1511     DESQVER.BAS '> „'> I search a method for detect DesqView and others populars multitask if present.„„' DesqviewVer routine for PowerBASIC 3.2 or later„' Donated to the Public Domain by Dave Navarro, Jr.„'„' DESCRIPTION:„'   Return the version of DesqView installed.„'„' EXAMPLE"„'   DECLARE FUNCTION DesqviewVer() AS INTEGER„'   IF ISTRUE(DesqviewVer) THEN„'     PRINT "DesqView version";DesqviewVer/100;" installed"„'   END IF„„FUNCTION DesqviewVer () AS INTEGER„„  ! push    DS                      ; save DS„„  ! mov     AX, &H1022              ; DesqView API Call„  ! xor     BX, BX                  ; clear BX„  ! int     &H15                    ; through int 15„  ! or      BX, BX                  ; is DesqView installed?„  ! jne     NoDesq                  ; no, exit„  ! mov     AX, BX                  ; put version into AX„  ! push    AX                      ; save minor version number for later„  ! mov     CL, 100                 ; prepare to muliply AL * 100„  ! mul     CL                      ; AX = AL * CL„  ! pop     BX                      ; retrieve minor version„  ! mov     BL, BH                  ; mov minor version to BL„  ! xor     BH, BH                  ; zero out BH„  ! add     AX, BX                  ; add major and minor parts„  ! jmp     short Done              ;„NoDesq:„  ! xor     AX, AX                  ; clear EX„Done:„  ! mov     FUNCTION, AX            ; return version number„  ! pop     DS                      ; restore DS„„END FUNCTION„Andrew Coggins                 PB NETBIOS                     rjohnso6@ix.netcom.com         09-01-96 (22:19)       PB                     430  19811    NETBIOS.BAS '==============================PBNETBIO.BAS================================„'This is public domain stuff, use at your own risk, etc. To test the use„'of the NetBios commands used to receive and send broadcast messages over„'a network. This sends ONE 80 character message to the other machine each„'time you hit "S" You must have registered an new name (and know its„'number) in the local name table before you can use the broadcast stuff.„'This is true for NetBIOS over NetBEUI in a DOS VDM in OS2 PEER. You may„'can avoid having to create a name in true DOS/NOVELL stuff. I don't have„'that so I can't test it. You only have to add a name once for your process„'to use it many times. (You should probably delete it when you finish your„'process because the name table is finite , but OS2 deletes it for me„'when I close the VDM so I don't worry about it. (I can't say enough good„'about OS2's accurate simulation of DOS (unlike Windoze XX)))„„'This does not check for the presence of a„'network. PB BBS has an example already that does that (PBLANT.ZIP).„'Another usefull document is Tom Thompson's NetBios Programmers Reference„'(1988 is the latest version I have) also on the PB BBS. This is meant„'mostly as an example of how to set up and talk to the NetBIOS (and as a„'result, the other computers). It wasn't meant to do anything useful, but„'if you run it on 2 computers when you hit the "S" key on one you'll see„'a string pop up on the other. I recommend single stepping if you want to„'see what is going on.„„'The basic operation of the program is:„'  1. Establish a name and get its number in the local name table„'  2. Go into Receive (no wait) mode (listen for broadcast from others)„'  3. Wait on local user (You) to hit "S" or ESC (to quit)„'  4. Upon S-key, cancel Receive, issue Send Broadcast, reissue Receive„'  5. Upon any receive, print what was received, and reissue receive.„„'OBTW - my name is Andy Coggins - I can be reached at„'rjohnso6@netcom.com. I am in the discovery phase w/ this stuff myself.„'But I could find NOTHING on this on ANY board/net/ftp/www so I decided„'to send this up because it worked as intended and maybe it will help„'somebody out. If you have anything that expands on this please let me„'know or post to the PowerBASIC site (support@powerpasic.com).„'======================================================================„%FLAGS = 0          'constants for register names„%AX    = 1„%BX    = 2„%CX    = 3„%DX    = 4„%SI    = 5„%DI    = 6„%BP    = 7„%DS    = 8„%ES    = 9„„'establish the Network Control block Type (64 bytes)„TYPE NCBType„  cmd AS BYTE             ' 1-command code„  rcode AS BYTE           ' 1-return code„  lsn AS BYTE             ' 1-Local Session Number„  locnum AS BYTE          ' 1-my name # in local name table (1)„  iobuff AS DWORD         ' 4-FAR Pointer to I/O Buffer„  bufflen AS WORD         ' 2-length of data in buffer„  callname AS STRING * 16 ' 16-remote system to call„  locname AS STRING * 16  ' 16-network name of local machine„  rectimout AS BYTE       ' 1-Recieve Time Out in 1/2 Seconds„  sentimout AS BYTE       ' 1-send Timeout in 1/2 second„  inthandl AS DWORD       ' 4-FAR Pointer to Post routine handler (0:0)„  cardnum AS BYTE         ' 1-Network Adapter number to execute command„  cmd_ccode AS BYTE       ' 1-Command Completion code„  dum AS STRING * 14      ' 14-reserved for use by Network Card Only„END TYPE„„'Initialize the NCB to all 0's (I assume they mean nulls in strings)„'You are supposed to clear the NCB each time you issue a new command„'(or use a different NCB)„'this should happen upon creation of the variable, so just copy„'what was created and that is my init value„DIM ncb AS SHARED NCBType               'working variable„DIM ncbinit AS SHARED NCBType           'initiazation value„„netname$ = "DELL 486-50"     'a unique name to add to the name table„„MAP iobuff$$ * 512         'use 512 buffer for broadcast messages„DIM buffaddr AS SHARED BYTE PTR          'pointer for string data„buffaddr = STRPTR32(iobuff$$)    '32bit address of data itself„„„CLS„'add unique name to name table and get the number returned by„'NetBIOS.„ncb = ncbinit               'clear the Network Control Block„PRINT "Adding Name will take approx 10 seconds (why, I don't know)"„CALL NCBAddName (ncb, netname$, xcode%)„IF xcode% THEN„  hexxcode$ = RIGHT$("00"+HEX$(xcode%),2)„  PRINT "We have a NetBIOS error - AL = ";hexxcode$;" (hex)  ";xcode%;" decimal"„  GOTO End.NTTest„ELSE„  PRINT "ADD Name was sucessful"„  PRINT "The Name ADDED was - ";ncb.locname„  PRINT "The Name NUMBER for this name is - ";ncb.locnum„  namenum? = ncb.locnum            'this is # to use for broadcast cmds„END IF„„„ncb = ncbinit               'must do to enter a command„rxcnt% = 0: txcnt% = 0      'just some status counters„„'set up receive mode on each computer„CALL NCBRcvBroadcast (ncb, buffaddr, namenum?, xcode%)„'CALL PrintNCB(ncb)              'just for testing„IF xcode% THEN„  hexxcode$ = RIGHT$("00"+HEX$(xcode%),2)„  PRINT "We have a NetBIOS error - AL = ";hexxcode$;" (hex)  ";xcode%;" decimal"„  CALL PrintNCB(ncb)            'just to see what changed in the NCB„  GOTO End.NTTest„END IF                          'error code on exit„„PRINT "Hit (S)end to send a broadcast, ESC to stop the program"„'This is the main program loop„choice$ = ""„WHILE choice$ <> CHR$(27)„  choice$ = INKEY$„  choice$ = UCASE$(choice$)„'  choice$ = "S"              'for single step testing„  IF choice$ = "S" THEN„    'cancel receive command„    CALL NCBCancel (ncb, xcode%)„'    CALL PrintNCB (ncb)„    IF xcode% THEN„      hexxcode$ = RIGHT$("00"+HEX$(xcode%),2)„      PRINT "We have a NetBIOS error - AL = ";hexxcode$;" (hex)  ";xcode%;" decimal"„      CALL PrintNCB(ncb)            'just to see what changed in the NCB„      GOTO End.NTTest„    END IF                        'xcode%„„  'initiate send command„    INCR txcnt%„    ncb = ncbinit                      'reinitialize ncb„    'use a dummy dynamic string (so you will know its length)„    'change the string each time so you can see some progress„    iobuff$ = STRING$(80, LTRIM$(STR$(txcnt% MOD 10)))„    CALL NCBSendBroadcast (ncb, buffaddr, namenum?, iobuff$, xcode%)„'    CALL PrintNCB (ncb)„    IF xcode% THEN„      hexxcode$ = RIGHT$("00"+HEX$(xcode%),2)„      PRINT "We have a NetBIOS error - AL = ";hexxcode$;" (hex)  ";xcode%;" decimal"„      CALL PrintNCB(ncb)            'just to see what changed in the NCB„      GOTO End.NTTest„    ELSE„      PRINT "Broadcast packet number - ";txcnt%„      PRINT iobuff$                'print what you sent„      'reissue receive command„      ncb = ncbinit„      CALL NCBRcvBroadcast (ncb, buffaddr, namenum?, xcode%)„      IF xcode% THEN„        hexxcode$ = RIGHT$("00"+HEX$(xcode%),2)„        PRINT "We have a NetBIOS error - AL = ";hexxcode$;" (hex)  ";xcode%;" decimal"„        CALL PrintNCB(ncb)            'just to see what changed in the NCB„        GOTO End.NTTest„      END IF                          'error code on exit„    END IF„„  ELSE                                'choice$ <> "s"„    'check for received message in no wait mode„    'print received message„    IF ncb.cmd_ccode = 255 THEN              '&HFF until completed„      LOCATE 24,1„      PRINT "Waiting on Send Broadcast from other computer - ";waitcnt&;„      INCR waitcnt&„    ELSEIF ncb.cmd_ccode = 0 THEN        'receive was successful„      INCR rxcnt%„      LOCATE 10,1„      PRINT "Receive packet number - ";USING$("#######",rxcnt%);" From ";ncb.callname„      msg$ = LEFT$(iobuff$$, ncb.bufflen)„      PRINT msg$„      msg$ = ""„      'reissue receive command„      ncb = ncbinit„      CALL NCBRcvBroadcast (ncb, buffaddr, namenum?, xcode%)„      IF xcode% THEN„        hexxcode$ = RIGHT$("00"+HEX$(xcode%),2)„        PRINT "We have a NetBIOS error - AL = ";hexxcode$;" (hex)  ";xcode%;" decimal"„        CALL PrintNCB(ncb)            'just to see what changed in the NCB„        GOTO End.NTTest„      END IF                          'error code on exit„    ELSE             'we had some netbios error - never happened in my test„      hexxcode$ = RIGHT$("00"+HEX$(ncb.cmd_ccode),2)„      PRINT "We have a NetBIOS error - AL = ";hexxcode$;" (hex)  ";xcode%;" decimal"„      CALL PrintNCB(ncb)            'just to see what changed in the NCB„      GOTO End.NTTest„    END IF                         'ncb.cmd_ccode„  END IF                         'choice$ = "s" or not„WEND„„End.Nttest:„PRINT "The program is finished - I hope you enjoyed this as much as I did"„END„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'Below are the Network generic routines.„'A routine to dump the Network Control Block to the Screen„SUB PrintNcb (ncb AS NCBType) LOCAL„  PRINT "This is the value in each NCB field"„„  PRINT "cmd = ";         ncb.cmd„  PRINT "rcode = ";       ncb.rcode„  PRINT "lsn = ";         ncb.lsn„  PRINT "locnum = ";      ncb.locnum„  PRINT "iobuff = ";      ncb.iobuff„  PRINT "bufflen = ";     ncb.bufflen„  PRINT "callname = ";    ncb.callname„  PRINT "locname = ";    ncb.locname„  PRINT "rectimout = ";  ncb.rectimout„  PRINT "sentimout = ";  ncb.sentimout„  PRINT "inthandl = ";   ncb.inthandl„  PRINT "cardnum = ";    ncb.cardnum„  PRINT "cmd_ccode = ";  ncb.cmd_ccode„  PRINT "dum = ";        ncb.dum„„  IF ncb.bufflen <> 0 THEN„    DIM x AS BYTE PTR                 'handle string 1 byte at a time„    x = ncb.iobuff             'transfer 32bit address of message buffer„    FOR count% = 1 TO ncb.bufflen  'read msg buffer 1 byte at a time„      inchar$ = CHR$(@x)           '@z points to an ASCII byte„      msg$ = msg$ + inchar$      'build a string for viewing in IDE„      INCR x                       ' increment the pointer itself„    NEXT count%„    PRINT "|" + msg$ + "|"„  END IF                          'anything in the io buffer?„END SUB                           'PrintNcb„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'display the NCB Status stuff. I got junk for the most of these, but that„'could be because of OS2's virtualization (or it could be me taking it„'apart wrong) I only wanted to look at the name table and I got that part„'right. If you want to get the rest of the status fields correct you„'need better documentation than I have. If you correct it, feel free to„'just replace this post w/ the correct stuff.„'This routine is not called in this program.„SUB DispNcbStatus (ncb AS NCBType, a$$) LOCAL„'a$$ is the global message buffer iobuff$$„'take apart the message buffer returned by the &H33 command to NetBios„'ie. show me satus of things„DIM y AS BYTE PTR        'a local byte pointer to walk down the string with„y = ncb.iobuff           'same as STRPTR32(a$$)„„namerows% = (ncb.bufflen - 60)\18„DIM Locname$(1:namerows%, 1:3)        'table for local names„„'there is probably an easier way to do this, but I don't need it,so„'I didn't spend time thinking about it.„nodename$ =               GimmeHex$(a$$, 1, 6)„jumpstat$ =               GimmeHex$(a$$, 7, 1)„post$ =                   GimmeHex$(a$$, 8, 1)„version$ =                GimmeHex$(a$$, 9, 2)„minrun$ =                 GimmeHex$(a$$, 11,2)„crcerr$ =                 GimmeHex$(a$$, 13,2)„alignerr$ =               GimmeHex$(a$$, 15,2)„coliderr$ =               GimmeHex$(a$$, 17,2)„aborterr$ =               GimmeHex$(a$$, 19,2)„txpacket$ =               GimmeHex$(a$$, 21,4)„rcpacket$ =               GimmeHex$(a$$, 25,4)„txretry$ =                GimmeHex$(a$$, 29,2)„rxnobuf$ =                GimmeHex$(a$$, 31,2)„dum1$ =                   GimmeHex$(a$$, 33,8)„freencb$ =                GimmeHex$(a$$, 41,2)„lastresetncb$ =           GimmeHex$(a$$, 43,2)„maxresetncb$ =            GimmeHex$(a$$, 45,2)„dum2$ =                   GimmeHex$(a$$, 47,4)„numsess$ =                GimmeHex$(a$$, 51,2)„lastresetsess$ =          GimmeHex$(a$$, 53,2)„maxresetsess$ =           GimmeHex$(a$$, 55,2)„maxpacketsize$ =          GimmeHex$(a$$, 57,2)„numnames$ =               GimmeHex$(a$$, 59,2)„'below are the local names„FOR i% = 0 TO namerows%-1„  Locname$(i%+1, 1) = MID$(a$$, 61+(18*i%),16)                    'local name„  Locname$(i%+1, 2) = LTRIM$(STR$(ASCII(MID$(a$$, 77+(18*i%),1)))) 'name #„  Locname$(i%+1, 3) = BinFmt$(ASCII(MID$(a$$, 78+(18*i%),1)),8)    'status„NEXT i%„„„PRINT "nodename$ = ";            nodename$;                          " ";„PRINT "jumpstat$ = ";            BimFmt$(VAL("&H"+jumpstat$),8);     " ";„PRINT "post$ = ";                VAL("&H"+post$);                    " ";„PRINT "version$ = ";             version$;                           " "„PRINT "minrun$ = ";              VAL("&H"+minrun$);                  " ";„PRINT "crcerr$ = ";              VAL("&H"+crcerr$);                  " ";„PRINT "alignerr$ = ";            VAL("&H"+alignerr$);                " ";„PRINT "coliderr$ = ";            VAL("&H"+coliderr$);                " ";„PRINT "aborterr$ = ";            VAL("&H"+aborterr$);                " "„PRINT "txpacket$ = ";            VAL("&H"+txpacket$);                " ";„PRINT "rcpacket$ = ";            VAL("&H"+rcpacket$);                " ";„PRINT "txretry$ = ";             VAL("&H"+txretry$);                 " ";„PRINT "rxnobuf$ = ";             VAL("&H"+rxnobuf$);                 " "„'PRINT "dum1$ = ";                dum1$„PRINT "freencb$ = ";             VAL("&H"+freencb$);                 " ";„PRINT "lastresetncb$ = ";        VAL("&H"+lastresetncb$);            " ";„PRINT "maxresetncb$ = ";         VAL("&H"+maxresetncb$);             " "„'PRINT "dum2$ = ";                dum2$„PRINT "numsess$ = ";             VAL("&H"+numsess$);                 " ";„PRINT "lastresetsess$ = ";       VAL("&H"+lastresetsess$);           " ";„PRINT "maxresetsess$ = ";        VAL("&H"+maxresetsess$);            " ";„PRINT "maxpacketsize$ = ";       VAL("&H"+maxpacketsize$);           " ";„PRINT "numnames$ = ";            VAL("&H"+numnames$);                " "„PRINT„PRINT " LOCAL Name Table follows"„'below are the local names„FOR i% = 0 TO namerows%-1„  PRINT "Name = ";Locname$(i%+1, 1);                                 " ";„  PRINT "NameNum = ";Locname$(i%+1, 2);                              " ";„  PRINT "Status = ";Locname$(i%+1, 3);                               " "„NEXT i%„„END SUB                                    'DispNcbStatus„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'to look at the binary representation of a value (from PB3 help)„FUNCTION BinFmt$(value&,size%) ' returns a binary string of size% digits„  BinFmt$ = RIGHT$("000000000000000"+BIN$(value&),size%)„END FUNCTION                         'BinFmt$„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'not used in this program (used by the DispNcbStatus routine)„FUNCTION GimmeHex$(a$$, start%, length%)„  'since y is pointing to 1st byte already, we want to hand it a start% = 1„  '(like MID$) but we don't want to add 1 to it. If we want it to start at„  'position 7 we want to add 6 to it.„  DIM y AS BYTE PTR„  y = STRPTR32(a$$)„„  INCR y, start%-1„  FOR i% = 1 TO length%„    a$ = a$ + RIGHT$("00"+HEX$(@y),2)„    INCR y„  NEXT i%„  FUNCTION = a$„END FUNCTION                          'GimmeHex$„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'just to consolidate code the call and the associated return value„'are passed to and from this routine„SUB CallNcb (ncb AS NCBType, rcode%) LOCAL„ncbseg?? = VARSEG(ncb)                  'find our typed var in memory„'ncbseghex$ = HEX$(ncbseg??)„ncbofs?? = VARPTR(ncb)„'ncbofshex$ = HEX$(ncbofs??)„„REG %ES, ncbseg??„REG %BX, ncbofs??„CALL INTERRUPT &H5C„AL?? = REG(%AX) AND &H00FF„rcode% = AL??                  'AL = 0 means no error„„END SUB                                'Call Ncb„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'not used in this routine„SUB CheckAddapterStatus (ncb AS NCBType, buffaddr AS DWORD, rcode%) LOCAL„„ncb.cmd = &h033                        'send a broadcast in wait mode„ncb.cardnum = 0             'send message from 1st network card in machine„ncb.callname = "*"                     'use my local call name„ncb.iobuff = buffaddr                  '32 bit address of the msg buffer„ncb.bufflen = 512                      'length of the message buffer„„CALL CallNcb (ncb, rcode%)„„END SUB                                  ' CheckAddapterStatus„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'add a name to the local name table„SUB NCBAddName(ncb AS NCBType, addname$, rcode%) LOCAL„ncb.cmd = &H030            'add name command - wait mode„„ncb.cardnum = 0             'use 1st network card in machine„ncb.locname = addname$     'name to add„„CALL CallNcb (ncb, rcode%)„„END SUB                                  'NCBAddName„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'delete a name from the local name table„SUB NCBDeleteName(ncb AS NCBType, delname$, rcode%) LOCAL„ncb.cmd = &H031            'delete name command - wait mode„„ncb.cardnum = 0             'use 1st network card in machine„ncb.locname = delname$„„CALL CallNcb (ncb, rcode%)„„END SUB                                  'NCBDeleteName„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'set up to receive, use no wait mode so you can do other things„'like get operator input. (you can keep checking for„'ncb.cmd_ccode <> &HFF to see if you received anything)„SUB NCBRcvBroadcast(ncb AS NCBType, buffaddr AS DWORD, namenum?, rcode%) LOCAL„'ncb.cmd = &H023            'receive command - wait mode„ncb.cmd = &H0A3            'receive command - nowait mode„„ncb.cardnum = 0             'use 1st network card in machine„ncb.locnum = namenum?       'my number in local name table„ncb.iobuff = buffaddr      '32 bit address of the msg buffer„ncb.bufflen = 512          'default (max) length of the message buffer„„CALL CallNcb (ncb, rcode%)„„END SUB                                  'Receive Broadcast„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'send a broadcast to EVERYBODY that has any kind of receive broadcast„'issued (I'm sure this could screw up some complex programs)„SUB NCBSendBroadcast(ncb AS NCBType, buffaddr AS DWORD, namenum?, iobuff$, rcode%) LOCAL„SHARED iobuff$$„ncb.cmd = &H022            'send command - wait mode„„ncb.cardnum = 0             'use 1st network card in machine„ncb.locnum = namenum?      'my position in local name table„ncb.iobuff = buffaddr      '32 bit address of the msg buffer„iobuff$$ = iobuff$„ncb.bufflen = LEN(iobuff$)    'length of the message to send„„„CALL CallNcb (ncb, rcode%)„„END SUB                                  'Send Broadcast„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'must cancel an unfinished command issued by a ncb before using„'THAT ncb for another command (you wouldn't believe how things bombed„'when I didn't cancel receive before I tried to send)„'I used wait mode (it was instantaneous)„SUB NCBCancel(ncb AS NCBType, rcode%) LOCAL„ncb.cmd = &H035            'cancel command for this ncb - wait mode„„ncb.cardnum = 0             'use 1st network card in machine„„CALL CallNcb (ncb, rcode%)„'I think OS/2 returns a 24h (36) (command competed before could cancel) to„'cancel a receive broadcast command, so I will treat this as no error.„IF rcode% = 36 THEN rcode% = 0„END SUB                                  'NCBCancel„''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„