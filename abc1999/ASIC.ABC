Dan Autery                     DOS COMMANDS V2.0 FOR ASIC     Autery@aol.com                 03-03-99 (17:51)       ASIC                   180  6866     GETCOMS2.ASIrem   GETCOMS2.ASI -- An expansion on John Kiernan's example program,„rem   GETCOMSP.ASI.„rem„rem   The following shows how to expand the limit of your argument length„rem   (when doing DOS calls) from 29 characters to 74 characters. :]„rem„rem   Kudos and thanks to JohnK for his earlier examples and many ASIC„rem   source code snippets. :)  Much of the following comes directly„rem   from his example programs.  This addendum is meant simply as an„rem   expansion of John's outstanding work and all credit for the code„rem   should go to him.. :>„„rem   BEGIN QUOTE from GETCOMSP.ASI:„rem   This code:„rem   ===========„rem     (a) teaches the use of CALL for using internal DOS commands within„rem         an executable file. Much easier with ASIC than with QuickBasic!„rem         and it compiles to less than a tenth the size of a QB executable„rem         file.„rem     (b) shows how to make and write to a simple text file without„rem         having to bother with "OPEN" and "CLOSE"„rem   ===========„rem     Format 1 of ASIC's CALL command allows you to carry out internal„rem     and external DOS commands in a .COM or .EXE program made by ASIC.„rem     The syntax of Format 1 is  CALL (string1,string2)  where string1 is„rem     the full name of an executable program, and string2 contains its„rem     argument(s), including a leading space and any switches, etc.„rem  ============„rem     To run an internal DOS command (also, to run a batch file),„rem     string1 must be the current COMSPEC, found in the DOS "environment"„rem       You could change Env=30000 to Env=30 without offending anyone but„rem       the most eccentric batch file zealot! However, allowing for a huge„rem       environment does not enlarge or slow down the compiled program.„rem   ===========„       FOR Env = 1 TO 30000„           Env$=ENVIRON$(Env)„             Comsp=INSTR(Env$,"COMSPEC")„               IF Comsp > 0 THEN„                 Comspec$=Env$„                 GOTO GotIt:„               ENDIF„       NEXT Env„                rem  The program cannot get this far (unless you have been„                rem  silly and have removed the COMSPEC statement from the„                rem  environment.„       PRINT "Couldn't find COMSPEC - This should be utterly impossible."„       GOTO Finished:„rem                     The next lines extract the COMSPEC„rem                     (after the = sign) and display it.„   GotIt:„       Length=LEN(Comspec$)„       EqualsPos=INSTR(Comspec$,"=")„       ComspLength=Length-EqualsPos„       Comspec$=RIGHT$(Comspec$,ComspLength)„       PRINT Comspec$„rem                     Pause the screen display„       PRINT "Press any key to continue . . ."„   Wait:„       Key$=INKEY$„         IF Key$="" THEN Wait:„rem                            Comspec$ shows which command processor you„rem                            are using. This may not be C:\COMMAND.COM.„rem                            See NOTES_AT_END:„rem   * ASIC's  CALL  is used to invoke DOS internal commands.      *„rem   * Spaces around /C matter a lot!  You can't add the " /C" to  *„rem   * the  Comspec$  variable.   The  /C  (with space before and  *„rem   * after) MUST be in the second part (string2) of the argument *„rem   * that follows CALL.  See also NOTES_AT_END:                  *„         CALL (Comspec$," /C dir/w")„         CALL (Comspec$," /C ver")„         CALL (Comspec$," /C path")„rem   ===========„rem  The argument following the /C  can be quite complicated,„rem  BUT IT CANNOT BE VERY LONG - an annoyance, mentioned in the„rem  commented code that follows.„ CALL (Comspec$," /C echo 12345678901234567890123456789012345678901234567890")„ PRINT " Only the first 24 of these numerals are displayed on the screen."„rem   ===========„„rem  END QUOTE:„„rem  ======================================================================„rem  The reason for the above 24 character limit is due to the [space]„rem  character at the beginning of the string being used for the call.„rem  The ascii value of " " is 32, which tells DOS that the amount of text„rem  in the following argument is 32 characters.„rem„rem  If you count them up, "/C echo 123456...etc" comes to significantly„rem  more than this.  The "/C echo " portion eats up 8 of those characters,„rem  leaving you with exactly 24 of your original 32 character allotment.„rem„rem  To expand the size limit of your argument, use the formal argument „rem  passing paramaters of Format 1:„rem„rem  See the "Do_the_call" subroutine to find out how the formal version„rem  is put together.„„Examples:„  GOSUB keys:„  PRINT„  PRINT "Using the FORMAL calling conventions, you have much"„  PRINT "more to work with:"„  „  rem -- echo (lots of) text to the screen:„„  Argument$="echo 12345678901234567890123456789012345678901234567890"„    GOSUB Do_the_call:„    GOSUB keys:„„  rem -- get an ordered list of all directories in the current directory:„„  Argument$="dir /a:d/o/p"„    GOSUB Do_the_call:„    GOSUB keys:„„  rem -- get an ordered list of all files other than directories„  rem    and display it in wide format on the screen, one page at a time:„„  Argument$="dir /a:-d/o/w/p"„    GOSUB Do_the_call:„    GOSUB keys:„  „  rem -- get a list of all files and directories in our windows directory,„  rem    in alphabetical order, save them to a file (that we can use„  rem    later), and print the contents of the file to the screen:„„   Key$=FIND FIRST("~files.txt",0)„   IF ERROR>0 THEN„„     Argument$="dir /o/b c:\windows\*.* > ~files.txt"„       GOSUB Do_the_call:„„     Argument$="type ~files.txt |more"„       GOSUB Do_the_call:„       KILL "~files.txt"„       GOSUB keys:„„   ENDIF„„„   Finished:„     CLS„     END„„„   rem -- Adds required parameters for calling formally via Format 1:„   Do_the_call:„„     CR$ = CHR$(13)„     Argument$ = "/C " + Argument$„     arglength = LEN(Argument$)„     firstchr$ = CHR$(arglenth)„     Argument$ = firstchr$ + Argument$„     Argument$ = Argument$ + CR$„„     IF arglength>74 THEN„       rem ---- Safety Net ----„       PRINT "Sorry.. That argument is too long."„     ELSE„       CALL Comspec$, Argument$„     ENDIF„„   RETURN„„„   keys:„     Key$=INKEY$„       IF Key$="" THEN keys:„     RETURN„„rem  As you'll see, the above routines work with tons of room to spare. :]„„rem  ASIC limits strings to 79 characters, and you need 3 of these for„rem  the "/C ", 1 for the CR$, and 1 for the "firstchar$", so the limit„rem  for this format is a max argument length of 74 characters.. :]„„rem  Still.. that's a far sight better than the 29 character limitation„rem  imposed by using informal calls. :>„„rem  ======================================================================„Dan Autery                     ASSEMBLY V2.0 IN ASIC          Autery@aol.com                 03-03-99 (17:51)       ASIC                   138  5821     ASEMASI2.ASIREM *** ASEMASI2.ASI -- ASSEMBLY in ASIC 5.0„REM *** Demonstration of the power of the ASIC "CODE" statement.„REM  ' Fast assembly language screen poking routine (pokes words)„REM ***„REM *** Donated to the Public Domain by Dan Autery (autery@aol.com)„REM ***„REM *** This is an update of the "linedraw" assembly language routine I„REM *** posted in the last issue. :>  This version is optimized for faster„REM *** writing (not that the last was all that slow). :>  It also has the„REM *** loop (for doing more than one line) built directly into the„REM *** assembly routine, so there's no longer a need to push and pop ES„REM *** after each line is drawn.  This routine is currently optimized„REM *** for drawing lines or boxes in SCREEN 0, on systems that use a color„REM *** (not monochrome) video card.  ES should be modified if you wish to„REM *** use the routine for other video modes (and the value added to DI„REM *** should be changed from 160 to the new screen width if you use this„REM *** in a video mode that uses more or less than 160 bytes per scanline).„REM ***„REM *** As with any code snippet that I've donated to the ABC archives,„REM *** feel free to use this in any way you wish.  If you'd like to„REM *** give me credit in your programs for the work, I sure won't object,„REM *** but there's no obligation at all to do so. :]„„GOTO Examples:„„REM  ' ES=segment, DI=offset, AX=2-byte value to move, CX=#words to copy„REM  ' DX=# of lines to write.„REM  ' Your program should supply AX, CX, DX, and DI.„REM  ' Uses registers AX,CX,DX,DI,ES„„linedraw:„ ES=&hexB800„ CODE 6„ SETREGS(AX,na,CX,DX,DI,na,na,na,ES)„ CODE 87,81,243,171,89,95,129,199,160,0,74,117,243,7„ GETREGS(na,na,na,na,DI,na,na,na,na)„RETURN„„„REM  ' The following shows how the linedraw code statements were derived:„REM  ' "Absolute Assembly v2.0" was used to get the QBASIC codes:„„REM (DEBUG OUTPUT)   (ASIC CODE)  (ASM Code)          (Notes)„REM       06              6        PUSH ES         ;Save ES (then use SETREGS)„REM       57             87        Writer: PUSH DI ;Save new Offset„REM       51             81        PUSH CX         ;Save CX (counter)„REM       F3             243       REPZ            ;Repeat next until CX=0„REM       AB             171       STOSW           ;Do the copy„REM       59             89        POP CX          ;Restore Counter„REM       5F             95        POP DI          ;Restore last Offset„REM    81C7A000     129,199,160,0  ADD DI,00A0     ;And bump it to next line„REM       4A             74        DEC DX          ;Decrement our row counter„REM      75F3          117,243     JNZ Writer      ;Not 0? Jump to writer:„REM       07              7        POP ES          ;Yes 0? All done.„„REM  As you'll see from the subroutine, I've used GETREGS to find„REM  the value of DI when the routine is finished.  This is handy for„REM  finding the offset of the line directly below the last one drawn,„REM  in case you want to write to it immediately afterwards.„„REM  ' Quick Explanation:„REM  ' The starting offset (DI) is determined by (ROW*160) + (COLUMN * 2).„REM  ' The word itself is stored in AX.„„REM  ' AX = (((BackgroundColor*16)+ForegroundColor)*256)+(ASCII value of text)„REM  ' Thus, if you wanted "Õ" in white characters on a blue background,„REM  ' AX would be (23*256)+205 = 6093„„„Examples:„  REM -- First, I want to draw a solid white line at the top of the screen:„„  REM Set our background color to white, foreground to black ((7*16)+0)*256„  AX=28672„  REM Add Ascii value of a " " (space) character:„  AX=AX+32„  REM Set width to 80 (80 words = 160 bytes)„  CX=80„  REM Set rows to 1„  DX=1„  REM Set initial offset to 0 (for top of screen)„  DI=0„„  GOSUB linedraw:„„  REM -- I want the next 23 lines to be a solid blue.  Since we're using„  REM -- the entire screen width, we can leave DX at 1 and just use a higher„  REM -- value of CX to accomplish this.  DI (our offset) is currently„  REM -- sitting at 160 (because of GETREGS), which is where we want to be,„  REM -- so we just need to change AX and CX.„„  REM Change AX to black letters on a blue background: ((1*16)+0)*256„  AX=4096„  REM Add the space character:„  AX=AX+32„  REM Change CX to write 23 rows:„  CX=80*23„„  GOSUB linedraw:„„  REM Let's make the last line white characters on a blue background:„  REM AX = ((1*16)+7)*256„  AX=5888„  REM And add the "Õ" character:„  AX=AX+205„  REM Change CX back to 80 (we only want to draw one row this time):„  CX=80„„  REM We need to change DI here because it's currently sitting at 320.. :>„  REM Remember, even though you've written 23 lines, the starting offset„  REM (160) was saved when linedraw was last called, then restored„  REM and incremented by 160 at the end of the loop.  We've only actually„  REM done one loop (DX=1) as far as the routine was concerned.„„  REM If the routine had been called with "CX=80, DX=23", DI would„  REM be at the correct offset, but it's much faster to draw an entire„  REM screen all at once than to execute a loop 23 times.  The loop is„  REM best used for lines or boxes that are less than the full width„  REM of the screen.„„  REM Since we want to draw the 24th row, (of 0 to 24), do the following:„„  DI=24*160„  GOSUB linedraw:„„  REM And the entire screen is drawn -- faster than CLS, and much, much„  REM faster than using PRINT and COLOR statements to create the above„  REM effects.  It's also faster (and less expensive in program size) than„  REM using POKEs to write directly to the screen because the routine„  REM removes the need to use FOR,NEXT or WHILE,WEND loops and DEFSEG„  REM statements.„„  keys:„    key$=INKEY$„    IF key$="" THEN keys:„„  CLS„  END„Dan Autery                     CAPTURE SCREEN 13 TO PCX       Autery@aol.com                 03-03-99 (17:51)       ASIC                   311  8151     SCRN2PCX.ASIREM *   SCRN2PCX.ASI -- ASIC 5.0 Screen Capture Routine, by Dan Autery,„REM *                 for capturing full-screen, 256-color images,„REM *                 (in SCREEN 13) and saving them to PCX format. :>„REM *„REM *   Compile with EXTENDED MATH and DECIMAL MATH options on. :]„REM *„REM *   ASIC vs. QBASIC Notes:„REM *„REM *   ASIC Variable identifiers:„REM *   & denotes a 4-byte DWORD„REM *   @ denotes an 8-byte value (double-DWORD/extended math operator)„REM *   $ denotes a string (variable)„REM *   Variables w/out identifiers are 2-byte WORDs„REM *   All variables in ASIC (other than strings) are signed„REM *   All ASIC arrays are 1-dimensional STATIC arrays, with an LBOUND„REM *   of 0 and a UBOUND determined by the DIM statement.„REM *„REM *   Although the labeled subroutines in ASIC aren't commonly found„REM *   in that format in QBASIC, they are supported by that program, as„REM *   are GOSUB and GOTO.  The format just isn't seen that often, since„REM *   most QBASIC programming stresses using the structure of true SUBs.„REM *„REM *   It's possible to do the same sort of structuring in ASIC, but it„REM *   requires compiling each individual subroutine into an OBJ file and„REM *   linking it with LINK.EXE (which isn't all that easy to find anymore).„REM *   All in all, for ASIC programs at least, the label, GOTO, and GOSUB„REM *   formats are generally sufficient for getting the job done. :>„REM *„REM *   Dan Autery (autery@aol.com)„„rem -- iarray is used to hold our current palette:„ DIM iarray@(96)„rem -- Data for writing PCX header:„ DATA 134284554&,0&,319,199,320,200,256,320&,320,200&,0&„rem -- Offset to the beginning of our palette array:„ iarrayptr=VARPTR(iarray@(1))„rem -- Offset of iarray element (0) -> (used for writing):„ spotptr=iarrayptr-8„„rem -- Make sure the current system uses a color video card:„ SCREEN 0„ ALT=ZMODE„ IF ALT<>1 THEN„   PRINT " This program requires a Color Video Card."„   END„ ENDIF„„main:„  rem -- Your main program code goes here:„„  SCREEN 13„„  rem -- Before you do a screen capture with the following subroutine,„  rem -- you should be in screen mode 13 (320x200x256), and should„  rem -- have a suitable image on screen.. :>„„  rem -- Display your image (and save the palette to iarray()) here:„„  rem -- For 256-color PCX files, you could just read the whole„  rem -- palette directly into your array by doing something like this:„  rem„  rem  AB&=FILELEN(myfile$)„  rem  AB&=AB&-768&„  rem  AB&=FILEPOS(1,AB&)„  rem  FOR DO=1 TO 96„  rem    INPUT# 1,iarray@(DO)„  rem    GOSUB errorcheck:„  rem  NEXT DO„  rem„  rem -- This sets the palette up to be written whenever needed.„  rem -- In this case, though, the above would be a bit redundant,„  rem -- since you'd be doing a PCX screen capture of a PCX file.. ;p„  rem -- But it does give the general idea. :]„„  GOSUB scrn2pcx:„  „  rem -- More program code, as desired:„„  rem -- Normal exit:„  ALT=0„„rem -- Clean things up, reset screen mode, and give error notice if needed:„quit:„ KILL "~f1.tmp"„ SCREEN 0„ IF ALT<>0 THEN„   GOSUB close1:„   LOCATE 11,21„   PRINT "Program terminated prematurely.."„ ENDIF„ END„„REM  '****************** SCREEN 13 to PCX WRITER ******************'„„scrn2pcx:„„ OPEN "O",2,"~f1.tmp"„ rem -- Safety Net --„ IF ERROR>0 THEN„     rem -- This should only happen if Disk Full or Disk Write Protected:„     LOCATE 20,1„     PRINT "Error: Unable to open temp file."„     GOSUB keys:„     RETURN„ ENDIF„„ REM ************* Find the first available file name *************„„ rem -- Gives 10,000 possible names (VIEW0000.PCX to VIEW9999.PCX):„ rem -- Avoids over-writing PCX files that are already in the directory.„„ t=10000„ key$="VIEW"„ WHILE t<20000„   A$=STR$(t)„   A$=RIGHT$(A$,4)„   A$=key$+A$„   A$=A$+".PCX"„   byt$=FIND FIRST(A$,0)„   IF ERROR=0 THEN„     t=t+1„   ELSE„     t=20000„   ENDIF„ WEND„„ IF byt$<>"" THEN„   LOCATE 20,1„   PRINT "No free file names are available!"„   GOSUB keys:„   RETURN„ ENDIF„ „ REM ***************** First, write the PCX header *****************„„ rem -- One nice thing about ASIC is that you can place *any* kind of„ rem -- data in DATA statements, then read it out in a different format.„ rem -- In this case, I've stored the data using a combination of 4-byte„ rem -- DWORDS and 2-byte WORDS, but I'm reading it out 2 DWORDS at a„ rem -- time as 8-byte decimal values:„ FOR t=1 TO 4„   READ iarray@(0)„   PRINT# 2,iarray@(0)„   GOSUB errorcheck:„   IF t=2 THEN„     byt$=STRING$(48,"0")„     GOSUB byteme:„   ENDIF„ NEXT t„ RESTORE„ FOR t=1 TO 6„   PRINT# 2,0@„   GOSUB errorcheck:„ NEXT t„„ REM ******************* Now write the PCX image *******************„„ rem -- The following algorithm reads and decodes one row at a time from„ rem -- the screen, does the PCX run-length-encoded compression, and„ rem -- writes to the file as needed:„ Arg&=0„ neg=0„ FOR t=1 TO 200„   counter=0„   n=0„   WHILE n<=320„     n=n+1„     IF n<=320 THEN„       DEFSEG=&hexA000„       newval=PEEK(Arg&)„       Arg&=Arg&+1&„       DEFSEG=-1„     ELSE„       newval=newval+1„     ENDIF„     IF counter=0 THEN„       firstval=newval„     ENDIF„     IF newval<>firstval THEN„       p=255„       WHILE counter>63„         counter=counter-63„         GOSUB write_neg:„       WEND„       IF counter>1 then„         p=192+counter„         GOSUB write_neg:„       ELSE„         IF firstval>191 THEN„           p=193„           GOSUB write_neg:„         ELSE„           GOSUB print_neg:„         ENDIF„       ENDIF„       firstval=newval„       counter=0„     ENDIF„     counter=counter+1„   WEND„ NEXT t„„ rem -- Add the "12" that comes just before the palette:„ value=12„ GOSUB write_ac:„„ rem -- Write any leftover bytes in iarray@(0):„ IF neg>0 THEN„   neg=neg-1„   FOR num=0 TO neg„     place=spotptr+num„     value=PEEK(place)„     byt$=CHR$(value)„     GOSUB byteme:„   NEXT num„ ENDIF„„ REM ********* Now wrap up the image by writing the palette **********„„ rem -- Assume a full 256 color (768-byte) palette:„ FOR t=1 TO 96„   PRINT# 2,iarray@(t)„   GOSUB errorcheck:„ NEXT t„„ REM ********************* And give it a new name *********************„„ CLOSE 2„ NAME "~f1.tmp" AS A$„ IF ERROR=0 THEN„   rem -- make a sound to show that we're done: 8]„   SOUND 3000,50„   SOUND 1500,128„ ELSE„   rem -- else, kill the temp file and tell the user there was an error:„   KILL "~f1.tmp"„   LOCATE 20,1„   PRINT "Error: Unable to name PCX file correctly."„   GOSUB keys:„ ENDIF„ byt$=""„RETURN„„ REM **************************** ALL DONE! ***************************„„write_neg:„  value=p„  GOSUB write_ac:„  GOSUB print_neg:„RETURN„„print_neg:„  value=firstval„  GOSUB write_ac:„RETURN„„rem -- POKEs values to our I/O element, iarray@(0), then prints to file„rem -- whenever eight bytes are written.  We're using a Double-DWORD„rem -- here since it allows for the fastest writing possible in ASIC,„rem -- outside of an assembly routine.  If ASIC allowed nul characters„rem -- in a string, we'd use a string here and write 78 bytes or so„rem -- at a time.„write_ac:„  place=spotptr+neg„  POKE place,value„  neg=neg+1„  IF neg=8 THEN„    PRINT# 2,iarray@(0)„    GOSUB errorcheck:„    neg=0„  ENDIF„RETURN„„rem -- writes single byte value or nul (0), as appropriate:„byteme:„  IF byt$="" THEN„    PRINT# 2,byt$„  ELSE„    PRINT# 2,byt$ NONULL„  ENDIF„  GOSUB errorcheck:„RETURN„„REM  '**********************END PCX WRITER*********************'„„rem -- simple "wait for user input" routine:„keys:„ key$=INKEY$„   IF key$="" THEN keys:„RETURN„„rem -- Error-Handling:„errorcheck:„ IF ERROR>0 THEN„   SCREEN 0„   COLOR 7,0„   PRINT„   PRINT " Error: ";„   IF ERROR=255 THEN„     PRINT "Disk is Full!"„   ELSE„     PRINT "Code =";„     PRINT ERROR„   ENDIF„   CLOSE 2„   LOCATE 23,2„   PRINT "Press a key to continue";„   GOSUB keys:„   GOTO quit:„ ENDIF„RETURN„Dan Autery                     GET PROGRAM STARTUP LOCATION   Autery@aol.com                 04-16-99 (15:55)       ASIC                   198  9026     PROGLOC.ASI REM *** PROGLOC.ASI -- Get Program Startup Location„REM *** Donated to the Public Domain by Dan Autery (autery@aol.com)„REM ***„REM *** Code based on FILESPEC.BAS, by Ronny Ong„REM ***„REM *** The following snippets show two routines for getting the startup„REM *** directory of your EXE program.  This information is handy for a„REM *** number of reasons.  In the examples below, the routines return„REM *** the path name of the data file where this program's user-„REM *** preferences are stored.  This allows the program to always find„REM *** and/or write to the correct file.„REM ***„REM *** The first routine is a plain, ASIC 5.0, adaptation of FILESPEC.BAS„REM *** The second routine is an Assembly level version of the above.„REM *** You'll find that the latter compiles to a MUCH smaller size than„REM *** the former (and is faster as well). ;)„„REM *** First, find the program's DATA segment:  This GETREGS routine„REM *** _must_ be placed at the VERY beginning of your ASIC program„REM *** (immediately after any REM, DIM, or DATA statements). Placing it„REM *** later in your code could have potentially harmful results..„„GETREGS(na,na,na,na,na,na,na,DS,na)„Dseg=DS„„REM 'Gets the location (directory) of this program and puts it in progname$„progloc: „ AX=&Hex6200„ REM ** Calls DOS interrupt 21 (hex), service 6200 (hex) (GET PSP)„ Int86(&hex21,AX,BX,Na,Na,Na,Na,Na,Na,Na)„ DEFSEG=BX„ num=PEEK(&hex2D)„ AB&=num„ AB&=AB&*256&„ num=PEEK(&hex2C)„ AT&=num„ AB&=AB&+AT&„ DEFSEG=AB&„„ REM ** The following assembles the complete path & name:„ n=1„ progname$=""„ value=0„ WHILE n=1„   num=PEEK(value)„   value=value+1„   IF num=0 THEN„     num=PEEK(value)„     IF num=0 THEN„       value=value+3„       num=PEEK(value)„       WHILE num<>0„         value=value+1„         key$=CHR$(num)„         progname$=progname$+key$„         num=PEEK(value)„       WEND„       n=0„     ENDIF„   ENDIF„   IF value<0 THEN„     n=0„   ENDIF„ WEND„„ REM ** At this point, progname$ contains the path\name of your program„ REM ** Since ASIC strings can only be 79 bytes, though, let's double-check„ REM ** to make sure our progname$ is valid:„ key$=FIND FIRST(progname$,0)„ IF ERROR=0 THEN„   n=LEN(progname$)„ ENDIF„„ REM ** This next routine finds the length of our string, minus the name„ REM ** of the EXE file (to allow us to extract the directory name).„ num=0„ IF n>0 THEN„   WHILE n>0„     n=n-1„     key$=MID$(progname$,n,1)„     IF key$="\" THEN„       num=n„       n=n-1„       key$=MID$(progname$,n,1)„„ REM ** While the following ~might~ not be necessary, it's here to trap„ REM ** any odd startup strings.  For example, if a person were to start„ REM ** your program from one directory up by typing "..\prog.exe",„ REM ** progname$ could be: "c:\mydir\..\prog.exe".„ REM ** If found, this adjusts the string length to compensate.„       IF key$<>"." THEN„         n=0„       ENDIF„     ENDIF„   WEND„ ENDIF„„ REM ** Again, we're checking the length of our string because of the„ REM ** ASIC '79 character' string limitation (grrr!). Since the DAT file„ REM ** name is 8 characters, the path can be no longer than 71 chars.„ IF num>71 THEN„   num=0„ ENDIF„ progname$=LEFT$(progname$,num)„ progname$=progname$+"prefs.dat"„ DEFSEG=-1„RETURN„„„REM 'This is the Assembly level (machine language) version of the above.„REM 'The actual Assembly commands used to create this are shown below.„progloc_asm:„ DI=VARPTR(progname$)„ ES=Dseg„ CODE 30,6„ SETREGS(na,na,na,na,DI,na,na,na,ES)„ CODE 6,87,49,192,170,180,98,205,33,142,219,190,44,0,173,142,192,6,31,49„ CODE 255,185,0,128,49,192,242,174,117,54,174,117,249,71,71,185,79,0,137,203„ CODE 87,94,242,174,117,38,41,203,137,217,95,7,6,87,243,164,253,137,217,176„ CODE 92,242,174,87,79,184,46,46,175,95,117,6,176,92,242,174,242,174,252„ CODE 71,71,176,0,170,95,7,7,31„„ REM 'progname$ now contains the complete path (minus the exe name)„ REM 'of your program.„„ num=LEN(progname$)„ IF num>71 THEN„   progname$=""„ ENDIF„ progname$=progname$+"prefs.dat"„RETURN„„REM  QB CALL ABS CODES   ASM CODES         ASIC CODES   NOTES„REM (&H1E)              ' PUSH DS             30„REM (&H6)               ' PUSH ES             6„REM           *** USE SETREGS(na,na,na,na,DI,na,na,na,ES) HERE ***„REM (&H6)               ' PUSH ES             6         save (new) ES„REM (&H57)              ' PUSH DI             87        save (new) DI„REM (&H31)+(&HC0)       ' XOR AX,AX           49,192    AX=0„REM (&HAA)              ' STOSB               170       nul progname$ string„REM (&HB4)+(&H62)       ' MOV AH,62           180,98    AX=6200h„REM (&HCD)+(&H21)       ' INT 21              205,33    call the interrupt„REM (&H8E)+(&HDB)       ' MOV DS,BX           142,219   DS=PSP„REM (&HBE)+(&H2C)+(&H0) ' MOV SI,002C         190,44,0  SI=2Ch„REM (&HAD)              ' LODSW               173       Get the entire word„REM (&H8E)+(&HC0)       ' MOV ES,AX           142,192   and put it into ES„REM (&H6)               ' PUSH ES             6         Copy ES to DS (for later)„REM (&H1F)              ' POP DS              31        ..via the stack„REM (&H31)+(&HFF)       ' XOR DI,DI           49,255    DI=0„REM (&HB9)+(&H0)+(&H80) ' MOV CX,8000         185,0,128 CX=32K (max env size)„REM (&H31)+(&HC0)       ' XOR AX,AX           49,192    AX=0„REM (&HF2)              ' Again: REPNZ        242       repeat while AL is„REM (&HAE)              ' SCASB               174       NOT equal to ES:DI„REM (&H75)+(&H36)       ' JNZ Exit            117,54    If No match, then exit„REM (&HAE)              ' SCASB               174       Is next byte zero?„REM (&H75)+(&HF9)       ' JNZ Again           117,249   No? Repeat search.„REM (&H47)              ' INC DI              71        skip two bytes„REM (&H47)              ' INC DI              71        after the '00'„REM (&HB9)+(&H4F)+(&H0) ' MOV CX,004F         185,79,0  Max string len=79„REM (&H89)+(&HCB)       ' MOV BX,CX           137,203   Copy to BX for later„REM (&H57)              ' PUSH DI             87        Copy DI to SI„REM (&H5E)              ' POP SI              94        ..via the stack„REM (&HF2)              ' REPNZ               242       Searching for nul terminator„REM (&HAE)              ' SCASB               174       Do the search„REM (&H75)+(&H26)       ' JNZ Exit            117,38    No match? Then exit.„REM (&H29)+(&HCB)       ' SUB BX,CX           41,203    Get our string size„REM (&H89)+(&HD9)       ' MOV CX,BX           137,217   And put it in CX„REM (&H5F)              ' POP DI              95        Restore string pointer„REM (&H7)               ' POP ES              7         And program segment„REM (&H6)               ' PUSH ES             6         Save 'em (needed, since„REM (&H57)              ' PUSH DI             87        we're popping them later)„REM (&HF3)              ' REPZ                243       Copy 'CX' bytes„REM (&HA4)              ' MOVSB               164       From DS:SI to ES:DI„REM (&HFD)              ' STD                 253       Set direction flag for backward scan„REM (&H89)+(&HD9)       ' MOV CX,BX           137,217   Restore string size„REM (&HB0)+(&H5C)       ' MOV AL,5C           176,92    Looking for "\"„REM (&HF2)              ' REPNZ               242       Repeat while ES:DI„REM (&HAE)              ' SCASB               174       is NOT equal to AL„REM (&H57)              ' PUSH DI             87        Save DI„REM (&H4F)              ' DEC DI              79        Odd, but needed„REM (&HB8)+(&H2E)+(&H2E)' MOV AX,2E2E         184,46,46 Looking for ".."„REM (&HAF)              ' SCASW               175       in the next word„REM (&H5F)              ' POP DI              95        Restore DI (w/out changing flags)„REM (&H75)+(&H6)        ' JNZ Over            117,6     No match?  Jump over:„REM (&HB0)+(&H5C)       ' MOV AL,5C           176,92    Look for next '\'„REM (&HF2)              ' REPNZ               242       Do twice: Once to„REM (&HAE)              ' SCASB               174       remove "..", and once„REM (&HF2)              ' REPNZ               242       to remove extra dir„REM (&HAE)              ' SCASB               174       name that ".." adds„REM (&HFC)              ' Over: CLD           252       ALWAYS Clear dir flag if set„REM (&H47)              ' INC DI              71        SCASB left us one byte„REM (&H47)              ' INC DI              71        before the '\', but we„REM (&HB0)+(&H0)        ' MOV AL,00           176,0     need one byte after..„REM (&HAA)              ' STOSB               170       write end-of-string nul„REM (&H5F)              ' Exit: POP DI        95        restore the stack„REM (&H7)               ' POP ES              7                "„REM (&H7)               ' POP ES              7                "„REM (&H1F)              ' POP DS              31               "„Dan Autery                     ABSOLUTE ASM TO ASIC DECODER   Autery@aol.com                 04-17-99 (16:25)       ASIC                   240  6106     CODER.ASI   REM -- 'ABSOLUTE ASSEMBLY TO ASIC' DECODER v0.9 (beta)„REM -- by Dan Autery (autery@aol.com)„REM„REM ** Created for William Yu's All Basic Code Archives.„REM ** This program is hereby placed in the Public Domain.„REM„REM **  With any program that contains Assembly or Machine Language, you're„REM ** undoubtedly aware that one misplaced or incorrect value can have„REM ** potentially disastrous effects.„REM„REM **  Personally, I can't begin to explain how frustrating it can be to„REM ** have an Assembly routine lock up a program because of some silly„REM ** mistake I've made - either in a HEX to Decimal conversion or because„REM ** I've inadvertantly left out a byte or two from a CODE statement (grr!).„REM ** Naturally, I had to find a solution for this.. ;)  And that's where„REM ** this handy little program comes in. :)„REM„REM **  This utility was created primarily to reduce the potentially„REM ** large amount of work involved in translating the Absolute Assembler's„REM ** HEX codes from QBASIC Call Absolute format to ASIC Decimal CODE„REM ** values.  Perhaps more importantly, though, it also cuts down on the„REM ** number of errors that inevitably pop up during the above process. :]„REM„REM **  I hope you find it helpful.. :>„REM„REM **  CODER.ASI compiles to approximately 5K (as a .COM file) and„REM ** requires no special ASIC settings.  I've tested it pretty extensively„REM ** on ABSASM2.BAS output files, and I've had no problems or glitches„REM ** so far.  However, you should still consider it a BETA (and should„REM ** double-check your output CODE to verify its accuracy until you're„REM ** confident with the program).„REM„REM **  Once compiled, you can activate the program from the DOS prompt„REM ** by typing "coder yourfile.ext" (where 'yourfile.ext' is the name of„REM ** the ABSASM2.BAS output file that you wish to convert).  The utility„REM ** will ask for an output file name in which to place your ASIC CODE.„REM ** Once you've typed in the output file name, the util will do the rest.„REM ** And that's pretty much all there is to it.  Your input file can be„REM ** in a different drive\directory [provided that you include the full„REM ** path to the file in the command line argument], if you wish.„„REM *************************  CODE BEGINS HERE ****************************„byt$=COMMAND$„byt$=LTRIM$(byt$)„byt$=RTRIM$(byt$)„IF byt$="" THEN„  COLOR 15,0„  PRINT„  PRINT "                'ABS ASM --> to ASIC Decoder, v0.9'"„  PRINT„  PRINT "    USAGE: 'Coder file.ext'"„  PRINT„  PRINT "    Use this utility on files that have been processed by"„  PRINT "  Petter Holmberg's QBASIC ABSOLUTE ASSEMBLY, v2.0 (ABSASM2.BAS)."„  PRINT„  PRINT "    This program creates a text file containing the ASIC CODE"„  PRINT "  data extracted from the HEX codes created by the above."„  COLOR 7,0„  PRINT„  PRINT "    Coded for the ABC Archives by Dan Autery (autery@aol.com)"„  END„ENDIF„key$=FIND FIRST(byt$,0)„GOSUB errorcheck:„OPEN "R",1,byt$„GOSUB errorcheck:„num=LEN(byt$)„num=num-4„IF num<1 THEN quit:„newname:„ CLS„ LOCATE 1,2„ PRINT "Input file=";„ PRINT byt$„ LOCATE 3,2„ PRINT "Please enter an output file name: ";„ INPUT ofile$„ num=INSTR(ofile$,".")„ IF num<2 THEN quit:„ key$=FIND FIRST(ofile$,0)„ IF ERROR=0 THEN„   PRINT„   PRINT " That file already exists: ";„   IF ofile$<>byt$ THEN„     PRINT "(O)verwrite, ";„   ENDIF„   PRINT "(N)ew name, (C)ancel";„   GOSUB kibit:„   new$=UCASE$(new$)„   IF new$="N" THEN newname:„   IF ofile$=byt$ THEN quit:„   IF new$<>"O" THEN quit:„ ENDIF„„OPEN "O",2,"~f1.tmp"„GOSUB errorcheck:„„crlf$=CHR$(13)„key$=CHR$(10)„crlf$=crlf$+key$„„readmore:„INPUT# 1, byt$ CRLF„IF ERROR=96 THEN write:„IF ERROR>0 THEN newfile:„write:„GOSUB getnum:„GOTO readmore:„„newfile:„  CLOSE 1„  CLOSE 2„  OPEN "I",1,"~f1.tmp"„  GOSUB errorcheck:„  OPEN "O",2,ofile$„  GOSUB errorcheck:„  charcount=0„„  readnew:„  INPUT# 1, byt$ CRLF„  IF ERROR=96 THEN writenew:„  IF ERROR>0 THEN„    PRINT# 2,crlf$ NONULL„    GOTO quit:„  ENDIF„  writenew:„  IF charcount=0 THEN„    PRINT# 2,crlf$ NONULL„    GOSUB errorcheck:„    PRINT# 2,"CODE " NONULL„    charcount=charcount+5„  ENDIF„  num=LEN(byt$)„  aa=num+charcount„  IF aa>72 THEN„    aa=1„    key$=""„    WHILE key$<>","„      key$=MID$(byt$,aa,1)„      IF aa>num THEN„        key$=","„        aa=1„      ELSE„        IF key$<>"," THEN„          aa=aa+1„        ENDIF„      ENDIF„    WEND„    aa=aa-1„    IF aa>0 THEN„      key$=LEFT$(byt$,aa)„      PRINT# 2,key$ NONULL„      GOSUB errorcheck:„      aa=LEN(key$)„      aa=aa+1„      num=num-aa„      byt$=RIGHT$(byt$,num)„    ENDIF„    charcount=0„    GOTO writenew:„  ENDIF„  charcount=aa„  PRINT# 2,byt$ NONULL„  GOSUB errorcheck:„  GOTO readnew:„„quit:„  IF ERROR>0 THEN„    PRINT " An error occurred during the conversion. Please verify your"„    PRINT "source and output files before using."„  ENDIF„  CLOSE 1„  CLOSE 2„  KILL "~f1.tmp"„  END„„getnum:„key$=" "„charcount=0„WHILE key$<>""„ key$=""„ tot=LEN(byt$)„ num=INSTR(byt$,"&H")„ IF num<1 THEN„   num=tot„ ELSE„   num=num+1„ ENDIF„ tot=tot-num„ IF tot>0 THEN„   A$=""„   temp2=0„   WHILE A$<>")"„     byt$=RIGHT$(byt$,tot)„     tot=tot-1„     A$=LEFT$(byt$,1)„     IF A$<>")" THEN„       temp1=ASC(A$)„       temp1=temp1-48„       IF temp1>9 THEN„         temp1=temp1-7„       ENDIF„       IF temp2=0 THEN„         temp2=temp1„       ELSE„         temp2=temp2*16„         temp2=temp2+temp1„       ENDIF„     ENDIF„   WEND„   key$=STR$(temp2)„   key$=LTRIM$(key$)„   IF key$="" THEN„     key$="0"„   ENDIF„ ENDIF„ PRINT# 2, key$ NONULL„ GOSUB errorcheck:„ IF key$<>"" THEN„   PRINT# 2, "," NONULL„   GOSUB errorcheck:„   charcount=charcount+1„ ENDIF„WEND„IF charcount>0 THEN„  PRINT# 2, crlf$ NONULL„  GOSUB errorcheck:„ENDIF„RETURN„„kibit:„  new$=INKEY$„  IF new$="" THEN kibit:„  RETURN„„errorcheck:„  IF ERROR>0 THEN„    GOTO quit:„  ENDIF„RETURN„Kenneth Green                  ARCADE SOUND EFFECTS           Ken27@thegrid.net              05-18-99 (12:28)       ASIC                   74   752      ARCADESD.ASIW=1000„X=2000„Y=6000„Z=12000„ZZ=24000„S=4000„C=8000„GO:„W=W-5„X=X-10„Y=Y-30„Z=Z-60„S=S+20„C=C+40„ZZ=ZZ-120„SOUND W,10„SOUND X,10„SOUND Y,10„SOUND Z,10„SOUND ZZ,10„SOUND C,10„SOUND S,10„IF X<100 THEN DONE:„GOTO GO:„DONE:„T=T+1„IF T=1 THEN DONE2:„X=2000„Y=6000„Z=12000„ZZ=24000„W=1000„S=4000„C=8000„GOTO GO:„DONE2:„SOUND 7000,500„SOUND 6000,450„SOUND 5000,500„SOUND 4000,450„SOUND 5000,500„SOUND 6000,450„SOUND 7000,500„X=0„Y=0„R=0„GO2:„X=X+50„Y=Y+100„R=R+200„E=E+400„SOUND X,30„SOUND Y,30„SOUND R,30„SOUND E,30„IF X>2000 THEN GO3:„GOTO GO2:„GO3:„X=0„Y=0„R=0„E=0„GGO3:„X=X+50„Y=Y+100„R=R+200„E=E+400„SOUND X,30„SOUND Y,30„SOUND R,30„SOUND E,30„IF X>2000 THEN GO4:„GOTO GGO3:„GO4:„Kenneth Green                  LEMONADE STAND                 Ken27@thegrid.net              05-18-99 (12:28)       ASIC                   199  5424     LEMONADE.ASIREM This program was made after midnight on May 17, 1999„REM It was created because about 10 years ago I played a similar„REM program when computer games had hardly any graphics on them.„REM This program has no graphics, but is really fun!„m=20„cls„print "               Lemonade Stand"„print„print "By Kenneth Green"„print„print "This program is a business simulation for all ages."„print "Learn how to spend and keep money to make more money by"„print "selling lemonade. The buyers come mostly at random, but also"„print "are effected on how much advertising you do."„print "You are started out with $20, a table, a chair, free unlimited"„print "water to mix the lemonade, a fairly good street to sell to, a"„print "a glass pitcher, and a friend to help you go buy lemonade and put"„print "up ads on sign posts and to yell for customers."„print "Plus this is a pretend world so you can sell as long as you want or"„print "sell until your money runs out. At the end, it will total your money."„print "Hint: The more ad signs you put up, the more customers you will get."„print "If you don't get any customers for a long time, well sometimes"„print "people just don't want something to drink!"„print "Remember that the higher you charge, the less customers you will"„print "have."„print "Also, City Ordinances say no more than 4 advertisements per game."„print "Press enter to begin.";„input a$„l=0„go:„cls„print "              Lemonade Stand"„print„print "Money: ";„print m„if l<1 then lll:„print "Type your price per glass you will charge here:";„input ch„if ch>10 then„   print "Your price is way to high, I will set it at $10 per glass."„   ch=10„   endif„if ch<1 then„   print "Your price is under $1 which these days isn't very profitable."„   print "I will set it as $1."„   ch=1„   endif„print "Glasses Of Lemonade To Sell: ";„print l„print "Amount of Advertisements you have: ";„print aa„print "------------------------------------------------------------"„goto am:„„REM Sorry for all the gotos, I had to shuffle this next section around.„lll:„if l<1 then„   print "You currently have no lemonade."„   if m<3 then„   print "You also don't have enough money to buy lemonade that could cost"„   print "as much as $3 a pitcher."„   print "Press enter to quit the game.";„   input qgg$„   goto done:„   endif„ print "Press enter to go buy lemonade.";„ input gb$„ goto buylemonade:„ endif„„am:„randomize„r=rnd(0)„r=r mod 20„r=r+1„if ch>6 then„   w=7„   goto nex:„   endif„w=ch„nex:„r=r+s„r=r-w„if r<10 then„   r=0„   endif„print "You have ";„print r;„print " customers at the moment."„print "------------------------------------------------------------"„„REM The next part was made because I didn't want to try and calculate„REM the difference of how many customers could get lemonade per group„REM and who does not. It makes hardly any difference in this game anyway.„if r>l then„   print "You just ran out of lemonade, but the group of customers were"„   print "kind and gave you what you charged for all of them."„   print "You thank them and gave the rest of the group water instead."„   l=0„   goto lll:„   endif„mm=ch*r„m=m+mm„l=l-r„print "Now you have: ";„print m;„print " dollars."„print "Now you have: ";„print l;„print " glasses of lemonade left."„check:„print "(1) Buy 1 Pitcher of Lemonade"„print "(2) Buy 1 Advertisement Sign"„print "(3) Keep Selling"„print "(4) End Game"„print "Type a number here and press enter:";„input num„if num=1 then buylemonade:„if num=2 then buyad:„if num=3 then go:„if num=4 then done:„goto check:„buylemonade:„le=rnd(0)„le=le mod 3„le=le+1„print "Currently, lemonade costs ";„print le;„print " dollars."„if le>m then„  print "Sorry, but you don't have enough money to buy any more."„  goto done:„  endif„print "You buy 1 pitcher of lemonade."„print "One pitcher equals 20 glasses."„m=m-le„print "Now you have ";„print m;„print " dollars."„print„l=l+20„print "You have ";„print l;„print " amounts of glasses to sell now."„print "Press enter to go back to main screen.";„input gb$„goto go:„buyad:„cls„if aa=4 then„  print "Sorry but due to the enormous amount of garbage on the street,"„  print "the city says you have the limit number of advertisements."„  print "Press enter to continue.";„  input ag$„  goto go:„  endif„print "Advertisements costs $4 each."„print "They add your profit because you get more customer attention."„if m<4 then„   print "Sorry, currently you have less than $4."„   print "Press enter to go back to main menu.";„   input bs$„   goto go:„   endif„m=m-4„aa=aa+1„print "You just bought 1 advertisement. In the real world it would matter"„print "where you place the sign at, but here it won't matter."„print "You now have: ";„print m;„print " dollars left."„print "Press enter to go back to main screen.";„input gg$„s=s+1„goto go:„done:„cls„print "                Lemonade Stand"„print„print "Your total money: ";„print m;„print " dollars."„print "You started with 20 dollars."„ppr=m-20„if ppr<1 then„    print "You didn't make any money."„    print "Good luck next game!"„    goto ddone:„    endif„print "Your total profit is ";„print ppr;„print " dollars!"„print„ddone:„print "Come back soon!"„print„print "Press enter to quit program.";„input qp$„end„Kenneth Green                  BUDGET PLANNER                 Ken27@thegrid.net              05-24-99 (00:26)       ASIC                   220  5169     BUDGET.ASI  start:„cls„print "                Budget Planner"„print„print "               By Kenneth Green"„print„print "This program allows you to record payments you make so you can"„print "stay on a budget."„print„print "I don't guarantee this will solve much, but it should help a little."„print "If you make a mistake, just finish it and then make a new one."„print„print "                 Main Menu"„print "                 ---------"„print„print "        (1) Make New Budget"„print "        (2) See An Existing Budget"„print "        (3) Quit"„print„print "Type a number here and press enter:";„input n$„if n$="1" then make:„if n$="2" then show:„if n$="3" then done:„goto start:„make:„cls„print "     Make A New Budget"„print„print "Below type an average price total for each payments."„print "If you don't pay for one or more of these then type 0."„print "Groceries: $";„input groceries„print "Rent or House Payment: $";„input house„print "Utilities (water and electricity, etc.): $";„input utilities„print "Automobile Insurance: $";„input autoinsurance„print "Cost Of Automobile : $";„input autocost„print "Automobile Gas: $";„input autogas„print "House Insurance: $";„input houseinsurance„print "Health Insurance: $";„input healthinsurance„print "Life Insurance: $";„input lifeinsurance„print "Leisure Outside of home: $";„input outsidefun„print "Leisure Inside of home: $";„input insidefun„print "All Credit Cards Total: $";„input creditcards„print "Banking Fees: $";„input bank„print "Cable TV or Satellite TV: $";„input cable„print "Internet Access: $";„input internet„print "IOU's: $";„input iou„print "Total of all Magazine and Newspaper Subscriptions: $";„input magazines„print "Amount you save per month: $";„input savings„print "Total of anything else: $";„input allelse„print "Type your Monthly Earnings: $";„input income„bills=house+utilities„bills2=bills+autoinsurance„bills3=bills2+autocost„bills4=bills3+autogas„bills5=bills4+houseinsurance„bills6=bills5+healthinsurance„bills7=bills6+lifeinsurance„bills8=bills7+outsidefun„bills9=bills8+insidefun„bills10=bills9+creditcards„bills11=bills10+bank„bills12=bills11+cable„bills13=bills12+internet„bills14=bills13+iou„bills15=bills14+magazines„bills16=bills15+savings„bills17=bills16+allelse„bills18=bills17+groceries„print "Total bills/payments per month:";„print bills18„le=income-bills18„print "You are left over with:";„print le„print„print "Do you want to save this information for later use (Y or N):";„input yn$„if yn$="y" then saveit:„if yn$="Y" then saveit:„if yn$="yes" then saveit:„if yn$="YES" then saveit:„if yn$="Yes" then saveit:„„print "Press enter to return to main menu.";„input mm$„goto start:„show:„cls„print "Type the name of your budget file here, leave out the .mon extension."„input bt$„bt$=bt$+".mon"„print„open "I",1,bt$„input# 1,house„input# 1,groceries„input# 1,utilities„input# 1,autoinsurance„input# 1,autocost„input# 1,autogas„input# 1,houseinsurance„input# 1,healthinsurance„input# 1,lifeinsurance„input# 1,outsidefun„input# 1,insidefun„input# 1,creditcards„input# 1,bank„input# 1,cable„input# 1,internet„input# 1,iou„input# 1,magazines„input# 1,savings„input# 1,allelse„input# 1,income„input# 1,le„cls„print "House Payment Or Rent: $";„print house„print "Groceries: $";„print groceries„print "Utilities (electricity, water, etc.): $";„print utilities„print "Auto Insurance: $";„print autoinsurance„print "Cost Of Automobile: $";„print autocost„print "Auto Gas: $";„print autogas„print "House Insurance: $";„print houseinsurance„print "Health Insurance: $";„print healthinsurance„print "Life Insurance: $";„print lifeinsurance„print "Outside Leisure: $";„print outsidefun„print "Inside Leisure: $";„print insidefun„print "Total Of All Credit Cards: $";„print creditcards„print "Banking Fees: $";„print bank„print "Cable TV or Satellite TV: $";„print cable„print "Internet Access: $";„print internet„print "IOU's: $";„print iou„print "Magazines and Newspapers: $";„print magazines„print "Amount Saved Per Month: $";„print savings„print "All Else: $";„print allelse„print "Monthly Income: $";„print income„print "Amount Leftover: $";„print le„close 1„print "Press enter to go back to main menu.";„input menu$„goto start:„done:„end„saveit:„print„print "Type your name or an easy name to remember here (8 letters or less)"„input t$„if t$="" then saveit:„if t$=" " then saveit:„if t$="  " then saveit:„t$=t$+".mon"„open "O",1,t$„print# 1,house„print# 1,groceries„print# 1,utilities„print# 1,autoinsurance„print# 1,autocost„print# 1,autogas„print# 1,houseinsurance„print# 1,healthinsurance„print# 1,lifeinsurance„print# 1,outsidefun„print# 1,insidefun„print# 1,creditcards„print# 1,bank„print# 1,cable„print# 1,internet„print# 1,iou„print# 1,magazines„print# 1,savings„print# 1,allelse„print# 1,income„print# 1,le„close 1„print t$;„print " file has been made. You can go back and view it anytime."„print„print "Press enter to go to main menu.";„input me$„goto start:„Raid                           INT DRIVEN FILE IO COPIER      comp.lang.basic.misc           05-26-99 (09:33)       ASIC                   211  5486     COPYA.ASI   rem Written on:5-26-1999 by Raid [SLAM]„rem COPYA.ASI - Simple limited error handling direct int driven file io„rem copier (files only) written in Asic v5. Compile: asicc copya.asi e b/exe„rem --„rem Simple copy routine. For some reason, partial file writes do not„rem occur... According to the docs for the int call, It should return„rem a partial write on error condition. Its not writing anything. :(„rem When this occurs, My program says "Disk Full" and stops.„rem Essentially, if 16k of data cannot be written, The write process„rem will not drop down and write what it can. If this code was„rem used in such programs as file splitters, You would waste a small„rem percentage of each floppy disk (or other media) you used. Unless„rem you modify this program to account for this. I've not done so.„rem Program written entirely in Asic v5. Compile: Asicc copya.asi e b/exe„rem Permission to use and/or abuse for whatever purpose is hereby Granted.„„dim work_buffer(8096)„rem routine designed to copy a file. This program uses a 16k Buffer.„rem Since an array (normal integer) in asic is 2 bytes per element, We only„rem need 8096 elements*2=16384 byte memory storage. <g> You can bring this„rem program to 32k or more by modifying bytesize variable (you'll need to„rem change other variables as well if you exceed 32767) as well as the size„rem of the work_buffer. A good rule of thumb, Max memory requirement/2„„dx=varptr(work_buffer(0))„print"Enter 1st (src) Filename: ";„input srcfile$;„print""„print"Enter 2nd (dst) Filename: ";„input dstfile$;„print""„print""„print"Attempting to create filename...";„filename$=dstfile$„gosub create_file:„bytesize=1„gosub write_file:„if byteswritten=0 then„print"Unable to create file."„gosub close_file:„end„endif„print"Creation successful."„gosub close_file:„gosub open_file:„dsthand=file_handle„„„print"Attempting to open...";„filename$=srcfile$„gosub open_file:„if file_handle<5 then„print"Failure opening! - Program Terminated"„file_handle=dsthand„gosub close_file:„print"Done!"„end„else„print"Success!"„srchand=file_handle„endif„„print"Now copying file...";„rem Now the actual copy process...„rem Point DX to our work_space memory,„rem We deal with 16k of data at a time.„dx=varptr(work_buffer(0))„copy_done&=0&„srclength&=filelen(srcfile$)„rem Now we know how big this sucker is. :P„„exitflag=0„while exitflag=0„bytesize=16384„file_handle=srchand„gosub read_file:„bytesize=bytesread„print"Read...";„print bytesize„file_handle=dsthand„gosub write_file:„print"Wrote...";„print byteswritten„„rem Ok, data read into memory, and sent to disk.„rem Now, lets see If after adding our actual read„rem data if it matches the host. If not, read more„rem if we have a match, close files and exit,„rem tell the user we copied ok.„„rem First, we do a quick check to see if we were able to write„rem the data we read.„if bytesread>0 then„if byteswritten=0 then„exitflag=1„print"Disk Full"„endif„endif„„total&=byteswritten„copY_done&=copy_done&+total&„if copy_done&=srclength& then„print"Copy Completed successfully..."„exitflag=1„endif„„if exitflag=1 then„file_handle=dsthand„gosub close_file:„file_handle=srchand„gosub close_file:„endif„wend„„print"Handle 1 (src) ";„print srchand„print"Handle 2 (dst) ";„print dsthand„print"Bytes read (request) ";„print bytesize„print"Bytes recieved (read) ";„print bytesread„print"Bytes write (request) ";„print bytesize„print"Bytes written (write) ";„print byteswritten„print"File Size (Source) ";„print srclength&„print"Amount of data known to be copied ";„print copy_done&„end„„„rem ---„rem  Transmission - Essential FiLE i/O„rem ---„„rem ***Create/Open/Read/Write/Close„„create_file:„rem Create filename specified in filename$, with normal attribute.„ax=&hex3c00„cx=0„dx=varptr(filename$)„int86(&hex21,ax,na,cx,dx,na,na,na,na,na)„file_handle=ax„return„„„rem open_file chart!„rem ax=&hex3d00„rem read-only„rem ax=&hex3d01„rem write only„rem ax=&hex3d02„rem read/write„„open_file:„rem See chart for access mode used.„AX=&HEX3D02„DX = VARPTR(Filename$)„INT86(&HEX21,AX,NA,na,DX,NA,NA,NA,NA,NA)„file_handle=ax„return„„write_file:„rem Writes bytes directly from memory (usually an array) to disk.„rem define dx register before calling this routine to point to the„rem memory address of the buffer area you want to write from. like so:„rem dx=varptr(buffer(0))„rem cx is how many bytes to write :)„if file_handle>4 then„ax=&hex4000„bx=file_handle„cx=bytesize„int86(&hex21,ax,bx,cx,dx,na,na,na,na,na)„byteswritten=ax„endif„return„„read_file:„rem as the name implies, it reads bytes into a buffer. :-)„rem as with write_file, you need to predefine the dx register for the„rem buffer where you want the info stored. Like so: dx=varptr(buffer(0))„rem if you don't, this routine will not work, or will overwrite some„rem other section of memory.  cx register is how many bytes to read :)„if file_handle>4 then„ax=&hex3f00„bx=file_handle„cx=bytesize„int86(&hex21,ax,bx,cx,dx,na,na,na,na,na)„bytesread=ax„endif„return„„close_file:„rem Close the file handle. If the file handle is less then 4, then„rem this routine will simply exit.„if file_handle>4 then„ax=&hex3e00„bx=file_handle„int86(&hex21,ax,bx,na,na,na,na,na,na,na)„endif„return„„„„„rem Regards,„rem Raid [SLAM]„rem Email: av.is.generally.lame@vx.0wns.you„John A. Kiernan                SHOW TOTAL & FREE DISK SPACE   kiernan@uwo.ca                 06-20-99 (02:09)       ASIC                   144  4659     DSKSP.ASI   rem  DSKSP.ASI  Version 1.0     J. A. Kiernan (c) January 1999„rem    Utility to show size and available bytes on a disk„„rem    Freeware!  Feel free to modify the code or incorporate „rem               parts of it into your own programmes, but„rem               don't blame me if your changes don't work.„„rem               This is an annotated example of an ASIC programme made„rem               almost entirely with objects CALLed as SUBs from the„rem               ASILIB library. The commands are preceded by explanatory„rem               rem lines.„„rem  This small ASIC program uses the ASILIB subroutine DriveSpace to get„rem  total and free bytes on a drive optionally identified in the command„rem  line (otherwise in the logged drive). Invalid arguments result„rem  in a Help Message.„„rem  Compilation:  ASICC DSKSP e b/obj„rem  Link with LINK.EXE   Library is c:\PROG\ASIC\ASILIB\ASI5LIB„rem  ~~~~                   That's where ASI5LIB.LIB is kept on my„rem                         hard disk. Somewhere else on yours, probably.„rem  „„rem  A note about ASILIB„rem    The ASILIB library is available as shareware ($25)„rem    from its author:„rem              Douglas R. Herr„rem              P. O. Box 207„rem              Sacramento, CA  95812„rem              U. S. A.„rem              telephone (916) 721-8762, voice only„rem              CompuServe 71247,3542„rem    It's good value for money, in my opinion.„rem  ASI5LIB.LIB is the ASILIB library file that goes with ASIC 5.0„„rem  The program code begins on the nest line.„  COLOR 7,0„  DiskDrive$=COMMAND$„  DiskDrive$=LTRIM$(DiskDrive$)„  DiskDrive$=RTRIM$(DiskDrive$)„    IF DiskDrive$ = "" THEN„      GOSUB CurrentDrive:„      GOTO GotDriveLetter:„    ENDIF„  DiskDriveLength=LEN(DiskDrive$)„    IF DiskDriveLength > 2 THEN„      GOSUB Message:„       IF Message=1 THEN TheEnd:„    ENDIF„GotDriveLetter:„  DiskDriveLetter$=LEFT$(DiskDrive$,1)„  DiskDriveLetter$=UCASE$(DiskDriveLetter$)„  DiskDriveLetter=ASC(DiskDriveLetter$)„    IF DiskDriveLetter < 65 THEN„      GOSUB Message:„       IF Message=1 THEN TheEnd:„    ENDIF„    IF DiskDriveLetter > 90 THEN„      GOSUB Message:„       IF Message=1 THEN TheEnd:„    ENDIF„  DiskDrive$=DiskDriveLetter$+":"„  GOTO Result:„Result:„rem    This is ASILIB's example, with adjustments to variable names.„  CALL SUB "DriveSpace", DiskDrive$, Total&, Free&, ErrCode„    IF ErrCode = -1 THEN„      PRINT "Invalid drive specification"„      GOSUB Message:„      GOTO TheEnd:„    ELSE„      PRINT ""„      PRINT "  Total space on drive ";„      PRINT DiskDrive$;„      PRINT "  ";„      COLOR 15,0„      PRINT Total&;„      COLOR 7,0„      PRINT " bytes."„      PRINT "  Free space on drive ";„      PRINT DiskDrive$;„      PRINT "   ";„      COLOR 14,0„      PRINT Free&;„      COLOR 7,0„      PRINT " bytes."„      GOSUB CurrentDrive:„      COLOR 3,0„      PRINT "  The current (=logged, or default) drive is ";„      COLOR 11,0„      PRINT DiskDrive$„      COLOR 7,0„    ENDIF„  GOSUB Pause:„TheEnd:„  END„„Message:„rem  Response to an invalid drive definition in the command line„  COLOR 2,0„  PRINT ""„  PRINT "  DSKSP.EXE  shows the size of a drive and the number of available bytes."„  PRINT ""„  COLOR 10,0„  PRINT "  Usage:  DSKSP [d:]"„  COLOR 2,0„  PRINT ""„  PRINT "          The optional d: is the drive letter, including the colon."„  PRINT "          Upper or lower case is OK. Anything else in the command"„  PRINT "          line will result in this help message, as will an invalid"„  PRINT "          drive letter or a floppy drive without a disk in it."„  PRINT ""„  PRINT "          DSKSP entered alone (without d:) will tell you about the"„  PRINT "          default (= current, or logged) drive."„  PRINT ""„  GOSUB Pause:„  PRINT ""„  Message=1„  COLOR 7,0„  RETURN„„CurrentDrive:„rem  Returns current drive (upper case, with colon) as DiskDrive$„    DiskDrive$=GETDRIVE()„    RETURN„„Pause:„rem     This is for Windows users, to provide an opportunity to„rem     read the Result: or the Message:„    COLOR 15,0„    PRINT ""„    PRINT "                                  Any key to continue ...";„    COLOR 7,0„  PauseNow:„    Key$=INKEY$„      IF Key$="" THEN PauseNow:„    COLOR 7,0„    PRINT ""„    RETURN„„rem  THIS is Line 141 of DSKSP.ASI  written by J. A. Kiernan in „rem  London, Ontario, Canada on 20th June 1999. The line numbers„rem  include blank lines in the file. If you have a copy that does„rem  not end here (Line 144) it has been edited and is not the original.„John A. Kiernan                BLANK SCREEN SAVER             kiernan@uwo.ca                 06-20-99 (02:09)       ASIC                   165  6956     SCRSAVE.ASI rem  SCRSAVE.ASI  Blank the screen; exact restoration with any keypress.„rem               Version 1.00 by J. A. Kiernan (c) October 1997„rem                               (kiernan@uwo.ca)„rem               Version 1.10 by J. A. Kiernan (c) February 1999„rem                 remembers and then replace the screen colour„rem                 attributes that were in effect before saving„rem                 the screen. (Avoids a blank black line below the„rem                 cursor on the restored screen, seen with Ver 1.0)„rem               Freeware! Feel free to modify the code or„rem               incorporate it into your own programmes, but„rem               don't blame me if your changes don't work.„„rem               This is an annotated example of an ASIC programme made„rem               almost entirely with objects CALLed as SUBs from the„rem               ASILIB library. The commands are preceded by explanatory„rem               rem lines.„„rem    The ASILIB library is available as shareware ($25)„rem    from its author:„rem              Douglas R. Herr„rem              P. O. Box 207„rem              Sacramento, CA  95812„rem              U. S. A.„rem              telephone (916) 721-8762, voice only„rem              CompuServe 71247,3542„rem    It's good value for money, in my opinion.„„rem  Compilation:„rem     To make the EXE file, you need  ASICC.EXE from ASIC version 5,„rem     a linker (LINK.EXE) and ASI5LIB.LIB (from the ASILIB library).„rem  The directory paths in the command lines below are the ones„rem  on my C: drive. Other people will organize their files„rem  in other ways. The LINK.EXE is Version 2.3, the one that„rem  went with IBM DOS 3.2.  The two command lines that follow„rem  (with duly modified path specs) are best put into a batch file,„rem  because every letter and comma is significant.„rem  COMMAND LINES FOR (1) compilation by ASICC; (2) linking with LINK -„rem   C:\PROG\ASIC\ASICC SCRSAVE e b/obj„rem   C:\PROG\ASIC\LINK SCRSAVE.OBJ,SCRSAVE.EXE,nul.map,C:\PROG\ASIC\ASILIB\ASI5LIB„„   rem   If this code is included in a programme that also makes calls„   rem   to other libraries, ASILIB must be last on libraries list in the„   rem   LINK command line (a requirement of the AllocDOS subroutine;„   rem   see the ASILIB documentation.)„„rem    The executable file (SCRSAVE.EXE) can be compressed with„rem    PKLITE, TINYPROG, XPACK or LZEXE (and probably others).„rem    Of these four, LZEXE gave the best compression (5871 --> 2442 bytes).„„rem  SUBs are all from ASI5LIB.LIB, which is the ASILIB library„rem  file that works with ASIC 5.0„„rem ____________ Programme code begins here _____________„„rem   Get the cursor position. This is one Line down from the„rem   DOS command line that calls the programme, and in„rem   column (Col) zero, because there isn't a DOS prompt„rem   any more once we are within this programme.„rem   Get the present screen colour attribute and „rem   translate it to foreground & background integer„rem   variables (Fg and Bg) „rem   The "TGetChr" sub also gets the Line, Column and Character„rem   at the cursor.„        Line=CSRLIN„        Col=POS(0)„rem   ASILIB uses 1-based coordinates„        Line=Line+1„        Col=Col+1„        CALL SUB "TGetChr"(Line,Col,Char,Colour)„        Fg=Colour MOD 16„        Bg=Colour/16„        Line=Line-1„        Col=Col-1„„rem   The "AllocDOS" SUB will need DOS 3 or higher, so get DOS version„rem   now, and display a message if it is below 3.0.„        CALL SUB "GetDOSver" Major Minor„          IF Major < 3 THEN„            PRINT "This program needs a DOS version 3 or higher."„            PRINT "Version ";„            Major$=STR$(Major)„            Major$=LTRIM$(Major$)„            Minor$=STR$(Minor)„            Minor$=LTRIM$(Minor$)„            Version$=Major$+"."„            Version$=Version$+Minor$„            PRINT Version$;„            PRINT " cannot evaluate the screen dimensions."„            PRINT "The original screen may not be accurately restored. Sorry!"„            GOSUB Wait:„          ENDIF„„rem   Calculate bytes required to save a text screen page. The ASILIB„rem   subroutine requires an extended integer, hence the "&" and also„rem   the need to have an "e" in the ASICC compiler's command line.„        CALL SUB "ScreenMem", ScreenBytes&„„rem   AllocDOS permits dynamic memory allocation for an ASIC programme.„rem   AllocDOS needs DOS 3 or higher.„rem   ScreenBytes& is the number of bytes you want to allocate.„rem   This number was returned by ASILIB's "ScreenMem" SUB.„rem   If the segment address returned by AllocDOS = 0, then„rem   insufficient memory is available for the requested memory„rem   block. The IF ... ENDIF below is to check for and respond to„rem   this unlikely event.„        CALL SUB "AllocDOS", ScreenBytes&, BlockSeg„          IF BlockSeg=0 THEN„            PRINT "Not enough memory to save the screen!"„            GOTO TheEnd:„          ENDIF„„rem   Acquire the screen.„        CALL SUB "GetScreen", BlockSeg, 0„„rem   Make a blank, black screen„        CLS„rem   Make the cursor invisible„        CALL SUB "CursorOff"„„rem   The  Wait:  subroutine is to wait (with screen black) until„rem   any key is pressed.„        GOSUB Wait:„„rem   Restore the screen.„        CALL SUB "PutScreen", BlockSeg, 0„„rem   The next job is to delete the command line that called this„rem   programme, so that the screen will look exactly as it was„rem   before this programme did its stuff.„rem   This necessitates a bit of cursor moving: up from the Line„rem   originally saved with CSRLIN. The column (Col) saved with„rem   POS(0) is 0 so a whole 80-column line can be overwritten„rem   with "space" (ASCII 32) characters. The DOS prompt will„rem   reappear on top of the deleted line, with the cursor„rem   poised to receive a new command.„rem   It is also necessary to restore the colour attributes„rem   (Fg, Bg) to their previous values.„rem                                     If you use 4DOS.COM instead„rem                                     of COMMAND.COM you can still„rem                                     invoke earlier commands with„rem                                     the PgUp and arrow keys, just„rem                                     as if this screen blanking„rem                                     programme had never been„rem                                     executed.„        Line=Line-1„        LOCATE Line,Col„        COLOR Fg,Bg„        BlankLine$=SPACE$(80)„        PRINT BlankLine$;„        Line=Line-1„        LOCATE Line,Col„„TheEnd:„END„„rem  Subroutines for use by GOSUBs are placed after„rem  the programme's END statement.„rem  This programme has only one GOSUB.„„Wait:„      Key$=INKEY$„        IF Key$="" THEN Wait:„      RETURN„„rem ________ The very end _________„