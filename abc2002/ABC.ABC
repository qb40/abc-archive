Walt Decker                    LB DLL for reading ABC Packets lydia2hg@yahoo.com             03-16-02 (  :  )       PB/DLL                 833  19155    abcr16a.bas $COMPILE DLL "ABCR16.DLL"„$INCLUDE "c:\pbdll60\winapi\winapi.inc"„„TYPE ABCFileStructure         ' Structures for *.ABC„  Author    AS STRING * 31    ' Programmer/Author's name„  Subject   AS STRING * 31    ' Subject/Title of code„  Origin    AS STRING * 31    ' Origin of code, or keywords„  Dateof    AS STRING * 23    ' Date of code release„  CodeOf    AS STRING * 23    ' Code of (QB,QBasic,PDS,ASIC,PB,VB,ASM,TEXT)„  NumLines  AS STRING * 5     ' Number of lines in code„  NumBytes  AS STRING * 9     ' Number of bytes when extracted„  FILENAME  AS STRING * 12    ' Default extraction name„END TYPE„„TYPE ABCIndexStructure„   Code     AS STRING * 1     'Special„   Position AS STRING * 10    'Byte position in file„   NumLines AS STRING * 5     'Number of lines in snippet„   Subject  AS STRING * 31    'Title„   Author   AS STRING * 31    'Programmer/Author's name„END TYPE„„TYPE PacketLines„  Lines     AS STRING * 252   'Multipurpose: Packet names and discription;„                              'Snipet title, author, date, and code; Snipet„                              'text; etc.„  Number    AS LONG           'Number of entries for above text„END TYPE„„TYPE DescSnip„  Choice    AS STRING * 82„END TYPE„DECLARE SUB ReadConfig(strABC AS STRING)„DECLARE SUB OnSort(intSort AS LONG)„„DECLARE FUNCTION GetABCs ALIAS "GetABCs"(PackData AS PacketLines)AS LONG„DECLARE FUNCTION Init ALIAS "Init"()AS LONG„DECLARE FUNCTION SnipDesc ALIAS "SnipDesc"(typSnip AS PacketLines, _„                 BYVAL intSort AS LONG, typPack AS DescSnip) AS LONG„„DECLARE FUNCTION GetSnip ALIAS "GetSnip"(AbcSnip AS ABCFileStructure, _„                 Sline AS PacketLines, BYVAL SnipNum AS LONG) AS LONG„„GLOBAL Packs()    AS STRING„GLOBAL Snips()    AS STRING„GLOBAL InitPack() AS STRING„„GLOBAL Eol        AS STRING * 1„GLOBAL sABC       AS STRING * 4„GLOBAL sIDX       AS STRING * 4„GLOBAL sCDE       AS STRING * 4„„GLOBAL ABCPath    AS STRING„GLOBAL LastPack   AS STRING„„GLOBAL Afile()    AS ABCFileStructure„GLOBAL AIndx()    AS ABCIndexStructure„„FUNCTION LibMain (BYVAL hInstance AS INTEGER, _„                  BYVAL wDataSeg AS WORD, _„                  BYVAL wHeapSize AS WORD, _„                  lpszCmdLine AS ASCIIZ) EXPORT AS INTEGER„„LOCAL strNull AS STRING„„  strNull = CHR$(0)„„  LibMain = 1   'success!„„END FUNCTION„„FUNCTION Init ALIAS "Init"() EXPORT AS LONG„„DATA "[LAST DIR]"„DATA ""„DATA "?"„DATA ""„DATA "[PACKETS]"„DATA ""„DATA "ABC=ABC Reader and packet specific code"„DATA "AI=Artificial intelligence"„DATA "ALGOR=Algorithms (compression, mathetics, sorts, etc.)"„DATA "ANSI=ANSI specific code"„DATA "ASIC=ASIC BASIC routines"„DATA "ASMCODE=Assembly routines for QBasic, Quick Basic, Power Basic, BasicToC"„DATA "BASBAS=BASICBASIC routines"„DATA "BASEC=William Yu's BASEC specific code"„DATA "BCX=Code for the BasicToC translator written by Kevin Diggins"„DATA "BINARY=Encryption, bit manipulation"„DATA "CHIPMUNK=APPLE code"„DATA "DB=Games and algorithms written in DarkBasic"„DATA "DASH=Collection of QB, *.OBJ, and *.ASM files"„DATA "DATETIME=Date and time routines (timers, delayse, clocks, etc.)"„DATA "DEMOS=Graphics, games, unfinished applications, code instruction"„DATA "DIRECTPB=Power Basic - DOS graphics routines"„DATA "DIRECTQB=QB graphics libraries and demo source code"„DATA "DISK=Disk routines (HD, FLOPPY, CD, etc.)"„DATA "DOS=Disk Operating System related routines (file, directory, prompt, etc)"„DATA "EGAVGA=EGA or VGA code (screen mode 9 and 12)"„DATA "FAQS=Frequently asked questions with answers"„DATA "GAMES=All types of games (arcade, RPG, adventure, action, space, etc.)"„DATA "GRAPHICS=General purpose graphics routines and demos"„DATA "HTML=Hypertext Markup Language using BASIC"„DATA "INTERRPT=BIOS/DOS low level interrupt routines"„DATA "KEYBOARD=Keyboard related routines (reading to and writing from, etc.)"„DATA "LIBERTY=LibertyBASIC for Windows specific code"„DATA "LIBRARY=BASIC Library or code requiring a library"„DATA "MEMORY=Memory management (EMS/XMS, conventional)"„DATA "MENU=Menu/user interface routines"„DATA "MISC=From accounting to zip-viewer"„DATA "MODEM=Modem and communications routines"„DATA "MOUSE=Mouse/lightpen routines"„DATA "NETWORK=Novell, LAN, IPX, etc."„DATA "PACKER=LZW compression routines"„DATA "PB=PowerBasic for DOS code"„DATA "PBCC=PowerBasic Console Compiler for Windows code"„DATA "PBDLL=PowerBasic Dynamic Link Library code"„DATA "PM=Protected mode access for DOS"„DATA "QBAPI=QBasic 1.1 ASM and test routines"„DATA "RAPIDQ=William Yu's byte code compiler specific routines"„DATA "SOUND=Sound effects and music (Adlib, wav, midi, sound blaster)"„DATA "TEXT=Routines for manipulating text and files"„DATA "VB=Visual Basic for DOS code"„DATA "VBWIN=Visual Basic for Windows code"„DATA "XBASIC=code written in the XBASIC language"„DATA ""„DATA "[LANGUAGES]"„DATA ""„DATA "PB"„DATA "PBCC"„DATA "PBDLL"„DATA "XBASIC"„DATA "LIBERTY"„DATA "QB"„DATA "QBASEC"„DATA "PDS"„DATA "CHIPMUNK"„DATA "RAPIDQ"„DATA "BASICC"„DATA "DIRECTQB"„DATA "ASIC"„DATA "BASICBASIC=BASBAS"„DATA "VB"„DATA "VBWIN"„DATA "DARKBASIC=DB"„DATA "BASICTOC=BCX"„DATA "TRUEBASIC=TB"„DATA ""„DATA "[EXTENSIONS]"„DATA ""„DATA "ZIP=COMPRESSED"„DATA "TKN=TOKENIZED"„DATA "EXE=EXECUTABLE"„DATA "COM=EXECUTABLE"„DATA "BAS=TEXT"„DATA "BAT=TEXT"„DATA "BI=TEXT"„DATA "INC=TEXT"„DATA "TXT=TEXT"„DATA "DOC=TEXT"„DATA ""„DATA "[FORMAT]"„DATA ""„DATA "NEW=0"„DATA "EOL=227"„DATA "SORT=0"„„LOCAL intNumDatas   AS INTEGER„LOCAL intI          AS INTEGER„LOCAL intFlag       AS INTEGER„„LOCAL strAbcConfig  AS STRING„LOCAL strCurDir     AS STRING„„sABC = ".ABC"„sIDX = ".IDX"„sCDE = ".CDE"„Eol = CHR$(227)„strAbcConfig = "ABCconfg.cfg"„strCurDir = CURDIR$„strAbcConfig = strCurdir + "\" + strAbcConfig„„IF DIR$(strAbcConfig) = "" THEN GOTO Cnfg_Read„„CALL ReadConfig(strAbcConfig)„Init = 2„EXIT FUNCTION„„Cnfg_Read: '„„intNumDatas = DATACOUNT„„REDIM InitPack(1 TO intNumDatas)„„FOR intI = 1 TO intNumDatas„    InitPack(intI) = READ$(intI)„    IF InitPack(intI) = "[LAST DIR]" THEN intFlag = intI + 2„    IF (intFlag > 0) AND (InitPack(intI) = "?") THEN„      InitPack(intI) = strCurDir„    END IF„NEXT intI„„OPEN strAbcConFig FOR OUTPUT AS #1„„FOR intI = 1 TO intNumDatas„  PRINT #1, InitPack(intI)„NEXT intI„CLOSE #1„Init = 1„„END FUNCTION„„SUB ReadConfig(strABC AS STRING)„„LOCAL intI AS INTEGER„LOCAL intF AS INTEGER„„OPEN strABC FOR INPUT AS #1„IF LOF(1) = 0 THEN„   CLOSE„   KILL strABC„   inti = Init„   OPEN strABC FOR INPUT AS #1„END IF„DO WHILE NOT EOF(1)„  INCR intI„  REDIM PRESERVE InitPack(1 TO intI)„  LINE INPUT #1, InitPack(intI)„LOOP„CLOSE„intF = UBOUND(InitPack)„FOR intI = 1 TO intF„  IF InitPack(intI) = "[LAST DIR]" THEN„    intI = intI + 1„    DO„      IF INSTR(InitPack(intI), "[") THEN„  intI = -1„        EXIT DO„      END IF„      IF InitPack(intI) = "" THEN GOTO Not_path„      ABCPath = InitPack(intI)„      intI = -1„      EXIT DO„Not_Path:  '„    INCR intI„    LOOP„  END IF„  IF intI < 0 THEN EXIT FOR„NEXT intI„„END SUB„„FUNCTION GetABCs(PackData AS PacketLines) EXPORT AS LONG„„  STATIC intLast AS LONG„„  LOCAL NumPacks AS LONG„  LOCAL intI     AS LONG„  LOCAL intJ     AS LONG„  LOCAL intK     AS LONG„  LOCAL intL     AS LONG„  LOCAL intM     AS LONG„  LOCAL intAttr  AS LONG„„  LOCAL Temp     AS STRING„  LOCAL CDE()    AS STRING„  LOCAL strNull  AS STRING * 1„  LOCAL strSpc   AS STRING * 1„  strNull = CHR$(0)„  strSpc = CHR$(32)„„  Temp = PackData.Lines„  Temp = TRIM$(Temp, ANY strNull + strSpc)„  NumPacks = PackData.Number„„IF NumPacks THEN GOTO Send_Pack_Data„„IF (Temp = "") AND (ABCPath <> "") THEN„  Temp = ABCPath„  GOTO Get_Pack_Data„END IF„„IF Temp = "" THEN„  FOR intI = 1 TO UBOUND(InitPack)„    IF InitPack(intI) = "[LAST DIR]" THEN„      intJ = intI + 1„      intI = intJ„    END IF„    IF (intJ > 0) AND TRIM$(InitPack(intI)) <> "" THEN„      Temp = TRIM$(InitPack(intI))„      intJ = 0„      intI = 0„      ABCPath = Temp„      GOTO Get_Pack_Data„    END IF„„Next_Path: '„„  NEXT intI„END IF„„intAttr = INSTR(Temp, "\*.*")„IF intAttr THEN Temp = LEFT$(Temp, intAttr - 1)„„IF Temp = ABCPath THEN„  GOTO Get_Pack_Data„END IF„FOR intI = 1 TO UBOUND(InitPack)„  IF InitPack(intI) = "[LAST DIR]" THEN„    INCR intI„      DO„        IF TRIM$(InitPack(intI)) <> "" THEN„          InitPack(intI) = Temp„          ABCPath = Temp„          intI = -1„          EXIT DO„        END IF„        INCR intI„      LOOP„  END IF„  IF intI < 0 THEN EXIT FOR„NEXT intI„„OPEN CURDIR$ + "\" + "AbcConfg.cfg" FOR OUTPUT AS #1„„FOR intI = 1 TO UBOUND(InitPack)„  PRINT #1, InitPack(intI)„NEXT intI„CLOSE #1„intI = 0„„Get_Pack_Data: '„„Temp = Temp + "\*.*"„intAttr = 23„Temp = DIR$(Temp, intAttr)„„IF Temp = "" THEN„  PackData.Lines = ""„  PackData.Number = 0„  GetABCs = 0„  EXIT FUNCTION„END IF„„IF UCASE$(RIGHT$(Temp, 3)) = "CDE" THEN„  INCR intJ„  REDIM PRESERVE CDE(1 TO intJ)„  CDE(intJ) = Temp„ELSE„  IF UCASE$(RIGHT$(Temp, 3)) = "ABC" THEN„    INCR intI„    REDIM PRESERVE Packs(1 TO intI)„    Packs(intI) = Temp„  END IF„END IF„„DO„  Temp = DIR$„  IF Temp = "" THEN EXIT DO„„  IF UCASE$(RIGHT$(Temp, 3)) = "CDE" THEN„    INCR intJ„    REDIM PRESERVE CDE(1 TO intJ)„    CDE(intJ) = Temp„  ELSE„    IF UCASE$(RIGHT$(Temp, 3)) = "ABC" THEN„      INCR intI„      REDIM PRESERVE Packs(1 TO intI)„      Packs(intI) = Temp„    END IF„  END IF„„LOOP„„IF (intI = 0) AND (intJ = 0) THEN„  PackData.Lines = ""„  PackData.Number = 0„  GetABCs = 0„  EXIT FUNCTION„END IF„„„IF intI THEN„  ARRAY SORT Packs()„END IF„„IF intJ THEN„  ARRAY SORT CDE()„END IF„„IF intI THEN„  FOR intK = 1 TO UBOUND(InitPack)„    IF UCASE$(InitPack(intK)) = "[PACKETS]" THEN EXIT FOR„  NEXT intK„  intL = intK + 1„  FOR intK = 1 TO intI„    intAttr = INSTR(Packs(intK), ".")„    Temp = UCASE$(LEFT$(Packs(intK), intAttr - 1))„„    FOR intM = intL TO UBOUND(InitPack)„      IF INSTR(InitPack(intM), "[") THEN EXIT FOR„      intAttr = INSTR(InitPack(intM), "=")„      IF intAttr = 0 THEN GOTO Next_Init_Pack„      IF UCASE$(LEFT$(InitPack(intM), intAttr - 1)) = Temp THEN„        Packs(intK) = Packs(intK) + STRING$(14 - LEN(Packs(intK)), " ")„        Packs(intK) = Packs(intK) + MID$(initPack(intM), intAttr + 1)„        GOTO Next_Pack„      END IF„„Next_Init_Pack: '„„    NEXT intM„    Packs(intK) = Packs(intK) + STRING$(14 - LEN(Packs(intK)), " ")„    Packs(intK) = Packs(intK) + "Unclassifed Packet!"„„Next_Pack: '„  NEXT intK„END IF„„IF intJ THEN„  FOR intK = 1 TO intJ„    CDE(intK) = CDE(intK) + STRING$(80 - LEN(CDE(intK)), " ")„    MID$(CDE(intK), 14) = "Install Me!"„  NEXT intK„END IF„„IF (intJ > 0) AND (intI > 0) THEN„  intK = intI + intJ - 1„  DIM CDETEMP(intK) AS STRING„  FOR intL = 1 TO intJ„      CDETEMP(intL) = CDE(intL)„  NEXT intL„  intJ = 1„  FOR intM = intL TO UBOUND(CDETEMP)„      CDETEMP(intM) = Packs(intJ)„      INCR intJ„  NEXT intM„  REDIM Packs(UBOUND(CDETEMP)) AS STRING„  FOR intI = 1 TO UBOUND(CDETEMP)„    Packs(intI) = CDETEMP(intI)„  NEXT intI„END IF„„Set_PackData_Number: '„„PackData.Lines = ""„PackData.Number = intI„GetABCs = intI„„EXIT FUNCTION„„Send_Pack_Data: '„„IF intLast = 0 THEN intLast = 1„„IF intLast > UBOUND(Packs) THEN„  intLast = 0„  PackData.Lines = ""„  PackData.Number = 0„  GetABCs = 0„  EXIT FUNCTION„END IF„„PackData.Lines = Packs(intLast)„PackData.Number = NumPacks - 1„GetABCs = NumPacks - 1„INCR intLast„„END FUNCTION„„FUNCTION SnipDesc(typSnip AS PacketLines, _„                  BYVAL intSort AS LONG, typPack AS DescSnip) _„                  EXPORT AS LONG„„STATIC intLastSnip AS LONG„STATIC intNumSnips AS LONG„STATIC strLastSnip AS STRING„„LOCAL intI AS LONG„LOCAL intJ AS LONG„LOCAL intK AS LONG„LOCAL intL AS LONG„LOCAL intM AS LONG„LOCAL intP AS LONG„„LOCAL strTemp  AS STRING„LOCAL strTemp1 AS STRING„LOCAL strTemp2 AS STRING„„LOCAL strExtn  AS STRING * 4„LOCAL strTrim  AS STRING * 2„„strTrim = CHR$(0) + " "„strTemp = typPack.Choice„strTemp = TRIM$(strTemp, ANY strTrim)„„IF strTemp = "" THEN„  SnipDesc = 0„  EXIT FUNCTION„END IF„„intI = INSTR(strTemp, " ")„IF intI = 0 THEN„  SnipDesc = 0„  EXIT FUNCTION„END IF„„strTemp = LEFT$(strTemp, intI - 1)„IF strLastSnip = strTemp THEN GOTO Send_Description„„strLastSnip = strTemp„„SELECT CASE RIGHT$(strTemp, 4)„  CASE sABC„    intJ = INSTR(strTemp, ".")„    strTemp1 = LEFT$(strTemp, intJ - 1) + sIDX„  CASE sCDE„END SELECT„„strTemp = ABCPath + "\" + strTemp„strTemp1 = ABCPath + "\" + strTemp1„LastPack = strTemp„intI = 0„intJ = 0„„REDIM Aindx(0 TO intI)„„intJ = SIZEOF(Aindx(0))„„OPEN strTemp1 FOR BINARY AS #1 LEN = intJ„„SEEK #1, 1„intNumSnips = LOF(1) \ intJ - 1„„strTemp1 = ""„FOR intI = 0 TO intNumSnips„  REDIM PRESERVE Aindx(0 TO intI)„  GET #1, , Aindx(intI)„NEXT intI„CLOSE #1„„REDIM Afile(0 TO intNumSnips)„„„OPEN strTemp FOR BINARY AS #1 LEN = LEN(Afile(0))„„FOR intI = 0 TO intNumSnips„  intP = VAL(Aindx(intI).Position)„  SEEK #1, intP„  GET #1, , Afile(intI)„NEXT intI„CLOSE #1„„IF intSort THEN CALL OnSort(intSort)„„typSnip.Lines = ""„typSnip.Number = intNumSnips„intLastSnip = -1„SnipDesc = intNumSnips„„EXIT FUNCTION„„Send_Description: '„„IF intLastSnip < 0 THEN intLastSnip = 0„„strTemp = STRING$(80, " ")„„MID$(strTemp, 1, 25) = Afile(intLastSnip).Author„MID$(strTemp, 27, 31) = Afile(intLastSnip).Subject„MID$(strTemp, 60, 8) = Afile(intLastSnip).DateOf„MID$(strTemp, 70, 10) = Afile(intLastSnip).CodeOf„typSnip.Lines = strTemp„typSnip.Number = typSnip.Number - 1„„INCR intLastSnip„„IF intLastSnip > intNumSnips THEN„  intLastSnip = -1„  SnipDesc = -1„  EXIT FUNCTION„END IF„„SnipDesc = intNumSnips - intLastSnip„„END FUNCTION„„FUNCTION GetSnip(AbcSnip AS ABCFileStructure, SnipLine AS PacketLines, _„                 BYVAL SnipNum AS LONG) EXPORT AS LONG„„STATIC intLastLine AS LONG„STATIC intNumLines AS LONG„„LOCAL intI      AS LONG„LOCAL intJ      AS LONG„LOCAL intK      AS LONG„LOCAL intP      AS LONG„LOCAL intSize   AS LONG„LOCAL intBytes  AS LONG„LOCAL intTimes  AS LONG„LOCAL intRemain AS LONG„„LOCAL strLine   AS STRING„LOCAL strRemain AS STRING„„IF intNumLines > 0 THEN GOTO Send_Lines„„intP = VAL(Aindx(SnipNum).Position)„intNumLines = VAL(Afile(SnipNum).NumLines)„intBytes = VAL(Afile(SnipNum).NumBytes)„intBytes = intBytes - intNumLines„intTimes = intBytes \ 250„intRemain = intBytes - intTimes * 250„intP = intP + SIZEOF(Afile(0))„intSize = 250„intJ = -1„intLastLine = -1„„OPEN LastPack FOR BINARY AS #1 LEN = intSize„SEEK #1, intP„„FOR intI = 1 TO intTimes„  GET$ #1,intSize, strLine„  GOSUB ParseString„NEXT intI„„IF intRemain THEN„  GET$ #1,intRemain, strLine„  GOSUB ParseString„  IF LEN(strLine) THEN„    INCR intJ„    REDIM PRESERVE Snips(0 TO intJ)„    Snips(intJ) = strLine„  END IF„  IF LEN(strRemain) THEN„    INCR intJ„    REDIM PRESERVE Snips(0 TO intJ)„    Snips(intJ) = strRemain„  END IF„END IF„CLOSE #1„SnipLine.Number = intJ„intNumLines = intJ„AbcSnip = Afile(SnipNum)„GetSnip = intJ„„EXIT FUNCTION„„Send_Lines: '„„IF intLastLine < 0 THEN intLastLine = 0„„SnipLine.Lines = Snips(intLastLine)„„SnipLine.Number = intNumLines - intLastLine„INCR intLastLine„„IF intLastLine > intNumLines THEN„  intNumLines = 0„  SnipLine.Number = 0„  getSnip = 0„  EXIT FUNCTION„END IF„„GetSnip = intLastLine„„EXIT FUNCTION„ParseString: '„  DO„    IF LEN(strRemain) THEN„      strLine = strRemain + strLine„      strRemain = ""„    END IF„    intK = INSTR(StrLine, Eol)„    IF intK THEN„      INCR intJ„      REDIM PRESERVE Snips(0 TO intJ)„      Snips(intJ) = LEFT$(strLine, intK - 1)„      strLine = MID$(strLine, intK + 1)„      strRemain = ""„    ELSE„      strRemain = strRemain + strLine„      strLine = ""„      EXIT DO„    END IF„  LOOP„RETURN„END FUNCTION„„SUB OnSort(SortOn AS LONG)„„LOCAL I AS LONG„LOCAL J AS LONG„LOCAL K AS LONG„LOCAL U AS LONG„„LOCAL Y1 AS LONG„LOCAL Y2 AS LONG„LOCAL D1 AS LONG„LOCAL D2 AS LONG„LOCAL M1 AS LONG„LOCAL M2 AS LONG„„LOCAL Ti AS STRING„LOCAL Tj AS STRING„LOCAL Tm AS STRING„„U = UBOUND(Afile)„FOR I = 0 TO U - 1„„Sort_Again: '„  SELECT CASE SortOn„    CASE 1„      Ti = LEFT$(Afile(I).Subject, 4)„      Tj = LEFT$(Afile(I + 1).Subject, 4)„    CASE 2„      Ti = RTRIM$(Afile(I).Author)„      Tj = RTRIM$(Afile(I + 1).Author)„      Y1 = INSTR(-1, Ti, " ")„      Y2 = INSTR(-1, Tj, " ")„      Ti = MID$(Ti, Y1 + 1)„      Tj = MID$(Tj, Y2 + 1)„    CASE 3„      Ti = UCASE$(LEFT$(Afile(I).DateOf, 8))„      Tj = UCASE$(LEFT$(Afile(I + 1).DateOf, 8))„„      M1 = VAL(LEFT$(Ti, 2))„      M2 = VAL(LEFT$(Tj, 2))„      D1 = VAL(MID$(Ti, 4, 2))„      D2 = VAL(MID$(Tj, 4, 2))„      Y1 = VAL(RIGHT$(Ti, 2))„      Y2 = VAL(RIGHT$(Tj, 2))„„      IF M1 < 1 THEN„        M1 = 1„        D1 = 1„        Y1 = 60„        Tm = LTRIM$(STR$(M1))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Ti = Tm + "-"„        Tm = LTRIM$(STR$(D1))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Ti = Ti + Tm + "-" + LTRIM$(STR$(Y1))„        Afile(I).DateOf = Ti„      ELSEIF D1 > 31 THEN„        Y1 = D1„        D1 = 1„        Tm = LTRIM$(STR$(M1))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Ti = Tm + "-"„        Tm = LTRIM$(STR$(D1))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Ti = Ti + Tm + "-" +LTRIM$(STR$(Y1))„        Afile(I).DateOf = Ti„      END IF„„      IF M2 < 1 THEN„        M2 = 1„        D2 = 1„        Y2 = 60„        Tm = LTRIM$(STR$(M2))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Tj = Tm + "-"„        Tm = LTRIM$(STR$(D2))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Tj = Tj + Tm + "-" + LTRIM$(STR$(Y2))„        Afile(I + 1).DateOf = Tj„      ELSEIF D1 > 31 THEN„        Y2 = D2„        D2 = 1„        Tm = LTRIM$(STR$(M2))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Tj = Tm + "-"„        Tm = LTRIM$(STR$(D2))„        Tm = STRING$(2 - LEN(Tm), "0") + Tm„        Tj = Tj + Tm + "-" +LTRIM$(STR$(Y2))„„        Afile(I + 1).DateOf = Tj„      END IF„„      M1 = (M1 - 1) * 30„      M2 = (M2 - 1) * 30„„      IF Y1 < 60 THEN„        Y1 = Y1 + 2000„      ELSE„        Y1 = Y1 + 1900„      END IF„„      IF Y2 < 60 THEN„        Y2 = Y2 + 2000„      ELSE„        Y2 = Y2 + 1900„      END IF„„      K = 1950„      Y1 = (Y1 - K) * 365 + M1 + D1„      Y2 = (Y2 - K) * 365 + M2 + D2„„      Ti = LTRIM$(STR$(Y1))„      Tj = LTRIM$(STR$(Y2))„„  END SELECT„  IF Ti > Tj THEN„„Swap_em: '„    SWAP Afile(I), Afile(I + 1)„    SWAP Aindx(I), Aindx(I + 1)„    IF I > 0 THEN„      DECR I„      GOTO Sort_Again„    END IF„  END IF„NEXT I„END SUB„„„„„„„„„„„„„„„„„„          „