John A. Kiernan                TWO TEXT UTILITIES             kiernan@uwo.ca                 03-28-95 (22:00)       ASIC                   219  14362    UPSI_ETC.BAS'>>> Page 1 of UPSI_ETC.ZIP begins here. TYPE:BINAA TLEN:10406„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"UPSI_ETC.ZIP",4^6:Z&=10406:?STRING$(50,177);„U"%up()%9%%%[-%%)SKCeP4=^_%7%%s(%%%)%%%%fgIhilb.n3RUR1jp$MAVNd(3C„U"+_.tlt</O*FgUvzPy;1WjKl/xJWT>$6zYy8n1&*m8rdZ0Lr',T(:kirNkkh<b-h„U"4sZoVcKRd=h%3.)gDD(l.bvY]/hA]2=gSr;2'aQV]UH2hH[L5;PB)]J'ljTPF+I„U"gP64XJO>\1.?#Rq\<wlr'j\gIaRN:WH'P%up%()9%%%%-%4%)KCqGrqD'&%%%''„U"(%%%+%%%%hfxydqjtI7$3<E71%IbmwSIBd##6cL6,]_]CXp4JcokR%q299Bl:z<„U"qPt]B.=epgJOyGogo:,371:H%8^u0'-_%0p.;FHmRL18Y>79Q(<J,^C&f8:1XIm„U"T:>GGA32TS]T[:a>d6O3D-rbs\##[F,1#%h/$-PO$3\A77vfOVn*Pd?%_YWPh=*„U"%Lse;2.T;&6IdHTnEUXrwO^,M3?K:m(4&nU1Kt',fD,u%p()9%%%%-R%%)K%C+D„U"8*mL)%+%?4%%%1%%%%hmj%pxuj%hSfxOn.&*,:\]98MTm4ZeL:S:J0UWZb;)jDt„U"TY#KSUx,IA<Ep:T=%YJ18x'po6shS&<d5Q4,T0Zl]aKcsGz$OmdV:qW50B6PnLW„U"MZ/G,b%,BSKu8vcJ6TWoUoK&^bjVAP$jaQijC&.IS55H:luSKWhfKv8&s]R4UmM„U"N[?dH]$1lS0oU+rLb%?BEl*u'8+dk<+;==/-+[k4-q0T01e*0O4TncVu-pl/Mc6„U"v_6rIy)G:&0uvf[fM,mdBXMWZWOq2]/6oG%9563X:'JUcLsRU--_ZKlHi)O'19;„U"VD4>J2j5<Zi:dU&upsS<iYzISGMKIq(8U7F63\Q2)/-=T.Z,eg=,iG,+10oQGN.„U"dY)I5o=_$]vLYtVf,uNhVp(J?3yTjuZyAMfFRpT0]cQ3k^OCk5LDkFHI/$k6ZOI„U"DhsBgZH]BKav)dU1brJoTgN<+E=(WsKdGFg(]ii/OLE(Ci9np1%rwR+)?tQiLv3„U"e>0+GRN;Hb^b*JZn_S.SW4o6u%)23Y?7WismUoKo%r9KejO\(9(H)PZEmR[7&T+„U"X1]b3j\cD.fGf\00&>m?IB=lfi*,hXp/dZEsr<Dm,0\6,3Kmx/k[y*Y1U3#YbBG„U"s3c+$q:QzVbd3mL80X4eifbd5XU4LhaG]Ec4GZ8^Y5Cst#SAbENWY+YA_Rdlxd?„U"b2;]Y#;/M%7ZX/;'y*CUp)>Wju]ySzYwU/t83cMEm9bq<:o;OWI9<<8$k=EGpId„U"-X<e.bs&f?hDF^Gi6[*URzP^pZM]Gl8YcM:6uJZW93$Ffd>YA)J5'(kJ4cR#[,:„U"C:fO5:^TWs-oKIa,62%&6p5zG)Hu+(ASuS'Y0GF[gyC^D^AaO6IRQ;N'bDv_P;q„U"B-S;)sMU6TF^j_>&it$pCGB)+i6FY,<3Vz\lVz#mQ$ke'disxY^V89c1owM2>AA„U"[%2lUIJsOEgGxVF*>Fe/NRstU=FZ#<=Q_tFX3tKh;6Z9:0rV+aCZe2hY35WDjOK„U"+,hMZ:&5bkoJ+LIQjfo'.x/uMjjHgcHs'A7y6ldlcqB-c4_dExSsD3L2pcXR,pu„U"7Cxu7ZB/,Ao8lNsTqyLrfATi1WD**z.6'5jQEOaj&2d$dT6FQ=u,'f4Tr/&#HZ'„U"]P4tf(#Km&>9e.)R&>N(Xfue5Ox7(06d;n[876O#iLf>hmC>?s$[B4twW\evaoA„U"nL[ULnm6H\6A*nlT+G/lCOXXCJc>Bk+0[i8ez_0tLMN<DoHr;V_K#wG&;i\ljZc„U"l<sAu*MCaTLd[Tf_fwEzi3Bw:f^CJV[jhD,X?q]..kVI$7qc<Se28m3UlEJP7Fo„U"t^yL4gcJ)GS/n9;//Z%b]Xkpbc:8N,#7eUCz_>gA/\w$^DcFZxoG\Dqgr&%Puty„U"+^)y8S*i*4L?NXb<3mJ/1ZXd.fP0&&qR0Ho8t>vKEZ0Q,YMx\o,JVBod+JPlc](„U"i8TMI0qsm$Kqcxvvv-D8up%()9%%%%-%4%)KC;kk%f&.*%%&z4%%%1%%%%hmjp%„U"xujh%StgoWf%x:(x&9dlpVj5huu8uOwPxCQJ2o,rfi?25w*'$oL:0.K,zv7GR1D„U"u3Y/8'nRVfOLgiC<d\+pfROI&NIe[Q7T4JNWIyk?EAW:>Crt0mjZu+Kpp]tR20h„U"ZicC/eG2p1>ZouWl2$$5Bc$WUJK;U'2N*p$FNPcf%O&-%(N-..%*hnZFPVV_$,y„U"fS\F7TJR;V'T2'FL2p4/V?69k-E[%CV?K&2/SYTq;oFP\py%fK+N,CFLTOm_,dZ„U"jeF%G'C_]D3$Qnb0SmUfqq_zK%k9Q9Y-*Xui)-tF=rnh(DVji8vvk%4z1YB16#5„U"l.,Am-670lkv)7Wh%o:uqW;pT6IJvVWY17uN2p9R?9TC]NzZ7;JXT/E+QHTE,$/„U"PaHD^+S;[Kt#Ep]12m\[P_WXH?NRW\A(IfH^E,_h1/36/1kKg%_n-7h\dS,hL$[„U"rSXfvE:Li2ylY-4p-z:z?cY4sojfnl85%qy)7p]rh%()xE<oRQc6L]1rLXqI;$)„U"slhu-mnM*E4=3tv]oL,7no>\&:9\0wg2M\?)*8G4g'bJpog0cuKBE:Ma-W<iWA1„U"#gP^2y4uBVaS'4TUNb^TT4-v$##$0pp3Z9]s$9f(PN>UO\tXk'Lm3F2-Or^Rk6,„U"K99qVleWPAW>9G3lg^op9shad5vS$fj)MT.[?3$Ei:**GNj=*#C5t=C2^ke,+kD„U"a&+a?]aD2kP;^o(?9xv5^$b(yhat'DTTgtgfGDw#7gb#RGH<ia<?.G#;<$?Bg.^„U"Q5X#A;XdRhbiICN08v,SAW*(Nhfc\Pm>DoIvC-UFc+TbV9t^4hidE;B+m>eiDpF„U"M9fK&^ri\F;b%?U\8:gu0?x\NLZOkCd.xv\/,g1^:)MtW14A,lXds9DZML]D8PL„U"uRUJNKTLv%mpE%k8B&aoT883oRP2DESi7/XT8^y9Ea;Xui\+WMeO]D>w2>Xjq[?„U"jq?*5Cqxjt(G,)D$z_g<?E=VJF;;CLcU&?f0ByTJvE=rPk4T$N-TbSlO/wO/9Fj„U"X:Qu&UdLPz1BGkz62tIjVkR\gBuEF/Z%pG>&Hr<,=&qDI(;w^Vi.-IhaZTDi)??„U"fEB#Muc%9?WWy;o6KOWwsYdD$eO=ndUM#(1dVW/Qlbv'adk+9tmq-<:6+EB/R/x„U"oNC\9\07JvUlW%ZOs\Ph#4BH9+rb:xBViv%jY6ZTJZ3b'a*c?e3<yq#':.'nnMV„U"_7pd2U#$qa^*RDEZ3QjT3wRg-u9j#..?n&B5?Ye8di,eguOf\3%B,6[^'nP$kh0„U"CjDWFrK_'c=;p2SRlTp)cA,TY4-e3:tz1G3vob:9fCU%U]DZynf\$vZQ1(K/2Js„U"IBuHFM6*^qvbKbn(Mm0yZ84XNpGasb$:5x\Rr*S0=?[p&&=VK&o3O#XzP$myaW.„U"++U4p[is:C3O[ZJ>t7t+LB,[5rLH.gYlaj0JCkmQiLBenEV=tnG;TGxNmITJFK]„U"*J2W93w.\>rotELF<;,X6\$b*ZX<mt-_b<bi?7-EAcWlBFx_XTIVF4E5&D&],:B„U"F6M1u7-cC%SiDOyxG#g]xwbk1_Ub33_+tP9dbgYu30o%D-9*gzH.4(*.CTC*T7l„U"fvx_104<*hdU0XN]P)+]-a56G1fJl8twwP[fn7+SVcEW09<(d-6/%-J?5Nu)dQ&„U"MB]e2s$L(t,4>wFh#/(8O1mlCkRu,HIrMX,p$:kyG9VA4fHvDk]N8JxafxtvZEr„U"GcmM^N4[DUJeG?=Y8]<sRqk+Dx,u%p()9%%%%-R%%)K4Cw(%*SG)%(%Y.%%%0%%„U"%%rjx%xflj.Sy'yDl%v^BSk5Mal[dEG*hI9gwtHa%nv0ANN$+icd:ZFc\SC\j2d„U",-*4UH4Qrflh.Z3?z(D9.0l\V>7Wr5_*JmCeZP;++O9+JuZ>(G^&,OgXM)+Xu^:„U"4#hE3[BS[h9rr?:UQu%KhWg3ii-r0rC5<:W0N4UC(]&o0f3L1C5:)r7R+s*pyQ&„U"-T:1Yb>].5DmdeQd5'MoHGwf;<C>U(_,ZXLQ#Qf\9e\5luQc5-:GzEma7vK1cEa„U"3^*pQ/fN-/Oj4XzMCzLGqvCp-2dV7sx?7E:g[7G6:zSR+SxQ^jSA.q,R#C0I8el„U"IAnsuNi.l\fCer6)Fm)>(3'w]/uez1b%jl[>(#=r;1CuPffhSPW8_guh<;_Q+GI„U"V5fdY1SbEFiGB,_nVp(I0nA)jYVL6rJsYQ&n]EolNHSiL)'c3aXYE=Gvr-DKETE„U"ZvuGmiPRFZg_hfj4l(o,#s3Yo$<SUB4[wL]ZoO)]p_k-[1Jbn1KJDr#UO7,dQ[P„U"tfdmw45C,DF6aUoI^1%ZUS?)4<Fx(u#:byk%Hq%(d>fdf]fB0sI#;ZEv.7WOj\S„U"[EB+o]Mn1(dF2fUN:-TvF91fs]Hu+q-Tet[G6kd,sn/k&&P^0LYC^[M0^;M;AN^„U"gJ^S]+mSxvMi?llOm=BtXxtDqiY).Y]p>$L$k9v:H:.uz+Bo1TnGJ7R*v1OpSho„U"ZiFRD8:5]]ov%#a(KC:%Z-X%J'U=:MZk>wFsRh_^,wJT:GJd7r&9-c><eA+?OUW„U"#2\c;'xOi=M.#Gp_NA'$2<KLZR&M;p[('g6$+RR4KnBgL6H^H,$gWII=GWjim=D„U":hOlZ:=NvY?C)RV\_FAAjF*4KKs7[^O/]s&J#CzOOkxK;]f&[t/Kd1mW,\EZvh)„U"2c>4T:sD;4NkH5I-XaJ<0W;k<6bmGb_ycQB3BJY-p6oF-Kf,KPI\W$Pt?XcwHje„U"V&L%$2w=$m(nnCr'cr+0S=Q40W_JPi5agM(qJEf\MynVRN5\x>f&H<5l_e1?NL&„U"o^Lo*Bosb?Atnf-(:SHe^\sk/IH.ik[iC=l2X^ybP4gFp4MpzyUvr[^pR6uhH?6„U"iT^pjoiy<g4_2^Oa;j:s3=DxV;D*hMyoZM&6+U.Vp<Q48t8>St'mZYQ8sJC-O+W„U"qOg]scf;n5$U]FUj4H_-^b2UcUi5;ulC3f>dWCvrsHHTX4i1R%ep&q,1nOAmmV=„U"c7LJgaWMEk_7-]nl5H51$;Jg?['+q$Dut.d.l+#fZ-JeDES2&\y.FF[w:']WYLu„U"4uB#g'pkjO(heMGBYX;<Ryl,f'leEke8Tb5MLkKilW<d+Jljc-Hf2YlBJ[]q3+k„U"m[n<m$\\1K%BZ5'>70Ms8Hcjk(6tCoI1X[9hz;VbKQ,D,ghidZ)hWiUBER;<0ck„U"gS3mIV)l0ZRKH8Hv1.t40\CeM]h3=MMIdL*N*+]-t0YAk;KfX?S6D/7ZAu(%up(„U")%9%%%[-%%)nKC>%:qE>/%%%/I%%%-%%%%zu%xnSfRxn&()*>#\^;M\YFd)t6&v„U"kEF48RA[E4\0>P/DAq(ye)n]W)m6d%Zq%G(Hjgs>RJw9*;aJoTc.B7hTTS__oex„U"ECmhAI]AX%^OokYtGA<hM+HGGbgi5GhJR%fb7I'q%,twdh]o-4-86jxF%<==R7d„U"\_#r^)M0=xWL<9/[,+Au-72M\Z]6=BgLNrqr7C1-a*JWjY1:QfEHSs8\#<[.s6U„U"0o;Qs92qRs9_,V_#K8^1]pnI.m;,7:t>C7N_4WTMA+#Gm21R58zo[K*lugcCG<j„U"v+g59nOuA[.OGH:eiq;S<$floT>^M3XcoK4$[F)a3di&?*a5l5c_JJwX:?C[IS3„U"f)O.^NYQ7wTZakiERf$&+y-9RC+o'vYhz*JUv1<u4?Hb0IQ?H2RabBY60H72<M&„U"Fv\#siPcx?GZJk3OMMoU7C7C/^hHxg_,$^\R)f(($Y^rTciEH8U5^-uZIc.L8aB„U"F&8xDG'#);M3*RCcoE[Hke/zYmYRdCmiq\)pq,8.+l:I,3OjA;^va)g9Sp5vf&,„U"bO>>I<R&trH-8NU>Q\;n>Z3fS=DcDJFt^YDo:c>[']D^j)p\rUFAFR*eiL>)XYw„U"+5M/w:/W4[:DoN+Z(M2T4cY>]j?(r:L.<T5Q2jMAfCa&+.m58KZp'-eo[SAxg=:„U"]ul+Efc7Rc-\SDSku_237t?#eHpQGJ#.6_&O)xq;_xr%pdPI$xjF1jHFI;CLMi9„U"DI#=a]0jY,$]ACkmMpJU:WSg%*3z9p'a<uVr8BQaDmlBDpsEE*?o)X_iTxwHny^„U"N8YLc5#LY7evPmi/E8cwmB(gzX=lol(P<RL]-L7+N9cIvBok/qsR[6hR-EKP/qG„U"mHFmk$:OFA5a?vQCLHu%5.f,AEC+#_caZlc]ZO-M_X/57]\TBE>(;VS_S;_q6Xh„U"*^%5c(V$CAD?ALEGJMtY^L)VJ)_^kaP#gsmyPIw#s,+M;Nu])VeMc;%UO_%fOg/„U":n.ss-&V$t=>-f3o>jq8h9[t(rl1s$e;\X]d>8Ec^'M&_tZ$+L&xhmjF(sNxm%&„U"+0IaB[;7P+0cWdz4/>7zO+-bq#i4^]q[k#w=Zh)uuKAbl_(Y);#tg#1]&m5O/sT„U"3VoO-vmK_PLr_?$10fK;RCeKk#php$9VHN.Wo$>(F;,&]?<=MLA)gC8aNo>*,[*„U"YWLuhF0nKNALRDfn%3[Iy/EIZ$<UAmDR493+^NlFE6L[O/l<>F>Od50\+lQ6KKl„U"]6dGGI0K*MoP[:[Ji]-T1*6Dgk]CljSgjBhXmilq>\FG>_X(FU-Tre\wrVU:rRV„U"]r$B_eJflFN12/Ui=FDUz*?UZ:0/Tc;ey02wTgh1lWM=xIOMW$^#,+7&j6.kPiy„U"9]A]x9-\F%$Oj7j:/Jw6>O$,yD:q81Dpjp6f-qYA]3iqU=Re>Sfd2%=O[p.Le4t„U"Zu(r9v'/vb_C0]*+]%tX_]'j\076G?Z?MCt]?]\,&=]Pa6^q8-b]W,1^W.s=0Sf„U"*>l'Ch*]3A&AGM:HG2y8YkY*.VzwQ[?PA.q]tYm(BwI]p8VIS*fYzzM#eCJVwWL„U"AQU3z2S(J*5u8Xf(ek?:UM3Bc0(ir5>Tc_U^[y/u>rI.U6,QOq++kBveO.tpTrA„U"KaP;d)7KU7c+6f7#\&8I<mS0*5ecThg*HrErn)n;C.?6+Up/WQ(+XIkNnwfduI&„U"K_WYCk1P#p3VKtUG(4$7$;MfJh.uG(5n4qou4>JFS7aA'l?bW8l>R]>ljl(c4tu„U"qg8aS5b#/oO(>q9BTLfqI9QmTv3]0kDg+etyyE0qUZRLjA\k(?CI;3#Gg>?ahAU„U"[mmF=OntGe<EisWWzCHsVKX2bZxpG)^HKoEt7C]/Gw1Y:vw+'.wlFHSml-odryH„U"J:evX,ACsc.EuJl?;(AIF^aKMlpsn,*fU?9*gk&NU,T3^f'_=1vg*,VBWdh-n\q„U"VWfN+KQiMgaaF9Y>S29xw\:f*R3k6:BSx3OP%ikiPo<1bmuQ/(%ju(jaM9H-2l+„U"-Mf9j))%o+u(M\/gIDJm]'txOga4;C[xii^;4uhOa0^Q.brM:UliNa4-w3yJ4p/„U"3cT'''_nwy/Snbgg*U4/8/lWbEGET<PX'U.p)^Knslrr_mU?W+BIP4IvlCk7q(D„U"afM987]nxm/;*hM7I4uPWI5vDq3TyPH+Frc1vP,,fP?Of_7WTJU'BZrn=V1FLae„U"oDZ&fBe/ugKZd8he9nu?Oa%mqg:-2foja&DT:?VB=tsXpMdsevACfDFL^?^s[=m„U"rE;e-*PQi&6B6&&lV_Xim)3JhEyeuSCWLtVAoOaw7lvckO6V,ZZk9sF_6XhZr[r„U"dv/C*mkY\s71_Pd,_BA>I2/JgN6dD,>cuwu._<A-Ar8-rm*a&:[v2co8H7*-^O-„U":c#4Dc?Y;+upoV=unNa1lkZ)klqZ%P++r4^Oc%rbh_iou7g^?+]_b+b(3tm#Kul„U"+0W$a5+*U0)Mr);l?RYsr\Ia;i5]2MJlt0?.h?V^Sq=te&aq?;1UI&PI&dP\Vc5„U"&7evC/08w^hnEphraF49u-C9Gkhxng^T*JI^1+\%0Rkfe,nP37DkSFu7\f?\Gi+„U"g4aG63fk*bG8:C\b(K3e67xEuvk6^n[Q;/_pHiUtaciE-[pWGq^_(g;?k)+#JOP„U"gW.4q;sHKdYI_;#ipH:a^'LA0JxD)z;)S8J\;jy_+f1cyQAsxu/,#Dj$vIpM1j?„U"R+Jn?,Ete%oPfP^PCQ<pSMG>&cdPmHz_)qZu3f.23IDwGFRf(0f+maka9dXo>A]„U"W<b7NqY^,\<\OCJ4JZ;DwLSEbYjc)F??Mi3cj^;FjLuS2iWvNLhh#_51U[5<j;i„U"ocAv?CLVPEmO*Eb_-0m5j6N>b>#pW)RT0S5$KJJ;n*iCCuYQ.AZqI.sPY+g1qH2„U",c3oASduFZ[Cr6VZ65<sfL1A=]?$;rAl>()#Qo8Iw2QL5r-wLPFqhIVm:0U?trc„U"j*PKfo/L&<lurS[Oe6pwWEqXFeA8K1S6[HWfPRxHA2v9b^#rV'[9t]3U>6=q575„U"Z,>a[&k<mr9]h-0oXF\]HTZ.).4tUv+2&*kh5_TbLxTsh-AIg^kwRj4<tR1M-$\„U"^[G<cU)9Ks>p=.js>387^ahx<N76g0w3(*$nnf&e.:I&-M6ICT*v)_nQlju&A/n„U"A5VmwZloLzSqa_^7&^Zy1WT8X-pT4Pui[9uEW.AcL9]g7:7oq,N2tjc[mKt'NMR„U"(5-8q2lMJtolyqaiMa2*xRj/OZ'5gEgKQgQd_YLtYfQ$O8vwN8B[JSPCv^>rtRR„U"PdM%)88+*2-[VK5$X'F7TW)[:FP=\jOeu3TEq08W+D%5dn<'jC4/jE8PW0%W_&j„U"euV1TqHg8Wn&458;']jdP=eN\PqoG/jfRK5X)=F7T)$[\:[]nK5(0&5>[>PqJ/-„U"jvK5EX*FMTU)[BFP=<jLeK0TEqK8WFt&5.S='jt=:[Lr7Ec,gbK..=h&%WHp[Pq„U"N=/jTK458(F)ML4i\8UdX6wmNu%p()9%%%%-R%%)K^C&)U,$%0%+%-L%%%-%%(%„U"%fx%jSfxOn&(*&>#\;8M\Yd0)t6zqr_Y*Y1^+,B4n;YIQ\9<1P_c0D_3&9^i((H„U"F1.A]X:0a.29.IjK(eP->O7n'9-etHcSv&D1hA5]RH_foS:)j_sauGZ<2b_Y:'G„U"IBupTVjp%oLgB9V^r[.i&$,[h)6(^tE=0E(m-2'_?3e;3cqI0-RgN[O;=#M=fn[„U".n<K#[1x#%MdEmS/5\&G*kU3R4(*O(,cL&SZ:<S7j9u*HZ=<A^?ic\Z*ui/UOvG„U"w)_.\b]qTuZN0O?9/OmgUdHLl.%\\[\*g\+L(87Y[U\I<r'Z-_B/>\nzbvedcd(„U"Y-Gj-'(d'#/N&<*oHbW&DGQ'J20-<knjjXQA,LnGa\:j^VNkQmjaW3>bvMZCS]2„U")S[niSn[eb3%P5ds/]C8,/G]i[w*5='kXGgcc.2Im8aU2'<N^(=nihC(?$c07iF„U"mpbeE2&'L(_4'[Ec*Anj6XY6sMSDnu6\%j'ToaKDyA]XQ:q&PW(/Ml;=Ou*nO&u„U"Wiq1VJA)4'HBrkYR\&uX>/etZJsK,m?S4B:>l:R1=k[LVr;N:)+8M/?2vIG9424„U"U-2TdvIx(xXrvkAeJcm\U)uHjOBwi/l0JMQ,^I$I4kIcdZA3-8id-h%R-ZU(u+M„U",Y+Qa#QAPr4+4KIqf7hdN)GZh&h4+p-M.K<0'0oaM0j^%l+I7iIGn]O\<EBaXf2„U"1:B;3RB4'qV*+,'H0ofVnU^YB66tbqJFTf^W6DdMT($gf(r5T$)[<T$g1-%Xi_U„U"ttU$3O*Fuxq:isSXZ>a?CXK]u2[,fMl(X#=F\%(yw[Gz;my'DCHBf[<2'^>58v:„U"q.Ri3(JC)Q\tFoZJ4TNq<K(XA:eXbuFD>k:QX5g[1T<93D(J*jx(/P'C3zA+mfx„U"68B-2[:W^HA#;j#o5VZ]cl_+LD\fp3U%d^=AF?5gn9x49,FIBta2V=#[X4,)]>.„U"B3ib[UBegzcD#q:1TjNP(Z9RzDi',gDU+;aL,(AqY6g=-^xI<]cES;YA./9;5Q^„U"'^PC-lSG?EGyS^t?9-3y.U[U2O1ZWk:vWboZjk)S6=YVQ/p=mX;R2on/$#r+OY2„U"+0761'16N'%#7t[5L+4K=Yi5]ftf+n2vEJ7]yX=b258A>Cweqz'3r^AH_dK4g[>„U"EVTRa[Q>:AyH*m(wqyx1i5ygo_/E;WHYF<?A<;f/'?=h[6R;&kR'PFpkrI_l)Z,„U"n^WAJoWJ?UVSz*>w4ojV/UDykFtX?tjJ;QWo\'XTJMIr1PPPII*)_B/F)lZBC&k„U"S)I%<vi*-8iE1<Gwcrhekx%N'I$BAa=J*A/8nt72?5sG63+3t%2U)%J2^1M:)S2„U"_AUfN##BBqEgJHG(6]3zR<g\(hQ10L\_e5<&[-'=:pQ?=gKUT[sUS3NT4$S9PE'„U"xCXEJEGr0tPNNE7:*QwOk.\pgEdL]\uc8f=F20c6\tl>;c]dCp2UD?Sy(kx#yo=„U"'O8l4<(>NdS:JXGQ6bldtkcEl-0jFs^3rQVU]6O]c=t]X6m)44JDyM%ODEcGm$j„U"G[MzI8*EKx^H3GDA&$xqALUWD:JLgLi1IS.%_h2x:^2Yy(;^+-w3SaJzYMfo)u]„U"DkEr^Mxu+q\qZYTP<pRiA=GVKl(V^k6>PfEQi?7[qG>/di\,A4Oa3#A)rch*'M%„U"XUEobNwrX0?62jO8jC)]iXMk_DImW8#u1TbStzJ7-(bRtCBj#dgMf6>;(zviI;]„U"Sd.O,ElQf,'_IEso#_tpXK9Q/D#bt1PgpRbe[Yps78ZAu,lIxseZf9T,Q.u#x-f„U";e+%W^U8I+V2Y\>cLRAgS'yD1GP(e)sg6[AkXs%CMmOm3V#>UN)j./bBE91+:lz„U">8Dj[a%D+c.[F6anOjCxv6ZII_2:yZ#J(P9aJo1XXT/2FyUAG#c8:gD98v6^I;c„U".DY>euM*(p(%>Sq^Do$2<Q=u/CBs4W^'+Pn=gk(x;=)Cx)ORiK_m[<rve>Rr9?k„U"?\&DxQXm+90fd8E1MuRUmmiY<7WuCnQS&yDRCW'A:]Z,$tT2MKJ(Es$]]db*hbh„U":B5h+/XCnLnlAc6LFft,rgOhUF6Eq7U8PHCSyPeZ8g/S0he[8Ip[TLBXsIh4aC#„U"Ou.AH)'j#f*YhfSc/&<S8U.3Dy2UrGy[mEUA%k'%J,Fx_eYW%Lut#U2e76tm6K7„U"-9IVNKri(-=N5oCcT,k#):0x*_JvraZ)cHcnfMZ\H\Q=X0GE1Qnap>p<Q(Dh4p1„U"LLHSQ5kMkba+IrE%)fh88J_dT;4Mg^$ZlO9(ak9Ghc0*V^+O.[]T:*wf*3L;%nT„U"n89<nJ,4%ZCeQ+'8>B+w,D<zbL.vv8Xm1oo,WFMI^cv9HA>Cus,,JcpaC=M:Mak„U"%j[=1<t2XpAmd8TP-#6l)X3<sUT,OZ^WqF,,M,/'xa.4stF1g7ysm0ROK&;;w>*„U"3xuT^O1fiNeEsUl%cxCj_BQ&2s\0j613Bi_'rtb%c/J;3?ZZ)4JN/Y)J<4zO?,Y„U"nF+*Du(XDWRMApZf:r96ebL[T2\(LlB$A3?^.MM'*CZP^6C6I3XM'iwV+(-i5VU„U"x3T0B8Zq<41>I)l^6Km2<Ln55,q-odr(RuRT4J:'G.29V[5;[uCpIW_\G-s0wjK„U"?WGNs,vL+]be[tJ$Lf&OJ+s87CoeNveyq^L(Nf/u&L2s_qj_KTJZNs&qD$CO=+O„U"t0\uHzb6TRjlPx'4*/i,[OHlaPr2vA2Q$&As;q/un5%G.IpKc,BHL-l;0<MnUDt„U"0h]5FMu.(s:nX:$e.<so2wX\J;oup\E2?,EmC&kan<pdrEQ]%S,6+KfFSZ0f'$n„U"=VWzKJ:nYecY$f:'kL'kr)jc,xEcbY$,Oo__#Y_Rvs.^$a=FQhR:MsDiP8T%^R^„U"yb0qoCEF[2l0R1H0WnsunKND](\mKqE=i%opdTbO3WcPEn3GYAxaw35w>m'OoFl„U"m>vr1J$H\6Iw3&zSZ)s#8IiHNUtwg8Qp*Si'aUBTIs<&d9wnLY-Nr$#a[r;JA<q„U"gt)%.vasIU5+[z<X>#9=4DZST0W>YWX?\(<mNd1.UZ\^;1[WeEQUl'()%:>,c#5„U"4%XhN>y,+%yo,ZM6Oat_y3\PJ]_-yp1voh)'s:'tD04PZfn0iGI;wuu2+UC?8/,„U"r-^TvjCW*fN23_QlilG?)hd,b5h]FL0Wn61cP5Fo2WB;H.*F-aRgxfLG&u[4U:+„U"?4%5xqK:u:osb7jNAO4SV*5LSh+&Ax(Ta/bEqnqE^5/&v*ZyHcPsE+V#6/nWoD;„U"c9<n(%xaoDr_3rX(,g5Y6S0.GNn.VI/HH/;_<d:X]T?v$#5#p,:kdq]USc\Y>sn„U"-u]KvUP/T-RlPT#<rqpqXB*)oPnIMnSyE[Y]WHxC8.botECDDVy8B,y,[YXC-L)„U"z/K;k<a-Kd.zEp*+]xdh(0t:XsHcVZ-Yd^q%ERChb&v%_7V>Pun5ger/^uUE)1X„U"n9vq*zg6G;wXI2o5el8NZ2SGv3E=fsWGFdeKWgSqx+3=4s8W4ceQuaSG983=\gs„U"W^cUeKdScq)3=e&sWpfceKf>Sq13H=psWFtdeKW$Sqs43=6s;Wndel5\Sqnq3=4„U"^sWTdXeu]Scq53=.,sWDoce5h>Sq*3B=lsWG>ceKraSq/43=Js>W(cekKeSqT33„U"=vpsWhdUeK[S-q'3iTL.Jy=(jQ.cj-3=.#sW\Tde-k+5F_5Ctl5^ode5b2SGr3]„U"=:L=&b_5\nl50d.ea#gD+x(#fT.#,43=*s>W0deQ5fSG8z3=TgsW.dXeucS$qt3„U"=e>sWXodeug>Sqf4IEob(s8t0x%&up&%'9%9%%%%-R%%)K4CeP=*^_%%+%s(%%%„U")%%%%%%%%%&%E%%%%%%%%%f%ghiu%p&'9%%9%%%%-%%E)KCGtrqD&[%%%'%(%%+„END SUB„SUB V2„U"%%%%%%%%%&%%E%%+%+%%%%hfx%yqju%p&'9%%9%%%%-%%*)KC+RD8mL[)%%?%4%„U"%1%%%%%%%%%&%%E%%(%R&%%%hmj%pxuj%hSfx%nup&%'9%9%%%%-R%%)KgCkk%(„U"f.*%(%z4%%%1%%%%%%%%%%%E%%%%O%+%%h%mjpx%ujhS%tgou%p&'9%%9%%%%-%„U"%$)KCwS(%SG#)%%Y%.%%0%%%%%%%%%&%%E%%+%,0%%%rjx%xflj.Sy'y%up&'%9„U"%9%%%%-%4%)KCH>%qE'>/%%%/I%%%-%%%%%%%%%&%E%%%%y5%%%zu%xnSf%xnup„U"%&'9%%9%%%[-%%)/KC&)<U$%07%%-L%%%-%%%%%%%%%&%%E%%%%d#%%&%fxj%Sf„U"xn%up*+%%%%%%,%,%&N&%%%6L%%%%%„END SUB„V2„CLOSE:IF S=91AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„'>>> Page 1 of UPSI_ETC.ZIP ends here. Last page. TCHK:91„Mike Beckman                   TIC-TAC-TOE                    mhscards@aol.com               12-17-95 (16:32)       ASIC                   673  16729    TICTAC.ASI  rem     TicTacToe„rem„rem     By:  Mike Beckman„rem             mhscards@aol.com„rem     „rem     For the ASIC 5.0 compiler„rem„rem =======================================================================„rem     This is a NO Bells and Whistles TicTacToe game I wrote for Asic.„„dim board(9)„„verybeginning:„vline$ = chr$(179)„hline$ = chr$(196)„cross$ = chr$(197)„turn = 1„„for x = 1 to 9„   board(x) = 0„next x„„gosub drawboard:„„begin:„if turn = 1 then„   goto startgame:„endif„if turn = 2 then„   goto computerturn:„endif„„end„„drawboard:„   cls„   color 15,0„   for x = 8 to 16„       locate x,35„       print vline$„       locate x,45„       print vline$„   next x„   for x = 31 to 49„       locate 10,x„       print hline$„       locate 14,x„       print hline$„   next x„   locate 10,35„   print cross$„   locate 10,45„   print cross$„   locate 14,35„   print cross$„   locate 14,45„   print cross$„return„„startgame:„   loop:„       keys$ = inkey$„   if keys$ = "" then loop:„„   if keys$ = "1" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "2" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "3" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "4" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "5" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "6" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "7" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "8" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   endif„„   if keys$ = "" then„       cls„       color 7,0„       end„   endif„„   if keys$ = "9" then„       keys = val(keys$)„       if board(keys) = 0 then„           board(keys) = 1„           turn = 2„       endif„       gosub redraw:„       goto begin:„   else„       goto startgame:„   endif„„redraw:„   if board(1) = 1 then„       color 9,0„       locate 15,32„       print "X"„   endif„„   if board(2) = 1 then„       color 9,0„       locate 15,40„       print "X"„   endif„„   if board(3) = 1 then„       color 9,0„       locate 15,48„       print "X"„   endif„„   if board(4) = 1 then„       color 9,0„       locate 12,32„       print "X"„   endif„„   if board(5) = 1 then„       color 9,0„       locate 12,40„       print "X"„   endif„„   if board(6) = 1 then„       color 9,0„       locate 12,48„       print "X"„   endif„„   if board(7) = 1 then„       color 9,0„       locate 9,32„       print "X"„   endif„„   if board(8) = 1 then„       color 9,0„       locate 9,40„       print "X"„   endif„„   if board(9) = 1 then„       color 9,0„       locate 9,48„       print "X"„   endif„„   if board(1) = 2 then„       color 14,0„       locate 15,32„       print "O"„   endif„„   if board(2) = 2 then„       color 14,0„       locate 15,40„       print "O"„   endif„„   if board(3) = 2 then„       color 14,0„       locate 15,48„       print "O"„   endif„„   if board(4) = 2 then„       color 14,0„       locate 12,32„       print "O"„   endif„„   if board(5) = 2 then„       color 14,0„       locate 12,40„       print "O"„   endif„„   if board(6) = 2 then„       color 14,0„       locate 12,48„       print "O"„   endif„„   if board(7) = 2 then„       color 14,0„       locate 9,32„       print "O"„   endif„„   if board(8) = 2 then„       color 14,0„       locate 9,40„       print "O"„   endif„„   if board(9) = 2 then„       color 14,0„       locate 9,48„       print "O"„   endif„„   gosub testwin:„„return„„computerturn:„   gfunk = 3„       while gfunk > 0„           gfunk = gfunk - 1„        rem *******„        rem Space 1„        rem *******„        if board(1) = 0 then„                if board(2) = gfunk then„                        if board(3) = gfunk then„                                board(1) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(4) = gfunk then„                        if board(7) = gfunk then„                                board(1) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(5) = gfunk then„                        if board(9) = gfunk then„                                board(1) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 2„        rem *******„        if board(2) = 0 then„                if board(1) = gfunk then„                        if board(3) = gfunk then„                                board(2) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(5) = gfunk then„                        if board(8) = gfunk then„                                board(2) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 3„        rem *******„        if board(3) = 0 then„                if board(2) = gfunk then„                        if board(1) = gfunk then„                                board(3) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(6) = gfunk then„                        if board(9) = gfunk then„                                board(3) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(5) = gfunk then„                        if board(7) = gfunk then„                                board(3) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 4„        rem *******„        if board(4) = 0 then„                if board(5) = gfunk then„                        if board(6) = gfunk then„                                board(4) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(1) = gfunk then„                        if board(7) = gfunk then„                                board(4) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 5„        rem *******„        if board(5) = 0 then„                if board(4) = gfunk then„                        if board(6) = gfunk then„                                board(5) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(8) = gfunk then„                        if board(2) = gfunk then„                                board(5) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(7) = gfunk then„                        if board(3) = gfunk then„                                board(5) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(9) = gfunk then„                        if board(1) = gfunk then„                                board(5) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 6„        rem *******„        if board(6) = 0 then„                if board(4) = gfunk then„                        if board(5) = gfunk then„                                board(6) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(3) = gfunk then„                        if board(9) = gfunk then„                                board(6) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 7„        rem *******„        if board(7) = 0 then„                if board(8) = gfunk then„                        if board(9) = gfunk then„                                board(7) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(4) = gfunk then„                        if board(1) = gfunk then„                                board(7) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(5) = gfunk then„                        if board(3) = gfunk then„                                board(7) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 8„        rem *******„        if board(8) = 0 then„                if board(7) = gfunk then„                        if board(9) = gfunk then„                                board(8) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(5) = gfunk then„                        if board(2) = gfunk then„                                board(8) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„„        rem *******„        rem Space 9„        rem *******„        if board(9) = 0 then„                if board(8) = gfunk then„                        if board(7) = gfunk then„                                board(9) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(6) = gfunk then„                        if board(3) = gfunk then„                                board(9) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„                if board(5) = gfunk then„                        if board(1) = gfunk then„                                board(9) = 2„                                gosub redraw:„                                turn = 1„                                goto begin:„                        endif„                endif„        endif„wend„randomizeit:„   randomize„   random = rnd(0)„   random = random mod 9„   random = random + 1„„   if board(random) = 0 then„       board(random) = 2„       gosub redraw:„       turn = 1„       goto begin:„   endif„„   goto randomizeit:„„testwin:„   if board(1) = 1 then„       if board(2) = 1 then„           if board(3) = 1 then youwin:„       endif„       if board(4) = 1 then„           if board(7) = 1 then youwin:„       endif„       if board(5) = 1 then„           if board(9) = 1 then youwin:„       endif„   endif„„   if board(2) = 1 then„       if board(5) = 1 then„           if board(8) = 1 then youwin:„       endif„   endif„„   if board(3) = 1 then„       if board(6) = 1 then„           if board(9) = 1 then youwin:„       endif„       if board(5) = 1 then„           if board(7) = 1 then youwin:„       endif„   endif„„   if board(4) = 1 then„        if board(5) = 1 then„                if board(6) = 1 then youwin:„        endif„   endif„„   if board(7) = 1 then„        if board(8) = 1 then„                if board(9) = 1 then youwin:„        endif„   endif„„   rem *******„   rem Computer test winning„   rem *******„„   if board(1) = 2 then„        if board(2) = 2 then„                if board(3) = 2 then youlose:„        endif„        if board(4) = 2 then„                if board(7) = 2 then youlose:„        endif„        if board(5) = 2 then„                if board(9) = 2 then youlose:„        endif„   endif„„   if board(2) = 2 then„        if board(5) = 2 then„                if board(8) = 2 then youlose:„        endif„   endif„„   if board(3) = 2 then„        if board(5) = 2 then„                if board(7) = 2 then youlose:„        endif„        if board(6) = 2 then„                if board(9) = 2 then youlose:„        endif„   endif„„   if board(4) = 2 then„        if board(5) = 2 then„                if board(6) = 2 then youlose:„        endif„   endif„„   if board(7) = 2 then„        if board(8) = 2 then„                if board(9) = 2 then youlose:„        endif„   endif„„   rem *******„   rem Test for cats game„   rem *******„„   flag = 0„   for qwerty = 1 to 9„        if board(qwerty) <> 0 then„                flag = flag + 1„        endif„   next qwerty„„   if flag = 9 then itsatie:„„return„„youwin:„        strin$ = "Congratulations, you win!"„        length = len(strin$)„        length = 80 - length„        length = length / 2„        color 10,0„        locate 22,length„        print strin$„        color 7,0„        print„        end„„youlose:„        color 10,0„        strin$ = "Better luck next time, you lose!"„        length = len(strin$)„        length = 80 - length„        length = length / 2„        locate 22,length„        print strin$„        color 7,0„        print„        end„„itsatie:„        color 10,0„        strin$ = "It's a cat's game!"„        length = len(strin$)„        length = 80 - length„        length = length / 2„        locate 22,length„        print strin$„        color 7,0„        print„        end„Mike Beckman                   TILES GAME                     mhscards@aol.com               12-17-95 (16:34)       ASIC                   295  6560     TILES.ASI   rem     Tiles for Asic„rem     „rem     By Mike Beckman„rem             mhscards@aol.com„rem„rem =======================================================================„rem„rem     The object of this game is to get the numbers in order from 1 to 8„rem     using the cursor keys.  It keeps track of the number of moves it„rem     takes you.  Hit ESCAPE to quit.„„dim board(9)„dim xcoord(9)„dim ycoord(9)„„data 9,32,9,40,9,48,12,32,12,40,12,48,15,32,15,40,15,48„„for x = 1 to 9„   read xcoord(x)„   read ycoord(x)„next x„„gosub setupboard:„gosub drawlines:„gosub drawboard:„gosub getinput:„end„„drawlines:„   vline$ = chr$(179)„   hline$ = chr$(196)„   cross$ = chr$(197)„   cls„   color 15,0„   for x = 8 to 16„       locate x,35„       print vline$„       locate x,45„       print vline$„   next x„   for x = 31 to 49„       locate 10,x„       print hline$„       locate 14,x„       print hline$„   next x„   locate 10,35„   print cross$„   locate 10,45„   print cross$„   locate 14,35„   print cross$„   locate 14,45„   print cross$„return„„setupboard:„   REM Initialization of playing field„   numbers$ = ""„   cls„   print "Initializing";„   for x = 1 to 9„       doagain:„       randomize„       g = rnd(0)„       g = g mod 9„       g = g + 1„       tmp$ = str$(g)„       tmp$ = ltrim$(tmp$)„       tmp$ = rtrim$(tmp$)„       a = instr(numbers$, tmp$)„       if a = 0 then„           if g < 9 then„               board(x) = g„               numbers$ = numbers$ + tmp$„               print ".";„           else„               board(x) = 0„               numbers$ = numbers$ + tmp$„               print ".";„           endif„       endif„       if a > 0 then doagain:„   next x„return„„drawboard:„   for x = 1 to 9„       tmp$ = str$(board(x))„       tmp$ = ltrim$(tmp$)„       tmp$ = rtrim$(tmp$)„       if tmp$ = "0" then„           tmp2 = x„           locate xcoord(x),ycoord(x)„           print " "„           goto skip:„       endif„               locate xcoord(x), ycoord(x)„               color 9,0„               print tmp$„       skip:„   next x„return„„getinput:„   getit$ = ""„       while getit$ = ""„           getit$ = inkey$„       wend„„   if tmp2 = 1 then„       if getit$ = "K" then„           board(1) = board(2)„           board(2) = 0„           score = score + 1„       endif„       if getit$ = "H" then„           board(1) = board(4)„           board(4) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 2 then„       if getit$ = "H" then„           board(2) = board(5)„           board(5) = 0„           score = score + 1„       endif„       if getit$ = "M" then„           board(2) = board(1)„           board(1) = 0„           score = score + 1„       endif„       if getit$ = "K" then„           board(2) = board(3)„           board(3) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 3 then„       if getit$ = "H" then„           board(3) = board(6)„           board(6) = 0„           score = score + 1„       endif„       if getit$ = "M" then„           board(3) = board(2)„           board(2) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 4 then„       if getit$ = "H" then„           board(4) = board(7)„           board(7) = 0„           score = score + 1„       endif„       if getit$ = "P" then„           board(4) = board(1)„           board(1) = 0„           score = score + 1„       endif„       if getit$ = "K" then„           board(4) = board(5)„           board(5) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 5 then„       if getit$ = "H" then„           board(5) = board(8)„           board(8) = 0„           score = score + 1„       endif„       if getit$ = "P" then„           board(5) = board(2)„           board(2) = 0„           score = score + 1„       endif„       if getit$ = "K" then„           board(5) = board(6)„           board(6) = 0„           score = score + 1„       endif„       if getit$ = "M" then„           board(5) = board(4)„           board(4) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 6 then„       if getit$ = "H" then„           board(6) = board(9)„           board(9) = 0„           score = score + 1„       endif„       if getit$ = "P" then„           board(6) = board(3)„           board(3) = 0„           score = score + 1„       endif„       if getit$ = "M" then„           board(6) = board(5)„           board(5) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 7 then„       if getit$ = "P" then„           board(7) = board(4)„           board(4) = 0„           score = score + 1„       endif„       if getit$ = "K" then„           board(7) = board(8)„           board(8) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 8 then„       if getit$ = "P" then„           board(8) = board(5)„           board(5) = 0„           score = score + 1„       endif„       if getit$ = "M" then„           board(8) = board(7)„           board(7) = 0„           score = score + 1„       endif„       if getit$ = "K" then„           board(8) = board(9)„           board(9) = 0„           score = score + 1„       endif„   endif„   if tmp2 = 9 then„       if getit$ = "P" then„           board(9) = board(6)„           board(6) = 0„           score = score + 1„       endif„       if getit$ = "M" then„           board(9) = board(8)„           board(8) = 0„           score = score + 1„       endif„   endif„„   if getit$ = "" then„       locate 20,1„       color 10,0„       print "Quitter....You had taken ";„       score$ = str$(score)„       score$ = ltrim$(score$)„       score$ = rtrim$(score$)„       color 15,0„       print score$;„       color 10,0„       print " tries."„       end„   endif„„   gosub drawboard:„   gosub checkwin:„   goto getinput:„„„return„„checkwin:„   bee$ = ""„   for q = 1 to 8„       a$ = str$(board(q))„       a$ = ltrim$(a$)„       a$ = rtrim$(a$)„       bee$ = bee$ + a$„   next q„   if bee$ = "12345678" then„       locate 20,1„       color 10,0„       Print "You win!!!"„       print„       print "It took you ";„       score$ = str$(score)„       score$ = ltrim$(score$)„       score$ = rtrim$(score$)„       color 15,0„       print score$;„       color 10,0„       print " tries to win!"„       end„   endif„return„„Dave Gjessing                  ASIC HELP                      dgjess@freenet.columbus.oh.us  12-22-95 (00:00)       ASIC                   578  16292    ASICHELP.ASIrem ASICHELP.ASI dg 12/22/95„rem Just messing around with some of the "ASICHELP" files that I„rem did several months ago, when I knew even *less* than I do now,„rem and was all gung-ho about using ASIC to learn BASIC. :)„rem„rem This is *very* "basic" stuff.„menu:„cls„color 14,0„locate 7, 0„print "                               ASICHELP.ASI"„print„print "                                 (G)OTO"„print "                                 (C)OLOR"„print "                                 (I)NKEY"„print "                                 (S)OUND"„print "                                 (P)RINT"„print "                                 (Q)UIT"„menuloop:„menuchoice$=inkey$„menuchoice$ = ucase$(menuchoice$)„rem input menuchoice$„   if menuchoice$ = "G" then gototop:„   if menuchoice$ = "C" then colortop:„   if menuchoice$ = "I" then inkeytop:„   if menuchoice$ = "S" then soundtop:„   if menuchoice$ = "P" then printtop:„   if menuchoice$ = "Q" then end:„goto menuloop:„end:„end„rem ***********************************************************************„rem GOTO.ASI (or GOTO.TXT)„rem by Dave Gjessing 8/20/95„rem demonstration ot the GOTO keyword„„gototop:„cls„quote$=chr$(34)„„rem see PRINT to find out what the quote$=chr$(34) thing is about„„color 14,0„„rem see the COLOR segment„„print "This segment demonstrates the GOTO keyword."„color 7,0„print„print "Unlike a lot of the other ASIC keywords, GOTO does just exactly"„print "what it's name implies. It makes the program execution GOTO another"„print "place in the code."„print„color 11,0„print "The syntax is: GOTO [targetlabel:]"„color 7,0„print„print "GOTO does not require any user input to work. As soon as the program"„print "encounters a GOTO statement, it jumps right to the target label and"„print "continues on from there. Nothing happens on the screen that would make"„print "it obvious that a GOTO statement had been encountered."„print„print "GOTO jumps DIRECTLY to the target label, no matter where the target"„print "label is in relation to the GOTO statement. The target can be either"„print "before or after the GOTO statement. The great thing about this is that"„print "your program does not have to simply proceed from one line to the next"„print "until it encounters the end. GOTO introduces some control."„print„color 7,0„print "Try it out in conjunction with the INPUT keyword, as the following"„print "example illustrates:"„print„print„print„color 10,0„print "press ENTER to continue";„input c$;„„page2:„cls„color 15,0„print "The following do-nothing program uses INPUT and GOTO:"„color 14,0„print„print "start:"„print "input c$"„print "goto end:"„print "goto start:"„print "end:"„print "end"„color 7,0„print„print "There is no way to get back to ";„print quote$;„print "start:";„print quote$;„print ", because as soon as input"„print "has gotten c$, the program will jump to the target label ";„print quote$;„print "end:";„print quote$;„print ", "„print "bypassing the line ";„print quote$;„print "goto start:";„print quote$;„print " Thus, the line ";„print quote$;„print "goto start:";„print quote$;„print " will"„print "NEVER be executed."„print„color 7,0„print "If you were to switch the two GOTO lines around, then the program"„print "would turn into one of those annoying continuous loop things that"„print "the INKEY$ section talks about. Try doing that and you will see what"„print "I mean. (look at the INKEY$ section first though, to avoid"„print "frustration!)."„print„print„print„print„color 10,0„print "press ENTER to leave the goto segment altogether."„print "press W, then ENTER to look at the (W)hole goto segment again.";„input nowwhat$;„nowwhat$=ucase$(nowwhat$)„if nowwhat$="" then menu:„if nowwhat$="W" then gototop:„„rem ************************************************************************„„rem COLOR.ASI (or COLOR.TXT)„rem by Dave Gjessing, 8-11-95„rem demonstrates the COLOR keyword„„colortop:„cls„rem    12/22/95 - this is incorporated in the QBPER12.BAS program„color 14,0„print "The following colors are available to you in ASIC:"„color 7,0„print„print "0 - Black     4 - Red         8 - Dark Grey    12 - Light Red"„print "1 - Blue      5 - Magenta     9 - Light Blue   13 - Light Magenta"„print "2 - Green     6 - Brown      10 - Light Green  14 - Yellow"„print "3 - Cyan      7 - White      11 - Light Cyan   15 - Bright White"„print„color 11,0„print "The syntax for the color statement is:"„print„color 14,0„print "COLOR [number for foreground],[number for background]"„print„color 11,0„print "To see what the various combinations look like, indicate"„print "a foreground and a background number below:"„print„color 7,0„   print "foreground ";„   input fg;„   print„   print "background ";„   input bg;„   print„   print„„sfg$=str$ (fg)„sbg$=str$ (bg)„sfg$=ltrim$ (sfg$)„sbg$=ltrim$ (sbg$)„„rem The four lines above manipulate the information that was just input„rem so that it can be displayed on the screen the way I want it. Notice„rem that we input normal integers for the variables fg and bg. A normal„rem integer has six "places" in it, so if you only input a single place,„rem say 2, for instance, then what you have is five "empty" places, and„rem the one place you entered. The letter e represents an empty space in„rem this example: eeeee2„rem Since I wanted the following display of the color numbers that were„rem selected to look just like they would in your code, I need to first„rem convert the normal integers fg and bg into string variables, then„rem trim off all of the leading spaces. The result is sfg$ and sbg$ -„rem string variables that I can print to the screen, and get the result„rem I wanted. See below->„„„   color fg,bg„   print " Here is a sample of text in the colors you just selected. "„   print " The syntax to create these colors would look like this:   "„   color 14,0„   print„   print "COLOR ";„   print sfg$;„   print ",";„   print sbg$;„„rem if the colors were 2 and 3, and we had NOT converted to strings and„rem trimmed spaces, the display here would be COLOR      2,     3„„color 7,0„print„print "(backgrounds 8 through 15 will make the foreground blink)"„print„„color 10,0„print "press ENTER to do another combination, Q and ENTER to Quit color";„input nowwhat$;„nowwhat$=ucase$(nowwhat$)„if nowwhat$="Q" then menu:„if nowwhat$="" then colortop:„„rem ***********************************************************************„„rem INKEY$.ASI (or INKEY$.TXT)„rem by Dave Gjessing 8/19/95„rem demonstrates some things that INKEY$ is good for„„inkeytop:„cls„quote$=chr$(34)„„rem see PRINT to find out what the quote$=chr$(34) thing is about„„color 14,0„„rem see the COLOR segment„„print "This segment demonstrates the INKEY$ keyword."„color 7,0„print„print "The INKEY$ keyword provides a special way of letting the user give"„print "instructions to your program. It is similar to INPUT, but unlike"„print "INPUT, it can only catch one keystroke at a time, and when it catches"„print "one of the ones it is waiting for, it reacts right then, not needing"„print "the user to press <ENTER> to send the information. It also differs"„print "in that it sort of ";„print quote$;„print "lurks";„print quote$;„print " in the background, while other functions go"„print "on. The great thing about it is that you can use it to give a way to"„print "break out of what would otherwise be a continuous loop."„print„print "Since accidentaly creating continuous loops is pretty darn easy to do,"„print "and since it's also pretty darn annoying when it happens, you might"„print "want to get in the habit of inserting the following bit of code at the"„print "beginning of each new program you work on:"„print„color 14,0„print "quit$=inkey$"„print "if quit$=";„print quote$;„print "q";„print quote$;„print "then quit:"„color 11,0„print "(start on your program here)"„color 14,0„print "quit:"„print "end"„color 7,0„print„print "Start working on the program in that space above ";„print quote$;„print "quit:";„print quote$„print„color 10,0„print "press ENTER to continue";„input c$;„„„cls„color 7,0„print "Now, if you screw up and create a loop, all you have to do is press"„print quote$;„print "q";„print quote$;„print " and your program will terminate. (Sure beats having to reboot the"„print "computer!)"„print„color 11,0„print "The following program would loop forever:"„print„color 14,0„print "top:"„print "print ";„print quote$;„print "whatever";„print quote$„print "goto top:"„color 7,0„print„color 11,0„print "This one would too, but you could get out by pressing ";„print quote$;„print "q";„print quote$;„print„print„color 14,0„print "top:"„print "quit$=inkey$"„print "if quit$=";„print quote$;„print "q";„print quote$;„print " then quit:"„print "print ";„print quote$;„print "whatever";„print quote$„print "goto top:"„print "quit:"„print "end"„color 11,0„print„print "...thereby saving you tons of frustration!"„print„print„print„color 10,0„print "press ENTER to continue";„input c$;„„example:„quit$=inkey$„if quit$="q" then nowwhat:„rem if quit$="t" then top: (take out the rem to make t work here)„print "whatever (remember the q to quit thing)"„goto example:„„nowwhat:„cls„color 11,0„„print "Here is the code that created that annoying loop just then:"„print„color 14,0„„print "example:"„print "quit$=inkey$"„print "if quit$=";„print quote$;„print "q";„print quote$;„print " then nowwhat:"„print "print ";„print quote$;„print "whatever (remember the q to quit thing)";„print quote$„print "goto example:"„print„color 11,0„print "You may have as many if-then statements as you want following the"„print "line that equates a variable name to inkey$. That is, you can create"„print "as many options as you need. Just remember to provide target labels"„print "for each option. This next bit, for instance, would accept either q"„print "or t to break the loop:"„print„color 14,0„print "example:"„print "quit$=inkey$"„print "if quit$=";„print quote$;„print "q";„print quote$;„print " then nowwhat:"„print "if quit$=";„print quote$;„print "t";„print quote$;„print " then top:"„print "print ";„print quote$;„print "whatever";„print quote$„print "goto example:"„„locate 22,0„color 10,0„print "press ENTER to leave the inkey$ segment altogether"„print "press W, then ENTER to look at the (W)hole inkey$ segment again";„input nowwhat$;„nowwhat$=ucase$(nowwhat$)„if nowwhat$="" then menu:„if nowwhat$="W" then inkeytop:„„rem ***********************************************************************„„rem PRINT.ASI (or PRINT.TXT)„rem by Dave Gjessing, 8/14/95„rem demonstration of print keyword„„printtop:„cls„color 14,0„„rem see COLOR.TXT„„rem One of the first things I discovered while fooling with this is that„rem a string constant can apprently not contain quotation marks INSIDE„rem of the beginning and ending quotation marks that DEFINE it. So, I had„rem to go to the ASCII chart and get the value for a " , which is 34, and„rem assign that value to a variable (quote$). I couldn't see any other way„rem to make - PRINT "This segment demonstrates the PRINT keyword" show up„rem on the screen complete.„rem So, all of this is apparently required:„„quote$=chr$(34)„print "PRINT ";„print quote$;„print "This segment demonstrates the PRINT keyword.";„print quote$„„rem (Whew! :) )„„color 7,0„print„color 15,0„print "This segment demonstrates the PRINT keyword."„color 7,0„print„print "The PRINT keyword is used to print things on the screen. In the"„print "example above, the yellow text is the actual line from the .asi file"„print "that causes the bright white message below it to show up on the screen." „print„color 11,0„print "The syntax is: PRINT [printobject1 [;] ]"„print„color 7,0„print "To quote from the 80/20 Software documentation:"„print„color 11,0„print "Printobject1 is defined as any valid ASIC data type: integer constant,"„print "integer variable, decimal constant, decimal variable, string constant,"„print "string variable, and arrays. The semicolon is optional and is used to"„print "tell ASIC if you want a carriage return/line feed issued."„color 7,0„print„print "My example above shows a string constant. Since there is NO semicolon"„print "at the end, ASIC issues a carriage return/line feed once the print"„print "operation is completed. If there WERE a semicolon at the end, then the"„print "next print operation would start on the same line, right after the"„„rem Here is that quotation mark work-around again...„„print "word ";„print quote$;„print "keyword";„print quote$;„print ". (ie: ";„print quote$;„print "...keyword.The PRINT keyword is used to ...";„print quote$;„print ")"„print„color 10,0„print "press ENTER to continue";„input c$;„„tryit:„cls„color 15,0„print "Here, make your own example. Type in your name."„print„color 7,0„input name$;„print„print„print "The line that you would need to type into your .asi file in order to"„print "have your program print your name on the screen would be this:"„print„color 14,0„print "PRINT ";„print quote$;„print name$;„print quote$„print„color 7,0„print "... and that would result in the following display:"„print„print name$„print„color 11,0„print "These examples show only one of the several valid data types, that"„print "being string constants. Like it says in the program documentation,"„print "however, any data type may be ";„print quote$;„print "printed";„print quote$;„print "."„print„print "This print example program, PRINT.COM uses string constants and also"„print "string variables. While writing it, I discovered a few things about"„print "ASIC that I had not known before (which isn't surprising, since I've"„print "only been working with programing for a little while). Read the file"„print "PRINT.TXT to see how PRINT.COM works."„print„color 10,0„print "press ENTER to continue";„input c$;„„cls„color 10,0„locate 20,0„print "press ENTER to leave the print segment altogether"„print "press W, then ENTER to look at the (W)hole print segment again"„print "press I, then ENTER to try (I)nputing your name again only"„input nowwhat$;„nowwhat$=ucase$(nowwhat$)„if nowwhat$="" then menu:„if nowwhat$="W" then printtop:„if nowwhat$="I" then tryit:„„rem ***********************************************************************„„rem SOUND.ASI„rem Dave Gjessing 8/21/95„rem a demonstration of the SOUND keyword„„rem I'm thinking that this will be based on the COLOR segment, behave the„rem same way, etc.„„rem DRAFT!!!!!!!!!!!!!„„soundtop:„cls„color 14,0„print "This is a demonstration of the SOUND keyword."„print„color 11,0„print "The syntax for the SOUND keyword is:"„print„color 14,0„print "sound [frequency, duration]"„print„color 11,0„print "Frequency and Duration are expressed as numbers. Frequencies"„print "can run from 0 to 32,767. Durations can run higher..."„print„color 7,0„print "Frequencies are backwards from what you might expect, with a higher"„print "number resulting in a lower sound. Duration seems to be a function"„print "of the Frequency. That is, a 400/200 sound takes the same amount of"„print "real time as a 200/400 sound. Beware that long Durations with low "„print "Frequencies can take a LONG time to execute..."„print„print "Create your own sample sound. Type in a number for each variable:"„print„print "Frequency: ";„input frequency&;„if frequency&>32767 then soundtop:„print„print„print " Duration: ";„input duration&;„cls„„print„print„color 14,0„print "Here here is an ASIC sound with a Frequency of:";„print frequency&„print "                             and a duration of:";„print duration&„sound frequency&, duration&„locate 24,0„color 10,0„print "press ENTER to do another sound, Q and ENTER to quit sound";„input c$;„c$=ucase$(c$)„if c$="Q" then menu:„if c$="" then soundtop:„„rem ***********************************************************************„John A. Kiernan                DOS COMMANDS IN ASIC PROGRAMS  kiernan@uwo.ca                 01-11-96 (22:22)       ASIC                   118  6064     GETCOMSP.ASIrem   GETCOMSP.ASI  An ASIC (version 4 or 5) program that:„rem     (a) teaches the use of CALL for using internal DOS commands within„rem         an executable file. Much easier with ASIC than with QuickBasic!„rem         and it compiles to less than a tenth the size of a QB executable„rem         file.„rem     (b) shows how to make and write to a simple text file without„rem         having to bother with "OPEN" and "CLOSE"„rem   Read the last few lines of this file for compiling instructions.„rem   ===========„rem     Format 1 of ASIC's CALL command allows you to carry out internal„rem     and external DOS commands in a .COM or .EXE program made by ASIC.„rem     The syntax of Format 1 is  CALL (string1,string2)  where string1 is„rem     the full name of an executable program, and string2 contains its„rem     argument(s), including a leading space and any switches, etc.„rem  ============„rem     To run an internal DOS command (also, to run a batch file),„rem     string1 must be the current COMSPEC, found in the DOS "environment"„rem       You could change Env=30000 to Env=30 without offending anyone but„rem       the most eccentric batch file zealot! However, allowing for a huge„rem       environment does not enlarge or slow down the compiled program.„rem   ===========„       FOR Env = 1 TO 30000„           Env$=ENVIRON$(Env)„             Comsp=INSTR(Env$,"COMSPEC")„               IF Comsp > 0 THEN„                 Comspec$=Env$„                 GOTO GotIt:„               ENDIF„       NEXT Env„                rem  The program cannot get this far (unless you have been„                rem  silly and have removed the COMSPEC statement from the„                rem  environment.„       PRINT "Couldn't find COMSPEC - This should be utterly impossible."„       GOTO Finished:„rem                     The next lines extract the COMSPEC„rem                     (after the = sign) and display it.„   GotIt:„       Length=LEN(Comspec$)„       EqualsPos=INSTR(Comspec$,"=")„       ComspLength=Length-EqualsPos„       Comspec$=RIGHT$(Comspec$,ComspLength)„       PRINT Comspec$„rem                     Pause the screen display„       PRINT "Press any key to continue . . ."„   Wait:„       Key$=INKEY$„         IF Key$="" THEN Wait:„rem                            Comspec$ shows which command processor you„rem                            are using. This may not be C:\COMMAND.COM.„rem                            See NOTES_AT_END:„rem   * ASIC's  CALL  is used to invoke DOS internal commands.      *„rem   * Spaces around /C matter a lot!  You can't add the " /C" to  *„rem   * the  Comspec$  variable.   The  /C  (with space before and  *„rem   * after) MUST be in the second part (string2) of the argument *„rem   * that follows CALL.  See also NOTES_AT_END:                  *„         CALL (Comspec$," /C dir/w")„         CALL (Comspec$," /C ver")„         CALL (Comspec$," /C path")„rem   ===========„rem  The argument following the /C  can be quite complicated,„rem  BUT IT CANNOT BE VERY LONG - an annoyance, mentioned in the„rem  commented code that follows.„ CALL (Comspec$," /C echo 12345678901234567890123456789012345678901234567890")„ PRINT " Only the first 24 of these numerals are displayed on the screen."„rem   ===========„rem  Redirection & piping are OK.  The next line makes a text„rem  file called JUNK in the default directory.„        CALL (Comspec$," /C echo This file is Junk! >JUNK")„rem        The above example illustrates the limitation of the„rem        length of string2 in ASIC's CALL command.  If you add„rem        one space anywhere in the string (for example, after„rem        "echo" or after ">" the string is truncated and makes„rem        a file named JUN instead of JUNK.„rem            You cannot get round this length limitation by using a„rem        variable for string2.„rem   ===========„rem  To append things to a file, use the DOS convention of„rem  two greater-than signs.„       CALL (Comspec$," /C echo Second line >>JUNK")„       CALL (Comspec$," /C ver >> JUNK")„       CALL (Comspec$," /C echo. >>JUNK")„       CALL (Comspec$," /C set >> junk")„       CALL (Comspec$," /C echo. >>JUNK")„       PRINT "  Now enter TYPE JUNK at the DOS prompt, to read the"„       PRINT "  redirected and appended outputs of internal DOS commands"„       PRINT "  executed within GETCOMSP.COM"„       PRINT "                                 You can then delete JUNK."„       PRINT ""„rem   ===========„rem   With this tiny program you have made a file and added text to it„rem   without having to bother with the "OPEN" and "CLOSE" commands of„rem   ASIC and other BASIC languages. Once you get the hang of the ASIC's„rem   CALL command, it's nearly as easy as writing a batch file.„rem   ===========„   Finished:„       END„   NOTES_AT_END:„rem  Command processors.„rem     Wise users of computers know that 4DOS.COM is better in every way„rem     than the COMMAND.COM that comes with MS-DOS. 4DOS is not the only„rem     command processor that's better than COMMAND.COM - there's DR DOS„rem     and NDOS and probably others too.„rem  Punctuation of the CALL command.„rem     If the punctuation of the CALL (string1,string2) command is wrong,„rem     the compiled ASIC program (a) doesn't work, and (b) uses up„rem     oodles of memory in temporary command processors - about 60kB each„rem     time you run it. Recover the eaten memory by entering EXIT several„rem     times at the DOS prompt. The DOS 6.0 command MEM/c/p will show how„rem     much memory is being used or wasted.„rem  How to compile this program.„rem     If this file, named GETCOMSP.ASI is in the same directory„rem     as the ASIC program files, the command:„rem                                             ASICC GETCOMSP„rem     will make GETCOMSP.COM (2659 bytes).„rem   ===========„rem     Written and put in the public domain by John A. Kiernan, Jan.1996„rem                                             (kiernan@uwo.ca)„„John A. Kiernan                UTILITY SHOWING COLOUR NUMBERS kiernan@uwo.ca                 01-14-96 (22:22)       ASIC                   157  4104     COL.ASI     rem  COL.ASI    Displays the 16 colours on the 8 backgrounds.„rem             Also shows composite colour attributes (single numbers).„rem             COL /f  to see numbers to use for flashing characters.„rem  Compile with ASIC version 3, 4 or 5 to make a .COM file.„     cls„     gosub announce:„     color 7,0„     arg$=command$„     arg$=ltrim$(arg$)„     arg$=rtrim$(arg$)„     arg$=lcase$(arg$)„     flash=instr(arg$,"f")„     spaces$=space$(39)„     locate 3,0„     gosub printtop:„       if flash>0 then flash:„     locate 2,0„     print "           Enter  COL /f  for numbers for flashing colours."„     locate 4,0„       for fg=0 to 15„          for bg=0 to 7„            gosub displayforegroundandbackground:„          next bg„       next fg„     goto finished:„  flash:„     locate 2,0„     print "           Enter  COL  without the  /f  for non-flashing colours."„     locate 4,0„       for fg=0 to 15„         for bg=8 to 15„           gosub displayforegroundandbackground:„         next bg„       next fg„  finished:„     gosub printbottom:„     print spaces$;„     print "Press any key . . ."„     gosub wait:„     locate 0,17„     print "composite colour attributes.                          "„     locate 3,0„       gosub printtop:„         if flash>0 then flashsingle:„         for fg=0 to 15„            for bg=0 to 7„               gosub displaysinglenumbers:„            next bg„       next fg„     goto theend:„  flashsingle:„     locate 3,0„     gosub printtop:„       for fg=0 to 15„          for bg=8 to 15„             gosub displaysinglenumbers:„          next bg„       next fg„  theend:„     gosub printbottom:„     print spaces$;„     print spaces$„     end„„rem  Subroutines follow.„„  announce:„         locate 0,0„         print "  COL.COM  Shows numbers for foreground and background colours."„         print "           (Version 1.0)           by  J. A. Kiernan  (c)  1996"„         return„„  printtop:„         print " ⁄";„         print "ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ";„         print "ø"„     return„„  printbottom:„         print " ¿";„         print "ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ";„         print "Ÿ";„         print ""„     return„„  displayforegroundandbackground:„         gosub getforegroundandbackground:„         color fg,bg„         print fg$;„         print " on ";„         print bg$;„         color 7,0„         print "≥";„         gosub linefull:„     return„„  getforegroundandbackground:„           if bg=0 then„             print " ≥";„           endif„           if bg=8 then„             print " ≥";„           endif„         fg$=str$(fg)„         fg$=ltrim$(fg$)„           if fg<10 then„             fg$=" "+fg$„           endif„         bg$=str$(bg)„         bg$=ltrim$(bg$)„           if bg<10 then„                 bg$=bg$+" "„           endif„     return„„  displaysinglenumbers:„         gosub getforegroundandbackground:„         gosub getsinglenumbers:„         color fg,bg„         print singlenumber$;„         color 7,0„         print "≥";„         gosub linefull:„     return„„  getsinglenumbers:„         singlenumber=bg*16„         singlenumber=singlenumber+fg„         singlenumber$=str$(singlenumber)„         singlenumber$=ltrim$(singlenumber$)„           if singlenumber<100 then„             if singlenumber<10 then„               if bg=0 then„                 singlenumber$="  "+singlenumber$„                 goto bgnotzero:„               endif„                 singlenumber$="  "+singlenumber$„             endif„             singlenumber$=" "+singlenumber$„           endif„  bgnotzero:„         singlenumber$="  "+singlenumber$„         singlenumber$=singlenumber$+"   "„     return„„  linefull:„         linefull=pos(0)„           if linefull > 68 then„             print ""„           endif„     return„„  wait:„         key$=inkey$„         if Key$="" then wait:„     return„„Tony D. Jones                  SCROLLING STARFIELD            arafel@ix.netcom.com           02-16-96 (00:00)       ASIC                   164  3573     STARFLD.ASI REM Author: arafel@ix.netcom.com (Tony D.J.)„REM STARFLD.ASI -- Creates a layered, side scrolling starfield.„REM Developed with ASIC 5.00„REM Written by Tony Jones -- 2/16/96„REM Notes: My goal was to write this entirely in Basic without any use of„REM        external assembly routines.„REM You can add more or less stars by changing the values in the DIM„REM statements and the the NumStars variable„„REM Arrays to hold our stars x,y,plane and colors„REM We have to use 4 different arrays because ASIC doesn't support„REM user defined types(i.e. structures).„„DIM Star_X(100)„DIM Star_Y(100)„DIM Star_P(100)„DIM Star_C(100)„„REM Variables to hold the old x,y positions so we don't have to erase the„REM whole screen„„DIM Old_X(100)„DIM Old_Y(100)„„REM Variable for the Number of stars we want„NumStars=100„„REM Variables to move the stars at different "velocities"„velocity_1=1„velocity_2=2„velocity_3=4„„REM Variable to store our visible and hidden video page„VisiblePage=&hex0000„HiddenPage=&hex0100„„REM Variable to store the color black„ColorBlack=&hex0C00„„REM Set the video mode to 320x200, 16 colors„REM We use this mode because we have multiple video pages and we can use„REM page flipping techniques to animate the starfield„SCREEN 7„„„REM Main program loop starts here„GOSUB InitStarfield:„„AnimateLoop:„ GOSUB UpdateStarfield:„ GOSUB DrawStarfield:„ GOSUB ShowPage:„„Wait:„ K$=INKEY$„ IF K$ = "" THEN„  GOTO AnimateLoop:„ ELSE„  SCREEN 0„  END„ ENDIF„„REM Here we setup the starfield„InitStarfield:„RANDOMIZE„„ REM Fill in the x,y positions„ FOR count=0 TO NumStars„  X=RND(0)„  X=X MOD 320„  Y=RND(0)„  Y=Y MOD 200„  Star_X(count)=X„  Star_Y(count)=Y„„  Plane=RND(0)„  Plane=Plane MOD 3„  IF Plane = 0 THEN„   Star_P(count) = 1„   Star_C(count) = &hex0C08„  ENDIF„„  IF Plane = 1 THEN„   Star_P(count) = 2„   Star_C(count) = &hex0C07„  ENDIF„„  IF Plane = 2 THEN„   Star_P(count) = 3„   Star_C(count) = &hex0C0F„  ENDIF„ NEXT count„RETURN„„REM Here's where we draw the starfield„DrawStarfield:„ FOR count = 0 TO NumStars„  REM We use the BIOS pixel setting routine so that we can specify which„  REM video page to draw on„  AX=Star_C(count)„  BX=HiddenPage„  CX=Star_X(count)„  DX=Star_Y(count)„  INT86(&hex10,AX,BX,CX,DX,NA,NA,NA,NA,NA)„ NEXT count„RETURN„„REM Here's where we flip the video pages„ShowPage:„ IF VisiblePage=&hex0000 THEN„  AX=&hex0501„  HiddenPage=&hex0000„  VisiblePage=&hex0100„ ELSE„  AX=&hex0500„  HiddenPage=&hex0100„  VisiblePage=&hex0000„ ENDIF„„ REM Now let the BIOS flip the page„ INT86(&hex10,AX,NA,NA,NA,NA,NA,NA,NA,NA)„„ REM Now we clear the hidden page to black„ FOR count=0 to NumStars„  AX=ColorBlack„  BX=HiddenPage„  CX=Old_X(count)„  DX=Old_Y(count)„  INT86(&hex10,AX,BX,CX,DX,NA,NA,NA,NA,NA)„ NEXT count„RETURN„„REM Animates the starfield by moving the pixels in the x direction„UpdateStarfield:„ FOR count=0 TO NumStars„„ REM Save the old x,y positions„ Old_X(count)=Star_X(count)„ Old_Y(count)=Star_Y(count)„„  IF Star_P(count)=1 THEN„   Star_X(count)=Star_X(count)+velocity_1„  ENDIF„„  IF Star_P(count)=2 THEN„   Star_X(count)=Star_X(count)+velocity_2„  ENDIF„„  IF Star_P(count)=3 THEN„   Star_X(count)=Star_X(count)+velocity_3„  ENDIF„„  REM Clip the x coordinate to the screen„  IF Star_X(count) > 319 THEN„   Star_X(count) = Star_X(count) - 320„  ENDIF„„  IF Star_X(count) < 0 THEN„   Star_X(count) = Star_X(count) + 319„  ENDIF„ NEXT count„RETURN„„„Ben McGaughey                  LINE DRAWING ROUTINE           www.iea.com/~benm              04-29-96 (00:00)       ASIC                   86   1620     LINE.ASI    REM Line Drawing program for ASIC 5.00„REM Programmed by Ben McGaughey„REM benm@iea.com„REM http://www.iea.com/~benm/„REM Date: April 29, 1996„„   REM X1,Y1,X2,Y2 are the starting and ending points of the line.„   X1@ = 22„   Y1@ = 3„„   X2@ = 120„   Y2@ = 155„„   SCREEN 13„„   XUNIT@ = 0„   YUNIT@ = 0„„   VALUE@ = Y1@ * 320„   OFFSET@ = VALUE@ + X1@„„   YDIFF@ = Y2@ - Y1@„„   IF YDIFF@ < 0 THEN„      YDIFF@ = -1 * YDIFF@„      YUNIT@ = -320„   ELSE„      YUNIT@ = 320„   ENDIF„„   XDIFF@ = X2@ - X1@„„   IF XDIFF@ < 0 THEN„      XDIFF@ = -1 * XDIFF@„      XUNIT@ = -1„   ELSE„      XUNIT@ = 1„   ENDIF„„   DEFSEG = &hexA000„„   IF XDIFF@ > YDIFF@ THEN„      LENGTH@ = XDIFF@ + 1„      FOR I@ = 0 TO LENGTH@„            POKE OFFSET@ , 15„            OFFSET@ = OFFSET@ + XUNIT@„            ERTERM@ = ERTERM@ + YDIFF@„            IF ERTERM@ > XDIFF@ THEN„                ERTERM@ = ERTERM@ - XDIFF@„                OFFSET@ = OFFSET@ + YUNIT@„            ENDIF„      NEXT I@„   ELSE„„   LENGTH@ = YDIFF@ + 1„   FOR I@ = 0 TO LENGTH@„       POKE OFFSET@ , 15„       OFFSET@ = OFFSET@ + YUNIT@„       ERTERM@ = ERTERM@ + XDIFF@„       IF ERTERM@ > 0 THEN„          ERTERM@ = ERTERM@ - YDIFF@„          OFFSET@ = OFFSET@ + XUNIT@„       ENDIF„   NEXT I@„„   ENDIF„„   PSET ( Y1@ , X1@ ) , 11„   PSET ( Y2@ , X2@ ) , 11„„   W0:„   VALUE0$ = INKEY$„   VALUE1$ = ""„   IF VALUE0$ = VALUE1$ THEN„       VALUE0 = 1„   ELSE„       VALUE0 = 0„   ENDIF„   IF VALUE0 <> 0 THEN„   ENDIF„   IF VALUE0 <> 0 THEN W0:„„   SCREEN 0„   WIDTH 80„„   END„Keith Olson                    SINGLE CHARACTER REPLACER      FidoNet QUIK_BAS Echo          05-10-96 (07:33)       ASIC                   246  4946     SCR.ASI     REM   Here is a program that I wrote in ASIC to change one character to„REM  another.  It isn't fancy, but it works. The syntax is:„REM„REM  SCR inputfile outputfile searchchar replacechar„REM  e.g. SCR manual.doc manual.fp 32 255„REM„REM  BTW, while it can replace ASCII 0 with something else, it can't do„REM  the reverse.„„cls„bg1=0„bg2=0„fg1=7„fg2=15„color fg2,bg1„print "S";„color fg1,bg1„print "ingle ";„color fg2,bg1„print "C";„color fg1,bg1„print "haracter ";„color fg2,bg1„print "R";„color fg1,bg1„print "eplacer v1.0·"„print "Copyright 1996, K-Soft Consulting"„print ""„„cmd$=command$„cmd$=ucase$(cmd$)„cmd$=ltrim$(cmd$)„cmd$=rtrim$(cmd$)„Tmp1=len(cmd$)„„if Tmp1=0 then MissingParams:„„Tmp1=instr(cmd$," ")„if Tmp1=0 then ShowSyntax:„„tmp2=tmp1-1„Param1$=left$(cmd$,Tmp2)„Param2$=Mid$(cmd$,Tmp1,127)„Param2$=ltrim$(Param2$)„„Tmp1=instr(Param2$," ")„if Tmp1=0 then MissingParams:„„Param3$=mid$(Param2$,Tmp1,127)„Param3$=ltrim$(Param3$)„Tmp1=Tmp1-1„Param2$=left$(Param2$,Tmp1)„„if Param1$=Param2$ then SameName:„„Tmp1=instr(Param3$," ")„if Tmp1=0 then MissingParams:„„Param4$=mid$(Param3$,Tmp1,127)„Param4$=ltrim$(Param4$)„Tmp1=Tmp1-1„Param3$=left$(Param3$,Tmp1)„„Param3=val(Param3$)„Param3=Param3 mod 256„Param4=val(Param4$)„Param4=Param4 mod 256„„InputFile$=find first (Param1$,0)„„   tmp1=len(InputFile$)„   if tmp1=0 then FileNotFound:„   OutputFile$=Param2$„   open "R",1,InputFile$„   EOF&=filepos(1,EOF)„   EOF&=EOF&+1&„   close 1„   open "I",1,InputFile$„   open "O",2,OutputFile$„„   locate 3,0„   print "   % done copying ";„   color fg2,bg2„   print Param1$;„   color fg1,bg1„   print " to ";„   color fg2,bg2„   print param2$„   color fg1,bg1„   print "Filtering out ";„   color fg2,bg2„   print "<ALT-";„   print param3$;„   print ">";„   color fg1,bg1„   print " and replacing with ";„   color fg2,bg2„   print "<ALT-";„   print param4$;„   print ">";„   color fg1,bg1„   print "."„   print„   print„   print "Press <ESC> to stop."„   print„   endy = csrlin„   color fg2,bg2„   OldTmp1&=0„   StartTime&=Timer„   I&=1&„   While i& < EOF&„      input# 1, InByte$ NONULL„      InByteAddr=varptr(InByte$)„      Tmp2=len(InByte$)„      OutByte$=space$(Tmp2)„      OutByteAddr=varptr(OutByte$)„      Tmp1&=Tmp2„      I&=I&+Tmp1&„      Tmp2=Tmp2-1„„      for j = 0 to Tmp2„         Tmp1=InByteAddr+j„         InByte=peek(Tmp1)„         Tmp1=OutByteAddr+j„         if InByte=Param3 then„            poke Tmp1, Param4„            Replacements&=Replacements&+1&„         else„            poke Tmp1,InByte„         endif„      next j„„      print#2, OutByte$ NONULL„„      tmp1&=i&*100„      Tmp1&=Tmp1&/EOF&„      if Tmp1& > OldTmp1& then„         tmp1$=str$(Tmp1&)„         Tmp1$=right$(tmp1$,3)„         locate 3,0„         print tmp1$;„         locate 25,88„         OldTmp1&=Tmp1&„         Tmp1$=inkey$„         Tmp2$=chr$(27)„         if Tmp1$=Tmp2$ then UserInt:„      endif„   wend„„   EndTime&=Timer„   Tmp1&=EndTime&-StartTime&„   Tmp2&=Tmp1& / 18„   Tmp1&=Tmp2& / 60„   Tmp2&=Tmp2& mod 60„   locate 6,0„   color fg1,bg1„   print "Replacements - ";„   tmp1$=str$(Replacements&)„   Tmp1$=ltrim$(tmp1$)„   color fg2,bg2„   print tmp1$;„   print "                                                         "„„   color fg1,bg1„   print "Total Bytes  - ";„   color fg2,bg2„   Tmp1$=str$(EOF&)„   Tmp1$=ltrim$(Tmp1$)„   print Tmp1$;„   print "                                            "„„   color fg1,bg1„   print "Total Time   - ";„   color fg2,bg2„   tmp1$=str$(Tmp1&)„   Tmp1$=ltrim$(tmp1$)„   print Tmp1$;„   print"m ";„   tmp1$=str$(Tmp2&)„   Tmp1$=ltrim$(tmp1$)„   print Tmp1$;„   print "s                                           "„„   color fg2,bg2„   locate 10,0„   print "Finished.                                       "„   goto Done:„„SameName:„   msg$="Cannot Overwrite Source File.                    "„   goto PrintError:„„UserInt:„„   msg$= "Interrupted by User.                            "„   goto PrintError:„„FileNotFound:„„   msg$= Param1$+" Not Found.                             "„„PrintError:„„   locate 7,0„   color fg2,bg2„   print msg$„   color fg1,bg1„   for i = 0 to 3„       tmp1$=space$(78)„       print tmp1$„   next i„   goto Done:„„MissingParams:„„   msg$= "Missing Parameters.                             "„„ShowSyntax:„„   locate 3,0„   color fg2,bg2„   print msg$„   color fg1,bg1„   print„   print„   print "SCR Replaces oldchar in source.fil with newchar.  Output goes"„   print "to target.fil."„   print„   print "Syntax:"„   print "SCR source.fil target.fil oldchar newchar"„   print„„Done:„„   color fg1,bg1„   tmp1=csrlin„   tmp1=tmp1+2„   locate tmp1y,0„   print„„rem EndLoop: Tmp1$=inkey$„rem if Tmp1$="" then EndLoop:„close 1„close 2„end„Lars Orsedal                   WAV PLAYER WITHOUT SIZE LIMIT  comp.lang.basic.misc           02-21-96 (22:52)       ASIC                   47   1064     WAVPLAY.ASI REM From: Lars Orsedal <liquid@kuai.se>„REM Newsgroups: comp.lang.basic.misc„REM Subject: Wav player without size limit. (for Asic)„REM Date: Wed, 21 Feb 1996 22:52:26 +0100„„REM Here is a simple sample-player for Asic! You can play files at any size with„REM it, and if you want to change the playback-frequency, just mix with the„REM FOR-NEXT loop a bit... Be sure to load SmartDrive before you use it or the„REM playback will be crappy :(  (I'm working on a cache-system to fix that.)„„RESET:„OUT &HEX226,1„OUT &HEX226,0„RESETLOOP:„X=INP(&HEX22E)„BIT7=ZBIT(7,X)„IF BIT7=0 THEN RESETLOOP:„X=INP(&HEX22A)„IF X=&HEXAA THEN RESETCLEAR:„GOTO RESETLOOP:„RESETCLEAR:„PRINT "RESET"„„SPEAKERON:„X=INP(&HEX22C)„BIT7=ZBIT(7,X)„IF BIT7=1 THEN SPEAKERON:„OUT &HEX22C,&HEXD1„„WAVPLAY:„OPEN "I",1,"X.WAV"„READWAV:„INPUT# 1,WAVE$ BYTE„WAVE=ASC(WAVE$)„I$=INKEY$„IF I$=" " THEN END:„IF ERROR=99 THEN ENDOFFILE:„IF WAVE=0 THEN READWAV:„OUT &HEX22C,&HEX10„FOR A=1 TO 225„NEXT A„OUT &HEX22C,WAVE„GOTO READWAV:„„END:„ENDOFFILE:„CLOSE 1„Ben McGaughey                  GET DOS VERSION                www.iea.com/~benm              05-27-96 (00:00)       ASIC                   69   1510     ASIREG.ASI  AX=&hex3000„INT86(&hex21,AX,BX,CX,DX,NA,NA,NA,NA,NA)„„REM  Read AH„„F=1„„REM Change the binary number stored in the first 8 bits of„REM AX to a decimal number.„for i = 0 to 7„T = zbit(i,AX)„If T = 1 then„   Z = Z+F„endif„F=F*2„next i„„REM Change the value in AX to a string for clean output.  The loop„REM just determines if the number returned is 1, 2 or 3 digits.„mah$ = str$(z)„If z > 9 then„   If z > 99 then„   mah$ = right$(mah$,3)„   else„   mah$=right$(mah$,2)„   endif„   else„   mah$=right$(mah$,1)„endif„„REM Read AL„F=1„T=0„Z=0„„REM This is the same process as before only we are reading the last„REM 8 bits stored in AX which is actually AL.„for i = 8 to 15„T = zbit(i,AX)„If T = 1 then„   Z = Z+F„endif„F=F*2„next i„mal$ = str$(z)„If z > 9 then„   If z > 99 then„   mal$ = right$(mal$,3)„   else„   mal$=right$(mal$,2)„   endif„   else„   mal$=right$(mal$,1)„endif„„Print "DOS Version: ";„Print mah$;„Print ".";„Print mal$„Print„Print "Some interrupts called in assembly return values in the 8 bit"„Print "registers such as AH,AL,BH,BL,CH,etc...  This program demonstrates"„Print "how to rip apart the 16 bit registers into 8 bit registers for"„Print "reading and evaluating.  In the program it is simple to change"„Print "from the AX register to BX or CX or DX by simply changing all of"„Print "the AX's in the program to what you want and the variable mah$ to"„Print "mbh$ or mch$.  I think you get it now so whatever."„„end„Stuart McLachlan               ENVIRONMENT PATHNAME           comp.lang.basic.misc           07-11-96 (16:56)       ASIC                   32   791      PATH.ASI    Rem Get Program Segment Prefix Address„    Ax=&Hex6200„    Int86(&Hex21,Ax,Bx,Na,Na,Na,Na,Na,Na,Na)„    Defseg = Bx„„Rem Get Address Of Environment Block„    Lo = Peek(&Hex2c)„    Hi = Peek(&Hex2d)„    Env = Hi * 256„    Env = Env + Lo„    Defseg = Env„„Rem Get Environment Length„    For Environment = 0 To 511„       Temp=Peek(Environment)„       If Temp = 1 Then„           Locationstart = Environment + 2„           Environment = 511„       Endif„    Next Environment„„Rem Get File Location Data„   For Filelocation = Locationstart To 511„      Temp = Peek(Filelocation)„      If Temp <> 0 Then„         Nextstring$ = Chr$(Temp)„        Fileloc$ = Fileloc$ + Nextstring$„      Else„      Filelocation = 511„      Endif„   Next Filelocation„Print Fileloc$„Tony Jones                     LOADS 320X200X256 PCX IMAGES   arafel1@ix.netcom.com          09-17-96 (00:00)       ASIC                   244  4320     SHOWPCX.ASI REM -- Filename: SHOWPCX.ASI„REM -- Developed with ASIC 5.00„REM -- Description: Decodes and displays 320x200,256 color PCX images„REM -- Date: September 17,1996„REM -- Author: Tony Jones„REM -- E-Mail: arafel1@ix.netcom.com„„REM -- Use in any way you wish, but give credit where credit is due. :-)„REM -- Compile with Extended Math on.„„REM -- Decodes a PCX file, fades the image in, waits for a key press„REM -- and then fades the image out.„„REM -- Array's to hold the palette data.„DIM Red(256)„DIM Green(256)„DIM Blue(256)„„REM -- We parse the command line for the name of our PCX file.„FileName$=COMMAND$„FileName$=LTRIM$(FileName$)„„IF FileName$ = "" THEN„„ PRINT„ PRINT "USAGE: SHOWPCX <filename>, where filename is a 320x200, 256 color"„ PRINT "PCX file with extension."„ PRINT„„ END„„ENDIF„„REM -- Enter Mode 13h„SCREEN 13„„REM --  Open the file„OPEN "R",1,FileName$„„REM -- Check to see if the file exist„IF ERROR > 0 THEN„ SCREEN 0„ PRINT„ PRINT " Error opening ";„ PRINT FileName$;„ PRINT "!"„ PRINT„ END„ENDIF„„REM -- Check to see if its a 320x200, 256 color PCX file„REM -- The first byte should be 10, the second should be 5.„INPUT#1, Man$ BYTE„Check = ASC(Man$)„IF Check <> 10 THEN„ CLOSE 1„ SCREEN 0„ PRINT„ PRINT " Not a valid PCX file!"„ PRINT„ END„ENDIF„„INPUT#1, Ver$ BYTE„Check = ASC(Ver$)„IF Check <> 5 THEN„ CLOSE 1„ SCREEN 0„ PRINT„ PRINT " Not a valid PCX file!"„ PRINT„ END„ENDIF„„REM -- Set the palette to black so we can fade the image in later.„FOR Index = 0 TO 255„  OUT(&hex3c8,Index)„  OUT(&hex3c9,0)„  OUT(&hex3c9,0)„  OUT(&hex3c9,0)„NEXT Index„„„REM -- Load the palette.„REM -- Position the file pointer 768 bytes from the end of the file.„LENG& = FILELEN(FileName$)„LENG& = LENG& - 768&„Temp&=FILEPOS(1,LENG&)„„FOR Index = 0 TO 255„ REM -- Get the red,green and blue values„ INPUT#1, R$ BYTE„ INPUT#1, G$ BYTE„ INPUT#1, B$ BYTE„„ Red(Index) = ASC(R$)„ Red(Index) = Red(Index) / 4„ Green(Index) = ASC(G$)„ Green(Index) = Green(Index) / 4„ Blue(Index) = ASC(B$)„ Blue(Index) = Blue(Index) / 4„NEXT Index„„„REM -- Position the file pointer 128 bytes from the start„Temp&=FILEPOS(1,128)„„REM -- Decode the PCX data„„Counter& = 0&„WHILE Counter& < 64000&„„ REM -- Get the data„ INPUT#1, Dat$ BYTE„„ REM -- See if this is a run.„ ACode = ASC(Dat$)„„ IF ACode > 191 THEN„  REM -- How many bytes are in the run.„  NumBytes = ACode - 192„„  REM -- Get the actual data for the run„  INPUT#1, Dat$ BYTE„  ACode = ASC(Dat$)„„  REM -- Put the data on the screen NumBytes times.„  DEFSEG = &hexA000„„  WHILE NumBytes > 0„   POKE Counter&,ACode„   Counter& = Counter& + 1&„   NumBytes = NumBytes - 1„  WEND„„  DEFSEG = -1„„ ELSE„  REM -- Else just put the data on the screen„  DEFSEG = &hexA000„„  POKE Counter&,ACode„  Counter& = Counter& + 1&„„  DEFSEG = -1„„ ENDIF„„WEND„„REM -- Close the file„CLOSE 1„„REM -- Fade the image in„FOR Count = 0 TO 31„„ FOR Index = 0 TO 255„„  OUT(&hex3c7,Index)„  TR = INP(&hex3c9)„  TG = INP(&hex3c9)„  TB = INP(&hex3c9)„„  IF TR < Red(Index) THEN„   TR = TR + 2„  ENDIF„„  IF TG < Green(Index) THEN„   TG = TG + 2„  ENDIF„„  IF TB < Blue(Index) THEN„   TB = TB + 2„  ENDIF„„  OUT(&hex3c8,Index)„  OUT(&hex3c9,TR)„  OUT(&hex3c9,TG)„  OUT(&hex3c9,TB)„„ NEXT Index„„„ REM -- Delay for a while to make the fade smooth.„ Thn& = TIMER„ Elapsed& = 0&„ WHILE Elapsed& < 2&„  Now& = TIMER„  Elapsed& = Now& - Thn&„  Elapsed& = ABS(Elapsed&)„ WEND„„NEXT Count„„K$=""„REM -- Wait for a key press and then exit„WHILE K$=""„ K$=INKEY$„WEND„„REM -- Fade the image out„FOR Count = 0 TO 31„„ FOR Index = 0 TO 255„„  OUT(&hex3c7,Index)„  TR = INP(&hex3c9)„  TG = INP(&hex3c9)„  TB = INP(&hex3c9)„„  IF TR > 0 THEN„   TR = TR - 2„  ENDIF„„  IF TG > 0 THEN„   TG = TG - 2„  ENDIF„„  IF TB > 0 THEN„   TB = TB - 2„  ENDIF„„  OUT(&hex3c8,Index)„  OUT(&hex3c9,TR)„  OUT(&hex3c9,TG)„  OUT(&hex3c9,TB)„„ NEXT Index„„ REM -- Delay for a while to make the fade smooth.„ Thn& = TIMER„ Elapsed& = 0&„ WHILE Elapsed& < 2&„  Now& = TIMER„  Elapsed& = Now& - Thn&„  Elapsed& = ABS(Elapsed&)„ WEND„„NEXT Count„„REM -- Back to text mode„SCREEN 0„„END„