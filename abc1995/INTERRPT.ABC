The ABC Programmer             COMPLETE INTERRUPT LIST        INTERRUPT,LIST                 Unknown Date (00:00:00)None                   265  12675    BIOS.TXT    The Complete BIOS Interrupts from 0 through &H1F„„Interrupt 0        Divide By 0 (Generated if a program divides by 0)„Interrupt 1        Single Step (Used by debuggers) „Interrupt 2        NonMaskable Hardware Interrupr (NMI)„Interrupt 3        Breakpoint (Used by debuggers)„Interrupt 4        Overflow„Interrupt 5        Print Screen (Print Screen Key)„Interrupt 6        Reserved„Interrupt 7        Reserved„Interrupt 8        Time of Day„Interrupt 9        Keyboard„Interrupt &HA      Reserved„Interrupts &HB-&HF BIOS end interrupt routine, resets interrupt handler„„***************************************************************„**** Interrupt &H10 handles the screen at the lowest level ****„***************************************************************„„Interrupt 10 Service 0      Set Screen Mode„Interrupt 10 Service 1      Set Cursor Type„Interrupt 10 Service 2      Set Cursor Position„Interrupt 10 Service 3      Find Cursor Position„Interrupt 10 Service 4      Read Light Pen Position„Interrupt 10 Service 5      Set Active Display Page„Interrupt 10 Service 6      Scroll Active Page Up„Interrupt 10 Service 7      Scroll Active Page Down„Interrupt 10 Service 8      Read Attribute/Character at Cursor Position„Interrupt 10 Service 9      Write Attribute/Character at Cursor Position„Interrupt 10 Service &HA    Write Character ONLY at Cursor Position„Interrupt 10 Service &HB    Set Color Palette„Interrupt 10 Service &HC    Write Dot (Set Pixel)„Interrupt 10 Service &HD    Read Dot (Read Pixel color)„Interrupt 10 Service &HE    Teletype Write to Active Page„Interrupt 10 Service &HF    Return Video State„Interrupt 10 Service &H10   Set Palette Registers„Interrupt 10 Service &H10   Function 0 Set Individual Palette Register„Interrupt 10 Service &H10   Function 1 Set Overscan (Border) Register„Interrupt 10 Service &H10   Function 2 Set All Palette Registers„Interrupt 10 Service &H10   Function 7 Read Individual Palette Register„Interrupt 10 Service &H10   Function 8 Read Overscan (Border) Register„Interrupt 10 Service &H10   Set DAC Register„             Function &H10„Interrupt 10 Service &H10   Set DAC Registers„             Function &H12„Interrupt 10 Service &H10   Select Color Page Mode„             Function &H13„Interrupt 10 Service &H11   Character Generator„Interrupt 10 Service &H12   Alternate Select„„*******************************************************************„**** Interrupt &H11 determines equipment installed in computer ****„*******************************************************************„„ax bits              Indicates„----------------------------------------------------------------------„15,14         Number of Printer Installed„13            Internal modem installed (1 = yes)„12            Not Used„11,10,9       Number of RS-232 cards attached„8             Not Used„7,6           Number of diskette drives: 00=1 drive; 01=2 drives„5,4           Video type: 01=40x25 color; 10=80x25 color; 11=80x25 mono„3             Not Used„2             Mouse Installed„1             Math Coprocessor installed? (1 = yes)„0             Diskette drives installed? (1 = yes)„„*****************************************************************************„*** Interrupt &H12 determines the size of installed memory on motherboard ***„***                not on add-in cards                                    ***„*****************************************************************************„„*********************************************************„**** Interrupt &H13 handles diskette and disk drives ****„*********************************************************„„Interrupt &H13  Service 0        Reset Disk„Interrupt &H13  Service 1        Read Status of Last Operation„Interrupt &H13  Service 2        Read Sectors into Memory„Interrupt &H13  Service 3        Write Sectors to Disk„Interrupt &H13  Service 4        Verify Sectors„Interrupt &H13  Service 8        Return Drive Parameters„Interrupt &H13  Service &HA,&HB  Reserved„Interrupt &H13  Service &HC      Seek„Interrupt &H13  Service &HD      Alternate Disk Reset„Interrupt &H13  Service &HE,&HF  Reserved„Interrupt &H13  Service &H10     Test Drive Ready„Interrupt &H13  Service &H11     Recalibrate Hard Drive„Interrupt &H13  Service &H12-14  Diagnostic Services„Interrupt &H13  Service &H19     Park Heads PS/2 Only„„*************************************************„**** Interrupt &H14 handles I/O Serial Ports ****„*************************************************„„Interrupt &H14  AH=0  Initialize RS232 Port„Interrupt &H14  AH=1  Send Character Through Serial Port„Interrupt &H14  AH=2  Receive Character From Serial Port„Interrupt &H14  AH=3  Return Serial Port's Status„„Interrupt &H15 handles cassette port on the original PC„„**************************************************„**** Interrupt &H16 handles the keyboard data ****„**************************************************„„Interrupt &H16  Service 0   Read Key from Keyboard„Interrupt &H16  Service 1   Check if Key Ready to be Read„Interrupt &H16  Service 2   Find Keyboard Status„„********************************************„**** Interrupt &H17 handles the printer ****„********************************************„„Interrupt &H17  Service 0   Print Character in al„Interrupt &H17  Service 1   Initialize Printer Port„Interrupt &H17  Service 2   Read Printer Status into ah„„********************************„**** Interrupts &H18 - &H20 ****„********************************„„Interrupt &H18  is the resident ROM BASIC„Interrupt &H19  is the boot interrupt„„Interrupt &H1A  Service 0   Read Time of Day„Interrupt &H1A  Service 1   Set Time of Day„„Interrupt &H1B  KeyBoard Break Address„Interrupt &H1C  Timer Tick Interrupt„Interrupt &H1D  Video Parameter Tables„Interrupt &H1E  Diskette Parameters„Interrupt &H1F  Graphics Character Definitions„„Interrupt &H20  Program Terminate„„************************************************************„**** Interrupt &H21 Handles almost all DOS' capabilites ****„************************************************************„„Interrupt &H21  Service 0       Program Terminate„Interrupt &H21  Service 1       KeyBoard Input„Interrupt &H21  Service 2       Character Output on Screen„Interrupt &H21  Service 3       Standard Auxiliary Device Input„Interrupt &H21  Service 4       Standard Auxiliary Device Output„Interrupt &H21  Service 5       Printer Output„Interrupt &H21  Service 6       Console I/O„Interrupt &H21  Service 7       Console Input Without Echo„Interrupt &H21  Service 8       Console Input w/o Echo with ^C Check„Interrupt &H21  Service 9       Character String Print„Interrupt &H21  Service &HA     String Input„Interrupt &H21  Service &HB     Check Input Status„Interrupt &H21  Service &HC     Clear Keyboard Buffer and Invoke Service„Interrupt &H21  Service &HD     Disk Reset„Interrupt &H21  Service &HE     Select Disk„Interrupt &H21  Service &HF     Open Pre-existing File„Interrupt &H21  Service &H10    Close File„Interrupt &H21  Service &H11    Search for First Matching File„Interrupt &H21  Service &H12    Search for Next Matching File„Interrupt &H21  Service &H13    Delete Files„Interrupt &H21  Service &H14    Sequential Read„Interrupt &H21  Service &H15    Sequential Write„Interrupt &H21  Service &H16    Create File„Interrupt &H21  Service &H17    Rename File„Interrupt &H21  Service &H18    Internal to DOS„Interrupt &H21  Service &H19    Find Default Disk„Interrupt &H21  Service &H1A    Set the DTA Location„Interrupt &H21  Service &H1B    FAT Information for Default Drive„Interrupt &H21  Service &H1C    FAT Information for Specified Drive„Interrupt &H21  Service &H1D -  Internal to DOS„                Service &H20„Interrupt &H21  Service &H21    Random Read„Interrupt &H21  Service &H22    Random Write„Interrupt &H21  Service &H23    File Size„Interrupt &H21  Service &H24    Set Random Record Field„Interrupt &H21  Service &H25    Set Interrupt Vector„Interrupt &H21  Service &H26    Create a New Program Segment (PSP)„Interrupt &H21  Service &H27    Random Block Read„Interrupt &H21  Service &H28    Random Block Write„Interrupt &H21  Service &H29    Parse FileName„Interrupt &H21  Service &H2A    Get Date„Interrupt &H21  Service &H2B    Set Date„Interrupt &H21  Service &H2C    Get Time„Interrupt &H21  Service &H2D    Set Time„Interrupt &H21  Service &H2E    Set or Reset Verify Switch„Interrupt &H21  Service &H2F    Get Current Disk Transfew Area„Interrupt &H21  Service &H30    Get DOS Version Number„Interrupt &H21  Service &H31    Terminate Process and Keep Resident„Interrupt &H21  Service &H32    Internal to DOS„Interrupt &H21  Service &H33    Control-Break Check„Interrupt &H21  Service &H34    Internal to DOS„Interrupt &H21  Service &H35    Get Interrupt Vector„Interrupt &H21  Service &H36    Get Free Disk Space„Interrupt &H21  Service &H37    Internal to DOS„Interrupt &H21  Service &H38    Returns Country Dependent Information„Interrupt &H21  Service &H39    Create a Subdirectory„Interrupt &H21  Service &H3A    Delete a Subdirectory„Interrupt &H21  Service &H3B    Change Current Directory„Interrupt &H21  Service &H3C    Create a File„Interrupt &H21  Service &H3D    Open a File„Interrupt &H21  Service &H3E    Close a File Handle„Interrupt &H21  Service &H3F    Read from File or Device„Interrupt &H21  Service &H40    Write to File or Device„Interrupt &H21  Service &H41    Delete a File„Interrupt &H21  Service &H42    Move Read/Write Pointer„Interrupt &H21  Service &H43    Change File's Attribute„Interrupt &H21  Service &H44    I/O Control„Interrupt &H21  Service &H45    Duplicate a File Handle„Interrupt &H21  Service &H46    Force Duplication of a File Handle„Interrupt &H21  Service &H47    Get Current Directory on Specified Drive„Interrupt &H21  Service &H48    Allocate Memory„Interrupt &H21  Service &H49    Free Allocated Memory„Interrupt &H21  Service &H4A    SETBLOCK (Memory Allocation)„Interrupt &H21  Service &H4B    Load or Execute a program-EXEC„Interrupt &H21  Service &H4C    Exit with Return Code„Interrupt &H21  Service &H4D    Get Return Code of Subprocess„Interrupt &H21  Service &H4E    Find First Matching„Interrupt &H21  Service &H4F    Find Next Matching„Interrupt &H21  Service &H50H-  Internal to DOS„                Service &H53    „Interrupt &H21  Service &H54    Get Verify State„Interrupt &H21  Service &H55    Internal to DOS„Interrupt &H21  Service &H56    Rename File„Interrupt &H21  Service &H57    Get or Set a File's Date & Time„Interrupt &H21  Service &H58    Internal to DOS„Interrupt &H21  Service &H59    Get Extended Error DOS 3+„Interrupt &H21  Service &H5A    Create Unique File DOS 3+„Interrupt &H21  Service &H5B    Create a New File DOS 3+„Interrupt &H21  Service &H5C    Lock and Unlock Access to a File DOS 3+„Interrupt &H21  Service &H5E00  Get Machine Name DOS 3+„Interrupt &H21  Service &H5E02  Set Printer Setup DOS 3+„Interrupt &H21  Service &H5E03  Get Printer Setup DOS 3+„Interrupt &H21  Service &H5F03  Redirect Device DOS 3+„Interrupt &H21  Service &H5F04  Cancel Redirection DOS 3+„Interrupt &H21  Service &H61    Reserved„Interrupt &H21  Service &H62    Get Program Segment Prefix DOS 3+„Interrupt &H21  Service &H63-64 Reserved„Interrupt &H21  Service &H65    Get Extended Country Information„Interrupt &H21  Service &H6601  Get Global Code Page„Interrupt &H21  Service &H6602  Set Global Code Page„Interrupt &H21  Service &H67    Set Handle Count DOS 3.30„Interrupt &H21  Service &H68    Commit File (Write Buffers) DOS 3.30„Interrupt &H21  Service &H6C    Extended Open/Create DOS 4.0„„*************************************************************„**** Interrupts &H22 - &HFF are the remaining Interrupts ****„*************************************************************„„Interrupt &H22          Terminate Address„Interrupt &H23          Control Break Exit Address„Interrupt &H24          Critical Error Handle„Interrupt &H25          Absolute Disk Read„Interrupt &H26          Absolute Disk Write„Interrupt &H27          Terminate and Stay Resident„Interrupt &H28H-&H2E    Internal to DOS„Interrupt &H2F          Multiplex Interrupt„Interrupt &H30H-&H3F    DOS Reserved„Interrupt &H40H-&H5F    Reserved„Interrupt &H60H-&H66    Reserved for User Software„Interrupt &H67          LIM 4.0 Support„Interrupt &H68H-&H7F    Not Used„Interrupt &H80H-&H85    Reserved for BASIC„Interrupt &H86H-&HF0    Used by BASIC Interpreter„Interrupt &HF1H-&HFF    Not Used„The ABC Programmer             INTERRUPT 10H REFERENCE        INTERRUPT,10H,REFERENCE        Unknown Date (00:00:00)None                   265  8502     INT10H.TXT  ******************************************************„***  The Interrupt 10H Reference with ASM Examples ***„******************************************************„„INT 10H Service 0 Set Screen Mode„    Input „      AH=0„      AL=Mode„    ASM Example:„      Mov Ah,0      ; Interrupt Service 0„      Mov Al,3      ; 80x25 Color Text„      Int 10h       ; Call DOS Interrupt 10H„„BIOS     Display     Number     Adapter Cards    Maximum Pages„Mode(AL)  Lines    of Colors                        Allowed„--------------------------------------------------------------„  0       40x25     B&W text    CGA, EGA, VGA        8„  1       40x25     Color text  CGA, EGA, VGA        8„  2       80x25     B&W text    CGA, EGA, VGA        4(CGA),8(EGA,VGA)„  3       80x25     Color text  CGA, EGA, VGA        4(CGA),8(EGA,VGA)„  4      320x200      4         CGA, EGA, VGA        1„  5      320x200      B&W       CGA, EGA, VGA        1„  6      640x200    2(on/off)   CGA, EGA, VGA        1„  7       80x25      Mono       MGA, EGA, VGA        1(MDA),8(EGA/VGA)„  8      160x200      16        PCjr                 1„  9      320x200      16        PCjr                 1„  AH     640x200      1         PCjr                 1„  BH      Reserved for future use„  CH      Reserved for future use„  DH     320x200      16        EGA,VGA              8„  EH     640x200      16        EGA,VGA              4„  FH     640x350     Mono       EGA,VGA              2„  10H    640x350      16        EGA,VGA              2„  11H    640x480      2         VGA                  1„  12H    640x480      16        VGA                  1„  13H    320x200      256       VGA                  1„--------------------------------------------------------------„„INT 10H Service 1 Set Cursor Type„    Input„      AH=1„      CH=Cursor Start Line„      CL=Cursor End Line„    OutPut„      New Cursor„    ASM Example:„      Mov Ah,1      ; Interrupt Service 1„      Mov CH,3      ; This creates a flashing block cursor„      Mov CL,1      ; Like the one you see when you press the INSERT key„      Int 10H       ; Call DOS Interrupt 10H„„INT 10H Service 2 Set Cursor Position„    Input„      DH,DL = Row, Column„      BH = Page Number„      AH = 2„    OutPut„      Cursor position changed„    ASM Example:„      Mov Ah,2      ; Interrupt Service 2„      Mov DH,0      ; Row = 0„      Mov DL,0      ; Column = 0„      Int 10H       ; Call DOS Interrupt 10H„„INT 10H Service 3 Find Cursor Position„    Input„      BH = Page Number„      AH = 3„    OutPut„      DH,DL = Row,Column of Cursor„      CH,CL = Cursor Mode currently Set.„„INT 10H Service 4 Read Light Pen Position„    Input„      AH = 4„    OutPut„      AH = 0 Light Pen Switch Not Down„      AL = 1 DH,Dl = Row, Column of Light Pen Position„             CH Raster Line (Vertical) 0-199„             BX Pixel Column (Horizontal) 0-319,639„„INT 10H Service 5 Set Active Display Page„    Input„      AL = 0-7 (Screen modes 0,1)„           0-3 (Screen modes 2,3)„      AH = 5„    OutPut„      Active Page Changed„„INT 10H Service 6 Scroll Active Page Up„    Input„      AL = #lines blacnked at bottom (0=Blank whole area)„      CH,CL = Upper Left Row, Column of area to scroll.„      DH,DL = Lower Right Row, Column of area to scroll.„      BH = Attribute used on blank line.„      AH = 6„„INT 10H Service 7 Scroll Active Page Down„    Input„      AL = #lines blacnked at bottom (0=Blank whole area)„      CH,CL = Upper Left Row, Column of area to scroll.„      DH,DL = Lower Right Row, Column of area to scroll.„      BH = Attribute used on blank line.„      AH = 7„„INT 10H Service 8 Read Attribute and Character at Cursor Position„    Input„      BH = Page Number„      AH = 8„    OutPut„      AL = Character read (ASCII)„      BH = Attribute of character (Alphanumerics only).„„INT 10H Service 9 Write Attribute and Character at Cursor Position„    Input„      BH = Page Number„      BL -> Alpha Modes = Attribute;„            Graphics Mode = Color„      CX = Count of characters to write„      AL = IBM ASCII code„      AH = 9„    OutPut„      Character written on screen at Cursor Position„„INT 10H Service A Write Character ONLY at Cursor Position„    Input„      BH = Page Number„      CX = Count of characters to write„      AL = IBM ASCII code„      AH = 0AH„    OutPut„      Character written on screen at Cursor Position„„INT 10H Service B Set Color Palette„    Input„      BH = Palette Color ID„      BL BH = 0 -> BL = Background Color„         BH = 1 -> BL = Palette Number; (0=Green/Red/Yellow);„                                        (1=Cyan/Magenta/White)„      AH = 11„„INT 10H Service C Write Dot„    Input„      DX = Row Number(0-199)  [0,0] is upper left.„      CX = Column Number(0-319,639)„      AL = Color Value (0-3)„      AH = 12„„NOTE: If bit 7 of AL is 1, the color value is XORed with the current value„      of the dot.„„INT 10H Service D Read Dor„    Input„      DX = Row Number(0-199)„      CX = Column Number(0-319,639)„      AH = 13„    OutPut„      AL = Color Value (0-3)„„INT 10H Service E Teletype Write to Active Page„    Input„      AL = IBM ASCII Code„      BL = Foreground Color (Graphics Mode)„      AH = 14„„INT 10H Service FH Return Video State„    Input„      AH = 15„    OutPut„      AH = Number of alphanumeric columns on screen„      AL = Current mode„      BH = Active display page„„INT 10H Service 10H Set Palette Registers„    Default Palette Colors (0-15) on EGA„      0 = Black„      1 = Blue„      :„      14 = Yellow„      15 = Intense White„„INT 10H Service 10H Function 0 Set Individual Palette Register„    Input„      AH = 10H„      AL = 0„      BL = Palette register to set (0-15)„      BH = Value to set (0-63)„„INT 10H Service 10H Function 1 - Set Overscan (Border) Register„    Input„      AH = 10H„      BH = Value to set (0-63)„„INT 10H Servie 10H Function 2 - Set All Palette Registers„    Input„      AH = 10H„      AL = 2„      ES:BX = Address of a 17-byte table holding color selections (0-63)„              Byes 0-15 hold color selections of rpalette registers 0-15„              Byte 16 holds the new overscan (border) color„„INT 10H Service 10H Function 7 - Read Individual Palette Register„    Input„      AH = 10H„      AL = 7„      BL = Register to read (color value)„    OutPut„      BH = Register setting.„„INT 10H Service 10H Function 8 - Read Overscan (Border) Register„    Input„      AH = 10H„      AL = 8„    OutPut„      BH = overscan setting.„„INT 10H Service 10H Function 10H - Set DAC Register„    Input„      AH = 10H„      AL = 10H„      BX = Register to set (0-255)„      CH = Green Intensity„      CL = Blue Intensity„      DH = Read Intensity„„INT 10H Service 10H Function 12H - Set DAC Registers„    Input„      AH = 10H„      AL = 12H„      BX = First register to set (0-255)„      CX = Number of registers to set (1-256)„      ES:DX = Address of a table of color intensities.  Three bytes are used„              for each DAC Register (use only lower 6 bits of each byte).„              Table is set up: red, green, blue, red, green, blue...„„INT 10H Service 10H Function 13H - Select Color Page Mode„    Input„      AH = 10H„      Al = 13H„      BL = 0 Select Color Paging Mode„             BH = 0 Selects 4 DAC register pages of 64 registers each„             BH = 1 Selects 16 DAC register pages of 16 registers each„      BL = 1 Select Active Color Page„           For use with 4 page mode:„             BH = 0 Selects the first block of 64 DAC registers„             BH = 1 Selects the second block of 64 DAC registers„             BH = 2 Selects the third block of 64 DAC registers„             BH = 3 Selects the fourth block of 64 DAC registers„           For use with 16 page setting:„             BH = 0 Selects the first block of 16 DAC registers„             BH = 1 Selects the second block of 16 DAC registers„             :„             :„             BH = 15 Selects the 15th block of 16 DAC registers„             BH = 16 Selects the 16th block of 16 DAC registers„„INT 10H Service 11H - Character Generator„„INT 10H Service 12H - Alternate Select„    Input„      AH = 12H„      BL = 30H„      AL = 0 -> 200 Screen scan lines„         = 1    350 Screen scan lines„         = 2    400 Screen scan lines„Earl Montgomery                INTERRUPT HELP                 INTERRUPT,HELP                 Unknown Date (00:00:00)QB, PDS                154  6536     INTHELP.BAS '$INCLUDE: 'qb.bi'„DIM inregs AS regtypex, outregs AS regtypex„CLS„LOCATE 1, 1: PRINT "For those of you that have mastered the use ";„PRINT "of interrupts, read no further!";„LOCATE 2, 1: PRINT "However if you are like me and still";„PRINT " struggling you might find this interesting.";„LOCATE 3, 1: PRINT "First off whenever you use an interrupt with";„PRINT " QB you need to load QB/L.";„LOCATE 4, 1: PRINT "This loads the QB.QLB library which contains";„PRINT " the code needed to use interrupts.";„LOCATE 5, 1: PRINT "Now you are ready to program! Your first";„PRINT " entry should be '$INCLUDE: 'QB.BI'";„LOCATE 6, 1: PRINT "This file contains the TYPE and Data";„PRINT " structure to be used.";„LOCATE 7, 1: PRINT "List QB.BI from DOS and you will see there ";„PRINT "are two types defined.";„LOCATE 8, 1: PRINT "RegType and RegTypeX. Notice that both are ";„PRINT "identical except that";„LOCATE 9, 1: PRINT "RegTypeX allows the use of the ES and DS ";„PRINT "segment registers.";„LOCATE 10, 1: PRINT "Your next entry should be: DIM inregs as ";„PRINT "regtypex,outregs as regtypex";„LOCATE 11, 1: PRINT "Now we need to call an interrupt. If you ";„PRINT "have the DOS programmers manual";„LOCATE 12, 1: PRINT "look at interrupt &h21 function &h19. This ";„PRINT "interrupt gets the Default";„LOCATE 13, 1: PRINT "Drive and returns the info in AL of register";„PRINT " AX. If AL returns a 0 this";„LOCATE 14, 1: PRINT "represents Drive A. If AL returns a 1 then ";„PRINT "this represents drive B. If AL";„LOCATE 15, 1: PRINT "returns a 2 this represents Drive C and so on."„LOCATE 16, 1: PRINT "Now we need to put something in register AX";„PRINT " and that is the function &H19.";„LOCATE 17, 1: PRINT "INREGS.AX=&H1900"„LOCATE 18, 1: PRINT "Now we call the interrupt."„LOCATE 19, 1: PRINT "CALL INTERRUPTX(&h21,INREGS,OUTREGS)"„LOCATE 23, 28: PRINT "Press any key to continue."„WAIT1:„I$ = INKEY$: IF I$ = "" THEN GOTO WAIT1„CLS„LOCATE 1, 1: PRINT "OK the DOS programmers manual said that the ";„PRINT "info would be returned in AL.";„LOCATE 2, 1: PRINT "How do we read AL from register AX? Use this";„PRINT " formula:";„LOCATE 3, 1: PRINT "AL=AX AND &HFF (More on these formulas later.)"„LOCATE 4, 1: PRINT "PRINT AL"„LOCATE 5, 1: PRINT : PRINT "Let's put everything together and ";„PRINT "see what we have.";„LOCATE 7, 1: PRINT "'$include: 'Qb.BI'"„LOCATE 8, 1: PRINT "DIM inregs AS RegTypeX,outregs AS RegTypeX"„ „ „LOCATE 9, 1: PRINT "inregs.ax=&h1900"„LOCATE 10, 1: PRINT "CALL INTERRUPTX(&h21,INREGS,OUTREGS)"„LOCATE 11, 1: PRINT "AX = (outregs.ax)"„LOCATE 12, 1: PRINT "AL=AX AND &Hff"„LOCATE 13, 1: PRINT "PRINT AL"„LOCATE 14, 1: PRINT "Now let's actually run this program. Ready?";„PRINT " Here goes!";„inregs.AX = &H1900„CALL interruptx(&H21, inregs, outregs)„loop1:„LOCATE 15, 28: PRINT "Press any key to continue."„I$ = INKEY$: IF I$ = "" THEN GOTO loop1„REM Formula to find AL.„AX = (outregs.AX)„AL = AX AND &HFF„REM Looking for a 2 in AL (My default drive is C)„PRINT AL„LOCATE 19, 1: PRINT "Well I got a 2 because my default drive is ";„PRINT "C. How about you?";„LOCATE 23, 28: PRINT "Press any key to continue."„wait2:„I$ = INKEY$: IF I$ = "" THEN GOTO wait2„CLS„LOCATE 1, 28: PRINT "Formulas to read AH and AX."„LOCATE 2, 1: PRINT "Now let's see how we can read AH."„LOCATE 3, 1: PRINT "To find AH the formula is ";„PRINT "AH=(AX AND &HFF00)/256";„LOCATE 4, 1: PRINT "Let's run it and see what we get."„LOCATE 5, 28: PRINT "Press any key to continue."„loop3:„I$ = INKEY$: IF I$ = "" THEN GOTO loop3„AH = (AX AND &HFF00) / 256„PRINT AH„LOCATE 7, 1: PRINT "I got 25. How about you?"„PRINT„LOCATE 10, 1: PRINT "Well we know the value of AL and AH. With ";„PRINT "these two values";„LOCATE 11, 1: PRINT "we can find out what is in AX. The formula ";„PRINT "is AX=(256*ah)+AL";„LOCATE 12, 1: PRINT "In my case AL was 2 and AH was 25. So 256 *";„PRINT " 25 <val in AH> + 2 <val> in AL=6402";„LOCATE 13, 1: PRINT "Let's run it and see what we get."„AX = (256 * AH) + AL„LOCATE 14, 28: PRINT "Press any key to continue."„loop4:„I$ = INKEY$: IF I$ = "" THEN GOTO loop4„PRINT AX„LOCATE 17, 1: PRINT "My values matched how about yours?"„LOCATE 23, 28: PRINT "Press any key to continue."„loop5:„I$ = INKEY$: IF I$ = "" THEN GOTO loop5„CLS„LOCATE 1, 1: PRINT "But someone is saying <But we put &h19> in ";„PRINT "AX how can it contain 6402!";„LOCATE 2, 1: PRINT "Did I mention the AX,BX,CX and DX registers ";„PRINT "are 16 bit registers?";„ „LOCATE 3, 1: PRINT "This means AX is composed of two 8 bit ";„PRINT "registers AL & AH";„LOCATE 4, 1: PRINT "Remember we put &H19 in AH and AL returned a";„PRINT " &h2. Therefore AX contains";„LOCATE 5, 1: PRINT "&H1902. And if you do a PRINT &H1902 you get ";„PRINT "6402. I am printing all";„LOCATE 6, 1: PRINT "values in decimal. Anyway, let's print it now."„LOCATE 8, 28: PRINT "Press any key to continue"„loop6:„I$ = INKEY$: IF I$ = "" THEN GOTO loop6„PRINT &H1902„PRINT "Your value may differ depending on your default drive."„LOCATE 23, 28: PRINT "Press any key to continue."„loop7:„I$ = INKEY$: IF I$ = "" THEN GOTO loop7„CLS„LOCATE 1, 1: PRINT "I hear someone saying <My books show AL on ";„PRINT "the left and AH on the right.>";„LOCATE 2, 1: PRINT "Then why doesn't AX contain &h0219 instead ";„PRINT " of &h1902?";„LOCATE 3, 1: PRINT "My reference books show the same thing and ";„PRINT "that is confusing to me too.";„LOCATE 4, 1: PRINT "But trust me for now AH is on the left and AL";„PRINT " is on the right. Maybe someone";„LOCATE 5, 1: PRINT "can shed some light on why the progrmming ";„PRINT "books show examples with AL on the";„LOCATE 6, 1: PRINT "left and AH on the right."„LOCATE 8, 1: PRINT "How would you like to see how the bit wise ";„PRINT "AND operation with";„LOCATE 9, 1: PRINT "&Hff allows us to read the value in AL? Hey!";„PRINT " Where is everyone going!?";„LOCATE 10, 1: PRINT "Class hasn't been dismissed! Hey come back!";„PRINT " Well for those of you who";„LOCATE 11, 1: PRINT "stayed it is very very simple: The AND &Hff";„PRINT " (255) or binary 11111111 "„LOCATE 12, 1: PRINT "sets all the bits in AH to 0. Therefore all ";„PRINT "we have left is what is in AL."„PRINT "Neat huh?"„LOCATE 14, 1: PRINT "Class is now dismissed."„locate 15,1:print"Your instructor was Earl Montgomery"„LOCATE 23, 28: PRINT "Press any key to continue."„loop8:„I$ = INKEY$: IF I$ = "" THEN GOTO loop8„END„Unknown Author(s)              EXECUTING ANOTHER PROGRAM      FidoNet QUIK_BAS Echo          09/95 (00:00)          QB, PDS                59   2433     EXEC.BAS    ' > I don't really know how to use interrupts, but I could really use„' > that. Could you give me some commented code and an explanation of how„' > to do it?„„„'Load QB /LQB. This includes the routines needed for calling interrupts.„'Second, this will _*NOT*_ work in the IDE! You have to compile it...„„'$INCLUDE: 'QB.BI'„„DIM Regs AS RegType              ' Whatever it is (Look in that BI„DIM RegsX AS RegTypeX            ' file)„„CLS„„'               INT 21,4B - EXEC/Load and Execute Program„'        AH = 4B„'        AL = 00  to load and execute program„'           = 01  (Undocumented)  create program segment prefix and load„'                 program, but don't execute.  The CS:IP and SS:SP of the„'                 program is placed in parameter block. Used by debuggers„'           = 03  load program only„'           = 04  called by MSC spawn() when P_NOWAIT is specified„'        DS:DX = pointer to an ASCIIZ filename„'        ES:BX = pointer to a parameter block„„'Okay. First, we have to load AX with the appropriate values. AX is the„'accumulator register, and is 16 bits wide. The two 8 bit portions are„'commonly referred to as AH and AL. (High and Low) Each can obviously„'hold one byte. AX=AH*256+AL„„CLS„A$ = "C:\COMMAND.COM" + CHR$(0)        'ASCIIZ = STRING$+&H00„'B$ = "My parameters!! WOW! Command.com will barf on these ones.. <G>"„B$ = ""„RegsX.AX = &H4B00      ' 4b - Select EXEC function from Int 21„                       ' 00 - Just load & run. Don't mess with the other„                       '      stuff... Life is too short!„RegsX.DS = VARSEG(A$)  ' DS: Holds Segment of String„RegsX.DX = SADD(A$)    ' DX: Holds Offset of String„                       ' For reference, 32-bit pointers to ram can be„                       ' calculated using SEGMENT * 65536 + OFFSET„                       ' However, since QB, unlike PB, doesn't support„                       ' pointers in any form, this is only useful for„                       ' passing to assembly routines or interrupts„RegsX.ES = VARSEG(B$)  ' Parameters in a string... Segment„RegsX.BX = SADD(B$)    ' Offset. You should be getting the drill <G>„„PRINT "Calling Int 21h EXEC on "; A$„„CALL INTERRUPTX(&H21, RegsX, RegsX)„„'        on return:„'        AX = error code if CF set  (see DOS ERROR CODES)„„„ProgramErrorCode = RegsX.AX„PRINT "Program exited with "; ProgramErrorCode„END„