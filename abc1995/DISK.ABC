Christy Gemmell                SET DISK VOLUME LABEL          SET,DISK,VOLUME,LABEL          05-19-92 (00:00)       QB, PDS                111  5174     VOLUME.BAS  ' VOLUME.BAS    Gets and/or Sets the disk volume label using DOS„'               Extended File Control Block (FCB) services. This„'               works with all MS-DOS versions from 2.0 up.„'„'Note that, while the ReadLabel routine will find the volume label from„'whichever subdirectory you happen to be in, the MakeLabel routine only„'works from the root directory of the drive you're relabelling.„'„'„'   Author:     Christy Gemmell„'   Date:       19/5/1992„'„'   $DYNAMIC„'„'   $INCLUDE: 'QB.BI'                       ' Use QBX.BI for PDS„'„    DECLARE SUB MakeLabel (Drive$, Label$)„    DECLARE SUB ReadLabel (Drive$, Label$)„„    CONST FALSE = 0, TRUE = NOT FALSE„„    TYPE XFCBType„	   XFlag AS STRING * 1                 ' Extended FCB signature„	   Rsrv1 AS STRING * 5                 ' Reserved (do not use)„	   Attr  AS STRING * 1                 ' File attribute„	   Drive AS STRING * 1                 ' Drive number„	   FName AS STRING * 11                ' Filename„	   Rsrv2 AS STRING * 5                 ' Reserved (do not use)„	   NName AS STRING * 11                ' Replacement name„	   Rsrv3 AS STRING * 9                 ' Reserved (do not use)„    END TYPE„„    DIM SHARED FCB AS XFCBType              ' File Control Block„    DIM SHARED InRegs AS RegTypeX           ' Register structures„    DIM SHARED OutRegs AS RegTypeX          '   for interrupt calls„„    DIM SHARED DTA AS STRING * 64           ' Disk Transfer Area„„    LSET FCB.XFlag = CHR$(255)              ' Flag as Extended FCB„    LSET FCB.Rsrv1 = STRING$(5, 0)          ' Fill with nulls„„'   Example program to test it all out.„'„    CLS„    Drive$ = "A:": Label$ = ""„    ReadLabel Drive$, Label$„    LOCATE 10, 1: PRINT "Current Label = "; Label$„    Label$ = "DidItWork"„    MakeLabel Drive$, Label$„    LOCATE 12, 1: PRINT "New Label     = "; Label$„END„„'   Creates or changes the volume label of the drive specified„'„SUB MakeLabel (Drive$, Label$) STATIC„    NewLabel$ = Label$                      ' Preserve new label„    ReadLabel Drive$, Label$                ' Search for current label„    IF Label$ = "" THEN                     ' If no label found„	  LSET FCB.FName = NewLabel$           '    Set new label„	  InRegs.ds = VARSEG(FCB)              '    Segment and offset of„	  InRegs.dx = VARPTR(FCB)              '      our File Control Block„	  InRegs.ax = &H1600                   '    Create file„	  INTERRUPTX &H21, InRegs, OutRegs     '    Call DOS„	  InRegs.ax = &H1000                   '    Close file„	  INTERRUPTX &H21, InRegs, OutRegs     '    Call DOS„    ELSE                                    ' Otherwise„	  LSET FCB.FName = Label$              '    Set current label„	  LSET FCB.NName = NewLabel$           '    Set replacement label„	  InRegs.ds = VARSEG(FCB)              '    Segment and offset of„	  InRegs.dx = VARPTR(FCB)              '      our File Control Block„	  InRegs.ax = &H1700                   '    Rename file„	  INTERRUPTX &H21, InRegs, OutRegs     '    Call DOS„    END IF„    Label$ = ""                             ' Check to see„    ReadLabel Drive$, Label$                '    if it worked„END SUB„„'   Reads the volume label of the drive specified.„'„SUB ReadLabel (Drive$, Label$) STATIC„    InRegs.ax = &H2F00                      ' Get current DTA„    INTERRUPTX &H21, InRegs, OutRegs        ' Call DOS„    DTASeg% = OutRegs.es                    ' Store DTA segment„    DTAOff% = OutRegs.bx                    ' Store DTA offset„    InRegs.ds = VARSEG(DTA)                 ' Replace with„    InRegs.dx = VARPTR(DTA)                 '    our own temporary„    InRegs.ax = &H1A00                      '    Disk Transfer Area„    INTERRUPTX &H21, InRegs, OutRegs        ' Call DOS„    IF Drive$ = "" THEN                     ' If no drive„	  Disk% = 0                            '    letter is supplied„    ELSE                                    '    use current drive„	  Disk% = ASC(UCASE$(Drive$)) - 64     '    otherwise convert„    END IF                                  '    letter to numeral„    LSET FCB.Drive = CHR$(Disk%)            ' Drive to search„    LSET FCB.Attr = CHR$(8)                 ' Specify Volume label„    LSET FCB.FName = "???????????"          ' Use wildcards for search„    InRegs.ds = VARSEG(FCB)                 ' Segment and offset of„    InRegs.dx = VARPTR(FCB)                 '    our File Control Block„    InRegs.ax = &H1100                      ' Find first match„    INTERRUPTX &H21, InRegs, OutRegs        ' Call DOS„    IF OutRegs.ax MOD 256 = &HFF THEN       ' If a label wasn't found„	  Label$ = ""                          '    return a null string„    ELSE                                    '    otherwise„	  Label$ = MID$(DTA, 9, 11)            '    extract it from„    END IF                                  '    our DTA„    InRegs.ds = DTASeg%                     ' Restore„    InRegs.dx = DTAOff%                     '    original„    InRegs.ax = &H1A00                      '    Disk Transfer Area„    INTERRUPTX &H21, InRegs, OutRegs        ' Call DOS„END SUB„„Andy Thomas                    CHANGE DISK SERIAL NUMBER      CHANGE,DISK,SERIAL,NUMBER      09/93 (00:00)          QB, PDS                147  4870     DSERIAL.BAS  DEFINT A-Z„ ' Purpose: To change the serial number on any DOS disk.„ ' WARNING THE FOLLOWING PROGRAM USES DIRECT DISK WRITES!„ ' by Andy Thomas 9/93„ ' Author not responsible for misuse or errors of any kind.„ ' Use of this program could, but should not, damage your disk„ ' or render data unusable.„ '$INCLUDE: 'QB.BI'„ ' QB must be started with the /L switch!„ DIM inreg AS RegTypeX, outreg AS RegTypeX„ CLS„ TYPE DiskPacketType„   Sector AS LONG         ' DWORD - starting sector number„   CountWrite AS INTEGER  ' WORD - Number of sectors affected„   TransAddres AS STRING * 4 ' DWORD - Location of data transfer„                             '         Address„ END TYPE„ ' Note: Sector is a LONG while TransAddres is a string„ ' because we know Sector is going to be zero for this program.„ ' In other uses Sector would need to be made a string to avoid„ ' QuickBasic OVERFLOW errors.„„ DIM DiskPacket AS DiskPacketType ' Disk Write Packet„ DIM DataStorage AS STRING * 512  ' string to read/write sector„„ PRINT "Place disk in drive."   ' get drive to change„ PRINT "Enter drive letter:";„ DO„   Drive$ = UCASE$(INKEY$)„ LOOP UNTIL Drive$ <> ""„ PRINT Drive$„ PRINT„„ DriveNumb = ASC(Drive$) - 65  ' drive number: A:=0, B:=1....„ inreg.cx = &HFFFF             ' Read/Write Absolute Sector„ inreg.ax = DriveNumb          ' Drive id„ DiskPacket.Sector = 0         ' start at sector 0„ DiskPacket.CountWrite = 1     ' load one sector„„ 'DWORD -- Seg:Off of DataStorage„ DiskPacket.TransAddres = CHR$(VARPTR(DataStorage) AND &HFF) +_„  CHR$(((VARPTR(DataStorage) AND &HFF00) \ 256) AND &HFF) +_„  CHR$((VARSEG(DataStorage) AND &HFF)) +_„  CHR$(((VARSEG(DataStorage) AND &HFF00) \ 256) AND &HFF)„„ inreg.ds = VARSEG(DiskPacket)  ' DS:BX = Disk write packet„ inreg.bx = VARPTR(DiskPacket)„„ CALL INTERRUPTX(&H25, inreg, outreg) ' read disk sector„„ ' Get serial number from boot sector„ FOR I = &H2B TO &H28 STEP -1„   OldSerial$ = OldSerial$ + HEX$(ASC(MID$(DataStorage, I, 1)))„   IF LEN(OldSerial$) = 4 THEN OldSerial$ = OldSerial$ + "-"„ NEXT I„„ PRINT "      Old serial number:"; OldSerial$„ LOCATE 5, 1„ PRINT "Enter new serial Number:"„„ ' get user input for new serial number„ ' making sure only a valid serial number is entered„ Ptr = 0„ DashAdj = 0„ DO„   DO„     A$ = UCASE$(INKEY$)„   LOOP UNTIL (INSTR("0123456789ABCDEF" + CHR$(8), A$) > 0) AND_„  A$ <> ""„   IF A$ = CHR$(8) THEN    ' backspace for corrections„     IF Ptr > 0 THEN„       Ptr = Ptr - 1„       NewSerial$ = LEFT$(NewSerial$, Ptr)„     ELSE„       NewSerial$ = ""„     END IF„   ELSE„     Ptr = Ptr + 1„     NewSerial$ = NewSerial$ + A$„   END IF„   LOCATE 5, 25„   PRINT "         "„„   LOCATE 5, 25„   PRINT LEFT$(NewSerial$, 4)„   IF Ptr > 4 THEN„     LOCATE 5, 29„     PRINT "-" + MID$(NewSerial$, 5, 8)„   END IF„ LOOP UNTIL Ptr = 8„ Ptr = 0„„ ' Convert NewSerial$ into numerical ASCII codes„ ' and save within DataStorage„ FOR I = &H2B TO &H28 STEP -1„   Sbyte = 0„   FOR J = 1 TO 2„     A$ = MID$(NewSerial$, J + Ptr, 1)„     IF ASC(A$) > 64 AND ASC(A$) < 71 THEN Adj = 55 ELSE Adj= 48„     Sbyte = (Sbyte * 16) + (ASC(A$) - Adj)„   NEXT J„   DEF SEG = VARSEG(DataStorage)„   POKE VARPTR(DataStorage) + I - 1, Sbyte„   Ptr = Ptr + 2„ NEXT I„„ ' Check to make sure new serial number was placed in„ ' correct location (this is a redundant check for safety)„ FOR I = &H2B TO &H28 STEP -1„   ChkSerial$ = ChkSerial$ + HEX$(ASC(MID$(DataStorage, I, 1)))„   IF LEN(ChkSerial$) = 4 THEN ChkSerial$ = ChkSerial$ + "-"„ NEXT I„„ ' confirm change„ PRINT„ PRINT "                disk:"; Drive$„ PRINT "  from serial number:"; OldSerial$„ PRINT "to new serial number:"; ChkSerial$„ PRINT "Confirm change: (Y/N)"„ DO„   A$ = UCASE$(INKEY$)„ LOOP UNTIL A$ = "Y" OR A$ = "N"„ IF A$ = "Y" THEN ' make the change„   DiskPacket.TransAddres = CHR$(VARPTR(DataStorage) AND &HFF) +_„  CHR$(((VARPTR(DataStorage) AND &HFF00) \ 256) AND &HFF) +_„  CHR$((VARSEG(DataStorage) AND &HFF)) +_„  CHR$(((VARSEG(DataStorage) AND &HFF00) \ 256) AND &HFF)„„   inreg.ds = VARSEG(DiskPacket)  ' DS:BX = Disk write packet„   inreg.bx = VARPTR(DiskPacket)„„   CALL INTERRUPTX(&H26, inreg, outreg) ' write disk sector„ ELSE„   PRINT "Change Aborted."„ END IF„„ END„„ ' Methodology: The disk serial number is stored as a Double„ ' Word in the boot sector (sector zero) of every disk at„ ' location 27h. This program reads sector zero into a string,„ ' changes the dword value at offset 27h and writes the changed„ ' data back to sector zero. While this program should work, and„ ' has been tested on both hard drives and floppy disks, I„ ' suggest it only be used on floppy drives, as a error„ ' occurring while writing to sector zero on the hard drive„ ' could be disastrous.„Dick Dennison                  DETECT DISK SIZE               DETECT,DISK,SIZE               01/93 (00:00)          QB, PDS                39   1219     DISKSIZE.BAS 'No checking for open drive doors on this:„„'$INCLUDE: 'qb.bi'„„DEFINT A-Z    'Dick Dennison 1/93 1:272/34 PD„DIM regs AS regtypex    'Does not test for open floppy door„„regs.ax = &H1C00                       'ah=1c al=00„regs.dx = 0                            '0=default, 1=a:,2=b:,etc„CALL interruptx(&H21, regs, regs)      'use dos„DEF SEG = regs.ds                      'change to returned segment„MediaByte = PEEK(regs.bx)              'Get the byte„DEF SEG                                'get back to basic's segment„„IF (regs.ax AND 255) <> &HFF THEN„„    SELECT CASE HEX$(MediaByte)„		CASE "F0"„			MediaType$ = "3.5 inch DS, 18 sectors or other"„		CASE "F8"„			MediaType$ = "Fixed Disk"„		CASE "F9"„			MediaType$ = "5.25 in DS, 15 sects or 3.5 in DS, 9 sects"„		CASE "FC"„			MediaType$ = "5.25 inch SS, 9 sectors"„		CASE "FD"„			MediaType$ = "5.25 inch DS, 9 sectors"„		CASE "FE"„			MediaType$ = "5.25 inch SS, 8 sectors"„		CASE "FF"„			MediaType$ = "5.25 inch DS, 8 sectors"„		CASE ELSE„			MediaType$ = "Unknown Type"„	END SELECT„	PRINT "Media ID Byte : "; HEX$(MediaByte); " = "; MediaType$„ELSE„	PRINT "Error encountered (invalid drive or critical error)"„END IF„END„Unknown Author(s)              FLOPPY DRIVE FUNCTIONS         FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                80   2202     FLOPPY.BAS  ' Function FLOPPYDRIVEREADY checks if disk is in drive„' Function FLOPPYWRITEOK checks if disk is write protected„„'$INCLUDE: 'QB.BI'„„DECLARE FUNCTION FloppyDriveReady% (Drive$, ErrCode%)„DECLARE FUNCTION FloppyWriteOK% (Drive$)„„DIM SHARED Register AS RegType, XRegister AS RegTypeX„„A = FloppyDriveReady%("A", ErrCode%)„„IF ErrCode% = -1 THEN PRINT "Disk in drive." ELSE PRINT "Drive not ready."„„FUNCTION FloppyDriveReady% (Drive$, ErrCode%)„'returns True (-1) if the floppy drive specified in Drive$„'has a disk in it. If the function returns False (0), ErrCode%„'contains the DOS error code.„'by Douglas H. Lusher, April, 1993„„Drive% = (ASC(Drive$) OR 32) - 97„„'reset floppy drive„Register.ax = 0„Register.dx = Drive%„CALL INTERRUPT(&H13, Register, Register)„„Register.ax = &H401„Register.cx = &H101„Register.dx = Drive%„CALL INTERRUPT(&H13, Register, Register)„„'call the interrupt twice since if a disk has just been inserted,„'the first time gives a wrong answer„Register.ax = &H401„Register.cx = &H101„Register.dx = Drive%„CALL INTERRUPT(&H13, Register, Register)„FloppyDriveReady% = ((Register.flags AND 1) = 0)„ErrCode% = ((Register.ax AND &HFF00) \ &H100) AND &HFF„„END FUNCTION„„FUNCTION FloppyWriteOK% (Drive$)„'returns True (-1) if the disk in the specified floppy drive„'is not write protected„'by Douglas H. Lusher, April 1993„„Drive% = (ASC(Drive$) OR 32) - 97„„'reset floppy drive„XRegister.ax = 0„XRegister.dx = Drive%„CALL INTERRUPTX(&H13, XRegister, XRegister)„XRegister.ax = &H401„XRegister.cx = &H101„XRegister.dx = Drive%„CALL INTERRUPTX(&H13, XRegister, XRegister)„„Buffer$ = SPACE$(512)„'read from the disk„XRegister.ax = &H201„XRegister.es = VARSEG(Buffer$)„XRegister.bx = SADD(Buffer$)„XRegister.cx = &H101„XRegister.dx = Drive%„CALL INTERRUPTX(&H13, XRegister, XRegister)„„'try writing back to the disk„XRegister.ax = &H301„XRegister.es = VARSEG(Buffer$)„XRegister.bx = SADD(Buffer$)„XRegister.cx = &H101„XRegister.dx = Drive%„CALL INTERRUPTX(&H13, XRegister, XRegister)„FloppyWriteOK% = ((XRegister.flags AND 1) = 0)„ErrCode% = ((XRegister.ax AND &HFF00) \ &H100) AND &HFF„„END FUNCTION„„Dave Navarro, Jr.              DISABLE/ENABLE DRIVE           dave@powerbasic.com            Unknown Date           PB                     25   427      DRVONOFF.BAS'Disables/Enables the specified drive.  DOS 5+ ONLY.„'Drive = (0 = A:, 1 = B:, etc.)„'„'Public Domain source by Dave Navarro, Jr.„„„SUB DisableDrive(BYVAL Drive AS INTEGER) PUBLIC„„  ! push DS„  ! mov  DX, Drive„  ! mov  AX, &H5F08„  ! int  &H21„  ! pop  DS„„END SUB„„SUB EnableDrive(BYVAL Drive AS INTEGER) PUBLIC„„  ! push DS„  ! mov  DX, Drive„  ! mov  AX, &H5F07„  ! int  &H21„  ! pop  DS„„END SUB„Brian McLaughlin               DETECT IF DRIVE IS READY       dave@powerbasic.com            Unknown Date           PB                     64   1570     DRVREADY.BAS' Drive Ready source for PowerBASIC 3.x„' by BRIAN MCLAUGHLIN„„$LIB ALL OFF„„DEFINT A-Z„„DECLARE FUNCTION DriveReady( BYVAL Drive$ )„„FOR X = ASC( "A" ) TO ASC( "F" )„  PRINT "Checking...";„  Ready = DriveReady( CHR$( X ))„  PRINT "drive "; CHR$( X );„  IF Ready THEN„    PRINT " ready."„  ELSE„    PRINT " NOT ready."„  END IF„NEXT„„'===============================„FUNCTION DriveReady( BYVAL Drive$ ) PUBLIC AS INTEGER„'===============================„' This FUNCTION returns -1 (true) if the drive is ready, or 0 (false),„' if the drive is not ready, or the drive letter is an invalid drive.„' It will NOT recognize a CD-ROM drive as being ready.„„  DIM DriveNum AS LOCAL INTEGER„  DIM DriveIsReady AS LOCAL INTEGER„„  DriveNum = ( ASC( Drive$ ) OR 32 ) - 97„  DriveIsReady = -1 'assume drive will be ready„„  ! push DS„  ! xor  AX, AX„  ! mov  DX, DriveNum     ; zero - based drive numbering used„  ! int  &H13             ; CALL BIOS TO RESET the drive controller„  ! mov  AX, &H401„  ! mov  CX, &H101„  ! mov  DX, DriveNum„  ! int  &H13„  ! mov  AX, &H401„  ! mov  CX, &H101„  ! mov  DX, DriveNum„  ! int  &H13„  ! jnc  DriveOK          ; carry set could be a fixed disk„  ! mov  AH, &H1C         ; so LET us look, USING DOS„  ! mov  DX, DriveNum„  ! inc  DX               ; one - based drive numbering used„  ! int  &H21„  ! cmp  DX, &HFF„  ! je   DriveOK„  ! mov  AX, [BX]„  ! cmp  AX, &HF8„  ! je   DriveOK„  ! mov  DriveIsReady, 0„„DriveOK:„„  ! pop DS„„  DriveReady = DriveIsReady„„END FUNCTION„James Vahn                     CMOS SAVE/RESTORE UTILITY      FidoNet QUIK_BAS Echo          Unknown Date           QB, QBasic, PDS        28   746      CMOS.BAS    'cmos2dsk.bas - James Vahn„'CMOS save/restore utility„ „DIM Byte AS STRING * 1„LOCATE , , 1„PRINT "Cmos 2 disk - James Vahn 1:30854/20@fidonet"„PRINT "Would you like to (S)ave or (R)estore your current CMOS data? ";„ „WHILE a$ = "": a$ = INKEY$: WEND„IF a$ = "s" THEN„        OPEN "\cmos.dat" FOR OUTPUT AS #1„        FOR CMOS = &H0 TO &H3F„        OUT &H70, CMOS„        DByte% = INP(&H71)„        PRINT #1, CHR$(DByte%);„        NEXT: CLOSE 1„PRINT "Data Saved": END„ „ELSEIF a$ = "r" THEN„        OPEN "\cmos.dat" FOR BINARY AS #1„        FOR CMOS = 1 TO LOF(1)„        OUT &H70, CMOS - 1„        GET #1, , Byte„        OUT &H71, ASC(Byte)„        NEXT: CLOSE 1„PRINT "Data Restored - please reboot.": END„ „END IF„Francois Roy                   CD-ROM RECOGNITION             FidoNet QUIK_BAS Echo          02-10-93 (17:19)       QB, PDS                53   1811     RECDROM.BAS 'You can use CALL INTERRUPT to read the ISO-9660 sectors via MSCDEX.  The VTOC„'(Volume Table of Contents) is accessible as shown below; I don't have its„'structure so can't tell you what the fields mean, but I can betcha no two are„'alike... the VTOC is a 2048-byte string; I defined my buffer in CDVTOC with a„'length of 4096 because for some reason 2048 gives me String Space Corrupt„'errors... the demo routine below prints the first 800 bytes of the VTOC but„'you may want to store the whole 2048 bytes as the CD's "fingerprint".„ „'The code snippet below is for QB; QBX far strings need a small alteration.„ „DECLARE SUB CDVTOC (D$, V$)„DECLARE SUB CDDRIVE (DR$)„   TYPE REGTYPE  ' For CALL INTERRUPT„     AX AS INTEGER„     BX AS INTEGER„     CX AS INTEGER„     DX AS INTEGER„     BP AS INTEGER„     SI AS INTEGER„     DI AS INTEGER„     FL AS INTEGER„     DS AS INTEGER„     ES AS INTEGER„   END TYPE„   DIM SHARED INR AS REGTYPE, OUR AS REGTYPE„   CALL CDDRIVE(D$)„   PRINT "Drive:"; D$„   CALL CDVTOC(D$, V$)„   PRINT LEFT$(V$, 800)„   END„ „SUB CDDRIVE (DR$) STATIC„    DR$ = STRING$(32, 0)„    INR.AX = &H150D„    INR.BX = SADD(DR$)„    INR.ES = SSEG(DR$)„    CALL InterruptX(&H2F, INR, OUR)„    IF ASC(DR$) = 0 THEN DR$ = "" ELSE DR$ = CHR$(ASC(DR$) + 65) + ":"„END SUB„ „SUB CDVTOC (D$, V$) STATIC„REM Reads VTOC„    DR$ = STRING$(4096, 0)„    INR.AX = &H1505„    INR.BX = SADD(DR$)„    INR.CX = INSTR("ABCDEFGHIJKLMNOP", LEFT$(D$, 1)) - 1„    INR.DX = 0  ' 1st volume descriptor„    INR.ES = SSEG(DR$)„    CALL InterruptX(&H2F, INR, OUR)„REM AX=1 is normal and indicates a standard vol. descr.„REM AX=15 is 'Invalid Drive' and 21 is 'Not Ready'. 255 means no vol. desc.„    IF OUR.AX > 1 THEN V$ = "Error" + STR$(OUR.AX) ELSE V$ = DR$„END SUB„Dave Navarro, Jr.              REPORTS DISK INFORMATION       Christy Gemmell                06-20-95 (00:00)       PB                     43   1905     DISKID.BAS  ' DISKID.BAS    reports disk volume and serial number from boot sector„'„'   Author:     Christy Gemmell (christy.gemmell@almac.co.uk)„'   Date:       12/4/1992„'„' Captured from alt.lang.basic newsgroup on July 20, 1995 and converted„' to PowerBASIC by Dave Navarro, Jr. (dave@powerbasic.com)„„    TYPE ParaBlock„        Info  AS INTEGER                ' Call information level„        SerNo AS LONG                   ' Disk serial number„        Label AS STRING * 11            ' Volume label„        FlSys AS STRING * 8             ' File system type„    END TYPE„„    INPUT "Which drive - <Enter> for default"; D$„„    GetDiskID D$, S$, V$, F$„    PRINT„    PRINT "Disk information for drive "; D$„    PRINT "----------------------------"„    PRINT "Volume label  : "; V$„    PRINT "Serial number : "; S$„    PRINT "File system   : "; F$„END„„SUB GetDiskID (Drive$, Serial$, Volume$, FileSys$)„    DIM Para AS ParaBlock               ' Buffer for drive parameter block„    Para.Info = 0                       ' Information level always zero„    REG 1, &H440D                       ' Generic IOCTL device request„    IF Drive$ = "" THEN                 ' If no drive specified„       REG 2, 0                         '    then use default„    ELSE                                ' Otherwise convert„       REG 2, ASC(UCASE$(Drive$)) - 64  ' drive letter to number„    END IF                              '     A: = 1, B: = 2 etc„    REG 3, &H866                        ' Subfunction: get drive ID„    REG 8, VARSEG(Para)                 ' Segment of buffer„    REG 4, VARPTR(para)                 ' Offset of buffer„    CALL INTERRUPT &H21                 ' Invoke DOS„    Serial$ = HEX$(Para.SerNo)          ' Get serial number„    Volume$ = Para.Label                ' Get volume label„    FileSy$ = Para.FlSys                ' Get file system type„END SUB„