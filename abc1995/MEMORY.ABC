Sequential Software Inc.       USING XMS MEMORY               XMS,MEMORY                     Unkown Date (00:00)    QB, PDS                160  10680    XMS.BAS     DECLARE SUB V1 ()„DECLARE SUB U (A$)„DEFINT A-Z: DIM SHARED K, S, B&, Z&: V1'Created by PostIt! 7.1„CLOSE : IF S = 168 AND B& = Z& THEN PRINT " :) Ok!" ELSE PRINT " :( Bad!"„„SUB U (A$) : FOR A = 1 TO LEN(A$): C = ASC(MID$(A$, A)) - 37: IF C < 0 THEN C = 91 + C * 32„IF K < 4 THEN K = C + 243 ELSE PRINT #1, CHR$(C + (K MOD 3) * 86); : K = K \ 3: B& = B& + 1„S = (S + C) AND 255: NEXT: LOCATE , 1: PRINT STRING$(B& * 50 \ Z&, 219); : END SUB„„SUB V1 : OPEN "O", 1, "XMS.ZIP", 4 ^ 6: Z& = 7405: PRINT STRING$(50, 177);„U "%up()#9%'O%-%%%If=QJ9*;P'7%%;)%%%,%.%%'r%xStgLolc..m9<9??Ht_?GE"„U "Gs*4qkiheF,qbP:7MbTCSGl-4s'P\\vu*'oufn3f4KgDQT3*Q#Q[&wzOmup;cC_"„U "z/FqZqiXa*K\66'KjIF*Q,<f+jL^X[G/FJl>tjlpcJW$&H^$qT?,Kd:0fdH=B&7"„U "a.,]fRtRiM6nK5]g*O]&xfh[T_)Sutqdm5jZ$5[2_[zMDI(G5iE-EK4z:Ec,D&H"„U ">iR\9I_TBf,'W=3hF*[&=>b)U$UskB1eT_RY=N7r9T&G]_O?uhd96<Ta[u_hziB"„U "iX\iWYq0c<f_?RS7rV3Jd3XgC.*ucsO=3]=A&&om,*=UGIbFcu7&I(L0W;vip&o"„U "Gdo:rAf%x=9all''5O^_,2tg<f%a%Z'4R$^<hU%lo6o*-F(e]Y3K)p1*;HnOFOK"„U "*^K?Dw*RQP+hoo3%uz?%&w&$1N)a8,/)M''99($gN*aMl8]IVV;1Ysg4/b6n^3t"„U "U3<(+2XQ>x(W*6tfm]Zwd8DC-lW=DYhFKmo&6QNCkfR_bU<R;SHlks:_7ZlxPg("„U "Y$e4Sw[fbY>Q:^WHn<avQn>Tc8fsY9nBG:b*+Y2tsx].l2Vk=>wf>HkG1D?v[g>"„U "/7qeg7n8Bw7KMY3eqtD,O(45kSp1x5mk4FjR.+Z?3aycHZ>uxvBrk84#,dCBaLf"„U "K#i8MoiGoNG'hi7hkA5UkyM2NaIFDwSDWT'#7,ugB9[pxRl_Fxj#\pumrOk6FV)"„U "TfL&Ug:D*<hWe3]/%exW*,f.Inpc'ZQ9pUDKY5?Rb#j5I'.B:t^W<uq-bFPfY_["„U "dnGZ\l^2SUZ^90-n0,y+L83.\M:bs[N9Z^Z*9Z$c3#;0O01dpeU5/+TF#OS6=^5"„U "=6Ah;0ii7+$WvWjXiT<i\i8**'h]>8+>)4:6SfE;Hgi8_FUFA[8C2pT,f^Ss)qp"„U "9C%5B<>6c<%up()#9%'O%-%%%%f=$S7:]57%%%4^%%%,%.%%'r%xSwjjkN*VGBT"„U "]akNXyvCDIxdLbJ%%P;##5_AD4+nrI3jZ#=k3/alW)+J%ne1(O%YkNvp4C&a7tg"„U "IBfVGylh1hX/rt-PX2=l;H.xp'.xrAGbB]tuP4PJ]dJxqBh<.i%[,<D:zCtPT;'"„U "Gq.zeZJ1Yl+u;RiqXDuwm%B4S4QZ]vnUs0/UYxu6e]SPv;0M9MJ9%A9ik6<>Yro"„U "fZfR5SE6tGjuDMzvuaBOndOnnd:RubRjbuJjjPn-'11Pg7QR?l\lhMG#MAum[^r"„U "6rP->iNM0e+P1XXPtZD,+9dC9C\5*:%xhKY0MsQqhw%[c&POeaI/zY(dN4p)Yu;"„U "neLnCO-S)X0qGA)wMX&x%lI,&T+nPxN+hc0R+SCh1.#M,p$UbW23=?Z>lAdp<e0"„U "T_&zRueQ&/8T<FmW.W9u4Bnq8I]vY3Vt,5^_6oZZ4DT:#]D+Xb:(YKK-W<_.HJt"„U ":;y&v6%9#=W>hiZ\%PpNA)Mdm>N8_Etd'EdIM9(f0LBi2QLJ&%5W7+0O.I%UbtW"„U "(P)#1?\),cY<g.d]g#M35[nZY09wCj/IgCl8(&e_>lB\t,8)fPqx>R(Fa?'+7Sa"„U ">CD9ue][[q&%WMcZ#PL:OoHh]Hu59,Wva/)LiVPlWi=fXlGEy+IygJ'F>t%b3i."„U ",k8S;[vVQeaAlq;KZ[vIL<kNq965S9'5[4^-16q)4yBtKgF?\p8sug?P\Yjtbz("„U "CELf>fkp_p-VojZ\jb^T$5]n7nD]gTAXbk#f;i/j^egeGFL\q$)\F<-:Um[UzcN"„U "XnD%a)u(3LG-o&6+(^67o7H5#lsJYko?_F]R%c#'OuKBFf8<W#z<9b*IlU0l&R7"„U "_Y2^BZHkPT-*c6;OMFuZCqSCbj)7<D6POl,?h;[d#rhUfMU[kYLtE^ypWZkdJj-"„U ".3c-t[4FMI\TlfMJ2iE=Jte7TNGh*<hKV2k\ZrWtkSarrr5R_drT8qU9VW?+LjP"„U "Of&0QePFKa\Fjjw_.riceFE>Gb3<u*APK*k<0*q$^.0*r7r'EiA+(UzbpV=C250"„U "Jz3&Vh2.>R-\2hrW^''jkpbT;j&I8%#b#BF[$)T'jTjI\E6Xt,vEa9/y1Kpt$(B"„U "#tdGCSCZ)xi'<qFC/\z-ghx5%QBn5ch(_yo+Ma&bZZZq\gj%3iU]uqD5DP[u5;)"„U "tK44oH82ErMIu.Ik7(aGHNp<W-u\o7ot?Tfw+/^ggVI#C0xe)5TIXdxzPe73=aL"„U "\?,u&m(Vq#Z$Cv6,+)gp,^XPl4I.wIn9\?O8oxf#9?#RLK-%ARu?Ik]cIcjRJYZ"„U "7'$F4FcoK\k5B8=G3<I6qk,Mo6[[5#]*hQ_1Id/7d2lkAfMG^C?\&E#*h;v8Mu\"„U "y,n_K3DmjtnZRhNHkKD6s[k&%>GM&bz:ePW^/oJ%^$$3RTkL2orVFNI3^GN:&6<"„U "<p(?nEtH^d9Zt>tzbZ,<=sW8VpRqYHOK4[z]R&+rUXUn;I\aVugkW#aZZpH'gS_"„U "0X3O0+xmow[:l#+O6_Fu78$DdEO^<oh/0Sw?4tYi0\j?jVa/q==h#B48+Tt$E]+"„U "L8=rm^[4=;=$,;1#[E5zuSrfIB/Qzu=UH#7;Pw=e,Vhu;^qTi7J,Ctnn'?9>uqF"„U "fV7=KpU*7HbBRG$=1;_tRE5O+)mt\xDHZC48<eag6#,_O;M2gA6fA:4pr$-F(i2"„U "%3A%<K6<Ko<.6g]*9u(KU5-b-h)k5NjgL1g-=G0*KpN]UU*;D.5F0M[Z_4.3oy3"„U "xRel+AV5[Xb>1<tX=>,1OoIA#OI?0=0&%9GJ\MAu)=kD__DLb4&)6'19/D.5N[R"„U "Ja_1-RVl4e6PdAsZhgjoR;+gntseOl_QP#-^l.O-[pX1;5gapT4-X%U=$W_JCB#"„U "4[)l9CbqPoOyWfW;^mDC&[fqf.G)A=i)\M=;5Sck4KLumEMg%Yh3j3sHriso\x1"„U "mwf9jo&aO'G4F:F;eleDw5H/?/o2oc7sq0fi6Af>?Lq4AR3awH]3%rjHD7+Q$vg"„U "^Z)$S%+U_6l9(%7u]88Vl+2VSUiXa*GUUOZD1^ENwFq_0^_d&(kbNz1G*SjR5=P"„U "o,YFR:U<cS;gPb:54Z3LunHF&M7>O0MW>k6#HDPK)<r^Px89T1X?+KP;o0ikJ=i"„U ")in<J_/u_=b1N#nf+9/wypI.Lo()8,[wo8,3$_0-'.<.jDx..lh;?%ywK_DHTc7"„U "(_n+Ud&v$.:VL'?MqKhx\ew$oN-Qy?1nJb6GE.U;$[%q<C:ec:=x#MF.J9y#)^l"„U "gq00yXk1x'Xb2H*j+KVS394o%CpVrl;SJQ1paJBvXHAG$azspCK]Yp4r3:W&cfg"„U "w;l=oC'_.3)%7T.^(WQtz&AO<Up&NOWQYPOm>,;nbIsYW=BdS9U/IOfA;'k[Z+:"„U "GTY:4IW%SijW2X&ckY>%0'D)<cd)Og_Zss6_2t(to._>7wIu(vz/fp2b<0\-8h&"„U "w$W>w]73UW*$PHfA24,h:;JHk]MG'QY5f(rrJXIRYK]J6/:VrF5/$>-8cwF_Pn#"„U "#f(W^S$*6=[N')K)2vIMpSJRdp]]7D7tOiLTpD(v-(Yg]_d0+SFv],;%GEynMCi"„U "]t(zUA0LrTsAgrU0A,hI3UY1(Resn1_Dr\UDJ'Nz/^4,p7s7t,Q2asNDkubZ'g4"„U "I%OHM[X'?E)6*4)HP&D/]swv1i:i#ebD1#dKM\K6p45u'aUo$UD2&TG)0HsjBl$"„U "A,*Yf:qXn)V6JBOVlSYWUB(WZDkU4EXsk)LmPVPNUHRSpFKQ'X4]gS_p6FO'P.*"„U "'cl'AWN#+vV88\W\fQ3h7Fqd/Pc4Z4T43nFj&,</\X[-7mYK[<s3*1MY$3+oZa:"„U "0trTiD$hn0nG3IqTf<B9;jYCOjAnW;Fp47e/1lYVWF_BF0r>1aoCiF.dR*tmhWY"„U "a]=Q2Eo%fhQ>&C8(,+c$)CuWHt/NlIKHaZ3#<2j.>SQ*v=yE3v,LgxnIZb:p9wV"„U "z,.F%2A&AMVdS'LPLOTt:EV,iPrbwLPkFQe+Oe*]6bd>$r:)88zp;>Td84=;qZu"„U "q-<:GvGY7s(B?Rwi)pg>,[nyZp)Z2KCK-B6m9F(M;%KoOT/w56<pQt)TECl9*XX"„U "0/knpG.n=cm1zNYV5Ue%/6mEZ/p-oUL>r;d'4y(Nt;%o<%oS>0b:Q/)z6=7?\>5"„U "T4PK/BRTo6lY0TCm;D#Usy%i<kUPWENPq;EQE4b0,KgnE1xC%](s_&T&l\j]o/4"„U "<hRC;W]?4Ba#8Rgcv<2jS/t$,ie\0HG/0kK+)OQ;FwE#y3?]JM($n5Y.[jlg_5n"„U "cP(+L1j2T>bA=_-=j18>vD1Pr>n/%+n#5:Me9G;CeZw5ZxX=$[dDgWLoCvv7,HC"„U "W7$w_$8a;\-sTV2kX\-:&a$W_SIUZUmTj#;#*IW-tHQ'yr=[m-C:##Pe0i[w9[t"„U "r+fBub3YblsHf\$plvU&4:l$ZZX\9p\Q\tF\j08ctZf59QH;/aWGX;.h&HW]JCm"„U "(\%oysm=3(R_S(b.Oy.,CEkxB-6*<+QOM[x1/:5a%7.-LLcxf;eVgXXu/i<;./("„U "9$7?o^#+p7:XV:>)hZ9k*h[a6hae?GEub-Sob4=B8Mi)219$\;Q?,s9&jRJ9sAm"„U "'Y;qCkw7J5$98SX#g4VRq9wb$h#rs()vatBSV4b)q(4r7=5R*C3Qw$&S*W2hPiL"„U "8hr\\g0gknsNxcd4G52+$SQDoS[#%;;;EYiY?jgQG366Y3dsvju%I+B1kS?1DTK"„U "$Hjh2vZ,Goo8^n,RqnjW59&i9EwBE>5>Hi<f1dQ5O-KB_;W;Ea7Cx'PySP),j?$"„U "%[pk7&Et'[HoJqM&7cflp3HSF_4%ov$0<9B9JkA?*;LUB-8^ttg47%uim?_uA:%"„U "\D_DPf^3hV.$tzgGZr/E1qim0S'M<yxkp,qf$iTqGs>TVo)f[r=Z=MG1$*iCAMR"„U "O8<xa:S:K'gr,l-j0BFVsN/_J'2>D(ROtSVYDKP*'8U?qGrYUa#Mf<*O_3(=)CY"„U "MacZF%nb^^?]/Q9D<^]lvt[vZV1LNN7.>u0x+QQW?0qUZrF/Xv(9VkDQ<PR__o:"„U "w1Q8SE7mHAB^laBI=*IMU(#J27<he6?[q/;2<6KCON_rdd*x,QY6Y\Co&]It,^t"„U "qd^CMr'3PDQ4J3z$CYvT[YFlb4THGvS?A*d\CL'X2;K1tBsH^?9Ff\8Z4Ulj36A"„„U "2]$7>,O?F6b_l$60PKuk^;[bMKZ.=zj5ud5:KdJ<-mKDE1vin5f5U^fGva)RE'S"„U "#sP/ov*8uq]]rx9VTteiw*llQfqMK[j<i7<]m67Yat?=To84AR[OQO0awI9,%j9"„U "c02GiJ^DY+3G%BlU#DFM4V'.Oa2LMRsR\Gimr<lBmr\*b#OJVE7HVch3n1%ZJbd"„U "Mtbqfj3s;Aj*d#>*N*PnSjh6K/Pe]lPz3Jhy^+TMV-GTn*^]mEJE/Bf<2=]?J.N"„U "dY&V-[Y2W=/5=CC.t>Im#j9'.kba$2_Chz,h3UtMkB5p;SbSBGB39_ccW_QG%7#"„U "q?Ifuhx5h=5>p4VQV8#nf+ALoaNV=6uvDjDB^YxH[h\;a/R&u7(1sf>+=N[lj,-"„U "$c/tQICA*f/bQ*hq#2kJDa]66+4ojT4/IEA_p6]&ct[TI\5Y0h;JB31;_Cj9v)p"„U "N'Ej1S$]A#YNpQvX8#AHy9JAa;1rp;u1p1_$+C5Z55^65bldTa>/7^o3eZsPtpF"„U "s.qWnA\OqsJC)GtSfY='F=IR\ZK'$Sot3>)>4$jcx:D-t],3mkx13i6HZxcX8#<"„U "uNq_fBv$KErtU7sOU3j[=S'?Uth;q<rq5DdZIF[0WQf58u;7J5(:,K5CWH380od"„U "rx/UQWr;un'5TIq[.j5WvX=9Wp9CjC_lk2hY:H2F9;FT*^9GIpA0HBi?u3budf&"„U "YiYRM<[/0cCUj9HI[xYM.eGA[j[qL/P6.V7-eLUWCt48MGc\F4ZT\UiDf<H6>$8"„U "nbQh4fG>hKfThcw.e^5I<Cuk[oM:cY)mAKKWmJ]9L&+;dupobo<gFvyoe=lJh)&"„U "R9SAlNT3RAjKU5=)T7QENrstr\VEEv*LTnlVk'rlUD9[4s.4HDoQY$rDD[2Bxtr"„U "F8)+90%Qj+\uXhcFA0ZvfYa>XLZ=^b?og-\h=LAsRHA:b(\8Zk&gKKc?rwo_OBX"„U ">)?dPTU2mFuxX/oLuIc.'D>oXLXprt$$F,mTxt2XU)),$gvnY1AA8?d(#gJ3TsP"„U "'OE8(A-q9)dp/KMKQh;?GIiGt4&\>D,V\me&w95e;xfj97v\9e=->a<e'Yz9tf5"„U "x;_Yp1s4^\&h_]pi0VxiVf:f*Fb21GcYl9U[OQ\EV/<XP/W9*W44N$qN4rQ9(U#"„U "cfcY-O]V;u],p_;jq&PB0Hl-c7f9NBvQwM<a1422Tmx(JH1lt?s[>#UK[u$McLb"„U "dOXlO_U4(7TJp.qS(vXe/yjM,I#HhF<GookhQ.GgAZvS-]-n+RV+f_:k;62)50$"„U "14Y^b>rCvC$q>oT7==YbWz<e14;uUv)xqw;(#2u2T2uG[NSuhhFttMA<ZZkonGp"„U "/F\tk.h=?W(FWhTgC'DPL3B>JqN>2EA;g2Nu2Ve];%AXH]:'ir<-E>sV:=8XraV"„U "\G9(_dKKp\60[8?0=I<\wFCjWjF875i,j%k\*Ye>tOnhj-Yir_jbGSE\N1u-ip="„U "DJN3PU=8XwdC=\xQ=5JBiLMBMzOXgo(GuMJZGMnVG>l8sS%=WE000&s*d&MKG\F"„U "6ei>or)?HS5VH^&#k?kvo#6NALsIMEj/ie+gyh3]/D,\ss3LK$tG[Y8b0Z>9H4d"„U "vOsx+&CfHO,Jdb^J:R4V6fhK8(JiR0Iw$+HCNrGBtmg]oP;HiNJxoJ\L,rl2u4P"„U "w)luottVj?VBr.+u:<taaB%0h8nn[5purMRzCPts,HjH<87A>L,,Yfkt$6FclMN"„U "2]fJfe3PlHqPqL*F672=T$6fR(K*B7=)&tJ&;y:lMKb_3KGjwyxs9D-]LLO.Spz"„U "M6T(_-+i^TG)#uc9XTJvLlv\jtsLa8sL\e:d0deqYz-1KOIjLh&p)aB71k<X11<"„U "TYO5Wt3ZPdDZ\peb8^pMR[cv^>wGf*1fMK\=rB/VEued6-uZ,=ll>OF?Qi<4tNv"„U "Dx%%up(%)9%'&O-%%#%f=O:fACS%+%%<%5%%0#%%%'%rxij%rtSgRfx&&<v>SmF"„U "8wBXNx0QA=2-Mo)qksr$Kk][Dsw)Atgm\N6tD1T?n/oSE0-hKtNvF%ddFs3_^qM"„U ";ZdRRhN$H5E:]IrH=dfO6tK3l'lV4xllT9RP3YXG:h#'8nFj,=[;QO#o[KkX<0B"„U ";SYe+ThH_0xYu8m/x#\=B2BuPo$Ep^M^9jBD/:Cfv7c#)KXW\hD/B4&0.tLb'Bl"„U "#-JBCM/LCV.b=yzku>fI69Bj\tv)A9N\Ns+a?:GiQMK;gT_3EG<=(;(./oP.4Vi"„U "C6%.D':1X0,'%1w8O\L3X.m57'Lo^W<ngD[24YDfW[^KB=5<w.wY.A45SBUaqU6"„U "lJCg6I2)PKv8CJ2J-N1eTDMs,m>R\Ka(.U[q+6xnxl#-t*lHpjS=(9:1:05,C<D"„U "2UEdWKp[iU;#p]$=?0UBZ/_F<=k]6EdSMk*E*_pmOW'XakH$=ghmKmJK8AC\PGl"„U ":kg?):1(\RMGLFs^U5_.$z&(wR)L\OIZnR8eAXL[J;a%P2tX#z-#eB9k02l1%Lg"„U ";k)c*3Gkn&bp)C%:);Ma:5Go<$YAR-eaVf?UNL.*o0xhZs\q?,,d_nw#RHOR'j="„U "kw45?,hb0oNd=iuBR$Ir#)ezUN$7sQIr#-pjVOQb+cTt5tb?\L,<O<I(3d)OQBB"„U "Oqi;+6Rw_u91U*T$[VHsod%X7)BVpP4clcF2SHta^(=R-8uAFkLCv3P5Ar)t)8x"„U "ZABI1KCr$srRE.Nu6VCt/S>0jERpixuB82,nKB(ZM&(dZ&?0Lr94]&#>mafk5Rg"„U "YnL3]IhkdvkXS2[RiKGs$b'&QQD;gv1K#0Fi<M1T.B'.Qv#F8,O5gHJNX#3?wMY"„U "hg;TiY9F+)QI7aXam%oNp7c]9[HsgFr&.\W<,2ihhuh>I^l1YSs7h4kk<0;Y7T5"„U "ZBBJbhG,_l8;pVPV;17_k,+a)e<+CxtVt+Z8\R<;kLBgK/B&]Go)$bU]n9<g.,e"„U "e.h?%aoU]HmKEw_)=ANUiM_-Y^g9C[t%.Gq\JMKTCSP=fVq6i&W3?;>Hldc9oAT"„U "&KX;dXSNJ17?0Y3(*(w\C)q4hRQN?E:i[MihQZX2:6E,BvCAF&l$;>g+5wddi4y"„U "-b&^fKo3lpU*CkvPV5aGs)gTDW0v?sWN[AqX#GCSgbPWF$E+/C7KJ*PCnOWBq+N"„U "SSmhQqBXgaMyCOcG;n([qsSZPQK=4RM6)T')vg#(KB\T->wX'*Rc/,.e^^FsO$U"„U "(7+UTx0Ft0)SFEK;qSN/FBb1AxKH4Ec\4^#%dpfEs7m47:C%y/VK(t&02%R;%?/"„U "3o4*:gBXiR>Q.YL#)?9e/,HN#Rz9x72:E/Lr&u.aUZ7IKOdbtKTcKoZN[-IszbS"„U "&od2fG:l$tT.Sw9m9n506[v)QrJ58pp6&o%9*>e+M71,URYR=G>C0=[s8s8Kff,"„U "9Sm\rY6d&KKYy;GCf$iIWcrM0D9ia9,%N>6,PJU5x$))l</aq-<DbtI3(bP.3&g"„U "%jDSd/+6K=R9Gn:)MB;$Zi,KVBi;CUOmx0FUYHhMjcEj;SG_6V5VBKYCS;_=p,u"„U ",kTZh\0iq=EQ=bv>3O.1BCb2PT(Sy<nTaj(Lp74)?;H18gv&.gx>KWy/,OGWG+$"„U "rGzoWHuXI8O=BZnZi)T0n?Uja7NwReG#.fkR$]V'ZA-BrS2Pe^(QvgjR_v&B]K-"„U "GqM467kqEW,eq'B4f5(GU%9UybeOQxw.PYI2=]7T*R%?ZLTQ3(%gj#-$bqmtKOr"„U "GpBo*BSfS^2&]/30Y/0jA7gWvXgifcO)$k\_kgnca+W/m#pVUa%F.4<8c3(_JS5"„U "t$IFZCl8u[6w]P/c1cLrJ3i6d;XlhP^$Z';HTqZR75PXtdZ47)J(M<YWg&s<uE7"„U "5g;(PkxVQhJ4554Ybp=S=h<*,F\Jfz&[5iH[Oh\ptqTF-;Ok'KNsTJvFTS*gQPb"„U "I($UIqd1<;^dC]D*DybjqIdFf%.,$Oc8X4t%U>=I)gcAo#NIrEq=YE^F>t/Y?HZ"„U "rWnWh56gu0[>80w'%up&'%9%9%%'%-%%%%f=;QJ*;'P'%%';)%%%,%%%%%%%%%%"„U "%E%%%%%%.%%'r%xStg%oup&%'9%9%%'%-%%%%f%=$S:+]57%%%4^%%%,%%%%%%%"„U "%%&%E[%%%u#'%%'%rxSw%jkup%&'9%%9%'%%-%%%.f=Of,ACS+%%%<5%%%0%%%%"„U "%%%%%&%%E%%%'V:%%&'rxi%jrtS%gfxu%p*+%%%%%(#%(%r%%%%Y%A%%%%%"„END SUB„„David L. Poskie                POKEBUFFER SUBROUTINE          POKE,BUFFER,SUBROUTINE         04/25/92 (00:00)       QB, QBasic, PDS        58   1939     POKEBUFF.BAS' POKEBUFF.BAS - Demonstrates PokeBuffer subroutine„'   Used to put a string into key buffer on program exit„'   by David L. Poskie   Madison, WI     QBASIC 1.0  25 April 92„'„'  Input:„'   Cmd$: A string of up to 14 characters to be used by DOS to invoke„'         the next program when leaving *this* QBASIC program.„' Output:„'   Cmd$ in the DOS key buffer„'„'> NOTE: Modifying for more than 14 chars + <CR> hangs your system! <„'„DEFINT A-Z„DECLARE SUB PokeBuffer (Cmd$)„CLS„PRINT "POKEBUFF - Subroutine Demo                       25 April 92"„PRINT " by David Poskie": PRINT„PRINT "This program demonstrates the PokeBuffer subroutine. It will"„PRINT " enter the command, 'DIR /W' to be used by DOS after this"„PRINT " program ends.": PRINT„PRINT "Press a key to quit this program . . ";„SLEEP„Work$ = "DIR /W"„CALL PokeBuffer(Work$)„PRINT : PRINT "POKEBUF.BAS ends here."„SYSTEM ' End of demo program„'      ================ Subroutine Begins Here ================„' POKEBUFF.SUB - Puts a string into key buffer - QBASIC 1.0 Subroutine„'    by David L. Poskie         Madison, WI           30 Nov 91„'„' Syntax:   CALL PokeBuffer (Cmd$)„'  Input:„'        Cmd$: A string of up to 14 characters to be used by DOS to invoke„'              the next program when leaving *this* QBASIC program.„' Output:„'        Cmd$ in the DOS key buffer„'„'> NOTE: Modifying for more than 14 chars + <CR> will hang your system!<„'„SUB PokeBuffer (Cmd$) STATIC„   '„   ' Limit the string to 14 characters plus <CR> and get its length„   Work$ = LEFT$(Cmd$, 14) + CHR$(13)„   Length% = LEN(Work$)„   '„   ' Set the segment for poking„   DEF SEG = 0„   '„   ' Define buffer's head & tail„   POKE 1050, 30„   POKE 1052, 30 + Length% * 2„   '„   ' Then poke each character.„   FOR Index% = 1 TO Length%„      POKE 1052 + Index% * 2, ASC(MID$(Work$, Index%))„   NEXT Index%„   '„END SUB ' PokeBuffer„Quinn Tyler Jackson            SUPER EMS                      SUPER,EMS                      12/30/92 (00:00)       PDS, VBDOS             361  12641    SUPEREMS.BAS' JackMack SuperArray Management Kit v1.0„' Released into the public domain on 30 December 1992„' Written by Quinn Tyler Jackson, JackMack Consulting & Development„„' This array management tool is programmed for VBDOS 1.0, but may„' be fully compatible with BASIC PDS 7.x.  It uses advanced features„' not found in QuickBASIC 4.5, but these features MAY be worked out„' by enterprising programmers.  Words to look for in the source code„' include: PRESERVE.„„' Features of this application:„„' INTEGER and LONG numeric arrays can be stored in EMS memory, leaving„' space free for bigger and better things.  Arrays are referenced not by„' obscure numbers and handles, but by user assigned names that may include„' ANY character.  That means that an array COULD conceivably be called„' "This is my array."„„' STRING arrays are stored to a to virtual memory file, and are variable„' length.  Only their pointers are stored in RAM, and even these are stored„' safely out of the way in EMS.  In short, as long as disk space allows,„' one could have a 300,000 element string array, each element being between„' one and 32000 some odd characters long, and it wouldn't take up any more„' of DGROUP or far string space than any other STRING JmArray.„' Also note that STRING arrays are compressed onto the virtual disk file„' if they do not contain high-ASCII characters, to conserve disk space.„„' Some academic points illustrated by this program:„„'   1) Pointer referencing,„'   2) End user modifiable array names,„'   3) "Handle-based" arrays,„'   4) Virtual memory.„„' NOTE: To allow for INTEGER and LONG values to be passed back from the„'       same function that returns STRING values, all values are passed„'       back as STRING.  They must be converted thus:„'„'       ErrorCode = JmSET ("My array", 10, "100")„'       IntegerValue = VAL(JmGet ("My array",10))„'„'       This is unfortunate, but allows one function to return ALL types„'       of data, not just one per function.„„' These seven routines are from Hanlin's PBCLONE 1.9 library.  Earlier„' versions of PBCLONE might work, too.„„DECLARE FUNCTION IsASCII% (Ch$)„DECLARE FUNCTION StrSqu$ (St$)„DECLARE FUNCTION StrUnSq$ (St$)„DECLARE SUB EMSClose (BYVAL ArrayHandle%)„DECLARE SUB EMSOpen (Elements&, ElementType%, ArrayHandle%, ErrCode%)„DECLARE SUB EMSGet (BYVAL ArrayHandle%, ElementNr&, Value AS ANY)„DECLARE SUB EMSPut (BYVAL ArrayHandle%, ElementNr&, Value AS ANY)„„' These routines are local to this particular program.„DECLARE FUNCTION IsAllASCII (Txt$) AS INTEGER„DECLARE FUNCTION JmDIM% (ArrayName$, Elements AS LONG, ArrayType%)„DECLARE FUNCTION JmWORD (InExpression$, Index%) AS STRING„DECLARE FUNCTION JmSET% (ArrayName$, Element AS LONG, Vlue AS STRING)„DECLARE FUNCTION JmERASE% (ArrayName$)„„OPTION BASE 1 ' I prefer things to start at one.  Humans tend to count that„              ' way, don't you agree?„„'Some system constants.„CONST BUFFER_MAX = 10           ' How many previously read strings to„buffer.„CONST VirtualFile = "JMVSA.$$$" ' Virtual string memory file.„CONST StartSize = 10            ' Initial size of pointer array.„„'Ye olde tradional Boolean logic constants„CONST TRUE = (1 = 1)            ' I prefer (1=1) since it is compiler„                                ' independent, whereas -1 is specific to„                                ' MS BASICS.„CONST FALSE = NOT TRUE„„' Array Types„CONST Array_Integer = 1„CONST Array_Long = 2„CONST Array_String = 3„„' Errors that might happen„CONST Err_EMS_Allocation = -1„CONST Err_Bad_Subscript = -2„CONST Err_Array_Not_Dimensioned = -3„CONST Err_Overflow = -4„CONST Err_DOS_Error = -5„„' PointerType for the array cross-reference table.„TYPE PointerType  Elements AS LONG  ' How many array elements array has.„„    Handle AS INTEGER               ' EMS handle of either data or ptr table„                                    ' (String arrays use an EMS ptr table).„„    ArrayType AS INTEGER            ' What type of array we're dealing with.„„    Accesses AS LONG                ' How many times this array is accessed.„END TYPE„„DEFINT A-Z„'$DYNAMIC arrays are going to be used so they can be redimensioned.„„' PtrArray changes size and must be preserved when it does so. Therefore,„' QuickBASIC users might have to rethink the logic I have used throughout.„DIM SHARED PtrArray(StartSize) AS PointerType„„REDIM SHARED AName$(StartSize)          ' Names of arrays.„DIM SHARED VirtualHandle AS INTEGER     ' Handle of virtual memory file.„„' The simple sample application to show syntax follows here.  Normally, your„' program would go here....„„„CLS„' A 300,000 element string array!  Requires lots of EMS for pointers! A„' one million element array would require 4 Megs of free EMS, but wouldn't„' take up any more DGROUP or conventional memory than a two element array!„„INPUT "This array can have any name you'd like: ", Array$„' Arrays can be named at the end-user level.  This is good for database„' applications and is a powerful feature.  The user is not forced to refer„' to his specific data by any contrived name other than the one he or she„' assigns!„„nul = JmDIM(Array$, 1000, Array_String)„IF nul < 0 THEN PRINT "ERROR": END„PRINT nul„PRINT "Getting data from array '" + Array$ + "'."„nul = JmSET(Array$, 1000, "This is a test.  The test seems to have worked.")„„PRINT JmGET(Array$, 1000, ErrCode)„„nul = JmERASE("*") 'Be sure to do this to free EMS handles and memory!„„FUNCTION IsAllASCII (Txt$) AS INTEGER„FOR scan = 1 TO LEN(Txt$)„    IF NOT IsASCII(MID$(Txt$, scan, 1)) THEN„        IsAllASCII = FALSE„        EXIT FUNCTION„    END IF„NEXT„IsAllASCII = TRUE„END FUNCTION„„FUNCTION JmDIM (ArrayName$, Elements AS LONG, ArrayType) AS INTEGER„STATIC ArrayPtr AS INTEGER„„' Get First Available spot in list.„FOR scan = 1 TO UBOUND(PtrArray)„    IF AName$(scan) = "" THEN„        ArrayPtr = scan„        Flag = TRUE„        EXIT FOR„    END IF„NEXT scan„„IF NOT Flag THEN ' We have to make room for a new array, since no spots left.„    ArrayPtr = UBOUND(PtrArray) + 1„    REDIM PRESERVE PtrArray(ArrayPtr) AS PointerType„    REDIM PRESERVE AName$(ArrayPtr)„END IF„„„SELECT CASE ArrayType„    CASE Array_Integer, Array_Long„        AName$(ArrayPtr) = ArrayName$„        PtrArray(ArrayPtr).Elements = Elements„        PtrArray(ArrayPtr).ArrayType = ArrayType„        EMSOpen Elements, Array_Type, Handle, ErrCode„        PtrArray(ArrayPtr).Handle = Handle„        IF ErrCode THEN„            JmDIM = -1„            EXIT FUNCTION„        ELSE„            JmDIM = Handle„            EXIT FUNCTION„        END IF„„    CASE Array_String, Array_Compressed„        AName$(ArrayPtr) = ArrayName$„        PtrArray(ArrayPtr).Elements = Elements„        PtrArray(ArrayPtr).ArrayType = ArrayType„        IF NOT VirtualHandle THEN 'we haven't opened the virtual file yet.„            VirtualHandle = FREEFILE„            OPEN VirtualFile FOR BINARY AS VirtualHandle„        END IF„        ' This EMS array is an array of POINTERS to file offsets.„        EMSOpen Elements, Array_Long, Handle, ErrCode„        PtrArray(ArrayPtr).Handle = Handle„        IF ErrCode THEN„            JmDIM = -1„            EXIT FUNCTION„        ELSE„            JmDIM = Handle„            EXIT FUNCTION„        END IF„END SELECT„„END FUNCTION„„FUNCTION JmERASE (ArrayName$)„„IF ArrayName$ <> "*" THEN ' The asterix is intended to erase ALL JmArrays!!„    FOR scan = 1 TO UBOUND(PtrArray)„        IF ArrayName$ = AName$(scan) THEN„                'Release EMS being used by array.„                EMSClose PtrArray(scan).Handle„                'Show the name as blank so that it is freed for future use.„                AName$(scan) = ""„                Flag = TRUE„                EXIT FOR„        END IF„    NEXT scan„    IF NOT Flag THEN„        ' We tried to ERASE an array that didn't exist.  Names ARE„        ' case sensitive, so "Quinn" and "quinn" are different.„        JmERASE = Err_Array_Not_Dimensioned„        EXIT FUNCTION„    END IF„ELSE„    CLOSE VirtualHandle ' Close the virtual string file and„'    KILL VirtualFile    ' get rid of it.„„    FOR scan = 1 TO UBOUND(PtrArray)„        IF AName$(scan) <> "" THEN„            'Release EMS used by array.„            EMSClose PtrArray(scan).Handle„        END IF„    NEXT scan„„    REDIM PtrArray(1) AS PointerType„    REDIM AName$(1)„    VirtualHandle = 0„END IF„END FUNCTION„„FUNCTION JmGET (ArrayName$, Element AS LONG, ErrCode AS INTEGER) AS STRING„STATIC BufferPtr„„FOR scan = 1 TO UBOUND(PtrArray)„    IF ArrayName$ = AName$(scan) THEN„        IF Element > PtrArray(scan).Elements THEN„            ErrCode = Err_Bad_Subscript„            EXIT FUNCTION„        END IF„        SELECT CASE PtrArray(scan).ArrayType„            CASE Array_Integer„                EMSGet PtrArray(scan).Handle, Element, TempInt%„                JmGET = STR$(TempInt%)„                Flag = TRUE„                EXIT FOR„„            CASE Array_Long„                EMSGet PtrArray(scan).Handle, Element, TempLong&„                JmGET = STR$(TempLong&)„                Flag = TRUE„                EXIT FOR„„            CASE Array_String„                EMSGet PtrArray(scan).Handle, Element, EndPtr&„„                ON LOCAL ERROR GOTO DOSErrorGet„                    ' First find the right spot in virtual file.„                    SEEK VirtualHandle, EndPtr&„                    ' Then find out how much data to read from file.„                    GET VirtualHandle, , Leng%„                    ' Then prepare an adequate buffer.„                    Buffer$ = SPACE$(ABS(Leng%))„                    ' And finally suck it in through the straw.„                    GET VirtualHandle, , Buffer$„                ON LOCAL ERROR GOTO 0„„                ' Negative lengths indicate previous compression.„                IF Leng% < 0 THEN Buffer$ = StrUnSq(Buffer$)„                JmGET = Buffer$„                Flag = TRUE„                EXIT FOR„        END SELECT„    END IF„NEXT scan„„IF NOT Flag THEN„    ErrCode = Err_Array_Not_Dimensioned„    EXIT FUNCTION„END IF„„EXIT FUNCTION„„DOSErrorGet:„' Something happened that had to be trapped.„ErrCode = Err_DOS_Error„EXIT FUNCTION„„END FUNCTION„„FUNCTION JmSET (ArrayName$, Element AS LONG, Vlue AS STRING)„FOR scan = 1 TO UBOUND(PtrArray)„    IF ArrayName$ = AName$(scan) THEN„        IF Element > PtrArray(scan).Elements THEN„            JmSET = Err_Bad_Subscript„            EXIT FUNCTION„        END IF„        SELECT CASE PtrArray(scan).ArrayType„„            CASE Array_Integer„                TempInt& = VAL(Vlue)„                IF TempInt& > 32768 OR TempInt& < -32768 THEN„                    ' Someone forgot his BASIC basics.„                    JmSET = Err_Overflow„                    EXIT FUNCTION„                END IF„                TempInt% = TempInt&„                ' Stuff it up there in EMS land.„                EMSPut PtrArray(scan).Handle, Element, TempInt%„                Flag = TRUE„                EXIT FOR„„            CASE Array_Long„                TempLong& = VAL(Vlue)„                EMSPut PtrArray(scan).Handle, Element, TempLong&„                Flag = TRUE„                EXIT FOR„„            CASE Array_String„„                ' New string assignments added to end of virtual file.„                EndPtr& = LOF(VirtualHandle) + 1„                EMSPut PtrArray(scan).Handle, Element, EndPtr&„                ON LOCAL ERROR GOTO DOSErrorSet„                    SEEK VirtualHandle, EndPtr&„                    ' Add the string length to the string for later use.„                    SELECT CASE IsAllASCII(Vlue)„                        CASE TRUE„                            'Compress string.„                            Vlue = StrSqu(Vlue)„                            ' Make it < 0 if compressed.„                            Vlue = MKI$(-LEN(Vlue)) + Vlue„                        CASE ELSE„                            Vlue = MKI$(LEN(Vlue)) + Vlue„                    END SELECT„                    PUT VirtualHandle, , Vlue„                ON LOCAL ERROR GOTO 0„                Flag = TRUE„                EXIT FOR„„        END SELECT„    END IF„NEXT scan„„IF NOT Flag THEN„    JmSET = Err_Bad_Array_Name„    EXIT FUNCTION„END IF„„EXIT FUNCTION„DOSErrorSet:„    JmSET = Err_DOS_Error„    EXIT FUNCTION„„END FUNCTION„James Vahn                     CHECK FOR EMS                  FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                61   2088     EMSCHECK.BAS'test4ems.bas  -  James Vahn 1:30854/20@fidonet„'written for QB 4.5  Load QB/L - does not work with Qbasic.„'$INCLUDE: 'qb.bi'„ „'This checks out your EMS driver & hardware.„ „TYPE EmsHardware„        EmmRawPageSize                  AS INTEGER„        NumberAlternateRegisterSets     AS INTEGER„        SizeMappingContextSaveArea      AS INTEGER„        NumberDMARegisterSets           AS INTEGER„        DMAOperationType                AS INTEGER„END TYPE„ „DIM Regs AS RegTypeX„DIM EmsH AS EmsHardware„ „Regs.ax = &H3567                 ' locate code for INT 67, EMS driver.„CALL INTERRUPTX(&H21, Regs, Regs)„DEF SEG = Regs.es„    FOR t = &HA TO &H11          ' search the driver header for text„    EMS$ = EMS$ + CHR$(PEEK(t))„    NEXT„IF EMS$ = "EMMQXXX0" THEN„    EMS$ = "EMMXXXX0"„    PRINT "DR DOS EMM386 detected."„    PRINT "Would you like it fixed (y/n)?"„          WHILE A$ = ""„          A$ = INKEY$„          WEND„          IF A$ = "y" THEN„          POKE &HA + 3, ASC("X")    ' fix(?) the driver handle.„          END IF„END IF„DEF SEG„IF EMS$ <> "EMMXXXX0" THEN PRINT "No EMS installed": END„ „PRINT "EMS Driver found at "; HEX$(Regs.es); ":"; HEX$(Regs.bx)„Regs.ax = &H5900        ' subfunction 59h„Regs.es = VARSEG(EmsH)  ' point ES:DI to the array EmsH„Regs.di = VARPTR(EmsH)  '„CALL INTERRUPTX(&H67, Regs, Regs)„ „PRINT "Emm Raw Page Size"; EmsH.EmmRawPageSize„PRINT "Number Alternate Register Sets"; EmsH.NumberAlternateRegisterSets„PRINT "Size Mapping Context Save Area"; EmsH.SizeMappingContextSaveArea„PRINT "Number DMA Register Sets"; EmsH.NumberDMARegisterSets„PRINT "DMA Operation Type"; EmsH.DMAOperationType„ „Regs.ax = &H4200„CALL INTERRUPTX(&H67, Regs, Regs)„ „PRINT "Total EMS memory"; Regs.dx * 16; CHR$(29) + "k"„PRINT "Total EMS memory available"; Regs.bx * 16; CHR$(29) + "k"„PRINT„ IF EmsH.NumberAlternateRegisterSets = 0 THEN„        PRINT "Hardware alternate page mapping not supported."„        PRINT " Bad news for multitasking."„ ELSE„        PRINT "Suitable for multitasking."„ END IF„Unknown Author(s)              EXPANDED MEMORY ROUTINES       QB TidBits                     Unknown Date           QB, PDS                333  9495     EMM.BAS     'Program to store data in Expanded memory with QuickBasic.„„DECLARE SUB CallEmm (EmmFuncNbr%)„DECLARE FUNCTION EmmDriverExists2% ()„DECLARE FUNCTION EmmDriverExists1% ()„DECLARE SUB EmmPrintStatus (Status%)„DECLARE FUNCTION FmtPointer$ (P AS ANY)„DECLARE FUNCTION Hi% (Operand%)„DECLARE FUNCTION Lo% (Operand%)„„'If you use the PDS product, change the next line to include„'the QBX.BI include file instead of the QB.BI file„„'$INCLUDE: 'QB.BI'„„DEFINT A-Z„„CONST EmsInt = &H67         'EMS interrupt number„CONST IoCtlFunc = &H44      'IOCtl DOS Function number„CONST PageLen = 16384       'Length of memory page„CONST MsgLen = 16           'Message length„CONST MsgsPerPage = PageLen \ MsgLen„CONST NumMsgs = 5000„„'*** Emm functions ***„„CONST GetStatus = &H40„CONST GetPageFrameAddr = &H41„CONST GetUnallocPages = &H42„CONST GetEmmVersion = &H46„CONST AllocatePages = &H43„CONST MapHandlePage = &H44„CONST DeallocatePages = &H45„„CLS„„TYPE address„    Segment AS LONG„    Offset AS LONG„END TYPE„„DIM P0 AS address             'Pointer to physical page 1„DIM P1 AS address             'Pointer to physical page 2„DIM P2 AS address             'Pointer to physical page 3„DIM P3 AS address             'Pointer to physical page 4„DIM MsgBuf AS address         'Pointer into mapped memory„DIM Buff AS STRING * 16       'Buffer for message to store in EM„DIM I AS INTEGER              'Dummy variable„DIM SHARED EmmRegs AS RegType 'Registers for interrupt calls„DIM Page AS LONG              'Page frame address„DIM Index AS LONG             'Index into page frame„DIM StrNum AS STRING * 6      'Holds record # for EMM msg„„'Test for the existence of the EMM driver„'You can choose from 1 of 2 methods„„'IF EmmDriverExists1% THEN         'Method 1„IF EmmDriverExists2% THEN          'Method 2„    PRINT "EMM driver exists"„ELSE„    PRINT "No EMM driver detected."„END IF„„'Print the current status of the EMM driver„„PRINT "Checking EMM status"„CALL CallEmm(GetStatus)„PRINT "EMM status ok"„„'Print the version number of the EMM driver„„CALL CallEmm(GetEmmVersion)„„PRINT "EMS driver version = ";„„AL% = Lo%(EmmRegs.ax)„MajorVersion = AL% \ 16„MinorVersion = AL% AND &HF„PRINT USING "!."; RIGHT$(STR$(MajorVersion), 1);„PRINT USING "!"; RIGHT$(STR$(MinorVersion), 1)„„IF AL% < &H32 THEN„    PRINT "Error - EMM version is earlier than 3.2"„    SYSTEM„END IF„„'***** Print the page frame & physical window addresses *****„„CALL CallEmm(GetPageFrameAddr)„„P0.Segment = EmmRegs.bx   'Window 0 -> P0 = BX:0000„P1.Segment = EmmRegs.bx   'Window 1 -> P1 = BX:4000„P2.Segment = EmmRegs.bx   'Window 2 -> P2 = BX:8000„P3.Segment = EmmRegs.bx   'Window 3 -> P3 = BX:C000„P0.Offset = &H0„P1.Offset = &H4000„P2.Offset = &H8000„P3.Offset = &HC000„„PRINT "Page frame segment address = "; HEX$(EmmRegs.bx)„PRINT "Physical page 0 address = "; FmtPointer$(P0)„PRINT "Physical page 1 address = "; FmtPointer$(P1)„PRINT "Physical page 2 address = "; FmtPointer$(P2)„PRINT "Physical page 3 address = "; FmtPointer$(P3)„„'***** Print # of unallocated pages and total # of pages *****„„CALL CallEmm(GetUnallocPages)„PRINT "Total EMS pages = "; EmmRegs.dx„PRINT "Unused EMS pages = "; EmmRegs.bx„„'***** Allocate some pages of expanded memory *****„„EmmRegs.bx = (NumMsgs + MsgsPerPage) \ MsgsPerPage„CALL CallEmm(AllocatePages)„PRINT "Allocated "; EmmRegs.bx; " pages to handle #"; EmmRegs.dx„EmmHandle = EmmRegs.dx„„'***** Load EMS RAM with data *****„„MsgBuf = P0„PRINT "Storing messages into extended memory page frame"„LastPageNbr = -1„FOR I = 0 TO NumMsgs - 1„    LOCATE 14, 50: PRINT USING "#,###"; I„    StrNum = STR$(I)„    Buff = " EMS msg #" + StrNum„    Page = I \ MsgsPerPage„    Index = I MOD MsgsPerPage„    MsgBuf.Offset = Index * LEN(Buff)„„    '***** Map indicated logical page into physical page 0 ****„„    IF Page <> LastPageNbr THEN„        AH = MapHandlePage„        AL = 0„        EmmRegs.ax = AH * 256 + AL  'Map EMS page & Physical page 0„        EmmRegs.bx = Page„        EmmRegs.dx = EmmHandle                      'EMM RAM handle„        CALL INTERRUPT(EmsInt, EmmRegs, EmmRegs)„        LastPageNbr = Page„    END IF„„    AH = Hi%(EmmRegs.ax)„    IF AH = 0 THEN„„        ' Set message into memory„„        DEF SEG = MsgBuf.Segment„        FOR J = 0 TO MsgLen - 1„            POKE MsgBuf.Offset + J, ASC(MID$(Buff, J + 1, 1))„        NEXT J„        DEF SEG„„    ELSE„        CALL EmmPrintStatus(AH)„        EXIT FOR„    END IF„NEXT I„„PRINT„„'Allow user to access any message in the buffer„„I = &HFF„„WHILE I <> -1„    INPUT "Enter message # to retrieve, or -1 to quit: "; I„    IF (I >= 0) AND (I < NumMsgs) THEN„„        MsgBuf = P3„        Page = I \ MsgsPerPage„        Index = I MOD MsgsPerPage„        „'***** Map indicated page into physical page 3 *****„„        AH = MapHandlePage                 'Map EMM page„        AL = 3                             ' using physical page 3„        EmmRegs.ax = AH * 256 + AL„        EmmRegs.bx = Page                  'Logical page number„        EmmRegs.dx = EmmHandle             'EMM RAM handle„„        CALL INTERRUPT(EmsInt, EmmRegs, EmmRegs)„        AH = Hi%(EmmRegs.ax)„        IF AH = 0 THEN„            MsgBuf.Offset = MsgBuf.Offset + Index * LEN(Buff)„„            'Move the bytes from memory to a local variable„„            DEF SEG = MsgBuf.Segment„            FOR J = 0 TO MsgLen - 1„                MID$(Buff, J + 1, 1) = CHR$(PEEK(MsgBuf.Offset + J))„            NEXT J„            DEF SEG„„            PRINT "Retrieved message -> "; Buff;„            PRINT " from page #"; Page; " Index"; Index„        ELSE„            CALL EmmPrintStatus(AH)„            I = -1„        END IF„    END IF„„WEND„„'***** Free the EMS RAM back to the EMM driver *****„„EmmRegs.dx = EmmHandle„CALL CallEmm(DeallocatePages)„PRINT "Released all memory for handle "; EmmRegs.dx„END„„'Error handling routine„„oops:„    SELECT CASE ERR„        CASE 53   'File/device not found.„            PRINT "No EMM driver found"„            SYSTEM„        CASE ELSE„            PRINT "Unknown error #"; ERR„            SYSTEM„    END SELECT„„SUB CallEmm (EmmFuncNbr)„„    EmmRegs.ax = EmmFuncNbr * 256„    CALL INTERRUPT(EmsInt, EmmRegs, EmmRegs)„    AH = Hi%(EmmRegs.ax)„    IF AH <> 0 THEN„        CALL EmmPrintStatus(AH)„        SYSTEM„    END IF„„END SUB„„FUNCTION EmmDriverExists1%„„DIM EmsDriver AS address„DIM EmsIdString AS STRING * 8„„EmmDriverExists1% = 0                   'False„DEF SEG = 0„VectorAddr = &H67 * 4„EmsDriver.Segment = PEEK(VectorAddr + 3) * 256& + _„                    PEEK(VectorAddr + 2)„„IF EmsDriver.Segment <> 0 THEN„    DEF SEG = EmsDriver.Segment„    EmsDriver.Offset = 10„    FOR I = 0 TO 7„     MID$(EmsIdString, I + 1, 1) = CHR$(PEEK(EmsDriver.Offset + I))„    NEXT I„    IF EmsIdString = "EMMXXXX0" THEN„     EmmDriverExists1% = -1„    END IF„END IF„DEF SEG„„END FUNCTION„„FUNCTION EmmDriverExists2%„„DIM EmmHandle AS INTEGER      'Handle for EMM allocated pages„„ON ERROR GOTO oops„    EmmDriverExists2% = -1      'Set default return value to TRUE„    OPEN "I", 1, "EMMXXXX0"„„    EmmRegs.ax = IoCtlFunc * 256&           'Call IOCtl Function„    EmmRegs.bx = FILEATTR(1, 2)             'Set DOS file handle#„    CALL INTERRUPT(&H21, EmmRegs, EmmRegs)  'Call DOS„    CLOSE 1„    IF (EmmRegs.flags AND 1) = 0 THEN       'Call successfull„     IF (EmmRegs.dx AND &H80) = &H80 THEN  'Handle is for a dev„        PRINT "Handle refers to a device"„     ELSE„        PRINT "Handle refers to a file"„        PRINT "Unable to contact EMM driver if present"„        SYSTEM„     END IF„    ELSE 'Call unsuccessfull„     SELECT CASE EmmRegs.ax„        CASE 1: PRINT "Invalid IOCtl subfunction"„        CASE 5: PRINT "Access to IOCTL denied"„        CASE 6: PRINT "Invalid handle"„        CASE ELSE„            PRINT "Unknown error # "; EmmRegs.ax„     END SELECT„     PRINT "Unable to contact EMM driver"„     SYSTEM„    END IF„    EXIT FUNCTION„„END FUNCTION„„SUB EmmPrintStatus (Status%)„    SELECT CASE Status%„        CASE &H0: S$ = "Status ok"„        CASE &H80: S$ = "Driver malfunction"„        CASE &H81: S$ = "Hardware malfunction"„        CASE &H83: S$ = "Bad Handle"„        CASE &H84: S$ = "Undefined function"„        CASE &H85: S$ = "No free handles"„        CASE &H86: S$ = "Page map context error"„        CASE &H87: S$ = "Insufficient memory pages"„        CASE &H88: S$ = "Not enough free pages"„        CASE &H89: S$ = "Can't allocate zero pages"„        CASE &H8A: S$ = "Logical page out of range"„        CASE &H8B: S$ = "Physical page out of range"„        CASE &H8C: S$ = "Page map hardware RAM full"„        CASE &H8D: S$ = "Page map already has a handle"„        CASE &H8E: S$ = "Page map not mapped to handle"„        CASE &H8F: S$ = "Undefined subfunction number"„        CASE ELSE„            S$ = "Unknown status number $" + HEX$(Status%)„    END SELECT„    PRINT "EMM: " + S$„END SUB„„FUNCTION FmtPointer$ (P AS address)„    F$ = "$" + RIGHT$(HEX$(P.Segment), 4)„    F$ = F$ + ":$" + RIGHT$(HEX$(P.Offset), 4)„    FmtPointer$ = F$„END FUNCTION„„FUNCTION Hi% (Operand%)„    Hi% = Operand% \ 256„END FUNCTION„„FUNCTION Lo% (Operand%)„    Lo% = Operand% MOD 256„END FUNCTION„Logan Ashby                    DETECTING XMS                  FidoNet QUIK_BAS Echo          05-28-93               ASM, QB, PDS           160  10680    XMSDETEC.BASDECLARE SUB V1 ()„DECLARE SUB U (A$)„DEFINT A-Z: DIM SHARED K, S, B&, Z&: V1'Created by PostIt! 7.1„CLOSE : IF S = 168 AND B& = Z& THEN PRINT " :) Ok!" ELSE PRINT " :( Bad!"„„SUB U (A$) : FOR A = 1 TO LEN(A$): C = ASC(MID$(A$, A)) - 37: IF C < 0 THEN C = 91 + C * 32„IF K < 4 THEN K = C + 243 ELSE PRINT #1, CHR$(C + (K MOD 3) * 86); : K = K \ 3: B& = B& + 1„S = (S + C) AND 255: NEXT: LOCATE , 1: PRINT STRING$(B& * 50 \ Z&, 219); : END SUB„„SUB V1 : OPEN "O", 1, "XMS.ZIP", 4 ^ 6: Z& = 7405: PRINT STRING$(50, 177);„U "%up()#9%'O%-%%%If=QJ9*;P'7%%;)%%%,%.%%'r%xStgLolc..m9<9??Ht_?GE"„U "Gs*4qkiheF,qbP:7MbTCSGl-4s'P\\vu*'oufn3f4KgDQT3*Q#Q[&wzOmup;cC_"„U "z/FqZqiXa*K\66'KjIF*Q,<f+jL^X[G/FJl>tjlpcJW$&H^$qT?,Kd:0fdH=B&7"„U "a.,]fRtRiM6nK5]g*O]&xfh[T_)Sutqdm5jZ$5[2_[zMDI(G5iE-EK4z:Ec,D&H"„U ">iR\9I_TBf,'W=3hF*[&=>b)U$UskB1eT_RY=N7r9T&G]_O?uhd96<Ta[u_hziB"„U "iX\iWYq0c<f_?RS7rV3Jd3XgC.*ucsO=3]=A&&om,*=UGIbFcu7&I(L0W;vip&o"„U "Gdo:rAf%x=9all''5O^_,2tg<f%a%Z'4R$^<hU%lo6o*-F(e]Y3K)p1*;HnOFOK"„U "*^K?Dw*RQP+hoo3%uz?%&w&$1N)a8,/)M''99($gN*aMl8]IVV;1Ysg4/b6n^3t"„U "U3<(+2XQ>x(W*6tfm]Zwd8DC-lW=DYhFKmo&6QNCkfR_bU<R;SHlks:_7ZlxPg("„U "Y$e4Sw[fbY>Q:^WHn<avQn>Tc8fsY9nBG:b*+Y2tsx].l2Vk=>wf>HkG1D?v[g>"„U "/7qeg7n8Bw7KMY3eqtD,O(45kSp1x5mk4FjR.+Z?3aycHZ>uxvBrk84#,dCBaLf"„U "K#i8MoiGoNG'hi7hkA5UkyM2NaIFDwSDWT'#7,ugB9[pxRl_Fxj#\pumrOk6FV)"„U "TfL&Ug:D*<hWe3]/%exW*,f.Inpc'ZQ9pUDKY5?Rb#j5I'.B:t^W<uq-bFPfY_["„U "dnGZ\l^2SUZ^90-n0,y+L83.\M:bs[N9Z^Z*9Z$c3#;0O01dpeU5/+TF#OS6=^5"„U "=6Ah;0ii7+$WvWjXiT<i\i8**'h]>8+>)4:6SfE;Hgi8_FUFA[8C2pT,f^Ss)qp"„U "9C%5B<>6c<%up()#9%'O%-%%%%f=$S7:]57%%%4^%%%,%.%%'r%xSwjjkN*VGBT"„U "]akNXyvCDIxdLbJ%%P;##5_AD4+nrI3jZ#=k3/alW)+J%ne1(O%YkNvp4C&a7tg"„U "IBfVGylh1hX/rt-PX2=l;H.xp'.xrAGbB]tuP4PJ]dJxqBh<.i%[,<D:zCtPT;'"„U "Gq.zeZJ1Yl+u;RiqXDuwm%B4S4QZ]vnUs0/UYxu6e]SPv;0M9MJ9%A9ik6<>Yro"„U "fZfR5SE6tGjuDMzvuaBOndOnnd:RubRjbuJjjPn-'11Pg7QR?l\lhMG#MAum[^r"„U "6rP->iNM0e+P1XXPtZD,+9dC9C\5*:%xhKY0MsQqhw%[c&POeaI/zY(dN4p)Yu;"„U "neLnCO-S)X0qGA)wMX&x%lI,&T+nPxN+hc0R+SCh1.#M,p$UbW23=?Z>lAdp<e0"„U "T_&zRueQ&/8T<FmW.W9u4Bnq8I]vY3Vt,5^_6oZZ4DT:#]D+Xb:(YKK-W<_.HJt"„U ":;y&v6%9#=W>hiZ\%PpNA)Mdm>N8_Etd'EdIM9(f0LBi2QLJ&%5W7+0O.I%UbtW"„U "(P)#1?\),cY<g.d]g#M35[nZY09wCj/IgCl8(&e_>lB\t,8)fPqx>R(Fa?'+7Sa"„U ">CD9ue][[q&%WMcZ#PL:OoHh]Hu59,Wva/)LiVPlWi=fXlGEy+IygJ'F>t%b3i."„U ",k8S;[vVQeaAlq;KZ[vIL<kNq965S9'5[4^-16q)4yBtKgF?\p8sug?P\Yjtbz("„U "CELf>fkp_p-VojZ\jb^T$5]n7nD]gTAXbk#f;i/j^egeGFL\q$)\F<-:Um[UzcN"„U "XnD%a)u(3LG-o&6+(^67o7H5#lsJYko?_F]R%c#'OuKBFf8<W#z<9b*IlU0l&R7"„U "_Y2^BZHkPT-*c6;OMFuZCqSCbj)7<D6POl,?h;[d#rhUfMU[kYLtE^ypWZkdJj-"„U ".3c-t[4FMI\TlfMJ2iE=Jte7TNGh*<hKV2k\ZrWtkSarrr5R_drT8qU9VW?+LjP"„U "Of&0QePFKa\Fjjw_.riceFE>Gb3<u*APK*k<0*q$^.0*r7r'EiA+(UzbpV=C250"„U "Jz3&Vh2.>R-\2hrW^''jkpbT;j&I8%#b#BF[$)T'jTjI\E6Xt,vEa9/y1Kpt$(B"„U "#tdGCSCZ)xi'<qFC/\z-ghx5%QBn5ch(_yo+Ma&bZZZq\gj%3iU]uqD5DP[u5;)"„U "tK44oH82ErMIu.Ik7(aGHNp<W-u\o7ot?Tfw+/^ggVI#C0xe)5TIXdxzPe73=aL"„U "\?,u&m(Vq#Z$Cv6,+)gp,^XPl4I.wIn9\?O8oxf#9?#RLK-%ARu?Ik]cIcjRJYZ"„U "7'$F4FcoK\k5B8=G3<I6qk,Mo6[[5#]*hQ_1Id/7d2lkAfMG^C?\&E#*h;v8Mu\"„U "y,n_K3DmjtnZRhNHkKD6s[k&%>GM&bz:ePW^/oJ%^$$3RTkL2orVFNI3^GN:&6<"„U "<p(?nEtH^d9Zt>tzbZ,<=sW8VpRqYHOK4[z]R&+rUXUn;I\aVugkW#aZZpH'gS_"„U "0X3O0+xmow[:l#+O6_Fu78$DdEO^<oh/0Sw?4tYi0\j?jVa/q==h#B48+Tt$E]+"„U "L8=rm^[4=;=$,;1#[E5zuSrfIB/Qzu=UH#7;Pw=e,Vhu;^qTi7J,Ctnn'?9>uqF"„U "fV7=KpU*7HbBRG$=1;_tRE5O+)mt\xDHZC48<eag6#,_O;M2gA6fA:4pr$-F(i2"„U "%3A%<K6<Ko<.6g]*9u(KU5-b-h)k5NjgL1g-=G0*KpN]UU*;D.5F0M[Z_4.3oy3"„U "xRel+AV5[Xb>1<tX=>,1OoIA#OI?0=0&%9GJ\MAu)=kD__DLb4&)6'19/D.5N[R"„U "Ja_1-RVl4e6PdAsZhgjoR;+gntseOl_QP#-^l.O-[pX1;5gapT4-X%U=$W_JCB#"„U "4[)l9CbqPoOyWfW;^mDC&[fqf.G)A=i)\M=;5Sck4KLumEMg%Yh3j3sHriso\x1"„U "mwf9jo&aO'G4F:F;eleDw5H/?/o2oc7sq0fi6Af>?Lq4AR3awH]3%rjHD7+Q$vg"„U "^Z)$S%+U_6l9(%7u]88Vl+2VSUiXa*GUUOZD1^ENwFq_0^_d&(kbNz1G*SjR5=P"„U "o,YFR:U<cS;gPb:54Z3LunHF&M7>O0MW>k6#HDPK)<r^Px89T1X?+KP;o0ikJ=i"„U ")in<J_/u_=b1N#nf+9/wypI.Lo()8,[wo8,3$_0-'.<.jDx..lh;?%ywK_DHTc7"„U "(_n+Ud&v$.:VL'?MqKhx\ew$oN-Qy?1nJb6GE.U;$[%q<C:ec:=x#MF.J9y#)^l"„U "gq00yXk1x'Xb2H*j+KVS394o%CpVrl;SJQ1paJBvXHAG$azspCK]Yp4r3:W&cfg"„U "w;l=oC'_.3)%7T.^(WQtz&AO<Up&NOWQYPOm>,;nbIsYW=BdS9U/IOfA;'k[Z+:"„U "GTY:4IW%SijW2X&ckY>%0'D)<cd)Og_Zss6_2t(to._>7wIu(vz/fp2b<0\-8h&"„U "w$W>w]73UW*$PHfA24,h:;JHk]MG'QY5f(rrJXIRYK]J6/:VrF5/$>-8cwF_Pn#"„U "#f(W^S$*6=[N')K)2vIMpSJRdp]]7D7tOiLTpD(v-(Yg]_d0+SFv],;%GEynMCi"„U "]t(zUA0LrTsAgrU0A,hI3UY1(Resn1_Dr\UDJ'Nz/^4,p7s7t,Q2asNDkubZ'g4"„U "I%OHM[X'?E)6*4)HP&D/]swv1i:i#ebD1#dKM\K6p45u'aUo$UD2&TG)0HsjBl$"„U "A,*Yf:qXn)V6JBOVlSYWUB(WZDkU4EXsk)LmPVPNUHRSpFKQ'X4]gS_p6FO'P.*"„U "'cl'AWN#+vV88\W\fQ3h7Fqd/Pc4Z4T43nFj&,</\X[-7mYK[<s3*1MY$3+oZa:"„U "0trTiD$hn0nG3IqTf<B9;jYCOjAnW;Fp47e/1lYVWF_BF0r>1aoCiF.dR*tmhWY"„U "a]=Q2Eo%fhQ>&C8(,+c$)CuWHt/NlIKHaZ3#<2j.>SQ*v=yE3v,LgxnIZb:p9wV"„U "z,.F%2A&AMVdS'LPLOTt:EV,iPrbwLPkFQe+Oe*]6bd>$r:)88zp;>Td84=;qZu"„U "q-<:GvGY7s(B?Rwi)pg>,[nyZp)Z2KCK-B6m9F(M;%KoOT/w56<pQt)TECl9*XX"„U "0/knpG.n=cm1zNYV5Ue%/6mEZ/p-oUL>r;d'4y(Nt;%o<%oS>0b:Q/)z6=7?\>5"„U "T4PK/BRTo6lY0TCm;D#Usy%i<kUPWENPq;EQE4b0,KgnE1xC%](s_&T&l\j]o/4"„U "<hRC;W]?4Ba#8Rgcv<2jS/t$,ie\0HG/0kK+)OQ;FwE#y3?]JM($n5Y.[jlg_5n"„U "cP(+L1j2T>bA=_-=j18>vD1Pr>n/%+n#5:Me9G;CeZw5ZxX=$[dDgWLoCvv7,HC"„U "W7$w_$8a;\-sTV2kX\-:&a$W_SIUZUmTj#;#*IW-tHQ'yr=[m-C:##Pe0i[w9[t"„U "r+fBub3YblsHf\$plvU&4:l$ZZX\9p\Q\tF\j08ctZf59QH;/aWGX;.h&HW]JCm"„U "(\%oysm=3(R_S(b.Oy.,CEkxB-6*<+QOM[x1/:5a%7.-LLcxf;eVgXXu/i<;./("„U "9$7?o^#+p7:XV:>)hZ9k*h[a6hae?GEub-Sob4=B8Mi)219$\;Q?,s9&jRJ9sAm"„U "'Y;qCkw7J5$98SX#g4VRq9wb$h#rs()vatBSV4b)q(4r7=5R*C3Qw$&S*W2hPiL"„U "8hr\\g0gknsNxcd4G52+$SQDoS[#%;;;EYiY?jgQG366Y3dsvju%I+B1kS?1DTK"„U "$Hjh2vZ,Goo8^n,RqnjW59&i9EwBE>5>Hi<f1dQ5O-KB_;W;Ea7Cx'PySP),j?$"„U "%[pk7&Et'[HoJqM&7cflp3HSF_4%ov$0<9B9JkA?*;LUB-8^ttg47%uim?_uA:%"„U "\D_DPf^3hV.$tzgGZr/E1qim0S'M<yxkp,qf$iTqGs>TVo)f[r=Z=MG1$*iCAMR"„U "O8<xa:S:K'gr,l-j0BFVsN/_J'2>D(ROtSVYDKP*'8U?qGrYUa#Mf<*O_3(=)CY"„U "MacZF%nb^^?]/Q9D<^]lvt[vZV1LNN7.>u0x+QQW?0qUZrF/Xv(9VkDQ<PR__o:"„U "w1Q8SE7mHAB^laBI=*IMU(#J27<he6?[q/;2<6KCON_rdd*x,QY6Y\Co&]It,^t"„U "qd^CMr'3PDQ4J3z$CYvT[YFlb4THGvS?A*d\CL'X2;K1tBsH^?9Ff\8Z4Ulj36A"„„U "2]$7>,O?F6b_l$60PKuk^;[bMKZ.=zj5ud5:KdJ<-mKDE1vin5f5U^fGva)RE'S"„U "#sP/ov*8uq]]rx9VTteiw*llQfqMK[j<i7<]m67Yat?=To84AR[OQO0awI9,%j9"„U "c02GiJ^DY+3G%BlU#DFM4V'.Oa2LMRsR\Gimr<lBmr\*b#OJVE7HVch3n1%ZJbd"„U "Mtbqfj3s;Aj*d#>*N*PnSjh6K/Pe]lPz3Jhy^+TMV-GTn*^]mEJE/Bf<2=]?J.N"„U "dY&V-[Y2W=/5=CC.t>Im#j9'.kba$2_Chz,h3UtMkB5p;SbSBGB39_ccW_QG%7#"„U "q?Ifuhx5h=5>p4VQV8#nf+ALoaNV=6uvDjDB^YxH[h\;a/R&u7(1sf>+=N[lj,-"„U "$c/tQICA*f/bQ*hq#2kJDa]66+4ojT4/IEA_p6]&ct[TI\5Y0h;JB31;_Cj9v)p"„U "N'Ej1S$]A#YNpQvX8#AHy9JAa;1rp;u1p1_$+C5Z55^65bldTa>/7^o3eZsPtpF"„U "s.qWnA\OqsJC)GtSfY='F=IR\ZK'$Sot3>)>4$jcx:D-t],3mkx13i6HZxcX8#<"„U "uNq_fBv$KErtU7sOU3j[=S'?Uth;q<rq5DdZIF[0WQf58u;7J5(:,K5CWH380od"„U "rx/UQWr;un'5TIq[.j5WvX=9Wp9CjC_lk2hY:H2F9;FT*^9GIpA0HBi?u3budf&"„U "YiYRM<[/0cCUj9HI[xYM.eGA[j[qL/P6.V7-eLUWCt48MGc\F4ZT\UiDf<H6>$8"„U "nbQh4fG>hKfThcw.e^5I<Cuk[oM:cY)mAKKWmJ]9L&+;dupobo<gFvyoe=lJh)&"„U "R9SAlNT3RAjKU5=)T7QENrstr\VEEv*LTnlVk'rlUD9[4s.4HDoQY$rDD[2Bxtr"„U "F8)+90%Qj+\uXhcFA0ZvfYa>XLZ=^b?og-\h=LAsRHA:b(\8Zk&gKKc?rwo_OBX"„U ">)?dPTU2mFuxX/oLuIc.'D>oXLXprt$$F,mTxt2XU)),$gvnY1AA8?d(#gJ3TsP"„U "'OE8(A-q9)dp/KMKQh;?GIiGt4&\>D,V\me&w95e;xfj97v\9e=->a<e'Yz9tf5"„U "x;_Yp1s4^\&h_]pi0VxiVf:f*Fb21GcYl9U[OQ\EV/<XP/W9*W44N$qN4rQ9(U#"„U "cfcY-O]V;u],p_;jq&PB0Hl-c7f9NBvQwM<a1422Tmx(JH1lt?s[>#UK[u$McLb"„U "dOXlO_U4(7TJp.qS(vXe/yjM,I#HhF<GookhQ.GgAZvS-]-n+RV+f_:k;62)50$"„U "14Y^b>rCvC$q>oT7==YbWz<e14;uUv)xqw;(#2u2T2uG[NSuhhFttMA<ZZkonGp"„U "/F\tk.h=?W(FWhTgC'DPL3B>JqN>2EA;g2Nu2Ve];%AXH]:'ir<-E>sV:=8XraV"„U "\G9(_dKKp\60[8?0=I<\wFCjWjF875i,j%k\*Ye>tOnhj-Yir_jbGSE\N1u-ip="„U "DJN3PU=8XwdC=\xQ=5JBiLMBMzOXgo(GuMJZGMnVG>l8sS%=WE000&s*d&MKG\F"„U "6ei>or)?HS5VH^&#k?kvo#6NALsIMEj/ie+gyh3]/D,\ss3LK$tG[Y8b0Z>9H4d"„U "vOsx+&CfHO,Jdb^J:R4V6fhK8(JiR0Iw$+HCNrGBtmg]oP;HiNJxoJ\L,rl2u4P"„U "w)luottVj?VBr.+u:<taaB%0h8nn[5purMRzCPts,HjH<87A>L,,Yfkt$6FclMN"„U "2]fJfe3PlHqPqL*F672=T$6fR(K*B7=)&tJ&;y:lMKb_3KGjwyxs9D-]LLO.Spz"„U "M6T(_-+i^TG)#uc9XTJvLlv\jtsLa8sL\e:d0deqYz-1KOIjLh&p)aB71k<X11<"„U "TYO5Wt3ZPdDZ\peb8^pMR[cv^>wGf*1fMK\=rB/VEued6-uZ,=ll>OF?Qi<4tNv"„U "Dx%%up(%)9%'&O-%%#%f=O:fACS%+%%<%5%%0#%%%'%rxij%rtSgRfx&&<v>SmF"„U "8wBXNx0QA=2-Mo)qksr$Kk][Dsw)Atgm\N6tD1T?n/oSE0-hKtNvF%ddFs3_^qM"„U ";ZdRRhN$H5E:]IrH=dfO6tK3l'lV4xllT9RP3YXG:h#'8nFj,=[;QO#o[KkX<0B"„U ";SYe+ThH_0xYu8m/x#\=B2BuPo$Ep^M^9jBD/:Cfv7c#)KXW\hD/B4&0.tLb'Bl"„U "#-JBCM/LCV.b=yzku>fI69Bj\tv)A9N\Ns+a?:GiQMK;gT_3EG<=(;(./oP.4Vi"„U "C6%.D':1X0,'%1w8O\L3X.m57'Lo^W<ngD[24YDfW[^KB=5<w.wY.A45SBUaqU6"„U "lJCg6I2)PKv8CJ2J-N1eTDMs,m>R\Ka(.U[q+6xnxl#-t*lHpjS=(9:1:05,C<D"„U "2UEdWKp[iU;#p]$=?0UBZ/_F<=k]6EdSMk*E*_pmOW'XakH$=ghmKmJK8AC\PGl"„U ":kg?):1(\RMGLFs^U5_.$z&(wR)L\OIZnR8eAXL[J;a%P2tX#z-#eB9k02l1%Lg"„U ";k)c*3Gkn&bp)C%:);Ma:5Go<$YAR-eaVf?UNL.*o0xhZs\q?,,d_nw#RHOR'j="„U "kw45?,hb0oNd=iuBR$Ir#)ezUN$7sQIr#-pjVOQb+cTt5tb?\L,<O<I(3d)OQBB"„U "Oqi;+6Rw_u91U*T$[VHsod%X7)BVpP4clcF2SHta^(=R-8uAFkLCv3P5Ar)t)8x"„U "ZABI1KCr$srRE.Nu6VCt/S>0jERpixuB82,nKB(ZM&(dZ&?0Lr94]&#>mafk5Rg"„U "YnL3]IhkdvkXS2[RiKGs$b'&QQD;gv1K#0Fi<M1T.B'.Qv#F8,O5gHJNX#3?wMY"„U "hg;TiY9F+)QI7aXam%oNp7c]9[HsgFr&.\W<,2ihhuh>I^l1YSs7h4kk<0;Y7T5"„U "ZBBJbhG,_l8;pVPV;17_k,+a)e<+CxtVt+Z8\R<;kLBgK/B&]Go)$bU]n9<g.,e"„U "e.h?%aoU]HmKEw_)=ANUiM_-Y^g9C[t%.Gq\JMKTCSP=fVq6i&W3?;>Hldc9oAT"„U "&KX;dXSNJ17?0Y3(*(w\C)q4hRQN?E:i[MihQZX2:6E,BvCAF&l$;>g+5wddi4y"„U "-b&^fKo3lpU*CkvPV5aGs)gTDW0v?sWN[AqX#GCSgbPWF$E+/C7KJ*PCnOWBq+N"„U "SSmhQqBXgaMyCOcG;n([qsSZPQK=4RM6)T')vg#(KB\T->wX'*Rc/,.e^^FsO$U"„U "(7+UTx0Ft0)SFEK;qSN/FBb1AxKH4Ec\4^#%dpfEs7m47:C%y/VK(t&02%R;%?/"„U "3o4*:gBXiR>Q.YL#)?9e/,HN#Rz9x72:E/Lr&u.aUZ7IKOdbtKTcKoZN[-IszbS"„U "&od2fG:l$tT.Sw9m9n506[v)QrJ58pp6&o%9*>e+M71,URYR=G>C0=[s8s8Kff,"„U "9Sm\rY6d&KKYy;GCf$iIWcrM0D9ia9,%N>6,PJU5x$))l</aq-<DbtI3(bP.3&g"„U "%jDSd/+6K=R9Gn:)MB;$Zi,KVBi;CUOmx0FUYHhMjcEj;SG_6V5VBKYCS;_=p,u"„U ",kTZh\0iq=EQ=bv>3O.1BCb2PT(Sy<nTaj(Lp74)?;H18gv&.gx>KWy/,OGWG+$"„U "rGzoWHuXI8O=BZnZi)T0n?Uja7NwReG#.fkR$]V'ZA-BrS2Pe^(QvgjR_v&B]K-"„U "GqM467kqEW,eq'B4f5(GU%9UybeOQxw.PYI2=]7T*R%?ZLTQ3(%gj#-$bqmtKOr"„U "GpBo*BSfS^2&]/30Y/0jA7gWvXgifcO)$k\_kgnca+W/m#pVUa%F.4<8c3(_JS5"„U "t$IFZCl8u[6w]P/c1cLrJ3i6d;XlhP^$Z';HTqZR75PXtdZ47)J(M<YWg&s<uE7"„U "5g;(PkxVQhJ4554Ybp=S=h<*,F\Jfz&[5iH[Oh\ptqTF-;Ok'KNsTJvFTS*gQPb"„U "I($UIqd1<;^dC]D*DybjqIdFf%.,$Oc8X4t%U>=I)gcAo#NIrEq=YE^F>t/Y?HZ"„U "rWnWh56gu0[>80w'%up&'%9%9%%'%-%%%%f=;QJ*;'P'%%';)%%%,%%%%%%%%%%"„U "%E%%%%%%.%%'r%xStg%oup&%'9%9%%'%-%%%%f%=$S:+]57%%%4^%%%,%%%%%%%"„U "%%&%E[%%%u#'%%'%rxSw%jkup%&'9%%9%'%%-%%%.f=Of,ACS+%%%<5%%%0%%%%"„U "%%%%%&%%E%%%'V:%%&'rxi%jrtS%gfxu%p*+%%%%%(#%(%r%%%%Y%A%%%%%"„END SUB„„Don Watkins                    PEEKS AND POKES                PEEKS,AND,POKES                Unknown Date           QB, QBasic, PDS        210  7958     PEEKPOKE.TXT        COMMONLY USED BASIC PEEKS, POKES AND SUBROUTINES „ „DUE TO THE LACK OF A COMPREHENSIVE, PUBLISHED DIRECTORY OF COMMONLY USED„POKES, PEEKS AND SUBROUTINES THIS LIST HAS BEEN COMPILED BY THE SMUG„PROSIG AS WELL AS A MANY OTHER HARDWORKING PD SOURCES. THANKS AND A TIP„OF THE HAT TO ALL CONTRIBUTORS! ADDITIONS TO THE LIST ARE ENCOURAGED AND„SHOULD BE ADDRESS TO:„ „         DON WATKINS, CIS IBMSIG 76003,252 „ „    THERE ARE, OF COURSE NO WARRENTIES OR GUARENTEES THAT ANY OF STUFF„WORKS AND FURTHERMORE, IF IT BLOWS UP YOUR MACHINE IT AIN'T MY FAULT.„   „-----------------------------------------------------------------------„ „ „    BY SPECIFYING A DEF SEG=&H40 IN ANY BASIC PROGRAM, IT IS POSSIBLE TO„REFERENCE THE FOLLOWING VECTORS (FIELDS) IN THE ROM BIOS AREA BY USING A„PEEK FUNCTION AND THE FOLLOWING OFFSETS FROM THE CURRENT SEGMENT AS„„    DEFINED BY THE DEF SEG STATEMENT. „„ „     &H0       -  RS232 ADDRESSES ON YOUR IBM PC. „          THIS WILL ALLOW YOU TO TELL HOW MANY (UP TO „          FOUR) ASYNC CARDS ARE ATTACHED, IF ANY. „„     &H8       -  PRINTER ADDRESSES ON YOUR IBM PC.„          THIS WILL TELL YOU WHAT PRINTER ADDRESSES, „          AND HOW MANY (UP TO FOUR) EXIST. EACH IS „          ADDRESSED BY A TWO BYTE HEX VALUE. „„     &H10      -  EQUIPMENT FLAG.„          THIS FIELD DESCRIBES THE SETTING OF THE „          OPTIONS SWITCHES. IT DESCRIBES WHAT OPTIONAL „          DEVICES ARE ATTACHED TO THE SYSTEM. THE „          FOLLOWING LISTS THE BIT-SIGNIFICANCE OF THIS „          FIELD: „          BIT 0 - INDICATES THAT THERE ARE DISKETTE „                  DRIVES ON THE SYSTEM. „          BIT 1 - NOT USED. „          BIT 2,3 - PLANAR RAM SIZE (00=16K 10=32K 01=48K „                    11=64K) „          BIT 4,5 - INITIAL VIDEO MODE (00=UNUSED „                                        10=40X25 COLOR „                                        01=80X25 COLOR „                                        11=80X25 MONO)„          BIT 6,7 - NUMBER OF DISKETTE DRIVES (00=1 10=2 „                    01=3 11=4) ONLY IF BIT 0 = 1. „          BIT 8   - UNUSED „          BIT 9,10,11 - NUMBER OF RS232 CARDS ATTACHED „          BIT 12  - GAME I/O ATTACHED „          BIT 13  - NOT USED „          BIT 14,15   - NUMBER OF PRINTERS ATTACHED „     &H13      -  MEMORY SIZE IN K BYTES. „     &H15      -  I/O RAM SIZE IN K BYTES. „     &H17      -  KEYBOARD FLAG -- THE FOLLOWING LISTS THE MASKS „          SET TO DESCRIBE CURRENT KEYBOARD STATUS: „          BYTE 1; „          &H80 - INSERT STATE ACTIVE „          &H40 - CAPS LOCK STATE HAS BEEN TOGGLED „          &H20 - NUM LOCK STATE HAS BEEN TOGGLED „          &H10 - SCROLL LOCK STATE HAS BEEN TOGGLED „          &H08 - ALTERNATE SHIFT KEY DEPRESSED „          &H04 - CONTROL SHIFT KEY DEPRESSED „          &H02 - LEFT SHIFT KEY DEPRESSED „          &H01 - RIGHT SHIFT KEY DEPRESSED „          BYTE 2; „          &H80 - INSERT KEY IS DEPRESSED „          &H40 - CAPS LOCK KEY IS DEPRESSED„          &H20 - NUM LOCK KEY IS DEPRESSED „          &H10 - SCROLL LOCK KEY IS DEPRESSED „          &H08 - SUSPEND KEY HAS BEEN TOGGLED „     &H49      -  CURRENT CRT MODE „          &H00 - 40X25 BW „          &H01 - 40X25 COLOR „          &H02 - 80X25 BW „          &H03 - 80X25 COLOR „          &H04 - 320X200 COLOR „          &H05 - 320X200 BW „          &H06 - 640X200 BW „          &H07 - 80X25 B&W CARD -- SPECIALIZED USE, USED „                 INTERNAL TO THE VIDEO ROUTINES. „     &H4A      -  NUMBER OF CRT COLUMNS „     &H50      -  CURSOR POSITION (ONE OF EIGHT) „     &H60      -  CURRENT CURSOR MODE „     &H6C      -  LOW WORD OF TIMER COUNT „     &H6E      -  HIGH WORD OF TIMER COUNT „     &H71      -  &H07 - BREAK KEY DEPRESSED„     &HFA6E    -  BEGINNING OF CHARACTER REGEN MEMORY „     &HFF53    -  PRTSC ROUTINE ADDRESS „ „ „    TOGGLE NUM LOCK „     DEG SEG = &H40 : POKE &H17, PEEK(&H17) OR 32   'TO TURN ON „     DEG SEG = &H40 : POKE &H17, PEEK(&H17) AND 223 'TO TURN OFF „ „    TOGGLE CAPS LOCK „     DEG SEG = &H40 : POKE &H17, PEEK(&H17) OR 64   'TO TURN ON „     DEG SEG = &H40 : POKE &H17, PEEK(&H17) AND 171 'TO TURN OFF „ „    SET SCROLL WINDOW „     10 DEF SEG : POKE 91,20 : POKE 92,25            'SETS UP WINDOW ON LINE„     20 LOCATE X,20                                  'FORCE CURSOR TO WINDOW„ „    SET WINDOW WIDTH „     DEF SEG : POKE 41,30                           'SETS WINDOW WIDTH tO 30„ „    RESTORE FUNCTION KEYS TO DEFAULT „     10 DEF SEG = &HFACE „     20 K = 1 „     30 I = 13 „     40 T$ = STRING$(13,32): J = 1 „     50 T1 = PEEK(I):IF T1 < 0 THEN MID$(T$,J,1) = CHR$(T1):J = J + 1: I = I + 1 : GOTO 50„     60 KEY K,LEFT$(T$,J-1):IF K <10 THEN K = K + 1: I = I + 1: GOTO 40: ELSE KEY ON„ „     DETERMINE MONITOR TYPE „      10 DEF SEG = 0 „      20 MONITOR.TYPE = PEEK(&H410) AND &H40 „      30 IF MONITOR.TYPE = 1 PRINT "40 X 25 COLOR" „      40 IF MONITOR.TYPE = 32 PRINT "80 X 25 COLOR" „      50 IF MONITOR.TYPE = 48 PRINT "MONOCHROME" „ „     DETERMINE AMOUNT OF MEMORY INSTALLED (ONLY WORKS FOR GREATER THAN 48K)„      DEF SEG = 0: MEMORY% = PEEK(&H413)+(256*PEEK(&H414)) „„     OR, PUT ANOTHER WAY: „ „         MEMORY INFO:         DEF SEG=0 „ „   ((PEEK(1040) AND 12) + 4 ) * 4     - MEMORY ON MOTHER-BOARD „   PEEK(1045) + 256 * PEEK(1046)      - EXPANSION MEMORY (ADD ON) „   PEEK(1043) + 256 * PEEK(1044)      - TOTAL MEMORY „ „     READ DRIVE SWITCHES „      DEF SEG = 0: NUMBER.OF.DRIVES% = PEEK(&H410) AND &HC0 „ „ „      CURRENT DISK INFO:  DEF SEG=64 „      DEF SEG=64 „      PEEK(69)  -  TRACK „      PEEK(70)  -  HEAD „      PEEK(71)  -  SECTOR „  256^PEEK(72)  -  BYTES PER SECTOR „ „     DETERMINE IF GAME ADAPTER EXISTS „      10 DEF SEG = 0: GAME.ADAPTER% = PEEK(&H411) AND &H10 „      20 IF GAME.ADAPTER% = 0 THEN GAME.ADAPTER$ = "NO" ELSE GAME.ADAPTER$  = "YES --INSTALLED"„ „     KEYBOARD STUFF „„  TO DISABLE ENTIRE KEYBOARD:  DEF SEG=64: OUT 97,204„  TO RE-ENABLE KEYBOARD:       DEF SEG=64: OUT 97,76 „ „  PRINTER STATUS--- AT LEAST ON EPSON --- „„     DEF SEG=64„     A=PEEK(8)+256*PEEK(9) „     B=(INP(A+1) AND 248) XOR 72 „     IF (B AND 128)<>128 THEN PRINTER OFF LINE ELSE ON LINE „ „  INITIALIZE PRINTER:          DEF SEG: OUT A+2,8 „                               OUT A+2,12 „  NOTE: THE A TO INITIALIZE IS FROM PRINTER STATUS ROUTINE „ „  A SHORT PROGRAM TO DISABLE AND RE-ENABLE CTRL BREAK FOLLOWS. „ „  100 DIM OLD%(4) „  110 DEF SEG=0 „  120 ' SAVE THE OLD CONTROL BREAK ADDRESS „  130 FOR I=&H6C TO &H6F „  140   OLD%(I-&H6C)=PEEK(I)„  150 NEXT „  160 ' ESTABLISH NEW CONTROL BREAK ADDRESS  (POINT TO IRET) „  170 POKE &H6C,&H53 „  180 POKE &H6D,&HFF „  190 POKE &H6E,&H0 „  200 POKE &H6F,&HF0 „  210 DEF SEG „  220 ' RESET OLD CONTROL BREAK ADDRESS „  230 DEF SEG=0 „  240 FOR I=&H6C TO &H6F „  250   POKE I,OLD%(I-&H6C) „  260 NEXT „ „ „          SAVE AND RESTORE A SCREEN IMAGE „ „     1 DEF SEG = &HB800                      'SAVE SCREEN IMAGE...CHANGE FOR„     2 INPUT FILENAME$                       'MONOCHROME.„     3 BSAVE FILENAME$,0,&H4000 „     1000 INPUT "FILENAME";FILENAME$         'RESTORE IMAGE „     1010 CLS „     1020 DEF SEG = &HB800                   'CHANGE TO &HB000 TO MONO „     1030 BLOAD FILENAME$ „ „                 NICE TO KNOW „                BASIC UNPROTECT „    ENTER BASICA „    TYPE BSAVE "UN.P",1124,1 „    LOAD "MYPROG „    BLOAD "UN.P",1124 „    THE PROGRAM CAN NOW BE LISTED, EDITED AND SAVED AS A NORMAL FILE. „ „    THE LIST IS GROWING BUT COULD BE LONGER!  ANY AND ALL ADDITIONS OF„„    COMMONLY USED SUBROUTINES AND PEEK/POKE LOCATIONS WILL BE GLADLY„ADDED. ADDRESS ALL ADDITIONS TO:  DON WATKINS CIS 76003,252 (IBMSIG).„WITH A BIT OF YOUR ASSISTANCE THIS DOCUMENT CAN BECOME AN EFFECTIVE TOOL„FOR THE BASIC PROGRAMMER....  SO CHIP IN.„