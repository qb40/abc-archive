Antoni Gual                    DOS Timer using PIT            agual@eic.ictnet.es            03-15-02 (  :  )       QB, Qbasic, PDS, PB    199  6063     Timerlib.basDECLARE FUNCTION Delay% (d AS ANY)„DECLARE FUNCTION XTimerD& ()„DECLARE FUNCTION XTimerW& ()„'--------------------------------------------------------------------------„'Microsecond timer library.Using DOS timer + PIT„'By Antoni Gual agual@eic.ictnet.es  3/2002„'--------------------------------------------------------------------------„'THE PROBLEM:„'To delay for intervals smaller than the QB'S TIMER resolution, a solution is„'to do a delay loop with parameters calculated on the speed of the pc.„'Unfortunately this calibration gives normally poor results when the user's„'pc is 'much faster, or slower than the test pc.„„'HOW DOES IT WORK:„'The PIT (Programmable Interval Timer) was the chip that keped the paces in„'the software timer, the speaker beeps and the DRAM refresh.Today its„'functions are emulated in the chipset.„'A backwards counter in the PIT starts at 65535 counts at a frequency of„'1,193,181 Hz. When it gets zero resets itself and issues an interrupt„'(it happens 18,2 times per second), used by DOS to update the software timer.„'At any time you can use the PIT register reading to increase accuracy of the„'DOS timer reading.„„'WINDOWS WARNING:„'In a DOS box in Win32, almost everything is emulated. The DOS timer update„'is not done at the same moment when PIT counter becomes 0, so you can have„'low readings (1/18.2 second lower than it should be)„„'So I present here two routines XTimerD& and XTimerW&„'Both give times in PIT units (1/1193181 of second), the first one is faster„'but will give incorrect readings in Windows. The second corrects the problem„'but it's 50% to 100% slower.„'Both routines are able to time a maximum delay of 29.99 minutes, limited by„'the capacity of the LONG variables used.„„„'The Delay routine is the base to implement your delays.It deals with timer„'rollovers.You can nest delays by using diferent delay vars.„'----------------------------------------------------------------------------„„'You can use these constants to convert XTimer readings to seconds„CONST clockfreq# = 1193181.666#           'PIT clock frequency„CONST secstick# = 1 / clockfreq#„„TYPE delaytype„ start AS LONG„ ends AS LONG„END TYPE„„CLS„xx$ = "|/\-"„'----------------speed test-----------------------------------------„„„„„nt = 3000„FOR j = 1 TO 3„dtimer& = 0„ltimer& = XTimerD&„'call xtimer nt times„FOR i% = 1 TO nt„    tim& = XTimerD&„    dtimer& = dtimer& + tim& - ltimer&„    SWAP ltimer&, tim&„NEXT„„'time the empty loop„dtimer1& = 0„xtimer& = XTimerD&„lt1& = 1&„„FOR i% = 1 TO nt„    tim& = 1&„    dt1& = dt1& + tim& - lt1&„    SWAP lt1&, tim&„NEXT„„'substract empty loop time„dtimer& = dtimer& - XTimerD& + ltimer&„PRINT USING "A call to XtimerD needs ##.#### milliseconds(Averaged in #### calls)"; dtimer& * secstick# * 1000 / nt; nt„NEXT„„'3 tests„FOR j = 1 TO 3„dtimer& = 0„ltimer& = XTimerW&„'call xtimer nt times„FOR i% = 1 TO nt„    tim& = XTimerW&„    dtimer& = dtimer& + tim& - ltimer&„    SWAP ltimer&, tim&„NEXT„„'time the empty loop„dtimer1& = 0„xtimer& = XTimerW&„lt1& = 1&„„FOR i% = 1 TO nt„    tim& = 1&„    dt1& = dt1& + tim& - lt1&„    SWAP lt1&, tim&„NEXT„„'substract empty loop time„dtimer& = dtimer& - XTimerW& + ltimer&„„PRINT USING "A call to XtimerD needs ##.#### milliseconds(Averaged in #### calls)"; dtimer& * secstick# * 1000 / nt; nt„NEXT„„'--------------------------implementing a delay -------------------------„„PRINT "delaying for 0.5 seconds  ";„a = 0„T& = XTimerW&„'--------to implement a delay first dim a variable of delaytype----------„DIM d AS delaytype„„'Then preset it with .start=-1 and .ends=delay time in PIT ticks„„d.start = -1: d.ends = .5 * clockfreq#„„'--------------------call delay function to initialize it-----------------„dummy = Delay%(d)„„'-----------------And loop until a delay call  returns <>0----------------„DO„    'do anything you want during the delay loop!!!!!„    a = (a + 1)„    LOCATE , 26: PRINT MID$(xx$, (a AND 3) + 1, 1);„LOOP UNTIL Delay%(d)„„'-----------------------------delay ended---------------------------------„PRINT USING "Delay was called #### times.  #.##### secs "; a; (XTimerW& - T&) * secstick#„„„FUNCTION Delay% (d AS delaytype)„'pass a start of -1 and a time into end to initialize delay„'Keep on calling it until it returns -1„„CONST tr& = &H3FFFFFFF, tc& = &H40000000„IF d.start = -1 THEN„    d.start = XTimerW&„    T& = d.ends„    d.ends = (d.start AND tr&) + (d.ends AND tr&)„    c% = ((d.start AND tc&) = tc&) + ((T& AND tc&) = tc&) + ((d.ends AND tc&) = tc&)„    IF c% AND 1 THEN d.ends = d.ends OR tc&„    EXIT FUNCTION„ELSE„    T& = XTimerW&„    IF d.ends > d.start THEN„        IF T& >= d.ends THEN Delay = -1: EXIT FUNCTION„    ELSE„        IF T& < d.start THEN„            IF T& >= d.ends THEN Delay = -1: EXIT FUNCTION„        END IF„    END IF„END IF„END FUNCTION„„FUNCTION XTimerD&„'returns time in PIT ticks modulo 29 min„'for use in plain DOS. In Windows some readings are 1/18.2 seconds too low!„„„CONST forty = &H40„CONST byte = 256&„    DEF SEG = forty„    IF NOT ini% THEN OUT &H43, &H0: ini% = -1„    DO„        t3& = PEEK(&H6D) AND &H7F„        t2& = PEEK(&H6C)„        t0& = INP(forty)„        t1& = INP(forty)„    LOOP UNTIL t2& = PEEK(&H6C)„    XTimerD& = -t0& + byte * (-t1& + byte * (1& + t2& + byte * t3&))„END FUNCTION„„FUNCTION XTimerW& STATIC„'returns time in PIT ticks modulo 30 min     „'Slow but safe to use in a DOS box in Windows as in plain DOS„CONST forty = &H40„CONST byte = 256&„    DEF SEG = forty„    IF NOT ini% THEN OUT &H43, &H0: ini% = -1„    DO„        t3& = PEEK(&H6D)„        t2& = PEEK(&H6C)„        t0& = INP(forty)„        t1& = INP(forty)„        x& = -t0& + byte * (-t1& + byte * (1& + t2& + byte * (t3& AND &H7F)))„        'rollover!„        IF (t3& AND &H80) <> lt3& THEN EXIT DO„    LOOP UNTIL x& > X1&„    SWAP x&, X1&: XTimerW& = X1&„    lt3& = t3& AND &H80„END FUNCTION„„David Williams                 When is Easter                 david.williams@ablelink.org    06-16-02 (  :  )       Qbasic,QB,PDS          71   1342     Easter.bas  ' EASTER.BAS „' Calculates (Gregorian-calendar) month and day of Easter Sunday. „  „' QBASIC code by David Williams, 2002 „' david.williams@ablelink.org „  „' Algorithm includes all rules for finding Easter, as „' used in western countries. „  „DECLARE SUB EaSun (Year%, Month%, Day%) „  „DEFINT A-Z „  „CLS „  „PRINT "Easter Sunday calculator." „PRINT „PRINT "Hit <ENTER> to quit." „  „DO „  „  PRINT „  INPUT "What year"; Y$ „  IF Y$ = "" THEN EXIT DO „  Year = VAL(Y$) „  PRINT „  „  IF Year >= 1582 THEN „  „    CALL EaSun(Year, Month, Day) „  „    IF Month = 3 THEN „      M$ = "March" „    ELSE ' Month must be 4 „      M$ = "April" „    END IF „  „    PRINT "In the year"; STR$(Year); „    PRINT ", Easter Sunday is on "; M$; STR$(Day); "." „  „  ELSE „  „    BEEP „    PRINT "Gregorian calendar not used before 1582." „  „  END IF „  „LOOP „  „END „  „SUB EaSun (Year, Month, Day) ' Finds month and day of Easter Sunday „  „  J = Year MOD 19 „  K = Year \ 100 „  L = Year MOD 100 „  M = K \ 4 „  N = K MOD 4 „  O = L \ 4 „  P = L MOD 4 „  Q = (8 * K + 13) \ 25 „  R = (19 * J + K - M - Q + 15) MOD 30 „  S = (J + 11 * R) \ 319 „  T = (2 * (N + O) - P - R + S + 32) MOD 7 „  U = R - S + T „  „  Month = (U + 90) \ 25 „  Day = (U + Month + 19) MOD 32 „  „END SUB „  „David Williams                 What is the Julian Date?       david.williams@ablelink.org    06-16-02 (  :  )       Qbasic,QB,PDS          203  4803     Jgconv.bas  'There are already some programs of mine in the ABC archives. Maybe this„'one should go there too. People who are interested in astronomy may„'well find it useful.„  „'David Williams„  „'-------------------------------------------------„  „' JGCONV.BAS„' Julian Day and Gregorian Date interconverter„  „' David Williams. 2001„' david.williams@ablelink.org„  „' Program interconverts Gregorian-calendar dates (regular ones)„' with Julian Days, a dating system used by astronomers which„' simply counts days from a starting point in the distant past.„  „' Note: For years before 1 C.E. (A.D.), program uses rationalized„' calendar. Year before year 1 is year 0. Year before that is„' year -1, and so on.„  „DECLARE SUB J2G ()„DECLARE SUB G2J ()„DECLARE SUB JultoGreg ()„DECLARE SUB GregtoJul ()„DECLARE FUNCTION Dte$ ()„DECLARE FUNCTION DivMult% (FirstPeriod%, LastPeriod%)„  „DEFINT A-Z„DIM SHARED Year AS INTEGER, Month AS INTEGER, Day AS SINGLE„DIM SHARED JulianDay AS DOUBLE, Num AS DOUBLE„DIM SHARED Period(1 TO 7, 1 TO 2) AS LONG„  „CONST ZeroOffset# = 1721119.5#„' Difference between Julian and Gregorian zeroes.„' Note: Julian Days start and end at noon UT, hence the .5„  „DATA 146097, 400, 36524, 100, 1461, 4, 365, 1, 153, 5, 61, 2, 31, 1„'Data are day-numbers and periods, e.g. 146097 days in 400 years.„'First 4 pairs are days and years. Last 3 are days and months.„  „FOR X = 1 TO 7„  FOR Y = 1 TO 2„    READ Period(X, Y)„  NEXT„NEXT„  „CLS„PRINT "Decimal fractions of Julian Days or Days of Month are allowed."„PRINT "Gregorian Dates should be in Universal Time (GMT)."„  „DO„  PRINT„  PRINT "1.  Gregorian to Julian"„  PRINT "2.  Julian to Gregorian"„  PRINT "3.  Quit"„  PRINT„  PRINT "Which? (by number) ";„  „  DO„    Key$ = INKEY$„  LOOP UNTIL Key$ >= "1" AND Key$ <= "3"„  PRINT Key$„  PRINT„  „  SELECT CASE Key$„     CASE "1"„       CALL G2J„     CASE "2"„       CALL J2G„     CASE "3"„       EXIT DO„  END SELECT„  „LOOP„  „END„  „„FUNCTION DivMult (FirstPeriod, LastPeriod)„' Utility function used by JultoGreg„  „ Total = 0„  „ FOR J = FirstPeriod TO LastPeriod„  „   Quot = INT(Num / Period(J, 1))' number of periods in Num days„  „   IF Quot = 4 THEN„      IF J = 2 OR J = 4 THEN Quot = 3' needed for February 29„   END IF„  „   Num = Num - Quot * Period(J, 1)' subtract the periods from Num„  „   Total = Total + Quot * Period(J, 2)' add in the years or months„  „ NEXT J„  „ DivMult = Total' number of years or months„  „END FUNCTION„„FUNCTION Dte$ ' puts Gregorian date in standard format„  „  Dte$ = STR$(Year) + "," + STR$(Month) + "," + STR$(Day)„  „END FUNCTION„„SUB EaSun (Year, Month, Day) ' Finds month and day of Easter Sunday„  „  J = Year MOD 19„  K = Year \ 100„  L = Year MOD 100„  M = K \ 4„  N = K MOD 4„  O = L \ 4„  P = L MOD 4„  Q = (8 * K + 13) \ 25„  R = (19 * J + K - M - Q + 15) MOD 30„  S = (J + 11 * R) \ 319„  T = (2 * (N + O) - P - R + S + 32) MOD 7„  U = R - S + T„  „  Month = (U + 90) \ 25„  Day = (U + Month + 19) MOD 32„  „END SUB„„SUB G2J ' Gregorian to Julian package„  „  INPUT "Greg. Date (YYYY,MM,DD) (WITH commas!) "; Year, Month, Day„  „  Date1$ = Dte$„  „  CALL GregtoJul„  CALL JultoGreg' Reverse conversion checks date's legality„  „  IF Date1$ = Dte$ THEN„         PRINT„         PRINT "Julian Day is: "; JulianDay„  ELSE„         BEEP„         PRINT„         PRINT "Illegal Gregorian Date"„  END IF„  „END SUB„„SUB GregtoJul ' Does basic Gregorian to Julian conversion„  „  ' Shift New Year from January 1 to March 1„  IF Month < 3 THEN„      Mth = Month + 9„      Yr = Year - 1„  ELSE„      Mth = Month - 3„      Yr = Year„  END IF„  „  Leap = INT(Yr / 4) - INT(Yr / 100) + INT(Yr / 400)„  ' leap years since Gregorian zero (March 1 in Year 0)„  „  Before = INT(30.6 * Mth + .5)„  ' days in this year (starting March 1) before present month„  „  JulianDay = ZeroOffset# + 365& * Yr + Leap + Before + Day - 1„  „END SUB„„SUB J2G ' Julian to Gregorian package„  „  INPUT "Julian Day"; JulianDay„  „  CALL JultoGreg„  „  PRINT„  PRINT "In format Year, Month, Day: Gregorian Date is:  "; Dte$„  „END SUB„„SUB JultoGreg ' Does basic Julian to Gregorian conversion„  „  Num = JulianDay - ZeroOffset#' days since Gregorian zero„  ' Note: DivMult reduces Num to show days remaining.„  „  Yr = DivMult(1, 4)' periods 1 - 4 are multiples of years„  „  Mth = DivMult(5, 7)' periods 5 - 7 are multiples of months„  „  Day = Num + 1' first day of month is #1, not #0„  „  ' Shift New Year from March 1 to January 1„  IF Mth > 9 THEN„      Month = Mth - 9„      Year = Yr + 1„  ELSE„      Month = Mth + 3„      Year = Yr„  END IF„  „END SUB„„David Williams                 Number of days between dates   david.williams@ablelink.org    09-15-02 (  :  )       QB,Qbasic,PDS          120  2798     datecalc.bas' DATECALC.BAS „  „' David Williams. 2002 „  „' david.williams@ablelink.org „  „' Program does simple calendar calculations, finding the number „' of days between two dates, or the date that is a given number of „' days after or before a given date. „  „' Decimal fractions of days are allowed. „  „DECLARE SUB SubDates () „DECLARE SUB AddDays () „DECLARE SUB DateIn (P$) „DECLARE SUB XD2G () „DECLARE SUB G2XD () „DECLARE FUNCTION Dte$ () „DECLARE FUNCTION DivMult% (Sep$, N&) „DEFINT A-Z „DIM SHARED Year AS INTEGER, Month AS INTEGER, Day AS SINGLE „DIM SHARED XDay AS DOUBLE „CLS „DO „  PRINT „  PRINT "1. Calculate number of days between two dates" „  PRINT "2. Calculate a date plus or minus some days" „  PRINT "3. Quit program" „  PRINT „  PRINT "Which (1 - 3)? "; „  DO „    K$ = INKEY$ „  LOOP UNTIL K$ >= "1" AND K$ <= "3" „  PRINT K$ „  PRINT „  SELECT CASE K$ „    CASE "1" „      CALL SubDates „    CASE "2" „      CALL AddDays „    CASE "3" „      EXIT DO „  END SELECT „LOOP „END „  „SUB AddDays „  CALL DateIn("Starting") „  INPUT "Add how many days (to subtract, use negative)"; Offset# „  XDay = XDay + Offset# „  CALL XD2G „  PRINT "Resulting date (Year, Month, Day) is "; Dte$ „END SUB „  „SUB DateIn (P$) „  DO „    PRINT P$; " date "; „    INPUT "(YYYY,MM,DD - with commas)"; Year, Month, Day „    D1$ = Dte$ „    CALL G2XD „    CALL XD2G „    IF D1$ = Dte$ THEN EXIT DO „    BEEP „    PRINT "Illegal Gregorian Date!" „  LOOP „END SUB „  „FUNCTION DivMult (Sep$, N&) „ A$ = ";146097,400;36524,100;1461,4;365,1:153,5:61,2:31,1" „ Total = 0 „ B = 1 „ DO „   B = INSTR(B, A$, Sep$) + 1 „   IF B = 1 THEN EXIT DO „   Days& = VAL(MID$(A$, B)) „   IF N& < 0 OR N& >= Days& THEN „     Quot = INT(N& / Days&) „     IF Quot = 4 THEN IF MID$(A$, B, 3) = "365" THEN Quot = 3 „     N& = N& - Quot * Days& „     Total = Total + Quot * VAL(MID$(A$, INSTR(B, A$, ",") + 1)) „   END IF „ LOOP „ DivMult = Total „END FUNCTION „  „FUNCTION Dte$ „  Dte$ = LTRIM$(STR$(Year)) + "," + STR$(Month) + "," + STR$(Day) „END FUNCTION „  „SUB G2XD „  IF Month < 3 THEN „      Mth = Month + 9 „      Yr = Year - 1 „  ELSE „      Mth = Month - 3 „      Yr = Year „  END IF „  Leap = INT(Yr / 4) - INT(Yr / 100) + INT(Yr / 400) „  Before = INT(30.6 * Mth + .5) „  XDay = 365& * Yr + Leap + Before + Day - 1 „END SUB „  „SUB SubDates „  CALL DateIn("Earlier") „  X# = XDay „  CALL DateIn("Later") „  PRINT "Difference between dates is"; CSNG(XDay - X#); "days." „END SUB „  „SUB XD2G „  N& = INT(XDay) „  F! = XDay - N& „  Year = DivMult(";", N&) „  Month = DivMult(":", N&) + 3 „  Day = N& + F! + 1 „  IF Month > 12 THEN „    Month = Month - 12 „    Year = Year + 1 „  END IF „END SUB „David Williams                 Find the days of the week      david.williams@ablelink.org    09-15-02 (  :  )       QB,Qbasic,PDS          37   796      weekdays.bas' WEEKDAYS.BAS „  „' Function "DayName$" finds day of week for any Gregorian date. „' Rest of program is demonstration. „  „' david.williams@ablelink.org „  „DECLARE FUNCTION DayName$ (Year%, Month%, Day%) „DEFINT A-Z „  „DO „  „  INPUT "Date (YYYY,MM,DD)"; Y, M, D „  PRINT "This date is a "; DayName$(Y, M, D) „  „  PRINT "Another? (y/n) "; „  DO „    K$ = UCASE$(INKEY$) „  LOOP UNTIL K$ = "Y" OR K$ = "N" „  PRINT K$ „  „LOOP UNTIL K$ = "N" „  „END „  „FUNCTION DayName$ (Y, M, D) „  IF M > 2 THEN „    P = M - 3 „    Q = Y „  ELSE „    P = M + 9 „    Q = Y - 1 „  END IF „  Z = (D + Q + Q \ 4 - Q \ 100 + Q \ 400 + CINT(2.6 * P)) MOD 7 „  N$ = "Tues  WednesThurs Fri   Satur Sun   Mon" „  DayName$ = RTRIM$(MID$(N$, 6 * Z + 1, 6)) + "day" „END FUNCTION „David Williams                 Daylite Saving Time            david.williams@ablelink.org    12-15-02 (  :  )       Qbasic,QB,PDS          11   329      DST.BAS     DEFINT A-Z „CLS „INPUT "Year"; Y „Q = (Y + Y \ 4 - Y \ 100 + Y \ 400) MOD 7 „F = 1 + (8 - Q) MOD 7 „B = 25 + (11 - Q) MOD 7 „PRINT "In most of North America, in the year"; STR$(Y); „PRINT ", clocks are set ahead on" „PRINT "April"; STR$(F); ", and back on October"; STR$(B); "." „PRINT "Both dates are Sundays." „END „