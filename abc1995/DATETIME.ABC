The ABC Programmer             A PERPETUAL CALENDAR           PERPETUAL,CALENDAR             05/15/94 (00:00)       QB, QBasic, PDS        363  9072     CALENDAR.BASDECLARE FUNCTION MonthDays% (monthNum%, year%)„DECLARE SUB ClearBuffer ()„DECLARE SUB ShowSchedule ()„DECLARE SUB CenterMessage (Info$, LineNum%, Colour%)„DECLARE SUB ShowMonth (Month%, day%, year%)„DECLARE FUNCTION DayNum% (Month%, day%, year%)„DECLARE FUNCTION DateNum& (Month%, day%, year%)„DECLARE FUNCTION LeapYear% (year%)„DECLARE FUNCTION MonthName$ (monthNum%)„DECLARE FUNCTION MonthDay% (Month%, year%)„„CONST MAXYEAR% = 2100„CONST MINYEAR% = 1950„CONST FALSE% = 0„CONST TRUE% = NOT FALSE%„„curMonth% = VAL(LEFT$(DATE$, 2))„curDay% = VAL(MID$(DATE$, 4, 2))„curYear% = VAL(RIGHT$(DATE$, 4))„CLS„ShowMonth curMonth%, curDay%, curYear%„CALL ShowSchedule„GOSUB ShowNotes„„SelectMonth:„„V$ = INKEY$„  IF V$ = CHR$(0) + "H" THEN GOSUB PreviousWeek„  IF V$ = CHR$(0) + "P" THEN GOSUB NextWeek„  IF V$ = CHR$(0) + "K" THEN GOSUB PreviousDay„  IF V$ = CHR$(0) + "M" THEN GOSUB NextDay„  IF V$ = CHR$(0) + "Q" THEN GOSUB NextMonth„  IF V$ = CHR$(0) + "I" THEN GOSUB PreviousMonth„  IF V$ = CHR$(13) THEN GOTO CallCalendar„  IF V$ = CHR$(27) THEN GOTO QuitProgram„„„done% = FALSE%„makeCall% = FALSE%„„GOTO SelectMonth„„CallCalendar:„    ComLine$ = STR$(curMonth%) + "/"„    ComLine$ = ComLine$ + STR$(curDay%) + "/"„    ComLine$ = ComLine$ + STR$(curYear%)„„    OPEN "SCHEDULE.DAT" FOR INPUT AS #1„      DO„        LINE INPUT #1, DAT$„        IF INSTR(DAT$, ComLine$) > 0 THEN„          GOSUB DisplaySchedule: EXIT DO„        ELSE„          GOSUB InputSchedule: EXIT DO„        END IF„      LOOP UNTIL EOF(1)„    CLOSE #1„„    ShowMonth curMonth%, curDay%, curYear%„„GOTO SelectMonth„„PreviousDay:„  IF curDay% > 1 THEN„    curDay% = curDay% - 1„  ELSEIF curMonth% > 1 THEN„    curMonth% = curMonth% - 1„    curDay% = MonthDays%(curMonth%, curYear%)„    VIEW PRINT 1 TO 11„    CLS„    GOSUB ShowNotes„  ELSE„    curYear% = curYear% - 1„    curMonth% = 12„    curDay% = 31„  END IF„  ShowMonth curMonth%, curDay%, curYear%„RETURN„„NextDay:„  IF curDay% < MonthDays%(curMonth%, curYear%) THEN„    curDay% = curDay% + 1„  ELSEIF curMonth% <> 12 THEN„    curDay% = 1„    curMonth% = curMonth% + 1„    VIEW PRINT 1 TO 11„    CLS„    GOSUB ShowNotes„  ELSE„    curDay% = 1„    curMonth% = 1„    curYear% = curYear% + 1„  END IF„  ShowMonth curMonth%, curDay%, curYear%„RETURN„„PreviousWeek:„  IF curDay% > 7 THEN„    curDay% = curDay% - 7„    ShowMonth curMonth%, curDay%, curYear%„  END IF„RETURN„„NextWeek:„  IF curDay% <= MonthDays%(curMonth%, curYear%) - 7 THEN„    curDay% = curDay% + 7„    ShowMonth curMonth%, curDay%, curYear%„  END IF„RETURN„„PreviousMonth:„  IF curMonth% > 1 THEN„    curMonth% = curMonth% - 1„  ELSEIF curYear% > MINYEAR% THEN„    curYear% = curYear% - 1„    curMonth% = 12„  END IF„  maxDay% = MonthDays%(curMonth%, curYear%)„  IF curDay% > maxDay% THEN curDay% = maxDay%„  VIEW PRINT 1 TO 11„  CLS„  ShowMonth curMonth%, curDay%, curYear%„  GOSUB ShowNotes„RETURN„„NextMonth:„  IF curMonth% < 12 THEN„    curMonth% = curMonth% + 1„  ELSEIF curYear% < MAXYEAR% THEN„    curYear% = curYear% + 1„    curMonth% = 1„  END IF„  maxDay% = MonthDays%(curMonth%, curYear%)„  IF curDay% > maxDay% THEN curDay% = maxDay%„  VIEW PRINT 1 TO 11„  CLS„  ShowMonth curMonth%, curDay%, curYear%„  GOSUB ShowNotes„RETURN„„PreviousYear:„  IF curYear% > MINTEAR% THEN„    curYear% = curYear% - 1„    maxDay% = MonthDays%(curMonth%, curYear%)„    IF curDay% > maxDay% THEN curDay% = maxDay%„    ShowMonth curMonth%, curDay%, curYear%„  END IF„RETURN„„NextYear:„  IF curYear% < MAXYEAR% THEN„    curYear% = curYear% + 1„    maxDay% = MonthDays%(curMonth%, curYear%)„    IF curDay% > maxDay% THEN curDay% = maxDay%„    ShowMonth curMonth%, curDay%, curYear%„  END IF„RETURN„„DisplaySchedule:„  INPUT #1, Info1$, Info2$, Info3$„  VIEW PRINT 12 TO 23„  IF curMonth% = 1 THEN curMonth$ = " January"„  IF curMonth% = 2 THEN curMonth$ = " February"„  IF curMonth% = 3 THEN curMonth$ = " March"„  IF curMonth% = 4 THEN curMonth$ = " April"„  IF curMonth% = 5 THEN curMonth$ = " May"„  IF curMonth% = 6 THEN curMonth$ = " June"„  IF curMonth% = 7 THEN curMonth$ = " July"„  IF curMonth% = 8 THEN curMonth$ = " August"„  IF curMonth% = 9 THEN curMonth$ = " September"„  IF curMonth% = 10 THEN curMonth$ = " October"„  IF curMonth% = 11 THEN curMonth$ = " November"„  IF curMonth% = 12 THEN curMonth$ = " December"„  LOCATE 17, 5: COLOR 14: PRINT curMonth$; curDay%; curYear%„  CALL CenterMessage(Info1$, 19, 15)„  CALL CenterMessage(Info2$, 20, 7)„  CALL CenterMessage(Info3$, 21, 7)„  VIEW PRINT 1 TO 11„RETURN„„ShowNotes:„VIEW PRINT 13 TO 15„LOCATE 14, 3: COLOR 7: PRINT "Notes:"„COLOR 10„currentDay% = curDay%„GOSUB NextCurDay„M = 7„OPEN "SCHEDULE.DAT" FOR INPUT AS #1„  DO„    LINE INPUT #1, DAT$„    IF INSTR(DAT$, ComLine$) THEN M = M + 2: LOCATE 14, M: PRINT currentDay%: currentDay% = currentDay% + 1: GOSUB NextCurDay„  LOOP UNTIL EOF(1)„CLOSE #1„VIEW PRINT 1 TO 11„RETURN„„NextCurDay:„    ComLine$ = STR$(curMonth%) + "/"„    ComLine$ = ComLine$ + STR$(currentDay%) + "/"„    ComLine$ = ComLine$ + STR$(curYear%)„RETURN„„InputSchedule:„RETURN„„QuitProgram:„  done% = TRUE%„„SUB CenterMessage (Info$, LineNum%, Colour%)„LOCATE LineNum%, 15„LOCATE LineNum%, INT((80 - LEN(Info$)) / 2)„COLOR Colour%, 0„PRINT LEFT$(Info$, 77)„END SUB„„SUB ClearBuffer„„  DO WHILE INKEY$ <> ""„  LOOP„„END SUB„„FUNCTION DateNum& (Month%, day%, year%)„„  startYear% = 1900„  january% = 1„  daysPerYr& = 365„„  tooEarly% = (year% < startYear%)„  badMonth% = (Month% < 1 OR Month% > 12)„  badDay% = (day% < 1 OR day% > MonthDays%(Month%, year%))„  IF tooEarly% OR badMonth% OR badDay% THEN„    DateNum& = 0„    EXIT FUNCTION„  END IF„„  num& = daysPerYr& * (year% - startYear%)„„  FOR curYear% = startYear% TO year% - 1 STEP 4„    IF LeapYear%(curYear%) THEN num& = num& + 1„  NEXT curYear%„„  FOR curMonth% = january% TO Month% - 1„    num& = num& + MonthDays%(curMonth%, year%)„  NEXT curMonth%„„  num& = num& + day%„  DateNum& = num&„„END FUNCTION„„FUNCTION DayNum% (Month%, day%, year%)„„  d& = DateNum&(Month%, day%, year%)„  IF d& <> 0 THEN dow% = d& MOD 7 + 1 ELSE dow% = 0„„  DayNum% = dow%„„END FUNCTION„„FUNCTION LeapYear% (year%)„„  divBy4% = (year% MOD 4 = 0)„  century% = (year% MOD 100 = 0)„  century400% = (year% MOD 400 = 0)„„  LeapYear% = divBy4% AND (century% IMP century400%)„„END FUNCTION„„FUNCTION MonthDays% (monthNum%, year%)„„  IF monthNum% < 1 OR monthNum% > 12 THEN„    MonthDays% = 0„    EXIT FUNCTION„  END IF„„  SELECT CASE monthNum%„   „    CASE 2„      days% = 28„      IF LeapYear%(year%) THEN days% = days% + 1„    CASE 4, 6, 9, 11„      days% = 30„    CASE ELSE„      days% = 31„  END SELECT„„  MonthDays% = days%„„END FUNCTION„„FUNCTION MonthName$ (monthNum%)„„       M$ = "January   February  March     April     "„  M$ = M$ + "May       June      July      August    "„  M$ = M$ + "September October   Novemeber December  "„„  IF monthNum% >= 1 AND monthNum% <= 12 THEN„    moStr$ = MID$(M$, (monthNum% - 1) * 10 + 1, 10)„    moStr$ = RTRIM$(moStr$)„  ELSE„    moStr$ = ""„  END IF„  MonthName$ = moStr$„„END FUNCTION„„SUB ShowMonth (Month%, day%, year%)„„  firstDay% = DayNum%(Month%, 1, year%)„  monthLength% = MonthDays%(Month%, year%)„  moStr$ = MonthName$(Month%)„  LOCATE 1, 1„  COLOR 14, 0: PRINT SPACE$(35 - LEN(moStr$) \ 2); moStr$; year%„  PRINT„  COLOR 15„  PRINT " Sunday     Monday     Tuesday   Wednesday   Thursday   Friday    Saturday"„  PRINT„  COLOR 7„„  curDate% = 0„  DO„    PRINT "  ";„    FOR curDay% = 1 TO 7„      isFirstDay% = (curDay% = firstDay% AND curDate% = 0)„      isInMonth% = (curDate% > 0 AND curDate% < monthLength%)„      IF isFirstDay% OR isInMonth% THEN„        curDate% = curDate% + 1„        IF curDate% = day% THEN COLOR 15, 1„        PRINT USING "###"; curDate%;„        PRINT "        ";„        COLOR 7, 0„      ELSE„        PRINT "           ";„      END IF„    NEXT curDay%„    PRINT„  LOOP UNTIL curDate% = monthLength%„„ „END SUB„„SUB ShowSchedule„VIEW PRINT 12 TO 24„COLOR 11„LOCATE 13, 1: PRINT CHR$(218); STRING$(77, 196); CHR$(191)„LOCATE 14, 1: PRINT CHR$(179); STRING$(77, 0); CHR$(179)„LOCATE 15, 1: PRINT CHR$(192); STRING$(77, 196); CHR$(217)„LOCATE 17, 1: PRINT CHR$(218); STRING$(77, 196); CHR$(191)„LOCATE 18, 1: PRINT CHR$(179); STRING$(77, 0); CHR$(179)„LOCATE 19, 1: PRINT CHR$(179); STRING$(77, 0); CHR$(179)„LOCATE 20, 1: PRINT CHR$(179); STRING$(77, 0); CHR$(179)„LOCATE 21, 1: PRINT CHR$(179); STRING$(77, 0); CHR$(179)„LOCATE 22, 1: PRINT CHR$(179); STRING$(77, 0); CHR$(179)„LOCATE 23, 1: PRINT CHR$(192); STRING$(77, 196); CHR$(217)„VIEW PRINT 1 TO 11„END SUB„„„--------------[ Cut and save this as SCHEDULE.DAT ]-----------------„ 8/ 28/ 1995„"This is the Schedule.Dat file","To save notes press enter on any day","Enjoy!"„Dick Dennison                  RETURNS DAY OF THE WEEK        DAY,FUNCTION                   10/26/89 (00:00)       QB, PDS                16   646      DAYWEEK.BAS 'Day of Week - Dick Dennison 10/26/89„'$INCLUDE: 'qb.bi'    'load qb with the /L switch„'Interrupt 21 Function 2AH - get date„DIM InRegs AS RegType, OutRegs AS RegType„DIM Day(7) AS STRING * 3„Day$(0) = "Sun": Day$(1) = "Mon": Day$(2) = "Tue": Day$(3) = "Wed"„Day$(4) = "Thu": Day$(5) = "Fri": Day$(6) = "Sat"„CLS„InRegs.ax = &H2A * 256   '2Ah in ah„CALL INTERRUPT(&H21, InRegs, OutRegs)„' * * * cx is the year, dh is the month, dl is the date, al is the day„PRINT OutRegs.cx; " = year"„PRINT OutRegs.dx \ 256; " = month"„PRINT OutRegs.dx MOD 256; " = date"„daynum% = OutRegs.ax MOD 256„PRINT "Day of the week is "; Day$(daynum%)„Joe Negron                     MONTHLY CALENDAR               MONTHLY,CALENDAR               01/08/93 (10:53)       QB, QBasic, PDS        215  6180     MONCAL.BAS  'Al, I'm reposting this as Richard Dale informs me that the copy he„'received had been cut off.  Let me know if you receive it OK.„„DEFINT A-Z„„DECLARE SUB OneMthCal (DateX$)„„DECLARE FUNCTION Date2Day% (DateX$)„DECLARE FUNCTION Date2Mth% (DateX$)„DECLARE FUNCTION Date2Serial& (DateX$)„DECLARE FUNCTION Date2Year% (DateX$)„DECLARE FUNCTION DayOfTheWeek$ (DateX$)„DECLARE FUNCTION Serial2Date$ (Serial&)„DECLARE FUNCTION MDY2Date$ (Month%, Day%, Year%)„DECLARE FUNCTION MthName$ (DateX$)„„CLS„OneMthCal DATE$„„SYSTEM„„'**********************************************************************„'* FUNCTION Date2Day%„'*„'* PURPOSE„'*    Returns the day number given a date in the standard date format.„'**********************************************************************„„'**********************************************************************„'* FUNCTION Date2Mth%„'*„'* PURPOSE„'*    Returns the month number given a date in the standard date format.„'**********************************************************************„„'**********************************************************************„„'* FUNCTION Date2Serial&„'*„'* PURPOSE„'*    Returns the astronomical Julian day number given a date in the„'*    standard date format.  Note that the year must be 1583 or greater.„'*„'* INTERNAL ROUTINE(S)„'*    FUNCTION Date2Day% (DateX$)„'*    FUNCTION Date2Mth% (DateX$)„'*    FUNCTION Date2Year% (DateX$)„'**********************************************************************„„'**********************************************************************„'* FUNCTION Date2Year%„'*„'* PURPOSE„'*    Returns the year number given a date in the standard date format.„'**********************************************************************„„'**********************************************************************„'* FUNCTION DayOfTheWeek$„'*„'* PURPOSE„'*    Returns a string stating the day of the week given a date in the„'*    standard date format.„'*„'* INTERNAL ROUTINE(S)„'*    FUNCTION Date2Serial& (DateX$)„'**********************************************************************„„'**********************************************************************„'* FUNCTION MDY2Date$„'*„'* PURPOSE„'*    Converts Month%, Day%, and Year% to a string in the standard date„'*    format.„'**********************************************************************„„'**********************************************************************„'* FUNCTION MthName$„'*„'* PURPOSE„'*    Returns then name of the month given a string in the standard date„'*    format.„'**********************************************************************„„'**********************************************************************„'* SUB OneMthCal„'*„'* PURPOSE„'*    Prints a one-month calendar for the given date at the current„'*    screen location.„'*„'* INTERNAL ROUTINE(S)„'*    FUNCTION Date2Day% (DateX$)„'*    FUNCTION Date2Mth% (DateX$)„'*    FUNCTION Date2Serial& (DateX$)„'*    FUNCTION Date2Year% (DateX$)„'*    FUNCTION DayOfTheWeek$ (DateX$)„'*    FUNCTION MDY2Date$ (Month%, Day%, Year%)„'*    FUNCTION MthName$ (DateX$)„'*    FUNCTION Serial2Date$ (Serial&)„'**********************************************************************„„'**********************************************************************„'* FUNCTION Serial2Date$„'*„'* PURPOSE„'*    Returns a date in the standard date format given a Julian day„'*    number.„'*„'* INTERNAL ROUTINE(S)„'*    FUNCTION MDY2Date$ (Month%, Day%, Year%)„'**********************************************************************„„FUNCTION Date2Day% (DateX$) STATIC„   Date2Day% = VAL(MID$(DateX$, 4))„END FUNCTION„„FUNCTION Date2Mth% (DateX$) STATIC„   Date2Mth% = VAL(DateX$)„END FUNCTION„„FUNCTION Date2Serial& (DateX$) STATIC„   Month% = Date2Mth%(DateX$)„   Day% = Date2Day%(DateX$)„   Year% = Date2Year%(DateX$)„„   IF Month% > 2 THEN„      Month% = Month% - 3„   ELSE„      Month% = Month% + 9„      Year% = Year% - 1„   END IF„„   TA& = 146097 * (Year% \ 100) \ 4„   TB& = 1461& * (Year% MOD 100) \ 4„   TC& = (153 * Month% + 2) \ 5 + Day% + 1721119„   Date2Serial& = TA& + TB& + TC&„END FUNCTION„„FUNCTION Date2Year% (DateX$) STATIC„   Date2Year% = VAL(MID$(DateX$, 7))„END FUNCTION„„FUNCTION DayOfTheWeek$ (DateX$) STATIC„   DayOfTheWeek$ = MID$("MonTueWedThuFriSatSun", ((Date2Serial&(DateX$) MOD 7) + 1) * 3 - 2, 3)„END FUNCTION„„FUNCTION MDY2Date$ (Month%, Day%, Year%) STATIC„   MDY2Date$ = RIGHT$("0" + MID$(STR$(Month%), 2), 2) + "-" + RIGHT$("0" + MID$(STR$(Day%), 2), 2) + "-" + RIGHT$("000" + MID$(STR$(Year%), 2), 4)„END FUNCTION„„FUNCTION MthName$ (DateX$) STATIC„   MthName$ = MID$("JanFebMarAprMayJunJulAugSepOctNovDec", VAL(DateX$) * 3 - 2, 3)„END FUNCTION„„SUB OneMthCal (DateX$) STATIC„   Row% = CSRLIN„   Col% = POS(0)„„   MName$ = MthName$(DateX$)„   LOCATE Row%, Col% + 12 - LEN(MName$) \ 2„„   Year% = Date2Year%(DateX$)„   PRINT MName$; ","; Year%„„   Month% = Date2Mth%(DateX$)„   Day% = 1„   Date1$ = MDY2Date$(Month%, Day%, Year%)„   Serial& = Date2Serial&(Date1$)„   Heading$ = " Sun Mon Tue Wed Thu Fri Sat"„   WA% = INSTR(1, Heading$, LEFT$(DayOfTheWeek$(Date1$), 3)) \ 4„   LOCATE Row% + 1, Col%„   PRINT Heading$„„   RowLoc% = Row% + 2„   LOCATE RowLoc%, Col% + 4 * WA%„„   DO„      PRINT USING "####"; Day%;„„      IF WA% = 6 THEN„         RowLoc% = RowLoc% + 1„         LOCATE RowLoc%, Col%„      END IF„„      WA% = (WA% + 1) MOD 7„      Serial& = Serial& + 1„      Day% = Date2Day%(Serial2Date$(Serial&))„   LOOP UNTIL Day% = 1„END SUB„„FUNCTION Serial2Date$ (Serial&) STATIC„   X& = 4 * Serial& - 6884477„   Y& = (X& \ 146097) * 100„   D& = (X& MOD 146097) \ 4„„   X& = 4 * D& + 3„   Y& = (X& \ 1461) + Y&„   D& = (X& MOD 1461) \ 4 + 1„   X& = 5 * D& - 3„   M& = X& \ 153 + 1„   D& = (X& MOD 153) \ 5 + 1„„   IF M& < 11 THEN„      Month% = M& + 2„   ELSE„      Month% = M& - 10„   END IF„„   Day% = D&„   Year% = Y& + M& \ 11„„   DateX$ = MDY2Date$(Month%, Day%, Year%)„   Serial2Date$ = DateX$„END FUNCTION„„zabudsk@ecf.utoronto.ca        COUNT TIMER TICKS              COUNT,TIMER,TICKS              Unknown Date (00:00)   QB, QBasic, PDS        111  4829     TIMER.BAS   DEFINT H, L, X„DEFDBL F, S„CLS„INPUT "Input scanning frequency: ", scanfreq„„'Initial Calculations„TickFreq = 18.20678518#                 'Number of Ticks per second„TimerResolution = 65536 * TickFreq      'Used to change computer's tick freq.„Delay = INT(TimerResolution / scanfreq) 'Calculates the delay between„                                        'clock ticks (Quantized)„DelayL = Delay MOD 256                  'Delay - Low Byte„DelayH = INT(Delay / 256)               'Delay - High byte„actualfreq = TimerResolution / Delay    'Actual frequency the computer is„                                        'operating at„resfrac = TickFreq / actualfreq         'A resulting fraction used to easily„                                        'calculate the elapsed time„„PRINT "Press any key to start."„WHILE INKEY$ = ""„WEND„„'Set timer register to new timing rate (Timer now speeds up)„'Elapsed time 1s will now show up using "TIMER" as > 1s„OUT &H43, &H36„OUT &H40, DelayL„OUT &H40, DelayH„„'Reset time (TIMER=0)„TIME$ = "00:00:00"„PRINT "Press any key to stop."„„WHILE INKEY$ = ""„   LOCATE 4, 1„   PRINT USING "#####.####"; TIMER * resfrac„   'Calculates actual elapsed time (TIMER-InitialTime)*resfrac„WEND„„FinalTime = TIMER„'gets final time„„CLS„PRINT "Total Elapsed Time: ";„PRINT USING "#####.####"; FinalTime * resfrac„„'Reset timer register - Normal time mode„'Important! returns timing mode to normal for DOS„'Some programs will not properly execute under a different time„'speed mode.„OUT &H43, &H36„OUT &H40, 255„OUT &H40, 255„„END„„'Theory of operation:„'Port 43h is some sort of computer paremeters register„'function 36h changes the tick timer speed by accepting two bytes from data„'register 40h.„'^----This was gleaned from a (horribly complex) C++ program and prototyped„'into a QuickBasic program.„„'From experimentation, a two byte integer is entered into the computer as„'a tick speed. The low byte is entered first (bits 0 to 7, 2^0 to 2^7) and„'the high byte second (bits 8 to 15, 2^8 to 2^15). This is expressed in my„'program as Delay, with DelayL and DelayH calculated. This corresponds to„'the delay between tick counts of the processor. (As I understand,„'each tick an internal interrupt is called to update the clock. If TSRs are„'dependent on the system clock, they will also be called (the more TSRs,„'the slower the response of the computer).„„'I found that for a high number (Delay = 65535), the clock speed was identical„'to the normal clock speed. For low numbers, the clock goes faster. For really„'low values, the clock speed slows down and stops at Delay=0. It gets dampened„'by the fact that updating the clock and such takes a finite amount of time,„'and can take longer than the tick delay time. Thus you need to find the best„'scanning frequency for a particular computer. My 486DX266 can scan at a„'frequency of at least 15000 Hz, where my zenith 8086 laptop can scan up to„'maybe 1200 at best.„„'After a scanning frequency is specified, it is converted to store in the„'computers memory by the equation: Delay = 65536 * (18.206../Scan frequency)„'Only the integer portion of the delay is taken.„'Thus the computers New tick frequency does not exactly match the scan„'frequency and our new frequency is calculated by the equation:„'                 65536 * 18.20678158„'F       = -------------------------------------„' actual    int(65536 * 18.20678158 / scanrate)„'Thus F_actual is very close to the scan rate (within a few percent).„'The new tick frequency will speed up the clock at a rate porportional to„'the tick frequency. with 18.2..Hz being the normal frequency,„'the clock gets speeded up (F_actual/18.2..) times.„'Thus our final actual time = TIMER / (F_actual/18.2...)„'                           = TIMER * (18.2.../F_actual)„'In our program, the scanning frequency is constant so we can set a constant„'to multiply the timer by to get the elapsed time in seconds (resfrac) in our„'case.„„'Well, good luck implementing this program, I had no trouble fitting this„'code into an existing program (Race car timer). I just had to include the„'setup code at the beginning of the program and multiply all times by„'resfrac to get the elapsed time, worked like a charm.„„'Sorry, I lost the original C program that had the wonderful TSR code to„'continuously set the tick timer to go faster. I do not know who to„'attribute for first supplying the addresses for the timer registers.„'I didn't bother to fix the Midnight rollover problem or the resetted time„'problems (no doubt easy enough to fix).„'Any comments, questions, fixes, etc. direct to comp.lang.basic.misc or„'alt.lang.basic or Email to: zabudsk@ecf.utoronto.ca„'Code can be freely distributed anywhere.„„Steve Halko                    SLEEP REPLACEMENT              SLEEP,REPLACEMENT              06-30-92 (00:00)       QB, QBasic, PDS        37   1142     NEWSLEEP.BAS  'NEWSLEEP.BAS by Steve Halko, 6-30-92„„  DEFINT A-Z„  DECLARE FUNCTION ReadTimer& ()„  DECLARE SUB NewSleep (Ticks)„„  CALL NewSleep(18)       'Delay for 1 second or until key pressed„  CALL NewSleep(0)        'Delay until key pressed„„  SUB NewSleep (Ticks)„  'This function is a replacement for SLEEP.  It takes the number„  'of system clock ticks as an argument, which gives you much„  'finer control than QB's SLEEP.  To emulate SLEEP with no arguments,„  'use NewSleep(0).  Unlike SLEEP, key presses are cleared from the„  'keyboard buffer.„„    StopTime& = ReadTimer& + Ticks„    DO UNTIL ((ReadTimer& > StopTime&) AND Ticks) OR LEN(INKEY$)„    LOOP„„  END SUB„„  FUNCTION ReadTimer& STATIC„„    „'[]=============================================================[]„'[]   Returns the number of clock ticks since midnight„'[]   without invoking FP emulator like TIMER does„'[]=============================================================[]„„     DEF SEG = &H40„     Lo& = PEEK(&H6C) + 256& * PEEK(&H6D)„     Hi& = PEEK(&H6E) + 256& * PEEK(&H6F)„„     ReadTimer& = (65536 * Hi&) + Lo&„„  END FUNCTION„Unknown Author(s)              TIME ZONES WORLDWIDE           TIME,ZONES,WORLDWIDE           Unknown Date (00:00)   QB, QBasic, PDS        72   3785     TIMEZONE.BAS100 REM CONVERTING LOCAL TIME TO TIME ZONES WORLDWIDE„105 WIDTH 80„110 GOTO 160: REM IBM BASIC„120 PRINT STRING$(80, 45): RETURN„130 CLS : FOR X = 1 TO 10: PRINT : NEXT X: RETURN„140 PRINT : INPUT "PRESS >RETURN< (Q TO QUIT) ", R$: IF R$ = "Q" THEN 150 ELSE RETURN„150 GOSUB 130: GOSUB 120: PRINT TAB(38); "END.": GOSUB 120: END„160 TT$ = "THE TIME IN THE COUNTRY YOU ASKED FOR IS ": GOSUB 130: GOSUB 120„170 GMT$ = "GREENWICH MEAN TIME IS ": ST$ = " STANDARD TIME"„180 PRINT TAB(5); "THIS PROGRAM CONVERTS LOCAL TIME TO TIME ANYWHERE IN THE WORLD"„190 GOSUB 120: GOSUB 140: GOSUB 130„200 PRINT "DO YOU WANT TO CONVERT FROM LOCAL ": PRINT„210 PRINT 1, "STANDARD TIME": PRINT 2, "DAYLIGHT TIME": GOSUB 120„220 INPUT "WHICH?  ", WHICH: GOSUB 130: PRINT "DO YOU WANT TO CONVERT FROM": PRINT„230 PRINT 1, "EASTERN TIME": PRINT 2, "CENTRAL TIME": PRINT 3, "MOUNTIAN TIME"„240 PRINT 4, "PACIFIC TIME": PRINT 5, "YUKON TIME": PRINT 6, "ALASKA/HAWAII TIME"„250 PRINT 7, "BERING TIME": GOSUB 120: INPUT "WHICH?  ", TIME: GOSUB 130: GOTO 370„260 GOSUB 120: IF CTRY = 9 THEN 280 ELSE 270„270 PRINT T$; TIME1; ":"; MINUTE$; " "; M$; ST$: GOTO 290„280 MIN = MINUTE + 30: IF MIN > 59 THEN MIN = MIN - 60„285 MIN$ = STR$(MIN): PRINT T$; TIME1; ":"; MIN$; " "; M$; ST$„290 GOSUB 120: GOSUB 310„300 PRINT GMT$; TIME2; ":"; MINUTE$; " "; M$: GOSUB 120: GOSUB 140: GOSUB 560„310 TIME2 = HOUR + (TIME + 4): IF TIME2 > 12 THEN M$ = "PM" ELSE M$ = "AM"„320 IF TIME2 > 24 THEN M$ = "AM"„330 IF TIME2 > 24 THEN TIME2 = TIME2 - 24„340 IF TIME2 > 12 THEN TIME2 = TIME2 - 12„350 IF TIME2 < 1 THEN TIME2 = TIME2 + 12„360 RETURN„370 PRINT "COUNTRIES (ALPHABETICALLY):": GOSUB 120„380 PRINT 1, "ARGENTINA": PRINT 2, "BRAZIL": PRINT 3, "CHINA": PRINT 4, "ENGLAND": PRINT 5, "EGYPT"„390 PRINT 6, "FRANCE": PRINT 7, "GERMANY": PRINT 8, "GREECE": PRINT 9, "INDIA": PRINT 10, "IRELAND"„400 PRINT 11, "ISREAL": PRINT 12, "ITALY": PRINT 13, "JAPAN": PRINT 14, "KENYA"„410 PRINT 15, "PHILIPPINES": PRINT 16, "PORTUGAL": PRINT 17, "RUSSIA (MOSCOW AREA)"„420 PRINT 18, "SOUTH AFRICA": PRINT 19, "SPAIN": PRINT 20, "TURKEY": GOSUB 120„430 INPUT "WHICH?  ", CTRY: GOSUB 130: GOSUB 580: T$ = TT$: GOSUB 260„440 TIME1 = TIME2 + GMT - TT: TIME2 = TIME1 - GMT + TT„450 IF TIME1 > 12 THEN M$ = "PM"„460 IF TIME1 < 12 THEN M$ = "AM"„470 IF TIME1 = 12 THEN 480 ELSE 490„480 IF MINUTE = 0 THEN M$ = "NOON" ELSE M$ = "PM"„490 IF TIME1 = 24 THEN 500 ELSE 510„500 IF MINUTE = 0 THEN M$ = "MIDNIGHT" ELSE M$ = "AM"„510 IF TIME1 > 24 THEN M$ = "AM"„520 IF TIME1 > 24 THEN TIME1 = TIME1 - 24„530 IF TIME1 > 12 THEN TIME1 = TIME1 - 12„540 IF TIME1 < 1 THEN TIME1 = TIME1 + 12„550 RETURN„560 GOSUB 130: INPUT "ANOTHER TIME CONVERSION?(Y/N)  ", TC$„570 IF TC$ <> "N" THEN GOSUB 130: GOTO 200 ELSE 150„580 TT = TIME + 4: IF WHICH = 2 THEN TT = TT + 1„590 INPUT "LOCAL TIME? (HOUR ONLY, NO MINUTES)     ", HOUR„600 INPUT "LOCAL TIME? (MINUTES)                   ", MINUTE„602 IF MINUTE = 0 THEN MINUTE$ = "00": GOTO 610„604 MINUTE$ = STR$(MINUTE)„606 IF LEFT$(MINUTE$, 1) = " " AND LEN(MINUTE$) = 2 THEN MINUTE$ = "0" + MID$(MINUTE$, 2, 1)„610 INPUT "AM (A) OR PM (P)?                       ", AM$„620 IF AM$ = "P" THEN HOUR = HOUR + 12„630 TIME2 = HOUR + TT„640 IF CTRY = 4 OR CTRY = 10 OR CTRY = 16 THEN GMT = TT„650 IF CTRY = 6 OR CTRY = 7 OR CTRY = 12 OR CTRY = 19 OR CTRY = 8 THEN GMT = TT + 1„660 IF CTRY = 20 OR CTRY = 11 OR CTRY = 18 OR CTRY = 5 THEN GMT = TT + 2„670 IF CTRY = 14 OR CTRY = 17 THEN GMT = TT + 3„680 IF CTRY = 1 OR CTRY = 2 THEN GMT = TT - 3„690 IF CTRY = 9 THEN GMT = TT + 5„700 IF MIN > 59 THEN MIN = MIN - 60 AND GMT = GMT + 1„710 IF CTRY = 15 THEN GMT = TT + 10„720 IF CTRY = 3 THEN GMT = TT + 8„730 IF CTRY = 13 THEN GMT = TT + 9„740 GOTO 440„„„Garry Spencer                  CALCULATES DAY OF THE WEEK     gspencer@stim.tec.tn.us        Unknown Date           QB, QBasic, PDS        87   2349     WEEKDAY.BAS 'WEEKDAY.BAS - Function to calculate the day of the week when given the„'              date in integer form: Mon%, Day%, Year% (year: 1582 to 2450)„'              Note: Returns (0=Sunday...6=Saturday)  or -1 if an error occurs„'              Written by: Garry Spencer (gspencer@stim.tec.tn.us)„„'To compile & link (stand-alone OBJ):       BC WEEKDAY;„ „'To add the WEEKDAY function to a library:  LIB libname +WEEKDAY;„ „'To compile a user program:                 BC progname/O;„'and add the WEEKDAY function to it:        LINK/EX progname WEEKDAY;„ „'To Use:„DECLARE FUNCTION WEEKDAY% (Mon%, Day%, Year%)   'do not use BYVAL„'Example:„CLS„PRINT : LOCATE 12, 12„INPUT ; "Enter date (mm,dd,yyyy): ", Mon%, Day%, Year%„DWeek% = WEEKDAY%(Mon%, Day%, Year%)„PRINT " is a ";„„SELECT CASE DWeek%„    CASE 0„        PRINT "Sunday."„    CASE 1„        PRINT "Monday."„    CASE 2„        PRINT "Tuesday."„    CASE 3„        PRINT "Wednesday."„    CASE 4„        PRINT "Thursday."„    CASE 5„        PRINT "Friday."„    CASE 6„        PRINT "Saturday."„    CASE ELSE„        PRINT "Error"„    END SELECT„„FUNCTION WEEKDAY% (Mon%, Day%, Year%)„DTmp% = 4: Days% = 0: Ofs% = 0: Leap% = 0: WEEKDAY% = -1„IF Year% < 1582 OR Year% > 2450 OR Mon% < 1 OR Mon% > 12 OR Day% < 1 THEN EXIT FUNCTION„FOR YTmp% = 1582 TO Year%„    DTmp% = (DTmp% + 1 + Leap%) MOD 7„        SELECT CASE 0„            CASE (YTmp% MOD 400)„                Leap% = 1„            CASE (YTmp% MOD 100)„                Leap% = 0„            CASE (YTmp% MOD 4)„                Leap% = 1„            CASE ELSE„                Leap% = 0„        END SELECT„NEXT YTmp%„FOR MTmp% = 1 TO Mon%: Ofs% = Ofs% + Days%„    SELECT CASE MTmp%„        CASE 1„            Days% = 31:„        CASE 2„            Days% = 28 + Leap%:„        CASE 3„            Days% = 31„        CASE 4„            Days% = 30:„        CASE 5„            Days% = 31:„        CASE 6„            Days% = 30„        CASE 7„            Days% = 31:„        CASE 8„            Days% = 31:„        CASE 9„            Days% = 30„        CASE 10„            Days% = 31„        CASE 11„            Days% = 30:„        CASE 12„            Days% = 31„    END SELECT„NEXT MTmp%„IF Day% <= Days% THEN WEEKDAY% = (DTmp% + Ofs% + Day% - 1) MOD 7„END FUNCTION„„Chris Tracy                    HOW MANY DAYS                  FidoNet QUIK_BAS Echo          Year of 1993           QB, QBasic, PDS        85   2350     DAYS.BAS    DECLARE SUB Days (M1, D1, Y1, M2, D2, Y2, N)„ „Days 1, 1, 85, 1, 3, 93, Number„PRINT "The number of days between 1/1/85 and 1/1/93 is:"; Number„ „SUB Days (M1, D1, Y1, M2, D2, Y2, N)„' How Many Days v1.0 - By Chris Tracy„' Credit goes to the person who originally wrote this routine in GWBASIC...„' This routine can be used to find the number of days between ANY date.„' It accounts for leap years, leap centuries, etc.„ „' M1/D1/Y1 - The First Date (Ie. 1/1/85)„' M2/D2/Y2 - The Last Date (Ie. 1/3/93)„' N        - The Value Returned.„ „' See the main module of an example of how to use this routine.„CheckVariables:„        IF M1 > 12 THEN GOTO EndTheSub:„        IF D1 > 31 THEN GOTO EndTheSub:„MainBody:„        Y = Y1„        M = M1„        D = D1„        GOSUB FindDays:„        N = A„        Y = Y2„        D = D2„        M = M2„        GOSUB FindDays:„        N = A - N„        GOTO EndTheSub:„FindDays:„        ON M GOTO Check1, Check2, Check1, Check3, Check1, Check3, Check1, Check1, Check3, Check1, Check3, Check1„        RETURN„Check1:„        IF D > 31 THEN GOTO FindDays:„        GOTO DetermineDays:„Check2:„        IF Y / 4 <> INT(Y / 4) THEN GOTO Check4:„        IF Y / 400 = INT(Y / 400) THEN GOTO Check5:„        IF Y / 100 <> INT(Y / 100) THEN GOTO Check5:„Check4:„        IF D > 28 THEN GOTO Returner:„Check5:„        IF D > 29 THEN GOTO Returner:„        GOTO DetermineDays:„Check3:„        IF D > 30 THEN GOTO Returner:„DetermineDays:„    SELECT CASE M„        CASE 1„                A = 0„        CASE 2„                A = 31„        CASE 3„                A = 59„        CASE 4„                A = 90„        CASE 5„                A = 120„        CASE 6„                A = 151„        CASE 7„                A = 181„        CASE 8„                A = 212„        CASE 9„                A = 243„        CASE 10„                A = 273„        CASE 11„                A = 304„        CASE 12„                A = 334„    END SELECT„    A = A + Y * 365 + INT(Y / 4) + D + 1 - INT(Y / 100) + INT(Y / 400)„    IF INT(Y / 4) <> Y / 4 THEN GOTO Returner:„    IF Y / 400 = INT(Y / 400) THEN GOTO Returner:„    IF Y / 100 = INT(Y / 100) THEN GOTO Returner:„    IF M > 2 THEN GOTO Returner:„    A = A - 1„Returner:„    RETURN„EndTheSub:„    END SUB„Zachary Becker                 UNIVERSAL TIME ZONE FINDER     Night Owl v10 CD-ROM           Year of 1993           QB, QBasic, PDS        62   2282     UTZ.BAS     'This program will determine the current coordinated universal time (UTC)„'in any one of the 5 time zones in the United States, plus the Atlantic„'time zone. This program will adjust for daylight savings time.„„„DECLARE SUB pause ()„0 CLS„10 PRINT "      Coordinated Universal Time Finder for the United States"„15 PRINT ""„20 PRINT "              U      U    TTTTTTTT   ZZZZZZZZZ    "„30 PRINT "              U      U       TT           ZZ"„40 PRINT "              U      U       TT         ZZ"„50 PRINT "               U    U        TT       ZZ"„60 PRINT "                UUUU         TT      ZZZZZZZZZ"„70 PRINT ""„100 PRINT "Copyright 1993 by Zachary Becker. All Rights Reserved. "„105 PRINT " Version 1.0 Use this program at your OWN RISK. No warranties"„106 PRINT "either expressed or implied are given and the author is not liable"„107 PRINT "for any damage to any property or person resulting from use of "„108 PRINT "this program. THIS VERSION (1.0) may be distributed freely, as shareware"„109 PRINT "in its ENTIRE and ORIGINAL form ONLY. DO NOT TAMPER."„pause„110 CLS„120 PRINT "Do you wish to continue? (Y/N)"„130 INPUT b$„140 IF b$ = "N" OR b$ = "n" THEN GOTO 155„150 IF b$ = "Y" OR b$ = "y" THEN GOTO 160„155 PRINT "Have a nice day!"; CHR$(1)„157 END„160 CLS„170 PRINT "What is the local time right now? (Please type as a 24 hour numeral.)"„180 INPUT c„190 CLS„200 PRINT "What time zone are you in now?"„210 PRINT " H-Hawaii or Alaska"„220 PRINT " P-Pacific"„230 PRINT " M-Mountain"„240 PRINT " C-Central"„250 PRINT " E-Eastern"„260 PRINT " A-Atlantic"„270 INPUT d$„280 IF d$ = "H" OR d$ = "h" THEN LET e = c + 1000„290 IF d$ = "P" OR d$ = "p" THEN LET e = c + 800„300 IF d$ = "M" OR d$ = "m" THEN LET e = c + 700„310 IF d$ = "C" OR d$ = "c" THEN LET e = c + 600„320 IF d$ = "E" OR d$ = "e" THEN LET e = c + 500„330 IF d$ = "A" OR d$ = "a" THEN LET e = c + 400„340 CLS„350 PRINT "Are you on daylight savings time now? (Y/N) "„360 INPUT f$„370 IF f$ = "N" OR f$ = "n" THEN LET e = e„380 IF f$ = "Y" OR f$ = "y" THEN LET e = e - 100„390 CLS„400 IF e > 2400 THEN LET e = e - 2400„440 PRINT "The correct coordinated universal time is "; e; " hours."„450 GOTO 120„„SUB pause„FOR a = 1 TO 200000„NEXT a„END SUB„„Peter Norton                   VISUAL CLOCK DISPLAY           Advanced BASIC Book            Unknown Date           QB, QBasic, PDS        15   566      CLOCK.BAS           SCREEN 8„        DRAW "BU50 NL25 F12 D20 G12 L50 H12 U20 E12 R25 BD22"„        DO„        TimeMark! = TIMER„        Hours! = INT(TimeMark! / 3600)„        Remainder! = TimeMark! - 3600 * Hours!„        IF Hours! > 12 THEN Hours! = Hours! - 12„        HourAngle! = -Hours! / 12 * 360„        Minutes! = INT(Remainder! / 60)„        MinuteAngle! = -Minutes! / 60 * 360„        DRAW "TA=" + VARPTR$(HourAngle!) + " NU8"„        DRAW "TA=" + VARPTR$(MinuteAngle!) + " NU12"„        LOCATE 15, 34: PRINT TIME$„        LOOP UNTIL INKEY$ = CHR$(27)„„Matt Pritchard                 TIMER FUNCTIONS                FidoNet QUIK_BAS Echo          09-30-92 (09:42)       QB, QBasic, PDS        39   1091     TIMERS.BAS  '>Start! = TIMER   'Start! had to be a single so it can handle the ma„'> 'amount that timer returns (86400) and so it can save„'>                 ' the decimal place.„„„'>> Do the peeks directly and use an INTEGER or LONG.... It'll be a whole„'>> lot faster than involving floating point...„„'>How can I do that?  I got SMALLEXE.BAS from the QB news and it had a„'>TIMER  replacement, but after midnight, it wouldn't reset to 0!„'> And it hardley ever  returned the same thing as TIMER (it„'>started out at 4 million whenever I ran  the program!)!„„You can do this:„„        DEF SEG = 0„        TimerLo% = PEEK (&h046C)„„        (or)„„        TimerFull& = PEEK (&h046C) + 256& * PEEK(&h046D)„„        or in assembly ...„„;TIMERCOUNT - QuickBASIC 4.5 File Timer Value Returned: ;DECLARE„FUNCTION TIMERCOUNT% ;Count = TIMERCOUNT% ;„„        PUBLIC  TIMERCOUNT„„TIMERCOUNT      PROC    FAR„„        XOR     AX,AX               ;Segment = 0000„        MOV     ES,AX„        MOV     AX,ES:[046Ch]       ;Get Timer Word..„„        RET„„TIMERCOUNT      ENDP„„