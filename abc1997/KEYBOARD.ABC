Charlie Quante                 A FILTERED INKEY$ ROUTINE      charlie@charlie.seanet.com     11-05-96               QB, QBasic, PDS        66   2503     TESTKEY.BAS 'FULL Header Extraction for this Source Code has been Enabledã' A sample program to demonstrate the TestKey subroutine.ããDECLARE SUB TestKey (KeyFlag%, CaseFlag%, KeysAccepted$)ãã    CLSã    DEFINT A-Zã'----------------------------------------------------------------------------ã'   Prompt the user for a number from 1 to 4.ã'   call TestKey - CaseFlag is unimportant for this example.ã'   Print the number of the item selected.ãã    PRINT "Select a number from 1 to 4: "ã    TestKey KeyFlag, -1, "1234"ã    PRINT "You selected item"; KeyFlagã'----------------------------------------------------------------------------  ãã'   Prompt the user for a letter from A to Zã'   Call TestKey - Note: Notice that you can have a combination of upper andã'                        lowercase letters.ã'   In this example CaseFlag is set to -1 and any key pressed is convertedã'   into uppercase. The same applies to the KeysAccepted$ string.ã'   Convert the number returned by KeyFlag back into a letter.ãã    PRINTã    PRINT "Select a letter from A to Z: "ã    TestKey KeyFlag, -1, "ABCDEfghijklmnopqrstuvwxyz"ã    PRINT "You selected letter "; CHR$(34); CHR$(KeyFlag + 64); CHR$(34)ã'----------------------------------------------------------------------------ã  ã'   Now CaseFlag is set to 0, and the user must enter either an uppercaseã'   A through E, or a lowercase f through zãã    PRINTã    PRINT "Okay, select another letter from A to Z: "ã    TestKey KeyFlag, 0, "ABCDEfghijklmnopqrstuvwxyz"ã    PRINT "You selected letter "; CHR$(34); CHR$(KeyFlag + 64); CHR$(34)ããSUB TestKey (KeyFlag, CaseFlag, KeysAccepted$)ã'Purpose: ã'           Get input from the user, and test it to see if it is one ofã'           the keys that are acceptable.ã'Variables:ã'           CaseFlag      - If CaseFlag is -1 then all input, is convertedã'                           to uppercase.ã'           KeyFlag       - Returns a number indicating which acceptable keyã'                           was pressed.ã'           KeysAccepted$ - Holds the acceptable keys.ã'           GetKey$ - Gets the key pressed via the INKEY$ command. ããã    KeyFlag = 0ã    IF CaseFlag THEN KeysAccepted$ = UCASE$(KeysAccepted$)ãã    DO WHILE KeyFlag = 0ã        GetKey$ = ""ã       ã        DO WHILE GetKey$ = ""ã            GetKey$ = INKEY$ã        LOOPã       ã        IF CaseFlag THEN GetKey$ = UCASE$(GetKey$)ã        KeyFlag = INSTR(KeysAccepted$, GetKey$)ã    LOOPãEND SUBããChris McKenzie                 CHECK ASCII CHARACTER CODE     unknown@sprynet.com            12-29-96 (14:06)       QB, QBasic, PDS        34   1067     CHKASC.BAS  'ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄã' This is a seemingly useless program, run it to find out what it is.ã'ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄããCLSãFOR WaitFiveSeconds% = 5 TO 1 STEP -1ã  LOCATE 1, 1: PRINT "Press key and HOLD.  You have"; WaitFiveSeconds%;"seconds to choose key."ã  SLEEP 1ãNEXT WaitFiveSeconds%ãCLSããFOR KeyBeingChecked = 1 TO 255ã  Button$ = INKEY$ã  SLEEP 1ã  IF Button$ = CHR$(KeyBeingChecked) THEN GOTO ItHasBeenFoundã  LOCATE 1, 1: PRINT "Checking code"; KeyBeingCheckedã  PercentDone = (KeyBeingChecked / 255) * 100 MOD 100ã  LOCATE 2.1: PRINT PercentDone; "% done."ãNEXT KeyBeingCheckedããNotFound:             ã  CLSã  PRINT "I'm sorry but the Ascii character code was not found."ã  GOTO FinalããItHasBeenFound:ã  CLSã  PRINT "The key has been found!  It is Ascii character"; KeyBeingChecked;ã  GOTO FinalããFinal:ã  PRINT "Press [Esc] to quit."ãNotPressingAButton: Button$ = INKEY$: IF Button$ <> CHR$(27) THEN GOTO NotPressingAButtonãENDãNick Kochakian                 KEY GENERATOR                  NickK@worldnet.att.net         02-12-97 (15:23)       QB, QBasic, PDS        314  3850     KEYGETR.BAS '----------------------------------------------------------------------------ã'Fast key getterã'ã'1/20/97ã'1997 By: - Nick Kochakian -ã'ã'Use this to get keys for a game, etc.ã'ã'If you have any comments or questions please e-mail me at:ã'ã'nickK@worldnet.att.netã'ã'Have fun! :)ã'----------------------------------------------------------------------------ãã'To exit just press: ESC -> ( CHR$(27) )ãã'How to use the information with your program:ã'Say the computer returns something like this:ã'CHR$( 0 ) + ;ã'What you'd need to enter into your program to make it work would be:ã'IF A$=CHR$(0)+; THEN  ,etc...ããCLSããA = 255ãDIM A$(A)ãFOR A = 1 TO 255ãREAD A$(A)ãNEXT AããA = 1ããPRINT "Press any key... Press ESC to exit..."ãDOããDOãA$(A) = INKEY$ãLOOP UNTIL A$(A) <> ""ãPRINT "CHR$(";ãPRINT ASC(A$(A));ãPRINT ") + "; A$(A)ã'A$(A) = INEKY$ãLOOP UNTIL A$(A) = CHR$(27)ããã'Up: IF a$(a) = CHR$(0) + "H" THEN BEEPã'Down: IF a$(a) = CHR$(0) + "P" THEN BEEPã'CHR$(0)+"K"  <- Leftã'CHR$(0)+"M"  <- Rightã'CHR$(0)+";"  <- F1ã'all chr$(0)+""""" from hereã'< <- F2ã'= <- F3ã'> <- F4ã'? <- F5ã'@ <- F6ããENDãDATA  1ãDATA  2ãDATA  3ãDATA  4ãDATA  5ãDATA  6ãDATA  7ãDATA  8ãDATA  9ãDATA  10ãDATA  11ãDATA  12ãDATA  13ãDATA  14ãDATA  15ãDATA  16ãDATA  17ãDATA  18ãDATA  19ãDATA  20ãDATA  21ãDATA  22ãDATA  23ãDATA  24ãDATA  25ãDATA  26ãDATA  27ãDATA  28ãDATA  29ãDATA  30ãDATA  31ãDATA  32ãDATA  33ãDATA  34ãDATA  35ãDATA  36ãDATA  37ãDATA  38ãDATA  39ãDATA  40ãDATA  41ãDATA  42ãDATA  43ãDATA  44ãDATA  45ãDATA  46ãDATA  47ãDATA  48ãDATA  49ãDATA  50ãDATA  51ãDATA  52ãDATA  53ãDATA  54ãDATA  55ãDATA  56ãDATA  57ãDATA  58ãDATA  59ãDATA  60ãDATA  61ãDATA  62ãDATA  63ãDATA  64ãDATA  65ãDATA  66ãDATA  67ãDATA  68ãDATA  69ãDATA  70ãDATA  71ãDATA  72ãDATA  73ãDATA  74ãDATA  75ãDATA  76ãDATA  77ãDATA  78ãDATA  79ãDATA  80ãDATA  81ãDATA  82ãDATA  83ãDATA  84ãDATA  85ãDATA  86ãDATA  87ãDATA  88ãDATA  89ãDATA  90ãDATA  91ãDATA  92ãDATA  93ãDATA  94ãDATA  95ãDATA  96ãDATA  97ãDATA  98ãDATA  99ãDATA  100ãDATA  101ãDATA  102ãDATA  103ãDATA  104ãDATA  105ãDATA  106ãDATA  107ãDATA  108ãDATA  109ãDATA  110ãDATA  111ãDATA  112ãDATA  113ãDATA  114ãDATA  115ãDATA  116ãDATA  117ãDATA  118ãDATA  119ãDATA  120ãDATA  121ãDATA  122ãDATA  123ãDATA  124ãDATA  125ãDATA  126ãDATA  127ãDATA  128ãDATA  129ãDATA  130ãDATA  131ãDATA  132ãDATA  133ãDATA  134ãDATA  135ãDATA  136ãDATA  137ãDATA  138ãDATA  139ãDATA  140ãDATA  141ãDATA  142ãDATA  143ãDATA  144ãDATA  145ãDATA  146ãDATA  147ãDATA  148ãDATA  149ãDATA  150ãDATA  151ãDATA  152ãDATA  153ãDATA  154ãDATA  155ãDATA  156ãDATA  157ãDATA  158ãDATA  159ãDATA  160ãDATA  161ãDATA  162ãDATA  163ãDATA  164ãDATA  165ãDATA  166ãDATA  167ãDATA  168ãDATA  169ãDATA  170ãDATA  171ãDATA  172ãDATA  173ãDATA  174ãDATA  175ãDATA  176ãDATA  177ãDATA  178ãDATA  179ãDATA  180ãDATA  181ãDATA  182ãDATA  183ãDATA  184ãDATA  185ãDATA  186ãDATA  187ãDATA  188ãDATA  189ãDATA  190ãDATA  191ãDATA  192ãDATA  193ãDATA  194ãDATA  195ãDATA  196ãDATA  197ãDATA  198ãDATA  199ãDATA  200ãDATA  201ãDATA  202ãDATA  203ãDATA  204ãDATA  205ãDATA  206ãDATA  207ãDATA  208ãDATA  209ãDATA  210ãDATA  211ãDATA  212ãDATA  213ãDATA  214ãDATA  215ãDATA  216ãDATA  217ãDATA  218ãDATA  219ãDATA  220ãDATA  221ãDATA  222ãDATA  223ãDATA  224ãDATA  225ãDATA  226ãDATA  227ãDATA  228ãDATA  229ãDATA  230ãDATA  231ãDATA  232ãDATA  233ãDATA  234ãDATA  235ãDATA  236ãDATA  237ãDATA  238ãDATA  239ãDATA  240ãDATA  241ãDATA  242ãDATA  243ãDATA  244ãDATA  245ãDATA  246ãDATA  247ãDATA  248ãDATA  249ãDATA  250ãDATA  251ãDATA  252ãDATA  253ãDATA  254ãDATA  255ãJoe Huber, Jr.                 MULTIPLE KEYS                  huberjjr@nicom.com             03-08-97 (13:07)       QB, QBasic, PDS        97   3058     MULTIKEY.BASDECLARE FUNCTION MULTIKEY (KEYNUM)ãã'MUTIKEY FUNCTION - LETS YOU TRAP SEVERAL KEYS AT ONCE (BETTER THAN INKEY$!!)ã'ã'USAGE:ã'  riable=MULTIKEY(KEYNUM)ã'WHERE KEYNUM IS THE KEY YOU WANT TO TRAPã'  riable = 1 IF KEY IS DEPRESSED, 0 IF IT ISN'Tã'ã'EMAIL ME AT: huberjjr@nicom.comã'ã'HAVE FUN!!!ãããDIM SHARED KEYS(255), SC(255), DU(255)  'ALWAYS NEED THIS!!!ããCLSããX = 10: Y = 10ãXX = X: YY = YããDOãã'FOR I = 1 TO 255                    '\ã' TEST = MULTIKEY(I)                 ' |-TEST LOOPã' LOCATE 1, 1: PRINT TEST; I         ' |ã' WHILE INKEY$ = "": WEND            ' | PRESS KEY IN QUESTION UNTILã'  IF TEST = 1 THEN END              ' | LOOP ENDS. THE SECOND NUMBER IS THEã'NEXT I                              '/  SCAN CODE FOR MULTIKEYããRIGHT = MULTIKEY(75)    ' GET SOME KEYS' STATUSESãLEFT = MULTIKEY(77)ãUP = MULTIKEY(72)ãDOWN = MULTIKEY(80)ãSPACE = MULTIKEY(57)ãESC = MULTIKEY(1)ããIF ESC = 1 THEN END    'TEMINATE WHEN ESCAPE IS PRESSEDããIF TIMELOOP = 100 THEN             'THIS MOVES YOU AROUNDã IF RIGHT = 1 THEN X = X - 1ã IF LEFT = 1 THEN X = X + 1        'THE TIMELOOP   RIABLE DELAYSã IF UP = 1 THEN Y = Y - 1          'MOVEMENT WITHOUT SLOWING DOWNã IF DOWN = 1 THEN Y = Y + 1        'INPUT (WITHOUT IT YOU WOULD GOã TIMELOOP = 0                      'WAAAAYYY TOO FAST)ãEND IFããIF X >= 80 THEN X = 80        'KEEPS YOU FROM GOING OFF THE SCREEN ANDãIF X <= 0 THEN X = 1          'MAKING AN ERRORãIF Y >= 23 THEN Y = 23ãIF Y <= 0 THEN Y = 1ãããIF SPACE = 1 THEN                    'CHANGES YOUTR SHAPE WHENã LOCATE Y, X: PRINT CHR$(94)         'YOU HIT SPACEãELSEã LOCATE Y, X: PRINT CHR$(127)ãEND IFããIF XX <> X OR YY <> Y THEN           'UPDATES YOUR POSITIONã LOCATE YY, XX: PRINT " "ã LOCATE Y, X: PRINT CHR$(127)ãEND IFãããXX = X: YY = Y                     'TELLS ME WHERE I WAS LASTããTIMELOOP = TIMELOOP + 1ããLOOP                 'LOOP (DUH...) :)ãã'THANX TO Eric Carr FOR FIGURING OUT HOW TO TRAP SEVERAL KEYS AT ONCEã'EVERYTHING ELSE WRITTEN BY ME,              ããFUNCTION MULTIKEY (KEYNUM)ãã STATIC FIRSTIMEãã IF FIRSTIME = 0 THENã  FOR E = 0 TO 127              '\ã  SC(E) = E: DU(E) = 1          '|ã  NEXT                          '|-ERIC CARR'S CODE--------------------\ã  FOR E = 128 TO 255            '|                                     |ã  SC(E) = E - 128: DU(E) = 0    '|                                     |ã  NEXT                          '/                                     |ã  FIRSTIME = -1                 '                                      |ã END IF                         '                                      |ã                                '                                      |ã I$ = INKEY$       ' So the keyb buffer don't get full     \routine/ \ |ã I = INP(&H60)     ' Get keyboard scan code from port 60h   \lines/  |-/ã OUT &H61, INP(&H61) OR &H82: OUT &H20, &H20       '         \!!!/   |ã KEYS(SC(I)) = DU(I) ' This says what keys are pressed        \!/    /ããMULTIKEY = KEYS(KEYNUM)ãããEND FUNCTIONãJoe Huber, Jr.                 MULTIKEY FUNCTION UPDATE       huberjjr@nicom.com             05-13-97 (14:46)       QB, QBasic, PDS        127  3287     MULTIKEY.BASDECLARE SUB KEYTEST (LOWERLIMIT!, UPPERLIMIT!)ãDECLARE FUNCTION MULTIKEY (KEYNUM)ãã'MUTIKEY FUNCTION - LETS YOU TRAP SEVERAL KEYS AT ONCE (BETTER THAN INKEY$!!)ã'ã'USAGE:ã'  riable=MULTIKEY(KEYNUM)ã'WHERE KEYNUM IS THE KEY YOU WANT TO TRAPã'  riable = 1 IF KEY IS DEPRESSED, 0 IF IT ISN'Tã'ã'CALL KEYTEST(lower,upper)ã'Use this to find new keycodesã'(unrem below to test)ãã' CALL KEYTEST(1, 200)ãã'Gives all keynums between 1 & 200ã'If the 0 by the number becomes a 1, then the key with that keycode isã'currently being depressedãã'EMAIL ME AT: huberjjr@nicom.comã'ã'HAVE FUN!!!ãã'ããããCLSããX = 10: Y = 10ãXX = X: YY = YããDOããRIGHT = MULTIKEY(75)    ' GET SOME KEYS' STATUSESãLEFT = MULTIKEY(77)ãUP = MULTIKEY(72)ãDOWN = MULTIKEY(80)ãSPACE = MULTIKEY(57)ãESC = MULTIKEY(1)ããIF ESC = 1 THEN END    'TEMINATE WHEN ESCAPE IS PRESSEDããIF TIMELOOP = 100 THEN             'THIS MOVES YOU AROUNDã IF RIGHT = 1 THEN X = X - 1ã IF LEFT = 1 THEN X = X + 1        'THE TIMELOOP   RIABLE DELAYSã IF UP = 1 THEN Y = Y - 1          'MOVEMENT WITHOUT SLOWING DOWNã IF DOWN = 1 THEN Y = Y + 1        'INPUT (WITHOUT IT YOU WOULD GOã TIMELOOP = 0                      'WAAAAYYY TOO FAST)ãEND IFããIF X >= 80 THEN X = 80        'KEEPS YOU FROM GOING OFF THE SCREEN ANDãIF X <= 0 THEN X = 1          'MAKING AN ERRORãIF Y >= 23 THEN Y = 23ãIF Y <= 0 THEN Y = 1ãããIF SPACE = 1 THEN                    'CHANGES YOUTR SHAPE WHENã LOCATE Y, X: PRINT CHR$(94)         'YOU HIT SPACEãELSEã LOCATE Y, X: PRINT CHR$(127)ãEND IFããIF XX <> X OR YY <> Y THEN           'UPDATES YOUR POSITIONã LOCATE YY, XX: PRINT " "ã LOCATE Y, X: PRINT CHR$(127)ãEND IFãããXX = X: YY = Y                     'TELLS ME WHERE I WAS LASTããTIMELOOP = TIMELOOP + 1ããLOOP                 'LOOP (DUH...) :)ãã'THANX TO Eric Carr FOR FIGURING OUT HOW TO TRAP SEVERAL KEYS AT ONCEã'EVERYTHING ELSE WRITTEN BY ME,              ããSUB KEYTEST (LOWERLIMIT, UPPERLIMIT)ãããDOãX = 1ãY = 1ãã FOR I = LOWERLIMIT TO UPPERLIMITã  TEST = MULTIKEY(I)ã  LOCATE Y, Xã  PRINT TEST; Iã ã  IF Y < 23 THENã   Y = Y + 1ã  ELSEã   Y = 1ã   X = X + 7ã  END IFã NEXT IããLOOP WHILE MULTIKEY(1) = 0ãENDãEND SUBããFUNCTION MULTIKEY (KEYNUM)ãã STATIC FIRSTIME, KEYS(), SC(), DU()ãã IF FIRSTIME = 0 THENã  DIM KEYS(255), SC(255), DU(255)ã  FOR E = 0 TO 127              '\ã  SC(E) = E: DU(E) = 1          '|ã  NEXT                          '|-ERIC CARR'S CODE--------------------\ã  FOR E = 128 TO 255            '|                                     |ã  SC(E) = E - 128: DU(E) = 0    '|                                     |ã  NEXT                          '/                                     |ã  FIRSTIME = -1                 '                                      |ã END IF                         '                                      |ã                                '                                      |ã I$ = INKEY$       ' So the keyb buffer don't get full     \routine/ \ |ã I = INP(&H60)     ' Get keyboard scan code from port 60h   \lines/  |-/ã OUT &H61, INP(&H61) OR &H82: OUT &H20, &H20       '         \!!!/   |ã KEYS(SC(I)) = DU(I) ' This says what keys are pressed        \!/    /ããMULTIKEY = KEYS(KEYNUM)ãããEND FUNCTIONãRobert Fortune                 KEYBOARD PORT TO SET DELAY     Ethan Winer's BASIC Techniques 07-01-97 (19:00)       QB, QBasic, PDS        45   2220     KEYPORTS.BAS'>I am making this "action"-game, where you have to avoid asteroids to getã'>points. However, I don't know how to get rid of keyboard delay, which isã'>VERY disturbing in a game like this. Does anyone know to get completelyã'>rid of it? I have gotten it to minimum with DOS-command:ã'>"mode con rate=32 delay=1", but there is still delay. Can anyone helpã'>me?ãã'   From Ethan Winer's book "BASIC: Techniques and Utilities" (availableã'   in freeware form in the WINER.ZIP file):ãã'   Keyboard Portsãã'   There are several ports associated with the keyboard, and one is ofã'   particular interest. The enhanced keyboards that come with AT-classã'   and later computers allow you to control how quickly keystrokes areã'   repeated automatically. There are actually two values - one sets theã'   initial delay before keys begin to repeat, and the other establishesã'   the repeat rate. By sending the correct values through the keyboardã'   port, you can control the keyboard's typematic response. The completeã'   program that follows shows how to do this, and Table 10.3 shows howã'   the delay and repeat values are determined.ãã   OUT &H60, &HF3        ' get keyboard's attentionã   FOR D& = 1 TO 100     ' brief delay to give the hardware time to settleã   NEXTãã   Value = 7             ' 1/4 second initial delay, 16 CPSã   OUT &H60, Valueãã'   Table 10.3 shows only some of the possible values that can be used.ã'   However, you can interpolate additional values for delay times andã'   repeat rates between those shown.ãã'  Table 10.3ã'  Sample Values for Setting the initial and Repeat Rate on AT-Style Keyboardã'  --------------------------------------------------------------------------ã'     Initial Delay                 0.25  0.50  0.75  1.00ã'     30 characters per second       00    20    40    60ã'     16 characters per second       07    27    47    67ã'      8 characters per second       0F    2F    4F    6Fã'      4 characters per second       17    37    57    77ã'      2 characters per second       1F    3F    5F    7Fãã'     Note: All values are shown in hexadecimalã'  ---------------------------------------------------------------------------ãKerry S. Goodin                TEST KEYBOARD BUFFER FOR CHAR  medvrsys@venus.net             08-19-97 (09:59)       QB, PDS                33   1547     INSTAT.BAS  ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''ã' -----Instat.bas----                                                      'ã' Function to test the keyboard buffer to see if a character is present.   'ã'                                                                          'ã' ( A key has been pressed).                                               'ã' It will not read the character but will return -1 if there is a          'ã' character or 0 is there is not a character in the buffer thus leaving    'ã' the buffer undisturbed.  This mimics the same function in PowerBasic(c)  'ã' but for QB 4.5.                                                          'ã' Written by: Kerry S. Goodin, D.D.S.                                      'ã'                                                                          'ã' USE AT YOUR OWN RISK.                                                    'ã'                                                                          'ã'note: start QB with the /L QB switch                                      'ã'                                                                          'ã''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''ããDEFINT A-ZãDECLARE FUNCTION instat ()ãã'$INCLUDE: 'c:\qb45\qb.bi'ããDIM SHARED inRegs AS RegType, outRegs AS RegTypeããFUNCTION instatã	inRegs.ax = &HB00ã	CALL INTERRUPT(&H21, inRegs, outRegs)ã	IF (outRegs.ax AND &HFF) <> 0 THENã		instat = -1ã	ELSEã		instat = 0ã	END IFãEND FUNCTIONãTommi Utriainen                CAPS ON/OFF ROUTINE            tomppa@pcuf.fi                 09-14-97 (21:42)       QB, QBasic, PDS        28   508      CAPS.BAS       ' caps on/offã   ' PRG BY TOMPPA 92ãã   CLSãã                ' 0 normalã                ' 1 shift-ã                ' 2 shift-ã                ' 4 Ctrl-ã                ' 8 Alt-ã                ' 16 scroll lockã                ' 32 numlockã                ' 64 CAPSLOCK ã                ' 128 -ã                ' 256 -ãã   DEF SEG = 0ã   POKE &H417, 0ã   DEF SEGããã   LINE INPUT "lowecase:"; text$ãã   DEF SEG = 0ã   POKE &H417, 64ã   DEF SEGãã   LINE INPUT "uppercase:"; text$ã