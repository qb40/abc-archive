Kerry S. Goodin                DETECTING KEY STATUS           kerry.goodin@shivasys.com      11-17-95 (00:00)       QB, PDS                108  2376     KEYFLAGS.BAS'**********************************************************„'*      keyflags.bas by Kerry S. Goodin, D.D.S.           *„'*        Placed in public domain 11-17-95                *„'*               use at your own risk                     *„'**********************************************************„„„DECLARE SUB keybFlags ()„DEFINT A-Z„„'Quick Basic Code for detecting the status of alt, ctrl, left shift, „'right shift, and insert or the state of the flags of numlock, capslock,„'and scroll lock of ROM BIOS (ie. Flag set on or off)„„'remember to start QB with the /lqb switch„'end program with esc key„„'$INCLUDE: 'qb.bi'„„'declare the types of the flags„TYPE Keyboard„ insert AS INTEGER„ CapsLock AS INTEGER„ NumLock  AS INTEGER„ ScrollLock AS INTEGER„ alt AS INTEGER„ Ctrl AS INTEGER„ LeftShift AS INTEGER„ RightShift AS INTEGER„END TYPE„„DIM SHARED inRegs AS RegType„DIM SHARED outRegs AS RegType„DIM SHARED kb AS Keyboard„„CLS„PRINT "Demo of reading the keyboard flags"„PRINT "press esc to end"„„DO„ COLOR 4, 7, 0„ LOCATE 20, 5, 0:„ CALL keybFlags„ IF kb.alt THEN„     PRINT " alt ";„ ELSE„     PRINT "     ";„ END IF„ IF kb.Ctrl THEN„     PRINT " Ctrl ";„ ELSE„     PRINT "      ";„ END IF„ IF kb.LeftShift THEN„     PRINT " LeftShift ";„ ELSE„     PRINT "           ";„ END IF„ IF kb.RightShift THEN„     PRINT " RightShift ";„ ELSE„     PRINT "            ";„ END IF„ IF kb.insert THEN„     PRINT " Insert ";„ ELSE„     PRINT "        ";„ END IF„ IF kb.CapsLock THEN„     PRINT " CapsLock ";„ ELSE„     PRINT "          ";„ END IF„ IF kb.NumLock THEN„     PRINT " NumLock ";„ ELSE„     PRINT "         ";„ END IF„ IF kb.ScrollLock THEN„     PRINT " ScrollLock ";„ ELSE„     PRINT "            ";„ END IF„ IF INKEY$ = CHR$(27) THEN EXIT DO 'get out of loop„„LOOP„„END„„SUB keybFlags„„ 'call the keyboard flags service„        'Int 16H Function 02H„„ inRegs.ax = &H200„ CALL interrupt(&H16, inRegs, outRegs)„„ 'extract the bits of the flag byte„ kb.insert = outRegs.ax \ 128„ kb.CapsLock = (outRegs.ax AND &H40) \ 64„ kb.NumLock = (outRegs.ax AND &H20) \ 32„ kb.ScrollLock = (outRegs.ax AND &H10) \ 16„ kb.alt = (outRegs.ax AND &H8) \ 8„ kb.Ctrl = (outRegs.ax AND &H4) \ 4„ kb.LeftShift = (outRegs.ax AND &H2) \ 2„ kb.RightShift = (outRegs.ax AND 1)„„END SUB„Justin Pasher/Vadim Kilshteyn  GET INPUT                      FidoNet QUIK_BAS Echo          11-06-95 (15:39)       QB, QBasic, PDS        114  3564     GETS.BAS    'Here's a nifty little code to get input from a user. It'll check every„'key pressed to a verification string that you define. You can also„'define the keys to end the input. The sub returns a key code = to the„'ASC() of the key used to end the input. It'll also return a string of„'the input. One neat affect is that it allows screen "wrapping". Try„'defining a StrLeng value greater than the screen width. It's cool. This„'was coded by Vadim Kilshteyn and me. Enjoy..„„DECLARE FUNCTION GetInput$ (ReturnStr$, Row, Col, StrLeng, WhatChar, Cursor, DoSound, StrCRC$, RetCRC$, MaxCol)„  DIM SHARED Nul AS STRING * 1„  DIM SHARED Esc AS STRING * 1„  DIM SHARED Enter AS STRING * 1„  Nul = CHR$(0): Enter = CHR$(13): Esc = CHR$(27)„  CONST True  = -1„  CONST False = 0„  CLS„  PRINT "Kewl Typing Program"„  FOR Ver = 1 TO 254„    IF Ver <> 7 AND Ver <> 27 THEN StrCRC$ = StrCRC$ + CHR$(Ver)„  NEXT„  RetCRC$ = Enter + Esc„  Row = 3: Col = 11„  WhatChar$ = "˘"„  LOCATE 3, 1: PRINT "Password ["; TAB(20); "]"„  Returned$ = GetInput$(RetStr$, Row, Col, 20, ASC(WhatChar$), True, True, StrCRC$, RetCRC$, 19)„  LOCATE 4, 1„  IF Returned$ = CHR$(27) THEN PRINT "Aborted..." ELSE PRINT RetStr$„  IF LEN(Returned$) = 1 THEN PRINT "Return Code: "; Returned$ ELSE PRINT "Return code: CHR$(0) +"; Returned$„„FUNCTION GetInput$ (ReturnStr$, Row, Col, StrLeng, WhatChar, Cursor, DoSound, StrCRC$, RetCRC$, MaxCol)„  IF WhatChar = 0 OR WhatChar = 8 OR WhatChar = 9 OR WhatChar = 10 OR WhatChar = 11 OR WhatChar = 255 THEN WhatChar = 32„  IF Cursor = True THEN Cursor = 1 ELSE Cursor = 0„  CurX = Col„  CurY = Row„  ScrnFull = 1„  IF MaxCol - Col + 1 <= StrLeng THEN„    SpaceC$ = STRING$(MaxCol - Col + 1, WhatChar)„    Total = MaxCol - CurX + 1„  ELSE„    SpaceC$ = STRING$(StrLeng, WhatChar)„    Total = StrLeng„  END IF„  MaxScrn = INT(StrLeng / Total)„  StartX = Col„  LOCATE Row, Col: PRINT SpaceC$;„  LOCATE Row, Col, Cursor„„GetKey:„  Key$ = ""„DO UNTIL LEN(Key$)„  Key$ = INKEY$„LOOP„„  IF INSTR(1, RetCRC$, Key$) = False AND INSTR(1, StrCRC$, Key$) = False THEN GOTO GetKey„  IF INSTR(1, RetCRC$, Key$) > 0 THEN GOTO EndIt„  IF Key$ = CHR$(25) THEN„    LOCATE CurY, StartX„    ScrnFull = 1„    Word$ = ""„    PRINT SpaceC$„    CurX = StartX„    LOCATE CurY, CurX„    GOTO GetKey„  END IF„  IF Key$ = CHR$(3) THEN GOTO GetKey„  IF Key$ = CHR$(0) + CHR$(144) THEN GOTO GetKey„„IF LEN(Word$) = StrLeng AND Key$ <> CHR$(13) AND Key$ <> CHR$(8) THEN„  IF DoSound = True THEN SOUND 450, 1: SOUND 950, 1„  GOTO GetKey„END IF„„IF Key$ = CHR$(8) THEN„  IF LEN(Word$) = 0 THEN„    CurX = StartX„    LOCATE CurY, CurX„    IF DoSound = True THEN SOUND 450, 1: SOUND 950, 1„    GOTO GetKey„  END IF„  IF CurX = StartX + 1 AND ScrnFull > 1 THEN„    ScrnFull = ScrnFull - 1„    CurX = StartX„    LOCATE CurY, StartX„    'PRINT SpaceC$„    Word$ = LEFT$(Word$, LEN(Word$) - 1)„    LOCATE CurY, CurX„    PRINT MID$(Word$, Total * (ScrnFull - 1) + 1, Total);„    CurX = MaxCol + 1„    LOCATE , CurX„    GOTO GetKey„  END IF„  CurX = CurX - 1„  LOCATE CurY, CurX„  PRINT CHR$(WhatChar);„  LOCATE CurY, CurX„  Word$ = LEFT$(Word$, LEN(Word$) - 1)„  GOTO GetKey„END IF„  IF CurX > MaxCol THEN„    CurX = StartX„    LOCATE CurY, StartX„    PRINT SpaceC$;„    LOCATE , StartX„    ScrnFull = ScrnFull + 1„  END IF„  LOCATE CurY, CurX: PRINT Key$;„  CurX = CurX + 1„  LOCATE CurY, CurX„  Word$ = Word$ + Key$„  GOTO GetKey„EndIt:„  ReturnStr$ = Word$„  GetInput$ = Key$„END FUNCTION„Rolf Genster                   NUMLOCK TOGGLE IN PB           Rolf@ice.prima.ruhr.de         01-19-96 (13:55)       PB                     57   1155     NUMLOCK.BAS $if 0„„ =========================================================================„„  Small code for switching NUMLOCK on and off„  written in PowerBasic 3.20„  by Rolf Genster on 01/19/96„„  Bit 6 : Caps Lock„  Bit 5 : Num Lock           1 = active, 0 = off„  Bit 4 : Scroll Lock„„„  Code for MS-Basics would look like:„       POKE &H417, PEEK(&H417) OR 32       'NUM-Lock on„     or„       POKE &H417, PEEK(&H417) AND NOT 32  'NUM-Lock off„„ =========================================================================„„$endif„„$lib all off„$optimize speed„$error all off„$cpu 80386„„defint a-z„„a$=lcase$(command$)„„print„„def seg = 0„„ if instr(a$,"on") > 0 then„     X = PEEK(&H417)„     BIT SET X, 5                 ' turn on NUM-Lock„     POKE &H417, X„     print "Numlock set!"„  elseif instr(a$,"off") > 0 then„     X = PEEK( &H417 )„     BIT RESET X, 5               ' turn off NUM-Lock„     POKE &H417, X„     print "Numlock reset!"„  else„     X = PEEK( &H417 )„     BIT TOGGLE X, 5              ' toggle NUM-Lock„     POKE &H417, X„     print "Numlock toggled!"„ end if„„def seg„„print„„end„Unknown Author(s)              SPECIAL KEY ASSIGNMENTS        mhscards@aol.com               02-03-96 (00:00)       QB, QBasic, PDS        134  4153     KEYCODES.BI 'FKeyDefs.bi„' Special Key Assignments„„CONST UpKey$ = CHR$(0) + CHR$(72)„CONST DownKey$ = CHR$(0) + CHR$(80)„CONST LeftKey$ = CHR$(0) + CHR$(75)„CONST RightKey$ = CHR$(0) + CHR$(77)„CONST PageUp$ = CHR$(0) + CHR$(73)„CONST PageDown$ = CHR$(0) + CHR$(81)„CONST HomeKey$ = CHR$(0) + CHR$(71)„CONST EndKey$ = CHR$(0) + CHR$(79)„CONST InsKey$ = CHR$(0) + CHR$(82)„CONST DelKey$ = CHR$(0) + CHR$(83)„CONST EnterKey$ = CHR$(13)„CONST TabKey$ = CHR$(9)„„CONST sTabKey$ = CHR$(0) + CHR$(15)„„CONST cHomekey$ = CHR$(0) + CHR$(119)„CONST cEndKey$ = CHR$(0) + CHR$(117)„CONST cPrtSc$ = CHR$(0) + CHR$(114)„CONST cLeftKey$ = CHR$(0) + CHR$(115)„CONST cRightKey$ = CHR$(0) + CHR$(116)„CONST cUpKey$ = CHR$(0) + CHR$(141)„CONST cDownKey$ = CHR$(0) + CHR$(145)„CONST cPageDown$ = CHR$(0) + CHR$(118)„CONST cPageUp$ = CHR$(0) + CHR$(132)„CONST cInsert$ = CHR$(0) + CHR$(146)„CONST cDelete$ = CHR$(0) + CHR$(147)„„CONST ' Function Keys„„CONST F1Key$ = CHR$(0) + CHR$(59)„CONST F2Key$ = CHR$(0) + CHR$(60)„CONST F3Key$ = CHR$(0) + CHR$(61)„CONST F4Key$ = CHR$(0) + CHR$(62)„CONST F5Key$ = CHR$(0) + CHR$(63)„CONST F6Key$ = CHR$(0) + CHR$(64)„CONST F7Key$ = CHR$(0) + CHR$(65)„CONST F8Key$ = CHR$(0) + CHR$(66)„CONST F9Key$ = CHR$(0) + CHR$(67)„CONST F10Key$ = CHR$(0) + CHR$(68)„CONST F11Key$ = CHR$(0) + CHR$(133)„CONST F12Key$ = CHR$(0) + CHR$(134)„„CONST ' Shifted Function Keys„„CONST sF1Key$ = CHR$(0) + CHR$(84)„CONST sF2Key$ = CHR$(0) + CHR$(85)„CONST sF3Key$ = CHR$(0) + CHR$(86)„CONST sF4Key$ = CHR$(0) + CHR$(87)„CONST sF5Key$ = CHR$(0) + CHR$(88)„CONST sF6Key$ = CHR$(0) + CHR$(89)„CONST sF7Key$ = CHR$(0) + CHR$(90)„CONST sF8Key$ = CHR$(0) + CHR$(91)„CONST sF9Key$ = CHR$(0) + CHR$(92)„CONST sF10Key$ = CHR$(0) + CHR$(93)„CONST sF11Key$ = CHR$(0) + CHR$(135)„CONST sF12Key$ = CHR$(0) + CHR$(136)„„CONST ' Control Function Keys„„CONST cF1Key$ = CHR$(0) + CHR$(94)„CONST cF2Key$ = CHR$(0) + CHR$(95)„CONST cF3Key$ = CHR$(0) + CHR$(96)„CONST cF4Key$ = CHR$(0) + CHR$(97)„CONST cF5Key$ = CHR$(0) + CHR$(98)„CONST cF6Key$ = CHR$(0) + CHR$(99)„CONST cF7Key$ = CHR$(0) + CHR$(100)„CONST cF8Key$ = CHR$(0) + CHR$(101)„CONST cF9Key$ = CHR$(0) + CHR$(102)„CONST cF10Key$ = CHR$(0) + CHR$(103)„CONST cF11Key$ = CHR$(0) + CHR$(137)„CONST cF12Key$ = CHR$(0) + CHR$(138)„„CONST ' Alt Function Keys„„CONST aF1Key$ = CHR$(0) + CHR$(104)„CONST aF2Key$ = CHR$(0) + CHR$(105)„CONST aF3Key$ = CHR$(0) + CHR$(106)„CONST aF4Key$ = CHR$(0) + CHR$(107)„CONST aF5Key$ = CHR$(0) + CHR$(108)„CONST aF6Key$ = CHR$(0) + CHR$(109)„CONST aF7Key$ = CHR$(0) + CHR$(110)„CONST aF8Key$ = CHR$(0) + CHR$(111)„CONST aF9Key$ = CHR$(0) + CHR$(112)„CONST aF10Key$ = CHR$(0) + CHR$(113)„CONST aF11Key$ = CHR$(0) + CHR$(139)„CONST aF12Key$ = CHR$(0) + CHR$(140)„„CONST ' Alt other keys„„CONST alt1$ = CHR$(0) + CHR$(120)„CONST alt2$ = CHR$(0) + CHR$(121)„CONST alt3$ = CHR$(0) + CHR$(122)„CONST alt4$ = CHR$(0) + CHR$(123)„CONST alt5$ = CHR$(0) + CHR$(124)„CONST alt6$ = CHR$(0) + CHR$(125)„CONST alt7$ = CHR$(0) + CHR$(126)„CONST alt8$ = CHR$(0) + CHR$(127)„CONST alt9$ = CHR$(0) + CHR$(128)„CONST alt0$ = CHR$(0) + CHR$(129)„CONST altHyphen$ = CHR$(0) + CHR$(130)„CONST altEqual$ = CHR$(0) + CHR$(131)„CONST altQ$ = CHR$(0) + CHR$(16)„CONST altW$ = CHR$(0) + CHR$(17)„CONST altE$ = CHR$(0) + CHR$(18)„CONST altR$ = CHR$(0) + CHR$(19)„CONST altT$ = CHR$(0) + CHR$(20)„CONST altY$ = CHR$(0) + CHR$(21)„CONST altU$ = CHR$(0) + CHR$(22)„CONST altI$ = CHR$(0) + CHR$(23)„CONST altO$ = CHR$(0) + CHR$(24)„CONST altP$ = CHR$(0) + CHR$(25)„„CONST altA$ = CHR$(0) + CHR$(30)„CONST altS$ = CHR$(0) + CHR$(31)„CONST altD$ = CHR$(0) + CHR$(32)„CONST altF$ = CHR$(0) + CHR$(33)„CONST altG$ = CHR$(0) + CHR$(34)„CONST altH$ = CHR$(0) + CHR$(35)„CONST altJ$ = CHR$(0) + CHR$(36)„CONST altK$ = CHR$(0) + CHR$(37)„CONST altL$ = CHR$(0) + CHR$(38)„„CONST altZ$ = CHR$(0) + CHR$(44)„CONST altX$ = CHR$(0) + CHR$(45)„CONST altC$ = CHR$(0) + CHR$(46)„CONST altV$ = CHR$(0) + CHR$(47)„CONST altB$ = CHR$(0) + CHR$(48)„CONST altN$ = CHR$(0) + CHR$(49)„CONST altM$ = CHR$(0) + CHR$(50)„„„Eric Carr                      SIMULTANEOUS KEY DEMO          FidoNet QUIK_BAS Echo          03-18-96 (13:12)       QB, QBasic, PDS        70   3011     KEYINPUT.BAS'Ok..Here is the sample keyboard routine I promised..I haven't tested it on any„'other computer excpet mine, but it should work for anyone..  This program lets„'you move a box around by pressing the arrow keys..The acual routine in only 4„'lines as i have marked..This program requires a minimum of a 486sx 25mhz if„'not compiled to run fast enough for all the keys to be updated..I also„'reprogrammed the internal timer from 18.2 to 30, so I could time it to 30 fps.„'To see if a key is being currently pressed, the variable KS is used (IF„'KS(75)=1 THEN button is pressed). Instead of ASCII, this uses scan codes,„'which you can look at in the QB help..Hope you can understand it! :)„„ DEFINT A-Z: DIM B(300): CLS„„ N& = 39772                  'Reprogram the timer to 30hz„ LB& = N& AND &HFF           'instead of 18.2 (for 30 frames„ HB& = (N& / 256) AND &HFF   'per second.)„ OUT &H43, &H3C: OUT &H40, LB&: OUT &H40, HB&„„ DIM KS(255), SC(255), DU(255)„ FOR E = 0 TO 127      ' Setup key data table KSC()„ SC(E) = E: DU(E) = 1„ NEXT„ FOR E = 128 TO 255„ SC(E) = E - 128: DU(E) = 0„ NEXT„„ SCREEN 13: COLOR 4„ LOCATE 10, 3: PRINT "Keyboard input routine by Eric Carr"„ COLOR 7: PRINT : COLOR 2„ PRINT "  Use the arrow keys to move the box."„ PRINT "Note that you can press two or more keys"„ PRINT "    at once for diagnal movement!"„ PRINT : COLOR 8: PRINT "          Press [Esc] to quit"„ X = 150: Y = 100: BX = X: BY = Y„ DEF SEG = 0„ POKE (1132), 0„ GET (X, Y)-(X + 15, Y + 15), B„ DO  'main loop„T:„ I$ = INKEY$       ' So the keyb buffer don't get full     \routine/„ I = INP(&H60)     ' Get keyboard scan code from port 60h   \lines/„ OUT &H61, INP(&H61) OR &H82: OUT &H20, &H20       '         \!!!/„ KS(SC(I)) = DU(I) ' This says what keys are pressed          \!/„ „ IF PEEK(1132) < 1 THEN GOTO T  'If not enough time was passed goto T„ POKE (1132), 0  'reset timer again„ BX = X: BY = Y„ IF KS(75) = 1 THEN XC = XC - 2: IF XC < -15 THEN XC = -15„ IF KS(77) = 1 THEN XC = XC + 2: IF XC > 15 THEN XC = 15„ IF KS(72) = 1 THEN YC = YC - 2: IF YC < -15 THEN YC = -15„ IF KS(80) = 1 THEN YC = YC + 2: IF YC > 15 THEN YC = 15„ IF XC > 0 THEN XC = XC - 1 ELSE IF XC < 0 THEN XC = XC + 1„ IF YC > 0 THEN YC = YC - 1 ELSE IF YC < 0 THEN YC = YC + 1„ Y = Y + YC: X = X + XC„ IF X > 300 THEN X = 300 ELSE IF X < 0 THEN X = 0„ IF Y > 180 THEN Y = 180 ELSE IF Y < 0 THEN Y = 0„ IF X <> BX OR Y <> BY THEN„ WAIT 936, 8: PUT (BX, BY), B, PSET„ GET (X, Y)-(X + 15, Y + 15), B: LINE (X, Y)-(X + 15, Y + 15), 9, BF„ END IF„ LOOP UNTIL KS(1) = 1 'loop until [Esc] (scan code 1) is pressed„„ N& = 65535                      'Program the timer back to„ LB& = N& AND &HFF               '18.2hz before exiting!„ HB& = (N& / 256) AND &HFF„ OUT &H43, &H3C: OUT &H40, LB&: OUT &H40, HB&„„ OUT &H61, INP(&H61) OR &H82: OUT &H20, &H20„ CLEAR   'need to have this if reprograming the timer„ END      'I think this ends the program. I'm not quite sure.. :)„„Eric Benson                    DETECT KEYDOWN & KEYUP EVENTS  comp.lang.basic.misc           04-11-96 (18:17)       QB, QBasic, PDS        119  3539     KEYPRESS.BAS'This routine I wrote to detect keydown and keyup events works great (using „'INP(&H60) as someone suggested a while back). To get the ascii of the key that„'was pressed I am using INKEY$.  It sometimes returns zero, I guess the BIOS„'hasn't translated the key when I call INKEY$.  But if you run the program„'below you may notice a fairly substantial (0.5 sec) delay sometimes.  „'Suggestions to get around this?„'I figure I could load an array with ascii codes and index it with the scancode „'i.e. ascii=scan2ascii(scancode), but I would still need to take care of the „'shift key.„'Or maybe I should run this in straight DOS and not in a Win95 DOS box.„„'Program Keypress.bas by Eric Benson - April 1996„DEFINT A-Z„DECLARE SUB KernelKeyPress (scancode AS INTEGER, ascii AS INTEGER, keystate AS INTEGER)„REM DECLARE SUB BYTECOPY (SEG SOURCE AS ANY, SEG DESTINATION AS ANY, NUMBYTES&)„CONST TRUE = -1, FALSE = 0„CONST keybuffermax = 10, kdown = 1, kpressed = 2, kup = 3„TYPE keyvar„  keyin AS INTEGER„  keyup AS INTEGER„  scancode AS INTEGER„  ascii AS INTEGER„  extended AS INTEGER„END TYPE„„CLS„REM GOTO test„DO„  keystate = 0„  KernelKeyPress scancode, ascii, keystate„  IF keystate = kdown THEN„    PRINT "keydown     "; scancode, ascii„  ELSEIF keystate = kup THEN„    PRINT "keyup       "; scancode, ascii„  END IF„LOOP UNTIL scancode = 1„END„„test:„'used to look at what the keyboard is outputing„DO„  keyin = INP(&H60)„'  LOCATE 1, 1: PRINT "    "„  LOCATE 1, 1: PRINT keyin„  b$ = INKEY$„LOOP UNTIL keyin = 1„END„„SUB KernelKeyPress (scancode AS INTEGER, ascii AS INTEGER, keystate AS INTEGER)„STATIC init AS INTEGER, buffer() AS keyvar„STATIC ibuf AS INTEGER, pressedkey AS INTEGER„IF init THEN„  keyin = INP(&H60)„  b$ = INKEY$„  'Warning inkey$ above does not always trap the keystroke„  IF keyin > 128 AND pressedkey THEN„    FOR i = 1 TO ibuf„      IF keyin = 170 OR buffer(i).keyup = keyin THEN„        scancode = buffer(i).scancode„        ascii = buffer(i).ascii„        keystate = kup„        IF ibuf = 1 THEN„          pressedkey = 0„        ELSEIF i < ibuf THEN„          pressedkey = buffer(i).keyup„          FOR j = i TO ibuf - 1„            SWAP buffer(j), buffer(j + 1)„          NEXT„          REM BYTECOPY buffer(i + 1), buffer(i), (ibuf - i) * 10„        ELSE„          'top key in buffer is unpressed„          pressedkey = buffer(i).keyup„        END IF„        ibuf = ibuf - 1„        EXIT SUB„      END IF„    NEXT„  END IF„  IF pressedkey <> keyin AND keyin < 129 THEN„    IF ibuf THEN„      FOR i = 1 TO ibuf„        IF buffer(i).keyin = keyin THEN EXIT SUB„      NEXT„    END IF„    IF ibuf < keybuffermax THEN„      ibuf = ibuf + 1„      buffer(ibuf).keyin = keyin„      buffer(ibuf).keyup = keyin + 128„     „      'Remove this IF..ENDIF block for normal execution„      'Will hang if shift is pressed„      IF LEN(b$) = 0 THEN„        DO„          b$ = INKEY$„        LOOP UNTIL LEN(b$)„      END IF„     „      IF LEN(b$) = 2 THEN„        buffer(ibuf).extended = ASC(RIGHT$(b$, 1))„      ELSEIF LEN(b$) THEN„        buffer(ibuf).ascii = ASC(b$)„      ELSE„        buffer(ibuf).ascii = 0„      END IF„      buffer(ibuf).scancode = keyin„      pressedkey = keyin„      scancode = keyin„      ascii = buffer(ibuf).ascii„      keystate = kdown„      EXIT SUB„    END IF„  END IF„ELSE„  DIM buffer(1 TO keybuffermax) AS keyvar„  ibuf = 0„  pressedkey = 0„  init = TRUE„END IF„END SUB„Jeremy Stanley                 LEFT/RIGHT SHIFT (USING BITS)  FidoNet QUIK_BAS Echo          04-13-96 (11:22)       QB, QBasic, PDS        36   916      BITKEY.BAS  '> "There's a byte in the BIOS area, the bits of which say which Ctrl, Alt and„'> Shift keys are depressed.  There's another which helps you differentiate left„'> from right keys.  But I can't remember what they are... Anyone?"„„'The first byte in question is at 0040:0017.  This example program should„'demonstrate how to read the status of these keys:„„DEFINT A-Z„„CLS„PRINT "Byte at 0040:0017  Press ESC to exit"„PRINT "   - bit 0 - Right shift"„PRINT "   - bit 1 - Left shift"„PRINT "   - bit 2 - Ctrl"„PRINT "   - bit 3 - Alt"„PRINT "   - bit 4 - Scroll lock"„PRINT "   - bit 5 - Num lock"„PRINT "   - bit 6 - Caps lock"„PRINT "   - bit 7 - Insert"„„DEF SEG = &H40„„DO„  c = PEEK(&H17)„  FOR x = 0 TO 7„    LOCATE x + 2, 1„    e = 2 ^ x„    PRINT (c AND e) \ e„  NEXT„LOOP UNTIL INKEY$ = CHR$(27)„„DEF SEG„„'jeremy.stanley@darkstarbbs.com„'http://pages.prodigy.com/perigee/„„Raymond Joh                    MOUSE AND KEY DEMO             dslayer@worldnet.att.net       05-27-96 (13:08)       QB, PDS                84   2968     KEYNMSE.BAS 'This demo is designed to integrate extended key(as well as normal key)„'functions into mouse routines. Be sure to load with the QB/L switch to„'make use of the Interrupt Calls.Though setup for QuickBasic, this code„'can easily be modified for QB.„'Author : Raymond Joh„'Status : Public Domain„„'$INCLUDE: 'qb.bi'„DECLARE FUNCTION GetKeyBuf$ ()„DECLARE SUB KeyStroke (keyboard$)„DEFINT A-Z„'=========================== Demo code(Remove) ============================„COLOR 15, 9„CLS„LOCATE 1, 30: PRINT "Mouse and Key Demo"„LOCATE 3, 1: PRINT "DEFINED KEYS"„PRINT STRING$(12, "Õ")„PRINT "<F1 KEY>"„PRINT "<F3><KEY>"„PRINT "<F5><KEY>"„PRINT "<TAB>"„PRINT "<ENTER>"„PRINT "<ALT><F>"„PRINT "<ALT><E>"„PRINT "<ALT><H>"„PRINT ""„PRINT "<ESCAPE> TO EXIT PROGRAM"„PRINT ""„PRINT ""„PRINT "To define your own <Hot> keys. Press any key"„PRINT "and note the ascii value below.That value will"„PRINT "need to be defined in the KeyStroke sub."„LOCATE 24, 14: PRINT "ASCII KEY VALUE";„COLOR 0, 7„LOCATE 25, 1: PRINT STRING$(80, " ");„'---------------------------- End of Demo Code ----------------------------„DO    'Remove - For demo use only„'============ Place the following two lines in your mouse loop ============„  keyboard$ = GetKeyBuf$„  IF keyboard$ <> "" THEN CALL KeyStroke(keyboard$)„LOOP  'Remove - For demo use only„END„„FUNCTION GetKeyBuf$„DIM InRegs AS RegType, OutRegs AS RegType„InRegs.ax = &H600„InRegs.dx = &HFF„CALL INTERRUPT(&H21, InRegs, OutRegs)„				 ' No character ready if zero flag set„IF (OutRegs.flags AND 2 ^ 6) THEN„  GetKeyBuf$ = ""„ELSE„  IF (OutRegs.ax AND &HFF) <> 0 THEN„    GetKeyBuf$ = CHR$(OutRegs.ax AND &HFF)„  ELSEIF (OutRegs.ax AND &HFF) = 0 THEN„    InRegs.ax = &H600„    InRegs.dx = &HFF„    CALL INTERRUPT(&H21, InRegs, OutRegs)„    GetKeyBuf$ = CHR$(0) + CHR$(OutRegs.ax AND &HFF)„  END IF„END IF„END FUNCTION„„SUB KeyStroke (keyboard$)„IF LEN(keyboard$) = 2 THEN„  Real.Key% = -ASC(RIGHT$(keyboard$, 1))„ELSE„  Real.Key% = ASC(keyboard$)„END IF„'============================== Demo Stuff =============================„LOCATE 25, 50: PRINT "UNDEFINED";        'Remove - For demo use only„LOCATE 25, 20: PRINT Real.Key%;          'Remove - For demo use only„„'======================= USER DEFINED KEY AREA =========================„IF Real.Key% = -59 THEN LOCATE 25, 50: PRINT "<F1 KEY> ";    'F1„IF Real.Key% = -61 THEN LOCATE 25, 50: PRINT "<F3 KEY> ";    'F3„IF Real.Key% = -63 THEN LOCATE 25, 50: PRINT "<F5 KEY> ";    'F5„IF Real.Key% = 27 THEN SYSTEM                                'ESCAPE„IF Real.Key% = 13 THEN LOCATE 25, 50: PRINT "<ENTER>  ";     'ENTER„IF Real.Key% = 9 THEN LOCATE 25, 50: PRINT "<TAB KEY>";      'TAB„IF Real.Key% = -33 THEN LOCATE 25, 50: PRINT "<ALT><F> ";    '<ALT><F>„IF Real.Key% = -18 THEN LOCATE 25, 50: PRINT "<ALT><E> ";    '<ALT><E>„IF Real.Key% = -35 THEN LOCATE 25, 50: PRINT "<ALT><H> ";    '<ALT><H>„END SUB„Jason Laviska                  KEYBOARD LIGHT CONTROL         jason.laviska@outdoor.com      06-12-96 (08:05)       QB, QBasic, PDS        53   1596     KEYLITE.BAS 'Controlling the keyboard light indicators by Jason Laviska.„'LaserArts' Library Function K-02-B„'--- Public Domain --- Use at your own risk ---„„'     This is a very short subprogram I made that will enable/disable„'the Num, Caps, and Scroll lock indicators on your keyboard.  All you„'have to do is to call the Keylite subprogram with a integer from 0 to„'7 and your keyboard lights will automatically adjust.  If you enter„'any other number using this subprogram, it will not do anything.  I„'have found that Keylite works successfully if the user presses a key,„'if Basic askes for a key (such as using Inkey$), or any other way you„'can think of to talk to the 8042-based keyboard controller chip.„'This has been successfully tested using a 101-key enhanced keyboard.„'This will not work on the original 83-key PC/XT keyboards that are„'not bidirectional.„„CLS„PRINT "Press any key to begin keyboard demostration. :)"„SLEEP„CLS„FOR Temp% = 0 TO 7„  Keylite Temp%„  Temp$ = INKEY$„  PRINT "Mode"; Temp%, "Press any key."„  SOUND 1000, .3„  SLEEP (5)„NEXT Temp%„„SUB Keylite (KeyMode%)„„'KeyMode% ... Valid values must be in the range of 0 to 7.„„'Cap   Num   Scr = KeyMode%„'---   ---   ---   --------„' 0     0     0       0„' 0     0     1       1„' 0     1     0       2„' 0     1     1       3„' 1     0     0       4„' 1     0     1       5„' 1     1     0       6„' 1     1     1       7„„' 0 = Inactive„' 1 = Active„„IF KeyMode% > -1 AND KeyMode% < 8 THEN„  DEF SEG = 0„  POKE &H417, (KeyMode% * 16) + 128„  DEF SEG„END IF„„END SUB„Steven Sensarn                 KEYBOARD ISR                   comp.lang.basic.misc           06-22-96 (22:14)       QB, QBasic, PDS        162  7658     KEYISR.BAS  'Here is a nice program that uses its own ISR to handle keyboard I/O.  „'Normally, BIOS handles interrupt calls from the keyboard.  Unfortunately, „'BIOS is relatively slow and often cannot catch up with the user pressing the „'keys on the keyboard.  This results in a keyboard buffer overflow and the PC „'starts beeping (it's happend to all of us).  To correct this error, the „'programmer writes his own ISR (interrupt service routine) and replaces the „'old ISR with it.  The keyboard is connected to IRQ1 (or it should be--if „'you're having keyboard problems, that might be the reason).  Therefore, the „'ISR must be connected to interrupt 9h (IRQ1's alias).  Enjoy!„„DECLARE SUB SETVECT (S AS INTEGER, O AS INTEGER, I AS INTEGER)„DECLARE SUB GETVECT (S AS INTEGER, O AS INTEGER, I AS INTEGER)„DECLARE SUB KEYBOARD.IN (OLDSEG AS INTEGER, OLDOFF AS INTEGER)„DECLARE SUB KEYBOARD.OUT (OLDSEG AS INTEGER, OLDOFF AS INTEGER)„„'$STATIC„„DIM RAWKEY AS INTEGER„DIM OLD.ISR.SEG AS INTEGER, OLD.ISR.OFF AS INTEGER„„CALL KEYBOARD.IN(OLD.ISR.SEG, OLD.ISR.OFF)„„DO„    PRINT RAWKEY 'DISPLAY SCANCODE OF LAST KEY PRESSED„                 'NOTICE THAT EACH KEY HAS A PRESS AND RELEASE CODE„LOOP UNTIL RAWKEY = 1„„CALL KEYBOARD.OUT(OLD.ISR.SEG, OLD.ISR.OFF)„„SUB GETVECT (S AS INTEGER, O AS INTEGER, I AS INTEGER)„„    'GETVECT RETURNS THE ADDRESS OF A FUNCTION POINTED TO IN THE„    'INTERRUPT VECTOR TABLE (STARTS AT 0000:0000H)„„    STATIC ASM AS STRING 'THE CODE FOR GETVECT„„    STATIC INI AS INTEGER 'USED TO DETECT WHETHER GETVECT HAS PREVIOUSLY„                          'BEEN CALLED„    IF INI = 0 THEN„        „        'CREATE ML FUNCTION IF NOT ALREADY CREATED„„        ASM = ASM + CHR$(&H55)                          'PUSH    BP„        ASM = ASM + CHR$(&H89) + CHR$(&HE5)             'MOV     BP,SP„        ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV     BX,[BP+06]„        ASM = ASM + CHR$(&H8A) + CHR$(&H7)              'MOV     AL,[BX]„        ASM = ASM + CHR$(&HB4) + CHR$(&H35)             'MOV     AH,35„        ASM = ASM + CHR$(&HCD) + CHR$(&H21)             'INT     21„        ASM = ASM + CHR$(&H53)                          'PUSH    BX„        ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'MOV     BX,[BP+0A]„        ASM = ASM + CHR$(&H8C) + CHR$(&H7)              'MOV     [BX],ES„        ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'MOV     BX,[BP+08]„        ASM = ASM + CHR$(&H58)                          'POP     AX„        ASM = ASM + CHR$(&H89) + CHR$(&H7)              'MOV     [BX],AX„        ASM = ASM + CHR$(&H5D)                          'POP     BP„        ASM = ASM + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'RETF    0006„        INI = 1 'FLAG CREATION„    END IF„„    DEF SEG = VARSEG(ASM)„    CALL ABSOLUTE(S, O, I, SADD(ASM)) 'RUN FUNCTION„END SUB„„SUB KEYBOARD.IN (OLDSEG AS INTEGER, OLDOFF AS INTEGER)„    SHARED RAWKEY AS INTEGER 'GLOBAL VARIABLE HOLDS SCANCODE„„    DIM SGL AS INTEGER, SGH AS INTEGER 'SEGMENT OF RAWKEY„    DIM OFL AS INTEGER, OFH AS INTEGER 'OFFSET OF RAWKEY„„    DIM BYTE AS STRING * 1 'USED TO ACTIVATE IRQ 1 IN PIC„„    STATIC ASM AS STRING 'HOLDS ISR„„    SGL = VARSEG(RAWKEY) AND &HFF 'LOAD LOW "BYTE" SEGMENT„    SGH = INT(VARSEG(RAWKEY) / 256) AND &HFF 'LOAD HIGH "BYTE" SEGMENT„„    OFL = VARPTR(RAWKEY) AND &HFF 'LOAD LOW "BYTE" OFFSET„    OFH = INT(VARPTR(RAWKEY) / 256) AND &HFF 'LOAD HIGH "BYTE" OFFSET„„    'THIS IS THE ISR.  IT READS A SCANCODE FROM THE KEYBOARD BUFFER„    'AND RESETS IT.  THE BEST PART IS, BIOS CAN'T TOUCH IT!„„    ASM = ""„    ASM = ASM + CHR$(&H52)                          'PUSH DX„    ASM = ASM + CHR$(&H51)                          'PUSH CX      „    ASM = ASM + CHR$(&H53)                          'PUSH BX„    ASM = ASM + CHR$(&H50)                          'PUSH AX„    ASM = ASM + CHR$(&H6)                           'PUSH ES„    ASM = ASM + CHR$(&H57)                          'PUSH DI„    ASM = ASM + CHR$(&H1E)                          'PUSH DS„    ASM = ASM + CHR$(&H56)                          'PUSH SI„    ASM = ASM + CHR$(&HFB)                          'STI„    ASM = ASM + CHR$(&HBA) + CHR$(&H60) + CHR$(&H0) 'MOV DX,0060„    ASM = ASM + CHR$(&HEC)                          'IN AL,DX„    ASM = ASM + CHR$(&H30) + CHR$(&HE4)             'XOR AH,AH„    ASM = ASM + CHR$(&HBA) + CHR$(SGL) + CHR$(SGH)  'MOV DX,SEG RAWKEY„    ASM = ASM + CHR$(&H8E) + CHR$(&HDA)             'MOV DS,DX„    ASM = ASM + CHR$(&HBE) + CHR$(OFL) + CHR$(OFH)  'MOV SI,OFFSET RAWKEY„    ASM = ASM + CHR$(&H88) + CHR$(&H4)              'MOV [SI],AL„    ASM = ASM + CHR$(&HBA) + CHR$(&H61) + CHR$(&H0) 'MOV DX,0061„    ASM = ASM + CHR$(&HEC)                          'IN AL,DX„    ASM = ASM + CHR$(&HC) + CHR$(&H82)              'OR AL,82„    ASM = ASM + CHR$(&HEE)                          'OUT DX,AL„    ASM = ASM + CHR$(&H24) + CHR$(&H7F)             'AND AL,7F„    ASM = ASM + CHR$(&HEE)                          'OUT DX,AL„    ASM = ASM + CHR$(&HB0) + CHR$(&H20)             'MOV AL,20„    ASM = ASM + CHR$(&HBA) + CHR$(&H20) + CHR$(&H0) 'MOV DX,0020„    ASM = ASM + CHR$(&HEE)                          'OUT DX,AL„    ASM = ASM + CHR$(&H5E)                          'POP SI„    ASM = ASM + CHR$(&H1F)                          'POP DS„    ASM = ASM + CHR$(&H5F)                          'POP DI„    ASM = ASM + CHR$(&H7)                           'POP ES„    ASM = ASM + CHR$(&H58)                          'POP AX„    ASM = ASM + CHR$(&H5B)                          'POP BX„    ASM = ASM + CHR$(&H59)                          'POP CX„    ASM = ASM + CHR$(&H5A)                          'POP DX„    ASM = ASM + CHR$(&HCF)                          'IRET„„    BYTE = CHR$(INP(&H21)) 'LOAD IRQ ENABLE REGISTER IN PIC„„    OUT &H21, (ASC(BYTE) AND (255 XOR 2)) 'CLEAR BIT 2 (IRQ 1)„„    CALL GETVECT(OLDSEG, OLDOFF, &H9) 'LOAD OLD ISR„    CALL SETVECT(VARSEG(ASM), SADD(ASM), &H9) 'STORE NEW ISR„END SUB„„SUB KEYBOARD.OUT (OLDSEG AS INTEGER, OLDOFF AS INTEGER)„    CALL SETVECT(OLDSEG, OLDOFF, &H9) 'RESTORE OLD ISR„END SUB„„SUB SETVECT (S AS INTEGER, O AS INTEGER, I AS INTEGER)„„    'SETVECT CHANGES THE ADDRESSES IN THE INTERRUPT VECTOR TABLE„    'TO POINT TO NEW FUNCTIONS„„    STATIC ASM AS STRING 'HOLDS THE SETVECT FUNCTION„    STATIC INI AS INTEGER 'USED TO TEST WHETHER OR NOT FUNCTION HAS PREVOUSLY„                          'BEEN CALLED„    IF INI = 0 THEN„„        'CREATE FUNCTION IF NOT ALREADY CREATED„„        ASM = ""„        ASM = ASM + CHR$(&H55)                          'PUSH BP„        ASM = ASM + CHR$(&H89) + CHR$(&HE5)             'MOV BP,SP„        ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'MOV BX,[BP+08]„        ASM = ASM + CHR$(&H8B) + CHR$(&H17)             'MOV DX,[BX]„        ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„        ASM = ASM + CHR$(&H8A) + CHR$(&H7)              'MOV AL,[BX]„        ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'MOV BX,[BP+0A]„        ASM = ASM + CHR$(&H1E)                          'PUSH DS„        ASM = ASM + CHR$(&H8E) + CHR$(&H1F)             'MOV DS,[BX]„        ASM = ASM + CHR$(&HB4) + CHR$(&H25)             'MOV AH,25„        ASM = ASM + CHR$(&HCD) + CHR$(&H21)             'INT 21„        ASM = ASM + CHR$(&H1F)                          'POP DS„        ASM = ASM + CHR$(&H5D)                          'POP BP„        ASM = ASM + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'RETF 0006„        INI = 1 'FLAG CREATION„    END IF„    DEF SEG = VARSEG(ASM)„    CALL ABSOLUTE(S, O, I, SADD(ASM)) 'RUN SETVECT„END SUB„