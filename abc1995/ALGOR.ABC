Mark H. Butler                 CALCULATING BIORHYTHMS         CALCULATING,BIORHYTHMS         Unknown Date (00:00:00)QB, PDS                369  9330     BIORHYTM.BAS'**************************************************************„'*** I converted this program from some old GW-Basic code„'*** I came across and jazzed it up somewhat. As you can see„'*** it's *SPAGHETTI* but it does work. It will require loading„'*** with QB.LIB OR QBX.LIB to run properly. Lines longer than„'*** 65 columns have been cut to a new line with an underscore,„'*** many of these lines you will need to re-append manually.„'**************************************************************„'***  Mark H Butler (1:105/330.5)„'**************************************************************„„TYPE RegType„  ax    AS INTEGER„  bx    AS INTEGER„  cx    AS INTEGER„  dx    AS INTEGER„  bp    AS INTEGER„  si    AS INTEGER„  di    AS INTEGER„  flags AS INTEGER„END TYPE„„DECLARE SUB PrintScreen ()„DECLARE SUB Pause (ticks%)„DECLARE SUB Cuckoo ()„DECLARE SUB Lineout ()„DECLARE SUB IDParse (IDLine$, NumberOfNames%, Name$(), MaxNames%)„DECLARE SUB INTERRUPT (intnum AS INTEGER, inreg AS RegType, outreg AS RegType)„„CONST Digit$ = "1234567890"„CONST CenterLine$ = "1-2-3-4-5-6-7-8-9-0-"„CONST PI! = 3.1416„CONST Symbol23$ = "*", Symbol28$ = "#", Symbol33$ = "+"    ', BL„NK$ = " "„CONST FALSE = 0, TRUE = NOT FALSE„DIM Name$(1 TO 10)„DIM Month%(12), Month$(12)„„80„ RESTORE 240„ FOR i% = 1 TO 12„    READ Month%(i%)„ NEXT i%„„240 DATA 31,28,31,30,31,30,31,31,30,31,30,31„   „ FOR i% = 1 TO 12„    READ Month$(i%)„ NEXT i%„   „ DATA January,February,March,April,May,June,July,August,September,October,November,December„„ CLS„ COLOR 0, 3„ LOCATE 3, 35, 0„ PRINT " BIORHYTHMS "„ COLOR 7, 0„ LOCATE 6, 1„ PRINT "The theory of biorhythms is that we are influenced by three rhythms, physical,": PRINT„ PRINT "emotional, and intellectual, beginning the day we are born.  The first and the": PRINT„ PRINT "middle days of each cycle are considered critical days. In the biorhythm chart": PRINT„ PRINT "which follows these days cross the dateline."„ PRINT„ PRINT„ PRINT "If you have a printer, a printed copy may be made by pressing the letter "; CHR$(34); "P"; CHR$(34); "."„ 'SOUND 2200, 1„„560„ LOCATE 20, 1„   „ DEF SEG = 0    '„ POKE 1047, 64  ''****** caps on„ DEF SEG    '„   „ LINE INPUT ; "Please enter your name: "; WHOM$„   „ DEF SEG = 0   '„ POKE 1047, 0  '****** caps off„ DEF SEG       '„„„ IF WHOM$ = "" THEN„    Cuckoo„    GOTO 560„ END IF„   „ IDParse WHOM$, NumberOfNames%, Name$(), 10„ IF NumberOfNames% > 1 THEN„    WHOM$ = Name$(1) + " " + Name$(NumberOfNames%)„ ELSE„    WHOM$ = Name$(1)„ END IF„    „600„   „ LOCATE 21, 1„ PRINT STRING$(78, " ")„ LOCATE 21, 1„„ „„ PRINT "What is "; WHOM$; "'s "; "birthdate? MM-DD-YY ";„ LINE INPUT DateString$„ ON ERROR GOTO 2760„   „ IF INSTR(Digit$, MID$(DateString$, 1, 1)) = 0 THEN ERROR 0„ N% = 1„ IF INSTR(Digit$, MID$(DateString$, 2, 1)) <> 0 THEN N% = 2„ BirthMonth% = VAL(MID$(DateString$, 1, N%))„ IF BirthMonth% < 1 OR BirthMonth% > 12 THEN ERROR 0„   „ S% = N% + 2„ IF INSTR(Digit$, MID$(DateString$, S%, 1)) = 0 THEN ERROR 0„ N% = 1: IF INSTR(Digit$, MID$(DateString$, S% + 1, 1)) <> 0 THEN N% = 2„ BirthDate% = VAL(MID$(DateString$, S%, N%))„ IF BirthDate% < 1 OR BirthDate% > 31 THEN ERROR 0„   „ S% = S% + N% + 1„ BirthYear% = VAL(MID$(DateString$, S%)): IF BirthYear% = 0 THEN ERROR 0„ IF BirthYear% < 100 THEN BirthYear% = BirthYear% + 1900„ IF BirthYear% < 1582 THEN ERROR 0„„980„ LOCATE 22, 1„ PRINT STRING$(78, " ")„ LOCATE 22, 1„ LINE INPUT "Start the biorhythm at : MM-YY "; DateString$„   „ ON ERROR GOTO 2780„   „ IF INSTR(Digit$, MID$(DateString$, 1, 1)) = 0 THEN ERROR 0„ N% = 1: IF INSTR(Digit$, MID$(DateString$, 2, 1)) <> 0 THEN N% = 2„ CalcMonth% = VAL(MID$(DateString$, 1, N%))„ IF CalcMonth% < 1 OR CalcMonth% > 12 THEN ERROR 0„ S% = N% + 2„ FOR i% = S% TO LEN(DateString$)„    IF INSTR(Digit$, MID$(DateString$, i%, 1)) = 0 THEN ERROR 0„ NEXT„ CalcYear% = VAL(MID$(DateString$, S%)): IF CalcYear% = 0 THEN ERROR 0„ IF CalcYear% < 100 THEN CalcYear% = CalcYear% + 1900„ IF CalcYear% < 1582 THEN ERROR 0„ IF CalcYear% < BirthYear% THEN ERROR 0„ IF (CalcYear% = BirthYear%) AND (CalcMonth% < BirthMonth%) THEN ERROR 0„ ON ERROR GOTO 0„„'DAYS FROM BIRTH TO END OF MONTH„ TotalDays = Month%(BirthMonth%) - BirthDate% + 1„ YEAR% = BirthYear%„ GOSUB 2820„ IF BirthMonth% <= 2 AND YEAR% = 0 THEN TotalDays = TotalDays + 1„                            'LEAP YEAR ^„ FOR i% = (BirthMonth% + 1) TO 12        'REST OF BIRTH YEAR„„    TotalDays = TotalDays + Month%(i%)„ NEXT i%„   „ YEAR% = CalcYear% - BirthYear% - 1       'YEARS IN BETWEEN„ C23% = 20 * YEAR%„ C28% = 1 * YEAR%„ C33% = 2 * YEAR%„   „ FOR i% = (BirthYear% + 1) TO (CalcYear% - 1)  'LEAP YEARS IN BETWEEN„    YEAR% = i%„    GOSUB 2820„    IF YEAR% = 0 THEN TotalDays = TotalDays + 1„ NEXT i%„ „ FOR i% = 1 TO (CalcMonth% - 1)        'MONTHS„    TotalDays = TotalDays + Month%(i%)„ NEXT i%„ „ YEAR% = CalcYear%„ GOSUB 2820„ IF CalcMonth% >= 2 AND YEAR% = 0 THEN TotalDays = TotalDays + 1 'LEAP YEAR„ „ C23% = (C23% + TotalDays) MOD 23      'CALCULATE DAYS INTO CYCLE„ C28% = (C28% + TotalDays) MOD 28„ C33% = (C33% + TotalDays) MOD 33„   „ COLOR 0, 1„ CLS„ COLOR 0, 3„ PRINT SPACE$(80);„ LOCATE 1, 1„ PRINT " "; WHOM$; "'s Biorhythm for "; Month$(CalcMonth%); CalcYear%;„ Birthdayline$ = "Birthdate is " + Month$(BirthMonth%) + STR$(BirthDate%) + STR$(BirthYear%)„ LOCATE , 80 - LEN(Birthdayline$)„ PRINT Birthdayline$„ LOCATE 25, 1„ COLOR 0, 2„ PRINT " "; Symbol23$; " PHYSICAL  ";„ COLOR 0, 12„ PRINT " "; Symbol28$; " EMOTIONAL  ";„ COLOR 0, 5„ PRINT " "; Symbol33$; " INTELLECTUAL  ";„ COLOR 0, 3„ PRINT SPC(7); "More BIORHYTHMS? Y/N ";„ COLOR 16„ PRINT "Y"; SPACE$(7);„ LOCATE 13, 9„ COLOR 0, 3„ PRINT CenterLine$; CenterLine$; CenterLine$; "1"„ J% = Month%(CalcMonth%)„ YEAR% = CalcYear%„ GOSUB 2820„ IF CalcMonth% = 2 AND YEAR% = 0 THEN J% = J% + 1„ K% = 1„ C% = 9„2200„ P23 = SIN(2! * PI! * CSNG(C23%) / 23!)„ P28 = SIN(2! * PI! * CSNG(C28%) / 28!)„ P33 = SIN(2! * PI! * CSNG(C33%) / 33!)„ PNN = P23„ GOSUB 2580„ LOCATE INN%, C%„ COLOR 0, 2„ PRINT Symbol23$;„ PNN = P28„ GOSUB 2580„ LOCATE INN%, C%„ COLOR 0, 12„ PRINT Symbol28$;„ PNN = P33„ GOSUB 2580„ LOCATE INN%, C%„ COLOR 0, 5„ PRINT Symbol33$;„ K% = K% + 1„ C% = C% + 2„ C23% = C23% + 1            'next day„„ C28% = C28% + 1„ C33% = C33% + 1„ IF K% <= J% THEN 2200„ COLOR 7, 0„2540„ LOCATE 25, 71„ DateString$ = INPUT$(1)„ DateString$ = UCASE$(DateString$)„ IF DateString$ = CHR$(13) OR DateString$ = "Y" THEN„    RUN 80„ ELSEIF DateString$ = "N" THEN„    Lineout„ ELSEIF DateString$ = "P" THEN„    ON ERROR GOTO PrintError„    CALL PrintScreen„    ON ERROR GOTO 0„ ELSE„    Cuckoo„ END IF„ GOTO 2540„2580„ REM ROUTINE TO COMPUTE ROW NUMBER„ REM„ PSGN = SGN(PNN)„ PTT = PSGN * .05„ IF PTT = 0 THEN PTT = .05„ PQQ = -(PNN + PTT) / .1„ INN% = FIX(PQQ) + 13„ 'SOUND 900, .05„ 'SOUND 37, .05„ Pause 1„ RETURN„„2760„ PRINT DateString$; " is an invalid date, please reenter"; STRING$(20, " ")„ Cuckoo„ RESUME 600„2780„ PRINT DateString$; " is an invalid date, please reenter"; STRING$(20, " ")„ Cuckoo„ RESUME 980„2820„ IF YEAR% MOD 4 <> 0 THEN RETURN   'LEAP YEAR CALCULATION„ IF (YEAR% MOD 100 = 0) AND (YEAR% MOD 400 <> 0) THEN RETURN„ YEAR% = 0„ RETURN„„PrintError:„ CLS„ PRINT "Printer access error."„ END„„DEFINT A-Z„SUB Cuckoo„    'SOUND 750, 1„    'SOUND 550, 1„END SUB„„SUB IDParse (IDLine$, NumberOfNames%, Name$(), MaxNames%) STATIC„ NumberOfNames% = 0: In% = FALSE„ Cl$ = IDLine$„ L = LEN(Cl$)„ FOR i% = 1 TO L„    C$ = MID$(Cl$, i%, 1)„    IF (C$ <> " " AND C$ <> CHR$(9) AND C$ <> "/") THEN„        IF NOT In% THEN„            IF NumberOfNames% = MaxNames% THEN EXIT FOR„            NumberOfNames% = NumberOfNames% + 1„            In% = TRUE„        END IF„        Name$(NumberOfNames%) = Name$(NumberOfNames%) + C$„    ELSE„        In% = FALSE„    END IF„ NEXT i%„ FOR i% = 1 TO NumberOfNames%„    IDLen% = LEN(Name$(i%))„    Big$ = UCASE$(LEFT$(Name$(i%), 1))„    Little$ = LCASE$(MID$(Name$(i%), 2, IDLen%))„    Name$(i%) = Big$ + Little$„ NEXT i%„END SUB„„SUB Lineout STATIC„DIM Lines$(1 TO 24)„   „ Lines$(1) = STRING$(80, CHR$(196))„ Sp% = 2„ Ln% = 76„ FOR i% = 2 TO 21„    Lines$(i%) = SPACE$(Sp%) + STRING$(Ln%, CHR$(196)) + SPACE$(2)„    Sp% = Sp% + 2„    Ln% = Ln% - 4„ NEXT i%„   „ Lines$(22) = SPACE$(39) + CHR$(254) + SPACE$(2)„ Lines$(23) = SPACE$(39) + CHR$(249) + SPACE$(2)„ „ COLOR 0, 0„ X% = 1„ y% = 25„ FOR i% = 1 TO 12„    LOCATE y%, 1„    PRINT STRING$(80, CHR$(32));„    LOCATE X%, 1„    PRINT STRING$(80, CHR$(32));„    Pause 1„    X% = X% + 1„    y% = y% - 1„ NEXT i%„ COLOR 3, 0„ FOR i% = 1 TO 23„    LOCATE 13, 1: PRINT Lines$(i%);„    Pause 1„ NEXT i%„ COLOR 7, 0„ CLS„ LOCATE , , 1, 6, 7„END SUB„„SUB Pause (ticks%)„ DEF SEG = 0„ DO UNTIL TestTick% > ticks%„    LastTick% = GetTick%„    GetTick% = PEEK(&H46C)„    IF LastTick% <> GetTick% THEN„        TestTick% = TestTick% + 1„    END IF„ LOOP„ DEF SEG„END SUB„„SUB PrintScreen„    DIM InRegs AS RegType„    CALL INTERRUPT(5, InRegs, InRegs)„    LPRINT CHR$(12);„END SUB„„Rich Geldreich                 HUFFMAN ENCODER V2.00          HUFFMAN,ENCODER                05-29-92 (00:00:00)    QB, PDS                511  15538    HUFFMAN2.BAS' Huffman encoder v2.00 for PDS & QB4.5„' by Rich Geldreich May 29th, 1992„' Revised for PDS July 13, 1992„' This program is in the public domain. Use it for what you want!„' Just give me credit. If you find any bugs in it, please tell me about„' them.„'„' QB4.5 users: use search & replace and change all of the "SSEG" strings„' in this program to "VARSEG" strings.„' Do not press ctrl+break while this program is compressing! The string„' pointers may change, which may result in an error! Also, to realize„' the true speed of this program you must run it compiled.„' The overall compression of this program is not optimal, because the„' entire tree is sent to the output file. This was done so the decoding„' program can be as simple and fast as possible(the tree takes up about„' 1000 bytes or so; it depends on the input file).„'„' This program is much, much better than my first huffman encoder. It's„' faster, and (should be) easier to understand. The entire program was„' rewritten from scratch. The following changes have been made:„„' The huffman tree is now scanned using a recursive algorithm instead of„' a slow, down-up search.„' Instead of searching for the lowest 2 nodes using a slow, linear search,„' this program uses a much faster presorted table. The entire tree can„' be combined in less than a second on my 286-10!„' The input file is scanned & compressed with a very fast buffer loading„' system, to overcome QB's slowness with binary files.„' A new shell sort is used to sort the node table before the tree is„' combined. A simple bubble sort is then used thereafter.„„DEFINT A-Z„DECLARE SUB InitTree ()„DECLARE SUB MakeSortTable ()„DECLARE SUB CombineTree ()„DECLARE SUB CleanUpTree ()„DECLARE SUB WriteTree ()„„DECLARE SUB SortDistribution2 ()„DECLARE SUB SortDistribution ()„DECLARE SUB GetDistribution ()„DECLARE SUB RecurseTree (Node)„„DECLARE SUB FillBuffer ()„„„CONST True = -1, False = 0„CONST Null = -2„CONST BufferLength = 10000„„CLEAR , , 10000„„DIM SHARED Father(512) AS LONG, LeftSon(512), RightSon(512)„DIM SHARED Index(512), RealIndex, Used(255) AS LONG„DIM SHARED Pointer(255), HighestEntry„DIM SHARED Code(255, 40), CodeLength(255)„DIM SHARED CurrentLength, CurrentCode(40)„„DIM SHARED Buffer$, Address, EndAddress, Bits(8), CurrentByte, CurrentBit„DIM SHARED BufferSeg„„„LOCATE , , 1„„„Bits:„    DATA 1,2,4,8,16,32,64,128,256„„'read the bit masks„RESTORE Bits„FOR A = 0 TO 8: READ Bits(A): NEXT„„'initialize the tree„InitTree„„'initialize the input buffer„Buffer$ = STRING$(BufferLength, 0)„EndAddress = 1: Address = 0„„PRINT "Getting Distribution:";„'open input file„OPEN COMMAND$ FOR BINARY AS #1„'check to see if it exists„IF LOF(1) = 0 THEN„    CLOSE #1„    KILL COMMAND$„    PRINT„    PRINT COMMAND$; " not found"„    END„END IF„'read the input file and gather the distribution of each character„GetDistribution„'make a sorting table„MakeSortTable„'sort the table with the a shell sort„SortDistribution„'combine the tree until there is only one node at the "top"„CombineTree„'work down the tree finding codes which represent each character„TopOfTree = Pointer(0)„CurrentLength = 0„RecurseTree TopOfTree„'for debugging: prints the code for each character„'FOR A = 0 TO 255„'    IF Used(A) > 256 THEN„'        PRINT A;„'        FOR B = 0 TO CodeLength(A)„'            PRINT Code(A, B);„'        NEXT„'        PRINT„'    END IF„'NEXT„'STOP„'"cleans" the tree up so it can be sent as small as possible„CleanUpTree„„CurrentByte = 0: CurrentBit = 0„RealIndex = RealIndex - 1„'open output file„OPEN "output.huf" FOR BINARY AS #2„'kill file if it already exists„IF LOF(2) <> 0 THEN„    CLOSE #2„    KILL "output.huf"„    OPEN "output.huf" FOR BINARY AS #2„END IF„„'put the header„A& = LOF(1)„PUT #2, , A&            'number of bytes in original file„PUT #2, , RealIndex     'number of nodes in tree„Top = Index(TopOfTree)„PUT #2, , Top           'top of tree„„WriteTree               'writes the tree to the output file„„'compresses the input file„PRINT : PRINT "Encoding...": PRINT : PRINT„Ypos = CSRLIN - 2„„SEEK #1, 1„EndAddress = 1: Address = 0„'initialize the output buffer„A$ = STRING$(5000, 0)„A& = SADD(A$)„A& = A& - 65536 * (A& < 0)„OBufferSeg = VARSEG(A$) + (A& \ 16)„OAddress = (A& MOD 16)„OEndAddress = OAddress + 5000„Ostart = OAddress„'start compressing„FOR A& = 1 TO LOF(1)„   „    'get a byte from the input file„    Address = Address + 1„    'if Address=EndBuffer then it's time to fill the input buffer„    IF Address = EndAddress THEN FillBuffer„    B = PEEK(Address)„    'send out all of the bits that represent the input character„    FOR C = 0 TO CodeLength(B)„        IF Code(B, C) THEN„            CurrentByte = CurrentByte * 2 OR 1      'send "1"„        ELSE„            CurrentByte = CurrentByte * 2           'send "0"„        END IF„        CurrentBit = CurrentBit + 1„        'if CurrentBit=8 then we have a complete byte„        IF CurrentBit = 8 THEN„            DEF SEG = OBufferSeg„            POKE OAddress, CurrentByte„            OAddress = OAddress + 1„            'if Oaddress=Oendaddress then it's time to flush the„            'output buffer„            IF OAddress = OEndAddress THEN„                PUT #2, , A$„                B& = SADD(A$)„                B& = B& - 65536 * (B& < 0)„                OBufferSeg = VARSEG(A$) + (B& \ 16)„                OAddress = (B& MOD 16)„                OEndAddress = OAddress + 5000„                Ostart = OAddress„            END IF„            CurrentByte = 0: CurrentBit = 0„            DEF SEG = BufferSeg„        END IF„    NEXT„    'see if it's time to update screen„    PrintCount = PrintCount + 1„    IF PrintCount = 1024 THEN„        PrintCount = 0„        LOCATE Ypos, 1„        PRINT "Bytes In:"; A&; (A& * 100&) \ LOF(1); "%  "„        B& = LOF(2) + OAddress - Ostart„        PRINT "Bytes Out:"; B&; "   "„        PRINT "Compression:"; 100 - (B& * 100&) \ A&; "% ";„    END IF„NEXT„'put whatever is left of the byte buffer into the output buffer„DO UNTIL CurrentBit = 8„    CurrentByte = CurrentByte * 2„    CurrentBit = CurrentBit + 1„LOOP„„DEF SEG = OBufferSeg„POKE OAddress, CurrentByte„A$ = LEFT$(A$, OAddress + 1 - Ostart)„PUT #2, , A$„'report compression„LOCATE Ypos, 1„PRINT "Bytes In:"; LOF(1); SPACE$(16)„PRINT "Bytes Out:"; LOF(2); SPACE$(16)„PRINT "Overall Compression:"; 100 - (LOF(2) * 100&) \ LOF(1); "%"; SPACE$(16);„CLOSE„„END„„'"Cleans" up the tree so it can be sent.„SUB CleanUpTree„    RealIndex = 0„    FOR A = 0 TO 512„        B& = Father(A)„        IF B& <> Null THEN„            IF B& < 256 THEN„                IF Used(B&) > 256 THEN„                    Index(A) = RealIndex„                    RealIndex = RealIndex + 1„                END IF„            ELSEIF B& > 256 THEN„                Index(A) = RealIndex„                RealIndex = RealIndex + 1„            END IF„        END IF„    NEXT„„    FOR A = 0 TO 512„        B& = Father(A)„        IF B& <> Null THEN„            IF B& < 256 THEN„                IF Used(B&) > 256 THEN„                    IF LeftSon(A) <> Null THEN„                        LeftSon(A) = Index(LeftSon(A))„                    END IF„                    IF RightSon(A) <> Null THEN„                        RightSon(A) = Index(RightSon(A))„                    END IF„                END IF„            ELSEIF B& > 256 THEN„                IF LeftSon(A) <> Null THEN„                    LeftSon(A) = Index(LeftSon(A))„                END IF„                IF RightSon(A) <> Null THEN„                    RightSon(A) = Index(RightSon(A))„                END IF„            END IF„        END IF„    NEXT„END SUB„„'Combines the tree until there is only one node at the top.„SUB CombineTree„   „    Parents = HighestEntry + 1„    DO UNTIL Parents = 1„        'sort the current distribution„        SortDistribution2„        'find the lowest 2 entries„        Lowest = Pointer(HighestEntry)„        NextLowest = Pointer(HighestEntry - 1)„        'find new frequency„        NewFrequency& = Father(Lowest) + Father(NextLowest) - 256„        'combine the two nodes„        IF RightSon(Lowest) = Null AND RightSon(NextLowest) = Null THEN„            Father(NextLowest) = NewFrequency&„            RightSon(NextLowest) = LeftSon(Lowest)„            Father(Lowest) = Null„            Parents = Parents - 1„            HighestEntry = HighestEntry - 1„        ELSEIF RightSon(Lowest) = Null AND RightSon(NextLowest) <> Null THEN„            Father(Lowest) = NewFrequency&„            RightSon(Lowest) = NextLowest„            Pointer(HighestEntry - 1) = Pointer(HighestEntry)„            Parents = Parents - 1„            HighestEntry = HighestEntry - 1„        ELSEIF RightSon(Lowest) <> Null AND RightSon(NextLowest) = Null THEN„            Father(NextLowest) = NewFrequency&„            RightSon(NextLowest) = Lowest„            Parents = Parents - 1„            HighestEntry = HighestEntry - 1„        ELSEIF RightSon(Lowest) <> Null AND RightSon(NextLowest) <> Null THEN„            'search for new node„            FOR A = 512 TO 0 STEP -1„                IF Father(A) = Null THEN EXIT FOR„            NEXT„            Father(A) = NewFrequency&„            LeftSon(A) = Lowest„            RightSon(A) = NextLowest„      „            HighestEntry = HighestEntry - 1„            Pointer(HighestEntry) = A„            Parents = Parents - 1„        END IF„    'loop until there is only one node at the top„    LOOP„END SUB„„'Fills the input buffer.„SUB FillBuffer„    GET #1, , Buffer$„„    A& = SADD(Buffer$)„    A& = A& - 65536 * (A& < 0)„    BufferSeg = VARSEG(Buffer$) + (A& \ 16)„    Address = (A& MOD 16)„    EndAddress = Address + BufferLength„    DEF SEG = BufferSeg„„END SUB„„'Scans the input file for its distribution.„SUB GetDistribution„       „    FOR A& = 1 TO LOF(1)„        Address = Address + 1„        IF Address = EndAddress THEN„            FillBuffer„            PRINT ".";„        END IF„        B = PEEK(Address) * 2„        Father(B) = Father(B) + 1„    NEXT„    B = 0„    FOR A = 0 TO 510 STEP 2„        Used(B) = Father(A): B = B + 1„    NEXT„END SUB„„'Initilizes the tree.„SUB InitTree„    B = 0„    FOR A = 0 TO 510 STEP 2„  „        Father(A) = 256„        LeftSon(A) = A + 1„        RightSon(A) = Null„  „        Father(A + 1) = B„        LeftSon(A + 1) = Null„        RightSon(A + 1) = Null„  „        B = B + 1„    NEXT„END SUB„„'Makes a sorting table.„SUB MakeSortTable„    HighestEntry = 0„    FOR A = 0 TO 510 STEP 2„        IF Father(A) > 256 THEN„            Pointer(HighestEntry) = A„            HighestEntry = HighestEntry + 1„        END IF„    NEXT„    HighestEntry = HighestEntry - 1„END SUB„„'Recursive procedure to go down the tree and build up codes„'that represent each character.„SUB RecurseTree (Node)„    'are we at a character?„    IF Father(Node) < 256 THEN„        'yup! CurrentCode() has this character's bit sequence„        Char = Father(Node)„        FOR A = 0 TO CurrentLength - 1„            Code(Char, A) = CurrentCode(A)„        NEXT„        CodeLength(Char) = CurrentLength - 1„    END IF„    'go to the left if there's something there„    IF LeftSon(Node) <> Null THEN„        CurrentCode(CurrentLength) = 1      'add "1" to the current code„        CurrentLength = CurrentLength + 1„        RecurseTree LeftSon(Node)           'go down„        CurrentLength = CurrentLength - 1   'take "1" from the current code„    END IF„    'go to the right if there's something there„    IF RightSon(Node) <> Null THEN„        CurrentCode(CurrentLength) = 0      'add "0" to the current code„        CurrentLength = CurrentLength + 1„        RecurseTree RightSon(Node)          'got down„        CurrentLength = CurrentLength - 1   'take "0" from the current code„    END IF„END SUB„„'A REAL Shell sort follows. It is much faster than the well-known one.„'Sorts the nodes according to the sorting table.„SUB SortDistribution„    Offset = HighestEntry \ 2„    DO„        FOR I = 0 TO HighestEntry - Offset„            IF Father(Pointer(I)) < Father(Pointer(I + Offset)) THEN„                SWAP Pointer(I), Pointer(I + Offset)„                CompareLow = I - Offset„                CompareHigh = I„                DO WHILE CompareLow >= 0„                    IF Father(Pointer(CompareLow)) < Father(Pointer(CompareHigh)) THEN„                        SWAP Pointer(CompareLow), Pointer(CompareHigh)„                        CompareHigh = CompareLow„                        CompareLow = CompareLow - Offset„                    ELSE„                        EXIT DO„                    END IF„                LOOP„            END IF„        NEXT„        Offset = Offset \ 2„    LOOP WHILE Offset > 0„    „„END SUB„„'A simple bubble sort... used while combining the tree.„SUB SortDistribution2„    „    DO„        SwapFlag = False„        FOR A = HighestEntry - 1 TO 0 STEP -1„            IF Father(Pointer(A + 1)) > Father(Pointer(A)) THEN„                SWAP Pointer(A + 1), Pointer(A)„                SwapFlag = True„            END IF„        NEXT„    LOOP WHILE SwapFlag„    „END SUB„„'Writes the tree to disk.„SUB WriteTree„    „„    FOR A = 0 TO 512„        B& = Father(A)„        IF B& <> Null THEN„            IF B& < 256 THEN„                IF Used(B&) > 256 THEN„                    GOSUB SendOne„                    FOR C = 0 TO 7„                        IF (B& AND Bits(C)) > 0 THEN„                            GOSUB SendOne„                        ELSE„                            GOSUB SendZero„                        END IF„                    NEXT„                END IF„            ELSEIF B& > 256 THEN„                GOSUB SendZero„                IF LeftSon(A) <> Null THEN„                    GOSUB SendOne„                    Son = LeftSon(A)„               „                    FOR C = 0 TO 8„                        IF (Son AND Bits(C)) > 0 THEN„                            GOSUB SendOne„                        ELSE„                            GOSUB SendZero„                        END IF„                    NEXT„                ELSE„                    GOSUB SendZero„                END IF„                IF RightSon(A) <> Null THEN„                    GOSUB SendOne„                    Son = RightSon(A)„                   „                    FOR C = 0 TO 8„                        IF (Son AND Bits(C)) > 0 THEN„                            GOSUB SendOne„                        ELSE„                            GOSUB SendZero„                        END IF„                    NEXT„                ELSE„                    GOSUB SendZero„                END IF„            END IF„        END IF„    NEXT„„    EXIT SUB„„SendZero:„    CurrentByte = CurrentByte * 2„    CurrentBit = CurrentBit + 1„    IF CurrentBit = 8 THEN„        A$ = CHR$(CurrentByte)„        PUT #2, , A$„        CurrentByte = 0: CurrentBit = 0„    END IF„RETURN„„SendOne:„   „    CurrentByte = CurrentByte * 2 OR 1„    CurrentBit = CurrentBit + 1„    IF CurrentBit = 8 THEN„        A$ = CHR$(CurrentByte)„        PUT #2, , A$„        CurrentByte = 0: CurrentBit = 0„    END IF„RETURN„„END SUB„Rich Geldreich                 HUFFMAN DECODER V2.00          HUFFMAN,DECODER                05-29-92 (00:00:00)    QB, PDS                166  4588     DECODER.BAS ' Huffman decoder v2.00 for PDS & QB4.5„' by Rich Geldreich May 29th, 1992„' Revised for PDS July 13, 1992„' This program is in the public domain.„' QB4.5 users: use search & replace and change all of the "SSEG" strings„' in this program to "VARSEG" strings.„' Do not press ctrl+break while this program is decompressing! The string„' pointers may change, which may result in an error! Also, to realize„' the true speed of this program you must run it compiled!„' See HUFFMAN2.BAS for info.„„DEFINT A-Z„„DECLARE FUNCTION GetBit ()„DECLARE SUB FillBuff ()„„CONST True = -1, False = 0„CONST Null = -2„CONST BufferLength = 10000„„DIM SHARED Bits(8)„DIM SHARED Father(512)„DIM SHARED LeftSon(512)„DIM SHARED RightSon(512)„„DIM SHARED Buffer$, Address, EndAddress, CurrentByte, BitsIn, BufferSeg„„Bits:„    DATA 1,2,4,8,16,32,64,128,256„„RESTORE Bits„FOR A = 0 TO 8: READ Bits(A): NEXT„'disk buffer„Buffer$ = STRING$(BufferLength, 0): EndAddress = 1: Address = 0: BitsIn = -1„'turn on cursor„LOCATE , , 1„'open the compressed file„OPEN "output.huf" FOR BINARY AS #1„'get the header„GET #1, , FileLength&„GET #1, , RealIndex„GET #1, , TopOfTree„'read in the tree„FOR A = 0 TO RealIndex„    IF GetBit THEN„        Father = 0„        FOR C = 0 TO 7„            IF GetBit THEN Father = Father + Bits(C)„        NEXT„        Father(A) = Father„        RightSon(A) = Null„        LeftSon(A) = Null„    ELSE„        Father(A) = 256„        IF GetBit THEN„            Son = 0„            FOR C = 0 TO 8„                IF GetBit THEN Son = Son + Bits(C)„            NEXT„            LeftSon(A) = Son„        ELSE„            LeftSon(A) = Null„        END IF„        IF GetBit THEN„            Son = 0„            FOR C = 0 TO 8„                IF GetBit THEN Son = Son + Bits(C)„            NEXT„            RightSon(A) = Son„        ELSE„            RightSon(A) = Null„        END IF„    END IF„NEXT„'when PrintCounter=1024 then screen is updated„PrintCounter = 0„'A$ is the output buffer„A$ = STRING$(5000, 0)„A& = SADD(A$)„A& = A& - 65536 * (A& < 0)„OutputSeg = VARSEG(A$) + (A& \ 16)„OAddress = (A& MOD 16)„OEndAddress = OAddress + 5000„OStart = OAddress„'start decoding„PRINT "Decoding:";„Xpos = POS(0): Ypos = CSRLIN„'open output file„OPEN COMMAND$ FOR BINARY AS #2„'decode each byte„FOR CurrentByte& = 1 TO FileLength&„    DEF SEG = BufferSeg„    'start at top of tree„    A = TopOfTree„    'keep on getting bits until a character is found„    DO„        'if BitsIn<0 then time to fill byte buffer„        IF BitsIn < 0 THEN„            Address = Address + 1„            'if Address=EndBuffer then time to fill disk buffer„            IF Address = EndAddress THEN„                FillBuff„            END IF„            CurrentByte = PEEK(Address): BitsIn = 7„        END IF„        'see if we go left or right„        IF (CurrentByte AND Bits(BitsIn)) THEN A = LeftSon(A) ELSE A = RightSon(A)„        BitsIn = BitsIn - 1„        F = Father(A)„        'loop until an ascii character is found„    LOOP UNTIL F < 256„    'put byte into output buffer„    DEF SEG = OutputSeg„    POKE OAddress, F„    OAddress = OAddress + 1„    IF OAddress = OEndAddress THEN„        PUT #2, , A$„        A& = SADD(A$)„        A& = A& - 65536 * (A& < 0)„        OutputSeg = VARSEG(A$) + (A& \ 16)„        OAddress = (A& MOD 16)„        OEndAddress = OAddress + 5000„        OStart = OAddress„    END IF„    'see if time to update the screen„    PrintCounter = PrintCounter + 1„    IF PrintCounter = 1024 THEN„        PrintCounter = 0„        LOCATE Ypos, Xpos„        PRINT (CurrentByte& * 100) \ FileLength&; "%";„    END IF„'loop until all of the characters have been restored„NEXT„'save whatever is currently in the output buffer„A$ = LEFT$(A$, OAddress - OStart)„PUT #2, , A$„CLOSE„'all done„LOCATE Ypos, Xpos„PRINT " done."„„END„„'fills the input buffer„SUB FillBuff„    GET #1, , Buffer$„    A& = SADD(Buffer$)„    A& = A& - 65536 * (A& < 0)„    BufferSeg = VARSEG(Buffer$) + (A& \ 16)„    Address = (A& MOD 16)„    EndAddress = Address + BufferLength„    DEF SEG = BufferSeg„END SUB„„'gets one bit from the input file(only used when the tree„'is read in)„FUNCTION GetBit STATIC„    IF BitsIn < 0 THEN„        Address = Address + 1„        IF Address = EndAddress THEN„            FillBuff„        END IF„        CurrentByte = PEEK(Address): BitsIn = 7„    END IF„    GetBit = (CurrentByte AND Bits(BitsIn)): BitsIn = BitsIn - 1„END FUNCTION„Rich Geldreich                 LZW COMPRESSOR                 LZW,COMPRESSOR                 Year of 1992 (00:00:00)QB, PDS                356  10822    LZWC.BAS    'Experimental LZW Compressor for PDS / QuickBASIC 4.5„'By Rich Geldreich 1992„'This program is in the public domain: use as you wish!„'(QB4.5 users: Use search & replace to change all of the "SSEG" strings„'to "VARSEG" strings in this program.)„'If you have and questions or problems, write/call:„„'Rich Geldreich„'410 Market St.„'Gloucester City, NJ 08030„'(609)-742-8752„'„' Do not press ctrl+break while this program is decompressing! The string„' pointers may change, which may result in an error!„„DEFINT A-Z„DECLARE SUB PutByte (A)„DECLARE SUB PutCode (A)„DECLARE SUB Rebuild.Table (New.Entries)„DECLARE FUNCTION GetByte ()„DECLARE SUB Hash (Prefix, Suffix, Index, Found)„„CONST True = -1, False = 0„„DIM SHARED Prefix(6576), Suffix(6576), Code(6576)„DIM SHARED Used(4096)„„DIM SHARED InBuffer$, IAddress, IEndAddress, Iseg„DIM SHARED OutBuffer$, OStartAddress, OAddress, OEndAddress, Oseg„„DIM SHARED CodeSize, CurrentBit, Char&„DIM SHARED Shift(12) AS LONG„„„FOR A = 0 TO 12: READ Shift(A): NEXT„DATA 1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192„„„LOCATE , , 1„IF POS(0) <> 1 THEN PRINT„„„InBuffer$ = STRING$(4000, 0)   'input buffer„OutBuffer$ = STRING$(4000, 0)  'output buffer„„„A& = SADD(OutBuffer$)„A& = A& - 65536 * (A& < 0)„Oseg = VARSEG(OutBuffer$) + (A& \ 16)     'Segment of buffer„OAddress = (A& MOD 16)                  'Current address in disk buffer„OEndAddress = OAddress + 4000           'End address of  buffer„OStartAddress = OAddress                'Start of buffer„„'Open input file„File$ = COMMAND$„IF File$ = "" THEN LINE INPUT "File to compress? "; File$: File$ = LTRIM$(RTRIM$(File$))„IF File$ = "" THEN END„OPEN File$ FOR BINARY AS #1„FileLength& = LOF(1)„'Is it there?„IF FileLength& = 0 THEN„    CLOSE #1„    KILL COMMAND$„    PRINT COMMAND$; " not found"„    END„END IF„'Open output file„OPEN "output.lzw" FOR BINARY AS #2„'Is it already there?„IF LOF(2) <> 0 THEN„    'Kill output file and reopen it„    CLOSE #2„    KILL "output.lzw"„    OPEN "output.lzw" FOR BINARY AS #2„END IF„'CurrentLoc& - position in input file„CurrentLoc& = 2„„'Compression codes:„'Code 256 = end of file„'Code 257 = increase code size„'Code 258 = rebuild table„'Code 259 - 4095 = available for strings„StartCode = 259                 'First LZW code that is available„NextCode = 259„'The maximum code that can be represented in 9 bits„MaxCode = 512„'Start with 9 bit code size„CodeSize = 9„'Current bit position in Char& - use for PutCode„CurrentBit = 0„'Char& is a temporary buffer; accumulates codes from main program and„'puts them in the output file once complete bytes have been„'built„Char& = 0„„GOSUB ClearTable„'Get first byte from file(it's a special case)„Prefix = GetByte„„PRINT "LZW Compressor For QuickBASIC 4.5"„PRINT "By Richard Geldreich June 2nd, 1992"„PRINT "Compressing "; File$„PRINT : PRINT : PRINT„'First line to start updating statistics„Y = CSRLIN - 3„'Main compression loop„DO„    DO„     „        IF CurrentLoc& > FileLength& THEN„            PutCode Prefix„            PutCode 256„            PutCode 0: PutCode 0„            OutBuffer$ = LEFT$(OutBuffer$, OAddress - OStartAddress)„            LOCATE Y, 1„            PRINT "Bytes In:"; CurrentLoc&; (100& * CurrentLoc&) \ FileLength&; "%"„            BytesOut& = LOF(2) + (OAddress - OStartAddress)„            PRINT "Bytes Out:"; BytesOut&„            PRINT "Total Compression:"; 100 - ((100& * BytesOut&) \ CurrentLoc&); "%                         ";„            PUT #2, , OutBuffer$„            CLOSE„            END„        ELSE„            „            Suffix = GetByte„            CurrentLoc& = CurrentLoc& + 1„            'We now have a Prefix:Suffix to search for.„            'If the search fails, put the Prefix in the output file„            'and set the Prefix equal to the character which caused„            'the failure.„„            Hash Prefix, Suffix, Index, Found„            IF Found = True THEN„                Prefix = Code(Index)„                'update how many times this string was used„                Used(Prefix) = Used(Prefix) + 1„            END IF„        END IF„    LOOP WHILE Found = True„„    'only increase the code size when required„    DO WHILE Prefix >= MaxCode AND CodeSize < 12„        PutCode 257„        MaxCode = MaxCode * 2„        CodeSize = CodeSize + 1„    LOOP„   „    PutCode Prefix„„    'Put the new string into the hash table.„    Prefix(Index) = Prefix„    Suffix(Index) = Suffix„    Code(Index) = NextCode  'remember this string's code„„    'Prefix is now equal to the character that caused the failure now.„    Prefix = Suffix„ „    NextCode = NextCode + 1„    'if there are too many strings then rebuild the encoding table„    IF NextCode > 4096 THEN„           „        PutCode 258 'send rebuild table code to decompressor„„        Rebuild.Table New.Entries„        NextCode = New.Entries + StartCode„       „        IF NextCode > 4096 THEN„            GOSUB ClearTable„            NextCode = StartCode        'reset NextCode to top of tree„        END IF„„        CodeSize = 9„        MaxCode = 512„„        „    END IF„„    'let the impatient user know we haven't hung up (yet!)„    PrintCounter = PrintCounter + 1     'see if time to update the„    IF PrintCounter = 512 THEN          'screen„        LOCATE Y, 1„        PRINT "Bytes In:"; CurrentLoc&; (100& * CurrentLoc&) \ FileLength&; "%"„        BytesOut& = LOF(2) + (OAddress - OStartAddress)„        PRINT "Bytes Out:"; BytesOut&„        PRINT "Compression:"; 100 - ((100& * BytesOut&) \ CurrentLoc&); "%  "; "CodeSize:"; CodeSize; "NextCode:"; NextCode; "   ";„        PrintCounter = 0„    END IF„LOOP„'clears the hash table„ClearTable:„    FOR A = 0 TO 6576„        Prefix(A) = -1„        Suffix(A) = -1„        Code(A) = -1„    NEXT„RETURN„„'Reads one byte from the input buffer, and fills the buffer if it's emty.„FUNCTION GetByte STATIC„    IF IAddress = IEndAddress THEN„        GET #1, , InBuffer$„        A& = SADD(InBuffer$)„        A& = A& - 65536 * (A& < 0)„        Iseg = VARSEG(InBuffer$) + (A& \ 16)„        IAddress = (A& MOD 16)„        IEndAddress = IAddress + 4000„    END IF„    DEF SEG = Iseg„    GetByte = PEEK(IAddress)„    IAddress = IAddress + 1„END FUNCTION„„'Attempts to finds a prefix:suffix string.„SUB Hash (Prefix, Suffix, Index, Found)„    „    Index = (Prefix * 256& XOR Suffix) MOD 6577 'XOR hashing„    IF Index = 0 THEN  'is Index lucky enough to be 0?„        Offset = 1     'Set offset to 1, because 6577-0=6577„    ELSE„        Offset = 6577 - Index„    END IF„    DO 'until we find a match or don't„        IF Code(Index) = -1 THEN      'is there nothing here?„            Found = False             'yup, not found„            EXIT SUB„        'is this entry what we're looking for?„        ELSEIF Prefix(Index) = Prefix AND Suffix(Index) = Suffix THEN„            Found = True              'yup, found„            EXIT SUB„        ELSE 'retry until we find what were looking for or we find a blank„             'entry„            Index = Index - Offset„            IF Index < 0 THEN 'is index too far down?„                Index = Index + 6577 'yup, bring it up then„            END IF„        END IF„    LOOP„END SUB„„'Throws a byte into the output buffer and writes the buffer if it's full.„SUB PutByte (A) STATIC„    IF OAddress = OEndAddress THEN„        PUT #2, , OutBuffer$„        OAddress = OStartAddress„    END IF„    DEF SEG = Oseg„    POKE OAddress, A„    OAddress = OAddress + 1„END SUB„„'Throws one multi-bit code to the output file.„SUB PutCode (A) STATIC„    SHARED MaxCode„    IF A >= MaxCode THEN STOP„„    Char& = Char& + A * Shift(CurrentBit)„    CurrentBit = CurrentBit + CodeSize„    DO WHILE CurrentBit > 7„        PutByte Char& AND 255„        Char& = Char& \ 256„        CurrentBit = CurrentBit - 8„    LOOP„END SUB„„'This is the "experimental" part of the program. This procedure eliminates„'any strings which are not used in the encoding table: the usual result of„'doing this is greater compression.„'It isn't documented well yet... I'm still working on it.„SUB Rebuild.Table (New.Entries)„    DIM P(4096), S(4096), U(4096) AS LONG, Pn(4096), C(4096)„    DIM Location(4096)„   „    SHARED StartCode, MaxCode, Prefix„    Num.Entries = 0„    „    FOR A = 0 TO 6576„        C = Code(A)„        IF C <> -1 THEN 'valid code?„            IF Used(C) > 0 THEN 'was it used at all?„                Used(C) = 0„                P = Prefix(A): S = Suffix(A)„                P(Num.Entries) = P          'put it into a temporary table„                S(Num.Entries) = S„                U(Num.Entries) = P * 4096& + S„                C(C) = Num.Entries„                Num.Entries = Num.Entries + 1„            END IF„        END IF„    NEXT„    „„    Num.Entries = Num.Entries - 1„    FOR A = 0 TO Num.Entries„        Pn(A) = A„    NEXT„        'sort the table according to it's prefix:suffix„    Mid = Num.Entries \ 2„    DO„        FOR A = 0 TO Num.Entries - Mid„            IF U(Pn(A)) > U(Pn(A + Mid)) THEN„                SWAP Pn(A), Pn(A + Mid)„                Swap.Flag = True„                CompareLow = A - Mid„                CompareHigh = A„                DO WHILE CompareLow >= 0„                    IF U(Pn(CompareLow)) > U(Pn(CompareHigh)) THEN„                        SWAP Pn(CompareLow), Pn(CompareHigh)„                        CompareHigh = CompareLow„                        CompareLow = CompareLow - Mid„                    ELSE„                        EXIT DO„                    END IF„                LOOP„               „            END IF„        NEXT„        „        Mid = Mid \ 2„    LOOP WHILE Mid > 0„    „    „    FOR A = 0 TO Num.Entries„        Location(Pn(A)) = A„    NEXT„    'clear the old hash table„    FOR A = 0 TO 6576„        Prefix(A) = -1„        Suffix(A) = -1„        Code(A) = -1„    NEXT„    „    'put each prefix:suffix into the hash table„    FOR A1 = 0 TO Num.Entries„        A = Pn(A1)„       „        P = P(A)„        S = S(A)„        IF P >= StartCode THEN 'is it pointing twards a string?„            P = StartCode + Location(C(P)) 'yup; update the pointer„        END IF„        IF S >= StartCode THEN„            S = StartCode + Location(C(S))„        END IF„        'where does this prefix:suffix go?„        Hash P, S, Index, 0„        'put it there„        Prefix(Index) = P„        Suffix(Index) = S„        Code(Index) = A1 + StartCode„        „    NEXT„    '# of entries in the hash table now„    New.Entries = Num.Entries + 1„END SUB„„Rich Geldreich                 LZW DECOMPRESSOR               LZW,DECOMPRESSOR               Year of 1992 (00:00:00)QB, PDS                292  7971     LZWD.BAS    'Experimental LZW Decompressor for PDS / QuickBASIC 4.5„'By Rich Geldreich 1992„'This program is in the public domain: use as you wish!„'(QB4.5 users: Use search & replace to change all of the "SSEG" strings„'to "VARSEG" strings in this program.)„'If you have and questions or problems, write/call:„„'Rich Geldreich„'410 Market St.„'Gloucester City, NJ 08030„'(609)-742-8752„'„' Do not press ctrl+break while this program is decompressing! The string„' pointers may change, which may result in an error!„„DEFINT A-Z„DECLARE SUB PutByte (A)„DECLARE SUB Rebuild.Table (New.Entries)„DECLARE FUNCTION GetCode ()„DECLARE FUNCTION GetByte ()„CONST True = -1, False = 0„„'Prefix & Suffix of each code„DIM SHARED Prefix(4096), Suffix(4096), Used(4096)„DIM OutCode(4096)               'simulates a hardware stack„„'Input and output disk buffers„DIM SHARED InBuffer$, IAddress, IEndAddress, Iseg„DIM SHARED OutBuffer$, OStartAddress, OAddress, OEndAddress, Oseg„„'Used for screen updating„DIM SHARED BytesIn&„„'Powers of two„DIM SHARED Powers(7)„DIM SHARED LongPowers(12) AS LONG„'Mask for each codesize„DIM SHARED Masks(12)„'Current codesize„DIM SHARED CodeSize„'Initialize each array„FOR A = 0 TO 7: Powers(A) = 2 ^ A: NEXT„FOR A = 0 TO 12: LongPowers(A) = 2 ^ A: NEXT„FOR A = 1 TO 12: Masks(A) = (2 ^ A) - 1: NEXT„'Turn on cursor„LOCATE , , 1„'Initialize each disk buffer„InBuffer$ = STRING$(5000, 0)„OutBuffer$ = STRING$(5000, 0)„'Find address of output buffer„A& = SADD(OutBuffer$)„A& = A& - 65536 * (A& < 0)„Oseg = VARSEG(OutBuffer$) + (A& \ 16)„OAddress = (A& MOD 16)„OEndAddress = OAddress + 5000„OStartAddress = OAddress„BytesIn& = 0„'Open files„OPEN "OUTPUT.LZW" FOR BINARY AS #1„OPEN COMMAND$ FOR BINARY AS #2„„'First code is 259„FreeCode = 259„StartCode = 259„'First codesize is 9 bits„CodeSize = 9„'Get First code(special case)„Code = GetCode„CurCode = Code„OldCode = Code„FinChar = Code„PutByte FinChar„„FileLength& = LOF(1)„IF POS(0) <> 1 THEN PRINT„PRINT "LZW Decompressor in QuickBASIC 4.5"„PRINT "By Richard Geldreich June 2nd, 1992"„PRINT "Decompressing:";„Y = CSRLIN: X = POS(0)„'Main decompression loop„DO„    'Update screen every 1,024 codes„    OutputCounter = OutputCounter + 1„    IF OutputCounter = 1024 THEN„        LOCATE Y, X„        PRINT (100& * BytesIn&) \ FileLength&; "% done";„        OutputCounter = 0„    END IF„„GetCode:„    'Get code from input file„    Code = GetCode„    'Process code„    SELECT CASE Code„    'End of file code„    CASE 256„        OutBuffer$ = LEFT$(OutBuffer$, OAddress - OStartAddress)„        PUT #2, , OutBuffer$„        LOCATE Y, X„        PRINT " done       "„        CLOSE : END„    'Increase code size code„    CASE 257„        CodeSize = CodeSize + 1„    CASE 258„        Rebuild.Table New.Entries„        FreeCode = New.Entries + StartCode„        CodeSize = 9„„        IF FreeCode > 4096 THEN„            FreeCode = StartCode„            Code = GetCode„             „            CurCode = Code„            OldCode = Code„             „            FinChar = Code„            PutByte FinChar„        ELSE„            'prevents an invalid code from entering the table„            Ignore.Next = True„        END IF„„    'Process a code„    CASE ELSE„       „        CurCode = Code„        InCode = Code„        'Do we have this string yet?„        IF Code >= FreeCode THEN„            'If Code>FreeCode then stop decompression: this can't be right!„            IF Code > FreeCode THEN PRINT "??BAD LZW CODE IN FILE": CLOSE : END„            'Trick decompressor to use last code„            „            Used(Code) = Used(Code) + 1„            CurCode = OldCode„            OutCode(OutCount) = FinChar„            OutCount = OutCount + 1„        END IF„        „        'Does this code represent a string?„        IF CurCode >= StartCode THEN„            'Get each character from the table and push it onto the stack„            „            DO„                Used(CurCode) = Used(CurCode) + 1„                OutCode(OutCount) = Suffix(CurCode)„                OutCount = OutCount + 1„                CurCode = Prefix(CurCode)„            'keep on doing this until we have a normal character„            LOOP UNTIL CurCode <= 255„        END IF„        FinChar = CurCode„        OutCode(OutCount) = FinChar„        'Pop all the codes of the stack and put them into the output file„        FOR A = OutCount TO 0 STEP -1„            PutByte OutCode(A)„        NEXT„        OutCount = 0„        'Put the new string into the table„        IF Ignore.Next THEN„            Ignore.Next = False„        ELSE„            Prefix(FreeCode) = OldCode„            Suffix(FreeCode) = FinChar„            FreeCode = FreeCode + 1„        END IF„        OldCode = InCode„    END SELECT„LOOP„„FUNCTION GetByte STATIC„    IF IAddress = IEndAddress THEN„        GET #1, , InBuffer$„        A& = SADD(InBuffer$)„        A& = A& - 65536 * (A& < 0)„        Iseg = VARSEG(InBuffer$) + (A& \ 16)„        IAddress = (A& MOD 16)„        IEndAddress = IAddress + 5000„    END IF„    DEF SEG = Iseg„    GetByte = PEEK(IAddress)„    BytesIn& = BytesIn& + 1„    IAddress = IAddress + 1„END FUNCTION„„FUNCTION GetCode STATIC„    IF BitsLeft = 0 THEN„        TempChar = GetByte„        BitsLeft = 8„    END IF„    WorkCode& = TempChar \ Powers(8 - BitsLeft)„    DO WHILE CodeSize > BitsLeft„        TempChar = GetByte„        WorkCode& = WorkCode& OR TempChar * LongPowers(BitsLeft)„        BitsLeft = BitsLeft + 8„    LOOP„    BitsLeft = BitsLeft - CodeSize„    GetCode = WorkCode& AND Masks(CodeSize)„END FUNCTION„„SUB PutByte (A) STATIC„    IF OAddress = OEndAddress THEN„        PUT #2, , OutBuffer$„        OAddress = OStartAddress„    END IF„    DEF SEG = Oseg„    POKE OAddress, A„    OAddress = OAddress + 1„END SUB„„SUB Rebuild.Table (New.Entries)„    DIM P(4095), S(4095), U(4095) AS LONG, Pn(4095), C(4095)„    DIM location(4095)„   „    SHARED StartCode, OldCode„   „    Num.Entries = 0„    FOR A = StartCode TO 4095„        IF Used(A) > 0 THEN„            Used(A) = 0„            P = Prefix(A): S = Suffix(A)„            P(Num.Entries) = P„            S(Num.Entries) = S„            U(Num.Entries) = P * 4096& + S„            C(A) = Num.Entries„            Num.Entries = Num.Entries + 1„        END IF„    NEXT„  „„    Num.Entries = Num.Entries - 1„    FOR A = 0 TO Num.Entries„        Pn(A) = A„    NEXT„  „    Mid = Num.Entries \ 2„    DO„        FOR A = 0 TO Num.Entries - Mid„            IF U(Pn(A)) > U(Pn(A + Mid)) THEN„                SWAP Pn(A), Pn(A + Mid)„                Swap.Flag = True„                CompareLow = A - Mid„                CompareHigh = A„                DO WHILE CompareLow >= 0„                    IF U(Pn(CompareLow)) > U(Pn(CompareHigh)) THEN„                        SWAP Pn(CompareLow), Pn(CompareHigh)„                        CompareHigh = CompareLow„                        CompareLow = CompareLow - Mid„                    ELSE„                        EXIT DO„                    END IF„                LOOP„              „            END IF„        NEXT„       „        Mid = Mid \ 2„    LOOP WHILE Mid > 0„   „   „    FOR A = 0 TO Num.Entries„        location(Pn(A)) = A„    NEXT„   „    „   „    FOR A1 = 0 TO Num.Entries„        A = Pn(A1)„     „        P = P(A)„        S = S(A)„        IF P >= StartCode THEN„            P = StartCode + location(C(P))„        END IF„        IF S >= StartCode THEN„            S = StartCode + location(C(S))„        END IF„       „        Prefix(A1 + StartCode) = P„        Suffix(A1 + StartCode) = S„       „    NEXT„    „    IF OldCode >= StartCode THEN„        OldCode = StartCode + location(C(OldCode))„    END IF„   „    New.Entries = Num.Entries + 1„„END SUB„„Zack Jones                     FAST SORTING ALGORITHMS        FAST,SORTING,ALGORITHMS        11-07-92 (13:59:00)    QB, QBasic, PDS        147  3722     FASTSORT.BAS'QuickSort2 - QuickSort iterative (rather than recursive) by Cornel Huth.„„DEFINT A-Z„DECLARE SUB Fastsorti (inarray%(), lower%, upper%)„DECLARE SUB QuickSort2 (sortarray%(), lower%, upper%)„„TYPE stacktype 'for QuickSort2„  low AS INTEGER„  hi AS INTEGER„END TYPE„CLS„FOR a = 1 TO 12„  count = 2 ^ a„  REDIM temp(1 TO count) AS INTEGER„  ' Generate a random array to test the sort.„„  RANDOMIZE a„  FOR b = 1 TO count„    temp(b) = RND * 32766 + 1„  NEXT b„„  s1# = TIMER„  DO„    start# = TIMER 'Wait for the beginning of a clock cycle.„  LOOP WHILE s1# = start#„  Fastsorti temp(), 1, count„  e1# = TIMER„„  'Make the original arrays identical (no cheating! ;^)„„  RANDOMIZE a„  FOR b = 1 TO count„    temp(b) = RND * 32766 + 1„  NEXT b„„  s2# = TIMER„  DO„    start# = TIMER„  LOOP WHILE s2# = start#„  QuickSort2 temp(), 1, count„  e2# = TIMER„„  ' A test to make sure it sorted it correctly.„  '„  'FOR chk = 1 TO Count„  '  PRINT Temp(chk);„  'NEXT chk„  'PRINT„„  PRINT "FastSort: took"; e1# - s1#;„  PRINT TAB(30); "seconds to sort"; count; "entries."„  PRINT "MiscSort: took"; e2# - s2#;„  PRINT TAB(30); "seconds to sort"; count; "entries."„NEXT a„„SUB Fastsorti (inarray%(), lower%, upper%)„„  ' This routine was writen by Ryan Wellman.„  ' Copyright 1992, Ryan Wellman, all rights reserved.„  ' Released as Freeware October 22, 1992.„  ' You may freely use, copy & modify this code as you see„  ' fit. Under the condition that I am given credit for„  ' the original sort routine, and partial credit for modified„  ' versions of the routine.„„  ' Thanks to Richard Vannoy who gave me the idea to compare„  ' entries further than 1 entry away.„„  increment = (upper + lower)„  l2 = lower - 1„„  DO„    increment = increment \ 2„    i2 = increment + l2„    FOR index = lower TO upper - increment„      IF inarray(index) > inarray(index + increment) THEN„        SWAP inarray(index), inarray(index + increment)„        IF index > i2 THEN„          cutpoint = index„          stopnow = 0„          DO„            index = index - increment„            IF inarray(index) > inarray(index + increment) THEN„              SWAP inarray(index), inarray(index + increment)„            ELSE„              stopnow = -1„              index = cutpoint„            END IF„          LOOP UNTIL stopnow„        END IF„      END IF„    NEXT index„  LOOP UNTIL increment <= 1„END SUB„„SUB QuickSort2 (sortarray(), lower%, upper%)„  'QuickSort iterative (rather than recursive) by Cornel Huth„  DIM lstack(1 TO 128) AS stacktype   'our stack„  DIM sp AS INTEGER                   'out stack pointer„  sp = 1„  'maxsp = sp„  lstack(sp).low = lower%„  lstack(sp).hi = upper%„  sp = sp + 1„  DO„    sp = sp - 1„    low = lstack(sp).low„    hi = lstack(sp).hi„    DO„      i = low„      j = hi„      mid = (low + hi) \ 2„      compare = sortarray(mid)„      DO„        DO WHILE sortarray(i) < compare„          i = i + 1„        LOOP„        DO WHILE sortarray(j) > compare„          j = j - 1„        LOOP„        IF i <= j THEN„          SWAP sortarray(i), sortarray(j)„          i = i + 1„          j = j - 1„        END IF„      LOOP WHILE i <= j„      IF j - low < hi - i THEN„        IF i < hi THEN„„          lstack(sp).low = i„          lstack(sp).hi = hi„          sp = sp + 1„        END IF„        hi = j„      ELSE„        IF low < j THEN„          lstack(sp).low = low„          lstack(sp).hi = j„          sp = sp + 1„        END IF„        low = i„      END IF„    LOOP WHILE low < hi„    'IF sp > maxsp THEN maxsp = sp„  LOOP WHILE sp <> 1„  'PRINT "MAX SP"; maxsp„END SUB„Unknown Author(s)              MAZE GENERATOR                 MAZE,GENERATOR                 Unknown Date (00:00:00)QB, QBasic, PDS        294  11835    MAZEGEN.BAS 1010 KEY OFF„1020 DEFINT A-Z„1030 X.MAX=95„1040 Y.MAX=49„1050 DIM DELTA.X(6,720)„1060 DIM DELTA.Y(6,720)„1070 DIM PAGE(Y.MAX,X.MAX)„1080 DIM R.N(8)„1090 DIM STACK.1(Y.MAX*X.MAX)„1100 DIM STACK.2(Y.MAX*X.MAX)„1110 CLS„1120 PRINT "                                 Maze Generator"„1130 PRINT„1140 PRINT„1150 PRINT„1160 PRINT "     Random number seed?  ";„1170 LINE INPUT SEED$„1180 R.N.INDEX.1=1„1190 FOR R.N.INDEX.2=1 TO LEN(SEED$)„1200   TEM.INT=ASC(MID$(SEED$,R.N.INDEX.2,1))„1210   R.N(R.N.INDEX.1)=TEM.INT„1220   R.N.INDEX.1=R.N.INDEX.1+1„1230 NEXT R.N.INDEX.2„1240 R.N.INDEX.2=8„1250 WHILE (R.N.INDEX.1 > 1)„1260   R.N.INDEX.1=R.N.INDEX.1-1„1270   R.N(R.N.INDEX.2)=R.N(R.N.INDEX.1)„1280   R.N.INDEX.2=R.N.INDEX.2-1„1290 WEND„1300 WHILE (R.N.INDEX.2 >= 1)„1310   R.N(R.N.INDEX.2)=367„1320   R.N.INDEX.2=R.N.INDEX.2-1„1330 WEND„1340 DELTA.Y(1,1)=-1„1350 DELTA.X(1,1)=-2„1360 DELTA.Y(2,1)=1„1370 DELTA.X(2,1)=-2„1380 DELTA.Y(3,1)=-2„1390 DELTA.X(3,1)=0„1400 DELTA.Y(4,1)=2„1410 DELTA.X(4,1)=0„1420 DELTA.Y(5,1)=-1„1430 DELTA.X(5,1)=2„1440 DELTA.Y(6,1)=1„1450 DELTA.X(6,1)=2„1460 DELTA.INDEX.2=0„1470 FOR DELTA.INDEX.1A=1 TO 6„1480   FOR DELTA.INDEX.1B=1 TO 6„1490     IF DELTA.INDEX.1A = DELTA.INDEX.1B THEN 1850„1500       FOR DELTA.INDEX.1C=1 TO 6„1510         IF DELTA.INDEX.1A = DELTA.INDEX.1C THEN 1840„1520         IF DELTA.INDEX.1B = DELTA.INDEX.1C THEN 1840„1530           FOR DELTA.INDEX.1D=1 TO 6„1540             IF DELTA.INDEX.1A = DELTA.INDEX.1D THEN 1830„1550             IF DELTA.INDEX.1B = DELTA.INDEX.1D THEN 1830„1560             IF DELTA.INDEX.1C = DELTA.INDEX.1D THEN 1830„1570               FOR DELTA.INDEX.1E=1 TO 6„1580                 IF DELTA.INDEX.1A = DELTA.INDEX.1E THEN 1820„1590                 IF DELTA.INDEX.1B = DELTA.INDEX.1E THEN 1820„1600                 IF DELTA.INDEX.1C = DELTA.INDEX.1E THEN 1820„1610                 IF DELTA.INDEX.1D = DELTA.INDEX.1E THEN 1820„1620                   FOR DELTA.INDEX.1F=1 TO 6„1630                     IF DELTA.INDEX.1A = DELTA.INDEX.1F THEN 1810„1640                     IF DELTA.INDEX.1B = DELTA.INDEX.1F THEN 1810„1650                     IF DELTA.INDEX.1C = DELTA.INDEX.1F THEN 1810„1660                     IF DELTA.INDEX.1D = DELTA.INDEX.1F THEN 1810„1670                     IF DELTA.INDEX.1E = DELTA.INDEX.1F THEN 1810„1680                         DELTA.INDEX.2=DELTA.INDEX.2+1„1690                         DELTA.X(DELTA.INDEX.1A,DELTA.INDEX.2)=DELTA.X(1,1)„1700                         DELTA.Y(DELTA.INDEX.1A,DELTA.INDEX.2)=DELTA.Y(1,1)„1710                         DELTA.X(DELTA.INDEX.1B,DELTA.INDEX.2)=DELTA.X(2,1)„1720                         DELTA.Y(DELTA.INDEX.1B,DELTA.INDEX.2)=DELTA.Y(2,1)„1730                         DELTA.X(DELTA.INDEX.1C,DELTA.INDEX.2)=DELTA.X(3,1)„1740                         DELTA.Y(DELTA.INDEX.1C,DELTA.INDEX.2)=DELTA.Y(3,1)„1750                         DELTA.X(DELTA.INDEX.1D,DELTA.INDEX.2)=DELTA.X(4,1)„1760                         DELTA.Y(DELTA.INDEX.1D,DELTA.INDEX.2)=DELTA.Y(4,1)„1770                         DELTA.X(DELTA.INDEX.1E,DELTA.INDEX.2)=DELTA.X(5,1)„1780                         DELTA.Y(DELTA.INDEX.1E,DELTA.INDEX.2)=DELTA.Y(5,1)„1790                         DELTA.X(DELTA.INDEX.1F,DELTA.INDEX.2)=DELTA.X(6,1)„1800                         DELTA.Y(DELTA.INDEX.1F,DELTA.INDEX.2)=DELTA.Y(6,1)„1810                   NEXT DELTA.INDEX.1F„1820               NEXT DELTA.INDEX.1E„1830           NEXT DELTA.INDEX.1D„1840       NEXT DELTA.INDEX.1C„1850   NEXT DELTA.INDEX.1B„1860 NEXT DELTA.INDEX.1A„1870 Y.OUT.MOD.4=1„1880 FOR Y.OUT=1 TO Y.MAX„1890   IF Y.OUT.MOD.4 <> 1 THEN 2030„1900     X.OUT.MOD.8=1„1910     FOR X.OUT=1 TO X.MAX„1920       IF ((X.OUT.MOD.8 = 0) AND (Y.OUT <> 1) AND (Y.OUT <> Y.MAX)) THEN 1980„1930       IF X.OUT.MOD.8 = 3 THEN 1980„1940       IF X.OUT.MOD.8 = 4 THEN 1980„1950       IF X.OUT.MOD.8 = 5 THEN 1980„1960         PAGE(Y.OUT,X.OUT)=0„1970       GOTO 1990„1980         PAGE(Y.OUT,X.OUT)=1„1990       X.OUT.MOD.8=X.OUT.MOD.8+1„2000       IF X.OUT.MOD.8 >= 8 THEN X.OUT.MOD.8=0„2010     NEXT X.OUT„2020   GOTO 2260„2030     IF ((Y.OUT.MOD.4 <> 0) AND (Y.OUT.MOD.4 <> 2)) THEN 2140„2040       X.OUT.MOD.8=1„2050       FOR X.OUT=1 TO X.MAX„2060         IF ((X.OUT.MOD.8 = 2) OR (X.OUT.MOD.8 = 6)) THEN 2090„2070           PAGE(Y.OUT,X.OUT)=0„2080         GOTO 2100„2090           PAGE(Y.OUT,X.OUT)=1„2100         X.OUT.MOD.8=X.OUT.MOD.8+1„2110         IF X.OUT.MOD.8 >= 8 THEN X.OUT.MOD.8=0„2120       NEXT X.OUT„2130     GOTO 2260„2140       X.OUT.MOD.8=1„2150       FOR X.OUT=1 TO X.MAX„2160         IF X.OUT.MOD.8 = 0 THEN 2220„2170         IF X.OUT.MOD.8 = 1 THEN 2220„2180         IF X.OUT.MOD.8 = 4 THEN 2220„2190         IF X.OUT.MOD.8 = 7 THEN 2220„2200           PAGE(Y.OUT,X.OUT)=0„2210         GOTO 2230„2220           PAGE(Y.OUT,X.OUT)=1„2230         X.OUT.MOD.8=X.OUT.MOD.8+1„2240         IF X.OUT.MOD.8 >= 8 THEN X.OUT.MOD.8=0„2250       NEXT X.OUT„2260   Y.OUT.MOD.4=Y.OUT.MOD.4+1„2270   IF Y.OUT.MOD.4 >= 4 THEN Y.OUT.MOD.4=0„2280 NEXT Y.OUT„2290 X=4„2300 Y=Y.MAX-2„2310 PAGE(Y,X)=0„2320 STACK.HEAD=-1„2330   DELTA.INDEX.1A=1„2340     DELTA.INDEX.2=R.N(1)„2350     R.N.INDEX.1=1„2360     FOR R.N.INDEX.2=2 TO 8„2370       TEM.INT=R.N(R.N.INDEX.2)„2380       R.N(R.N.INDEX.1)=TEM.INT„2390       DELTA.INDEX.2=DELTA.INDEX.2+TEM.INT„2400       IF DELTA.INDEX.2 > 727 THEN DELTA.INDEX.2=DELTA.INDEX.2-727„2410       R.N.INDEX.1=R.N.INDEX.2„2420     NEXT R.N.INDEX.2„2430     R.N(8)=DELTA.INDEX.2„2440   IF DELTA.INDEX.2 > 720 THEN 2340„2450   PASSAGE.FOUND=0„2460   SEARCH.COMPLETE=0„2470   WHILE (SEARCH.COMPLETE = 0)„2480     WHILE ((DELTA.INDEX.1A <= 6) AND (PASSAGE.FOUND = 0))„2490       X.NEXT=X+2*DELTA.X(DELTA.INDEX.1A,DELTA.INDEX.2)„2500       IF X.NEXT > 0 THEN 2530„2510         DELTA.INDEX.1A=DELTA.INDEX.1A+1„2520       GOTO 2670„2530         IF X.NEXT < X.MAX THEN 2560„2540           DELTA.INDEX.1A=DELTA.INDEX.1A+1„2550         GOTO 2670„2560           Y.NEXT=Y+2*DELTA.Y(DELTA.INDEX.1A,DELTA.INDEX.2)„2570           IF Y.NEXT > 0 THEN 2600„2580             DELTA.INDEX.1A=DELTA.INDEX.1A+1„2590           GOTO 2670„2600             IF Y.NEXT < Y.MAX THEN 2630„2610               DELTA.INDEX.1A=DELTA.INDEX.1A+1„2620             GOTO 2670„2630               IF PAGE(Y.NEXT,X.NEXT) = 0 THEN 2660„2640                 PASSAGE.FOUND=-1„2650               GOTO 2670„2660                 DELTA.INDEX.1A=DELTA.INDEX.1A+1„2670     WEND„2680     IF PASSAGE.FOUND <> 0 THEN 2760„2690       IF STACK.HEAD < 0 THEN 2760„2700         DELTA.INDEX.1A=STACK.1(STACK.HEAD)„2710         DELTA.INDEX.2=STACK.2(STACK.HEAD)„2720         X=X-2*DELTA.X(DELTA.INDEX.1A,DELTA.INDEX.2)„2730         Y=Y-2*DELTA.Y(DELTA.INDEX.1A,DELTA.INDEX.2)„2740         STACK.HEAD=STACK.HEAD-1„2750         DELTA.INDEX.1A=DELTA.INDEX.1A+1„2760     IF PASSAGE.FOUND = 0 THEN 2790„2770       SEARCH.COMPLETE=-1„2780     GOTO 2810„2790       IF ((STACK.HEAD >= 0) OR (DELTA.INDEX.1A <= 6)) THEN 2810„2800         SEARCH.COMPLETE=-1„2810   WEND„2820   IF PASSAGE.FOUND = 0 THEN 2900„2830     STACK.HEAD=STACK.HEAD+1„2840     STACK.1(STACK.HEAD)=DELTA.INDEX.1A„2850     STACK.2(STACK.HEAD)=DELTA.INDEX.2„2860     PAGE(Y.NEXT,X.NEXT)=0„2870     PAGE((Y+Y.NEXT)\2,(X+X.NEXT)\2)=0„2880     X=X.NEXT„2890     Y=Y.NEXT„2900 IF STACK.HEAD <> -1 THEN 2330„2910 PAGE(2,2)=0„2920 PAGE(Y.MAX-1,X.MAX-1)=0„2930 SCREEN 1„2940 COLOR 0,0„2950 CLS„2960 Y.PREVIOUS=0„2970 Y.NEXT=2„2980 FOR Y.OUT=1 TO Y.MAX„2990   X.OUT=1„3000   FOR X.NEXT=2 TO X.MAX„3010     IF PAGE(Y.OUT,X.OUT) = 0 THEN 3100„3020       IF PAGE(Y.OUT,X.NEXT) = 0 THEN 3040„3030         LINE (3*(X.OUT-1),4*(Y.OUT-1))-(3*(X.NEXT-1),4*(Y.OUT-1)),1„3040       IF Y.PREVIOUS <= 0 THEN 3070„3050         IF PAGE(Y.PREVIOUS,X.NEXT) = 0 THEN 3070„3060           LINE (3*(X.OUT-1),4*(Y.OUT-1))-(3*(X.NEXT-1),4*(Y.PREVIOUS-1)),1„3070       IF Y.NEXT > Y.MAX THEN 3100„3080         IF PAGE(Y.NEXT,X.NEXT) = 0 THEN 3100„3090           LINE (3*(X.OUT-1),4*(Y.OUT-1))-(3*(X.NEXT-1),4*(Y.NEXT-1)),1„3100     X.OUT=X.NEXT„3110   NEXT X.NEXT„3120   Y.PREVIOUS=Y.OUT„3130   Y.NEXT=Y.NEXT+1„3140 NEXT Y.OUT„3150 BEEP„3160 WHILE (INKEY$ = "")„3170 WEND„3180 NUM.DEAD.ENDS=0„3190   FOR Y.OUT=3 TO Y.MAX STEP 4„3200     FOR X.OUT=4 TO X.MAX STEP 8„3210       NUM.WALLS=PAGE(Y.OUT-1,X.OUT-2)„3220       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT+1,X.OUT-2)„3230       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT+2,X.OUT)„3240       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT+1,X.OUT+2)„3250       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT-1,X.OUT+2)„3260       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT-2,X.OUT)„3270       IF NUM.WALLS <> 5 THEN 3510„3280         NUM.DEAD.ENDS=NUM.DEAD.ENDS+1„3290         IF PAGE(Y.OUT-1,X.OUT-2) <> 0 THEN 3330„3300           LINE (3*(X.OUT-4),4*(Y.OUT-1))-(3*(X.OUT-2),4*(Y.OUT-3)),2„3310           PAGE(Y.OUT-1,X.OUT-2)=1„3320         GOTO 3510„3330           IF PAGE(Y.OUT-2,X.OUT) <> 0 THEN 3370„3340             LINE (3*(X.OUT-2),4*(Y.OUT-3))-(3*X.OUT,4*(Y.OUT-3)),2„3350             PAGE(Y.OUT-2,X.OUT)=1„3360           GOTO 3510„3370             IF PAGE(Y.OUT-1,X.OUT+2) <> 0 THEN 3410„3380               LINE (3*X.OUT,4*(Y.OUT-3))-(3*(X.OUT+2),4*(Y.OUT-1)),2„3390               PAGE(Y.OUT-1,X.OUT+2)=1„3400             GOTO 3510„3410               IF PAGE(Y.OUT+1,X.OUT+2) <> 0 THEN 3450„3420                 LINE (3*(X.OUT+2),4*(Y.OUT-1))-(3*X.OUT,4*(Y.OUT+1)),2„3430                 PAGE(Y.OUT+1,X.OUT+2)=1„3440               GOTO 3510„3450                 IF PAGE(Y.OUT+2,X.OUT) <> 0 THEN 3490„3460                   LINE (3*X.OUT,4*(Y.OUT+1))-(3*(X.OUT-2),4*(Y.OUT+1)),2„3470                   PAGE(Y.OUT+2,X.OUT)=1„3480                 GOTO 3510„3490                   LINE (3*(X.OUT-2),4*(Y.OUT+1))-(3*(X.OUT-4),4*(Y.OUT-1)),2„3500                   PAGE(Y.OUT+1,X.OUT-2)=1„3510     NEXT X.OUT„3520   NEXT Y.OUT„3530   Y.LIMIT=Y.MAX-1„3540   FOR Y.OUT=5 TO Y.LIMIT STEP 4„3550     FOR X.OUT=8 TO X.MAX STEP 8„3560       NUM.WALLS=PAGE(Y.OUT-1,X.OUT-2)„3570       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT+1,X.OUT-2)„3580       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT+2,X.OUT)„3590       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT+1,X.OUT+2)„3600       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT-1,X.OUT+2)„3610       NUM.WALLS=NUM.WALLS+PAGE(Y.OUT-2,X.OUT)„3620       IF NUM.WALLS <> 5 THEN 3860„3630         NUM.DEAD.ENDS=NUM.DEAD.ENDS+1„3640         IF PAGE(Y.OUT-1,X.OUT-2) <> 0 THEN 3680„3650           LINE (3*(X.OUT-4),4*(Y.OUT-1))-(3*(X.OUT-2),4*(Y.OUT-3)),2„3660           PAGE(Y.OUT-1,X.OUT-2)=1„3670         GOTO 3860„3680           IF PAGE(Y.OUT-2,X.OUT) <> 0 THEN 3720„3690             LINE (3*(X.OUT-2),4*(Y.OUT-3))-(3*X.OUT,4*(Y.OUT-3)),2„3700             PAGE(Y.OUT-2,X.OUT)=1„3710           GOTO 3860„3720             IF PAGE(Y.OUT-1,X.OUT+2) <> 0 THEN 3760„3730               LINE (3*X.OUT,4*(Y.OUT-3))-(3*(X.OUT+2),4*(Y.OUT-1)),2„3740               PAGE(Y.OUT-1,X.OUT+2)=1„3750             GOTO 3860„3760               IF PAGE(Y.OUT+1,X.OUT+2) <> 0 THEN 3800„3770                 LINE (3*(X.OUT+2),4*(Y.OUT-1))-(3*X.OUT,4*(Y.OUT+1)),2„3780                 PAGE(Y.OUT+1,X.OUT+2)=1„3790               GOTO 3860„3800                 IF PAGE(Y.OUT+2,X.OUT) <> 0 THEN 3840„3810                   LINE (3*X.OUT,4*(Y.OUT+1))-(3*(X.OUT-2),4*(Y.OUT+1)),2„3820                   PAGE(Y.OUT+2,X.OUT)=1„3830                 GOTO 3860„3840                   LINE (3*(X.OUT-2),4*(Y.OUT+1))-(3*(X.OUT-4),4*(Y.OUT-1)),2„3850                   PAGE(Y.OUT+1,X.OUT-2)=1„3860     NEXT X.OUT„3870   NEXT Y.OUT„3880 IF NUM.DEAD.ENDS <> 0 THEN 3180„3890 BEEP„3900 WHILE (INKEY$ = "")„3910 WEND„3920 SCREEN 0„3930 WIDTH 80„3940 END„Jean Crepeau                   MAZES                          MAZES                          07-19-92 (00:00:00)    QB, QBasic             177  6576     MAZES.BAS   '        I was reading  a message a  while ago asking  about a maze„'drawing algorithm.  I've been  working on this  algorithm since last„'night and it's now ready to be sent. It draws a one-solution two-exits„'maze.  From one of the to exit/entrance, you can reach any 'square' in„'the maze.„'„'        It works in three phases. First it draws the paths and waits for„'a key. This is the main drawing  algorithm. Then it clears the screen,„'draws the walls (outlined paths),  and waits for a  key. Finally, the„'third part finds and draws the unique solution of  the maze and then„'waits for a key. You can exit at any time by pressing [Esc].„„' Maze„' By Jean Cr*peau„„DEFINT A-Z„DECLARE FUNCTION num (x, y)„DECLARE SUB vdctr (x$)„RANDOMIZE TIMER„DO„    SCREEN 0, 0: CLS„    COLOR 15: vdctr "Maze": COLOR 7„    vdctr "By Jean Cr*peau"„    PRINT„    INPUT "X,Y: ", nx, ny„    nx = nx - 1: ny = ny - 1„    IF nx <= 0 THEN nx = 31„    IF ny <= 0 THEN ny = 31„' Initialization„   SCREEN 1, 0: CLS : wx = 320 - 1: wy = 200 - 1' CGA4„    'SCREEN 2, 0: CLS : wx = 640 - 1: wy = 200 - 1' CGA2„    'SCREEN 3, 0: CLS : wx = 720 - 1: wy = 348 - 1' HERC„    xi = wx \ nx: yi = wy \ ny„    mx = (wx - xi * nx) / 2: my = (wy - yi * ny) / 2„    REDIM SHARED ar(nx, ny), avl(3), bit(7)„    bit(0) = 1: bit(1) = 2: bit(2) = 4: bit(3) = 8„    bit(4) = 1: bit(5) = 3: bit(6) = 7: bit(7) = 15„' Maze computation„    tt = (nx + 1) * (ny + 1): t = 0: ox = 0: oy = 0„    DO„        IF t = 0 THEN„            t = tt: cx = 0: cy = RND * ny„            sy0 = cy„        ELSE„            cx = ox: cy = oy: DO„                IF ar(cx, cy) THEN„                    IF num(cx, cy) > 0 THEN EXIT DO„                END IF„                cy = cy + 1: IF cy > ny THEN : cy = 0: cx = cx + 1: IF cx = nx THEN cx = 0„            LOOP„            ox = cx: oy = cy„        END IF„        DO„            px = cx * xi: py = cy * yi„            n = 4„            avl(0) = 1: avl(1) = 2: avl(2) = 3: avl(3) = 4„            IF cx = nx THEN avl(0) = 0 ELSE IF ar(cx + 1, cy) THEN avl(0) = 0„            IF cy = ny THEN avl(1) = 0 ELSE IF ar(cx, cy + 1) THEN avl(1) = 0„            IF cx = 0 THEN avl(2) = 0 ELSE IF ar(cx - 1, cy) THEN avl(2) = 0„            IF cy = 0 THEN avl(3) = 0 ELSE IF ar(cx, cy - 1) THEN avl(3) = 0„            DO„                IF avl(0) = 0 AND n > 0 THEN„                    n = n - 1: SWAP avl(0), avl(n)„                ELSEIF avl(1) = 0 AND n > 1 THEN„                    n = n - 1: SWAP avl(1), avl(n)„                ELSEIF avl(2) = 0 AND n > 2 THEN„                    n = n - 1: SWAP avl(2), avl(n)„                ELSEIF avl(3) = 0 AND n > 3 THEN„                    n = n - 1: SWAP avl(3), avl(n)„                ELSE„                    EXIT DO„                END IF„            LOOP UNTIL n = 0„            IF n = 0 THEN EXIT DO„            q = avl(INT(RND * n)) - 1„            IF ar(cx, cy) = 0 THEN t = t - 1„            ar(cx, cy) = ar(cx, cy) OR bit(q)„            SELECT CASE q„            CASE 0: cx = cx + 1„            CASE 1: cy = cy + 1„            CASE 2: cx = cx - 1„            CASE 3: cy = cy - 1„            END SELECT„            ar(cx, cy) = ar(cx, cy) OR bit(q XOR 2): t = t - 1„            LINE (mx + px, my + py)-(mx + cx * xi, my + cy * yi)„„            IF cx = nx THEN sy1 = cy„        LOOP„        IF INKEY$ = CHR$(27) THEN GOTO quit„    LOOP UNTIL t = 0„    ar(nx, sy1) = ar(nx, sy1) OR bit(0)„    ar(0, sy0) = ar(0, sy0) OR bit(2)„    a$ = INPUT$(1)„' "Outline" maze„    CLS„    xi = wx \ (nx + 1): yi = wy \ (ny + 1)„    mx = (wx - (nx + 1) * xi) / 2: my = (wy - (ny + 1) * yi) / 2„    LINE (mx, my)-(mx, my + yi * (ny + 1))„    py = (sy0 + 1) * yi: LINE (mx, my + py)-(mx, my + py - yi), 0„    LINE (mx, my)-(mx + xi * (nx + 1), my)„    FOR y = 0 TO ny„        FOR x = 0 TO nx„            px = mx + (x + 1) * xi: py = my + (y + 1) * yi„            IF (ar(x, y) AND bit(0)) = 0 THEN LINE (px, py)-(px, py - yi)„            IF (ar(x, y) AND bit(1)) = 0 THEN LINE (px, py)-(px - xi, py)„        NEXT„        IF INKEY$ = CHR$(27) THEN GOTO quit„    NEXT„    a$ = INPUT$(1)„' Solution computation„    cx = 0: cy = sy0: t = 1: ld = 2: d = 0: u$ = "0"„    DO„        q = ar(cx, cy) AND NOT bit(ld)„        IF q = bit(0) THEN„            d = 0„        ELSEIF q = bit(1) THEN„            d = 1„        ELSEIF q = bit(2) THEN„            d = 2„        ELSEIF q = bit(3) THEN„            d = 3„        ELSEIF t = 1 THEN„            IF q AND bit(0) THEN„                u$ = u$ + CHR$(48 + d): d = 0„            ELSEIF q AND bit(1) THEN„                u$ = u$ + CHR$(48 + d): d = 1„            ELSEIF q AND bit(2) THEN„                u$ = u$ + CHR$(48 + d): d = 2„            ELSEIF q AND bit(3) THEN„                u$ = u$ + CHR$(48 + d): d = 3„            ELSE„                d = ld: t = 0„            END IF„        ELSE„            nd = ASC(RIGHT$(u$, 1)) AND 3„            q = ar(cx, cy) AND NOT bit(nd XOR 2) AND NOT bit(ld + 4)„            IF q AND bit(1) THEN„                t = 1: d = 1„            ELSEIF q AND bit(2) THEN„                t = 1: d = 2„            ELSEIF q AND bit(3) THEN„                t = 1: d = 3„            ELSE„                u$ = LEFT$(u$, LEN(u$) - 1)„                d = nd XOR 2„            END IF„        END IF„        px = mx + cx * xi: py = my + cy * yi„        LINE (px + 2, py + 2)-(px + xi - 2, py + yi - 2), t, BF„        SELECT CASE d„        CASE 0: cx = cx + 1: LINE (px + xi - 2, py + 2)-(px + xi + 2, py + yi - 2), t, BF„        CASE 1: cy = cy + 1: LINE (px + 2, py + yi - 2)-(px + xi - 2, py + yi + 2), t, BF„        CASE 2: cx = cx - 1: LINE (px - 2, py + 2)-(px + 2, py + yi - 2), t, BF„        CASE 3: cy = cy - 1: LINE (px + 2, py - 2)-(px + xi - 2, py + 2), t, BF„        END SELECT„        ld = d XOR 2„        IF INKEY$ = CHR$(27) THEN GOTO quit„    LOOP UNTIL cx = nx AND cy = sy1„    px = mx + cx * xi: py = my + cy * yi: LINE (px + 2, py + 2)-(px + xi - 2, py + yi - 2), t, BF„LOOP UNTIL INPUT$(1) = CHR$(27)„quit: SCREEN 0„END„„FUNCTION num (x, y)„  SHARED nx, ny„  n = 4„  IF x >= nx THEN n = n - 1 ELSE IF ar(x + 1, y) THEN n = n - 1„  IF y >= ny THEN n = n - 1 ELSE IF ar(x, y + 1) THEN n = n - 1„  IF x <= 0 THEN n = n - 1 ELSE IF ar(x - 1, y) THEN n = n - 1„  IF y <= 0 THEN n = n - 1 ELSE IF ar(x, y - 1) THEN n = n - 1„  num = n„END FUNCTION„„SUB vdctr (x$)„    PRINT SPACE$(40 - LEN(x$) / 2); x$„END SUB„„Quinn Tyler Jackson            FORMULA SOLVER                 FORMULA,SOLVER                 Unknown Date (00:00)   QB, QBasic, PDS        1021 31071    FORMULA.BAS 'This message is to serve as a brief tutorial on the syntax of the„'FUNCTION funSolveEquation(InText$).„'„'First of all, there are standard statements:„'„'1+1„'2+3„'9*2+2„'9etc.„'„'That's fairly simple.  Then, there are more advanced operators, such as„'` and # and }.„'„'-4` = 4  That is to say, ` returns the ABSOLUTE value of x.„'„'4.5# = 4  That is to say, # returns the integer part of x.„'„'2}4 means "the square root of 4"„'3}8 means "the cube root of 4"„'„'That is, n}x returns the nth root of x.„'„'Then, there are exotic operators, such as !, which is the factorial„'symbol, which means that 5! returns 5 factorial, or 1x2x3x4x5, or 120.„'0! is 1 by definition.„'„'There are other operators:„'„'5%2 works as 5 MOD 2„'5\2 does integer division„'5~7 works as 5 XOR 7„'5&7 works as 5 AND 7„'5|7 works as 5 OR 7„'„'Some logical operators:„'„'1>2 returns 0, for false„'1<>2 returns -1, for true„'5==2 returns 0, for false„'(1<3)|=(2==1) returns -1, for IMPLIED TRUTH„'„'Parenthesis override standard BODMAS precedence.  Therefore:„'„'5*(1+2) returns 15, rather than 7.„'„'VARIABLE ASSIGNMENT:„'„'Variables are case insensitive, and can consist of:„'„'        first character must be either @ or A-Z„'        subsequent characters can be anything but spaces or„'        operators (numbers or commas are legal, as are underscores, but„'        A^TEST would be a to the power of test.„'„'Variable assignment is achieved by the statment:„'„'Variable:=equation„'„'Therefore, one could do any of the following:„'„'STATEMENT                          VALUE OF A„'---------------------------------------------„'A:=10                                10„'A:=10*2                              20„'A:=square_root[9]                     3„'„'Suppose A is equal to 10, the following would change its value to 20:„'„'A:=A*2„'„'FUNCTIONS:„'„'Functions are assigned in a similar fashion to variables.„'„'square[x]:=x^2„'„'Now, whenever a value for the x parameter is supplied, it is put into„'the formula, and the function returns the result.  Variables in function„'parameters are local to those functions and are dynamic.  That is to„'say, if x is specified as being 100 somewhere else, that doesn't affect„'the function.„'„'Therefore,„'„'square[10] would return 100.„'square[n] would return 4 if n were equal to 2„'square[1+5] would return 36 and„'square[square[2]] would return 16, and is an example of the nesting that„'is possible with functions.„'„'In the definition of the function, one can assign parameter defaults.„'That is, one can supply values for the parameters that are used as a„'default value if that parameter is not supplied in the call.„'„'area[radius,pi:(22/7)]:=pi*radius^2„'„'As it stands, suppose someone were to then call the function like this:„'„'area[10]„„'This would return 31.429, using the default of 22/7 for pi, which is a„'rough approximation.  However, if a stickler were to come along and„'demand a more accurate value for pi, he could supply the missing„'parameter:„'„'area[10,3.14159]„'„'and the function would use this value for pi rather than the default.„'„'Note that when the default parameter is at the END of the paremeter list„'in the function definition, there is no need for a placeholder.  In„'other locations, one is required:„'„'area[pi:22/7,radius]:=pi*radius^2„'„'Now, to call this using the default value for pi, one would have to do„'this:„'„'area[,10]„'„'The , serves as a place holder for the missing parameter, just as in the„'BASIC statement:„'„'LOCATE ,10„'„'SOME ADVANCED TOPICS:„„'Multiline statements are possible.  The result of the LAST calculation„'in the list is what funSolveEquation returns.  Therefore, one could do„'this:„'        2„'a:=1;b:=2;c:=3;a+b+c„'„'This would return the value 6.„'Functions canNOT take advantage of this feature.„'„'I leave you to figure out the rest....„'„'„'„ '     THE                                *                  RDF14.BAS„ '  JACK MACK                            *„ '  RECURSIVE                           * ***    *     *„ '   DESCENT                           *     *     * *„ '  ALGEBRAIC       ******             *     *     * *„ '   FORMULA            *               `****'   *     *„ '     AND             **      ***************************************„ '  DEFINABLE            *    *„ '  FUNCTIONS            *   *„ '   ENGINE         *****'  *         *              *„ '                         *         *                *„ '        *               *         *                  *„ '       * *             *         *    5(100-x+2b)     *   *     *„ '      *   *           *          *                    *   *     *„ '           *         *           *   *************    *   *     *„ '            *       *            *                    *   `******„ '             *     *             *       3!+35y       *         *„ '              *   *               *                  *          *„ '               * *                 *                *      `****'„ '  v1.4          *                   *              *„ '              Public Domain Code Written By Quinn Tyler Jackson„ '„ '„ '           *                        *                           *„ '            ****************************************************„ '            *ALL FUTURE VERSIONS WILL LOSE QBASIC COMPATIBILITY*„ '          ***     AND WILL ADOPT PDS/VBDOS EXTENSIONS, SO      ***„ '            *           GRAB THIS ONE WHILE YOU CAN!           *„ '            ****************************************************„ '           *                        *                           *„ '„ '„ ' DEDICATION:„ '„ ' This program is dedicated to my wife Laleh, and our three children,„ '  Ozra, Shahraam, and Arehzou, who give up a lot of their time with„ '           me so I can program at this infernal keyboard!„ '„ ' The superlative, full-featured equation solver, featuring:„ '„ '  1. STANDARD AND ADVANCED OPERATORS„ '  2. STANDARD PRECEDENCE SOLVING ALGORITHM„ '  3. ASSIGNABLE VARIABLES WITH DESCRIPTIVE NAMES„ '  4. NEW TO VERSION 1.4!!!!  Function definition!„ '„ '  I've supplied the module, you figure it out!„„DECLARE FUNCTION funSolveEquation! (InText$)„DECLARE FUNCTION fqjEval! (InText$)„DECLARE FUNCTION fqjVAL! (InText$)„DECLARE FUNCTION fqjFetchVar! (VarName$)„DECLARE FUNCTION fqjInList% (OpTyp$, Op$)„DECLARE FUNCTION fqjSolveFormula! (InToken$)„DECLARE FUNCTION fqjEvalErrMsg$ ()„DECLARE FUNCTION fqjEvaluate! (InText$)„DECLARE SUB sjfParse (Word$(), Txt$, Spt$, WordNum%)„DECLARE SUB sqjApplyOp (Op$, x!, y!)„DECLARE SUB sqjAssignFun (FunctName$, Formula$, Protection%)„DECLARE SUB sqjAssignVar (VarName$, VarValue!, Protection%)„DECLARE SUB sqjDesParse (Phase%, x!)„DECLARE SUB sqjGetToken ()„„CONST TRUE = -1„CONST FALSE = NOT TRUE„„CONST ASSIGNMENT = ":="     ' This can be changed to suit your needs„                            ' Using a simple = is possible, since„' logical„                            ' equality is a double == with this parser,„                            ' but the PASCAL standard := is easier to„' deal„                            ' with as an assignment operator for some.„„' Operator classes                PRECEDENCE„'---------------------------------------------------„CONST POWER = "^}?**>><<!`#"       ' FIRST„CONST MULTDIV = "*/\%"             ' SECOND„CONST ADDSUB = "+-"                ' THIRD„CONST LOGICAL = "&|=~<=<>==>"      ' FOURTH„CONST UNARY = "!#`"                ' UNARY operators„„„DIM SHARED WHITESPACE AS STRING„DIM SHARED OPERATOR AS STRING„„CONST OperatorClass = 1„CONST DigitClass = 2„CONST FunctionClass = 3„„CONST MAXLEVELS = 10    ' Numbers of levels of nesting allowed„CONST MAXCOMMANDS = 10  ' Number of commands per statement„CONST MAXPARAMS = 10    ' Number of parameters in a function allowed„CONST SYMMAX = 200      ' Total number of symbols allowed„CONST VARMAX = 100      ' Total number of variables allowed„CONST FUNMAX = 100      ' Total number of definable functions allowed„CONST SYSMAX = 25„„TYPE SymbolTableType„        SymName AS STRING * 30  ' Name of the symbol„        SymLvl AS INTEGER       ' Level that it was assigned„        SymType AS INTEGER      ' Whether it is a variable or function„        TabPtr AS INTEGER       ' Ptr to data tables„END TYPE„„' Used by SymType„CONST SymVARIABLE = 0„CONST SymFUNCTION = 1„„CONST PROTECTED = -1„CONST UNPROTECTED = 1„„DIM SHARED ErrorCode AS INTEGER„DIM SHARED WarningCode AS INTEGER„' Error code constants„CONST eqjDivisionByZero = 1„CONST eqjProtectedFunction = 2„CONST eqjProtectedVariable = 3„CONST eqjSymbolTableFull = 4„CONST eqjVariableTableFull = 5„CONST eqjFucntionTableFull = 6„CONST eqjMismatchedParenthesis = 7„CONST eqjUndefinedVariable = 8„CONST eqjFunctionDefaultUsed = 9„CONST eqjSyntaxError = 10„„' Variables global to this module...„DIM SHARED SymTable(SYMMAX) AS SymbolTableType  ' Table holds symbols„DIM SHARED VarTable(VARMAX) AS SINGLE           ' Table hold variable DATA„DIM SHARED ParTable(FUNMAX) AS STRING   ' Table holds function parameters„DIM SHARED ForTable(FUNMAX) AS STRING   ' Table holds function formulas„DIM SHARED SysTable(SYSMAX) AS STRING„„DIM SHARED SymPtr AS INTEGER    ' Points to highest symbol in table„DIM SHARED VariPtr AS INTEGER   ' Points to highest variable in table„DIM SHARED FunPtr AS INTEGER    ' Points to highest function in table„DIM SHARED LvlPtr AS INTEGER    ' Indicates the current level being„                                ' evaluated„„DIM SHARED PTR(MAXLEVELS) AS INTEGER    ' Points to location in string being„                                        ' evluated„DIM SHARED EXPR$(MAXLEVELS)       ' Expression being evaluated„DIM SHARED TOKEN$(MAXLEVELS)            ' Current token being evaluated„DIM SHARED TypeToken(MAXLEVELS)         ' Type of current token„„CLEAR , , 1024 * 4„„„CLS„' Initialize tables„nul = fqjEvaluate("")„„' The following module level code is used for testing and debugging.„„DO„    LvlPtr = 0„    TestDeep% = 0   ' Find all cases of TestDeep% and erase when„                    ' you modify this module to fit into your programs,„                    ' since it is only used for testing purposes„    LOCATE 4„    PRINT "Formula --->" + SPACE$(80);„    LOCATE 4, 16„    LINE INPUT Test$„    LOCATE 6„    Synch! = TIMER          'synchronize to the system timer„    DO„      Start! = TIMER„    LOOP WHILE Start! = Synch!„    PRINT "Result ---->", funSolveEquation(Test$); "                  "„    LOCATE 3„    PRINT "Time ------>"; TIMER - Start!; "                "; TAB(50); "Recursion Depth: "; TestDeep%„    LOCATE 1„    PRINT "Last error->", fqjEvalErrMsg$; "                                                      "„„    VIEW PRINT 8 TO 24„    FOR i% = 1 TO SymPtr„        IF i% MOD 17 = 0 THEN„            LOCATE 8„            Sec% = TRUE„        END IF„„        IF Sec% THEN„            LOCATE , 40„        END IF„„        SELECT CASE SymTable(i%).SymType„            CASE SymVARIABLE„                PRINT "V: "; RTRIM$(SymTable(i%).SymName); " -->";„                SELECT CASE SymTable(i%).SymLvl„                    CASE IS > PROTECTED„                        PRINT VarTable(SymTable(i%).TabPtr); "         "„                    CASE ELSE„                        PRINT fqjFetchVar(RTRIM$(SymTable(i%).SymName)); "          "„                END SELECT„            CASE SymFUNCTION„                PRINT "F: "; RTRIM$(SymTable(i%).SymName)„        END SELECT„    NEXT i%„    Sec% = FALSE„    VIEW PRINT„LOOP„„„PredefinedFunctionData:„„' The following functions are read into the symbol table the first„' time the function is called.  I thought they would be of some help.„' Note that they are PROTECTED.  That is to say, they cannot be„' redefined„' by the user, in the same way the user cannot redefine built-in„' functions„' in BASIC.  Add any to this list any functions that would suit your„' needs.„„DATA "square_root[x]","2}x"„DATA "cube_root[x]","3}x"„DATA "rand[high:100,seed:timer]","high?seed"„'                          ^„'                          |„'         seeds with timer if no seed supplied„'„DATA "area_of_circle[r,pi:3.1415926]","pi*r^2"„'                         ^^^^^^^^^„'                             |„'                  defaults if none supplied„'                       |          |„'                       V          V„DATA "distance[x1,y1,z1:0,x2,y2,z2:0]","square_root[(x1-x2)^2+(y1-y2)^2+(z1-z2)^2]"„DATA "*END*",""„„' These following system variables.  They cannot be redefined, since„' they„' return system information.  When you add a system variable to this„' list, you must also add it to the SELECT CASE VarName$ structure in„' the FUNCTION fqjFetchVar.  Here are a few to get you started.„„SystemVariableData:„DATA "timer"„DATA "string_mem"„DATA "free_mem"„DATA "stack"„DATA "rnd"„DATA "*END*"„„FUNCTION fqjEval (InText$)„„EXPR$(LvlPtr) = UCASE$(InText$)„„PTR(LvlPtr) = 1„„AssignmentPtr% = INSTR(EXPR$(LvlPtr), ASSIGNMENT)„ParenPtr% = INSTR(EXPR$(LvlPtr), "[")„„IF AssignmentPtr% = 0 THEN ' just do a simple evaluation„            EXPR$(LvlPtr) = EXPR$(LvlPtr)„            CALL sqjGetToken„            CALL sqjDesParse(1, x)„            fqjEval = x„ELSE                       ' assign a variable or function!„    VariableName$ = LTRIM$(RTRIM$(LEFT$(EXPR$(LvlPtr), AssignmentPtr% - 1)))„„    SELECT CASE (ParenPtr% > 0) AND (ParenPtr% < AssignmentPtr%)„        CASE 0„                Valu = fqjEval(MID$(EXPR$(LvlPtr), AssignmentPtr% + 2))„                CALL sqjAssignVar(VariableName$, Valu, LvlPtr)„                fqjEval = Valu„        CASE ELSE„                Formula$ = LTRIM$(MID$(EXPR$(LvlPtr), AssignmentPtr% + 2))„                CALL sqjAssignFun(VariableName$, Formula$, UNPROTECTED)„    END SELECT„END IF„END FUNCTION„„FUNCTION fqjEvalErrMsg$„' This function returns either a null string for no error, or a„' description„' of the most recent error that occurred in processing a statement.„' Errors„' terminate the process and return 0, whereas warnings continue„' functioning„' and return a value based upon defaults.„„SELECT CASE ErrorCode + WarningCode„    CASE 0„        T$ = ""„    CASE eqjDivisionByZero„        T$ = "Division by zero"„    CASE eqjProtectedVariable„        T$ = "Attempt to overwrite protected variable"„    CASE eqjProtectedFunction„        T$ = "Attrmpt to redefine protected function"„    CASE eqjSymbolTableFull„        T$ = "Symbol table full"„    CASE eqjVariableTableFull„        T$ = "Variable table full"„    CASE eqjFunctionTableFull„        T$ = "Function table full"„    CASE eqjMismatchedParenthesis„        T$ = "Mismatched parenthesis encountered"„    CASE eqjUndefinedVariable„        T$ = "Undefined variable referenced -- assuming value of 0"„    CASE eqjFunctionDefaultUsed„        T$ = "Function parameter not supplied -- default assumed"„    CASE eqjSyntaxError„        T$ = "General syntax error"„END SELECT„„fqjEvalErrMsg$ = T$„END FUNCTION„„FUNCTION fqjEvaluate (InText$)„„„InText$ = LTRIM$(InText$)„„' Expand unary suffixes for easier parsing„ FOR i% = 1 TO LEN(UNARY)„    Temp$ = MID$(UNARY, i%, 1)„    IF INSTR(InText$, Temp$) THEN„        TempPtr = 1„        DO„            Char$ = MID$(InText$, TempPtr, 1)„            IF fqjInList(UNARY, Char$) THEN„                InText$ = LEFT$(InText$, TempPtr) + "0" + MID$(InText$, TempPtr + 1)„            END IF„            TempPtr = TempPtr + 1„        LOOP UNTIL TempPtr >= LEN(InText$)„    END IF„NEXT i%„„fqjEvaluate = fqjVAL(InText$)„„END FUNCTION„„FUNCTION fqjFetchVar (VarName$)„„SELECT CASE VarName$„    CASE "TIMER"„        fqjFetchVar = TIMER„    CASE "STRING_MEM"„        fqjFetchVar = FRE("A")„    CASE "FREE_MEM"„        fqjFetchVar = FRE(-1)„    CASE "STACK"„        fqjFetchVar = FRE(-2)„    CASE "RND"„        fqjFetchVar = RND„    CASE ELSE„        FOR i% = SymPtr TO 1 STEP -1„'            IF SymTable(i%).SymLvl = LvlPtr OR SymTable(i%).SymLvl = 1„' THEN„                IF SymTable(i%).SymType = SymVARIABLE THEN„                    IF RTRIM$(SymTable(i%).SymName) = VarName$ THEN„                        fqjFetchVar = VarTable(SymTable(i%).TabPtr)„                            EXIT FUNCTION„                    END IF„                END IF„'            END IF„        NEXT i%„        WarningCode = eqjUndefinedVariable„END SELECT„„END FUNCTION„„FUNCTION fqjInList% (OpTyp$, Op$)„„IF LEN(Op$) THEN„    IF INSTR(OpTyp$, Op$) > 0 THEN„        fqjInList% = TRUE„    END IF„END IF„END FUNCTION„„FUNCTION fqjSolveFormula (InToken$)„„DIM Param$(MAXPARAMS)„DIM Default(MAXPARAMS)„DIM ParValue$(MAXPARAMS)„DIM ParValue(MAXPARAMS)„„Paren% = INSTR(InToken$, "[")„FunctName$ = LTRIM$(RTRIM$(LEFT$(InToken$, Paren% - 1)))„Par$ = MID$(InToken$, Paren% + 1, LEN(InToken$) - Paren% - 1)„„FOR i% = 1 TO SymPtr„    IF SymTable(i%).SymType = SymFUNCTION THEN„        IF RTRIM$(SymTable(i%).SymName) = FunctName$ THEN„            Formula$ = ForTable(SymTable(i%).TabPtr)„            Para$ = ParTable(SymTable(i%).TabPtr)„            CALL sjfParse(Param$(), Para$, ",", Tot%)„            FOR a% = 1 TO Tot%„                Temp$ = Param$(a%)„                TempPtr = INSTR(Temp$, ":")„                SELECT CASE TempPtr„                    CASE 0„                        ' Do nothing„                        Default(a%) = 0„                    CASE ELSE„                        Param$(a%) = LEFT$(Temp$, TempPtr - 1)„                        Default(a%) = fqjEvaluate(MID$(Temp$, TempPtr + 1))„                END SELECT„            NEXT a%„            EXIT FOR„        END IF„    END IF„NEXT i%„„CALL sjfParse(ParValue$(), Par$, ",", Tot2%)„„FOR i% = 1 TO Tot%„„    IF ParValue$(i%) = "" THEN„        ParValue(i%) = Default(i%)„        WarningCode = eqjFunctionDefaultUsed„    ELSE„        ParValue(i%) = fqjEvaluate(ParValue$(i%))„    END IF„„    ' Push the parameters to the variable stack temporarily„„    IF SymPtr < SYMMAX THEN„        ' Since it wasn't, put it there„        VariPtr = VariPtr + 1„        SymPtr = SymPtr + 1„„        IF VariPtr <= VARMAX THEN„            SymTable(SymPtr).SymName = Param$(i%)„            SymTable(SymPtr).SymType = SymVARIABLE„            SymTable(SymPtr).TabPtr = VariPtr„            SymTable(SymPtr).SymLvl = LvlPtr + 1„            VarTable(VariPtr) = ParValue(i%)„        ELSE„            ErrorCode = eqjVariableTableFull„        END IF„    ELSE„        ErrorCode = eqjSymbolTableFull„    END IF„„NEXT i%„„fqjSolveFormula = fqjEvaluate(Formula$)„„VariPtr = VariPtr - Tot%    ' Clear the variable stack of„SymPtr = SymPtr - Tot%      ' variables used in parameter„END FUNCTION„„FUNCTION fqjVAL (InText$)„„' Initialize some variables....„„IF LvlPtr < MAXLEVELS THEN„    LvlPtr = LvlPtr + 1„„    DIM CommandArray$(MAXCOMMANDS)„„        ' separate statement by semicolons„        CALL sjfParse(CommandArray$(), InText$, ";", Tot%)„„        FOR i% = 1 TO Tot%„            fqjVAL = fqjEval(CommandArray$(i%))„„            IF ErrorCode THEN„                fqjVAL = 0„                EXIT FUNCTION„            END IF„        NEXT i%„„    LvlPtr = LvlPtr - 1„„    ELSE„        ErrorCode = eqjNestedTooDeep„END IF„END FUNCTION„„FUNCTION funSolveEquation (InText$)„„STATIC Initialized%„„IF Initialized% = FALSE THEN„    RESTORE PredefinedFunctionData„    DO„        READ N$, F$„        IF N$ <> "*END*" THEN„            CALL sqjAssignFun(N$, F$, PROTECTED)„        END IF„    LOOP UNTIL N$ = "*END*"„„    RESTORE SystemVariableData„    DO„        READ N$„        IF N$ <> "*END*" THEN„            CALL sqjAssignVar(N$, 0, PROTECTED)„        END IF„    LOOP UNTIL N$ = "*END*"„„    Initialized% = TRUE„END IF„„OPERATOR = ADDSUB + MULTDIV + POWER + LOGICAL„WHITESPACE = " " + CHR$(13) + CHR$(9) + CHR$(10)„„ErrorCode = 0„WarningCode = 0„LvlPtr = 0„funSolveEquation = fqjEvaluate(InText$)„„END FUNCTION„„SUB sjfParse (Word$(), Txt$, Spt$, WordNum%)„„Text$ = Txt$„WordNum% = 0„SepLen% = LEN(Spt$)„„DO„    WordNum% = WordNum% + 1„    EndWord% = INSTR(Text$, Spt$)„    IF EndWord% THEN„        Word$(WordNum%) = LEFT$(Text$, EndWord% - 1)„        Text$ = MID$(Text$, EndWord% + SepLen%)„    ELSE„        Word$(WordNum%) = Text$„        Text$ = ""„    END IF„LOOP WHILE LEN(Text$)„END SUB„„SUB sqjApplyOp (Op$, x, y)„„' This is the meat of the operator section, and can be modified to„' includ ANY symbol as an operator, or any two byte symbol combination.„' Any symbol added has to be added to the constant that sets its„' level of precedence.„„SELECT CASE Op$„    CASE "-"    ' subtraction„        x = x - y„    CASE "+"    ' addition„        x = x + y„    CASE "*"    ' multiplication„        x = x * y„    CASE "/"    ' division„        IF y <> 0 THEN„            x = x / y„        ELSE„            ErrorCode = eqjDivisionByZero„        END IF„    CASE "\"    ' integer division„        IF y <> 0 THEN„            x = x \ y„        ELSE„            ErrorCode = eqjDivisionByZero„        END IF„    CASE "%"    ' modulo division„        IF y <> 0 THEN„            x = x MOD y„        ELSE„            ErrorCode = eqjDivisionByZero„        END IF„    CASE "^", "**"  ' exponentation„        x = x ^ y„    CASE "}"    ' the rth root of y„        IF y <> 0 THEN„            x = y ^ (1 / x)„„        ELSE„            ErrorCode = eqjDivisionByZero„        END IF„    CASE "?"    ' random number from 0 to x, seed y„        RANDOMIZE y„        x = RND * x„    CASE "<<"   ' bitshift left y by x bits„        x = INT(y) * 2 ^ INT(x)„    CASE ">>"   ' bitshift right y by x bits„        x = INT(y) \ 2 ^ INT(x)„    CASE "!"    ' factorial„        Temp& = 1„        FOR i% = 1 TO x„                Temp& = Temp& * i%„        NEXT i%„        x = Temp&„    CASE "`"„        x = ABS(x)„    CASE "#"    ' absolute„        x = INT(x)„    CASE "<"    ' logical less than than„        x = x < y„    CASE "<=", "=<" ' logical less than or equal to„        x = x <= y„    CASE ">"    ' logical greater than„        x = x > y„    CASE ">=", "=>" ' logical greater than or equal to„        x = x >= y„    CASE "=="    ' logical equality„        x = x = y„    CASE "<>" ' logical inequality„        x = x <> y„    CASE "|=", "=|" ' logical implication„        x = x IMP y„    CASE "&=", "=&" ' logical equivlance„        x = x EQV y„    CASE "&"   ' bitwise AND„        x = x AND y„    CASE "|"    ' bitwise OR„        x = x OR y„    CASE "~"    ' bitwise XOR„        x = x XOR y„END SELECT„END SUB„„SUB sqjAssignFun (FunctName$, Formula$, Protection%)„„FunctName$ = UCASE$(FunctName$)„„ParPtr% = INSTR(FunctName$, "[")„NamePart$ = LEFT$(FunctName$, ParPtr% - 1)„ParamPart$ = MID$(FunctName$, ParPtr% + 1, LEN(FunctName$) - ParPtr% - 1)„„' First we see if this function is already in the list„FOR i% = 1 TO SymPtr„    IF SymTable(i%).SymType = SymFUNCTION THEN„        IF RTRIM$(SymTable(i%).SymName) = NamePart$ THEN„            IF SymTable(i%).SymLvl <> PROTECTED THEN„                ' Since it was, just change its formula„                IF ParamPart$ <> "" THEN„                    ' Make sure it just isn't a formula„                    ' that uses empty parenthesis for the params.„                    ParTable(SymTable(i%).TabPtr) = ParamPart$„                END IF„            ELSE„                ErrorCode = eqjProtectedFunction„            END IF„            ForTable(SymTable(i%).TabPtr) = Formula$„            EXIT SUB„        END IF„    END IF„NEXT i%„„IF SymPtr < SYMMAX THEN„    ' Since it wasn't, put it there„    FunPtr = FunPtr + 1„    SymPtr = SymPtr + 1„„    IF FunPtr <= FUNMAX THEN„        SymTable(SymPtr).SymName = NamePart$„        SymTable(SymPtr).SymType = SymFUNCTION„        SymTable(SymPtr).SymLvl = Protection%„        SymTable(SymPtr).TabPtr = FunPtr„        ParTable(FunPtr) = ParamPart$„        ForTable(FunPtr) = Formula$„    ELSE„        ErrorCode = eqjFunctionTableFull„    END IF„„ELSE„    ErrorCode = eqjSymbolTableFull„END IF„END SUB„„SUB sqjAssignVar (VarName$, VarValue, Protection%)„VarName$ = UCASE$(VarName$)„„' First we see if this variable is already in the list„FOR i% = 1 TO SymPtr„    IF SymTable(i%).SymType = SymVARIABLE THEN„        IF RTRIM$(SymTable(i%).SymName) = VarName$ THEN„            IF SymTable(i%).SymLvl <> PROTECTED THEN„                IF SymTable(i%).SymLvl = LvlPtr THEN„                    ' Since it was, just change its value„                    VarTable(SymTable(i%).TabPtr) = VarValue„                    EXIT SUB„                END IF„            ELSE„                ErrorCode = eqjProtectedVariable„                EXIT SUB„            END IF„        END IF„    END IF„NEXT i%„„IF SymPtr < SYMMAX THEN„    ' Since it wasn't, put it there„    VariPtr = VariPtr + 1„    SymPtr = SymPtr + 1„„    IF VariPtr <= VARMAX THEN„        SymTable(SymPtr).SymName = VarName$„        SymTable(SymPtr).SymType = SymVARIABLE„        SymTable(SymPtr).TabPtr = VariPtr„        SymTable(SymPtr).SymLvl = Protection%„        VarTable(VariPtr) = VarValue„    ELSE„        ErrorCode = eqjVariableTableFull„    END IF„ELSE„    ErrorCode = eqjSymbolTableFull„END IF„END SUB„„SUB sqjDesParse (Phase%, x)„„SHARED TestDeep%    ' This variable used for testing how deep recursion goes„' This is the central cortex of this module.„' It uses wicked recursion, so beware!  In fact, this routine is so„' recursive that unless you're a major masochist, you'd better leave it„' well enough alone!„TestDeep% = TestDeep% + 1   ' Used for testing phase only„„SELECT CASE Phase%„„    CASE 1„        ' See if something of a higher precedence should be done first.„        CALL sqjDesParse(2, x)„„        Op$ = TOKEN$(LvlPtr)„„        ' The lowest level of precedence is handled by this Level.„„        DO WHILE fqjInList(LOGICAL, Op$)„            CALL sqjGetToken„            CALL sqjDesParse(2, y)„            CALL sqjApplyOp(Op$, x, y)„            Op$ = TOKEN$(LvlPtr)„        LOOP„„    CASE 2„        ' See if something of a higher precedence should be done first.„        CALL sqjDesParse(3, x)„        Op$ = TOKEN$(LvlPtr)„„        DO WHILE fqjInList(ADDSUB, Op$)„            CALL sqjGetToken„            CALL sqjDesParse(3, y)„            CALL sqjApplyOp(Op$, x, y)„            Op$ = TOKEN$(LvlPtr)„        LOOP„„    CASE 3„        ' See if something of a higher precedence should be done first.„        CALL sqjDesParse(4, x)„„        Op$ = TOKEN$(LvlPtr)„„        DO WHILE fqjInList(MULTDIV, Op$)„            CALL sqjGetToken„            CALL sqjDesParse(4, y)„            CALL sqjApplyOp(Op$, x, y)„            Op$ = TOKEN$(LvlPtr)„        LOOP„„    CASE 4„        ' See if something of a higher precedence should be done first.„        CALL sqjDesParse(5, x)„„        Op$ = TOKEN$(LvlPtr)„„        IF fqjInList(POWER, Op$) THEN„            CALL sqjGetToken„            CALL sqjDesParse(5, y)„            CALL sqjApplyOp(Op$, x, y)„        END IF„„    CASE 5„        Op$ = ""„„        IF TypeToken(LvlPtr) = OperatorClass AND (fqjInList(ADDSUB, TOKEN$(LvlPtr))) THEN„            Op$ = TOKEN$(LvlPtr)„            CALL sqjGetToken„        END IF„„        CALL sqjDesParse(6, x)„„        ' This handles negative prefixes„        SELECT CASE Op$„            CASE "-"„                x = -x„        END SELECT„„    CASE 6„        ' This level handles parentheses„„        IF TOKEN$(LvlPtr) = "(" AND TypeToken(LvlPtr) = OperatorClass THEN„            CALL sqjGetToken„            CALL sqjDesParse(1, x)„„            IF TOKEN$(LvlPtr) <> ")" THEN„                ErrorCode = eqjMismatchedParenthesis„            END IF„„            CALL sqjGetToken„        ELSE„            SELECT CASE TypeToken(LvlPtr)„                CASE DigitClass„                    x = VAL(TOKEN$(LvlPtr))„                    CALL sqjGetToken„„                CASE FunctionClass„                    x = fqjSolveFormula(TOKEN$(LvlPtr))„                    TypeToken(LvlPtr) = DigitClass„                    CALL sqjGetToken„            END SELECT„        END IF„END SELECT„END SUB„„SUB sqjGetToken„„TOKEN$(LvlPtr) = ""„„DO WHILE fqjInList(WHITESPACE, MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1))„    PTR(LvlPtr) = PTR(LvlPtr) + 1„LOOP„„Temp$ = MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)„IF Temp$ >= "0" AND Temp$ <= "9" THEN„„    ' Build up a number from its digits„    DO WHILE INSTR(" ()" + OPERATOR$, MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)) = 0„        TOKEN$(LvlPtr) = TOKEN$(LvlPtr) + MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)„        PTR(LvlPtr) = PTR(LvlPtr) + 1„    LOOP„„    TypeToken(LvlPtr) = DigitClass„    EXIT SUB„END IF„„IF INSTR("()" + OPERATOR$, MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)) THEN„„    TypeToken(LvlPtr) = OperatorClass„    TOKEN$(LvlPtr) = MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)„    PTR(LvlPtr) = PTR(LvlPtr) + 1„„    IF INSTR("()", TOKEN$(LvlPtr)) THEN„        EXIT SUB„    ELSE„        ' see if it's a compound operator„        IF INSTR(OPERATOR$, MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)) THEN„            Temp$ = MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)„            IF Temp$ <> "-" THEN„                TOKEN$(LvlPtr) = TOKEN$(LvlPtr) + Temp$„                PTR(LvlPtr) = PTR(LvlPtr) + 1„            END IF„        END IF„    END IF„    EXIT SUB„END IF„„Temp$ = MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)„IF Temp$ >= "@" AND Temp$ <= "Z" THEN„„„    ' Build up a variable name based upon letters„    DO WHILE INSTR(" ()" + OPERATOR$, MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)) = 0„        Temp$ = MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)„        IF Temp$ <> "[" THEN„            TOKEN$(LvlPtr) = TOKEN$(LvlPtr) + Temp$„            PTR(LvlPtr) = PTR(LvlPtr) + 1„        ELSE„            TOKEN$(LvlPtr) = TOKEN$(LvlPtr) + "["„            DO WHILE SepPtr% <> -1„                PTR(LvlPtr) = PTR(LvlPtr) + 1„                T$ = MID$(EXPR$(LvlPtr), PTR(LvlPtr), 1)„                SELECT CASE T$„                    CASE "["„                        SepPtr% = SepPtr% + 1„                    CASE "]"„                        SepPtr% = SepPtr% - 1„                END SELECT„                TOKEN$(LvlPtr) = TOKEN$(LvlPtr) + T$„            LOOP„            PTR(LvlPtr) = PTR(LvlPtr) + 1„            TypeToken(LvlPtr) = FunctionClass„            EXIT SUB„        END IF„    LOOP„„    TOKEN$(LvlPtr) = STR$(fqjFetchVar(TOKEN$(LvlPtr)))„    TypeToken(LvlPtr) = DigitClass„    EXIT SUB„END IF„END SUB„„Quinn Tyler Jackson            WORD COMPRESSIONS              WORD,COMPRESSIONS              Unknown Date (00:00)   QB, QBasic, PDS        195  5189     WRDPRESS.BASDECLARE FUNCTION fqjSqueeze$ (InString$, Table$())„DECLARE FUNCTION fqjTableInit% ()„DECLARE FUNCTION funQompress$ (InText$)„DEFINT A-Z„OPTION BASE 1„ „' Compression types„CONST WordType = 255            'Word compression was achieved.„ „CONST TrigramType = 254         'Trigram compression was acheived.„ „CONST DigramType = 253          'Digram compression was achieved.„ „CONST NoType = 254              'No reasonable compression was possible.„                                'The maximum amount that could be achieved„                                'follows the NoType byte.„ „DIM SHARED WordTable$(128 TO 228)„DIM SHARED TriTable$(128 TO 226)„DIM SHARED DiTable$(128 TO 227)„ „ „nul = fqjTableInit„OPEN "TEST.TXT" FOR INPUT AS #1„ „ „DO„ „LINE INPUT #1, Txt$„NewText$ = funQompress(Txt$)„NewLen = LEN(NewText$)„Ratio = (LEN(Txt$) - NewLen)„Saved = Saved + Ratio„ „SELECT CASE ASC(NewText$)„    CASE WordType„        PRINT "W: "; Ratio„    CASE TriType„        PRINT "T: "; Ratio„    CASE DiType„        PRINT "D: "; Ratio„    CASE NoType„        PRINT "N: "; Ratio„    CASE ELSE„END SELECT„ „LOOP UNTIL EOF(1)„ „PRINT "Saved"; Saved; "bytes on a file of"; LOF(1); "bytes."„ „CLOSE„ „END„ „EnglishWordData:„ „' Below are listed the hundred most frequently used words in English.„' Taken from fifteen English authors and many newspapers.  Compiled by„' Frank R. Fraprie.  Taken from Helen Gaines Fouche's _Cryptanalysis_,„' which is published by Dover Publications since 1956.„ „DATA the,of,and,to,a,in,that,is,I,it„DATA for,as,with,was,his,he,be,not,by,but„DATA have,you,which,are,on,or,her,had,at,from„DATA this,my,they,all,their,an,she,has,were,me„DATA been,him,one,so,if,will,there,who,no,we„DATA when,what,your,more,would,them,some,than,may,upon„DATA its,out,into,our,these,man,up,do,like,after„DATA shall,great,now,such,should,other,only,any,then,yet„DATA about,those,can,made,well,old,must,us,said,time,two„DATA time,even,new,could,very,much,own,most,might,first„ „EnglishTrigramData:„ „' The ninety-eight most frequent English trigrams, combining a count of„' 20,000 trigrams by Fletcher Pratt, in "Secret and Urgent," supposed not„' to include include overlaps between words, and 5,000 by Frank R. Fraprie,„' including overlaps.  Also taken from Fouche's _Crytanalysis_.„ „DATA the,ing,and,ion,ent,for,tio,ere,her,ate„DATA ver,ter,tha,ati,hat,ers,his,res,ill,are„DATA con,nce,all,eve,ith,ted,ain,est,man,red„DATA thi,ive,rea,wit,ons,ess,ave,per,ect,one„DATA und,int,ant,hou,men,was,oun,pro,sta,ine„DATA whi,ove,tin,ast,der,ous,rom,ven,ard,ear„DATA din,sti,not,ort,tho,day,ore,but,out,ure„DATA str,tic,ame,com,our,wer,ome,een,lar,les„DATA san,set,any,art,nte,rat,rut,ica,ich,nde„DATA pre,enc,has,whe,will,era,lin,tra„ „EnglishDigramData:„ „' One-hundred digrams from the same book, also compiled by„' Pratt and Fraprie from 20,000 trigrams.„ „DATA th,in,er,re,an,he,ar,en,ti,te„DATA at,on,ha,ou,it,es,st,or,nt,hi„DATA es,st,or,nt,hi,ea,ve,co,de,ra„DATA ro,li,ri,io,le,nd,ma,se,al,ic„DATA fo,il,ne,la,ta,el,me,ec,is,di„DATA si,ca,un,ut,nc,wi,ho,tr,be,ce„DATA wh,ll,fi,no,to,pe,as,wa,ur,lo„DATA pa,us,mo,om,ai,pr,we,ac,ee,et„DATA sa,ni,rt,na,ol,ev,ie,mi,ng,pl„DATA iv,po,ch,ei,ad,ss,il,os,ul,em„„FUNCTION fqjSqueeze$ (InString$, Table$())„ „   s$ = InString$„   FOR ASCII = LBOUND(Table$) TO UBOUND(Table$)„      DO„         i = INSTR(s$, Table$(ASCII))„         IF i THEN„ „s$ = LEFT$(s$, i - 1) + CHR$(ASCII) + MID$(s$, i + LEN(Table$(ASCII)))„ „         END IF„      LOOP WHILE i„   NEXT„ „   fqjSqueeze$ = s$„ „END FUNCTION„„FUNCTION fqjTableInit„' This function initializes all compression tables and returns a value„' equal to how many thousandths of a second is required to intialize the„' tables.„ „StartTime! = TIMER„RESTORE EnglishWordData„ „FOR i = LBOUND(WordTable$) TO UBOUND(WordTable$)„    READ WordTable$(i)„    WordTable$(i) = WordTable$(i) + " "„NEXT i„ „RESTORE EnglishTrigramData„ „FOR i = LBOUND(TriTable$) TO UBOUND(TriTable$)„    READ TriTable$(i)„NEXT i„ „RESTORE EnglishDigramData„ „FOR i = LBOUND(DiTable$) TO UBOUND(DiTable$)„    READ DiTable$(i)„NEXT i„ „fqjTableInit = (TIMER - StartTime!) * 1000„ „END FUNCTION„„FUNCTION funQompress$ (InText$)„STATIC WCount, TCount, DiCount„ „IF LTRIM$(RTRIM$(InText$)) = "" THEN„    funQompress$ = CHR$(NoType)„    EXIT FUNCTION„END IF„ „OrigLen = LEN(InText$)„ „Word$ = fqjSqueeze(InText$, WordTable$())„Tri$ = fqjSqueeze(InText$, TriTable$())„Di$ = fqjSqueeze(InText$, DiTable$())„ „Word = LEN(Word$)„Tri = LEN(Tri$)„Di = LEN(Di$)„ „IF Tri < Di AND Tri < Word THEN„    Txt$ = Tri$„    METH$ = CHR$(TriType)„    TCount = TCount + 1„ELSEIF Di < Word THEN„        Txt$ = Di$„        METH$ = CHR$(DiType)„        DiCount = DiCount + 1„ELSE„    Txt$ = Word$„    METH$ = CHR$(WordType)„    WCount = WCount + 1„END IF„ „SELECT CASE OrigLen > LEN(Txt$)„    CASE -1„        Txt$ = METH$ + MKI$(OrigLen) + Txt$„    CASE ELSE„        Txt$ = CHR$(NoType) + MKI$(OrigLen) + InText$„END SELECT„ „funQompress$ = Txt$„END FUNCTION„„Unknown Author(s)              CALCULATING CRC BLOCKS         CALCULATING,CRC,BLOCKS         Unknown Date (00:00)   QB, QBasic, PDS        47   1876     CRC.BAS     '=== BEGIN: CRC.BAS ===„DECLARE FUNCTION CRC16& (Block$)„DECLARE FUNCTION CRC32& (Block$)„'=== END ===„„DEFINT A-Z„FUNCTION CRC16& (B$)      'Calculates CRC for Each Block„„DIM Power(0 TO 7)                              'For the 8 Powers of 2„DIM CRC AS LONG„„FOR I = 0 TO 7                                 'Calculate Once PerBlock to„   Power(I) = 2 ^ I                            ' Increase Speed Within FOR J„NEXT I                                         ' Loop„CRC = 0                                        'Reset for Each Text Block„FOR I = 1 TO LEN(B$)                           'Calculate for Length of Block„   ByteVal = ASC(MID$(B$, I, 1))„   FOR J = 7 TO 0 STEP -1„      TestBit = ((CRC AND 32768) = 32768) XOR ((ByteVal AND Power(J)) = Power(J))„      CRC = ((CRC AND 32767&) * 2&)„      IF TestBit THEN CRC = CRC XOR &H1021&     ' <-- This for 16 Bit CRC„   NEXT J„NEXT I„CRC16& = CRC                               'Return the Word Value„END FUNCTION„„DEFSNG A-Z„FUNCTION CRC32& (B$)      'Calculates CRC for Each Block„„DIM Power(0 TO 7)                              'For the 8 Powers of 2„DIM CRC AS LONG„„FOR I = 0 TO 7                                 'Calculate Once Per Block to„   Power(I) = 2 ^ I                            ' Increase Speed Within FOR J„NEXT I                                         ' Loop„CRC = 0                                        'Reset for Each Text Block„FOR I = 1 TO LEN(B$)                           'Calculate for Length of Block„   ByteVal = ASC(MID$(B$, I, 1))„   FOR J = 7 TO 0 STEP -1„      TestBit = ((CRC AND 32768) = 32768) XOR ((ByteVal AND Power(J)) = Power(J))„      CRC = ((CRC AND 32767&) * 2&)„      IF TestBit THEN CRC = CRC XOR &H8005&     ' <-- This for 32 Bit CRC„   NEXT J„NEXT I„CRC32& = CRC                               'Return the Word Value„END FUNCTION„„Victor Yiu                     ASSEMBLY PI                    ASSEMBLY,PI                    07/93 (00:00)          QB, PDS                209  6171     ASMPI.BAS   ' AsmPI v1.0 ˛ (C) Copyright Victor Yiu, July 1993.„' ~~~~~~~~~~„' FAST! FAST! FAST! FAST! FAST!„'„' Using hand-coded assembly routines I wrote, this program will calculate„' pi up to 20,000 digits at -really- high speeds.  I used Rich Geldreich's„' original BASIC public-domain "BCDPI" program as a guide.  Only thing is:„' this version is much faster.„„DECLARE SUB asmBCDInit (BYVAL NumDigits%)„DECLARE SUB asmBCDclr (BYVAL Segm%)„DECLARE SUB asmBCDadd (BYVAL SegmA%, BYVAL SegmB%)„DECLARE SUB asmBCDsub (BYVAL SegmA%, BYVAL SegmB%)„DECLARE SUB asmBCDmul (BYVAL SegmA%, BYVAL SegmB%, BYVAL Mult%)„DECLARE FUNCTION asmBCDdiv% (BYVAL SegmA%, BYVAL SegmB%, BYVAL Divisor%)„DECLARE FUNCTION asmBCDdivL% (BYVAL SegmA%, BYVAL SegmB%, BYVAL Divisor%)„„' Warning: These hand-coded BCD arithmetic libraries are designed for„' use in this program only.  Almost all error checking is removed;„' and sqeezed for every last ounce of speed left <g>.  Because of this,„' it only handles conditions such as ones in this program ... i.e.„' being able to only positive numbers.  It is hard to reuse these procs.„' without modification.„„DECLARE SUB BCDdisplay (Array%())„DECLARE SUB PrintIt (Text$)„„DEFINT A-Z„CONST False = 0, True = NOT False„„NumDigits = 500    ' Range: 1 to 20,000„PassIn = VAL(COMMAND$)„IF (PassIn >= 10) AND (PassIn <= 20000) THEN NumDigits = PassIn„NumDigits = NumDigits + 5„„Limit1 = (NumDigits / .69897) + ((NumDigits / .69897) * .1) + 5„Limit2 = (NumDigits / 2.37) + 7„„DIM NumA(NumDigits \ 2), NumB(NumDigits \ 2), NumC(NumDigits \ 2)„asmBCDInit NumDigits        ' initialize ASM routines„„CLS : COLOR 14„PRINT "AsmPI 1.0 ˛ (C) Copyright Victor Yiu, 1993"„PRINT STRING$(42, "~"): COLOR 7„IF VARPTR(NumA(0)) + VARPTR(NumB(0)) + VARPTR(NumC(0)) <> 0 THEN„    PRINT "Arrays not aligned on segment boundaries."„    PRINT "Unusual."„    STOP„END IF„PRINT "Calculating"; NumDigits - 5; "digits.  <Esc> to abort.";„COLOR 31„PRINT "    BLAZINGLY SUPER-FAST!!!  WOW!"„COLOR 7: PRINT„„A = VARSEG(NumA(0)): B = VARSEG(NumB(0)): C = VARSEG(NumC(0))„„asmBCDclr A             ' A = 10^(NumDigits-1)„asmBCDclr B„FirstDigit = (NumDigits - 1) \ 2„IF NumDigits AND 1 THEN„    NumA(FirstDigit) = 1„ELSE„    NumA(FirstDigit) = 256„END IF„„PRINT "Pass 1: 0  %";„t! = TIMER                  ' start timer„                            ' do pass 1 specially:„Divisor = 3„Dummy = asmBCDdiv(A, A, 5)„Dummy = asmBCDdivL(A, C, 1) ' just copy A -> C„asmBCDadd B, C„„DO WHILE Divisor < Limit1„„    Dummy = asmBCDdiv(A, A, 25)„    Dummy = asmBCDdivL(A, C, Divisor)„    asmBCDsub B, C„    Divisor = Divisor + 2„„    Dummy = asmBCDdiv(A, A, 25)„    Dummy = asmBCDdivL(A, C, Divisor)„    asmBCDadd B, C„    Divisor = Divisor + 2„„    IF (Divisor AND 15) = 15 THEN„        LOCATE , 8„        PRINT Divisor * 100& \ Limit1;„        IF INKEY$ = CHR$(27) THEN PRINT : PRINT "Aborted.": END„    END IF„LOOP„asmBCDmul B, B, 4„„LOCATE , 1„PRINT "Pass 1 complete."„PRINT "Pass 2: 0  %";„„asmBCDclr A     ' A = 10^(NumDigits-1)„IF NumDigits AND 1 THEN„    NumA(FirstDigit) = 1„ELSE„    NumA(FirstDigit) = 256„END IF„„Divisor = 3„Dummy = asmBCDdiv(A, A, 239)„Dummy = asmBCDdivL(A, C, 1)„asmBCDsub B, C„„DO WHILE Divisor < Limit2„    Dummy = asmBCDdiv(A, A, 239)   ' 239^2„    Dummy = asmBCDdiv(A, A, 239)„    Dummy = asmBCDdivL(A, C, Divisor)„    asmBCDadd B, C„    Divisor = Divisor + 2„„    Dummy = asmBCDdiv(A, A, 239)„    Dummy = asmBCDdiv(A, A, 239)„    Dummy = asmBCDdivL(A, C, Divisor)„    asmBCDsub B, C„    Divisor = Divisor + 2„„    IF (Divisor AND 7) = 7 THEN„        LOCATE , 8„        PRINT Divisor * 100& \ Limit2;„        IF INKEY$ = CHR$(27) THEN PRINT : PRINT "Aborted.": END„    END IF„LOOP„asmBCDmul B, B, 4„„LOCATE , 1„PRINT "Pass 2 complete.  Time:"; TIMER - t!; "secs."„BCDdisplay NumB()„„SUB BCDdisplay (Array())„SHARED NumDigits„„DEF SEG = VARSEG(Array(0))„Start = NumDigits - 1„Tens = -1„OPEN "PI" FOR OUTPUT AS #1„PRINT„„FOR Disp = Start TO 4 STEP -1     ' skip last 5 or so„    Temp = PEEK(Disp)„    IF Temp > 9 THEN„        PRINT„        PRINT "Bad number!  Error in program!"„    ELSE„        Tens = Tens + 1„„        PrintIt CHR$(Temp + 48)„        IF Disp = Start THEN„            PrintIt "."„        ELSEIF (Tens MOD 10) = 0 THEN„            PrintIt " "„            IF (Tens MOD 70) = 0 THEN„                PrintIt "": PrintIt "  "„            END IF„        END IF„    END IF„NEXT„CLOSE„„DEF SEG„„END SUB„„SUB PrintIt (Text$)„„IF LEN(Text$) THEN„    PRINT Text$;„    PRINT #1, Text$;„ELSE„    PRINT„    PRINT #1,„END IF„„END SUB„„„„'---------8<----[ Begin ASMPILIB.BAS ]---->8---------------„„DEFINT A-Z:DIM SHARED B,K,S,B&,Z&:XA '** by PostIt! 7.0 ** BETA„SUB XA:OPEN "O",1,"ASMPI.LZH",4^6:Z&=583:?STRING$(50,177);„U"DE^P9$5XPE#%##2Y)##*+$O=C#$,dv#pslQ#ole2%kp##M$?/Hm1Y6Upn8VR]Gw„U"K9$-^[V0-2G)Itt./+bEA>p)[-_i'\S',3f)/PiIROKamsMm7e'07d-H9D-N?W(„U"_HO-K)nguj,A[KbR%!&p&(0%3WB2UnBQf>\0`OZr?!mS$M_#3L,*Dm$YOoQN?6I„U"t[W6t_^[B]4q_eBI92TDvfas8G(`Jh',(<J%cCkgg8Du%=m(lhtob.;^%i!u5-W„U"iBoDkOA$2w9Z4!.wt%!sD'j,uJ=e=v.%H?SXp4b0i(]I-,`glMP]3QH\t<Z8wtg„U"0O!+%RU^BV+R>OV,h\s/$:'OZ=YA8Tpbs-`Y#`)k]71-lrH/m&nQ0Y0N?C!5XK(„U"kwes\)l6hq3:*M;74&dlmngv]tUL>^BZrmiK;'r[pH&u?x\bKO+*fG\&kLg+j*W„U"$I^U/t+jp?tn[g&drknhRMG>s%Pk^cP0H=-Vk!`VwlS;VV$SAq&g-<ld6GgYG3W„U"[fo&%<1W;*hee(+CX3jG/N2=J7Nx\7,<H6-3nN1nRatESc.E2r&1F_86GQ#E_D(„U"5pI89rOa0^L90\<Y2<:$2Fe-.eBYZ.bqNk;<T<S9D[;^?sio0WQ146_jH7fIU^Y„U"`^]4E?WZ\U>#l0;qF1AR4&\=kUfUV^s[O'X=cSfcMQ#Lik$rEi==Up)aUfY.fC+„U"O.s77u.7YYo-,3ViRr*dqBUv'rOa^cdl'rM#"„END SUB„CLOSE:IF S=198AND B&=Z&THEN?":) Ok"ELSE?":( Bad„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-35:B=B-1:IF C<0THEN C=29„S=(S+C)*2:IF B<0THEN B=4:K=C ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=S\256+(S AND 255):NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„„'---------8<----[ Begin ASMPILIB.BAS ]---->8---------------„„' ------- That's it, folks!„' I hope you enjoy it!  Please feel free to leave me a message on„' comments and suggestions.  Wow, this was fun!  Thanks!„Rich Geldreich                 PRIME NUMBER GENERATOR         PRIME,NUMBER,GENERATOR         Unknown Date (00:00)   QB, QBasic, PDS        212  4825     PRIME.BAS   'Prime Number Generator„'Algorithm from Knuth's "Sorting and Searching" Page 617„'Programmed by Rich Geldreich„'„'Notes:  This  prime   number   generator   uses   a   disk   file„'"PRIMEBUF.BIN" to hold the prime numbers, so little RAM memory is„'needed.   Each  prime  number  is  represented  as the difference„'between the last prime number by  a single byte.  In other words,„'the gap between each prime number is stored instead of each prime„'number itself.  All gaps are even  numbers,  because  all  primes„'must be odd numbers.  Therefore, each byte can represent a gap of„'up  to  510, because the least significant bit of each gap length„'is always unused.  (Except for the special cases of 1-2, and 2-3.„'These primes aren't stored in  the  disk file; they're assumed to„'be present.) Since the maximum gap between all consecutive primes„'up to 436,273,009 is only 286, a single byte is good  enough  for„'this program!)„'„'The  program  stops  when  escape is pressed or when the priority„'queue is full.„'„'On a 286/10, roughly 3.2 million prime numbers were calculated in„'about 2.5 hours by this program.„'„DEFINT A-Z„„DECLARE SUB PutPrime (a&)„DECLARE FUNCTION GetPrime& ()„„'Maximum prime candidate = HeapSize*HeapSize„CONST HeapSize = 4096„CONST IOSize = 2048„„OPEN "primebuf.bin" FOR OUTPUT AS #1: CLOSE #1„OPEN "primebuf.bin" FOR BINARY AS #1„„DIM SHARED PrimeBuf1 AS STRING * IOSize, Buf1Loc, Buf1FLoc AS LONG„DIM SHARED PrimeBuf2 AS STRING * IOSize, Buf2Loc, Buf2FLoc AS LONG„DIM SHARED SlideFlag„DIM SHARED LastPrime1&, LastPrime2&„„Buf1Loc = 1 + (1 - 1): Buf1FLoc = 1„Buf2Loc = 1 + (2 - 1): Buf2FLoc = 1„LastPrime1& = 3„LastPrime2& = 5„„'Priority queue„DIM HeapQ(1 TO HeapSize) AS LONG„DIM HeapQ1(1 TO HeapSize) AS LONG„DIM HeapQ2(1 TO HeapSize) AS LONG„„DIM SHARED n AS LONG„DIM t AS LONG„DIM Q AS LONG, Q1 AS LONG, Q2 AS LONG„DIM TQ AS LONG, TQ1 AS LONG„DIM u AS LONG„„n = 5„d = 2„r = 1„t = 25„HeapQ(1) = 25„HeapQ1(1) = 10„HeapQ2(1) = 30„„DO„  DO„    Q = HeapQ(1)„    Q1 = HeapQ1(1)„    Q2 = HeapQ2(1)„„    TQ = Q + Q1„    TQ1 = Q2 - Q1„„    '***Insert Heap(1) into priority queue„    i = 1„    DO„        j = i * 2„        IF j <= r THEN„            IF j < r THEN„                IF HeapQ(j) > HeapQ(j + 1) THEN„                  j = j + 1„                END IF„            END IF„„            IF TQ > HeapQ(j) THEN„                HeapQ(i) = HeapQ(j)„                HeapQ1(i) = HeapQ1(j)„                HeapQ2(i) = HeapQ2(j)„                i = j„            ELSE„                EXIT DO„            END IF„        ELSE„            EXIT DO„        END IF„    LOOP„    HeapQ(i) = TQ„    HeapQ1(i) = TQ1„    HeapQ2(i) = Q2„    '***„„  LOOP UNTIL n <= Q„„  DO WHILE n < Q„    PutPrime n„    n = n + d„    d = 6 - d„  LOOP„„  IF n = t THEN„„    u = GetPrime„    t = u * u„„    '***Find location for new entry„    j = r + 1„    DO„      i = j \ 2„      IF i = 0 THEN„        EXIT DO„      END IF„      IF HeapQ(i) <= t THEN„        EXIT DO„      END IF„      HeapQ(j) = HeapQ(i)„      HeapQ1(j) = HeapQ1(i)„      HeapQ2(j) = HeapQ2(i)„      j = i„    LOOP„    '***„    HeapQ(j) = t„    IF (u MOD 3) = 2 THEN„      HeapQ1(j) = 2 * u„    ELSE„      HeapQ1(j) = 4 * u„    END IF„    HeapQ2(j) = 6 * u„„    r = r + 1„    IF r = HeapSize THEN 'Don't overflow priority queue„      EXIT DO„    END IF„„  END IF„„  n = n + d„  d = 6 - d„„LOOP UNTIL LEN(INKEY$)„„'Print prime numbers calculated. (Except for the last few„'which are still in the output buffer.)„„CLS„SEEK #1, 1„LastPrime& = 3„PRINT 1; 2; 3;„FOR a = 1 TO LOF(1) \ IOSize„  GET #1, , PrimeBuf1„  FOR b = 1 TO IOSize„    LastPrime& = LastPrime& + ASC(MID$(PrimeBuf1, b, 1)) * 2„    PRINT LastPrime&;„  NEXT„  IF LEN(INKEY$) THEN EXIT FOR„NEXT„CLOSE„END„„FUNCTION GetPrime&„„  IF SlideFlag = 0 THEN„    LastPrime2& = LastPrime2& + 2 * ASC(MID$(PrimeBuf1, Buf2Loc, 1))„  ELSE„    LastPrime2& = LastPrime2& + 2 * ASC(MID$(PrimeBuf2, Buf2Loc, 1))„  END IF„  GetPrime& = LastPrime2&„„  Buf2Loc = Buf2Loc + 1„  IF Buf2Loc = (IOSize + 1) THEN„    Buf2FLoc = Buf2FLoc + IOSize„    GET #1, Buf2FLoc, PrimeBuf2„    Buf2Loc = 1„  END IF„„END FUNCTION„„SUB PutPrime (a&)„„  STATIC TotalPrimes AS LONG„„  MID$(PrimeBuf1, Buf1Loc) = CHR$((a& - LastPrime1&) \ 2)„  Buf1Loc = Buf1Loc + 1„„  IF Buf1Loc = (IOSize + 1) THEN„    TotalPrimes = TotalPrimes + IOSize„    LOCATE , 1„    PRINT "Primes found:"; TotalPrimes; "Maximum candidate:"; n;„„    PUT #1, Buf1FLoc, PrimeBuf1„    Buf1Loc = 1„    Buf1FLoc = Buf1FLoc + IOSize„„    IF SlideFlag = 0 THEN„      SlideFlag = -1„      PrimeBuf2 = PrimeBuf1„    END IF„  END IF„„  LastPrime1& = a&„„END SUB„Unknown Author(s)              JULIA FRACTAL                  JULIA,FRACTAL                  Unknown Date (00:00)   QB, QBasic, PDS        134  4586     JULFRAC.BAS 'The Julia set.  A fascinating fractal discovered by Raoul Julia,„'a French mathematician who was born in the 19th century.„'It is defined in the complex plane by the *simple* equation:„'f(Z) = Z^2 +U, where Z and U are complex numbers of the form„'a + bi where i = SQR(-1)..„'I leave this to my friends in the QuickBASIC conference.„'You'll need a VGA screen.  You'll REALLY appreciate an 80397„'numerical co-processor.„'It might even work with interpreted QBASIC.  Tell me about it.„'It is *highly* recommended that you compile the program first..„'You can choose a linear magnification anywhere between 1 and„'100,000,000,000,000 (1 followed by 14 zeroes).  In practice,„'you should not go beyond 13 zeroes, as we then reach the CPU's„'precision limit..„'Choosing successive magnifications of 1, 400, 160000, ...(x 400)„'will give you a screen which represents the *details* included„'in *one* dot of the previous magnification..„'At magnification 10^14, the whole screen represents the details„''missing' from the original magnification 1 screen which has„''grown' to a size of 10 billion kilometers in width!!!„'--------------------------- Cut here ---------------------------„'$DYNAMIC„DEFINT A-Z„CONST PI = 3.141592654#„CONST TWOPI = PI * 2#„CONST False = 0, True = NOT False„CONST SPAN = 200  'virtual 200x200 dot screen.„TYPE Cplex        'Complex type (a + bi) where a & b are reals„  Re AS DOUBLE    'and where i = SQRT(-1)„  Im AS DOUBLE    'Conventionaly, a is the Re(al) part and„END TYPE          'b is the Im(aginary) part.„„DECLARE SUB DoPalette (Pal)„DECLARE SUB Julia (U AS Cplex, Mag#)„DECLARE SUB CplexADD (Num1 AS Cplex, Num2 AS Cplex, Answ AS Cplex)„DECLARE SUB CplexMUL (Num1 AS Cplex, Num2 AS Cplex, Answ AS Cplex)„„DO„  SCREEN 0, 0, 0, 0„  WIDTH 80, 25„  CLS„  LOCATE 12, 35„  PRINT "Julia set, written by Raymond Paquin"„  DO„    LOCATE 14, 1„    INPUT "Magnification (1 to 100000000000000, 0 to abort)"; Mag#„  LOOP UNTIL (Mag# >= 1# AND Mag# <= 100000000000000#) OR Mag# = 0„  IF Mag# = 0# THEN EXIT DO„  DO„    LOCATE 16, 1„    INPUT "Palette, 1 (structure), 2 (artistic), 0 to abort)"; Pal„  LOOP UNTIL Pal = 0 OR Pal = 1 OR Pal = 2„  IF Pal = 0 THEN EXIT DO„  SCREEN 13„  WINDOW (-SPAN, -SPAN)-(SPAN, SPAN)„  DIM U AS Cplex„  U.Re = .138341      'Don't mess with this„  U.Im = .649857      'Don't mess with this„                      'Of course, wou will. but don't come„                      'crying to me !„  DoPalette Pal„  Mag# = Mag# / 1.5#„  Julia U, Mag#„LOOP„END„„REM $STATIC„SUB CplexADD (Num1 AS Cplex, Num2 AS Cplex, Answ AS Cplex)„  Answ.Re = Num1.Re + Num2.Re„  Answ.Im = Num1.Im + Num2.Im„END SUB„„SUB CplexMUL (a AS Cplex, b AS Cplex, c AS Cplex)„  c.Re = a.Re * b.Re - a.Im * b.Im„  c.Im = a.Re * b.Im + a.Im * b.Re„END SUB„„SUB DoPalette (Pal)„  DIM Kolor&(0 TO 255)„  SELECT CASE Pal„    CASE 1„      FOR i = 0 TO 255„        Blue& = (CLNG(i) * 13&) MOD 64&„        Green& = (CLNG(i) * 3&) MOD 64&„        Red& = (CLNG(i) * 7&) MOD 64&„        PALETTE i, Blue& * 65536 + Green& * 256& + Red&„      NEXT i„    CASE 2„      FOR i = 0 TO 255„        b# = SIN(3# * TWOPI * (CDBL(i) / 63#))„        Blue& = CLNG(b# * b# * 63#)„        r# = SIN(2# * TWOPI * (CDBL(i) / 63#))„        Red& = CLNG(r# * r# * 63#)„        g# = SIN((TWOPI + PI) * (CDBL(i) / 63#))„        Green& = CLNG(g# * g# * 63#)„        PALETTE i, Blue& * 65536 + Green& * 256& + Red&„      NEXT i„  END SELECT„END SUB„„SUB Julia (U AS Cplex, Mag#)„DIM Z AS Cplex„DIM Z2 AS Cplex„OfX# = -.090010013#     'These two values have been chosen so that„OfY# = -.00002514951#   'successive magnifications would always„                        'yield 'interesting' regions.  Don't mess„                        'with them.  ... but you will ANYWAY ...„  InfX# = -1# / Mag# + OfX#„  SupX# = 1# / Mag# + OfX#„  IncrX# = .006245# / Mag#„„  InfY# = -1# / Mag# + OfY#„  SupY# = 1# / Mag# + OfY#„  IncrY# = .01# / Mag#„  „  FOR rz# = InfX# TO SupX# STEP IncrX#„    FOR iz# = InfY# TO SupY# STEP IncrY#„      IF INKEY$ <> "" THEN GOTO NoWaitKey„      Z.Re = rz#„      Z.Im = iz#„      FOR i = 0 TO 32767„        CplexMUL Z, Z, Z2   'The heart: Z <-- Z^2 + U, where„        CplexADD Z2, U, Z   'Z and U are complex numbers.„        IF Z.Re * Z.Re + Z.Im * Z.Im > 10# THEN EXIT FOR„      NEXT i„      i = i AND &HFF„      PRESET ((rz# - OfX#) * SPAN * Mag#, (iz# - OfY#) * SPAN * Mag#), i„    NEXT iz#„  NEXT rz#„  WHILE INKEY$ = ""„  WEND„NoWaitKey:„END SUB„„Unknown Author(s)              CALCULATOR FUNCTIONS           CALCULATOR,FUNCTIONS           Unknown Date           QB, QBasic, PDS        205  3990     CALC.BAS    DECLARE FUNCTION Calc# (A$)„DECLARE SUB Arith (OO$, R#, H#)„DECLARE SUB GetExp (R#)„DECLARE SUB GetToken ()„DECLARE SUB Level1 (R#)„DECLARE SUB Level2 (R#)„DECLARE SUB Level3 (R#)„DECLARE SUB Level4 (R#)„DECLARE SUB Level5 (R#)„DECLARE SUB Level6 (R#)„DECLARE SUB Ptv (R#)„DECLARE SUB Un (OO$, R#)„„DEFINT A-Z„„COMMON SHARED Token$, TokenType#, p#, Arg$„„'IF INSTR(PRG$, "+-*/<>()=&_?") THEN„'REPLACE "+" WITH " + " IN PRG$„'REPLACE "-" WITH " - " IN PRG$„'REPLACE "*" WITH " * " IN PRG$„''REPLACE "\" WITH " \ " IN PRG$„'REPLACE "/" WITH " / " IN PRG$„''REPLACE "^" WITH " ^ " IN PRG$„'REPLACE "<" WITH " < " IN PRG$„'REPLACE ">" WITH " > " IN PRG$„'REPLACE "(" WITH " ( " IN PRG$„'REPLACE ")" WITH " ) " IN PRG$„'REPLACE "=" WITH " = " IN PRG$„'REPLACE "&" WITH " & " IN PRG$„'REPLACE "?" WITH "" IN PRG$„'REPLACE "_"+CHR$(13,10) WITH " " IN PRG$„'END IF„„PRINT„PRINT "((1 + 2) + (3 - 5) * 4 )/ 6="„PRINT Calc("((1+2)+(3-5)*4)/6")„PRINT ((1 + 2) + (3 - 5) * 4) / 6#„PRINT„„DEFDBL A-Z„SUB Arith (OO$, R, H)„„  IF OO$ = "-" THEN R = (R - H)„  IF OO$ = "+" THEN R = (R + H)„  IF OO$ = "*" THEN R = (R * H)„  IF OO$ = "/" THEN R = (R / H)„  IF OO$ = "^" THEN R = (R ^ H)„  IF OO$ = "<" THEN R = (R < H)„  IF OO$ = ">" THEN R = (R > H)„  IF OO$ = "=" THEN R = (R = H)„„END SUB„„' All of the following subroutines are necessary to perform the recursive„' descent parser.  CALC is the only callable routine, and must be passed„' a string containing a valid math expression.„' An invalid expression, such as (2**4) or (1+2+3+) will result in a„' SYNTAX ERROR message, printed on the screen by the sub PTV().  Mismatched„' parenthesis result in an error message displayed by sub LEVEL6().  These„' error messages could be replaced with the ERROR nn statement, allowing your„' own error-handling routines to report the error.„'„' This routine supports boolean expressions (1>2) and unary operators (5*-1)„FUNCTION Calc (A$)„„  R = 0„  p = 1„  IF A$ = "" THEN GOTO EndCalcSub„  Arg$ = A$„  CALL GetExp(R)„  LET Calc = R„„EndCalcSub:„„END FUNCTION„„SUB GetExp (R)„„  CALL GetToken„  CALL Level1(R)„„END SUB„„SUB GetToken„„  Token$ = ""„„  WHILE MID$(Arg$, p, 1) = " "„    p = p + 1„  WEND„„  IF INSTR("-+*/^()<>=", MID$(Arg$, p, 1)) THEN„    TokenType = 1„    Token$ = MID$(Arg$, p, 1)„    p = p + 1„    EXIT SUB„  END IF„„    IF INSTR("01234567890.", MID$(Arg$, p, 1)) THEN„      WHILE INSTR(" -+*/^()<>=", MID$(Arg$, p, 1)) = 0„        Token$ = Token$ + MID$(Arg$, p, 1)„        p = p + 1„      WEND„      TokenType = 2„    END IF„„END SUB„„SUB Level1 (R)„„  CALL Level2(R): OO$ = Token$„  WHILE OO$ = "<" OR OO$ = ">" OR OO$ = "="„    CALL GetToken„    CALL Level2(H)„    CALL Arith(OO$, R, H)„    OO$ = Token$„  WEND„„END SUB„„SUB Level2 (R)„„  CALL Level3(R)„  OO$ = Token$„  WHILE OO$ = "+" OR OO$ = "-"„    CALL GetToken„    CALL Level3(H)„    CALL Arith(OO$, R, H)„    OO$ = Token$„  WEND„„END SUB„„SUB Level3 (R)„„  CALL Level4(R)„  OO$ = Token$„  WHILE OO$ = "*" OR OO$ = "/"„    CALL GetToken„    CALL Level4(H)„    CALL Arith(OO$, R, H)„    OO$ = Token$„  WEND„„END SUB„„SUB Level4 (R)„„  CALL Level5(R)„  IF Token$ = "^" THEN„    CALL GetToken„    CALL Level4(H)„    CALL Arith("^", R, H)„  END IF„„END SUB„„SUB Level5 (R)„„  OO$ = ""„  IF TokenType = 1 AND (Token$ = "+" OR Token$ = "-") THEN„    OO$ = Token$„    CALL GetToken„  END IF„„  CALL Level6(R)„  IF OO$ <> "" THEN CALL Un(OO$, R)„„END SUB„„SUB Level6 (R)„„  IF Token$ = "(" AND TokenType = 1 THEN GOTO Eddy:„  CALL Ptv(R)„  EXIT SUB„„Eddy:„  CALL GetToken„  CALL Level1(R)„  IF Token$ <> ")" THEN ERROR 102„  CALL GetToken„„END SUB„„SUB Ptv (R)„„  IF TokenType = 2 THEN„    R = VAL(Token$)„    CALL GetToken„    EXIT SUB„  END IF„„  BEEP„  ERROR 101„  END„„END SUB„„SUB Un (OO$, R)„„  IF OO$ = "-" THEN R = -R„„END SUB„„Unknown Author(s)              METRIC CONVERTER               METRIC,CONVERTER               Unknown Date           QB, QBasic, PDS        1047 18675    METRIC.BAS  DECLARE SUB Pause (a!)„DECLARE SUB Frame (left%, Right%, top%, bottom%)„DECLARE SUB Stars (co!, qwe$)„DECLARE SUB Chart (starter, stoper, inc, number)„DECLARE SUB CtoI ()„DECLARE SUB KtoF ()„DECLARE SUB FtoK ()„DECLARE SUB KtoC ()„DECLARE SUB CtoK ()„DECLARE SUB KtoP ()„DECLARE SUB PtoK ()„DECLARE SUB FtoC ()„DECLARE SUB CtoF ()„DECLARE SUB ItoC ()„DECLARE FUNCTION CM! (s!)„DECLARE FUNCTION In! (a!)„DECLARE FUNCTION CelK! (u!)„DECLARE FUNCTION KelC! (l!)„DECLARE FUNCTION KelF! (i!)„DECLARE FUNCTION FahrK! (r!)„DECLARE FUNCTION Kg! (o!)„DECLARE FUNCTION Lbs! (n!)„DECLARE FUNCTION Fahr! (a!)„DECLARE FUNCTION Celsius! (s!)„„COMMON SHARED rou„COLOR 13„BEEP„ON KEY(31) GOSUB F12„KEY(31) ON„CLS„WIDTH 80, 50„r% = 5„c% = 37„Frame 23, 56, 1, 5„COLOR 10„LOCATE 2, 24„PRINT "Welcome to the metric converter:"„COLOR 15„LOCATE 3, 36„PRINT "Convert"„COLOR 10„LOCATE 4, 31„„DO„ „  rou = 0„  PRINT "Any key to continue"„ „  DO„  LOOP UNTIL INKEY$ <> ""„ „  CLS„  COLOR 12„  LOCATE r% - 1, c%„  PRINT "M E N U"„  COLOR 13„  Frame 27, 53, r% + 1, 28„  LOCATE r% + 2, c% - 9„  COLOR 14„  PRINT "1";„  COLOR 9„  PRINT ".  Fahrenheit to Celsius"„  LOCATE r% + 4, c% - 9„  COLOR 14„  PRINT "2";„  COLOR 9„  PRINT ".  Celsius to Fahrenheit"„  LOCATE r% + 6, c% - 9„  COLOR 14„  PRINT "3";„  COLOR 9„  PRINT ".  Inches to Centimeters"„  LOCATE r% + 8, c% - 9„  COLOR 14„  PRINT "4";„  COLOR 9„  PRINT ".  Centimeters to Inches"„  LOCATE r% + 10, c% - 9„  COLOR 14„  PRINT "5";„  COLOR 9„  PRINT ".  Kilogram to Pounds"„  LOCATE r% + 12, c% - 9„  COLOR 14„  PRINT "6";„  COLOR 9„  PRINT ".  Pounds to Kilograms"„  LOCATE r% + 14, c% - 9„  COLOR 14„  PRINT "7";„  COLOR 9„  PRINT ".  Kelvien to Celsius"„  LOCATE r% + 16, c% - 9„  COLOR 14„  PRINT "8";„  COLOR 9„  PRINT ".  Celsius to Kelvien"„  LOCATE r% + 18, c% - 9„  COLOR 14„  PRINT "9";„  COLOR 9„  PRINT ".  Kelvien to Fahrenheit"„  LOCATE r% + 20, c% - 9„  COLOR 14„  PRINT "0";„  COLOR 9„  PRINT ".  Fahrenheit to Kelvien"„  LOCATE r% + 22, c% - 9„  COLOR 14„  PRINT "X";„  COLOR 9„  PRINT ".  Exit"„  COLOR 11„  LOCATE 49, 26„  PRINT "[Esc] and [F12] also exit."„  LOCATE r% + 25, c% - 10„  PRINT "Please enter your selection ";„  COLOR 27„  PRINT "_"„  COLOR 11„  CALL Stars(2, qwe$)„  a$ = qwe$„  IF a$ = CHR$(27) THEN EXIT DO„  COLOR 15„  LOCATE r% + 25, c% + 19„  PRINT a$„  COLOR 13„  SLEEP 1„  w$ = UCASE$(a$)„„  SELECT CASE w$„    CASE "1"„      rou = 1„      FtoC„    CASE "2"„      rou = 2„      CtoF„    CASE "3"„      rou = 3„      ItoC„    CASE "4"„      rou = 4„      CtoI„    CASE "5"„      rou = 5„      KtoP„    CASE "6"„      rou = 6„      PtoK„    CASE "7"„      rou = 7„      KtoC„    CASE "8"„      rou = 8„      CtoK„    CASE "9"„      rou = 9„      KtoF„    CASE "0"„      rou = 0„      FtoK„    CASE "X"„      GOSUB F12:„    CASE ELSE„      LOCATE , 22„      PRINT "Please press only a key from [1 to 7]"„      LOCATE , 31„  END SELECT„  „  COLOR 13„  BEEP„LOOP„„F12:„  BEEP„  COLOR 11„  FOR q = 29 TO 37„    LOCATE q„    PRINT SPACE$(80)„  NEXT q„  Frame 28, 52, 30, 36„  COLOR 10„  LOCATE 32, 31„  PRINT "Thank-you for using"„  COLOR 15„  LOCATE 34, 37„  PRINT "Convert"„  COLOR 7„  END„„F9:„  COLOR 10„  Pause 0„  COLOR 11„  RETURN„„FUNCTION CelK (o)„„  CelK = o - 273.15„„END FUNCTION„„FUNCTION Celsius (m)„„  Celsius = 5 / 9 * (m - 32)„„END FUNCTION„„SUB Chart (st, en, inc, r)„„ON KEY(9) GOSUB F9:„KEY(9) ON„CLS„COLOR 12„Frame 23, 56, 1, 6„COLOR 10„LOCATE 2, 33„PRINT "Converter Chart"„PRINT„LOCATE , 24„COLOR 13„PRINT "Press [F9] once to pause listing"„LOCATE , 27„PRINT "Then hit any key to resume"„PRINT„PRINT„COLOR 15„„SELECT CASE r„  CASE 1„    PRINT "  Fahrenheit", "             Celsius"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## ¯F  ==IS==  ######.## ¯C"; q; Celsius(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 2„    PRINT "     Celsius", "          Fahrenheit"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## ¯C  ==IS==  ######.## ¯F"; q; Fahr(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 3„    PRINT "     Inches", "        Centimeters"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## &  ==IS==  ######.## cm"; q; CHR$(34); CM(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 4„    PRINT " Centimeters", "             Inches"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## cm  ==IS==  ######.## &"; q; In(q); CHR$(34)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 5„    PRINT "   Kilograms", "               Pounds"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## kg  ==IS==  ######.## lbs"; q; Lbs(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 6„    PRINT "       Pounds", "            Kilograms"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## lbs  ==IS==  ######.## kg"; q; Kg(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 7„    PRINT "    Kelvien", "            Celsius"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## K  ==IS==  ######.## ¯C"; q; CelK(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 8„    PRINT "     Celsius", "            Kelvien"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## ¯C  ==IS==  ######.## K"; q; KelC(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 9„    PRINT "    Kelvien", "         Fahrenheit"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## K  ==IS==  ######.## ¯F"; q; FahrK(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„  CASE 0„    PRINT "  Fahrenheit", "            Kelvien"„    PRINT„    VIEW PRINT 10 TO 50„    COLOR 11„    FOR q = st TO en STEP inc„      PRINT USING "######.## ¯F  ==IS==  ######.## K"; q; KelF(q)„      ' WAIT &H20, 1„      ' WAIT &H20, 1„    NEXT q„    PRINT„END SELECT„„Pause 2„VIEW PRINT„CLS„KEY(9) OFF„„END SUB„„FUNCTION CM (i)„„  CM = i * 2.54„„END FUNCTION„„SUB CtoF„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of temperatures"„    PRINT„    COLOR 11„    INPUT "Enter Celsius (¯C) temperature:->", a$„ „    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting temperature (¯C):->", st„      PRINT„      INPUT "Enter Ending temperature (¯C):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending temperature MUST be greater than Starting temperature!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„    „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„ „    w = VAL(a$)„    PRINT USING "That temperature in Fahrenheit is_->######.## ¯F"; Fahr(w)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„SUB CtoI„ „WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of lengths"„    PRINT„    COLOR 11„    INPUT "Enter length in Centimeters:->", a$„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting length (cm):->", st„      PRINT„      INPUT "Enter Ending length (cm):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending length MUST be greater than Starting length!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„   „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    q = VAL(a$)„    PRINT USING "That length in Inches is_->######.## &"; In(q); CHR$(34)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„SUB CtoK„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of temperatures"„    PRINT„    COLOR 11„    INPUT "Enter Celsius (¯C) temperature:->", a$„„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting temperature (¯C):->", st„      PRINT„      INPUT "Enter Ending temperature (¯C):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending temperature MUST be greater than Starting temperature!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„  „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    s = VAL(a$)„    PRINT USING "That temperature in Kelvien is_->######.## K"; KelC(s)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„FUNCTION Fahr (c)„„  Fahr = (c * 9 / 5) + 32„„END FUNCTION„„FUNCTION FahrK (k)„„  FahrK = ((k - 273.15) * 9 / 5) + 32„„END FUNCTION„„SUB Frame (left%, Right%, top%, bottom%) STATIC„„horiz% = Right% - left% - 1„hline$ = STRING$(horiz%, 205)„„FOR vert% = top% + 1 TO bottom% - 1„  LOCATE vert%, left%„  PRINT CHR$(186); SPC(horiz%); CHR$(186)„NEXT vert%„„LOCATE bottom%, left%„PRINT CHR$(200);„LOCATE bottom%, left% + 1„PRINT hline$;„LOCATE bottom%, Right%„PRINT CHR$(188);„LOCATE top%, left%„PRINT CHR$(201);„LOCATE top%, left% + 1„PRINT hline$„LOCATE top%, Right%„PRINT CHR$(187);„„END SUB„„SUB FtoC„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of temperatures"„    PRINT„    COLOR 11„    INPUT "Enter Fahrenheit temperature:->", a$„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting temperature (¯F):->", st„      PRINT„      INPUT "Enter Ending temperature (¯F):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending temperature MUST be greater than Starting temperature!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„   „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    j = VAL(a$)„    PRINT USING "That temperature in Celsius is_->######.## ¯C"; Celsius(j)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„SUB FtoK„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of temperatures"„    PRINT„    COLOR 11„    INPUT "Enter Fahrenheit (¯F) temperature:->", a$„„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting temperature (¯F):->", st„      PRINT„      INPUT "Enter Ending temperature (¯F):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending temperature MUST be greater than Starting temperature!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„  „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    h = VAL(a$)„    PRINT USING "That temperature in Kelvien is_->######.## K"; KelF(h)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„FUNCTION In (c)„ „  In = c / 2.54„„END FUNCTION„„SUB ItoC„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of lengths"„    PRINT„    COLOR 11„    INPUT "Enter length in Inches:->", a$„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting length (Inches):->", st„      PRINT„      INPUT "Enter Ending length (Inches):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending length MUST be greater than Starting length!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„  „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    i = VAL(a$)„    PRINT USING "That length in Centimeters is_->######.## &"; CM(i)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„FUNCTION KelC (c)„„  KelC = c + 273.15„„END FUNCTION„„FUNCTION KelF (f)„„  KelF = (5 / 9 * (f - 32)) + 273.15„„END FUNCTION„„FUNCTION Kg (p)„ „  Kg = p / 2.2„„END FUNCTION„„SUB KtoC„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of temperatures"„    PRINT„    COLOR 11„    INPUT "Enter Kelvien (K) temperature:->", a$„„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting temperature (K):->", st„      PRINT„      INPUT "Enter Ending temperature (K):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending temperature MUST be greater than Starting temperature!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„   „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    k = VAL(a$)„    PRINT USING "That temperature in Celsius is_->######.## ¯C"; CelK(k)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„SUB KtoF„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of temperatures"„    PRINT„    COLOR 11„    INPUT "Enter Kelvien (K) temperature:->", a$„„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting temperature (K):->", st„      PRINT„      INPUT "Enter Ending temperature (K):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending temperature MUST be greater than Starting temperature!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„   „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    k = VAL(a$)„    PRINT USING "That temperature in Fahrenheit is_->######.## ¯F"; FahrK(k)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„SUB KtoP„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of weights"„    PRINT„    COLOR 11„    INPUT "Enter weight in Kilograms:->", a$„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting weight (kg):->", st„      PRINT„      INPUT "Enter Ending weight (kg):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending weight MUST be greater than Starting weight!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„  „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    k = VAL(a$)„    PRINT USING "That weight in Pounds is_->######.## lbs"; Lbs(k)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„FUNCTION Lbs (k)„ „  Lbs = 2.2 * k„„END FUNCTION„„SUB Pause (a)„„PRINT„IF a = 0 THEN LOCATE , 27„PRINT "Press any key to continue."„PRINT„„DO„LOOP WHILE INKEY$ = ""„„END SUB„„SUB PtoK„„WHILE INKEY$ <> ""„WEND„CLS„„DO„„  DO„    COLOR 13„    PRINT "Type 'end' to exit"„    PRINT "Type 'chart' to make a chart of weights"„    PRINT„    COLOR 11„    INPUT "Enter weight in Pounds:->", a$„    IF UCASE$(a$) = "END" THEN„      PRINT„      EXIT DO„    END IF„„    IF UCASE$(a$) = "CHART" THEN„      PRINT„      PRINT„      COLOR 10„      INPUT "Enter Starting weight (lbs):->", st„      PRINT„      INPUT "Enter Ending weight (lbs):->", en„      PRINT„      INPUT "Increment:->", inc„      PRINT„„      IF en < st THEN„        PRINT "Ending weight MUST be greater than Starting weight!"„        PRINT„        SLEEP 3„        COLOR 11„        EXIT DO„      END IF„ „      COLOR 11„      roun = rou„      Chart st, en, inc, roun„      PRINT„      EXIT DO„    END IF„„    p = VAL(a$)„    PRINT USING "That weight in Kilograms is_->######.## kg"; Kg(p)„    COLOR 13„    PRINT„„  LOOP„„LOOP WHILE UCASE$(a$) <> "END"„„END SUB„„SUB Stars (co, qwe$)„ „COLOR co„a$ = "*    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    "„„WHILE INKEY$ <> ""„WEND„„DO„   „  FOR a% = 1 TO 5„    LOCATE 1, 1„    PRINT MID$(a$, a%, 80);„    LOCATE 33, 1„    PRINT MID$(a$, 6 - a%, 80);„    FOR b% = 2 TO 31„      c% = (a% + b%) MOD 5„     „      IF c% = 1 THEN„        LOCATE b%, 80„        PRINT "*";„        LOCATE 33 - b%, 1„        PRINT "*";„      ELSE„        LOCATE b%, 80„        PRINT " ";„        LOCATE 33 - b%, 1„        PRINT " ";„      END IF„„    NEXT b%„  NEXT a%„  qwe$ = INKEY$„„LOOP WHILE qwe$ = ""„„END SUB„„Ethan Winer                    VISUAL QUICK SORT              PC Magazine BASIC Techniques   Year of 1992           QB, QBasic, PDS        175  3726     VISQSORT.BAS'********* SEEQSORT.BAS - Quick Sort algorithm visual demonstration„„'Copyright (c) 1992 Ethan Winer„„DEFINT A-Z„DECLARE SUB SeeQSort (Array!())„„RANDOMIZE TIMER         'generate a new series each run„„CONST MaxElements = 23  'the size of the text array„CONST Delay! = 1!       'pause delay, change to suit„CONST FG = 7            'the foreground color„CONST BG = 1            'the background color„CONST Hi = 15 + 16      'high-intensity flashing„„DIM Array!(1 TO MaxElements)    'create an array„FOR X = 1 TO MaxElements        'fill with random numbers„  Array!(X) = RND(1) * 500      'between 0 and 500„NEXT„„COLOR FG, BG„CLS„LOCATE 25, 1„PRINT "Press Escape to end the program early"; TAB(80);„CALL SeeQSort(Array!())„„SUB SeeQSort (Array!()) STATIC„„REDIM QStack(10)        'create a stack big enough for this example„„First = LBOUND(Array!)  'initialize work variables„Last = UBOUND(Array!)„„DO„  DO„    Temp! = Array!((Last + First) \ 2)  'seek midpoint„    I = First„    J = Last„„    DO     'reverse both < and > below to sort descending„      WHILE Array!(I) < Temp!„        I = I + 1„        GOSUB UpdateScreen„        GOSUB Pause„      WEND„      WHILE Array!(J) > Temp!„        J = J - 1„        GOSUB UpdateScreen„        GOSUB Pause„      WEND„      IF I > J THEN EXIT DO„      IF I < J THEN„        LOCATE 1, 60„        COLOR BG, FG„        PRINT " About to swap ";„        COLOR Hi, BG„        LOCATE I, 39„        PRINT USING "####.## "; Array!(I);„        LOCATE J, 39„        PRINT USING "####.## "; Array!(J);„        COLOR FG, BG„        GOSUB Pause„        SWAP Array!(I), Array!(J)„        GOSUB UpdateScreen„        LOCATE 1, 60„        COLOR BG, FG„        PRINT "    Swapped    ";„        GOSUB Pause„      END IF„„      I = I + 1„      J = J - 1„    LOOP WHILE I <= J„„    IF I < Last THEN                    'Done„      LOCATE 1, 60„      COLOR BG, FG„      PRINT " About to push ";„      GOSUB Pause„      QStack(StackPtr) = I              'Push I„      QStack(StackPtr + 1) = Last       'Push Last„      StackPtr = StackPtr + 2„      GOSUB UpdateScreen„      LOCATE 1, 60„      COLOR BG, FG„      PRINT "     Pushed    ";„      GOSUB Pause„    END IF„„    Last = J„  LOOP WHILE First < Last„„  IF StackPtr = 0 THEN EXIT DO„„  LOCATE 1, 60„  COLOR BG, FG„  PRINT " About to pop ";„  GOSUB Pause„  StackPtr = StackPtr - 2„  First = QStack(StackPtr)              'Pop First„  Last = QStack(StackPtr + 1)           'Pop Last„  GOSUB UpdateScreen„  LOCATE 1, 60„  COLOR BG, FG„  PRINT "    Popped    ";„  GOSUB Pause„LOOP„„ERASE QStack               'delete the stack array„COLOR FG, BG„EXIT SUB„„UpdateScreen:„  COLOR FG, BG„  LOCATE 1, 60„  PRINT SPC(15);„„  FOR X = 1 TO MaxElements„    LOCATE X, 24„    IF X = (Last + First) \ 2 THEN„      COLOR BG, FG„      PRINT " Midpoint ==> "„      COLOR FG, BG„    ELSE„      PRINT SPC(14);„    END IF„  „    LOCATE X, 1„    IF X = First THEN„      COLOR BG, FG„      PRINT " First ==> "„      COLOR FG, BG„    ELSE„      PRINT SPC(11);„    END IF„   „    LOCATE X, 13„    IF X = Last THEN„      COLOR BG, FG„      PRINT " Last ==> "„      COLOR FG, BG„    ELSE„      PRINT SPC(11);„    END IF„„„    LOCATE X, 39„    PRINT USING "####.## "; Array!(X);„    PRINT SPC(17);„    COLOR BG, FG„    LOCATE X, 48„„    IF X = I THEN„      PRINT " <== I "„    END IF„    IF X = J THEN„      LOCATE X, 56„      PRINT " <== J "„    END IF„„    COLOR FG, BG„  NEXT„RETURN„„„Pause:„  Start! = TIMER„  DO„  LOOP WHILE Start! + Delay! > TIMER„„  IF INKEY$ = CHR$(27) THEN END„„  RETURN„„END SUB„Jamshid Khoshrangi             PB FORMULA SOLVER              qjackson@direct.ca             09-12-95 (00:00)       PB                     279  18354    ARDAF.BAS   '>>> Page 1 of ARDAF.ZIP begins here. TYPE:BINAA TLEN:13413„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"ARDAF.ZIP",4^6:Z&=13413:?STRING$(50,177);„U"%up()%9%%%#-%2\S*DAT?YvdXm%%[2%%%1%%%%fw%ifkV%ZVSgRfxFL_:B?#Q/a„U"6E-Nw4B*C]e?INE(X<f'Gf=U+Rfeo%a\*MxI2mYUT<(1h>QA$_^Nu^w1u_YLw2V„U"DJ&MFqpa_TeIt+Lz1XhugN(NHd6;^f3<sjcp8zAcq.pgZrRHK\=2$&kZ_8lca5Z„U"sutXY:Y4d4=6xN=ErIAa/i(VrgcF'FpZBwwM7_QoHUBFMElt\lVWEN*&>zpCbXD„U"/3<fN)Ng'djS+Z<Dd-aPXQv]r6%f>4_A,ieF;aut_9pKw%c]tJJf0<GJO3-fdfS„U"Z'tf#GFID4_.ZN1rv&V7D:[Tu<2./5XZjVvqm,6R4Rt=lXT,XMi_DuTY8&R7+AW„U"BAXtcspZ6N?r*U?*H:<QQVZZvexKf'pJe)(fGu[#m-%pUV(tqRq]QY]Cj_Rj$63„U"emcB]<S)A&mqV',gP%eE5>ClL[F\(qOH^1kF.hqiWcC;a:n'Kg36[5GX5I0Ff't„U"tPot3*^-)\v:,,>pS>k7-GUjWqH:;PlUo\7rtssF?[0'WWTsQ[l>vh[U>wO>'jO„U"6=Tuf0VHp+>sgY?m3JunR>nWqIaaPpTB*UHFm+H&-W-eIVh;Y9qhWWr[?;Lk'_G„U"Qu<eGIf7a36BA)Q/NKedI4HGiUs#6X<O0EmR]LMjkH:QIMORh</uYPtG&ZRZNG*„U"r=Pj%r?X6JNY+jj6FP,+q*#L*Y^];:n5%:HUUQxfw(5$FIk#8;$S6JbaQc5pQY,„U"riNs=H/[X_uM/_UbVgT#&.[zC.ZAk[23jOXQk;hC\tc./m'lQE<C%+\C/O8JI?b„U"*c_t]tt*HpB_S#mh06=%/EF#dH_z=/^%[/8k-5=Ff)gW+Ppc\2#;53+JaFh;jGt„U">F(S<X,^)#_99R%-Qc0>V\a*7W.1r1)L=kjq[0Cre]XgQ_?G1DJ#/:lksa;lVe6„U"bb2DKbSIn1:n]E$uJ^\+^>>nF#(Z+&t2k*q1WUl03;QT<jU\OZCI1Tg.W3<n#^M„U"d1GC/r#W(Hms+)f1Qm.HkF<?j78sXQ=1DH,W6tM;tJm)$(5,O08Lj(D)JVhP+-2„U"O\il&v3fo**(TG]WGK0QZ?VXHrZRn[SCrRsi]%&M,ARN2U*+LNg;Ikd]/.QF[Ui„U"3iB7ce-:V07#;IlSF1<Z1SW&Vjg.k(K>/:xE'ZK&%E,7p]2]Gf.Bxa0Rr6SIq^B„U"(VUVgG,-)V$.lBe\DE9hbL#K7-PGn$]]VBO6paXRe\K9\0=%CmC7VfwK074f5/d„U"N5/p&$U#$VnE0qxDBB8_6'Az3qs4?Y0GJ;+il.<BK&\6s:lL/98f8/IJ(k[$ZbK„U"l6d60[r>.JabU2ob7Cnf6t4PJx:u*^HZo?F0D[5.'RB%.JMJg-;6_-SY=31U?$W„U"qQ\_5CBc+2IYWW=CUv^SZ'cb)F;$.88Ytiu&cFd3OgClns$wCk+a:sjC0e)]pQG„U"0LY_:k7UgZofidfI/SGe'>4^x'C6PB-h<Ki2U?pxm]Zv0mk[P0[)_WG7#Kpc2DS„U"Uur>h5<nDU3FQ>(MoP.gkO;#V8T#7SUR=CeXnl0g\^s]^uKrerU(X0\rwt]7]_^„U"i)-V0)WVFDhjNKDPf(uDj#je5*<ikUAU^R2Cp5F-BLt-H3<K.5CjElvbX8*+t9[„U"b&-Y+I1EYiN'WVOEHYB1mQ'-3$<]FLEv(0[k;.g<0F2xOl[_G&=<GhZSa^0>;oU„U">+E>l'4.xX%iQCa>knn$<*cSWWY(<.?+BTA)V(WIf4#>5:[)W8/w1ZWXk<$6'/3„U";U&qK/B4/H%tVNkJd1IgYpJVbXgWs_)jC5B=-pWViTLHwbr4<u8*w/Q?i6uPh^*„U"K:gLrz&zGbrKgdKeR5P/c>ObS\rYp8MLvlG180:p>39dm=bQ5*&LkE[3Xn40)WG„U"mlwT;9tHiz>q+*1.bzZOZ9HEZ#8?q(Zf'b;tjGHFo$2$g-QRC$#dDd>?MBlXi4L„U"tk;*\0bo5$'x8MuT[s40q#ZHF<n0rDD8Bud[#$;f%5-Dp*D\'V?=&Ypt&CXucrp„U"6ZqET<E4^RbarNL'gg=C*SSn9j1G77i+97KIsdE/hO^wI#q0t_imwW#e:pDJxy<„U"aI?7/y5s'n5ikt-R6dg7aX=7>\0%ys-I,l\Abk2zhejl\CWZ0^zH(Ad7UeiHmDl„U"cFC'oyOR'7]f7Cfi'$gfq1CK6?O1f)LHJKMp/f]i?H/1PKZB053VX+[p'[CHpf(„U"]M4WQe*tAJUot;ffj)eJ6Y,68e+kte)-1<8iS\mg:8V50i;*cPgYD?A+Rx=Xnnr„U"ZK*HZK),CPE>_r8iP/bUK,q*?[AX$+]/$aI21_3_&6quO9n+;MX11=8F3)VRplB„U"WdT'H]g*m1g6Gi5UgT$=)r6[H7%$dWOC3X%Mu];6lJupMVCRxmf/fDOw:NjDv\+„U"H*,tng._e>AFWS%,J=[E70PKg6[27oS1c\whoSRkeW-#s3hfMcv7>Xx^/xb8aE&„U"bTmdabKouebL+3g,PX.f-SZ)/QuFeLO'4=j3FD93GjkD;HwM_S-qatJcr9VWYZo„U"d+GS7+]Uix$?JiZLKg$MO=:k%4QkuyoL2=Psx9P_4XK)lkO(v?c.4?52#V1?p?2„U"FjRON?mgGA);6.3LL%lr'w%BsTdEj>i:31rU]F3Kf=IayZ0H3#LIN3(Y*/8Cb6k„U"*DFrEZ)X/XFNw/8+J.D%n=&^/y(2<RwX4*%lQ;w5F5hS=.Fl&4Ab]amdh'.pZ.X„U"1f<vFI7<',GkCsD^X7^sG$FKD10[Y[G\PYg=_V8q<L:wS3W[VLF-*.,\+Yku1^&„U"#plW>O''e[/19B$d6iS;YjaeWk*[3,/$Q%BFm#r5iE/*5r\Je#7pK##jAQ7<(Jh„U"%NUs)1:/s$g(tIgE*71r8jw7F]UvWp3gG&VCE0c9'/]>WqMJ^g6FAJ^oxH:o>\R„U"qV=DIp;uD=X;6o)(1F'*u=9FH:Pt1Lb%>--CM5MQI/AI-Q['(,[qaoR).r[zdl[„U"CU$BoOQB([_'V:KNx?y.wL$TGMSugRj:/=^BQc]2PMm'q'H*HFMIr_+cqgB:wDX„U"xiX\qDJGvz2Rt]29pPiJ2VM;&q+*[t5Z7#*/NgU1U7\4Og:LmhJ0Tyc*1_=wd4Y„U"ROAFqv*jOiMji+#d9GYJ^m.ULF]O<u%tZjo^dCSg4_V%03fFR0/>KCBbMK?#Af7„U"dilE$ZFQM*0jFRU76X8ZR*Ra+jWgv(aTgA1>kFL$Zl>^%hXEBhjsSAIuslL?'\p„U"nNG75)Y+,piT]PuO0mfghqMs([KP.UKTblkgZ(:ovG<AH.z[*JTU=QqX<7z($)m„U"Czpj+A<:m?u,EKiWP0DtLNcRP3]c%[Oeeig:xlgOx._hIJ#qW9u8))n+ZUms.\x„U"je$G_w7(WXI09dc:9=ff?7)#7goTAmHe?Gt.V*j-s\CPt/)c37H;d%T%3O]?S4*„U"c*cm:N,Yg&<da;AvV?n)v=/#o\g+V(<>t[)qS)73G6-e2(f.06,0:]+5Jfd-Vi(„U"PLD.QhD319\X[&R[)XcM?^a)X1=P_KMOHo'hQ#P8m0HRAHYDt][srZ8.XG.A:.c„U"6^3$O/WtKS.lar[5cEL'MY7'qCIgBslh'Eh/nGJID\+&r7IDpwW(+-jk=TCw,v,„U"2K(lfJa/3Pa]T$?0i9[OUe+sM?STZbShvTpZH0/Sq/drLEpQ(UVpO$q?=I18<_;„U"YHS'8>bi2s)a.B7j(+Jl1ON(;;2WSQg0CFHPFc2>(*J/p;nM]ZiC:+yT;HZ.t2v„U"1dPN5yUE%qHcY7AEadnK/S9DgS.Vl=_B7=C9Z-?E6C)+/Tfrkz^YHjGSy4/XlaG„U"[cq'fK19<wgCNVu\ZuWj&;#ICF#AU9YHAo_$hJ.aHk*L<O1;ypIyx1i'f[]1I:W„U"ImAsPo:g#-?FKTZg]k\f$OS;yH8?)QI*sXsdl4gOa#N9oOQ)WQA&dk5<YZV[.4S„U"s?)*HV&OWr&c&[$f97sAuE5bS.BkjChM<5*+N^)cPx%'UIgvk^VtclWnbB5pcVD„U"h=*h=xmd1Xj$rIx2RZ>93qnkixX&sajk0fyDmd1BpH]Q?u7DKEF-Di;126]5_d6„U"Hcx*hJPt.Q;h-9WxQ'*:D1y(DpAF9Jmeo&m,r=/(i[KocM<9:E.LJb\a9WWr0)?„U"AsBuk7lo9)C.W*PTV''pYhQ+=&H&]g9mf$i2-cEtfhQ(0U#w_A:4Sn>C-=fNloL„U"Us%V^j(FvEDWNX**)40=M]VQxW<8zm>uVC_=j7u59;b/+t>HBgA\7L[(hq:%=I/„U",'boG_8yBRX%G]('ZA(Eguj_T:Qf>jpo3x>=XS:?]OC3FD\&yMzlVOqj9p8\q60„U"qhS1?$IEL,<lu=*tV/S?j\XkC5p;9x>:rZQan[qjUU9k:yjz+QSJeA_ukTZO#A:„U";&LKmfV'.uDU(r[d*W7V(0Z<(Td,KmN1ZA\tHR2K7ikFrJy<Fu*YWu+KV:u*rri„U"b_5IFdTue2pH6]=;=-4$:]xPslgc5lfLL4FVj\XmE]oD6R13HM+LO4[>IS-#ov?„U"R&B=at^i77Kj*eBAcQ[<*ik8&Nw4AqmI30v9#7xi&_-]gY:P&ZD%FF&O;.cby?:„U"K5W2'E+M;0rQ0[JPntYuJTw1in<P]:LwL+M_$Q_5p]>U%,J#T:&R)a/KaEcQSro„U"B28YK]9/lJvgYe<Y=wJ&(%gsU(G>9_1.x[2e(5r2WkF1AOOR=xomq:Jb:$e=3a>„U"EBKijSbELFfhJ<KiFacuDE2&jn'9nbd.iZ6<[86]&0^E7_j6Duo6tMF')F^)$O<„U"k%WPwO5GNW>NSid\:gJ?O,W[PVlgQ^>MHUNBBnMhW,*+5rL\hjKBIm/g.A?BDN]„U"-8AV&eXbAl]r6>++F>8KkU\xs\Yfw2TH$b8zk-dbK'EP;ivpq7MaJ*7e>kZdrkM„U"V%nWhq*)k8B.$\'rv\2[(3<VGK1RUO9Gv/e*_)J&1H)R5?TQ.5*iw.615j2Kd5S„U"g1Th;7.OGte5xF$OeA-a%e-\Om4')bMR&J0VDnm\j68iN?D\UR9Eq[/NEP5R,_r„U"w.,FN1cf?Z&kn6;1n3XAkb:OFLKI5=C/1B%KV)T(L;D)X-S>/d%#+.mDUQ6WqXe„U"sjcXK8<qOY\]r(g8SsX>2J3z1jB)1\6>PE8/p$Hfp7T,FIyMa/c8?n;^]#'71,<„U"BYObZY'7.1&sC[m4jJ(Zor/S$05'b%K\DL(mJpUyNFs$Rfl3HsD3\^.pAg93EYP„U"8YkR,\Z%)7dv\91>N_t;JXQci9i'[Jp[cpaJX8,SbYDZPF1J%]TDyXU?\9VI:LG„U"H?.tL;%.**qcB?9^X[Z(a:SJRx70Z;/A4i,w?2;wp=0V'0:3gu(;/Af3V6EkZ\4„U"Sfj-t'oG([6653PhYBCmDH'+:gh-(\'+Tqs?dr$BPBD8ooTy#>ot.W3*K#fIgh;„U"jgeg*s^Vq)P4wUdMgoShUVgNerW1r5WR7i5P[Fm^<4fg5]P1T7)Q6[x]N,'dNrY„U"S:F;JI[\_?*W.t#un/x-G5%a<S:9WILy4/\VP^>]G%9e2.xCcjLS^oAJ_jK[1%q„U"B\9-)xjBzG<&jSf0=mGd=Z%I'-v'Q'W5#kIGaTKisjd*k?T*7DXTj&G=5rB?4l-„U",sOE><m[#O9VXH<?(/I0.iF>(,Fv3lG/qg<.m1bxAhm([/e04%01Nlph8mBRObj„U"SDa;ml,YR/-i:([dFj)Oc>xKksaNCP4#*Lw_*<bg'%'8#T%F.+&'[1(3tmDoQU0„U";(&h--5cC?(z/+PB=R]2q8XNjp>?R\YS&\,%Ii+g+'j]_Tva4l^X>8<*45H8C*w„U"ikAx<rL\%8Rln5pBPb5YmmMsA&KDC*ZTjTf08bK9ub&4tNuc4N,\AyGYiNkRu+J„U"wq:Rs#?+Bp#ccLnw)f]C6Q)ZSTAXL:.Z*YB40]',Nd-#g5I0JF>nK[_53Eb[xo+„U"BW^o\O3$,W2/KVUy7H*by<^vLNA*LYz)4%s&m1^/e(uKan_mT]:;fzAH&m=Q<a9„U"f]og;P_jCY&Pa1'S#z>k-Rn^DUkX6(tR\hLAMvrCW\eU+3CqO)EP:KCFq6.&1XY„U"%+9<MDR*[,5Uh'qFKW'd/lHLJ+2*YNW2g;d\s+gQ-)sHX_+pb1i59\4Q$V-F-u/„U"e>Lg[%eP%wv0#Ub^9:CgwpD_DBWEToeBVP1=uCNm+S'VJQe%m'0uR_;'tBpA?S-„U"fI:((M/xqijI2SN:P=8c0N>2%xkKg#SU?do8C3&iGtJMF>-VM+JkK#UJc]R=sr9„U"^s9x8b%-6p[mvEr.WbAMv:3/<raSE'VD=7<cR3O>X1q.kF_.[r?FE\7KF5[FmCM„U"kf^2\](RSQ&agnTE]RR.wshm93be(bS0QYg[$o+iAfq14teVG&mBb*WD:0d#V0P„U"+<CQw,M)Lr,qi;+iCJ^Vl4$8gL&wxRtONGXlW-I93w]_\P_OWCWt2pd[$Yi)iE^„U"#mG8#(a0*nwvTtBVpdM'ZJ/Gp'Eh=CW*7Y5<+(q[76<<OsnmZBNo_RtmMP_:9Yp„U"NptX[puO1_t$9FCbPg5CAZexXie+fn'ELTMDs;v79usBD-l9U(1U:g:,C]8%]^_„U";^<;??Joj0G<Ir\+JG?SDH1IOYh6JZ*L8w%w*a=Z).cYw%mW:H9;M<-)dpS.uFF„U"giqFGP:6>N]o$TV0q:Ltap=0HBastFa/#BV#nU*osiDdLE+>dp*J[LRsN.%7p3B„U"2S1[7Mn=q'=ifF-ArnQ3o'b:h*9r=k\37Vs8=s\)^Ny-x/Z\Z*)Z4mW9IxZfpL^„U"UZA?UIr;#zvZ+>mB.R0lpc1COuOUnL:lpFTJTt4aDbC0mKud%3f2+DW/ufYjlH(„U"B[x,3lh>,H/:yq.r5bR&S[0<2U_R74/E0016oJ:kgfcb>7<#B?pus:1^Rz&WT<%„U"p+'0fcs>U1<>ZWY2pVmn(jTV00XRSjvBV0Go/XxMIgtZ+3VfRZ*Znici1a<kaov„U"A9m4k'Kal1;JLig^J$=h0nZL>++3r9+p4\2w:/r'zld\y*u9jx1QYsS4X2q3C^3„U"UBGM#7T_$b9K_us_qa]-?Mm:#?UVVfnRyWBl=u1q[Pi:Le/PoqTeblP3;Qd3)\<„U"lWN.9[_J=62=Q<a,9\dw-Tlf0JPUBX:^']Lwj1D6zdRc_h%djh/0l5Jmq:)y8eR„U"i9Y%;*1mEeB4<>/peZrCUCTt/I2=9UT'AH/J&ICAR>k_4l;S)V[R>#s_O\jHiSJ„U"6-])Nd5.-IH8G%kHK7yZ#Q82=\Wn<5]\T;XS?'?TZRha\NQX-U,C1baRJceG1q_„U"8=8T#oQ:EtoPX$#^$W9;p]8d'4^ro<0BHGCD8bX7anaW#f&>>^gi,4gJO:pJ)sO„U"\875^LYlUjRE6ZR%%,Qz_?Lej;Q7oeMA%4=-fGr/DVH43WaE3fW]9a]QUZ\zEBX„U"7nJ819WriR<_b:h]GtAmok,KI#.BSMrJiS67J18C*.[#Go/WKP8WWqc:[N1[OA.„U"pXX5T&Fi0KB9gShx/)76kl?g<7rAbe-QGH)fG9UhrmJ\fokAP_j\+xT6ls89k.[„U"d9w:)=VbQI,[,;,eKXC+-Q/sl$fet[w]I.G3e7UZ:Mra=b<eJN?o/SL*$,L2tqX„U"W5P.+G:+n>+<G*Y9y&75:,dK5EVVsTBYCXB/?RLF/VYMm_l>/)hd%O.v^no99?a„U"%G4YEK<?=\a11b3u(l%93s7RvgmP/KA(B52e_a+bIds0#q7&<:iQ<^V)]i9^mcb„U"^H?(tO#cw5F'Aa#j0CI3^L\B57KTxH^.j]XM#8qUVLHVY/Q'qFSguVNmon5?aqd„U"bG>+S;U;4q/?V>??pN5^tC(NNJ9Q=+IRe2ql8i2q=?b>CPiqfV;uvZ_-Kk79I2'„U"(4>a;tNk8=W/]U7EHj\2m0b+L+9B-\U9eU/K7+gb;b<mgVF.eA<bHl:/sMQD(HR„U"o[[n5:9a&CL,w^wwyi5T2R%#1t7.gbJuBH]TPWV?>p)7hqn60=#n?9TSa\U?&/z„U"NWJnOWqLwEgQbNpIm4(o)?#.dK+wHCg\O$f<o5BUF/<pSmDs4X0;m.*^&Ot\1OX„U"WFBoH%G(+iQrhwoPjHXx+Q%aQeRKjz>?cWc6FDF_XFcL>'&u?&:MdtA1m03ZC$T„U"Om&OaU5.;LseS:)c[<V]Iy&]^2\'w4):c%4F0q2e.S_op^n0(\SU%JPlZMbqiHd„U"d$_kk\>00xoN-U,TK_$)6oH53V?IAa+hSs]$;$Ed1]'jwqRC6l(>UwE-<8Ov;H)„U"'Q':mWc[7QVZAIQrx$bS#'Ssjq*IhCiYW(>TS*E#?:IHK[0Ip%WjC%:<-Q?Kt]&„U"_cV'JiT2R2'Q)DYd<Hr#I)(5xT:_GR'*=?uPTM)to/hm&gZnjU3)-Qz0fJ\C3M'„U"1%Fi:pAqe<\upE=h^qD>UblWe;L$cCkPu$4Zms+(3fM%>6jidM:qWomr7;=.IkV„U"$\D%o04?:*dmpu7'Gff?#Fc]DaY'<n^igq\SRai6h*Wn[HoGW.?^bkJs%uX5P/I„U"#L0'_Zhsa9e&/c6hbt5fi^)kx*2A(/4WLu1VQ?E?l,;BQ1gZ\PB,EQ?aE=(yQ=K„U"fW-<3E:EUqLh6eu.:)cjB>BU)KPy:zVm\uw\3QU1*g-kT,\HMsUsaZJJT\H:Bo+„U"f]ph*<B5*uNrvlPjItI'A6gC$<qSG5?jpN5lm%yi^%bhw<laHM[$p%m7msmpRwJ„U"rnSyg*E5:ey-.=.K1;U\<h+&up^\K&=wb=U_(Sl[c.Ew/?huqeII#5+)&KlA*y*„U".((\3&PJYms)X:[z>Fi*>Zml^Ih>eq9z/n>ud7F>2pTVJxZlvun<SL;UBui-SPS„U"++h[b+2HS[,ba9?G8n0KCp2J[C=e]J>A8ec,uX/.R,ZMC#7[*9wAfY2A(gb\+N:„U"ut?XBk=W+oC(=92b0b^K<m,ZLELJ8+dK_Ay.9jehO:We=M^b%+4yWA>%-vbR1wO„U"$^QJLK^2\9%kL#VVz(<wJms9tpQhGx(Nis.b3QI*4Rc8DO59J;h0tro^z[U3>9.„U"VlK.L\I+&[YX)Wrs<0F+95O.pXT9f<KTGVP11+q>Uta#nTf/-38o_&+4kXP4vzT„U"dVWvjl[8ppgK[<V%NSGFnNehPYt<F.q9Pv^]1ex=A_Q#O1'_oMhslP2eYSbq>de„U"-B?RUhn\TVwJ'-e&L6b3(#P,YpWHZasPpp0+LEltd%7Q:D0F]-9[L%hQn*r,7ME„U"\rx4wqn7rZOK/&%u1Fr?KBu(ZA.P1;/ZXXmN=QnwY^H_aMU6^oOJ5WO7XE.yUT3„U"o&Zu$<Q(n9JPPVEHYCCC:lzC6hutP6#r,12%y+ama\G-**NPS%=j=3ECxPHy&iV„U"FzqvIkDn,z6+#(NU]F'/]Q/E_[gZ0Gs,tpN(tuJh3:XbrIy;,t3XL2)RjnGf1kV„U"w.4BC'62r*NQtckzVL+\.03hrcnMdut.nptFt._?Z3wbLcz&Z*F0yiC[0IP,Rn+„U"3\P^#[\R7]kI[h_ee()(]j=Te)6NSVi^s(^?hZsbFA$.-yFV:qS6M)U>%./h1m9„U"\VDU7,9-+3cw7;<TX7\$+x]d%73NDWwNkSS/?R-Q)V)(/vf8'oZX(H[cNQ]In1j„U"4qnyh;yIl^YWu<HUivrvQL)oNTe*rVVKirVdYNGaeV0GaseiSlS5+mq8ohuxqcN„U"1h9o$tzRGC^X75+..*,R;aJT-*G<VlM1hXU?b$vc55(%CWOgBe>90\,5yeWzrR=„U"vM.+1MO/Wn?(\1H:t3l,S$?u<;3[\[Y'\imHm(Q7qVD0T+fo;lH(1/nKG(fBYv3„U"A*:S(,6,RsdFwQpcAxlx<)H9e7rK\?uKID%;D4o*2oO(m\&syKmt8AS,V=wW_Dy„U"&:4tjioE6Ku*et?wx&%M6Ga8MG&6:7]i[ZE,r=m_%FJ<nHOc2UF/)1bi*jT3RSn„U"#)=z+4-c+I:#$,N](gZV^0Pvi2(wgg6hE;=MYSOWt^n3*\1'asb^m61F8Y68Wug„U":'>\)u8KwcRn:q)c-OD;:LBg>JOrMMqtTXO;$oU2?e1SxO+M38U=GsEe)JRy=5/„U"h,zIX=YnKBqytipb%(34<O2R$u3)P8p0^D&+wQLJggiak%Km&d3v\j7']=URec+„U"*Qlb'<IfOas[ETnT3[$e7W.bGe^mJbK%ghDD5o/2gA]Fv36unu)(KsUF2H4FNnN„U"LhRFDWf$5VUM=lhwYV=%:W=B;F2V4YxSbrA-+ksBaoT(h4WO0Q#85Sa2c]4Wsw,„U"T22DC*qgrPh+rm8G:G\L$7vH8KA9KK#Q[e-s2V/T)PQ?kbV<4r+ntNXp;.Qpt.f„U"h8tKr[>sL8uw\*zq[&q$A>1:/cbp0EZ,rxKu(TxVMzdbWAT#(Eyi8UmD;M>L?gs„U"v=pANqDF7(Y%KScWqdwZde8.Pk6GH>EoklpZ^:nG?u_<i&[,50nL(:nNt7.E%P_„U"apw(9GcMm3mSy3]5pAwBQCN7[0LpDE*'V+pxch6Tf2vULnLw(<=al<3?TV>_BKv„U"uQ_3GaUnk0trj-)O#4N4f^9'PE2aJy.y-qV?rw3TC\,7iwpor.DWgT1<(-YFxjD„U"ch+d1*s5]?t.X5rlofF.GI.S$*R+R%().\-(XMpIM9x#[ZQ>MT+2>0[UY0+$LHf„U"or*a+h0j;#s;YDe1*(Or_idC(un;058Q)K7(m2RYbJ?L*2*3,RqvbIoj$Su=Yh\„U"DC,bS$f<;]%y?%/d?wmCr#qqH2%?3^tS\b9>/JVFKEhF#5)krAb*p>MWKK0F*<1„U"A;yOEy))as:(EzU+E6A/#O#;.R\yi-^D53ZOJD91s(BwY'm3rVG#l7^2ka)7^[*„U"Y6$#G$nl7+*V+c]OUAM;%?seBlcwElQrI>kCCN]4w>_Xa:3Wtj.A7<)2Gr7V\6T„U"=,_*=8(aIOMb_6kbINWr#-hw$Ht/AO\9,/w6H54N$9k\0(A5P&T^6^I)W#7jj^O„U"y8:;UhD6c;A:0WXc[C_sHx4x3NIrbFvQkPWXg5t\3aZV^<[UqjIk#\R*h3l\f(?„U"N'f,kOFHMlD:989x(9;?sZDfYvF:\,wS8;A/54c'xMBN-$ITD[j\rndXH2aKiu3„U"df9:>UE4.kG09(EQ7rh;7g'_6fAXFz=/_m7N).5fqsfr1+u*OvMDo'Mr\C-P)o:„U"-&0E0?'TZ/qU4\WuN-2P]EQg)s-$Qt$TA-,XP;D/dphU\Q%pq9A9ML+m4=FwTAE„U",>9_agA+^48L\N[gfEQuA';I&I=?W)c_N7KO1l)s*oEk0Hn$]KT#',xN&$Q.LG<„U"aV>3a0j-VV$RUd4N(**q1t*oSd68e(tZ>T,8x1JUtdohmnaPY9LAodrX*Jh/vTr„U"]1Ee$8t6t9=m0;:Z(;rd'y$x(>V/ug?WZenI8q9);4yGmJPsHsU[x?iZCxeChJX„U"(o\l:I'Rl=?RPH.x#D+q&GIFkv\9rN\\Zprte(s[$Yi:5[L\:^[R=+tuo^b*C=<„U"spHCXd$\+v?)El-d6CExpw8qq&fQFf]67r\saZU=gYWP20aOjuc.,d-9-e__LNE„U"&P5N;CLEqz8kS=rWL/_z9]Yw>3\MAFEul&HKl?qDT4fHZ)biyH.AVMfo5c'k#:p„U")moPC/-mgER&?SW0v?4:.ErFM)'uZ=^?A>0?64[OErHS3aq?Ej8:A4sCS^WT$*p„U"82+$RQYBNftVnuVNJEhd_?NjmVdr),2w(,#RR*NfKnN9mvdrxiownuq*^s-<]wB„U"Df_'74'?hkH8__['OXX.H*Gv4]f$dKE-rq5a9BqFy<.*/3$&q1m3?n$q0S'G]S9„U">;WOrd4jo2(^w>k6GT<1Gpd0xHSi*C$gw)OyH02Y4?y^R^qae^F*ZrsZOFBXz4\„U"J3_z/k<-OUa9wP88%$'jQ<C3#BD.0XIlrJl)ehO_qEH]Nkii3fgeR^57\DB/)jN„U"e]u-Oo[UJxOZP[tINo.nceU(cpAaQux]VR1#[DX2?'3jySK)iu?:90oj3<Ex[wY„U"f0uwOzfimkdmCX+1J,OL(z9Ii91KK+N(K_^d3XwJsJiFQ/EDccPNlP$$e2SOWNb„U"icbhrNt2&wS6?bY[-qTC*8A%Pfh9i'YbFch;^aa.k\]V-E.;Z-E]&;Wj,$^,kel„U"wr9$w-jPOj$/o;t07o.PA/93#byb+VbI#5V;4<t6Fr3)0de1?VI6A6UaT-o#mtn„U"TivfhGRNki%L3^^AEE0w/-t<&*RWF694#=Qo[0RXnZfp7bTcjcfdhcFgm&#X*<1„U"COeM^[9I4:gCOZ&,XQFL-qeoBnt]*O7p\aeF:GR\qjcSBf,>=.:LMEz)b(dyBD4„U"AP4P5K)^tnAhD%5:Ac*dP-b^/zjuX&egwJ=*f':2hm8bg#ZC;.z-.c/4<K;Gj^m„U">/\vBSO2-(w3+uJ:=vGDF0$38$,s\5<BvE<_C^Q>W<+e*H#/Le\a\wiM)+%Uyrb„U"3&%;R(aqbIJq]\w;_#>Mv&O8Fpd'>%u(nS2T4lO9X/g1h?M\[X)l)Bnk:q;XzHE„U"K?(RdnMRYlg?tJg'>],?aT$cYMIE/Z'A90)o_S9X#,Uz:1$EG1'LrVzhQpJNt:.„U"rS5M(a\6Vj:wuvw1C2V_/XD\Mx\D]NN>Nmz9C-N.?Nr=DhOWY,S/5x/GXm<jL9J„U"#+DF4fXov?ci+Hi2J=8hU]1\kK?;.%+n9\^9._5hVLUS1*zE0m$:B/TigeB0?we„U"2%6EGJF$Khj/o^SaF7R?Z/kNQMj8+FY\bA*j;x$>L^PictLZN9T^,T8E.kc3Qb^„U"QZ(q0adwZ1TLo;.mZn9^aHK8?B2RTH^.Nmp\2:dOo,1Y(wkP4A-O*pN;&Q2Wvrb„END SUB„SUB V2„U"3Yz>),qDM8ih#,YE4[oP3HhzvZ7Mm=\cSv2NaTx-ZG/9EE'R4E>gF4<GyR01n5p„U"TQ\VlRSbhM,LT&isBO07/qb5^pP]l$P'>JE9V/cUrkW:3Dnl'58a8*zxuRUhNo.„U"#Ip=T<?)mXw4cf#zuAao#;R-fH1-TMwiXKN)pJ^9dkuh6_Ku?+ijrZdE<K0+2?=„U":e6g3hJ*+&C91vwaHkshPVibjF'vb8io*8dwU1[<KZNMbbMR$ILd/'>K,M_rn-4„U"A71/wd/MC#/<N3j'Bn:xc(c%dxA5Xz7kUQ.-u.BpG4)0]/$b46kQj<S310^8F:6„U"ot>5G.MA^1>\\jb$O_gForscFmD'A%^S4kq5_[nbJh<,acdunwED;y[;qsYh'jp„U"US_25Je,xYAfM1y*&WUcV99b^7IY\3)1PtH-3So:BCU*fnU's#jEM_xiJ;ihX&X„U"^'X6HULfe'OS^]\]G]^4UE?M0WF>4FPmK2(tpl#l$j_N*e-+iNG5epMU#W(GeZC„U"8'o&9mQ>:bi\[qRY$_u/QHF$rs>4j)OMjd^Rs&tcd.hUdZG<<iQ>cAT6exBw[Om„U"<G1MKx70g)ck)DHRfLT9iE[$?/A(mq8Fom7pwZcK6QhJIVC:NNe,XXym_>?UttC„U"oS:\Nu9&oP-pm$NTa\eF*CJ2jsu5V\qy*WZW]wrstHseqkBtJXsi#oNZ.JL[$6'„U"tWZ0PO<76b+H&0g>Jf$Q/H:X>+2CX(4m5dlo/Lq1ej%O:Mw4<k?iAleHZ(fdffJ„U"RS%+4-+H6I*u3qOiGr,%E+9kHOUDbGq=N()p/aE[rW?4M&'-XK]zjqIYzgSJ(n8„U"VMuB0u8PG:8=<85pS]gCa+1Oii(^]BKo=B[R_L9vJ&BPLz=<c-'tUD\3RC7]r&&„U"Qyn^Fv2ODy7nu>K9S3HN*ypb[=*s>PT(23O(Ty6dH19Y?-NPB$;A\&#AJ^0K43%„U"JuV'ZnqG/a8rjJP/Wvz>$>i1.B>9p3r]jNK>KHZ%C\5H[*sL%eQN:9y*&*YgowP„U"[?E.pg'DrTYY.$0[r)W'JW5egsEFOrn]'kmrLpZ(Qf*JqIzGFm9?[-KQ&Q;Wf.$„U"8R7a7(;1x/xyA<NX'8X<3dC[o31D<0ga/%>C4sUIwvsj%GWb'0&9P_5scsoV8=?„U"R(Fp$y-L%Zp^'vj)e;$d9+<e,oOs.sR$^'O+'\ai[*/HuLVSwDtl/NdvbwTij/?„U"#43qrJ]RfeNYV$JUV21&9.3j0&*^6,Kh5\GV))^BIor2PO(R8flju3$$5D'-%b)„U"&j?1XTUc<P>EQQoP_Qs3C'h2+LcM+ABb*/*&fc(pQU^9$22%bhBJkBT>f>og-'2„U"XaC^^$hc*mf$h6*/w?BggC?2S=pEt:<1etZ7RFuMgTcYsU['HEBZ%pB2HMkyffE„U"XubhS;HCc1*JXhTO#%)kU^DeW?7/b_4o/W.MGlX;<xCvOTE1L/i[&9n4;vdnYY^„U"H(odsX;*:KT89&gQUtadziCw0X3;Td2nXzX)&j91/KdM:8=v;'#chGQ-TBnQT^)„U"yegdSm71c$oc=Mw&iH&0lP=6081wrxc4S)H(<5TF*>I1jl%y;JpO*i*:,QR/zdK„U"sy'5jkfsiN,i/FlWc2v#qHFwkbmg<<,%4i(qS&pme=4EE^BYYeogccoZD4lf$pC„U"D0;EC$T,BVP:l2^2,kr25wE_mfJ2R&hfi&O#N-p1u)>Qijb]E(H2>ag2:$i$o$o„U"+P51s=Mj<A/Zp3d;#',T*8S]t7%caHN'XNYDXo^67R0%K[TFFEXhZqNr)9_fDKB„U"_3OTm*jnvS]^O7fTA6YO188u0f\F9)P7Fk#YSU'du/Hk%ub$',b+M/aGR9bP6=P„U"bkNoGX*5&Kj2_lEp%?ak^?m%\P=JSMe+XTRy4F)?OC0[C0[\<o:qi>>/bSOkwzo„U"F=M_gSP4j#+S+ffFWvty)<-mm%\p2vNHHZDlp5'%3vne8)*F]m2&9Yj&H[z]F0L„U"0iO#)9+s*4-NKYoU<2'-3P&Q/ulc?FOt^,xykIZWI;8m=rp4hqQBQwrm[eq:c2q„U"f(3sNTu1U7QuM/WCf\%k?5/cD>5=^%Fp*f$fpe<:68:u+Dc[I2b<qPm/r<NL)aG„U"p^/\'O-[f99RYu<&cFA?h5u:)z[$;[h/gJKN1nk5#0^73/+2P(H[Js5%:(hD4lo„U"CKO5yU+eX\rPPcWZajp$c)[KFIX7.f7;CHUZ3?V'9^.?iHxys^MN?.taWK\q4&5„U"T8(i6DAmXhLkkbg(z&-a.RWP:44rhVB]l.b64Knpl;<zxA(zmhOUqys^dHrxZr8„U"*uE#ArgoX<wR:pQsdfx0ZsIC5HNB8/02GFdU/+fkEq*wM,KQx;P1Zu]j8B,sip+„U"Nq'9\wM,]2oGlKIjM=#;nXa&\Jw'i#j>mBFw_vd(m^4Zq1L1(qs'gUIboI9SVZI„U"X7wSmbSxZB6Syf*3/*Sbc3I9e3H((i5BU46Pr8aP(*]j9:f<:.H_&[d<b%8X9A>„U"$NM/>qgth3.LGZH^>ZjOG4[XJjKj+L[PABnOL*g29qRbp?Man?hv#??7QRrqR#b„U"XrDmMHV6=rVcTFk:9+Rw2o(M*LT.5%jE7-Kk';.4qQ0pNTdd1S%tIgeEWC=H.Yx„U"-&g1rn_B\NXP\ljXEmg58p>B7.gDV*_:3e%O$>ASc$0cUZ#c8n.wr2^e7KQfE.&„U"k&VdAJvRS:3P'dY<it(9hB=aTPA_3u_89()w\CYrtf4Y>YR8Yq6>;wn_*5Ur.O,„U",BE/5yVf;DolOkS%Oe#M0cFU0gDRy\JWPuufrQcx++e(CQ_=ET(8E%xy=%xM)m3„U"6ihALM2IUD;pjnjB)xshgj=Up=6gUf[MLI%F[90#s3%G5v6H;GRZ35?xl&upfvi„U"c7V.i3#94t7<Kd4%1,pJ7**^#B,Eob8DuNy]ZtgRoMKM5$;xaODT%,(Sj,d.He)„U"]7Ni7+_TRbs0[bdu/i_fK0uL<%Zehc5qBE#L^Ds(([[-khTF<%b#<+V-Fa9-,8K„U"+O:%nx5Md6Lnc]5hpSjm?1K*TAtGLT.WnpQum%di_TW&2NZR_iVu1._q/%iOn5G„U"88czU6WO1tL.A67Oc8-48#fyA>_#6>=n$CE']e'VS(JM6K^;sr=G/[P.6ag$i&6„U"v)*(OzeVbx&zUOmO(eiXjaBa9H]buCVjCi$Szr69qkwbp1ek$8vkP3'#Ek(FWM*„U"OYCeGVD$KKVs&pPcw=,t47J)N]7,Kl+Uhg9$N)rhkpqI(um_]5YVsc35sJJbGV>„U"&)64VNNQ66vf<^:ES]WgujcKm:g.et\;bT6S+bfdfWo8BNE'%-P0TOh6WME+%](„U"&1aS#Ue:iY&A^=&s8H</lz'8dObrC13ew+-Meuc6IUqZXA/Wajv4t+hQ9D]d'WB„U"#'J>c/KK&KE\Ob%$$JF.R1uIDO64aSzk0(1X>3TIxZ;DK7QK8WfhdS,_:^i'U$u„U"fU->agSdeNDRS9F3*cV4Hplgvp1b+\4F9ZLa8Ufp9fq*4NKju,ql1ZA#k$,+Qk^„U"FHRBV_a4Iu$J(cIWw^=onKiuBf#VnVJ#LH;eK5&Q%v_XxsXpH^108-8o)*u,f90„U"6O4*U,:_?6r9FBuf&O^Jd>Z%5Y+7r,#uOY+p$7+8HIqM6<,0G\m4:Z#*/)?9,*/„U"qYRwI9>R,))i/Zl)khBbCgkluq]BbE$.aL\Ey9OGxOQMODe+8\0cT7$X,Tc':J[„U"wECcX>ZuBT%Q&NP^;zYRsk=Vh1WFYWU?KiLdn:Lx9h-5iBUKK6^V98Ze$5pc,rd„U"H<6X3V8F<TW*tM(y.-4YA7HfXd3lSY\Fi)zyezj9k_\_QH?2&v)RT$RZ.>[y#Md„U"tyvir^w1G<TZ(oVJc)>Nj5s+An=u>aD?&:r1Qa5mfNh=p]#-/ra20>C7h<&<'s7„U"otED)y1Z^u:F3Rd*yB;S$1myGp*MyyPS:>)jECG#4PcqIx.Os-%E\q4aF*+bQ;a„U"S,erHirkI/Zk;R174.;UKCVVRm]YVhqJ]Xhe/?CLcYe_)^=;pH2PvzI0Hd5=*1p„U"hTT:6.GG-*:c-8v]OFT<$WYJC9Bf[Od)NF0i^rOhie$OZNo=5w;3[99Shy7bC2&„U"y6js:UKEbqkx*^]mowXrRWRD4$G]hg$+x%Dup&%'9%9%%%%-I%2\*jDATY-vdX%„U"=%[2%%%1%%%%%%%%%&%E%%%%%%%%%f%wifk%VZVS%gfxu%p*+%%%%%&%%&%_%%%„U"%:%Y%%%%%„END SUB„V2„CLOSE:IF S=226AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„'>>> Page 1 of ARDAF.ZIP ends here. Last page. TCHK:226„