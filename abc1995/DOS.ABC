Jerry Aldrich                  GET DRIVE TREE                 GET,DRIVE,TREE                 12-01-92 (05:15)       QB, QBasic, PDS        117  3596     GETTREE.BAS 'It will NOT work on a Mono system, due to the„'fact it uses 2 video pages, but it works just fine with color.  The„'resulting program will scan the same drive in 16.7 Seconds (compiled) or„'19.5 seconds in the environment.  And it's ALL QB code!  Here 'tis:„„DECLARE SUB GetDirs (Path$, Level%)„DECLARE SUB ShowTree ()„DEFINT A-Z„' Dimension Array to Hold Directories and Variable for Number of Dirs„DIM SHARED Path$(300), DCnt„„' Set Active and Visual Pages to 1 and Clear Screen„SCREEN 0, , 1, 1: CLS„„' Prompt User for Drive Letter and Prepare Screen„PRINT "Get Tree For Which Drive :";„DO: Drive$ = UCASE$(INKEY$): LOOP UNTIL LEN(Drive$): PRINT Drive$„PRINT "Scanning Drive " + Drive$ + " :"„„' Set Frist Path to Root and Directory Count to 1„Path$(1) = Drive$ + ":": DCnt = 1„„' Send Output to Page 0 (hide it)„SCREEN 0, , 0, 1„„' Start Recursive Directory Scan„GetDirs Path$(1), 1„„' Clear Screen and Set OutPut Back to Page 1 and Show Tree„CLS : SCREEN 0, , 1, 1„ShowTree„„' Set All Pages to 0 and End„SCREEN 0, , 0, 0„END„„SUB GetDirs (Path$, Level)„' Clear Screen, Display Sub Directories in Path$, Find out Last Line„CLS : FILES RTRIM$(Path$) + "\*.": LastLin = CSRLIN - 3„„' Start Scanning Each Line of the Screen for Directory Entries„FOR Lin = 1 TO LastLin„  FOR Col = 0 TO 3   ' Start with Column Offset of 0„    D$ = ""          ' Clear Temp Character Variable„    DEF SEG = &HB800 ' Set Default Segment to Video Memory„    ' Read One Entry (17 Characters) From Video Memory„    FOR Char = 0 TO 34 STEP 2„      D$ = D$ + CHR$(PEEK(Lin * 160 + Col * 36 + Char))„    NEXT„    DEF SEG ' Set Default Segement Back to QB Data„    ' If Entry is a Sub Directory„    IF INSTR(D$, "<DIR>") AND INSTR(D$, ".") = 0 THEN„      ' Update Count on Visible Page„      DCnt = DCnt + 1: SCREEN 0, , 1, 1: LOCATE 2, 19„      PRINT LTRIM$(STR$(DCnt)): SCREEN 0, , 0, 1„      ' Add the Parent Path to the Name„      P$ = RTRIM$(Path$) + "\" + RTRIM$(LEFT$(D$, INSTR(D$, " ")))„      ' Store it to the Array„      Path$(DCnt) = P$„      ' Do a Recursive Search of That Sub for Subs„      GetDirs P$, Level + 1„      ' Find Last \ in Directory Name„      DO„        W = INSTR(W + 1, P$, "\"): IF W THEN P = W„      LOOP WHILE W„      ' Parse Out the Parent Directory„      P$ = LEFT$(P$, P - 1)„      ' Clear Screen, Re-Display Parent Directory, and Get Last Line„      CLS : FILES P$ + "\*.": LastLin = CSRLIN - 3„    END IF„  NEXT„NEXT„END SUB„„SUB ShowTree„CLS : S = 1: Top = 1: IF DCnt < 22 THEN Max = DCnt - 1 ELSE Max = 22„Refresh:„OldN = 0: N = 0„FOR I = Top TO Top + Max„  P$ = Path$(I): N = 0: P = 0„  DO„    W = INSTR(W + 1, P$, "\"): IF W THEN P = W: N = N + 1„  LOOP WHILE W„  P2$ = Path$(I + 1): N2 = 0: P2 = 0„  DO„    W = INSTR(W + 1, P2$, "\"): IF W THEN P2 = W: N2 = N2 + 1„  LOOP WHILE W„  Nof$ = LEFT$(RIGHT$(P$, LEN(P$) - P) + SPACE$(20), 20)„  IF INSTR(Nof$, ":") THEN„    LOCATE I, S: PRINT LEFT$("\" + SPACE$(20), 20)„  ELSE„    T$ = "": FOR J = 1 TO N - 1: T$ = "≥  " + T$: NEXT„    IF N2 < N THEN T$ = T$ + "¿" ELSE T$ = T$ + "√"„    LOCATE I - Top + 1, S: PRINT T$ + "ƒƒ";„    PRINT Nof$„  END IF„NEXT„DO: K$ = INKEY$: LOOP UNTIL LEN(K$)„IF LEN(K$) = 1 THEN K = ASC(K$) ELSE K = -ASC(RIGHT$(K$, 1))„SELECT CASE K„  CASE 27„    CLS : EXIT SUB„  CASE -80„    Top = Top + 1„  CASE -72„    Top = Top - 1„  CASE -73„    Top = Top - 19„  CASE -81„    Top = Top + 19„END SELECT„IF Top < 1 THEN Top = 1„IF Top + Max > DCnt THEN Top = DCnt - Max„GOTO Refresh„„END SUB„„J. Derek Lyons                 PARSE COMMAND LINE             PARSE,COMMAND,LINE             11/91 (00:00)          QB, QBasic, PDS        224  8643     CLINE.BAS   '  Program CLINE.BAS„'  Version 1.00„'  Parses the command tail into an array holding all„'  command line arguments.„'  Written by: J. Derek Lyons.„'  November 1991„'  Released into the public domain to the extent of my ability to do so.„„DECLARE SUB ParCline (Arg$(), MaxArg%, Res%)„„DEFINT A-Z„OPTION BASE 0„„DIM Arg$(5)             'Array to hold the arguments„MaxArg% = 5             'Maximum number of arguments„'„'  To demonstrate CLINE, simply compile this program inside Quick Basic„'  or from the command line.„'„'  Many more options are discussed in CLINE.DOC„'„CLS„CALL ParCline(Arg$(), MaxArg%, Res%)„FOR x = 1 TO 5: PRINT Arg$(x): NEXT x„IF Res% = -1 THEN PRINT "Too Many Arguments"„IF Res% = 0 THEN PRINT "Sucessful Processing"„IF Res% = 1 THEN PRINT "No Arguments Found"„END„„SUB ParCline (Arg$(), MaxArg%, Res%)„'  Inputs„'     MaxArg%   Maximum number of arguments„'     Arg$()    Empty array to hold the arguments„'               To work properly should be DIMed as Arg$(MaxArg%)„'  Outputs„'     Res%      Result of subroutine„'               -1 = Too many arguments„'                0 = Sucessful processing„'                1 = No arguments found„'     Arg$()    Array holding the arguments„'„                        'numarg and argpos must be initialized„                        'because QB initializes them as 0„NumArg = 1              'Because there is no leading space for the„                        'first argument we must add 1 to the total„                        'number of space to find the total number„                        'of arguments„ArgPos = 1              'The first position in the array„„Cline$ = LTRIM$(RTRIM$(COMMAND$))„                        'Get the command line and trim all the spaces„Clen = LEN(Cline$)      'Get the length of the command line„„IF Clen = 0 THEN        'There are no arguments so there is no reason„                        'to continue processing the command line„   Res% = 1„   EXIT SUB„END IF„„FOR Scount = 1 TO Clen  'Get the number of arguments„   IF MID$(Cline$, Scount, 1) = " " THEN NumArg = NumArg + 1„                        'Each time a space is found in the command line„                        'the number of arguments is incremented„NEXT Scount„„IF NumArg > MaxArg% THEN„                        'So we don't crash the program by trying to„                        'write past the end of the array„   Res% = -1„   EXIT SUB„END IF„„FOR wcount = 1 TO Clen„   IF MID$(Cline$, wcount, 1) <> " " THEN„      Arg$(ArgPos) = Arg$(ArgPos) + MID$(Cline$, wcount, 1)„                        'If a character is found, then add it to the„                        'current string„   ELSEIF MID$(Cline$, wcount, 1) = " " THEN„      ArgPos = ArgPos + 1„                        'If a space is found, start processing the„                        'next string„   END IF„NEXT wcount„„END SUB„'     CLINE.BAS„'     Version 1.00„'     Mountain Bay Software„'     James Derek Lyons„'„'     A subroutine to parse the command line for„'     QUICK BASIC programs.„„'CLINE.BAS is hereby released into the public domain to the extent„'of my legal rights to do so.„'The author makes no warranty as to the fitness of this code for any„'given application.  The responsibility for determining fitness of„'use and for any damages caused lies with the user.„„'CLINE.BAS has been tested using MSDOS V3.3 and Quick Basic V4.5.„'QUICK BASIC and MSDOS are registered trademarks of the Microsoft„'Corporation.„„'INDEX„„'1.      Overview„'2.      Program Logic.„'2A.     The Parsing Algorithm„'3A.     Error Handling.„„'1. OVERVIEW„„'     One of the most useful functions of MSDOS is the ability to„'use a 'command tail'.  That is to say, a set of variables which„'can be read by a program at run-time and used to modify it's„'operation.„'     In QUICK BASIC the COMMAND$ function can be used to read the„'command tail into your program.  However, this function returns the„'entire command tail as a single string.  Unless you are using only„'one run-time option, this is fairly useless.„'     CLINE offers the QUICK BASIC programmer a method of importing„'this command tail and parsing it into useful string variables.„„'2. PROGRAM LOGIC„„'     The algorithm used by CLINE is fairly simple.  The requirements„'for using this subroutine are deliberately held to a minimum.„'     Three variables are required to use the subroutine.  Two must„'be declared in advance.„„'     These variables are:„'     MaxArg%, which is the maximum number of arguments expected.„'     Arg$(),  which is a string array to hold the returned, parsed,„'              arguments.„'     Res%,    which is a variable to hold the result flag for the„'              subroutine.„„'     The following assumptions apply these variables;„„'     MaxArg% is the total number of arguments that the user can„'legally use when loading the program.  As will be shown later each„'argument is assumed to be separated by a space.  Thus "/FILE DUMMY„'would be counted as two arguments.  "/FILE:DUMMY and "-AJ2" would„'both be considered to be one argument.„„'     ARG$() is a string array to hold the arguments when they are„'parsed.  To prevent programs from bombing, ARG$() is best„'dimensioned by using DIM ARG$(MaxArg%).„„'     Res% is an integer flag that returns the result of the parsing„'process.  These results are defined as follows;„„'     -1   indicates that too many arguments were found.  Processing„'           is halted and control returned to the calling program.„'      0   indicates that processing was successful and the parsed„'          arguments will be found in ARG$().„'      1   Indicates that no command line was found.  Processing is„'          halted and control is returned to the calling program.„„'     No error handling is performed by CLINE other than the setting„'of Res% to the appropriate value.„„'2A. The Parsing Algorithm„„'     The command tail retrieved by COMMAND$ is processed as„'follows;„'     First all leading and trailing spaces are removed using the„'LTRIM$() and RTRIM$() functions.  Since the algorithm determines„'the number of arguments by counting the number of spaces, any„'extraneous ones at the beggining and end must be removed.„'     Because there is no leading space for the first argument, the„'NUMARG and ARGPOS() variables are initialized to 1.„'     The length of the command tail is then determined.  If no tail„'is found, processing is returned to the calling program.  A flag„'is set to inform the calling program that no command line options„'were found.„'     Each position in the string is then examined using the„'MIDSTRING$() function.  Each time a space is encountered, the„'argument count is increased by one.„'     The total number of arguments found by this statement is then„'compared to the maximum allowable number.  If the number found„'exceeds the number allowed, processing is halted and control„'returned to the calling program.  The programmer must provide code„'to handle this error and inform the user of the failure.„'     Each position in the string is then examined.  If a non-space„'character is encountered, the character is added to the current„'string.  If a space is encountered, the string number is„'incremented by one and processing continues with the next„'character.„„'     Hence the string /FILE DUMMY /A -AQD2 /OUTFILE:TEST would„'parse as follows;„„'     String #1     /FILE„'     String #2     DUMMY„'     String #3     /A„'     String #4     -AQD2„'     String #5     /OUTFILE:TEST„„'     Note that because of the way COMMAND$ functions, all„'alphabetic characters will be in upper case.„„'     Control is then returned to the calling program.„„'3A. ERROR HANDLING„„'     Other than errors relating to the number of arguments, and the„'lack of a command tail, no native error handling is provided.„„'     If too many arguments are encountered, the programmer must„'provide routines to inform the user of the syntax error and recover„'from the error condition.„„'     If no arguments are provided then a flag is set to inform the„'calling program.  The programmer must provide code for his program„'to respond approprietly.„„'     It is suggested that if too many, or no, command line„'arguments are found, that any defaults be loaded and the user„'informed.„„'     If this code is used in a command line utility, (a program„'that is run only from the command line), that the program inform„'the user and exit gracefully.„Michael Malley                 COMMAND$ ACTUAL CASE           COMMAND$,ACTUAL,CASE           04-24-92 (16:55)       QB, PDS                33   648      COMMAND.BAS TYPE RegTypeX„     ax    AS INTEGER„     bx    AS INTEGER„     cx    AS INTEGER„     dx    AS INTEGER„     bp    AS INTEGER„     si    AS INTEGER„     di    AS INTEGER„     flags AS INTEGER„     ds    AS INTEGER„     es    AS INTEGER„END TYPE„DECLARE SUB InterruptX (intnum AS INTEGER, Inreg AS RegTypeX, outreg AS RegTypeX)„„DIM Regs AS RegTypeX„„Regs.ax = &H2F * 256„InterruptX &H21, Regs, Regs„DEF SEG = Regs.es„„Offset = Regs.bx„Length = PEEK(Offset)„„Cmd$ = SPACE$(Length)„„FOR Counter = Offset + 1 TO Offset + Length„    MID$(Cmd$, (Counter - Offset)) = CHR$(PEEK(Counter))„NEXT Counter„„PRINT Cmd$„„DEF SEG„„Logan Ashby                    RENAMING FILES                 RENAMING,FILES                 06-28-92 (15:44)       QB, PDS                98   3257     RENAME.BAS   ' --------------------------------------------------------------„ '| WCRENAME.BAS                                                 |„ '| Rename function that supports wildcard characters in file    |„ '| names.  Logan Ashby - Public Domain - 06/28/92               |„ ' --------------------------------------------------------------„ DEFINT A-Z„ ' $INCLUDE: 'QBX.BI'„ '-----------'QB.BI' for QB45„„ ' --------------------------------------------------------------„ '| FUNCTION and TYPE Declarations to be used in module level    |„ '| code which calls Rename% Function                            |„ ' --------------------------------------------------------------„ DECLARE FUNCTION ReName% (OldName$, NewName$)„„ TYPE DosPListT„     ax AS INTEGER„     bx AS INTEGER„     cx AS INTEGER„     dx AS INTEGER„     SI AS INTEGER„     di AS INTEGER„     ds AS INTEGER„     es AS INTEGER„     Rsrvd AS INTEGER„     CompID AS INTEGER„     ProcID AS INTEGER„ END TYPE„„ ' ------------------------ ReName% -----------------------------„ '|  Renames file(s) using DOS Interrupt calls.  Works across    |„ '|  subdirectories if necessary.  Returns 0 if successful, DOS  |„ '|  error code if it fails.                                     |„ ' --------------------------------------------------------------„ FUNCTION ReName% (OldName$, NewName$)„„ DIM InRegX AS RegTypeX„ DIM OutRegX AS RegTypeX„ DIM DOSParmList AS DosPListT„ DIM FileNameBuf AS STRING * 128„„ Null$ = CHR$(0)„„ FileNameBuf = OldName$ + Null$     '| Canonicalize OldName$„ InRegX.ax = &H6000„ InRegX.ds = VARSEG(FileNameBuf)„ InRegX.es = VARSEG(FileNameBuf)„ InRegX.SI = VARPTR(FileNameBuf)„ InRegX.di = VARPTR(FileNameBuf)„ CALL InterruptX(&H21, InRegX, OutRegX)„ IF (OutRegX.flags AND 1) THEN„     ReName% = OutRegX.ax„     PRINT "Error in Canonicalizing OldName$"„     EXIT FUNCTION„ ELSE„     TmpOldName$ = LEFT$(FileNameBuf, INSTR(FileNameBuf, Null$))„ END IF„„ FileNameBuf = NewName$ + Null$     '| Canonicalize NewName$„ CALL InterruptX(&H21, InRegX, OutRegX)„ IF (OutRegX.flags AND 1) THEN„     ReName% = OutRegX.ax„     PRINT "Error in Canonicalizing NewName$"„     EXIT FUNCTION„ ELSE„     TmpNewName$ = LEFT$(FileNameBuf, INSTR(FileNameBuf, Null$))„ END IF„„ InRegX.ax = &H5100                 '| Get PSP Segment„ CALL InterruptX(&H21, InRegX, OutRegX)„„ PSPSeg% = OutRegX.bx„„ DOSParmList.ax = &H5600            '| Build DOS Parameter List„ DOSParmList.cx = 0                 '|   Structure.„ DOSParmList.dx = SADD(TmpOldName$)„ DOSParmList.ds = SSEG(TmpOldName$) '| Use VARSEG for QB45„ DOSParmList.di = SADD(TmpNewName$)„ DOSParmList.es = SSEG(TmpNewName$) '| Use VARSEG for QB45„ DOSParmList.Rsrvd = 0„ DOSParmList.CompID = 0„ DOSParmList.ProcID = PSPSeg%„„ InRegX.ax = &H5D00                 '| Do Rename, using Internal„ InRegX.ds = VARSEG(DOSParmList)    '|   Server Function Call to„ InRegX.dx = VARPTR(DOSParmList)    '|   support wildcards in„                                    '|   filenames.„ CALL InterruptX(&H21, InRegX, OutRegX)„ IF (OutRegX.flags AND 1) THEN„     ReName% = OutRegX.ax„     PRINT "Error in Renaming Files"„     EXIT FUNCTION„ END IF„„ ReName% = 0„„ END FUNCTION„„Matt Hart                      GET/SET FILE DATE/TIME         GET,SET,FILE,DATE,TIME         Unknown Date (00:00)   QB, PDS                128  4483     FILEDATE.BAS' FILEDATE.BAS  by Matt Hart„'„' Gets or sets a file date/time„'„' GetFileDateTime returns the Date in MM-DD-YYYY format„'                     and the Time in HH:MM:SS„' SetFileDateTime expects the Date and Time in the same formats„„    '$INCLUDE: 'QB.BI'    ' Use your path to QB or QBX.BI„    DEFINT A-Z„    DECLARE SUB GetFileDateTime (F$, Dat$, Tim$, Ecode%)„    DECLARE SUB SetFileDateTime (F$, Dat$, Tim$, Ecode%)„„' ------------------------- Sample code„    F$ = LTRIM$(RTRIM$(COMMAND$))„    CALL GetFileDateTime(F$, Dat$, Tim$, Ecode)„    IF NOT Ecode THEN„	   PRINT F$; " date is "; Dat$„	   PRINT F$; " time is "; Tim$„    ELSE„	   PRINT "1 Error = "; Ecode„	   END„    END IF„    NewTim$ = "01:01:02"„    NewDat$ = "02-02-1980"„    CALL SetFileDateTime(F$, NewDat$, NewTim$, Ecode)„    IF Ecode THEN„	   PRINT "2 Error = "; Ecode„	   END„    END IF„    CALL GetFileDateTime(F$, Dat$, Tim$, Ecode)„    IF Ecode THEN„	   PRINT "3 Error = "; Ecode„	   END„    END IF„    PRINT F$; " new date is "; Dat$„    PRINT F$; " new time is "; Tim$„    CALL SetFileDateTime(F$, Dat$, Tim$, Ecode)„    IF Ecode THEN„	   PRINT "4 Error = "; Ecode„	   END„    END IF„    END„' ------------------------------------„„SUB GetFileDateTime (F$, Dat$, Tim$, Ecode)„    Ecode = 0„    DIM InRegs AS RegTypeX„    DIM OutRegs AS RegTypeX„    InRegs.ax = &H3D00                          ' Open file function„    DIM FileName AS STRING * 128                ' Use fixed length„    FileName = F$ + CHR$(0)                     ' Must be ASCIIZ string„    InRegs.ds = VARSEG(FileName)                ' Fixed length makes these„    InRegs.dx = VARPTR(FileName)                ' come out right„    CALL INTERRUPTX(&H21, InRegs, OutRegs)      ' Open the file„    IF NOT OutRegs.flags THEN                   ' No error„	   Handle = OutRegs.ax                     ' Save DOS file handle„	   InRegs.ax = &H5700                      ' Get date/time function„	   InRegs.bx = Handle„	   CALL INTERRUPTX(&H21, InRegs, OutRegs)„	   HMS& = OutRegs.cx                       ' Use long integer for„	   IF HMS& < 0& THEN HMS& = 65536 + HMS&   ' positive numbers„	   Hours = HMS& \ 2048&                    ' Hours is first 5 bits„	   Minutes = (HMS& AND 2047&) \ 31&        ' Minutes is next 6 bits„	   Seconds = HMS& AND 31&                  ' Seconds is last 5 bits„	   H$ = LTRIM$(STR$(Hours))„	   M$ = LTRIM$(STR$(Minutes)): IF LEN(M$) = 1 THEN M$ = "0" + M$„	   S$ = LTRIM$(STR$(Seconds)): IF LEN(S$) = 1 THEN S$ = "0" + S$„	   Tim$ = H$ + ":" + M$ + ":" + S$„	   YMD& = OutRegs.dx                       ' Long int here too„	   IF YMD& < 0 THEN YMD& = 65536 + YMD&    ' Convert to + if needed„	   Year = 1980& + YMD& \ 512&              ' Year is first 7 bits„	   Month = (YMD& AND 511&) \ 31&           ' Month is next 4 bits„	   Day = YMD& AND 31&                      ' Day is last 5 bits„	   Y$ = LTRIM$(STR$(Year))„	   M$ = LTRIM$(STR$(Month))„	   D$ = LTRIM$(STR$(Day)): IF LEN(D$) = 1 THEN D$ = "0" + D$„	   Dat$ = M$ + "-" + D$ + "-" + Y$„	   InRegs.ax = &H3E00                      ' Close file function„	   InRegs.bx = Handle„	   CALL INTERRUPTX(&H21, InRegs, OutRegs)  ' Close it„    ELSE„„	   Ecode = OutRegs.flags       ' Otherwise return error flags„    END IF„END SUB„„SUB SetFileDateTime (F$, Dat$, Tim$, Ecode)„    Ecode = 0„    DIM InRegs AS RegTypeX„    DIM OutRegs AS RegTypeX„    InRegs.ax = &H3D00„    DIM FileName AS STRING * 128„    FileName = F$ + CHR$(0)„    InRegs.ds = VARSEG(FileName)„    InRegs.dx = VARPTR(FileName)„    CALL INTERRUPTX(&H21, InRegs, OutRegs)„    IF NOT OutRegs.flags THEN„	   Handle = OutRegs.ax„	   InRegs.ax = &H5701„	   InRegs.bx = Handle„	   Hours& = VAL(LEFT$(Tim$, 2)) * 2048&„	   Minutes& = VAL(MID$(Tim$, 4, 2)) * 32&„	   Seconds& = VAL(RIGHT$(Tim$, 2)) \ 2„	   HMS& = Hours& + Minutes& + Seconds&„	   IF HMS& > 65536 THEN„		  InRegs.cx = 65536 - HMS&„	   ELSE„		  InRegs.cx = HMS&„	   END IF„	   Year& = (VAL(RIGHT$(Dat$, 4)) - 1980&) * 512&„	   Month& = VAL(LEFT$(Dat$, 2)) * 32&„	   Day& = VAL(MID$(Dat$, 4, 2))„	   YMD& = Year& + Month& + Day&„	   IF YMD& > 65536 THEN„		  InRegs.dx = 65536 - YMD&„	   ELSE„		  InRegs.dx = YMD&„	   END IF„	   CALL INTERRUPTX(&H21, InRegs, OutRegs)„	   InRegs.ax = &H3E00„	   InRegs.bx = Handle„	   CALL INTERRUPTX(&H21, InRegs, OutRegs)„    ELSE„	   Ecode = OutRegs.flags„    END IF„END SUB„„Unknown Author                 WARM/COLD REBOOT               WARM,COLD,REBOOT               Unknown Date (00:00)   QB, PDS                13   325      REBOOT.BAS       ' Warm Reboot„ „     DEF SEG = 0„     IF WarmBoot% = True THEN„          POKE &H473, &H12 ' Setup for Warm Boot„          POKE &H472, &H34„     ELSE„          POKE &H472, &H12 ' Setup for Cold Boot„          POKE &H473, &H34 ' tho not really nessary„     END IF„     DEF SEG = &HFFFF„     CALL Absolute(0)„„Unknown Author(s)              RETURN TRUE EXE NAME           RETURN,TRUE,EXE,NAME           Unknown Date (00:00)   QB, PDS                89   3243     REXENAME.BASREM *************************************************************„REM **                                                         **„REM **  This program will read the TRUE program name from the  **„REM **  Environment.  If you are executing a program called    **„REM **  HELLO.EXE, and only typed HELLO at the command line,   **„REM **  It would return the ENTIRE PATH of where HELLO.EXE is  **„REM **  located.  If HELLO.EXE is in C:\DOS\BASIC\QB, the      **„REM **  line returned from this program would be               **„REM **  c:\dos\basic\qb\HELLO.EXE instead of just HELLO        **„REM **                                                         **„REM **  This program is basically a reprint from a very early  **„REM **  Cobb Inside Microsoft Basic Journal, but can be used   **„REM **  freely.  It is in the Public Domain.  No credit or     **„REM **  other compensation is necessary or expected.           **„REM **                                                         **„REM **  This program should work with BOTH QuickBasic 4.5 and  **„REM **  the Basic Professional Development System 7.xx         **„REM **                                                         **„REM *************************************************************„„REM ****  Below is the main program module  ************„„DECLARE FUNCTION ProgramName$ ()„DEFINT A-Z„„CONST FALSE = 0„CONST TRUE = -1„„'PDS users should change the next line to include the QBX.BI file„'$INCLUDE: 'QB.BI'„„CLS„PRINT "Program name = "; ProgramName$„END„„REM ****  Below is a FUNCTION that should be parsed by the QB ***„REM ****  or QBX Environments.  *********************************„„'=================== Function ProgramName$ ======================„'== INPUT: None                                                ==„'== RETURNS: Name of currently executing program               ==„'================================================================„'„FUNCTION ProgramName$„„DIM Regs AS RegType„„'Get PSP address„„   Regs.ax = &H6200„   CALL Interrupt(&H21, Regs, Regs)„   PSPSegment = Regs.bx„„'Find environment address from PSP„„   DEF SEG = PSPSegment„   EnvSegment = PEEK(&H2D) * 256 + PEEK(&H2C)„„'Find the filename„„   DEF SEG = EnvSegment„   EOT = FALSE                 'Set end of environment table flag„   Offset = 0„„   WHILE NOT EOT„	 Byte = PEEK(Offset)       'Get table character„	 IF Byte = 0 THEN          'End of environment string?„'        PRINT                   'Uncomment to print environment„	    Offset = Offset + 1„	    Byte = PEEK(Offset)„	    IF Byte = 0 THEN        'End of environment?„		  Offset = Offset + 3   'Yes - Skip over nulls & tbl info„		  C% = PEEK(Offset)„		  WHILE C% <> 0                   'Assemble filename string„			FileN$ = FileN$ + CHR$(C%)    '  from individual„			Offset = Offset + 1           '  characters„			C% = PEEK(Offset)„		  WEND„		  EOT = TRUE              'Set flag to exit while/wend loop„	    END IF„	 ELSE                        'No-Read more environment string„'        PRINT CHR$(Byte);         'Uncomment to print environment„	    Offset = Offset + 1„	 END IF„   WEND„   ProgramName$ = FileN$„   DEF SEG„END FUNCTION„„John Gallas                    FAST DIRECTORY CHANGER         FAST,DIRECTORY,CHANGER         12-30-92 (00:00)       QB, PDS                240  5577     JD.BAS      ' JD.BAS  -  Fast Directory Changer  -  By John Gallas  -  12/30/92„„' Use it as you wish, just don't forget who really wrote it.„„DEFINT A-Z„„DECLARE SUB AddDirs (CurrentDir$, ListOfEm$)„DECLARE SUB ScanDrive ()„„DECLARE FUNCTION CurDir$ ()„DECLARE FUNCTION DIR$ (FileSpec$)„„' $INCLUDE: 'QB.BI'„„CONST DOS = &H21„CONST SetDTA = &H1A00, FindFirst = &H4E00, FindNext = &H4F00„„CONST True = -1, False = 0„„IF COMMAND$ = "" THEN„„    PRINT„    PRINT "JD 1.0  By John Gallas"„    PRINT„    PRINT "Usage: JD <full or partial directory name>"„    PRINT "   or: JD /SCAN to create a new directory database."„    END„„END IF„„IF INSTR(COMMAND$, "/SCAN") THEN  'they wanna scan the drive„„    ScanDrive„    END„„END IF„„„'open the file„OPEN "\JD.IDX" FOR BINARY AS #1„'create a string to hold its contents„DirList$ = STRING$(LOF(1), 0)„'read in the string„GET #1, , DirList$„'close the file„CLOSE #1„„Search$ = RTRIM$(LTRIM$(COMMAND$))„„'We have to start scanning the list of directories after the current„'directoriy's entry, incase theres another dir with the same pattern.„Temp$ = "C:\" + CurDir$„„Check = INSTR(DirList$, Temp$ + CHR$(0))„„Pointer = 1„„IF Check THEN Pointer = Check + LEN(Temp$) + 5„„IF INSTR(Temp$, Search$) = 0 THEN„   'the current directory is definatly not one of the possible choices, so„   'set the pointer back to 1.„   Pointer = 1„END IF„„Times = 1„Success = False„„DO„„   Check = INSTR(Pointer, DirList$, Search$)„„   IF Check = 0 THEN  'check if its in an earlier entry„	 IF Times = 2 THEN Success = False: EXIT DO„	 Pointer = 1: Times = 2„   ELSE„	 Success = True„	 EXIT DO„   END IF„„LOOP„„IF Success THEN„„   'find the entry closest to Check„   FOR x = Check TO 1 STEP -1„	x$ = MID$(DirList$, x, 1)„	IF x$ = CHR$(0) THEN x = x + 1: EXIT FOR„	IF x = 1 THEN EXIT FOR„   NEXT x„   x2 = INSTR(x, DirList$, CHR$(0))„   ToGo$ = MID$(DirList$, x, x2 - x)„   CHDIR ToGo$„„ELSE„„   PRINT "Directory not found!"„„END IF„„END„„SUB AddDirs (CurrentDir$, ListOfEm$)„„Temp$ = CurrentDir$„„'Do this for the 1 exception that we're scanning C:\, because we won't get„'any files when we ask for a list in C:\\*.*„IF RIGHT$(Temp$, 1) = "\" THEN Temp$ = LEFT$(Temp$, LEN(Temp$) - 1)„„x$ = Temp$ + "\*.*"„d$ = Temp$ + "\"„„File$ = DIR$(x$)„„DO WHILE LEN(File$)„  ListOfEm$ = ListOfEm$ + d$ + File$„  File$ = DIR$("")„LOOP„„END SUB„„FUNCTION CurDir$„„'reads the current directory„„DIM Reg AS RegTypeX„DIM CurrentDrive AS INTEGER„DIM CurrentDir AS STRING * 64„„	'Get current disk drive„	Reg.ax = &H19 * 256„	INTERRUPTX &H21, Reg, Reg„	CurrentDrive = Reg.ax MOD 256„„	'Get current directory„„	Reg.ax = &H47 * 256„	Reg.dx = CurrentDrive + 1  'Note adding one to drive for this, or„						    'could use 0 for default drive„	Reg.ds = VARSEG(CurrentDir)„	Reg.si = VARPTR(CurrentDir)„	INTERRUPTX &H21, Reg, Reg„„	x = INSTR(CurrentDir, CHR$(0))„	IF x = 1 THEN CurDir$ = "\" ELSE CurDir$ = LEFT$(CurrentDir, x - 1)„„END FUNCTION„„' This function was origionally written by Dave Cleary.  I made a few„'modifications to it so that it would only find directories.  I put a„'* next to the lines that I changed.„FUNCTION DIR$ (FileSpec$) STATIC„„	DIM DTA AS STRING * 44, Regs AS RegTypeX„	Null$ = CHR$(0)„„ReTry:    '*„„	'-----  Set up our own DTA so we don't destroy COMMAND$„	   Regs.ax = SetDTA                    'Set DTA function„	   Regs.dx = VARPTR(DTA)               'DS:DX points to our DTA„	   Regs.ds = -1                        'Use current value for DS„	   INTERRUPTX DOS, Regs, Regs          'Do the interrupt„„	'-----  Check to see if this is First or Next„	   IF LEN(FileSpec$) THEN              'FileSpec$ isn't null, so„								    'FindFirst„		 FileSpecZ$ = FileSpec$ + Null$   'Make FileSpec$ into an ASCIIZ„								    'string„		 Regs.ax = FindFirst              'Perform a FindFirst„		 Regs.cx = 16                     '* I changed this to look for dirs„		 Regs.dx = SADD(FileSpecZ$)       'DS:DX points to ASCIIZ file„		 Regs.ds = -1                     'Use current DS„	   ELSE                                'We have a null FileSpec$,„		 Regs.ax = FindNext               'so FindNext„	   END IF„„	   INTERRUPTX DOS, Regs, Regs          'Do the interrupt„„	'-----  Return file name or null„	   IF Regs.flags AND 1 THEN            'No files found„		 DIR$ = ""                        'Return null string„		 EXIT FUNCTION„	   ELSE„		 '* check if its . or .., if so, can't accept it.„		 IF ASC(MID$(DTA, 22, 1)) <> 16 THEN„		   'its not a subdirectory, so skip it„		   GOTO ReTry„		 END IF„		 IF MID$(DTA, 31, 1) = "." THEN   '*If its . or ..„		   FileSpec$ = ""„		   GOTO ReTry„		 END IF„	   END IF„	   Null = INSTR(31, DTA, Null$)     'Get the filename found„	   DIR$ = MID$(DTA, 31, Null - 30)  'It's an ASCIIZ string starting„								 'at offset 30 of the DTA„„END FUNCTION„„SUB ScanDrive„„PRINT "Scanning Directories..."„„Path$ = "C:\*.*"„DPath$ = "C:\"„DirList$ = "C:\" + CHR$(0)„„'Go through DirList$ and search each subdirectory in it.„„Place = 1„„DO„„  x = INSTR(Place, DirList$, CHR$(0))„  IF x THEN„	'theres yet another subdirectory in the list„	'find out what it is„	DPath$ = MID$(DirList$, Place, x - Place)„	Place = x + 1„	LOCATE , 1: PRINT DPath$; "       ";„	AddDirs DPath$, DirList$„  ELSE„	EXIT DO„  END IF„„LOOP„„OPEN "\JD.IDX" FOR BINARY AS #1„PUT #1, , DirList$„CLOSE #1„„PRINT„PRINT "Done."„„END„„END SUB„„Earl Montgomery                ELIMINATE DUPES                ELIMINATE,DUPES                Unknown Date (00:00)   QB, PDS                264  7943     ELIMDUPE.BAS'This program finds duplicates in the selected directories and„'gives you the oppurtunity to delete. It can also work on just„'one directory and allow you to delete files within that„'directory. I think it is pretty neat. Try it out.„„'---- DOCS FOR ELIMDUPE.BAS„'„'If you program alot as I do, at the end of the day you have probably„'created quite a few duplicate files. And after several days you„'really have a mess on your hands. For example I have a seperate„'QB source file directory (QBSOURCE). And I am constantly moving„'files back and forth between QBSOURCE and QB45. Well this is where„'ELIMDUPE comes in handy. It will delete these files in a hurry!„'I prefer to use utility programs written in a language I understand,„'provided I have the source code - which you do! I prefer this„'because if I locate a bug I can fix it. And if I decide to add a„'few new features I can do that too.„'„'Comments: The program is so easy to use this DOC file really isn't„'necessary. However there are a couple of things you need to know.„'„'#1. You can select the root directory from your hard drive by„'    pressing <ENTER> at any directory prompt.„'„'#2. When prompted to decide whether or not to delete a file„'    pressing <ENTER> is the same as "N" and takes you to the„'    next duplicate.„'„'#3. You can also use this program to delete files in only one„'    directory. To do this just enter the same directory name„'    for both selections (directory #1 and directory #2).„'„'If you find any bugs please let me know! Especially if you have„'fixed them! <smile>.„ „'Credits: Thanks to Tim Fitzgerald, Dick Dennison and Mike Herbert„'         for their help with the interrupts.„'         Special thanks to Tim Berneman as I hacked some of his„'         interrupt code from BDIR.BAS„ „„ „'$INCLUDE: 'qb.bi'„DEFINT A-Z„DIM f1.nam$(500) 'Make as large as you need„DIM f2.nam$(500)„DIM f1.name$(500)„DIM f2.name$(500)„drive$ = "C:\"„ON ERROR GOTO fatalerror„KEY(10) ON„ON KEY(10) GOSUB exitroutine„DIM inregs AS regtypex, outregs AS regtypex„REM Saving the current directory„tempdir$ = STRING$(64, " ")„inregs.es = -1„inregs.ax = &H4700„inregs.dx = 0„inregs.ds = VARSEG(tempdir$)„inregs.si = SADD(tempdir$)„CALL interruptx(&H21, inregs, outregs)„tempdir$ = LEFT$(tempdir$, INSTR(tempdir$, CHR$(0)) - 1)„restart:„CLS„DEF SEG = &HB800„COLOR 14„POKE 0, 201„FOR x = 2 TO 158 STEP 2: POKE x, 205: NEXT„POKE 158, 187„FOR x = 160 TO 3880 STEP 160: POKE x, 186: NEXT„POKE 3840, 200„FOR x = 3842 TO 4000 STEP 2: POKE x, 205: NEXT„FOR x = 3998 TO 160 STEP -160: POKE x, 186: NEXT„POKE 3998, 188„DEF SEG„firstinput:„LOCATE 2, 30: PRINT "Eliminate Dupes"„LOCATE 3, 28: PRINT "By Earl Montgomery"„LOCATE 4, 20: PRINT "Written entirely in Quick Basic 4.5"„LOCATE 6, 15: PRINT "Press <ENTER> at any directory prompt for C:\"„LOCATE 10, 4: PRINT STRING$(40, " ")„LOCATE 11, 4: PRINT STRING$(40, " ")„LOCATE 10, 4: INPUT "Name of first directory"; n1$„n1$ = UCASE$(n1$)„path$ = drive$ + n1$ + CHR$(0)„REM changing directories„inregs.es = -1„inregs.ax = &H3B00„inregs.ds = VARSEG(path$)„inregs.dx = SADD(path$)„CALL interruptx(&H21, inregs, outregs)„IF outregs.ax = 3 THEN GOSUB invaliddirectory1: GOTO firstinput„GOSUB begin„secondinput:„LOCATE 10, 4: PRINT STRING$(40, " ")„LOCATE 11, 4: PRINT STRING$(40, " ")„LOCATE 10, 4: INPUT "Name of second directory"; n2$„n2$ = UCASE$(n2$)„path$ = drive$ + n2$ + CHR$(0)„inregs.es = -1„inregs.ax = &H3B00„inregs.ds = VARSEG(path$)„inregs.dx = SADD(path$)„CALL interruptx(&H21, inregs, outregs)„IF outregs.ax = 3 THEN GOSUB invaliddirectory2: GOTO secondinput„GOSUB lookfordupes„begin:„     de1 = 0„     filespec$ = "*.*" + CHR$(0)„     inregs.ax = &H2F00„     CALL interruptx(&H21, inregs, outregs)„     data.seg = outregs.es„     data.off = outregs.bx„     inregs.ax = &H4E00„     inregs.dx = SADD(filespec$)„     inregs.ds = -1„     CALL interruptx(&H21, inregs, outregs)„     cy = outregs.flags AND 1„     IF cy = 0 THEN„     END IF„     WHILE cy = 0„     DEF SEG = data.seg„     f1.name$ = ""„     i = data.off + 30„     WHILE PEEK(i) <> 0„     f1.name$ = f1.name$ + CHR$(PEEK(i))„     i = i + 1„     WEND„     DEF SEG„     de1 = de1 + 1„     f1.nam$(de1) = f1.name$„     inregs.ax = &H4F00„     CALL interruptx(&H21, inregs, outregs)„     cy = outregs.flags AND 1„     WEND„     IF i = 0 THEN„     END IF„     RETURN„lookfordupes:„de2 = 0„filespec$ = "*.*" + CHR$(0)„     inregs.ax = &H2F00„     CALL interruptx(&H21, inregs, outregs)„     data.seg = outregs.es„     data.off = outregs.bx„     inregs.ax = &H4E00„     inregs.dx = SADD(filespec$)„     inregs.ds = -1„     CALL interruptx(&H21, inregs, outregs)„     cy = outregs.flags AND 1„     IF cy = 0 THEN„     END IF„     WHILE cy = 0„     DEF SEG = data.seg„     f2.name$ = ""„     i = data.off + 30„     WHILE PEEK(i) <> 0„     f2.name$ = f2.name$ + CHR$(PEEK(i))„     i = i + 1„„     WEND„     DEF SEG„     de2 = de2 + 1„     f2.nam$(de2) = f2.name$„     inregs.ax = &H4F00„     CALL interruptx(&H21, inregs, outregs)„     cy = outregs.flags AND 1„     WEND„     IF i = 0 THEN„     END IF„     IF de1 > de2 THEN endofloop = de1:  ELSE endofloop = de2„     FOR x = 1 TO endofloop„     FOR Y = 1 TO endofloop„     IF f1.nam$(x) = f2.nam$(Y) THEN GOSUB duplicatefound„     NEXT: NEXT„     GOTO exitorcontinue„delete:„tryagain:„LOCATE 10, 4: PRINT STRING$(40, " ")„LOCATE 11, 4: PRINT STRING$(40, " ")„LOCATE 12, 4: PRINT STRING$(40, " ")„LOCATE 10, 4: PRINT "(1) "; n1$; : PRINT "          (2) " + n2$„LOCATE 11, 4: PRINT "Duplicate File Name "; : PRINT f1.nam$(x)„LOCATE 12, 4: INPUT "From which directory (1 or 2)"; dn„IF dn = 1 THEN path$ = drive$ + n1$ + CHR$(0)„IF dn = 2 THEN path$ = drive$ + n2$ + CHR$(0)„IF dn <> 1 AND dn <> 2 THEN BEEP: GOTO tryagain„inregs.es = -1„inregs.ax = &H3B00„inregs.ds = VARSEG(path$)„inregs.dx = SADD(path$)„CALL interruptx(&H21, inregs, outregs)„KILL temp$„RETURN„fatalerror:„BEEP: CLS„PRINT "Error is code "; : PRINT ERR„PRINT "Fatal error returning to DOS"„SLEEP (2)„path$ = drive$ + tempdir$ + CHR$(0)„inregs.es = -1„inregs.ax = &H3B00„inregs.ds = VARSEG(path$)„inregs.dx = SADD(path$)„CALL interruptx(&H21, inregs, outregs)„CLS : SCREEN 0: SYSTEM„duplicatefound:„LOCATE 10, 4: PRINT STRING$(40, " ")„LOCATE 11, 4: PRINT STRING$(40, " ")„LOCATE 12, 4: PRINT STRING$(40, " ")„IF n1$ = "" THEN LOCATE 10, 4: PRINT "C:\" ELSE LOCATE 10, 4: PRINT n1$;„IF n2$ = "" THEN LOCATE 10, 20: PRINT "C:\" ELSE LOCATE 10, 20: PRINT n2$„LOCATE 11, 4: PRINT f1.nam$(x); : LOCATE 11, 20: PRINT f2.nam$(Y)„temp$ = f1.nam$(x)„LOCATE 12, 4: INPUT "Delete one of these files"; q$„q$ = UCASE$(q$): IF q$ = "Y" THEN GOTO delete:  ELSE RETURN„exitorcontinue:„CLS„PRINT "No duplicates found or all duplicates have been processed."„INPUT "Do you wish to check other directories"; q$„q$ = UCASE$(q$)„„IF q$ = "Y" THEN CLS : GOTO prepareforrestart„IF q$ = "N" THEN GOTO exitroutine„GOTO exitorcontinue„exitroutine:„path$ = drive$ + tempdir$ + CHR$(0)„inregs.es = -1„inregs.ax = &H3B00„inregs.ds = VARSEG(path$)„inregs.dx = SADD(path$)„CALL interruptx(&H21, inregs, outregs)„CLS : SCREEN 0: SYSTEM„prepareforrestart:„FOR x = 0 TO 500„f1.nam$(x) = ""„f2.nam$(x) = ""„f1.name$(x) = ""„f2.name$(x) = ""„NEXT„n1$ = ""„'m2$ = ""„n2$=""„'I just noticed that in the last part of ELIMDUPE.BAS (part 4 of 4)„'that there is a mistake in the sub PREPARETORESTART:„'The line that reads:„'m2$="" should read n2$="".„'However it runs fine as it is but thought I'd better pass it along.„'Earl„„de1 = 0: de2 = 0„path$ = ""„temp$ = ""„GOTO restart„invaliddirectory1:„LOCATE 11, 4„PRINT "Invalid Directory"„SLEEP (1)„RETURN„invaliddirectory2:„LOCATE 11, 4„PRINT "Invalid Directory"„SLEEP (1)„RETURN„Rich Geldreich                 REAL DIRECTORY                 REAL,DIRECTORY                 Year of 1991 (00:00)   QB, PDS                878  25887    REALDIR.BAS 'RealDir.Bas version 1.00„'By Rich Geldreich December, 1991„'You may use this program in any way as you wish as long as„'you don't make any money off it before I know about it!„'For any questions, comments, write or call at...„'410 Market St.„'Gloucester City, New Jersey 08030„'(609)-456-0721„„'$DYNAMIC„DEFINT A-Z„„DECLARE SUB RestorePath (A$)„DECLARE SUB ChangeDrive (Drive$)„DECLARE SUB Refresh (X, Y, Length)„DECLARE SUB Sort (A$(), Low, High)„DECLARE SUB GetDir (EntryName$(), Extension$(), EntryType(), DirNum, Path$, Status)„DECLARE SUB SelectFile (FileName$, Status)„DECLARE SUB MakeFrame (X1, Y1, X2, Y2)„„DECLARE FUNCTION LogicalDrives (Drive$)„DECLARE FUNCTION GetKey ()„DECLARE FUNCTION CurrentPath$ ()„DECLARE FUNCTION CurrentDrive$ ()„DECLARE FUNCTION NumDrives ()„DECLARE FUNCTION RandInt (Lower, Upper)„DECLARE FUNCTION RealPath$ ()„„„CONST True = -1, False = NOT True„CONST File = 0, Directory = 1„CONST Enter = 13, TabKey = 9„CONST UpArrow = -72, DownArrow = -80„CONST LeftArrow = -75, RightArrow = -77„CONST BackSpace = 8„CONST Home = -71, EndKey = -79, Esc = 27„„TYPE FileFindBuf„    DOS            AS STRING * 19„    CreateTime     AS STRING * 1„    Attributes     AS INTEGER„    AccessTime     AS INTEGER„    AccessDate     AS INTEGER„    FileSize       AS LONG„    FileName       AS STRING * 13„END TYPE„„TYPE Register„    Ax    AS INTEGER„    Bx    AS INTEGER„    Cx    AS INTEGER„    Dx    AS INTEGER„    Bp    AS INTEGER„    Si    AS INTEGER„    Di    AS INTEGER„    Flags AS INTEGER„    Ds    AS INTEGER„    Es    AS INTEGER„END TYPE„DIM SHARED ErrorStatus„„„'sample usage:„„„„SCREEN 0, , 1, 1„„CLS„'The next program line gets a filename from the user.„'Don't overlook that THE CURRENT DIRECTORY IS CHANGED(unless you„'use RealDir and RestoreDir)!!!„„'Status will be 2 if the user hits Escape.„'Status will be 1 if a file was selected.„„'OldPath$ = RealPath$„SelectFile FileName$, Status„'RestorePath OldPath$„„„CLS„PRINT "Status returned:"; Status„IF Status = 2 THEN„    PRINT "Aborted."„ELSE„    PRINT "File selected: "; FileName$„END IF„END„„„ErrorHandler:„    ErrorStatus = True„RESUME NEXT„„REM $STATIC„'Changes current drive.„SUB ChangeDrive (Drive$)„    DIM InReg AS Register„    InReg.Ax = &HE00„    InReg.Dx = ASC(Drive$) - 65„    CALL interrupt(&H21, InReg, InReg)„END SUB„„'Returns current drive.„FUNCTION CurrentDrive$„    DIM InReg AS Register„    InReg.Ax = &H1900„    CALL interrupt(&H21, InReg, InReg)„    CurrentDrive$ = CHR$(65 + InReg.Ax MOD 256)„END FUNCTION„„'Returns current path(not a full path- the current drive must be added).„'**********************************************************************„'WARNING: for some reason, if the drive isn't ready this sub will„'HANG UP!!! (the SelectFile sub makes sure the drive is ready)„FUNCTION CurrentPath$„        DIM InReg AS Register„        DIM PathSize AS STRING * 64„        InReg.Ax = &H4700„        InReg.Dx = ASC(CurrentDrive$) - 64„        InReg.Ds = VARSEG(PathSize)„        InReg.Si = VARPTR(PathSize)„        CALL InterruptX(&H21, InReg, InReg)„        CurrentPath$ = LEFT$(PathSize, INSTR(PathSize, CHR$(0)) - 1)„END FUNCTION„„'Generic Getdir subroutine. Status will be -1 if an error occurs.„'EntryName$() ,Extension$() and Entrytype will hold directory.„'EntryType() tells what the entry is(a FILE or DIRECTORY- see constants).„'Path$ must be full path + wildcard. ...like "c:\dos\*.*"„'If Path$ isn't found then Status will be -1.„SUB GetDir (EntryName$(), Extension$(), EntryType(), DirNum, Path$, Status)„„    DIM InReg AS Register, OutReg AS Register„    DIM Buffer AS FileFindBuf„     „    DirNum = 0„„„    InReg.Ax = &H1A00„    InReg.Ds = VARSEG(Buffer)„    InReg.Dx = VARPTR(Buffer)„    CALL interrupt(&H21, InReg, OutReg)„    InReg.Ax = &H4E00„    InReg.Cx = 16„    Npath$ = Path$ + CHR$(0)„    InReg.Dx = SADD(Npath$)„    CALL InterruptX(&H21, InReg, OutReg)„    FirstFM = (OutReg.Ax AND &HF)„    IF OutReg.Flags AND 1 THEN„        Status = True„        EXIT SUB„    ELSE„        Status = False„    END IF„  „    IF FirstFM = 0 THEN„        GOSUB MakeFile„        DO„            InReg.Ax = &H4F00„            InReg.Dx = SADD(Npath$)„            CALL interrupt(&H21, InReg, OutReg)„            NextFM = OutReg.Ax AND &HF„            IF NextFM = 0 THEN„                GOSUB MakeFile„            END IF„        LOOP WHILE NextFM = 0„    END IF„    EXIT SUB„„MakeFile:„    IF LEFT$(Buffer.FileName, 1) = "." THEN„        RETURN„    END IF„ „     „    Entry$ = RTRIM$(Buffer.FileName)„    IF Buffer.Attributes = 4096 THEN„        EntryName$ = RTRIM$(LEFT$(Entry$, 8))„        EntryType = Directory„    ELSE„        IF INSTR(Entry$, ".") = 0 THEN„            EntryName$ = RTRIM$(LEFT$(Entry$, 8))„            Extension$ = ""„        ELSE„            EntryName$ = LEFT$(Entry$, INSTR(Entry$, ".") - 1)„            Extension$ = RTRIM$(LEFT$(MID$(Entry$, INSTR(Entry$, ".") + 1), 3))„        END IF„        EntryType = File„    END IF„    „  „    EntryName$(DirNum) = EntryName$„    Extension$(DirNum) = Extension$„    EntryType(DirNum) = EntryType„„    DirNum = DirNum + 1„„    Buffer.Attributes = 0„    Buffer.AccessTime = 0„    Buffer.AccessDate = 0„    Buffer.FileSize = 0„    Buffer.FileName = STRING$(13, 32)„RETURN„„END SUB„„'This sub returns the ascii keycode- extended keycodes(ones that have„'a zero as the first character) return easy to handle negative„'values.„FUNCTION GetKey„    DO„        A$ = INKEY$„    LOOP UNTIL A$ <> ""„    IF LEN(A$) = 2 THEN„        GetKey = -ASC(RIGHT$(A$, 1))„    ELSE„        GetKey = ASC(A$)„    END IF„END FUNCTION„„FUNCTION LogicalDrives (Drive$)„    DIM InReg AS Register„    InReg.Ax = &H440E„    InReg.Bx = ASC(Drive$) - 64„    CALL interrupt(&H21, InReg, InReg)„    IF (InReg.Flags AND 1) = 1 THEN„        LogicalDrives = -1„    ELSE„        LogicalDrives = InReg.Ax AND 255„    END IF„END FUNCTION„„'Makes a frame in text mode. X1,Y1 start X2,Y2 end„SUB MakeFrame (X1, Y1, X2, Y2)„    UpLeft$ = "⁄": UpRight$ = "ø": LoLeft$ = "¿": LoRight$ = "Ÿ"„    H$ = "ƒ": V$ = "≥"„    LOCATE Y1, X1„    PRINT UpLeft$; STRING$(X2 - X1 - 1, H$); UpRight$;„    LOCATE Y2, X1„    PRINT LoLeft$; STRING$(X2 - X1 - 1, H$); LoRight$;„    FOR Y = Y1 + 1 TO Y2 - 1„        LOCATE Y, X1„        PRINT V$;„        LOCATE Y, X2„        PRINT V$;„    NEXT„END SUB„„'Returns the number of logical drives. For instance- if 4 is returned„'then the valid drive names are A: B: C: & D:„'Since I only got to check this sub out with my computer's„'drive configuration, this sub checks over it's findings„'to make sure it has the correct number of logical drives.„'(better safe than sorry!)„FUNCTION NumDrives„    DIM InReg AS Register„    InReg.Ax = &HE00„    InReg.Dx = ASC(CurrentDrive$) - 65„    CALL interrupt(&H21, InReg, InReg)„    Temp = (InReg.Ax MOD 256) - 1„    FOR A = 1 TO Temp„        IF LogicalDrives(CHR$(A + 64)) = -1 THEN„            NumDrives = A - 1„            EXIT FUNCTION„        END IF„    NEXT„    NumDrives = Temp„END FUNCTION„„'This subroutine is for the QuickSort algoritmn only.„FUNCTION RandInt (Lower, Upper)„    RandInt = INT(RND(1) * (Upper - Lower) + .5) + Lower„END FUNCTION„„'Returns the current path in a usable form.„'WARNING: if the drive isn't ready this sub will HANG UP!!!„FUNCTION RealPath$„    RealPath$ = CurrentDrive$ + ":\" + CurrentPath$„END FUNCTION„„'Highlights an area. Use a COLOR statement before calling.„SUB Refresh (X, Y, Length)„    FOR A = X TO X + Length - 1„        LOCATE Y, A„        PRINT CHR$(SCREEN(Y, A));„    NEXT„END SUB„„'Similar to the CHDIR command except this can also change the current„'drive.„SUB RestorePath (A$)„    ChangeDrive LEFT$(A$, 1)„    CHDIR A$„END SUB„„'Allows the user to select a file.„'Valid keys:„'Up, down, left, and right arrow keys move cursor.„'Tab key changes between Files and Directories windows.„'A-Z, a-z, 0-9 goes right to the next name beginning with the pressed letter.„'Home and End keys go to beginning or ending of list.„'Enter selects.„'Esc aborts.„SUB SelectFile (FileName$, Status)„  „    'dim all arrays„    REDIM EntryName$(400), Extension$(400), EntryType(400)„    REDIM SortBuffer$(400)„    REDIM Window$(34, 12), Direct$(100)„  „    „    SCREEN 0, , 1, 1„    CLS„    COLOR 14, 0„   „    'make screen„    MakeFrame 1, 1, 80, 24„    MakeFrame 5, 7, 58, 22„    MakeFrame 60, 7, 75, 22„    MakeFrame 17, 2, 32, 4„  „   „    COLOR 15„    LOCATE 1, 33„    PRINT " Choose File "„    LOCATE 3, 5„    PRINT "File Name:"„    LOCATE 6, 29„    PRINT "Files"„    LOCATE 6, 62„    PRINT "Directories"„   „    'If Position=1 then Cursor is at Files window, if it's 2 then„    'the cursor is at the Directories window„    Position = 1„   „    'set up path at root directory of current drive„    Newpath$ = CurrentDrive$ + ":\"„   „    'set up default wildcard„    WildCard$ = "*.*"„   „    DO„      „        'fast way of clearing arrays„        ERASE Window$, Direct$„        REDIM Window$(34, 12), Direct$(100)„      „        UseLast1 = False„        UseLast2 = False„       „        'get current drive„        Drive$ = CurrentDrive$„       „        'clear flag„        ErrorStatus = 0„                 „        'see if drive is ready„        ON ERROR GOTO ErrorHandler„        CHDIR Newpath$„        ON ERROR GOTO 0„       „        'if drives ready then get current path„        IF ErrorStatus = 0 THEN Path$ = CurrentPath$„       „        'Path$ will be "" if on root directory„        IF Path$ = "" THEN„            FullPath$ = Drive$ + ":\" + WildCard$„            Root = True„        ELSE„            FullPath$ = Drive$ + ":\" + Path$ + "\" + WildCard$„            Root = False„        END IF„        'FullPath$ now has ready to use path+wildcard„„        LOCATE 5, 5„        PRINT FullPath$; STRING$(79 - POS(0), 32)„       „        'alert user if drive not ready; otherwise„        'get the directory„        IF ErrorStatus <> 0 THEN„            SOUND 1000, 3„            Num = 0„            LOCATE 25, 34„            COLOR 15 + 16„            PRINT "Drive Error";„            COLOR 15„        ELSE„            GetDir EntryName$(), Extension$(), EntryType(), Num, FullPath$, Status„        END IF„       „        'set NoFiles to True so it can be proved false later„        NoFiles = True„       „        'if Num<>0 then there are directories or files„        IF Num <> 0 THEN„            TempNum = 0„           „            'put all files in sort buffer„            FOR A = 0 TO Num - 1„                IF EntryType(A) = File THEN„                    SortBuffer$(TempNum) = EntryName$(A)„                    IF Extension$(A) <> "" THEN„                        SortBuffer$(TempNum) = SortBuffer$(TempNum) + "." + Extension$(A)„                    END IF„                    TempNum = TempNum + 1„                END IF„            NEXT„            'if there are files then QuickSort them„            'and put them in a 2 dimensional array„            IF TempNum <> 0 THEN„              „                Sort SortBuffer$(), 0, TempNum - 1„                X = 0„                Y = 0„                FOR A = 0 TO TempNum - 1„                    Window$(X, Y) = SortBuffer$(A)„                    LastX = X„                    LastY = Y„                    Y = Y + 1„                    IF Y > 11 THEN„                        Y = 0: X = X + 1„                    END IF„                NEXT„                NoFiles = False„            END IF„        END IF„       „        'set up directory array„        DirectNum = 0„        IF NOT Root THEN„            Direct$(DirectNum) = ".."„            DirectNum = DirectNum + 1„        END IF„        FOR A = 1 TO NumDrives„            Direct$(DirectNum) = "[-" + CHR$(64 + A) + "-]"„            DirectNum = DirectNum + 1„        NEXT„        FOR A = 0 TO Num - 1„            IF EntryType(A) = Directory THEN„                Direct$(DirectNum) = EntryName$(A)„                DirectNum = DirectNum + 1„            END IF„        NEXT„        Sort Direct$(), 0, DirectNum - 1„„        'CurrentX and CurrentY hold cursors position in Files window„        CurrentX = 0„        CurrentY = 0„       „        'DirectNum holds maximum position if Direct$() array„        DirectNum = DirectNum - 1„       „        'put lists on screen„        GOSUB Update1„        GOSUB Update2„       „        'clear FileName window at put new name„        LOCATE 3, 19: PRINT STRING$(8 + 3 + 1, " ")„        LOCATE 3, 19: PRINT Window$(0, 0)„       „        DO„            'if there are no files then don't let cursor at Files window„            IF NoFiles THEN Position = 2„           „            'depending on Position, go to FileWindow or DirectWindow„            SELECT CASE Position„                CASE 1„                    GOSUB FileWindow„                CASE 2„                    GOSUB DirectWindow„            END SELECT„            'loop while the user just presses the TAB key„        LOOP WHILE Status = 3„       „        'loop until the user presses ENTER or ESC„    LOOP UNTIL Status <> 0„   „    'erase the arrays„    ERASE EntryName$, Extension$, EntryType, SortBuffer$„'return to calling program„EXIT SUB„„'updates the Files window with files„Update1:„    'switch to work screen so user gets a clean change„    SCREEN 0, , 2, 1„    COLOR 15, 0„    'copy old screen to work screen„    PCOPY 1, 2„   „    'start printing the file entries„    RealX = 7„    FOR X = CurrentX TO CurrentX + 2„        FOR Y = 0 TO 11„            LOCATE Y + 9, RealX„            PRINT STRING$(12, 32)„            LOCATE Y + 9, RealX„            PRINT Window$(X, Y)„        NEXT„        RealX = RealX + 17„    NEXT„    'print location bar„    LOCATE 22, 7: PRINT STRING$(50, "∞")„    IF LastX = 0 THEN„        X = 7„    ELSE„        X = 7 + (CurrentX / LastX) * 49„    END IF„    LOCATE 22, X: PRINT "€";„    'copy work screen to display screen„    PCOPY 2, 1„    SCREEN 0, , 1, 1„    COLOR 15, 0„RETURN„'updates the directory window„Update2:„    'print directories„    RealY = 9„    FOR Y = CurrentY TO CurrentY + 11„        LOCATE RealY, 62„        PRINT STRING$(8, 32);„        LOCATE RealY, 62„        PRINT Direct$(Y)„        RealY = RealY + 1„    NEXT„    'print location bar„    FOR Y = 8 TO 8 + 13„        LOCATE Y, 75„        PRINT "∞"„    NEXT„    LOCATE 8 + (CurrentY / DirectNum) * 13, 75„    PRINT "€"„RETURN„'this sub controls the cursor when it is in the Files window„FileWindow:„    IF UseLast1 THEN„        Xpos = LastXPos1„        YPos = LastYPos1„    ELSE„        Xpos = 0„        YPos = 0„    END IF„    DO„        'highlight the cursors position„        COLOR 0, 7„        Refresh 6 + Xpos * 17, YPos + 9, 18„        COLOR 15, 0„       „        'get the filename under the cursor„        FileName$ = Window$(CurrentX + Xpos, YPos)„       „        'print the current file at tope„        LOCATE 3, 19„        PRINT STRING$(13, 32)„        LOCATE 3, 19„        PRINT FileName$„„        'wait for a key„        A = GetKey„       „        'clear cursor„        Refresh 6 + Xpos * 17, YPos + 9, 18„       „        'process the key„        SELECT CASE A„            CASE Esc„                Status = 2„                RETURN„            CASE Home„                CurrentX = 0„                Xpos = 0: YPos = 0„                GOSUB Update1„            CASE EndKey„                CurrentX = LastX„                YPos = LastY„                Xpos = 0„                GOSUB Update1„            CASE TabKey„                'save the cursors position„                LastXPos1 = Xpos„                LastYPos1 = YPos„                UseLast1 = True„„                Status = 3„                Position = 2„                RETURN„            CASE Enter„                IF Path$ <> "" THEN„                    FileName$ = Drive$ + ":\" + Path$ + "\" + FileName$„                ELSE„                    FileName$ = Drive$ + ":\" + FileName$„                END IF„                Status = 1„                RETURN„            CASE DownArrow„                YPos = YPos + 1„                IF Xpos + CurrentX = LastX AND YPos > LastY THEN„                    YPos = LastY„                END IF„                IF YPos > 11 THEN„                    YPos = 0„                    Xpos = Xpos + 1„                    IF Xpos > 2 THEN„                        Xpos = 2„                        CurrentX = CurrentX + 1„                        IF CurrentX - 2 > LastX THEN„                            CurrentX = LastX - 2„                        END IF„                        GOSUB Update1„                    END IF„                END IF„            CASE UpArrow„                YPos = YPos - 1„                IF YPos < 0 THEN„                    IF Xpos + CurrentX = 0 THEN„                        YPos = 0„                    ELSE„                        YPos = 11„                        Xpos = Xpos - 1„                        IF Xpos < 0 THEN„                            Xpos = 0„                            CurrentX = CurrentX - 1„                            IF CurrentX < 0 THEN„                                CurrentX = 0„                                Xpos = 2„                            END IF„                            GOSUB Update1„                        END IF„                    END IF„                END IF„            CASE LeftArrow„                Xpos = Xpos - 1„                IF Xpos < 0 THEN„                    Xpos = 0„                    IF Xpos + CurrentX = 0 THEN„                        YPos = 0„                    ELSE„                        CurrentX = CurrentX - 1„                        GOSUB Update1„                    END IF„                END IF„            CASE RightArrow„                Xpos = Xpos + 1„                IF Xpos + CurrentX > LastX THEN„                    Xpos = LastX - CurrentX„                    YPos = LastY„                END IF„                IF Xpos + CurrentX = LastX AND YPos > LastY THEN„                    YPos = LastY„                END IF„                IF Xpos > 2 THEN„                    Xpos = 2„                    CurrentX = CurrentX + 1„                    IF Xpos + CurrentX = LastX AND YPos > LastY THEN„                        YPos = LastY„                    END IF„                    GOSUB Update1„                END IF„            CASE 65 TO 90, 97 TO 122, 48 TO 57„                A$ = UCASE$(CHR$(A))„                RealX = CurrentX + Xpos„                RealY = CurrentY + YPos„                StopX = RealX„                StopY = RealY„                ScanX = RealX„                ScanY = RealY + 1„                IF ScanY > 11 THEN„                    ScanY = 0„                    ScanX = ScanX + 1„                END IF„                DO UNTIL ScanX > LastX OR LEFT$(Window$(ScanX, ScanY), 1) = A$„                    ScanY = ScanY + 1„                    IF ScanY > 11 THEN„                        ScanY = 0„                        ScanX = ScanX + 1„                    END IF„                LOOP„                IF NOT ScanX > LastX THEN„                    Xpos = 0„                    YPos = ScanY„                    CurrentX = ScanX„                    GOSUB Update1„                ELSE„                    ScanX = 0„                    ScanY = 0„                    DO UNTIL (ScanX = StopX AND ScanY = StopY) OR LEFT$(Window$(ScanX, ScanY), 1) = A$„                        ScanY = ScanY + 1„                        IF ScanY > 11 THEN„                            ScanY = 0„                            ScanX = ScanX + 1„                        END IF„                    LOOP„                    IF NOT (ScanX = StopX AND ScanY = StopY) THEN„                        Xpos = 0„                        YPos = ScanY„                        CurrentX = ScanX„                        GOSUB Update1„                    END IF„                END IF„        END SELECT„    LOOP„'this sub controls the cursor when it is in the Directories window„DirectWindow:„    IF UseLast2 THEN„        YPos = LastYPos2„    ELSE„„        YPos = 0„    END IF„    DO„        'highlight the cursors position„        COLOR 0, 7„        Refresh 61, YPos + 9, 14„        'wait for a key„        A = GetKey„       „        'unhighlight the cursors position„        COLOR 15, 0„        Refresh 61, YPos + 9, 14„       „        'process key„        SELECT CASE A„            CASE Esc„                Status = 2„                RETURN„            CASE TabKey„                'see if it's ok to go to files window„                IF NOT NoFiles THEN„                    'save the cursors position„                    UseLast2 = True„                    LastYPos2 = YPos„                   „                    Position = 1„                    Status = 3„                    RETURN„                END IF„            CASE Enter„                NewDirect$ = Direct$(YPos + CurrentY)„                IF NewDirect$ = ".." THEN„                    Newpath$ = ".."„                    Status = 0„                    RETURN„                ELSEIF LEFT$(NewDirect$, 1) = "[" THEN„                    PCOPY 1, 2„                    NewDrive$ = MID$(NewDirect$, 3, 1)„                    ErrorStatus = 0„                   „                    'check drive to see if it is ready„                    ON ERROR GOTO ErrorHandler„                    CHDIR NewDrive$ + ":\"„                    ON ERROR GOTO 0„                   „                    PCOPY 2, 1„                    IF ErrorStatus <> 0 THEN„                        SOUND 1000, 3„                        LOCATE 25, 34„                        COLOR 15 + 16„                        PRINT "Drive Error";„                        COLOR 15„                    ELSE„                        LOCATE 25, 34„                        PRINT STRING$(11, 32);„                        Newpath$ = NewDrive$ + ":\"„                        ChangeDrive NewDrive$„                        Status = 0„                        RETURN„                    END IF„                ELSE„                    IF Path$ = "" THEN„                        Newpath$ = Drive$ + ":\" + NewDirect$„                    ELSE„                        Newpath$ = Drive$ + ":\" + Path$ + "\" + NewDirect$„                    END IF„                    Status = 0„                    RETURN„                END IF„            CASE DownArrow„                YPos = YPos + 1„                IF YPos + CurrentY > DirectNum THEN„                    YPos = YPos - 1„                END IF„                IF YPos > 11 THEN„                    YPos = 11„                    CurrentY = CurrentY + 1„                    IF CurrentY + 11 > DirectNum THEN„                        CurrentY = DirectNum - 11„                    END IF„                    GOSUB Update2„                END IF„            CASE UpArrow„                YPos = YPos - 1„                IF YPos < 0 THEN„                    YPos = 0„                    CurrentY = CurrentY - 1„                    IF CurrentY < 0 THEN„                        CurrentY = 0„                    END IF„                    GOSUB Update2„                END IF„            CASE Home„                YPos = 0„                CurrentY = 0„                GOSUB Update2„            CASE EndKey„                YPos = 0„                CurrentY = DirectNum„                GOSUB Update2„            CASE 65 TO 90, 97 TO 122, 48 TO 57„                A$ = UCASE$(CHR$(A))„                StopScan = YPos + CurrentY„                Scan = StopScan + 1„                DO UNTIL Scan > DirectNum OR LEFT$(Direct$(Scan), 1) = A$„                    Scan = Scan + 1„                LOOP„                IF NOT Scan > DirectNum THEN„                    YPos = 0„                    CurrentY = Scan„                    GOSUB Update2„                ELSE„                    Scan = 0„                    DO UNTIL Scan = StopScan OR LEFT$(Direct$(Scan), 1) = A$„                        Scan = Scan + 1„                    LOOP„                    IF NOT Scan = StopScan THEN„                        YPos = 0„                        CurrentY = Scan„                        GOSUB Update2„                    END IF„                END IF„        END SELECT„    LOOP„„END SUB„„'QuickSorts a string array. Low=first entry High=last entry„SUB Sort (A$(), Low, High)„„   IF Low < High THEN„      IF High - Low = 1 THEN„         IF A$(Low) > A$(High) THEN„            SWAP A$(Low), A$(High)„         END IF„      ELSE„„         RandIndex = RandInt(Low, High)„         SWAP A$(High), A$(RandIndex)„         Partition$ = A$(High)„         DO„„            I = Low: J = High„            DO WHILE (I < J) AND (A$(I) <= Partition$)„               I = I + 1„            LOOP„            DO WHILE (J > I) AND (A$(J) >= Partition$)„               J = J - 1„            LOOP„„            IF I < J THEN„               SWAP A$(I), A$(J)„            END IF„         LOOP WHILE I < J„„         SWAP A$(I), A$(High)„„         IF (I - Low) < (High - I) THEN„            Sort A$(), Low, I - 1„            Sort A$(), I + 1, High„         ELSE„            Sort A$(), I + 1, High„            Sort A$(), Low, I - 1„         END IF„      END IF„   END IF„END SUB„„Christy Gemmell                GET/SET FILES DATE/TIME        GET,SET,FILE,DATE,TIME         07-10-95 (00:00)       QB, PDS                205  7972     QBFDATE.BAS ' FILEDATE.BAS  get and set a files date and time stamps.„'„'   Author:     Christy Gemmell„'   Date:       10/7/1995„'   Language:   QuickBASIC„'„'   $INCLUDE: 'QB.BI'„'„	DECLARE FUNCTION GetDateFormat% ()„	DECLARE FUNCTION GetFileDate$ (FileName$)„	DECLARE FUNCTION Sint% (Num&)„	DECLARE FUNCTION UInt& (Num%)„	DECLARE SUB SetFileDate (FileName$, FileDate$, Fmt%, Done%)„„	DIM SHARED Regs AS RegTypeX„„	CLS : PRINT : FileName$ = "QB.EXE"„	OldDate$ = GetFileDate$(FileName$)„	IF OldDate$ <> "" THEN„	   PRINT FileName$; " is currently dated "; OldDate$„	   PRINT„	   NewDate$ = LEFT$(DATE$, 6) + MID$(DATE$, 9, 2) + "  " + TIME$„	   PRINT "Setting file to current date and time... ";„	   SetFileDate FileName$, NewDate$, 0, Done%„	   IF Done% THEN„		  PRINT "done"„		  NewDate$ = GetFileDate$(FileName$)„		  PRINT„		  PRINT FileName$; " is now dated "; NewDate$„		  PRINT„		  PRINT "Now reverting back to previous setting... ";„		  SetFileDate FileName$, OldDate$, -1, Done%„		  IF Done% THEN„			 PRINT "done"„			 DateNow$ = GetFileDate$(FileName$)„			 PRINT„			 PRINT FileName$; " is now dated "; DateNow$„		  ELSE„			 PRINT "failed!"„		  END IF„	   ELSE„		  PRINT "failed!"„	   END IF„	END IF„END„„'Thanks to Derek Sim who gave me algorithms for inserting and extracting„'the years, months, days, hours, minutes and seconds from the encoded„'bits of the various registers. It made me wish that Microsoft had given„'us a SHIFT statement like PowerBASIC.„„'   Returns a code indicating the national date format.„'„'   Return values:  0 = MM-DD-YY   (USA)„'                   1 = DD/MM/YY   (Europe)„'                   2 = YY-MM-DD   (Japan)„'„'   Depends on COUNTRY = setting in CONFIG.SYS (default = USA)„'„FUNCTION GetDateFormat%„	B$ = SPACE$(64)                     ' To hold country information„	Regs.ds = VARSEG(B$)                ' DS = segment of buffer„	Regs.dx = SADD(B$)                  ' DX = offset of buffer„	Regs.ax = &H3800                    ' DOS Service 56„	INTERRUPTX &H21, Regs, Regs         ' - get country information„	GetDateFormat% = ASC(B$)            ' Date format is first byte„END FUNCTION„„'   Returns date and time a file was last updated.„'„'   The date and time are returned as a string in one of these formats:„'„'       --123456789012345678--„'„'         MM-DD-YY  HH:MM:SS    (for USA)„'         DD/MM/YY  HH:MM:SS    (for Europe)„'         YY-MM-DD  HH:MM:SS    (for Japan)„'„'   (there are two blank spaces between the date and time„'„FUNCTION GetFileDate$ (FileName$)„	Dt$ = ""                            ' Assume failure„	F$ = FileName$ + CHR$(0)            ' Make filespec ASCIIZ„	Regs.ds = VARSEG(F$)                ' DS = segment of filespec„	Regs.dx = SADD(F$)                  ' DX = offset of filespec„	Regs.ax = &H3D00                    ' DOS Service 61„	INTERRUPTX &H21, Regs, Regs         ' - open file for reading„	Carry% = Regs.flags AND 1           ' Check carry flag„	IF Carry% = 0 THEN                  ' If no error occurred..„	   Handle% = Regs.ax                ' Get handle from AX„	   Regs.bx = Handle%                ' Transfer it to BX„	   Regs.ax = &H5700                 ' DOS Service 87„	   INTERRUPTX &H21, Regs, Regs      ' - get file date and time„	   Carry% = Regs.flags AND 1        ' Check carry flag„	   IF Carry% = 0 THEN               ' If no error occurred..„		  FlTime& = UInt&(Regs.cx)      ' Bit-encoded time from CX„		  FlDate& = UInt&(Regs.dx)      ' Bit-encoded date from DX„		  Yr% = (FlDate& \ 512) + 1980  ' Get year„		  FlDate& = FlDate& AND &H1FF   ' Isolate day and month„		  Mth% = FlDate& \ 32           ' Get month„		  Day% = FlDate& AND &H1F       ' Get day„		  Hrs% = FlTime& \ 2048         ' Get hours„		  FlTime& = FlTime& AND &H7FF   ' Isolate minutes and seconds„		  Mins% = FlTime& \ 32          ' Get hours„		  Sex% = (FlTime& AND &H1F) * 2 ' Get seconds„		  Y$ = RIGHT$("0" + LTRIM$(RTRIM$(STR$(Yr%))), 2)„		  M$ = RIGHT$("0" + LTRIM$(RTRIM$(STR$(Mth%))), 2)„		  D$ = RIGHT$("0" + LTRIM$(RTRIM$(STR$(Day%))), 2)„		  Fmt% = GetDateFormat%         ' Get national date format„		  SELECT CASE Fmt%„			  CASE 0                    ' USA„				   Dt$ = M$ + "-" + D$ + "-" + Y$„			  CASE 1                    ' Europe„				   Dt$ = D$ + "/" + M$ + "/" + Y$„			  CASE 2                    ' Japan„				   Dt$ = Y$ + "-" + M$ + "-" + D$„			  CASE ELSE„		  END SELECT„		  H$ = RIGHT$("0" + LTRIM$(RTRIM$(STR$(Hrs%))), 2)„		  M$ = RIGHT$("0" + LTRIM$(RTRIM$(STR$(Mins%))), 2)„		  S$ = RIGHT$("0" + LTRIM$(RTRIM$(STR$(Sex%))), 2)„		  Dt$ = Dt$ + "  " + H$ + ":" + M$ + ":" + S$„	   END IF„	   Regs.bx = Handle%                ' File handle to BX„	   Regs.ax = &H3E00                 ' DOS Service 62„	   INTERRUPTX &H21, Regs, Regs      ' - close the file„	END IF„	GetFileDate$ = Dt$                  ' Return date and time as string„END FUNCTION„„'   Sets the last-access date and time of the specified file.„'„'   Note: FileDate$ must be in one of the following formats:„'„'       --123456789012345678--„'„'         MM-DD-YY  HH:MM:SS    (for USA)„'         DD/MM/YY  HH:MM:SS    (for Europe)„'         YY-MM-DD  HH:MM:SS    (for Japan)„'„'   (there are two blank spaces between the date and time„'„'   If Fmt% is TRUE (non-zero) then the procedure uses the date„'   format for the country corresponding to the COUNTRY= setting„'   in the computers CONFIG.SYS file (default = USA)„'„'   If Fmt% is FALSE (zero) then USA format is used.„'„SUB SetFileDate (FileName$, FileDate$, Fmt%, Done%)„	Done% = 0                           ' Assume failure„	F$ = FileName$ + CHR$(0)            ' Make filespec ASCIIZ„	Regs.ds = VARSEG(F$)                ' DS = segment of filespec„	Regs.dx = SADD(F$)                  ' DX = offset of filespec„	Regs.ax = &H3D00                    ' DOS Service 61„	INTERRUPTX &H21, Regs, Regs         ' - open file for reading„	Carry% = Regs.flags AND 1           ' Check carry flag„	IF Carry% = 0 THEN                  ' If no error occurred..„	   Handle% = Regs.ax                ' Get handle from AX„	   IF Fmt% THEN„		  Fmt% = GetDateFormat%         ' Get national date format„	   END IF„	   SELECT CASE Fmt%„		   CASE 0                       ' USA„				Day% = VAL(MID$(FileDate$, 4, 2))„				Mth% = VAL(LEFT$(FileDate$, 2))„				Yr% = VAL(MID$(FileDate$, 7, 2))„		   CASE 1                       ' Europe„				Mth% = VAL(MID$(FileDate$, 4, 2))„				Day% = VAL(LEFT$(FileDate$, 2))„				Yr% = VAL(MID$(FileDate$, 7, 2))„		   CASE 2                       ' Japan„				Mth% = VAL(MID$(FileDate$, 4, 2))„				Yr% = VAL(LEFT$(FileDate$, 2))„				Day% = VAL(MID$(FileDate$, 7, 2))„		   CASE ELSE„	   END SELECT„	   Hrs% = VAL(MID$(FileDate$, 11, 2))„	   Mins% = VAL(MID$(FileDate$, 14, 2))„	   Sex% = VAL(MID$(FileDate$, 17, 2))„	   IF Yr% < 80 THEN Yr% = Yr% + 100 ' Remember the 21st Century„	   FlDate& = ((Yr% - 80) * 512) + (Mth% * 32) + Day%„	   Regs.dx = Sint%(FlDate&)         ' Load result into DX„	   FlTime& = (Hrs% * 2048&) + (Mins% * 32) + (Sex% \ 2)„	   Regs.cx = Sint%(FlTime&)         ' Load result into CX„	   Regs.bx = Handle%                ' File handle to BX„	   Regs.ax = &H5701                 ' DOS Service 87„	   INTERRUPTX &H21, Regs, Regs      ' - set file date and time„	   Carry% = Regs.flags AND 1        ' Check carry flag„	   IF Carry% = 0 THEN               ' If no error occurred..„		  Done% = -1                    '   report success„	   END IF„	   Regs.bx = Handle%                ' File handle to BX„	   Regs.ax = &H3E00                 ' DOS Service 62„	   INTERRUPTX &H21, Regs, Regs      ' - close the file„	END IF„END SUB„„FUNCTION Sint% (Num&)„	Sint% = -((Num& > 32767) * (Num& - 65536)) - ((Num& < 32767) * Num&)„END FUNCTION„„FUNCTION UInt& (Num%)„	UInt& = -((Num% < 0) * (65536 + Num%) + ((Num% >= 0) * Num%))„END FUNCTION„„Dave Cleary                    PDS DIR$ FUNCTION FOR QB       FidoNet QUIK_BAS Echo          Unknown Date           QB                     82   2816     DIR.BAS     'DIR.BAS by Dave Cleary„'„'One of the most useful additions to BASIC 7 PDS is the DIR$ function.„'This function allows you to read a directory of filenames. It also„'allows you to check the existence of a file by doing the following:„'„'  IF LEN(DIR$("COMMAND.COM")) THEN„'     PRINT "File Found"„'  ELSE„'     PRINT "File not found"„'  END IF„'„'Now QuickBASIC 4.X users can have this useful function for their„'programs.„'„'Calling DIR$ with a FileSpec$ returns the the name of the FIRST„'matching file name. Subsequent calls with a null FileSpec$ return the„'NEXT matching file name. If a null string is returned, then no more„'matching files were found. FileSpec$ can contain both a drive and a„'path plus DOS wildcards. Special care should be taken when using„'this on floppy drives because there is no check to see if the drive„'is ready.„„DEFINT A-Z„„DECLARE FUNCTION DIR$ (FileSpec$)„„'$INCLUDE: 'QB.BI'„„'-----  Some constants that DIR$ uses„CONST DOS = &H21„CONST SetDTA = &H1A00, FindFirst = &H4E00, FindNext = &H4F00„„'--------------------------------------------------------------------„'This shows how to call DIR$ to find all matching files„„CLS„FileSpec$ = "C:\QB\*.*"„Found$ = DIR$(FileSpec$)„DO WHILE LEN(Found$)„   PRINT Found$„   Found$ = DIR$("")„LOOP„„'--------------------------------------------------------------------„„FUNCTION DIR$ (FileSpec$) STATIC„„   DIM DTA AS STRING * 44, Regs AS RegTypeX„   Null$ = CHR$(0)„„'-----  Set up our own DTA so we don't destroy COMMAND$„   Regs.AX = SetDTA                    'Set DTA function„   Regs.DX = VARPTR(DTA)               'DS:DX points to our DTA„   Regs.DS = -1                        'Use current value for DS„   InterruptX DOS, Regs, Regs          'Do the interrupt„„'-----  Check to see if this is First or Next„   IF LEN(FileSpec$) THEN              'FileSpec$ isn't null, so„							    'FindFirst„	 FileSpecZ$ = FileSpec$ + Null$   'Make FileSpec$ into an ASCIIZ„							    'string„	 Regs.AX = FindFirst              'Perform a FindFirst„	 Regs.CX = 0                      'Only look for normal files„	 Regs.DX = SADD(FileSpecZ$)       'DS:DX points to ASCIIZ file„	 Regs.DS = -1                     'Use current DS„   ELSE                                'We have a null FileSpec$,„	 Regs.AX = FindNext               'so FindNext„   END IF„„   InterruptX DOS, Regs, Regs          'Do the interrupt„„'-----  Return file name or null„   IF Regs.Flags AND 1 THEN            'No files found„	 DIR$ = ""                        'Return null string„   ELSE„	 Null = INSTR(31, DTA, Null$)     'Get the filename found„	 DIR$ = MID$(DTA, 31, Null - 30)  'It's an ASCIIZ string starting„   END IF                              'at offset 30 of the DTA„„END FUNCTION„„Logan Ashby/Andy Thomas        CHECK IF FILE EXISTS           FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                195  6119     EXISTS.BAS  ' >    5) Procedures must be bulletproof.„' >       FUNCTION Exist - Returns true if file is present.„'„' Sounds like some interesting challenges, but it struck me as„' odd, you want to see "bulletproof" routines, which I take to„' mean as routines that do a lot of error-checking, yet your„' Exist function could be shot full of holes, to continue the„' metaphor, fairly easily. Here's something I whipped up from my„' own Exist function, I bulletproofed and commented it as heavily„' as I could. „„ DECLARE FUNCTION Exist% (seed$, SearchAttrb%)„ DECLARE FUNCTION floppyDriveReady% (drive$)„„ TYPE regtype             ' Also found in QB.BI„   ax AS INTEGER„   bx AS INTEGER„   cx AS INTEGER„   dx AS INTEGER„   bp AS INTEGER„   si AS INTEGER„   di AS INTEGER„  flags AS INTEGER„   ds AS INTEGER„   es AS INTEGER„ END TYPE„„ TYPE DTAdata                     'used by DOS services„   Reserved  AS STRING * 21       'reserved for use by DOS„   Attribute AS STRING * 1        'the file's attribute„   FileTime  AS STRING * 2        'the file's time„   Filedate  AS STRING * 2        'the file's date„   FileSize  AS LONG              'the file's size„   filename  AS STRING * 13       'the file's name„ END TYPE„„ END„„ DEFINT A-Z„ FUNCTION Exist% (Name$, SearchAttrb%)„„ ' Format:„ ' EXIST Name$, SearchAttrb%„ ' Name$ can be any valid DOS filename, directory name, or volume label.„ '     wildcards (* and ?) are accepted.„ ' Attrb% can be the following:„ '     0 == Test for any file„ '    39 == Test for any file„ '    16 == Test for Directory names ONLY„ '     8 == Test for Volume labels ONLY„ '     4 == Test for System files ONLY„ '     2 == Test for Hidden files ONLY„ '     1 == Test for Read-Only files ONLY„ '    63 == Test for anything file/label/directory„ '„ '  Combinations can be made (ie. search for Read-only„ '  Directories) by following this binary number bit chart:„ '     Bit 7  Shareable (Novell Netware, otherwise ignore)„ '     Bit 6  unused„ '     Bit 5  archive„ '     bit 4  Directory„ '     Bit 3  Volume Label„ '     Bit 2  system„ '     Bit 1  Hidden„ '     Bit 0  Read only„ '  for example a Read-only Directory would be bits 0 and 4,„ '  in binary numbers that's: 10001 or 17 decimal.„„ ' If the tested for item exists Exist% will be set to -1, true„ '    and SearchAttrb% can be ignored„„ ' If the tested for item does not exist, or there is an error,„ ' Exist% will be set to 0, false, and SearchAttrb% will be set„ ' to one of the following:„ '    -1 == Floppy drive not ready or invalid drive letter.„ '     0 == item does not exist.„„ DIM inreg AS regtype, outreg AS regtype„ DIM DTA AS DTAdata„„ seed$ = LTRIM$(RTRIM$(UCASE$(Name$)))„„ IF SearchAttrb% AND 8 THEN  ' Volume label check„   ' Volume Label searches need to have a "." for the„   ' ninth character if the label is >8 characters.„   ' The following assures a correct search„„   IF NOT (INSTR(seed$, ".")) THEN„„     ' step backwards through the string„„     FOR I = LEN(seed$) TO 1 STEP -1„„       ' look for end of string, or drive/directory marker„„       IF MID$(seed$, I, 1) = ":" OR MID$(seed$, I, 1) = "\" OR I = 1 THEN„„         ' I points to start of name, without drive/directory„         ' marker, see if "." is required„„         IF LEN(MID$(seed$, I + 1, LEN(seed$) - I)) > 8 THEN„„           ' if no drive/directory, then we're checking the„           ' default drive, in this case I must equal 0 to„           ' place the "." correctly.„„           IF I = 1 THEN I = 0„„           ' place the "."„„           seed$ = LEFT$(seed$, I) + MID$(seed$, I + 1, 8) + "." + MID$(seed$, I + 9, LEN(seed$) - I)„         END IF„         I = 1  ' exit the next loop„       END IF„     NEXT I„   END IF„ END IF„„ IF SearchAttrb% = 0 THEN SearchAttrb% = 39  ' default search„„ ' if there's a drive in the search string„ IF INSTR(seed$, ":") THEN„   drive$ = LEFT$(seed$, 1)   ' gets the drive„ ELSE„   drive$ = "@"               ' for default drive„ END IF„„ ' if it's a floppy drive we need to make sure a disk„ ' is in the drive.„ IF NOT floppyDriveReady(drive$) THEN„   SearchAttrb% = -1   ' Floppy not ready.„   Exist% = 0„   EXIT FUNCTION„ END IF„„ inreg.dx = VARPTR(DTA)      'set a new DOS DTA„ inreg.ds = VARSEG(DTA)„ inreg.ax = &H1A00„ CALL interruptx(&H21, inreg, outreg)„„ seed$ = seed$ + CHR$(0)     'DOS needs ASCIIZ string„ inreg.ax = &H4E00           'find file name service„ inreg.cx = SearchAttrb%„ inreg.dx = SADD(seed$)      'show where the spec is„ inreg.ds = VARSEG(seed$)    'use this with QB - SSEG for PDS(?)„ CALL interruptx(&H21, inreg, outreg)„„ IF (outreg.flags AND 1) THEN„   SearchAttrb% = 0          ' Item does not exist„   Exist% = 0„ ELSE„   Exist% = -1               ' item exists„ END IF„„ END FUNCTION„„ DEFINT A-Z„ FUNCTION floppyDriveReady% (drive$)„ DIM inreg AS regtype, outreg AS regtype„„ ' This function may also be used independently from„ ' the Exist% function. It returns -1, true if the„ ' drive is ready, or 0, false, if the drive is not„ ' ready, or the drive letter is an invalid drive.„„ drive% = (ASC(drive$) OR 32) - 97„„ 'reset floppy drive„ inreg.ax = 0„ inreg.dx = drive%„ CALL interruptx(&H13, inreg, outreg)„„ inreg.ax = &H401     'verify disk sector„ inreg.cx = &H101„ inreg.dx = drive%„ CALL interruptx(&H13, inreg, inreg)„ 'call the interrupt twice since if a disk has just been„ 'inserted, the first time gives a wrong answer„ inreg.ax = &H401„ inreg.cx = &H101„ inreg.dx = drive%„ CALL interruptx(&H13, inreg, outreg)„„ 'if it was a hard disk we just checked forget the whole thing„ IF outreg.ax AND 256 THEN„   inreg.ax = &H1C00      ' check drive type„   inreg.dx = drive% + 1  ' diff. drive number system must add 1„   CALL interruptx(&H21, inreg, outreg)„   ' check if drive was a valid drive letter.„   IF (outreg.ax AND &HFF) = &HFF THEN HardCheck = 0 ELSE HardCheck = -1„ END IF„„ floppyDriveReady% = ((outreg.flags AND 1) = 0) OR HardCheck„„ END FUNCTION„J. Derek Lyons                 PARSE COMMAND LINE             QBFAQ                          11/91                  QB, PDS                222  8591     CLINE.BAS   '  Program CLINE.BAS„'  Version 1.00„'  Parses the command tail into an array holding all„'  command line arguments.„'  Written by: J. Derek Lyons.„'  November 1991„'  Released into the public domain to the extent of my ability to do so.„„DECLARE SUB ParCline (Arg$(), MaxArg%, Res%)„„DEFINT A-Z„OPTION BASE 0„„DIM Arg$(5)             'Array to hold the arguments„MaxArg% = 5             'Maximum number of arguments„'„'  To demonstrate CLINE, simply compile this program inside Quick Basic„'  or from the command line.„'„CLS„CALL ParCline(Arg$(), MaxArg%, Res%)„FOR x = 1 TO 5: PRINT Arg$(x): NEXT x„IF Res% = -1 THEN PRINT "Too Many Arguments"„IF Res% = 0 THEN PRINT "Sucessful Processing"„IF Res% = 1 THEN PRINT "No Arguments Found"„END„„SUB ParCline (Arg$(), MaxArg%, Res%)„'  Inputs„'     MaxArg%   Maximum number of arguments„'     Arg$()    Empty array to hold the arguments„'               To work properly should be DIMed as Arg$(MaxArg%)„'  Outputs„'     Res%      Result of subroutine„'               -1 = Too many arguments„'                0 = Sucessful processing„'                1 = No arguments found„'     Arg$()    Array holding the arguments„'„                        'numarg and argpos must be initialized„                        'because QB initializes them as 0„NumArg = 1              'Because there is no leading space for the„                        'first argument we must add 1 to the total„                        'number of space to find the total number„                        'of arguments„ArgPos = 1              'The first position in the array„„Cline$ = LTRIM$(RTRIM$(COMMAND$))„                        'Get the command line and trim all the spaces„Clen = LEN(Cline$)      'Get the length of the command line„„IF Clen = 0 THEN        'There are no arguments so there is no reason„                        'to continue processing the command line„   Res% = 1„   EXIT SUB„END IF„„FOR Scount = 1 TO Clen  'Get the number of arguments„   IF MID$(Cline$, Scount, 1) = " " THEN NumArg = NumArg + 1„                        'Each time a space is found in the command line„                        'the number of arguments is incremented„NEXT Scount„„IF NumArg > MaxArg% THEN„                        'So we don't crash the program by trying to„                        'write past the end of the array„   Res% = -1„   EXIT SUB„END IF„„FOR wcount = 1 TO Clen„   IF MID$(Cline$, wcount, 1) <> " " THEN„      Arg$(ArgPos) = Arg$(ArgPos) + MID$(Cline$, wcount, 1)„                        'If a character is found, then add it to the„                        'current string„   ELSEIF MID$(Cline$, wcount, 1) = " " THEN„      ArgPos = ArgPos + 1„                        'If a space is found, start processing the„                        'next string„   END IF„NEXT wcount„„END SUB„'     CLINE.BAS„'     Version 1.00„'     Mountain Bay Software„'     James Derek Lyons„'„'     A subroutine to parse the command line for„'     QUICK BASIC programs.„„'CLINE.BAS is hereby released into the public domain to the extent„'of my legal rights to do so.„'The author makes no warranty as to the fitness of this code for any„'given application.  The responsibility for determining fitness of„'use and for any damages caused lies with the user.„„'CLINE.BAS has been tested using MSDOS V3.3 and Quick Basic V4.5.„'QUICK BASIC and MSDOS are registered trademarks of the Microsoft„'Corporation.„„'INDEX„„'1.      Overview„'2.      Program Logic.„'2A.     The Parsing Algorithm„'3A.     Error Handling.„„'1. OVERVIEW„„'     One of the most useful functions of MSDOS is the ability to„'use a 'command tail'.  That is to say, a set of variables which„'can be read by a program at run-time and used to modify it's„'operation.„'     In QUICK BASIC the COMMAND$ function can be used to read the„'command tail into your program.  However, this function returns the„'entire command tail as a single string.  Unless you are using only„'one run-time option, this is fairly useless.„'     CLINE offers the QUICK BASIC programmer a method of importing„'this command tail and parsing it into useful string variables.„„'2. PROGRAM LOGIC„„'     The algorithm used by CLINE is fairly simple.  The requirements„'for using this subroutine are deliberately held to a minimum.„'     Three variables are required to use the subroutine.  Two must„'be declared in advance.„„'     These variables are:„'     MaxArg%, which is the maximum number of arguments expected.„'     Arg$(),  which is a string array to hold the returned, parsed,„'              arguments.„'     Res%,    which is a variable to hold the result flag for the„'              subroutine.„„'     The following assumptions apply these variables;„„'     MaxArg% is the total number of arguments that the user can„'legally use when loading the program.  As will be shown later each„'argument is assumed to be separated by a space.  Thus "/FILE DUMMY„'would be counted as two arguments.  "/FILE:DUMMY and "-AJ2" would„'both be considered to be one argument.„„'     ARG$() is a string array to hold the arguments when they are„'parsed.  To prevent programs from bombing, ARG$() is best„'dimensioned by using DIM ARG$(MaxArg%).„„'     Res% is an integer flag that returns the result of the parsing„'process.  These results are defined as follows;„„'     -1   indicates that too many arguments were found.  Processing„'           is halted and control returned to the calling program.„'      0   indicates that processing was successful and the parsed„'          arguments will be found in ARG$().„'      1   Indicates that no command line was found.  Processing is„'          halted and control is returned to the calling program.„„'     No error handling is performed by CLINE other than the setting„'of Res% to the appropriate value.„„'2A. The Parsing Algorithm„„'     The command tail retrieved by COMMAND$ is processed as„'follows;„'     First all leading and trailing spaces are removed using the„'LTRIM$() and RTRIM$() functions.  Since the algorithm determines„'the number of arguments by counting the number of spaces, any„'extraneous ones at the beggining and end must be removed.„'     Because there is no leading space for the first argument, the„'NUMARG and ARGPOS() variables are initialized to 1.„'     The length of the command tail is then determined.  If no tail„'is found, processing is returned to the calling program.  A flag„'is set to inform the calling program that no command line options„'were found.„'     Each position in the string is then examined using the„'MIDSTRING$() function.  Each time a space is encountered, the„'argument count is increased by one.„'     The total number of arguments found by this statement is then„'compared to the maximum allowable number.  If the number found„'exceeds the number allowed, processing is halted and control„'returned to the calling program.  The programmer must provide code„'to handle this error and inform the user of the failure.„'     Each position in the string is then examined.  If a non-space„'character is encountered, the character is added to the current„'string.  If a space is encountered, the string number is„'incremented by one and processing continues with the next„'character.„„'     Hence the string /FILE DUMMY /A -AQD2 /OUTFILE:TEST would„'parse as follows;„„'     String #1     /FILE„'     String #2     DUMMY„'     String #3     /A„'     String #4     -AQD2„'     String #5     /OUTFILE:TEST„„'     Note that because of the way COMMAND$ functions, all„'alphabetic characters will be in upper case.„„'     Control is then returned to the calling program.„„'3A. ERROR HANDLING„„'     Other than errors relating to the number of arguments, and the„'lack of a command tail, no native error handling is provided.„„'     If too many arguments are encountered, the programmer must„'provide routines to inform the user of the syntax error and recover„'from the error condition.„„'     If no arguments are provided then a flag is set to inform the„'calling program.  The programmer must provide code for his program„'to respond approprietly.„„'     It is suggested that if too many, or no, command line„'arguments are found, that any defaults be loaded and the user„'informed.„„'     If this code is used in a command line utility, (a program„'that is run only from the command line), that the program inform„'the user and exit gracefully.„Brian McLaughlin               EXPAND FILE HANDLES            FidoNet POWER_BAS Echo         10-21-95 (18:33)       PB                     78   3390     FHANDLES.BASOver the years I must have seen a couple dozen messages posted that„went like this:„„"...I changed my CONFIG.SYS to read FILES=100, but BASIC will only„let me open 15 files. What's wrong?..."„„Here is some PowerBASIC 3.x code to let your program open more than„15 files at once, and all the information you need to understand and„use that code.„„First off, it isn't BASIC that is limiting your program to 15 open„files at once.  It's DOS.  Even though DOS lets you put a FILES=255„statement in your CONFIG.SYS, DOS still rations out its file handles„like a miser giving away dollar bills.„„When you boot up DOS, one of the first things it does is open 5 file„handles for its own use, and assign them to a set of five standard„devices, like the screen and the keyboard.  Then, when your program„starts, DOS lets it use those 5, plus 15 more handles for its own„files, for a total of 20.„„So what good is the FILES=255, if your program only gets 20?„„It goes like this.  Your program can get more than 20, as long as it„asks for them, nicely.  There's a DOS service, &H67, that sets the„maximum number of file handles your program can use.  Unless you„call &H67, you get no extra handles. Understand?„„BUT, you have to send it the number of open files you want, plus 5.„Yes, that's right.  Say, you want to be able to open 30 files at„once, not 15.  Then you must send a value of 35.  The extra five are„the five DOS devices! DOS counts them against your limit.„„The other catch is that, if you send it a number larger than the„FILES=XXX setting in your CONFIG.SYS, the XXX will act as a ceiling.„You shouldn't be able to get more than XXX file handles, minus the„five handles for DOS.„„Here's the code:„„'------------------------- START CODE ----------------------------„„DECLARE SUB ExpandHandles (BYVAL TotalHandleCount%, ErrValue%)„„'==============================================================„ SUB ExpandHandles (BYVAL TotalHandleCount%, ErrValue%)  PUBLIC„'==============================================================„' Using this SUB, you can change the number of file handles„' your program can open, up to the highest number allowed under the„'„'    FILES=XXX„'„' statement in the CONFIG.SYS file, provided the program is running„' under DOS v3.3 or higher.„'„' The number you pass to this SUB should be the total number of files„' you want to be able to open, plus 5 (to allow for DOS stdxxx handles).„'„' If you pass a number higher than the XXX in FILES=XXX, there will„' NOT be an error reported in ErrValue%...I don't know why DOS doesn't„' flag that as an error. It just doesn't!„„  ErrValue% = 0                       ' assume no error„„  IF TotalHandleCount% > 20 THEN      ' hey! we get 20 automatically!„    MemToFree% = (TotalHandleCount% - 20) * 2„    MEMPACK                           'pack memory first„    dummy& = SETMEM(-MemToFree%)      'free the memory next„    ASM    Mov  AH, &H67              ; DOS function 67h in AH„    ASM    Mov  BX, TotalHandleCount% ; puts new handle total in BX„    ASM    Int  &H21                  ; call DOS interrupt„    ASM    Jnc  NoError               ; if carry flag set, we failed„    ASM    Mov  ErrValue%, AX         ; otherwise, return the error„  END IF„NoError:„„END SUB„'---------------------------- END CODE -----------------------------„Unknown Author(s)              TRUNCATE FILE                  FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                67   2516     TRUNC.BAS   ' > Is there an easy way in QB to truncate a file to a certain length„' > without copying it? „ „'Sure .. Not directly via QB, but through an interrupt call. As long as„'the file is opened for RANDOM, BINARY or OUTPUT, this should work fine.„'I wrote it for QBX, but it'll work fine for other version by changing„'the $INCLUDE to QB.BI for VBDOS.BI.„ „    DECLARE FUNCTION TruncateFile% (Handle%, NewLength&)„    DEFINT A-Z„    REM $INCLUDE: 'qbx.bi'„    OPEN "TEST.DAT" FOR BINARY AS #1        'Create a file to test„    A$ = " "„    PUT #1, 10240, A$                       'Make it 10K long„    PRINT "File length:"; LOF(1)            'Make sure„    Handle% = FILEATTR(1, 2)                'Get DOS file handle„    NewLength& = 5000                       'New length for this file„    Status% = TruncateFile%(Handle%, NewLength&)    'Do it„    IF Status% THEN„        PRINT "DOS Error";Status%;" occurred."„    ELSE„        PRINT "New file length:"; LOF(1)„    END IF„    CLOSE„ „FUNCTION TruncateFile% (Handle%, NewLength&)„ „    DIM Reg AS RegTypeX„ „    'First, position the file read/write pointer to the place where the„    'truncation should take place. We can't trust BASIC's SEEK statement„    'because the movement is sometimes held until the next read/write.„ „    Reg.AX = &H4200             'DOS "Set file pointer" function„    Reg.BX = Handle%„ „    'We go through these steps to prevent "overflow" errors when„    'NewLength& > 32767. The high word of the file position goes in CX„    'and the low word goes in DX. Since BASIC treats integers and longs„    '"signed" variables, we need to take to extra steps to prevent„    'an overflow error as we break the long integer down.„ „    DEF SEG„    Addr% = VARPTR(NewLength&)„    Reg.CX = CVI(CHR$(PEEK(Addr% + 2)) + CHR$(PEEK(Addr% + 3)))„    Reg.DX = CVI(CHR$(PEEK(Addr%)) + CHR$(PEEK(Addr% + 1)))„    CALL InterruptX(&H21, Reg, Reg)„    IF Reg.Flags AND 1 THEN„        Status% = Reg.AX„        GOTO TruncateExit„    END IF„ „    'Now, write 0 bytes.„    Reg.AX = &H4000                 'Dos "Write file or device"„    Reg.BX = Handle%„    Reg.CX = 0                      'Write 0 bytes„    Reg.DX = 0                      'These are not needed, but make„    Reg.DS = 0                      ' sure they're zero, just in case„    CALL InterruptX(&H21, Reg, Reg)„    IF Reg.Flags AND 1 THEN„        Status% = Reg.AX„    END IF„ „TruncateExit:„    TruncateFile% = Status%„ „END FUNCTION„Dave Navarro, Jr.              PRUNE FILES AND DIRECTORY      comp.lang.basic.misc           Unknown Date           PB32                   73   1644     PRUNE.BAS   ' Prune all files in a directory tree and remove all directories.„' Released to the Public Domain by Dave Navarro, Jr.„' Requires PowerBASIC 3.2 or later.„„$STACK 4096           'uses recursion, so use a large stack„$INCLUDE "PB32.INC"„„DEFINT A-Z„„Direc$ = UCASE$(COMMAND$)„„ErCode = Prune(Direc$)„„SELECT CASE ErCode„  CASE 1 : PRINT Direc$; " not found!"„  CASE 2 : PRINT Direc$; " is not a directory!"„END SELECT„„END ErCode„„FUNCTION Prune(BYVAL directory AS STRING) PUBLIC AS INTEGER„„  IF NOT Exist(directory) THEN„    FUNCTION = 1                 'directory not found„    EXIT FUNCTION„  END IF„„  IF (ATTRIB(directory) AND 16) <> 16 THEN„    FUNCTION = 2                 'not a directory„    EXIT FUNCTION„  END IF„„  KillFiles directory„„  RMDIR directory„„END FUNCTION„„SUB KillFiles(directory AS STRING) PRIVATE„„  DIM f            AS LOCAL STRING„  DIM DtaSeg       AS LOCAL INTEGER„  DIM DtaOFs       AS LOCAL INTEGER„  DIM OldDtaBuffer AS LOCAL STRING„„  GetDTA DtaSeg, DtaOfs„„  DEF SEG = DtaSeg„    OldDtaBuffer = PEEK$(DtaOfs, 44)     'save current DTA information„  DEF SEG„„  directory = RTRIM$(directory, "\")„  PRINT directory + "\"„„  f = DIR$(Directory + "\*.*",16)„  WHILE LEN(f)„    PRINT directory + "\" + f„    IF ASCII(f) <> 46 THEN„      IF (DtaAttrib AND 16) = 16 THEN„        KillFiles directory + "\" + f„        RMDIR directory + "\" + f„      ELSE„        KILL directory + "\" + f„      END IF„    END IF„    f = DIR$„  WEND„„  DEF SEG = DtaSeg„    POKE$ DtaOfs, OldDtaBuffer           'restore saved DTA information„  DEF SEG„„END SUB„