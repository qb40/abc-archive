Thomas Matysik                 LIST BOX                       FidoNet QUIK_BAS Echo          01-11-97 (16:45)       QB, QBasic, PDS        191  6600     LISTBOX.BAS '* LISTBOX.BAS * '* By Thomas Matysik *„„' **** PUBLIC DOMAIN ****„„'* These routines display a 78-character-wide list box on the screen, in any„'  height required.  The length of the lines can be up to 76 characters.„'„'  The data is transferred to the ListBox routine in the string array„'  MyData(), which can have basically as many different elements as needed,„'  but the first element must be 1.„'„'  If the extended ascii characters in the PRINT statements in the Box sub„'  don't come out properly, they should be characters 201, 205, 178 for the„'  first PRINT statement, character 186 (twice) for the second PRINT, and„'  characters 200, 205 and 188 for the third PRINT.„„'  To make a list box, call ListBox, with the data array, starting line on„'  the screen, ending line on the screen, and the variable to return the„'  selected option number in.„„'  The Selected% variable returned will be either -1 (if the user pressed„'  <Esc>) or the array element number of the selected option. *„„DECLARE SUB Box (x1%, y1%, x2%, y2%)„DECLARE SUB ListBox (MyData() AS STRING, StartLine%, EndLine%, Selected%)„DECLARE SUB DisplayListBox (MyData() AS STRING, CurrentDisplay%, CurrentSelection%, StartLine%, EndLine%)„„COLOR 7, 1„CLS„OPEN "e:\bitcom\sw-index\selected.txt" FOR INPUT AS #1„„DIM MyData(1 TO 100)  AS STRING„„FOR i = 1 TO 100„  INPUT #1, MyData(i)„  MyData(i) = LEFT$(MyData(i), 76)„NEXT i„„CLOSE„„ListBox MyData(), 1, 25, a%„„IF a% > 0 THEN„  PRINT : PRINT "You selected option"; a%„  PRINT MyData(a%)„ELSEIF a% = -1 THEN„  PRINT : PRINT "*Cancel*"„END IF„„SLEEP dummy$ = INKEY$„„SUB Box (x1%, y1%, x2%, y2%) '* Display top line (character 201, row of character 205, character 187) *„LOCATE y1%, x1%„PRINT "+"; STRING$(x2% - x1% - 1, "-"); "+";„„'* Display side bars (character 186) *„FOR i = y1% + 1 TO y2% - 1„  LOCATE i, x1%„  PRINT "|";„  LOCATE i, x2%„  PRINT "|";„NEXT i„„'* Display bottom line (200, row of 205, 188) *„LOCATE y2%, x1%„PRINT "+"; STRING$(x2% - x1% - 1, "-"); "+";„„END SUB„„SUB DisplayListBox (MyData() AS STRING, CurrentDisplay%, CurrentSelection%, StartLine%, EndLine%)„  COLOR 3, 0„  Box 2, StartLine%,79, EndLine%               'Draw a box around the list COLOR 7, 0„„  FOR i = StartLine% + 1 TO EndLine% - 1„„    '* Get string to display *„    CurrentString$ = MyData(CurrentDisplay% + i - StartLine% - 1)„„    '* If the selection bar is on this line then change colour *„    IF i - StartLine% = CurrentSelection% THEN COLOR 15, 4„„    LOCATE i, 3„    PRINT CurrentString$; SPACE$(76 - LEN(CurrentString$));„„    '* If colour was changed for selection bar then change back *„    IF i - StartLine% = CurrentSelection% THEN COLOR 7, 0„  NEXT i„„END SUB„„SUB ListBox (MyData() AS STRING, StartLine%, EndLine%, Selected%)„„  CurrentDisplay% = 1                   'Set first line displayed to 1„  GOSUB ListMenuDown                    'Set the selection bar to item 1„„  ' Display the box„  DisplayListBox MyData(), CurrentDisplay%, CurrentSelection%, StartLine%, EndLine%„„  DO„„    DO„      xxx$ = INKEY$„    LOOP WHILE xxx$ = ""„„    SELECT CASE xxx$„„      CASE CHR$(0) + "H"                'Up arrow key„        GOSUB ListMenuUp„„      CASE CHR$(0) + "P"                'Down arrow key„        GOSUB ListMenuDown„„      CASE CHR$(0) + "I"                'Page Up key„        IF CurrentDisplay% > 1 THEN„          CurrentDisplay% = CurrentDisplay% - (EndLine% - StartLine% - 2)„          IF CurrentDisplay% < 1 THEN CurrentDisplay% = 1„          DisplayListBox MyData(), CurrentDisplay%, CurrentSelection%, StartLine%, EndLine%„        END IF„„      CASE CHR$(0) + "Q"                'Page Down key„        IF CurrentDisplay% < UBOUND(MyData) - ((EndLine% - StartLine% - 2) * 2) THEN„          CurrentDisplay% = CurrentDisplay% + (EndLine% - StartLine% - 2)„        ELSE„          CurrentDisplay% = UBOUND(MyData) - (EndLine% - StartLine% - 2)„        END IF„        DisplayListBox MyData(), CurrentDisplay%, CurrentSelection%, StartLine%, EndLine%„„      CASE CHR$(13)                     'Enter key (select)„        Selected% = CurrentDisplay% + CurrentSelection% - 1„        EXIT SUB„„      CASE CHR$(27)                     'Esc key (cancel)„        Selected% = -1„        EXIT SUB„    END SELECT„  LOOP„„  EXIT SUB„„ListMenuDown:                        'GOSUB routine for down arrow key„ IF CurrentDisplay% + CurrentSelection% < UBOUND(MyData) THEN„    '* If selection bar is on the last item currently displayed scroll down *„    IF CurrentSelection% = EndLine% - StartLine% - 1 THEN„      IF CurrentDisplay% < (UBOUND(MyData) - (EndLine% - StartLine% - 2)) THEN„        CurrentDisplay% = CurrentDisplay% + 1„        DisplayListBox MyData(), CurrentDisplay%, CurrentSelection%, StartLine%, EndLine%„      END IF„    ELSE„      CurrentSelection% = CurrentSelection% + 1„„      IF NOT CurrentSelection% < 2 THEN         'Remove old selection bar„        COLOR 7, 0„        LOCATE CurrentSelection% + StartLine% - 1, 3„        PRINT MyData(CurrentSelection% - 2 + CurrentDisplay%); SPACE$(76 - LEN(MyData(CurrentSelection% - 2 + CurrentDisplay%)));„      END IF„„      COLOR 15, 4                               'Create new selection bar„      LOCATE CurrentSelection% + StartLine%, 3„      PRINT MyData(CurrentSelection% - 1 + CurrentDisplay%); SPACE$(76 - LEN(MyData(CurrentSelection% - 1 + CurrentDisplay%)));„    END IF„  END IF„RETURN„„„„ListMenuUp:                                     'Gosub routine for up arrow„  IF CurrentDisplay% + CurrentSelection% > 2 THEN„„    '* If currently selected item is first item displayed then scroll up *„    IF CurrentSelection% = 1 AND CurrentDisplay% > 1 THEN„      CurrentDisplay% = CurrentDisplay% - 1„      DisplayListBox MyData(), CurrentDisplay%, CurrentSelection%, StartLine%, EndLine%„    ELSE„      CurrentSelection% = CurrentSelection% - 1„„      '* Remove old selection bar *„      IF NOT CurrentSelection% + StartLine% = EndLine% - 1 THEN„        COLOR 7, 0„        LOCATE CurrentSelection% + StartLine% + 1, 3„        PRINT MyData(CurrentSelection% + CurrentDisplay%); SPACE$(76 - LEN(MyData(CurrentSelection% + CurrentDisplay%)));„      END IF„„      '* Create new selection bar *„      COLOR 15, 4„      LOCATE CurrentSelection% + StartLine%, 3„      PRINT MyData(CurrentSelection% - 1 + CurrentDisplay%); SPACE$(76 - LEN(MyData(CurrentSelection% - 1 + CurrentDisplay%)));„    END IF„  END IF„RETURN„„END SUB„Peter Scatliffe                PB SCROLL BOX W/HI-LITE MARKER Peter_Scatliffe@CompuServe.com 02-10-97 (16:52)       PB                     157  5201     SCRLBOX2.BAS'_|_|_|   SCRLBOX2.BAS„'_|_|_|   This program demonstrates the use of a configurable scroll„'_|_|_|   box with hi-lite marker.„'_|_|_|   It will read and display itself when it is run.„'_|_|_|   Released to the   PUBLIC DOMAIN   by Kurt Kuzba.„'_|_|_|   Modified (& still PUBLIC DOMAIN) February 1997 by Peter Scatliffe„'_|_|_|   to:„'_|_|_|    - Powerbasic 3.0c„'_|_|_|„'_|_|_|    - Allowing the passing of a LowerLimit (LowLim%) so that you can„'_|_|_|      select a range in the middle of a string array (say elements„'_|_|_|      10 to 50.  The highest element used is set by HighLim%.„'_|_|_|„'_|_|_|    - I also pass the array to be displayed as a parameter rather„'_|_|_|      than as a global variable because it is more flexible.„'_|_|_|   If you want the unused portion of the screen filling remove the„'_|_|_|   5 rem's below.„„DECLARE FUNCTION ScrollBox% (Passed(1) as string, LowLim%, HiLim%, high%, wide%, LIN%, COL%,Options%)„„TYPE textline„   l AS STRING * 80„END TYPE„„dim txt(800) as string„dim Selected as integer„dim t as integer„„OPEN "scrlbox2.bas" FOR INPUT AS #1„ t = 0„ WHILE ((t < 800) AND (NOT EOF(1)))„   LINE INPUT #1, txt(t)„   t = t + 1„ WEND„CLOSE 1„„Selected = ScrollBox%( txt(), 1, t-1, 10, 50, 5, 10, 0 )„„COLOR 2, 0: CLS„if Selected% < 0 then„  PRINT "You hit ESCAPE"; Selected„  else„  PRINT "You hit ENTER on array item"; Selected„end if„END„'_|_|_|   end   SCROLBOX.BAS„„„'**************************************************************************„'This function will display a list box of items in the string array„Passed()„'  - LowLim and High Lim allow you to limit the list parts of the array„'  - High & Wide define the number of rows High and columns wide.„'  - Lin and Col define the position of the top left hand corner„'  - Options =„'               0 no sort„'               1 alpha/numeric sort ascending (case sensitive)„'               2 alpha/numeric sort ascending (ignore case)„'               3 alpha/numeric sort descending (case sensitive)„'               4 alpha/numeric sort descending (ignore case)„'    NB The array you pass if you sort will be changed.  If you only„'       select part if the array to display, then only the selected part„'       part will be sorted.„'The function returns -1 if ESCAP was pressed, or the element number if„'RETURN was pressed„„FUNCTION ScrollBox% (Passed(1) as string,LowLim as integer, HiLim as integer, High as integer, Wide as integer, Lin as integer, Col as integer, Options as integer)„„   dim Sel as integer„   dim Top as integer„   dim ex as integer„   dim s as string„   dim t as integer„   dim p as integer„   dim pp as string„„   local Sel, Top, ex, s, t, p, pp„„„„   select case LowLim„     case < lbound(Passed())„       LowLim = lbound(Passed())„     case = 0„       LowLim = lbound(Passed())„   end select„„   select case HiLim„     case = 0„       HiLim = lbound(Passed())„     case > ubound(Passed())„       HiLim = ubound(Passed())„     case <= LowLim„       HiLim = ubound(Passed())„   end select„„   HiLim = HiLim - LowLim + 1„„   select case Options„     case = 1„       array sort Passed(LowLim) for HiLim„     case = 2„       array sort Passed(LowLim) for HiLim, collate ucase„     case = 3„       array sort Passed(LowLim) for HiLim, descend„     case = 4„       array sort Passed(LowLim) for HiLim, collate ucase, descend„„   end select„„   COLOR 7, 0: CLS : Sel = 0: Top = 0: ex = HiLim„   COLOR 9, 1: LOCATE 1, 1, 0: s = STRING$(Wide, " ")„rem   FOR t = 0 TO High + 1„rem      LOCATE Lin + t, Col„rem      PRINT STRING$(Wide + 4, CHR$(177));„rem   NEXT„   Lin = Lin + 1: Col = Col + 2„   WHILE HiLim = ex„      COLOR 9, 1: LOCATE Lin - 1, Col„rem      PRINT MID$(STR$(Sel + 1), 2) + STRING$(3, CHR$(177))„      FOR t = 0 TO (High - 1)„         LOCATE Lin + t, Col: COLOR 1, 3„         IF t + Top = Sel THEN COLOR 0, 7„         PRINT mid$(Passed(Top + t + LowLim) + s, 1, Wide);„      NEXT„      p = 0: pp = " HPIQGO" + CHR$(13) + CHR$(27)„      WHILE p < 2: p = INSTR(pp, RIGHT$(INKEY$, 1)): WEND„      SELECT CASE p„         CASE = 2   'CURSOR UP„            IF Sel > 0 THEN Sel = Sel - 1„            IF Sel < Top THEN Top = Sel„         CASE = 3   'CURSOR DOWN„            IF Sel < (HiLim - 1) THEN Sel = Sel + 1„            IF Sel > (Top + (High - 2)) THEN Top = Sel - High + 1„         CASE = 4   'PAGE UP„            Top = Top - High: Sel = Sel - High„            IF Top < 0 THEN Top = 0„            IF Sel < LowLim THEN Sel = 0„         CASE = 5   'PAGE DOWN„            Top = Top + High: Sel = Sel + High„            IF Top >= HiLim - High THEN Top = HiLim - High„            IF Top < 0 THEN Top = 0„            IF Sel >= HiLim THEN Sel = HiLim - 1„         CASE = 6   'HOME„            Top = 0: Sel = 0„         CASE = 7   'END„            Sel = HiLim - 1: Top = Sel - High + 1„            IF Top < 0 THEN Top = 0„         CASE = 8   'ENTER„            HiLim = Sel„         CASE = 9   'ESCAPE„            HiLim = -1„            Sel = -1 - LowLim„      END SELECT„   WEND„   ScrollBox% = Sel + LowLim„END FUNCTION„Denis Boyles                   HIGHLIGHT OF CHOICES           FidoNet QUIK_BAS Echo          02-06-97 (01:13)       QB, QBasic, PDS        89   2197     CHOICES.BAS '>I would like some help with drop-down menus.  How does one program the„'>following in Quick BASIC:„„'>1.  When the menu drops down, how do you save the information below„'>    the menu so that it can be displayed again after you're done with„„'You could copy the screen area to a buffer and then restore it later or„'simply clear and re-draw.„„'>2.  How do you program the highlight bar to select choices on the menu?„„'Hmm, might this demo I whipped up help, it displays a simple FILE menu„'complete with highlight. Use the up/down keys to move the highlight and press„'enter to `select' the option. When you've had enough, simply select the„'EXIT choice on the menu, hope it helps.„„'CHOICES.BAS - Public Domain by Denis Boyles„'            ! Microsoft QBASIC v1.1„'            ? a possible menu/highlight demonstration?„„DECLARE SUB ReadItems ()„DECLARE SUB DrawMenu (choice%)„DECLARE FUNCTION GetChoice% (choice%)„DECLARE FUNCTION GetKey$ ()„„DEFINT A-Z„„CONST NUMITEMS = 6„„DIM SHARED items(1 TO NUMITEMS) AS STRING„„ReadItems„choice = 1„COLOR 7, 0„CLS„„PRINT "Use "; CHR$(24); CHR$(25); " to move, ENTER to select";„PRINT ", choose EXIT to quit."„„DO„  choice = GetChoice(choice)„  LOCATE 3, 1„  COLOR 15, 0„  PRINT "You picked: "; items(choice)„LOOP UNTIL choice = NUMITEMS„„DATA "New", "Open...", "Save", "Save As...", "Print", "Exit"„„SUB DrawMenu (choice)„  FOR ct = 1 TO NUMITEMS„    LOCATE 9 + ct, 32„    IF ct = choice THEN COLOR 15, 1 ELSE COLOR 0, 7„    PRINT items(ct)„  NEXT„END SUB„„FUNCTION GetChoice (choice)„  DO„    DrawMenu choice„    key$ = GetKey$„„    SELECT CASE key$„      CASE CHR$(0) + CHR$(80)„        choice = choice + 1„        IF choice > NUMITEMS THEN choice = 1„„      CASE CHR$(0) + CHR$(72)„        choice = choice - 1„        IF choice < 1 THEN choice = NUMITEMS„    END SELECT„  LOOP UNTIL key$ = CHR$(13)„„  GetChoice = choice„END FUNCTION„„FUNCTION GetKey$„  DO„    key$ = INKEY$„  LOOP WHILE key$ = ""„„  GetKey$ = key$„END FUNCTION„„SUB ReadItems„  FOR ct = 1 TO NUMITEMS„    READ items(ct)„    items(ct) = items(ct) + SPACE$(16 - LEN(items(ct)))„  NEXT„END SUB„Kirk Woodward                  PULL-DOWN MENU                 harryst@castel.nl              02-24-97 (16:00)       QB, QBasic, PDS        1207 39324    BBMENU.BAS  DEFINT A-Z„DECLARE SUB menuSub6 ()„DECLARE SUB menuSub5 ()„DECLARE SUB menuSub3 ()„DECLARE SUB menuSub4 ()„DECLARE SUB menuSub2 ()„DECLARE SUB menuSub1 ()„DECLARE SUB menuTop ()„DECLARE SUB eraseSubMenus ()„DECLARE SUB showTopFrame ()„DECLARE SUB showSubFrame ()„DECLARE SUB showSubText (dimSwitch$)„DECLARE SUB showSubHighlight ()„DECLARE SUB getSubDecision ()„DECLARE SUB showTopText ()„DECLARE SUB showTopHighlight ()„DECLARE SUB getTopDecision ()„DECLARE SUB DisplaySubMenu ()„DECLARE SUB topBarDisplay (topBarText$(), topSelection, itemWanted)„„DIM topBarText$(1 TO 6)            ' the text on the top line of initial menu„„'   We have opted to designate the menu elements as COMMON SHARED so that„'   any part of the menuing system will be available from any part of your„'   application.„„COMMON SHARED subMenuText$()„COMMON SHARED topBarText$()„COMMON SHARED topSelection„COMMON SHARED topHighlight„COMMON SHARED subMenuToShow„COMMON SHARED subSelection„COMMON SHARED mc„COMMON SHARED position„COMMON SHARED strippedTopBarString$„„'$DYNAMIC„„'       Converted from PowerBASIC to QuickBASIC by Mr. Snow^Xtance„'       Coders Alliance & DeeJee'z Team„'„'       E-Mail: mrsnow@freemail.nl„„' ==================„'     bbmenu.bas„' ==================„'„'       Does the world REALLY need another bounce bar menuing program?„'    „'       I LOVE Microsoft's User Interface - but - wow! the baggage„'       one has to carry to use it!„'„'       By way of comparison:  If you load up MS's UIDEMO.BAS along„'       with the required LIB and compile it you'll have an .EXE file„'       of 120,000 bytes(!).  Friends, thats BEFORE you even start„'       writing your program!„'„'       If you compile BBMENU.BAS you'll wind up with an .EXE file„'       of 54,848 bytes and -- for what I needed -- I had everything„'       I needed UI for!!  i.e., get, and act upon, an operator's„'       decision.„'„'       Let me be the first to say:  UI can do a whale of a lot„'       more than BBMENU does -- BUT -- how much more do YOU need„'       to do?  I just KNOW I could get you some windowing, shadowing„'       ect for a WHOLE lot less than the 66,000 bytes BBMENU doesn't„'       need as it stands now!„'„'       Better Yet:  How 'bout YOU show us YOUR stuff?„'„'       Register this source code, gimmie a little credit at the top of„'       your program, then YOU add what you feel you've "gotta have" and„'       send it back up to this BBS with a new name???„'„'       Sound like fun?  Sure -- it is!  Get goin' on becoming a„'       published author yourself!„'„'       Register your use for $25 and get the NEWEST version PLUS„'       two ADDITIONAL SUBs that do meaningful work and will save your„'       time!„'„'       (Those additional SUBs register separately for $10-$25.  You„'       get 'em free for registering.)„'„'       SOURCE?  OF COURSE!   You always get full source code with„'       your registration.„'„'       We accept Visa, MasterCard or American Express credit cards,„'       24 hours a day, 7 days a week.„'„'„'       Kirk Woodward                 CompuServe: 70146,51„'       People Centered Programs„'       PO Box 610171„'       Dallas, TX 75261-0171„'       REGISTRATIONS ONLY: 1-800-553-5883„'       817/488-4940  FAX: 817/488-4945„'„„    '  Here's the logic of this menuing system:„    '„    '   1.  Program Starts with top line display of the topBarText$()„    '       array.„    '„    '   2.  Operator makes a selection with the left and right arrow„    '       keys and touches ENTER - or - touches the highlighted letter.„    '„    '   3.  That 'pulls down' the secondary menu.„    '„    '   4.  Operator makes a selection from the secondary menu„    '       via arrow keys and ENTER or highlighted letter. (Same„    '       as the Top Bar, except that the sub menus all use A-Z)„    '„    '   Additionally, when the sub menu is pulled down, the„    '   operator can move left or right, pulling down menus as„    '   they go.  (The 'old' pulled down menu is cleared from the„    '   display.  If you prefer to leave it on the screen -- in„    '   effect "stacking" the menus -- just REM out the lines in„    '   the eraseSubMenus SUB or delete the call to that sub in„    '   getSubDecision SUB)„    '„    '   A short explanation of "bounce bar" technology, or, things„    '   are not what they appear to be!„    '„    '   To get the effect of a moving bar of light that shows the„    '   operator's decision in a very graphic manner, two things happen„    '   very quickly:„    '„    '           1.  The existing highlighted text must be over„    '               written with the same characters un-highligted.„    '„    '           2.  The new selection must be 'reversed' (or high-„    '               lighted) and printed right on top of the text„    '               printed in 1.„    '„    '   I have also elected to add another touch:  'Diming' the texts„    '   that are no longer under consideration by virtue of the„    '   operator's decision(s) and "jumping" the highlight bar should„    '   the operator elect to touch a highlighted key rather than„    '   moving the bar to an item.  These effects are, again, created„    '   by re-writing affected segments of the screen.„    '„    '   Students of the process can slow the action down to see each„    '   process as it happens by setting a break point - or the command„    '   STOP at the end of 4 SUBs:„    '„    '           1.  showTopText„    '           2.  showTopHighlight„    '           3.  showSubText„    '           4.  showSubHighlight„    '„    '   Place the break point at the END SUB command in each SUB or„    '   in the blank line above it type:  STOP.   Then run the program.„    '   As you hit each stopping point, touch the F4 key to see the screen„    '   the program has created.  (The F5 key will continue running the„    '   program)„    '„    '   Be sure to REM out your STOP commands!„„„programStarts:„„    SCREEN 0„    CLS„   „    '   The nested nature of the SUB calls in this program make„    '   the "out of stack space" error a possibility should the„    '   operator pull down a menu and then hold down the left or„    '   right arrow without stopping to make a selection.  Over several„    '   crash tests we found the program could take about 15 such„    '   non-decision making repetitions before crashing.  If you feel„    '   you need to protect against such odd stroking, the appropriate„    '   measure would be to set a larger stack (it will deny the space„    '   to other parts of your application.)„    '„    '   Out of Stack space is not a trappable error and the STACK and„    '   CLEAR commands cannot appear in a SUB.„    '„    '   The 'absolute' solution would be to disable the program's„    '   present ability to respond to left and right arrow presses„    '   in the SUB getSubDecision.  That will force the operator to„    '   return to the top bar menu in order to move to a new sub menu.„    '„    '   Our recommendation:  Build your application with the feature„    '   included.  If out of stack space becomes a problem as you test„    '   the finished application, disable the feature in the SUB„    '   getSubDecision.„    '„    '   We tested the top bar menu with the arrow keys depressed for„    '   several THOUSAND repetitions with no problems.„    '„„„    CALL menuTop„„    '   Trap a "N"o answer to the question about quitting the program„    '   in the menuTop SUB  (the topSelection variable will = 27)„„    IF topSelection = 27 THEN„        GOTO programStarts:„        END IF„„„evaluateChoice:„„    '  trap ESC key press in the sub menu„„    IF subSelection = 27 THEN„        eraseSubMenus„        GOTO programStarts:„        END IF„„    '   two values are returned to this main module . . .„    '„    '   These nested SELECT CASE blocks call the appropriate„    '   action for each operator selection.„    '„    '   As it is now, we have made provision for all the demo„    '   selections  . . . if you change the number of items on„    '   a sub menu, you will need to adjust the number of CASE„    '   statements.  (The SUB getSubDecision accepts all twenty sub„    '   menu selections, so what follows is where an invalid entry„    '   would be trapped.  You are correct that the entry error„    '   could be trapped in getSubDecision, but if each menu is„    '   different in terms of items, you would need a separate getSubDecision„    '   for each menu.„    '„    '   This secondary block seemed the best way to maintain„    '   modularity, yet trap inevitable operator errors.„„    SELECT CASE topHighlight             '  the top bar menu selected„        CASE 1                           '  top bar Item #1„            SELECT CASE subSelection     '  sub menu #1„                CASE 1„                CASE 2„                CASE 3„                CASE 4„                CASE 5„                CASE 6„                CASE 7„                CASE 8„                CASE 9„                CASE 10„                CASE 11„                CASE 12„                CASE 13„                CASE 14„                CASE 15„                CASE 16„                CASE 17„                CASE 18„                CASE 19„                CASE 20„                CASE ELSE„                    SOUND 1300, 1„                    COLOR 30, 0: LOCATE 5, 6: PRINT " Invalid "„                    SLEEP 1„                    subSelection = 0„                    menuSub1„                    GOTO evaluateChoice:„„                    'LOCATE 5, 6: COLOR 0, 7: PRINT " Invalid ": COLOR 7, 0„                    'SLEEP 1„            END SELECT„        CASE 2                           '  top bar item #2„            SELECT CASE subSelection     '  sub menu #2„                CASE 1„                CASE 2„                CASE 3„                CASE 4„                CASE 5„                CASE 6„                CASE 7„                CASE 8„                CASE 9„                CASE 10„                CASE ELSE„                    SOUND 1300, 1„                    COLOR 30, 0: LOCATE 5, 18: PRINT " Invalid "„                    SLEEP 1„                    subSelection = 0„                    menuSub2„                    GOTO evaluateChoice:„„            END SELECT„„        CASE 3                           '  top bar item #3„            SELECT CASE subSelection     '  sub menu #3„                CASE 1„                CASE 2„                CASE 3„                CASE 4„                CASE 5„„                CASE ELSE„                    SOUND 1300, 1„                    COLOR 30, 0: LOCATE 5, 24: PRINT " Invalid "„                    SLEEP 1„                    subSelection = 0„                    menuSub3„                    GOTO evaluateChoice:„            END SELECT„„„        CASE 4                           '  top bar item #4„            SELECT CASE subSelection     '  sub menu #4„                CASE 1„                CASE 2„                CASE 3„                CASE 4„                CASE 5„                CASE 6„                CASE 7„                CASE 8„                CASE 9„                CASE 10„                CASE 11„                CASE 12„                CASE 13„                CASE 14„                CASE 15„                CASE ELSE„                    SOUND 1300, 1„                    COLOR 30, 0: LOCATE 5, 38: PRINT " Invalid "„                    SLEEP 1„                    subSelection = 0„                    menuSub4„                    GOTO evaluateChoice:„„            END SELECT„„        CASE 5                           '  top bar item #5„            SELECT CASE subSelection     '  sub menu #5„                CASE 1„                CASE 2„                CASE 3„                CASE 4„                CASE 5„                CASE 6„                CASE 7„                CASE 8„                CASE 9„                CASE 10„                CASE 11„                CASE 12„                CASE 13„                CASE 14„                CASE 15„                CASE ELSE„                    SOUND 1300, 1„                    COLOR 30, 0: LOCATE 5, 45: PRINT " Invalid "„                    SLEEP 1„                    subSelection = 0„                    menuSub5„                    GOTO evaluateChoice:„„            END SELECT„„        CASE 6                           '  top bar item #6„            SELECT CASE subSelection     '  sub menu #6„                CASE 1„                CASE 2„                CASE 3„                CASE ELSE„                    SOUND 1300, 1„                    COLOR 30, 0: LOCATE 5, 48: PRINT " Invalid "„                    SLEEP 1„                    subSelection = 0„                    menuSub6„                    GOTO evaluateChoice:„„            END SELECT„„    END SELECT„„„    '    In your finished application, you would discard everything„    '    below here and unrem the END command and the RUN "YourAPP"„    '    (substituting the name of your application for YourAPP.)„„    '  RUN "YourAPP"„    '  END                              ' program would normally end here„„    '   the balance of this main module 'validates' the return from the„    '   menus.  The flow would have gone to those specific tasks before„    '   reaching this point.„„    SOUND 700, 3„    SOUND 1200, 2„    SOUND 1000, 4„    PLAY "g"„    showSubText "YES"„    position = subSelection„    showSubHighlight„    COLOR 7, 0„    LOCATE 25, 1„    PRINT STRING$(80, 32);„    LOCATE 25, 1„    PRINT " Selected: ";„    COLOR 0, 7„    PRINT " "; subMenuText$(subSelection);„    COLOR 7, 0„    PRINT " Any key reruns. Ctrl+Break ends";„    DO: LOOP UNTIL INKEY$ > ""„    COLOR 6, 0: LOCATE 2, 2: PRINT strippedTopBarString$: COLOR 7, 0„    LOCATE 25, 1: PRINT SPACE$(80);„    COLOR 23, 0„    LOCATE 25, 35: PRINT "    Working    ";„    COLOR 7, 0„    eraseSubMenus„    SLEEP (1)„    RUN "bbmenu"„    END„„handler:„„    IF ERR = 9 THEN             'subscript out of range error„        position = 1„        RESUME NEXT„        END IF„„REM $STATIC„'=================„SUB eraseSubMenus„'=================„„    '   clears the area occupied by the sub menus„„    COLOR 7, 0                                 ' setting white on black„„    LOCATE 3, 2: PRINT STRING$(78, 205)        ' redraw bottom of top frame„„    FOR x = 4 TO 24„        LOCATE x, 1: PRINT SPACE$(79);„    NEXT„„„END SUB„„'===================„SUB getSubDecision„'===================„„    '   We come here to get operator input when the sub menu(s) is/are„    '   on the screen.„„    DO„„        keyPressed$ = ""„„        DO„            keyPressed$ = INKEY$„        LOOP UNTIL keyPressed$ > ""„„        '  trap the ESC key„„        IF ASC(keyPressed$) = 27 THEN : subSelection = 27: EXIT SUB„„        IF LEN(keyPressed$) = 1 THEN„„            '   a regular key, or a highlighted letter was pressed„            '„            '   the block is set up for the maximum of 20 possible„            '   choices - if the choice is not appropriate for the„            '   menu displayed it is trapped in BBMENU, the main module„„            keyPressed$ = UCASE$(keyPressed$)„            SELECT CASE keyPressed$„                CASE "A"„                    subSelection = 1„                CASE "B"„                    subSelection = 2„                CASE "C"„                    subSelection = 3„                CASE "D"„                    subSelection = 4„                CASE "E"„                    subSelection = 5„                CASE "F"„                    subSelection = 6„                CASE "G"„                    subSelection = 7„                CASE "H"„                    subSelection = 8„                CASE "I"„                    subSelection = 9„                CASE "J"„                    subSelection = 10„                CASE "K"„                    subSelection = 11„                CASE "L"„                    subSelection = 12„                CASE "M"„                    subSelection = 13„                CASE "N"„                    subSelection = 14„                CASE "O"„                    subSelection = 15„                CASE "P"„                    subSelection = 16„                CASE "Q"„                    subSelection = 17„                CASE "R"„                    subSelection = 18„                CASE "S"„                    subSelection = 19„                CASE "T"„                    subSelection = 20„                CASE CHR$(13)                     ' operator touched ENTER„                    subSelection = position„                CASE ELSE„                    '   This block passes ALL key strokes back to the„                    '   main module, error trapping is done there„                    '   rather than here.„                    subSelection = 21„„            END SELECT„„        ELSEIF LEN(keyPressed$) = 2 THEN„„            ' an arrow or function key -- extended key -- was pressed„            ' pick off the ASC value of the 'meaningful' byte.„„            SELECT CASE ASC(RIGHT$(keyPressed$, 1))„                CASE 72            '  up arrow was pressed„                    position = position - 1„                    IF position < 1 THEN position = UBOUND(subMenuText$)„„                '   If the operator presses the left or right arrow„                '   while a sub menu is 'pulled down' they move to„                '   the adjacent sub menu immediately - without having„                '   to return to the top bar menu„                '„                '   The program erases the old sub menu before pulling„                '   down the new one, but, if you REM out the eraseSubMenus„                '   call, the menus will 'stack' on the screen.„                '„                '   This feature also opens the program up to a possible„                '   out of stack space error, which can't be trapped.  If„                '   you have a problem with it, REM out this section.  The„                '   operator then presses the ESC key to return to the top„                '   bar and make another sub menu selection.„„                CASE 75, 77     ' left (75) or right (77) arrow was pressed„                    '   REM out this call to the eraseSubMenus SUB if„                    '   you would like to leave the 'old' sub menu on„                    '   the screen - stacking them.„„                    eraseSubMenus„„                    IF ASC(RIGHT$(keyPressed$, 1)) = 75 THEN„                        subMenuWanted = topHighlight - 1„                        IF subMenuWanted < 1 THEN subMenuWanted = 6„                    ELSE„                        subMenuWanted = topHighlight + 1„                        IF subMenuWanted > 6 THEN subMenuWanted = 1„                    END IF„                    LOCATE 2, 2: COLOR 6, 0: PRINT strippedTopBarString$: COLOR 7, 0„                    SELECT CASE subMenuWanted„                        CASE 1: menuSub1„                        CASE 2: menuSub2„                        CASE 3: menuSub3„                        CASE 4: menuSub4„                        CASE 5: menuSub5„                        CASE 6: menuSub6„                    END SELECT„                    EXIT SUB„„                CASE 80            ' down arrow was pressed„                    position = position + 1„                    IF position > UBOUND(subMenuText$) THEN position = 1„„                CASE ELSE„                    SOUND 1200, 1„„            END SELECT„„            '  now we update the screen„„            CALL showSubText(dimSwitch$)„            CALL showSubHighlight„„        ELSE„„            ' an unanticipated key was pressed„„            SOUND 1000, 1„„            '  restart the sub„„            CALL getSubDecision„„        END IF„„                                      ' only making a selection will escape„    LOOP UNTIL subSelection > 0       ' this loop„„    CALL showSubText("YES")    '    "YES" means the call IS to dim the text„    CALL showSubHighlight      '    the sub menu selection is highlighted„„END SUB„„'===================„SUB getTopDecision„'===================„„    topSelection = 0„„    showTopText„„    IF topHighlight = 0 THEN topHighlight = 1   ' making Item One the default selection„    showTopHighlight„„    DO„„        keyPressed$ = ""„„        DO„            keyPressed$ = INKEY$„        LOOP UNTIL keyPressed$ > ""„„        IF ASC(keyPressed$) = 27 THEN topSelection = 27: EXIT SUB„„        IF LEN(keyPressed$) = 1 THEN„„            ' a regular key, or a highlighted letter was pressed„„            keyPressed$ = UCASE$(keyPressed$)„„            SELECT CASE keyPressed$„„                '   These are the highlighted letters on the top line„„                CASE "O"„                    topSelection = 1„                CASE "T"„                    topSelection = 2„                CASE "H"„                    topSelection = 3„                CASE "F"„                    topSelection = 4„                CASE "I"„                    topSelection = 5„                CASE "X"„                    topSelection = 6„                CASE CHR$(13)       ' operator touched ENTER„                    topSelection = topHighlight„                CASE ELSE„                    '  unacceptable key was touched„                    SOUND 1300, 1„                    topSelection = 0„            END SELECT„„        ELSEIF LEN(keyPressed$) = 2 THEN„„            ' an arrow or function -- extended -- key was pressed.„            ' We pick off the 'meaningful' byte and analyze„            ' it's ASC value.„„            SELECT CASE ASC(RIGHT$(keyPressed$, 1))„„                CASE 77            ' right arrow was pressed„                    topHighlight = topHighlight + 1„                CASE 75            ' left arrow was pressed„                    topHighlight = topHighlight - 1„                CASE 80              ' down arrow was pressed„„                    '   has same effect as pressing the ENTER key,„                    '   operators seem to expect it.„„                    topSelection = topHighlight„„                CASE ELSE„                    SOUND 1200, 1„„            END SELECT„„            '  now we refresh the display„„            CALL showTopText„            CALL showTopHighlight„„„        ELSE„„            ' an unanticipated key was pressed„„            SOUND 1000, 1„„            '  restart the sub„„            CALL getTopDecision„„        END IF„„                                      ' only making a selection will escape„    LOOP UNTIL topSelection > 0       ' this loop„„    '   This 'turns off' the top bar highlights„„    COLOR 6, 0: LOCATE 2, 2: PRINT strippedTopBarString$: COLOR 7, 0„„„END SUB„„'=============„SUB menuSub1„'=============„„    '   Do you want to change the number of items on this menu?„    '„    '   Simple.„    '„    '   Just change the dimension of the subMenuText$ array and„    '   type in the new items or make the appropriate deletions.„    '   The drawing of the sub menu frame, and the display of the„    '   menu items is controlled by the UBOUND function of the„    '   sub menu array.„    '„    '   You should also adjust the SELECT CASE block for this„    '   menu in the main module, BBMENU.„„„    ERASE subMenuText$„„    DIM subMenuText$(1 TO 20)„„    subMenuText$(1) = "Menu One SubMenu Item One     "„    subMenuText$(2) = "Menu One SubMenu Item Two     "„    subMenuText$(3) = "Menu One SubMenu Item Three   "„    subMenuText$(4) = "Menu One SubMenu Item Four    "„    subMenuText$(5) = "Menu One SubMenu Item Five    "„    subMenuText$(6) = "Menu One SubMenu Item Six     "„    subMenuText$(7) = "Menu One SubMenu Item Seven   "„    subMenuText$(8) = "Menu One SubMenu Item Eight   "„    subMenuText$(9) = "Menu One SubMenu Item Nine    "„    subMenuText$(10) = "Menu One SubMenu Item Ten     "„    subMenuText$(11) = "Menu One SubMenu Item Eleven  "„    subMenuText$(12) = "Menu One SubMenu Item Twelve  "„    subMenuText$(13) = "Menu One SubMenu Item Thirteen"„    subMenuText$(14) = "Menu One SubMenu Item Fourteen"„    subMenuText$(15) = "Menu One SubMenu Item Fifteen "„    subMenuText$(16) = "Menu One SubMenu Item Sixteen "„    subMenuText$(17) = "Menu One SubMenu Item Seventee"„    subMenuText$(18) = "Menu One SubMenu Item Eighteen"„    subMenuText$(19) = "Menu One SubMenu Item Nineteen"„    subMenuText$(20) = "Menu One SubMenu Item Twenty  "„„    mc = 3„    showSubFrame„    showSubText (dimSwitch$)„    showSubHighlight„    topHighlight = 1„    showTopHighlight„    getSubDecision„„END SUB„„'==============„SUB menuSub2„'==============„„    '   Do you want to change the number of items on this menu?„    '„    '   Simple.„    '„    '   Just change the dimension of the subMenuText$ array and„    '   type in the new items or make the appropriate deletions.„    '   The drawing of the sub menu frame, and the display of the„    '   menu items is controlled by the UBOUND function of the„    '   sub menu array.„    '„    '   You should also adjust the SELECT CASE block for this„    '   menu in the main module, BBMENU.„„„    ERASE subMenuText$„„    DIM subMenuText$(1 TO 10)„„    subMenuText$(1) = "Menu Two SubMenu Item One     "„    subMenuText$(2) = "Menu Two SubMenu Item Two     "„    subMenuText$(3) = "Menu Two SubMenu Item Three   "„    subMenuText$(4) = "Menu Two SubMenu Item Four    "„    subMenuText$(5) = "Menu Two SubMenu Item Five    "„    subMenuText$(6) = "Menu Two SubMenu Item Six     "„    subMenuText$(7) = "Menu Two SubMenu Item Seven   "„    subMenuText$(8) = "Menu Two SubMenu Item Eight   "„    subMenuText$(9) = "Menu Two SubMenu Item Nine    "„    subMenuText$(10) = "Menu Two SubMenu Item Ten     "„„    mc = 15„    showSubFrame„    showSubText (dimSwitch$)„    showSubHighlight„    topHighlight = 2„    showTopHighlight„    getSubDecision„„END SUB„„'=============„SUB menuSub3„'=============„„    '   Do you want to change the number of items on this menu?„    '„    '   Simple.„    '„    '   Just change the dimension of the subMenuText$ array and„    '   type in the new items or make the appropriate deletions.„    '   The drawing of the sub menu frame, and the display of the„    '   menu items is controlled by the UBOUND function of the„    '   sub menu array.„    '„    '   You should also adjust the SELECT CASE block for this„    '   menu in the main module, BBMENU.„„„    ERASE subMenuText$„„    DIM subMenuText$(1 TO 5)„„    subMenuText$(1) = "Menu Three SubMenu Item One   "„    subMenuText$(2) = "Menu Three SubMenu Item Two   "„    subMenuText$(3) = "Menu Three SubMenu Item Three "„    subMenuText$(4) = "Menu Three SubMenu Item Four  "„    subMenuText$(5) = "Menu Three SubMenu Item Five  "„„    mc = 20„    showSubFrame„    showSubText (dimSwitch$)„    showSubHighlight„    topHighlight = 3„    showTopHighlight„    getSubDecision„„END SUB„„'=============„SUB menuSub4„'=============„„„    '   Do you want to change the number of items on this menu?„    '„    '   Simple.„    '„    '   Just change the dimension of the subMenuText$ array and„    '   type in the new items or make the appropriate deletions.„    '   The drawing of the sub menu frame, and the display of the„    '   menu items is controlled by the UBOUND function of the„    '   sub menu array.„    '„    '   You should also adjust the SELECT CASE block for this„    '   menu in the main module, BBMENU.„„    ERASE subMenuText$„„    DIM subMenuText$(1 TO 15)„„    subMenuText$(1) = "Menu Four SubMenu Item One    "„    subMenuText$(2) = "Menu Four SubMenu Item Two    "„    subMenuText$(3) = "Menu Four SubMenu Item Three  "„    subMenuText$(4) = "Menu Four SubMenu Item Four   "„    subMenuText$(5) = "Menu Four SubMenu Item Five   "„    subMenuText$(6) = "Menu Four SubMenu Item Six    "„    subMenuText$(7) = "Menu Four SubMenu Item Seven  "„    subMenuText$(8) = "Menu Four SubMenu Item Eight  "„    subMenuText$(9) = "Menu Four SubMenu Item Nine   "„    subMenuText$(10) = "Menu Four SubMenu Item Ten    "„    subMenuText$(11) = "Menu Four SubMenu Item Eleven "„    subMenuText$(12) = "Menu Four SubMenu Item Twelve "„    subMenuText$(13) = "Menu Four SubMenu Item Thirtee"„    subMenuText$(14) = "Menu Four SubMenu Item Fourtee"„    subMenuText$(15) = "Menu Four SubMenu Item Fifteen"„„    mc = 35„    showSubFrame„    showSubText (dimSwitch$)„    showSubHighlight„    topHighlight = 4„    showTopHighlight„    getSubDecision„„END SUB„„'============„SUB menuSub5„'============„„    '   Do you want to change the number of items on this menu?„    '„    '   Simple.„    '„    '   Just change the dimension of the subMenuText$ array and„    '   type in the new items or make the appropriate deletions.„    '   The drawing of the sub menu frame, and the display of the„    '   menu items is controlled by the UBOUND function of the„    '   sub menu array.„    '„    '   You should also adjust the SELECT CASE block for this„    '   menu in the main module, BBMENU.„„„    ERASE subMenuText$„„    DIM subMenuText$(1 TO 15)„„    subMenuText$(1) = "Menu Five SubMenu Item One    "„    subMenuText$(2) = "Menu Five SubMenu Item Two    "„    subMenuText$(3) = "Menu Five SubMenu Item Three  "„    subMenuText$(4) = "Menu Five SubMenu Item Four   "„    subMenuText$(5) = "Menu Five SubMenu Item Five   "„    subMenuText$(6) = "Menu Five SubMenu Item Six    "„    subMenuText$(7) = "Menu Five SubMenu Item Seven  "„    subMenuText$(8) = "Menu Five SubMenu Item Eight  "„    subMenuText$(9) = "Menu Five SubMenu Item Nine   "„    subMenuText$(10) = "Menu Five SubMenu Item Ten    "„    subMenuText$(11) = "Menu Five SubMenu Item Eleven "„    subMenuText$(12) = "Menu Five SubMenu Item Twelve "„    subMenuText$(13) = "Menu Five SubMenu Item Thirtee"„    subMenuText$(14) = "Menu Five SubMenu Item Fourtee"„    subMenuText$(15) = "Menu Five SubMenu Item Fifteen"„„    mc = 42„    showSubFrame„    showSubText (dimSwitch$)„    showSubHighlight„    topHighlight = 5„    showTopHighlight„    getSubDecision„„END SUB„„'=============„SUB menuSub6„'=============„„    '   Do you want to change the number of items on this menu?„    '„    '   Simple.„    '„    '   Just change the dimension of the subMenuText$ array and„    '   type in the new items or make the appropriate deletions.„    '   The drawing of the sub menu frame, and the display of the„    '   menu items is controlled by the UBOUND function of the„    '   sub menu array.„    '„    '   You should also adjust the SELECT CASE block for this„    '   menu in the main module, BBMENU.„„„    ERASE subMenuText$„„    DIM subMenuText$(1 TO 3)„„    subMenuText$(1) = "Menu Six SubMenu Item One    "„    subMenuText$(2) = "Menu Six SubMenu Item Two    "„    subMenuText$(3) = "Menu Six SubMenu Item Three  "„„    mc = 45„    showSubFrame„    showSubText (dimSwitch$)„    showSubHighlight„    topHighlight = 6„    showTopHighlight„    getSubDecision„„END SUB„„SUB menuTop„„    IF topHighlight = 0 THEN topHighlight = 1' Item One will be default„„    ' The  >  symbol tells the system that the next character is„    ' to be highligted.  Each highlighted letter should be unique . . .„„    topBarText$(1) = " Item >One    "„    topBarText$(2) = " Item >Two    "„    topBarText$(3) = " Item T>hree  "„    topBarText$(4) = " Item >Four   "„    topBarText$(5) = " Item F>ive   "„    topBarText$(6) = " Item Si>x    "„„    CALL showTopFrame              '    draw a box for the top bar menu„    CALL showTopText               '    print the topBarText$ array„    CALL showTopHighlight          '    highlight an item„    CALL getTopDecision            '    get the operator's decision„„    SELECT CASE topSelection„„        CASE 1„            CALL menuSub1„        CASE 2„            CALL menuSub2„        CASE 3„            CALL menuSub3„        CASE 4„            CALL menuSub4„        CASE 5„            CALL menuSub5„        CASE 6„            CALL menuSub6„        CASE 27                             '  operator pressed ESC at„            LOCATE 2, 2                     '  the top bar menu„            COLOR 7, 0: PRINT STRING$(78, 32)         ' clear the top line box„            LOCATE 25, 1: PRINT SPACE$(80);           ' clear the bottom line„            LOCATE 2, 30„            COLOR 5, 7„            PRINT " Quit the Program?  (Y/N) "„            COLOR 7, 0„            qd$ = ""„            DO„                SOUND 1500, 3„                qd$ = UCASE$(INPUT$(1))„                IF qd$ = "Y" THEN„                    CLS„                    PRINT "Operator Exited Program on "; DATE$; " at "; TIME$„                    PRINT„                    '   You will want to subsitute your own 'sign off'„                    '   information for the following lines.  Many„                    '   'shareware' authors display registration information.„                    '   Others invite call for "new products catalog."„                    PRINT "People Centered Programs Software"„                    PRINT "PO Box 610171 "„                    PRINT "Dallas, TX 75261-0171"„                    PRINT "817/488-4940"„                    PRINT„                    END„                    END IF„            LOOP UNTIL INSTR("YN", qd$) > 0„„            EXIT SUB„„„        CASE ELSE„„    END SELECT„„„END SUB„„'=================„SUB showSubFrame„'=================„„    '   draw the sub menu frame and the highlighted character„    '   (The mc value -- the upper left corner of the sub menu frame --„    '   is set in the subMenuX that is calling this routine.„    '„    '   A limited 3-d effect is possible by combining the two line„    '   drawing characters with the single line ones.„    '„    '   As with :„    '„    '   …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ∏„    '   ∫                                    ≥„    '   ”ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„    '„    '   Refer to PDS's on line help under ASC Characters„    '„„    LOCATE 3, mc„    COLOR 7, 0„    PRINT "—"; STRING$(33, 205); "—";                    ' top bar„    FOR x = 1 TO UBOUND(subMenuText$)„        x$ = CHR$(x + 64)„        LOCATE 3 + x, mc: PRINT "≥ ";                    ' left side„        COLOR 0, 7„        PRINT x$;                                        '  highlighted ltr„        COLOR 7, 0„        PRINT SPACE$(31); "≥";                           '  right side„    NEXT x„„    LOCATE 3 + x, mc: PRINT "¿"; STRING$(33, 196); "Ÿ";  ' bottom bar„„END SUB„„'====================„SUB showSubHighlight„'====================„„subStarts:„„    '   the variable position can be at 0 when the program„    '   reaches this SUB and would crash.  We trap the error„    '   and assign a value to position.„„    ON ERROR GOTO handler:„„    IF position = 0 THEN position = 1„    COLOR 0, 7„    LOCATE 3 + position, mc + 4„    PRINT subMenuText$(position)„    COLOR 7, 0„„    EXIT SUB„„END SUB„„'===============„SUB showSubText (dimSwitch$)„'===============„„    '   display the sub menu's choices„„    IF dimSwitch$ = "YES" THEN„        dimSwitch$ = ""„        COLOR 6, 0                '   dims the text on a monochrome„    ELSE                          '   monitor - brown on a color monitor„        COLOR 7, 0„    END IF„„    FOR x = 1 TO UBOUND(subMenuText$)„        LOCATE 3 + x, mc + 4: PRINT subMenuText$(x)„    NEXT x„„    COLOR 7, 0„„END SUB„„'==================„SUB showTopFrame„'==================„„    '    draw a box for the top bar menu items„    '    see the showSubFrame SUB for an example of„    '   a 3-d effect one can achieve by mixing two line„    '   and one line drawing characters.„„    LOCATE 1, 1: PRINT "…"; STRING$(78, 205); "ª";   '  top score„    LOCATE 2, 1: PRINT "∫ "; TAB(79); " ∫";          '  the end pieces„    LOCATE 3, 1: PRINT "»"; STRING$(78, 205); "º";   '  bottom score„„    '  show operator's instructions„    '  the instructions are the same for the sub menus„    '  so it stays on the screen when they are displayed„„    COLOR 0, 7„    LOCATE 25, 10: PRINT " Use Arrow Keys & ENTER or touch Highlighted Letter   (ESC to End) ";„„END SUB„„'=====================„SUB showTopHighlight„'=====================„„    'come here to reverse the item  where the cursor is located on top bar„„    IF topHighlight < 1 THEN topHighlight = 6        ' Jump to #6„    IF topHighlight > 6 THEN topHighlight = 1        ' Jump back to #1„„    COLOR 0, 7      '  black letters on white backgroud„„    '  the variable strippedTopBarString$ equals all the topBarText array„    '  elements cocantenated to eliminate the  >  symbol.  The variable„    '  (strippedTopBarString$) is created in the SUB showTopText.  It„    '  is a COMMON SHARED variable, so can be called from anywhere in the„    '  the application.„„    IF topHighlight = 1 THEN LOCATE 2, 2: PRINT LEFT$(strippedTopBarString$, 12)„    IF topHighlight = 2 THEN LOCATE 2, 15: PRINT MID$(strippedTopBarString$, 14, 12)„    IF topHighlight = 3 THEN LOCATE 2, 27: PRINT MID$(strippedTopBarString$, 26, 13)„    IF topHighlight = 4 THEN LOCATE 2, 40: PRINT MID$(strippedTopBarString$, 39, 12)„    IF topHighlight = 5 THEN LOCATE 2, 52: PRINT MID$(strippedTopBarString$, 51, 13)„    IF topHighlight = 6 THEN LOCATE 2, 68: PRINT MID$(strippedTopBarString$, 67, 12)„„    COLOR 7, 0„„END SUB„„'=================„SUB showTopText„'=================„„    strippedTopBarString$ = ""    '  makes sure only one copy is in memory„„    '   We cocantenate the topBarText$ array for printing purposes„„    topBarString$ = topBarText$(1) + topBarText$(2) + topBarText$(3) + topBarText$(4) + topBarText$(5) + topBarText$(6)„„    '  now we print the top bar, highlighting "speed keys" as we go„„    COLOR 15, 0„    LOCATE 2, 2„„    FOR x = 1 TO LEN(topBarString$)„        c$ = MID$(topBarString$, x, 1)    ' looking at each character„        IF c$ = ">" THEN„            COLOR 0, 7„            c$ = ""                       '  now we know the next„        ELSE                              '  character is to be highlighted„            PRINT c$;                     '  so we erase the  >  and change„                                          '  the color„„            ' now we rebuild the menu items without the  >  highlight symbol„„            strippedTopBarString$ = strippedTopBarString$ + c$„„            COLOR 15, 0                    ' returning to white on black„„        END IF„„    NEXT x„„END SUB„Kurt Kuzba                     POPUP MENU                     FidoNet QUIK_BAS Echo          02-09-97 (00:00)       QB, QBasic, PDS        93   4105     POPUPS.BAS  '_|_|_|   POPUPS.BAS„'_|_|_|   Example of popup menus in QBasic.„'_|_|_|   No warrantee, guarantee, or manatee given or implied.„'_|_|_|   Released   PUBLIC DOMAIN   by Kurt Kuzba.  (2/9/97)„DECLARE FUNCTION MenuS$ (M%)„DECLARE FUNCTION MenuWin% (x%, y%, Menu$)„p% = POS(0): c% = CSRLIN: Menu% = 1: poplin% = 1: popcol% = 1: CLS„DO: act% = MenuWin%(poplin%, popcol%, MenuS$(Menu%))„   SELECT CASE Menu%„      CASE 1„         IF (act% = -1) OR (act% = 3) THEN„            Menu% = 3: act% = -1: poplin% = 6: popcol% = 60„         END IF„         IF (act% = -2) OR (act% = 2) THEN„            Menu% = 2: act% = -2: poplin% = 3: popcol% = 30„         END IF„      CASE 2„         IF (act% = -1) OR (act% = 11) THEN„            Menu% = 1: act% = -1: poplin% = 1: popcol% = 1„         END IF„         IF (act% = -2) OR (act% = 10) THEN„            Menu% = 3: act% = -2: poplin% = 6: popcol% = 60„         END IF„      CASE 3„         IF (act% = -1) OR (act% = 6) THEN„            Menu% = 2: act% = -1: poplin% = 3: popcol% = 30„         END IF„         IF (act% = -2) OR (act% = 5) THEN„            Menu% = 1: act% = -2: poplin% = 1: popcol% = 1„         END IF„   END SELECT„LOOP WHILE act% < 0„COLOR 2, 0:  LOCATE c%, p%:  PRINT "Your Choice = "; act%: SYSTEM„FUNCTION MenuS$ (M%)„   SELECT CASE M%„      CASE 1: M$ = "Choice Window;Item One;Window Two;Window Three;"„         M$ = M$ + "Item Four;Item Five;Item Six;Item Seven;"„         M$ = M$ + "Item Eight;Item Nine;Item Ten;"„      CASE 2: M$ = "Menu Items;Delete;Remove;Add;Concatenate;Itemize"„         M$ = M$ + ";Sort By Name;Sort By Size;Sort By Date;Sort By "„         M$ = M$ + " Extension;Next Directory;Previous Directory;"„      CASE 3: M$ = "Test Menu Items;Lawnmower;Sprinkler;Leaf Rake;Ga"„         M$ = M$ + "rden Hose;Next Menu;Previous Menu;Refrigerator;S"„         M$ = M$ + "tove;Kitchen Sink;"„      CASE ELSE: M$ = ""„   END SELECT: MenuS$ = M$„END FUNCTION„FUNCTION MenuWin% (x%, y%, Menu$)„   ox% = CSRLIN: oy% = POS(0): bs% = 160 * x% - 160 + y% * 2 - 2„   DIM M$(23): i% = -1: M% = 0: ndx% = 1: V& = &H3DA„   WHILE ndx% <> 0: nxt% = INSTR(ndx%, Menu$, ";")„      IF nxt% <> 0 THEN„         i% = i% + 1: M$(i%) = MID$(Menu$, ndx%, nxt% - ndx%)„         nxt% = nxt% + 1: IF LEN(M$(i%)) > M% THEN M% = LEN(M$(i%))„      END IF: ndx% = nxt%: es% = (x% + i% + 2) * 160 - 1„   WEND: M% = M% + 2: fil$ = STRING$(M%, " "): k% = 0: p% = 0: c% = 0„   FOR F% = 0 TO i%: M$(F%) = LEFT$(" " + M$(F%) + fil$, M%): NEXT„   DIM buf(4000) AS STRING * 1: s% = (M% + 2) * 2: DEF SEG = &HB800„   FOR t% = 0 TO es% - bs%„      IF (t% MOD 160) < s% THEN„         buf(t%) = CHR$(PEEK(t% + bs%))„      ELSE t% = 160 * (t% \ 160 + 1)„         WHILE (INP(V&) AND 8) = 0: WEND: WHILE (INP(V&) AND 8) <> 0: WEND„      END IF„   NEXT: LOCATE x%, y%, 0: COLOR 8, 1: x% = x% + 1„   PRINT CHR$(213); STRING$(M%, CHR$(205)); CHR$(184);„   FOR p% = 0 TO i%:„      WHILE (INP(V&) AND 8) = 0: WEND: WHILE (INP(V&) AND 8) <> 0: WEND„      LOCATE x% + p%, y%: COLOR 8: PRINT CHR$(179);„      COLOR 15 + 3 * (p% = 0): PRINT M$(p%); : COLOR 8: PRINT CHR$(179)„   NEXT: LOCATE x% + p%, y%: y% = y% + 1: p% = 1„   PRINT CHR$(212); STRING$(M%, CHR$(205)); CHR$(190);„   WHILE k% <> 13 AND k% <> 27„      LOCATE x% + p%, y%: COLOR 1, 7: PRINT M$(p%);„      k$ = "": WHILE k$ = "": k$ = INKEY$: WEND„      k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))„      LOCATE x% + p%, y%: COLOR 15, 1„      SELECT CASE k%„         CASE -72: PRINT M$(p%): p% = p% - 1 - i% * (p% = 1)„         CASE -80: PRINT M$(p%): p% = p% + 1 + i% * (p% = i%)„         CASE -75: p% = -1: k% = 13„         CASE -77: p% = -2: k% = 13„         CASE 27: p% = 0„      END SELECT„   WEND„   FOR t% = es% - bs% TO 0 STEP -1„      IF (t% MOD 160) < s% THEN„         POKE t% + bs%, ASC(buf(t%))„      ELSE t% = 160 * (t% \ 160) + s%„         WHILE (INP(V&) AND 8) = 0: WEND: WHILE (INP(V&) AND 8) <> 0: WEND„      END IF: NEXT: ERASE buf: LOCATE ox%, oy%: MenuWin% = p%„END FUNCTION„'_|_|_|   end   POPUPS.BAS„Kurt Kuzba                     FILE MENU LIST SELECTOR        FidoNet QUIK_BAS Echo          07-15-97 (23:57)       QB, QBasic, PDS        90   3555     BASMENU.BAS '>   read all basic files out of a dir and then list then for„'>   you and you could just press a number to run them„'   This is fairly simple, really. Here is something to study.„'_|_|_|   BASMENU.BAS„'_|_|_|   A simple menuing system in QuickBasic.„'_|_|_|   No warrantee or guarantee given or implied.„'_|_|_|   PUBLIC DOMAIN   by  Kurt Kuzba.  (7/15/1997)„TYPE FileList: F AS STRING * 12: END TYPE„DECLARE SUB BoxBorder ()„DECLARE FUNCTION ChooseProgram$ (BF() AS FileList)„ON ERROR GOTO BooBoo„COLOR 12, 0„CLS„PRINT : PRINT "Creating a menu list..."„SHELL "dir /b *.bas > bas_list.txt"„DIM lst AS INTEGER, count AS INTEGER„DIM BasFile(5000) AS FileList, FError AS STRING„FError = "OK": lst = FREEFILE: OPEN "bas_list.txt" FOR INPUT AS #lst„IF FError <> "OK" THEN„   PRINT : PRINT " Could not open the directory list."„   WHILE INKEY$ > "": WEND: WHILE INKEY$ = "": WEND„   SYSTEM„END IF: count = 0: PRINT : PRINT "Reading menu list.";„WHILE (NOT EOF(lst)) AND (count < 5000)„   count = count + 1: PRINT "."; : LINE INPUT #lst, BasFile(count).F„WEND:  BasFile(0).F = STR$(count): KILL "bas_list.txt"„CALL BoxBorder: ToRun$ = ChooseProgram$(BasFile())„IF ToRun$ = "" THEN„   COLOR 9, 0: CLS : LOCATE 10, 1, 1„   PRINT " You have not chosen a program."„   PRINT " Hit any key to continue..."„   WHILE INKEY$ > "": WEND: WHILE INKEY$ = "": WEND„   SYSTEM„END IF„PRINT : PRINT "Running "; ToRun$„count = INSTR(ToRun$, ".")„IF count > 1 THEN ToRun$ = LEFT$(ToRun$, count - 1): RUN ToRun$„SYSTEM„BooBoo: FError = STR$(ERR): RESUME NEXT„SUB BoxBorder„   COLOR 14, 5„   LOCATE 7, 30„   PRINT " "; CHR$(218); CHR$(194); STRING$(14, 196);„   PRINT CHR$(194); CHR$(191); " ";„   FOR t% = 1 TO 10„      LOCATE 7 + t%, 30„      PRINT " "; STRING$(2, 179); SPACE$(14); STRING$(2, 179); " ";„   NEXT„   LOCATE 18, 30„   PRINT " "; CHR$(192); CHR$(193); STRING$(14, 196);„   PRINT CHR$(193); CHR$(217); " ";„   COLOR 13, 0: LOCATE 20„   LOCATE , 30: PRINT "Keys you may use:"„   LOCATE , 30: PRINT "DOWN, UP, HOME, END"„   LOCATE , 30: PRINT "PAGE UP, PAGE DOWN"„   LOCATE , 30: PRINT "ENTER  (select)"„   LOCATE , 30: PRINT "ESCAPE (abort)";„END SUB„FUNCTION ChooseProgram$ (BF() AS FileList)„   hi% = VAL(BF(0).F): choice% = 1: index% = 1„   DO„      FOR t% = 0 TO 9„         LOCATE 8 + t%, 33, 0„         COLOR 15, 1: IF choice% = (t% + index%) THEN COLOR 1, 7„         s$ = SPACE$(14)„         IF (t% + index%) <= hi% THEN MID$(s$, 2) = BF(t% + index%).F„         PRINT s$;„      NEXT„      DO: k$ = UCASE$(INKEY$): LOOP WHILE k$ = ""„      k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))„      SELECT CASE k%„         CASE 13: ChooseProgram$ = BF(choice%).F: EXIT DO„         CASE 27: ChooseProgram$ = "": EXIT DO„         CASE -71: choice% = 1: index% = 1„         CASE -72: choice% = choice% + (choice% > 1)„            IF choice% < index% THEN index% = choice%„         CASE -73: choice% = choice% - 10: index% = index% - 10„            IF choice% < 1 THEN choice% = 1„            IF index% < 1 THEN index% = 1„         CASE -79: choice% = hi%: index% = hi% - 9„            IF index% < 1 THEN index% = 1„         CASE -80: choice% = choice% - (choice% < hi%)„            IF index% < (choice% - 9) THEN index% = choice% - 9„         CASE -81: choice% = choice% + 10: index% = index% + 10„            IF choice% > hi% THEN choice% = hi%„            IF index% < (choice% - 9) THEN index% = choice% - 9„      END SELECT„   LOOP„END FUNCTION„'_|_|_|   end   BASMENU.BAS„Sam McKoy                      CLICKABLE MENU SYSTEM          fam.mckoy@xtra.co.nz           08-26-97 (21:12)       QB, QBasic, PDS        142  9415     MENU.BAS    DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"MENU.ZIP",4^6:Z&=6797:?STRING$(50,177);„U"%up()%9%%%#-%T0I?Hq+7]Aw97%%Au%%%-%%%%rj%szSg7fxfa;:F[]H+X^V9xu„U"<I-TIF>Op/H<(LJ-]aBG5A^%LLEAhT)kGSL)InGq<w0szdI-T+2nr36h6?$Wf>2„U"W+>nStwbPMj-r,rhHIxeC.rt$>52r#g[8Tloud897BF7U-QVE&MMgp\K?d=TIDv„U"D/F^Lq]\9GP)ZtDl;,LcY4+&=,mS\\Hcws,AbrYV<:T][#EVj#P$g.0cAueE+t7„U"/>#RVZUCsdn6db%LpaN7(;%_MB^v$L.g7MMF+SZt&q9M/xHF_k53*u-_Ln\#w?c„U"Nb.FNXrPL.5^Oj:?]TpgnI48/I)<TldQE&d:k&b>\0lKAhn>]kHE+)tm\#&O0LV„U"k(WD5s.DKNGYi'4(RlEF7d><8mk^-0-q91Av^t,h=\AhEC+IRl^ae>UiGJ_Rj82„U",PU$=U1oi[rHw;Tkt9t4nW,cnOO<6e07CP#qFpP%Z7EzG6^\Hcg3j).*Sj>1t]S„U"r32jIp5'bDcl^+hw6.P=hn=arvt#me(MM.\mJND>e:pN7;<QmPD2CJ-[+HTyU<p„U">d2ThMhePT9z=p4)#QREUaQ5*G5%;I-6.ArHQ-pHL\3qFcx(eI$nt*TD3s()yue„U"K]rzHDcfwZ#gm6'.fu.03?]F\#55vf$so3;oqo.aYXhDq9d:&+j;%AJ0.YsC)T7„U"S&9(5uoqbd)9g)hG%19hVQq\5J/tZ'&1%g:z72'XwEqWI%I<\dBzRgEC>I;#Dsj„U"fx8-?tQg\ML;t?U)_PC'3(e)os1/A><(N>Le]w/r7'<<e1Xn]>9Io+(uvVgu6Pb„U"_A9MYjBj_r7%.X1si[Q$qgqTybS7[vvenG4aEnBMRFQe\IPmPP9+6%GU]jRqOe2„U"WjrlQ>p18kaH\W;?:;ENoHVhPoz0F_;A_OiMpik2nS<IsdLlc'*]aF'+Ez6=PcS„U"n[XRE4->6XWf%#R=a\;?2z?iT1^q3$_%p-^1G+-&i5J+sF$1lh)Y%EA1,8<l6IS„U"4fn:PS$$b3Wl%Fd>R%d(W;HK2ix(-d)3I0woPLh_p]T2?&tFJI&NRnaTS;FZ9.X„U"r?7R?tR?\%OK-=#lXY4^JPOR#JOj?4)[4([>?m+%O?No%+w\$(0)b*:nL;qY3B'„U"9CQeI>4JCYEArdP02rcwztwN1Yu_'ggt;_/h:2_9Jp'x+Rbzx/2CJBK;)+hU[k2„U"Gg2X#?ZMcbUte6*.38.kDJH6w[6K5mMV,Y'j-$aD7.jW[RQ+hok*;.Ky-[ceZJ,„U"L;=tqh:0#,g;\=4oT8/PkoV<M#,C-Ke(axjKt4p:Tk%$/lPM?3MnLMg*F9eu:pz„U"N?,-P1^SRR-%rwV<rAc.N,;(=:.k]dE0/J0n_2R%*relR[GQ\B$uR_*FCp:tA6M„U"NnbbA/EQ),(4Q=Wl<(bBPa*k%<0Z-Ajk[Ur?z3l&LRg+HA2i#oIm+BMgn=NWCxi„U"I6vj)eA?CwCJ7?8F/9E$g&<CpL2?%E09iCUWl94.4r6ntI0vYOFom,nW>oNr-$0„U",&3YQDg,C[Bm?#E\O%?<>PNg]UY4%Y:%58[EDg?j[tb*]b_tqPXH#Bdg6znS(1k„U"^+I&-+HGOZ2%z>5%ECnNDJjwC#npMdj.>>Q$*gtQP5&NJtbIXIq_>Y,Y,juj+>j„U"O;u;W'wa#q'ntdh'ug\(<MltTjh0tP^nfY\J6c^5n(,YbOq(6wyq0$9+g+M,*%P„U"\>p\BJQ;OMkQ[:O_[&DhYeoLEB$1:/0kF]Q%VK>>'tpli.fQSSNGSNsGSx(>WoX„U"?oDyqu]0jYoW_Wo1;AhtVbv[CgpwK1I&J[*:<c3t^(z+>y4V6EP.=6<;J[ZdNM*„U"gv&V,q)_';/heNs?CtJ.5jAB/=M4=52KD#1K8c-evYjJ#VU]IyP-v^M7)DiJC8G„U"H:fGcgoXMF2,F>af6C0jXsNRFo)&Ja0W3b#d,b>i\xlpv6(LDRP'UjJF*&P7qC^„U"Z[^A;pu2bzVk5f\].*vpZ)Aa5X$2BqF9T*9P>/oO035[IJ'EUo0z$H.ut.6r*d5„U"J<r?,$JcmdsPcsJc_1rdB0t1/uraKOmW.AlIfxk#DouN0QDG\c+']W#kl*xLrI,„U"/R8.H5Vs8&e&cq0OI?NJVCo3FE1:PX?l\)XBOtAZ#3JwZX(jCk'm+SNGJ09C1.G„U"hpZWZmNf*U31-(tO<w,O%5mn^]JW/cMxu]$jEpO^LWl.grEj72?fcia4tW,yKC#„U")I=[hU#..;)uJPIW$_g;W6,$O\Ed$0\n+uhE<^Qjqh>JBhTd-pao#RRi'\E0[TU„U"iuPr)&V%bHQ7Mt_PJYAV7_omL[]&bl/gqz7eYNG(3NYKxoG=]Q&GM=(v[\S4<*M„U"p/GKi=htt5VG;1sAiS;6Ma'2%+lUu)MX29IfI[]X1Rq%YOSP;P.OAN9#owB\AbO„U"p2wKVj:z2j]Q=#lMd9WQICyRJ<BWpHT,)nmondOq78N^MmP1&w5My3*&Q+W89+(„U"Z(yo2&19*mkQ?/xI*zC2M'HSKfFNR&3.wF59gA+P9kHWF<$_GM_y27+U_AT+%$$„U"#etj*3ZMn:oUO>&#MlOe\9jJIH<1[rKsb5+)/16X-E/>fW/0x'Ae&6D'(mmaV>p„U"qOnR1VWIWgbu&xfQ%1B7qi+0RV$jo/8RL*cgj:=;XSZW[juJwM.<QMT<H*i(04?„U"l[*Ztj2fMCyv)rpbj2sFm#oRrW$g[&Q+w%I<jHKYDnj'ATF&a%(&f<Ou*[-d\K[„U"8FU.u<kF'i',vCTiW:'[oa#hA/leQ7jnB=+\'0mh&N$)/\Z1H<WpDl:I-wSp1EJ„U"RE5m0&;19grd\74+&#W(fFS4lJY=>63iQpz<tGWjp%1RQbi;l?TMbstxb\gVyto„U"P\09'Bp_rG.4[vFgR?GOWCyN;,5QYN45H4#2qFey?DXZN*dxG7%/0wZ/P(/[gX5„U"U-Q+Ku^K^j\3GmTC<Q_\viQ-j,942(/M2gTH<'9R0lW2Iwo*6PqdIB[4<DE?/':„U"Kwq_LzEl(KNb<W7za:OV+/<oF+nA7Y_.7jNAEc'>0u[Ppox:nHmjnc4o/#a*&v_„U"_F2Q;0)Vzkfe85#^PQ&-r0f*3aPTKec>A:*:BN7i'/&a_g,Za6x+bBppl-]02sa„U"7156:,0/7'9d0TQd2qF&Un/.H%qyR'rU\]tEcpmpc:(J\$#LU<ZeM9;[^>7PrCp„U">%CB*M/.n'6LZN2Za92n'SybT>;%PZYbn&<53v42536pbsGB7m6Ss4dCd;;7-EG„U";8%qWVlkd6^&?PN&<\+$5-GFrSu*Y*vAHC[3pCr(kNFL(lCm7kfX&dh3Z\+S;H7„U"Noo1(:p#>6)cwuMeRPb/Y2Uv%-7Z4(Cwc?ekK/8OR<_Gj=Sq;7iyMUG8DU9TDU-„U"44=SaG/-[8m]J1mmrVdp+,dp*'&<zV5:TY&hrGmC:f\qUd.,zv6+5Mh38Sm4ih$„U"A'-]WWQ->s-J60Q?ZG_W::WR?lA6gvm);&p5vBOZJx'hPFS;hD\O-#Mp8C2SalU„U"GiJ'_REL-+&oE7>YgAN-SKz,=1]4peDh.k%V>&f2U^b6E&8=r.Z46Q)(Q_;n&,)„U";X7.f407Ffg78?AG[VwI8-l0Sm[i)w5cUg*c\_cc9A#qUHj:+pEE[2wL#Ry:2z(„U":(;-..FQlF5-zu^6E)jB#k+zb.]z*tLT,1K6Ow.Jo]PYXJ>V1E%t2*gkJc+fEp3„U"=n<<ve8fGU;H;Mx]\1'+4)JAs0J:Ty&=0F>:X1WPYHc-Rfo/i2t)Li59G9[sT,s„U"S6r?13e'+T8w4spPl#1K)p/JxN0=%>xxngzRHpsR_r5tc'k.Lr_o29'7wfdyVT#„U"2Y%v+DpJ+&Ul#]_CEz+F#A(CeSUqshIMF[2b8I?-r^4'sRJC-xL#L:Nr4ePuZ=l„U"R4064f$ia^mZY5ul1,VT9\_rX4LX^_R4nB(\P^LN3P^cKB&\O^gQWv56-oE>Bd>„U"MGNe='1U$OZ'=4=Xhst5Z^)m8'drU1CL(t1<Bgc$9C2L+:UtDjDvt9n\I:vh1Je„U"F:a^/XGN7b%.fYn</DcTR6<\U/1B??>+rjyg9Ba;ngZ/cDV9TJzakvq::haK2NA„U"F\vE>1Jcutd(7Z)mR.%dRKPe'Qp,bH7<o%RCyB_&s[SR%^c*7Yi0gOFU-_pEsLA„U"j?U_mCEQ?<:<b>3EB1n([nP3Ap0G2JprB5jF.d*?F0?trr^75o8fPeV9eDmH_G'„U"Q:LD\ncjFQ^do>'tkUQ5?$<EC[:GoWu^9M>UO0=](/pPZj+GLEaTPh#gHSS^_t<„U"pZBs<OC6ukMk-w]RBlT#ID%6?L28Oam0;;F'#3KnH<sk15LHmH7EACA5LYnqU8a„U"AkQdLEGvneubiIh=Jj2I(l(_AmAdOZh2]5ZlMG']?/)xZ4o:^=<'e$S/5I:#:;q„U"4kVGs8iU\24nNQG2#W(C$;Hezi][1'p+T&HqRjAH<38edI=Y#1^JT5A.%2WY+Xm„U"OYa,T8EY6+n?$FE.-[\c)=7MbV9w%RW?d-s2yestIGrI6dDbz?-TvZ/d=N_,h]x„U"ouNSjbdZ8[_s.5N(\?eW$f8#w;dukg*SlbH5WfVSvlTno?l<bI_,B<isAR]sm]m„U"tUfJ*1_ty3datTc9XA$s^gqZ&8Y[(^PatD<dxQ/AQg\8i7+PL&wOa4B(M+;(_%/„U",>Z+Q.[SZ/Br^yB(THR]rr-WC#bGsDQTm_6a+V1b5*(VW0rHdMY0+GLRhhZ?P'f„U"N?7hoynFl54iGt#gT%kxZ&1Oj0GWZ>>u/R&PXVPv>&G4CFFWp%11u)QL+0Mk'&A„U"JFT[:im:RJDfRF;)J+mC5p5:0Zj9I]3D=B-R(otS9&)$+pAR))2WKTQFmD/S%w;„U"\F\o_V%=.nQT-bB,G'W(T=HSq&<&$Gtzce5j*n<O/\;Y2-L&GFcjGvt;l;]xL^k„U"sLp<Jqylt60aCrGlgFl\=f+lp9l^00aQh_LpVCe1/AMWADkgi7oMH)q&_>J[lG)„U"v]45hri65$r:ggtj_%o7ApqQaS[z'N^4x-G-A/0Oia;kkgio-5Tr/bFeV_S_;E4„U"[16G7J;>p-t)Y)sRQi'-hGC6GTEv;O?W<e7Qmj'Q)mw&(vWW#jNXY8lO>LEdOhp„U"+t\gG+8+NTeQr5'QoDhz8<*8#IN^%9[0;FqfjhAS:MvG?)i.t#<c(G#rk0X=Dp(„U"x6O3>ik0_3A>:8Y&KU993A7MxFM]ke:6kKY>PVpjjLP=?rM;5qQ\91Etd$]RQ>X„U".p%Pa32FtJ-d3#1l3ULu+<'Aa3sGTrd[tq5-\\q$42[,hD-A3;;5$=bm^mHnAqH„U"[4VHayd$lHOa$^+;'EBST#u/;bc'^M(5?-:^\PP]bK':?S*'4/VA,PG>;n:j9?P„U"S,gjc])uhJ,Z#_,Z#'9>44;Oda)Kr(:f\pX+DJc'^='9>hP/*;+rC9c[a9,]BrO„U"_3eL*[)CW.9Wd:PPu+0k'Y3;Cj:cEI1>AWyA,BH/%K*tw;?b;sFwQKT2bs?q[/\„U"nZ/i9tIajbMUDet*XUrJF9fV?=HcC^OfX^D:7PL#uz-lKkPWoo/YUq#o'1jRx7k„U"'>a4'ZDSE_<.\/gBM72;%R=w(QInR2AYP\#5CEaOW'#JloJfDpZN7otfiRXiJ^L„U"v*fC245jrg[A,l4Wt*sdF/AcldFG65uZoi_A\rXtDE^=YNg9d2s,3-Z%=g?g/E/„U"QDD=X6u-roON6)(>c^,:K;y1[BHpE4l0J<_)w<Qg_-NdU*L(]fZ+I,wpbI-=Xmx„U":>N(-C%$Hx#0o3[0doVWn%;4pIjnR#.Bov63^f:=o,)6W05\D<H8Z\36*4&hkd.„U"z?rC$ITMELW_koSG(mjaYnaKRWkp9\U=Pj&K+KIM.hc'a,]<C07QEvdd.0<-m<V„U"N]g6AIb'z<V9fd\nfp'frDuDg:=8GQun)=nS,T9JqaY;U&r=dRdN[5'w_'D.dRS„U"K77mWN]plHMXc%uhUd-tbSCSU.\'-Wb0P6-F+.2JSt3NKGLeEVAWrd)eNbL;y,%„U"AHICnTY;ak9ZV]CDT__bWfk9WP7IbQ-q$t^m4tiQw_$*)>#:bQ\8oTbv7D&S&qb„U"(IBbamG1g/6*SF/]^NgreZg*sJK>lEa9%VJ7Tzt%.AoWUuaNY^);kAa[rDXmWjf„U"mdb.ML(QSaJQ$xrFc[Q;AKFhJ>N].<I.7_.&stYOQ>NPBhPc7Orwm\):IDmi%I[„U"(B7an&0+4*tnSNI:U.$4(r%vK6,vO]8zA-=?RE2ax8iY?:VFV10F/-?V;6D-P.p„U"Fti#IU8\EfY&-]n77_v;5?eg\4%no+nYYak0.#g8a^w(Q$Hb[oz5/Ohl0cAr/cM„U"kmN9LIZY<6VFnn00*g3dSU1etYUv6SD>V0SuwAodATrdi-_gGvvsnfpl-gYsVgY„U"1SJyDqw#PFk5i38_)y9jMAlMt<H%6StvN2FS&pNQ5PZJV3/Xp$Lq*23?5gVs7%r„U"h/csWl3,^V8*]nKD;sbdtE<vI,>ajIRj6sv9V?T%v9TBj>)^mi9WRW%:vM5PwpX„U"IFKfYvK?IHmf$o;s'mK5q61EQsKyB+ice7fhnq4H>D#)B-hZu*[eY[bx5$W8vw0„U"gYI^^QIe06VofsdI,&6ipcD0x^^#lj,gU,PHK$*QQU^r^$1jQIVpA^Y;+pi2NFM„U"5(n9O%c:_8C<)m6kaa]UPCb'(:>T]qx4rIuRUW_3h=RJ*>*Yk$8U*VdqJMpPrOa„U"Ne2[81n7[+Db&V9;\tPUtuN*uk%?ecnKZ.#IAFGX/-Y)[fmz05<f]AkF6xDz)Z2„U"5F4PJlU>U0bYaFWH),#_tw:X+v.9koNEs<eq/T59syX/SUsT(y^jfnYL+FwsZMK„U"jnOtmt'3*,[REBuGp9f?mixT%up()%9%%%R-%F)d.He<)+DP&.%%/'%%%-%%%%r„U"j%szSyJ'yT$:f>+e:5UhKfw,aW*E3.uYjMTY[#p14,MD7b$E4vS1K%<jtboKXfw„U"RR-n?U69hblhp2lFFY_QcLKUpTEVm(dn$%a:>)o=p&_p>S=C%a.26b#?x1J>NS#„U"&Z6a1U,F<PC8tvF67mtu/XY)f^%j.7NQL(054p'B(TVRcuhXXeq&H;PG9lvSH%u„U"Q0u,6RO-CL[IS.Tgs9\.'7.^xz1etW1BS6q%T*$]N5c3fUGT.;K/sb;ES[eahK5„U"wlSutlfbeQ*7L:7mOMa*NQTyq=Q?.U3yrF5Oxua:p1pHq2.$+-hWu$iF+FfhNz]„U"8_-=Zhp4rW>.[ykoi42T&$sH_>l\^[PC<)MWQ'rNs=3^gmkn##xpzwIWYZT5R_0„U"VH['xup(%)9%%%%-%y&z?H\=x]k[#(%%X%+%%/%%%%w%jfir#jSy'+y&yf,>k]5„U"[b\wwo<mXZ)RyDzlpmXL;5(0jJ<%$C5f'IV/0E%85j.l+?wvG]hptzVb*V(Mo5>„U"8pc_Rd7>A>J*0&9DXJ)pF,Bl<a/cQGp^q/>FGfC?)bDoe#S]n6WsddR-FV$00W(„U":;RG&G(jNBn3fHCu*]i7+ork^dc-(HS-uieeouVItD'2=$UX2_)T3]BSYCk5xJf„U"oNh/.p/C-'pRzfV$p()K<h<a]KuB<ur9Pz7qUkbr7Eo&AL0*j#9]%U?:h;RiSI]„U"Gw9h1EAAu*wOQ_&g+*8r]C=S?)U_=k'SOeQ,Zv9:XUZKCHj0.fH=A^DdJbo[vi0„U"cd>Zm/:q4w-4Ij::kRlw_>/pG'B8&OXmx8OQqD?EgA,-;C,[?(-H+Iv&7('+XX*„U"C0DiZ9a*T+QFkLCAq#reO5%tUpwLV[r>,?Oj55hIr$CF];LA;+I1C-TJl5%B#Lt„U"99K^n$kxVPLivmo=fO]_bxOLO_[5t$SdC]PeCRe[uCeM52XGuj?O\p&su#4p;4N„U"n/g/'qHh;KL5]=Y^LLojIsr&Q1$/cCoT?N(wis3c\2]RjDF\81pV#\%7,Ov^y%p„U"G/_H:Q2)#s*g0*cilv%Nr25f+a(_mU>8U8$rRphNEV^2C?m\WC1Z\pbA:]*pfB6„U"JET;j>'nLLJlqnjk+V+v,FLPO.2#+>^l8=VtDsRhF]Co2kLJS9WjG?,FuwZS:UG„U"PhnVBX)a<UAMt\l)gB'WC3iZxeo)4fU+S-&7pSUggdDfd$FutV]WrPP<pY:lGD,„U"GKU37.2morLUwh%FbB[He^+A\LE=&0rr/57z8U:#;v8Gb1-lf1B>E6N$/_[k=9K„U"r,?<f'=hN/z^S+pQLFp/,4nvI_QpT69VGmu0R\.wj0:AA5;_l6ki5NHjl$6g:ul„U"ubt.weiaLq6F_NXFF:kc(A1Alc/g*_?TCR<>]B91tw5[Un;R<\Kk%]l>\BbfHF=„U"2i59QfHj9q3B>yJFz]^*3[/o5$s?,R):BeC%2Z]b:1nW51M8q:fX^9J$K3]'sy&„U"H'JEA,C+Dx%u%p&'9%%9%%%%-%TA0?Hq\+]Aw[9%%A%u%%-%%%%%%%%%&%%E%%%„U"%%%%%%rjs%zSgf%xup&%'9%9%%%%-4%F).UHe<+&DP&%(%/'%%%-%%%%%%%%%&%„U"E%%%%I%:%%r%jszS(y'yu%p&'9%%9%%%%-%y&z?H\=x]k[#(%%X%+%%/%%%%%%%„U"%%&%%E%%(%D;%%%wjf%irjS(y'yu%p*+%%%%%(#%(%s[%%%L%>%%%%%„END SUB„CLOSE:IF S=201AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Kurt Kuzba                     GRID MENU                      FidoNet QUIK_BAS Echo          09-11-97 (12:19)       QB, QBasic, PDS        79   3713     GRIDMENU.BAS'>   Does anyone out there has the source code for a Grid Menu ??„„'_|_|_|   GRIDMENU.BAS   PUBLIC DOMAIN   by  Kurt Kuzba  9/11/1997„'_|_|_|   A demonstration of constructing a grid-type menu for„'_|_|_|   a QuickBasic application.„DO: Gridmenu running%„   SELECT CASE running%„      CASE 1: Mysub1„      CASE 2: Mysub2„      CASE 3: Mysub3„      CASE 4: Mysub4„      CASE 5: Mysub5„      CASE 6: Mysub6„      CASE 7: Mysub7„      CASE 8: Mysub8„      CASE 9: Mysub9„   END SELECT: LOOP WHILE running%: SYSTEM„SUB Gridmenu (Grid%) : COLOR 2, 0: CLS : ShowGrid 0, 0„   IF Grid% = 0 THEN Grid% = 1„   ShowGrid Grid%, 1„   DO: k% = 0: k$ = UCASE$(INKEY$)„      IF k$ > "" THEN k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))„      SELECT CASE k%„         CASE -72, ASC("U"), ASC("N"): ShowGrid Grid%, 0„            Grid% = (Grid% + 5) MOD 9 + 1: ShowGrid Grid%, 1„         CASE -80, ASC("D"), ASC("S"): ShowGrid Grid%, 0„            Grid% = (Grid% + 2) MOD 9 + 1: ShowGrid Grid%, 1„         CASE -75, ASC("L"), ASC("E")„            ShowGrid Grid%, 0: row% = (Grid% - 1) \ 3„            Grid% = (Grid% + 1) MOD 3 + 1 + row% * 3: ShowGrid Grid%, 1„         CASE -77, ASC("R"), ASC("W")„            ShowGrid Grid%, 0: row% = (Grid% - 1) \ 3„            Grid% = (Grid% MOD 3) + 1 + row% * 3: ShowGrid Grid%, 1„         CASE ASC("1") TO ASC("9"): Grid% = k% - ASC("0"): EXIT DO„         CASE 13: EXIT DO„         CASE 27, ASC("0"): Grid% = 0: EXIT DO„      END SELECT: LOOP: END SUB„SUB MenuMessage (s%) :  LOCATE 20, 10: COLOR 10, 0„   SELECT CASE s%„      CASE 1: s$ = "Menu selection ONE"„      CASE 2: s$ = "Menu selection TWO"„      CASE 3: s$ = "Menu selection THREE"„      CASE 4: s$ = "Menu selection FOUR"„      CASE 5: s$ = "Menu selection FIVE"„      CASE 6: s$ = "Menu selection SIX"„      CASE 7: s$ = "Menu selection SEVEN"„      CASE 8: s$ = "Menu selection EIGHT"„      CASE 9: s$ = "Menu selection NINE"„   END SELECT: PRINT LEFT$(s$ + SPACE$(80), 60); : END SUB„SUB Mysub1 : CLS : PRINT "This is the first menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND: END SUB„SUB Mysub2 : CLS : PRINT "This is the second menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND: END SUB„SUB Mysub3 : CLS : PRINT "This is the third menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND: END SUB„SUB Mysub4 : CLS : PRINT "This is the fourth menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND:  END SUB„SUB Mysub5 : CLS : PRINT "This is the fifth menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND:  END SUB„SUB Mysub6 : CLS : PRINT "This is the sixth menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND:  END SUB„SUB Mysub7 : CLS : PRINT "I am Seven of Nine. We are Borg."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND:  END SUB„SUB Mysub8 : CLS : PRINT "This is the eighth menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND:  END SUB„SUB Mysub9 : CLS : PRINT "This is the ninth menu selection."„   WHILE INKEY$ <> "": WEND: WHILE INKEY$ = "": WEND:  END SUB„SUB ShowGrid (which%, hilite%) : border$ = STRING$(3, 205)„   COLOR 2, 0: IF hilite% <> 0 THEN COLOR 15, 1„   SELECT CASE which%„      CASE 1 TO 9: y% = ((which% - 1) MOD 3) * 10 + 10„         LOCATE ((which% - 1) \ 3) * 5 + 5, y%„         PRINT CHR$(201); border$; CHR$(187)„         LOCATE , y%: PRINT CHR$(186); which%; CHR$(186)„         LOCATE , y%: PRINT CHR$(200); border$; CHR$(188)„         MenuMessage which%„      CASE ELSE: FOR t% = 1 TO 9: ShowGrid t%, 0: NEXT„   END SELECT: END SUB„'_|_|_|   end   GRIDMENU.BAS   PUBLIC DOMAIN„Rodney Steele                  GUI EASYMENU                   rsteele@cs.mun.ca              10-09-97 (12:11)       QB, QBasic, PDS        606  20348    EASYMENU.BAS'Programmer: Rodney Steele„'E-Mail    : rwsteele@geocities.com„'Web Page  : http://www.geocities.com/siliconvalley/horizon/1099„'S-Mail    : P.O.Box 1, Birchy Bay, NF., Canada, A0G 1E0„'Date      : Oct. 9/97„'Version   : 1.0„'„'Hi, thanks for trying EasyMenu. After trying to find a good graphic menu„'system for screen 13 and not having any luck, I decided to write my own.„'This is it, 'EasyMenu'. This program was originally designed for screen 13,„'but with a few changes it now can be used in both 13 and 12.„'„'Please tell me what you think, or if you find a bug, or even if you have„'some ideas, email me.„'----------------------------------------------------------------------------„'                     Copyright 1997 by Rodney Steele„'                     -------------------------------„'You are permitted to use this program provided that it is used in a„'non-commercial product and you must give credit eithor on screen or in a„'credit or documention file stating:„'„'   "Menu, Font13, and Mouse Routines created by Rodney Steele".„'„'This Program is provides 'as-is' no waranties expressed or implied.„'Use at own risk.„'----------------------------------------------------------------------------„'NOTE„'Since not much error detection code is used, data on the far right and at„'the bottom of the screen will not be printed if it extends behond the screen„'limits. If you experience data loss, reduce the size of the data in the main„'or sub-menu options.„'-----„'To Start your own menu:„'All you have to do is define three constants, type in your menu options, and„'call InitMouse to initilized the menu system, then call the function Menu.„'After choosing a option it will return a unique number for that option.„'More details below on what to change to create your own menu.„'-----„'To calculate the unique number for an option, use this equation„'Unique number =  (column-1) * nsmo + row„'-----„'Run this program to try the demo!!„'----------------------------------------------------------------------------„DECLARE FUNCTION Menu% ()„DECLARE FUNCTION InitMouse% ()„DECLARE SUB SetPointerMouse ()„DECLARE SUB SpeedMouse (x%, y%, d%)„DECLARE SUB ClearMouse ()„DECLARE SUB CallMouse (ax%, bx%, cx%, dx%, es%)„DECLARE SUB ShowMouse ()„DECLARE SUB PutMouse (x%, y%)„DECLARE SUB HideMouse ()„DECLARE SUB DataMouse (lbpressed%, rbpressed%, x%, y%)„DECLARE SUB MenuInit ()„DECLARE SUB Font13 (text$, x%, y%, col%)„DECLARE SUB XYMouse (x1%, y1%, x2%, y2%)„„DEFINT A-Z„CONST false = 0, true = NOT false„'----------------------------------------------------------------------------„' #1„'-----„'You must change the constant " nmmo ".  Number of main menu options, to the„'number you are using.„'-----„'You must change the constant " nsmo ".  Number of submenu options, to the„'max number you are using in a submenu. Also note, you must include in the„'count the number of seperation lines "-".„'-----„'You also have a choice bewteen modes 12 or 13, select as described below.„'-----„CONST nmmo = 7  'number of main menu options in Sm(0)„CONST nsmo = 8  'largest number of sub-menu options from Sm(1) to Sm(nmmo)„                'Sm(6) and Sm(1) below are the largest with 8 items.„CONST mm = 1    'screen 12 = 2, screen 13 = 1„'----------------------------------------------------------------------------„IF nmmo > nsmo THEN largest = nmmo ELSE largest = nsmo„DIM SHARED smd(0 TO nmmo, 0 TO largest) AS STRING„DIM SHARED Sm(0 TO nmmo)  AS STRING„DIM SHARED da(0 TO nmmo, 1 TO 3), xloc(0 TO nmmo)„DIM SHARED SubMenuPrinted, y, x, Mouse(0 TO 44)„DIM SHARED ax, bx, cx, dx, es„DIM SHARED lbpressed, rbpressed„'----------------------------------------------------------------------------„' #2„'-----„'Store your main menu options in identifier Sm(0).„'SM(1) to Sm(nmmo) are where the submenu options are stored.„'-----„'The subtraction sign "-" is used to produce a seperation line, and must be„'seperated by commas in the submenu options, thats Sm(1) to Sm(nmmo).„'Note, no "-" signs in the main menu identifier Sm(0).„'-----„'You must have a comma at the end of all data strings.  That is from Sm(0) to„'Sm(nmmo) the last character inside the quotes MUST be a comma.„'-----„'Do add spaces before and/or after commas to increase space between words.„'Each space is equal to one pixel.„'DON'T add spaces with the subtraction sign "-"„'Only use AlphNumeric characters, except for the subtraction sign and comma.„'-----„Sm(0) = "file,edit,view,search,run,debug,options,"„Sm(1) = "new,open,save,save as,-,print,-,exit,"„Sm(2) = "cut,copy,paste,clear,new subroutine,new function,"„Sm(3) = "sub,split,output screen,"„Sm(4) = "find,repeat last find,change,"„Sm(5) = "start,restart,continue,"„Sm(6) = "step,procedure step,-,trace on,-,toggle breakpoint,clear breakpoint,set next statement,"„Sm(7) = "display,help path,syntax checking"„'----------------------------------------------------------------------------„'These are the color constants, change if you wish.„'I have chosen colors below that will work in both modes.„CONST mmfontcol = 15     'Main menu font color„CONST mmBackCol = 4      'Main menu background color„CONST mmfhcol = 0        'Main menu font in highlight area„CONST mmHLCol = 10       'Main menu highlight color„CONST smfontcol = 0      'Submenu font color„CONST smBackCol = 7      'Submenu background color„CONST HighLightCol = 10  'Highlight color„CONST outlinecol = 0     'Outline and dividing line color„'----------------------------------------------------------------------------„Mouse:        'Data for new mouse pointer.„DATA &HF7FF,&HE3FF,&HC1FF,&H80FF,&HE3FF,&HE3FF,&HE3FF,&HE3FF„DATA &HFFFF,&HFFFF,&HFFFF,&HFFFF,&HFFFF,&HFFFF,&HFFFF,&HFFFF„DATA &H0   ,&H800 ,&H1C00,&H3E00,&H800 ,&H800 ,&H800 ,&H800„DATA &H0   ,&H0   ,&H0   ,&H0   ,&H0   ,&H0   ,&H0   ,&H0„'----------------------------------------------------------------------------„„„IF mm = 1 THEN SCREEN 13 ELSE SCREEN 12„„'User's program starts here„„lbpressed = false„rbpressed = false„finished = false„„IF InitMouse THEN„  SetPointerMouse                              'Use a different mouse pointer„  IF mm = 1 THEN                               'Limit mouse to this area„    XYMouse 0, 0, 647, 199„  ELSE„    XYMouse 0, 0, 640, 479„  END IF„  „  SpeedMouse 50, 50, 64                        'Set regular and double speed„  PutMouse 100, 50                             'Place mouse at this point„  PAINT (100, 100), 3                          'Color screen„  MenuInit                                     'Setup EasyMenu„ „  'Draw some boxes„  FOR t = 1 TO 50„    LINE (INT(RND * 319) + 1, INT(RND * 192) + 8)-(INT(RND * 319) + 1, INT(RND * 192) + 8), 4, B„  NEXT„  ShowMouse                                    'Turn on mouse„ „  DO                                           'Main program loop„    ClearMouse                                 'Clear mouse buffer„    DataMouse lbpressed, rbpressed, x, y       'Get mouse data„    „    IF y <= 6 * mm THEN                        'Detect when mouse is on menu„      op = Menu                                'Call EasyMenu function„      LOCATE 13, 1: PRINT STRING$(20, " ")„      LOCATE 13, 1„      SELECT CASE op„     „        CASE 0„          PRINT "No choice selected."„       „        CASE 1„          PRINT "New"„     „        CASE 2„          PRINT "Open"„     „        CASE 3„          PRINT "Save"„     „        CASE 6„          PRINT "Exit"           'Quit program„          finished = true„     „        CASE 4, 5, 7 TO 50„          PRINT "Not defined!!"„     „      END SELECT„     „      LOCATE 15, 1: PRINT "You choice was menu option #"; op„      LOCATE 17, 1: PRINT "This is mode ";„     „      IF mm = 1 THEN„        PRINT "13";„      ELSE„        PRINT "12";„      END IF„     „      PRINT " to try mode"„     „      IF mm = 1 THEN„        PRINT "12";„      ELSE„        PRINT "13";„      END IF„      PRINT " change the constant mm"„      LOCATE 20, 1: PRINT "Choose exit to quit."„     „   END IF„  LOOP UNTIL finished„  HideMouse„   „ELSE„  PRINT "Mouse not found!!!"„END IF„„END„„SUB CallMouse (ax, bx, cx, dx, es)„'Get data by calling ML program.„DEF SEG = VARSEG(Mouse(0))„CALL Absolute(ax, bx, cx, dx, es, VARPTR(Mouse(0)))„DEF SEG„END SUB„„SUB ClearMouse„'Clear mouse buffer.„DO„  DataMouse lbpressed, rbpressed, x, y„LOOP WHILE rbpressed OR lbpressed„END SUB„„SUB DataMouse (lbpressed, rbpressed, x, y)„'Return current x, y position of mouse and if a button is pressed.„ax = 3„CallMouse ax, bx, cx, dx, es„„IF mm = 2 THEN div = 1 ELSE div = 2„x = cx \ div„y = dx„„lbpressed = (bx AND 1) <> 0„rbpressed = (bx AND 2) <> 0„END SUB„„SUB Font13 (text$, x, y, col)„fp$ = ""„FOR t = 1 TO LEN(text$)„  letter$ = UCASE$(MID$(text$, t, 1))„  IF letter$ = "A" THEN„                              fp$ = fp$ + "u4r2d2nl2d2br2"„    ELSEIF letter$ = "B" THEN fp$ = fp$ + "u4r2d2nl2d2nl2br2"„    ELSEIF letter$ = "C" THEN fp$ = fp$ + "nr2u4r2bd4br2"„    ELSEIF letter$ = "D" THEN fp$ = fp$ + "u4r1f1d2g1l1br4"„    ELSEIF letter$ = "E" THEN fp$ = fp$ + "nr2u2nr1u2r2bd4br2"„    ELSEIF letter$ = "F" THEN fp$ = fp$ + "u2nr1u2r2bd4br2"„    ELSEIF letter$ = "G" THEN fp$ = fp$ + "nr2u4r2bd2d2br2"„    ELSEIF letter$ = "H" THEN fp$ = fp$ + "u4bd2r2nu2d2br2"„    ELSEIF letter$ = "I" THEN fp$ = fp$ + "r2l1u4nl1r1bd4br2"„    ELSEIF letter$ = "J" THEN fp$ = fp$ + "nu1r2u4nl1r1bd4 br2"„    ELSEIF letter$ = "K" THEN fp$ = fp$ + "nu4bu2ne2f2br2"„    ELSEIF letter$ = "L" THEN fp$ = fp$ + "nu4r2br2"„    ELSEIF letter$ = "M" THEN fp$ = fp$ + "u4f2e2d4br2"„    ELSEIF letter$ = "N" THEN fp$ = fp$ + "u4f4u4bd4br2"„    ELSEIF letter$ = "O" THEN fp$ = fp$ + "br1h1u2e1f1d2g1br3"„    ELSEIF letter$ = "P" THEN fp$ = fp$ + "u4r2d2nl2bd2br2"„    ELSEIF letter$ = "Q" THEN fp$ = fp$ + "br1h1u2e1r1f1d2g1l1bu1br1f1r1br2"„    ELSEIF letter$ = "R" THEN fp$ = fp$ + "u4r2d2l2f2br2"„    ELSEIF letter$ = "S" THEN fp$ = fp$ + "r2u2l2u2r2bd4br2"„    ELSEIF letter$ = "T" THEN fp$ = fp$ + "br1u4nl1r1bd4br2"„    ELSEIF letter$ = "U" THEN fp$ = fp$ + "nu4r2nu4br2"„    ELSEIF letter$ = "V" THEN fp$ = fp$ + "bu4d3f1e1u3bd4br2"„    ELSEIF letter$ = "W" THEN fp$ = fp$ + "nu4e2f2u4bd4br2"„    ELSEIF letter$ = "X" THEN fp$ = fp$ + "ne4br4nh4br2"„    ELSEIF letter$ = "Y" THEN fp$ = fp$ + "br1u2l1u2br2d2l1bd2br3"„    ELSEIF letter$ = "Z" THEN fp$ = fp$ + "nr2u1e2u1l2bd4br4"„    ELSEIF letter$ = "0" THEN fp$ = fp$ + "u4r2d4nl2br2"„    ELSEIF letter$ = "1" THEN fp$ = fp$ + "br1u4g1br1bd3br2"„    ELSEIF letter$ = "2" THEN fp$ = fp$ + "nr2u1e2u1l2bd4br4"„    ELSEIF letter$ = "3" THEN fp$ = fp$ + "r2u2nl2u2nl2bd4br2"„    ELSEIF letter$ = "4" THEN fp$ = fp$ + "bu2nu2r2nu2d2br2"„    ELSEIF letter$ = "5" THEN fp$ = fp$ + "r2u2l2u2r2bd4br2"„    ELSEIF letter$ = "6" THEN fp$ = fp$ + "bu2r2d2l2u4r2bd4br2"„    ELSEIF letter$ = "7" THEN fp$ = fp$ + "bu3u1r2d4br2"„    ELSEIF letter$ = "8" THEN fp$ = fp$ + "nr2u4r2d2nl2d2br2"„    ELSEIF letter$ = "9" THEN fp$ = fp$ + "br2u4l2d2r2bd2br2"„    ELSE fp$ = fp$ + "br1"„  END IF„NEXT„'Change size of font for screen mode.„IF mm = 2 THEN size$ = "s8 c" ELSE size$ = "s4 c"„„location$ = size$ + STR$(col) + " bm" + STR$(x) + "," + STR$(y) + " x"„DRAW location$ + VARPTR$(fp$)            'Print data.„END SUB„„SUB HideMouse„ax = 2„CallMouse ax, bx, cx, dx, es„END SUB„„FUNCTION InitMouse„'Write ML routine to memory.„d$ = "5589E5568B760E8B048B760C8B1C8B760A8B0C8B76088B148B76068E04CD338B760E89048B760C891C8B760A890C8B760889148B76068C045E5DCB"„DEF SEG = VARSEG(Mouse(0))„FOR t = 0 TO 87„  POKE VARPTR(Mouse(0)) + t, VAL("&H" + MID$(d$, t * 2 + 1, 2))„NEXT„'Check for mouse.„ax = 0„CallMouse ax, bx, cx, dx, es„InitMouse = ax„END FUNCTION„„FUNCTION Menu„'This function returns a unique number for an option that is chosen and well„'displaying and erasing the sub-menus.„DIM smenu(1)„rightside = 319 * mm      'Edges of sub-menu„leftside = 0              '„BottomSide = 199          '„mc = 0„SubMenuPrinted = false„pc = 0„'----------------------------------------------------------------------------„'Main Menu routine„DO„  GOSUB GetMouseInfo„  IF y <= 6 * mm THEN                  'If mouse on main menu area...„    pc = mc„    FOR t = 1 TO nmmo                  'Locate option picked.„      IF x < xloc(t) THEN EXIT FOR„    NEXT„    mc = t„    IF mc = nmmo + 1 THEN              'Erase if not on a main menu option.„      GOSUB EraseOldMenu               ' thats the far right area.„    ELSE„      IF mc <> pc THEN                 'If different choice then print menu.„        IF SubMenuPrinted THEN         'Erase if leaving one menu option for„          GOSUB EraseOldMenu           ' another.„        END IF„        GOSUB PrintNewMenu             'and print new sub-menu.„      ELSE„        IF NOT SubMenuPrinted THEN GOSUB PrintNewMenu„      END IF„    END IF„  ELSEIF y > 6 * mm AND SubMenuPrinted THEN  'On sub-menu area.„    pc = mc„    mmchoice = 0                             'Set choice to zero.„    GOSUB MoveHighLight                      'Highlight current option.„    IF mmchoice <> 0 THEN EXIT DO            'If choice selected exit loop.„  ELSEIF y > 6 * mm AND NOT SubMenuPrinted THEN 'Leaving sub-menu below main.„    EXIT DO„  END IF„LOOP„„IF SubMenuPrinted THEN„  GOSUB EraseOldMenu„  IF pc <> 0 THEN pc = pc - 1„  Menu = mmchoice + pc * nsmo            'Calculate the unique number.„ELSE                                     'No option picked leaving function.„  Menu = 0                               'Set Menu to no option.„END IF„EXIT FUNCTION„'----------------------------------------------------------------------------„MoveHighLight:„pjump = 10 * mm„preWordIndex = 1„DO                'Find new highlight option.„  HideMouse„  WordIndex = 0: yy = y„  jump = 3 * mm: choice = 0„ „  IF yy > 9 * mm THEN„    DO„      WordIndex = WordIndex + 1„      IF yy > jump + (6 * mm) THEN„        IF smd(mc, WordIndex) = "-" THEN„          jump = jump + 8 * mm„          WordIndex = WordIndex + 1„          choice = choice + 1„        ELSE„          jump = jump + 7 * mm„          choice = choice + 1„        END IF„      ELSE„        WordIndex = WordIndex - 1„        EXIT DO„      END IF„    LOOP UNTIL WordIndex = da(mc, 1)„        'Only redraw if a different option is choosen.„    IF preWordIndex <> WordIndex THEN„        'Erase old highligh and reprint option.„      LINE (emm1 + 3, pjump)-(emm3 - 3, pjump + (6 * mm)), smBackCol, BF„      Font13 smd(mc, preWordIndex), emm1 + 5, pjump + 5 * mm, smfontcol„        'Print new highlight and option.„      LINE (emm1 + 3, jump)-(emm3 - 3, jump + 6 * mm), HighLightCol, BF„      Font13 smd(mc, WordIndex), emm1 + 5, jump + 5 * mm, smfontcol„     „      preWordIndex = WordIndex„      pjump = jump„    END IF„  END IF„  ShowMouse„  GOSUB GetMouseInfo„        'User picks a choice.„  IF lbpressed THEN mmchoice = choice„        'If leaving sub-menu boundaries then erase.„  IF x < leftside OR x > rightside OR y > BottomSide THEN GOSUB EraseOldMenu„„LOOP WHILE SubMenuPrinted AND y > 6 * mm AND NOT lbpressed„RETURN„'----------------------------------------------------------------------------„EraseOldMenu:„IF SubMenuPrinted THEN„  HideMouse„ „  'Erase sub-menu by replacing what was under it.„  PUT (emm1, 7 * mm), smenu, PSET„ „  'Redraw main menu option highlight and word.„  LINE (emm1, 6 * mm)-(emm2 - 1, 0), mmBackCol, BF„  Font13 smd(0, emm0), emm1 + 2, 5 * mm, mmfontcol„  SubMenuPrinted = false„  rightside = 319 * mm„  leftside = 0„  BottomSide = 199„  ShowMouse„END IF„RETURN„'----------------------------------------------------------------------------„PrintNewMenu:„HideMouse„'Calculate data used in drawing sub-menu.„emm0 = mc„emm1 = xloc(mc - 1)„emm2 = xloc(mc)„emm3 = emm1 + da(mc, 2) + 9„emm4 = (12 + (da(mc, 1) - da(mc, 3)) * 7 + da(mc, 3)) * mm„„'Define sides of sub-menu boundaries.„rightside = emm3„leftside = emm1„BottomSide = emm4„SubMenuPrinted = true„„'Highlight main menu option and print option.„LINE (emm1, 6 * mm)-(emm2 - 1 * mm, 0), mmHLCol, BF„Font13 smd(0, mc), emm1 + 2, 5 * mm, mmfhcol„„'Save area where menu will be printed, and draw sub-menu background, outline,„'and highlight.„REDIM smenu((emm3 - emm1 + 1) * (emm4 - (7 * mm) + 1) / 2 + 2)„GET (emm1, 7 * mm)-(emm3, emm4), smenu„LINE (emm1, 7 * mm)-(emm3, emm4), smBackCol, BF„LINE (emm1 + 2, 9 * mm)-(emm3 - 2, emm4 - 2 * mm), outlinecol, B„LINE (emm1 + 3, 10 * mm)-(emm3 - 3, 16 * mm), HighLightCol, BF„„'Draw seperating lines and print options.„jump = 9 * mm„FOR t = 1 TO da(mc, 1)„  IF smd(mc, t) = "-" THEN„    jump = jump + 1 * mm„    LINE (emm1 + 3, jump)-(emm3 - 2, jump), outlinecol„  ELSE„    jump = jump + 6 * mm„    Font13 smd(mc, t), emm1 + 5, jump, smfontcol„    jump = jump + 1 * mm„  END IF„NEXT„ShowMouse„RETURN„'----------------------------------------------------------------------------„GetMouseInfo:„'Clear mouse buffer.„ClearMouse„'Get current location storing in px and py„DataMouse lbpressed, rbpressed, x, y„px = x„py = y„„'Wait until mouse has moved or a button is selected.„DO„  DataMouse lbpressed, rbpressed, x, y„LOOP UNTIL px <> x OR py <> y OR lbpressed OR rbpressed„RETURN„END FUNCTION„„SUB MenuInit„'Find number of items for each main menu item and also the length of the„'longest item.„FOR i = 0 TO nmmo„  INums = 0„  counter = 0: count = 0: pcount = 1„  HiCounter = 0„  FOR t = 1 TO LEN(Sm(i))„    letter$ = UCASE$(MID$(Sm(i), t, 1))„    IF letter$ = "," THEN„      INums = INums + 1„      smd(i, INums) = MID$(Sm(i), pcount, count)„      pcount = pcount + count + 1„      count = 0„      IF counter > HiCounter THEN HiCounter = counter„      counter = 0„    ELSE„      IF INSTR("MNWXQ", letter$) <> 0 THEN„        length = 6 * mm„      ELSEIF INSTR("ABCDEFGHIJKLOPRSTUVYZ", letter$) <> 0 THEN„        length = 4 * mm„      ELSEIF letter$ = "-" THEN„        da(i, 3) = da(i, 3) + 1„        length = 0„      ELSEIF letter$ = " " THEN„        length = 1„      ELSEIF INSTR("0123456789", letter$) <> 0 THEN„        length = 3 * mm„      END IF„      count = count + 1„      counter = counter + length„    END IF„  NEXT„  da(i, 1) = INums„  da(i, 2) = HiCounter„NEXT„'-----„'Compute location for x; used to detect which option is choosen.„xloc(0) = 0„total = 0„count = 0„FOR t = 1 TO LEN(Sm(0))„  letter$ = UCASE$(MID$(Sm(0), t, 1))„  IF INSTR("MNWXQ", letter$) <> 0 THEN„    total = total + 6 * mm„  ELSEIF INSTR("ABCDEFGHIJKLOPRSTUVYZ", letter$) <> 0 THEN„    total = total + 4 * mm„  ELSEIF letter$ = " " THEN„    total = total + 1 * mm„  ELSEIF INSTR("0123456789", letter$) <> 0 THEN„    total = total + 3 * mm„  ELSEIF letter$ = "," THEN„    total = total + 3„    count = count + 1„    xloc(count) = total„  END IF„NEXT„'-----„'Draw main menu and display options.„LINE (0, 0)-(320 * mm, 6 * mm), mmBackCol, BF„FOR t = 1 TO nmmo„  Font13 smd(0, t), xloc(t - 1) + 2, 5 * mm, mmfontcol„NEXT„END SUB„„SUB PutMouse (x, y)„ax = 4„cx = x„dx = y„CallMouse ax, bx, cx, dx, es„END SUB„„SUB SetPointerMouse„'Create a new smaller pointer for the mouse.„DIM ms(1 TO 32) AS INTEGER„„RESTORE Mouse„FOR t = 1 TO 32„  READ ms(t)„NEXT„„ax = 9„IF mm = 1 THEN bx = 8 ELSE bx = 5   'Move column of cursor hot spot.„cx = 0„dx = VARPTR(ms(1))„es = VARSEG(ms(1))„CallMouse ax, bx, cx, dx, es„END SUB„„SUB ShowMouse„ax = 1„CallMouse ax, bx, cx, dx, es„END SUB„„SUB SpeedMouse (x, y, d)„'Define mickey/pixel ratio.„'How many mickeys per 8 pixel.„ax = 15„cx = x                        'Default 8.„dx = y                        'Default 16.„CallMouse ax, bx, cx, dx, es„„'Define double-speed threshold.„'If speed exceeds threshold, the cursor's motion is doubled.„ax = 19„dx = d                        '0 = default for 64/second„CallMouse ax, bx, cx, dx, es„END SUB„„SUB XYMouse (x1, y1, x2, y2)„'Set boundaries.„ax = 7„cx = x1„dx = x2„CallMouse ax, bx, cx, dx, es„ax = 8„cx = y1„dx = y2„CallMouse ax, bx, cx, dx, es„END SUB„