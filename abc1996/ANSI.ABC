Tyler Barnes                   DISPLAY ANSI FILE WITH MUSIC   FidoNet QUIK_BAS Echo          11-16-95 (18:07)       QB, QBasic, PDS        126  3568     DISPANSI.BAS' On November 16, 1995 at 6:07 PM  Tyler Barnes replied to some other guy:„„' > Does anyone out there know how to display ansi in Qbasic?„„'Here's something... It supports the common ANSI escape codes, and ANSI music. „'This was written by someone else, modified by myself to support ANSI music, „'and to work on 24 lines instead of 25... and some other stuff. If for some „'reason you don't like this one, I have another routine written in full by „'myself. It's a bit bigger, and doesn't support ANSI music, but I've found that„'it works better in some cases. It also seems to be easier to add escape codes, „'but that might be just because I know EXACTLY how it works.„„DECLARE SUB ShowFile(FileName$)„DECLARE SUB PrintANSI(Text$,LF)„CONST Yes=1,No=0„SUB PrintANSI(Text$,LF)„LF$=LTRIM$(STR$(LF))„DEF SEG=&HB800„DEFINT A-Z„STATIC W,E,L,F,B,O,V,E$,Music,MBuff$„C=(((CSRLIN-1)*80)+(POS(0)-1)):L=CSRLIN-1„IF C>=1920 THEN MaxSize=2000 ELSE MaxSize=1920„FOR I=1 TO LEN(Text$)„A$=MID$(Text$,I,1):GOSUB ANSI„NEXT I:GOTO EndItAll„ANSI:„IF W<99 THEN W=100:F=7:B=0:A=0:Music=No:MBuff$=""„IF Music=Yes THEN GOTO Music„IF E <> 27 THEN„IF ASC(A$) <> 27 THEN GOSUB CHRout: ELSE E=27:E$=A$„TCP=C„RETURN„END IF„IF O <> 27 AND ASC(A$)=34 THEN O=E:RETURN„IF O=27 THEN„IF ASC(A$)=34 THEN O=0„RETURN„END IF:E$=E$+A$„IF LEN(E$)=2 AND A$ <>"[" THEN E=0:E$="":RETURN„S=INSTR("HfABCDsuJKmM",A$)„SELECT CASE S„CASE 0:RETURN„CASE 1:GOSUB CursorA„CASE 2:GOSUB CursorA„CASE 3:L=-1:GOSUB CursorL„CASE 4:L=1:GOSUB CursorL„CASE 5:L=1:GOSUB CursorC„CASE 6:L=-1:GOSUB CursorC„CASE 7:V=C„CASE 8:C=V„CASE 9:CLS :C=0„CASE 10:L=C:WHILE L MOD 80 <> 0:POKE L*2,32:L=L+1:WEND„CASE 11:GOSUB Colorz„CASE 12:Music=Yes„END SELECT:E=0:E$="":RETURN„CursorA:L=VAL(MID$(E$,INSTR(E$,"[")+1))„C=VAL(MID$(E$,INSTR(E$,";")+1))„IF C>0 THEN C=(C-1):IF C>79 THEN C=79„IF L>0 THEN L=(L-1):IF L>24 THEN L=24„C=L*80+C:RETURN„CursorL:P=VAL(MID$(E$,INSTR(E$,"[")+1))„P=P-(P<1):L=INT(C/80)+P*L„IF L<0 THEN L=0: ELSE IF L>24 THEN L=24„C=(C MOD 80)+L*80:RETURN„CursorC:P=VAL(MID$(E$,INSTR(E$,"[")+1))„P=P-(P<1):L=(C MOD 80)+P*L:C=INT(C/80)*80„IF L<1 THEN L=0: ELSE IF L>79 THEN L=79„C=C+L:RETURN„Colorz:E$=MID$(E$,INSTR(E$,"[")+1)„DO:E=VAL(E$)„SELECT CASE E„CASE 0:F=7:B=0„CASE 1:F=(F AND 7) OR 8„CASE 5:B=(B AND 7) OR 8„CASE 8:F=B„CASE 30 TO 37:P=E-29:E=ASC(MID$("@DBFAECG",P)) AND 7„F=(F AND 248) OR E„CASE 40 TO 47:P=E-39:E=ASC(MID$("@DBFAECG",P)) AND 7„B=(B AND 248) OR E„END SELECT:P=INSTR(E$,";"):E$=MID$(E$,P+1)„LOOP WHILE P>0:RETURN„CHRout:P=ASC(A$)„IF P=7 THEN BEEP:RETURN„IF P=13 THEN C=C-C MOD 80:RETURN„IF P=10 THEN C=C+80„IF P=12 THEN CLS :C=0:L=0„IF P=8 AND C>0 THEN C=C-1:POKE C*2,32„IF P <> 10 AND P <> 12 AND P <> 8 THEN POKE C*2+1,F+16*B:POKE C*2,P:C=C+1„IF C>=MaxSize THEN„C=C-80:LOCATE 24,80:PRINT„END IF:RETURN„Music:„MBuff$=MBuff$+A$„IF A$ <>"" THEN RETURN„IF UCASE$(LEFT$(MBuff$,1))="F" THEN MBuff$=RIGHT$(MBuff$,LEN(MBuff$)-1)„MBuff$="MB"+RTRIM$(LTRIM$(LEFT$(MBuff$,LEN(MBuff$)-1)))„PLAY MBuff$„MBuff$="":E$="":Music=No„RETURN„EndItAll:„LF=VAL(LF$)„LOCATE INT(C/80)+1,C-((INT(C/80))*80)+1„COLOR F,B„IF LF=Yes THEN PRINT„DEF SEG„EXIT SUB„END SUB„DEFSNG A-Z„SUB ShowFile(FileName$)„Z%=FREEFILE„OPEN FileName$ FOR INPUT AS Z%:CLOSE Z%„OPEN FileName$ FOR BINARY AS Z%„Remaining%=LOF(Z%)„DO UNTIL Remaining%=0„IF Remaining%>=4096 THEN„ThisPass%=4096„ELSE„ThisPass%=Remaining%„END IF„Data$=INPUT$(ThisPass%,Z%)„PrintANSI Data$,No„Remaining%=Remaining%-ThisPass%„LOOP„CLOSE Z%„END SUB„„Kurt Kuzba                     QB ANSI EMULATOR               FidoNet QUIK_BAS Echo          11-17-95 (00:18)       QB, QBasic, PDS        99   3837     QBANSI.BAS  'An unknown gentleman asked this question:„„'>   i have just wrote a communications program, and it doesn't have„'>   ansi emulation. can anyone tell me how to use ansi ... ?„'>..................................................................„„' And Kurt Kuzba replied:„„'   You may use the CONSOLE for output, assuming that ANSI.SYS or„'some other ANSI interpreter is loaded, like this.„'   OPEN "CONS:" FOR OUTPUT AS #1: PRINT #1 Ansi$;: CLOSE 1„'Or you may use an internal emulator or library.„ '|================  begin ANSISUB.BAS  ==============================|„ '|  This is a QBasic SUB to display ANSI files without the use of    |„ '|  ANSI.SYS, using direct screen writes.                            |„ '|          Released to the Public Domain by Kurt Kuzba              |„ '|===================================================================|„DECLARE SUB ansi (A$)„ON ERROR GOTO Done: i$ = STRING$(16, " ") + STRING$(15, CHR$(29))„COLOR 2, 0: CLS : f$ = COMMAND$: PRINT f$„IF f$ = "" THEN„   LOCATE 5, 10: PRINT "File to display ";„   COLOR 1, 7: PRINT i$; : INPUT "", f$:„END IF„IF f$ = "" THEN GOTO Done„COLOR 2, 0: OPEN f$ FOR BINARY AS #1„WHILE NOT EOF(1)„   f$ = INPUT$(1024, #1): l% = LEN(f$)„   FOR t% = 1 TO l%: ansi (MID$(f$, t%, 1)): NEXT„WEND„Done:„   CLOSE 1: COLOR 2, 0: FOR S% = 5 TO 35: SOUND S% * 200, .1: NEXT„   R$ = "": WHILE R$ = "": R$ = INKEY$: WEND: END„SUB ansi (A$)„DEF SEG = &HB800„DEFINT A-Z: STATIC W, E, l, C, O, M, f, B, V, E$„IF W < 99 THEN W = 100: C = 0: f = 7: B = 0: A = 0: M = f + 16 * B„IF E <> 27 THEN„   IF ASC(A$) <> 27 THEN GOSUB CHRout:  ELSE E = 27: E$ = A$„   EXIT SUB„END IF„IF O <> 27 AND ASC(A$) = 34 THEN O = E: EXIT SUB„IF O = 27 THEN„   IF ASC(A$) = 34 THEN O = 0„   EXIT SUB„END IF: E$ = E$ + A$„IF LEN(E$) = 2 AND A$ <> "[" THEN E = 0: E$ = "": EXIT SUB„S = INSTR("HfABCDsuJKmhlp", A$)„SELECT CASE S„  CASE 0: EXIT SUB„  CASE 1: GOSUB CursorA„  CASE 2: GOSUB CursorA„  CASE 3: l = -1: GOSUB CursorL„  CASE 4: l = 1: GOSUB CursorL„  CASE 5: l = 1: GOSUB CursorC„  CASE 6: l = -1: GOSUB CursorC„  CASE 7: V = C„  CASE 8: C = V„  CASE 9: CLS : C = 0„  CASE 10: l = C: WHILE l MOD 80 <> 0: POKE l * 2, 32: l = l + 1: WEND„  CASE 11: GOSUB Colorz„END SELECT: E = 0: E$ = "": EXIT SUB„CursorA: l = VAL(MID$(E$, INSTR(E$, "[") + 1))„   C = VAL(MID$(E$, INSTR(E$, ";") + 1))„   IF C > 0 THEN C = (C - 1): IF C > 79 THEN C = 79„   IF l > 0 THEN l = (l - 1): IF l > 24 THEN l = 24„   C = l * 80 + C: RETURN„CursorL: P = VAL(MID$(E$, INSTR(E$, "[") + 1))„   P = P - (P < 1): l = INT(C / 80) + P * l„   IF l < 0 THEN l = 0:  ELSE IF l > 24 THEN l = 24„   C = (C MOD 80) + l * 80: RETURN„CursorC: P = VAL(MID$(E$, INSTR(E$, "[") + 1))„   P = P - (P < 1): l = (C MOD 80) + P * l: C = INT(C / 80) * 80„   IF l < 1 THEN l = 0:  ELSE IF l > 79 THEN l = 79„   C = C + l: RETURN„Colorz: E$ = MID$(E$, INSTR(E$, "[") + 1)„  DO: E = VAL(E$)„  SELECT CASE E„     CASE 0: f = 7: B = 0„     CASE 1: f = (f AND 7) OR 8„     CASE 5: B = (B AND 7) OR 8„     CASE 8: f = B„     CASE 30 TO 37: P = E - 29: E = ASC(MID$("@DBFAECG", P)) AND 7„                    f = (f AND 248) OR E„     CASE 40 TO 47: P = E - 39: E = ASC(MID$("@DBFAECG", P)) AND 7„                    B = (B AND 248) OR E„  END SELECT: P = INSTR(E$, ";"): E$ = MID$(E$, P + 1)„  LOOP WHILE P > 0: M = f + 16 * B: RETURN„CHRout: P = ASC(A$)„   IF P = 7 THEN BEEP: RETURN„   IF P = 13 THEN C = C - C MOD 80: RETURN„   IF P = 10 THEN C = C + 80„   IF P <> 10 THEN POKE C * 2, P: POKE C * 2 + 1, M: C = C + 1„   IF C >= 2000 THEN„      C = C - 80: LOCATE 25, 80: PRINT„      FOR l = 3680 TO 3840: POKE l, PEEK(l + 160): POKE l + 160, B: NEXT„   END IF: RETURN„END SUB„ '|===================  end ANSISUB.BAS  =========================|„David A. Wicker                BETTER ANSI TO BASIC CONVERTER david@fastlane.net             01-13-96 (17:44)       QB, QBasic, PDS        201  7119     ANSIBAS.BAS DEFINT A-Z„DECLARE SUB ReadANSI (T$)„DECLARE SUB SaveANSI (F$)„„' * FREEWARE Submission to better ANSI to BASIC„' * Written by David A. Wicker (david@fastlane.net)„„' * Reason: other could not handle complex ANSI pictures„'           my version is quite a bit smaller and produces smaller„'           Q-Basic 4.5 merge source.„            „' * NOTE!  Does not handle FLASHING (but neither did other) :)„„DEF SEG = &HB800„„Again:„  CLS„  LOCATE 12„  PRINT "* ANSI TO BASIC MERGE CONVERTOR WRITTEN BY DAVID A. WICKER *"„  PRINT„  DO„    INPUT "(C)onvert ANSI / (S)ee Sample / (E)xit :", T$„  LOOP UNTIL T$ = "C" OR T$ = "S" OR T$ = "E"„  IF T$ = "E" THEN END„„  IF T$ = "S" THEN„    RESTORE SampleANSI„    T$ = ""„    FOR I = 1 TO 96„      READ A$„      T$ = T$ + A$„    NEXT„    ReadANSI T$„Pause:„    LOCATE 24, 1„    PRINT "Press any key to continue:";„    DO: LOOP UNTIL INKEY$ > ""„    GOTO Again„  END IF„„  IF T$ = "C" THEN„GetName:„    PRINT„    INPUT "Path and Name of ANSI picture: I.E. \ansi\test.ans: ", F$„    IF F$ = "" THEN GOTO Again„    ON ERROR GOTO NotFound„    OPEN "I", 1, F$„    CLOSE„    SaveANSI F$„    PRINT "ANSI.INS saved on current path."„    PRINT "Use Q-Basic 4.5 (F)ile & (M)erge to extract"„    GOTO Pause„  END IF„„END„„NotFound:„  PRINT "* ERROR *  ANSI FILE NOT FOUND!"„  RESUME GetName„„SampleANSI:„DATA "›&€$ﬂ$€$ﬂ$€$ $›&€$ﬂ$ﬂ$€$ $›&€$ﬂ$ﬂ$€$ $›&"„DATA "€$ $›&€$ﬂ$ﬂ$€$ $ $ $ﬂcﬂc c c c c‹r‹r‹r‹r"„DATA "‹r r r r rﬂcﬂc * * * * * * * * * * * *H1"„DATA "e1y1 1K1i1d1s1.1.1.1 * * * * * * * * * *"„DATA "›&€$ $ $ $€$ $›&€$‹$‹$€$ $›&€$‹$‹$€$ $›&"„DATA "€$ $›&€$ $ $€$ $ﬂc c c c c c c€rﬂr rﬂr r"„DATA "ﬂr€r r r r r r rﬂc * * * * * * * * *ø/ /"„DATA "ø/ * * * * * * * * * * * * * * * * * * *"„DATA "›&€$ $ $ $€$ $›&€$‹2€2€$‹2›&€$ $ﬂ$‹$ $›&"„DATA "€$ $›&€$‹$‹$ﬂd d d d d d d d€r€r r€r r€r"„DATA " r€r€r r r r r r rﬂc * * * * * * * *≥///"„DATA "ø/⁄/ƒ/ø/⁄/ƒ/ø/⁄/ƒ/ø/ * * * * * * * * * *"„DATA "∞C±C≤C *∞C±C≤C *ﬂ2€2€2€2€2€2‹2 2∞C±C≤C *"„DATA "∞C±C≤C *∞C c€'ﬂ'ﬂ'ﬂ' '‹'‹'‹'‹'‹'‹'‹'‹'‹'"„DATA "‹'‹'‹'‹'‹' '‹c‹c‹c c c * * * * * * *Ÿ/ /"„DATA "Ÿ/¿/ƒ/ƒ/¿/ƒ/ƒ/√/ƒ/Ÿ/ * * * * * * * * * *"„DATA " / / /‹2€2€2‹2 2 2 2€2€2€2€2€2€2‹2 * * *"„DATA " * * * * r€' '‹'€'€'€'€'ﬂ'ﬂ'ﬂ'ﬂ'ﬂáﬂáﬂáﬂá"„DATA "ﬂ'ﬂ'ﬂ'ﬂ'€á€á€á€á‹' ' g g * * * * * * * *"„DATA " * * * * * * *Ÿ/ * * * * * * * * * * * *"„DATA " / /€2€2€2€2€2€2‹2 2∞Cﬂ2€2€2€2€2€2€2‹2±C"„DATA "≤C *∞C±C‹c *€'€'›'≤É≤É *ﬂÉ É ÉﬂÉ * É É *"„DATA "ﬂÉ É ÉﬂÉ *≤É≤Éﬁ'€'€' '‹c * * * * *⁄/ƒ/ø/"„DATA " / / /./⁄/./ * * * * * * * * * * * * * *"„DATA " / / /ﬂ2€2€2€2€2€2€2‹2 2 2€2€2€2€2€2€2€2"„DATA "‹2 2 2 rﬂc€'›'≤É≤É É É Éﬂ)ﬂ)ﬂ) â â â â â"„DATA " â‹É‹É‹É É É É≤É≤Éﬁ'€'ﬂc c * * * *¿/ƒ/ø/"„DATA "⁄/¬/ø/ø/≥/ø/¬/ƒ/ø/⁄/ƒ/ø/ * * * * * * * *"„DATA " / /≤C *∞Cﬂ2€2€2€2€2€2€2‹2 2ﬂ2€2€2ﬂ2ﬂ2 2"„DATA "‹2‹2‹2 2‹c›'≤É≤É É É É›)€2€2€2›É É É É É"„DATA "ﬁÉ€2€2€2›É É É É≤É≤Éﬁ'‹c * * * * *¿/ƒ/Ÿ/"„DATA "Ÿ/ /Ÿ/Ÿ/Ÿ/Ÿ/Ÿ/ /Ÿ/¿/ƒ/¥/ * * * * * * * *"„DATA " * * * * * * * *ﬂ2€2€2€2ﬂ2ﬂ2€2‹2›2‹2€2€2"„DATA "€2€2€2€2 2≤É≤É É É Éﬁ2€2€2€2ﬂBﬂB›É É ÉﬁÉ"„DATA "ﬂBﬂB€2€2€2›2€)€)€)≤É≤É * * * * * * * * *"„DATA " * * * * * * * * * *ƒ/Ÿ/ * * * * * * * *"„DATA " / /∞C±C≤C *∞C±C≤C‹2‹2‹2€2€2‹2ﬂ2 2€2€2€2"„DATA "ﬂ2 2ﬂÉﬂÉﬂÉ *≤É≤É ÉﬁÉ€2€2ﬂB Bﬂ$ 4 * Ñ Ñ *"„DATA " 4ﬂ$ 4ﬂB€2€2›É É≤É≤É *ﬂÉﬂÉﬂÉ * * * * * *"„DATA "a1n1d1 1S1n1u1f1f1 * * * * * * * * * * *"„DATA " * * * * * * * *€2€2€2€2€2€2€2€2‹2 2ﬂ2 2"„DATA " í í í í í íﬁÉ≤É≤É É›)€2 B *˛2ﬁ$›É É ÉﬁÉ"„DATA "›$˛2 2 B€2ﬁ) â≤É≤É›É É É É É É É * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * *∞C±C≤C * *ﬂ2‹2‹2ﬂ2€2ﬂ2ﬂ2‹2€2€2 í"„DATA " í í í í\É É É *‹É É É ÉﬂíﬂÉﬂÉﬁ) â â â â"„DATA "›)ﬂÉﬂÉﬂí í í í‹É * É É/É É É É É É *t1h1"„DATA "o1s1e1 1S1n1i1f1i1t1s1 * * * * * * * * *"„DATA " * * * * * * * *€2€2€2€2€2‹2ﬂ2€2€2€2ﬂ2€2"„DATA " í í í í/É É ÉﬂÉ * *‹É É É Éﬁ) â â â â â"„DATA " â›) â â â‹É * *ﬂÉ É É\É É É É É * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * *∞C±Cﬂ2€2€2€2‹2‹2€2€2ﬂ2‹2€2€2"„DATA "€2 2ﬂ)ﬂ) â â›É ÉﬂÉ * * * * * *ﬂ)€)€)€)€)"„DATA "ﬂ) * * * * * *ﬂÉ ÉﬁÉ É É‹É‹É * * * *∞C±C"„DATA "≤C *∞C±C≤C *∞C±C≤C *∞C±C≤C * * * * * * *"„DATA "‹'‹'‹'‹' * * * * * *ﬂ2ﬂ2ﬂ2ﬂ2ﬂ2 2ﬂ2€2€2ﬂ2"„DATA "‹'€'€'€'€'‹' á á áﬂÉ * * * * * * * * * *"„DATA " * * * * * *ﬂÉ É É É‹' g g‹'‹'‹'€'€'€' g"„DATA " g g g‹' * * * * * * * * * * * * * * * *"„DATA "ﬁ2€2›2›2 2 2 2 2∞C±C≤C *∞C±C≤C *∞C±C≤C c"„DATA " c c c c c c‹' á á á á áﬂÉﬂÉ *€'‹'‹'‹'‹'"„DATA "€' 'ﬂÉﬂÉ É É É É É‹' g g g g g g g g g g"„DATA " g g g g g * * *∞C±C≤C *∞C±C≤C * * * * *"„DATA "‹'‹'‹'‹' * * * * * * * * * * * * * * * *"„DATA " g g g g g g g‹$ﬂ) â â â â â âﬂÉﬂ'ﬂ'ﬂ'ﬂ'"„DATA "ﬂÉ É É É É É Éﬂ)‹$ d d d d d d d * d d d"„DATA " d d d d d d * * * * * * * * * * * * * *"„DATA "ﬁ2€2›2›2 * * * * * *∞C±C≤C *∞C±C≤C *∞C±C"„DATA "≤Cﬂ' g g g g g€$€$‹$ﬂ)ﬂ)ﬂ)ﬁ) â â â â â â"„DATA " â â›)ﬂ)ﬂ)ﬂ)‹$€$€$ d d d d d d * d d d d"„DATA " d d d d d d d±C≤C *∞C±C≤C * * * * * * *"„DATA "‹'‹'‹'‹' * * * * * * * * * * * * * * * *"„DATA " * * * g g g€$€$€$€$ d d d‹'‹'ﬂ)ﬂ)ﬂ)ﬂ)ﬂ)"„DATA "ﬂ)‹'‹' g g g€$€$€$€$ d d d *‹' g g g g g"„DATA " g g g g g g * * * * * * * * * * * * * *"„DATA "ﬁ2€2›2›2 2 2 2 2∞C±C≤C *∞C±C≤C *∞C±C≤C *"„DATA "∞C±C≤C * c€$€$€$€$€$€$ d d d d d d d d d"„DATA " d d d d d€$€$€$€$€$€$ d *€2 2ﬂ'ﬂ'ﬂ'ﬂ'ﬂ'"„DATA "ﬂ'ﬂ'ﬂ'ﬂ'ﬂ'‹2 2 2∞C±C≤C *∞C±C≤C * * * * *"„DATA "‹'‹'‹'‹' * * * * * * * * * * * * * * * *"„DATA " * * * *ﬂ' g€$€$€q€q€$€$ d€$€$€$€$€$€$€$"„DATA "€$€$€$ d€$€$€A€A€$€$ dﬂ' ' '€2€2€2€2€2€2"„DATA "€2€2€2€2€2ﬂ2 * * * * * * * * * * * * * *"„DATA "ﬁ2€2›2›2 2 2∞C±C≤C *∞C±C≤C *∞C±C≤C *∞C±C"„DATA "≤C *∞C±C≤C * *ﬂ$ 4 4ﬂ$ﬂ3 3 3 3 3 3 3 3 3"„DATA " 3 3 3 3ﬂ3ﬂ$ 4 4ﬂ$ $ $ $ $€2€2€2ﬂ2€2€2ﬂ2"„DATA "€2€2ﬂ2€2€2€2∞C±C≤C *∞C±C≤C * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„DATA " * * * * * * * * * * * * * * * * * * * *"„„DEFINT A-Z„SUB ReadANSI (T$)„  FOR I = 0 TO 23„    FOR J = 0 TO 79„      N = I * 160 + J * 2„      A = ASC(MID$(T$, N + 1, 1))„      IF A = 255 THEN A = 34„      POKE N, A„      B = ASC(MID$(T$, N + 2, 1))„      POKE N + 1, B - 35„    NEXT„  NEXT„END SUB„„DEFINT A-Z„SUB SaveANSI (F$)„  Q$ = CHR$(34)„  SHELL "TYPE " + F$„  OPEN "O", 1, "ANSI.INS"„  FOR I = 0 TO 24„    FOR J = 0 TO 79„      IF J = 0 OR J = 20 OR J = 40 OR J = 60 THEN„        IF I > 0 OR J > 0 THEN PRINT #1, Q$„        PRINT #1, "DATA " + Q$;„      END IF„      N = I * 160 + J * 2„      A = PEEK(N)„      IF A < 32 THEN A = 32„      IF A = 255 THEN A = 32„      IF A = 34 THEN A = 255„      B = PEEK(N + 1)„      B = B MOD 128„      PRINT #1, CHR$(A); CHR$(B + 35);„    NEXT„  NEXT„  PRINT #1, Q$„  CLOSE„END SUB„„David J. Arigan                ANSI DISPLAY                   FidoNet QUIK_BAS Echo          02-03-96 (16:21)       QB, QBasic, PDS        135  4082     ANSIDISP.BASDECLARE SUB ansiout (s$)„„' ANSI display V1.1 - Written by David Arigan„' You can use this freely provided you mention me in your credits.„„DEFINT A-Z„„OPEN "picture.ans" FOR BINARY AS #1„„blen& = 4096: buf$ = SPACE$(blen&): flen& = LOF(1)„WHILE flen&„  IF blen& > flen& THEN blen& = flen&: buf$ = SPACE$(flen&)„  GET #1, , buf$: flen& = flen& - blen&: ansiout buf$„WEND„CLOSE„„SUB ansiout (s$) STATIC„  DIM parm$(16)„  IF init = 0 THEN„    init = -1„    fc = 7: bc = 0: cfx = 0: blink = 0„    lx = 1: ly = 1„    DEF SEG = &H0„    xl = PEEK(&H44A) + 256 * PEEK(&H44B)„    yl = PEEK(&H44C) + 256 * PEEK(&H44D) \ 2 \ xl„    cc$ = "000402140105031500040206010503070812101409131115"„  END IF„  COLOR VAL(MID$(cc$, (fc + cfx) * 2 + 1, 2)) OR blink„  COLOR , VAL(MID$(cc$, bc * 2 + 1, 2)) AND 7„  FOR i = 1 TO LEN(s$)„    a$ = MID$(s$, i, 1)„    IF a$ = CHR$(10) THEN a$ = "" ' ***** Linefeed fix„    SELECT CASE sq$„    CASE ""„      IF a$ = CHR$(27) THEN sq$ = a$ ELSE PRINT a$;„    CASE CHR$(27)„      IF a$ = "[" THEN sq$ = sq$ + a$: parm = 0 ELSE anserr = 1„    CASE ELSE„      sq$ = sq$ + a$„      SELECT CASE a$„      CASE "0" TO "9"„        IF parm = 0 THEN parm = 1: parm$(1) = ""„        parm$(parm) = parm$(parm) + a$„      CASE ";", ","„        parm = parm + 1: parm$(parm) = ""„      CASE "=", "?"„      CASE "@"„        sq$ = ""„      CASE "A"„        IF parm = 0 THEN y = CSRLIN - 1 ELSE y = CSRLIN - VAL(parm$(1))„        IF y < 0 THEN y = 1„        LOCATE y: sq$ = ""„      CASE "B"„        IF parm = 0 THEN y = CSRLIN + 1 ELSE y = CSRLIN + VAL(parm$(1))„        IF y > yl THEN y = yl„        LOCATE y: sq$ = ""„      CASE "C"„        IF parm = 0 THEN x = POS(0) + 1 ELSE x = POS(0) + VAL(parm$(1))„        IF x > xl THEN x = xl„        LOCATE , x: sq$ = ""„      CASE "D"„        IF parm = 0 THEN x = POS(0) - 1 ELSE x = POS(0) - VAL(parm$(1))„        IF x < 0 THEN x = 1„        LOCATE , x: sq$ = ""„      CASE "f", "H"„        SELECT CASE parm„        CASE 0„          y = 1: x = 1„        CASE 1„          y = VAL(parm$(1))„        CASE ELSE„          y = VAL(parm$(1)): x = VAL(parm$(2))„        END SELECT„        IF y > yl THEN y = yl„        IF y < 1 THEN y = 1„        IF x > xl THEN x = xl„        IF x < 1 THEN x = 1„        LOCATE y, x: sq$ = ""„      CASE "h", "l"„        sq$ = ""    ' *** set/reset graphics mode„      CASE "J"„        IF parm = 1 AND VAL(parm$(1)) = 2 THEN CLS„        sq$ = ""„      CASE "K"„        x = POS(0): PRINT SPACE$(xl - x); : LOCATE , x: sq$ = ""„      CASE "L"„        sq$ = ""    ' *** Inserts n blank lines at cursor line.„      CASE "M"„        sq$ = ""    ' *** Deletes n lines including cursor line.„      CASE "m"„        FOR j = 1 TO parm„          SELECT CASE VAL(parm$(j))„          CASE 0„            fc = 7: bc = 0: cfx = 0: blink = 0„          CASE 1„            cfx = 16„          CASE 2„            cfx = 8„          CASE 4    ' *** Underscore on„          CASE 5„            blink = 16„          CASE 7„            SWAP fc, bc„          CASE 8    ' *** Attributes Invisible„          CASE 30 TO 37„            fc = VAL(parm$(j)) - 30„          CASE 40 TO 47„            bc = VAL(parm$(j)) - 40„          END SELECT„          COLOR VAL(MID$(cc$, (fc + cfx) * 2 + 1, 2)) OR blink„          COLOR , VAL(MID$(cc$, bc * 2 + 1, 2)) AND 7„        NEXT j„        sq$ = ""„      CASE "n"„        sq$ = ""    ' *** ESC[6n asks for a Position Report„      CASE "P"„        sq$ = ""    ' *** Deletes n chars including cursor char.„      CASE "p"„        BEEP„        sq$ = ""    ' *** Keyboard Reassignment„      CASE "R"„        sq$ = ""    ' *** Cursor Position Report„      CASE "s"„        lx = POS(0): ly = CSRLIN: sq$ = ""„      CASE "u"„        LOCATE ly, lx: sq$ = ""„      CASE "y"„        sq$ = ""    ' *** Output char translate.„      CASE ELSE„        anserr = 1„      END SELECT„    END SELECT„    IF anserr THEN anserr = 0: PRINT sq$; : i = i - 1: sq$ = ""„  NEXT i„END SUB„Kurt Kuzba                     IMPORT ANSI INTO BASIC FUNCTIONFidoNet QUIK_BAS Echo          10-06-96 (08:23)       QB, QBasic, PDS        65   3210     ANSIFUNC.BAS'>   ansi for a menu in a quickbasic program without having„'>   the ansi in a seperate file that has to be loaded and„'>   without ansi.sys loaded. Is this possible?„'>...........„'   Yes. It is. This will put the .ANS into code, and, in„'another message, I post an ANSI interpreter. It should be next.„„ '|======================  begin ANSIFUNC.BAS  =======================|„ '|  This is a QBasic program to convert an ANSI file to a QBasic     |„ '|  FUNCTION that will return the file as a string. In the program   |„ '|  this program produces, the function is called and the resulting  |„ '|  string is output to CONSOLE, which requires ANSI.SYS loaded.     |„ '|          Released to the Public Domain by Kurt Kuzba              |„ '|===================================================================|„ ' set error trap, set colors, clear screen, q$ = quote mark ==========„ON ERROR GOTO Done: COLOR 2, 0: CLS : q$ = CHR$(34)„ ' create a string for the input boxes  ===============================„i$ = STRING$(16, " ") + STRING$(15, CHR$(29))„ ' print message and get filename from user, open file for input ======„LOCATE 5, 10: PRINT "We will turn an ANSI file into a QBasic function"„LOCATE 6, 10: PRINT "which returns the entire ANSI file as a string."„LOCATE 8, 10: PRINT "Enter ANSI name [ EX. MYPIC.ANS ] ";„COLOR 1, 7: PRINT i$; : INPUT "", ans$: COLOR 2, 0„IF ans$ <> "" THEN OPEN ans$ FOR INPUT AS #1:  ELSE GOTO Done„ ' get name of function to create from user ===========================„LOCATE 10, 10: PRINT "Enter Function name [ EX. Pic1$ ] ";„COLOR 1, 7: PRINT i$; : INPUT "", func$: COLOR 2, 0„ ' make FUNCTION name and open file for input =========================„IF func$ = "" THEN GOTO Done„IF RIGHT$(func$, 1) <> "$" THEN func$ = func$ + "$"„name$ = func$ + ".bas": OPEN name$ FOR OUTPUT AS #2„ ' write QBasic FUNCTION to file ======================================„PRINT #2, "DECLARE FUNCTION "; func$; "()"„PRINT #2, "open "; q$; "CONS:"; q$; " FOR OUTPUT AS #1"„PRINT #2, "PRINT #1, "; func$„PRINT #2, "FUNCTION "; func$„PRINT #2, "t$ = "; q$; q$„ ' process ANSI to create QBasic routine to construct string ==========„WHILE NOT EOF(1)„   WHILE NOT EOF(1)„      PRINT #2, "t$=t$+"; q$; : C$ = ""„      WHILE C$ <> CHR$(10) AND NOT EOF(1)„         C$ = INPUT$(1, #1)„         IF C$ = CHR$(13) THEN„            C$ = q$ + " + CHR$(13) + CHR$(10)" + CHR$(13) + CHR$(10)„         END IF„         IF C$ <> CHR$(10) THEN PRINT #2, C$;„      WEND„   WEND„WEND„ ' finish writing QBasic FUNCTION to file =============================„PRINT #2, q$„PRINT #2, func$; "=t$"„PRINT #2, "END FUNCTION"„ ' done, tell user new program is ready, wait for key =================„LOCATE 12, 10: COLOR 10„PRINT "Your new program, "; name$; ", containing the FUNCTION"„LOCATE 13, 10: PRINT func$; ", to display "; ans$; ", is ready to test."„LOCATE 14, 10: PRINT "ANSI.SYS must be loaded for "; name$; " to work."„Done:  CLOSE 1: CLOSE 2: C% = 0: i$ = ""„WHILE i$ = ""„   C% = (C% + 1) AND 15: LOCATE 15, 10: COLOR C%: PRINT "Hit a Key"„   i$ = INKEY$„WEND: COLOR 2„ '|  ===============  end ANSIFUNC.BAS  ==============================|„