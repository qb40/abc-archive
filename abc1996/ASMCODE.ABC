Ethan Winer                    TRAP CTRL-ALT-DEL              BASIC Techniques               Year of 1991           TASM, MASM             90   3209     NOREBOOT.BAS;NOREBOOT.ASM, traps Ctrl-Alt-Del within a BASIC program„„;Copyright (c) 1991 Ethan Winer„„„;Syntax: CALL NoReboot(BYVAL InstallFlag%)„;„;Where InstallFlag is non-zero to install the TSR, or zero to deinstall it.„„„.Model Medium, Basic„.Code„„NoReboot Proc Uses DS, InstallFlag:Word„„  Cmp  InstallFlag,0     ;do they want to install the routine?„  Je   Deinstall         ;no, go deinstall it„  „  Cmp  CS:Old9Seg,0      ;yes, but have we already been installed?„  Jne  Exit              ;yes, and don't do that again!„„  Mov  AX,3509h          ;ask DOS for the existing Int 9 vector address„  Int  21h               ;DOS returns the segment:address in ES:BX„  Mov  CS:Old9Adr,BX     ;save it locally„  Mov  CS:Old9Seg,ES„„  Mov  AX,2509h          ;point Interrrupt 9 to our own handler„  Mov  DX,Offset NewInt9„  Push CS                ;copy CS into DS„  Pop  DS„  Int  21h„„Exit:„  Ret                    ;return to BASIC„„„;-- Control comes here each time a key is pressed or released.„NewInt9:„  Sti                    ;enable further interrupts„  Push AX                ;save the registers we'll be using„  Push DS„„  In   AL,60h            ;get the scan code from the keyboard„  Cmp  AL,83             ;is it the Delete key?„  Jnz  Continue          ;no, continue on to BIOS interrupt 9„„  Xor  AX,AX             ;see if the Alt and Ctrl keys are down„  Mov  DS,AX             ;by looking at address 0:417h„„  Mov  AL,DS:[417h]      ;get the shift status at 0000:0417h„  Test AL,8              ;is Alt key depressed?„  Jz   Continue          ;no, continue on to BIOS interrupt„  Test AL,4              ;is Ctrl key depressed?„  Jz   Continue          ;no, continue on to BIOS interrupt„„  In   AL,61h            ;send an acknowledge to keyboard„  Mov  AH,AL             ;otherwise the Ctrl-Alt-Del keystroke„  Or   AL,80h            ;  will still be hanging around the„  Out  61h,AL            ;  next time a program goes to get a key„  Mov  AL,AH„  Out  61h,AL„  Mov  AL,20h            ;indicate end of interrupt to 8259„  Out  20h,AL            ;  interrupt controller chip„„  Pop  DS                ;ignore, and simply return to caller„  Pop  AX„  Iret                   ;use this special form of Ret instruction„                         ;  when returning from an interrupt routine„„Continue:„  Pop  DS                ;restore the saved registers„  Pop  AX„  Jmp  DWord Ptr CS:Old9Adr   ;continue on to BIOS interrupt 9„                              ;  by jumping to the address that„                              ;  was saved during initialization„„DeInstall:„  Mov  AX,2509h          ;restore the original Int 9 handler„  Mov  DX,CS:Old9Adr     ;from the segment and address saved earlier„  Mov  DS,CS:Old9Seg„  Int  21h               ;DOS does this for us„  Mov  CS:Old9Seg,0      ;clear this so we can tell we're not installed„  Jmp  Short Exit        ;and then exit back to BASIC„„NoReboot Endp„„  Old9Adr   DW 0         ;these remember the original Int 9 address„  Old9Seg   DW 0         ;they must be in the code segment because„                         ;  DS is undefined when NewInt9 gets control„End„Stephan Van Loendersloot       ASSEMBLY IN QBASIC             FidoNet QUIK_BAS Echo          12-15-95 (21:45)       QB, QBasic, PDS        53   1923     ASMBAS.BAS  '> While I got through your twit filter somehow ;) To those who are„'> trying to use my GUI Interface in QBasic (instead of QuickBasic 4.5),„'> it won't work - you'll need to use DOS Calls CALL INTERRUPT command in„'> QuickBasic.  QBasic won't support those.  BUT, I will try to get at it„'> and make a QBasic version sometime soon.„„'> Anyone know how to convert CALL INTERRUPT stuff into PEEK & POKE?...„„'Here I am...again ;-)„„'It's pretty easy to use assembly stuff in QBasic. It's not possible to write„'variables in registers via Basic. The following is an example of how to„'incorporate some assembly in Qbasic. It does not attempt to do anything very„'ambitious. It only beeps the speaker, but that's not the point. Point is how to„'use assembly in QBasic (GWBasic also accepts it, but line number have to be„'added).„„'Now here's what you need to do.„'First write the program / routine that you wish to use in Basic, in assembly.„'My program doesn't do much, as I already stated:„„mov ah, 2       ; Write a character to screen„mov dl, 7       ; Ascii character 7 (= bell)„int 21h         ; Call to DOS„retf            ; Far return to transfer control back to BASIC„„(BTW. I skipped the 'push bp' etc. since I don't use any variables passed to„the function).„Once assembled, this translates to the following bytes:„„&HB4, &H02, &HB2, &H07, &HCD, &H21, &HCB„„This has to be written to memory and executed.„„DIM Beeper%(1)„MemoryLoc% = VARPTR(Beeper%(1))„'mov ah, 2„POKE MemoryLoc%, &HB4„POKE MemoryLoc% + 1, &H2„'mov dl, 7„POKE MemoryLoc% + 2, &HB2„POKE MemoryLoc% + 3, &H7„'int 21h„POKE MemoryLoc% + 4, &HCD„POKE MemoryLoc% + 5, &H21„'retf„POKE MemoryLoc% + 6, &HCB„CALL ABSOLUTE(Returnvalue%, VARPTR(Beeper%(1))„„ReturnValue% isn't used.„„'I know it could be much more optimized, but I wanted to give an oversimplified„'example, so everyone can understand it.„PC Magazine                    DOS FONT GENERATOR             FidoNet QUIK_BAS Echo          02-06-96 (14:00)       ASM                    80   2727     FONTGEN.ASM ' > > the PC Magazine FONT.COM program, which will alter the DOS font.„' > > then let you save it in a COM file to load up the font.. Cool, hu„'„' > You bet! I use to do alot of assembly programing when I was into„' > RSDOS. Used the old EDTASM program. It was amazing how fast the„' > programs were concerning the Coco(s) only had a 1.75 Mz CPU.„„.model tiny     ; This program only 587 bytes long (I think)„.stack 0FFh     ; Lots of "stack"„.code           ; Start the code„„; Make sure you are in video mode 3 (text mode)„mov ah,0„mov al,3„int 10h„„; BIOS routine to load user defined character font„push cs         ; Address ds and es to code segment„pop ds          ; Tedious, but necessary„push cs„pop es          ; This register "is" used in this routine.„mov ax,1100h    ; BIOS function to load user_specified font„mov bh,14       ; number of bytes_per_character in table (below)„mov bl,0        ; character generator RAM block„mov cx,1        ; number of character we are going to change„mov dx,'T'      ; first (only) character we are changing„push bp         ; address character generation table„mov bp,offset figure2   ; choose figure1 or figure2, or define own.„jmp over                ; jump over this "data", to not confuse compiler„„;----- Below, is the table that defines the new font.„figure1 db        00000000b     ; A HAPPY FACE replaces normal "T"„        db        00000000b„        db        11100111b     ; A 1 means the "dot" is visible„        db        11100111b     ; A 0 means the "dot" is invisible„        db        00000000b„        db        00111100b„        db        00111100b„        db        00000000b„        db        10000001b„        db        11000011b„        db        01100110b„        db        00111100b„        db        00000000b„        db        00000000b„;„;  Comment out the "font" that you don't wish to use.„;„figure2 db        11111111b     ; MY NAME "Tim" replaces normal "T"„        db        00001000b„        db        00001000b„        db        00001000b„        db        00000000b„        db        00001000b„        db        00001000b„        db        00001000b„        db        00001000b„        db        00000000b„        db        11000011b„        db        10100101b„        db        10011001b„        db        10011001b„„over:„„int 10h„pop bp          ; ANYTIME bp is changed, always push_and_pop it.„„; DOS routine to send character to screen„mov dl,'T'      ; Our newly defined font„mov ah,2„int 21h„„; pause screen so you can see what the new font will look like„xor ax, ax      ; zero the whole register, though only 'ah' is used.„int 16h„„mov ah,4Ch„int 21h„end„Luis Espinoza                  BIT MANIPULATORS LIBRARY       QBTIPS_H.DOC                   10-05-92 (12:35)       ASM, QB, PDS           160  4337     BITMAN.ASM  ' Bitman.Bi„' Bit Manipulators Library„' Written By: Luis Espinoza„' This Library is PUBLIC DOMAIN„' All functions return the result„' Bit% range 0-15„' Byte% is a 16 bit word (Integer) to look at„' Byte2% is an integer for the math functions (Band,Bor,Bxor)„„declare function LShift%(ByVal Byte%,ByVal Bit%)        'Shift Left„declare function RShift%(ByVal Byte%,ByVal Bit%)        'Shift Right„declare function ReadBit%(ByVal Byte%,ByVal Bit%)       'Read Bit in Byte„declare function ResetBit%(ByVal Byte%,ByVal Bit%)      'Reset Bit in Byte (0)„declare function SetBit%(ByVal Byte%,ByVal Bit%)        'Set Bit in Byte (1)„declare function ToggleBit%(ByVal Byte%,ByVal Bit%)     'Toggle Bit„declare function Band%(ByVal Byte1%,ByVal Byte2%)       'Binary And„declare function Bor%(ByVal Byte1%,ByVal Byte2%)        'Binary Or„declare function BXor%(ByVal Byte1%,ByVal Byte2%)       'Binary Xor„declare function BOC%(ByVal Byte1%)                     'Ones Compliment„„;Written in TASM„„.Model Medium, Basic„.Code BITMAN„„LSHIFT  proc, ByteVal:Word, Bit:Word„„        mov     ax,[ByteVal]„        mov     cx,[Bit]„        shl     ax,cl„        ret„„LSHIFT  endp„„RSHIFT  proc, ByteVal:Word, Bit:Word„„        mov     ax,[ByteVal]„        mov     cx,[Bit]„        shr     ax,cl„        ret„„RSHIFT  endp„„READBIT proc, ByteVal:Word, Bit:Word„„        mov     ax,[ByteVal]„        mov     dx,1„        mov     cx,[Bit]„        shl     dx,cl„        test    dx,ax„        je      @1„        mov     ax,1„        jmp     @2„@1:„        xor     ax,ax„@2:„        ret„READBIT endp„	„„RESETBIT proc, ByteVal:Word, Bit:Word„„        mov     ax,1„        mov     cx,[Bit]„        shl     ax,cl„        mov     dx,[ByteVal]„        not     dx„        and     ax,dx„        ret„„RESETBIT endp„„SETBIT  proc, ByteVal:Word, Bit:Word„„        mov     ax,1„        mov     cx,[Bit]„        shl     ax,cl„        or      ax,[ByteVal]„        ret„„SETBIT  endp„„TOGGLEBIT proc, ByteVal:Word, Bit:Word„„        mov     ax,1„        mov     cx,[Bit]„        shl     ax,cl„        xor     ax,[ByteVal]„        ret„„TOGGLEBIT endp„„BAND    proc, ByteVal1:Word, ByteVal2:Word„„        mov     ax,[ByteVal1]„        and     ax,[ByteVal2]„        ret„„BAND    endp„„BOR     proc, ByteVal1:Word, ByteVal2:Word„„        mov     ax,[ByteVal1]„        or      ax,[ByteVal2]„        ret„„BOR     endp„„BXOR    proc, ByteVal1:Word, ByteVal2:Word„„        mov     ax,[ByteVal1]„        xor     ax,[ByteVal2]„        ret„„BXOR    endp„„BOC     proc, ByteVal1:Word„„        mov     ax,[ByteVal1]„        not     ax„        ret„„BOC     endp„„        public  READBIT„        public  TOGGLEBIT„        public  RESETBIT„        public  SETBIT„        public  RSHIFT„        public  LSHIFT„        public  BXOR„        public  BOR„        public  BAND„        public  BOC„        end„„„„CLS:?STRING$(50,177):?"Creating: BITMAN.OBJ with Postit!"„DEFINT A-Z:FOR A=0 TO 6:P(A)=2^A:NEXT:OPEN "B",1,"BITMAN.OBJ"„T$="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789()"„G"aYaakiusu1uqo5sqt1eOiccaaaav1jNyVbsqZnxzTjgBLjhiGyvzYnxAV5giY4s„G"nXiiIsaaqPhdJVJHccLevnfKtUe0unvkIdaaqPZKLcaaaOH4aaauOuAPeaSGqjr„G"vtb50xuvewurWqprurpJ5baGeaaiWabmHLmaqbFruqufebefevbjmMhaasaaabf„G"eWdw2aagiusu1uqorWqprur9H5baGeQayWbbmMLiaGbeDKupvfulQjbaGW)cKfK„G"paaadGGufnvrujusuTdaaKlKkaaadmGqpneNaaa8qQaaamWac9Kuccaa7dzdaaW„G"agmvrujusuffaa4dKlaaadqGqy9KupcaauczdaaWagi1uiLKru9aaaShKlaaadq„G"Gqb5er1baaudPdaaWahivrbrKqjrLhaaWpq2aaamGbmnfsjzevaaaaqcjeaaWaj„G"q1thDetfjusungaaafIeaaqIgqKGYkadaaavTi7lAecl6KbtdExktaavTi7lAec„G"l6KbtJExktaavTi7lAec6gaal6KbtlEHqtxb4gaaRlWma3LYeaqvlYoUbaWIozW„G"0GVOviCV0JiCxktaavTi74gaal6Kbtd(cgHqxktaavTi74gaal6Kbtd(mgHqxkt„G"aavTi7lAecJyKbDPmbau1ISVOriSGrg0LYeaqvlY(IgHWmgzqxktaavTi7lAKb3„G"dDxklaaGROaaaaD"„N=531:K=255:IF LEN(C$)<>708 THEN ?"Incomplete script file!":BEEP:END„FOR A=1 TO N:LOCATE 1:?STRING$(50*(A/N),8):IF L=0 THEN GOSUB G:L=6„W=T\P(6-L):GOSUB G:W=W OR T*P(L):L=L-2:B$=CHR$(W AND K):PUT 1,,B$:NEXT„?:IF C<>86 THEN ?"Bad checksum!":BEEP:END ELSE ?"Success!":END„G:I=I+1:T=INSTR(T$,MID$(C$,I,1))-1:C=(C+T)*2:C=C\256+(C AND„255):RETURN„SUB G(A$):SHARED C$:C$=C$+LEFT$(A$,63):END SUB„Tony Elliott                   MONITOR SHELL & GET ERRORLEVEL QBTIPS_?.DOC                   12-23-92 (14:35)       ASM                    87   2521     MONSHELL.ASM; MonitorShell (MONSHELL.ASM)„„; Written by Tony Elliott„„; EllTech Development, Inc.„; 4374 Shallowford Industrial Parkway„; Marietta, GA 30066„; (404) 928-8960 Voice or (404) 928-7111 BBS (DS)„„; Released into the public domain.„„; This routine is written for Microsoft QuickBASIC 4.x, BASIC 6.x and Microsoft„; PDS 7.x. Assemble using MASM 5.1:  MASM MONSHELL;„„; You can link it directly to your program, place it in a LINK library (.LIB)„; or a .QLB.„„; To use it:„„;   DECLARE SUB MonitorShell ()„;   DECLARE FUNCTION FetchErrorLevel% ()„;„;   CALL MonitorShell„;   SHELL "PkZip -Xxy"„;   PRINT "ErrorLevel returned from SHELL:";FetchErrorLevel%„„.model medium, basic„.code„„Old21        Label Dword        ;Label pointing to old Int 21h handler„Old21Offset  dw ?               ;Offset part„Old21Segment dw ?               ;Segment part„MonitorSet   db 0               ;Our "hooked" flag„ExitCode     db ?               ;Where we store the exit code„„MonitorShell proc uses ds„„    ; From BASIC: CALL MonitorShell„„    cmp cs:MonitorSet,0         ;Are we already hooked?„    jnz MonitorExit             ;If so, exit„    mov ax,3521h                ;Get current vector for int 21h„    int 21h„    mov cs:Old21Segment,es      ;Remember it for later„    mov cs:Old21Offset,bx„    mov ax,2521h„    push cs„    pop ds                      ;Point int 21h handler to our code„    mov dx, offset OurInt21„    int 21h„    mov cs:MonitorSet,-1        ;Set our flag„„MonitorExit:„    ret„„OurInt21:                       ;Our Int 21h handler„    cmp ah,4ch                  ;Is it a 'terminate' request?„    jnz Continue                ;If not, continue on„„    mov cs:ExitCode,al          ;Remember the exit code„    push ax„    push ds„    mov ax,2521h                ;Unhook ourself after the first hit„    mov ds,Old21Segment„    mov dx,Old21Offset„    int 21h                     ;Point Int 21h back to original„handler„    pop ds„    pop ax„    mov cs:MonitorSet,0         ;Set out flag back to zero„    „Continue:„    jmp dword ptr [Old21]       ;Transfer control to original Int 21h„„MonitorShell endp„„FetchErrorLevel proc„„    ;From BASIC: DECLARE FUNCTION FetchErrorLevel%„    ;            PRINT "Last errorlevel:"; FetchErrorLevel%„„    mov al,cs:ExitCode          ;Put the errorlevel into al„    xor ah,ah                   ;Zero ah„    ret                         ;ErrorLevel returned as result„„FetchErrorLevel endp„    end„Daniel Garlans                 DEBUG ASM CONVERTER            garlans@usa.pipeline.com       07-29-96 (17:10)       QB, QBasic, PDS        116  6028     DEBUGASM.BAS'DEBUG ASM Converter Version 1.0a Rewrite 1 „'Written by: White Shade of DuoTech „'(Real Name: Daniel Garlans) „'This program is freeware. „'You may use this code any way you like, just give me credit =] „'Information on conversion from a FAQ by Ian Muskgrave (sorry if I misspelled) „'My E-Mail Address: garlans@usa.pipeline.com „'This converts DEBUG-ASM (debug < name.dbg > out.asm) into CALL ABSOLUTE strings „'and saves them and code for use into an out file. „'This is rewrite 1 because my first version was written at about 9:30 to 10:30 pm „'and I was tired and so it was huge, messy and wasn't working, so the next day „'I wrote it entirely from scratch :) „'Absolutly needed in the file to convert from: „'-U in a line to show where the HEX Code output started and -Q in a line to„„'show what line the output ends on. Format of a converted line in result file: „'ASM$=ASM$+whatevertoadd 'offset = xxxx:xxxx hex code:whateverthehexis „'the ASM$ can be changed to whatever. „'Sub Cp prints t$ in the center of row l! in 80 column text mode. „'Have fun with this :) It's fully commented. „'you can do whatever you want with it... „'THINGS 2 KNOW: No error handling...Still some optimizing to do...quite fast... „'can convert something like a 16k file (I don't have anything that big to test with) „ „DECLARE SUB Cp (t$, l!) „CLS „'print a headline :) „COLOR 15, 1 'set background to dark blue, foreground to bright white „LOCATE 1, 1: PRINT STRING$(80, " ") 'make first line be all dark blue „CALL Cp("DebugASM Converter 1.0a", 1) 'use Cp to write the text to the center „COLOR 7, 0 'make colors normal „INPUT "File to Convert:"; a$: file$ = UCASE$(a$) 'get filename and make it uppercase „INPUT "File to write to:"; a$: outfile$ = UCASE$(a$)'get output name and make it uppercase „INPUT "String to write to:"; a$: cnme$ = UCASE$(a$)'get string name in output file and make it uppercase „PRINT " Converting: " + file$               'display info „PRINT " Saving output to: " + outfile$      'ditto „PRINT " Converted Code String: " + cnme$    'ditto „OPEN file$ FOR INPUT AS #1 'Open Files „OPEN outfile$ FOR OUTPUT AS #2 'Open Files „st = 0 'start pos... if still 0 after next block, error :) „en = 0'end pos...ditto „PRINT "Finding start of hex code values"; „DO WHILE NOT EOF(1) 'Loop until end of the file „  LINE INPUT #1, a$ 'get a line (commas etc allowed) „  c$ = UCASE$(a$) 'convert to uppercase „  IF INSTR(c$, "-U") THEN 'Is -U in it? (indicates start of hex code) „    st = v + 1 'If it is, make the start equal the next line in file „  END IF „  IF INSTR(c$, "-Q") THEN 'Is -Q in it? (indicates end of hex code) „    en = v 'If so, make end equal this line „    END IF „  PRINT "."; 'Display a dot to show that the proggy is working :) „  v = v + 1 'Increase current-line counter „LOOP 'duh :) „PRINT 'go to next line (because of the 'print ".";') „SEEK 1, 1 'Set current position in input file to first character (it was at the end) „'DIM lne$(1 TO v) 'Actually, This isn't needed...wonder what I was thinking.... :) „IF st = 0 OR en = 0 THEN 'Wait! If the start and end positions are STILL zero now, the program failed. „  PRINT "Error, -U or -Q not found. Unable to convert." „  CLOSE 'close files „  END 'duhh :) „END IF „ „PRINT "Moving to start of HEX code at line "; st „FOR a = 1 TO st 'loop until start line „  LINE INPUT #1, temp$ 'so the file pos is moved. „NEXT a „lnt = en - st 'amount of lines between -U and -Q „PRINT "Converting & Saving..." „FOR a = 1 TO lnt 'loop for the lines between -U and -Q „  LINE INPUT #1, a$ 'get the line to work on „  a$ = UCASE$(a$) 'make uppercase (for neatness in output) „  IF LEN(a$) > 0 THEN 'so it doesn't try to convert a blank line :) „    offse$ = LEFT$(a$, 9) 'Get Offset (always first 9 letters  xxxx:xxxx) „    toconv$ = MID$(a$, 11, 6) 'get the HEX Code to convert „    toconv$ = RTRIM$(toconv$) 'trim spaces from end „    toconv$ = LTRIM$(toconv$) '  "    "     "   start „    'dn = LEN(tonconv$) 'get length...whoops this isn't needed because... „    SELECT CASE LEN(toconv$) 'select case with the length      of this :) „      CASE 2 'maybe like CB (retf) „        fin$ = "CHR$(&H" + toconv$ + ")" 'Make the output string.. „      CASE 4 'maybe like CD33 (int 33h) „        one$ = LEFT$(toconv$, 2) 'get first two letters „        two$ = RIGHT$(toconv$, 2) 'get last two letters „        fin$ = "chr$(&H" + one$ + ") + chr$(&H" + two$ + ")" 'make output string „      CASE 6 'maybe like B80100 (mov ax,0001) „        one$ = LEFT$(toconv$, 2) 'get first two „        two$ = MID$(toconv$, 3, 2) 'get last two „        fin$ = "chr$(&H" + one$ + ") + chr$(&H" + two$ + ")" 'make output string „      CASE ELSE 'Prolly an error „        PRINT "Warning: Unknown hex string, cannot convert." „        fin$ = "" 'make output string be nothing. „    END SELECT „    IF LEN(fin$) <> 0 THEN 'do this only if the output string is more than nothing (see in CASE ELSE it sets FIN$ to nothing?) „      v$ = cnme$ + "=" + cnme$ + "+" + fin$ + " 'Offset=" + offse$ + " Hex Command= " + toconv$  'Assemble output string (see opening comments) „      PRINT #2, v$ 'write final final output string to the output file „    END IF „  END IF „NEXT a „PRINT "Writing info for code use..." „'next four lines write commented out code for the use of the converted code. „PRINT #2, "'These next commented lines are for using the converted code." „PRINT #2, "'DEF SEG=VARSEG(" + cnme$ + ")" „PRINT #2, "'theoff%=SADD(" + cnme$ + ")" „PRINT #2, "'CALL ABSOLUTE(theoff%)" „CLOSE 'close all file handles „PRINT "Conversion of Debug-Asm complete."' " + file$ + " to " + outfile$ + " in " + cnme$ 'give a little info „PRINT "Coding by: White Shade of DuoTech" 'More info „PRINT "This program is Freeware and may be freely distributed." 'and a little more.. „END 'Terminate program :) „ „SUB Cp (t$, l) „  v = 40 - (LEN(t$) / 2) „  LOCATE l, v „  PRINT t$ „END SUB „