Mike Ginger                    PRINTER LPT PORT STATUS        FidoNet QUIK_BAS Echo          01-05-97 (06:16)       QB, PDS                130  4516     LPT.BAS     '---------------------------------------------------------------------„' Note that you will need to invoke QuickBASIC with the '/L' option, ie:„'  QB /L„„' Freeware from Mike Ginger„'---------------------------------------------------------------------„„'$INCLUDE: 'QB.BI'„„„Printers:„„CLS„„	PRINT "LPT No."; TAB(10); "Address";„	PRINT TAB(23); "Bit Number and Status"; TAB(57); "Meaning"„	PRINT TAB(23); "0   1   2   3   4   5   6   7"„	PRINT "-------"; TAB(10); "---------";„	PRINT TAB(23); "-----------------------------";„	PRINT TAB(57); "---------------------"„„Printerloop:„„LOCATE 4, 1„LptPeeker% = 7„„FOR LptNum% = 1 TO 3 STEP 1„„'---------------------------------------------------------------------„„ ' Routine to get Printer Port Address's„„ DEF SEG = 64„„ Temp1$ = HEX$(PEEK((LptNum% + 1) + LptPeeker%))„ Temp2$ = HEX$(PEEK((LptNum%) + LptPeeker%))„ LptAddr$ = Temp1$ + Temp2$„„ DEF SEG„„ LptPeeker% = LptPeeker% + 1„„	PRINT LptNum%; TAB(10); LptAddr$; "h"; TAB(20);„„'---------------------------------------------------------------------„„ ' Routine to Check status of the Printer:„„    DIM inregLptStat AS RegType„    DIM outregLptStat AS RegType„„„    low% = &O0: high% = &O2„„    inregLptStat.AX = low% + (256 * high%)„     inregLptStat.dx = LptNum% - 1„    CALL INTERRUPT(&H17, inregLptStat, outregLptStat)„    PrnStatus% = outregLptStat.AX \ 256„  „„' Value will be non-zero if bit is set:               Bit     Meaning„						    ' ---     -------„PRINT USING "####"; outregLptStat.AX \ 256 AND 1;   '  0      Timeout„PRINT USING "####"; outregLptStat.AX \ 256 AND 2;   '  1      unused„PRINT USING "####"; outregLptStat.AX \ 256 AND 4;   '  2      unused„PRINT USING "####"; outregLptStat.AX \ 256 AND 8;   '  3      I/O error„PRINT USING "####"; outregLptStat.AX \ 256 AND 16;  '  4      Selected„PRINT USING "####"; outregLptStat.AX \ 256 AND 32;  '  5      Out of Paper„PRINT USING "####"; outregLptStat.AX \ 256 AND 64;  '  6      Acknowledge„PRINT USING "####"; outregLptStat.AX \ 256 AND 128; '  7      Not Busy„„' Further Information:„„' If bits are set    PrnStatus%=         Means„' ---------------    -----------         -------------------------------„' 4 AND 7            (Dec -112)          Printer On-Line and Ready„' 4                  (Dec 16)            Printer On-Line and Busy„' 3 AND 6 AND 7      (Dec -56)           Printer is Switched Off„' 3 AND 6            (Dec 72)            Printer is Switched Off„' 7                  (Dec 128)           Printer is Switched Off„' 5                  (Dec 32)            Printer is Switched Off„' 5 AND 7            (Dec -96)           Printer is Switched Off„' 3 AND 7            (Dec -120)          Printer is Off-Line„' 3                  (Dec 8)             Printer is Off-Line„' 3 AND 4            (Dec 24)            Printer is Off-Line„' 3 AND AND 4 AND 7  (Dec -108)          Printer is Off-Line„' 3 AND 5 AND 7      (Dec -108)          Printer is Out of Paper„' 3 AND 5            (Dec 40)            Printer is Out of Paper„' 3 AND 4 AND 5      (Dec 56)            Printer is Out of Paper„' 3 AND 4 AND 5 AND 7(Dec -76)           Printer is Out of Paper„' 4 AND 5            (Dec 48)            Printer Cable not connected„' 4 AND 5 AND 7      (Dec -80)           Printer Cable not connected„„„PRINT TAB(55); "  (";„„      IF LptAddr$ = "00" THEN„	PRINT "No Port Exists     ";„      ELSEIF PrnStatus% = -112 THEN„	PRINT "On-Line and Ready  ";„      ELSEIF PrnStatus% = -56 OR PrnStatus% = 72 OR PrnStatus% = 128 THEN„	PRINT "Switched Off       ";„      ELSEIF PrnStatus% = -96 OR PrnStatus% = 32 THEN„	PRINT "Switched Off       ";„      ELSEIF PrnStatus% = 8 OR PrnStatus% = -120 THEN„	PRINT "Off-Line           ";„      ELSEIF PrnStatus% = 24 OR PrnStatus% = -108 THEN„	PRINT "Off-Line           ";„      ELSEIF PrnStatus% = 16 THEN„	PRINT "On-Line and Busy   ";„      ELSEIF PrnStatus% = 40 OR PrnStatus% = -108 THEN„	PRINT "Paper Out          ";„      ELSEIF PrnStatus% = 56 OR PrnStatus% = -76 THEN„	PRINT "Paper Out          ";„      ELSEIF PrnStatus% = 48 OR PrnStatus% = -80 THEN„	PRINT "Cable Not Connected";„      ELSE„	PRINT "General Error      ";„      END IF„„PRINT ")"„„NEXT LptNum%„„'---------------------------------------------------------------------„„pause$ = INKEY$„IF pause$ <> CHR$(27) GOTO Printerloop„„'---------------------------------------------------------------------„Hans Lunsing                   INTERRUPTX IN QBASIC           FidoNet QUIK_BAS Echo          12-29-96 (13:25)       QBasic                 107  3288     INTX.BAS    ' >> Don't forget.. I'm using Qbasic.. I don't think it has interrupt„' >> capabilities..„„' > Someone posted a SUB to use Interrupts in QBasic, but I don't„' > know where you can find it. It uses CALL ABSOLUTE, which is built„' > into QBasic.„„'Here you have a sub to use interrupts in QBASIC:„„' InterruptX„' Interrupt procedure for QBASIC„' (c) 1992 Hans Lunsing„' ----------------------------------------------------------------------„DEFINT A-Z„„' Register type for use with InterruptX„„TYPE RegTypeX„  ax AS INTEGER„  BX AS INTEGER„  CX AS INTEGER„  DX AS INTEGER„  BP AS INTEGER„  SI AS INTEGER„  DI AS INTEGER„  Flags AS INTEGER„  DS AS INTEGER„  ES AS INTEGER„END TYPE„„CONST FALSE = 0, TRUE = NOT FALSE„„DECLARE SUB InterruptX (IntNo%, Inreg AS RegTypeX, OutReg AS RegTypeX)„„'-----------------------------------------------------------------------„' The machine code of the interrupt procedure for InterruptX„'-----------------------------------------------------------------------„InterruptXASM:„' Number of bytes„DATA  190„' Hexadecimal representation of machine code„DATA 55,8B,EC,8B,5E,0C,8B,17,0A,F6„DATA 74,07,C7,07,FF,FF,E9,A7,00,8B„DATA 5E,06,8B,1F,2E,88,97,77,00,32„DATA C0,80,FA,25,74,05,80,FA,26,75„DATA 02,0C,02,50,1E,06,56,57,9C,8B„DATA 76,0A,80,FA,20,7C,05,80,FA,30„DATA 7C,0A,81,7C,08,FF,FF,74,03,8B„DATA 6C,08,8B,44,0E,25,D5,0F,50,8B„DATA 04,8B,5C,02,8B,4C,04,8B,54,06„DATA 8B,7C,0C,FF,74,0A,81,7C,12,FF„DATA FF,74,03,8E,44,12,81,7C,10,FF„DATA FF,74,03,8E,5C,10,5E,9D,CD,00„DATA 55,8B,EC,9C,83,C5,0E,F6,46,FE„DATA 02,74,02,45,45,1E,56,8E,5E,FC„DATA 8B,76,08,89,04,89,5C,02,89,4C„DATA 04,89,54,06,8F,44,0A,89,7C,0C„DATA 8F,44,10,8C,44,12,8F,44,0E,8F„DATA 44,08,F6,46,FE,02,74,02,44,44„DATA 9D,5F,5E,07,1F,58,5D,CA,08,00„„'-----------------------------------------------------------------------„' Example: get current video mode„'-----------------------------------------------------------------------„DIM r AS RegTypeX„r.ax = &HF00„InterruptX &H10, r, r„VideoMode = (r.ax AND &HFF)„PRINT "Video mode is "; VideoMode„END„„SUB InterruptX (IntNo AS INTEGER, Inreg AS RegTypeX, OutReg AS RegTypeX) STATIC„'-----------------------------------------------------------------------„' Interrupt procedure. Works in the same way as its QB 4.5 counterpart.„'-----------------------------------------------------------------------„„IF NOT MachineCode% THEN„  ' First time dimension string array to hold machine code„  RESTORE InterruptXASM„  READ nASMBYTES%„  REDIM ASMBuffer(0 TO nASMBYTES% - 1) AS STRING * 1„END IF„„' Get address of machine code„DEF SEG = VARSEG(ASMBuffer(0))„Offset% = VARPTR(ASMBuffer(0))„„IF NOT MachineCode% THEN„  ' First time load string array with machine code„  FOR i% = 0 TO nASMBYTES% - 1„    READ Code$„    POKE Offset% + i%, VAL("&H" + Code$)„  NEXT i%„  ' Indicate availability of machine code„  MachineCode% = TRUE„END IF„„' Call interrupt.„' The first Offset% parameter is used by the machine code modifying it self,„' so don't leave it out.„CALL ABSOLUTE(IntNo%, Inreg, OutReg, Offset%, Offset%)„„DEF SEG„END SUB„„'Hans Lunsing,           Fido     : 2:281/607.214, 2:282/610.12„'                        Internet : jlunsing@doge.nl„Dave Navarro, Jr.              PRINT STRINGS THROUGH THE BIOS dave@powerbasic.com            02-06-97 (14:04)       PB                     22   835      BIOSPRNT.BAS'=============================================================================„'                   Source code snippet: PowerBASIC for DOS„'„'           Author: Dave Navarro, Jr. (dave@powerbasic.com)„' Copyright status: Public Domain„'„' Print strings through the BIOS.„'„'=============================================================================„„BIOSPrint "Hello World!"„„SUB BIOSPrint(X$) Static                  'print a string through the„BIOS„  Temp$ = X$ + CHR$(13) + CHR$(10)        'concatenate a CRLF to the„string„  FOR X = 1 TO LEN(Temp$)                 'for each character„    REG 1, &H0E00 + ASC(MID$(Temp$, X))   'service &HE in AH, char in AL„    REG 2, 0                              'text page zero in BH„    CALL INTERRUPT &H10                   'call the BIOS to print it„  NEXT„END SUB„Rick Elbers                    INTERRUPTS IN QBASIC 2: INSIDEQrick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        28   935      2INSIDEQ.BAS'INTERRUPTS IN 2:QBASIC HOOKING INTERRUPTS„'---------------------------------------------------------------„'RICK ELBERS december 1996„„„Q16: What interrupt vectors are changed by QBASIC ?„„A16: When Qbasic is loaded in memory then it changes„     a few interrupt vectors to point to Qbasic routines:„      „      HARDWARE INTERRUPTS HOOKED BY QBASIC:„„      INT 0   DIVIDE BY ZERO INTERRUPT„      INT 4   OVERFLOW INTERRUPT„      INT 9   KEYBOARD INTERRUPT„      INT A   LPT 2/EGA,VGA/IRQ 9„„      SOFTWARE INTERRUPTS HOOKED BY QBASIC:„„      INT 1C  TIMER TICK INTERRUPT„      INT 22  TERMINATE( ADRESS)„      INT 23  CTRL      INT 24  CRITICAL ERROR HANDLER„      INT 2E  COMMAND COM LOADER„      INT 2F  MULTIPLEX INTERRUPT„      INT 34--3F FLOATING POINT EMULATION„      INT EF  BASICs ORIGINAL INT 9 VECTOR!„      INT F0  BASICs ORIGINAL INT 8 VECTOR!„      INT F6  SOMETHING VERY SPECIAL FOR QBASIC!„Rick Elbers                    INTERRUPTS IN QBASIC 3: SIMULATrick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        422  18185    3SIMULAT.BAS'INTERRUPTS IN QBASIC 3: SIMULATING AN INTERRUPT„'--------------------------------------------------------------------------„'Rick Elbers november 1996„'-------------------------„DECLARE FUNCTION newvec& (segnewint%, offnewint%)„DECLARE FUNCTION oldvec& (nr%)„DECLARE SUB getvec (Svec%, Ovec%, nr%)„DECLARE SUB pokeW (pokeseg%, pokeoff%, word%)„DECLARE SUB pokeDW (pokeseg%, pokeoff%, dword&)„                                                „'INTRODUCTION„'-------------„'When we are concerned with interrupthandlers, then our first goal has to be„'to establish the current way interrupts are handled. When some interrupt is„'processed the processor retrieves the place to jump to (among other things).„'This place he retrieves from 0:INTNR*4. That is to say, in the lower memory„'all interrupts are mapped with a far pointer to the code for that interrupt.„'Of course, since we spoke about FAR pointers every interrupt pointer is„'a double word. That is were the INTNR*4 is coming from. The interrupt pointers„'are commonly referred to as VECTORS.„„'GETTING THE INTERRUPT VECTORS„'-----------------------------„'From inside our QBASIC ide we can get all vectors, but we have to keep„'in mind that we only retrieve vectors as QBASIC looks at them. That is to„'say that some interrupts are handled by qbasic itself, instead of by DOS.„'For instance the values for INT 0 and INT 4 are not the same that you„'get from dumping the lower memory in debug...(you are encouraged to do so..)„'But otherwise the program to execute now is very instructive...„„CLS„FOR nr% = 0 TO &HFF„getvec Vecseg%, Vecoff%, nr%„PRINT " Int "; STRING$(2 - LEN(HEX$(nr%)), "0"); HEX$(nr%); "->";„IF Vecseg% = 0 AND Vecoff% = 0 THEN„  PRINT "Not used ";„ELSE„  PRINT STRING$(4 - LEN(HEX$(Vecseg%)), "0"); HEX$(Vecseg%); ":";„  PRINT STRING$(4 - LEN(HEX$(Vecoff%)), "0"); HEX$(Vecoff%);„END IF„IF nr% MOD 4 = 3 THEN PRINT„IF nr% MOD 80 = 79 THEN SLEEP„NEXT„CLS : PRINT "press a key for next demo part"„SLEEP„„'We have seen that a lot of INTERRUPT VECTORS are free, so we can„'experiment with them. Even when after controlling the so called "FREE„'VECTORS" with debug they appear indeed free. So it is sure and safe„'to experiment with INT 83h for instance. So be it: we will start with„'developing a testcode for our newinterrupt, so that there will be no„'misunderstandings wether we execute int 83h or not. Afterwards we will„'do what is necessary to make it possible to execute int 83h. Our„'handler will do nothing fancy. He will simply print the character 'a' .„'-------„'NEWINT„'-------„DIM newint%(6)„newint%(0) = &H5052              'PUSH AX,DX„newint%(1) = &H41B2              'MOV  DL,41„newint%(2) = &H2B4               'MOV  AH,02„newint%(3) = &H21CD              'INT  21„newint%(4) = &H5A58              'POP DX,AX„newint%(5) = &HCB                'RETF„„segnewint% = VARSEG(newint%(0)): offnewint% = VARPTR(newint%(0))„'Agreed ? Well let us control him:„DEF SEG = segnewint%: CALL absolute(offnewint%)„SLEEP„'Seems to be oke, not ?„'--------------------------„'SETTING INTERRUPT VECTORS„'--------------------------„'Since we have a working handler by now, we might process with the part of„'resetting the interrupt 83h vector( currently 0:0 ) to the adress of our„'handler( currently segnewint%:offnewint%). As it turns out QBASIC„'enables our capacity to set a vector with the DOScall INT 21, 25h. At least„'on my PC this call bumps( when somebody show me otherwise i'll be delighted).„'But for know let us take the more direct route, which is: changing the adress„'stored at 0:83h*4„„setvec:„DEF SEG = 0„POKE (&H83 * 4), offnewint% AND &HFF„POKE (&H83 * 4 + 1), offnewint% \ &HFF„POKE (&H83 * 4 + 2), segnewint% AND &HFF„POKE (&H83 * 4 + 3), segnewint% \ &HFF„SLEEP„„'OKE What we did here was storing the adress of our handler„'in the interrupt vector table in the form:„'                       DW  SEG:OFF„„'Interesting enough in assembler you won't risk such a move since there„'could and in fact will be an interrupt during the writing to the vector„'adress and the vector will be stored inadekwately. One other thing:„'The interrupts are all far return adresses, which is just difficult„'language for that they are words in the form segment:offset. THIS IS„'NOT THE STANDARD WAY OF STORING A WORD! but INTEL designed it so...„'About the formulas used: ANDING AN INTEGER WITH &HFF will give you the„'High Byte since 0000 0000 1111 1111 AND .... .... .... .... will result„'in zeroing the higher byte(agreed ?). The other way around works the„'division which returns the higher byte in the lower byte.„„'[in fact it is not ! for signed integers, luckely i know the segment of„'QBASIC is not a signed value so everything will role smoothly....For code„'that is always okay for signed integers look at the POKEW and POKEDW routines]„„'controle„FOR i% = 0 TO 3„  PRINT HEX$(PEEK(&H20C + i%));„NEXT„DEF SEG„SLEEP„„'So far we seems to be oke: allright ? Well lets review a bit. It is„'called SETVEC wat we have done. It should be easy for you to make this„'into a callable sub. In general you have to poke to INTNR*4+something.„'May be it is just ok to do this first right now before going further...„„'Okay so far,so good. Now the miracle itself. Will it work ? It is easy to„'be so eager to try that you overlook one major change you have to make„'to our handler. It ended so far with RETF, but an interrupt restores the„'flags also so we have to return with an Interrupt-return(IRET):„newint%(5) = &HCF       'IRET replaces RETF„„'Okay now we are ready for the miracle. Have we developed an INTERRUPT ?„'Let's just call INT 83h and look what happens. PFFF........„DIM test%(2)„test%(0) = &H83CD      'INT 83„test%(1) = &HCB        'RETF„„CLS : DEF SEG = VARSEG(test%(0))„CALL absolute(VARPTR(test%(0)))„DEF SEG„„'I do not know what your machine is saying but mine is printing 'a' !„'Is that all ? Yes, that is all. We have passed our first exam!„„„'INTERRUPT HANDLERS:part one„'----------------------------„'When we want to intercept an important interrupt like DOS INT 21 then„'it is obvious that we first must have the ability to store the vector„'so that we can put the original vector back after we are done. Since our„'int 83 can serve further as example interrupt let us call getvec for„'int 83 and then store the vector.„„„getvec segvec%, offvec%, &H83„Savevec:„oldint83& = segvec% * 65536 + offvec%„„'We are going to store the vector in one WORDvalue since 1)It reduces our„'variables with one. Therefore adding to clarity. 2) In essence the vector„'is just one variable. And while we store him this way we can with just one„'instruction like JMP OLDint83 return to our former handler.„'For control again:„PRINT HEX$(oldint83&)„„'Agreed ? No ? Well you are right. This long integer is not really a DW„'since INTEL choosed to put the vectors in the form off(flipped):seg(flipped)„'and not in the expected seg(flipped):off(flipped) way. This might be„'a little confusing at first. But look at it this way: Because we store it„'this way oldint83& is stored in the form off:seg.When later getvec looks at„'the vectors in the table it reads excactly the offset at INTnr*4 and the„'segment at INTnr*4+2. So indeed excactly our OLDINT83&!„„„'A SHORT_LONGCUT :„'--------------------„'Well,okay say we want to interrupt int 21h because we do not like the way„'function 0ah handles function-KEYS like <F1>( it do'nt). We are capable of„'getting the vector already. Also we can store the vector in an adekwate way„'and set the vector to our code. At a certain point we want to restore the„'vector table again(Agreed ?), because we do not want to write code for all„'INt 21h functions. At least not for free.....<G>. So we have to practice one„'other thing. That is :resetting a vector from the one we stored.„„'Now let us return to our practice. We are writing int 83h. Let us now try to„'reset the vector first to 0000:0000 what it was before we were so arrogant to„'take over. This should be simple. Use setvec with SEGnewint%=0 AND OFFnewint%=0„SLEEP„DEF SEG = 0: POKE (&H83 * 4), 0: POKE (&H83 * 4 + 1), 0„POKE (&H83 * 4 + 2), 0: POKE (&H83 * 4 + 3), 0:„„'CONTROL:„getvec segvec%, offvec%, &H83„PRINT HEX$(segvec%), HEX$(offvec%)„DEF SEG„'agreed again ?„SLEEP„„'What was again the question: Oh,yes after Hooking DOS we will reset the„'vector. Since we not put an int handler which interrupted our int 83H at„'0000:0000, which we should by the way never even try, and since the concept„'of interrupting ourselves never managed to come clear to me, we just have„'to imagine we just stored our vector 0:0 at int 83h adres. So what is„'left is that we want to restore the vector after done..Since we have„'oldint83& this should be simple not ? But poke just only writes bytes!„'this means you should write your own pokeDW. Not so..?„„'DEF SEG = 0: POKEDW &H83 * 4, oldint83&: DEF SEG„'and thats it.„„'Control is now important.By the way does everybody knows that doshelp.com„'and edit.com are QBASIC programs started up with QBASIC/edcom and„'QBASIC/qhelp respectively ( so much for not compiler QBASIC ?)„„getvec segvec%, offvec%, &H83„PRINT HEX$(segvec%); HEX$(offvec%): DEF SEG = 0„FOR i% = 0 TO 3: PRINT HEX$(PEEK((&H83 * 4) + i%)): NEXT„„'Okay while this whole document might seem a little bit childish in nature„'you must agree that we are advancing...At this moment we know we can„'restore vectors after using them. A very important feature...„'Also you could have stored the two procedures SETVEC and GETVEC by now i„'guess, making your code even more evident. vecRestore is just a specific„'Setvec and Savevec& is a)evident and b) needs POKE_DW„„'To advance we have to know some basics of an Interrupthandler„'--------------------------------------------------------------„'What an interrupt does is a whole lot, so be aware: An interrupt„'does push first the flags, then pushes cs:ip(return adress),then calculates„'vector adress as we do INTnr*4 loads up ip: then cs of the INTvec. After„'done there is an IRET executed: meaning that first cs then ip then the„'flags are restored from the stack( minus the interrupt and trap flag, which„'are cleared on return).„'In CODE: 'PUSHF„          'PUSH CS„          'PUSH IP„          'vectoradressing: leave the MUL etc for know„          'JMP VECTORADRESS„          '...................„          'DOES WHATEVER HERE IS DONE„          '...................„          'POP IP„          'POP CS„          'POPF„'Although not entiraly true this is sufficient knowledge for know. From„'above it could be concluded that when writing an interrupthandler we have„'to do one extra thing when we define our handler as a far procedure( meaning„'that apart from IP also CS is pushed). We have to do manually PUSHF„'before jumping to the OLDINT and PopF them again as the OLDINT returns„'since the IRET at the end has POPF 'ed . After that we simulated the„'INT call.!„„'Okay before actually going into writing a real interrupt-handler we just„'have to do lots more in the sector of making procedures,using labels„'in our asm-subs. I can tell one thing on before hand : the string way„'of going does not seem to survive procedures,using Data_array,labels etc.„'At least i am returning to a better way of the old code%().It is not„'necessary to use datastatements, and clearity could even be incremented„'using also ASM comments( necessary for bigger asmsubs) in a header like„'in normal assemblerprograms with some modifications. Furthermore, arrays„'does not wander around in mem, so they are adressable as procedures,datas„'etc. At last, since you can use datas directly in your assemblersubs,the„'external use of stack is dropping down to zero. This diminished a lot of„'code_space. Making the code more visible. Okay, i will return on the subject of Hooking Interrupt„'later......„„'Let's round the whole thing off with rewriting our RestoreVEC. We should„'be possible to directly write the VEC back using OLDINT83& ,not?„'Okay let us try.„getvec segvec%, offvec%, &H83: PRINT HEX$(segvec%), HEX$(offvec%)„'reset the vec to 0?„pokeDW 0, &H83 * 4, 0„getvec segvec%, offvec%, &H83: PRINT HEX$(segvec%), HEX$(offvec%)„'we seems to have it done.„'Now restore our vector ?„pokeDW 0, &H83 * 4, oldint83&„getvec segvec%, offvec%, &H83: PRINT HEX$(segvec%), HEX$(offvec%)„„'Maybe you agree that we accurataly restored a vector. Since probably„'the only purpose for getting a vector is to restore him at some time„'we might even change Getvec so that it reads one long integer in the„'format segvec:offvec in our variable OlDINT&„PRINT HEX$(oldvec&(&H83))'seems to be ok?„„'Ok now to summarize we can do the whole thing with enlightening speed„'and shortness:„CLS„pokeDW 0, &H83 * 4, 0           'restore situation to start„oldint83& = oldvec&(&H83)       'get the original int83„pokeDW 0, &H83 * 4, segnewint% * 65536 + offnewint%„                                'set our int83 vector„DEF SEG = VARSEG(test%(0))„CALL absolute(VARPTR(test%(0))) 'execute our handler„DEF SEG„pokeDW 0, &H83 * 4, oldint83&   'restore the original vector„„„'Seems to be oke, not ?  Apart from doing the whole thing in an assembler„'procedure i can see only one thing to improve codeshortness being to„'write a function newvec&(segnewint%,offnewint%) which is trivial„'but in the long run it rules out the flip INTEL confusion. Note that we„'prepared us already on using assembler for the whole thing by consequently„'loading up registers first,before writing to a BASIC variable( which is,„'can be argued, bad code viewed solely from here and now QBASICcode)„„'part 2 to be released on my homepage.some time later will handle the„'actual INT 21 handler.„„SUB getvec (d%, v%, nr%)„„d% = 1: v% = 2'variabele initialisatie„dataseg% = VARSEG(d%): offset% = VARPTR(d%)„datasg$ = CHR$(dataseg% AND &HFF) + CHR$(dataseg% \ 256)„offset1$ = CHR$(offset% AND &HFF) + CHR$(offset% \ 256)„offset2$ = CHR$((VARPTR(v%) AND &HFF)) + CHR$((VARPTR(v%) \ 256))„„'CODE IN QBASIC„'**************************************„„„ASM$ = ""„ASM$ = ASM$ + CHR$(&HB4) + CHR$(&H35)              'MOV  AH,35       „ASM$ = ASM$ + CHR$(&HB0) + CHR$(nr%)               'MOV  AL,INTnr   „ASM$ = ASM$ + CHR$(&HCD) + CHR$(&H21)              'INT  21          „ASM$ = ASM$ + CHR$(&HB8) + dataseg$                'MOV  AX,dataseg$    „ASM$ = ASM$ + CHR$(&H8E) + CHR$(&HD8)              'MOV  DS,AX       „ASM$ = ASM$ + CHR$(&H8C) + CHR$(&H6) + offset1$    'MOV  ptr[seg],ES„ASM$ = ASM$ + CHR$(&H89) + CHR$(&H1E) + offset2$'  'mov ptr[off],BX„ASM$ = ASM$ + CHR$(&HCB)                           'RETF           „„„'____________________________„ Codeoff% = SADD(ASM$)„ DEF SEG = VARSEG(ASM$)„ CALL absolute(Codeoff%)„'____________________________„DEF SEG„„END SUB„„FUNCTION newvec& (segnewint%, offnewint%)„newvec& = segnewint% * 65536 + offnewint%„END FUNCTION„„FUNCTION oldvec& (nr%)„'-------------------------------------------------------------------'„'This function is a replacement of GETVEC. It stores the old vector„'in INTEL format in an long integer. INTEL format means in the format„'segment:offset here.„'The procedure first stores the vector in ES[BX], before we access it„'IN:  INTnr%„'OUT: oldvec&„'-------------------------------------------------------------------'„s% = 1: o% = 2'variabele initialisatie„dataseg% = VARSEG(s%): offset% = VARPTR(s%)„datasg$ = CHR$(dataseg% AND &HFF) + CHR$(dataseg% \ 256)„offset1$ = CHR$(VARPTR(s%) AND &HFF) + CHR$(VARPTR(s%) \ 256)„offset2$ = CHR$(VARPTR(o%) AND &HFF) + CHR$(VARPTR(o%) \ 256)„„„'CODE IN QBASIC„'**************************************„„„ASM$ = ""„ASM$ = ASM$ + CHR$(&HB4) + CHR$(&H35)              'MOV  AH,35     „ASM$ = ASM$ + CHR$(&HB0) + CHR$(nr%)               'MOV  AL,INTnr „ASM$ = ASM$ + CHR$(&HCD) + CHR$(&H21)              'INT  21        „ASM$ = ASM$ + CHR$(&HB8) + dataseg$                'MOV  AX,dataseg$  „ASM$ = ASM$ + CHR$(&H8E) + CHR$(&HD8)              'MOV  DS,AX     „ASM$ = ASM$ + CHR$(&H8C) + CHR$(&H6) + offset1$    'MOV  ptr[seg],ES„ASM$ = ASM$ + CHR$(&H89) + CHR$(&H1E) + offset2$'  'mov ptr[off],BX„ASM$ = ASM$ + CHR$(&HCB)                           'RETF         „„„'____________________________„ Codeoff% = SADD(ASM$)„ DEF SEG = VARSEG(ASM$)„ CALL absolute(Codeoff%)„'____________________________„DEF SEG„oldvec& = s% * 65536 + o%„END FUNCTION„„SUB pokeDW (pokeseg%, pokeoff%, dword&)„'This function will just poke a Dword into memory, just like„'the standard function Poke does it, with one enhancement.„'While poke needs a def seg before it we will transfer that to„'the function also! So :„'DW segment to poke word to„'DW offset to poke word to„'DD Dwordvalue to poke„'---------------------------------------------------------------„DEF SEG = VARSEG(dword&)„ptr% = VARPTR(dword&)„LowWlowbyte% = PEEK(ptr%): LowWhighbyte% = PEEK(ptr% + 1)„HighWlowbyte% = PEEK(ptr% + 2): HighWhighbyte% = PEEK(ptr% + 3)„„DEF SEG = pokeseg%„  POKE pokeoff%, LowWlowbyte%„  POKE pokeoff% + 1, LowWhighbyte%„  POKE pokeoff% + 2, HighWlowbyte%„  POKE pokeoff% + 3, HighWhighbyte%„DEF SEG„END SUB„„SUB pokeW (pokeseg%, pokeoff%, word%)„'This function will just poke a word into memory, just like„'the standard function Poke does it, with one enhancement.„'While poke needs a def seg before it we will transfer that to„'the function also! So :„' DW segment to poke word to„' DW offset to poke word to„' DW wordvalue to poke„'Of course you should use this only for reasons of putting all your„'variables in one DATAsegment, since otherwise just defining a integer„'is enough.„'---------------------------------------------------------------„DEF SEG = VARSEG(word%)„ptr% = VARPTR(word%)„highbyte% = PEEK(ptr% + 1): lowbyte% = PEEK(ptr%)„DEF SEG = pokeseg%„  POKE pokeoff%, lowbyte%„  POKE pokeoff% + 1, highbyte%„DEF SEG„„END SUB„Rick Elbers                    INTERRUPTS IN QBASIC 4: HOOKSFTrick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        1369 51052    4HOOKSFT.BAS'INTERRUPTS IN QBASIC 4:HOOKING SOFTWARE INTERRUPTS„'---------------------------------------------------------------„'RICK ELBERS november 1996„„„DECLARE FUNCTION add.newint$ (vector&)„DECLARE FUNCTION replace.newint$ (vector&)„DECLARE SUB dosprnchar ()„DECLARE SUB dosprstr (string2write$)„DECLARE SUB pokeDW (pokeseg%, pokeoff%, dword&)„DECLARE SUB nwintcallint (vector&)„DECLARE FUNCTION newint2$ (vector&)„DECLARE SUB newintcall2 (newint$)„DECLARE SUB newintcall (newintr$)„DECLARE FUNCTION newint$ (vector&)„DECLARE SUB handler1 (vector&, variant%)„DECLARE SUB Pokestring (segje%, offje%, main$)„DECLARE SUB interruptcall (vector&)„DECLARE FUNCTION long2str$ (sdword&)„DECLARE FUNCTION int2str$ (sword%)„DECLARE FUNCTION oldvec& (nr%)„DECLARE FUNCTION newvec& (seghandler%, offhandler%)„„CLS„'-------------„'INTRODUCTION„'--------------„'This is part one concerned with actually intercepting a real interrupt:„'in this case int 21. Let us first start up with doing the interrupt 21„'call a little bit different to provide some insight into real interrupts.„„'----------------------------------------------„'CALLING THE INTERRUPT ROUTINE:'INT' SIMULATION„'----------------------------------------------„'Since by now we know that an interrupthandler is just some routine at some„'adress pointed to by the vector at 0:intnr%*4 we might think we could also„'simulate an INT instruction by something like call vector&. And surprisingly,„'this is true.„'However there are two things we have to add before we can do that. Maybe you„'recalled from the first part of this discussion that an int call does also„'push the flags onto the stack before jumping to the code. The meaning of this„'is that our interrupt_call simulation has to pushf before calling the routine„'at vector&. The code in the sub interruptcall is doing that. Let us look if„'it works:„„OLDINT21VEC& = oldvec&(&H21): PRINT HEX$(OLDINT21VEC&):„interruptcall (OLDINT21VEC&)„SLEEP„'This is looking like 'a' on my machine..is it with you too?„„'----------------------------„'ENABLING OTHER INTERRUPTS„'----------------------------„'With the discussion before we have attended to what an interrupt is normally„'doing except one thing: before jumping to the actual interruptcode there is„'another action taken by INT. Int is enabling further hardware interrupts.„'You can control that again by stepping through some code using debug( take„'for instance the int 9 handler). You simply put int 9 at some place and trace„'the instruction.Immediately you will see the third flag( EI) change to DI(„'disable interrupts).„'Although this is done with every interrupt, it is not necessary for int 21„'since it does not read out itself any necesarry information like ports.„'You should imagine what might have happened when we wanted to read some„'critical information and in between there occurred some interrupt. It might„'be that we read half of it before an interrupt occured ( since most pcs read„'out 32 bits at once it just might be one of the 50% cases where a word„'value is read in two parts.). When this interrupt is storing information say„'in ax and we where just reading a word into ax it is clear we are in trouble.„'so to keep it short a full interrupt masking routine looks like:„„'PUSHF         'push flags for matching the int push of flags„'CLI           'disable interrupts„'CALL VECTOR&  'jmps to the vectoradress while pushing the cs:ip return adress„'STI           'enable interrupts again.„'Notewearthy is also that the iret of the procedure we called pop'ed the flags„'before returning. So we have proper access to returned flags like as if we„'used 'INT'.„„'------------------------------------„'INTERRUPT HANDLERS: GENERAL FORM„'------------------------------------„'You might have asked yourself, why are we going to such a great length to„'execute a code we could have simply be executing by int 21 itself. The reason„'is that when we are intercepting some real interrupt we might just want to„'actually rewrite only a part of the code. Say for instance we only want to„'intercept int 21, function 2( printchar), but not all other functions.„'In that case after we established the hotfunction is not requested, we could„'call the original routine again. You might wanna ask why not at that point„'execute a simple int instruction ? But there we are asking dos to be„'multitasking..since we are already in interrupt code aren't we ? And well,„'for the moment let us suppose dos does not support multitasking. Indeed it„'does not allow you to call int 21 inside some int 21 code..Before there„'will rise again faulty rumours however, i should state that dos can be made„'multitasking, however this is certainly not simple. To see how it can be done„'you might take a look at R.Hydes art of programming chapter 19.„„'Taking into consideration everything we have discussed thus far the general„'outline of an interrupthandler might be clear:„„„'PUSHF         'push flags for matching the int push of flags„'CLI           'disable interrupts„'CMP AX,HOTFCN 'is there a request for our hot function ?„'JZ NEWINT     'if it is jump to our newint.„'               if not:„'CALL OLDINT   'jmps to the vectoradress while pushing the cs:ip return adress„'JMP END       'end we are done„               'flags returned are the normal int returns flags.„'newint:„'------„'POPF           'pop original(entrance) flags again.„'PUSHA          'push all registers before...„'----------------------„'actual code to execute„'----------------------„'POPA           'pop all registers afterwards....„'[[PUSHF:CALL OLDINT]]'with the original registers.„                'flags returned are the flags returned by our code.„„'end:„'----„'STI            'enable interrupts again„'RETF           'back to qbasic„„'The part that says [[PUSHF:CALL OLDINT]] is only facultative. You can use„'this when you want to execute and your handler and the original one. Say for„'instance you only want to print another character 'a'before the printed one,„'only when some print 'a' function is executed( or more likely : print„'something like "hello, love feeling good today" when there is a request for„'printing "income"). In that case you have of course to push the flags again,„'since we restored the original ones in our routine. Furthermore especially„'for this addditionhandlers there are the popa and pusha intructions in our„'interrupt. They are necessary since in the actual code, you might change„'reggies in the first part, and when the actual [[PUSHF:CALL OLDINT]]is„'executed then you want the entrance registers restored. Since you just want„'at that point an INT instruction executed..„„'To make the structure pointed out above a bit more visible i wrote the„'routine handler1 that has an interrupt handler for int 21, function 9.„'When you call this routine with the function 9 set( that is option 3)„'it will NOT display the string but instead an 'B'. For other functions,„'for instance function 2( print a character) just the normal function is„'executed. So option 1 will display the character 'A' on screen just like„'the interruptcall routine did. Option 2 is just a control. It will„'display the string via the normal interrupt calling routine.„„'For control let us execute handler:„CLS„FOR i% = 1 TO 3„handler1 oldvec&(&H21), i%„LOCATE i%, 40: PRINT "output of variant "; i%:„NEXT„SLEEP„„'------------------------------„'RESUME: A SHORT LONGCUT AGAIN„'------------------------------„'Until now we have already managed a lot, though you might not be aware of it.„'First of all since we have managed to simulate an interruptcall we have now„'the weapons to do multiple "INT" calls in one INTERRUPT ROUTINE. We know what„'to do( CLI and PUSHF before CALLING) to multitask DOS.„„'Secondly you might have discovered that our last routine was not as clear as„'normal. A few things are confusing here i think. First of all the calling„'routine and the caller are mixed in this example for instruction purposes.„'To clear things a little bit i separated the newint and the intcaller„'procedures again using the PROC segment handling i described in another„'discussion. In the sub Newintcall our handler is setup like a FAR PROCEDURE,„'and that is exactly what the interrupt routines are themselves.„CLS„newintcall newint$(oldvec&(&H21))„SLEEP„„'The upset in newintcall and newint together could be considered the basic„'upset of a handler. You will notice that when some other function then„'function &h9 is called then there will not be printed anything.„'But when we call newint with intcaller2, that is with registers set up for„'printing a sign,normal functionality is achieved.„„CLS„newintcall2 newint$(oldvec&(&H21))„SLEEP„„„'Apart from the setting vectors as we did in the first part of this discussion„'our basic handler is allright in NEWINT now. I think we cleared the air a bit„'but there are more sources of confusion when we start to use more advanced„'handlers. The handler so far in newint, does only functions as REPLACE_HANDLER„'as i would like to call it. When we call for the hooked function newint„'REPLACES the oldint. Things are getting a lot more interesting when we are„'going to ADD functionality to some call. In that case we might speak of„'ADD_HANDLERS. In that case we might distinguish  a few parts for further„'clarification. But let us first look for the accomplishments:„CLS„newintcall newint2$(oldvec&(&H21)): SLEEP:„CLS : newintcall2 newint2$(oldvec&(&H21))„SLEEP„'Shit on my machine there is an 'i' instead of a 'h' on yours too ? Well„'fix it....„„'When you take a closer look on the newint2 again referred to as the basic„'ADD_handler then you might notice a few parts:„„'------------------------------„'HANDLER_ADD: basic structure„'------------------------------„„'1)Push original registers„'-------------------------„'  PUSHA                      'All the registers changed in this handler„„'2)condition to be met„'----------------------„'  CMP AH, CRITICAL VALUE     'The value to be hooked„'  JZ  NEWINT                 'If so then jump to our newint„„'3)oldint„'---------„'  PUSHF                      'If not then simulate INT„'  CLI„'  CALL VECTOR$„'  JMP END                    'and jump to the end„„'4)newint„'4a)newint:part before the original call„'---------------------------------------„'REGISTER UPSET FOR CODE BEFORE„'[if there is also a call to vector$ then:„'   PUSHF„'   CALL VECTOR$]„„'4b)newint:original call„'   POPA                     'Restore entrance registers AND„'   PUSHA                    'Store them again....„'   PUSHF                    'Simulate intcall with original registers so:„'   CALL VECTOR$             'old functionality matched!!!„„'4c)newint:part after the original call„'REGISTER UPSET FOR CODE AFTER„'[If there is also a call to vector$ then:„'   PUSHF„'   CALL VECTOR$]„„'5)Closing:„'   STI                      'Enable interrupts again„'   POPA                     'Restore original registers again„'                            [note:flags returned are the flags„'                            returned by the last call vector$]„'   RETF                     'Return to caller„„'Of course it should be mentioned that there can be saved a few bytes by„'making the oldint into a call_able procedure also, but for clarity i thought„'this basic structure was best. Take into consideration however that„'interrupthandlers are usually closely related to TSR programming and it will„'be obvious you should give optimization in this cases your best shot...„„'INTERRUPTHANDLERS VIEWED FROM CALLING PROGRAMS„'-----------------------------------------------„'So far we have given the interrupthandlers themselves our almost undivided„'attention, but we might turn now for a moment to the calling programs, since„'it seems to be that we 've got our handlers basically working.„'From the point of view from our calling programs callnewint( call the hooked„'function) and callnewint2(call another function) in fact the only important„'thing of newint is in fact its adress....„'So far we managed to call the newint by adress by just putting the newint$„'into a PROC segment that could be adressed by the callnewint procedure. It„'was however no coincidence that the PROC segment was an integer array. When„'we are designing things the way we do, as i will advise for keeping things„'evident, then it is obvious we should use an integerarray to store the newint„'instead of an asm$ string since the integerarray will not be walking around„'in memory between CALLs.„'This is the more evident because when it is a real interrupt replacer then„'the function will be called * a lot* of times, and we have to store the„'adress of the newint into the vector table..„'So far we were passing the newint$ to the newintcaller but it is apparent„'that when the adress of our newint is stored in the vectortable then that„'is no longer necessary. Also the calling codes could be restored to normal„'[replace call vector$ by int 21 again]. When we adequately stored the vector„'of our interrupt newint to replace the oldvector of int 21 then everything„'should work nicely. We only should call our setvec once for initializing.„'After we know the newvec of course<g>. There is the option to EITHER put„'a setvec procedure at the beginning of our newintcaller OR put a setvec„'procedure at the beginning of our interrupthandler. The last is certainly„'not advised since we want to keep our interrupthandler as short as possible.„'Also setting vectors at the start of a newintcaller seems to be only making„'sense when you use newint only in that one procedure. In that case you might„'wonder if an interrupthandler is necessary at all, but if so, then it seems„'like the way to go to design newintcaller as first setting vectors and ending„'with resetting vectors. However,,...„'Interrupthandlers are really shining in the area where one handler can be used„'for many other procedures. Or where you want to replace a limiting function„'of DOS for a lot of calls to the same procedure. Therefore in this discussion„'we will go for the general design:„'-----------„'QBASIC:MAIN„'-----------„'GETVEC             'get oldvector„'INITNEWINT         'Initialize the newintcode- in other words put in into place„'SETVEC             'set newvector„'NEWINTCALLER       'whatever assembly sub that also calls the HOOKED INT„'RESETVEC           'setvec oldvector„„'The only remaining thing is the initializing of newint using an adressable„'integerarray for storage. I can promise you that i will develop some method„'of assembly storage that has both the advantages of asm$ and asm% but for„'now i will use a quick patch, since we still use the changing abstraction„'method.....Let us see:„„newinterrupt$ = newint$(oldvec&(&H21)): DIM nwint%(LEN(newinterrupt$) \ 2 + 1)„nwintseg% = VARSEG(nwint%(0)): nwintoff% = VARPTR(nwint%(0))„Pokestring nwintseg%, nwintoff%, newinterrupt$„„'Things are done...so far...a bit of a back and forth translation but allright„'its oftopic and it works..„'CONTROLE:„newintvector& = newvec&(nwintseg%, nwintoff%)„CLS : nwintcallint (newintvector&)„„'There seems to be no difference to the strings.....   But before going to„'the actually putting all of it together a short recall section is in place„'i think„„„'---------------------------------„'INTERRUPT_HANLERS: SHORT RESUME„'----------------------------------„'We started our discussion concerning interrupthandlers with the examining„'of interrupts as they are. We discovered the vectortable, and managed to„'set up our own interrupt by putting a vector to code of our own at some„'open place. In the process we noticed that QBASIC resets itself a few„'vectors in the vectortable. We developed a few very basicfunctions for„'rapidly setting and resetting vectors, thereby passing the DOS function„'INT 21,25 that is normally doing that, but is to some unknown reason„'disabled in our IDE. Furthermore we started to get further into interrupts„'and there general structure. We discovered PUSHF and the IRET instruction.„'That was pretty much where the first part ended. Promising but nothing more..„„'In the second part presented here we discovered that all the basics were„'already there just waiting for us to put in code..We started with an„'interrupt simulation routine which CALLs the vector instead of INT with the„'same functionality. A little attention was given to enabling interrupts,„'and to DOSs single tasking.. After that we rapidly progressed to some„'basicstructures for HANDLERS. We distinguished between ADD_HANDLERS and the„'more simple REPLACE_HANDLERS. We cleared some confusement considering the„'actual HANDLER and the CALLING ROUTINES by then, since like always, when„'progressing, more structure is needed or at least desirable. We executed„'two calling routines one requesting for the hooked function and the other„'one requesting some other function.„'Towards the end we left the handlers again in favor of first the CALLING„'PROCEDURES and later QBASIC itself as MAIN CALLER. In the process we„'reviewed our initial setvec/getvec procedures. Eventually also we returned„'to integer storing our handler, since it has to be adressable at a fixed„'adress.„'The discussion will be ended here with some almost "nonsense" interrupt„'handler, but i take it that in the process if have outlined the the major„'flexibility of interrupthandlers also. The actual use of handlers is„'a topic far to big for this article, maybe for the place you read this„'from and maybe also for me..I just wanted to present the basic handling„'to you so that new roads are open for you. It might just be that i design„'some handlers and upload them in LINT.bas. We'll see...„„„'-------------------------„'PUTTING IT ALL TOGETHER.„'-------------------------„'Now that we know that our handler is allright, we are ready for the big„'surprise. Let us actually do the resetting of vectors...so that our handler„'is executed instead of the original one!„'We have to do minor surgery to our handler and caller however, since the„'handlers will be no longer FAR PROCEDURES but INTERRUPT HANDLERS. The„'only difference is that they return with IRET instead of RETF...meaning„'that they PUSH the flags also. We have been extensivaly into the flags„'already but since our handler is now the interrupt himself he had to return„'with IRET also!! So there are the final subs called ADD_NEWINT and REPLACE_„'NEWINT.„'The second change is even more little. The caller can does not have to be„'no longer some FAR PROCEDURE CALLER but can be an ordinary interruptcaller.„'For that reason the dosprnstr and dosprnchar are used as calling the hooked„'function and calling another one.„„'We know already from the first part of this discussion that the setvec and„'getvec routines are oke. So we do not have to bother about that.„„CLS„COLOR 0, 7: PRINT "Before the INTERRUPT HOOKING a CALL of dosprnstr looks like:":„COLOR 7, 0: dosprstr ("wat is dit ? Een interrupt handler !")„PRINT :„COLOR 0, 7: PRINT "Before the INTERRUPT HOOKING a CALL of dosprnchar looks like:"„COLOR 7, 0: dosprnchar„PRINT : COLOR 0, 7„LOCATE 12, 1„PRINT "Press a key to see what the same calls looks like after hooking"„COLOR 7, 0„SLEEP: CLS„„'get the original int 21 vector„oldint21& = oldvec&(&H21)„„'initializing newinterrupt & nwint_vector for replace.newint„'------------------------------------------------------------„newinterrupt$ = replace.newint$(oldint21&):„REDIM nwint%(LEN(newinterrupt$) \ 2 + 1)„nwintseg% = VARSEG(nwint%(0)): nwintoff% = VARPTR(nwint%(0))„Pokestring nwintseg%, nwintoff%, newinterrupt$„newintvector& = newvec&(nwintseg%, nwintoff%)„„'set our vector for int 21 at the vectortable„pokeDW 0, &H21 * 4, newintvector&„„'execute an ordinary intcaller:  [almost forgot how that works...]„CLS : COLOR 0, 7: PRINT "When the INTERRUPT is REPLACE_HOOKED a CALL of dosprnstr looks like:":„LOCATE 2, 1: COLOR 7, 0: dosprstr ("wat is dit ? Een interrupt handler !")„LOCATE 3, 1: COLOR 0, 7: PRINT "When the INTERRUPT is REPLACE_HOOKED a CALL of dosprnchar looks like:"„LOCATE 4, 1: COLOR 7, 0: dosprnchar„COLOR 0, 7„LOCATE 12, 1: PRINT "Press a key again to see what the ADD_handler output looks like"„COLOR 7, 0:„SLEEP: CLS„„„'Initializing newinterrupt & nwint_vector for add.newint„'------------------------------------------------------------„newinterrupt$ = add.newint$(oldint21&):„REDIM nwint%(LEN(newinterrupt$) \ 2 + 1)„nwintseg% = VARSEG(nwint%(0)): nwintoff% = VARPTR(nwint%(0))„Pokestring nwintseg%, nwintoff%, newinterrupt$„newintvector& = newvec&(nwintseg%, nwintoff%)„„'set our vector for int 21 at the vectortable„pokeDW 0, &H21 * 4, newintvector&„„'execute an ordinary intcaller:  [almost forgot how that works...]„CLS : COLOR 0, 7: PRINT "When the INTERRUPT is ADD_HOOKED a CALL of dosprnstr looks like:":„LOCATE 2, 1: COLOR 7, 0: dosprstr ("wat is dit ? Een interrupt handler !")„LOCATE 3, 1: COLOR 0, 7: PRINT "When the INTERRUPT is ADD_HOOKED a CALL of dosprnchar looks like:"„LOCATE 4, 1: COLOR 7, 0: dosprnchar„COLOR 0, 7„LOCATE 12, 1: PRINT "Press a key again to reset everything to normal"„COLOR 7, 0:„SLEEP: CLS„„'reset the vector to oldvec&„'-----------------------------„pokeDW 0, &H21 * 4, oldint21&   'restore the original vector„„COLOR 0, 7: PRINT "After the INTERRUPT HOOKING a CALL of dosprnstr looks like:":„COLOR 7, 0: dosprstr ("wat is dit ? Een interrupt handler !")„PRINT :„COLOR 0, 7: PRINT "After the INTERRUPT HOOKING a CALL of dosprnchar looks like:"„COLOR 7, 0: dosprnchar„PRINT : COLOR 0, 7„„„„END„„FUNCTION add.newint$ (vector&)„'---------------------------„'EXAMPLE OF AN ADD_HANDLER„'---------------------------„'This handler is an example of hooking an interrupt on„'print string. When another function then function 9„'is requested then the string will be printed,if the„'normal printstring is requested( function 9) then„'this handler will print 'B' AND the string requested AND 'H'.„'---------------------------------------------------------„'DATA  'Make our vector to fit the string way of saving„'-------„vector$ = long2str$(vector&)„'----------------------------------------------------------„'CODE„'----„'0) Preserve the registers on entrance„'push ax„'push dx„'push ds„'„'1) Condition to be met„'cmp ah,09                   'print string ?„'jz newint                   'if zero move to our newint„'2) Oldint„'pushf                       'imitate the interrupt„'cli„'call vector$                'if not then execute int 21,9„'jmp end                     'and jump to the end„„'4) Newint„'----------„'part before:„'-------------„„'mov ah,2„'mov dl,42„'pushf                       'simulating an int call again„'cli„'call vector$                'execute druk tek b„„'part original call:„'pop ds                     'restore entrance registers„'pop dx„'pop ax„'push ax„'push dx„'push ds„„'pushf                      'simulate int again„'cli„'call vector$„'-------------„'part after:„'-------------„'mov ah,2„'mov dl,49„'pushf                       'simulating an int call again„'cli„'call vector$                'execute druk tek h„„'5)Closing„'end :„'sti„„'pop ds„'pop dx„'pop ax„'iret                        'back to calling routine„'-----------------------------------„'preserve original registers for later use„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„'conditional part:„asm$ = asm$ + CHR$(&H80) + CHR$(&HFC) + CHR$(&H9)'cmp ah,09„asm$ = asm$ + CHR$(&H74) + CHR$(&H9)             'jz newint„'oldint:„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&HFA)                         'cli„asm$ = asm$ + CHR$(&H9A) + vector$               'call vector$„asm$ = asm$ + CHR$(&HEB) + CHR$(&H21)            'jmp end„'newint:before„'-------------------------------------------------------„'ax: already preserved but will be changed temporaraly„'dx: already preserved but will be changed temporaraly„'-----------------------------------------------------„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)             'mov ah,02„asm$ = asm$ + CHR$(&HB2) + CHR$(&H42)            'mov dl,42„asm$ = asm$ + CHR$(&HFA)                         'cli          simulate int„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&H9A) + vector$               'druktek(b)„'11 newint:old part„asm$ = asm$ + CHR$(&H1F)  'pop original registers back„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'push them again for retrieving.„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„„asm$ = asm$ + CHR$(&H9C)                 'pushf      'simulate an int„asm$ = asm$ + CHR$(&H9A) + vector$       'printstring„'24 newint:after part„'----------------------------------------„'Original registers are preserved„'but ax and dx will change„'----------------------------------------„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)     'mov ah,02„asm$ = asm$ + CHR$(&HB2) + CHR$(&H49)    'mov dl,49„asm$ = asm$ + CHR$(&H9C)                 'pushf    'simulate int„asm$ = asm$ + CHR$(&H9A) + vector$       'druktek(h)„„'35 end:„asm$ = asm$ + CHR$(&HFB)                 'sti„'popa:„asm$ = asm$ + CHR$(&H1F)                 'pop original registers back„asm$ = asm$ + CHR$(&H5A)                 'but flags delivered will be„asm$ = asm$ + CHR$(&H58)                 'last interrupt call flags„'retf:„asm$ = asm$ + CHR$(&HCF)                 'iret„add.newint$ = asm$„„END FUNCTION„„SUB dosprnchar„'This sub is just printing a character using a DOS int 21,2 call„„'-------------------------------------------------------------------------„'CODE„'-----„prnchar$ = ""„prnchar$ = prnchar$ + CHR$(&H50)                 'pusha„prnchar$ = prnchar$ + CHR$(&H52)„„prnchar$ = prnchar$ + CHR$(&HB2) + CHR$(&H45)    'mov dl,&h45„prnchar$ = prnchar$ + CHR$(&HB4) + CHR$(&H2)     'MOV AH,2„prnchar$ = prnchar$ + CHR$(&HCD) + CHR$(&H21)    'INT 21„„prnchar$ = prnchar$ + CHR$(&H5A)„prnchar$ = prnchar$ + CHR$(&H58)„„prnchar$ = prnchar$ + CHR$(&HCB)                 'retf„„'________________________________________„Codeoff% = SADD(prnchar$)„DEF SEG = VARSEG(prnchar$): LOCATE 5, 1„CALL ABSOLUTE(Codeoff%): DEF SEG„'________________________________________„„„END SUB„„SUB dosprstr (string2write$)„'This procedure is just printing out the string2write„'using dos int 21,9 function.„„'-------------------------------------------------------------------------„'DATA„a% = LEN(string2write$) + 1: DIM datas%(a% \ 2 + 1)„'-----------------------------„'INTRODUCTION ON DATASEGMENTS:„'------------------------------„'DATAS will be our datasegment. Take good care that we declare it as an„'array since arrays start at segment bounderies. That way we will not be„'surprised by segment changes. This might be trivial but when you use„'a simple variable which is number Xth in the row of variables it just might„'be that your starting adress is at seg:&hfffe. Same holds for stringvariables.„'They do not start at segmentbounderies too. Another feature of strings„'is that they walk around in memory due to garbage collection, making a„'string very unsuited for adressability purposes. So: we use DATAS% and poke„'our variables and strings just inside it!„„'The length of the datasegment in this example is designed to keep only„'the string.„„b$ = string2write$ + "$"         'This is the way DOS processes stringprint„'--------------------------------„'MAKE THE DATASEGMENT ADRESSABLE:„'--------------------------------„'Here is the basic upset of an adressable datasegment:„„dataseg% = VARSEG(datas%(0)): dataoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): dataoff$ = int2str$(dataoff%)„„'Next we poke our string into the datasegment.„Pokestring dataseg%, dataoff%, b$„„'-----------------------------------„'CODE„'push ax„'push dx„'push ds„„'mov ax,dataseg$„'mov ds,ax„'mov dx,dataoff$„'mov ah,09         'printstring with ending $„'int 21„'pop ds„'pop dx„'pop ax„'retf„'-----------------------------------„'pusha„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„„asm$ = asm$ + CHR$(&HB8) + dataseg$      'MOV AX,DATASEG$„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)    'MOV DS,AX„asm$ = asm$ + CHR$(&HBA) + dataoff$      'MOV DX,DATAOFF$„asm$ = asm$ + CHR$(&HB4) + CHR$(&H9)     'MOV AH,9„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)    'INT 21„„'popa„asm$ = asm$ + CHR$(&H1F)„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'retf„asm$ = asm$ + CHR$(&HCB)„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL ABSOLUTE(Codeoff%)„'________________________________________„DEF SEG„„END SUB„„SUB handler1 (vector&, variant%)„'This handler is an example of hooking an interrupt on„'print string.„„'let us setup a variant like or one char print or a string print.„'variant =1 =>print string a$ with our handler„'variant =2 =>print string a$ with normal int 21„'variant =3 =>print character "A"„„a$ = "this is a teststring$"„„DIM datas%(2 + LEN(a$))„dataseg% = VARSEG(datas%(0)): dataoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): vector$ = long2str$(vector&)„stringoff$ = int2str(dataoff% + 4)„Pokestring dataseg%, dataoff% + 4, a$„„'-----------------------------------„'push ax„'push dx„'push ds„'mov ax,dataseg$„'mov ds,ax                    'mov ds,dataseg„„'testroutine:„'if variant%< 3 then          'print a string used for testing„  'mov dx,stringoff$          '(option 1 and 2)„  'mov ah,9„'else„  'mov ah,2                   'print character "A" used for testing„  'mov dl,41                  '(option 3)„'endif„„'start of handler:„'pushf„'cli„'if variant%>1 then          'if not an ordinary print string call:(option 1)„'cmp ah,09                   'print string ?„'jz newint                   'if zero move to our newint„'end if„'call vector$                'if not then execute int 21,9„'jmp end                     'and jump to the end„„'newint start:„'popf                        'original flags„'mov ah,2„'mov dl,42„'pushf                       'simulating an int call again„'call vector$                'execute druk tek b„„'end :„'sti„'pop ds„'pop dx„'pop ax„'retf„'-----------------------------------„'pusha„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„'test:„asm$ = asm$ + CHR$(&HB8) + dataseg$„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)„IF variant% < 3 THEN                     'print string„asm$ = asm$ + CHR$(&HBA) + stringoff$    'mov dx,stringoff$„asm$ = asm$ + CHR$(&HB4) + CHR$(&H9)     'mov ah,9„ELSE                                     'print character 'a'„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)     'mov ah,2„asm$ = asm$ + CHR$(&HB2) + CHR$(&H41)    'mov dl,41„END IF„'handler„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&HFA)                         'cli„IF variant% > 1 THEN„asm$ = asm$ + CHR$(&H80) + CHR$(&HFC) + CHR$(&H9)'cmp ah,09„asm$ = asm$ + CHR$(&H74) + CHR$(&H7)             'jz newint„END IF„asm$ = asm$ + CHR$(&H9A) + vector$               'call vector$„asm$ = asm$ + CHR$(&HEB) + CHR$(&HB)             'jmp end„'newint:„asm$ = asm$ + CHR$(&H9D)                         'popf„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)„asm$ = asm$ + CHR$(&HB2) + CHR$(&H42)„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&H9A) + vector$               'druktek(b)„„'end:„„asm$ = asm$ + CHR$(&HFB) 'sti„'popa:„asm$ = asm$ + CHR$(&H1F)„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'retf:„asm$ = asm$ + CHR$(&HCB)„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL ABSOLUTE(Codeoff%)„'________________________________________„DEF SEG„„END SUB„„FUNCTION int2str$ (sword%)„'this function is translating sword integers into a string. its only use„'is when you still use asm$ for assembler functions( like i do). in that„'case you can make your integer values usable ..„'this function simply translates the hexa bytes„'into stringbytes as is.„'----------------------------------------------------„DEF SEG = VARSEG(sword%)„ptr% = VARPTR(sword%)„int2str$ = CHR$(PEEK(ptr%)) + CHR$(PEEK(ptr% + 1))„DEF SEG„„END FUNCTION„„SUB interruptcall (vector&)„DIM datas%(2)„dataseg% = VARSEG(datas%(0)): dataoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): vector$ = long2str$(vector&)„„„'-----------------------------------„'push ax„'push dx„'push ds„'mov ax,dataseg$„'mov ds,ax  'mov ds,dataseg„'mov ah,2   'druktek„'mov dl,41  'teken a„'cli        'disable interrupts„'pushf      'simulate interrupt„'call vector$ 'farcall to interrupt vector„'sti        'enable interrupts again„'pop dx„'pop ax„''popf is done by the iret of the routine we called„'-----------------------------------„'pusha„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„„asm$ = asm$ + CHR$(&HB8) + dataseg$„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)„asm$ = asm$ + CHR$(&HB2) + CHR$(&H41)„asm$ = asm$ + CHR$(&HFA)            'cli„asm$ = asm$ + CHR$(&H9C)            'pushf„asm$ = asm$ + CHR$(&H9A) + vector$„asm$ = asm$ + CHR$(&HFB)            'sti„'popa„asm$ = asm$ + CHR$(&H1F)„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'retf„asm$ = asm$ + CHR$(&HCB)„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL ABSOLUTE(Codeoff%)„'________________________________________„DEF SEG„„„END SUB„„FUNCTION long2str$ (sdword&)„'this function simply translates the bytes„'of the sdword to a string as is„'it is only useful when you still use asm$„'approach (like i do)„'-------------------------------------------„DEF SEG = VARSEG(sdword&)„ptr% = VARPTR(sdword&)„long2str$ = CHR$(PEEK(ptr%)) + CHR$(PEEK(ptr% + 1)) + CHR$(PEEK(ptr% + 2)) + CHR$(PEEK(ptr% + 3))„DEF SEG„END FUNCTION„„FUNCTION newint$ (vector&)„'-----------------------------„'EXAMPLE OF A REPLACE_HANDLER[far procedure]„'------------------------------„'This handler is an example of hooking an interrupt on„'print string. When another function then function 9„'is requested then the string will be printed,if the„'normal printstring is requested( function 9) then„'this handler will print only 'B'.„'---------------------------------------------------------„'DATA  'Make our vector to fit the string way of saving„'-------„vector$ = long2str$(vector&)„'----------------------------------------------------------„'CODE„'----„'0) Preserve the registers on entrance„'push ax„'push dx„'push ds„'1) Imitate an interrupt„'pushf„'cli„'2) Condition to be met„'cmp ah,09                   'print string ?„'jz newint                   'if zero move to our newint„'3) Oldint„'call vector$                'if not then execute int 21,9„'jmp end                     'and jump to the end„'4) Newint„'newint start:„'popf                        'original flags„'mov ah,2„'mov dl,42„'pushf                       'simulating an int call again„'call vector$                'execute druk tek b„'5)Closing„'end :„'sti„„'pop ds„'pop dx„'pop ax„'retf                        'back to calling routine„'-----------------------------------„'pusha„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„„'asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)     'mov ah,9 test is oke„„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&HFA)                         'cli„asm$ = asm$ + CHR$(&H80) + CHR$(&HFC) + CHR$(&H9)'cmp ah,09„asm$ = asm$ + CHR$(&H74) + CHR$(&H7)             'jz newint„asm$ = asm$ + CHR$(&H9A) + vector$               'call vector$„asm$ = asm$ + CHR$(&HEB) + CHR$(&HB)             'jmp end„'newint:„asm$ = asm$ + CHR$(&H9D)                         'popf„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)„asm$ = asm$ + CHR$(&HB2) + CHR$(&H42)„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&H9A) + vector$               'druktek(b)„„'end:„asm$ = asm$ + CHR$(&HFB) 'sti„'popa:„asm$ = asm$ + CHR$(&H1F)„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'retf:„asm$ = asm$ + CHR$(&HCB)„„newint$ = asm$„„END FUNCTION„„FUNCTION newint2$ (vector&)„'---------------------------„'EXAMPLE OF AN ADD_HANDLER[far procedure]„'---------------------------„'This handler is an example of hooking an interrupt on„'print string. When another function then function 9„'is requested then the string will be printed,if the„'normal printstring is requested( function 9) then„'this handler will print 'B' AND the string requested AND 'H'.„'---------------------------------------------------------„'DATA  'Make our vector to fit the string way of saving„'-------„vector$ = long2str$(vector&)„'----------------------------------------------------------„'CODE„'----„'0) Preserve the registers on entrance„'push ax„'push dx„'push ds„'„'1) Condition to be met„'cmp ah,09                   'print string ?„'jz newint                   'if zero move to our newint„'2) Oldint„'pushf                       'imitate the interrupt„'cli„'call vector$                'if not then execute int 21,9„'jmp end                     'and jump to the end„„'4) Newint„'----------„'part before:„'-------------„„'mov ah,2„'mov dl,42„'pushf                       'simulating an int call again„'cli„'call vector$                'execute druk tek b„„'part original call:„'pop ds                     'restore entrance registers„'pop dx„'pop ax„'push ax„'push dx„'push ds„„'pushf                      'simulate int again„'cli„'call vector$„'-------------„'part after:„'-------------„'mov ah,2„'mov dl,49„'pushf                       'simulating an int call again„'cli„'call vector$                'execute druk tek h„„'5)Closing„'end :„'sti„„'pop ds„'pop dx„'pop ax„'retf                        'back to calling routine„'-----------------------------------„'preserve original registers for later use„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„'conditional part:„asm$ = asm$ + CHR$(&H80) + CHR$(&HFC) + CHR$(&H9)'cmp ah,09„asm$ = asm$ + CHR$(&H74) + CHR$(&H9)             'jz newint„'oldint:„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&HFA)                         'cli„asm$ = asm$ + CHR$(&H9A) + vector$               'call vector$„asm$ = asm$ + CHR$(&HEB) + CHR$(&H21)            'jmp end„'newint:before„'-------------------------------------------------------„'ax: already preserved but will be changed temporaraly„'dx: already preserved but will be changed temporaraly„'-----------------------------------------------------„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)             'mov ah,02„asm$ = asm$ + CHR$(&HB2) + CHR$(&H42)            'mov dl,42„asm$ = asm$ + CHR$(&HFA)                         'cli          simulate int„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&H9A) + vector$               'druktek(b)„'11 newint:old part„asm$ = asm$ + CHR$(&H1F)  'pop original registers back„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'push them again for retrieving.„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„„asm$ = asm$ + CHR$(&H9C)                 'pushf      'simulate an int„asm$ = asm$ + CHR$(&H9A) + vector$       'printstring„'24 newint:after part„'----------------------------------------„'Original registers are preserved„'but ax and dx will change„'----------------------------------------„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)     'mov ah,02„asm$ = asm$ + CHR$(&HB2) + CHR$(&H49)    'mov dl,49„asm$ = asm$ + CHR$(&H9C)                 'pushf    'simulate int„asm$ = asm$ + CHR$(&H9A) + vector$       'druktek(h)„„'35 end:„asm$ = asm$ + CHR$(&HFB)                 'sti„'popa:„asm$ = asm$ + CHR$(&H1F)                 'pop original registers back„asm$ = asm$ + CHR$(&H5A)                 'but flags delivered will be„asm$ = asm$ + CHR$(&H58)                 'last interrupt call flags„'retf:„asm$ = asm$ + CHR$(&HCB)„„newint2$ = asm$„„END FUNCTION„„SUB newintcall (newintr$)„'In this sub the CALLER code is setup. This code will call some interrupt„'handler referred to as newintr$. It is setup for clarity in some other„'function( you can think of that function as a far function<ha ha >)„„'This function is requesting a printstring from DOS which IS HOOKED„'-------------------------------------------------------------------------„'PROC„'-----„DIM PROCS%(LEN(newintr$) \ 2 + 1)„procseg% = VARSEG(PROCS%(0)): procoff% = VARPTR(PROCS%(0))„procseg$ = int2str$(procseg%):„„Pokestring procseg%, procoff%, newintr$: newintoff$ = int2str$(procoff%)„'Okay we have a PROC segment now with:„'PROC:0               newintr$„'---------------------------------------------------------------------„'DATA:„'------„b$ = "Hello i have been printed by an interrupthandler$"  'This is the way DOS processes stringprint„REDIM datas%(LEN(b$) \ 2 + 1)„dataseg% = VARSEG(datas%(0)): dataoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): dataoff$ = int2str$(dataoff%)„Pokestring dataseg%, dataoff%, b$„'-------------------------------------------------------------------------„'CODE OF NEWINT CALLER:[Note that instead of INT we just call our newint]„'-----„prnstr$ = ""„prnstr$ = prnstr$ + CHR$(&H50)                 'pusha„prnstr$ = prnstr$ + CHR$(&H52)„prnstr$ = prnstr$ + CHR$(&H1E)„„prnstr$ = prnstr$ + CHR$(&HB8) + dataseg$      'MOV AX,DATASEG$„prnstr$ = prnstr$ + CHR$(&H8E) + CHR$(&HD8)    'MOV DS,AX„prnstr$ = prnstr$ + CHR$(&HBA) + dataoff$      'MOV DX,DATAOFF$„prnstr$ = prnstr$ + CHR$(&HB4) + CHR$(&H9)     'MOV AH,9„prnstr$ = prnstr$ + CHR$(&H9A) + newintoff$ + procseg$„„prnstr$ = prnstr$ + CHR$(&H1F)                 'popa„prnstr$ = prnstr$ + CHR$(&H5A)„prnstr$ = prnstr$ + CHR$(&H58)„„prnstr$ = prnstr$ + CHR$(&HCB)                 'retf„„'________________________________________„Codeoff% = SADD(prnstr$)„DEF SEG = VARSEG(prnstr$): LOCATE 5, 1„CALL ABSOLUTE(Codeoff%): DEF SEG„'________________________________________„„„END SUB„„SUB newintcall2 (newintr$)„'In this sub the CALLER code is setup. This code will call some interrupt„'handler referred to as newintr$. It is setup for clarity in some other„'function( you can think of that function as a far function<ha ha >)„„'This function is requesting a printcharacter to DOS which is NOT HOOKED„'PROC„'-----„DIM PROCS%(LEN(newintr$) \ 2 + 1)„procseg% = VARSEG(PROCS%(0)): procoff% = VARPTR(PROCS%(0))„procseg$ = int2str$(procseg%):„„Pokestring procseg%, procoff%, newintr$: newintoff$ = int2str$(procoff%)„'Okay we have a PROC segment now with:„'PROC:0               newintr$„'-------------------------------------------------------------------------„'CODE OF NEWINT CALLER:[Note that instead of INT we just call our newint]„'-----„prnchar$ = ""„prnchar$ = prnchar$ + CHR$(&H50)                 'pusha„prnchar$ = prnchar$ + CHR$(&H52)„„prnchar$ = prnchar$ + CHR$(&HB2) + CHR$(&H45)    'mov dl,&h45„prnchar$ = prnchar$ + CHR$(&HB4) + CHR$(&H2)     'MOV AH,2„prnchar$ = prnchar$ + CHR$(&H9A) + newintoff$ + procseg$„„prnchar$ = prnchar$ + CHR$(&H5A)„prnchar$ = prnchar$ + CHR$(&H58)„„prnchar$ = prnchar$ + CHR$(&HCB)                 'retf„„'________________________________________„Codeoff% = SADD(prnchar$)„DEF SEG = VARSEG(prnchar$): LOCATE 5, 1„CALL ABSOLUTE(Codeoff%): DEF SEG„'________________________________________„„END SUB„„FUNCTION newvec& (seghandler%, offhandler%)„'While this function is again very evident, it„'clarifys the intel format of storing vectors.„'-----------------------------------------------„newvec& = seghandler% * 65536 + offhandler%„END FUNCTION„„SUB nwintcallint (vector&)„'In this sub the CALLER code is setup in an integer way.„'This code will call some interrupt handler referred to as newintr.„'It is only referred to here by its vector&(a long integer in the„'form seg:off)„„'This function is requesting a printstring from DOS which IS HOOKED„'-------------------------------------------------------------------------„'DATA:„'------„vector$ = long2str$(vector&)„b$ = "Hello i have been printed by an interrupthandler$"  'This is the way DOS processes stringprint„DIM datas%(LEN(b$) \ 2 + 1)„dataseg% = VARSEG(datas%(0)): dataoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): dataoff$ = int2str$(dataoff%)„Pokestring dataseg%, dataoff%, b$„'-------------------------------------------------------------------------„'CODE OF NEWINT CALLER:[Note that instead of INT we just call our newint]„'-----„prnstr$ = ""„prnstr$ = prnstr$ + CHR$(&H50)                 'pusha„prnstr$ = prnstr$ + CHR$(&H52)„prnstr$ = prnstr$ + CHR$(&H1E)„„prnstr$ = prnstr$ + CHR$(&HB8) + dataseg$      'MOV AX,DATASEG$„prnstr$ = prnstr$ + CHR$(&H8E) + CHR$(&HD8)    'MOV DS,AX„prnstr$ = prnstr$ + CHR$(&HBA) + dataoff$      'MOV DX,DATAOFF$„prnstr$ = prnstr$ + CHR$(&HB4) + CHR$(&H9)     'MOV AH,9„prnstr$ = prnstr$ + CHR$(&H9A) + vector$„„prnstr$ = prnstr$ + CHR$(&H1F)                 'popa„prnstr$ = prnstr$ + CHR$(&H5A)„prnstr$ = prnstr$ + CHR$(&H58)„„prnstr$ = prnstr$ + CHR$(&HCB)                 'retf„„'________________________________________„Codeoff% = SADD(prnstr$)„DEF SEG = VARSEG(prnstr$): LOCATE 5, 1„CALL ABSOLUTE(Codeoff%): DEF SEG„'________________________________________„„„END SUB„„FUNCTION oldvec& (nr%)„'-------------------------------------------------------------------'„'this function is a replacement of getvec. it stores the old vector„'in intel format in an long integer. intel format means in the format„'segment:offset here.„'the procedure first stores the vector in es[bx], before we access it„'in:  intnr%„'out: oldvec&„'-------------------------------------------------------------------'„s% = 1: o% = 2'variabele initialisatie„dataseg% = VARSEG(s%): offset% = VARPTR(s%)„datasg$ = CHR$(dataseg% AND &HFF) + CHR$(dataseg% \ 256)„offset1$ = CHR$(VARPTR(s%) AND &HFF) + CHR$(VARPTR(s%) \ 256)„offset2$ = CHR$(VARPTR(o%) AND &HFF) + CHR$(VARPTR(o%) \ 256)„„'hieronder volgt de code in qbasic„'**************************************„„„asm$ = ""„asm$ = asm$ + CHR$(&HB4) + CHR$(&H35)              'mov  ah,35„asm$ = asm$ + CHR$(&HB0) + CHR$(nr%)               'mov  al,intnr„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)              'int  21„asm$ = asm$ + CHR$(&HB8) + dataseg$                'mov  ax,dataseg$„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)              'mov  ds,ax„asm$ = asm$ + CHR$(&H8C) + CHR$(&H6) + offset1$    'mov  ptr[seg],es„asm$ = asm$ + CHR$(&H89) + CHR$(&H1E) + offset2$'  'mov ptr[off],bx„asm$ = asm$ + CHR$(&HCB)                           'retf„„„'____________________________„ Codeoff% = SADD(asm$)„ DEF SEG = VARSEG(asm$)„ CALL ABSOLUTE(Codeoff%)„'____________________________„DEF SEG„oldvec& = s% * 65536 + o%„END FUNCTION„„SUB pokeDW (pokeseg%, pokeoff%, dword&)„'This function will just poke a Dword into memory, just like„'the standard function Poke does it, with one enhancement.„'While poke needs a def seg before it we will transfer that to„'the function also! So :„'DW segment to poke word to„'DW offset to poke word to„'DD Dwordvalue to poke„'---------------------------------------------------------------„DEF SEG = VARSEG(dword&)„ptr% = VARPTR(dword&)„LowWlowbyte% = PEEK(ptr%): LowWhighbyte% = PEEK(ptr% + 1)„HighWlowbyte% = PEEK(ptr% + 2): HighWhighbyte% = PEEK(ptr% + 3)„„DEF SEG = pokeseg%„  POKE pokeoff%, LowWlowbyte%„  POKE pokeoff% + 1, LowWhighbyte%„  POKE pokeoff% + 2, HighWlowbyte%„  POKE pokeoff% + 3, HighWhighbyte%„DEF SEG„END SUB„„SUB Pokestring (segje%, offje%, main$)„'------------------------------------------------------„'this function pokes a string (might be asciiz)into„'memory at a given location, making it possible to„'access strings in byte form„'------------------------------------------------------„„DEF SEG = segje%„FOR i% = 0 TO LEN(main$) - 1„  POKE offje% + i%, ASC(MID$(main$, i% + 1, 1))„NEXT„DEF SEG„„END SUB„„FUNCTION replace.newint$ (vector&)„'-----------------------------„'EXAMPLE OF A REPLACE_HANDLER„'------------------------------„'This handler is an example of hooking an interrupt on„'print string. When another function then function 9„'is requested then the string will be printed,if the„'normal printstring is requested( function 9) then„'this handler will print only 'B'.„'---------------------------------------------------------„'DATA  'Make our vector to fit the string way of saving„'-------„vector$ = long2str$(vector&)„'----------------------------------------------------------„'CODE„'----„'0) Preserve the registers on entrance„'push ax„'push dx„'push ds„'1) Imitate an interrupt„'pushf„'cli„'2) Condition to be met„'cmp ah,09                   'print string ?„'jz newint                   'if zero move to our newint„'3) Oldint„'call vector$                'if not then execute int 21,9„'jmp end                     'and jump to the end„'4) Newint„'newint start:„'popf                        'original flags„'mov ah,2„'mov dl,42„'pushf                       'simulating an int call again„'call vector$                'execute druk tek b„'5)Closing„'end :„'sti„„'pop ds„'pop dx„'pop ax„'iret                        'back to calling routine„'-----------------------------------„'pusha„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„„'asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)     'mov ah,9 test is oke„„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&HFA)                         'cli„asm$ = asm$ + CHR$(&H80) + CHR$(&HFC) + CHR$(&H9)'cmp ah,09„asm$ = asm$ + CHR$(&H74) + CHR$(&H7)             'jz newint„asm$ = asm$ + CHR$(&H9A) + vector$               'call vector$„asm$ = asm$ + CHR$(&HEB) + CHR$(&HB)             'jmp end„'newint:„asm$ = asm$ + CHR$(&H9D)                         'popf„asm$ = asm$ + CHR$(&HB4) + CHR$(&H2)„asm$ = asm$ + CHR$(&HB2) + CHR$(&H42)„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&H9A) + vector$               'druktek(b)„„'end:„asm$ = asm$ + CHR$(&HFB) 'sti„'popa:„asm$ = asm$ + CHR$(&H1F)„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'retf:„asm$ = asm$ + CHR$(&HCF)„„replace.newint$ = asm$„„END FUNCTION„Tommi Utriainen                CHANGE COLOR OF SCREEN BORDER  tomppa@pcuf.fi                 09-14-97 (21:42)       QB, PDS                15   250      BORDER.BAS  '--- change screen border colors„„' $INCLUDE: 'qb.bi'„„DIM inregs AS RegType, outregs AS RegType„„inregs.ax = &H1001„inregs.bx = &H1100„„CALL INTERRUPT(&H10, inregs, outregs)„„'SCREEN 0, 1„COLOR 1, 15„PRINT "see borders"„LINE INPUT a$„Petter Holmberg                FILE ROUTINES USING INTERRUPTS petter.holmberg@usa.net        10-29-97 (01:20)       QB, PDS                236  8300     QFILE.BAS   ' -------------------------------------------------------------------------- '„' QuickBASIC file routines, ver. 0.9beta                                     '„' By Petter Holmberg, 1997 (petter.holmberg@usa.net)                         '„'                                                                            '„' This program demonstrates file I/O using interrupts. With these routines   '„' you can instantly access up to 65536 bytes from anywhere in files up to 2  '„' gigabytes long, or directly write up to 65536 bytes to such a file with    '„' the speed of BLOAD/BSAVE. These routines will be included in a disk I/O    '„' library that I'll hopefully release for January 1, 1998.                   '„'                                                                            '„' These routines are just a preview of what they will look in the upcoming   '„' disk library. The routines in this program don't check if the drive of     '„' the file to be read from or written to is ready, they don't feature any    '„' checking to see if the file pointer exceeds the file length, they don't    '„' tell you if you have read past the end of the file, and in that case how   '„' much data you recieved and they don't tell you if you have written past    '„' the amount of free disk space aviable.                                     '„' These are just a few of the things not supported yet. However,             '„' these routines are very useful for QuickBASIC programmers since the BLOAD  '„' and BSAVE routines have a 64k file size limit and the file GET and PUT     '„' keywords are based on the length of the variable used.                     '„'                                                                            '„' If you want to experiment with these routines I strongly advise you to do  '„' so on a floppy disk, since I can't guarantee the results of using these    '„' routines in uncommon ways. Please note that I don't take any               '„' responsibility for any damage whatsoever due to the use of this code.      '„' These routines are just beta versions and they haven't been tested for     '„' bugs and errors, the whole code was written in just one evening.           '„'                                                                            '„' Any comments and suggestions can be sent to: petter.holmberg@usa.net       '„' If you use this code in your programs, all I ask for is some credits.      '„' Petter Holmberg                                                            '„'                                                                            '„' -------------------------------------------------------------------------- '„„TYPE RegTypeX„  ax    AS INTEGER„  bx    AS INTEGER„  cx    AS INTEGER„  dx    AS INTEGER„  bp    AS INTEGER„  si    AS INTEGER„  di    AS INTEGER„  flags AS INTEGER„  ds    AS INTEGER„  es    AS INTEGER„END TYPE„„DIM SHARED inregs AS RegTypeX, outregs AS RegTypeX„„DECLARE SUB InterruptX (intnum%, inregs AS RegTypeX, outregs AS RegTypeX)„DECLARE SUB ReadFile (filename$, filepos&, destseg%, destofs%, readlen%, fileerror%)„DECLARE SUB WriteFile (filename$, filepos&, sourceseg%, sourceofs%, writelen%, fileerror%)„„' --- Demonstration code:„„CLS„INPUT "Input a file name (Make sure it's not already used!!!): ", filename$„„' Create and reset file:„OPEN filename$ FOR OUTPUT AS #1: CLOSE #1„„teststr$ = "This is a test"„„PRINT "Test string: "; teststr$„PRINT "Writing text to file...";„„WriteFile filename$, -1, VARSEG(teststr$), SADD(teststr$), LEN(teststr$), fileerror%„„IF fileerror% > 0 THEN„ PRINT "Error!"„ PRINT "Error code:"; fileerror%„ END„ELSE„ PRINT "Done!"„END IF„„PRINT "Reading from file...";„„' Blank out the string:„teststr$ = SPACE$(LEN(teststr$))„„ReadFile filename$, 0, VARSEG(teststr$), SADD(teststr$), LEN(teststr$), fileerror%„„IF fileerror% > 0 THEN„ PRINT "Error!"„ PRINT "Error code:"; fileerror%„ END„ELSE„ PRINT "Done!"„END IF„„PRINT "Text returned: "; teststr$„„SUB ReadFile (filename$, filepos&, destseg%, destofs%, readlen%, fileerror%)„„' This SUB reads a certain amount of data from a file into system memory.„' - filename$ is the name of the file to be read from.„' - filepos& is the starting position in the file for the reading. Due to„'   overflow errors, you can only define a number up to a little more than 1„'   megabyte. This will hopefully be fixed in the finished version.„' - destseg% is the destination segment in system memory for the data to be„'   transferred.„' - destofs% is the destination offset in system memory for the data to be„'   transferred.„' - readlen% is the number of bytes to be read from the file. If you want„'   to read more than 35536 bytes, write the number in hexadecimal.„' - fileerror% is a variable containing possible errors. The error codes are„'   listed below:„'    0: Call successful, no error„'    1: File not found„'    2: Path not found„'    3: Too many open files„'    4: Access denied„'    5: Access code invalid„„filename$ = filename$ + CHR$(0)„fileerror% = 0„„' Open the file for reading:„inregs.ax = &H3D00„inregs.ds = VARSEG(filename$)„inregs.dx = SADD(filename$)„InterruptX &H21, inregs, outregs„„IF outregs.flags AND 1 THEN„ SELECT CASE outregs.ax„  CASE 2: fileerror% = 1„  CASE 3: fileerror% = 2„  CASE 4: fileerror% = 3„  CASE 5: fileerror% = 4„  CASE 12: fileerror% = 5„ END SELECT„ EXIT SUB„ELSE„ filehandle% = outregs.ax„END IF„„' Set the file pointer:„inregs.ax = &H4200„inregs.bx = filehandle%„inregs.cx = (filepos& AND &HFFFF0000) \ &H10000 AND &HFFFF&„inregs.dx = filepos& AND &HFFFF„InterruptX &H21, inregs, outregs„„' Read the data:„inregs.ax = &H3F00„inregs.bx = filehandle%„inregs.cx = readlen%„inregs.ds = destseg%„inregs.dx = destofs%„InterruptX &H21, inregs, outregs„„' Close the file:„inregs.ax = &H3E00„inregs.bx = filehandle%„InterruptX &H21, inregs, outregs„„END SUB„„SUB WriteFile (filename$, filepos&, sourceseg%, sourceofs%, writelen%, fileerror%)„„' This SUB writes a certain amount of data from system memory into a file.„' - filename$ is the name of the file to be written to. Note that the file„'   specified must already exist.„' - filepos& is the starting position in the file for the writing. Due to„'   overflow errors, you can only define a number up to a little more than 1„'   megabyte. This will hopefully be fixed in the finished version.„'   If you set this varable to -1, the data will be written to the end of„'   the file.„' - sourceseg% is the destination segment in system memory for the data to be„' - transferred.„' - sourceofs% is the destination offset in system memory for the data to be„'   transferred.„' - writelen% is the number of bytes to be written to the file. If you want„'   to write more than 35536 bytes, write the number in hexadecimal.„' - fileerror% is a variable containing possible errors. The error codes are„'   listed below:„'    0: Call successful, no error„'    1: File not found„'    2: Path not found„'    3: Too many open files„'    4: Access denied„'    5: Access code invalid„„filename$ = filename$ + CHR$(0)„fileerror% = 0„„' Open the file for writing:„inregs.ax = &H3D01„inregs.ds = VARSEG(filename$)„inregs.dx = SADD(filename$)„InterruptX &H21, inregs, outregs„„IF outregs.flags AND 1 THEN„ SELECT CASE outregs.ax„  CASE 2: fileerror% = 1„  CASE 3: fileerror% = 2„  CASE 4: fileerror% = 3„  CASE 5: fileerror% = 4„  CASE 12: fileerror% = 5„ END SELECT„ EXIT SUB„ELSE„ filehandle% = outregs.ax„END IF„„' Set the file pointer:„IF filepos& = -1 THEN„ inregs.ax = &H4202„ inregs.bx = filehandle%„ inregs.cx = 0„ inregs.dx = 0„ InterruptX &H21, inregs, outregs„ELSE„ inregs.ax = &H4200„ inregs.bx = filehandle%„ inregs.cx = (filepos& AND &HFFFF0000) \ &H10000 AND &HFFFF&„ inregs.dx = filepos& AND &HFFFF„ InterruptX &H21, inregs, outregs„END IF„„' Write the data:„inregs.ax = &H4000„inregs.bx = filehandle%„inregs.cx = writelen%„inregs.ds = sourceseg%„inregs.dx = sourceofs%„InterruptX &H21, inregs, outregs„„' Close the file:„inregs.ax = &H3E00„inregs.bx = filehandle%„InterruptX &H21, inregs, outregs„„END SUB„