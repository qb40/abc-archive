Peter Norton                   PC PAINT PROGRAM               PC,PAINT,PROGRAM               Unknown Date (00:00)   QB, PDS                243  8736     PAINT.BAS   TYPE RegType„        ax      AS INTEGER„        bx      AS INTEGER„        cx      AS INTEGER„        dx      AS INTEGER„        bp      AS INTEGER„        si      AS INTEGER„        di      AS INTEGER„        flags   AS INTEGER„END TYPE„„        DIM InRegs AS RegType, OutRegs AS RegType„        DIM Storage(31266) AS INTEGER„„        GOSUB Initialize„„        DO„            GOSUB GetLeftButtonPress„„            IF MenuSelectionMade% THEN „                GOSUB MenuChoice„            ELSE„                IF DrawFlag% THEN GOSUB DrawPixel„                IF LineFlag% THEN GOSUB DrawLine„                IF BoxFlag% THEN GOSUB DrawBox„                IF CircleFlag% THEN GOSUB DrawCircle„                IF PaintFlag% THEN GOSUB DrawPaint„            END IF„„        LOOP WHILE 1„„        END„„Initialize:„        SCREEN 8„        LOCATE 1, 1„        Fore% = 1„        Back% = 2„        COLOR Fore%, Back%„        PRINT "Exit    Color   Bkgrnd  Draw    Line    " + _„         "Box     Circle  Paint   Save    Load";„„        InRegs.ax = 0   'Initialize mouse„        CALL INTERRUPT(&H33, InRegs, OutRegs)„„        InRegs.ax = 1   'Show mouse cursor„        CALL INTERRUPT(&H33, InRegs, OutRegs)„        DrawFlag% = 0„        LineFlag% = 0„        BoxFlag% = 0„        CircleFlag% = 0„        PaintFlag% = 0„        RETURN„„GetLeftButtonPress:„„            DO„                InRegs.bx = 0          'Wait for left button press„                InRegs.ax = 5„                CALL INTERRUPT(&H33, InRegs, OutRegs)„            LOOP WHILE OutRegs.bx = 0„            Row% = OutRegs.dx \ 8 + 1„            IF Row% = 1 THEN„                MenuSelectionMade% = 1„            ELSE„                MenuSelectionMade% = 0„            END IF„            RETURN„„MenuChoice:„            DrawFlag% = 0„            LineFlag% = 0„            BoxFlag% = 0„            CircleFlag% = 0„            PaintFlag% = 0„            Choice% = OutRegs.cx \ 64 + 1„            SELECT CASE Choice%„                CASE 1„                        END„                CASE 2„                        Fore% = Fore% + 1„                        IF Fore% > 15 THEN Fore% = 0„                        COLOR Fore%, Back%„                        InRegs.ax = 2   'Hide mouse cursor„                        CALL INTERRUPT(&H33, InRegs, OutRegs)„                        LOCATE 1, 9„                        PRINT "Color   ";„                        InRegs.ax = 1   'Show mouse cursor„                        CALL INTERRUPT(&H33, InRegs, OutRegs)„                CASE 3„                        Back% = Back% + 1„                        IF Back% > 7 THEN Back% = 0„                        COLOR Fore%, Back%„                CASE 4„                        DrawFlag% = 1„                CASE 5„                        LineFlag% = 1„                CASE 6„                        BoxFlag% = 1„                CASE 7„                        CircleFlag% = 1„                CASE 8„                        PaintFlag% = 1„                CASE 9„                        InRegs.ax = 2   'Hide mouse cursor„                        CALL INTERRUPT(&H33, InRegs, OutRegs)„                        GET (0, 8)-(639, 199), Storage„                        DEF SEG = VARSEG(Storage(1))„                        BSAVE "PAINT.DAT", VARPTR(Storage(1)), 62532„                        DEF SEG„                        InRegs.ax = 1   'Show mouse cursor„                        CALL INTERRUPT(&H33, InRegs, OutRegs)„                CASE 10„                        InRegs.ax = 2   'Hide mouse cursor„                        CALL INTERRUPT(&H33, InRegs, OutRegs)„                        DEF SEG = VARSEG(Storage(1))„                        BLOAD "PAINT.DAT", VARPTR(Storage(1))„                        DEF SEG„                        PUT (0, 8), Storage, PSET„                        InRegs.ax = 1   'Show mouse cursor„                        CALL INTERRUPT(&H33, InRegs, OutRegs)„            END SELECT„        RETURN„„DrawPixel:„                InRegs.bx = 0          'Get left button releases to clear queue„                InRegs.ax = 6„                CALL INTERRUPT(&H33, InRegs, OutRegs)„ „                DO„                    InRegs.ax = 3„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    X% = OutRegs.cx„                    Y% = OutRegs.dx„                    InRegs.ax = 2   'Hide mouse cursor„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    PSET (X%, Y%)„                    InRegs.ax = 1   'Show mouse cursor„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    InRegs.bx = 0          'Left Button Releases„                    InRegs.ax = 6„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                LOOP WHILE OutRegs.bx = 0„„        RETURN„„DrawLine:„                X% = OutRegs.cx„                Y% = OutRegs.dx„                XOld% = X%„                YOld% = Y%„„                InRegs.bx = 0          'Get left button releases to clear queue„                InRegs.ax = 6„                CALL INTERRUPT(&H33, InRegs, OutRegs)„„                DO„                    InRegs.ax = 3„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    YNew% = OutRegs.dx„                    XNew% = OutRegs.cx„                    InRegs.ax = 2   'Hide mouse cursor„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    LINE (X%, Y%)-(XOld%, YOld%), Back%„                    LINE (X%, Y%)-(XNew%, YNew%), Fore%„                    XOld% = XNew%„                    YOld% = YNew%„                    InRegs.ax = 1   'Show mouse cursor„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    InRegs.bx = 0          'Left Button Releases„                    InRegs.ax = 6„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                LOOP WHILE OutRegs.bx = 0„        RETURN„„DrawBox:„                X% = OutRegs.cx„                Y% = OutRegs.dx„                XOld% = X%„                YOld% = Y%„„                InRegs.bx = 0          'Get left button releases to clear queue„                InRegs.ax = 6„                CALL INTERRUPT(&H33, InRegs, OutRegs)„„                DO„                    InRegs.ax = 3„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    YNew% = OutRegs.dx„                    XNew% = OutRegs.cx„                    InRegs.ax = 2   'Hide mouse cursor„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    LINE (X%, Y%)-(XOld%, YOld%), Back%, B„                    LINE (X%, Y%)-(XNew%, YNew%), Fore%, B„                    XOld% = XNew%„                    YOld% = YNew%„                    InRegs.ax = 1   'Show mouse cursor„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                    InRegs.bx = 0          'Left Button Releases„                    InRegs.ax = 6„                    CALL INTERRUPT(&H33, InRegs, OutRegs)„                LOOP WHILE OutRegs.bx = 0„        RETURN„„DrawCircle:„                X% = OutRegs.cx„                Y% = OutRegs.dx„                XOld% = X%„                YOld% = Y%„„                InRegs.bx = 0          'Get left button releases to clear queue„                InRegs.ax = 6„                CALL INTERRUPT(&H33, InRegs, OutRegs)„„                DO„                   InRegs.ax = 3„                   CALL INTERRUPT(&H33, InRegs, OutRegs)„                   YNew% = OutRegs.dx„                   XNew% = OutRegs.cx„                   InRegs.ax = 2   'Hide mouse cursor„                   CALL INTERRUPT(&H33, InRegs, OutRegs)„                   CIRCLE (X%, Y%), SQR((X% - XOld%) ^ 2 + (Y% - YOld%) ^ 2),_ „                       Back%„                   CIRCLE (X%, Y%), SQR((X% - XNew%) ^ 2 + (Y% - YNew%) ^ 2)„                   XOld% = XNew%„                   YOld% = YNew%„                   InRegs.ax = 1   'Show mouse cursor„                   CALL INTERRUPT(&H33, InRegs, OutRegs)„                   InRegs.bx = 0          'Left Button Releases„                   InRegs.ax = 6„                   CALL INTERRUPT(&H33, InRegs, OutRegs)„                LOOP WHILE OutRegs.bx = 0„        RETURN„„DrawPaint:„                X% = OutRegs.cx„                Y% = OutRegs.dx„                InRegs.ax = 2   'Hide mouse cursor„                CALL INTERRUPT(&H33, InRegs, OutRegs)„                PAINT (X%, Y%)„                InRegs.ax = 1   'Show mouse cursor„                CALL INTERRUPT(&H33, InRegs, OutRegs)„        RETURN„Rich Geldreich                 SMOOTH MOUSE CURSOR            SMOOTH,MOUSE,CURSOR            07-20-92 (00:00)       QB, PDS                248  16609    CSRDEMO.BAS DEFINT A-Z  ' Created by BIN2QB 3.3 freeware 7/92„f$="csrdemo.lzh":LSBs=3„CLS : PRINT "Creating ";f$„OPEN f$ FOR BINARY AS #1 :FSize&= 10730 „ON ERROR GOTO Done:LOCATE 2,1:PRINT STRING$(78,176)„DO„  READ Lyne$:LynLen=LEN(Lyne$)„  FOR i=1 TO LynLen „    Power=((i-1)MOD 4)*6„    B&=(ASC(MID$(Lyne$,i,1))-59)*2^Power:C&=C&+B&„    IF i MOD 4=0 THEN„      Stored&=Stored&+3:XCk&=XCk& XOR C&:LOCATE 2,1„      PRINT STRING$(CINT(Stored&/FSize&*78),219);„      IF Stored&>FSize& THEN LSBs=3+(FSize&-Stored&)„      Bin$=LEFT$(MKL$(C&),LSBs):PUT #1,,Bin$:C&=0„    ENDIF„  NEXT i:LOOP„DATA _[TFg\AGhG=;;;kC;;;;@pBxS;M;FGoOMLOLHx_FH@oMs@MN;;kKND@L@poNiCOK„DATA Np[=>H`O=@oOns]K<HP>EooNPt]K<HP>EGMAhkAUpoMY<;;;qA;;;?gaw^<C<ckK„DATA NDPKNp_FJD_M^`QN;;K;UDqaPNfsZbWJ`LCghI<I<>tTPd]cn>^pXBRhlqMxE];p„DATA e<@OIBrSjQMH^FtzsU=@=I=kj=GAwMnAsLTOC=JClZV]@<]VRCdyYXmdKT\G_zVh„DATA <o^TfdygnQ]UNhjAC>[;yjUpUR`TTpugRxiQueUgUhvIVwP\mLem_jA@nkfX`zbj„DATA YShrH=]SxpDJ>s@AsYVRKD]UQSQ]DDjRWXwX]Msu;er<RcKDgQP]Ik<o[=K_IKWX„DATA [SoRIfCxnZGZ;us;ond^;KbQN\unUXDpWbpTN;>?\dR<;[ZiSCX?@UYnw>CRnL\o„DATA AfJOgcGHdXy`nW=y<[Vo>g>^jzY>K^^;SaZg[InSFE\<]ysryxzfxhUi\Esyyzox„DATA zpzAccHw;rksVhyAdgdFLFv_sdX`o_JpB_nV[?Jt<EYL>YTeB[CZJK?=YK?_o`>\„DATA Bc<MaN=]kOHCeLE>s]BQSNOZ>BQCKlaDsGYS<X]NTdCr`sa?rakQ\SFh>Ig[[spx„DATA OaiPHVZNk=mHhkAUpomE@;;;wD<;;ohYo^<C<WKNJP`F=@oOXnQN;;;<jgqiLVUr„DATA fyg?YyZpk>`H<K[hTPaMs\[lUp=S?X^@V^BqZ^^WhYZJXvGmjZwBvzD;>O]_DpqP„DATA @FdrH;zGgSdMsVmqsDZQjt\rVkU^aQiVjghxiRYSsJkyNylGIjxsw=jQIG_nMIko„DATA HB>o[]WYOJP?\_<oEkGKab??Sk_c][NC[snWDNTz[GPHOwHr@Qs<DHIOEWp=<AgV„DATA h>Tt<HiCMH`aDCKyxKE_nfoKcsLceKMh[WowBeD\RwdG=if`=wy>ZESpYvlAQQrD„DATA WdN<bAcKNiQbFi\vub\jz@^ODCSQ_==Dn>eQczO?<_pqogCV]e\C?\NSLOMIMAeL„DATA joPEeGq^Vw\soXVSGGLKOEV@@<<WnhnBHwSZCpxV]^`zESR<EKPkSEDNquNKLFe>„DATA m@nVr_W@P[]c]CVK@LT[d;XFw?b_PK\WcUV;qVIE;MbBk<cW^B_@=;;bqfQLE^r]„DATA XS<KI\f][?`WIfuPczG;`>nyCEbIdQgDy;hA;]i[@YeeATwO?PFDn`GTEw]L^xGD„DATA <LD[^`uSUyX?IlkHhStDFdKcNoOD=Od]_iqX^efQ@K;_]Ecb^hC;K=S<DP]@OMOf„DATA nCi[coEBY>=_tA`;cWfbu_VYmErss<QZqr=huguR[yD^`>ovRp\OmA_OTRkScROi„DATA c`E`i_C=gdMQ<kk`g=UDKwoEq?d>YE=Ns]^GQqIdu_;DHQqLbziIviv`XBw\N?iY„DATA RByisUIJJtn>]Er<KcPA@AG<DyPbHrxlyvzP>@MIZFUSIUiIrcVQx^R<;wYdWrcl„DATA ^zilnxfAzvbHThVgMu@vchVw^Ed>olilrP<wVDtha>V`Ip^_nnh`BzYc[H`bvaXB„DATA B_FidRegb_tQrFOj\f=yBjy[qzZNEIOVuSFPVkCuCaQrXX;uKCy?CzNonvxTYQj^„DATA HrCxG_f^ABPdgGUfOQbWtjNXyCU^]geuDBWnDYGw^RgNqH<>SYXvWFbbD\LmlOcg„DATA Mk;IcUi@bpcbXgvHC]Mku\]vGngZAemhrxnL_v\Zn^JRY`GTX=Qz]DJ`kPvsA\]I„DATA R<?SOq?JbmToiGSNTatNhJ]EvLduGFKIc;Fko?kgHtKE=TiIFsYIOmv^^A`M>`Pu„DATA <NaFbd[pMOJuwlIoMb=fHdP@ldrCqAwx\^kiBh@ytT[`O]gTDNwYOZMtqBgUAod<„DATA QpbbWKlst[D_vVk_Wo?cntzdlT>QQ_tX;knvaed?dTGV`GBfs@j^aTzzVUwBKDbi„DATA jbxRuXY<;ezwtbJfhdxsIMn_naqjfaQtlqUQ`ICqqYhcRCnjNX=WjCqjOJVi[@>t„DATA `qofaCGqfntAZpW>VI?f\z\TB]_]uyUp[iqZbAlTAl<@vZywcMdqkEHtOZeqRjvx„DATA \tBa<hINxVMS<NdishdGd=KHDtL=`W>hyFgHaHEbKzE^uHBrVBdtmN`dpoEyno_?„DATA pX`\dm>yCF;lxEo@ojLFUtw=DsDABtCKkvEUW@pf<<A_yUiw?>ZdkGG>o]Gmnvlu„DATA ;SNna\t\eQ^hAPDOLFJ_ifJWiwxbSbHZKAe`WkAPjGEVn?eCywU[b>ZGfpejnj=n„DATA zitU<ZhZjoDVw?[iaD]DoOz_qylGnzkziXpWKPochkDJsrfxr]P[WaNqCwv`Kwtw„DATA @E>q?SVWdN<viudD?wU\w>hCOxC;O=]Y@zBr[kB^cnJkD;C[>Q`QNHZz]UCH]atK„DATA VhFUG@xd_LzifbbrXvkeYiRvhbULxQFLNz[t]IXciB`XLzxRksBcnfGmMupT>ZRa„DATA ]xqwD[NN]UDV?eyrxv]x;WhZokvClo=VcPNFOR;;;[S?;;;XkCJA[?[=>H`O<HPN„DATA i?oOHLh]H<;;?oxWVBhhYUEYlbmtxbj_q=h`yhh_MVTC]`PD`AnMDt=?Keu@Blxs„DATA `j@ZRZrI_KZtrJb^t[A<@vM?<i<Fh;y=\gMj;wy<qp<hhTvrUpyzYRPeeTy=q>JW„DATA Rz<oSj[ULHukQ;`Ma_@tmCC<_Kk=qtH;KoGr\mrv=j\tCauGysNE]iGQXwyXYu<v„DATA >VGE^dNsISO@tshf^JcpzkD_TU?doM?aJ;]FNKkg\\sv<APAJO]XA=J@?fSfIL<@„DATA LV;=D>LzsWi<<f;YCteU<VILGMj[E?Wk]kG`Hf]xXheOhi_[gGeSfEpxtKe?y\kN„DATA =KGtQs<>b[PbQnaLCL=y\]pweG`JstKEGJtL?eR?;kMwTQpk=U;dNlS=e?Cf_Hp?„DATA fvfYHNq\Li?DJetg>KQ;lGILLN<@`Psl<[QUPOHFkOYQpqEypjYGcmhXIYEdisqf„DATA I[F?yXdB^eeknPRRljypI[_N[]suWT_;aTb;DPDE?FdLK[dQsaetc_ugEDx<RMBE„DATA i>=L@YhfhGT^ckr<GrGIhGnpKd\miEMUUgd]z;bRKfBzouIovSqZVyuHP>wWgl\q„DATA _y]^`DonwDnoBFg^kxd^kMeY=LHWd_itM>>NPICo`uQSR]VvYq@=AA=VtvDt]HUu„DATA TsM[Xqu;gCsvep>chsy[i[ZazTKAOWgHaE^eB<rKQ?rp>x_`sUQ]bLTTvt;OnUxF„DATA JX>_SJvWBW``?=k]pC]@En@tl@dL>xw[<BgY@XEF]vLE^QT]tMIqCUA=Z_LD_iBl„DATA xwtCx@XAZH_F_tu<BjGRMkAYoftFUQpgZjfph;hlNpTrcJqHZv?YG?XnuDolQPu=„DATA Q=IZwRF[MbdCKj<DkolCnS`;`?Qp_hYfZKECZm^=tAH=qkSL`HqP?Uaq^?PLDfYY„DATA `rHocN]Fp`>m[WSMF=XPiL<zpMs=OVtVZmTke]aycxlyD@_Sgm[eBOGLptGOv>]R„DATA ?Hq?ejpuHD>KFEqFvBEOwfhZZzMqDsHJ>=QwnmfLd<zQBb^ie`Sv`iCCYTzKjIRr„DATA ykHURE>CE>OSRiX<RlWiNImBNCIYmcrCh;rNK@ogWPs`@LpDrQuocISW`O^BTDV>„DATA bSsKA[<oMxzwm;@=LdfQOaRGJxPVv>AUa^s]uc\WNcSGDYmpW@SuM_?sEFxmkBDD„DATA wta<Ev_LDL`E]l_ySbWW=jGpajFXlELK^ThbiY<]wsXk;adKQENe]?H`FJswWUEK„DATA ZXfkqcrK>KYlvkAP_mBnqQ=DqO=k_MOWk@XCyrqHVgLRyiH^\HN>@HE;hWfGxCFD„DATA qANrdHh@\I]TD=h`Mo[oSiivI\HjWnojPgxq<FcxzzrO>ral[JYj@nRFrnYJV>vq„DATA _YNsWZBTXt;fwrDwO_pE]TWpck@dgnkLVC;rZPDsr]PHwgnqO>gTc]VygF[\Xkv`„DATA wmZ^;<i[oP>ioD\Na\h\fF]S]><HdHq\U?\Ad[AlxleGL<OQBuchg`lw<>lJmKpE„DATA T=pE_^cTD_itN[dhA_KblFCDGu\?P@UF<NXLOmGE]xNGAmw^Ke@;Y[RY<m;\QH_A„DATA lJeJkGA[ykVuRUKe?DHzL^tViN=i;>jNYyg\mkwEgUq>DDV?KiUuPKN^Dggek;FP„DATA DgqzLhSXSkMyS]gYi=gq;]hZGvnykbVTBNVXll?j]NUmLZP]bOdhA>UJyO@jz\tS„DATA DTG>uiWZRn=zFwbE^tOaVQJNYFljL^LMCQpZBsg_vuCV>Zj?mUypqBVOGXPEaIMR„DATA SRxdacQRqdCMD^Sr\ubKxZGhc<WO>AzASBUVaedREJqpYUKewGH<GHtZlVvikraf„DATA ujDUftbIzVBZjheJpBurRhOq\S^<=db`pHK^gtIz^WhuW]pyCzAPP?NsuZuuA@Vs„DATA etHKX^w@mO;rUMbMZMotzqH?o[DXjeMuBZmf=@VkpZOttvsYkUvZun<BZdFxttzL„DATA YOyuOFR[EjR\@ZVrFVLCrVpGcJwWO_D^zGQ>I^^zITwAWIb>ITwAWIrrTKlScnHZ„DATA oTgzXBnjNnj@BFTf;H]ShkAUpomu<;;;KH;;;cxYo^<C<cKOGD?NDD_FO\@PsiON„DATA ;;K;hJq`lMgcSVzMZ=Jk@DTnKG?;ktWYGMYsY`Nk^lk=qyZfMryrYrhqnlbWzVJ\„DATA ^?=\Czh>LNVbuFIr>ytrV[a>iteftTYyhtyonryyfY_RU>[yZwXkuWKguOZvhBpz„DATA BycGIuUYqEamiaNPlAJmS[YLsRh@N;E<[vvaSii;q[sEapV;tqC?`Qh[peyngIKW„DATA w[YA;sDVYS`JVMXd=o[zD<[>;RLjfQTX<kc<<dZxxhv;S?FfnsB>HEv]Fnv=?sN_„DATA f[pubid^cu>aYDuRBe<_XHMDI@Bu]QCarZ_MUQW[yVjcBdbyPGXaiPzzIkbd_ydl„DATA XuvvOlYduXEXtXU>Ve=vky\^bheHjvIaE>eyyYDtAczjC;X?Etqz_CH>uP@MpIwk„DATA zZayofEF@Kzt\yrkZGHy@Pn@XY^\k[cQC>ci]sZyioq@>c_aJza<HZKTkhGQDrTj„DATA wpEnLTkuV_gCVAHH>W^<@hSksQhXOHkCCVx\=oBr<LUbDN\mQ_[cCDMV>S>eKZg_„DATA fDUMUBFZDGZntYuscsv<VeLO?dNNR[Rg_jYnOtdH<PEk\KdCr?gRFXC]_@MSlTKf„DATA B>i`Fd]wF_Q[RUlEzGm>cHoAg[lMQ;X@w=v=NfarkOcHbPIXnfQLEnWEbASnX\qh„DATA DClXmguKcrMf]nrTSMMchkAUpo=??;;;Dd;;;OOZo^<C<gkKND@L@poNiCOKN\nL„DATA H<;;>ssUVBfdXZntMsnz\P_;_HIKHt=humi]H[hxASyADi`jyg<sUocjNkBtalzs„DATA jv>S=>`_hSVQjHWYh[VXHUosfzrVxRzaQGw?tAVgPQgzso@FZrL[UYLxB[Ww<`mm„DATA HwyXu]Ze`[tnUKMam_tDSQnC?F<[YIa[plLHEZsn?Cj]SMQFOPb;PZ<eYrJbuCoG„DATA C[Oo??JBL;ECXCAcPUL;CGDoM];Wy`bT?@E<k]jBM@L`IRY<=?\ADOSfc\IqXdGi„DATA yFTrb;dwU=M`NSUA@wDouO`QDMu[LyhzkGYSQiDYkKjzQna>vitUDOY=CS>FSIBG„DATA IWJZ=ppEz]eoddNxoWFDzsCYN`LhnnHuSX;FahDjlLjYSKe]kvLA\[?RYB[baBJJ„DATA NrsvFSi>hE<HsXPjCavN]WPc[hx]]@gboPe?jgbXVgI<u>iBGwec^_AxOBxc=TI`„DATA aj;`jC<JQp[]pF_y\IHenYlj_vfpfOHVK<rQa<Wkpq;kgsk@kYsJ`dhjVxTgQa@l„DATA zkUfEhPx`Uj_YLKZPiuiTTlH`CqvMWneRdcgxOPdqFzCrVhfhNQQ_ZTYQwb[zsyl„DATA Pzb]pAliyB\xQtU`EH]tRez]pAtwEDpXV_pKo@uttirfBInLdGKvGrpFomIU=Pr;„DATA @>?J`=?JE<iDipLlhVWvxCWzbPczlfyISHcvZtephJ\oTyFblzkFEddXdmiZOKUw„DATA fboO_cvADCu\rR@HP?O<Cj=N>uQJFZu>q<NrVQ;MUSfpLRILl]qTMy[gMBCgYj^H„DATA B;GHIVyYkMrOB_bx;_VWZC_UysUeNSMY[kpIAdu_?GUoj>_=\QoVDY^EFUht>gap„DATA ndOUZc^sBG^>w=IxfNB[nAq`ngK;kj;cnBsYj=[T^t[JMKCr`?[ikG;VwtXrdkAq„DATA ^e`DNojfvCBuh]Hf>r?^HUNHupFN^dWPgbC=QBnGVcS[QNZboSgUX@[Ucj@SyKsM„DATA ?CnO`DiaPnno__gb`LxSHY]\MIuGGN^\SdnVPpUdUKBldisu=CWBOcUxE=LnQHCf„DATA ^ADsQ@pbTJG=F^U^mOp=rx_ctBjLWx\ZoEOMyB]UjtNhTzhAwiUgTTaGuWgbDqPJ„DATA r]seFmRgOfxTdOlMrM;G?K=zsx\wW>JOZWcsOC@FsX=gmmydjOHlqITlQsz^B_sk„DATA ABLLWeyfoFNU`MrnEJRm;Vgw_@oGF>mrfVOyED`SOkseQSAP^]`f^>uO_L[umoa^„DATA =]u_pUxqASRqSqaGWpCQjohPUGGTnTl@SaUXYc_eezmn;cpxAUPgnnPXgnxpc_LI„DATA zHerQGSu>agLENd>AhTynlpuSdn\zKU\ramsw_RlxVeElZiU<AHPeIU<LxIsV_[r„DATA CJYb\mxqHNa<VqJAuJB@XQFU`AOefVkGzNri`nJ=N^_CA=?DPq=VcPNFaD;;;__<„DATA ;;;JuLJA[?k=H@oM@HoOMt]K<HPAXo?;;CKIeptXOhXuZfn>z@HggetmJcrbqVnp„DATA gtK_ZMYHfU;Hd[FqyAFNfY;nmyx\jsxQo[;Ss<liRi<W^VBR^aq?IThYUfzHJi?q„DATA p=O_IfFnzmL]V_mcX<>NdKO?_O`AASobcT=eeK?mYMU^CTT^=b[sDGSjD;<<HN[g„DATA IaYD<@?UiBlc=^O_GOCfbghH_EP_uaNCGI?<_nBNEQbc\KMxK`k;njAM]AThp_y^„DATA US^ocUOurJuODQbgrWtIJUSiyjEfg]fyUaRgRAFnjXYX<fUMuR]cxlbcvZ@gLgyv„DATA MuIUNSJMaKFhfDd?M\j\W]Gn>LR`BhPXOIgMLg>IPTTWIchOCDeCfnGlKdAlilsb„DATA x]yfYLpXO\=FSQTDjsSOMpNsdea^HeFvEQ?NEi<L`zmLAMgKO\xbywx;vbKOO<HV„DATA =ZUFod>=edHd<F_M;QLNr>b=JTqLRA>qTIinmyQ@FO@crGIaFL?ztlVKh>lU?uLo„DATA A[VKh>lU?uLoA[VKh>lU?uLoA[VKh>lV<xLhToCzKwAu>AbYj^`yCGiTIhbixoJ=„DATA XXAXq;yS_PjOji;^GsEjXkyZB@qXzLeWKO>Uou>C<ZZKxjAfiIfbhlU[fUHTe@zV„DATA lgGaA>qWBGvztzTjxHSQVINZryuvjbWRs>akzkY<k=?Akuz\P=yiK]jMNCHA=ZgM„DATA Nu^Wg`vZMFQBtJDIZjquhySeXr]fnuATOHyn@F?cKEj_KSzSZV_YVABKfGusFpIu„DATA WsJKPlWyBt@ZR]S=Id[k[xl>Ly>AJSYVIBkekdEIZlTla?igDDa[kxgQCwVJ>DUn„DATA F\\]>BgScqNVZwv`pP@G_KUFg\QHhKw?;;KHy;;;idDzS;M;FGoOMDOKNH^F=@oO„DATA JtLN;;K>rkRbqpuhVGvuqNqrrr]<DuI=MfOMqMXUwa_CVY`aDDzDXqdWc\z_]^C]„DATA Ko;;O[obIy^zvvHw;;[MdS=pJevlnk]aQow=mTYNFWdPdnxmptQtir<fLUvqTjzJ„DATA jZJuuVVOrL=?Bps@PEEHn@O\CDYnG;`KI]tGAhiuDq\`gi`L\Gsv^fF\zQsBzdkH„DATA gsa`jVCLohv[Uo^]vl[EjwLvGNj^]WxcLnqgfrBz^C@^Lf=ArAdmGaAvNhZG]QNL„DATA U;fcwcQ]CPSjAXBKI_NmPg<]<YJdiSWkk\i]?g>]pEzCGO;kbFcBoe>yR^N][kg^„DATA r=inG]JtlmpUFRqYU?d\RgR@ECmlAWAgjQq;cBw;;n?yv\^H]@nIg?<LhBjpWn^E„DATA MNSl>>NEqD>r`EZoKy^R=bnSj<n`;m>o<x=mq;Sd_RKF=>Yg>T[KI;CB_AIBaPYb„DATA QWzNwsabwkUuLa\g]]N?ftarHqwmQkkX`bHvQ<T=RsErbVjC`rymqkAayLtJ?_^?„DATA oFwkFYWY]>isMDFLG=?gSZoJ@hya;JdIkRYgvILMC?jjby`u^GP\>N;W^lOE<^lH„DATA @Cg>ikK=[[<_[Gjp?mECJ@GA[z?Z?X[JpC?dd;yX;TaQc>fK`yNxRUL?yPlJT?=J„DATA XFMFTNVH<C[ylySJ?V]@lPGq=k@wKkKaTMfFZWzVwWug^;l?[hKdp=v]KVLlyRu^„DATA iSlEsMuGABKzGuokOOQmgD[^wBPdmN\R>qN]LE?\g=w`crlGzKSXwWbFxzz<Pldy„DATA WfM^SHm`HCGpT;t[];C<FkaN_RBt=Z?q<q^tp\=;ZFq=mNBIFUnvTRf^gmR<JaVi„DATA tivdZ_kSirivru@uLgKxq=ISDRDZ>JWOFU<HjWZu`bCBzDKCKgepxy?vMDZiu^^z„DATA F?gAHKjRBI^GVgJxG=r\tBA<sPrqGd@;qCMDlaAUOlPClpSAtDOaMoLKCM;qYoG\„DATA S>=IQU\COHwxFnKBKXuCCyFaf;Tpcuqn_u=AQueOAvHO;I;m_KKDVD]kP[LpNKnU„DATA PDhr>RXSc`MSDyTQpZajgbr?RagQv]cBtIl@SHzfousCORgIzlQfBDNtK\?cG[PL„DATA P^mw;bQ[SHB<?Nm]D>;wCsl`Ydc^c^zMSCOjuK_tq^qRCA<>NLZP>qNrGEnRlEXT„DATA egUfr@KVGER_pw=s@uxdZl;<S\BRhg?^GeKYeJ;g?<Y>Jg;zgdatHB\di<Kj;Lwr„DATA QD=>>VPcd<cKZEG@WvQNPHviMSgci\YVWnUVo;ILLDgUTJLjSHY>VVgccdhp<lV[„DATA Ykgl<f?]<=duPBW?`v\F`YyZhP=qkCB@VyK`>uUDpnJJxYLOSRdguUbONcldgDcC„DATA Com@KrCHHHc<G_xLLh=]^uIHcCHUQ\QBSaNU^aW;cCeq`JAtWTMTiQe<alX[iPDF„DATA BKYMpKsXDZua@k@`<ChTdGRSPNqsEe<]hHiFdgd?W?\AuLhN@mXbfiOrMNxdD?PU„DATA SbrTH<^LgVKr`Q<hSpKJmHOyLJAA;@BuZL_Xi_EsLBWref]\Xfd]t=_FfnL^P]PB„DATA ?bYIOMBTIWK^_]H]RECx?lRSpsQ>W`AdD;OPVu=?gbTreCiyfdI^K=>Gc=yYi;=q„DATA Y@kXl<<Fu<@<\L=q?evA^fbU@ut@A@JxZ<Da_h<puNF;cuDSu;G@YH=\i>OeXhSK„DATA FKYoQe[Lnn?EsThK?e@bfUSwGdWNI[?sclAWzCqowp=ilEalbGDp@hsr>G@PKFrW„DATA UVFCggvYu]>ijk`>nbW`lCtR[Gr[U^;WAY]lrYvBEsfb^K[;gkCcZ@jCyPhBZE@F„DATA QqeyUT_MwL<G;D<Uex_GxsTBckQooHsmKUeERxWh[MzVYCWra>XO@NfT[e[TLBDs„DATA oDnLFlONQxNnryFr>X]EuKDAs]ySm>Rsl[SsA=<vo_AA_rYY[p;RSlEYHb[IUPZl„DATA >`[KUQAU^cIsa@RTKDUFaW<LSn;Qohk\yG[xlcSYNLlMhjCf_H?pl]JVzEJLZAXx„DATA llHt`ZIjIqkfjzMRYEO\?HmIEbO;;yZYqqeVhnl[w;OL`OE?Kd=BDPKgkXgi@f;q„DATA XasIC[wCqomtXirn@B@fDBvOmVKw?\_JFdFLwHnb[?ncZAAnrS^[UooCn^Yh`Bqw„DATA W[p^Etb@vereqX?P[p=GJkANIc_^Vh;Jq\kW]^ytvaR?OMmYcfHh]BnAcXRo_\w^„DATA lKGtnIBFG@tmO[f^Wdo[wcPoHV=AIo_B=fkmPsozNiXlc>boDep?NaMIfZiAFE<M„DATA By?Anr@p]JrAyn>a\jzSe<fWvyofsSWtO]DpATbtWMkCBqKM=O`_\spNjxLC;VgW„DATA YO=;vpCoo@XgOntiF;\ptMaqwNyppZM;<GtJvG@OUQQtb;;mLcnGbk=r;jbtcnJF„DATA k<ZR@<a[ge]G\iI>]FBF<`nkIo`bb<rK?;`SIaFEJWli>UesisJB]KBgg\zKL<sC„DATA U\lG?q[?KzK_bnAzhzWg_nZIszeWoJrfhdGi;hNi=sQclZGksYCiHDvcPyp\ytGu„DATA M<zs__oRoAbsvEx<=o\EVzJd]dzxOOweVlFThZserMSdXnw\U;G?VRyCCQDsCODs„DATA ocnGZX]eDKeFDKfGDKgGDwX>wuuaRjtGZi=YQsk=wUx<xjp^BIOzwYqk[=OpfE\v„DATA s_R[dP_VZWWs<vYKRK@<]YJXnhJB=<jv^ZB@w<`TGkOA\;vPxWdI<d]gz_WBh`It„DATA ta_fKUymYoIdQ<Y<NLsZlz[zxS;ClDzw]wIhf\rkir?hpoeVRjTh[s;^USBDfAjP„DATA X^[LCGGDGquULbATf<Z]OTvNVIcvsaK?faEjK]?RuNYX>i>vpHD?V[WZ;nPxvbS_„DATA s^zFkPKmmygntp>jWiDZ@ajk@nxaQ?hsJBfwHZdThxcawx`HXysaJV^RWjhBd?VV„DATA e\HrVu=nVvLMlnbqqd^gzzsLtiEFujnJxcsl^IYYaOkYltRDrDdSRhh]bHcjmdnT„DATA [W=?KLwgnl;nIlpi@`\>=HCFwKdKgfz;gFcy=fI\KVkpVD=<f];iVKZYMKLmd@<c„DATA mQ[GIqral=;G^JqRgXGzd@b?fK\pNNuQ]lpt=QnVig^hFr<JGMHn_L`tlJlbEh\L„DATA KC?__TmhjlbsOc=GioOw=`bWxtES<_FT]xHvSFqcTgoERPSmLFH=CFS=RcV?fPBY„DATA @azeqetsqGBDUizmYT=tgoWDXYLJJRhYYDf\NRMmzUVfyxcebzNAl[FoVpcNdzTD„DATA nIcZkSaEWqDOi;L`P>\ILqJh[W[>O<=fGT?undOkqCN@G]R>Zf]ffcWqtKBMp=>G„DATA sggKi;QMIdcOi>oz<U_TwfUMW?E>]MgjnTHjYvPNxCuFvtqWrUrYtJNTl<VxgjeC„DATA jWu<TXWgALDI]xQKUccFWVJBPkZ;[TYm^GEHTwjSqoYnQY_lwZulLfAVMqzvcjjf„DATA LCUbnYxuPFeFl\myLt^t^dyRoqsIfjcb<I\@acC\;mHjG]=OfeATCoiccORy^I]z„DATA sJEfTjx_pgLsaSPXlNmFFbKPCXxmmV_bWhOLWapb;JbL>r?@eTxUqUPUb<NVLKXb„DATA PkKKgnOQJNTAoKeAcv]?BNgPow=mN\tmPg=WES^fx>v\rTnL>jNaiB]wEqdJ?\IE„DATA ?h;u=`<B=wSQlBtZP[kb;YaMNZ@r>VyAFQeIXamyeIU<hoK<Veu;QE;<cWembl[O„DATA Q?Ya<aqCJCQP;TlDyeM]zfYIEdC<]XJrtYjMJzDyLDIaBD`^eB`hMs\_`qtMJnOs„DATA @THjyjt`jLB=ltZV\vhAItKIVnvsVpTjss_nv]HDVOHPzB@RWJvE;xeKebxTaIu[„DATA fBECzbpBwcYq@QTFOzCEpiXibFvOuE<snYcQoR>SmgVcJHPMHbXefzgPUqq;KoWF„DATA o;?DoB;YTVfRixkaQPYNEL=V`UcyAfEY?<hMdnPyvjS`=RkhNFDiAhzYyypCTo_O„DATA urOhnvypdLPewX]tsc;a@dEX?=WQsrOms`?aS]^=UbBCPUo=jK@VsojyZl^qTX]o„DATA ZERnQ?dPO=PvgMhidIu>@HffKn=nXg=wI=re\wo`AeEnIQNv>RahxUdLMXx`\DaT„DATA UgAF<d\e\LFvdnMumYMUc]wqaponphhbvggZvoGKkGQeVKHVhJeKnB<`NuKR?oye„DATA f@[ageST\fPPIe`DACu_d]PEfL`\Lc>Ew_;[gAFl_T;i>bjEfg?Kx\rzhUlqhqJT„DATA p;<GRRrAQNjpNtdcjlBx[hcMGR`cp?Klidxn@trvWdJcawXRND?fcZxIV]Y]^iUf„DATA ecvSOTp]ICcZBSzje@U[JZiQtORy\Y@yaTR@PllFx>`^XyISR<=_zSBkcerEQLGP„DATA \_cIENSGxHhft@nBWxbWpckJuVkZZFKXKcNZ[k_aP]R_G_S=x\QIBwUgQmSJ_LZz„DATA dzcZtZamvMZBnWRBfOVEFQ=qGwdJGQmtZeB`AuQOawv[joOSzYPF`Nw]WFFaX@ew„DATA @rRlNX_w>ntloJE[dCFkHUzAd=BdiLlbl?=UMoOVcQ__WxB?NVqd]q]\Y_VagEKh„DATA >u<_ML_<FNkdo>x^QhJATsmWkOb<ysj_jiXgfRj]Ep\[WkXF^cB[uSaDuVzHK=]k„DATA r^j@HD>oxF=`\X]wokSBzrmXqDczaqnPr`tXhlrMsoSyKaJYmBp^[ZsUNzZewmAC„DATA hyPlwyOAUvmJqHn_kWBTvwoEOcRLa;OEiwzZGHljehmGjizDZDj[^IOWhew;ctAp„DATA cQGMZVOou<nQ\KXR;guGI[vUroGZ[nrmIrWUQ^ufmBxRZfOjgvuyvzaEomGHHjo=„DATA =mWsewOaaeBbtQ;ZIw^nDkgN<MSOCB[yEPQoicBem=kkUQOI`aAYSXpTJSfHUbPv„DATA eOYBKl]GCzb[zuaQ\b_VsPzhAlcbi<^trg\l;S\pXNLSdS<y[iwDkVt[KlXsZI\h„DATA lJ]PB[LcksYFmOY`g[CsE^GAqSr`bdDRfN@X=]J@y^IfQhxuHbFssCc>wIn?L=D>„DATA PU^H>pffOjn\?ijKOt]CQe`cs_szBBTg<dmplGWIiX^SDxP;>ukBgf=XfSWIXi<@„DATA SQsHCNcqdY_P@i^GRImckgsWKUPamOUl?_GiVM]YHM;fRvdU?ex`YOHAgBkVSikZ„DATA s>[cuMQTF_OKMvWzJUrgmndZxvEr;uSPr\TH@ZhMLM>`hSCCjhSfWneeoS`upxMs„DATA bbKABQPhf]tfzcBy_U[lAJn<<PfOQ\R@HTel;MPYXi@Pqdkah[zBQHGMs=CN>tfq„DATA EEsLmYaRR`@Mq]KReNKpaVddVGCfd>Zu[VYbGPYqXstgbN=DBe=QJVQkR>]uRMRd„DATA ePV;oKTquq_DzYmYDlUNeO^G]uAOgQOopUnPrljeVeL]?xCFubduW\BEHlmmayLI„DATA ej`LcVDeuJOf@qMqL?LNnwWlfjDU[WQkXrkVa^c?Lr>DYylBd<ermFhPxVuYdJU@„DATA m;UHCgMu^AYdNPILqpo`fQ`InwgeZa?PQS?MXX^R<TXMXbd`sQrItveyFgZOb__K„DATA zemSNYfOJ]O[V[VbgLgPuZPV<KrXQ@T\klODqQNtzgTDnvv=b]R?;eDCtY>UJsGJ„DATA al`ThH=RpkX`jN@RE\ZvIDTzVlM\n_FN\ZETQ;rHta<l;BhGfPBe^\^hThl^WcwW„DATA mK__fNsZCaDdQFbflHHcCfJ`tg_XegXU\^;gW]G<W_b=icpBzrHRgetq=ahUfs=c„DATA kpQOk`TFRzipLUMhySvopSvey>ogZxFLvD]IlJ=j?sEw>@tFlWgR<GKKZ=dCKj]w„DATA G`Q`YRh=d^^Cedh`cp?PNZeKsu]haic^Ce=EkimK[^JZhjEYAZpwAm]fDSp^b;A<„DATA UmZNV\^l]hM<EJASaTVhfsM]`d[_QYKbFNdeEDd>LTQhLMcYpHpZ^[@mIrjIdxRV„DATA LxKZxh=KdW@v]D<vgj_=?EZ`LWcby`eRBJica_nNa]egPh`cHuTeu^ugZZOAjT`X„DATA yyfV;mj?ebm[uLCJu_hIUFYr[Z=]L_vr]Uh<i\ZdxM`u<ES]d>pv_bodJd;ChfUk„DATA DSusKK<Je``Vv^uWKlxe;pCOAM;\fsD\mPtUIMWJdUuFXs]^dZzdbVohNzVefOBa„DATA hP_iynfugg^OrFtRqsmuISa`YRxSZiPGVUVfx[Qz_uqPjFvOcg;HJqO_IdzcsogM„DATA PCvhbRzf@P`@dX@d=Llcr@TOSTo\_SE\D?_WmRQ[PMtSTF^Vn^almKa@mel]DYJP„DATA mRskIOw<ksUlt<Pc]E@>F`fPD^fK=PaP=[sYD_gEPD<<G@Q_tFF`?C]xLugLOd>u„DATA WcGwdhX>`X_GrE\WeTHohKmteGs<pFelksjgqz]iei=zeBmzFdcyN`CZdQJpK>io„DATA ORFuxoPu@Xe[dA>E]UXrJOGRTXXMZZHNiElXpjQAd^VpU<sOMFGnIlffJtfSAfz]„DATA WKZFCFTfgMTv_XtU_gXRId]v`IuGp[uLfMxcmhYimSXRPWUXlxdpnMmm_XIz\Uqh„DATA gVZpa_P>`iwru^jrrffhqxsmEXVJqYrf^e^jJiRckiItwFmGHp\fZZiqzZ=lzJts„DATA pHsQPmJXoGkquMbiWYtO_vrVxhAbggIYzEzYjJBmzHurzrHwzPHwujWLuzZBJhSt„DATA dmrpBj>tuzy]gzvaeR^vpJkwyg^?YdsPBnGneaTaMbmL<jkCleUWcvsW]eTZoy`]„DATA meQ\@WCwc_TpJN[ScAMoRNSPz=MhjWANLA^wnoFB;DaiHtUbn@oSxRrFBF?IE]Mw„DATA mG_DGDyV@V?XhquxO>mHKxXPktl<kEhpKemDJ;ScvnURonh@zcfVN``lU=^xrYb\„DATA NIc^TDyoXPgn=ftyNbTFrO]__zxqQ`uF;<;;„Done:CLOSE #1: PRINT„IF XCk&<> 7796697  THEN „  PRINT "DATA corrupt!  File deleted."„  KILL f$„ELSE„  PRINT f$;" created."„END IF:END„Unknown Author(s)              TEXT MODE MOUSE DEMO           TEXT,MODE,MOUSE,DEMO           Unknown Date (00:00)   QB, PDS                261  6165     MOUSDEMO.BAS' Text Mode Mouse Demo„' First call MUST be to initialize mouse„' Right Mouse Button to Quit Program.„„DEFINT A-Z„'$INCLUDE: 'QB.BI'„„DECLARE SUB SetUpGrid ()„DECLARE SUB PrintMsg (PosX%, PosY%, PrintTxt$)„DECLARE SUB Reverse ()„DECLARE SUB DspButtons (Buttons%, PX%, PY%)„DECLARE SUB Normal ()„DECLARE FUNCTION IsMono% ()„DECLARE FUNCTION Rand% (MaxValue%)„DECLARE FUNCTION GetButtonUpStatus% (Button%, MPosX%, MPosY%)„DECLARE SUB MouseHandler (ax%, bx%, cx%, dx%)„DECLARE FUNCTION GetMouseStatus% (MPosX%, MPosY%)„DECLARE SUB MouseOff ()„DECLARE SUB MouseOn ()„DECLARE FUNCTION MouseReset% ()„DECLARE FUNCTION ThereIsAMouse% ()„DECLARE SUB ClearButton (Button%)„DECLARE SUB SetMouseSoftCursor (MouseChar%, MouseFGColor%, MouseBGColor%)„„COMMON SHARED /QBMouse/ True, False, OutRegs AS RegType„„DIM SHARED SWidth, VideoAddr„DIM SHARED PrL, PrR, PrLr, PrM„DIM SHARED PrLM, PrMR, PrAll, PrNone„DIM SHARED ForeGround, Background, HiLight„DIM SHARED ButtonLeft, ButtonRight, ButtonMiddle„„DIM SHARED MouseVisible, MHMax, MVMax„DIM SHARED MouseIntr, MHCell, MVCell„„True = -1: False = 0: SWidth = 80„„'Mouse button press definitions„„	PrL = 1: PrR = 2: PrLr = 3: PrM = 4„	PrLM = 5: PrMR = 6: PrAll = 7: PrNone = 0„„'Button definitions„„	ButtonLeft = 0„	ButtonRight = 1„	ButtonMiddle = 2„„	IF IsMono THEN„	   ForeGround = 7: Background = 0„	ELSE„	   ForeGround = 3: Background = 0„	END IF„„	SCREEN 0: CLS : SetUpGrid„„	IF ThereIsAMouse THEN„	   PrintMsg 24, 1, "Mouse Installed"„	   SLEEP (1)„	   IF NOT MouseReset THEN„		  PrintMsg 24, 1, "No mouse reset"„		  END„	   ELSE„		  PrintMsg 24, 1, "Mouse reset"„	   END IF„	ELSE„	   PrintMsg 24, 1, "Sorry, there's no mouse on this system"„	   END„	END IF„„	LOCATE 25, 1: Reverse: PRINT SPACE$(80);„	LOCATE 25, 1„	PRINT "(Press Left Button to change mouse,";„	PRINT "Right Button to Quit)";„	MouseOn„	ClearButton ButtonLeft„„	DO WHILE Buttons <> PrR„	   Buttons = GetMouseStatus(MPosX, MPosY)„	   DspButtons Buttons, MPosX, MPosY„	   IF Buttons = PrL THEN„		  MouseCharacter = Rand(255)„		  IF IsMono THEN„			 SetMouseSoftCursor MouseCharacter, 7, 0„		  ELSE„			 FGColor = Rand(7)„			 BGColor = Rand(7)„			 SetMouseSoftCursor MouseCharacter, FGColor, BGColor„		  END IF„		  MouseOn„		  PrintMsg 2, 40, "MouseCharacter: " + STR$(MouseCharacter)„		  PrintMsg 3, 40, "MouseFGColor: " + STR$(FGColor)„		  PrintMsg 4, 40, "MouseBGColor: " + STR$(BGColor)„		  ClearButton ButtonLeft„	   END IF„	LOOP„	MouseOff„	END„„SUB ClearButton (Button)„	   WHILE NOT GetButtonUpStatus(Button, 0, 0): WEND„END SUB„„SUB DspButtons (Buttons, PX, PY)„	Reverse„	LOCATE 24, 42: PRINT "Buttons: ";„	SELECT CASE Buttons„	   CASE PrNone„		  PRINT "None          ";„	   CASE PrL„		  PRINT "Left          ";„	   CASE PrR„		  PRINT "Right         ";„	   CASE PrLr„		  PRINT "Left & right  ";„	   CASE PrLM„		  PRINT "Left & middle ";„	   CASE PrMR„		  PRINT "Middle & right";„	   CASE PrAll„		  PRINT "All           ";„	   CASE ELSE„		  PRINT "Unknown " + STR$(Buttons);„	END SELECT„	LOCATE 24, 66: PRINT USING "XPos=## "; PX;„	LOCATE 24, 74: PRINT USING "YPos=##"; PY;„	Normal„END SUB„„FUNCTION GetButtonUpStatus (Button, MPosX, MPosY)„	   ax = 6„	   bx = Button„	   OutRegs.ax = 0„	   OutRegs.bx = 0„	   OutRegs.cx = 0„	   OutRegs.dx = 0„„	   MouseHandler ax, bx, 0, 0„„	   MPosX = OutRegs.cx \ MHCell + 1„	   MPosY = OutRegs.dx \ MVCell + 1„	   IF OutRegs.ax = 0 THEN„			 GetButtonUpStatus = True„	   ELSE„			 GetButtonUpStatus = False„	   END IF„END FUNCTION„„FUNCTION GetMouseStatus (MPosX, MPosY)„	   ax = 3„	   OutRegs.bx = 0: OutRegs.cx = 0: OutRegs.dx = 0„	   MouseHandler ax, 0, 0, 0„	   GetMouseStatus = OutRegs.bx„	   MPosX = OutRegs.cx \ MHCell + 1„	   MPosY = OutRegs.dx \ MVCell + 1„END FUNCTION„„FUNCTION IsMono„	DIM InRegs AS RegType„	InRegs.ax = &HF00„	INTERRUPT &H10, InRegs, OutRegs„	IsMono = (OutRegs.ax MOD 256 = 7)„END FUNCTION„„SUB MouseHandler (ax, bx, cx, dx)„„DIM InRegs AS RegType„	   InRegs.ax = ax„	   InRegs.bx = bx„	   InRegs.cx = cx„	   InRegs.dx = dx„	   INTERRUPT MouseIntr, InRegs, OutRegs„END SUB„„SUB MouseOff„	   IF MouseVisible THEN„			 MouseHandler 2, 0, 0, 0„			 MouseVisible = False„	   END IF„END SUB„„SUB MouseOn„	   IF NOT MouseVisible THEN„			 MouseHandler 1, 0, 0, 0„			 MouseVisible = True„	   END IF„END SUB„„FUNCTION MouseReset„	   MHMax = 639    'Max virtual horizontal mouse position„	   MVMax = 199    'Max virtual vertical mouse position„	   MHCell = 8     'Mouse horizontal cell width„	   MVCell = 8     'Mouse vertical cell height„	   MouseIntr = &H33„	   MouseHandler 0, 0, 0, 0„	   MouseReset = OutRegs.ax„	   MouseVisible = False„END FUNCTION„„SUB Normal„	COLOR ForeGround, Background„END SUB„„SUB PrintMsg (PosX, PosY, PrintTxt$)„	LOCATE PosX, PosY: Reverse„	PRINT LEFT$(PrintTxt$ + STRING$(40, " "), 40);„	Normal„END SUB„„FUNCTION Rand (MaxValue)„	Rand = INT((MaxValue + 1) * RND)„END FUNCTION„„SUB Reverse„	COLOR Background, ForeGround„END SUB„„SUB SetMouseSoftCursor (MouseChar, MouseFGColor, MouseBGColor)„	   MouseOn„	   ax = 10„	   bx = 0         'Select software cursor„	   cx = &H8800    'Screen mask value„	   dx = &H8800 + MouseBGColor * 4096 + MouseFGColor * 256 + MouseChar„	   MouseHandler ax, bx, cx, dx„	   MouseOff„END SUB„„SUB SetUpGrid„	LOCATE 1, 1„	FOR I = 1 TO 80„	   PRINT RIGHT$(STR$(I), 1);„	NEXT„	LOCATE 2, 1„	FOR I = 2 TO 25„	   LOCATE I, 1„	   PRINT USING "##"; I;„	NEXT„	Reverse„	LOCATE 24, 1: PRINT SPACE$(80);„	Normal„END SUB„„FUNCTION ThereIsAMouse„	   IRET = 207„	   DEF SEG = 0    'Set to base system address„	   MouseSegment = PEEK(207) * 256 + PEEK(206)„	   MouseOffset = PEEK(205) * 256 + PEEK(204)„	   IF MouseSegment = 0 AND MouseOffset = 0 THEN„			 ThereIsAMouse = False„	   ELSE„			 DEF SEG = MouseSegment„			 MouseInstruction = PEEK(MouseOffset)„			 IF MouseInstruction = IRET THEN„					ThereIsAMouse = False„			 ELSE„					ThereIsAMouse = True„			 END IF„	   END IF„	   DEF SEG„END FUNCTION„„Unknown Author(s)              SIMPLE MOUSE ROUTINE           SIMPLE,MOUSE,ROUTINE           Unknown Date (00:00)   QB, PDS                49   989      SIMMOUSE.BAS'COPIED FROM COMPUTE APRIL 1992 PG 52„'ENTERED BY A. CHRISTOPHER OLIVER FOR SUPERLINK BBS.„'YOU NEED TO LOAD THIS TO THE BEGINNING OF YOUR PROGRAM.„'OR MAKE IT A LIBRARY„'SUPERLINK BBS - (904)735-2224 FRI-MON„DEFINT A-Z„'$INCLUDE: 'QB.BI'„DECLARE SUB HIDEMOUSE ()„DECLARE SUB SHOWMOUSE ()„DECLARE SUB GETMOUSECORD (K%, K3%, M4%)„DECLARE SUB STARTMOUSE ()„DIM SHARED Inregs AS RegType, Outregs AS RegType„ „STARTMOUSE„SHOWMOUSE„„DO„  GETMOUSECORD K, X, Y„  LOCATE 1, 1„  PRINT X, Y, K„LOOP WHILE K = 0„ „HIDEMOUSE„END„„SUB GETMOUSECORD (K%, M3%, M4%)„Inregs.ax% = 3„CALL INTERRUPT(&H33, Inregs, Outregs)„M3% = Outregs.cx% / 8 + 1„M4% = Outregs.dx% / 8 + 1„K% = Outregs.bx%„END SUB„„SUB HIDEMOUSE„Inregs.ax% = 2„CALL INTERRUPT(&H33, Inregs, Outregs)„END SUB„„SUB SHOWMOUSE„Inregs.ax = 1„CALL INTERRUPT(&H33, Inregs, Outregs)„END SUB„„SUB STARTMOUSE„Inregs.ax% = 0„CALL INTERRUPT(&H33, Inregs, Outregs)„Mouseinitialize% = Outregs.ax%„END SUB„„Unknown Author(s)              GRAPHICAL MOUSE GRID           FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS, VB            352  12088    MOUSGRID.BAS'„'                            G r i d  .  B a s„'           VBDOS/PDS/QB Code to Demonstrate Code Interaction„'                          with Mouse Clicks„'  „'               Program Quits on press of the <ESC> Key.„„' NOTE: Make sure to Load in the Default Quick Library using "/L"„' when running this code...„„' |========================================================================|„' | Note:  This  code  was  actually written  under VBDOS. While _all_ of  |„' | the  Interrupt Calls  would have worked under QB with just INTERRUPT,  |„' | _some_ of the Calls wouldn't have worked in VBDOS (or PDS Far Strings) |„' | without INTERRUPTX.  I Figured just  sticking to one type of Interrupt |„' | Call (IntX),  would  be easiest,  least confusing,  and most portable. |„' |========================================================================|„„' Define the Constants used for Button Clicks..„  CONST Raised% = 0: CONST Depressed% = NOT Raised%„„' =============================| Functions |==============================„' Draws a ScreenFull of Square Grids„  DECLARE FUNCTION DrawGrid% ()„„' Runs all the Routines in this Module„  DECLARE FUNCTION RunGridDemo% ()„„' Checks for Existance (sp) of Mouse Driver„  DECLARE FUNCTION HaveMouse% ()„„' ============================| SubRoutines |=============================„' Generic Mouse Driver„  DECLARE SUB Mouse (M0, M1, M2, M3)„'„' Displays Mouse Cursor„  DECLARE SUB MouseShow ()„'„' Hides Mouse Cursor„  DECLARE SUB MouseHide ()„„' Draws a Graphical Mouse Cursor„  DECLARE SUB MouseCursor ()„„' Polls for KeyPress or MouseClick„  DECLARE SUB GetEvents ()„„' Draws Individual Grid Elements„  DECLARE SUB DrawButton (XPos%, YPos%, State)„„' Draws Depressed/Released Button„  DECLARE SUB ClickButton (M2, M3, M1)„„' ============================| Variables |=============================„' Define the type needed for INTERUPTX call..„  TYPE RegTypeX„  ax    AS INTEGER„  bx    AS INTEGER„  cx    AS INTEGER„  Dx    AS INTEGER„  bp    AS INTEGER„  si    AS INTEGER„  di    AS INTEGER„  flags AS INTEGER„  ds    AS INTEGER„  es    AS INTEGER„  END TYPE„„' DIM the Interrupt TYPE ..„  DIM SHARED Regs AS RegTypeX„ „' Define the Grid Data as Shared„  DIM SHARED GridRows%, GridCols%, GridLength%, GridHeight%„  DIM SHARED RowOffset%, GridEndX%, ColOffset%, GridEndY%„„' Define Grid Error Handler Return Variable as Shared„  DIM SHARED Abort%„  „' ===================| Module Level Demo Code |=====================„  ' Set Up the Size of The Grid, before We Start the Routine..„  ' Start with your Original Configuration - an 8*8 box,„  ' in a 48*48 Grid ...„    GridRows% = 48: GridCols% = 48„    GridLength% = 8: GridHeight% = 8„„  ' Call the Main Routine„    Success% = RunGridDemo%„„ ' Or UNREM the lines below to try - looks like a SpreadSheet, and„ ' even though it runs off the Screen, you can still depress„ ' the buttons ...„   ' GridRows% = 6: GridCols% = 6„   ' GridLength% = 135: GridHeight% = 30„   ' Success% = RunGridDemo%„„    SCREEN 0, , 0, 0: SYSTEM„„' =================| Module Level Error Handler |==================„ErrorHandler:„   SCREEN 0, , 0, 0   ' Back to Text Mode ...„„   SELECT CASE ERR„   CASE 5           ' "Illegal Function Call" - Bad Screen Mode ?„    ErrMsg$ = "You Must have a VGA to run this program"„   CASE 6        ' OverFlow - Probable Too Large a Grid Square for Mem.„    ErrMsg$ = "Your Individual Grid Size is too Large for Memory."„   CASE 32766    ' Grid won't fit On Screen„    ErrMsg$ = "Grid Dimension(s) will not fit On Screen."„   CASE 32767    ' No Mouse Present„    ErrMsg$ = "There is no Mouse Present to run this Demo."„   CASE ELSE„     ErrMsg$ = "Unknown Error."„   END SELECT„„   L% = LEN(ErrMsg$)           ' Get Length of Error Message„   LOCATE 15, (80 - L%) \ 2: PRINT ErrMsg$  ' Center the Message„   LOCATE 17, 31: PRINT "Aborting Program."„„   Abort% = -1                 ' Set ABORT Flag„   RESUME NEXT                 ' Return to Calling Routine„„„' ========================| Mouse Cursor Data |============================„  DATA &HF3FF,&HE1FF,&HE1FF,&HE07F,&HE00F,&HE001,&HE000,&H8000„  DATA &H0,&H0,&H0,&H0,&H0,&H0,&H8001,&HC003„  DATA &H0,&HC00,&HC00,&HC00,&HD80,&HDB0,&HDB6,&HDB6„  DATA &H6DB6,&H6FFE,&H6FFE,&H7FFE,&H7FFE,&H7FFE,&H3FFC,&H0„  DATA 5 ,0„„SUB ClickButton (M2, M3, M1)„   ' Computes Button Top and Left withing Grid, then„   ' Automatically Calls the DrawBox Routine with the correct„   ' (Raised or Depressed) Parameter„   ' M2 - X Location of Mouse Click, returned from Mouse Call„   ' M3 - Y Location of Mouse Click, returned from Mouse Call„   ' M1 - Whether Mouse Button is Depressed : returned from Mouse Call„„    XOffsetIntoGrid% = M2 - RowOffset% - 1 ' Incremental Distance from„    YOffsetIntoGrid% = M3 - ColOffset% - 1 ' the Top/Left Edges of Grid„„    XGrid% = XOffsetIntoGrid% \ GridLength%  ' Compute Which Individual„    YGrid% = YOffsetIntoGrid% \ GridHeight%   ' Grid Unit was Clicked„    „    XLocation% = (XGrid% * GridLength%) + RowOffset%  ' Left Edge of Button„    YLocation% = (YGrid% * GridHeight%) + ColOffset%  ' Top Edge of Button„„    MouseHide                               ' Hide Mouse„    DrawButton XLocation%, YLocation%, M1   ' Draw the Button„    MouseShow                               ' Show the Mouse„„END SUB„„SUB DrawButton (XPos%, YPos%, State)„    ' Draws an Individual Button in the Grid,„    ' in either the Raised, or Derpressed, Condition„    ' Parameters: XPos% : Pixel Pos of Left Edge of Box„    '             YPos% : Pixel Pos of Top Edge of Box„    '             State : Either Raised, or Depressed„„    IF State THEN           ' Just Switch the "Foreground"„      Fg% = 8: Bg% = 15     ' and "BackGround" Colors (shading)„    ELSE                    ' to simulate either a Raised or„      Fg% = 15: Bg% = 8     ' a Depressed State„    END IF„„   ' Now Draw the Individual Button„    LINE (XPos%, YPos%)-(XPos% + GridLength% - 1, YPos% + GridHeight% - 1), 7, BF„    LINE (XPos%, YPos% + GridHeight% - 1)-(XPos%, YPos%), Fg%„    LINE -(XPos% + GridLength% - 1, YPos%), Fg%„    LINE -(XPos% + GridLength% - 1, YPos% + GridHeight% - 1), Bg%„    LINE -(XPos% + 1, YPos% + GridHeight% - 1), Bg%„„END SUB„„FUNCTION DrawGrid%„  ' Draws a Screen Full of Grids dependent on Variables Assigned„  ' at the Module Level.„  '          -=  Shared variables used are as Follows: =-„  ' GridRows% : Number of Grids along the Horizontal Plane„  ' GridCols% : Number of Grids along Vertical Plane„  ' GridLength% : Length of Grid in Current Screen Size„  ' GridHeight: Height of Individual Grid in Current Screen Size..„  „  ' Compute where to Center the Grid on the Horizontal ...„    RowBytes% = GridRows% * GridLength%     ' Pixels in each Row„    RowOffset% = (640 - RowBytes%) \ 2  ' Left Edge of Grid„    GridEndX% = RowOffset% + (GridRows% * GridLength%)„„  ' Compute Where to Center the Grid on the Vertical ...„    ColBytes% = GridCols% * GridHeight%      ' Pixels in each Column„    ColOffset% = (480 - ColBytes%) \ 2  ' Top Edge of Grid„    GridEndY% = ColOffset% + (GridCols% * GridHeight%)„„  ' Check to see if Grid will _reasonably_ fit OnScreen..„  ' (Don't want an entire Grid off screem , but Clipping is OK..„    ON ERROR GOTO ErrorHandler:„    IF RowOffset% < -GridLength% OR ColOffset% < -GridHeight% THEN„      ERROR 32766„      EXIT FUNCTION„    END IF„     IF Abort% THEN DrawGrid% = 0: EXIT FUNCTION„„  ' Draw a Simple BackDrop for Our Grids ...„    LINE (RowOffset% - (GridLength% \ 2), ColOffset% - (GridHeight% \ 2))-(GridEndX% + (GridLength% \ 2), GridEndY% + (GridHeight% \ 2)), 7, BF„  „  ' And Run a Loop, Drawing the Boxes OnScreen„    FOR YAxis% = 0 TO GridCols% - 1„      FOR XAxis% = 0 TO GridRows% - 1„        XDatum% = RowOffset% + (XAxis% * GridLength%)„        YDatum% = ColOffset% + (YAxis% * GridHeight%)„        DrawButton XDatum%, YDatum%, Raised%„      NEXT XAxis%„    NEXT YAxis%„„END FUNCTION„„SUB GetEvents„   ' Loops constantly, polling for either a Mouse Click,„   ' or Aborts on an <ESC> KeyPress.„„  DO„   ' Check for Mouse Click Event„     M0 = 3: M1 = 0: M2 = 0: M3 = 0          ' Initialize Ax  Reg only ...„     Mouse M0, M1, M2, M3     ' Call Mouse Interrupt„„   ' We don't care which button was Clicked, so just see if„   ' the Bx Register (the Value returned in the "M1" Variable)„   ' has a value other than "0".„    IF M1 THEN          ' Yep, Button was Clicked - is it in our Grid ?„      IF M2 >= RowOffset% AND M2 <= GridEndX% THEN    ' In Horz Grid ?„        IF M3 >= ColOffset% AND M3 <= GridEndY% THEN  ' In Vert Grid„          X1 = M2: Y1 = M3„          ClickButton X1, Y1, M1               ' Yep - Hilight Button„           DO„             M0 = 3: M1 = 0: M2 = 0: M3 = 0    ' Loop until Released„             Mouse M0, M1, M2, M3              ' Call Mouse Interrupt„           LOOP UNTIL M1 = 0„           ClickButton X1, Y1, M1„        END IF„       END IF„    END IF„  „  ' And Check for an <ESC> Key KeyPress...„    a$ = INKEY$„    IF a$ = CHR$(27) THEN Quit% = -1„„  LOOP UNTIL Quit%„„  „END SUB„„FUNCTION HaveMouse%„ ' Checks to see if Mouse is Installed„„  DEF SEG = 0„   MouseSegment& = 256& * PEEK(207) + PEEK(206)„   MouseOffset& = 256& * PEEK(205) + PEEK(204)„„  DEF SEG = MouseSegment&„   IF (MouseSegment& = 0 AND MouseOffset& = 0) OR PEEK(MouseOffset&) = 207 THEN„    HaveMouse% = 0„   ELSE„    HaveMouse% = 1„   END IF„  DEF SEG„„END FUNCTION„„SUB Mouse (M0, M1, M2, M3)„  ' Calls interrupt &H33 to invoke Mouse Functions in the MS Mouse Driver.„„  Regs.ax = M0: Regs.bx = M1: Regs.cx = M2: Regs.Dx = M3„  CALL INTERRUPT(&H33, Regs, Regs)„  M0 = Regs.ax: M1 = Regs.bx: M2 = Regs.cx: M3 = Regs.Dx„„END SUB„„SUB MouseCursor„  ' Reads in DATA for Mouse Cursor, Draws Mouse Cursor„  ' Using INT&H33 / 9„„  ' Read in Graphical Mouse Cursor Data„    FOR i% = 1 TO 32                     ' Run a Loop thru the DATA„      READ Wrd%                          ' Read in Integer Data„      MMsk$ = MMsk$ + MKI$(Wrd%)         ' Translate to BYTEs„    NEXT i%„    READ Hotx, Hoty                      ' Cursor HotSpot„„  ' Now For the Interrupt call ..„    Regs.ax = 9: Regs.bx = Hotx: Regs.cx = Hoty„    Regs.Dx = SADD(MMsk$)   ' Use with all Basics ..„„  ' Next Line not neeeded for QB, (Optional for PDS ??)„  ' But using it gives Far String Support.„    Regs.es = VARSEG(MMsk$)  ' Need InterruptX for this One ..„„    CALL INTERRUPTX(&H33, Regs, Regs)„„END SUB„„SUB MouseHide„    ' Hides Mouse cursor„      Mouse 2, 0, 0, 0„END SUB„„SUB MouseShow„  ' Shows mouse Cursor„    Mouse 1, 0, 0, 0„END SUB„„FUNCTION RunGridDemo%„  ' Sets Up Program - Returns TRUE if all went right„„  ' First, Check for VGA ..„    ON ERROR GOTO ErrorHandler:„     SCREEN 12„    ON ERROR GOTO 0„    IF Abort% THEN RunGridDemo% = 0: EXIT FUNCTION„  „  ' Blank the Screen while Drawing ..„    OUT &H3C4, 1: Cmr% = INP(&H3C5): OUT &H3C5, Cmr% OR &H20„  „  ' We've Got VGA, Now Draw the Grids ..„    Success% = DrawGrid%„  „  ' Turn the Screen back On ..„    OUT &H3C4, 1: Cmr% = INP(&H3C5): OUT &H3C5, Cmr% AND &HDF„„  ' Check for Error AFTER We turn the Screen Back on...„    IF Abort% THEN RunGridDemo% = 0: EXIT FUNCTION„„  ' Check for Mouse ...„    IF HaveMouse = 1 THEN           ' The Rodent is IN ..„      Mouse 0, 0, 0, 0              ' Initialize Mouse„      MouseCursor                   ' Draw "Pointing Hand"„      MouseShow                     ' Show Mouse Cursor„    ELSE„      ON ERROR GOTO ErrorHandler:„        ERROR 32767                 ' Invoke own Error„      ON ERROR GOTO 0„      RunGridDemo% = 0: EXIT FUNCTION„  END IF„„  ' Now Just hang around, waiting for Something to Happen ..„    GetEvents„„  ' If we Made it to here, everything's OK ...„    RunGridDemo% = -1„    MouseHide„„END FUNCTION„„Chad Beck                      MOUSE PAINT                    FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                70   2183     MPAINT.BAS    DEFINT A-Z„  '$INCLUDE: 'qb.bi'„  DIM SHARED Registers AS RegType„„  CONST GridSize = 8, BoxSize = GridSize - 2„  CONST GridColr = 8„  DrawingColr = 4                       'Selected drawing color #„  Colr = DrawingColr                    'Toggles black & DrawingColr„„'Initialize the mouse„  Registers.AX = 0„  CALL Interrupt(&H33, Registers, Registers)„„'Drawing grid„  SCREEN 12„  FOR X = 110 TO 500 STEP GridSize„    LINE (X, 2)-(X, 386), GridColr„    LINE (110, X - 108)-(494, X - 108), GridColr„  NEXT„„'Set horizontal boundaries„  Registers.AX = 7„  Registers.CX = 0                      'Registers.CX = 112„  Registers.DX = 620                    'Registers.DX = 495„  CALL Interrupt(&H33, Registers, Registers)„„'Set vertical boundaries„  Registers.AX = 8„  Registers.CX = 1„  Registers.DX = 452                    'Registers.DX = 382„  CALL Interrupt(&H33, Registers, Registers)„„  DO„  'Show the mouse cursor„    Registers.AX = 1„    CALL Interrupt(&H33, Registers, Registers)„Top:„    DO„    'Get mouse location and status:„      'If Registers.BX=1 then left button is pushed„      'If Registers.BX=2 then right button is pushed„      'If Registers.BX=3 then both buttons have been pushed„„      Registers.AX = 3„      CALL Interrupt(&H33, Registers, Registers)„„      OldButtons = Buttons              'Save previous button state„      Buttons = Registers.BX„    LOOP UNTIL Buttons = 1              'Wait for left button„„    OldX = Xo: OldY = Yo                'Save previous coordinates„    X = Registers.CX„    Y = Registers.DX„„    Xo = (X \ GridSize) * GridSize - 1  'Adjust for odd grid placement„    Yo = (Y \ GridSize) * GridSize + 3„„  'If the cursor or buttons haven't changed then do nothing„    IF (OldX - Xo) + (OldY - Yo) + (OldButtons - Buttons) = 0 THEN„      GOTO Top:„    END IF„    IF POINT(Xo, Yo) = Colr THEN Colr = Colr XOR DrawingColr„„  'Painting routine„    Registers.AX = 2                    'Hide the mouse cursor„    CALL Interrupt(&H33, Registers, Registers)„    LINE (Xo, Yo)-STEP(BoxSize, BoxSize), Colr, BF„    PSET ((Xo \ GridSize), (Yo \ GridSize)), Colr„„  LOOP„Glen Blankenship               MOUSE FUNCTIONS FOR QBASIC     comp.lang.basic.misc           Year of 1995           QB, QBasic, PDS        232  8114     MOUSE4QB.BAS'There are two core functions, InitMouse and CallMouse.  InitMouse„'establishes that a mouse driver is present and active and initializes the„'mouse to its default state.  CallMouse performs the actual function calls.„„'In addition, I've included subroutines for several standard mouse function„'calls.  The only one that's at all complex is the cursor-setting routine.„'Most of the others are simple "wrappers" that pass the caller's parameters„'on to CallMouse, after setting any unused parameters to zero.„„'It's easy enough to builds wrappers for any mouse functions I haven't„'included - just look at any list of Int 33h mouse calls, and place the„'register parameters in the correspondingly-named CallMouse parameters.„„'Here's the program:„'------------------------------------------------------------„'MOUS4QB.BAS - Mouse functions for QBasic„'By Glen Blankenship, 1995„'This code is hereby dedicated to the public domain.„„DEFINT A-Z„„'The two core functions:„DECLARE SUB CallMouse (regAX%, regBX%, regCX%, regDX%)„DECLARE FUNCTION InitMouse% ()„                  „'Wrappers for assorted mouse-driver function calls:„DECLARE SUB MouseHardReset ()„DECLARE SUB MouseShow ()„DECLARE SUB MouseHide ()„DECLARE SUB MouseGetStatus (LButton%, RButton%, WhereX%, WhereY%)„DECLARE SUB MousePut (XCoord%, YCoord%)„DECLARE SUB MouseHorizLimits (Left%, Right%)„DECLARE SUB MouseVertLimits (Upper%, Lower%)„DECLARE SUB MouseSetGraphCursor ()„„CONST FALSE = 0„CONST TRUE = NOT FALSE„„'=-=-=-=-=-=-= Test Program  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-„CONST LimitLeft = 100„CONST LimitRight = 400„CONST LimitTop = 50„CONST LimitBottom = 200„„CLS„SCREEN 9„IF InitMouse THEN„   MouseHorizLimits LimitLeft, LimitRight„   MouseVertLimits LimitTop, LimitBottom„  „   'Draw box to show Mouse Motion Limits„   LINE (LimitRight, LimitTop)-(LimitLeft, LimitBottom), 3, BF„  „   'Create a hand-shaped mouse cursor„   RESTORE Hand„   MouseSetGraphCursor„  „   'Place the cursor in the middle of the box„   BoxCenterX = LimitLeft + ((LimitRight - LimitLeft) \ 2)„   BoxCenterY = LimitTop + ((LimitBottom - LimitTop) \ 2)„   MousePut BoxCenterX, BoxCenterY„„   LOCATE 1, 1„   PRINT "Press either mouse button to quit"„  „   MouseShow                     'Make the cursor visible„  „   DO„      MouseGetStatus LeftButton, RightButton, XCoord, YCoord„     „      LOCATE 2, 1„      PRINT "X Coordinate:"; XCoord„      PRINT "Y Coordinate:"; YCoord       'Print Cursor Location„   LOOP UNTIL LeftButton OR RightButton   'Loop until either button pressed„  „   MouseHide                     'Hide the cursor„   MouseHardReset                'Reset mouse to default state„„ELSE                             '(If InitMouse returned 0)„  PRINT "No mouse active";„  SLEEP 1„END IF„  „SCREEN 0: WIDTH 80: CLS          'Reset to text mode„SYSTEM                           'Exit to DOS„„„Hand:          'Data for graphics cursor, used by MouseSetGraphCursor„„'First, the Hot Spot cordinates:„DATA  4        :  'X coordinate„DATA  0        :  'Y coordinate„„'Next, the two cursor masks.  The data is shown here as hexadecimal„'numbers.  Each hex digit corresponds to 4 bits in the mask.  The„'bits are shown graphically in the comment lines.„„'Screen mask - Clear bits black out the corresponding pixel:„DATA  &HF3FF   : ';X,X,X,X;_,_,X,X;X,X,X,X;X,X,X,X;„DATA  &HE1FF   : ';X,X,X,_;_,_,_,X;X,X,X,X;X,X,X,X;„DATA  &HE1FF   : ';X,X,X,_;_,_,_,X;X,X,X,X;X,X,X,X;„DATA  &HE1FF   : ';X,X,X,_;_,_,_,X;X,X,X,X;X,X,X,X;„DATA  &HE049   : ';X,X,X,_;_,_,_,_;_,X,_,_;X,_,_,X;„DATA  &HE000   : ';X,X,X,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &H8000   : ';X,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &H0000   : ';_,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &H0000   : ';_,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &H0000   : ';_,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &H0000   : ';_,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &H8000   : ';X,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &HC001   : ';X,X,_,_;_,_,_,_;_,_,_,_;_,_,_,X;„DATA  &HE001   : ';X,X,X,_;_,_,_,_;_,_,_,_;_,_,_,X;„DATA  &HE001   : ';X,X,X,_;_,_,_,_;_,_,_,_;_,_,_,X;„DATA  &HE001   : ';X,X,X,_;_,_,_,_;_,_,_,_;_,_,_,X;„„'Cursor Mask - Set bits invert the color of the corresponding pixel:„DATA  &H0000   : ';_,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„DATA  &H0C00   : ';_,_,_,_;X,X,_,_;_,_,_,_;_,_,_,_;„DATA  &H0C00   : ';_,_,_,_;X,X,_,_;_,_,_,_;_,_,_,_;„DATA  &H0C00   : ';_,_,_,_;X,X,_,_;_,_,_,_;_,_,_,_;„DATA  &H0C00   : ';_,_,_,_;X,X,_,_;_,_,_,_;_,_,_,_;„DATA  &H0DB6   : ';_,_,_,_;X,X,_,X;X,_,X,X;_,X,X,_;„DATA  &H0DB6   : ';_,_,_,_;X,X,_,X;X,_,X,X;_,X,X,_;„DATA  &H6DB6   : ';_,X,X,_;X,X,_,X;X,_,X,X;_,X,X,_;„DATA  &H6FFE   : ';_,X,X,_;X,X,X,X;X,X,X,X;X,X,X,_;„DATA  &H6FFE   : ';_,X,X,_;X,X,X,X;X,X,X,X;X,X,X,_;„DATA  &H7FFE   : ';_,X,X,X;X,X,X,X;X,X,X,X;X,X,X,_;„DATA  &H3FFE   : ';_,_,X,X;X,X,X,X;X,X,X,X;X,X,X,_;„DATA  &H1FFC   : ';_,_,_,X;X,X,X,X;X,X,X,X;X,X,_,_;„DATA  &H0FFC   : ';_,_,_,_;X,X,X,X;X,X,X,X;X,X,_,_;„DATA  &H0FFC   : ';_,_,_,_;X,X,X,X;X,X,X,X;X,X,_,_;„DATA  &H0000   : ';_,_,_,_;_,_,_,_;_,_,_,_;_,_,_,_;„„'End Test Program =-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=„„'--------------END MOUS4QB.BAS------------------------------------„„SUB CallMouse (regAX, regBX, regCX, regDX)„   SHARED Mseg, Mofs, MousePresent  'shared w/InitMouse„  „   IF MousePresent THEN„      DEF SEG = Mseg„      CALL ABSOLUTE(regAX, regBX, regCX, regDX, Mofs)„      DEF SEG„   END IF„END SUB„„FUNCTION InitMouse STATIC„   SHARED Mseg, Mofs, MousePresent     'Shared  w/CallMouse„„   CONST IRET = &HCF          'OpCode of IRET instruction„   CONST MVector = &H33 * 4   'Mouse interrupt vector address  - Int 33h„„   MousePresent = FALSE       'Assume no mouse„   InitMouse = FALSE„„   DEF SEG = 0                'Get mouse driver interrupt vector„   mv0 = PEEK(MVector)„   mv1 = PEEK(MVector + 1)„   mv2 = PEEK(MVector + 2)„   mv3 = PEEK(MVector + 3)„„   DEF SEG„   POKE VARPTR(Mofs), mv0„   POKE VARPTR(Mofs) + 1, mv1„   POKE VARPTR(Mseg), mv2„   POKE VARPTR(Mseg) + 1, mv3„„   'Check to see if driver is installed.„   'First, make sure vector is non-zero:„   IF Mseg OR Mofs THEN„      'Next, make sure byte at interrupt entry is not an IRET:„      DEF SEG = Mseg„      IF PEEK(Mofs) <> IRET THEN„         Mofs = Mofs + 2            'BASIC entry is at int entry + 2„         MousePresent = TRUE        'It's present.  Is it active?„         ax = 0„         CallMouse ax, 0, 0, 0      'Mouse Function 0 - H'ware reset„         MousePresent = ax          'Set MousePresent and InitMouse„         InitMouse = MousePresent   '  to returned value.„      END IF„      DEF SEG„   END IF„END FUNCTION„„SUB MouseGetStatus (LButton, RButton, X, Y) STATIC„   CallMouse 3, Buttons, X, Y          'Function 3: Get Mouse Status„   LButton = ((Buttons AND 1) = 1)     'Set Buttons to true/false„   RButton = ((Buttons AND 2) = 2)„END SUB„„SUB MouseHardReset STATIC„   CallMouse 0, 0, 0, 0                'Function 0:  Reset Mouse„END SUB„„SUB MouseHide STATIC„   CallMouse 2, 0, 0, 0                'Function 2:  Hide Cursor„END SUB„„SUB MouseHorizLimits (Left, Right) STATIC„   CallMouse 7, 0, Left, Right         'Function 7:  Limit Horizontal Motion„END SUB„„SUB MousePut (XCoord, YCoord) STATIC„   CallMouse 4, 0, XCoord, YCoord      'Function 4 - Set mouse position„END SUB„„SUB MouseSetGraphCursor STATIC„   '--- NOTE -------------------------------„   'Caller must RESTORE to cursor DATA block„   'before calling this routine„   '----------------------------------------„   READ HotSpotX„   READ HotSpotY„„   FOR i = 1 TO 32„      READ HexVal„      cursor$ = cursor$ + MKI$(HexVal)„   NEXT„„   'Function 9 - Set Graphics Cursor„   CallMouse 9, HotSpotX, HotSpotY, SADD(cursor$)„END SUB„„SUB MouseShow STATIC„   CallMouse 1, 0, 0, 0                'Function 1:  Show Cursor„END SUB„„SUB MouseVertLimits (Upper, Lower) STATIC„   CallMouse 8, 0, Upper, Lower        'Function 8:  Limit Vertical Motion„END SUB„„Kurt Kuzba                     TEXT MOUSE ROUTINES            FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                114  2963     TXTMOUSE.BAS'Some of these functions/subs might require a little modification because„'they are set for text mode only. Please use these freely!„'***********************************************************************„„' $INCLUDE: 'qb.bi'„DEFINT A-Z„DECLARE SUB Mouse (m1%, m2%, m3%, m4%)„DECLARE SUB MousePut (xmouse%, ymouse%)„DECLARE SUB MouseHide ()„DECLARE SUB MouseInches (horizontal%, vertical%)„DECLARE FUNCTION MouseInstall% ()„DECLARE SUB MouseLightPen (switch%)„DECLARE SUB MousePressLeft (leftcount%, xmouse%, ymouse%)„DECLARE SUB MousePressRight (rightcount%, xmouse%, ymouse%)„DECLARE SUB MouseRange (x1%, y1%, x2%, y2%)„DECLARE SUB MouseReleaseLeft (leftcount%, xmouse%, ymouse%)„DECLARE SUB MouseReleaseRight (rightcount%, xmouse%, ymouse%)„DECLARE SUB MouseWarp (threshhold%)„DECLARE SUB MouseShow ()„DECLARE SUB MouseSoftCursor (screenmask%, cursormask%)„DECLARE SUB MouseNow (leftbutton%, rightbutton%, xmouse%, ymouse%)„„IF MouseInstall THEN MouseShow„„SUB Mouse (m1%, m2%, m3%, m4%)„	   DIM InRegs AS RegTypeX, OutRegs AS RegTypeX„	   InRegs.ax = m1%„	   InRegs.bx = m2%„	   InRegs.cx = m3%„	   InRegs.dx = m4%„	   INTERRUPTX &H33, InRegs, OutRegs„	   m1% = OutRegs.ax„	   m2% = OutRegs.bx„	   m3% = OutRegs.cx„	   m4% = OutRegs.dx„END SUB„„SUB MouseHide„	   Mouse 2, 0, 0, 0„END SUB„„SUB MouseInches (horizontal%, vertical%)„	   IF horizontal% > 100 THEN horizontal% = 100„	   IF vertical% > 100 THEN vertical% = 100„	   h% = horizontal% * 5 \ 2„	   v% = vertical% * 8„	   Mouse 10, 0, h%, v%„END SUB„„FUNCTION MouseInstall%„	   mflag% = 0„	   Mouse mflag%, 0, 0, 0„	   MouseInstall% = mflag%„END FUNCTION„„SUB MouseLightPen (switch%)„	   IF switch% THEN„			 Mouse 13, 0, 0, 0„	   ELSE„			 Mouse 14, 0, 0, 0„	   END IF„END SUB„„SUB MouseNow (leftbutton%, rightbutton%, xmouse%, ymouse%)„	   Mouse 3, m2%, xmouse%, ymouse%„	   leftbutton% = ((m2% AND 1) <> 0)„	   rightbutton% = ((m2% AND 2) <> 0)„END SUB„„SUB MousePressLeft (leftcount%, xmouse%, ymouse%)„	   m1% = 5„	   leftcount% = 0„	   Mouse m1%, leftcount%, xmouse%, ymouse%„END SUB„„SUB MousePressRight (rightcount%, xmouse%, ymouse%) STATIC„	   m1% = 5„	   rightcount% = 1„	   Mouse m1%, rightcount%, xmouse%, ymouse%„END SUB„„SUB MousePut (xmouse%, ymouse%)„	   Mouse 4, 0, xmouse%, ymouse%„END SUB„„SUB MouseRange (x1%, y1%, x2%, y2%)„	   Mouse 7, 0, x1%, x2%„	   Mouse 8, 0, y1%, y2%„END SUB„„SUB MouseReleaseLeft (leftcount%, xmouse%, ymouse%)„	   m1% = 6„	   leftcount% = 0„	   Mouse m1%, leftcount%, xmouse%, ymouse%„END SUB„„SUB MouseReleaseRight (rightcount%, xmouse%, ymouse%)„	   m1% = 6„	   rightmouse% = 1„	   Mouse m1%, rightcount%, xmouse%, ymouse%„END SUB„„SUB MouseShow„	   Mouse 1, 0, 0, 0„END SUB„„SUB MouseSoftCursor (screenmask%, cursormask%)„	   Mouse 10, 0, screenmask%, cursormask%„END SUB„„SUB MouseWarp (threshold%)„	   Mouse 19, 0, 0, threshold%„END SUB„„Chris Wagner                   MOUSE TESTER                   FidoNet QUIK_BAS Echo          Unknown Date           QB, PDS                119  3172     MOUSTEST.BAS'*** "Mouse Tester" by Chris Wagner„'***„REM $INCLUDE: 'QB.BI'  '*** use QBX.BI in PDS7„DECLARE SUB Mouseon ()„DECLARE SUB MouseOff ()„DECLARE SUB MouseSetHor (Min%, Max%)„DECLARE SUB MouseSetVert (Min%, Max%)„DECLARE SUB MouseLocate (Xpos%, Ypos%)„DECLARE SUB MouseStatus (Vert%, Hor%, Mbuttons$)„DECLARE FUNCTION MouseInstalled% ()„DIM SHARED RegX AS RegTypeX„„    CLS„    LOCATE 2, 20: PRINT "Mouse Tester    By Chris Wagner";„    LOCATE 4, 20„    IF MouseInstalled% THEN„        PRINT "Mouse found and reset."„    ELSE„        PRINT "Mouse not found."„        END„    END IF„    LOCATE 14, 30: PRINT "…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª";„    LOCATE 15, 30: PRINT "∫  Press Q to Quit    ∫";„    LOCATE 16, 30: PRINT "∫   or Click here     ∫";„    LOCATE 17, 30: PRINT "»ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº";„    CALL MouseSetHor(1, 80)„    CALL MouseSetVert(1, 25)„    CALL MouseLocate(20, 70)„    CALL Mouseon„    LOCATE 25, 1: PRINT "X Coord:    Y Coord:    ";„    DO„        CALL MouseStatus(Vert%, Hor%, Mbuttons$)„        LOCATE 25, 10: PRINT LTRIM$(STR$(Vert%)); "  ";„        LOCATE 25, 26: PRINT LTRIM$(STR$(Hor%)); "  ";„        LOCATE 25, 48: PRINT Mbuttons$;„        A$ = UCASE$(INKEY$)„        IF Mbuttons$ = "L  " OR A$ = "Q" THEN„            IF Vert% >= 14 AND Vert% <= 17 OR A$ = "Q" THEN„                IF Hor% >= 30 AND Hor% <= 52 OR A$ = "Q" THEN„                    MouseOff„                    CLS„                    SYSTEM„                END IF„            END IF„        END IF„    LOOP„„'====[ EOF ]====„„FUNCTION MouseInstalled%„    DEF SEG = 0„    MouseSeg& = 256& * PEEK(207) + PEEK(206)„    MouseOfs& = 256& * PEEK(205) + PEEK(204) + 2„    DEF SEG = MouseSeg&„    IF (MouseSeg& = 0 AND MouseOfs& = 0) OR PEEK(MouseOfs&) = 207 THEN„        MouseInstalled% = 0„        EXIT FUNCTION„    ELSE„        MouseInstalled% = -1„    END IF„    DEF SEG„    RegX.ax = 0„    CALL INTERRUPTX(&H33, RegX, RegX)„    IF RegX.ax = -1 THEN„        MouseInstalled% = -1„    ELSE„        MouseInstalled% = 0„    END IF„END FUNCTION„„SUB MouseLocate (Xpos%, Ypos%)„    RegX.dx = (Xpos% * 8) - 1„    RegX.cx = (Ypos% * 8) - 1„    RegX.ax = 4„    CALL INTERRUPTX(&H33, RegX, RegX)„END SUB„„SUB MouseOff„    RegX.ax = 2„    CALL INTERRUPTX(&H33, RegX, RegX)„END SUB„„SUB Mouseon„    RegX.ax = 1„    CALL INTERRUPTX(&H33, RegX, RegX)„END SUB„„SUB MouseSetHor (Min%, Max%)„    RegX.cx = (Min% * 8) - 1„    RegX.dx = (Max% * 8) - 1„    RegX.ax = 7„    CALL INTERRUPTX(&H33, RegX, RegX)„END SUB„„SUB MouseSetVert (Min%, Max%)„    RegX.cx = (Min% * 8) - 1„    RegX.dx = (Max% * 8) - 1„    RegX.ax = 8„    CALL INTERRUPTX(&H33, RegX, RegX)„END SUB„„SUB MouseStatus (Vert%, Hor%, Mbuttons$)„    RegX.ax = 3„    CALL INTERRUPTX(&H33, RegX, RegX)„    Vert% = (RegX.dx / 8) + 1„    Hor% = (RegX.cx / 8) + 1„    SELECT CASE RegX.bx„        CASE 0„            Mbuttons$ = "   "„        CASE 1„            Mbuttons$ = "L  "„        CASE 2„            Mbuttons$ = "  R"„        CASE 3„            Mbuttons$ = "L R"„        CASE 4„            Mbuttons$ = " C "„    END SELECT„END SUB„