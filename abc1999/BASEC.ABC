The ABC Programmer             SIEVE OF ERATOSTHENES BENCHMARKvoxel@edmc.net                 12-23-98 (18:30)       BEC                    42   1034     SIEVE.BAS   rem ********************************„rem *** BASEC version of Classic ***„rem ***  Sieve of Eratosthenes   ***„rem ***      Benchmark           ***„rem ********************************„rem„rem This will prove how slow BASEC really is :)„rem Trust me, 25 iterations is too long, you'll want to press CTRL+BREAK„rem From this, I gather BASEC is over 10 times slower than PB and QB.„rem However, a fair test would be against other p-code compilers or interpreters.„rem For BASEC v0.15 [DOS/UNIX] by William Yu„„DIM Flags(8190) AS INTEGER„„PRINT "Sieve - 25 iterations"„„X& = TIMER„„FOR Iter = 1 TO 25„  Count = 0„„  FOR I = 0 TO 8190„    Flags(I) = 1„  NEXT I„„  FOR I = 0 TO 8190„    IF Flags(I) = 1 THEN„       Prime = I + I„       Prime = Prime + 3„       K = I + Prime„       WHILE K <= 8190„         Flags(K) = 0„         K = K + Prime„       WEND„       Count = Count + 1„    END IF„  NEXT I„  ?"Iteration ";Iter;": ";Count;"  took "; (TIMER - X&); " seconds."„  X& = TIMER„NEXT Iter„„END„The ABC Programmer             BAGELS GUESSING GAME FOR BASEC voxel@edmc.net                 12-23-98 (18:30)       BEC                    85   3396     BAGELS.BAS  ' Modified for use with BASEC [DOS/UNIX] by William Yu„„    PRINT TAB(33); "BAGELS"„    PRINT TAB(15); "CREATIVE COMPUTING MORRISTOWN, NEW JERSEY"„    PRINT "Modified for execution in QBASIC by James Hooker,  1996"„    REM *** BAGELS NUMBER GUESSING GAME„    REM *** ORIGINAL SOURCE UNKNOWN BUT SUSPECTED TO BE„    REM *** LAWRENCE HALL OF SCIENCE, U.C. BERKLEY„    DIM Answer%(13) AS INTEGER„    DIM PlayerGuess%(13) AS INTEGER„    DIM i% as integer,j% as integer,picocount% as integer, fermicount% as integer„    dim a$ as string„    dim y as integer„    PRINT : PRINT : PRINT„    INPUT "WOULD YOU LIKE THE RULES (YES OR NO)"; a$„    IF UCASE$(LEFT$(a$, 1)) <> "N" THEN„        PRINT„        PRINT "I AM THINKING OF A 3 DIGIT NUMBER.  TRY TO GUESS"„        PRINT "MY NUMBER AND I WILL GIVE YOU CLUES AS FOLLOWS:"„        PRINT "PICO - ONE DIGIT IS IN THE WRONG PLACE"„        PRINT "FERMI - ONE DIGIT IS IN THE CORRECT PLACE"„        PRINT "BAGELS - NO DIGIT IS CORRECT"„    END IF„    RANDOMIZE„    DO„        FOR i% = 1 TO 3„NoDupDig:„            Answer%(i%) = RND(10)„            IF i% > 1 THEN„                FOR J% = 1 TO i% - 1„                    IF Answer%(i%) = Answer%(J%) THEN GOTO NoDupDig„                NEXT„            END IF„        NEXT„        PRINT„        PRINT "OK, I HAVE A NUMBER IN MIND."„        FOR i% = 1 TO 20„BadGuess:   PRINT "GUESS #"; i%;" ";„            INPUT a$„            IF LEN(a$) <> 3 THEN„                PRINT "TRY GUESSING A THREE DIGIT NUMBER."„                GOTO BadGuess„            END IF„            FOR J% = 1 TO 3„                PlayerGuess%(J%) = ASC(MID$(a$, J%, 1)) - 48„                IF PlayerGuess%(J%) < 0 OR PlayerGuess%(J%) > 9 THEN„                    PRINT "WHAT?"„                    GOTO BadGuess„                END IF„            NEXT J%„            IF PlayerGuess%(1) = PlayerGuess%(2) OR PlayerGuess%(2) = PlayerGuess%(3) OR PlayerGuess%(3) = PlayerGuess%(1) THEN„                PRINT "OH, I FORGOT TO TELLL YOU THAT THE NUMBER I HAVE IN MIND"„                PRINT "HAS NO DIGITS THE SAME."„                GOTO BadGuess„            END IF„            PicoCount% = 0„            FermiCount% = 0„            FOR J% = 1 TO 2„                IF Answer%(J%) = PlayerGuess%(J% + 1) OR Answer%(J% + 1) = PlayerGuess%(J%) THEN PicoCount% = PicoCount% + 1„            NEXT J%„            IF Answer%(1) = PlayerGuess%(3) OR Answer%(3) = PlayerGuess%(1) THEN PicoCount% = PicoCount% + 1„            FOR J% = 1 TO 3„                IF Answer%(J%) = PlayerGuess%(J%) THEN FermiCount% = FermiCount% + 1„            NEXT J%„            IF FermiCount% = 3 THEN„                PRINT "YOU GOT IT!!!"„                Y = Y + 1„                GOTO Winner„            END IF„            FOR J% = 1 TO PicoCount%„                PRINT "PICO ";„            NEXT J%„            FOR J% = 1 TO FermiCount%„                PRINT "FERMI  ";„            NEXT J%„            IF PicoCount% + FermiCount% = 0 THEN PRINT "BAGELS";„            PRINT„        NEXT i%„        PRINT "OH WELL"„        PRINT "THATS'S TWENTY GUESSES. MY NUMBER WAS"; 100 * Answer%(1) + 10 * Answer%(2) + Answer%(3)„Winner: INPUT "PLAY AGAIN (YES OR NO)"; a$„    LOOP UNTIL UCASE$(LEFT$(a$, 1)) <> "Y"„    PRINT„    PRINT "A "; Y; " POINT BAGLES BUFF!!"„    PRINT "HOPE YOU HAD FUN. BYE."„The ABC Programmer             TILES GAME FOR BASEC           voxel@edmc.net                 12-23-98 (18:30)       BEC                    312  7011     TILES.BAS   ' Converted from ASIC to BASEC v0.15 [DOS] by William Yu (11-15-98)„„rem     Tiles for Asic„rem     „rem     By Mike Beckman„rem             mhscards@aol.com„rem„rem =======================================================================„rem„rem     The object of this game is to get the numbers in order from 1 to 8„rem     using the cursor keys.  It keeps track of the number of moves it„rem     takes you.  Hit ESCAPE to quit.„„dim board(9) as integer„dim xcoord(9) as integer„dim ycoord(9) as integer„„dim tmp$ as string„DIM X AS INTEGER„DIM VLINE$ AS STRING„DIM HLINE$ AS STRING„DIM CROSS$ AS STRING„DIM NUMBERS$ AS STRING„DIM G AS INTEGER„DIM A AS INTEGER„DIM TMP2 AS INTEGER„DIM GETIT$ AS STRING„DIM SCORE AS INTEGER„DIM SCORE$ AS STRING„DIM BEE$ AS STRING„DIM Q AS INTEGER„DIM A$ AS STRING„„data 9,32,9,40,9,48,12,32,12,40,12,48,15,32,15,40,15,48„„for x = 1 to 9„   read xcoord(x)„   read ycoord(x)„next x„„gosub setupboard:„gosub drawlines:„gosub drawboard:„gosub getinput:„end„„drawlines:„   vline$ = chr$(179)„   hline$ = chr$(196)„   cross$ = chr$(197)„   cls„   color 15,0„   for x = 8 to 16„       locate x,35„       print vline$„       locate x,45„       print vline$„   next x„   for x = 31 to 49„       locate 10,x„       print hline$„       locate 14,x„       print hline$„   next x„   locate 10,35„   print cross$„   locate 10,45„   print cross$„   locate 14,35„   print cross$„   locate 14,45„   print cross$„return„„setupboard:„   REM Initialization of playing field„   numbers$ = ""„   cls„   print "Initializing";„   randomize„   for x = 1 to 9„       doagain:„       g = rnd(10)„       g = g mod 9„       g = g + 1„       tmp$ = str$(g)„       tmp$ = ltrim$(tmp$)„       tmp$ = rtrim$(tmp$)„       a = instr(numbers$, tmp$)„       if a = 0 then„           if g < 9 then„               board(x) = g„               numbers$ = numbers$ + tmp$„               print ".";„           else„               board(x) = 0„               numbers$ = numbers$ + tmp$„               print ".";„           end if„       end if„       if a > 0 then goto doagain:„   next x„return„„drawboard:„   for x = 1 to 9„       tmp$ = str$(board(x))„       tmp$ = ltrim$(tmp$)„       tmp$ = rtrim$(tmp$)„       if tmp$ = "0" then„           tmp2 = x„           locate xcoord(x),ycoord(x)„           print " "„           goto skip:„       end if„               locate xcoord(x), ycoord(x)„               color 9,0„               print tmp$„       skip:„   next x„return„„getinput:„   getit$ = ""„       while getit$ = ""„           getit$ = inkey$„       wend„„   if tmp2 = 1 then„       if getit$ = "K" then„           board(1) = board(2)„           board(2) = 0„           score = score + 1„       end if„       if getit$ = "H" then„           board(1) = board(4)„           board(4) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 2 then„       if getit$ = "H" then„           board(2) = board(5)„           board(5) = 0„           score = score + 1„       end if„       if getit$ = "M" then„           board(2) = board(1)„           board(1) = 0„           score = score + 1„       end if„       if getit$ = "K" then„           board(2) = board(3)„           board(3) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 3 then„       if getit$ = "H" then„           board(3) = board(6)„           board(6) = 0„           score = score + 1„       end if„       if getit$ = "M" then„           board(3) = board(2)„           board(2) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 4 then„       if getit$ = "H" then„           board(4) = board(7)„           board(7) = 0„           score = score + 1„       end if„       if getit$ = "P" then„           board(4) = board(1)„           board(1) = 0„           score = score + 1„       end if„       if getit$ = "K" then„           board(4) = board(5)„           board(5) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 5 then„       if getit$ = "H" then„           board(5) = board(8)„           board(8) = 0„           score = score + 1„       end if„       if getit$ = "P" then„           board(5) = board(2)„           board(2) = 0„           score = score + 1„       end if„       if getit$ = "K" then„           board(5) = board(6)„           board(6) = 0„           score = score + 1„       end if„       if getit$ = "M" then„           board(5) = board(4)„           board(4) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 6 then„       if getit$ = "H" then„           board(6) = board(9)„           board(9) = 0„           score = score + 1„       end if„       if getit$ = "P" then„           board(6) = board(3)„           board(3) = 0„           score = score + 1„       end if„       if getit$ = "M" then„           board(6) = board(5)„           board(5) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 7 then„       if getit$ = "P" then„           board(7) = board(4)„           board(4) = 0„           score = score + 1„       end if„       if getit$ = "K" then„           board(7) = board(8)„           board(8) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 8 then„       if getit$ = "P" then„           board(8) = board(5)„           board(5) = 0„           score = score + 1„       end if„       if getit$ = "M" then„           board(8) = board(7)„           board(7) = 0„           score = score + 1„       end if„       if getit$ = "K" then„           board(8) = board(9)„           board(9) = 0„           score = score + 1„       end if„   end if„   if tmp2 = 9 then„       if getit$ = "P" then„           board(9) = board(6)„           board(6) = 0„           score = score + 1„       end if„       if getit$ = "M" then„           board(9) = board(8)„           board(8) = 0„           score = score + 1„       end if„   end if„„   if getit$ = "" then„       locate 20,1„       color 10,0„       print "Quitter....You had taken ";„       score$ = str$(score)„       score$ = ltrim$(score$)„       score$ = rtrim$(score$)„       color 15,0„       print score$;„       color 10,0„       print " tries."„       end„   end if„„   gosub drawboard:„   gosub checkwin:„   goto getinput:„„„return„„checkwin:„   bee$ = ""„   for q = 1 to 8„       a$ = str$(board(q))„       a$ = ltrim$(a$)„       a$ = rtrim$(a$)„       bee$ = bee$ + a$„   next q„   if bee$ = "12345678" then„       locate 20,1„       color 10,0„       Print "You win!!!"„       print„       print "It took you ";„       score$ = str$(score)„       score$ = ltrim$(score$)„       score$ = rtrim$(score$)„       color 15,0„       print score$;„       color 10,0„       print " tries to win!"„       end„   end if„return„The ABC Programmer             SIMPLIFIED HANGMAN GAME        voxel@edmc.net                 12-23-98 (18:30)       BEC                    58   1262     HANG.BAS    ' HANG.BAS for BASEC [DOS/UNIX], by William Yu„'„' An overly simplified version of hangman, without the man :)„„CONST false = 0„CONST true = NOT false„„DIM words$(100) AS STRING„DIM word        AS STRING„DIM L$          AS STRING * 1„DIM done        AS INTEGER„„DATA 12„DATA horse, computer, accessories, townhouse, terminal, directory„DATA library, desktop, zebra, degenerate, calculus, pumpkin„„READ num„FOR i = 1 TO num„  READ words$(i)„NEXT i„„PRINT : PRINT "HANG DUD by William Yu"„„RANDOMIZE TIMER„„playagain:„n = rnd(num)+1„word = STRING$(LEN(words$(n)), "-")„„L$ = ""„GOSUB Displayword„„DO„  PRINT "Guess a letter [0 = Quit]: "; : L$ = UCASE$(GET$(1))„  GOSUB Displayword„  IF done = true THEN„    PRINT "Wow, you got it!  Congratulations, play again [y/n]? ";„    L$ = UCASE$(GET$(1))„    IF L$ = "Y" THEN GOTO playagain„    L$ = "0"„  END IF„LOOP UNTIL L$ = "0"„„END„„Displayword:„  PRINT : PRINT "The mystery word: ";„  FOR i = 1 TO LEN(words$(n))„    IF L$ = MID$(UCASE$(words$(n)), i, 1) THEN„      word = LEFT$(word, i - 1) + L$ + MID$(word, i + 1, 255)„    END IF„  NEXT i„  PRINT word„  done = true„  FOR i = 1 TO LEN(word)„    IF MID$(word, i, 1) = "-" THEN done = false„  NEXT i„RETURN„The ABC Programmer             GAME OF MATCHES FOR BASEC      voxel@edmc.net                 12-23-98 (18:30)       BEC                    298  5154     MATCHES.BAS ' Converted from ASIC to BASEC v0.15 [DOS] by William Yu (10-05-98)„„' Subject: GAME OF MATCHES                   Date: 03-13-97 (00:00)       „'  Author: batkin6114@aol.com                Code: ASIC                   „'  Origin: comp.lang.basic.misc            Packet: ASIC.ABC„'===========================================================================„'SCREEN 0„'WIDTH 80„COLOR 7, 0„CW = 0„HW = 0„A$ = CHR$(27)„START:„RANDOMIZE„N = 23„DUMB = 0„CLS„GOSUB SHOWMATCHES:„PRINT„PRINT "           ******************** ";„COLOR 4, 0„PRINT "23 MATCHES GAME";„COLOR 7, 0„PRINT " ********************"„PRINT "           **                                                     **"„PRINT "           **   Each turn, you may take away 1, 2, or 3 matches.  **"„PRINT "           **   The player stuck with the last match loses.       **"„PRINT "           **                                                     **"„PRINT "           **   Choose: <";„COLOR 4, 0„PRINT "D";„COLOR 7, 0„PRINT ">unce, <";„COLOR 4, 0„PRINT "S";„COLOR 7, 0„PRINT ">mart, or <";„COLOR 4, 0„PRINT "G";„COLOR 7, 0„PRINT ">enius Computer.   **"„PRINT "           **                                                     **"„PRINT "           *********************************************************"„LOOP1:„K$ =Input$(1)„K$ = UCASE$(K$)„IF K$ = A$ THEN goto ALLDONE:„IF K$ = "D" THEN„  DUMB = 1„  GOTO  EXIT1:„END IF„IF K$ = "S" THEN„  DUMB = 2„  GOTO EXIT1:„END IF„IF K$ = "G" THEN„  GOTO EXIT1:„END IF„GOTO LOOP1:„EXIT1:„CLS„LOCATE 10, 0„PRINT "           *********************************************************"„PRINT "           **                                                     **"„PRINT "           **        Who moves first? <";„COLOR 4, 0„PRINT "Y";„COLOR 7, 0„PRINT ">ou, <";„COLOR 4, 0„PRINT "C";„COLOR 7, 0„PRINT ">omputer.          **"„PRINT "           **                                                     **"„PRINT "           *********************************************************"„LOOP2:„K$ = INKEY$„K$ = UCASE$(K$)„IF K$ = A$ THEN goto ALLDONE:„IF K$ = "Y" THEN„  FIRST = 1„  GOTO EXIT2:„END IF„IF K$ = "C" THEN„  FIRST = 0„  GOTO EXIT2:„END IF„GOTO LOOP2:„EXIT2:„IF FIRST = 0 THEN goto COMMOVE:„GOSUB SHOWMATCHES:„GOTO GETMOVE:„SHOWMATCHES:„CLS„PRINT„PRINT "    ";„COLOR 4, 0„FOR A = 1 TO 2„PRINT„PRINT "    ";„FOR X = 1 TO N„PRINT " ≤≤";„NEXT X„NEXT A„COLOR 7, 0„PRINT„PRINT "    ";„FOR X = 1 TO N„PRINT " ≤≤";„NEXT X„PRINT„PRINT "    ";„COLOR 7, 0„FOR A = 1 TO 8„FOR X = 1 TO N„PRINT " €€";„NEXT X„PRINT„PRINT "    ";„NEXT A„COLOR 7, 0„RETURN„GETMOVE:„GETNUM:„PRINT„PRINT "     You have ";„COLOR 4, 0„N$ = STR$(N)„N$ = LTRIM$(N$)„PRINT N$;„COLOR 7, 0„PRINT " matches left."„PRINT "     How many do you want to remove (1, 2, or 3)? ";„LOOP4:„K$ = INKEY$„IF K$ = "" THEN goto LOOP4:„IF K$ = A$ THEN goto ALLDONE:„R = VAL(K$)„IF R >= N THEN goto ERROR1:„IF R < 1 THEN goto ERROR1:„IF R > 3 THEN goto ERROR1:„GOTO NOERROR1:„ERROR1:„  PRINT„  PRINT„  COLOR 4, 0„  PRINT "     Illegal number. Try again!"„  COLOR 7, 0„  GOTO GETNUM:„NOERROR1:„N = N - R„GOTO COMMOVE:„COMMOVE:„CLS„CR = RND(0)„CR = CR MOD 3„CR = CR + 1„IF N = 20 THEN„  CR = 3„END IF„IF N = 16 THEN„CR = 3„END IF„IF N = 12 THEN„CR = 3„END IF„IF N = 8 THEN„CR = 3„END IF„IF N = 4 THEN„CR = 3„end if„IF N = 23 THEN„CR = 2„end if„IF N = 19 THEN„CR = 2„end if„IF N = 15 THEN„CR = 2„end if„IF N = 11 THEN„CR = 2„end if„IF N = 7 THEN„CR = 2„end if„IF N = 3 THEN„CR = 2„end if„IF N = 22 THEN„CR = 1„end if„IF N = 18 THEN„CR = 1„end if„IF N = 14 THEN„CR = 1„end if„IF N = 10 THEN„CR = 1„end if„IF N = 6 THEN„CR = 1„end if„IF N = 2 THEN„CR = 1„end if„IF N = 1 THEN„CR = 1„end if„IF DUMB > 0 THEN„   GOSUB COMDUMB:„end if„N = N - CR„IF N = 0 THEN goto COMLOSE:„GOSUB SHOWMATCHES:„PRINT„PRINT "     The Computer removes ";„COLOR 4, 0„CR$ = STR$(CR)„CR$ = LTRIM$(CR$)„PRINT CR$;„COLOR 7, 0„PRINT " matches."„IF N = 1 THEN goto YOULOSE:„GOTO GETMOVE:„YOULOSE:„PRINT„PRINT "     You have the last match, You lose!"„CW = CW + 1„GOTO DONE:„COMLOSE:„N = 1„GOSUB SHOWMATCHES:„PRINT„PRINT "     The Computer has the last match, It loses!"„HW = HW + 1„GOTO DONE:„DONE:„PRINT„PRINT "     You have won ";„COLOR 4, 0„HW$ = STR$(HW)„HW$ = LTRIM$(HW$)„PRINT HW$;„COLOR 7, 0„PRINT " game(s), the Computer has won ";„COLOR 4, 0„CW$ = STR$(CW)„CW$ = LTRIM$(CW$)„PRINT CW$;„COLOR 7, 0„PRINT " game(s)."„PRINT„PRINT "     <";„COLOR 4, 0„PRINT "Q";„COLOR 7, 0„PRINT ">uit or any other key to play again..."„LOOP3:„K$ = INKEY$„K$ = UCASE$(K$)„IF K$ = "Q" THEN„ALLDONE:„  CLS„  END„end if„IF K$ = "" THEN goto LOOP3:„GOTO START:„COMDUMB:„CR = RND(0)„CR = CR MOD 3„CR = CR + 1„IF N = 4 THEN„  CR = 3„end if„IF N = 3 THEN„  CR = 2„end if„IF N = 2 THEN„  CR = 1„end if„IF N = 1 THEN„  CR = 1„end if„IF DUMB = 1 THEN goto YESRETURN:„IF N = 6 THEN„  CR = 1„end if„IF N = 7 THEN„  CR = 2„end if„IF N = 8 THEN„  CR = 3„end if„YESRETURN:„RETURN„The ABC Programmer             PC BATTLE OF NUMBERS GAME      voxel@edmc.net                 12-23-98 (18:30)       BEC                    92   3318     BATTLE.BAS  ' Converted to BASEC [DOS] by William Yu„'„5 '----------- PC BATTLE OF NUMBERS GAME ------------„8 '„DIM C as integer, I as integer, M as integer, P as integer,_„    T as integer, X as integer„10 CLS„20 'DEFINT C, I, M, P, T, X„30 RANDOMIZE 'VAL(RIGHT$(TIME$, 2))„40 M = RND(4) + 5„50 T = RND(19) + 17„55 LOCATE 25, 25„60 PRINT CHR$(16); CHR$(16); CHR$(16); " THE BATTLE OF NUMBERS ";„70 PRINT CHR$(17); CHR$(17); CHR$(17);„75 LOCATE 1, 1„80 PRINT "THIS GAME PITS YOU AGAINST THE PC IN A TEST OF ";„90 PRINT "MATHMATICAL SKILL. TWO NUMBERS,"„100 PRINT "ONE SEVERAL TIMES LARGER THAN THE OTHER,HAVE ";„110 PRINT "BEEN SELECTED AT RANDOM. BY TURNS"„120 PRINT "BOTH YOU AND THE COMPUTER SUBTRACT AN INTERGER ";„130 PRINT "BETWEEN 1 AND ";„140 COLOR 31, 0: PRINT M; : COLOR 7, 0: PRINT " FROM THE TOTAL"„150 PRINT "LISTED BELOW UNTIL ZERO IS LEFT. WHOEVER MUST ";„160 PRINT "MAKE THE FINAL SUBTRACTION IS THE"„170 PRINT "LOSER. UNLESS YOU EMPLOY A RATIONAL STRATEGY,";„180 PRINT " THE COMPUTER WILL TROUNCE YOU"„190 PRINT "EVERY TIME, AND GLOAT ABOUT IT, TOO. ";„200 PRINT "THE FIRST TURN IS YOURS -- GOOD LUCK!"„210 PRINT CHR$(201); STRING$(28, 205); CHR$(203);„220 PRINT STRING$(20, 205); CHR$(203); STRING$(28, 205); CHR$(187);„230 PRINT CHR$(186); TAB(28); CHR$(186); TAB(8);„240 PRINT "TOTAL"; TAB(7); CHR$(186); TAB(28); CHR$(186);„250 PRINT CHR$(186); TAB(28); CHR$(199);„260 PRINT STRING$(20, 196); CHR$(182); TAB(28); CHR$(186);„270 FOR I = 10 TO 22„280    LOCATE I, 1„290    PRINT CHR$(186); TAB(28); CHR$(186); TAB(20);„300    PRINT CHR$(186);:LOCATE ,80:? CHR$(186);„310 NEXT I„315 PRINT CHR$(200); STRING$(28, 205); CHR$(202);„317 PRINT STRING$(20, 205); CHR$(202); STRING$(28, 205); CHR$(188);„320 PC$ = CHR$(19) + " PC WINS " + CHR$(19)„330 PLAYER$ = CHR$(19) + " YOU WIN " + CHR$(19)„340 LOCATE 10, 40: PRINT T„350 '„355 '----------- MAIN STRATEGY LOOP ------------„356 '„360 FOR I = 10 TO 100 STEP 2„370    GOSUB 600„380    T = T - P: LOCATE I + 1, 40: PRINT T;„390    IF T = 0 THEN WIN$ = PC$: GOTO 480„400    C = T - ((M + 1) * INT((T - 1) / (M + 1)) + 1)„410    IF C = 0 THEN C = INT(1 + RND(M))„420    IF T = 1 THEN C = 1„430    T = T - C„440    LOCATE I + 1, 58: PRINT "PC SUBTRACTS "; C;„450    LOCATE I + 2, 40: PRINT T;„460    IF T = 0 THEN WIN$ = PLAYER$: GOTO 480„470 NEXT I„475 '„476 '--- ANNOUNCE WINNER, SOUND OFF, DISPLAY OPTIONS ---„477 '„480 COLOR 0, 7: LOCATE 8, 31: PRINT STRING$(4, 32); WIN$; STRING$(5, 32)„482 FOR K = 1 TO 2„484    'FOR J = 3000 TO 400 STEP -300„486    'SOUND J, .5„488 NEXT K„490 COLOR 7, 0: LOCATE 25, 17„500 PRINT "    >>>  PRESS ANY KEY TO QUIT GAME  <<<     ";„520 „530 X$ = UCASE$(INPUT$(1))„570„580 CLS : LOCATE ,,1 : END„585 '„586 '------------ PLAYER-INPUT SUBROUTINE -------------„590 '„600 X = 100„610 WHILE 1„620    LOCATE I, 7, 1: PRINT "YOU SUBTRACT? ";„625    P = VAL(INPUT$(1)): PRINT P: LOCATE , , 0„630    IF (P >= 1) AND (P <= M) AND (P <= T) THEN GOTO 690„640    IF M < T THEN„         X = M„       ELSE„         X = T„       END IF„650    LOCATE 25, 11: COLOR 15, 0„660    PRINT "IMPROPER INPUT. PLEASE ENTER AN INTERGER IN THE RANGE 1 -"; X;„670    COLOR 7, 0: LOCATE I, 7: PRINT STRING$(18, 32)„680 WEND„690 'IF X < 100 THEN KEY ON: KEY OFF„700 RETURN„The ABC Programmer             SIMPLE MP3 PLAYER FOR BASEC    voxel@edmc.net                 12-23-98 (18:30)       BEC                    45   772      MP3PLAY.BAS '' Simple MP3 Player for BASEC by William Yu„„CLS„„False = 0: True = NOT False„„repeat = False„„filename$ = "NO\LONG\FILE\NAMES\PLEASE.mp3"„„mp3.play(filename$, repeat)„„x = 0: y = 0: n = 1„„?"Playing... ";filename$:?„?"Sample rate: ";mp3.samprate„?"   Bit rate: ";mp3.bitrate„?"     Stereo: ";„if mp3.stereo = false then„  ?"No"„else„  ?"Yes"„end if„„?:?"[ESC = Stop, R = Rewind]":?:?">> ";„„'screen 12„„while (mp3.run >= 0)„ ' Do what you want here, but mp3.run or mp3.poll must be called often„ '  „ '  showjpg("abc.jpg",x,y,n)„ '  x=(x+1) mod 640„ '  y=(y+1) mod 480„ A$=inkey$„ if ucase$(A$)="R" then„   MP3.Replay„ elseif ucase$(A$)=chr$(27) then„   goto exitloop„ end if„ if A$<>"" then ?A$;„wend„exitloop:„mp3.free„END„The ABC Programmer             JPEG VIEWER FOR BASEC          voxel@edmc.net                 12-23-98 (18:30)       BEC                    28   644      JPGVIEW.BAS ' Unbelievable, a JPEG viewer in BASIC... cool!„'„' How it's called:  ShowJPG(Filename, X, Y, Scale)„„dim filename as string*1024„dim mode as integer„dim x as integer„dim y as integer„„filename = "abc.jpg"„„cls„?"Woo hoo, JPEG viewer for BASIC?":?:?"Press any key to proceed..."„do:loop until inkey$<>""„„mode = 13    '' so far I have 13 (320x200x256) and 12 (640x480x256)„„screen mode„for x = 0 to 300 step 150„  for y = 0 to 200 step 50„    showjpg(filename,x,y,1)„    showjpg(filename,x,y+30,2)„    showjpg(filename,x+50,y+30,4)„    showjpg(filename,x+90,y+30,8)„  next y„next x„do:loop until inkey$<>""„screen 0„Jernej Simoncic                MARTIN FRACTALS FOR BASEC      jernej.simoncic@guest.arnes.si 03-23-99 (08:41)       BEC                    87   2370     MARB.BAS    ' Martin fractal program, by Alan Meiss„' Converted to basic by Jernej Simoncic„' This code is designed for BASEC 0.15 by William Yu„'„'  Formula from "Dynamical Systems and Fractals",„'   by Karl-Heinz Becker and Michael Dîrfler,„'   Cambridge University Press, 1990„'„DIM xmax as integer, ymax as integer, t as integer, tcmax as integer„dim tc as integer, clr as integer, cx as integer, cy as integer, code as integer„DIM sa AS DOUBLE, sav AS DOUBLE, sb AS DOUBLE, sc AS DOUBLE„DIM ch AS STRING * 1, a as double, b as double, c as double, s as double„dim x as double,y as double,tmp1 as double, tmp2 as double, tmp as double„dim xold as double, yold as double,xnew as double, ynew as double„dim xc as double, yc as double, signn as double, sign as double„dim px as double, py as double,keypressed as integer, k$ as string„„   RANDOMIZE TIMER„„   xmax = 639„   ymax = 479„   cx = INT(.5 + xmax / 2!)„   cy = INT(.5 + ymax / 2!)„   SCREEN 12„   tcmax=100„   sa = RND * 100! - 50!„   sb = RND * 100! - 50!„   sc = RND * 100! - 50!„   sav = (ABS(sa) + ABS(sb) + ABS(sc)) / 3!„   'martin1 sa, sb, sc, 6! - ABS(sav / 10!)„   goto martin1„   SCREEN 0„„martin1:' (a AS DOUBLE, b AS DOUBLE, c AS DOUBLE, s AS DOUBLE)„a=sa „b=sb „c=sc „tmp=ABS(sav / 10!)„s=6-tmp„'DIM xold AS DOUBLE, yold AS DOUBLE, xnew AS DOUBLE, ynew AS DOUBLE„„   xold = 0„   yold = 0„   clr = INT(RND * 256)„   t = 0„   tc = 0„   ch = "a"„   DO„      px=xold * s„      py=yold * s„      gosub plot „      signn=xold„      gosub getsign„      xnew = yold - sign * SQR(ABS(b * xold - c)) '{ <- This is it! These two }„      ynew = a - xold                        '  { <- lines generate the }„      xold = xnew                             ' {     entire fractal! }„      yold = ynew„      t = t + 1„      IF t > 500 THEN„         tc = tc + 1„         clr = clr + 1„         IF clr > 255 THEN clr = 1„         t = 0„      END IF„      k$ = INKEY$„      IF k$ <>"" THEN end„   LOOP UNTIL keypressed or ((tc > (tcmax - 1)) AND (tcmax > 0))„   screen 0„end„'SUB plot (x AS DOUBLE, y AS DOUBLE, clr)„plot:„xc=.5+px„xc=int(xc)„xc=xc+cx„yc=.5+py„yc=int(yc)„yc=yc+cy„PSET (xc, yc), clr„return„„'FUNCTION sign (x AS DOUBLE)„getsign:„if signn= 0 then sign = 0„if signn < 0 then sign=-1„if signn>0 then sign = 1„'END FUNCTION„return„The ABC Programmer             PCX VIEWER FOR BASEC           voxel@edmc.net                 03-24-99 (19:07)       BEC                    89   1679     VIEWPCX.BAS ' 640x480x256 PCX Viewer  (only standard palette) for BASEC v0.15„' By William Yu,  Code based on Tony Jones' ASIC PCX Viewer.„'„' Actually, a PCX loader is already contained in GRAPHICS.LIB, however,„' there's no way to call it, because I didn't implement it :)„„DIM FileName AS STRING„DIM ID AS INTEGER„DIM BCode AS BYTE„DIM NumBytes AS INTEGER„DIM Counter AS LONG„DIM PCXFILE AS INTEGER„DIM X AS INTEGER, Y AS INTEGER„DIM K$ AS STRING„„FileName = "PCXFILE.PCX"„„PCXFile = FREEFILE„„OPEN "R", PCXFile, FileName„„'' -- Check to see if the file exist„IF LOF(PCXFile) = 0 THEN„ PRINT "File not found: "; FileName„ CLOSE PCXFile„ KILL FileName„ END„END IF„„GET PCXFile,, ID„„IF ID <> 1290 THEN„  PRINT "Error in header"„  PRINT FileName; " must be a true 256 PCX file."„  CLOSE PCXFile„  END„END IF„„SEEK PCXFile, 129„„SCREEN 12„„'' Decode the PCX data„„Counter = 0„X = 0: Y = 0„WHILE Counter < 640*480„„ GET PCXFile,,BCode„„ IF BCode > 191 THEN„   '' How many bytes are in the run.„   NumBytes = BCode - 192„„   '' Get the actual data for the run„   GET PCXFile,,BCode„„   Counter = Counter + NumBytes„   IF NumBytes > 640 - X THEN„     LINE (X, Y)-(639, Y), BCode„     NumBytes = NumBytes - (640 - X)„     X = 0„     Y = Y + 1„     LINE (X, Y)-(X+NumBytes-1, Y), BCode„   ELSE„     LINE (X, Y)-(X+NumBytes, Y), BCode„   END IF„„   X = X + NumBytes„   IF X = 640 THEN X = 0: Y = Y + 1„„ ELSE„   '' Else just put the data on the screen„„   PSET (X,Y), BCode„   Counter = Counter + 1„   X = X + 1„   IF X = 640 THEN X = 0: Y = Y + 1„ END IF„„WEND„„CLOSE PCXFile„„K$ = INPUT$(1)„„SCREEN 0„„END„The ABC Programmer             TARGET PRACTISE                voxel@edmc.net                 04-05-99 (02:12)       BEC                    200  6361     TARGET.BAS  ' Target Practise, converted to BASEC v0.15 [DOS] by William Yu„„'Variable list for target.bas„DIM POINTS% AS INTEGER„DIM AMMO% AS INTEGER„DIM XPOS% AS INTEGER„DIM YPOS% AS INTEGER„DIM COL% AS INTEGER„DIM ECOL% AS INTEGER„DIM EXPOS% AS INTEGER„DIM EYPOS% AS INTEGER„DIM EDIR% AS INTEGER„DIM XMIN% AS INTEGER„DIM XMAX% AS INTEGER„DIM YMIN% AS INTEGER„DIM YMAX% AS INTEGER„DIM EXMIN% AS INTEGER„DIM EYMIN% AS INTEGER„DIM EXMAX% AS INTEGER„DIM EYMAX% AS INTEGER„DIM I% AS INTEGER„DIM KEY$ AS STRING„„'===========================================================================„' Subject: SIMPLE TARGET GAME                Date: 06-21-98 (02:38)       „'  Author: Chris Pulley                      Code: QB, QBasic, PDS        „'  Origin: beelzebu@swbell.net             Packet: DEMOS.ABC„'===========================================================================„' Target  Version 1.0„'„' This is a simple target game it is extremly simple to program and use„' this code is freeware and you may use all or any of the code you want„' as long as you give me (Chris Pulley) some credit„'„' Has a Few Bugs Sometimes the Enemy isn't completly cleared during„' movement and sometimes the ball gets caught in a loop and follows the„' same pattern, adjust the edir% numbers in the enemy control section„' to change the directions„'„' If you can fix it then COOL if not I don't give a fuck, took me 20 minutes„' to program and I have better things to do„'„' The Keys are as follows      Have NUM-LOCK on to use keypad„'„' W = UP                       8 = UP„' X = DOWN                     2 = DOWN„' A = LEFT                     4 = LEFT„' S = RIGHT                    6 = RIGHT„' Q = UP AND LEFT              7 = UP AND LEFT„' E = UP AND RIGHT             9 = UP AND RIGHT„' Z = DOWN AND LEFT            1 = DOWN AND LEFT„' C = DOWN AND RIGHT           3 = DOWN AND RIGHT„'„' M = FIRE                     5 = FIRE„'„' ESCAPE = END„'„CLS                                                    ' Clear the Screen„„SCREEN 13                                              ' 13h 320 X 200 X 256„RANDOMIZE TIMER                                        ' Set Random Numbers„„points% = 0„ammo% = 1000                                           ' Set Variables„xpos% = 160„ypos% = 100„col% = 4„ecol% = 2„expos% = 100„eypos% = 100„edir% = 4„xmin% = 17„xmax% = 300„ymin% = 17„ymax% = 143„exmin% = 33„eymin% = 20„exmax% = 294„eymax% = 139„„LINE (0, 0)-(319, 199), 1, B                           ' Draw the Game Screen„LINE (0, 160)-(319, 160), 1„LOCATE 22, 2: PRINT "AMMO:"„LOCATE 22, 25: PRINT "POINTS:"„„updatescreen:                                          ' Update All„IF ammo% = 0 THEN GOTO done1„'sleep .1„' Update Targeter„IF xpos% < xmin% THEN xpos% = xmin%„IF xpos% > xmax% THEN xpos% = xmax%„IF ypos% < ymin% THEN ypos% = ymin%„IF ypos% > ymax% THEN ypos% = ymax%„„LINE (xpos% - 16, ypos% - 15)-(xpos% + 16, ypos% + 15), 0, BF„LINE (xpos%, ypos%)-(xpos% - 11, ypos%), col%„LINE (xpos%, ypos%)-(xpos% + 11, ypos%), col%„LINE (xpos%, ypos%)-(xpos%, ypos% - 10), col%„LINE (xpos%, ypos%)-(xpos%, ypos% + 10), col%„CIRCLE (xpos%, ypos%), 7, col%„„' Update Enemy„LINE (expos% - 20, eypos% - 15)-(expos% + 20, eypos% + 15), 0, BF„CIRCLE (expos%, eypos%), 10, ecol%„PAINT (expos%, eypos%), ecol%, ecol%„„' Update User Variables„LOCATE 22, 7: PRINT ammo%„LOCATE 22, 32: PRINT points%„„„' Enemy Control„IF edir% = 1 THEN„ expos% = expos% - 1: eypos% = eypos% - 1„  IF expos% < exmin% THEN edir% = 3„  IF eypos% < eymin% THEN edir% = 4„  IF expos% > exmax% THEN edir% = 2„  IF eypos% > eymax% THEN edir% = 1„END IF„IF edir% = 2 THEN„ expos% = expos% + 1: eypos% = eypos% - 1„  IF expos% < exmin% THEN edir% = 2„  IF eypos% < eymin% THEN edir% = 3„  IF expos% > exmax% THEN edir% = 4„  IF eypos% > eymax% THEN edir% = 1„END IF„IF edir% = 3 THEN„ expos% = expos% + 1: eypos% = eypos% + 1„  IF expos% < exmin% THEN edir% = 3„  IF eypos% < eymin% THEN edir% = 4„  IF expos% > exmax% THEN edir% = 4„  IF eypos% > eymax% THEN edir% = 2„END IF„IF edir% = 4 THEN„ expos% = expos% - 1: eypos% = eypos% + 1„  IF expos% < exmin% THEN edir% = 3„  IF eypos% < eymin% THEN edir% = 4„  IF expos% > exmax% THEN edir% = 1„  IF eypos% > eymax% THEN edir% = 1„END IF„„' Get User Key„key$ = INKEY$„IF key$ = "w" THEN ypos% = ypos% - 5: GOTO updatescreen„IF key$ = "8" THEN ypos% = ypos% - 5: GOTO updatescreen„IF key$ = "x" THEN ypos% = ypos% + 5: GOTO updatescreen„IF key$ = "2" THEN ypos% = ypos% + 5: GOTO updatescreen„IF key$ = "a" THEN xpos% = xpos% - 5: GOTO updatescreen„IF key$ = "4" THEN xpos% = xpos% - 5: GOTO updatescreen„IF key$ = "d" THEN xpos% = xpos% + 5: GOTO updatescreen„IF key$ = "6" THEN xpos% = xpos% + 5: GOTO updatescreen„IF key$ = "q" THEN xpos% = xpos% - 5: ypos% = ypos% - 5: GOTO updatescreen„IF key$ = "7" THEN xpos% = xpos% - 5: ypos% = ypos% - 5: GOTO updatescreen„IF key$ = "z" THEN xpos% = xpos% - 5: ypos% = ypos% + 5: GOTO updatescreen„IF key$ = "1" THEN xpos% = xpos% - 5: ypos% = ypos% + 5: GOTO updatescreen„IF key$ = "e" THEN xpos% = xpos% + 5: ypos% = ypos% - 5: GOTO updatescreen„IF key$ = "9" THEN xpos% = xpos% + 5: ypos% = ypos% - 5: GOTO updatescreen„IF key$ = "c" THEN xpos% = xpos% + 5: ypos% = ypos% + 5: GOTO updatescreen„IF key$ = "3" THEN xpos% = xpos% + 5: ypos% = ypos% + 5: GOTO updatescreen„IF key$ = "m" THEN GOTO shoot„IF key$ = "5" THEN GOTO shoot„IF key$ = CHR$(27) THEN GOTO done„GOTO updatescreen„„shoot:        „ammo% = ammo% - 2„LINE (100, 159)-(xpos% - 4, ypos%), 2„LINE (220, 159)-(xpos% + 4, ypos%), 2„LINE (100, 159)-(xpos% - 4, ypos%), 0„LINE (220, 159)-(xpos% + 4, ypos%), 0„„IF xpos% > expos% THEN„ IF xpos% > expos% - 15 THEN„ IF xpos% < expos% + 15 THEN„ IF ypos% > eypos% - 15 THEN„ IF ypos% < eypos% + 15 THEN GOTO newenemy„END IF„END IF„END IF„END IF„„GOTO updatescreen„„newenemy:„ammo% = ammo% + 500„points% = points% + 1000„LINE (expos% - 15, eypos% - 15)-(expos% + 15, eypos% + 15), 0, BF„expos% = INT(RND * 300)„eypos% = INT(RND * 139)„IF expos% < exmin% THEN GOTO newenemy„IF eypos% < eymin% THEN GOTO newenemy„GOTO updatescreen„„done1:„CLS„PRINT "GAME OVER:   AMMO DEPLETED": PRINT„PRINT "FINAL POINTS: ", points%„SLEEP„„done:„Oliver Rigby AKA Tirin         COLORFUL MP3 PLAYER FOR BASEC  tirin@btinternet.com           04-23-99 (01:36)       BEC                    82   1641     MP3PLAY.BAS ' MP3 BASEC PLAYER - Based on Simple MP3 Player for BASEC by William Yu.„' I've added colour, added load, added file checker and Quit Checker,„' auto uppercase filename. Looks a bit better, All I need to figure out is„' ID3 tags and Graphics.........„'„'Oliver Rigby AKA Tirin„'I can't beleive it's made with Basec, for a fresh Basic taste!„„Start: CLS„False = 0: True = NOT False„REPEAT = TRUE„LOCATE 1, 30„COLOR 4„PRINT ">>MP3 BASEC PLAYER<<„LOCATE 2„COLOR 1„?">>"„LOCATE 2, 79„COLOR 1„?"<<"„LOCATE 2, 20„COLOR 15„INPUT "Enter the filename: ", filename$„UCASE=(filename$)„CLS„REPEAT = 1„MP3.PLAY(filename$, repeat)„IF MP3.RUN < 0 THEN GOTO DEAD„COLOR 4„RES: LOCATE 1, 30„?">>MP3 BASEC PLAYER<<„LOCATE 2, 10„COLOR 5„?">>  Playing... ";filename$:?„LOCATE 2, 50„COLOR 10„?"Sample rate: ";mp3.samprate; " <<"„LOCATE 3, 10„COLOR 9„?">>  Bit rate: ";mp3.bitrate; „LOCATE 3, 50„COLOR 8„?"Stereo: ";„IF MP3.STEREO = false THEN„  ?"No         <<"„  ELSE„  ?"Yes        <<"  „END IF„COLOR 13„LOCATE 4, 10„?"[   ESC = Exit, T = TurnTable Scratch R = Rewind L = Load   ]":?„res2: LOCATE 30„ WHILE (mp3.run >= 0)„SKIP: A$=inkey$„  IF UCASE$(A$)="R" then„   MP3.REPLAY„ ELSEIF UCASE$(A$)=chr$(27) THEN„   GOTO EXITLOOP„ ELSEIF UCASE$(A$)="T" THEN„  GOTO TT„ ELSEIF UCASE$(A$)="L" THEN„  GOTO LOAD„ END IF„ IF A$<>"" THEN ?A$;„WEND„EXITLOOP:„LOCATE 25„INPUT "Are you sure you want to quit: ", b$„IF UCASE$(b$) = "Y" THEN GOTO DIE„CLS„GOTO RES„DIE:„MP3.FREE„END„LOAD: MP3.FREE„GOTO START„DEAD: PRINT "File not found...."„END„TT: LOCATE„DO„LOOP UNTIL INKEY$ = " "„GOTO RES2„The ABC Programmer             SIMPLE CGI FORM PARSER         voxel@edmc.net                 04-29-99 (12:20)       BEC                    36   967      CGIFORM.BAS '' Simple CGI form parser for BASEC v0.20 by William Yu„'' You can use SHELL "mailto"  if you want to mail someone in Unix/Linux„'' Generate a file and SHELL "mailto name@isp.com < file"„'' Isn't this much easier on the eyes than Perl or C?„'' I've only tested this code on a Unix server, don't know about Windows NT„'' Author: William Yu <voxel@edmc.net>„„DIM A$ AS STRING„„?"Content-type: text/html"„?:?"<HTML><BODY>"„?"REMOTE ADDR: "; ENVIRON$("REMOTE_ADDR")+"<br>"„„?"Request method is: "; ENVIRON$("REQUEST_METHOD")+"<BR>"„?"Content type is:   "; ENVIRON$("CONTENT_TYPE")+"<BR>"„?"Content length:    "; VAL(ENVIRON$("CONTENT_LENGTH")„?"<BR>Original content:  ";„  A$ = GET$(VAL(ENVIRON$("CONTENT_LENGTH")))„?A$+"<BR>"„„'' Parse Content„„J = 1„I = INSTR(A$, "&")„WHILE I <> 0„  ?MID$(A$,J,I-J)+"<BR>"„  J = I+1„  I = INSTR(J, A$, "&")„WEND„?MID$(A$,J,I-J)+"<BR><BR>"„„?"<BR>All this was done in BASEC!"„„?"</BODY></HTML>"„„END„The ABC Programmer             TIP OF THE DAY CGI PROGRAM     voxel@edmc.net                 06-06-99 (09:11)       BEC                    77   2137     TIPS.BAS    '-- TIPS.BAS for BASEC v0.20 by William Yu [June 1, 1999]„'„'-- Tip of the Day CGI Program tested under Linux/Unix server„'-- Not really "the day," more like, whatever I can find...„'-- In this example, I'm listing all tips in the data.txt file.„'-- You can use RND to randomly select one.„'-- 2 things before you can get going:„'--     1. Create data.txt in your cgi-bin directory„'--     2. chmod 666 data.txt„'„'-- This is a good example of how you can read text files.„'-- You'll notice that BOTH Read/Write on the file must be SET (chmod 666)!„'-- That is a flaw in the BASEC language, since any BINARY file is open„'-- for reading and writing.„„'-- If you really wanted to, you can pretty much write a very nice,„'-- but slow, search engine from this example and using the "Simple CGI„'-- Form Parser" example from BASEC.ABC„„„' Example  DATA.TXT file„'„' 2„' Tip 1: Hello World!„' Tip 2: I forget...„„DIM NUM AS LONG„DIM A$ AS STRING„DIM I AS INTEGER„„OPEN "B", 1, "data.txt"„   '-- The first value is the number of lines/tips in the data.txt file.„   '-- You have to hard code (type) that in, no error checking...„   '-- Obviously you can modify this program to avoid using this method.„„   A$ = SPACE$(20)„   GET #1, , A$„   I = INSTR(A$, CHR$(10))       '-- Grab the number„   SEEK #1, I + 1                '-- Points to first tip...„   A$ = LEFT$(A$, I - 1)„   NUM = VAL(A$)„„   '-- Why waste...„   DIM Lines(1 TO NUM) AS STRING„„   GOSUB GetLines„CLOSE #1„„PRINT "Content-type: text/html"„PRINT : PRINT "<HTML><BODY>"„PRINT "<CENTER>"„PRINT "<FONT SIZE=+3><B>Tip of the Day</B></FONT><BR><BR>"„„FOR I = 1 TO NUM„  PRINT Lines(I) + "<BR>"     '-- All tips are listed, you can change this„NEXT I„„PRINT "</CENTER>"„PRINT "</BODY></HTML>"„„END„„„GetLines:„  '' Cheap cheap cheap, BASEC has no LINE INPUT command„  I = 1„  WHILE I <= NUM„    IF EOF(1) THEN RETURN    '' Really cheap, can't attach to WHILE...„    A$ = SPACE$(1)„    GET #1, , A$„    IF A$ = CHR$(10) THEN„      I = I + 1„    ELSE„      Lines(I) = Lines(I) + A$„    END IF„  WEND„RETURN„The ABC Programmer             INFIX TO POSTFIX/RPN CONVERTER voxel@edmc.net                 06-23-99 (12:55)       BEC, QB, QBasic        135  3105     RPN.BAS     ' INFIX TO POSTFIX (RPN) CONVERTER/EVALUATOR by William Yu„' Compiled with BEC [DOS/UNIX], should work with QBasic as well„' For a better example, see ALGOR.ABC for my other RPN CONVERTER.„' This example is probably too confusing, since I can't use subroutines„' in BASEC.„„CONST Max = 100„CONST TRUE = 1„CONST FALSE = 0„„DIM Stack(1 TO Max) AS STRING * 1„DIM Expression AS STRING„DIM Operator AS STRING * 1„DIM CurOp AS STRING * 1„DIM Signs AS STRING„DIM StackTop AS INTEGER, Priority AS INTEGER, CurPriority AS INTEGER„DIM I AS INTEGER, J AS INTEGER, Valid AS INTEGER, ErrorCode AS INTEGER„DIM DonePopping AS INTEGER„„StackTop = 0„Signs = " ()+-*/^"„ErrorCode = FALSE„„PRINT "INFIX to POSTFIX (RPN) CONVERTER by William Yu"„PRINT„PRINT "An example of an INFIX expression: (4 - 6) * (80 / 5) ^ 2 + 100"„PRINT„PRINT "Please enter an INFIX Expression: ";„INPUT Expression„„PRINT "POSTFIX (RPN) Expression is: ";„FOR I = 1 TO LEN(Expression)„  Valid = FALSE„  Operator = MID$(Expression, I, 1)„  FOR J = 1 TO LEN(Signs)„    IF Operator = MID$(Signs, J, 1) THEN Valid = TRUE„  NEXT J„  IF Valid THEN„    IF Operator = " " THEN„      '-- Do nothing„    ELSEIF Operator = "(" THEN„      GOSUB PushStack„    ELSEIF Operator = ")" THEN„      GOSUB ProcessRightParen„    ELSE„      PRINT " ";„      GOSUB ProcessOperator„    END IF„  ELSE„    PRINT Operator;        ' This is not really an operator.„  END IF„„  IF ErrorCode = TRUE THEN„    PRINT "<<< Error in INFIX Expression >>>"„    END„  END IF„NEXT I„„WHILE StackTop <> 0„  GOSUB PopStack„  IF Operator <> "(" THEN„    PRINT " "; Operator;„  ELSE„    PRINT "<<< Error in INFIX Expression, unresolved left parenthesis >>>"„    END„  END IF„WEND„„END„„„PopStack:„  IF StackTop = 0 THEN„    PRINT " *** Attempt to pop from an empty stack ***"„  ELSE„    Operator = Stack(StackTop)„    StackTop = StackTop - 1„  END IF„RETURN„„PushStack:„  StackTop = StackTop + 1„  IF StackTop > Max THEN„    PRINT " *** Attempt to push on a full stack ***"„  ELSE„    Stack(StackTop) = Operator„  END IF„RETURN„„„ProcessOperator:„  GOSUB GetPriority„  CurPriority = Priority        ' Save this„  CurOp = Operator              ' and this„  DonePopping = FALSE„  DO„    IF StackTop = 0 THEN„      DonePopping = TRUE„    ELSE„      GOSUB PopStack„      GOSUB GetPriority„      IF CurPriority <= Priority THEN„        PRINT " "; Operator; " ";„      ELSE„        GOSUB PushStack„        DonePopping = TRUE„      END IF„    END IF„  LOOP UNTIL DonePopping„  Operator = CurOp„  GOSUB PushStack„RETURN„„ProcessRightParen:„  DO„    IF StackTop = 0 THEN„      ErrorCode = TRUE„      RETURN„    END IF„    GOSUB PopStack„    IF Operator <> "(" THEN PRINT " "; Operator;„  LOOP UNTIL Operator = "("„RETURN„„GetPriority:„  IF Operator = "(" THEN„    Priority = 0„  ELSEIF Operator = "+" OR Operator = "-" THEN„    Priority = 1„  ELSEIF Operator = "*" OR Operator = "/" THEN„    Priority = 2„  ELSEIF Operator = "^" THEN„    Priority = 3„  END IF„RETURN„The ABC Programmer             3D SINE GRAPH FOR BASEC        voxel@edmc.net                 06-24-99 (10:00)       BEC, QB, QBasic        74   2360     SINEGRPH.BAS' Converted to BASEC v0.20 by William Yu„' Yes, it does crash, but you get the idea.„'===========================================================================„' Subject: SINE GRAPH                        Date: 03-11-92 (10:20:00)    „'  Author: Rick Pedley                       Code: QB, QBasic             „'    Keys: SINE,GRAPH                      Packet: EGAVGA.ABC„'===========================================================================„DIM SineRow(1 TO 240) AS SINGLE„DIM SineCol(1 TO 350) AS SINGLE„DIM X AS INTEGER„DIM CF AS INTEGER„DIM MAXVERTRES AS INTEGER„DIM MAXHORZRES AS INTEGER„DIM R AS INTEGER„DIM P AS INTEGER„DIM H AS INTEGER„DIM C AS INTEGER„DIM A AS INTEGER„DIM Z AS INTEGER„DIM UNDER AS INTEGER„DIM T AS INTEGER„DIM L AS INTEGER„DIM K AS INTEGER„DIM D AS INTEGER„DIM G AS INTEGER„„FOR x = 1 TO 240„   SineRow(x) = SIN(x / 10) * 30„NEXT x„„FOR x = 1 TO 350„   SineCol(x) = SIN(x / 20) * 30„NEXT x„                                                                 „SCREEN 12„CF = 1„MaxVertRes = 480„MaxHorzRes = 640„R = 0: P = 0: H = 0„C = 0: A = 0: Z = 0„Under = -1  'Change to 0 for no under side.„T = 1: L = 1: K = MaxVertRes: D = 0: G = 0„Start:                                                          „   P = K„   FOR C = T + D TO 1 STEP -1„      A = T + L: R = A - C: IF R > 240 THEN GOTO SkipSurface„      Z = (SineRow(R) + SineCol(C)) + 150„      H = K - Z - R„      IF H >= P OR H < 0 THEN GOTO Underside„      P = H: PSET (A - 1, P), 9  '<-Try 10,12,13,etc.           „Underside:                                                      „      IF Under THEN„         IF R = L OR R = L + 1 THEN G = H + 5: GOTO SkipUnder„         IF H <= G THEN GOTO SkipUnder„         G = H: IF G > MaxVertRes THEN GOTO SkipUnder„         PSET (A - 1, G), 1 '<-Try 2,4,12, etc.                 „      END IF„SkipUnder:                                                      „   NEXT C„                                                                 „SkipSurface:                                                    „   IF A = MaxHorzRes THEN GOTO Done„   T = T + 1„   IF T > 350 THEN„      T = 350„      L = L + 1: D = D + 1„      IF D = CF THEN D = 0„   END IF„   GOTO Start„Done:                                                           „DO„LOOP UNTIL INKEY$<>""„„END„