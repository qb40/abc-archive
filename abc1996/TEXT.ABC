Alexander Podkolzin            EDIT/INPUT STRING              app@sbank.e-burg.su            11-09-95 (11:16)       PB                     154  6402     INPSTR.BAS  '------------------------------ Demo here ----------------------------------ã  DEFINT a-zã  CLSã  COLOR 0,7ã  LOCATE 25,1ã  PRINT "        You can use Backspace-,Ins-,Home-,Del-,End- keys and arrow keys.        ";ã  s$=InputStr$("I am a string, edit me, please.",3,10,40,15,4)ã  COLOR 14,1ã  LOCATE 12,10ã  PRINT s$ã  ENDã'---------------------------------------------------------------------------ã'ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ã'³ FUNCTION : InputStr$                                                    ³ã'³ CALL     : s$ = InputStr$(Ed$,y%,x%,n%,textcolor%,backcolor%)           ³ã'³ Where    : Ed$   - string to edit,                                      ³ã'³          : y%,x% - place to edit/input string from,                     ³ã'³          : n%    - number of characters to edit/input.                  ³ã'³ RETURNS  : edit/input string, or null-string, if <Esc> is pressed.      ³ã'³ AUTHOR   : Alexander Podkolzin (app@sbank.e-burg.su).                   ³ã'ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙã' Source code is formatted by my program "PBB".ã'---------------------------------------------------------------------------ã'ã  FUNCTION InputStr$(Ed$,y%,x%,n%,textcolor%,backcolor%)ã'ã     STATIC Ins%                        ' Switcher of Ins-mode.ã'ã     Enter$ = CHR$(13)                  ' List of keys, we need inã     Esc$ = CHR$(27)                    ' our function.ã     BcSp$ = CHR$( 8)                   'ã     Ins$ = CHR$(0,82)                  ' Equals to CHR$(0)+CHR$(82)ã     Home$ = CHR$(0,71)                 'ã     Del$ = CHR$(0,83)ã     EndKey$ = CHR$(0,79)ã     LeftKey$ = CHR$(0,75)ã     RightKey$= CHR$(0,77)ã'ã     OldX% = POS(0)                     ' As well-bred programmers, :)ã     OldY% = CSRLIN                     ' we have to save screen parameters.ã     OldColor% = pbvScrnTxtAttr         ' Internal PB variables: color,ã     Vis%=pbvCursorVis                  ' coursor is visiable (TRUE or FALSE),ã     Sl1%=pbvCursor1                    ' top line of cursor,ã     Sl2%=pbvCursor2                    ' bottom line.ã'ã     Ptr% = x%                          ' Current cursor position.ã     COLOR textcolor%,backcolor%        ' Colors we'll use in our function.ã     LOCATE y%,x%ã     PRINT Ed$ã'ã     Edit$=GetString$(y%,x%,n%)ã     LOCATE y%,x%ã     PRINT Edit$ã     DO                                 ' Main loop:ã        IF Ptr%<x% THEN                 ' First of all weã           Ptr%=x%                      ' haveã           ITERATE LOOP                 ' toã        END IF                          ' normalizeã        IF Ptr%>x%+n%-1 THEN            ' theã           Ptr%=x%+n%-1                 ' cursor position.ã           ITERATE LOOPã        END IFã        IF Ins%=0 THENã           LOCATE y%,Ptr%,1,7,8         ' Usual cursorã        ELSE                            'ã           LOCATE y%,Ptr%,1,5,8         ' "Ins" cursorã        END IFã        WHILE NOT INSTAT: WENDã        s$ = INKEY$ã$IF 1   '----------------------------------------------------------------ã'ã' This < $IF...$ENDIF > block is for Russian PB-users only, as INKEY$ã' does not distinguish lowercase Russian character "à". (PB3.0)ã'ã        IF LEN(s$)=2 AND ASC(LEFT$(s$,1))=0 AND ASC(RIGHT$(s$,1))=0 THENã           s$=CHR$(224)ã        END IFã'ã$ENDIF  '----------------------------------------------------------------ã        SELECT CASE s$ã           CASE Esc$ã              InputStr$=""ã              EXIT LOOPã           CASE Enter$ã              InputStr$=RTRIM$(GetString(y%,x%,n%))ã              EXIT LOOPã           CASE Ins$ã              Ins% = Ins% XOR 1ã              ITERATE LOOPã           CASE Home$ã              Ptr%=x%ã              ITERATE LOOPã           CASE EndKey$ã              Ptr%=x%+LEN(RTRIM$(GetString(y%,x%,n%)))ã              ITERATE LOOPã           CASE LeftKey$ã              DECR Ptr%ã              ITERATE LOOPã           CASE RightKey$ã              INCR Ptr%ã              ITERATE LOOPã           CASE Del$ã              m%=Ptr%-x%ã              k%=x%+n%-Ptr%ã              Edit$=GetString$(y%,x%,m%)+GetString$(y%,Ptr%+1,k%)ã           CASE BcSp$                   ' Exception!ã              DECR Ptr%                 'ã              IF Ptr%<x% THEN           ' So, normalize the cursorã                 Ptr%=x%                ' position here.ã                 ITERATE LOOP           'ã              END IFã              m%=Ptr%-x%ã              k%=x%+n%-Ptr%ã              Edit$=GetString$(y%,x%,m%)+GetString$(y%,Ptr%+1,k%)ã           CASE ELSEã              IF LEN(s$)=1 THENã                 m%=Ptr%-x%             ' Symbols before cursorã                 k%=x%+n%-Ptr%-1        ' Symbols after cursorã                 IF Ins%=1 THEN         ' Editing in Ins-modeã                    Edit$=GetString$(y%,x%,m%)+ s$ +GetString$(y%,Ptr%,k%)ã                    Edit$=LEFT$(Edit$,n%)ã                 ELSE                   ' Editing in usual modeã                    Edit$=GetString$(y%,x%,m%)+ s$ +GetString$(y%,Ptr%+1,k%)ã                 END IFã                 INCR Ptr%ã              END IFã        END SELECTã        LOCATE y%,x%,0,0,0              ' Make cursor invisiableã        PRINT Edit$                     'ã     LOOP                               ' End of main loop.ã     IF Vis% THEN                       ' Now we haveã        Vis%=0                          ' toã     ELSE                               ' restoreã        Vis%=1                          ' our parameters.ã     END IF                             'ã     ct%=OldColor% AND 15ã     cb%=OldColor%\16ã     COLOR ct%,cb%ã     LOCATE Oldy%,OldX%,Vis%,Sl1%,Sl2%ã  END FUNCTION                          ' BYE !ã'---------------------------------------------------------------------------ã' This function is not fast, but we don't need speed here.ã'ã  FUNCTION GetString$(y%,x%,n%)         ' Reads string from the screen.ã     s$=""                              ' y%,x% - string coordinates,ã     FOR i%=0 TO n%-1                   ' n% - characters to read.ã        s$ = s$ + CHR$(SCREEN(y%,x%+i%))ã     NEXTã     GetString$ = s$ã  END FUNCTIONã'---------------------------------------------------------------------------ããããBrent Ashley                   WORD COUNTER                   QBFAQ                          05-11-92 (22:51)       QB, QBasic, PDS        63   2279     WC.BAS      'Speaking of contests...ãã'I got a call today from none other than Ethan Winer, saying I've wonã'Crescent's "word count" programming contest!  The idea was to writeã'the fastest all-qb program to count the words in a text file.  This oneã'does it on a 350k file in 1.4 seconds on my SX.  Ethan said I could postã'it about, so here goes:ãã' Compile:  BC /o/a wc,,wc;ã' Link:     LINK /ex/noe wc+nocom;ã'ãDEFINT A-ZãDIM FBuf AS STRING * 8192              ' Use fixed string to fixã                                       ' positionããWCount% = -32768                       ' Init count to bottom of integerã                                       ' rangeã                                       ' to get 65535 counts availableããDEF SEG = VARSEG(FBuf)                 ' Point to fixed buffer in memoryãBufStart% = VARPTR(FBuf)ãBufLen% = 8192ããNotOnWord = -1                         ' Assume not on word to startããOPEN COMMAND$ FOR BINARY AS #1         ' Open file and store lengthãAmtLeft& = LOF(1)ããDO                                     ' Process fileãã  IF AmtLeft& >= BufLen% THEN GOTO NotLastBlockãã  BufLen% = AmtLeft&                   ' Last block - size accordinglyã  Done% = -1                           '  and flag end of loopã  GOTO GetBuf                          ' Less likely event gets GOTOããNotLastBlock:                          ' More likely event falls thru toã                                       ' GetBufã  AmtLeft& = -BufLen% + AmtLeft&       ' Negative first saves bytesããGetBuf:ã  GET #1, , FBuf                       ' Fill bufferãã  FOR Ofs% = BufStart% TO BufStart% + BufLen% - 1  ' Traverse bufferãã    IF PEEK(Ofs%) > 32 THEN GOTO NotWhiteSpaceãã    IF NotOnWord% THEN GOTO NextByte   ' If already white space...ãã    NotOnWord% = -1                    ' Trailing edge of wordã    WCount% = WCount% + 1              '  triggers counterã    GOTO NextByteããNotWhiteSpace:                         ' Not white space is more likelyã    NotOnWord% = 0                     '  so comparison done on whiteã                                       '  spaceããNextByte:ã  NEXTãLOOP UNTIL Done%                       ' post-compare saves bytesããPRINT WCount% + 32768                  ' display word countããAlexander Podkolzin            GET TEXT                       app@sbank.e-burg.su            11-20-95 (17:41)       PB                     242  8663     GETTEXT.BAS '------------------------- Demo here --------------------------------ãdefint a-zãdim m$(100)ã%MAXLINES = 1000ã' Dymmy array (for testing):ãm$(1)="1aaa It's a dummy text zzzaaaaaaa ---------- First line"ãm$(2)="2bbbbbbdddddddddddddddbbbbbbbbddddb"ãm$(3)="3ccccccccccaaaazzzzzzaaaaaa"ãm$(4)="4bbbbbbbbbbbbb"ãm$(5)="5aaaaaaaaaaeeaaazzzzzzaaaaa"ãm$(6)="6bbbbwwwwwwwbbbbbbbbbbb"ãm$(7)="7aaaaaaaaaataaazzzzzzdffaaaaaa"ãm$(8)="8bbbbbbaaaaaaaaaaaaabbbbbbbbb"ãm$(9)="9aaaaaaaaazzzzzzaaaaaaa"ãm$(10)="10bbbbbbbbbbbbbbbww"ãm$(11)="11aaaazzzzzzaaaaaaawwwwwwwwwwwwaaaaaaa"ãm$(12)="12bbbbbbbbbbbbbbb"ãm$(13)="13aaaaaaaaazzzzzzaaaaaaaaa"ãm$(14)="14bbbbbbbbbbbbbbb ------------- Last line "ã'ãclsãprint string$(2000,176);ãcolor 0,7ãlocate 1,1ãprint space$(80);ãlocate 1,16ãprint "Using navigation keys,choose a line from text array..."ãlocate 25,1ãprint space$(80);ãs$ = gettext(m$(),1,22,7,58,13,12,1,0,7) '0,7)ãif s$="" then s$=" You have pressed ESC-key"ãlocate 25,2ãprint "You chose line: "; s$;ãendãã'--------------------------------------------------------------------------ã' GetText$:ã' Returns a string, you chose from an array. It can be used for menuingã' as well. If you don't want cursor bar, make ct%=ctn%, cb%=cbn% and itã' will be a kind of simple browser.ã'--------------------------------------------------------------------------ã' Author: Alexander Podkolzin <APP@nw.sbank.e-burg.su>ã'--------------------------------------------------------------------------ã'ã  FUNCTION GetText$( txt$(),_           ' text array,ã     twin%,_                            ' win type,ã     xb%, yb%, xe%, ye0%,_              ' window coordinates,ã     ct%,cb%,_                          ' window colors,ã     ctn%,cbn%)_                        ' cursor bar colorsã     PUBLICã'ã     OldX% = POS(0)                     ' Saving parameters have to beã     OldY% = CSRLIN                     ' your habit :)ã     OldColor% = pbvScrnTxtAttr         ' (internal PB variable)ã     COLOR ct%,cb%                      'ã'ã     Enter$=CHR$(13)                    ' Only for beauty of our code,ã     Esc$ = CHR$(27)                    ' as it's rather difficult toã     Home$ = CHR$(0,71)                 ' understand such lines as:ã     PgUp$ = CHR$(0,73)                 ' IF RIGHT$(s$,1) = "G" THEN ...ã     EndKey$ = CHR$(0,79)               ' then:ã     PgDn$ = CHR$(0,81)                 ' IF s$ = Home$ THEN ...ã     Up$ = CHR$(0,72)                   'ã     Down$ = CHR$(0,80)                 'ã'ã     FOR i%=1 TO %MAXLINES              ' max lines in text arrayã        IF LEN(txt$(i%))=0 THEN EXIT FORã     NEXT i%ã     nlines%=i%-1ã     IF nlines%<ye0%-yb%-1 THENã        ye%=yb%+nlines%+1ã     ELSEã        ye%=ye0%ã     END IFã     lpage%=ye%-yb%-1ã     CALL win(twin%,xb%,yb%,xe%,ye%,ct%,cb%)ã     begy%=1ã     Cur%=1ã     endy%=MIN(lpage%,nlines%)ã     GOSUB ShowTextã     GOSUB ShowCursorBarã     DO                                 ' begy% - first line to show,ã        IF nlines%<1 THEN EXIT LOOP     ' endy% - last line to show (array)ã        k$=INKEY$                       ' cur%  - the cursor bar lineã        SELECT CASE k$                  ' lpage%- length of window (page)ã           CASE "" : ITERATE LOOPã           CASE Esc$ : cur%=0 : begy%=1:EXIT LOOPã           CASE Enter$ : EXIT LOOPã           CASE Home$ : begy%=1 : endy%=nlines%ã           CASE EndKey$: begy%=nlines%-ye%+yb%+2 : endy%=nlines%ã           CASE Up$ã              IF cur%>1 THENã                 GOSUB HideCursorBarã                 DECR cur%ã                 GOSUB ShowCursorBarã              ELSEã                 begy%=begy%-1ã                 endy%=endy%-1ã              END IFã           CASE Down$ã              IF cur%<lpage% THENã                 GOSUB HideCursorBarã                 INCR cur%ã                 GOSUB ShowCursorBarã              ELSEã                 begy%=begy%+1ã                 endy%=endy%+1ã              END IFã           CASE PgUp$ : begy%=begy%-lpage% : endy%=endy%-lpage%ã           CASE PgDn$ : begy%=begy%+lpage% : endy%=endy%+lpage%ã           CASE ELSE  : k$=""ã        END SELECTã        GOSUB ShowTextã     LOOPã     Gt%=begy%+cur%-1ã     IF Gt%<>0 THENã        GetText$=txt$(Gt%)ã     ELSEã        GetText$=""ã     END IFã     ct%=OldColor% AND 15               ' restore parametersã     cb%=OldColor%\16                   'ã     COLOR ct%,cb%                      'ã     LOCATE oldy%,oldx%                 'ã     EXIT FUNCTIONããShowText:ã     CALL Numerer(nlines%,lpage%,begy%,endy%)ã     GOSUB MakeRulerã     FOR i%=begy% TO endy%ã        PutString xb%+2,yb%+i%-begy%+1,_ã                  LEFT$(txt$(i%)+SPACE$(xe%-xb%+1),xe%-xb%-3)ã     NEXT i%ã     RETURNããShowCursorBar:ã     FOR i%=xb%+1 TO xe%-1ã        PutAttribute i%,yb%+cur%,ctn%,cbn%ã     NEXTã     RETURNããHideCursorBar:ã     FOR i%=xb%+1 TO xe%-1ã        PutAttribute i%,yb%+cur%,ct%,cb%ã     NEXTã     RETURNããMakeRuler:ã    FOR i%=yb%+1 TO ye%-1ã       PutAttribute xe%,i%,ct%,cb%ã       PutString xe%,i%,CHR$(177)ã    NEXTã    k%=((begy%+cur%-1)/nlines%)*(ye%-yb%-1)ã    IF k%=0 THEN k%=1                   ' Correction "Kill insect"ã    PutString xe%,yb%+k%,CHR$(219)ã    RETURNã  END FUNCTIONã'ã' A few words about correction "Kill insect". :)ã' Probable, it is not mine invention.         :)ã' Sometimes in my programs appears difficult  :)ã' points, in which I have hardly to think to  :)ã' write "universal" formula for all possible  :)ã' cases. As I'm a LAZY person, I write simple :)ã' formula and correct its wrong results by    :)ã' additional line (sometimes not one) of code.:)ã' Such corrections I name "Kill insect".      :)ã'--------------------------------------------------------------------------ã' Numerer "normalizes" begy% and endy%        <-  very usefull function!ã'ã  SUB Numerer(nlines%,lpage%,begy%,endy%)ã     IF nlines%<=lpage% THENã        begy%=1ã        endy%=nlines%ã        EXIT SUBã     END IFã     IF begy%<1 THENã        begy%=1ã        endy%=begy%+lpage%-1ã        EXIT SUBã     END IFã     IF begy%+lpage%-1>=nlines% THENã        endy%=nlines%ã        begy%=nlines%-lpage%+1ã        EXIT SUBã     END IFã     endy%=begy%+lpage%-1ã  END SUBã'--------------------------------------------------------------------------ã  SUB PutString(x%,y%,st$)ã     k%=160*(y%-1)+x%+x%-2ã     DEF SEG = &HB800                   ' This is system dependent!ã     FOR i%=0 TO LEN(st$)-1ã        POKE$ k%+i%+i%,MID$(st$,i%+1,1)ã     NEXTã     DEF SEGã  END SUBã'--------------------------------------------------------------------------ã  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)ã'ã     OldColor% = pbvScrnTxtAttr         ' Internal PB variableã     SELECT CASE t%                     ' Window typesã'                                       ' (you can make as much types,ã'                                       '  as you want):ã        CASE 1ã           a%=218:b%=196:c%=191         'ÚÄÄÄÄÄÄÄ¿ã           h%=179:      :d%=179         '³   1   ³ã           g%=192:f%=196:e%=217         'ÀÄÄÄÄÄÄÄÙã        CASE 2ã           a%=201:b%=205:c%=187         'ÉÍÍÍÍÍÍÍ»ã           h%=186:      :d%=186         'º   2   ºã           g%=200:f%=205:e%=188         'ÈÍÍÍÍÍÍÍ¼ã        CASE ELSEã           a%=032:b%= a%:c%= a%         'ã           h%= a%: :d%= a%              ' Blanks onlyã           g%= a%:f%= a%:e%= a%         'ã     END SELECTã     COLOR ct%,cb%ã     LOCATE yb%,xb%   : PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%)ã     FOR i%=yb%+1 TO ye%-1ã        LOCATE i%,xb% : PRINT CHR$(h%)+     SPACE$(xe%-xb%-1)     +CHR$(d%)ã     NEXTã     LOCATE ye%,xb%   : PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%)ã     FOR i%=yb%+1 TO ye%+1ã        PutAttribute xe%+1,i%,8,0       ' Maikingã     NEXT                               ' shadowsã     FOR i%=xb%+1 TO xe%+1              'ã        PutAttribute i%,ye%+1,8,0       'ã     NEXTã     ct%=OldColor% AND 15               ' restore colorsã     cb%=OldColor%\16ã     COLOR ct%,cb%ã  END SUBã'--------------------------------------------------------------------------ã  SUB PutAttribute(x%,y%,t%,b%)         ' Puts attribute byte to video memoryã     LOCAL c%                           ' directly to Colomn, Row positionã     c% = b%*16+t%                      'ã     DEF SEG = &hb800                   ' NOTE: This is system depending !ã     POKE 160*(y%-1)+x%+x%-1,c%ã     DEF SEGã  END SUBã'--------------------------------------------------------------------------ãKenneth W. Melvin              EDITING RANDON ACCESS FILE     kwmelvin@nr.infi.net           11-24-95 (00:00)       QB, QBasic, PDS        548  21776    KEN-ED03.BAS'+------------------------------------------------------------------+ã'| Filename: KEN-ED03.BAS                                           |ã'|     Date: 11-24-95                                               |ã'|  Purpose: Simple example of editing a random access file using   |ã'|         : structured Qbasic. This is part of an ongoing series   |ã'|         : of personal programming examples for learning QBasic   |ã'|  Version: 0.03   ( added Ethan Winer's Editor subprocedure )     |ã'|   Author: kwmelvin@nr.infi.net <Kenneth W. Melvin>               |ã'|    Kudos: Thanks to Phil Wright for his patient tutorials, and to|ã'|         : Dave Gjessing for encouragement and support, and to    |ã'|         : Ethan Winer for _BASIC Techniques and Utilities_       |ã'| Language: QBasic 1.1      drive:\> QBASIC /RUN KEN-ED03          |ã'|    Notes: Documentation (started 11-21-95)                       |ã'|         : Add graphics routines from DEMOSCRN.BAS                |ã'|         : Add sorting routine                                    |ã'|    * New: Now choose a record to Edit from the display list      |ã'|         : Note the use of the FRE() function to measure memory   |ã'|         : If user presses 0 or >NumRec, she's taken back to Menu |ã'|         : Editor subprocedure added to EnterRecord and EditRecord|ã'+------------------------------------------------------------------+ã'===================================================================+ã'---- PSEUDOCODE version 0.03                                       |ã'1. Open the random access file                                     |ã'2. Display beginning file statistics                               |ã'3. LOOP until menu option "Q" is chosen                            |ã'   3.1 Display the menu and input choice                           |ã'   3.2 Execute the correct subprocedure                            |ã'       3.2.1  Enter a record                                       |ã'       3.2.2  List a record                                        |ã'       3.2.3  Edit a record                                        |ã'       3.2.4  Quit                                                 |ã'4. Display ending file statistics                                  |ã'5. Close the random access file                                    |ã'6. Stop                                                            |ã'                                                                   |ã'---- Enter a Record                                                |ã'1. Input the data for the new record using Editor                  |ã'2. Ask if there's another new record to Enter                      |ã'3. IF the answer is Yes THEN LOOP                                  |ã'   ELSE                                                            |ã'4. End Sub                                                         |ã'                                                                   |ã'---- List a Record                                                 |ã'1. Define the keystrokes and capture them                          |ã'2. Display the records to the screen and wait for user input       |ã'   2.1 If Right Arrow is pressed, increment record shown           |ã'   2.2 If Left Arrow is pressed, decrement record shown            |ã'   2.3 If Enter is pressed, Edit the record shown                  |ã'       2.3.1 Enter editing sub and print chosen record to screen   |ã'       2.3.2 Ask which line to edit (menu right now)               |ã'       2.3.3 Use Editor sub to edit each line.                     |ã'       2.3.4 Edit another line?                                    |ã'       2.3.5 If Yes, loop to 2.3.3                                 |ã'       2.3.6 If No, Edit another record?                           |ã'       2.3.7 If Yes, get record number to edit and loop to 2.3.1   |ã'       2.3.8 If No, go back to main menu.                          |ã'   2.4 If Esc is pressed, return to the main menu.                 |ã'                                                                   |ã'---- Edit a Record                                                 |ã'1. Ask for record number to edit                                   |ã'   1.1 If record number entered is 0, ask again                    |ã'   1.2 If record number does not exist                             |ã'       1.2.1 Show a brief error message                            |ã'       1.2.2 Return to main menu                                   |ã'2. Edit the record chosen                                          |ã'   2.1 Enter the editing sub and print the chosen record to screen |ã'   2.2 Ask user to choose which line to edit (menu right now)      |ã'   2.3 Use Editor sub to edit each line.                           |ã'   2.4 Edit another line?                                          |ã'   2.5 If Yes, loop to 2.3                                         |ã'   2.6 If No, Edit another record?                                 |ã'   2.7 If Yes, get record number to edit and loop to 2.1           |ã'   2.8 If No, go back to main menu.                                |ã'                                                                   |ã'---- File Statistics                                               |ã'1. Display data file statistics for learning purposes only         |ã'   These routines may be removed when no longer needed             |ã'   1.1 Show data file length at start and end of program           |ã'   1.2 Show record size                                            |ã'   1.3 Show number of records in file                              |ã'   1.4 Show total heap space available                             |ã'   1.5 Show total string space available                           |ã'2. The MemAvail sub is called from several locations               |ã'                                                                   |ã'---- End of Program                                                |ã'1. Display final file statistics                                   |ã'2. Close all open files.                                           |ã'===================================================================+ãã' *** Declarations ***ãDECLARE SUB EnterScreen (NumRec%)ãDECLARE SUB Kprint (Text$, Row%, Col%, Fg%, Bg%)ãDECLARE SUB EditARecord (RecordToEdit%)ãDECLARE SUB Editor (Text$, LeftCol%, RightCol%, KeyCode%)ãDECLARE SUB EnterRecord (NumRec%)ãDECLARE SUB DataFileStats (FileLen%, RecSize%, NumRec%)ãDECLARE SUB DisplayRecord (NumRec%)ãDECLARE SUB MemAvail (Row%, Col%)ãDECLARE SUB PrintTheMenu ()ããREM $DYNAMIC 'for use by MemAvailããDEFINT A-Zã' *** TYPE Structure ***ãTYPE MyFriendsã    LastName AS STRING * 14ã    FirstName AS STRING * 14ã    StreetAdd AS STRING * 28ã    City AS STRING * 14ã    State AS STRING * 2ã    ZipCode AS STRING * 10ã    Phone AS STRING * 14ã    Birthday AS STRING * 10ã    Comments AS STRING * 50ãEND TYPEãã' *** Dimension variable of TYPE MyFriends ***ãDIM Friend AS MyFriendsãã' *** Open a random access file ***ãOPEN "KEN-ED03.DAT" FOR RANDOM AS #1 LEN = LEN(Friend)ãã' *** Define some variables ***ãFileLen = LOF(1)ãRecSize = LEN(Friend)ãNumRec = LOF(1) / LEN(Friend)ãã' *** Show Datafile statistics ***ãCALL DataFileStats(FileLen, RecSize, NumRec)ãCALL Kprint("Press any key to continue", 25, 1, 7, 0)ãSLEEPãã' *** MAIN PROGRAM LINE ***ãBeginHere:ãDOã  CALL PrintTheMenuã  Sel$ = INPUT$(1)ã  SELECT CASE Sel$ã    CASE "E", "e"ã        CALL EnterRecord(NumRec)ã    CASE "L", "l"ã        CALL DisplayRecord(NumRec)ã    CASE "D", "d"ã        CALL EditARecord(RecordToEdit)ã    CASE "Q", "q"ã        GOTO EndProgramã    CASE ELSEã        GOTO BeginHereã  END SELECTãLOOP UNTIL UCASE$(Sel$) = "Q"ããEndProgram:ãCLSãFileLen = LOF(1)ãRecSize = LEN(Friend)ãNumRec = LOF(1) / LEN(Friend)ãCALL DataFileStats(FileLen, RecSize, NumRec)ãCLOSEãENDãã'*** END OF PROGRAM ***ããREM $STATICãSUB DataFileStats (FileLen, RecSize, NumRec)ã    CLSã    CALL Kprint("DATABASE FILE STATISTICS", 10, 27, 3, 0): COLOR 7, 0ã    LOCATE 12, 30: PRINT "FileSize:"; FileLen; "bytes"ã    LOCATE 13, 28: PRINT "RecordSize:"; RecSize; "bytes"ã    LOCATE 14, 27: PRINT "No. Records:"; NumRecã    CALL MemAvail(15, 21)ãEND SUBããSUB DisplayRecord (NumRec)ãCLSãDIM Friend AS MyFriends  'this DIM statement has to be here, or QBasicã                            'shows an error message:"Identifier cannotã                            'include period."  Highlight on Friend.LastName.ãX = 1                   'initialize record numberãDO                      'begin display loopã    Ky$ = INKEY$        'capture a keypressã    IF Ky$ <> "" THENã        IF Ky$ = CHR$(0) + "M" THEN X = X + 1   '-> arrow key - nextã        IF Ky$ = CHR$(0) + "K" THEN X = X - 1   '<- arrow key - previousã        IF Ky$ = CHR$(13) THEN CALL EditARecord(X): EXIT SUB '<Enter> - editã        IF Ky$ = CHR$(27) THEN EXIT SUB         ' <Esc> key - exitã    END IFã   ã    IF X = 0 THEN X = NumRec                    ' wrap-around when recordã    IF X > NumRec THEN X = 1                    ' goes past end or beginningã    IF X < 1 THEN X = 1ãã    GET #1, X, Friend       'get #filenum, recordnumber, variableã    LOCATE 5, 30: COLOR 3, 0: PRINT "Record No."; X: COLOR 7, 0ã    LOCATE 7, 25: PRINT Friend.LastName, Friend.FirstNameã    LOCATE 8, 25: PRINT Friend.StreetAddã    LOCATE 9, 25: PRINT Friend.City; Friend.State; " "; Friend.ZipCodeã    LOCATE 10, 25: PRINT Friend.Phone,ã    LOCATE 11, 25: PRINT Friend.Birthdayã    LOCATE 12, 25: PRINT Friend.Commentsã    ã    'Screen Legendã    LOCATE 14, 25: COLOR 4, 0: PRINT "< ";CHR$(26);" >"; : COLOR 7, 0: PRINT " = Next Record"ã    LOCATE 15, 25: COLOR 4, 0: PRINT "<  >"; : COLOR 7, 0: PRINT " = Previous Record"ã    LOCATE 16, 25: COLOR 4, 0: PRINT "<ÄÙ>"; : COLOR 7, 0: PRINT " = Edit Record"ã    LOCATE 17, 25: COLOR 4, 0: PRINT "<Esc>"; : COLOR 7, 0: PRINT " = Exit";ã    CALL MemAvail(20, 25)ã    SLEEP: CLSãLOOPãEND SUBããSUB EditARecord (RecordToEdit)ã    DIM Friend AS MyFriendsãã'****** Main editing loop ***ãDOã    CLSã    NumRec = LOF(1) / LEN(Friend)ã    IF RecordToEdit >= 1 THEN GOSUB PrintExistingRecordã    IF RecordToEdit = 0 THENã        LOCATE 12, 20: COLOR 7, 0ã        INPUT "Edit which record number?: ", RecordToEditã    ELSEIF RecordToEdit > NumRec THENãTryAgain:ã        CALL Kprint("ERROR - That record doesn't exist!", 12, 25, 3, 0)ã        RecordToEdit = 0ã        SLEEP 5ã    END IFã    GOSUB PrintExistingRecordã   ãStartLineEdit:ã    LOCATE 15, 1: PRINT "[press zero (0) to exit]": CALL MemAvail(20, 25)ã    LOCATE 16, 1: INPUT "Choose a line to edit (1-9): ", Choiceã        IF Choice = 0 THEN EXIT SUBã    SELECT CASE Choiceã       ã        CASE 1ã            LOCATE 3, 26: COLOR 14, 0ã            CALL Editor(Friend.LastName, 26, 40, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 2ã            LOCATE 4, 26: COLOR 14, 0ã            CALL Editor(Friend.FirstName, 26, 40, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 3ã            LOCATE 5, 26: COLOR 14, 0ã            CALL Editor(Friend.StreetAdd, 26, 54, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 4ã            LOCATE 6, 26: COLOR 14, 0ã            CALL Editor(Friend.City, 26, 40, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 5ã            LOCATE 7, 26: COLOR 14, 0ã            CALL Editor(Friend.State, 26, 28, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 6ã            LOCATE 8, 26: COLOR 14, 0ã            CALL Editor(Friend.ZipCode, 26, 36, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 7ã            LOCATE 9, 26: COLOR 14, 0ã            CALL Editor(Friend.Phone, 26, 40, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 8ã            LOCATE 10, 26: COLOR 14, 0ã            CALL Editor(Friend.Birthday, 26, 36, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE 9ã            LOCATE 11, 26: COLOR 14, 0ã            CALL Editor(Friend.Comments, 26, 76, KeyCode)ã            PUT #1, RecordToEdit, Friend: GOSUB PrintExistingRecordã       ã        CASE ELSEã            BEEP: GOTO StartLineEditã    END SELECTã    ã    'clear lines from screenã    LOCATE 16, 1: PRINT STRING$(70, CHR$(32))ã    LOCATE 17, 1: PRINT STRING$(70, CHR$(32))ã   ã    LOCATE 16, 1: PRINT "Edit another line? Y/N"; : Ans$ = INPUT$(1)ã    IF UCASE$(Ans$) = "Y" THEN GOTO StartLineEditã   ã    CALL Kprint("Edit another record? Y/N", 18, 1, 4, 0)       'ask user forã    Ans$ = INPUT$(1): COLOR 7, 0: RecordToEdit = 0             'input...ã    IF UCASE$(Ans$) = "N" THEN EXIT SUB      'get out of here if answer is NoãLOOP WHILE UCASE$(Ans$) = "Y"                'loop as long as they answer Yesããã'---- this routine is used to show the edits made and is also a menuã'     for selection of which line to edit.ãPrintExistingRecord:ã    ã    CLSã    NumRec = LOF(1) / LEN(Friend)ã    IF RecordToEdit > NumRec THEN GOTO TryAgainã    IF RecordToEdit = 0 THEN EXIT SUBã    GET #1, RecordToEdit, Friendã    LOCATE 2, 1: COLOR 3, 0: PRINT "Edit Record #"; RecordToEdit: COLOR 7, 0ã    PRINT "1) Last Name           : "; Friend.LastNameã    PRINT "2) First Name          : "; Friend.FirstNameã    PRINT "3) Street Address      : "; Friend.StreetAddã    PRINT "4) City                : "; Friend.Cityã    PRINT "5) State               : "; Friend.Stateã    PRINT "6) Zip Code            : "; Friend.ZipCodeã    PRINT "7) Phone               : "; Friend.Phoneã    PRINT "8) Birthday            : "; Friend.Birthdayã    PRINT "9) Comments            : "; Friend.Commentsã    COLOR 7, 0ãRETURNããEND SUBããSUB Editor (Text$, LeftCol, RightCol, KeyCode) STATICã  '---- Editor is a single line text editorã  '---- Find the cursor's sizeã  DEF SEG = 0ã  IF PEEK(&H463) = &HB4 THENã        CsrSize = 12                'mono uses 13 scan linesã  ELSEã        CsrSize = 7                 'color uses 8ã  END IFãã  '----Work with a temporary copyã  Edit$ = SPACE$(RightCol - LeftCol + 1)ã  LSET Edit$ = Text$ãã  '---- See where to begin editing and print the string.ã  TxtPos = POS(0) - LeftCol + 1ã  IF TxtPos < 1 THEN TxtPos = 1ã  IF TxtPos > LEN(Edit$) THEN TxtPos = LEN(Edit$)ãã  LOCATE , LeftColã  PRINT Edit$;ãã  '---- This is the main loop for handling key pressesã  DOã        LOCATE , LeftCol + TxtPos - 1, 1ãã        DOã          Ky$ = INKEY$ã        LOOP UNTIL LEN(Ky$)             'wait for a keypressãã        IF LEN(Ky$) = 1 THEN            'create a key codeã          KeyCode = ASC(Ky$)            'regular character keyã        ELSE                            'extended keyã          KeyCode = -ASC(RIGHT$(Ky$, 1))ã        END IFãã        '---- Branch according to the key pressedã        SELECT CASE KeyCodeãã          '---- Backspace: decrement the pointer and theã          '     cursor, and ignore if in the first column.ã          CASE 8ã                TxtPos = TxtPos - 1ã                LOCATE , LeftCol + TxtPos - 1, 0ã                IF TxtPos > 0 THENã                  IF InsStatus THENã                        MID$(Edit$, TxtPos) = MID$(Edit$, TxtPos + 1) + " "ã                  ELSEã                        MID$(Edit$, TxtPos) = " "ã                  END IFã                        PRINT MID$(Edit$, TxtPos);ã                END IFãã          '---- Enter or Escape: this block is optional inã          '     case you want to handle these separately.ã          CASE 13, 27ã                EXIT DO                 'exit the subprogramãã          '---- Letter keys: turn off the cursor to hideã          '     the printing, handle Insert mode as needed.ã          CASE 32 TO 254ã                LOCATE , , 0ã                IF InsStatus THEN       'expand the stringã                  MID$(Edit$, TxtPos) = Ky$ + MID$(Edit$, TxtPos)ã                  PRINT MID$(Edit$, TxtPos);ã                ELSE                    'else insert characterã                  MID$(Edit$, TxtPos) = Ky$ã                  PRINT Ky$;ã                END IFã                TxtPos = TxtPos + 1     'update position counterãã          '---- Left arrow: decrement the position counter.ã          CASE -75ã                TxtPos = TxtPos - 1ãã          '---- Right arrow: increment position counter.ã          CASE -77ã                TxtPos = TxtPos + 1ãã          '---- Home: jump to the first character position.ã          CASE -71ã                TxtPos = 1ãã          '---- End: search for the last non-blank, andã          '     make that the current editing position.ã          CASE -79ã                FOR N = LEN(Edit$) TO 1 STEP -1ã                  IF MID$(Edit$, N, 1) <> " " THEN EXIT FORã                NEXTã                TxtPos = N + 1ã                IF TxtPos > LEN(Edit$) THEN TxtPos = LEN(Edit$)ãã          '---- Insert key: toggle the Insert state andã          '     adjust the cursor size.ã          CASE -82ã                InsStatus = NOT InsStatusã                IF InsStatus THENã                  LOCATE , , , 0, CsrSizeã                ELSEã                  LOCATE , , , CsrSize - 1, CsrSizeã                END IFã          ã          '---- Delete: delete the current character andã          '     reprint what remains in the string.ã          CASE -83ã                MID$(Edit$, TxtPos) = MID$(Edit$, TxtPos + 1) + " "ã                LOCATE , , 0ã                PRINT MID$(Edit$, TxtPos);ãã          '---- All other keys: exit the subprogramã          CASE ELSEã                EXIT DOã        END SELECTã  '---- Loop until the cursor moves out of the field.ã  LOOP UNTIL TxtPos < 1 OR TxtPos > LEN(Edit$)ãã  Text$ = RTRIM$(Edit$)         'trim the textããEND SUBããSUB EnterRecord (NumRec)ãCLSãDIM Friend AS MyFriends     'this DIM statement has to be here, or QBasicã                            'shows an error message:Identifier cannot includeã                            'period.    Highlight on Friend.LastName.ãDOã    GOSUB InitializeScreenã    CALL MemAvail(20, 25)ã            LOCATE 3, 1: COLOR 14, 0ã            CALL Editor(Friend.LastName, 26, 40, KeyCode): COLOR 7, 0ã          ã            LOCATE 4, 1: COLOR 14, 0ã            CALL Editor(Friend.FirstName, 26, 40, KeyCode): COLOR 7, 0ã          ã            LOCATE 5, 1: COLOR 14, 0ã            CALL Editor(Friend.StreetAdd, 26, 54, KeyCode): COLOR 7, 0ã          ã            LOCATE 6, 1: COLOR 14, 0ã            CALL Editor(Friend.City, 26, 40, KeyCode): COLOR 7, 0ã          ã            LOCATE 7, 1: COLOR 14, 0ã            CALL Editor(Friend.State, 26, 28, KeyCode): COLOR 7, 0ã          ã            LOCATE 8, 1: COLOR 14, 0ã            CALL Editor(Friend.ZipCode, 26, 36, KeyCode): COLOR 7, 0ã          ã            LOCATE 9, 1: COLOR 14, 0ã            CALL Editor(Friend.Phone, 26, 40, KeyCode): COLOR 7, 0ã          ã            LOCATE 10, 1: COLOR 14, 0ã            CALL Editor(Friend.Birthday, 26, 36, KeyCode): COLOR 7, 0ã          ã            LOCATE 11, 1: COLOR 14, 0ã            CALL Editor(Friend.Comments, 26, 76, KeyCode): COLOR 7, 0ã            PUT #1, NumRec, Friendã           ã    NumRec = LOF(1) / LEN(Friend)ã    LOCATE 13, 1: PRINT "Enter another record? Y/N ";   'ask user for inputã    Ans$ = INPUT$(1)ã    GOSUB EnterANewRecord: CLSãLOOP WHILE UCASE$(Ans$) = "Y"               'loop as long as they answer YesãGOTO ThisIsTheEndããInitializeScreen:ã    NumRec = NumRec + 1ã    CALL EnterScreen(NumRec)ãRETURNããEnterANewRecord:ã    IF NumRec = 0 THEN EXIT SUBã    GET #1, NumRec, Friendã    Friend.LastName = ""ã    Friend.FirstName = ""ã    Friend.StreetAdd = ""ã    Friend.City = ""ã    Friend.State = ""ã    Friend.ZipCode = ""ã    Friend.Phone = ""ã    Friend.Birthday = ""ã    Friend.Comments = ""ãRETURNããThisIsTheEnd:ãEND SUBããSUB EnterScreen (NumRec)ã    DIM Friend AS MyFriendsã    LOCATE 2, 1: COLOR 3, 0: PRINT "Enter Record #"; NumRec: COLOR 7, 0ã    PRINT "Last Name              : "ã    PRINT "First Name             : "ã    PRINT "Street Address         : "ã    PRINT "City                   : "ã    PRINT "State                  : "ã    PRINT "Zip Code               : "ã    PRINT "Phone                  : "ã    PRINT "Birthday               : "ã    PRINT "Comments               : "ã    COLOR 7, 0ãEND SUBããSUB Kprint (Text$, Row, Col, Fg, Bg)ã    LOCATE Row, Colã    COLOR Fg, Bgã    PRINT Text$;ãEND SUBããSUB MemAvail (Row, Col)ã    LOCATE Row, Colã    PRINT "  Free heap space:"; FRE(-1)ã    LOCATE (Row + 1), Colã    PRINT "Free string space:"; FRE(0)ã    LOCATE , , 0ãEND SUBããSUB PrintTheMenuã  CLSã  CALL Kprint("Main Menu", 5, 31, 4, 0)ã  CALL Kprint("E", 7, 31, 4, 0): CALL Kprint("nter a Record", 7, 32, 7, 0)ã  CALL Kprint("L", 9, 31, 4, 0): CALL Kprint("ist Records", 9, 32, 7, 0)ã  CALL Kprint("E", 11, 31, 7, 0): CALL Kprint("d", 11, 32, 4, 0)ã  CALL Kprint("it Records", 11, 33, 7, 0)ã  CALL Kprint("Q", 13, 31, 4, 0): CALL Kprint("uit", 13, 32, 7, 0)ã  CALL Kprint("Choose", 15, 31, 4, 0): CALL Kprint(" E, L, D, ", 15, 37, 7, 0)ã  CALL Kprint("or ", 15, 47, 4, 0): CALL Kprint("Q", 15, 50, 7, 0)ã  CALL MemAvail(20, 25)ãEND SUBããSami Laine                     PASSWORD FUNCTION              oh1jkt@mea.cc.utu.fi           11-14-95 (21:25)       QB, QBasic, PDS        61   1443     PASSWORD.BAS' PASSWORD.BAS - demonstration of basic input routines, when hidingã'        typed characters (plus this will handle backspace).ã'ã' PASSWORD.BAS is hereby donated to public domain by Sami Laine.ã'ã' You can contact original author as <oh1jkt@mea.cc.utu.fi> or from FidoNetã' point 2:222/130.69.ã'ã' Password$ will return string "(NULL)" in any error (there are only few,ã' actually just one - too long ( > 1 ) Repl$ string).ã'ã' Sample call:ã'ã'       secret$ = Password$("Secret word: ", "*", 8)ã'ãDECLARE FUNCTION Password$ (Prompt$, Repl$, MaxLength%)ããFUNCTION Password$ (Prompt$, Repl$, MaxLength%)ã'ã' Make sure user is using only 1 character as replacement.ã'ãIF LEN(Repl$) > 1 THENã	Password$ = "(NULL)"ã	EXIT FUNCTIONãEND IFããPRINT Prompt$;ãOrigRow% = CSRLINãOrigColumn% = POS(1)ãColumn% = OrigColumn%ããDOã	' Read character.ã	C$ = INPUT$(1)ã	SELECT CASE ASC(C$)ã		' Handle ENTER (stop reading characters).ã		CASE 13ã			EXIT DOã		' Handle BACKSPACE key.ã		CASE 8ã			IF Column% > OrigColumn% THENã				Column% = Column% - 1ã				LOCATE OrigRow%, Column%ã				PRINT " ";ã				LOCATE OrigRow%, Column%ã				IF LEN(TmpStr$) THENã					TmpStr$ = MID$(TmpStr$, 1, (LEN(TmpStr$) - 1))ã				END IFã			END IFã		CASE ELSEã			IF LEN(TmpStr$) < MaxLength% THENã				TmpStr$ = TmpStr$ + C$ã				PRINT Repl$;ã			END IFã			Column% = Column% + 1ã	END SELECTãLOOPããPassword$ = TmpStr$ããEND FUNCTIONãRick Pedley                    SHUFFLING DATA IN AN ARRAY     FidoNet QUIK_BAS Echo          10-03-93 (10:42)       QB, QBasic, PDS        78   2563     SHUFFLE.BAS ' > I'm looking for a code to shuffle data so that I get a list of theãã' Here's a way to shuffle each number exactly once, in _one_ array:ã ãDEFINT A-Z ãRANDOMIZE TIMER ã ãMaxNum = 1000 ãDIM Array (1 TO MaxNum) ãFOR x = 1 TO MaxNum ã   Array(x) = x ãNEXT x ãTop = 1 ãBottom = MaxNum ãWHILE Bottom > Top ã   RandNum = INT((Bottom - Top + 1) * RND + 1) ã   SWAP Array(RandNum), Array(Bottom) ã   Bottom = Bottom - 1 ãWEND ã ã'With five numbers, here's a picture of how it works: ã ã'1            1            4            3            3 < Bottom ã'2            5            5            5 < Bottom   5   (exit) ã'3            3            3 < Bottom   4            4 ã'4            4 < Bottom   1            1            1 ã'5 < Bottom   2            2            2            2 ã ã'Sometimes the Bottom value swaps with itself, as I did purposely ã'in the last column. And as you can see, although 4 moved twice, ã'the shuffle is always completed in MaxNum times through the loop. ã'It's very fast, no index array is needed, and it doesn't slow ã'down near the end the way some other methods do. Here's a semi- ã'practical application for a sort like this (shuffling a deck of ã'cards is another obvious use). If you compare this method with ã'filling an index array with flag values, you'll see the difference. ã ã'Turn text screen from white to black randomly, ã'one location at a time. ã ãDEFINT A-Z ãRANDOMIZE TIMER ãRows = 25                 'or 43 or 50 ãMaxNum = Rows * 80 ãDIM ScrnEl(MaxNum) ãBlock$ = CHR$(219) ãBlockLine$ = STRING$(80, Block$)ãFOR X = 1 TO MaxNum       'initialize array ã   ScrnEl(X) = X ãNEXT X ãTop = 1: Bot = MaxNum ãDO                        'shuffle all screen pos'ns ã   RandNum = INT(Bot * RND + 1) ã   SWAP ScrnEl(RandNum), ScrnEl(Bot) ã   Bot = Bot - 1 ãLOOP WHILE Bot > Top ãCLS ãCOLOR 15 ãFOR X = 1 TO Rows         'fill in screen ã   PRINT BlockLine$; ãNEXT X ãDO UNTIL LEN(INKEY$): LOOP ããCOLOR 0 ãFOR X = 1 TO 2000 ã   C = ScrnEl(X) MOD 80: IF C = 0 THEN C = 80 'calc screen pos'n ã   R = ScrnEl(X) \ 80 - (C < 80) ã   LOCATE R, C: PRINT Block$; ãNEXT X ãEND ã ã'You can use this method easily with file records. You would do the ã'shuffle first, so all the values held in Array() are out of order. ã'Then, step through the file records: ã ãFOR Y = 1 TO 3000                ' 3000 records, already DIM'd ã   GET #x, RecordNumber(Array(y))' the _value_ of Array(x) points to theãNEXT Y                           ' record you're going to read. ãJim Broadbent                  TEXT INSIDE A BOX              FidoNet QUIK_BAS Echo          11-25-95 (23:36)       QB, QBasic, PDS        118  3690     BOXTEXT.BAS ' > I am in need of some help. I want to open a textã' > file & place the text from that file with a drawnã' > box. The box's size should be determined by theã' > amount of text from the imported file.ãã ã'Well one way to do it is to use TEXT graphics.ã ã'There are several considerations to take into account.ã'These include:ã ã'1.  The maximum number of lines (rows) of text to beã'    printed within the box is 21 since we require oneã'    row for the top and bottom of the box PLUS a blankã'    line at the top and bottom to look nice.ã ã'2.  Similarly the maximum width of a character lineã'    is 76 characters (columns)(eliminating 2 for theã'    sides of the box and 2 more for blank spaces atã'    either side.ã ã'3.  We shall assume the TEXT file is a sequential file.ã'    and we have an 80 column screen.ã ã ã'   ***** STEP # 1......develope a BOX Subroutine *****ã ã        DECLARE SUB BOX (H!, W!, R!, C!)ã ã'       This statement is at start of the main programã ã'       H is the height of the box in rowsã'       W is the width of the box in columnsã'       R is the row of the upper LHS of the boxã'       C is the column of the upper LHS of the boxã ã ã'   ***** STEP #2  -  Input the text file, count number ofã'                     lines and determine the maximum widthã'                     the lines.ã ã        SCREEN 0: WIDTH 80ã        DIM TEXT$(25)            ' ARBITARY 25 LINES OF TEXTã      ãSTART:ã        CLSã        LINEMAX = 0: COLUMNMAX = 0ã        LOCATE 9, 19ã        PRINT "Enter the filename of the text to be boxed"ã        LOCATE 11, 35ã        LINE INPUT A$             ' you should makeã                                  ' this bulletproofã        ã        OPEN A$ FOR INPUT AS #1   ' DITTO for this as wellã ã        DO WHILE NOT EOF(1)ã           INPUT #1, B$ã           LINEMAX = LINEMAX + 1ã           IF LINEMAX > 21 THEN     ' Too many linesã              LINEMAX = LINEMAX - 1ã              EXIT DOã           END IFã           CMAX = LEN(B$)            ' You should check to seeã                                     ' if it is over 76 charsã ã           IF CMAX > COLUMNMAX THEN COLUMNMAX = CMAXã           TEXT$(LINEMAX) = B$ã        LOOPã        CLOSE #1ã ã'   ******* STEP #3 - Calculate the H, W, R, C values ******ã ã'       Hopefully this will centre the box in the screenã ã        H = LINEMAX + 4          ' We add 4 to take in the linesã                                 ' and spaces of the boxã ã        W = COLUMNMAX + 4        ' Add 4 for the 4 extra box charsã ã        R = INT((25 - H) / 2)ã        C = INT((80 - W) / 2)ã ã        CLSã        CALL BOX(H, W, R, C)     ' Draw the boxã ã        FOR I = 1 TO LINEMAXã           LOCATE R + I + 1, C + 2   ' Print text to boxã           PRINT TEXT$(I);ã        NEXT Iã ã        LOCATE 25, 1: PRINT "Do it again <Y/N>? ";ã        DO                           ' Do it again?ã           A$ = INKEY$ã           IF A$ = "Y" OR A$ = "y" THEN EXIT DOã           IF A$ = "N" OR A$ = "n" THEN ENDã        LOOPã        GOTO STARTã ã'You should improve it by making the stages bulletproofã'and able to handle file with over 21 lines.ããSUB BOX (H, W, R, C)ã ã'       MAKE A BOX SUBROUTINE (TEXT FORMAT)ã'       H = HEIGHT; W = WIDTH; R = UPPER ROW; C = LHS COLUMNã ã        LOCATE R, Cã        PRINT CHR$(201); STRING$(W - 2, 205); CHR$(187)ã        FOR L = 1 TO H - 1ã        T = L + Rã        LOCATE T, C: PRINT CHR$(186)ã        LOCATE T, C + W - 1: PRINT CHR$(186)ã        NEXT Lã        LOCATE R + H, Cã        PRINT CHR$(200); STRING$(W - 2, 205); CHR$(188);ã ãEND SUBããChristopher Pinder             MASKED INPUT ROUTINES          comp.lang.basic.misc           12-01-95 (23:15)       QB, QBasic, PB, PDS    172  4131     MASKEDIT.BASREM BIT OF CODE BY C.PINDER - Donated to the PUBLIC DOMAINãREM DISCLAIMER - If it doesn't work - I didn't say it wouldãREM Tested with PowerBasic and QBasicãããREM run this first to get the feel of it, thenãREM port the two functions into your own code (if you want to )ããDECLARE FUNCTION getasc%()ãDECLARE FUNCTION getusing%(answer$, row%, col%, picture$)ããREM templated input functionsãREM getusing% returns an integer corresponding to how the input wasãREM terminated, 13 = RET ,27 = ESC, 328 = UP ARROW, 336 = DOWN ARROWããREM the rule for creating a MASK.ãREM Where there's a '~' you can input a character, otherwise you can'tãREM This works for embedded spaces too - see examplesãREM If you need to use the tilde character you'll have to substitueãREM a character of your choice > 127 or so as the MASK CHARãREM If you've got the patience, you might want to tidy up the deleteãREM for 'ordinary' input you can use all ~'s i.e. "~~~~~~~~~~", 10 charsãREM this code does no TYPE CHECKING, any old char will doãREM if you need type checking, YOU write itããREM Lets test the blighter !!!!!!!!!!!!!!!!ããCLSããv = getusing(x$, 1, 1, "~~-~~~-~~~~")ã	LOCATE 1, 40: PRINT "x$ = "; x$ãã    REM now that x$ is valid, lets make sure a subsequent call won'tã    REM bugger it up, we'll edit it a second time !ããv = getusing(x$, 2, 1, "~~-~~~-~~~~")ã	LOCATE 2, 40: PRINT "x$ = "; x$ãããx$ = ""ããv = getusing(x$, 3, 1, "~~/~~/~~~~")ã	LOCATE 3, 40: PRINT "x$ = "; x$ããx$ = ""ããv = getusing(x$, 4, 1, "~~~.~~")ã	LOCATE 4, 40: PRINT "x$ = "; x$ããx$ = ""ããv = getusing(x$, 5, 1, "$~~.~~ - ~~%")ã	LOCATE 5, 40: PRINT "x$ = "; x$ããx$ = ""ããv = getusing(x$, 6, 1, "Name:~~~~~~~~~~~~~~~~~~~~")ã	LOCATE 6, 40: PRINT "x$ = "; x$ããx$ = ""ããv = getusing(x$, 7, 1, "A(~~),B(~~),[~~.~~]")ã	LOCATE 7, 40: PRINT "x$ = "; x$ãããENDããããFUNCTION getasc%ã	x$ = ""ã    WHILE (LEN(x$) = 0)ã		x$ = INKEY$ã		WENDã    m% = (LEN(x$) - 1) * 256ã    getasc% = ASC(RIGHT$(x$, 1)) + (1 * m%)ãEND FUNCTIONããFUNCTION getusing% (answer$, row%, col%, picture$)ã	imask$ = ""ã    FOR i% = 1 TO LEN(picture$)ã	temp$ = MID$(picture$, i%, 1)ã	IF temp$ = "~" THENã		imask$ = imask$ + " "ã	ELSEã		imask$ = imask$ + temp$ã	END IFã    NEXT i%ãã	la% = LEN(answer$)ã    lp% = LEN(picture$)ã    IF la% < lp% THENã	answer$ = answer$ + RIGHT$(imask$, lp% - la%)ã    ELSEã	IF la% > lp% THENã		answer$ = LEFT$(answer$, lp%)ã	END IFã    END IFãã    FOR i% = 1 TO LEN(picture$)ã	temp$ = MID$(picture$, i%, 1)ã	IF temp$ <> "~" THENã		MID$(answer$, i%, 1) = temp$ã	END IFã	NEXT i%ã	done% = 0:ãã    spos% = 1ã	WHILE spos% < LEN(answer$) AND MID$(picture$, spos%, 1) <> "~"ã	spos% = spos% + 1ã	WENDãã	DO WHILE NOT doneãã	REM rather inelegant 'catch boundary conditions'ã	IF RIGHT$(picture$, 1) <> "~" AND spos% = LEN(answer$) THENã		WHILE spos% > 1 AND MID$(picture$, spos%, 1) <> "~"ã			spos% = spos% - 1ã        WENDã    END IFã	IF LEFT$(picture$, 1) <> "~" AND spos% = 1 THENã	WHILE spos% < len(answer$) AND MID$(picture$, spos%, 1) <> "~"ã		spos% = spos% + 1ã    WENDã    END IFãã	LOCATE row%, col%, 1ã	PRINT answer$;ã	LOCATE row%, col% + spos% - 1, 1ã	x% = getasc%ãã	IF x% = 13 OR x% = 27 OR x% = 328 OR x% = 336 THENã		getusing% = x%: EXIT FUNCTIONã	    END IFãã	IF x% > 31 AND x% < 128 THENã		MID$(answer$, spos%, 1) = CHR$(x%)ã	    IF spos% < LEN(answer$) THENã		spos% = spos% + 1ã		WHILE spos% < LEN(answer$) AND MID$(picture$, spos%, 1) <> "~"ã			spos% = spos% + 1ã			WENDã		END IFã		END IFãã		IF x% = 331 AND spos% > 1 THENã		spos% = spos% - 1ã			WHILE spos% > 1 AND MID$(picture$, spos%, 1) <> "~"ã		spos% = spos% - 1ã		WENDã		END IFããã    IF x% = 8 THENã	MID$(answer$, spos%, 1) = " "ã	IF spos% > 1 THENã		spos% = spos% - 1ã        WHILE spos% > 1 AND MID$(picture$, spos%, 1) <> "~"ã		spos% = spos% - 1ã		WENDã		END IFã	END IFãã		IF x% = 333 AND spos% < LEN(answer$) THENã		spos% = spos% + 1ã			WHILE spos% < LEN(answer$) AND MID$(picture$, spos%, 1) <> "~"ã		spos% = spos% + 1ã		WENDã		END IFã	LOOPãEND FUNCTIONããKurt Kuzba                     K.I.S.S. EDITOR                FidoNet QUIK_BAS Echo          12-02-95 (00:00)       QB, QBasic, PDS        967  24018    KISSED.BAS  '_|_|_|   KISSED.BASã'_|_|_|   Keep It Simple, Stupid EDitor  [ Qbasic / QuickBasic ]ã'_|_|_|   Released to the   PUBLIC DOMAIN   by Kurt Kuzba  (12/02/95)ã  CLEAR ' $DYNAMICã  TYPE TXTã    L AS STRING * 80ã  END TYPEã  TYPE PARMSã    INS AS INTEGERã    TOP AS INTEGERã    LIN AS INTEGERã    CRS AS INTEGERã    TOT AS INTEGERã    MLA AS INTEGERã    MCA AS INTEGERã    MLZ AS INTEGERã    MCZ AS INTEGERã    WID AS INTEGERã  END TYPEã  DIM SHARED D0(800) AS TXTã  DIM SHARED D1(800) AS TXTã  DIM SHARED D2(800) AS TXTã  DIM SHARED CFG(3) AS PARMSã  DIM SHARED DOC$(6)ã  DOC$(1) = COMMAND$ã  DOC$(2) = ""ã  DOCINIT 0ã  DOCINIT 1ã  DOCINIT 2ã  DOC$(4) = ""ã  DOC$(5) = "INS"ã  IF DOC$(1) <> "" THENã    DOCOPN DOC$(1), 1ã  ELSEã    DOC$(1) = "text1.txt"ã  END IFã  ED% = 1ã  WHILE ED% <> 0ã    ED% = EDDOC%(ED%)ã  WENDãã  COLOR 2, 0ã  CLSã  SYSTEMãWHATTHE:ã  DOC$(3) = STR$(ERR)ãRESUME NEXTããREM $STATICã'ãSUB ALARMã  FOR T% = 0 TO 25ã    SOUND 2200 + 2 * T%, .1ã    SOUND 2225 + T%, .05ã  NEXTãEND SUBããSUB CHECKMARK (D%, SH%)ã  IF SH% THENã    IF CFG(D%).MCA = 0 THENã      CFG(D%).MLA = CFG(D%).LINã      CFG(D%).MLZ = CFG(D%).LINã      CFG(D%).MCA = CFG(D%).CRSã      CFG(D%).MCZ = CFG(D%).CRSã    END IFã   ELSEã    CFG(D%).MCA = 0ã  END IFãEND SUBããSUB CLIPBOARDã  CFG(0).LIN = 0ã  CFG(0).CRS = 1ã  K% = 0ã  DOC$(0) = "CLIPBOARD    [ESC] TO EXIT"ã  WHILE K% <> 27ã    L% = CFG(0).LINã    CFG(0).MCA = 1ã    CFG(0).MCZ = 80ã    CFG(0).MLA = L%ã    CFG(0).MLZ = L%ã    SHOWDOC 0ã    INFOBAR 0ã    K% = GETKEY%ã    SELECT CASE K%ã       CASE -71                                                   '__HOME*ã      CFG(0).LIN = 0ã      CFG(0).TOP = 0ã       CASE -79                                                    '__END*ã      L% = CFG(0).TOT - 23ã      IF L% < 0 THEN L% = 0ã      CFG(0).TOP = L%ã      CFG(0).LIN = CFG(0).TOT - 1ãCASE -73:ã      IF L% <> 0 THENã        C% = L% - 24ã        CFG(0).LIN = -C% * (C% >= 0)ã        C% = CFG(0).TOP - 24ã        CFG(0).TOP = -C% * (C% >= 0)ã      END IFã       CASE -81                                              '__PAGE DOWN*ã      T% = CFG(D%).TOT - 1ã      P% = T% - 23ã      L% = L% + 24ã      IF L% <= (T% + 23) THENã        IF L% > T% THEN L% = T%ã        CFG(0).LIN = L%ã        L% = CFG(0).TOP + 24ã        IF L% > P% THEN L% = P%ã        CFG(0).TOP = -L% * (L% >= 0)ã      END IFã       CASE -72                                                '__CRSR UP*ã      L% = L% - 1ã      IF L% >= 0 THENã        CFG(0).LIN = L%ã        IF CFG(0).TOP > L% THEN CFG(0).TOP = L%ã      END IFã       CASE -80                                            '__CURSOR DOWN*ã      L% = L% + 1ã      IF L% < CFG(0).TOT THENã        CFG(0).LIN = L%ã        T% = CFG(0).TOPã        IF L% > (T% + 23) THEN CFG(0).TOP = T% + 1ã      END IFã    END SELECTã  WENDãEND SUBããSUB CUTTEXT (D%)ã  IF CFG(D%).MCA = 0 THENã    T% = MSG%("No Text Marked", "")ã    EXIT SUBã  END IFã  ORDERMARK D%, LA%, LZ%, CA%, CZ%ã  DOCINIT 0ã  R% = CFG(D%).LINã  I% = LZ% - LA%ã  CFG(0).TOT = I% + 1ã  FOR L% = 0 TO I%ã    CFG(0).LIN = L%ã    CFG(D%).LIN = LA% + L%ã    T$ = GETLINE$(D%)ã    IF L% = I% THEN T$ = LEFT$(T$, CZ%)ã    IF L% = 0 THEN T$ = MID$(T$, CA%)ã    D0(L%).L = T$ã  NEXTã  CFG(D%).LIN = R%ã  NOISEãEND SUBããSUB DELETETEXT (D%)ã  IF CFG(D%).MCA = 0 THENã    T% = MSG%("No Text Marked", "")ã    EXIT SUBã  END IFã  ORDERMARK D%, LA%, LZ%, CA%, CZ%ã  L% = LZ% - LA%ã  R% = LA%ã  CFG(D%).CRS = CA%ã  CFG(D%).MCA = 0ã  CFG(D%).LIN = LA%ã  T$ = MID$(LEFT$(" " + GETLINE$(D%), CA%), 2)ã  CFG(D%).LIN = LZ%ã  P$ = RTRIM$(MID$(GETLINE$(D%), CZ% + 1))ã  B$ = T$ + P$ã  IF LA% = LZ% THENã    IF B$ = "" THENã      B$ = DELLINE$(D%)ã    ELSEã      PUTLINE D%, B$ã    END IFã  END IFã  IF LZ% > LA% THENã    IF P$ = "" THENã      LZ% = LZ% + 1ã     ELSEã      PUTLINE D%, P$ã    END IFã    IF T$ <> "" THENã      CFG(D%).LIN = LA%ã      LA% = LA% + 1ã      PUTLINE D%, T$ã    END IFã  END IFã  IF LA% < LZ% THENã    L% = LZ% - LA%ã    Z% = CFG(D%).TOT - L%ã    CFG(D%).TOT = Z%ã    FOR T% = LA% TO Z%ã      IF D% = 1 THEN D1(T%).L = D1(T% + L%).Lã      IF D% = 2 THEN D2(T%).L = D2(T% + L%).Lã    NEXTã    FOR T% = Z% TO 799ã      IF D% = 1 THEN D1(T%).L = ""ã      IF D% = 2 THEN D2(T%).L = ""ã    NEXTã  END IFã  CFG(D%).LIN = R%ã  R% = R% - 1ã  IF CFG(D%).TOT < 0 THEN CFG(D%).TOT = 1ã  IF R% + 25 > CFG(D%).TOT THEN R% = CFG(D%).TOT - 24ã  CFG(D%).TOP = R% * -(R% >= 0)ã  NOISEãEND SUBããFUNCTION DELLINE$ (D%)ã  L% = CFG(D%).LINã  E% = CFG(D%).TOT - 1ã  IF D% = 1 THENã    DELLINE$ = RTRIM$(D1(CFG(1).LIN).L)ã    FOR T% = L% TO E% - 1ã      D1(T%).L = D1(T% + 1).Lã    NEXTã    D1(E%).L = SPACE$(80)ã  END IFã  IF D% = 2 THENã    DELLINE$ = RTRIM$(D2(CFG(2).LIN).L)ã    FOR T% = L% TO E% - 1ã      D2(T%).L = D2(T% + 1).Lã    NEXTã    D2(E%).L = SPACE$(80)ã  END IFã  CFG(D%).TOT = E% - (E% = L%)ã  SHOWDOC D%ãEND FUNCTIONããSUB DOCINIT (D%)ã  FOR T% = 0 TO 799ã    IF D% = 0 THEN D0(T%).L = ""ã    IF D% = 1 THEN D1(T%).L = ""ã    IF D% = 2 THEN D2(T%).L = ""ã  NEXTã  PARMSINIT D%ãEND SUBããSUB DOCOPN (F$, D%)ã  ON ERROR GOTO WHATTHEã  T% = 1ã  DOC$(3) = "ok"ã  IF F$ <> "" THEN OPEN F$ FOR INPUT AS #1ã  T$ = "File Error :: " + F$ + " :: Hit a Key"ã  IF DOC$(3) <> "ok" THENã    T% = MSG%(T$, "")ã    EXIT SUBã  END IFã  WHILE T% = 1ã    L% = 0ã    DOCINIT D%ã    WHILE ((L% < 800) AND (NOT EOF(1)))ã      LINE INPUT #1, P$ã      P$ = RTRIM$(P$)ã      CFG(D%).LIN = L%ã      WHILE INSTR(P$, CHR$(9)) <> 0ã        P% = INSTR(P$, CHR$(9))ã        T$ = MID$(P$, P% + 1)ã        T$ = "   " + T$ã        IF P% > 1 THEN T$ = LEFT$(P$, P% - 1) + T$ã        P$ = T$ã      WENDã      IF LEN(P$) > 79 THENã        IF L% < 799 THENã          PUTLINE D%, LEFT$(P$, 79)ã          P$ = MID$(P$, 80)ã          L% = L% + 1ã          CFG(D%).LIN = L%ã        END IFã        P$ = LEFT$(P$, 79)ã      END IFã      PUTLINE D%, P$ã      L% = L% + 1ã    WENDã    T$ = "File too large. Load next section (Y/N)?"ã    IF (NOT EOF(1)) THENã      T% = MSG%(T$, "yn")ã     ELSEã      T% = 0ã    END IFã  WENDã  CLOSE 1ã  CFG(D%).TOT = L%ã  CFG(D%).LIN = 0ã  ALARMã  DOC$(D%) = UCASE$(F$)ãEND SUBããFUNCTION EDDOC% (D%)ã  DEF SEG = 0ã  EDDOC% = D%ã  IF D% = 0 THEN GOTO CYCLEã  SHOWDOC D%ã  EDIT$ = "YES"ã  S$ = SPACE$(80)ã  WHILE EDIT$ = "YES"ã    T$ = GETLINE$(D%) + S$ã    L% = CFG(D%).LINã    C% = CFG(D%).CRSã    SHOWDOC D%ã    INFOBAR D%ã    LOCATE L% - CFG(D%).TOP + 2, C%, 1, 13 * CFG(D%).INS, 13ã    K% = GETKEY%ã    SH% = ((PEEK(&H417) AND 3) <> 0)ã    W% = CFG(D%).WIDã    IF K% = 9 THENã      T$ = LEFT$(T$, C% - 1) + SPACE$(9) + MID$(T$, C%)ã      K% = 32ã      C% = C% + 9ã    END IFã    SELECT CASE K%ã     CASE 32 TO 254                                               '__TEXT*ã      IF CFG(D%).INS <> 0 THEN MID$(T$, C% + 1) = MID$(T$, C%)ã      MID$(T$, C%) = CHR$(K%)ã      T$ = RTRIM$(T$)ã      IF (LEN(T$) > W%) THENã        P$ = MID$(T$, W% + 1)ã        T$ = LEFT$(T$, W%)ã        T% = 0ã        WHILE T% = 0ã          R$ = RIGHT$(T$, 1)ã          L% = LEN(T$)ã          T% = INSTR("*+\]}:)/- ", R$) - (L% < (W% * .75))ã          IF T% = 0 THENã            P$ = R$ + P$ã            T$ = LEFT$(T$, L% - 1)ã          END IFã        WENDã        PUTLINE D%, T$ã        L% = CFG(D%).LINã        T% = LEN(T$)ã        IF L% < 799 THENã          CFG(D%).LIN = L% + 1ã          INSLINE D%, P$ã        END IFã        IF C% > W% AND L% < 799 THENã          C% = C% - T%ã          L% = L% + 1ã        END IFã        CFG(D%).LIN = L%ã        IF C% > W% AND L% > 788 THEN C% = T%ã       ELSEã        PUTLINE D%, T$ã      END IFã      CFG(D%).CRS = C% + 1ã     CASE 8                                                  '__BACKSPACE*ã      L% = CFG(D%).LINã      T% = LEN(RTRIM$(T$))ã      IF (C% = 1) AND (L% = 0) THEN GOTO CYCLEã      IF C% > 1 THENã        IF T% <> 0 THEN MID$(T$, C% - 1) = MID$(T$, C%) + " "ã        CFG(D%).CRS = C% - 1ã        PUTLINE D%, T$ã       ELSEã        LINECAT D%, L% - 1ã      END IFã       CASE -83                                                 '__DELETE*ã      T% = LEN(RTRIM$(T$))ã      IF C% <= T% THENã        MID$(T$, C%) = MID$(T$, C% + 1) + " "ã        PUTLINE D%, T$ã       ELSEã        LINECAT D%, CFG(D%).LINã      END IFã       CASE -82                                                 '__INSERT*ã      T$ = DOC$(6)ã      IF SH% THENã        IF T$ <> "" THENã          INSLINE D%, T$ã          CFG(D%).CRS = 1ã        END IFã       ELSEã        CFG(D%).INS = ABS(CFG(D%).INS - 1)ã        NOISEã      END IFã     CASE 13                                                     '__ENTER*ã      L% = CFG(D%).LINã      IF L% >= 799 THEN GOTO CYCLEã      IF C% = 1 THENã        P$ = ""ã       ELSEã        P$ = LEFT$(T$, C% - 1)ã      END IFã      PUTLINE D%, P$ã      CFG(D%).LIN = L% + 1ã      INSLINE D%, MID$(T$, C%)ã      CFG(D%).CRS = 1ã       CASE -61, -38                                       '__ALT/L or F3*ã      SAVEQRY D%ã      LOADDOC D%ã      GOTO CYCLEã       CASE -60, -31                                       '__ALT/S or F2*ã      SAVEDOC D%ã     CASE 27, -45                       '__ESCAPE or CTRL/X : exit editor*ã      EDIT$ = "NO"ã       CASE -94                         '__CTRL/F1 : switch to Document 1*ã      IF DOC$(1) = "" THEN DOC$(1) = "text1.txt"ã      EDDOC% = 1ã      GOTO CYCLEã       CASE -95                         '__CTRL/F2 : switch to Document 2*ã      IF DOC$(2) = "" THEN DOC$(2) = "text2.txt"ã      EDDOC% = 2ã      GOTO CYCLEã       CASE -96                                                '__CTRL/F3*ã      CLIPBOARDã     CASE 25                                                    '__CTRL/Y*ã      DOC$(6) = DELLINE$(D%)ã      CFG(D%).CRS = 1ã       CASE -71                                                   '__HOME*ã      CHECKMARK D%, SH%ã      CFG(D%).CRS = 1ã      SETMARK D%, SH%ã       CASE -79                                                    '__END*ã      CHECKMARK D%, SH%ã      C% = LEN(RTRIM$(T$)) + 1ã      CFG(D%).CRS = -C% * (C% < 81) - 80 * (C% > 80)ã      SETMARK D%, SH%ã       CASE -119                                             '__CTRL/HOME*ã      CHECKMARK D%, SH%ã      CFG(D%).CRS = 1ã      CFG(D%).LIN = CFG(D%).TOPã      SETMARK D%, SH%ã       CASE -117                                              '__CTRL/END*ã      CHECKMARK D%, SH%ã      C% = CFG(D%).TOP + 23ã      T% = CFG(D%).TOT - 1ã      IF C% >= T% THEN C% = T%ã      CFG(D%).LIN = C%ã      T$ = RTRIM$(GETLINE$(D%))ã      T% = LEN(T$)ã      CFG(D%).CRS = T% - (T% < 80)ã      SETMARK D%, SH%ã       CASE -132                                          '__CTRL/PAGE UP*ã      CHECKMARK D%, SH%ã      CFG(D%).TOP = 0ã      CFG(D%).LIN = 0ã      CFG(D%).CRS = 1ã      SETMARK D%, SH%ã       CASE -118                                        '__CTRL/PAGE DOWN*ã      CHECKMARK D%, SH%ã      C% = CFG(D%).TOTã      CFG(D%).TOP = -(C% - 24) * (C% > 23)ã      CFG(D%).LIN = C% - 1ã      CFG(D%).CRS = 1ã      SETMARK D%, SH%ã       CASE -73                                                '__PAGE UP*ã      CHECKMARK D%, SH%ã      IF L% = 0 THEN GOTO CYCLEã      C% = L% - 24ã      CFG(D%).LIN = -C% * (C% >= 0)ã      C% = CFG(D%).TOP - 24ã      CFG(D%).TOP = -C% * (C% >= 0)ã      SETMARK D%, SH%ã       CASE -81                                              '__PAGE DOWN*ã      CHECKMARK D%, SH%ã      T% = CFG(D%).TOT - 1ã      P% = T% - 23ã      L% = CFG(D%).LIN + 24ã      IF L% > (T% + 23) THEN GOTO CYCLEã      IF L% > T% THEN L% = T%ã      CFG(D%).LIN = L%ã      L% = CFG(D%).TOP + 24ã      IF L% > P% THEN L% = P%ã      CFG(D%).TOP = -L% * (L% >= 0)ã      SETMARK D%, SH%ã       CASE -72                                                '__CRSR UP*ã      CHECKMARK D%, SH%ã      L% = L% - 1ã      IF L% < 0 THEN GOTO CYCLEã      CFG(D%).LIN = L%ã      IF CFG(D%).TOP > L% THEN CFG(D%).TOP = L%ã      SETMARK D%, SH%ã       CASE -80                                            '__CURSOR DOWN*ã      CHECKMARK D%, SH%ã      L% = L% + 1ã      IF L% >= CFG(D%).TOT THEN GOTO CYCLEã      CFG(D%).LIN = L%ã      T% = CFG(D%).TOPã      IF L% > (T% + 23) THEN CFG(D%).TOP = T% + 1ã      SETMARK D%, SH%ã       CASE -75                                            '__CURSOR LEFT*ã      CHECKMARK D%, SH%ã      IF C% = 1 THEN GOTO CYCLEã      CFG(D%).CRS = C% - 1ã      SETMARK D%, SH%ã       CASE -77                                           '__CURSOR RIGHT*ã      CHECKMARK D%, SH%ã      IF C% > 79 THEN GOTO CYCLEã      CFG(D%).CRS = C% + 1ã      SETMARK D%, SH%ã       CASE -46                                      '__ALT/C :: CUT TEXT*ã      CUTTEXT D%ã       CASE -32                                   '__ALT/D :: DELETE TEXT*ã      DELETETEXT D%ã       CASE -25                                    '__ALT/P :: PASTE TEXT*ã      PASTETEXT D%ã       CASE -59, -35                               '__ALT/H OR F1 :: HELP*ã      HELPã       CASE -115                                             '__CTRL/LEFT*ã      CFG(D%).WID = W% + (W% > 10)ã       CASE -116                                            '__CTRL/RIGHT*ã      CFG(D%).WID = W% - (W% < 79)ã    END SELECTã  WENDã  T$ = CHR$(13) + "yn " + CHR$(27)ã  SAVEQRY D%ã  EDDOC% = -D% * (MSG("Exit KISSED (Y/N)?", T$) > 2)ãCYCLE:ã  NOISEã  DEF SEGãEND FUNCTIONããFUNCTION GETKEY%ã  T$ = ""ã  WHILE T$ = ""ã    T$ = INKEY$ã  WENDã  GETKEY% = ASC(T$)ã  IF ASC(T$) = 0 THEN GETKEY% = -ASC(MID$(T$, 2))ãEND FUNCTIONããFUNCTION GETLINE$ (D%)ã  GETLINE$ = ""ã  IF D% = 1 THEN GETLINE$ = D1(CFG(1).LIN).Lã  IF D% = 2 THEN GETLINE$ = D2(CFG(2).LIN).LãEND FUNCTIONããFUNCTION GETSTR$ (P$, D$, M%)ã  PCOPY 0, 1ã  SCREEN , , 1, 1ã  L% = 7 + LEN(P$) + M%ã  INS% = 1ã  Y% = 40 - L% \ 2ã  X% = 11ã  COLOR 9, 1ã  LOCATE X%, Y%ã  FOR T% = 1 TO 3ã    LOCATE , Y%ã    PRINT STRING$(L%, CHR$(176))ã  NEXTã  LOCATE X% + 1, Y% + 2ã  COLOR 15, 4ã  PRINT " "; P$; " ";ã  X% = CSRLINã  Y% = POS(0)ã  PRINT SPACE$(M% + 1);ã  D$ = LEFT$(D$ + SPACE$(M%), M%)ã  B$ = CHR$(29)ã  P% = (LEN(RTRIM$(D$)) MOD M%) + 1ã  WHILE T% <> 13ã    LOCATE , Y%, 0ã    COLOR 14, 4ã    PRINT D$;ã    COLOR 1, 7ã    LOCATE , Y% + P% - 1, INS%, 13, 13ã    PRINT MID$(D$, P%, 1); B$;ã    T% = GETKEY%ã    SELECT CASE T%ã     CASE 32 TO 127ã      IF INS% <> 0 THEN D$ = LEFT$(LEFT$(D$, P%) + MID$(D$, P%), M%)ã      MID$(D$, P%) = CHR$(T%)ã      IF P% < M% THEN P% = (P% MOD M%) + 1ã     CASE 8ã      IF P% > 1 THEN MID$(D$, P% - 1) = MID$(D$, P%) + " "ã      P% = P% + (P% > 1)ã      IF P% = 1 THEN SOUND 1000, .1ã     CASE 27ã      D$ = ""ã      T% = 13ã       CASE -82ã      INS% = ABS(INS% - 1)ã       CASE -83ã      MID$(D$, P%) = MID$(D$, P% + 1) + " "ã       CASE -75ã      P% = ((P% - 2 + M%) MOD M%) + 1ã       CASE -77ã      P% = (P% MOD M%) + 1ã     CASE 25ã      D$ = SPACE$(M%)ã      P% = 1ã       CASE -71ã      P% = 1ã       CASE -79ã      P% = LEN(RTRIM$(D$))ã      P% = P% - (P% <> M%)ã    END SELECTã  WENDã  SCREEN , , 0, 0ã  GETSTR$ = RTRIM$(D$)ãEND FUNCTIONããSUB HELPã  SCREEN , , 1, 1ã  COLOR 11, 1ã  CLSã  T$ = STRING$(80, CHR$(177))ã  FOR T% = 1 TO 25ã    LOCATE T%, 1ã    PRINT T$;ã  NEXTã  COLOR 14, 0ã  LOCATE 3, 7, 0ã  PRINT "____NORMAL KEYS_______________"ã  LOCATE , 7ã  PRINT " Left Arrow     (Cursor Left) "ã  LOCATE , 7ã  PRINT " Right Arrow   (Cursor Right) "ã  LOCATE , 7ã  PRINT " Up Arrow         (Cursor Up) "ã  LOCATE , 7ã  PRINT " Down Arrow     (Cursor Down) "ã  LOCATE , 7ã  PRINT " Page Up     (Cursor Page UP) "ã  LOCATE , 7ã  PRINT " Page Down (Cursor Page Down) "ã  LOCATE , 7ã  PRINT " Home           (Cursor Home) "ã  LOCATE , 7ã  PRINT " End             (Cursor End) "ã  LOCATE , 7ã  PRINT " Insert       (Toggle Insert) "ã  LOCATE , 7ã  PRINT " Delete              (Delete) "ã  LOCATE , 7ã  PRINT " F1                    (Help) "ã  LOCATE , 7ã  PRINT " F2               (Load Text) "ã  LOCATE , 7ã  PRINT " F3               (Save Text) "ã  LOCATE , 7ã  PRINT " ESCAPE        (EXIT  EDITOR) "ã  LOCATE 19, 7ã  PRINT "____SHIFT KEYS________________"ã  LOCATE , 7ã  PRINT " Insert  (Insert CTRL/Y Line) "ã  LOCATE , 7ã  PRINT "    Any Cursor movement key   "ã  LOCATE , 7ã  PRINT "   with SHIFT will mark text. "ã  LOCATE 3, 45ã  PRINT "____CONTROL KEYS______________"ã  LOCATE , 45ã  PRINT " F1              (Document 1) "ã  LOCATE , 45ã  PRINT " F2              (Document 2) "ã  LOCATE , 45ã  PRINT " F3          (View Clipboard) "ã  LOCATE , 45ã  PRINT " Home              (Page Top) "ã  LOCATE , 45ã  PRINT " End            (Page Bottom) "ã  LOCATE , 45ã  PRINT " Page Up           (Text top) "ã  LOCATE , 45ã  PRINT " Page Down      (Text Bottom) "ã  LOCATE , 45ã  PRINT " Left Arrow    (-line length) "ã  LOCATE , 45ã  PRINT " Right Arrow   (+line length) "ã  LOCATE , 45ã  PRINT " CTRL/Y         (Delete Line) "ã  LOCATE 17, 45ã  PRINT "____ALT KEYS__________________"ã  LOCATE , 45ã  PRINT " ALT/H                 (Help) "ã  LOCATE , 45ã  PRINT " ALT/C    (Copy To Clipboard) "ã  LOCATE , 45ã  PRINT " ALT/D   (Delete Marked Text) "ã  LOCATE , 45ã  PRINT " ALT/P      (Paste ClipBoard) "ã  LOCATE , 45ã  PRINT " ALT/X                 (EXIT) "ã  T% = GETKEY%ã  SCREEN , , 0, 0ãEND SUBããSUB INFOBAR (D%)ã  P$ = SPACE$(80)ã  MID$(P$, 7) = "l" + MID$(STR$(CFG(D%).LIN + 1), 2)ã  MID$(P$, 27) = STR$(CFG(D%).TOT) + " lines"ã  MID$(P$, 40) = DOC$(D%)ã  MID$(P$, 24) = CHR$(64 + D%)ã  MID$(P$, 18) = DOC$(CFG(D%).INS + 4)ã  MID$(P$, 13) = "w" + MID$(STR$(CFG(D%).WID), 2)ã  LOCATE 1, 1ã  MID$(P$, 2) = "c" + MID$(STR$(CFG(D%).CRS), 2)ã  COLOR 15, 1ã  PRINT P$;ãEND SUBããSUB INSLINE (D%, S$)ã  L% = CFG(D%).LINã  IF D% = 1 THENã    FOR T% = 799 TO L% + 1 STEP -1ã      D1(T%).L = D1(T% - 1).Lã    NEXTã    D1(CFG(1).LIN).L = S$ã  END IFã  IF D% = 2 THENã    FOR T% = 799 TO L% + 1 STEP -1ã      D2(T%).L = D2(T% - 1).Lã    NEXTã    D2(CFG(2).LIN).L = S$ã  END IFã  IF CFG(D%).TOT < 800 THEN CFG(D%).TOT = CFG(D%).TOT + 1ã  SHOWDOC D%ãEND SUBããSUB LINECAT (D%, L%)ã  R% = CFG(D%).LINã  CFG(D%).LIN = L% + 1ã  P$ = RTRIM$(GETLINE$(D%))ã  C% = CFG(D%).CRSã  CFG(D%).LIN = L%ã  T$ = GETLINE$(D%)ã  IF R% = L% THEN T$ = LEFT$(T$, C% - 1)ã  IF R% <> L% THENã    T$ = RTRIM$(T$)ã    CFG(D%).CRS = LEN(T$) + 1ã  END IFã  T$ = T$ + P$ã  T% = LEN(T$)ã  IF T% < 80 THEN P$ = DELLINE$(D%)ã  IF LEN(T$) > 79 THENã    CFG(D%).LIN = L% + 1ã    PUTLINE D%, MID$(T$, 80)ã  END IFã  CFG(D%).LIN = L%ã  PUTLINE D%, LEFT$(T$, 79)ã  SHOWDOC D%ãEND SUBããSUB LOADDOC (D%)ã  DN$ = GETSTR$("Load File?", "", 32)ã  IF DN$ <> "" THEN DOCOPN DN$, D%ãEND SUBããFUNCTION MSG% (M$, P$)ã  M% = LEN(M$)ã  P$ = UCASE$(P$)ã  PCOPY 0, 1ã  SCREEN , , 1, 1ã  IF P$ = "" THEN P$ = CHR$(13) + CHR$(27) + " "ã  WHILE INKEY$ <> ""ã  WENDã  C% = 37 - (M% + 1) \ 2ã  LOCATE 10, C%ã  COLOR 9, 1ã  LOCATE 11, C%, 0ã  PRINT STRING$(M% + 6, CHR$(176))ã  LOCATE , C%ã  PRINT CHR$(176); CHR$(176);ã  COLOR 14, 4ã  PRINT " "; M$; " ";ã  COLOR 9, 1ã  PRINT CHR$(176); CHR$(176)ã  LOCATE , C%ã  PRINT STRING$(M% + 6, CHR$(176))ã  ALARMã  T% = 0ã  WHILE INSTR(P$, UCASE$(CHR$(T%))) < 1ã    T% = GETKEY%ã  WENDã  SCREEN , , 0, 0ã  MSG% = INSTR(P$, UCASE$(CHR$(T%)))ãEND FUNCTIONããSUB NOISEã  SOUND 1000, .1ãEND SUBããSUB ORDERMARK (D%, LA%, LZ%, CA%, CZ%)ã  CA% = CFG(D%).MCAã  LA% = CFG(D%).MLAã  CZ% = CFG(D%).MCZã  LZ% = CFG(D%).MLZã  LA& = LA%ã  LZ& = LZ%ã  LA& = LA& * 80 + CA%ã  LZ& = LZ& * 80 + CZ%ã  IF LA& > LZ& THENã    SWAP LA%, LZ%ã    SWAP CA%, CZ%ã  END IFãEND SUBããSUB PARMSINIT (D%)ã  CFG(D%).INS = 1ã  CFG(D%).TOP = 0ã  CFG(D%).LIN = 0ã  CFG(D%).CRS = 1ã  CFG(D%).TOT = 1ã  CFG(D%).MLA = 0ã  CFG(D%).MCA = 0ã  CFG(D%).MLZ = 0ã  CFG(D%).MCZ = 0ã  CFG(D%).WID = 70ãEND SUBããSUB PASTETEXT (D%)ã  IF CFG(0).TOT = 1 AND RTRIM$(D0(0).L) = "" THENã    T% = MSG%("No text in Clipboard", "")ã    EXIT SUBã  END IFã  L% = CFG(D%).LINã  R% = L%ã  C% = CFG(D%).CRSã  CFG(D%).MCA = 0ã  O% = CFG(0).TOTã  I% = O% - 1ã  E% = CFG(D%).TOTã  IF (C% > 1) AND (I% = 0) THENã    T$ = GETLINE$(D%) + SPACE$(80)ã    T$ = RTRIM$(LEFT$(T$, C% - 1) + RTRIM$(D0(0).L) + MID$(T$, C%))ã    PUTLINE D%, LEFT$(T$, 79)ã    IF LEN(T$) > 79 AND L% < 799 THENã      CFG(D%).LIN = L% + 1ã      INSLINE D%, MID$(T$, 80)ã      CFG(D%).LIN = L%ã    END IFã    NOISEã    EXIT SUBã  END IFã  FOR T% = 799 TO L% STEP -1ã    IF T% - 0 >= 0 THENã      IF D% = 1 THEN D1(T%).L = D1(T% - O%).Lã      IF D% = 2 THEN D2(T%).L = D2(T% - O%).Lã    END IFã  NEXTã  FOR T% = 0 TO I%ã    IF D% = 1 THEN D1(T% + L%).L = D0(T%).Lã    IF D% = 2 THEN D2(T% + L%).L = D0(T%).Lã  NEXTã  CFG(D%).TOT = E% + O%ã  IF E% + O% > 800 THEN CFG(D%).TOT = 800ã  NOISEãEND SUBããSUB PUTLINE (D%, T$)ã  IF D% = 1 THEN D1(CFG(D%).LIN).L = LEFT$(T$ + SPACE$(80), 80)ã  IF D% = 2 THEN D2(CFG(D%).LIN).L = LEFT$(T$ + SPACE$(80), 80)ãEND SUBããSUB SAVEDOC (D%)ã  ON ERROR GOTO WHATTHEã  DOC$(3) = "ok"ã  L% = CFG(D%).LINã  CFG(D%).LIN = 0ã  T% = CFG(D%).TOTã  P$ = RTRIM$(GETLINE$(D%))ã  IF P$ = "" AND T% = 1 THENã    T% = MSG%("No Text", "")ã    EXIT SUBã  END IFã  DN$ = DOC$(D%)ã  DN$ = GETSTR$("Save As?", DN$, 32)ã  IF DN$ = "" THENã    CFG(D%).LIN = L%ã    EXIT SUBã  END IFã  DOC$(D%) = DN$ã  OPEN DN$ FOR OUTPUT AS #1ã  IF DOC$(3) <> "ok" THENã    T% = MSG%("File Error :: Hit a Key", "")ã   ELSEã    FOR P% = 0 TO T% - 1ã      CFG(D%).LIN = P%ã      P$ = RTRIM$(GETLINE$(D%))ã      IF P$ = "" THEN P$ = " "ã      PRINT #1, P$ã    NEXTã    CFG(D%).LIN = L%ã    ALARMã    CLOSE 1ã  END IFãEND SUBããSUB SAVEQRY (D%)ã  L% = CFG(D%).LINã  CFG(D%).LIN = 0ã  T% = CFG(D%).TOTã  CFG(D%).LIN = L%ã  P$ = RTRIM$(GETLINE$(D%))ã  IF P$ = "" AND T% = 1 THENã    NOISEã    EXIT SUBã  END IFã  T% = MSG%("Save Current Document (Y:N)?", " ny" + CHR$(13))ã  IF T% > 2 THENã    NOISEã    SAVEDOC D%ã   ELSEã    ALARMã  END IFãEND SUBããSUB SETMARK (D%, SH%)ã  IF SH% = 0 THEN EXIT SUBã  L% = CFG(D%).LINã  C% = CFG(D%).CRSã  L& = L%ã  L& = L& * 80 + C%ã  A% = CFG(D%).MLAã  A& = A%ã  A& = A% * 80 + CFG(D%).MCAã  CFG(D%).MLZ = L%ã  CFG(D%).MCZ = C%ãEND SUBããSUB SHOWDOC (D%)ã  L% = CFG(D%).LINã  T% = CFG(D%).TOPã  COLOR 10, 0ã  LOCATE , , 0ã  IF T% + 23 < L% THENã    T% = L% - 23ã    CFG(D%).TOP = T%ã  END IFã  FOR B% = 0 TO 23ã    L% = B% + T%ã    IF L% > 799 THENã      LOCATE 2 + B%, 1ã      PRINT SPACE$(80);ã     ELSEã      SHOWLINE D%, L%, 2 + B%ã    END IFã  NEXTãEND SUBããSUB SHOWLINE (D%, L%, S%)ã  LA% = 0ã  LZ% = 0ã  CA% = 0ã  CZ% = 0ã  IF CFG(D%).MCA <> 0 THEN ORDERMARK D%, LA%, LZ%, CA%, CZ%ã  IF D% = 0 THEN T$ = D0(L%).L + SPACE$(80)ã  IF D% = 1 THEN T$ = D1(L%).L + SPACE$(80)ã  IF D% = 2 THEN T$ = D2(L%).L + SPACE$(80)ã  LOCATE S%, 1ã  COLOR 10, 0ã  IF CA% = 0 OR (LA% > L%) OR (LZ% < L%) THENã    PRINT LEFT$(T$, 80);ã   ELSEã    IF LA% = LZ% THENã      IF CA% > 1 THEN PRINT LEFT$(T$, CA% - 1);ã      COLOR 0, 3ã      PRINT MID$(T$, CA%, CZ% - CA% + 1);ã      COLOR 10, 0ã      PRINT MID$(T$, CZ% + 1, 80 - CZ%);ã     ELSEã      IF (L% > LA%) AND (L% < LZ%) THENã        COLOR 0, 3ã        PRINT LEFT$(T$, 80);ã       ELSEã        IF L% = LA% THENã          IF CA% > 1 THEN PRINT LEFT$(T$, CA% - 1);ã          COLOR 0, 3ã          PRINT MID$(T$, CA%, 81 - CA%);ã         ELSEã          COLOR 0, 3ã          PRINT LEFT$(T$, CZ%);ã          COLOR 10, 0ã          PRINT MID$(T$, CZ% + 1, 80 - CZ%);ã        END IFã      END IFã    END IFã  END IFãEND SUBããDave Gjessing                  ASCII HELL                     dgjess@freenet.columbus.oh.us  10-22-95 (00:00)       QB, QBasic, VBDOS      42   855      ASKYHELL.BAS'file ASKYHELL.BAS  DG - 10/22/95ã'Qbasic, VBDOSã'have a few too many beers and fart around trying to write somethingã'that you can't remember why you started, and this is what happens...ã'ã'(comments available ONLY with the * professional version)ãCLSãF = 0ãB = 0ãY = 1ãX = 1ãQ = 9ãtop:ãCOLOR F, BãM = VAL(MID$(TIME$, 5, 1))ãF = VAL(RIGHT$(TIME$, 1))ãIF F > 8 THEN F = F + 1ãIF F > 15 THEN F = 0ãB = VAL(MID$(TIME$, 7, 1))ãIF B > 8 THEN B = B + 1ãIF B > 15 THEN B = 0ãIF B = F THEN B = B + MãLOCATE Y, XãY = Y + B + 1ãIF Y > 25 THEN Y = 1ãX = X + M / Y + MãIF X > 80 THEN X = 1ãIF X = 5 AND Y = 6 THEN F = 1: B = 1: X = 1: Y = 1: Q = 1ãIF B < 1 THEN B = 1ãQ = Q + F * 5 / BãIF Q > 255 THEN Q = 8ãPRINT CHR$(Q);ãcutitout$ = INKEY$ãIF cutitout$ = "c" THEN GOTO lastãGOTO topãlast:ãCOLOR 7, 0ãCLSãENDã'* he he :)ãããHauke Daempfling               SUPER TEXT PACKER              hcd@berlin.snafu.de            01-04-96 (00:58)       QB, QBasic, PDS        107  5023     TEXTPACK.BASDECLARE SUB PackTxt (text$)ã' Super Text/String Packer/Unpacker for QB4.5ã'     Originally by Greg Estabrooksã'  Slightly changed by Hauke Daempflingãã'(small note: all documentation is by Hauke :) )ãã'This program (or rather the PackTxt sub) packs/unpacksã' strings to about 52% of their original size. All I can say isã' that this is one of the best code snippets I've ever seen. :)ã' Actually, it's brilliant :).ãã' I changed it from its original version in the following ways:ã' 1) The sub adds CHR$(255) to a packed string to indicate thatã'    it is packed. (For automatic packing/unpacking)ã' 2) The sub checks if the values of the characters in the string areã'    between 32 and 127 to reduce errors while packing.ã' 3) Last but not least, I've added some documatation.ãã'Usage is very simple. Take a string (A$, for example) and call PackTxt:ã' A$ = "This is a test string for the text packer."ã' PackTxt A$ã'The string will be packed and CHR$(255) added to the beginning to indicateã'that it is packed. To unpack a string just call PackTxt again:ã' PackTxt A$ã'There. That's all there is to it. Have fun :)ãã'PackTxt SUB begins hereãDEFINT A-Zã'This sub packs strings to about 52% of their original size. The subã' automatically checks if the string is packed or not and unpacks/packsã' it accordingly. (neat, huh?)ã' Don't play around with the dictionary or you can lower the packingã' ratio (when I got it there was a single space missing and thatã' reduced the ratio by about 10%!).ã' NOTE: text$ may only contain ASCII characters with the values 32-127!ãSUB PackTxt (text$)ã'the commets here are cluttered up... delete them if you wantã  ã   'The dictionary... it may look like junk, but it is prerry much the heartã   ' of the packer (so don't mess it up :) )ã   d1$ = "  e  as  tinthouerhet anreesr d onn or o i y wo tontyo. neisarte"ã   d2$ = "ed,  ctiy  bat snd fal pensestvengitu talehaurllcousa  mf dfoof "ã   d3$ = "siril  hmeg om Icehironsasiossbedepe rli Tetel nicho lilprcactut"ã   d4$ = "Thpaeceachh wige ebuaisursulmawaotowtsmploI solyee Cunm rtieno S"ã   d5$ = "diwhs.rafincademe.irplk  ury Pwoacos gams,duayavucColamowe Aoopu"ã   Dict$ = d1$ + d2$ + d3$ + d4$ + d5$ã   IF LEN(Dict$) <> 320 THEN              'just to check...ã     PRINT "PACKING ERROR: Dictionray has the wrong size"ã     EXIT SUBã   END IFã  ã   IF NOT LEFT$(text$, 1) = CHR$(255) THEN 'check if the string is packedã     'the string isn't packed so pack it...ã     IF LEN(text$) < 4 THEN EXIT SUB 'no use with strings less than 4 chars.ã    ã     FOR a = 1 TO LEN(text$)              'check if there are any charactersã       v = ASC(MID$(text$, a, 1))         ' with values out of range (theyã       IF v < 32 OR v > 127 THEN EXIT SUB ' _cannot_ be packed otherwise)ã     NEXT aã    ã     DOã      ã       cnt = cnt + 1               'read pointer in text$ã       char$ = MID$(text$, cnt, 2) 'characters to be checked for in Dict$ã      ã       IF cnt = LEN(text$) THEN    'if the end of the string has been reachedã         text$ = CHR$(255) + temp$ + CHR$(ASC(MID$(text$, cnt, 1)) - 32)ã         EXIT SUB                   '^^^^ add the last characterã       END IFã      ã       xx = 1 'read pointer in Dict$ãReDo:ã       x = INSTR(xx, Dict$, char$)4;1;120;1;0xpã       IF x THEN           'if the characters from text$ are in Dict$ã         IF (x \ 2) = (x / 2) THEN 'if the instr of the characters can't beã           xx = x + 1              ' divided by 2 then look again (it needsã           GOTO ReDo               ' to be divided so it can be packed)ã         END IFã         temp$ = temp$ + CHR$((x \ 2) + 96) 'add the instr of the charactersã         cnt = cnt + 1                      ' in Dict$ to temp$ (note thatã              '^^^ characters shouldn't     ' it's stored so that it's moreã                 ' be compressed twice      ' than 95)ã       ELSEã         'if the characters aren't found store the first characterã         '(note that it's less than 95 and that cnt is only moved up _1_)ã         temp$ = temp$ + CHR$(ASC(MID$(text$, cnt, 1)) - 32)ã       END IFã     LOOP WHILE cnt < LEN(text$)ã     text$ = CHR$(255) + temp$ 'copy temp$ into text$ and add CHR$(255)ã     EXIT SUB                  ' to indicate a packed stringã   ELSEã     'text$ is packed so unpack itã     comp$ = RIGHT$(text$, LEN(text$) - 1) 'remove CHR$(255)ã     text$ = ""                            're-init text$ã     FOR x = 1 TO LEN(comp$)ã       char = ASC(MID$(comp$, x, 1))ã       IF char > 95 THEN 'if char > 95 then char is the instr of theã                         ' unpacked characters in Dict$, remember?ã         text$ = text$ + MID$(Dict$, (char - 96) * 2 + 1, 2)ã       ELSE 'if the characters weren't found in Dict$ they were storedã            ' with a value less than 95 (most are found, though)ã         text$ = text$ + CHR$(ASC(MID$(comp$, x, 1)) + 32)ã       END IFã     NEXT xã   END IFãEND SUBãScott Hoopes                   NEW TEXT FONT                  FidoNet QUIK_BAS Echo          03/95 (00:00)          QB, PDS                101  3448     NEWFONT.BAS 'NEWTXT.BAS - by Scott Hoopes Compuserve 73304,274ã'placed into the public domain March 1995ãã'demonstrates how to create your own characters in text modeãã'the default character for VGA is a 8x16 cell like the following:ã'                  00000000ã'                  00000000ã'                  11111111ã'                  11011011ã'                  10011001ã'                  00011000ã'                  00011000ã'                  00011000ã'                  00011000ã'                  00011000ã'                  00011000ã'                  00011000ã'                  01111110ã'                  00000000ã'                  00000000ã'                  00000000ã'the above might be how a 'T' is represented.ã'for demonstration, we will change the definition of ASCII 255 which byã'default would look like all zeros in the above example.ãã'first we need to access BIOS interrupts so the next few lines areã'neccessaryãDEFINT A-Zã'$INCLUDE: 'qb.bi'ãDIM inregs AS RegTypeX, outregs AS RegTypeXãã'clear the screen and put some ASCII 255's on the screenãCLSãPRINT STRING$(80, 255);                    'so we can see itããDIM holder AS STRING * 16   'this is where we put our new ASCII 255ã					   'must be a multiple of 16 bytes sinceã					   'each character is 16 bytes longãã'now we develop a new character to replace ASCII 255ã'                  00000000  0ã'                  00000000  0ã'                  00011000  24ã'                  00100100  36ã'                  01011010  90ã'                  10100101  165ã'                  10100001  161ã'                  10100001  161    <-- these are the numbers we mustã'                  10100101  165        put in 'holder' to representã'                  01011010  90         our new charã'                  00100100  36ã'                  00011000  24ã'                  00000000  0ã'                  00000000  0ã'                  00000000  0ã'                  00000000  0ããDEF SEG = VARSEG(holder)      'set default segment to that of ourã						'new characterã						'we must poke each of the above valuesã						'into 'holder'ãPOKE VARPTR(holder), 0        'VARPTR(holder) is the offset of 'holder'ãPOKE VARPTR(holder) + 1, 0ãPOKE VARPTR(holder) + 2, 24ãPOKE VARPTR(holder) + 3, 36ãPOKE VARPTR(holder) + 4, 90ãPOKE VARPTR(holder) + 5, 165ãPOKE VARPTR(holder) + 6, 161ãPOKE VARPTR(holder) + 7, 161ãPOKE VARPTR(holder) + 8, 165ãPOKE VARPTR(holder) + 9, 90ãPOKE VARPTR(holder) + 10, 36ãPOKE VARPTR(holder) + 11, 24ãPOKE VARPTR(holder) + 12, 0ãPOKE VARPTR(holder) + 13, 0ãPOKE VARPTR(holder) + 14, 0ãPOKE VARPTR(holder) + 15, 0ããDEF SEG                       'reset the default segment to BASICãã inregs.ax = &H1100           'BIOS function to load new char definitionã inregs.bx = 16 * 256         '16 bytes/char - for 256 charactersã inregs.cx = 1                'number of characters to changeã inregs.dx = 255              'the character to changeã inregs.es = VARSEG(holder)   'segment of holderã inregs.bp = VARPTR(holder)   'offset of holderã CALL INTERRUPTX(&H10, inregs, outregs)ãã SLEEP                        'so we see it until a key pressããã'now we must reset the video state so the BIOS resumes using the correctã'character definitionsãã inregs.ax = &H3     'BIOS function to reset the video display to 80ã				 'cols x 25 linesã CALL INTERRUPTX(&H10, inregs, outregs)ããENDããDavid J. Arigan                UUENCODER                      FidoNet QUIK_BAS Echo          02-04-96 (19:14)       QB, QBasic, PDS        39   1362     UUENCODE.BAS'Here is a UUEncoder program I wrote for no particular reason whatsoever.ã'It is fairly small and simple (pretty quick also).  Enjoy.ãã'David Ariganãã  IF LEN(COMMAND$) = 0 THEN PRINT "Usage: UUENCODE <filename>": ENDã  file$ = COMMAND$ã  IF INSTR(file$, " ") THEN file$ = LEFT$(file$, INSTR(file$, " ") - 1)ã  unam$ = file$ã  IF INSTR(unam$, ".") THEN unam$ = LEFT$(file$, INSTR(file$, ".") - 1)ã  pnam$ = file$ã  IF INSTR(pnam$, "\") THEN pnam$ = MID$(pnam$, INSTR(file$, "\") + 1)ã  OPEN file$ FOR BINARY AS #1ã  IF LOF(1) = 0 THENã    PRINT "File '"; file$; "' does not exist."ã    CLOSE #1: KILL file$: ENDã  END IFã  OPEN unam$ + ".uue" FOR OUTPUT AS #2ã  PRINT #2, "begin 644 " + pnam$ã  bl& = 45: fl& = LOF(1): bf$ = SPACE$(bl&)ã  WHILE fl&ã    IF fl& < bl& THEN bl& = fl&: bf$ = SPACE$(bl&)ã    GET #1, , bf$: fl& = fl& - bl&ã    IF bl& MOD 3 <> 0 THEN bf$ = bf$ + STRING$(3 - bl& MOD 3, 0)ã    FOR i = 1 TO bl& STEP 3ã      c1 = ASC(MID$(bf$, i, 1))ã      c2 = ASC(MID$(bf$, i + 1, 1))ã      c3 = ASC(MID$(bf$, i + 2, 1))ã      l$ = l$ + CHR$(c1 \ 4 + 32)ã      l$ = l$ + CHR$((c1 * 16 + c2 \ 16 AND &H3F) + 32)ã      l$ = l$ + CHR$((c2 * 4 + c3 \ 64 AND &H3F) + 32)ã      l$ = l$ + CHR$((c3 AND &H3F) + 32)ã    NEXTã    PRINT #2, CHR$(32 + bl&); l$: l$ = ""ã  WENDã  PRINT #2, : PRINT #2, "end"ã  CLOSE #1, #2ãããDavid J. Arigan                UUDECODER                      FidoNet QUIK_BAS Echo          02-04-96 (19:14)       QB, QBasic, PDS        63   2310     UUDECODE.BAS'This is the UUDecoder that goes along with my UUEncoding program.  If youã'like them let me know.  If you decide to use either of them (or portions ofã'them m in your programs, remember to include my name in the credits. Thanx.ãã'David J. Ariganãã  DEFINT A-Zã  IF LEN(COMMAND$) = 0 THEN PRINT "Usage: UUDECODE <filename>": ENDã  file$ = COMMAND$ã  IF INSTR(file$, " ") THEN file$ = LEFT$(file$, INSTR(file$, " ") - 1)ã  unam$ = file$ã  IF INSTR(pnam$, "\") THEN pnam$ = MID$(pnam$, INSTR(file$, "\") + 1)ã  OPEN file$ FOR BINARY AS #1ã  IF LOF(1) = 0 THENã    PRINT "File '"; file$; "' does not exist."ã    CLOSE #1: KILL file$: ENDã  END IFã  CLOSE #1ã  OPEN unam$ FOR INPUT AS #1ã  WHILE EOF(1) = 0ã    LINE INPUT #1, l$: lc = lc + 1ã    IF LCASE$(LEFT$(l$, 5)) = "begin" THENã      n = INSTR(l$, " ")ã      IF n <> 0 AND INSTR(n + 1, l$, " ") <> 0 THENã        onam$ = RTRIM$(MID$(l$, INSTR(n + 1, l$, " ") + 1))ã        OPEN onam$ FOR BINARY AS #2ã        DOã          LINE INPUT #1, l$: lc = lc + 1ã          IF LCASE$(LEFT$(l$, 3)) = "end" THEN success = -1: EXIT DOã          IF LEN(l$) THENã            ls = (ASC(l$) - 32) MOD 64: o$ = ""ã            IF ls < 0 OR ls > 45 OR ls > ((LEN(l$) - 1) * 3 \ 4) THENã              PRINT "*** Error in line #"; lc; " (Bad length)": EXIT DOã            END IFã            FOR i = 1 TO lsã              p = ((i - 1) \ 3) * 4ã              SELECT CASE (i - 1) MOD 3ã                CASE 0ã                  c% = (ASC(MID$(l$, p + 2)) - 32) * 4ã                  c% = c% + (ASC(MID$(l$, p + 3)) - 32) \ 16ã                CASE 1ã                  c% = ((ASC(MID$(l$, p + 3)) - 32) * 16) AND &HF0ã                  c% = c% + (ASC(MID$(l$, p + 4)) - 32) \ 4ã                CASE 2ã                  c% = ((ASC(MID$(l$, p + 4)) - 32) * 64) AND &HC0ã                  c% = c% + (ASC(MID$(l$, p + 5)) - 32)ã              END SELECTã              o$ = o$ + CHR$(c)ã            NEXT iã            PUT #2, , o$ã          END IFã        LOOP UNTIL EOF(1)ã        CLOSE #2ã        IF success = 0 THENã          PRINT "*** UUDecoding '"; onam$; " was not succesful."ã        ELSEã          PRINT "Finished UUDecoding '"; onam$; "'"ã          success = 0ã        END IFã      END IFã    END IFã  WENDã  CLOSE #1ãDave Gjessing                  TEXT USER INTERFACE            dgjess@freenet.columbus.oh.us  02-11-96 (18:35)       QB, QBasic, PDS        254  8034     TUI.BAS     DECLARE SUB CommandPointer (firstline%, Col%, BotLimit%, Fgc%, Bgc%, DoLine%)ãDECLARE SUB DLBox (TLine%, LCol%, BLine%, RCol%, FieldNo%, border%, Fgc%, Bgc%, shadow%)ãDECLARE SUB MenuBar (message%, Fgc%, Bgc%)ããDEFINT A-Zãã'IFACE_06.BAS - a text user interface - Dave Gjessing 1996ã'Copy IFACE_06.BAS to [yourprog].BAS, erase the demonstration below,ã'and put in your own code instead.ã'The demonstration is all black and white, and seems to work fineã'on Hercules, MCGA, and color VGA.ãã'demonstrationãtop:ãDLBox 2, 1, 23, 80, 0, 2, 7, 0, 0ãMenuBar 1, 7, 0ãCommandPointer 3, 3, 22, 7, 0, DoLine%ããSELECT CASE DoLine%ã   CASE IS < 100ã   LOCATE DoLine%, 5ã   PRINT "the pointer is on line "; DoLine%ã   SLEEP 2: GOTO topã   CASE 100ã   DLBox 10, 25, 14, 55, 0, 1, 7, 0, 1    'single border, shadowã   LOCATE 12, 32: PRINT "page down pressed"ã   SLEEP 2: GOTO topã   CASE 200ã   DLBox 10, 25, 14, 55, 0, 2, 7, 0, 0    'double border, no shadowã   LOCATE 12, 33: PRINT "page up pressed"ã   SLEEP 2: GOTO topã   CASE 601 TO 609ã   DLBox 10, 25, 14, 55, 0, 1, 7, 0, 1    'single border, shadowã   LOCATE 12, 33ã   DoLineStr$ = STR$(DoLine%)ã   PRINT "F"; RIGHT$(DoLineStr$, 1); " key pressed"ã   SLEEP 2: GOTO topã   CASE 610ã   DLBox 10, 25, 14, 55, 0, 2, 7, 0, 1    'double border, shadowã   LOCATE 12, 33: PRINT "F10 key pressed"ã   SLEEP 2: GOTO topã   CASE 900ã   CLS : ENDã   CASE ELSEã   GOTO topããEND SELECTããSUB CommandPointer (firstline%, Col%, BotLimit%, Fgc%, Bgc%, DoLine%)ã'this is where the user reacts to menu choices...ããCOLOR Fgc%, Bgc%ãDoLine% = firstline%    'set aside the first line (sent with the sub call)ã                        'as the upper limit to the list. (Work with DoLine%)ãLOCATE firstline%, Col% 'go to the line and column called for in theã                        'subroutine callãPRINT CHR$(16)          'and print the line pointer on the screenããDO                      'run around in circles awaiting instructionsãselection$ = INKEY$ãselection$ = UCASE$(selection$)ãã'the next two IF's move the pointer up and down...ãIF selection$ = CHR$(0) + "H" THEN           'UpArrowã   LOCATE DoLine%, Col%: PRINT CHR$(0)       'first blank out old pointerã   DoLine% = DoLine% - 1                     'move up one lineã   IF DoLine% < firstline% THEN DoLine% = BotLimit% 'jump to bottom if at topã   LOCATE DoLine%, Col%                      'go to where directedã   PRINT CHR$(16)                            'print new pointer on screenã   END IFãIF selection$ = CHR$(0) + "P" THEN           'DnArrowã   LOCATE DoLine%, Col%: PRINT CHR$(0)       'cover the last pointerã   DoLine% = DoLine% + 1                     'move down one lineã   IF DoLine% > BotLimit% THEN DoLine% = firstline% 'jump to top if at bottomã   LOCATE DoLine%, Col%                      'go to where directedã   PRINT CHR$(16)                            'new pointerã   END IFãã'this IF reacts to the user pressing the ENTER key. The sub ends with a newã'value for DoLine%, equal to the line that the pointer was on.ãIF selection$ = CHR$(13) THENã    DoLine% = DoLine%ã    EXIT SUBã    END IFãã'these other IF's return a value for DoLine% which is not a valid screenã'coordinate. It is up to the SELECT CASE statements that follow the lineã'that called CommandPointer to determine what to do with the returned valueããIF selection$ = CHR$(0) + CHR$(81) THEN      'page down keyã   DoLine% = 100ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(73) THEN      'page up keyã   DoLine% = 200ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(59) THEN      'F1 keyã   DoLine% = 601ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(60) THEN      'F2 keyã   DoLine% = 602ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(61) THEN      'F3 keyã   DoLine% = 603ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(62) THEN      'F4 keyã   DoLine% = 604ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(63) THEN      'F5 keyã   DoLine% = 605ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(64) THEN      'F6 keyã   DoLine% = 606ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(65) THEN      'F7 keyã   DoLine% = 607ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(66) THEN      'F8 keyã   DoLine% = 608ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(67) THEN      'F9 keyã   DoLine% = 609ã   EXIT SUBã   END IFãIF selection$ = CHR$(0) + CHR$(68) THEN      'F10 keyã   DoLine% = 610ã   EXIT SUBã   END IFãIF selection$ = CHR$(27) THEN                'escape keyã   DoLine% = 900ã   EXIT SUBã   END IFãLOOPã'break out of the loop and return to the calling module with a new variableã'called DoLine%, equal to the line number on screen where the selected itemã'was being displayed, or else with a number beyond the screen size (100, 200,ã'etc.), which will be used to convey special instructionsãEND SUBããSUB DLBox (TLine, LCol, BLine, RCol, FieldNo, border, Fgc, Bgc, shadow)ã'DLBOX (DeLuxe Box) is a fancy box sub-routine that includesã'a user-defined background character parameter, single or double-ã'line border (or no border), and foreground and background color parameters,ã'plus shadow or no shadow option.ã'ã'The no-border option makes this "box" routine able to replace "background"ã'routines.ãCOLOR Fgc, Bgcã   IF border = 0 THEN    'no border at allã      ULC = FieldNoã      URC = FieldNoã      LLC = FieldNoã      LRC = FieldNoã      HORIZ = FieldNoã      VERT = FieldNoã         END IFã   IF border = 1 THEN   'single line borderã      ULC = 218         'upper left cornerã      URC = 191         'upper right cornerã      LLC = 192         'lower left cornerã      LRC = 217         'lower right cornerã      HORIZ = 196       'horizontal linesã      VERT = 179        'vertical linesã         END IFã   IF border = 2 THEN   'double line borderã      ULC = 201         'ditto all aboveã      URC = 187ã      LLC = 200ã      LRC = 188ã      HORIZ = 205ã      VERT = 186ã         END IFããLOCATE TLine, LColãPRINT CHR$(ULC) + STRING$(((RCol - LCol) - 1), CHR$(HORIZ)) + CHR$(URC)ãFOR x = 1 TO (BLine - TLine) - 1ãLOCATE ((TLine + 1) + NextLine), LColã   NextLine = NextLine + 1ãPRINT CHR$(VERT) + STRING$(((RCol - LCol) - 1), CHR$(FieldNo)) + CHR$(VERT);ãNEXT xãLOCATE BLine, LColãPRINT CHR$(LLC) + STRING$(((RCol - LCol) - 1), CHR$(HORIZ)) + CHR$(LRC);ã ããIF shadow = 1 THEN   'for consistancy, use 1 for shadows, 0 for no shadowã   IF BLine > 24 OR RCol > 79 THEN GOTO badshadowãCOLOR 7, 0           'shadows are darkããLOCATE BLine + 1, LCol + 1                 'across theãPRINT STRING$((RCol - LCol), CHR$(176));  'bottom...ã ãFOR I = TLine + 1 TO BLine + 1              'on theãLOCATE I, RCol + 1: PRINT CHR$(176);         'right sideãNEXTããEND IFãCOLOR Fgc, Bgc       'restore original colorsãbadshadow:ããEND SUBããSUB MenuBar (message, Fgc, Bgc)ãCOLOR Bgc%, Bgc%                             'nothing but backgroundãLOCATE 1, 1: PRINT STRING$(80, 219);           'color bar 1 at topãLOCATE 24, 1: PRINT STRING$(80, 219);          'color bar 2 at bottomãLOCATE 25, 1: PRINT STRING$(80, 219);          'color bar 3 at very bottomãCOLOR Fgc%, Bgc%                             'activate foreground colorãprogname$ = "IFACE_06.BAS - a text user interface for QBasic, etc."ãtitle1$ = "title for MenuBar 1"ãLOCATE 25, (40 - (LEN(progname$) / 2)): PRINT progname$;   'prog nameããIF message% = 1 THENã    LOCATE 1, 1: PRINT " <ESC> QUIT "; CHR$(4); " arrows & enter to select "; CHR$(4); " <F> keys as needed";ã    LOCATE 24, (40 - (LEN(title1$) / 2)): PRINT title1$;ãEND IFããIF message% = 2 THENãEND IFããIF message% = 3 THENãEND IFããIF message% = 4 THENãEND IFããIF message% = 5 THENãEND IFããIF message% = 6 THENãEND IFããIF message% = 7 THENãEND IFããIF message% = 8 THENãEND IFããIF message% = 9 THENãEND IFããIF message% = 10 THENãEND IFããEND SUBããThe ABC Programmer             TEXT POP-UP BUTTONS            Like the ABC Reader buttons    02-14-96 (11:20)       QB, QBasic, PDS        125  4253     BUTTONS.BAS '========================================ã'  Nice looking TEXT Pop-up Buttonsã'  Programmed by William Yu  (02-14-96)ã'ã'  Features:ã'    One subroutine callã'    Shadow can be placed on either sideã'    Up/Down button positionã'    User defined colours (colors USA)ã'    Multiple high-lightable charactersã'    EASY to use!ã'ã'  This routine was not used within theã'  ABC Reader v1.00, I programmed thisã'  subroutine after.ã'ã'  You may wish to cut down or abbr. theã'  variables later.  I used the hugeã'  variable names for easy reference.ã'========================================ããDEFINT A-ZãDECLARE SUB TextButton (Position%, XButton%, YButton%, Button$, ButtonForeColour%, ButtonBackColour%, ButtonHiLightChar%, ShadowColour%, ShadowBackGround%, Shadow%)ãDECLARE SUB Pause (Seconds!)ããSCREEN 0, , 0, 0ããCOLOR , 1: CLS      ' Create a coloured background for demonstration purposesããCONST Right = -1    ' Whatever number you want, but RIGHT <> LEFTãCONST Left = 0ãCONST Up = -1       ' Whatever number you want, but UP <> DOWNãCONST Down = 0ããX = 35: Y = 11                ' X and Y coordinates of buttonãHelpButton$ = "~Help (~F~1)"  ' Spaces not required, automatically includedãButtonForeColour = 0          ' Letters colour are BLACKãButtonBackColour = 7          ' Colour of button is GREYãButtonHiLightChar = 15        ' High-lighted character is WHITEãButtonShadowColour = 0        ' Button shadow is DARK GREYãShadowBackGround = 1          ' Shadow's background colour is BLACKãShadow = Right                ' Place shadow to the RIGHT of buttonããDO       ' Drive user crazy with this loop!ã  TextButton Up, X, Y, HelpButton$, ButtonForeColour, ButtonBackColour, ButtonHiLightChar, ButtonShadowColour, ShadowBackGround, Shadowã  Pause .3ã  TextButton Down, X, Y, HelpButton$, ButtonForeColour, ButtonBackColour, ButtonHiLightChar, ButtonShadowColour, ShadowBackGround, Shadowã  Pause .4ãLOOP UNTIL INKEY$ <> ""ãã' Equivalent lines without all the variables:ã'ã' TextButton Up, 40, 10, "~Help", 0, 7, 15, 8, 0, Rightã' TextButton Down, 40, 10, "~Help", 0, 7, 15, 8, 0, RightããSUB Pause (Seconds!)ããT! = TIMER                        ' Pause routineãWHILE NOT TIMER - T! > Seconds!   ' Delay for how many Seconds!ãWEND                              ' WHILE...WEND or DO...LOOP  WhateverããEND SUBããSUB TextButton (Position, XButton, YButton, Button$, ButtonForeColour, ButtonBackColour, ButtonHiLightChar, ShadowColour, ShadowBackGround, Shadow)ããXCor = XButtonããIF (Shadow = Left) AND (Position = Up) THEN      ' Place shadows on theã  LOCATE YButton, XButton - 1                    ' left side of buttonã  COLOR ShadowColour, ShadowBackGroundã  PRINT "Ü";ã  LOCATE YButton + 1, XButton - 1: PRINT "ßß";ãEND IFããIF Position = Down THEN        ' This routine removes the shadowsã  LOCATE YButton, XButtonã  COLOR , ShadowBackGroundã  PRINT " ";ã  IF Shadow = Right THEN XCor = XCor + 1 ELSE XCor = XCor - 1ã  LOCATE YButton + 1, XCor: PRINT " ";ãEND IFããLOCATE YButton, XCorãCOLOR ButtonForeColour, ButtonBackColourãPRINT " ";              ' Spaces are automatically inserted, remove if desiredããLength = LEN(Button$)   ' Number of characters in BUTTON$ãFOR I = 1 TO Length     ' Parse them allã  IF MID$(Button$, I, 1) = "~" THENã    COLOR ButtonHiLightCharã  ELSEã    XCor = XCor + 1ã    LOCATE YButton, XCorã    PRINT MID$(Button$, I, 1);ã    COLOR ShadowColour, ShadowBackGroundã    IF Position = Up THENã      LOCATE YButton + 1, XCor: PRINT "ß";ã    ELSEã      LOCATE YButton + 1, XCor: PRINT " ";ã    END IFã    COLOR ButtonForeColour, ButtonBackColourã  END IFãNEXT IããIF Position = Down THEN        ' This routine also removes the shadowsã  LOCATE YButton + 1, XCor + 1ã  COLOR ShadowColour, ShadowBackGroundã  PRINT " ";ã  IF Shadow = Left THENã    LOCATE YButton, XCor + 2: PRINT " ";ã  END IFãEND IFããCOLOR ButtonForeColour, ButtonBackColourãLOCATE YButton, XCor + 1ãPRINT " ";              ' Spaces are automatically inserted, remove if desiredããIF (Shadow = Right) AND (Position = Up) THENã  COLOR ShadowColour, ShadowBackGroundã  PRINT "Ü";ã  LOCATE YButton + 1, XCor + 1: PRINT "ßß";ãEND IFããEND SUBããAlexander Podkolzin            SIMPLE FILE BROWSER            APP@nw.sbank.e-burg.su         02-29-96 (14:39)       PB32                   267  7463     BRWSFILE.BAS'--------------------------------------------------------------------------ã' Simple File Browser. Author: Alexander Podkolzin <APP@nw.sbank.e-burg.su>ã' Use it as you want...ã' PowerBASIC 3.2ã'--------------------------------------------------------------------------ã$CPU 8086ã$OPTIMIZE SIZEã$COMPILE EXEã$DEBUG MAP OFFã$DEBUG PBDEBUG OFFã$LIB ALL       OFFã$ERROR ALL     OFFã$COM    0ã$STRING 4ã$STACK  2048ã$SOUND  1ã$DIM ARRAYã$DYNAMICã$OPTION CNTLBREAK OFFã'--------------------------------------------------------------------------ã  %MaxLines = 5000                      ' Max strings to showã  %MaxLen=240                           ' Max LEN of a stringã'ã  DEFINT a-zã  DIM txt$(%MaxLines)ã'ã  InsKey$=CHR$(0,82)                    ' Key codesã  Enter$=CHR$(13)ã  Esc$ = CHR$(27)ã  Home$ = CHR$(0,71)ã  PgUp$ = CHR$(0,73)ã  EndKey$ = CHR$(0,79)ã  PgDn$ = CHR$(0,81)ã  Up$ = CHR$(0,72)ã  Down$ = CHR$(0,80)ã  LeftKey$ = CHR$(0,75)ã  RightKey$ = CHR$(0,77)ã  CtrlPgUp$ = CHR$(0,132)ã  CtrlPgDn$ = CHR$(0,118)ã  CtrlHome$ = CHR$(0,119)ã  CtrlEnd$ = CHR$(0,117)ã'ã  Twin%=1                               ' Win typeã  xb%=1 : yb%=2 : xe%=80 : ye%=24       ' Edit window coordinatesã'ã  ct%=7                                 ' Main colorsã  cb%=0                                 'ã'ã  FileName$ = COMMAND$                  ' File to editã'ã  IF NOT FileExists(FileName$) THENã     PRINT "Command line <FileName> not found..."ã     BEEPã     ENDã  END IFã'ã  src% = FREEFILEã  OPEN FileName$ FOR INPUT AS src%ã  i%=0ã  DO WHILE EOF(src%)=0 AND i% < %MaxLinesã     INCR i%ã     LINE INPUT #src%,txt$(i%)ã     IF txt$(i%)="" THEN txt$(i%)=" "ã     REPLACE CHR$(9) WITH "        " IN txt$(i%)ã  LOOPã  CLOSE src%ã  nlines%=i%ã'ã  COLOR 0,7ã  LOCATE 1,1ã  PRINT SPACE$(80);ã  LOCATE 1,4ã  PRINT "File = ";FileName$;ã  LOCATE 25,1ã  PRINT SPACE$(80);ã'ã  COLOR ct%,cb%ã'ã  lpage%=ye%-yb%-1ã  CALL win(twin%,xb%,yb%,xe%,ye%,ct%,cb%)ã  Aprint 3,ye%,"´     :   =   Ã"ã'ã  begx%=1ã  begy%=1ã  endy%=MIN(lpage%,nlines%)ã  CurY%=1ã  CurX%=1ã  GOSUB ShowTextã  GOSUB ShowCursorã  DOã     GOSUB ShowCursorã     WHILE NOT INSTAT: WEND             ' begy% - first line to show,ã     IF nlines%<1 THEN EXIT LOOP        ' endy% - last line to show (array)ã     k$=INKEY$                          ' CurY%  - the cursor bar lineã     SELECT CASE k$                     ' lpage%- length of window (page)ã        CASE InsKey$ã           : ITERATE LOOPã        CASE Esc$ã           : CurY%=0 : begy%=1:EXIT LOOPã        CASE Enter$ã           : EXIT LOOPã        CASE Home$ã           : CurX%=2 : begx%=1ã        CASE EndKey$ã           : l%=LEN(txt$(begy%+CurY%-1))ã           : CurX%=MIN(l%+1,78)+1ã           : endx%=MAX(l%+1,78)+1ã           : begx%=endx%-78ã        CASE Up$ã           IF CurY%>1 THENã              DECR CurY%ã           ELSEã              begy%=begy%-1ã              endy%=endy%-1ã           END IFã        CASE Down$ã           IF CurY%<lpage% THENã              INCR CurY%ã           ELSEã              begy%=begy%+1ã              endy%=endy%+1ã           END IFã        CASE LeftKey$ã           IF CurX%>2 THENã              DECR CurX%ã           ELSEã              begx%=begx%-1ã              IF begx%<1 THEN begx%=1ã           END IFã        CASE RightKey$ã           IF CurX% < 79 THENã              INCR CurXã              Show=0ã           ELSEã              INCR begxã              IF begx >%MaxLen-79 THEN begx=%MaxLen-79ã           END IFã        CASE PgUp$ã           : begy%=begy%-lpage%ã           : endy%=endy%-lpage%ã        CASE PgDn$ã           : begy%=begy%+lpage%ã           : endy%=endy%+lpage%ã        CASE CtrlPgUp$ã           : begy%=1ã           : endy%=begy%+lpage%-1ã           : CurX%=2ã           : CurY%=1ã        CASE CtrlPgDn$ã           : endy%=nlines%ã           : begy%=endy%-lpage%+1ã           : CurX%=2ã           : CurY%=21ã        CASE CtrlHome$ã           : CurY%=1ã        CASE CtrlEnd$ã           : CurY%=21ã        CASE ELSEã           : k$=""ã     END SELECTã     GOSUB ShowTextã  LOOPã  CLSã  ENDã'--------------------------------------------------------------------------ããShowText:ã  CALL Numerer(nlines%,lpage%,begy%,endy%)ã  GOSUB MakeRulerã  FOR i%=begy% TO endy%ã     Aprint xb%+1,yb%+i%-begy%+1,_ã     MID$(txt$(i%)+SPACE$(xe%-xb%+1),begx%,78)ã  NEXT i%ã  RETURNã'--------------------------------------------------------------------------ããShowCursor:ã  LOCATE ye%,4,0ã  PRINT RIGHT$("0000"+LTRIM$(STR$(begy%+CurY%-1)),5)ã  LOCATE ye%,10,0ã  PRINT RIGHT$("00"+LTRIM$(STR$(begx%+Curx%-2)),3)ã  IF CurX%< 2 THEN CurX%= 2ã  IF CurX%>79 THEN CurX%=79ã  LOCATE ye%,14,0ã  PRINT RIGHT$("00"+LTRIM$(STR$(SCREEN(CurY%+2,CurX%))),3)ã  LOCATE yb%+CurY%,CurX,1ã  RETURNã'--------------------------------------------------------------------------ããMakeRuler:ã  FOR i%=yb%+1 TO ye%-1ã     Aprint xe%,i%,CHR$(177)ã  NEXTã  k%=((begy%+CurY%-1)/nlines%)*(ye%-yb%-1)ã  IF k%=0 THEN k%=1ã  Aprint xe%,yb%+k%,CHR$(219)ã  RETURNã'--------------------------------------------------------------------------ã  SUB Numerer(nlines%,lpage%,begy%,endy%)ã     IF nlines%<=lpage% THENã        begy%=1ã        endy%=nlines%ã        EXIT SUBã     END IFã     IF begy%<1 THENã        begy%=1ã        endy%=begy%+lpage%-1ã        EXIT SUBã     END IFã     IF begy%+lpage%-1>=nlines% THENã        endy%=nlines%ã        begy%=nlines%-lpage%+1ã        EXIT SUBã     END IFã     endy%=begy%+lpage%-1ã  END SUBã'--------------------------------------------------------------------------ã  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)ã'ã     OldColor% = pbvScrnTxtAttr         ' Internal PB variableã     SELECT CASE t%                     ' Window typesã'                                       ' (you can make as much types,ã'                                       '  as you want):ã        CASE 1ã           a%=218:b%=196:c%=191         'ÚÄÄÄÄÄÄÄ¿ã           h%=179:      :d%=179         '³   1   ³ã           g%=192:f%=196:e%=217         'ÀÄÄÄÄÄÄÄÙã        CASE 2ã           a%=201:b%=205:c%=187         'ÉÍÍÍÍÍÍÍ»ã           h%=186:      :d%=186         'º   2   ºã           g%=200:f%=205:e%=188         'ÈÍÍÍÍÍÍÍ¼ã        CASE ELSEã           a%=032:b%= a%:c%= a%         'ã           h%= a%:      :d%= a%         ' Blanks onlyã           g%= a%:f%= a%:e%= a%         'ã     END SELECTã     COLOR ct%,cb%ã     LOCATE yb%,xb%ã     PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%);ã     FOR i%=yb%+1 TO ye%-1ã        LOCATE i%,xb%ã        PRINT CHR$(h%)+ SPACE$(xe%-xb%-1) +CHR$(d%);ã     NEXTã     LOCATE ye%,xb%ã     PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%);ã     ct%=OldColor% AND 15               ' restore colorsã     cb%=OldColor%\16ã     COLOR ct%,cb%ã  END SUBã'--------------------------------------------------------------------------ã  SUB Aprint(x%,y%,st$)ã     ox%=POS(0)ã     oy%=CSRLINã     LOCATE y%,x%,0ã     PRINT st$;ã     LOCATE oy%,ox%,1ã  END SUBã'--------------------------------------------------------------------------ãFUNCTION FileExists%(FileName$)ã  S$=DIR$(FileName$)ã  IF LEN(S$) = 0 THENã     FileExists% =  0ã  ELSEã     FileExists% = -1ã  END IFãEND FUNCTIONã'--------------------------------------------------------------------------ãDouglas H. Lusher              80X28 TEXT MODE                FidoNet QUIK_BAS Echo          03-21-96 (16:01)       QB, PDS                30   895      80X28.BAS   ' > How can I put the screen in 80x28 textmode?ãã DEFINT A-Zã '$INCLUDE: 'qb.bi'ã DIM Reg AS RegTypeãã WIDTH , 43          'this is necessary so that BASIC will notã                     '   complain if we attempt to use theã                     '   LOCATE command on a row greater than 25ãã Reg.AX = &H1202                 'set up 400 scan linesã Reg.BX = &H30ã CALL Interrupt(&H10, Reg, Reg)ã Reg.AX = &H3                    'set up normal text modeã CALL Interrupt(&H10, Reg, Reg)ã Reg.AX = &H1111                 'load ega character set (8 x 14)ã Reg.BX = 0ã CALL Interrupt(&H10, Reg, Reg)ãã 'show that we now have 28 linesã Lines% = 28ã FOR Row% = 1 TO Lines%ã   LOCATE Row%, 1: PRINT USING "###"; Row%;ã NEXTã SLEEPã 'you can increase the value of Lines in the above loop,ã '   but you will see that only 28 appear on screenãã SCREEN 0: WIDTH 80, 25: CLSã ENDãEthan Winer                    FAST LINE INPUT REPLACEMENT    FidoNet QUIK_BAS Echo          03-24-96 (01:24)       QB, QBasic, PDS        78   3248     BUFIN.BAS   '> Has anybody else been working with or using the Bufin$ routineã'> written by Ethan Winer that was posted a few days ago as aã'> fast substitute for the LINE INPUT command? Has anyoneã'> else noticed that it returns an extra blank line at the endã'> of the file unless the final line had no carriage return/lineã'> feed at the end? Has anyone found a work-around for this bug?ã'> Thanks.ãã'No, but I would love to see the code from Bufin$, then maybe I can helpã'you out...I missed the code the first time around...! :(ããDEFINT A-ZãFUNCTION BufIn$ (FileName$, Done) STATICã'********* BUFIN.BAS - fast LINE INPUT replacementã'Copyright (c) 1992 Ethan WinerããIF NOT Reading THEN            'if the first time throughã  Reading = -1                 'show that we're now readingã  Done = 0                     'clear Done just in caseã  CR = 0                       'no return found yet.ã  CR$ = CHR$(13)               'define for speed laterãã  FileNum = FREEFILE           'open the fileã  OPEN FileName$ FOR BINARY AS #FileNumã  Remaining& = LOF(FileNum)    'byte count to be readãã  BufSize = 4096               'bytes to read each passã  Buffer$ = SPACE$(BufSize)    'assume BufSize bytesãEND IFãã'---- This is the main outer loop.ãDO WHILE Remaining&              'while more in the fileãã  IF CR = 0 THEN                 'if no Return was foundã    IF Remaining& < BufSize THEN 'read only what remainsã      BufSize = Remaining&       'resize the bufferã      IF BufSize < 1 THEN EXIT DO'possible only if EOF 26ã      Buffer$ = SPACE$(BufSize)  'create the file bufferã    END IFã    GET #FileNum, , Buffer$      'read a blockã    BufPos = 1                   'start at the beginningã  END IF                         '  of that blockãã  DO                                 'walk through bufferã    CR = INSTR(BufPos, Buffer$, CR$) 'look for a Returnã    IF CR THEN                       'we found oneã      SaveCR = CR                    'save whereã      BufIn$ = MID$(Buffer$, BufPos, CR - BufPos)ã      BufPos = CR + 2                'skip inevitable LFã      EXIT FUNCTION                  'all done for nowã    ELSE                             'back up in the fileã      '---- If we reached the end of the file and no 13ã      '     was found, return what remains in the string.ã      IF SEEK(FileNum) >= LOF(FileNum) THENã        Output$ = MID$(Buffer$, SaveCR + 2)ã        '---- Trap a trailing CHR$(26) EOF marker.ã        IF RIGHT$(Output$, 1) = CHR$(26) THENã          Output$ = LEFT$(Output$, LEN(Output$) - 1)ã        END IFã        BufIn$ = Output$             'assign the functionã        Remaining& = BufSize         'set to fall outã        EXIT DO                      'and exit nowã      END IFã      Slop = BufSize - SaveCR - 1    'calc buffer excessã      Remaining& = Remaining& + Slop 'calc file excessã      SEEK #FileNum, SEEK(FileNum) - Slop  'seek to startã    END IFãã  LOOP WHILE CR                'while more in bufferã  Remaining& = Remaining& - BufSizeããLOOPããReading = 0                    'we're not reading anymoreãDone = -1                      'show that we're all doneãCLOSE #FileNum                 'final cleanupããEND FUNCTIONãPeter Cooper                   SMOOTH VERTICAL SCROLL         comp.lang.basic.misc           04-08-96 (23:03)       QB, QBasic, PDS        46   965      SCROLLUP.BAS' There may be a small amount of flicker in some speed cases.. if you adjustã' the delay% loop in 'upwholeline' you can eliminate this.. it is set for myã' machine at the mo.. mail me  peter@trenham.demon.co.ukã' DONT EXIT BEFORE ITS FINISHED. your display will look strange , Peco_ããDEF SEG = &HB800ããSCREEN 0ãCLSãFOR a% = 1 TO 23ã        LOCATE a%ã        COLOR a% MOD 15 + 1ã        PRINT STRING$(80, CHR$(a% + 64))ãNEXT a%ããFOR a% = 1 TO 23ã        upwholelineãNEXT a%ãDEF SEGãCOLOR 15ããSUB scrollupãã' you should've seen this procedure about 10 mins ago.. it was a whole scrollã' routine using pokes etc when I realized all I had to do was this!ããLOCATE 24ãPRINTããEND SUBããSUB textvert (vpos%)ãOUT &H3D4, 8ãOUT &H3D5, vpos%ãEND SUBããSUB upwholelineãFOR a% = 0 TO 15ãWAIT &H3DA, 8ãtextvert a%ãFOR delay% = 1 TO 8500: NEXT delay%  ' this is 8500 in PDS and 7800 in QBasic for meãNEXT a%ãscrollupããtextvert 0ãEND SUBãCarl Gorringe                  GET/PUT IN TEXT                FidoNet QUIK_BAS Echo          04-10-96 (11:31)       QB, QBasic, PDS        227  7796     GETPUT.BAS  '>Is it possible to wipe from one screen to another in text mode? (Looks likeã'>one screen is raised or pulled off to the side revealing  another screenã'>underneath.)ãã'Following is a program that will allow you to GET any portion of theã'Text screen into an array, and then PUT it back anywhere on screen. Ifã'the image goes off the edge, then it is simply clipped, so I believe youã'can get the effect you are looking for by using them. Enjoy!ãã'--- Carl Gorringe --- <carl.gorringe@rhosoft.com>ãã'----------------------------------ã'  GETPUT.BAS - (c) Carl Gorringeã'----------------------------------ã' Released to the public domainã' You may use this or modify it any way you want, just rememberã'  to give me credit if you use it in your programs.ãã'---- Must Keep All of the Following! ----ããDECLARE SUB TextGetPutLoad ()ãDECLARE SUB TextGetPut (Xlen%, Ylen%, SorcSeg%, SorcOff%, SorcSkip%, DestSeg%, DestOff%, DestSkip%)ãDECLARE SUB TextGet (X1%, Y1%, X2%, Y2%, Image%())ãDECLARE SUB TextPut (X1%, Y1%, Image%())ããCOMMON SHARED TextGetPutRoutine%()ããDIM SHARED TextGetPutRoutine%(30)ãCALL TextGetPutLoadãã'--------- Begin Program ----------ãã' Put Whatever you want here.ã' Just remember that the GET/PUT routines ONLY work forã' SCREEN 0; WIDTH 80,25; and Text Page 0ã' You can switch to other modes, just don't call these routines in them.ããENDã'---------- End Program -----------ããSUB TextGet (X1%, Y1%, X2%, Y2%, Image%())ãã' ::: (c) Carl Gorringe 6/13/93 ::: << v2.1 >>ã'--------------------------------------------------------ã' This gets the text region from (X1%,Y1%) to (X2%,Y2%)ã' and stores it in Image%(). Make sure Image%() is aã' DYNAMIC array because this SUB will REDIM it.ã' Coordinates start at (1,1) for the upper-left corner.ã'--------------------------------------------------------ããScrWidth% = 80ãScrLength% = 25ããIF X1% < 1 OR X1% > X2% OR Y1% < 1 OR Y1% > Y2% THEN EXIT SUBããNum% = (X2% - X1% + 1) * (Y2% - Y1% + 1) + 1ãREDIM Image%(Num%)ããImage%(0) = X2% - X1% + 1ãImage%(1) = Y2% - Y1% + 1ãã'<*>--------- Machine Language Varibles ----------<*>ãIF X2% > ScrWidth% THENã	TableSkip% = (X2% - ScrWidth%) * 2ã	X2% = ScrWidth%ãELSEã	TableSkip% = 0ãEND IFããIF Y2% > ScrLength% THENã	Y2% = ScrLength%ãEND IFããXcount% = X2% - X1% + 1: Ycount% = Y2% - Y1% + 1ãScrStart% = (ScrWidth% * (Y1% - 1) + (X1% - 1)) * 2ãNextLine% = (ScrWidth% * 2) - (Xcount% * 2)ããPageSegment% = &HB800    '-- Screen 0, Page 0 --ãTableSegment% = VARSEG(Image%(0))ãTableOffset% = VARPTR(Image%(0)) + 4ããCALL TextGetPut(Xcount%, Ycount%, PageSegment%, ScrStart%, NextLine%, TableSegment%, TableOffset%, TableSkip%)ããEND SUBããSUB TextGetPut (Xlen%, Ylen%, SorcSeg%, SorcOff%, SorcSkip%, DestSeg%, DestOff%, DestSkip%)ãã' ::: (c) Carl Gorringe 6/13/93 ::: << v1.3 >>ã'--------------------------------------------------------ã' This Should NOT be Used by itself!ã' It should ONLY be used within TextGet() and TextPut()!ã'--------------------------------------------------------ããIF TextGetPutRoutine%(0) <> &HBB06 THENã	CALL TextGetPutLoadãEND IFãã'<*>------- Pass Machine Language Arguments -------<*>ããLow% = LBOUND(TextGetPutRoutine%)ãDEF SEG = VARSEG(TextGetPutRoutine%(Low%))   '--Set Segment--ãP% = VARPTR(TextGetPutRoutine%(Low%))        '--Set Offset--ããPOKE (P% + &H2), ASC(LEFT$(MKI$(SorcSeg%), 1))ãPOKE (P% + &H3), ASC(RIGHT$(MKI$(SorcSeg%), 1))ããPOKE (P% + &H5), ASC(LEFT$(MKI$(DestSeg%), 1))ãPOKE (P% + &H6), ASC(RIGHT$(MKI$(DestSeg%), 1))ããPOKE (P% + &H8), ASC(LEFT$(MKI$(DestOff%), 1))ãPOKE (P% + &H9), ASC(RIGHT$(MKI$(DestOff%), 1))ããPOKE (P% + &HB), ASC(LEFT$(MKI$(SorcOff%), 1))ãPOKE (P% + &HC), ASC(RIGHT$(MKI$(SorcOff%), 1))ããPOKE (P% + &HE), ASC(LEFT$(MKI$(Ylen%), 1))ãPOKE (P% + &H10), ASC(LEFT$(MKI$(Xlen%), 1))ããPOKE (P% + &H26), ASC(LEFT$(MKI$(SorcSkip%), 1))ãPOKE (P% + &H27), ASC(RIGHT$(MKI$(SorcSkip%), 1))ããPOKE (P% + &H2B), ASC(LEFT$(MKI$(DestSkip%), 1))ãPOKE (P% + &H2C), ASC(RIGHT$(MKI$(DestSkip%), 1))ãã'<*>--------- Run Machine Language Routine ---------<*>ããCALL ABSOLUTE(P%)ããDEF SEGããEND SUBããSUB TextGetPutLoadãã' ::: (c) Carl Gorringe 6/13/93 ::: << v1.0 >>ã'--------------------------------------------------------ã' This only needs to be called once in the beginning of theã' program to store the Assembly language code into theã' global array TextGetPutRoutine%().ã'--------------------------------------------------------ããLow% = LBOUND(TextGetPutRoutine%)ãDEF SEG = VARSEG(TextGetPutRoutine%(Low%))   '--Set Segment--ãP% = VARPTR(TextGetPutRoutine%(Low%))        '--Set Offset--ãã'<*>------ Start Assembly Language Code ------<*>ã'         --- 41 bytes long ---ããPOKE (P% + &H0), &H6                              '  Push ESãPOKE (P% + &H1), &HBB                             '  Mov  BX , ????ãPOKE (P% + &H4), &HBA                             '  Mov  DX , ????ãPOKE (P% + &H7), &HBF                             '  Mov  DI , ????ãPOKE (P% + &HA), &HBE                             '  Mov  SI , ????ãPOKE (P% + &HD), &HB5                             '  Mov  CH , ??ãPOKE (P% + &HF), &HB1                             '  Mov  CL , ??ãPOKE (P% + &H11), &H8E: POKE (P% + &H12), &HC3    '  Mov  ES , BXãPOKE (P% + &H13), &H26                            ' ES:ãPOKE (P% + &H14), &H8B: POKE (P% + &H15), &H4     '  Mov  AX ,[SI]ãPOKE (P% + &H16), &H8E: POKE (P% + &H17), &HC2    '  Mov  ES , DXãPOKE (P% + &H18), &H26                            ' ES:ãPOKE (P% + &H19), &H89: POKE (P% + &H1A), &H5     '  Mov [DI], AXãPOKE (P% + &H1B), &H83: POKE (P% + &H1C), &HC6    '  Add  SI ,+02ã	POKE (P% + &H1D), &H2ãPOKE (P% + &H1E), &H83: POKE (P% + &H1F), &HC7    '  Add  DI ,+02ã	POKE (P% + &H20), &H2ãPOKE (P% + &H21), &HFE: POKE (P% + &H22), &HC9    '  Dec  CLãPOKE (P% + &H23), &H75: POKE (P% + &H24), &HEC    '  Jnz  &H11ãPOKE (P% + &H25), &HB8                            '  Mov  AX , ????ãPOKE (P% + &H28), &H1: POKE (P% + &H29), &HC6     '  Add  SI , AXãPOKE (P% + &H2A), &HB8                            '  Mov  AX , ????ãPOKE (P% + &H2D), &H1: POKE (P% + &H2E), &HC7     '  Add  DI , AXãPOKE (P% + &H2F), &HFE: POKE (P% + &H30), &HCD    '  Dec  CHãPOKE (P% + &H31), &H75: POKE (P% + &H32), &HDC    '  Jnz  &HFãPOKE (P% + &H33), &H7                             '  Pop  ESãPOKE (P% + &H34), &HCB                            '  Retfãã'--------------------------------ãDEF SEGããEND SUBããSUB TextPut (X1%, Y1%, Image%())ãã' ::: (c) Carl Gorringe 6/13/93 ::: << v2.1 >>ã'--------------------------------------------------------ã' This puts the image stored in Image%() back to the screenã' with the upper-left corner of the image at (X1%,Y1%).ã' Coordinates start at (1,1) for the upper-left corner ofã' the screen. If the image goes outside of bounds then itã' will be automatically clipped.ã'--------------------------------------------------------ããScrWidth% = 80ãScrLength% = 25ããX2% = Image%(0) - 1 + X1%ãY2% = Image%(1) - 1 + Y1%ããIF X1% < 1 OR X1% > X2% OR Y1% < 1 OR Y1% > Y2% THEN EXIT SUBããNum% = (X2% - X1% + 1) * (Y2% - Y1% + 1) + 1ãã'<*>--------- Machine Language Varibles ----------<*>ããIF X2% > ScrWidth% THENã	TableSkip% = (X2% - ScrWidth%) * 2ã	X2% = ScrWidth%ãELSEã	TableSkip% = 0ãEND IFããIF Y2% > ScrLength% THENã	Y2% = ScrLength%ãEND IFããXcount% = X2% - X1% + 1: Ycount% = Y2% - Y1% + 1ãScrStart% = (ScrWidth% * (Y1% - 1) + (X1% - 1)) * 2ãNextLine% = (ScrWidth% * 2) - (Xcount% * 2)ããPageSegment% = &HB800    '-- Screen 0, Page 0 --ãTableSegment% = VARSEG(Image%(0))ãTableOffset% = VARPTR(Image%(0)) + 4ããCALL TextGetPut(Xcount%, Ycount%, TableSegment%, TableOffset%, TableSkip%, PageSegment%, ScrStart%, NextLine%)ããEND SUBããDouglas H. Lusher              TEXT EDITOR                    FidoNet QUIK_BAS Echo          03-11-96 (01:10)       QB, PDS                1214 35257    EDITOR.BAS  'A few comments are called for, in no particular order:ã'1) this text editor works by loading a file into a string arrayã'and allowing the user to manipulate it there. The limit on fileã'size, then, is the amount of string memory available. In compiledã'form, this will be about 57K. Run in the environment, this willã'be about 40K. I have worked quite hard to prevent "Out of memory"ã'errors from crashing the program, but it may not beã'quite perfect yet. You will note a variable named "MemPad"ã'at various places in the code. The program always leaves aã'small amount of memory free for use by QB's built-in routines.ã'I am working on an editor that will handle much larger fileã'sizes, but that code is still very buggy and I will notã'inflict my buggy code on the world.ãã'2) when compiled as-is for a stand-alone text editor, it willã'produce about a 56K file. I am working on eliminating all useã'of the LINE INPUT command, and when successful, the compiledã'size should go down about 10K because the floating point emula-ã'tion routines will no longer be linked in.ãã'3) please understand that I wrote this editor for my own use.ã'I needed something for doing mail, small batch files, etc. Iã'don't have very much money, so I didn't want to buy something.ã'For a while I was using TED, the editor from PC magazine, butã'I do so much of my work in QB and am so accustomed to the wayã'the QB editor works that I found using TED to be quite annoying.ã'My fingers just naturally wanted to go where they were accustommedã'to for QB. So finally, fancying myself a moderately competentã'programmer, I decided to write an editor for myself that workedã'like QB's. This code is the result. I will listen to suggestionsã'for improvement, but please understand that I will make onlyã'such changes as suit *me*. If you want it to work differently,ã'you'll have to rework the code to suit yourself. (Bug reports,ã'of course, are always welcome.)ãã'4) There are, unfortunately, a dearth of comments, remarks, andã'explanations in the code. I'm sorry. I have worked for quite aã'while on this code and it is very familiar to me, so commentsã'were just getting in my way. And I have done everything possibleã'to give names to variables and procedures that make clear theirã'purpose in the code. I fancy the code is quite readable withoutã'many comments, but then, as I said, I'm very familiar with it,ã'so I'm probably not a good judge.ãã'5) The whole trick to doing a text editor is that there are twoã'things that you must keep track of: the location of the cursorã'on the screen, and the location of where you are in the file.ã'Variables having to do with locations on the screen are givenã'names that contain "Row" or "Col" depending on whether theyã'refer to a row or a column on the screen. Variables with namesã'containing "Ln" or "Line" have to do with the lines in theã'file (the same as the elements of the string array which containã'the text). Variables whose names contain "Char" refer toã'character positions in the lines of the text. CursRow%, CursCol%ã'are the current location of the cursor on the screen. ActLn%ã'is the line being edited. ActChar% is the character within thatã'line where editing is taking place. Note that the active lineã'is copied to a scalar string variable (named ActLn$) for speedã'and ease of reference. Variable names that containã'the letters "Ptr" are just generic pointers to lines orã'characters. Hopefully, this information will help you to followã'the flow of the code.ã'   These variables control how much of the screen the editorã'covers:ã'  TopRow% = 1: BotRow% = 25: LeftCol% = 1: RiteCol% = 80ã'these values, of course, make it take the whole screen. Simplyã'by changing these values you can edit text on only part of theã'screen if you wish. Note, however, that code assumes thatã'dialog boxes can be centered in the editing area of the screen.ã'If the screen window for editing is made too small, the dialogã'boxes will be chopped off. So if you want a very small editingã'area, you will have to rework that part of the code. As written,ã'the screen window must be at least 72 columns wide and theã'total number of screen rows should not be less than 3.ã'Oh, and when you shell out to DOS, it automatically takes theã'whole screen, so changes would have to be made there as well.ãã'6) You can load a file from the command line or from withinã'the editor. Enter text from the keyboard. The arrow keysã'move the cursor from line to line or character toã'character. Home takes the cursor to the begining of theã'current line, the End key takes it to the end.ã'PageUp and PageDn move the cursor the number of lines in theã'editing window. Control+Home takes you to the beginning of theã'file, Control+End takes you to the end. To mark a block, holdã'down a shift key and use the above listed keys to move the cursorã'as desired. When a block is marked, you can delete it using theã'delete key, or Shift+delete deletes it and moves it to theã'clipboard. Text in the clipboard can be inserted anywhere usingã'Shift+Insert. If a block is marked, it can be printed byã'pressing Alt+P. A marked block can be saved to a file byã'pressing Alt+S. When no block is marked, pressing Alt+Sã'saves the entire file to disk. Pressing Alt+L allows you toã'load a file into the editor. Alt+F allows you to search forã'text in the file. Alt+R displays a ruler on the screen that youã'can move up and down using the arrow keys. Pressing F10 willã'shell you out to DOS. F1 is the help key, for what it's worth.ã'Use Alt+X or Alt+Q to quit. Alt+X assumes you will want toã'save the file, while Alt+Q gives you the option of exitingã'without saving the changes you made. I forgot to mentionã'the Tab key and the Backspace key, they both work. The insertã'key toggles you between insert mode and overstrike mode. Whenã'there is a dialog box on screen, you can abort and return toã'the editor by pressing Escape.ãã'code for a text editor, written completely in QuickBASIC 4.5ã'by Douglas H. Lusher, 03-11-1996ãDEFINT A-Zã'$INCLUDE: 'qb.bi'ãCONST False = 0, True = NOT FalseãCONST Black = 0, Blue = 1, Brown = 6, Grey = 7ãCONST AltF = -33, AltL = -38, AltP = -25, AltQ = -16ãCONST AltR = -19, AltS = -31, AltX = -45ãCONST ESC = 27, ENTER = 13, BkSpc = 8, TabKey = 9ãCONST F1Key = -59, F10Key = -68ãCONST InsertKey = -82, DeleteKey = -83ãCONST HomeKey = -71, CtrlHome = -119ãCONST EndKey = -79, CtrlEnd = -117ãCONST PgUpKey = -73, PgDnKey = -81ãCONST UpArrow = -72, DnArrow = -80, LArrow = -75, RArrow = -77ããDIM SHARED TopRow%, BotRow%, LeftCol%, RiteCol%ãDIM SHARED ScrnRows%, MidRow%, ScrnWidth%ãDIM SHARED FirstLn%, LastLn%, MaxLines%, FirstChar%, MaxChars%ãDIM SHARED CursRow%, CursCol%, ActLn%, ActChar%ãDIM SHARED FG%, BG%, BoxFG%, BoxBG%ãDIM SHARED CursSize%, TabLen%, MemPad%, Null$ããTopRow% = 1: BotRow% = 25: LeftCol% = 1: RiteCol% = 80ãScrnRows% = (BotRow% - TopRow%) + 1ãMidRow% = TopRow% + (ScrnRows% \ 2)ãScrnWidth% = (RiteCol% - LeftCol%) + 1ããFirstLn% = 1: LastLn% = 0: MaxLines% = 800ãFirstChar% = 1: MaxChars% = 255ããCursRow% = TopRow%: CursCol% = LeftCol%ãActLn% = FirstLn%: ActChar% = FirstChar%ããFG% = Grey: BG% = Black: BoxFG% = Grey: BoxBG% = BrownãIF ColorMonitor% THENã  CursSize% = 12: BG% = BlueãELSEã  CursSize% = 7ãEND IFãTabLen% = 8: Null$ = "": MemPad% = 1024ããDIM Text$(FirstLn% TO MaxLines% + 1)ãã Cmd$ = RTRIM$(COMMAND$)ã Ptr% = INSTR(Cmd$, "/L:")ã IF Ptr% THENã   Ptr2% = INSTR(Ptr% + 3, Cmd$, " ")ã   IF Ptr2% THENã	L$ = MID$(Cmd$, Ptr% + 3, Ptr2% - (Ptr% + 3))ã	IF LEN(L$) THEN MaxLines% = VAL(L$)ã	Cmd$ = MID$(Cmd$, 1, Ptr% - 1) + MID$(Cmd$, Ptr2% + 1)ã   ELSEã	L$ = MID$(Cmd$, Ptr% + 3)ã	IF LEN(L$) THEN MaxLines% = VAL(L$)ã	Cmd$ = RTRIM$(MID$(Cmd$, 1, Ptr% - 1))ã   END IFã END IFã File$ = Cmd$ã IF INSTR(File$, "*") OR INSTR(File$, "?") THENã   BEEP: PRINT "No wildcards allowed in file specification": ENDã END IFããIF LEN(File$) THENã  IF FileExists(File$) THENã    File = FREEFILEã    OPEN File$ FOR INPUT AS Fileã	 IF LOF(File) THENã	   LnPtr% = 0ã	   DO UNTIL EOF(File)ã		LnPtr% = LnPtr% + 1ã		IF LnPtr% > MaxLines% THENã		  BEEP: PRINT "File has too many lines"ã		  CLOSE File: ENDã		END IFã		LINE INPUT #File, Text$(LnPtr%)ã		CALL Filter(Text$(LnPtr%))ã		IF FRE(Null$) < MemPad% THENã		  BEEP: PRINT "Not enough memory"ã		  CLOSE File: ENDã		END IFã	   LOOPã	   LastLn% = LnPtr%ã	 END IFã    CLOSE Fileã  ELSEã    IF NOT LegalFileName(File$) THENã	 BEEP: PRINT "Bad file name": ENDã    END IFã  END IFãEND IFããSCREEN 0, 1, 0: WIDTH 80ãCOLOR FG%, BG%, BG%: CLSããFileChanged% = FalseãDOãCALL Edit(Text$(), ExitKey%, FileChanged%)ãSELECT CASE ExitKey%ã  CASE AltSã    IF FileChanged% THENã	 IF LEN(File$) THENã	   GOSUB SaveFileã	 ELSEã	   GOSUB GetFileNameã	   IF KeyCode% = ENTER THEN GOSUB SaveFileã	 END IFã    END IFã  CASE AltQã    IF FileChanged% THENã	 CALL MsgBox("Save file changes? (Y/N) ", "YyNn", KeyCode%)ã	 SELECT CASE KeyCode%ã	   CASE 89, 121                  '"Y", "y"ã		IF LEN(File$) THENã		  GOSUB SaveFileã		ELSEã		  GOSUB GetFileNameã		  IF KeyCode% = ENTER THEN GOSUB SaveFile: EXIT DOã		END IFã	   CASE 78, 110                  '"N", "n"ã		EXIT DOã	   CASE ESCã		'do nothing to return to edit modeã	 END SELECTã    ELSEã	 EXIT DOã    END IFã  CASE AltXã    IF FileChanged% THENã	 GOSUB GetFileNameã	 IF KeyCode% = ENTER THEN GOSUB SaveFile: EXIT DOã    ELSEã	 EXIT DOã    END IFãEND SELECTãLOOPãCLS : ENDããGetFileName:ãDOã  CALL InputBox("File name: ", File$, KeyCode%)ã  IF KeyCode% = ENTER THENã    IF LegalFileName(File$) THEN EXIT DO ELSE BEEPã  ELSE 'IF KeyCode% = ESC THENã    EXIT DOã  END IFãLOOPãRETURNããSaveFile:ãFile = FREEFILEãOPEN File$ FOR OUTPUT AS Fileã  IF LastLn% > 0 THENã    FOR LnPtr% = FirstLn% TO LastLn%ã	 PRINT #File, Text$(LnPtr%)ã    NEXTã  END IFãCLOSE FileãFileChanged% = FalseãRETURNããFUNCTION ColorMonitor%ãColorMonitor% = TrueãDEF SEG = 0ãIF PEEK(&H463) <> &HD4 THEN ColorMonitor% = FalseãDEF SEGãEND FUNCTIONããSUB DrawBox (TopRow%, NumRows%, LCol%, NumCols%)ããTop$ = STRING$(NumCols%, "Í")ãMID$(Top$, 1, 2) = " É": MID$(Top$, NumCols% - 1, 2) = "» "ãSide$ = SPACE$(NumCols%)ãMID$(Side$, 1, 2) = " º": MID$(Side$, NumCols% - 1, 2) = "º "ãBot$ = Top$ãMID$(Bot$, 2, 1) = "È": MID$(Bot$, NumCols% - 1, 1) = "¼"ããLOCATE TopRow%, LCol%, 0: PRINT Top$ãFOR Row% = 3 TO NumRows%ã  LOCATE , LCol%: PRINT Side$ãNEXTãLOCATE , LCol%: PRINT Bot$;ããEND SUBããSUB Edit (Text$(), KeyCode%, FileChanged%)ã'code for a text editor, written completely in QuickBASIC 4.5ã'by Douglas H. Lusher, 03-11-1996ãã'when marking a block involving multiple lines:ãBlkStartLn = 0        'is the starting line of the blockãBlkLines = 0          'the number of lines in the block.ã				  'If zero, then not in this block marking modeãã'when marking a block of characters within a single line:ãBlkStartChar = 0      'this is the starting characterãBlkChars = 0          'the number of characters in the block.ã				  'If zero, then not in this block marking modeããRefresh$ = SPACE$(ScrnWidth)       'scratch spaceãInsertMode = TrueãLOCATE , , 0, CursSize - 1, CursSizeãGOSUB RefreshScreenãDOã  ActLn$ = Text$(ActLn): ActLnLen = LEN(ActLn$)ã  LOCATE CursRow, CursCol, 1ã  DO WHILE LEN(INKEY$): LOOPã  DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)ã  DEF SEG = 0: ShiftByte = PEEK(&H417): DEF SEGã  ShiftPressed = ((ShiftByte AND 3) <> 0)ã  KeyCode = ASC(Ky$): IF KeyCode = 0 THEN KeyCode = -ASC(MID$(Ky$, 2))ã  SELECT CASE KeyCodeã    CASE 32 TO 255, 1 TO 6, 14 TO 27: GOSUB DoLetterKeyã    CASE BkSpc: GOSUB DoBackSpaceKeyã    CASE TabKey: GOSUB DoTabKeyã    CASE ENTER: GOSUB DoCarriageReturnã    CASE InsertKey: GOSUB DoInsertKeyã    CASE DeleteKey: GOSUB DoDeleteKeyã    CASE UpArrow: GOSUB DoUpArrowã    CASE DnArrow: GOSUB DoDnArrowã    CASE PgUpKey: GOSUB DoPgUpKeyã    CASE PgDnKey: GOSUB DoPgDnKeyã    CASE LArrow: GOSUB DoLArrowã    CASE RArrow: GOSUB DoRArrowã    CASE HomeKey: GOSUB DoHomeKeyã    CASE EndKey: GOSUB DoEndKeyã    CASE CtrlHome: GOSUB DoCtrlHomeã    CASE CtrlEnd: GOSUB DoCtrlEndã    CASE F1Key: GOSUB DoHelpã    CASE F10Key: CLS : SHELL: GOSUB RefreshScreenã    CASE AltF: GOSUB FindTextã    CASE AltL: GOSUB LoadFileã    CASE AltP: GOSUB DoPrintã    CASE AltR: GOSUB DoRulerã    CASE AltS: IF BlkLines THEN GOSUB SaveLines ELSE EXIT DOã    CASE AltQ, AltX: EXIT DOã    CASE ELSE: BEEPã  END SELECTãLOOPããEXIT SUBããDoCarriageReturn:ãIF BlkLines OR BlkChars THEN BEEP: RETURNãIF LastLn = MaxLines THEN BEEP: RETURNãIF ActLn < LastLn THENã  FOR LnPtr = LastLn TO ActLn + 1 STEP -1ã    SWAP Text$(LnPtr), Text$(LnPtr + 1)ã  NEXTã  Text$(ActLn) = LEFT$(ActLn$, ActChar - 1)ã  Text$(ActLn + 1) = MID$(ActLn$, ActChar)ãEND IFãActLn = ActLn + 1ãActChar = FirstCharãIF CursRow <> BotRow THEN CursRow = CursRow + 1ãCursCol = LeftColãLastLn = LastLn + 1ãGOSUB RefreshScreenãFileChanged = TrueãRETURNããDoTabKey:ãIF BlkLines OR BlkChars THEN BEEP: RETURNãIF ActLn > MaxLines THEN BEEP: RETURNãTabChars = TabLen - (ActChar MOD TabLen)ãIF ActLnLen + TabChars > MaxChars THEN BEEP: RETURNãIF ActChar - 1 + TabChars > MaxChars THEN BEEP: RETURNãIF ActChar <= ActLnLen THENã  Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + SPACE$(TabChars) + MID$(ActLn$, ActChar)ãELSEã  Text$(ActLn) = ActLn$ + SPACE$((ActChar - ActLnLen - 1) + TabChars)ãEND IFãActChar = ActChar + TabCharsãIF CursCol + TabChars <= RiteCol THENã  CursCol = CursCol + TabCharsã  GOSUB RefreshLineãELSEã  GOSUB RefreshScreenãEND IFãIF ActLn > LastLn THEN LastLn = ActLnãFileChanged = TrueãRETURNããDoDeleteKey:ãIF BlkLines THENã  IF BlkLines > 0 THENã    ActLn = BlkStartLnã    CursRow = Greater(CursRow - BlkLines, TopRow)ã  END IFã  ClipLines = ABS(BlkLines)ã  BytesNeeded& = 0ã  FOR LnPtr = ActLn TO ActLn + ClipLines - 1ã    BytesNeeded& = BytesNeeded& + LEN(Text$(LnPtr)) + 6ã  NEXTã  IF BytesNeeded& + MemPad > FRE(Null$) THEN ClipLines = 0: BEEP: RETURNã  REDIM ClipBoard$(ClipLines - 1)ã  FOR LnPtr = 0 TO ClipLines - 1ã    SWAP ClipBoard$(LnPtr), Text$(ActLn + LnPtr)ã  NEXTã  FOR LnPtr = ActLn TO LastLn - ClipLinesã    SWAP Text$(LnPtr), Text$(LnPtr + ClipLines)ã  NEXTã  BlkLines = 0: ClipChars = 0ã  LastLn = LastLn - ClipLinesã  IF NOT ShiftPressed THEN ClipLines = 0: ERASE ClipBoard$ã  GOSUB RefreshScreenãELSEIF BlkChars THENã  IF BlkChars > 0 THENã    ActChar = BlkStartCharã    CursCol = Greater(CursCol - BlkChars, LeftCol)ã  END IFã  ClipChars = ABS(BlkChars)ã  ClipBoard$ = MID$(ActLn$, ActChar, ClipChars)ã  Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + MID$(ActLn$, ActChar + ClipChars)ã  BlkChars = 0: ClipLines = 0ã  IF NOT ShiftPressed THEN ClipChars = 0: ClipBoard$ = Null$ã  GOSUB RefreshScreenãELSE 'no blocks markedã  IF ShiftPressed THEN BEEP: RETURNã  IF ActChar <= ActLnLen THENã    Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + MID$(ActLn$, ActChar + 1)ã    GOSUB RefreshLineã  ELSE 'IF ActChar > ActLnLen THENã    IF ActLn >= LastLn THEN BEEP: RETURNã    IF ActChar > MaxChars THEN BEEP: RETURNã    IF (ActChar - 1) + LEN(Text$(ActLn + 1)) > MaxChars THEN BEEP: RETURNã    Text$(ActLn) = ActLn$ + SPACE$(ActChar - ActLnLen - 1) + Text$(ActLn + 1)ã    Text$(ActLn + 1) = Null$ã    FOR LnPtr = ActLn + 1 TO LastLnã	 SWAP Text$(LnPtr), Text$(LnPtr + 1)ã    NEXTã    LastLn = LastLn - 1ã    GOSUB RefreshScreenã  END IFãEND IFãFileChanged = TrueãRETURNããDoInsertKey:ãIF ShiftPressed THENã  IF ClipLines THENã    IF LastLn + ClipLines > MaxLines THEN BEEP: RETURNã    BytesNeeded& = 0ã    FOR LnPtr = 0 TO ClipLines - 1ã	 BytesNeeded& = BytesNeeded& + LEN(ClipBoard$(LnPtr))ã    NEXTã    IF BytesNeeded& + MemPad > FRE(Null$) THEN BEEP: RETURNã    IF ActLn <= LastLn THENã	 FOR LnPtr = LastLn TO ActLn STEP -1ã	   SWAP Text$(LnPtr), Text$(LnPtr + ClipLines)ã	 NEXTã    END IFã    FOR LnPtr = 0 TO ClipLines - 1ã	 Text$(ActLn + LnPtr) = ClipBoard$(LnPtr)ã    NEXTã    LastLn = LastLn + ClipLinesã    GOSUB RefreshScreenã    FileChanged = Trueã  ELSEIF ClipChars THENã    IF ActLn > MaxLines THEN BEEP: RETURNã    IF ActLnLen + ClipChars > MaxChars THEN BEEP: RETURNã    IF ActChar + ClipChars - 1 > MaxChars THEN BEEP: RETURNã    IF ActChar <= ActLnLen THENã	 Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + ClipBoard$ + MID$(ActLn$, ActChar)ã    ELSEã	 Text$(ActLn) = ActLn$ + SPACE$(ActChar - ActLnLen - 1) + ClipBoard$ã    END IFã    IF ActLn > LastLn THEN LastLn = ActLnã    GOSUB RefreshLineã    FileChanged = Trueã  END IFãELSE 'IF NOT ShiftPressed THENã  InsertMode = NOT InsertModeã  IF InsertMode THENã    LOCATE , , , CursSize - 1, CursSizeã  ELSEã    LOCATE , , , CursSize \ 2, CursSizeã  END IFãEND IFãRETURNããDoBackSpaceKey:ãIF BlkLines OR BlkChars THEN BEEP: RETURNãIF ActChar = FirstChar THENã  IF ActLn = FirstLn THEN BEEP: RETURNã  IF ActLnLen + LEN(Text$(ActLn - 1)) > MaxChars THEN BEEP: RETURNã  ActChar = LEN(Text$(ActLn - 1)) + 1ã  Text$(ActLn - 1) = Text$(ActLn - 1) + ActLn$ã  Text$(ActLn) = Null$ã  FOR LnPtr = ActLn TO LastLnã    SWAP Text$(LnPtr), Text$(LnPtr + 1)ã  NEXTã  IF LastLn >= ActLn THEN LastLn = LastLn - 1ã  ActLn = ActLn - 1ã  IF CursRow <> TopRow THEN CursRow = CursRow - 1ã  CursCol = Lesser(ActChar, RiteCol)ã  GOSUB RefreshScreenãELSE 'IF ActChar > FirstChar THENã  IF ActChar <= ActLnLen + 1 THENã    Text$(ActLn) = LEFT$(ActLn$, ActChar - 2) + MID$(ActLn$, ActChar)ã  END IFã  ActChar = ActChar - 1ã  IF CursCol <> LeftCol THENã    CursCol = CursCol - 1ã    GOSUB RefreshLineã  ELSEã    GOSUB RefreshScreenã  END IFãEND IFãFileChanged = TrueãRETURNããDoLetterKey:ãIF BlkLines OR BlkChars THEN BEEP: RETURNãIF ActLn > MaxLines THEN BEEP: RETURNãIF ActChar > MaxChars THEN BEEP: RETURNãIF ActChar <= ActLnLen THENã  IF InsertMode THENã    IF ActLnLen = MaxChars THEN BEEP: RETURNã    Text$(ActLn) = LEFT$(ActLn$, ActChar - 1) + " " + MID$(ActLn$, ActChar)ã  END IFã  MID$(Text$(ActLn), ActChar) = Ky$ãELSE 'IF ActChar > ActLnLen THENã  Text$(ActLn) = ActLn$ + SPACE$(ActChar - ActLnLen - 1) + Ky$ãEND IFãActChar = ActChar + 1ãIF CursCol <> RiteCol THENã  CursCol = CursCol + 1ã  GOSUB RefreshLineãELSEã  GOSUB RefreshScreenãEND IFãIF ActLn > LastLn THEN LastLn = ActLnãFileChanged = TrueãRETURNããDoUpArrow:ãBlkChars = 0ãIF ShiftPressed THENã  IF BlkLines = 0 THEN BlkStartLn = ActLnã  IF ActLn > FirstLn THEN BlkLines = BlkLines - 1ãELSEã  BlkLines = 0ãEND IFãIF ActLn <> FirstLn THENã  ActLn = ActLn - 1ã  IF CursRow <> TopRow THEN CursRow = CursRow - 1ãEND IFãGOSUB RefreshScreenãRETURNããDoDnArrow:ãBlkChars = 0ãIF ShiftPressed THENã  IF BlkLines = 0 THEN BlkStartLn = ActLnã  IF ActLn <= LastLn THEN BlkLines = BlkLines + 1ãELSEã  BlkLines = 0ãEND IFãIF ActLn <= LastLn THENã  ActLn = ActLn + 1ã  IF CursRow <> BotRow THEN CursRow = CursRow + 1ãEND IFãGOSUB RefreshScreenãRETURNããDoPgUpKey:ãBlkChars = 0ãIF ShiftPressed THENã  IF BlkLines = 0 THEN BlkStartLn = ActLnã  BlkLines = Greater(BlkLines - ScrnRows, FirstLn - BlkStartLn)ãELSEã  BlkLines = 0ãEND IFãActLn = Greater(ActLn - ScrnRows, FirstLn)ãIF ActLn < CursRow THEN CursRow = TopRow + ActLn - 1ãGOSUB RefreshScreenãRETURNããDoPgDnKey:ãBlkChars = 0ãIF ShiftPressed THENã  IF BlkLines = 0 THEN BlkStartLn = ActLnã  BlkLines = Lesser(BlkLines + ScrnRows, (LastLn + 1) - BlkStartLn)ãELSEã  BlkLines = 0ãEND IFãActLn = Lesser(ActLn + ScrnRows, LastLn + 1)ãIF (LastLn + 1) - ActLn < BotRow - CursRow THENã  CursRow = Lesser(BotRow - ((LastLn + 1) - ActLn), TopRow + LastLn)ãEND IFãGOSUB RefreshScreenãRETURNããDoLArrow:ãIF ShiftPressed THENã  IF BlkLines THEN BEEP: RETURNã  IF BlkChars = 0 THEN BlkStartChar = ActCharã  BlkChars = Greater(BlkChars - 1, FirstChar - BlkStartChar)ãELSEã  BlkLines = 0: BlkChars = 0ãEND IFãIF ActChar <> FirstChar THENã  ActChar = ActChar - 1ã  IF CursCol <> LeftCol THEN CursCol = CursCol - 1ãEND IFãGOSUB RefreshScreenãRETURNããDoRArrow:ãIF ShiftPressed THENã  IF BlkLines THEN BEEP: RETURNã  IF BlkChars = 0 THEN BlkStartChar = ActCharã  IF ActChar <= MaxChars THEN BlkChars = BlkChars + 1ãELSEã  BlkLines = 0: BlkChars = 0ãEND IFãIF ActChar <= MaxChars THENã  ActChar = ActChar + 1ã  IF CursCol <> RiteCol THEN CursCol = CursCol + 1ãEND IFãGOSUB RefreshScreenãRETURNããDoHomeKey:ãIF ShiftPressed THENã  IF BlkLines THEN BEEP: RETURNã  IF BlkChars = 0 THEN BlkStartChar = ActCharã  BlkChars = FirstChar - BlkStartCharãELSEã  BlkLines = 0: BlkChars = 0ãEND IFãActChar = FirstCharãCursCol = LeftColãGOSUB RefreshScreenãRETURNããDoEndKey:ãIF ShiftPressed THENã  IF BlkLines THEN BEEP: RETURNã  IF BlkChars = 0 THEN BlkStartChar = ActCharã  BlkChars = (ActLnLen + 1) - BlkStartCharãELSEã  BlkLines = 0: BlkChars = 0ãEND IFãLeftChar = ActChar - CursCol + 1ãActChar = ActLnLen + 1ãIF ActChar <= LeftChar THENã  CursCol = Lesser(ActChar, RiteCol)ãELSEã  CursCol = Lesser(ActChar - LeftChar + 1, RiteCol)ãEND IFãGOSUB RefreshScreenãRETURNããDoCtrlHome:ãBlkChars = 0ãIF ShiftPressed THENã  IF BlkLines = 0 THEN BlkStartLn = ActLnã  BlkLines = FirstLn - BlkStartLnãELSEã  BlkLines = 0ãEND IFãActLn = FirstLnãCursRow = TopRowãGOSUB RefreshScreenãRETURNããDoCtrlEnd:ãBlkChars = 0ãIF ShiftPressed THENã  IF BlkLines = 0 THEN BlkStartLn = ActLnã  BlkLines = (LastLn + 1) - BlkStartLnãELSEã  BlkLines = 0ãEND IFãActLn = LastLn + 1ãCursRow = Lesser(BotRow, TopRow + LastLn)ãGOSUB RefreshScreenãRETURNããRefreshScreen:ãLOCATE , , 0ãLnPtr = ActLn - (CursRow - TopRow)ãCharPtr = ActChar - (CursCol - LeftCol)ãIF BlkLines THENã  StartLn = BlkStartLn: StopLn = BlkStartLn + BlkLinesã  IF StartLn > StopLn THEN SWAP StartLn, StopLnã  FOR Row = TopRow TO BotRowã    LSET Refresh$ = MID$(Text$(LnPtr), CharPtr, ScrnWidth)ã    LOCATE Row, LeftColã    IF LnPtr >= StartLn AND LnPtr < StopLn THENã	 COLOR BG, FG: PRINT Refresh$; : COLOR FG, BGã    ELSEã	 PRINT Refresh$;ã    END IFã    LnPtr = LnPtr + 1ã  NEXTãELSEIF BlkChars THENã  StartChar = BlkStartChar: StopChar = BlkStartChar + BlkCharsã  IF StartChar > StopChar THEN SWAP StartChar, StopCharã  LCol = Greater(StartChar - CharPtr, 0)ã  RCol = StopChar - CharPtrã  FOR Row = TopRow TO BotRowã    LSET Refresh$ = MID$(Text$(LnPtr), CharPtr, ScrnWidth)ã    LOCATE Row, LeftColã    IF LnPtr = ActLn THENã	 PRINT LEFT$(Refresh$, LCol);ã	 COLOR BG, FGã	 PRINT MID$(Refresh$, LCol + 1, RCol - LCol);ã	 COLOR FG, BGã	 PRINT MID$(Refresh$, RCol + 1);ã    ELSEã	 PRINT Refresh$;ã    END IFã    LnPtr = LnPtr + 1ã  NEXTãELSEã  FOR Row = TopRow TO BotRowã    LSET Refresh$ = MID$(Text$(LnPtr), CharPtr, ScrnWidth)ã    LOCATE Row, LeftColã    PRINT Refresh$;ã    LnPtr = LnPtr + 1ã  NEXTãEND IFãRETURNããRefreshLine:ãLSET Refresh$ = MID$(Text$(ActLn), ActChar - CursCol + LeftCol, ScrnWidth)ãLOCATE CursRow, LeftCol, 0ãIF BlkChars THENã  StartChar = BlkStartChar: StopChar = BlkStartChar + BlkCharsã  IF StartChar > StopChar THEN SWAP StartChar, StopCharã  LCol = Greater(StartChar - CharPtr, 0)ã  RCol = StopChar - CharPtrã  PRINT LEFT$(Refresh$, LCol);ã  COLOR BG, FGã  PRINT MID$(Refresh$, LCol + 1, RCol - LCol);ã  COLOR FG, BGã  PRINT MID$(Refresh$, RCol + 1);ãELSEã  PRINT Refresh$;ãEND IFãRETURNããDoHelp:ãTemp$ = STR$(ActChar): MID$(Temp$, 1, 1) = ":"ãMsg$ = "Cursor" + STR$(ActLn) + Temp$ + " | Bytes free:" + STR$(FRE(Null$))ãD = (ScrnWidth - LEN(Msg$)) \ 2 - 4ãCOLOR BoxFG, BoxBGãCALL DrawBox(MidRow% - 1, 3, LeftCol + D, LEN(Msg$) + 8)ãLOCATE MidRow%, LeftCol + D + 4: PRINT Msg$;ãDO UNTIL ASC(INPUT$(1)) = ESC: LOOPãTemp$ = Null$: Msg$ = Null$ãCOLOR FG, BGãGOSUB RefreshScreenãRETURNããLoadFile:ãIF BlkLines OR BlkChars THEN BEEP: RETURNãIF ActLn > MaxLines THEN BEEP: RETURNãCALL InputBox("File name: ", LoadFile$, KeyCode)ãGOSUB RefreshScreenãIF KeyCode <> ENTER THEN RETURNãLoadFile$ = LTRIM$(RTRIM$(LoadFile$))ãIF LEN(LoadFile$) = 0 THEN RETURNãIF FileExists(LoadFile$) THENã  FileLines = FileLineCount(LoadFile$)ã  IF FileLines = 0 THEN RETURNã  IF LastLn + FileLines > MaxLines THENã    CALL MsgBox("File has too many lines", Null$, KeyCode)ã    GOSUB RefreshScreen: RETURNã  ELSEIF FileSize&(LoadFile$) + MemPad > FRE(Null$) THENã    CALL MsgBox("Not enough memory", Null$, KeyCode)ã    GOSUB RefreshScreen: RETURNã  END IFãELSEã  BEEP: CALL MsgBox("File not found", Null$, KeyCode)ã  GOSUB RefreshScreen: GOTO LoadFileãEND IFããIF ActLn <= LastLn THENã  FOR LnPtr = LastLn TO ActLn STEP -1ã    SWAP Text$(LnPtr), Text$(LnPtr + FileLines)ã  NEXTãEND IFãFile = FREEFILEãOPEN LoadFile$ FOR INPUT AS #Fileã  FOR LnPtr = ActLn TO ActLn + FileLines - 1ã    LINE INPUT #File, FileLn$ã    CALL Filter(FileLn$)ã    Text$(LnPtr) = FileLn$ã  NEXTã  FileLn$ = Null$ãCLOSE FileãLastLn = LastLn + FileLinesãFileChanged = TrueãGOSUB RefreshScreenãRETURNããSaveLines:ãCALL InputBox("File name: ", SaveFile$, KeyCode)ãGOSUB RefreshScreenãIF KeyCode = ENTER THENã  SaveFile$ = LTRIM$(RTRIM$(SaveFile$))ã  IF LEN(SaveFile$) THENã    IF FileExists(SaveFile$) THENã	 CALL MsgBox("Specified file already exists: [A]ppend [O]verwrite [C]ancel? ", "AaOoCc", KeyCode)ã	 GOSUB RefreshScreenã	 SELECT CASE KeyCodeã	   CASE 65, 97: Mode$ = "A": GOSUB DoFileSaveã	   CASE 79, 111: Mode$ = "O": GOSUB DoFileSaveã	   CASE 67, 99, ESC    'do nothing to cancel the saveã	 END SELECTã    ELSEã     IF LegalFileName(SaveFile$) THENã	   Mode$ = "O": GOSUB DoFileSaveã	 ELSEã	   CALL MsgBox("Bad file name", Null$, KeyCode)ã	   GOSUB RefreshScreen: GOTO SaveLinesã	 END IFã    END IFã  END IFãEND IFãRETURNããDoFileSave:ãFile = FREEFILEãOPEN Mode$, File, SaveFile$ã  StartLn = Lesser(ActLn, BlkStartLn)ã  FOR LnPtr = StartLn TO StartLn + ABS(BlkLines) - 1ã    PRINT #File, Text$(LnPtr)ã  NEXTãCLOSE FileãRETURNããFindText:ãIF BlkLines THEN BEEP: RETURNãIF BlkChars THENã  CharPtr = Lesser(BlkStartChar, BlkStartChar + BlkChars)ã  Search$ = MID$(ActLn$, CharPtr, ABS(BlkChars))ã  GOSUB SearchãELSEã  CALL InputBox("Find: ", Search$, KeyCode)ã  GOSUB RefreshScreenã  IF KeyCode = ENTER THENã    IF LEN(Search$) THEN GOSUB Searchã  END IFãEND IFãRETURNããSearch:ãCount = 0ãLnPtr = ActLn: CharPtr = ActCharãDOã  CharPtr = INSTR(CharPtr, Text$(LnPtr), Search$)ã  IF CharPtr THENã    BlkStartChar = CharPtrã    BlkChars = LEN(Search$)ã    ActChar = BlkStartChar + BlkCharsã    CursCol = Lesser(LeftCol + ActChar - 1, RiteCol)ã    TopLn = ActLn - (CursRow - TopRow)ã    ActLn = LnPtrã    CursRow = MidRowã    IF ActLn >= TopLn AND ActLn < TopLn + ScrnRows THENã	 CursRow = TopRow + (ActLn - TopLn)ã    ELSEIF ActLn <= ScrnRows THENã	 CursRow = TopRow + ActLn - 1ã    ELSEIF (LastLn + 1) - ActLn < BotRow - CursRow THENã	 CursRow = BotRow - ((LastLn + 1) - ActLn)ã    END IFã    GOSUB RefreshScreen: EXIT DOã  ELSEã    Count = Count + 1ã    IF Count > LastLn THENã	 CALL MsgBox("Search string not found", Null$, KeyCode)ã	 GOSUB RefreshScreen: EXIT DOã    END IFã    LnPtr = LnPtr + 1: IF LnPtr > LastLn THEN LnPtr = FirstLnã    CharPtr = 1ã  END IFãLOOPãRETURNããDoPrint:ãIF BlkLines THENã  StartLn = Lesser(ActLn, BlkStartLn)ã  StopLn = StartLn + ABS(BlkLines) - 1ãELSEã  StartLn = FirstLnã  StopLn = LastLnãEND IFãFOR LnPtr = StartLn TO StopLnã  LPRINT Text$(LnPtr)ãNEXTãBlkLines = 0ãGOSUB RefreshScreenãRETURNããDoRuler:ãIF BlkLines OR BlkChars THEN RETURNãRuler$ = SPACE$(MaxChars)ãFOR CharPtr = 1 TO MaxCharsã  MID$(Ruler$, CharPtr, 1) = "Â"ã  IF CharPtr MOD 5 = 0 THEN MID$(Ruler$, CharPtr) = "Å"ã  IF CharPtr MOD 10 = 0 THENã    MID$(Ruler$, CharPtr - 1) = CHR$(((CharPtr \ 10) MOD 10) + 48)ã  END IFãNEXTãRuler$ = MID$(Ruler$, ActChar - CursCol + LeftCol, ScrnWidth)ããRulerRow = TopRowãDOã  GOSUB PrintRulerã  DO WHILE LEN(INKEY$): LOOPã  DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)ã  KeyCode = ASC(Ky$): IF KeyCode = 0 THEN KeyCode = -ASC(MID$(Ky$, 2))ãSELECT CASE KeyCodeã    CASE UpArrowã	 IF RulerRow > TopRow THEN RulerRow = RulerRow - 1ã    CASE DnArrowã	 IF RulerRow < BotRow THEN RulerRow = RulerRow + 1ã    CASE PgUpKeyã	 IF RulerRow <> TopRow THEN RulerRow = TopRowã    CASE PgDnKeyã	 IF RulerRow <> BotRow THEN RulerRow = BotRowã    CASE ESCã	 EXIT DOã    CASE ELSEã	 BEEPã  END SELECTãLOOPãRuler$ = Null$ãGOSUB RefreshScreenãRETURNããPrintRuler:ãGOSUB RefreshScreenãLOCATE RulerRow, LeftCol, 0ãCOLOR BG, FG: PRINT Ruler$; : COLOR FG, BGãRETURNããEND SUBããFUNCTION FileExists% (FileName$)ãDIM XRegister AS RegTypeXãã'save the current DTAãXRegister.AX = &H2F00ãCALL InterruptX(&H21, XRegister, XRegister)ãOldDTASeg% = XRegister.ESãOldDTAOff% = XRegister.BXãã'set up a new DTAãDTA$ = SPACE$(43)ãXRegister.AX = &H1A00ãXRegister.DS = VARSEG(DTA$)ãXRegister.DX = SADD(DTA$)ãCALL InterruptX(&H21, XRegister, XRegister)ãã'get first matching fileãTemp$ = FileName$ + CHR$(0)ãXRegister.AX = &H4E00ãXRegister.CX = &H6ãXRegister.DS = VARSEG(Temp$)ãXRegister.DX = SADD(Temp$)ãCALL InterruptX(&H21, XRegister, XRegister)ã'if the carry flag is clear then the file existsãFileExists% = ((XRegister.Flags AND 1) = 0)ã'restore the old DTAãXRegister.AX = &H1A00ãXRegister.DS = OldDTASeg%ãXRegister.DX = OldDTAOff%ãCALL InterruptX(&H21, XRegister, XRegister)ããEND FUNCTIONããFUNCTION FileLineCount% (FileName$)ãlines% = 0ãFile = FREEFILEãOPEN FileName$ FOR INPUT AS Fileã  DO UNTIL EOF(File)ã    lines% = lines% + 1ã    LINE INPUT #File, FileLine$ã  LOOPãCLOSE FileãFileLineCount% = lines%ãEND FUNCTIONããFUNCTION FileSize& (FileName$)ãFile = FREEFILEãOPEN FileName$ FOR BINARY AS Fileã  FileSize& = LOF(File)ãCLOSE FileãEND FUNCTIONããSUB Filter (Dirty$)ããChar$ = CHR$(7): GOSUB FilterIt       'beepãBadChr$ = CHR$(12): GOSUB FilterIt    'Form feedããBadChr$ = CHR$(9)                     'tabãPtr% = 1ãDOã  Ptr% = INSTR(Ptr%, Dirty$, BadChr$)ã  IF Ptr% THENã    TabChars% = TabLen - (Ptr% MOD TabLen%)ã    Dirty$ = MID$(Dirty$, 1, Ptr% - 1) + SPACE$(TabChars%) + MID$(Dirty$, Ptr% + 1)ã  ELSEã    EXIT DOã  END IFãLOOPãDirty$ = LEFT$(Dirty$, MaxChars%)ãEXIT SUBããFilterIt:ãPtr% = 1ãDOã  Ptr% = INSTR(Ptr%, Dirty$, Char$)ã  IF Ptr% THENã    MID$(Dirty$, Ptr%, 1) = " "ã  ELSEã    EXIT DOã  END IFãLOOPãRETURNããEND SUBããFUNCTION Greater% (Var1%, Var2%) STATICãGreater% = Var1%: IF Var2% > Var1% THEN Greater% = Var2%ãEND FUNCTIONããSUB InputBox (Prompt$, InputText$, KeyCode%)ããCOLOR BoxFG%, BoxBG%ãCALL DrawBox(MidRow% - 1, 3, LeftCol% + 3, ScrnWidth% - 6)ãDOã  LOCATE MidRow%, LeftCol% + 7: PRINT Prompt$;ã  CALL InputLine(InputText$, ScrnWidth% - 15 - LEN(Prompt$), KeyCode%)ãLOOP UNTIL KeyCode% = ENTER OR KeyCode% = ESCãCOLOR FG%, BG%ããEND SUBããSUB InputLine (Text$, ViewWidth%, KeyCode%)ããMaxLnLen% = 128ãLCol% = POS(0): RCol% = LCol% + ViewWidth% - 1ãView$ = SPACE$(ViewWidth%)ãWork$ = LEFT$(Text$, MaxLnLen%)ãLnLen% = LEN(Work$)ãCCol% = Lesser(LCol% + LnLen%, RCol%)ãAChar% = LnLen% + 1ããLOCATE , , 0, CursSize% - 1, CursSize%ãInsert% = TrueãDOã  LOCATE , LCol%ã  LSET View$ = MID$(Work$, AChar% - (CCol% - LCol%), ViewWidth%)ã  PRINT View$;ã  LOCATE , CCol%, 1ã  LnLen% = LEN(Work$)ã  DOã    DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)ã    KeyCode% = ASC(Ky$): IF KeyCode% = 0 THEN KeyCode% = -ASC(MID$(Ky$, 2))ã  LOOP UNTIL KeyCode% <> BadKey%: BadKey% = 0ã  LOCATE , , 0ã  SELECT CASE KeyCode%ã    CASE BkSpcã	 IF AChar% = 1 THENã	   BEEP: BadKey% = KeyCode%ã	 ELSEã	   IF AChar% <= LnLen% + 1 THENã		Work$ = LEFT$(Work$, AChar% - 2) + MID$(Work$, AChar%)ã	   END IFã	   AChar% = AChar% - 1ã	   IF CCol% <> LCol% THEN CCol% = CCol% - 1ã	 END IFã    CASE ENTERã	 Text$ = Work$ã	 EXIT DOã    CASE ESCã	 EXIT DOã    CASE 32 TO 255      ' letter keysã	 IF AChar% > MaxLnLen% THENã	   BEEP: BadKey% = KeyCode%ã	 ELSEã	   IF AChar% <= LnLen% THENã		IF Insert% THENã		  IF LnLen% = MaxLnLen% THENã		    BEEP: BadKey% = KeyCode%ã		  ELSEã		    Work$ = LEFT$(Work$, AChar% - 1) + Ky$ + MID$(Work$, AChar%)ã		    AChar% = AChar% + 1ã		    IF CCol% <> RCol% THEN CCol% = CCol% + 1ã		  END IFã		ELSE 'IF NOT Insert% THEN (in overstrike mode)ã		  MID$(Work$, AChar%, 1) = Ky$ã		  AChar% = AChar% + 1ã		  IF CCol% <> RCol% THEN CCol% = CCol% + 1ã		END IFã	   ELSE 'IF AChar% > LnLen% THENã		Work$ = Work$ + SPACE$(AChar% - LnLen% - 1) + Ky$ã		AChar% = AChar% + 1ã		IF CCol% <> RCol% THEN CCol% = CCol% + 1ã	   END IFã	 END IFã    CASE LArrowã	 IF AChar% = 1 THENã	   BEEP: BadKey% = KeyCode%ã	 ELSE 'IF AChar% > 1 THENã	   AChar% = AChar% - 1ã	   IF CCol% <> LCol% THEN CCol% = CCol% - 1ã	 END IFã    CASE RArrowã	 IF AChar% > MaxLnLen% THENã	   BEEP: BadKey% = KeyCode%ã	 ELSEã	   AChar% = AChar% + 1ã	   IF CCol% <> RCol% THEN CCol% = CCol% + 1ã	 END IFã    CASE HomeKeyã	 AChar% = 1ã	 CCol% = LCol%ã    CASE EndKeyã	 AChar% = LnLen% + 1ã	 CCol% = Lesser(LCol% + LnLen%, RCol%)ã    CASE InsertKeyã	 Insert% = NOT Insert%ã	 IF Insert% THENã	   LOCATE , , , CursSize% - 1, CursSize%ã	 ELSEã	   LOCATE , , , CursSize% \ 2, CursSize%ã	 END IFã    CASE DeleteKeyã	 IF AChar% <= LnLen% THENã	   Work$ = LEFT$(Work$, AChar% - 1) + MID$(Work$, AChar% + 1)ã	 END IFã    CASE ELSEã	 BEEP: BadKey% = KeyCode%ã  END SELECTã LOOPã LOCATE , , , CursSize% - 1, CursSize%ããEND SUBãã FUNCTION LegalFileName% (FileName$)ã DIM XRegister AS RegTypeXã LegalFileName% = Falseã IF FileExists%(FileName$) THENã  LegalFileName% = Trueã ELSEã  'attempt to create the fileã  Temp$ = FileName$ + CHR$(0)ã  XRegister.AX = &H3C00ã  XRegister.CX = 0ã  XRegister.DS = VARSEG(Temp$)ã  XRegister.DX = SADD(Temp$)ã  CALL InterruptX(&H21, XRegister, XRegister)ã  IF (XRegister.Flags AND 1) = 0 THENã    'if carry flag is clear, then file was created OKã    LegalFileName% = Trueã    'delete the fileã    XRegister.AX = &H4100ã    CALL InterruptX(&H21, XRegister, XRegister)ã  END IFã END IFãã END FUNCTIONãã FUNCTION Lesser% (Var1%, Var2%) STATICã Lesser% = Var1%: IF Var2% < Var1% THEN Lesser% = Var2%ã END FUNCTIONããSUB MsgBox (Msg$, ValidKeys$, KeyCode%)ãã W% = LEN(Msg$) + 8ã M% = ScrnWidth% - 6ã IF W% > M% THEN W% = M% - 4ã D% = (ScrnWidth% - W%) \ 2ã COLOR BoxFG%, BoxBG%ã CALL DrawBox(MidRow% - 1, 3, LeftCol% + D%, ScrnWidth% - (D% * 2))ã LOCATE MidRow%, LeftCol% + D% + 4: PRINT LEFT$(Msg$, W%);ã COLOR FG%, BG%ãã DO WHILE LEN(INKEY$): LOOPã IF LEN(ValidKeys$) THENã  LOCATE , , 1ã  DOã    DO: VK$ = INKEY$: LOOP UNTIL LEN(VK$)ã    IF ASC(VK$) = ESC THEN EXIT DOã    IF INSTR(ValidKeys$, VK$) THEN EXIT DO ELSE BEEPã  LOOPã  LOCATE , , 0ã  KeyCode% = ASC(VK$)ã ELSEã  DO UNTIL LEN(INKEY$): LOOPã END IFãEND SUBããSUB SetVGABorderColor (Colour%)ã 'Colour must be in the range 0 - 255ã DIM Register AS RegTypeã Register.AX = &H1001ã Register.BX = Colour% * &H100ã CALL Interrupt(&H10, Register, Register)ãEND SUBããNaushir Patuck                 STRING EDIT/INPUT ROUTINE      naushir@pl.jaring.my           04-21-96 (21:25)       QB, QBasic, PDS        250  6532     INPUT.BAS   'This is a useful string Editing/Input routine I wroteã'to get rid of the horrors of Input forever :-)ããDECLARE SUB enter (text$, min!, max!, permitted$, caps!, justify!, password!, insert!, cursorvisible!, fillchar$)ããCLSãLOCATE 1, 4ãPRINT "Name : [" + STRING$(20, " ") + "]";ãLOCATE , 12ãã'Text to be edited.  If left as "", a new string will be createdãtext$ = "Jack"ãã'Minimum number of charactersãmin = 2ãã'Maximum number of charactersãmax = 20ãã'All the characters which areã'allowed to be enteredã'NOTE : Space should also be included here (if needed).ãpermitted$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz "ãã'Set case of text$ã'0 = As is enteredã'1 = All characters changed are upper caseãcaps = 0ãã'Justification of text$ã'0 = Noneã'1 = Left Justifyã'2 = Right Justifyãjustify = 0ãã'Set password type displayã'0 = Offã'1 = Onãpassword = 0ãã'Set insert stateã'0 = Offã'1 = Onã'Note : Insert can be toggled on and off with theã'       INSERT Key when the subroutine is runningãinsert = 1ãã'Is cursor visible or notã'0 = Noã'1 = Yesãcursorvisible = 1ãã'This fills the rest of the string (the empty part)ã'with the character provided by fillchar$ during display.ã'NOTE : This is just for the display of the string on the screenã'       and will not actually be added text$ãfillchar$ = "ù"ãã'Calling routineãenter text$, min, max, permitted$, caps, justify, password, insert, cursorvisible, fillchar$ããLOCATE 3, 4ãPRINT "The Name you entered was '" + text$ + "'"ãLOCATE 4, 4ãPRINT "Length of string :"; LEN(text$)ã                ã'Pls send comments/suggestions to :ã'Naushir Patuckã'naushir@pl.jaring.myããSUB enter (text$, min, max, permitted$, caps, justify, password, insert, cursorvisible, fillchar$)ããoldxpos = POS(0)ãoldypos = CSRLINãcursorposn = LEN(text$) + 1ãended = 0ãxpos = oldxposãypos = oldyposããIF caps THEN text$ = UCASE$(text$)ããIF cursorvisible = 1 THENã  IF insert = 1 THENã    LOCATE ypos, xpos, 1, 7, 7ã  ELSEã    LOCATE ypos, xpos, 1, 0, 7ã  END IFãELSEã  cursorvisible = 0ãEND IFããIF password = 1 THENã  PRINT STRING$(LEN(text$), 254) + (STRING$(max - LEN(text$), fillchar$))ãELSEã  PRINT text$ + STRING$(max - LEN(text$), fillchar$)ãEND IFããxpos = xpos + LEN(text$)ãoldtext$ = text$ããDOã  ã  LOCATE ypos, xpos, cursorvisibleã  ã  x$ = ""ã  WHILE LEN(x$) = 0ã    x$ = INKEY$ã  WENDã  ã  SELECT CASE x$ã      ã    CASE CHR$(27)                                 ' ESC Keyã      IF oldtext$ <> "" THENã        text$ = oldtext$ã        cursorposn = LEN(text$) + 1ã        xpos = oldxpos + LEN(text$)ã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE CHR$(0) + CHR$(82)                       ' Insert Keyã      IF cursorvisible THENã        IF insert = 1 THENã          LOCATE ypos, xpos, 1, 0, 7ã          insert = 0ã        ELSEã          LOCATE ypos, xpos, 1, 7, 7ã          insert = 1ã        END IFã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE CHR$(0) + CHR$(75)                       ' Left Keyã      IF (cursorvisible) AND (password <> 1) AND (cursorposn <> 1) THENã        cursorposn = cursorposn - 1ã        xpos = xpos - 1ã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE CHR$(0) + CHR$(77)                       ' Right Keyã      IF (cursorvisible) AND (password <> 1) THENã        IF cursorposn <= LEN(text$) THENã          cursorposn = cursorposn + 1ã          xpos = xpos + 1ã        ELSEã          SOUND 600, 2ã        END IFã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE CHR$(8)                                  ' Backspaceã      IF NOT (cursorposn = 1) THENã        IF cursorposn <= LEN(text$) THENã          text$ = LEFT$(text$, cursorposn - 2) + RIGHT$(text$, LEN(text$) - cursorposn + 1)ã        ELSEIF cursorposn = (LEN(text$) + 1) THENã          text$ = LEFT$(text$, LEN(text$) - 1)ã        END IFã        cursorposn = cursorposn - 1ã        xpos = xpos - 1ã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE CHR$(0) + CHR$(83)                       ' Delete Keyã      IF (password <> 1) AND cursorposn <= LEN(text$) THENã        text$ = LEFT$(text$, cursorposn - 1) + RIGHT$(text$, LEN(text$) - cursorposn)ã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE CHR$(13)                                 ' Enter Keyã      IF (LEN(text$) >= min) THENã        ended = 1ã      ELSEã        SOUND 600, 2ã        ended = 0ã      END IFã      ã    CASE CHR$(0) + CHR$(71)                       ' Home Keyã      IF (cursorvisible) AND (password <> 1) THENã        cursorposn = 1ã        xpos = oldxposã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE CHR$(0) + CHR$(79)                       ' End Keyã      IF (cursorvisible) AND (password <> 1) THENã        cursorposn = LEN(text$) + 1ã        xpos = oldxpos + LEN(text$)ã      ELSEã        SOUND 600, 2ã      END IFã      ã    CASE ELSE                                     ' Any Other Keyã      IF INSTR(permitted$, x$) THENã        IF (insert) THENã          IF LEN(text$) <> max THENã            text$ = LEFT$(text$, cursorposn - 1) + x$ + RIGHT$(text$, LEN(text$) - cursorposn + 1)ã            cursorposn = cursorposn + 1ã            xpos = xpos + 1ã          ELSEã            SOUND 600, 2ã          END IFã        ELSEã          IF cursorposn - 1 <> max THENã            IF cursorposn = LEN(text$) + 1 THENã              text$ = text$ + x$ã            ELSEã              text$ = LEFT$(text$, cursorposn - 1) + x$ + MID$(text$, cursorposn + 1, LEN(text$) - cursorposn)ã            END IFã            cursorposn = cursorposn + 1ã            xpos = xpos + 1ã          ELSEã            SOUND 600, 2ã          END IFã        END IFã      ELSEã        SOUND 600, 2ã      END IFã      ã  END SELECTã  ã  IF caps THEN text$ = UCASE$(text$)ã  ã  LOCATE oldypos, oldxposã  PRINT SPACE$(max)ã  ã  LOCATE oldypos, oldxpos, cursorvisibleã  ã  IF password = 1 THENã    PRINT STRING$(LEN(text$), 254) + (STRING$(max - LEN(text$), fillchar$))ã  ELSEã    PRINT text$ + STRING$(max - LEN(text$), fillchar$)ã  END IFã  ãLOOP UNTIL endedããIF justify = 2 THEN                               ' Right Justifyã  text$ = STRING$(max - LEN(text$), " ") + text$ãELSEIF justify = 1 THEN                           ' Left Justifyã  text$ = text$ + (STRING$(max - LEN(text$), " "))ãEND IFããLOCATE ypos, xpos, 1, 7, 7ããEND SUBãAlexander Podkolzin            PB EDITOR                      APP@nw.sbank.e-burg.su         04-24-96 (10:58)       PB32                   588  16050    PBEDIT.BAS  'ã' Simple Editor. Author: Alexander Podkolzin <APP@nw.sbank.e-burg.su>ã' Use it as you want...ã' PowerBASIC 3.2+ã' I'v deleted all block operations from the Editor, as they wereã' very ... don't know how to name them (may be "dummy": initial fileã' was 2 times longer).ã' PLEASE, share with me your experience if you'll rewrite this code !ã' I'll appreciate any respond of You !ã' Thanks for paying attention to that Editor!ã'ã'----------------------------------------------------------------------ã  $LIB ALL OFFã'----------------------------------------------------------------------ã'ã  %FALSE=0ã  %TRUE=NOT %FALSEã  %MaxLines= 10000ã  %MaxLen= 240ã  %FastCur= 8ã  %NormAttrib = &H07ã  %BlockAttrib= &H17ã  %KeyAttrib = &H1Bã  %PathAttrib = &H0Bã  %BlnkAttrib = %BlockAttrib +&H80ã  %HelpAttrib = &H17ã  %HotAttrib = &H15ã  %LineAttrib = &H0Aã'ã  DEFINT a-zã'ã  DIM Txt(%MaxLines) AS SHARED STRINGã  DIM Ins AS SHARED INTEGERã  DIM nlines AS SHARED INTEGERã  DIM ScrnSeg AS INTEGERã'ã  IF (pbvScrnCard AND 1) = 0 THENã    ScrnSeg = &HB800              ' color monitorã  ELSEã    ScrnSeg = &HB000              ' mono monitorã  END IFã'ã  y=CSRLINã  x=POS(0)ã  FileName$=COMMAND$ã  IF LEN(FileName$)=0 THENã     Cprint x,y,"USING: PBEDIT <File Name>",%NormAttribã     ENDã  END IFã'ã  IF NOT FileHere(FileName$) thenã     Cprint x,y,"File not found !",%NormAttribã     ENDã  END IFã'ã  InsKey$=CHR$(0,82)ã  Esc$=CHR$(27)ã  Home$=CHR$(0,71)ã  PgUp$=CHR$(0,73)ã  PgDn$=CHR$(0,81)ã  Up$=CHR$(0,72)ã  Down$=CHR$(0,80)ã  LeftKey$=CHR$(0,75)ã  RightKey$=CHR$(0,77)ã  CtrlPgUp$=CHR$(0,132)ã  CtrlPgDn$=CHR$(0,118)ã  CtrlHome$=CHR$(0,119)ã  CtrlEnd$=CHR$(0,117)ã  TabKey$=CHR$(9)ã  EndKey$=CHR$(0,79)ã  AltX$=CHR$(0,45)                ' Quitã'ã  BcSp$ = CHR$(8)ã  Enter$=CHR$(13)ã  DelKey$=CHR$(0,83)ã'ã  CtrlB$=CHR$(2)ã  CtrlC$=CHR$(3)ã  CtrlK$=CHR$(11)ã  CtrlL$=CHR$(12)ã  CtrlN$=CHR$(14)ã  CtrlQ$=CHR$(17)ã  CtrlV$=CHR$(22)ã  CtrlY$=CHR$(25)ã'ã  Ins=1ã  IsChanged=%FALSEã'ã  xb=1 : yb=1 : xe=80 : ye=24     ' Editor's window coordinatesã'                                 ' "ye" has to be less then 25!ã'ã  Cprint 1,ye+1,space$(80),%BlockAttribã'ã  Win 1,xb,yb,xe,ye,7,0ã'ã  FOR i=yb+1 to ye-1ã     Cprint xe,i,CHR$(177),%NormAttribã  NEXTã'ã  MYXA=1ã'ã  GOSUB LoadFileã'ã  Cprint 3,ye,"<     :   =   >",%NormAttribã'ã  Cprint xe,yb+MYXA,CHR$(219),%NormAttribã  DOã     Numerer nlines,lpage,begy,endyã     GOSUB PrepareScreenã     GOSUB ShowPage               ' lpage- length of window (page)ã     Show=1                       ' begy - first line to show,ã     IF nlines <1 then exit loop  ' endy - last line to show (array)ã     WHILE NOT INSTAT: WEND       ' CurY - the cursor lineã     Simb$=INKEY$ã     DEF SEG=0ã     POKE &H41C , peek(&H41A)     ' clear keyboard bufferã     DEF SEGã     SELECT CASE Simb$ã        CASE InsKey$ã           Ins = Ins xor 1ã           Show=0ã        CASE Home$ã           CurX=2ã           begx=1ã        CASE EndKey$ã           l=LEN(Txt(LineN))ã           CurX=MIN(l+1,wpage)+1ã           endx=MAX(l+1,wpage)+1ã           begx=endx-wpageã        CASE Up$ã           IF CurY >1 thenã              decr CurYã              Show=0ã           ELSEã              IF begy=1 thenã                 Show=0ã              END IFã              begy=begy-1ã              endy=endy-1ã              EXIT SELECTã           END IFã        CASE Down$ã           IF CurY <lpage thenã              INCR CurYã              Show=0ã           ELSEã              IF endy=nlines then exit SELECTã              INCR begyã              INCR endyã           END IFã        CASE PgUp$ã           begy=begy-lpageã           IF begy<=0 then begy=1ã        CASE PgDn$ã           begy=begy+lpageã           IF begy>=nlines-lpage+1 THEN begy=nlines-lpage+1ã        CASE LeftKey$ã           IF CurX >2 thenã              decr CurXã              Show=0ã           ELSEã              decr begxã              IF begx <1 thenã                 begx=1ã                 Show=0ã              END IFã           END IFã        CASE TabKey$ã           IF CurX <79-%FastCur thenã              INCR CurX,%FastCurã              Show=0ã           ELSEã              begx=begx+%FastCurã              IF begx >%MaxLen-79 then begx=%MaxLen-79ã           END IFã        CASE RightKey$ã           IF CurX <79 thenã              INCR CurXã              Show=0ã           ELSEã              INCR begxã              IF begx >%MaxLen-79 then begx=%MaxLen-79ã           END IFã        CASE CtrlPgUp$ã           begy=1ã           CurX=2ã           CurY=1ã        CASE CtrlPgDn$ã           begy=nlines-lpage+1ã           CurX=xb+1ã           CurY=ye-2ã        CASE CtrlHome$ã           CurY=1ã           Show=0ã        CASE CtrlEnd$ã           CurY=ye-2ã           Show=0ã        CASE AltX$,Esc$ã           EXIT LOOPã'ã'~~~~~~~~~~~~~~   All other chars will change Txt()   ~~~~~~~~~~~~~~ã        CASE Enter$ã           IF Ins=1 then          ' IF "Ins" is ONã              IsChanged=%TRUE         ' Txt() is changedã              IF nlines=%MaxLines thenã                 BEEP             ' too many stringsã                 EXIT SELECTã              END IFã              BreakLine LineN,SimbNã           END IFã           CurX=2ã           IF CurY < lpage thenã              INCR CurYã           ELSEã              INCR begyã           END IFã           begx=1ã'ã        CASE DelKey$ã           IsChanged=%TRUEã           l=LEN(Txt(LineN))ã           IF SimbN=1 and l=0 thenã              IF nlines>1 and LineN<>nlines THENã                 DelLine LineNã                 INCR nlinesã                 CurX=2ã              END IFã           ELSEIF SimbN>l and LineN=nlines THENã              EXIT SELECTã           ELSEã              IF SimbN>l thenã                 f$=Txt(LineN)+space$(SimbN-l-1)ã                 IF len(f$+Txt(LineN+1))>%MaxLen THENã                    BEEPã                    EXIT SELECTã                 END IFã                 Txt(LineN)=f$+Txt(LineN+1)ã                 INCR LineNã                 DelLine LineNã              ELSEIF l=1 thenã                 Txt(LineN)=""ã              ELSEã                 DelChar LineN,SimbNã              END IFã           END IFã'ã        CASE BcSp$ã           IsChanged=%TRUEã           IF SimbN=1 AND LineN=1 THEN EXIT SELECTã           IF SimbN=1 THENã              IF nlines>1 THENã                 sa$=Txt(LineN-1)ã                 sb$=Txt(LineN)ã                 DelLine LineNã                 Txt(LineN-1)=sa$+sb$ã                 CurX=LEN(sa$)+2ã                 IF LineN>1 THENã                    IF endy=<nlines THEN DECR CurYã                    IF CurY<1 thenã                       INCR CurYã                       DECR begyã                    END IFã                 END IFã              END IFã           ELSEIF SimbN>LEN(Txt(LineN))+1 THENã              DECR CurXã           ELSEã              DECR SimbNã              DelChar LineN,SimbNã              DECR CurXã           END IFã'ã        CASE CtrlY$ã           IsChanged=%TRUEã           DelLine LineNã           begx=1ã           CurX=2ã'ã        CASE CtrlN$ã           IsChanged=%TRUEã           InsLine LineNã'ã        CASE CtrlK$ã           Cprint xb+1,ye+1,"^K",%BlockAttribã           Cprint xb+4,ye+1,"more...",%BlnkAttribã           LOCATE ye+1,xb+3ã           WHILE NOT INSTAT: wendã           k$=INKEY$ã           Cprint xb+1,ye+1,SPACE$(10),%BlockAttribã           SELECT CASE k$ã'ã           END SELECTã        CASE CtrlQ$ã'ã        CASE ELSEã           IF LEN(Simb$)=1 and asc(Simb$)>31 THENã              IsChanged=%TRUEã              Txt(LineN)=Txt(LineN)+space$(%MaxLen)ã              IF Ins=1 THENã                 InsChar LineN,SimbN,Simb$ã              ELSEã                 ReplaceChar LineN,SimbN,Simb$ã              END IFã              INCR CurXã              IF CurX=xe THENã                 INCR begxã                 CurX=xe-1ã              END IFã              Txt(LineN)=RTRIM$(Txt(LineN))ã           END IFãã'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ã     END SELECTã  LOOPã  IF IsChanged THENã     Win 1,xb+1,yb+1,xe-1,yb+3,7,1ã     Cprint xb+3,yb+2,"File is changed, save ? (Y/N) ",%HelpAttribã     DOã        WHILE NOT INSTAT: wendã        s$=INKEY$ã        SELECT CASE s$ã           CASE "Y","y"ã              GOSUB SaveFileã              EXIT LOOPã           CASE "N","n"ã              EXIT LOOPã        END SELECTã     LOOPã  END IFã'ã' Clear screen before exitã'ã  Cprint 1,1,space$(2000),%NormAttribã  LOCATE ,,,11,12ã  ENDã'----------------------------------------------------------------------ããShowPage:ã  IF Show=0 THEN RETURNã  FOR i=1 TO lpageã     n = begy+i-1ã     Txt(n)=RTRIM$(Txt(n))ã     l = LEN(Txt(n))ã     s$=MID$(Txt(n)+space$(%MaxLen - l),begx,wpage)ã     Cprint xb+1,yb+i,s$,%NormAttribã  NEXT iã  RETURNã'----------------------------------------------------------------------ããPrepareScreen:ã'ã' Show Cursor:ã'ã  LineN=begy+CurY-1ã  SimbN=begx+Curx-2ã  Cprint 4,ye,RIGHT$("0000"+LTRIM$(STR$(LineN)),5),%PathAttribã  Cprint 10,ye,RIGHT$("00"+LTRIM$(STR$(SimbN)),3),%PathAttribã  Cprint 14,ye,RIGHT$("00"+LTRIM$(STR$(SCREEN(CurY+1,CurX ))),3),%PathAttribã  IF CurX < xb+1 THEN CurX= xb+1ã  IF CurX >xe-1 THEN CurX=xe-1ã  IF CurY >nlines then CurY=nlinesã  LOCATE yb+CurY,CurX,1ã'ã' Make Ruler:ã'ã  IF Nlines > lpage thenã     om=MYXAã     MYXA=((begy+CurY-1)/nlines )*(ye-yb-1)ã     IF MYXA=0 then MYXA=1ã     IF om <> MYXA thenã        Cprint xe,yb+om,CHR$(177),%NormAttribã        Cprint xe,yb+MYXA,CHR$(219),%NormAttribã     END IFã  END IFã'ã' Show Keys:ã'ã  IF Ins=1 THENã     LOCATE ,,,4,12ã     sa$="INS"ã  ELSEã     locate ,,,11,12ã     sa$ = "   "ã  END IFã  Cprint 71,ye+1,sa$,%BlockAttribã'ã' Show Size:ã'ã  Size&=-1ã  FOR i=1 to nlinesã     Size&=Size&+LEN(Txt(i))+2ã  NEXTã  Cprint 35,ye,"<Lines:     >",%NormAttribã  Cprint 65,ye,"<Size:",%NormAttribã  Cprint 78,ye,">",%NormAttribã  Cprint 42,ye,RIGHT$("      "+STR$(nlines),5),%PathAttribã  Cprint 71,ye,RIGHT$("      "+STR$( Size&),7),%PathAttribã'ã' Check if the editor file is changedã'ã  IF NOT IsChanged THENã     Cprint 19,ye,"=",%NormAttribã  ELSEã     Cprint 19,ye,"ö",%PathAttribã  END IFã  RETURNã'----------------------------------------------------------------------ã  FUNCTION FileHere (FileNAME$)ã     S$=DIR$(FileNAME$)ã     IF LEN(S$)=0 THENã        FileHere = 0ã     ELSEã        FileHere =-1ã     END IFã  END FUNCTIONã'----------------------------------------------------------------------ã  SUB BreakLine(LineN,SimbN)      ' Separates LineN-th string for twoã'                                 ' at SimbN-th positionã     sa$=MID$(Txt(LineN),1,SimbN-1)ã     sb$=MID$(Txt(LineN),SimbN,%MaxLen)ã     ARRAY INSERT Txt(LineN)ã     Txt(LineN)=sa$ã     Txt(LineN+1)=sb$ã     INCR nlinesã  END SUBã'----------------------------------------------------------------------ã  SUB DelLine(LineN)              ' Deletes LineN-th lineã     ARRAY DELETE Txt(LineN)ã     DECR nlinesã  END SUBã'----------------------------------------------------------------------ã  SUB InsLine(LineN)ã     BreakLine LineN,LEN(Txt(LineN))+1ã  END SUBã'----------------------------------------------------------------------ã  SUB InsChar(LineN,SimbN,Simb$)ã     s$=Txt(LineN)ã     Txt(LineN)=LEFT$(s$,SimbN-1)+Simb$+RIGHT$(s$,LEN(s$)-SimbN+1)ã  END SUBã'----------------------------------------------------------------------ã' Replacement of a charã  SUB ReplaceChar(LineN,SimbN,Simb$)ã     MID$(Txt(LineN),SimbN)=Simb$ã  END SUBã'----------------------------------------------------------------------ã  SUB DelChar(LineN,SimbN)ã     s$=Txt(LineN)ã     Txt(LineN)=LEFT$(s$,SimbN-1) + RIGHT$(s$,LEN(s$)-SimbN)ã  END SUBã'---------------------------------------------------------------------------ããSaveFile:ã  IF NOT IsChanged THEN RETURNã  Cprint 3,ye+1,"Saving...",%BlnkAttribã  n=INSTR(FileName$,".")ã  IF n<>0 THENã     n$=LEFT$(FileName$,n-1)      'ã     e$=".APP"                    ' Extension for changed file.ã  ELSE                            'ã     n$=FileName$ã     e$=".APP"ã  END IFã  IF FileHere(n$+e$) THENã     KILL n$+e$ã  END IFã  DestFile=FREEFILEã  OPEN n$+e$ FOR OUTPUT AS DestFileã  FOR i=1 to nlinesã     PRINT #DestFile,Txt(i)ã  NEXTã  CLOSE DestFileã  Cprint 3,ye+1,SPACE$(10),%BlockAttribã  IsChanged=%FALSEã  GOSUB PrepareScreenã  RETURNã'---------------------------------------------------------------------------ããLoadFile:ã  redim Txt(%MaxLines)ã  Cprint 3,yb+1,"Loading...",%NormAttrib + &H80ã  src=FREEFILEã  OPEN FileName$ FOR INPUT as srcã  i=0ã  DO WHILE EOF(src )=0 AND i < %MaxLinesã     INCR iã     LINE INPUT #src,Txt(i)ã' Double load timeã     REPLACE CHR$(9) with "        " IN Txt(i )ã  LOOPã  Size&= LOF(src )+1ã  CLOSE srcã  nlines=i+1ã  Txt(nlines )=""ã'ã  x=(80- LEN(FileName$)) \ 2ã  Cprint x-1,yb,repeat$(LEN(FileName$)+2,CHR$(196)),%NormAttribã  Cprint x,yb,UCASE$(FileName$),%PathAttribã  begx=1ã  begy=1ã  lpage=ye-yb-1ã  wpage=xe-xb-1ã  endy=MIN(lpage,nlines )ã  CurY=1ã  CurX=2ã  SimbN=1ã  Show=1ã  LOCATE yb+1,xb+1ã  RETURNã'---------------------------------------------------------------------------ã' "Numerer" normalizes begy% and begx%ã  SUB Numerer(nlines%,lpage%,begy%,endy%)ã     IF nlines%<=lpage% THENã        begy%=1ã        endy%=nlines%ã        EXIT SUBã     END IFã     IF begy%<1 THENã        begy%=1ã        endy%=begy%+lpage%-1ã        EXIT SUBã     END IFã     IF begy%+lpage%-1>=nlines% THENã        endy%=nlines%ã        begy%=nlines%-lpage%+1ã        EXIT SUBã     END IFã     endy%=begy%+lpage%-1ã  END SUBã'----------------------------------------------------------------------------ã  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)ã'ã     OldColor% = pbvScrnTxtAttr   ' Internal PB variableã'ã     SELECT CASE t%               ' Window typesã'                                 ' (you can make as much types,ã'                                 ' as you want):ã        CASE 1ã           a%=218:b%=196:c%=191   ' Single frameã           h%=179:      :d%=179ã           g%=192:f%=196:e%=217ã        CASE 2ã           a%=201:b%=205:c%=187   ' Double frameã           h%=186:      :d%=186ã           g%=200:f%=205:e%=188ã        CASE ELSEã           a%=032:b%= a%:c%=a%    ' Blanks onlyã           h%= a%:      :d%=a%ã           g%= a%:f%= a%:e%=a%ã     END SELECTã'ã     COLOR ct%,cb%ã'ã     LOCATE yb%,xb%ã     PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%);ã'ã     FOR i%=yb%+1 TO ye%-1ã        LOCATE i%,xb%ã        PRINT CHR$(h%) + SPACE$(xe%-xb%-1) +CHR$(d%);ã     NEXTã'ã     LOCATE ye%,xb%ã     PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%);ã'ã     ct%=OldColor% AND 15         ' restore colorsã     cb%=OldColor% \ 16ã     COLOR ct%,cb%ã  END SUBã'----------------------------------------------------------------------------ã  SUB PutAttribute(x%,y%,t%,b%)   ' Puts attribute byte to video memoryã     LOCAL c%                     ' directly to Colomn, Row positionã     c% = b%*16+t%ã     DEF SEG = ScrnSegã     POKE 160*(y%-1)+x%+x%-1,c%ã     DEF SEGã  END SUBã'----------------------------------------------------------------------------ã  SUB Cprint(x%,y%,s$,attr%)      ' Color printingã     LOCATE ,,0                   ' For more speed better to useã     REG 1,&H1300                 ' ASSEMBLER subroutineã     REG 2,attr%ã     REG 3,LEN(s$)ã     REG 4,(y%-1)*256+x%-1ã     REG 9,STRSEG(s$)ã     REG 7,STRPTR(s$)ã     CALL INTERRUPT &H10ã     LOCATE ,,1ã  END SUBã'----------------------------------------------------------------------ãDave Navarro, Jr.              FIND POSITION OF WORD IN STRINGdave@powerbasic.com            05-01-96 (19:29)       PB                     64   1712     WORDPOS.BAS '=============================================================================ã'                   Source code snippet: PowerBASIC for DOSã'ã'           Author: Dave Navarro, Jr. (dave@powerbasic.com)ã' Copyright status: Public Domainã'ã' Returns the position of a word in a string.  It must be a complete word,ã' and not part of another word (such as "BOB" in "BOBBY").ã'ã'=============================================================================ããDIM Text AS STRINGãDIM Find AS STRINGããText = "Main$ = UCASE$(Main$)"ãFind = "UCASE$"ããPRINT FindãPRINT Textãx = IsWord(0, Text, Find)ãIF x THEN PRINT SPACE$(x-1);"^"ãã'****************************************************************************ã'IsWord - Return the position of the specified complete word in a stringã'ãFUNCTION IsWord(BYVAL Start AS INTEGER, BYVAL Main AS STRING, BYVAL Search AS STRING)ãã  DIM Delimeters AS STRINGã  DIM FrontChr   AS STRINGã  DIM BackChr    AS STRINGã  DIM Where      AS INTEGERãã  Delimeters = " ()+-*\/<>;=:',^" + CHR$(34)ãã  Main   = UCASE$(Main)ã  Search = UCASE$(Search)ãã  IF Start < 1 THENã    Start = 1ã  END IFãã  Where   = INSTR(Start, Main$, Search$)ãã  IF Where THENã    IF Where > 1 THENã      FrontChr = MID$(Main, Where-1, 1)ã    END IFã    IF Where + LEN(Search) <= LEN(Main) THENã      BackChr = MID$(Main, Where+LEN(Search), 1)ã    END IFãã    IF (LEN(FrontChr) = 0) OR (INSTR(FrontChr, ANY Delimeters) > 0) THENã      Front = -1ã    END IFã    IF (LEN(BackChr) = 0) OR (INSTR(BackChr, ANY Delimeters) > 0) THENã      Back  = -1ã    END IFãã    IF (Front = -1) AND (Back = -1) THENã      FUNCTION = Whereã    END IFã  END IFããEND FUNCTIONãDave Gjessing                  FILE BROWSER                   dgjess@freenet.columbus.oh.us  05-25-96 (00:00)       QB, QBasic, PDS        139  3583     BF.BAS      'Needed a subroutine to replace -> SHELL "type [filespec] | more"ã'BF seems to work pretty well. It writes a copy of the text file to aã'temporary structured file, which can then be jumped around in withã'ease and speed.ãã'Please note that this is mainly intended as a subroutine to deal withã'text files from known sources (in my case, ones created by the programã'using the sub). I have run into unexpected problems with certain textã'files when using BF as a stand-alone program. This particular versionã'will (for instance) fly off the handle at a CHR$(12)... <G>. But, asã'long as you know what files BF will run into, it seems to be prettyã'stable.ãã'Shameless plug: BF is incorporated in my program ShareCon, which can beã'found at http://www.simtel.net/pub/simtelnet/msdos/database/sc1-2e.zipã'end of plugãã'define data type for temporary file...ããTYPE txlineãln AS STRING * 80ãEND TYPEãDIM text AS txlineããfilename$ = COMMAND$ããIF filename$ = "" OR filename$ = "?" OR filename$ = "/?" THENãPRINT "(B)rowse (F)ile.BAS    Dave Gjessing 5/25/96"ãPRINT "A smooth-scrolling text file viewer subroutine (or complete program"ãPRINT "as presented here)."ãPRINT "BF can only handle lines 80 characters in length (or less)."ãPRINTãPRINT "to use, type -> BF [filespec]"ãENDãEND IFããON ERROR GOTO fail  'it is assumed that error will be bad file nameãOPEN filename$ FOR INPUT AS #1ããspread = 23     'pass the spread as an argument when using BF as a subroutineããlow = 1ãhigh = spreadãcounter = 1ãtl = 1ããCLS     'if no error, clear the screen and beginããCOLOR 2, 0ãLOCATE 25, 1: PRINT CHR$(4); " PGUP - PGDN - ARROWS - HOME - END - ESC "; CHR$(4);ãCOLOR 15, 0ãPRINT " "; RIGHT$(filename$, 35); " ";ãCOLOR 7, 0ããOPEN "temp.$$$" FOR RANDOM AS #2 LEN = LEN(text)ããDO UNTIL EOF(1)             'copy file 1 (a plain ASCII text file)ãLINE INPUT #1, line$        'into a nice neat structured file forãtext.ln = line$             'random access (file 2)ãPUT #2, counter, textãcounter = counter + 1ãLOOPããCLOSE 1     'done with actual file we want to look at (browse temp file)ããsize = LOF(2) / LEN(text)   'find size of fileããagain:      'display selected screenful of file on screenãtl = 1ãIF low < 1 THEN low = 1ãFOR x = low TO highãGET #2, x, textãLOCATE tl, 1: PRINT text.lnãtl = tl + 1ãNEXT xãtl = 1ãã'move around within the temporary file...ããDOãop$ = INKEY$ãop$ = UCASE$(op$)ã  ã   IF op$ = CHR$(0) + CHR$(71) THEN 'home keyã   low = 1ã   high = spreadã   GOTO againã   END IFãã   IF op$ = CHR$(0) + CHR$(79) THEN 'end keyã   high = sizeã   low = (high - spread) + 1ã   GOTO againã   END IFãã   IF op$ = CHR$(0) + CHR$(81) THEN 'page down keyã   low = low + spreadã   high = high + spreadã    IF high > size THENã    high = sizeã    low = (high - spread) + 1ã    END IFã   GOTO againã   END IFã  ã   IF op$ = CHR$(0) + CHR$(73) THEN 'page up keyã   low = low - spreadã   high = high - spreadã      IF low < 1 THEN low = 1: high = (low + spread) - 1ã   GOTO againã   END IFãã   IF op$ = CHR$(0) + "P" THEN 'down arrowã   low = low + 1ã   high = high + 1ã   GOTO againã   END IFãã   IF op$ = CHR$(0) + "H" THEN 'up arrowã   low = low - 1ã   high = high - 1ã      IF low < 1 THEN low = 1: high = spreadã   GOTO againã   END IFã   ã   IF op$ = CHR$(27) THEN           'escape keyã   CLOSEã   KILL "temp.$$$"ã   CLSã   ENDã   END IFããLOOPããfail:       'report expected error - don't clear the screenãPRINTãPRINT "file -> "; filename$; " not found"ãENDããJohn Wantland                  UFO SCREEN SAVER               kwantlan@coffey.com            05-26-96 (14:47)       QB, QBasic, PDS        106  3609     UFO.BAS     1 k = 2ã10 REM ufoã15 CLSã16 COLOR 15, 0ã17 RANDOMIZE TIMERã18 n = INT(RND * 8 + 1)ã20 a$ = "ÜÜÜÜ" + CHR$(8) + CHR$(8) + CHR$(8) + CHR$(8) + CHR$(8) + CHR$(8) + "ÜÜÜÜ"ã30 x = 12: y = 31ã31 r = INT(RND * 15 + 1)ã32 c = INT(RND * 60 + 1)ã33 u = INT(RND * 15 + 1)ã34 v = INT(RND * 60 + 1)ã35 w = INT(RND * 15 + 1)ã36 e = INT(RND * 60 + 1)ã40 COLOR 7, 0: LOCATE r, c: PRINT "   ÛÛÛÛÛÛÛÛÛÛÛÛ "ã41 LOCATE r + 1, c: PRINT " ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã42 LOCATE u, v: PRINT "   ÛÛÛÛÛÛÛÛÛÛÛÛ "ã43 LOCATE u + 1, v: PRINT " ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã44 LOCATE w, e: PRINT "   ÛÛÛÛÛÛÛÛÛÛÛÛ "ã45 LOCATE w + 1, e: PRINT " ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ãFOR t = 1 TO 79ãCOLOR k, 0ãLOCATE 23, t: PRINT "Û";ãNEXT tã49 LOCATE x, yã50 RANDOMIZE TIMERã55 COLOR 9, 0ã60 PRINT a$ã70 IF y <= 1 OR y >= 64 OR x <= 1 OR x >= 23 THEN 100ã80 IF y = 20 OR y = 40 OR y = 60 OR x = 12 THEN n = INT(RND * 8 + 1)ã100 IF y <= 1 THEN n = 1ã110 IF y >= 64 THEN n = 2ã120 IF x <= 1 THEN n = 3ã130 IF x >= 22 THEN n = 4ã140 IF y <= 1 AND x <= 1 THEN n = 5ã150 IF y <= 1 AND x >= 22 THEN n = 6ã160 IF y >= 64 AND x <= 1 THEN n = 7ã170 IF y >= 64 AND x >= 22 THEN n = 8ã180 FOR t = 1 TO 1000: NEXT tã190 LOCATE x, y: PRINT "               "ã200 IF n = 1 THEN y = y + 1ã210 IF n = 2 THEN y = y - 1ã220 IF n = 3 THEN x = x + 1ã230 IF n = 4 THEN x = x - 1ã240 IF n = 5 THEN y = y + 1: x = x + 1ã250 IF n = 6 THEN y = y + 1: x = x - 1ã260 IF n = 7 THEN y = y - 1: x = x + 1ã270 IF n = 8 THEN y = y - 1: x = x - 1ã275 COLOR 0, 0ã280 b$ = INKEY$: IF b$ <> "" THEN 300ã285 c = c + 1: IF c >= 64 THEN CLS : c = 1: r = INT(RND * 15 + 1)ã286 v = v + 1: IF v >= 64 THEN CLS : v = 1: u = INT(RND * 15 + 1)ã287 e = e + 1: IF e >= 64 THEN CLS : e = 1: w = INT(RND * 15 + 1)ã288 i = i + 1: IF i >= 100 THEN GOSUB 510: i = 0ã290 GOTO 40ã300 FOR t = 1 TO 1000: NEXT tã305 COLOR 8, 0ã310 CLSã320 PRINT "       ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã330 PRINT "      ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã340 PRINT "     ÛÛÛÛÛÛ        ÛÛÛÛ        ÛÛÛÛÛÛ"ã350 PRINT "    ÛÛÛÛÛÛÛ        ÛÛÛÛ        ÛÛÛÛÛÛÛ"ã360 PRINT "   ÛÛÛÛÛÛÛÛ        ÛÛÛÛ        ÛÛÛÛÛÛÛÛ"ã370 PRINT "  ÛÛÛÛÛÛÛÛÛ        ÛÛÛÛ        ÛÛÛÛÛÛÛÛÛ"ã380 PRINT "  ÛÛÛÛÛÛÛÛÛ        ÛÛÛÛ        ÛÛÛÛÛÛÛÛÛ"ã390 PRINT "  ÛÛÛÛÛÛÛÛÛ        ÛÛÛÛ        ÛÛÛÛÛÛÛÛÛ"ã400 PRINT "   ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã410 PRINT "    ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã420 PRINT "     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã430 PRINT "      ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã440 PRINT "       ÛÛÛÛÛÛÛÛ            ÛÛÛÛÛÛÛÛ"ã450 PRINT "        ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã460 PRINT "         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã470 PRINT "          ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã480 PRINT "           ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã490 PRINT "            ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ"ã495 COLOR 15, 0: PRINT "                 BELIEVE!"ã500 ENDã510 s = 2100ã519 FOR h = x TO 21ã520 LOCATE h - 1, y: PRINT "              "ã530 LOCATE h, y: COLOR 9, 0: PRINT a$ãb$ = INKEY$: IF b$ <> "" THEN 300ã540 FOR t = 1 TO 1000: NEXT tãs = s - 100: SOUND s, 1ã545 x = x + 1ã550 NEXT hã560 LOCATE 21, y: PRINT "              "ã570 FOR h = 7 TO 20ã575 ON ERROR GOTO 1ã580 LOCATE x, y + h: COLOR 8, 0: PRINT CHR$(1)ã590 LOCATE x, y: COLOR 9, 0: PRINT a$ãb$ = INKEY$: IF b$ <> "" THEN 300ã600 FOR t = 1 TO 1000: NEXT tã605 LOCATE x, y + h: PRINT " "ã610 NEXT hã620 LOCATE 21, y + 16: PRINT " "ã630 FOR h = x TO 12 STEP -1ã640 IF x <> 22 THEN LOCATE h + 1, y: PRINT "              "ã650 LOCATE h, y: PRINT a$ãb$ = INKEY$: IF b$ <> "" THEN 300ã660 FOR t = 1 TO 1000: NEXT tã670 x = x - 1ã680 NEXT hã690 CLSã700 RETURNãThe ABC Programmer             SWITCH TEXT MODE W/O CLEARING  Convert from PASCAL Code       06-12-96 (11:10)       QB, PDS                31   730      SWITCH.BAS  '{ Switching without clearing test, by Bas van Gaalen, Holland, PD }ã' Converted to BASIC by William Yu (06-12-96)ãã'$INCLUDE: 'QB.BI'ãDIM SHARED InRegs AS RegTypeããCLSãPRINT "Select from the following option please:"ãPRINT "0 - Quit": PRINT "1 - 25 Lines": PRINT "2 - 50 Lines"ããDOã  A$ = INPUT$(1)ã  IF A$ = "1" THEN Lines.25ã  IF A$ = "2" THEN Lines.50ãLOOP UNTIL A$ = "0"ããENDããSUB Lines.25ã  InRegs.ax = &H83ã  CALL INTERRUPT(&H10, InRegs, InRegs)ãEND SUBããSUB Lines.50ã  InRegs.ax = &H1202ã  InRegs.bx = &H30      ' assembly:  mov bl, 30hã  CALL INTERRUPT(&H10, InRegs, InRegs)ã  InRegs.ax = &H1112ã  InRegs.bx = &H0       ' assembly:  mov bl, 0ã  CALL INTERRUPT(&H10, InRegs, InRegs)ãEND SUBãEdward Blake                   PLAIN TEXT EDITOR              eblake2@quebectel.com          06-28-96 (08:37)       QB, PDS                580  17640    EDITOR7.BAS 'ã' 1996 Edward Blake (14 years old), Plain Text Editor v7.0ã' maybe its called Editor7.bas, I called it like that because I have aã' Editor1 , Editor2, Editor3... all very limited and bug infested!!ã' But this shouldnt have too many bugs, but you might want to use itã' for something.. I modifie it for certain purposes, I made a versionã' for my Turbo Assembler, I simply changed the Custom command and renameã' it to "Assemble" (i'm too lazy to type Tasm then Tlink all the time).ã' Can serve as a IDE or a not-so-convenient editor.ã' used Microsoft QuickBasic 4.5 as Compiler, Minor\Major Change mightã' be needed to Interpret\Compile under another Implementation.ã' Remember to have the QB library, because I need to make interruptsã' for the mouse.ã'ã' Declarations of sub routinesãDECLARE SUB BCKGND ()                     ' BackGround RoutineãDECLARE SUB WIN (X1!, Y1!, X2!, Y2!, A$)  ' Text Windowing routineãDECLARE SUB LOADEDIT ()          ' Procedure called when the editor loadsãDECLARE SUB MAINEDIT ()          ' Where most of the stuff goesãDECLARE SUB FILEMENU ()          ' Called when you press the File menuãDECLARE SUB NEW ()               ' The File\New commandãDECLARE SUB SAVE ()              ' The File\Save commandãDECLARE SUB PRINTF ()            ' The File\Print commandãDECLARE SUB SHUTDOWN ()          ' The File\Exit commandãDECLARE SUB REPAINT ()           ' Repainting after a dialog box disappearsãDECLARE SUB SAVEBEFORE ()        ' Save Before Dialog BoxãDECLARE SUB SBHELP ()            ' Save Before HelpãDECLARE SUB SBREPAINT ()         ' Save Before RepaintãDECLARE SUB OPENF ()             ' The File\Open commandãDECLARE SUB SAVEAS ()            ' Called if no filenameãDECLARE SUB OPTIONFL ()          ' The File\(Custom) commandã' $INCLUDE: 'QB.BI'ã' Custom Settings Hard-Wired at run-timeãCONST EDITORNAME$ = "Editor's Title" ' Title appearing in the windowãCONST MAXLINES = 2000                    ' Maximum number of lines capableãCONST OPTIONFILE$ = "(Custom)"           ' Custom File CommandãCONST OPTIONFLHOT$ = "C"                 ' Custom command 's LetterãCONST OPTIONXHOTPOS = 1                  ' Position of custom letterãDIM FILE$(MAXLINES)                      ' Array for editable textãTITLE$ = COMMAND$                        ' Open a fileãIF COMMAND$ <> "" THEN            ' The Guy putted something as a parameterãOPEN TITLE$ FOR INPUT AS #1       ' It must be a file he wants to openãDO UNTIL EOF(1)                   ' Do the loop until The End of the fileãLINE INPUT #1, FILE$(I)ãI = I + 1ãLOOPãCLOSE #1ãEND IFãLOADEDIT                                 ' StartupãMAINEDIT                                 ' Main programãENDããSUB BCKGNDãFOR I = 1 TO 24ãLOCATE I, 1: PRINT STRING$(80, 177);ãNEXT IãLOCATE 25, 1: PRINT STRING$(80, 177);ãEND SUBããSUB FILEMENUãSHARED NOMSãDIM REGS AS RegTypeãREGS.ax = 2ãIF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãCOLOR 15, 1ãLOCATE 1, 2: PRINT " File "ãCOLOR 0, 7ãLOCATE 2, 1: PRINT "  New Document   "ãLOCATE 3, 1: PRINT "  Open Document  "ãLOCATE 4, 1: PRINT "  Save Document  "ãLOCATE 5, 1: PRINT "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"ãLOCATE 6, 1: PRINT "                 "ãLOCATE 7, 1: PRINT "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"ãLOCATE 8, 1: PRINT "  Print          "ãLOCATE 9, 1: PRINT "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"ãLOCATE 10, 1: PRINT "  Exit           "ãLOCATE 6, 1: PRINT OPTIONFILE$ãCOLOR 15, 7ãLOCATE 2, 3: PRINT "N"ãLOCATE 3, 3: PRINT "O"ãLOCATE 4, 3: PRINT "S"ãLOCATE 6, 1 + OPTIONXHOTPOS: PRINT OPTIONFLHOT$ãLOCATE 8, 3: PRINT "P"ãLOCATE 10, 3: PRINT "E"ãREGS.ax = 1ãIF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãSH = 1ãDOãI$ = UCASE$(INKEY$)ãREGS.ax = 3ãIF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãPM = REGS.bxãXM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1ãIF I$ <> "" THENãIF I$ = "N" THEN NEWãIF I$ = "O" THEN OPENFãIF I$ = "S" THEN SAVEãIF I$ = "P" THEN PRINTFãIF I$ = "E" THEN SHUTDOWNãIF I$ = "A" THEN OPTIONFLãIF I$ = CHR$(27) THEN EXIT DOãEXIT DOãEND IFãIF SH = 1 AND PM = 0 THEN SH = 0ãIF XM > 1 AND XM < 18 AND YM < 11 AND SH = 0 THENãIF YM = 1 AND PM = 1 THEN EXIT DOãIF YM = 2 AND PM = 1 THENãNEWãEXIT DOãEND IFãIF YM = 3 AND PM = 1 THENãOPENFãEXIT DOãEND IFãIF YM = 4 AND PM = 1 THENãSAVEãEXIT DOãEND IFãIF YM = 6 AND PM = 1 THENãOPTIONFLãEXIT DOãEND IFãIF YM = 8 AND PM = 1 THENãPRINTFãEND IFãIF YM = 10 AND PM = 1 THEN SHUTDOWNãEND IFãLOOPãREGS.ax = 2ãIF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãREPAINTãREGS.ax = 1ãIF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãEND SUBããSUB LOADEDITãDIM REGS AS RegTypeãREGS.ax = 0ãINTERRUPT 51, REGS, REGSãIF REGS.ax = 0 THEN NOMS = 1ãREGS.cx = 0ãREGS.dx = 0ãCOLOR 1ãBCKGNDãCOLOR 7, 1ãWIN 1, 2, 80, 24, EDITORNAME$ããREGS.ax = 1ãIF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãCOLOR 15, 7ãLOCATE 25, 1: PRINT "  Edward Blake, 1996                                                            ";ãCOLOR 0, 7ãLOCATE 1, 1: PRINT "  File                                                                          ";ãCOLOR 15, 5ãEND SUBããSUB MAINEDITãSHARED FILE$(), Y, X, Z, NOMSãDIM LINETRCK%(MAXLINES)ãDIM REGS AS RegTypeãREGS.ax = 0ãINTERRUPT 51, REGS, REGSãIF REGS.ax = 0 THEN NOMS = 1ãDOã    ' Extended Keyboardã    IF I$ = CHR$(0) + CHR$(33) THEN FILEMENUã    IF I$ = CHR$(0) + CHR$(80) THEN Y = Y + 1ã    IF I$ = CHR$(0) + CHR$(72) THEN Y = Y - 1ã    IF I$ = CHR$(0) + CHR$(75) THEN Z = Z - 1ã    IF I$ = CHR$(0) + CHR$(77) THEN Z = Z + 1ã    IF I$ = CHR$(0) + CHR$(71) THEN Z = 0ã    IF I$ = CHR$(0) + CHR$(79) THEN Z = LINETRCK%(X + Y)ã    IF Y < 0 THENã	Y = 0ã	X = X - 1ã    END IFã    IF Y > 20 THENã	Y = 20ã	X = X + 1ã    END IFãã    IF Z < 0 THEN Z = 0ã    IF Z > 77 THEN Z = 77ãã    IF X < 0 THEN X = 0ã    IF X > MAXLINES THEN X = MAXLINESãã    IF I$ > CHR$(1) AND I$ <= CHR$(255) THEN  ' Non-Extended Keyboardã	LOCATE 25, 1: PRINT "             ";ã	LOCATE 25, 1: PRINT ASC(I$); I$;ã	IF I$ = CHR$(13) THEN                 ' Enterã	    Y = Y + 1ã	    Z = 0ã	    I$ = ""ã	    IF Y > 20 THENã		Y = 20ã		X = X + 1ã	    END IFã	    IF X > MAXLINES THEN X = MAXLINESã	END IFã	IF I$ = CHR$(127) THEN                ' Delete Procedureã	END IFã	IF I$ = CHR$(8) THEN                  ' BackSpace Procedureã	    IF Z > 0 THENã	    IF FILE$(X + Y) <> "" AND NOT (Z > LEN(FILE$(X + Y))) THEN FILE$(X + Y) = LEFT$(FILE$(X + Y), Z - 1) + RIGHT$(FILE$(X + Y), LEN(FILE$(X + Y)) - Z)ã	    IF Z >= 0 THEN Z = Z - 1ã	    LINETRCK%(Y + X) = Zã	    END IFã	END IFã	IF I$ >= CHR$(32) AND I$ <= CHR$(255) AND I$ <> CHR$(127) THEN 'Printable Charactersã	    IF Z + 1 > LEN(FILE$(X + Y)) THEN FILE$(X + Y) = FILE$(X + Y) + STRING$(ABS(LEN(FILE$(X + Y)) - Z) + 1, 32)ã	    MID$(FILE$(Y + X), Z + 1, 1) = I$ã	    Z = Z + 1ã	    LINETRCK%(Y + X) = Zã	END IFã    END IFãã    IF Y < 0 THENã	Y = 0ã	X = X - 1ã    END IFã    IF Y > 20 THENã	Y = 20ã	X = X + 1ã    END IFãã    IF Z < 0 THEN Z = 0ã    IF Z > 77 THEN Z = 77ãã    IF X < 0 THEN X = 0ã    IF X > MAXLINES THEN X = MAXLINESãã    REGS.ax = 2ã    IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSã    FOR I = 0 TO 20ã	LOCATE I + 3, 2, 0: PRINT FILE$(X + I) + STRING$(78 - LEN(FILE$(X + I)), 32)ã    NEXT Iã    LOCATE Y + 3, 2 + Z, 1ã    REGS.ax = 1ã    IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSã    DOã	REGS.ax = 1ã	IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSã	I$ = INKEY$ã	IF I$ <> "" THEN EXIT DOã	REGS.ax = 3ã	INTERRUPT 51, REGS, REGSã	PM = REGS.bxã	XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1ã	IF PM = 0 THEN SH = 0ã	IF PM = 1 AND SH = 0 THENã	IF YM = 1 THENã	IF XM > 2 AND XM < 8 THEN FILEMENUã	END IFã	SH = 1ã	END IFã    LOOPãLOOPãEND SUBããSUB NEWãSHARED FILE$(), TITLE$ãSAVEBEFOREãFOR I = 0 TO MAXLINESãFILE$(I) = ""ãNEXT IãTITLE$ = ""ãEND SUBããSUB OPENFãSHARED FILE$(), TITLE$, NOMSãDIM REGS AS RegTypeãREGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãWIN 4, 3, 76, 8, "  Open  "ãWIN 6, 4, 74, 6, ""ãCOLOR 15, 1ãLOCATE 5, 7: PRINT SPACE$(67)ãLOCATE 7, 14: PRINT "    OK    "ãLOCATE 7, 34: PRINT "  CANCEL  "ãREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãDOã    IF Z < 0 THEN Z = 0ã    IF I$ > CHR$(1) AND I$ <= CHR$(255) THENã	IF I$ = CHR$(8) THENã	    IF Z > 0 THENã	    IF VTITLE$ <> "" AND NOT (Z > LEN(VTITLE$)) THEN VTITLE$ = LEFT$(VTITLE$, Z - 1) + RIGHT$(VTITLE$, LEN(VTITLE$) - Z)ã	    IF Z >= 0 THEN Z = Z - 1ã	    END IFã	END IFã	IF I$ >= CHR$(32) AND I$ <= CHR$(255) THENã	    IF Z + 1 > LEN(VTITLE$) THEN VTITLE$ = VTITLE$ + STRING$(ABS(LEN(VTITLE$) - Z) + 1, 32)ã	    MID$(VTITLE$, Z + 1, 1) = I$ã	    Z = Z + 1ã	END IFã    END IFã    IF Z < 0 THEN Z = 0ã    LOCATE 5, 7: PRINT RIGHT$(VTITLE$, 66) + " "ã    DOã	REGS.ax = 1ã	IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSã	I$ = INKEY$ã	IF I$ = CHR$(27) THEN CANCEL = 1ã	IF I$ = CHR$(13) THEN OK = 1ã	IF I$ <> "" THEN EXIT DOã	REGS.ax = 3ã	INTERRUPT 51, REGS, REGSã	PM = REGS.bxã	XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1ã	IF PM = 1 AND YM = 7 THENã	IF XM > 13 AND XM < 25 THEN OK = 1ã	IF XM > 33 AND XM < 45 THEN CANCEL = 1ã	IF OK = 1 OR CANCEL = 1 THEN EXIT DOã	END IFã    LOOPãIF OK = 1 OR CANCEL = 1 THEN EXIT DOãLOOPããREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãIF OK = 1 THEN TITLE$ = VTITLE$ãIF CANCEL = 1 THEN EXIT SUBãI = 0ãOPEN TITLE$ FOR INPUT AS #1ãDO UNTIL EOF(1)ãLINE INPUT #1, FILE$(I)ãI = I + 1ãLOOPãCLOSE #1ãEND SUBãã'ã' Custom File Command Pushedã'ãSUB OPTIONFLãEND SUBããSUB PRINTFãSHARED FILE$()ãFOR I = 0 TO MAXLINESãIF FILE$(I) <> "" THEN MXFILE = I + 1ãNEXT IãI = 0ãOPEN "LPT1:" FOR OUTPUT AS #1ãDO UNTIL I = MXFILEãPRINT #1, FILE$(I)ãI = I + 1ãLOOPãCLOSE #1ãEND SUBããSUB REPAINTãSHARED FILE$(), Y, ZãCOLOR 7, 1ãWIN 1, 2, 80, 24, EDITORNAME$ãCOLOR 15, 7ãLOCATE 25, 1: PRINT "  Edward Blake, 1996                                                            ";ãCOLOR 0, 7ãLOCATE 1, 1: PRINT "  File                                                                          ";ãCOLOR 15, 5ã    FOR I = 0 TO 20ã	LOCATE I + 3, 2, 0: PRINT FILE$(X + I) + STRING$(78 - LEN(FILE$(X + I)), 32)ã    NEXT Iã    LOCATE Y + 3, 2 + Z, 1ãEND SUBããSUB SAVEãSHARED TITLE$, FILE$()ãDIM REGS AS RegTypeãIF TITLE$ <> "" THENãFOR I = 0 TO MAXLINESãIF FILE$(I) <> "" THEN MXFILE = I + 1ãNEXT IãI = 0ãOPEN TITLE$ FOR OUTPUT AS #1ãDO UNTIL I = MXFILEãPRINT #1, FILE$(I)ãI = I + 1ãLOOPãCLOSE #1ãEND IFãIF TITLE$ = "" THEN SAVEASãREGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãREPAINTãREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãEND SUBããSUB SAVEASãSHARED FILE$(), TITLE$, NOMSãDIM REGS AS RegTypeãREGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãWIN 4, 3, 76, 8, "  Save as  "ãWIN 6, 4, 74, 6, ""ãCOLOR 15, 1ãLOCATE 5, 7: PRINT SPACE$(67)ãLOCATE 7, 14: PRINT "    OK    "ãLOCATE 7, 34: PRINT "  CANCEL  "ãREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãDOã    IF Z < 0 THEN Z = 0ã    IF I$ > CHR$(1) AND I$ <= CHR$(255) THENã	IF I$ = CHR$(8) THENã	    IF Z > 0 THENã	    IF VTITLE$ <> "" AND NOT (Z > LEN(VTITLE$)) THEN VTITLE$ = LEFT$(VTITLE$, Z - 1) + RIGHT$(VTITLE$, LEN(VTITLE$) - Z)ã	    IF Z >= 0 THEN Z = Z - 1ã	    END IFã	END IFã	IF I$ >= CHR$(32) AND I$ <= CHR$(255) THENã	    IF Z + 1 > LEN(VTITLE$) THEN VTITLE$ = VTITLE$ + STRING$(ABS(LEN(VTITLE$) - Z) + 1, 32)ã	    MID$(VTITLE$, Z + 1, 1) = I$ã	    Z = Z + 1ã	END IFã    END IFã    IF Z < 0 THEN Z = 0ã    LOCATE 5, 7: PRINT RIGHT$(VTITLE$, 66) + " "ã    DOã	REGS.ax = 1ã	IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSã	I$ = INKEY$ã	IF I$ = CHR$(27) THEN CANCEL = 1ã	IF I$ = CHR$(13) THEN OK = 1ã	IF I$ <> "" THEN EXIT DOã	REGS.ax = 3ã	INTERRUPT 51, REGS, REGSã	PM = REGS.bxã	XM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1ã	IF PM = 1 AND YM = 7 THENã	IF XM > 13 AND XM < 25 THEN OK = 1ã	IF XM > 33 AND XM < 45 THEN CANCEL = 1ã	IF OK = 1 OR CANCEL = 1 THEN EXIT DOã	END IFã    LOOPãIF OK = 1 OR CANCEL = 1 THEN EXIT DOãLOOPããREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãIF OK = 1 THENãTITLE$ = VTITLE$ãFOR I = 0 TO MAXLINESãIF FILE$(I) <> "" THEN MXFILE = I + 1ãNEXT IãI = 0ãIF INSTR(TITLE$, ".") = 0 THEN TITLE$ = TITLE$ + ".ASM"ãOPEN TITLE$ FOR OUTPUT AS #1ãDO UNTIL I = MXFILEãPRINT #1, FILE$(I)ãI = I + 1ãLOOPãCLOSE #1ãEND IFãEND SUBããSUB SAVEBEFOREãSHARED NOMSãDIM REGS AS RegTypeãREGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãCOLOR 7, 1ãWIN 10, 11, 70, 14, ""ãLOCATE 12, 11: PRINT "               Do you want to save before?                 "ãLOCATE 13, 11: PRINT "                                                           "ãCOLOR 0, 7ãLOCATE 13, 19: PRINT "   YES    "ãLOCATE 13, 35: PRINT "    NO    "ãLOCATE 13, 51: PRINT "   HELP   "ãCOLOR 15, 7ãLOCATE 13, 22: PRINT "Y"ãLOCATE 13, 39: PRINT "N"ãLOCATE 13, 54: PRINT "H"ãREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãDOãI$ = UCASE$(INKEY$)ãREGS.ax = 3: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãPM = REGS.bxãXM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1ãIF I$ = "Y" THEN OK = 1ãIF I$ = "N" THEN CANCEL = 1ãIF I$ = "H" THEN SBHELPãIF PM = 1 AND YM = 13 THENãIF XM > 18 AND XM < 30 THEN OK = 1ãIF XM > 34 AND XM < 45 THEN CANCEL = 1ãIF XM > 51 AND XM < 62 THEN SBHELPãEND IFãIF OK = 1 OR CANCEL = 1 THEN EXIT DOãLOOPãIF OK = 1 THEN SAVEãEND SUBããSUB SBHELPãSHARED NOMSãDIM REGS AS RegTypeãREGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãCOLOR 15, 0ãWIN 3, 2, 78, 24, "  Help On Before Save  "ãCOLOR 7, 0ãLOCATE 3, 4: PRINT " This prompt appears about anywhere when your file can get destroyed      ";ãLOCATE 4, 4: PRINT " like using the new or exit command.                                      ";ãLOCATE 5, 4: PRINT " This prompt will open anyway even after you saved your file.             ";ãLOCATE 6, 4: PRINT " If you press YES, then either:                                           ";ãLOCATE 7, 4: PRINT "      -You see the Save as command box if it is untitled                  ";ãLOCATE 8, 4: PRINT "      -It will be saved automatically if it already as a name             ";ãLOCATE 9, 4: PRINT " If you press NO, then changes to your file after its last save is        ";ãLOCATE 10, 4: PRINT " destroyed                                                                ";ãLOCATE 11, 4: PRINT "                                                                          ";ãLOCATE 12, 4: PRINT "                                                                          ";ãLOCATE 13, 4: PRINT "                                                                          ";ãLOCATE 14, 4: PRINT "                                                                          ";ãLOCATE 15, 4: PRINT "                                                                          ";ãLOCATE 16, 4: PRINT "                                                                          ";ãLOCATE 17, 4: PRINT "                                                                          ";ãLOCATE 18, 4: PRINT "                                                                          ";ãLOCATE 19, 4: PRINT "                                                                          ";ãLOCATE 20, 4: PRINT "                                                                          ";ã'LOCATE 21, 4: PRINT "                                                                          ";ã'LOCATE 22, 4: PRINT "                                                                          ";ã'LOCATE 23, 4: PRINT "                                                                          ";ãCOLOR 15, 7ãLOCATE 21, 4: PRINT "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿";ãLOCATE 22, 4: PRINT "³       R            ";ãCOLOR 0, 7ãPRINT "³";ãLOCATE 23, 4: PRINT "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ";ãCOLOR 0, 7ãLOCATE 22, 13: PRINT "eturn";ãREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãDOãI$ = UCASE$(INKEY$)ãREGS.ax = 3: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãPM = REGS.bxãXM = INT((80 / 640) * REGS.cx) + 1: YM = INT((25 / 200) * REGS.dx) + 1ãIF YM > 20 AND YM < 24 AND PM = 1 AND XM > 3 AND XM < 26 THEN EXIT DOãIF I$ = "R" THEN EXIT DOãLOOPãREGS.ax = 2: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãREPAINTãSBREPAINTãREGS.ax = 1: IF NOMS = 0 THEN INTERRUPT 51, REGS, REGSãEND SUBããSUB SBREPAINTãCOLOR 15, 1ãWIN 10, 11, 70, 14, ""ãLOCATE 12, 11: PRINT "               Do you want to save before?                 "ãLOCATE 13, 11: PRINT "                                                           "ãCOLOR 0, 7ãLOCATE 13, 19: PRINT "   YES    "ãLOCATE 13, 35: PRINT "    NO    "ãLOCATE 13, 51: PRINT "   HELP   "ãCOLOR 15, 7ãLOCATE 13, 22: PRINT "Y"ãLOCATE 13, 39: PRINT "N"ãLOCATE 13, 54: PRINT "H"ãEND SUBããSUB SHUTDOWNãDIM REGS AS RegTypeãCOLOR 15, 1ãLOCATE 10, 1: PRINT "  Exit           "ãSAVEBEFOREãREGS.ax = 0: INTERRUPT 51, REGS, REGSãCOLOR 7, 0ãCLSãSYSTEMãEND SUBããSUB WIN (X1, Y1, X2, Y2, A$)ãFOR I = Y1 TO Y2ãLOCATE I, X1: PRINT STRING$(X2 - X1, 32);ãNEXT IãLOCATE Y1, X1 + 1: PRINT STRING$(X2 - X1 - 1, 196);ãLOCATE Y2, X1 + 1: PRINT STRING$(X2 - X1 - 1, 196);ãFOR I = Y1 + 1 TO Y2 - 1ãLOCATE I, X1: PRINT CHR$(179);ãLOCATE I, X2: PRINT CHR$(179);ãNEXT IãLOCATE Y1, X1: PRINT CHR$(218);ãLOCATE Y1, X2: PRINT CHR$(191);ãLOCATE Y2, X1: PRINT CHR$(192);ãLOCATE Y2, X2: PRINT CHR$(217);ãIF A$ <> "" THENãLOCATE Y1, ((X2 + X1) / 2) - ((LEN(A$) + 2) / 2): PRINT CHR$(180) + A$ + CHR$(195)ãEND IFãEND SUBãEdward Blake                   TEXT WINDOW DESIGNER           eblake2@quebectel.com          06-28-96 (09:08)       QB, PDS                436  11690    WNDESIGN.BAS' 1995-96 Edward Blake (14 years old), QuickBasic Windowing designerã' Programming tool for creating a acceptable text based Windowing Interfaceã' looks quite primitive a the side of other, more sophisticated toolsã' But can always make a good interface, Keeps everything in RAM untilã' You want to save your work to a .BAS file, push ESC to go to the menuã'ãDECLARE SUB EXITP ()ãDECLARE SUB NEW ()ãDECLARE SUB SAVE ()ãDECLARE FUNCTION ZDIGIT$ (A%)ãDECLARE SUB MOUSE (A!)ãDECLARE SUB BACKCLRED (ACTT!)ãDECLARE SUB FORECLRED (ACTT!)ãDECLARE SUB PROPERTY (ACTTOOL!)ãDECLARE SUB TOOLBAR (X3!, Y3!)ãDECLARE SUB MENU ()ãDECLARE SUB RECONSTRUCT ()ãDECLARE SUB BCKGND ()ãDECLARE SUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)ã' $INCLUDE: 'QB.BI'ãTYPE OBJECTãX1 AS INTEGERãY1 AS INTEGERãX2 AS INTEGERãY2 AS INTEGERãBACKCLR AS INTEGERãFORECLR AS INTEGERãCAPTION AS STRING * 32ãEND TYPEãDIM INDEX AS INTEGERãDIM REGS AS RegTypeãDIM OBJ(300) AS OBJECTãCLSãBCKGNDãCOLOR 15, 1ãREGS.ax = 10ãREGS.bx = 0ãREGS.cx = &HFFFFãREGS.dx = &H4700ãINTERRUPT 51, REGS, REGSãREGS.ax = 1ãREGS.bx = 0ãREGS.cx = 1ãREGS.dx = 1ãINTERRUPT 51, REGS, REGSãDOãI$ = INKEY$ãREGS.ax = 3ãINTERRUPT 51, REGS, REGSããIF REGS.bx = 1 THENã   IF PD = 0 THENã   PD = 1ã   LSTX% = INT((80 / 640) * REGS.cx) + 1ã   LSTY% = INT((25 / 200) * REGS.dx) + 1ã   END IFã   IF PD = 1 THENã   WIN LSTX%, LSTY%, INT((80 / 640) * REGS.cx) + 1, INT((25 / 200) * REGS.dx) + 1, ""ã   END IFãEND IFãIF REGS.bx = 0 THENãLSPD = PDãPD = 0ã   IF LSPD = 1 THENã   WIN LSTX%, LSTY%, INT((80 / 640) * REGS.cx) + 1, INT((25 / 200) * REGS.dx) + 1, "Untitled"ã      IF LSTX% <> INT((80 / 640) * REGS.cx) + 1 THENã	 IF LSTY% <> INT((25 / 200) * REGS.dx) + 1 THENã	 OBJ(INDEX).X1 = LSTX%ã	 OBJ(INDEX).Y1 = LSTY%ã	 OBJ(INDEX).X2 = INT((80 / 640) * REGS.cx) + 1ã	 OBJ(INDEX).Y2 = INT((25 / 200) * REGS.dx) + 1ã	 OBJ(INDEX).BACKCLR = 1ã	 OBJ(INDEX).FORECLR = 15ã	 OBJ(INDEX).CAPTION = "Untitled"ã	 INDEX = INDEX + 1ã	 LSTX% = 0'INT((80 / 640) * REGS.cx) + 1ã	 LSTY% = 0'INT((25 / 200) * REGS.dx) + 1ã	 LSTPH = 0ã	 RECONSTRUCTã	 END IFã      END IFã	 LSTPH = 0ã   END IFãEND IFãIF REGS.bx = 0 THENãIF LSTX% = INT((80 / 640) * REGS.cx) + 1 THENãIF LSTY% = INT((25 / 200) * REGS.dx) + 1 THENãIF LSTPH = 0 THENã'ã'  PLACE ROUTINES HERE THE USER CLICKS (NOT DRAG)ã'ãTOOLBAR INT((80 / 640) * REGS.cx) + 1, INT((25 / 200) * REGS.dx) + 1ãRECONSTRUCTãLSTPH = 1ãEND IFãEND IFãEND IFãEND IFãIF I$ = CHR$(13) OR I$ = CHR$(27) OR I$ = CHR$(9) THEN MENUãLOOPããSUB BACKCLRED (ACTT)ãSHARED OBJ() AS OBJECT, INDEX AS INTEGERãDIM REGS AS RegTypeãCOLOR 0, 15ãLOCATE 9, 18: PRINT "<" + ZDIGIT$(OBJ(ACTT).BACKCLR) + ">"ãZ% = OBJ(ACTT).BACKCLRãDOãI$ = INKEY$ãIF I$ = CHR$(0) + CHR$(77) THEN Z% = Z% + 1ãIF I$ = CHR$(0) + CHR$(75) THEN Z% = Z% - 1ãIF Z% > 15 THEN Z% = 15ãIF Z% < 0 THEN Z% = 0ãOBJ(ACTT).BACKCLR = Z%ãLOCATE 9, 18: PRINT "<" + ZDIGIT(Z%) + ">"ãIF I$ = CHR$(13) THENãCOLOR 15, 1ãLOCATE 9, 18: PRINT " " + ZDIGIT(Z%) + " "ãEXIT SUBãEND IFãIF I$ = CHR$(27) THENãCOLOR 15, 1ãLOCATE 9, 18: PRINT " " + ZDIGIT(Z%) + " "ãEXIT SUBãEND IFãLOOPãEND SUBããSUB BCKGNDãFOR I = 1 TO 24ãLOCATE I, 1: PRINT STRING$(80, 177);ãNEXT IãLOCATE 25, 1: PRINT STRING$(80, 177);ãEND SUBããSUB EXITPãMOUSE 2ãCOLOR 7, 0ãCLSãSYSTEMãEND SUBããSUB FORECLRED (ACTT)ãSHARED OBJ() AS OBJECT, INDEX AS INTEGERãDIM REGS AS RegTypeãCOLOR 0, 15ãLOCATE 10, 18: PRINT "<" + ZDIGIT$(OBJ(ACTT).FORECLR) + ">"ãZ% = OBJ(ACTT).FORECLRãDOãI$ = INKEY$ãIF I$ = CHR$(0) + CHR$(77) THEN Z% = Z% + 1ãIF I$ = CHR$(0) + CHR$(75) THEN Z% = Z% - 1ãIF Z% > 15 THEN Z% = 15ãIF Z% < 0 THEN Z% = 0ãOBJ(ACTT).FORECLR = Z%ãLOCATE 10, 18: PRINT "<" + ZDIGIT(Z%) + ">"ãIF I$ = CHR$(13) THENãCOLOR 15, 1ãLOCATE 10, 18: PRINT " " + ZDIGIT(Z%) + " "ãEXIT SUBãEND IFãIF I$ = CHR$(27) THENãCOLOR 15, 1ãLOCATE 10, 18: PRINT " " + ZDIGIT(Z%) + " "ãEXIT SUBãEND IFãLOOPãEND SUBããSUB MENUãDIM REGS AS RegTypeãCOLOR 15, 1ãWIN 1, 1, 40, 25, ""ãCOLOR 0, 15ãLOCATE 1, 2: PRINT "        QB Fixed Window Design        "ãCOLOR 15, 1ãLOCATE 2, 2: PRINT " New                                  "ãLOCATE 3, 2: PRINT " Save in QuickBasic                   "ãLOCATE 4, 2: PRINT " Exit                                 "ãLOCATE 5, 1: PRINT "ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´"ãLOCATE 6, 2: PRINT "                                      "ãLOCATE 7, 2: PRINT "                                      "ãLOCATE 8, 2: PRINT "                                      "ãLOCATE 9, 2: PRINT "                                      "ãLOCATE 10, 2: PRINT "                                      "ãLOCATE 11, 2: PRINT "                                      "ãLOCATE 12, 2: PRINT "                                      "ãLOCATE 13, 2: PRINT "                                      "ãLOCATE 14, 2: PRINT "                                      "ãDOãREGS.ax = 3ãINTERRUPT 51, REGS, REGSãX4 = INT((80 / 640) * REGS.cx) + 1ãY4 = INT((25 / 200) * REGS.dx) + 1ãIF REGS.bx = 1 THENã   IF X4 < 40 THENã   IF Y4 = 2 THEN NEWã   IF Y4 = 3 THEN SAVEã   IF Y4 = 4 THEN EXITPã   END IFã   END IFã   IF X4 > 40 THENã   EXIT SUBã   END IFãLOOPãEND SUBããSUB MOUSE (A)ãDIM REGS AS RegTypeãREGS.ax = AãINTERRUPT 51, REGS, REGSãEND SUBããSUB NEWãSHARED OBJ() AS OBJECT, INDEX AS INTEGERãFOR I = 0 TO 300ãOBJ(I).X1 = 0ãOBJ(I).Y1 = 0ãOBJ(I).X2 = 0ãOBJ(I).Y2 = 0ãOBJ(I).BACKCLR = 0ãOBJ(I).FORECLR = 0ãOBJ(I).CAPTION = ""ãNEXT IãINDEX = 0ãEND SUBããSUB PROPERTY (ACTTOOL)ãSHARED OBJ() AS OBJECT, INDEX AS INTEGERãDIM REGS AS RegTypeãCOLOR 15, 1ãWIN 3, 6, 60, 15, ""ãCOLOR 0, 15ãLOCATE 6, 4: PRINT "Property            "ãCOLOR 15, 1ãLOCATE 8, 6: PRINT "           ÚÄÄÄÄ¿"ãLOCATE 9, 6: PRINT "Back Color ³    ³"ãLOCATE 10, 6: PRINT "Fore Color ³    ³"ãLOCATE 11, 6: PRINT "           ÀÄÄÄÄÙ"ãLOCATE 12, 6: PRINT "           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿"ãLOCATE 13, 6: PRINT "Caption    ³                                       ³"ãLOCATE 14, 6: PRINT "           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ"ãLOCATE 9, 19: PRINT ZDIGIT$(OBJ(ACTTOOL).BACKCLR)ãLOCATE 10, 19: PRINT ZDIGIT$(OBJ(ACTTOOL).FORECLR)ãLOCATE 13, 18: PRINT LEFT$(OBJ(ACTTOOL).CAPTION, 39)ãDOãREGS.ax = 3ãINTERRUPT 51, REGS, REGSãX4 = INT((80 / 640) * REGS.cx) + 1ãY4 = INT((25 / 200) * REGS.dx) + 1ãIF REGS.bx = 1 THENãIF X4 > 17 AND X4 < 57 AND Y4 > 12 AND Y4 < 14 THENãLOCATE 13, 18: INPUT "", OBJ(ACTTOOL).CAPTIONãEND IFãIF X4 > 5 AND X4 < 22 AND Y4 > 8 AND Y4 < 11 THENãIF Y4 = 9 THEN BACKCLRED ACTTOOLãIF Y4 = 10 THEN FORECLRED ACTTOOLãEND IFãIF Y4 < 6 OR Y4 > 15 OR X4 < 7 OR X4 > 60 THEN EXIT SUBãEND IFãLOOPãEND SUBããSUB RECONSTRUCTãSHARED OBJ() AS OBJECTãCOLOR 7, 0ãCLSãBCKGNDãFOR I = 0 TO 300ãIF OBJ(I).X1 = 0 THEN EXIT FORãCOLOR OBJ(I).FORECLR, OBJ(I).BACKCLRãWIN OBJ(I).X1, OBJ(I).Y1, OBJ(I).X2, OBJ(I).Y2, RTRIM$(OBJ(I).CAPTION)ãNEXT IãMOUSE 1ãEND SUBããSUB SAVEãSHARED OBJ() AS OBJECTãCOLOR 0, 7ãLOCATE 5, 6: PRINT " Save as QuickBasic 4.5 File  "ãCOLOR 15, 1ãLOCATE 6, 2: PRINT "FileName:                             "ãLOCATE 7, 2: PRINT "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿"ãLOCATE 8, 2: PRINT "³                                    ³"ãLOCATE 9, 2: PRINT "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ"ãLOCATE 8, 3: INPUT "", A$ãIF A$ = "" THEN EXIT SUBãOPEN A$ FOR OUTPUT AS #1ãPRINT #1, "DECLARE SUB BCKGND ()"ãPRINT #1, "DECLARE SUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)"ãPRINT #1, "DECLARE SUB WININTRO()"ãPRINT #1, "SUB WININTRO"ããFOR I% = 0 TO 300ãX = I%ãIF OBJ(X).X1 = 0 THEN EXIT FORãPRINT #1, "COLOR " + STR$(OBJ(X).FORECLR) + "," + STR$(OBJ(X).BACKCLR)ãPRINT #1, "WIN "; STR$(OBJ(X).X1); ","; STR$(OBJ(X).Y1); ","; STR$(OBJ(X).X2); ","; STR$(OBJ(X).Y2); ","; CHR$(34); RTRIM$(OBJ(X).CAPTION); CHR$(34)ãNEXT I%ããPRINT #1, "END SUB"ãPRINT #1, "SUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)"ãPRINT #1, "FOR I% = Y1% + 1 TO Y2% - 1"ãPRINT #1, "LOCATE I%, X1 + 1: PRINT STRING$(X2 - X1, 32);"ãPRINT #1, "Next I%"ãPRINT #1, "LOCATE Y1, X1 + 1: PRINT STRING$(X2 - X1, 196);"ãPRINT #1, "LOCATE Y2, X1 + 1: PRINT STRING$(X2 - X1, 196);"ãPRINT #1, "FOR I = Y1 + 1 TO Y2 - 1"ãPRINT #1, "LOCATE I, X1: PRINT CHR$(179);"ãPRINT #1, "LOCATE I, X2: PRINT CHR$(179);"ãPRINT #1, "NEXT I"ãPRINT #1, "LOCATE Y1, X1: PRINT CHR$(218);"ãPRINT #1, "LOCATE Y1, X2: PRINT CHR$(191);"ãPRINT #1, "LOCATE Y2, X1: PRINT CHR$(192);"ãPRINT #1, "LOCATE Y2, X2: PRINT CHR$(217);"ãPRINT #1, "IF A$ <> " + CHR$(34) + CHR$(34) + " THEN"ãPRINT #1, "LOCATE Y1, X1 + 1: PRINT A$;"ãPRINT #1, "END IF"ãPRINT #1, "END SUB"ãPRINT #1, "SUB BCKGND"ãPRINT #1, "FOR I = 1 TO 24"ãPRINT #1, "LOCATE I, 1: PRINT STRING$(80, 177);"ãPRINT #1, "NEXT I"ãPRINT #1, "LOCATE 25, 1: PRINT STRING$(80, 177);"ãPRINT #1, "END SUB"ãCLOSE #1ãCOLOR 15, 1ãLOCATE 5, 6: PRINT "                              "ãLOCATE 6, 2: PRINT "                                      "ãLOCATE 7, 2: PRINT "                                      "ãLOCATE 8, 2: PRINT "                                      "ãLOCATE 9, 2: PRINT "                                      "ãEND SUBããSUB TOOLBAR (X3, Y3)ãSHARED OBJ() AS OBJECT, INDEX AS INTEGERãDIM REGS AS RegTypeãFOR I = 0 TO 300ãIF OBJ(I).X1 = 0 THEN EXIT FORãIF OBJ(I).X1 <= X3 THENãIF OBJ(I).Y1 <= Y3 THENãIF OBJ(I).X2 >= X3 THENãIF OBJ(I).Y2 >= Y3 THENãACTTOOL = IãTOOLFOUND = 1ãLOCATE 1, 1: PRINT IãEND IFãEND IFãEND IFãEND IFãNEXT IãIF TOOLFOUND = 0 THEN EXIT SUBãCOLOR 0, 15ãWIN OBJ(ACTTOOL).X1, OBJ(ACTTOOL).Y1, OBJ(ACTTOOL).X2, OBJ(ACTTOOL).Y2, RTRIM$(OBJ(ACTTOOL).CAPTION)ãCOLOR 15, 1ãWIN 3, 2, 24, 7, "ToolBar"ããLOCATE 3, 4: PRINT LEFT$(OBJ(ACTOOL).CAPTION, 12); " ("; ACTTOOL; ")"ãLOCATE 4, 3: PRINT "ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´"ãLOCATE 5, 4: PRINT "Delete              "ãLOCATE 6, 4: PRINT "Property            "ãDOãREGS.ax = 3ãINTERRUPT 51, REGS, REGSã'INT((80 / 640) * REGS.cx) + 1ã'INT((25 / 200) * REGS.dx) + 1ãX4 = INT((80 / 640) * REGS.cx) + 1ãY4 = INT((25 / 200) * REGS.dx) + 1ãIF REGS.bx = 1 THENãIF X4 > 3 AND Y4 > 4 AND X4 < 24 AND Y4 < 8 THENãIF Y4 = 5 THENãCOLOR 0, 15ãLOCATE 5, 4: PRINT "Delete              "ãFOR I = ACTTOOL + 1 TO 300ãOBJ(I - 1).X1 = OBJ(I).X1ãOBJ(I - 1).Y1 = OBJ(I).Y1ãOBJ(I - 1).X2 = OBJ(I).X2ãOBJ(I - 1).Y2 = OBJ(I).Y2ãOBJ(I - 1).BACKCLR = OBJ(I).BACKCLRãOBJ(I - 1).FORECLR = OBJ(I).FORECLRãOBJ(I - 1).CAPTION = OBJ(I).CAPTIONãNEXT IãINDEX = INDEX - 1ãEXIT SUBãEND IFãIF Y4 = 6 THENãCOLOR 0, 15ãLOCATE 6, 4: PRINT "Property            "ãPROPERTY ACTTOOLãEXIT SUBãEND IFãEND IFããIF X4 < 3 OR Y4 < 2 OR X4 > 24 OR Y4 > 8 THENãEXIT SUBãEND IFãEND IFãLOOPãEND SUBããSUB WIN (X1 AS INTEGER, Y1 AS INTEGER, X2 AS INTEGER, Y2 AS INTEGER, A$)ãIF X1 > X2 THENãSWAP X1, X2ãEND IFãIF Y1 > Y2 THENãSWAP Y1, Y2ãEND IFãIF X2 - X1 = 0 THENãEXIT SUBãEND IFãIF Y2 - Y1 = 0 THENãEXIT SUBãEND IFããFOR I% = Y1% + 1 TO Y2% - 1ãLOCATE I%, X1 + 1: PRINT STRING$(X2 - X1, 32);ãNEXT I%ãLOCATE Y1, X1 + 1: PRINT STRING$(X2 - X1, 196);ãLOCATE Y2, X1 + 1: PRINT STRING$(X2 - X1, 196);ãFOR I = Y1 + 1 TO Y2 - 1ãLOCATE I, X1: PRINT CHR$(179);ãLOCATE I, X2: PRINT CHR$(179);ãNEXT IãLOCATE Y1, X1: PRINT CHR$(218);ãLOCATE Y1, X2: PRINT CHR$(191);ãLOCATE Y2, X1: PRINT CHR$(192);ãLOCATE Y2, X2: PRINT CHR$(217);ãIF A$ <> "" THENãLOCATE Y1, X1 + 1: PRINT A$;ãEND IFãEND SUBããFUNCTION ZDIGIT$ (A%)ãIF A% < 10 THEN ZDIGIT$ = "0" + RTRIM$(LTRIM$(STR$(A%)))ãIF A% >= 10 THEN ZDIGIT$ = RTRIM$(LTRIM$(STR$(A%)))ãEND FUNCTIONãCharles Godard                 PERCENT BOX                    FidoNet QUIK_BAS Echo          06-22-96 (00:00)       QB, QBasic, PDS        149  4264     PERCENT.BAS 'Percent.bas by Charles Godard 06/22/96ã'Opens, maintains, then closes a popup box to be used whenã'copying a file or performing other task, to pacify the userã'while he waits.ãã'Switch% = 0 turns it onã'Switch% = 1 maintains itã'Switch% = 2 closes itã'Pass to it, a number between 1 and 100 and the proper switchã'PercentBox 0, 0  'you must 1st open the boxã'PercentBox 1, (Percent%) 'maintain it with this.  Percent%ã'    MUST be in parenthesis or else MUST be a numeric value.ã'PercentBox 2, 0 'close it with thisã'give it a number between 0 and 100, and increment it as neededã'the delay's, STEP, and for/next are for demo onlyãã'I haven't tested this except in this program.  It could need someã'modification when run in a real program. <Oh well> :)ãã'inspired by reading in the conference.. Wellerstein to Goldbloomã'BTW, Alex, I liked yours, never got James' to run. PB, I guess :)ãã'I feel like the shipwrecked sailor, sending messages in a bottle.ã'If anyone sees this message in a bottle, I sure would like toã'hear about it.  I've been posting messages since feb, and theã'only response that I have gotten was the one the other day fromã'Joe.  I'm hoping that I am now making the trip! :)ããDEFINT A-ZãDECLARE SUB printScreen (Tr, Lc, H, W, Fg, Bg)ãDECLARE SUB copyScreen (Tr, Lc, H, W)ãDECLARE SUB PercentBox (Switch%, Percent%)ããTYPE Sdataã   Char  AS STRING * 1ã   Attr AS STRING * 1ãEND TYPEãREDIM SHARED x(25, 80) AS SdataãDIM SHARED Bg, FgãCLSãSCREEN 0ã'put stuff on screenãCOLOR &H7, 1: FOR i = 292 TO 678: PRINT i; : NEXT iããPercentBox 0, 0ããDly = 1: GOSUB delayã   FOR Percent% = 1 TO 100 STEP 9ã      PercentBox 1, (Percent%)  'you can change the name ofã      GOSUB delay               'Percent% and remove the ()ã   NEXT Percent%ãGOSUB delayããPercentBox 2, 0ããENDããdelay:ãT& = TIMER: DO WHILE (ABS(T& - TIMER) < Dly) AND INKEY$ = "": LOOPãRETURNããSUB copyScreen (Tr, Lc, H, W)ãã'Attr = SCREEN(Tr + 1, Lc + 1, 1)ã'Fg = Attr AND &HFã'Bg = Attr \ &H10ããFOR cr = Tr TO Tr + Hã   FOR cc = Lc TO Lc + Wã      x(cr, cc).Char = CHR$(SCREEN(cr, cc))ã      x(cr, cc).Attr = CHR$(SCREEN(cr, cc, 1))ã   NEXT ccãNEXT crããEND SUBããSUB PercentBox (Switch%, Percent%)ãTr = 11: Lc = 20: W = 43: H = 4: 'Fg = &H4: Bg = &H4:ããSTATIC boxOpenããSELECT CASE Switch%ã  CASE IS = 0  'open the boxã      'read data from the screenã      CALL copyScreen(Tr, Lc, H, W)ã      'put popup on screenã      FOR cr = Tr TO Tr + Hã            LOCATE cr, Lcã            COLOR 4, 4ã            PRINT STRING$(W, " ")ã      NEXT crã     ã      boxOpen = 1ã        ã            'set up border stylesã            BDRtl = 218: BDRtr = 191: BDRlc = 192: BDRrc = 217: 'cornersã            BDRv = 179: BDRh = 196:          'horizontal, vertical sidesãã         'Bdr top leftã         COLOR &HE, 4ã         LOCATE Tr, Lc: PRINT CHR$(BDRtl);  'top lt corner BDRã         'top BDR top horizontalã         FOR i = Tr TO Tr + W - 2: PRINT CHR$(BDRh); : NEXT iã         'top BDR Rt cornerã         LOCATE Tr, Lc + W: PRINT ; CHR$(BDRtr);ã         'Lt BDR verticalã         FOR i = Tr + 1 TO Tr + H - 1: LOCATE i, Lc: PRINT CHR$(BDRv); : LOCATE i, Lc + W: PRINT CHR$(BDRv); : NEXT iã         'bottom rt cornerã         LOCATE Tr + H, Lc + W: PRINT CHR$(BDRrc);ã         'left cornerã         LOCATE Tr + H, Lc: PRINT CHR$(BDRlc)ã         'right horizontalã         LOCATE Tr + H, Lc + 1: FOR i = Lc TO Lc + W - 2:ã         PRINT CHR$(BDRh); : NEXTãã  CASE IS = 1 'maintain boxã         IF boxOpen = 1 THENã             LOCATE Tr, Lc + 19: PRINT STR$(Percent%); "%"ã             Percent% = (Percent% / 100) * 40ã             LOCATE Tr + 2, Lc + 2: PRINT STRING$(Percent%, "Û")ã         END IFã ã  CASE IS = 2ã      'Close PercentBoxã      IF boxOpen = 1 THENã       boxOpen = 0ã       CALL printScreen(Tr, Lc, H, W, Fg, Bg)ã      END IFã  CASE ELSEãEND SELECTããEND SUBããSUB printScreen (Tr, Lc, H, W, Fg, Bg)ããCOLOR Fg, BgããFOR cr = Tr TO Tr + Hã   FOR cc = Lc TO Lc + Wã      LOCATE cr, ccã      Attr = ASC(x(cr, cc).Attr)ã      Fg = Attr AND &HFã      Bg = Attr \ &H10ã      COLOR Fg, Bgã      PRINT x(cr, cc).Char;ã   NEXT ccãNEXT crããEND SUBãDarryl Schneider               ENCODE/DECODE MESSAGE          fish2@datanet.ab.ca            07-17-96 (19:37)       QB, QBasic, PDS        463  12945    QCODE.BAS   'QCode - Version 1.0ã'ã'Messages can be encoded and decodedã'with QCode. A password is required toã'view a message, and is specified whenã'writing a message. Make sure everythingã'is in the C:\ directory and you willã'have no problem. Enjoy!ã'ã'Written by Darryl Schneiderã'fish2@datanet.ab.caã'The QBasic Zoneã'http://www.geocities.com/SiliconValley/8191/ã'ãSCREEN 12                              'set screen mode to 12 andãDEFSTR A-B, D-M, R, U                  'give some standard variableãDEFINT N-Q, S-T, V-W                   'settingsãDEFLNG X-ZããDIM CURSOR(1 TO 500)                    'draw the triangle cursorãLINE (50, 50)-(50, 66), 3ãLINE (50, 50)-(66, 58), 3ãLINE (50, 66)-(66, 58), 3ãPAINT (55, 55), 6, 3ãGET (50, 50)-(66, 66), CURSORããENTER = CHR$(13)                        'define all of the arrow keysãUP = CHR$(0) + CHR$(72)ãDOWN = CHR$(0) + CHR$(80)ãLEFT = CHR$(0) + CHR$(75)ãRIGHT = CHR$(0) + CHR$(77)ããMAINMENU:                               'just look at the label toãCLS                                     'find out what this sectionãLINE (160, 48)-(480, 230), 11, BF       'is aboutãLINE (160, 48)-(480, 63), 12, BFãLOCATE 4, 38: COLOR 14: PRINT "QCode"ãCOLOR 15ãLOCATE 7, 35: PRINT "Write a message"ãLOCATE 9, 35: PRINT "View a message"ãLOCATE 11, 35: PRINT "About QCode"ãLOCATE 13, 35: PRINT "Quit"ããMM1:                                     'write a messageãLINE (240, 70)-(270, 220), 11, BFãPUT (250, 95), CURSORãDOãA1 = INKEY$ãIF A1 = ENTER THEN GOSUB WRITEMESSAGEãIF A1 = UP THEN GOSUB MM4ãIF A1 = DOWN THEN GOSUB MM2ãLOOPããMM2:                                     'view a messageãLINE (240, 70)-(270, 220), 11, BFãPUT (250, 126), CURSORãDOãA2 = INKEY$ãIF A2 = ENTER THEN GOSUB VIEWMESSAGEãIF A2 = UP THEN GOSUB MM1ãIF A2 = DOWN THEN GOSUB MM3ãLOOPããMM3:                                     'go to the about screenãLINE (240, 70)-(270, 220), 11, BFãPUT (250, 159), CURSORãDOãA3 = INKEY$ãIF A3 = ENTER THEN GOSUB ABOUTãIF A3 = UP THEN GOSUB MM2ãIF A3 = DOWN THEN GOSUB MM4ãLOOPããMM4:                                     'quitãLINE (240, 70)-(270, 220), 11, BFãPUT (250, 191), CURSORãDOãA4 = INKEY$ãIF A4 = ENTER THEN GOSUB QUITãIF A4 = UP THEN GOSUB MM3ãIF A4 = DOWN THEN GOSUB MM1ãLOOPããWRITEMESSAGE:ãCLSãMNAME = ""ãMPASSWORD = ""ãMESSAGE = ""ãMESSAGE1 = ""ãSSAVE = 0ããOPEN "C:\UNTITLED.MSG" FOR OUTPUT AS #1ãWRITE #1, MPASSWORDãWRITE #1, MESSAGEãCLOSE #1ããOPEN "C:\UNTITLED.MSG" FOR OUTPUT AS #2ãLINE (0, 0)-(640, 17), 12, BFãCOLOR 14ãLOCATE 1, 28: PRINT "QCode - Writing a Message"ãCOLOR 15ãLOCATE 3, 10: INPUT "Message Name (max. 8 characters): ", MNAMEãLOCATE 4, 10: INPUT "Message Password: ", MPASSWORDãMNAME = UCASE$(MNAME)ãMPASSWORD = UCASE$(MPASSWORD)           'create a message name andãWRITE #2, MPASSWORD                     'passwordãLOCATE 6, 10: PRINT "Enter Message: "ãN1 = 8ãN2 = 1ãNEXTLETTER1:ãDO                                      'message is enteredãB1 = UCASE$(INKEY$)ãIF B1 = "A" THEN B2 = "^"               'these are all of the characterãIF B1 = "B" THEN B2 = "Z"               'representationsãIF B1 = "C" THEN B2 = "<"ãIF B1 = "D" THEN B2 = ":"ãIF B1 = "E" THEN B2 = "W"ãIF B1 = "F" THEN B2 = "Y"ãIF B1 = "G" THEN B2 = "~"ãIF B1 = "H" THEN B2 = "#"ãIF B1 = "I" THEN B2 = "N"ãIF B1 = "J" THEN B2 = "F"ãIF B1 = "K" THEN B2 = "I"ãIF B1 = "L" THEN B2 = "."ãIF B1 = "M" THEN B2 = "P"ãIF B1 = "N" THEN B2 = "X"ãIF B1 = "O" THEN B2 = "*"ãIF B1 = "P" THEN B2 = "&"ãIF B1 = "Q" THEN B2 = "V"ãIF B1 = "R" THEN B2 = "H"ãIF B1 = "S" THEN B2 = "C"ãIF B1 = "T" THEN B2 = "-"ãIF B1 = "U" THEN B2 = "%"ãIF B1 = "V" THEN B2 = "L"ãIF B1 = "W" THEN B2 = "E"ãIF B1 = "X" THEN B2 = "A"ãIF B1 = "Y" THEN B2 = "B"ãIF B1 = "Z" THEN B2 = "?"ãIF B1 = "1" THEN B2 = "9"ãIF B1 = "2" THEN B2 = "6"ãIF B1 = "3" THEN B2 = "4"ãIF B1 = "4" THEN B2 = "3"ãIF B1 = "5" THEN B2 = "1"ãIF B1 = "6" THEN B2 = "7"ãIF B1 = "7" THEN B2 = "8"ãIF B1 = "8" THEN B2 = "2"ãIF B1 = "9" THEN B2 = "5"ãIF B1 = "." THEN B2 = "G"ãIF B1 = "," THEN B2 = "$"ãIF B1 = "!" THEN B2 = "("ãIF B1 = "$" THEN B2 = ")"ãIF B1 = "@" THEN B2 = "="ãIF B1 = "-" THEN B2 = "+"ãIF B1 = "*" THEN B2 = "\"ãIF B1 = "?" THEN B2 = "/"ãIF B1 = "0" THEN B2 = "S"ãIF B1 = " " THEN B2 = " "ãIF B1 = "'" THEN B2 = "K"ãIF B1 = ENTER THEN GOSUB SAVEMESSAGEãLOOP UNTIL B1 <> ""ãLOCATE N1, N2: PRINT B1ãN2 = N2 + 1ãIF N2 = 60 THENã        N2 = 1ã        N1 = N1 + 1ãEND IFãMESSAGE1 = MESSAGE1 + B1             'puts all of the letters intoãMESSAGE = MESSAGE + B2               'one stringãB1 = ""ãGOSUB NEXTLETTER1ããSAVEMESSAGE:ãCLSãLINE (0, 0)-(640, 17), 12, BFãCOLOR 14ãLOCATE 1, 28: PRINT "QCode - Writing a Message"ãCOLOR 15ãLOCATE 3, 10: PRINT MESSAGE1ãLINE (100, 405)-(540, 440), 11, BFãLINE (100, 405)-(540, 440), 12, BãLOCATE 27, 18: PRINT "Save Message"ãLOCATE 27, 36: PRINT "Print Message"ãLOCATE 27, 55: PRINT "Main Menu"ããWM1:                               'saves the message in .msg formatãPUT (115, 415), CURSORãDOãE1 = INKEY$ãIF E1 = ENTER THENã              WRITE #2, MESSAGEã              CLOSE #2ã              FILENAME = "C:\" + MNAME + ".MSG"ã              NAME "C:\UNTITLED.MSG" AS FILENAMEã              CLOSE #2ã              SSAVE = 1ã              GOSUB WM1ãEND IFãIF E1 = LEFT THENã         LINE (115, 415)-(131, 431), 11, BFã         GOSUB WM3ãEND IFãIF E1 = RIGHT THENã         LINE (115, 415)-(131, 431), 11, BFã         GOSUB WM2ãEND IFãLOOPããWM2:                                'prints the messageãPUT (260, 415), CURSORãDOãE2 = INKEY$ãIF E2 = ENTER THENã         LPRINT "QCode Message"ã         LPRINT ""ã         IF SSAVE = 1 THEN LPRINT "File: "; FILENAMEã         LPRINT ""ã         LPRINT "Original Message:"ã         LPRINT ""ã         LPRINT "   "; MESSAGE1ã         LPRINT ""ã         LPRINT "Coded Message:"ã         LPRINT ""ã         LPRINT "   "; MESSAGEã         LPRINT ""ã         LPRINT ""ã         LPRINT "QCode was written by Darryl Schneider"ã         LPRINT ""ã         LPRINT ""ã         LPRINT ""ã         GOSUB WM2ãEND IFãIF E2 = LEFT THENã         LINE (260, 415)-(276, 431), 11, BFã         GOSUB WM1ãEND IFãIF E2 = RIGHT THENã         LINE (260, 415)-(276, 431), 11, BFã         GOSUB WM3ãEND IFãLOOPããWM3:                                     'return to main menuãPUT (412, 415), CURSORãDOãE3 = INKEY$ãIF E3 = ENTER THENã         IF SSAVE = 0 THENã                CLOSE #2ã                KILL "C:\UNTITLED.MSG"ã         END IFã         GOSUB MAINMENUãEND IFãIF E3 = LEFT THENã         LINE (412, 415)-(428, 431), 11, BFã         GOSUB WM2ãEND IFãIF E3 = RIGHT THENã         LINE (412, 415)-(428, 431), 11, BFã         GOSUB WM1ãEND IFãLOOPããVIEWMESSAGE:ãCLSãN3 = 8ãN4 = 1ãN5 = 8ãN6 = 1ãMNAME = ""ãMPASSWORD = ""ãMESSAGE = ""ãMP1 = ""ãMP2 = ""ããLINE (0, 0)-(640, 17), 12, BFãCOLOR 14ãLOCATE 1, 28: PRINT "QCode - Viewing a Message"ãCOLOR 15ãLOCATE 3, 10: INPUT "Message Name (max. 8 characters): ", DNAMEãLOCATE 4, 10: INPUT "Message Password: ", DPASSWORDãDNAME = UCASE$(DNAME)ãDPASSWORD = UCASE$(DPASSWORD)ãJFILE = "C:\" + DNAME + ".MSG"ãOPEN JFILE FOR INPUT AS #3              'opens a QCode file forãINPUT #3, MPASSWORD                     'viewingããVIEWME:ãLOCATE 6, 10: PRINT "Message: "; JFILEãINPUT #3, MESSAGEãY = LEN(MESSAGE)ãS = 1ãIF DPASSWORD = MPASSWORD THEN                'if password is correct,ã        DO                                   'displays decoded messageã        B3 = MID$(MESSAGE, S, 1)ã        IF B3 = "^" THEN B4 = "A"            'these are all of theã        IF B3 = "Z" THEN B4 = "B"            'character representationsã        IF B3 = "<" THEN B4 = "C"ã        IF B3 = ":" THEN B4 = "D"ã        IF B3 = "W" THEN B4 = "E"ã        IF B3 = "Y" THEN B4 = "F"ã        IF B3 = "~" THEN B4 = "G"ã        IF B3 = "#" THEN B4 = "H"ã        IF B3 = "N" THEN B4 = "I"ã        IF B3 = "F" THEN B4 = "J"ã        IF B3 = "I" THEN B4 = "K"ã        IF B3 = "." THEN B4 = "L"ã        IF B3 = "P" THEN B4 = "M"ã        IF B3 = "X" THEN B4 = "N"ã        IF B3 = "*" THEN B4 = "O"ã        IF B3 = "&" THEN B4 = "P"ã        IF B3 = "V" THEN B4 = "Q"ã        IF B3 = "H" THEN B4 = "R"ã        IF B3 = "C" THEN B4 = "S"ã        IF B3 = "-" THEN B4 = "T"ã        IF B3 = "%" THEN B4 = "U"ã        IF B3 = "L" THEN B4 = "V"ã        IF B3 = "E" THEN B4 = "W"ã        IF B3 = "A" THEN B4 = "X"ã        IF B3 = "B" THEN B4 = "Y"ã        IF B3 = "?" THEN B4 = "Z"ã        IF B3 = "9" THEN B4 = "1"ã        IF B3 = "6" THEN B4 = "2"ã        IF B3 = "4" THEN B4 = "3"ã        IF B3 = "3" THEN B4 = "4"ã        IF B3 = "1" THEN B4 = "5"ã        IF B3 = "7" THEN B4 = "6"ã        IF B3 = "8" THEN B4 = "7"ã        IF B3 = "2" THEN B4 = "8"ã        IF B3 = "5" THEN B4 = "9"ã        IF B3 = "S" THEN B4 = "0"ã        IF B3 = "G" THEN B4 = "."ã        IF B3 = "$" THEN B4 = ","ã        IF B3 = "(" THEN B4 = "!"ã        IF B3 = ")" THEN B4 = "$"ã        IF B3 = "=" THEN B4 = "@"ã        IF B3 = "+" THEN B4 = "-"ã        IF B3 = "\" THEN B4 = "*"ã        IF B3 = "/" THEN B4 = "?"ã        IF B3 = " " THEN B4 = " "ã        IF B3 = "K" THEN B4 = "'"ã        LOCATE N3, N4: PRINT B4ã        MP1 = MP1 + B4ã        N4 = N4 + 1ã        S = S + 1ã                IF N4 = 60 THENã                        N4 = 1ã                        N3 = N3 + 1ã                END IFã        LOOP UNTIL S = Y + 1ãEND IFããIF NOT DPASSWORD = MPASSWORD THEN          'if password is incorrect,ã        DO                                 'displays encoded messageã        B5 = MID$(MESSAGE, S, 1)ã        LOCATE N5, N6: PRINT B5ã        MP2 = MP2 + B5ã        N6 = N6 + 1ã        S = S + 1ã                IF N6 = 60 THENã                        N6 = 1ã                        N5 = N5 + 1ã                END IFã        LOOP UNTIL S = Y + 1ãEND IFã       ãCLOSE #3ããLINE (170, 405)-(470, 440), 11, BFãLINE (170, 405)-(470, 440), 12, BãLOCATE 27, 28: PRINT "Print Message"ãLOCATE 27, 48: PRINT "Main Menu"ããVM1:                                     'prints the messageãPUT (195, 415), CURSORãDOãE4 = INKEY$ãIF E4 = ENTER THENã         LPRINT "QCode Message"ã         LPRINT ""ã         IF SSAVE = 1 THEN LPRINT "File: "; FILENAMEã         LPRINT ""ã         LPRINT "Original Message:"ã         LPRINT ""ã         IF MP1 <> "" THEN LPRINT "   "; MP1ã         IF MP2 <> "" THEN LPRINT "    Sorry, you need the password!"ã         LPRINT ""ã         LPRINT "Coded Message:"ã         LPRINT ""ã         LPRINT "   "; MESSAGEã         LPRINT ""ã         LPRINT ""ã         LPRINT "QCode was written by Darryl Schneider"ã         LPRINT ""ã         LPRINT ""ã         LPRINT ""ã         GOSUB VM1ãEND IFãIF E4 = LEFT THENã         LINE (195, 415)-(211, 431), 11, BFã         GOSUB VM2ãEND IFãIF E4 = RIGHT THENã         LINE (195, 415)-(211, 431), 11, BFã         GOSUB VM2ãEND IFãLOOPããVM2:                                    'returns to main menuãPUT (355, 415), CURSORãDOãE5 = INKEY$ãIF E5 = ENTER THENã         GOSUB MAINMENUãEND IFãIF E5 = LEFT THENã         LINE (355, 415)-(371, 431), 11, BFã         GOSUB VM1ãEND IFãIF E5 = RIGHT THENã         LINE (355, 415)-(371, 431), 11, BFã         GOSUB VM1ãEND IFãLOOPããABOUT:                                'the infamous about screenãCLSãLINE (0, 0)-(640, 17), 12, BFãCOLOR 14ãLOCATE 1, 35: PRINT "About QCode"ãCOLOR 15ãPRINT ""ãPRINT ""ãPRINT "QCode was written in Microsoft QuickBasic by Darryl Schneider. The"ãPRINT "program is a message encoder/decoder. To use the program, first write"ãPRINT "a message. All message files are saved to the C:\ drive. The message"ãPRINT "name that you choose can be a maximum of 8 characters. No file extension"ãPRINT "or drive specification is required in the message name. The password"ãPRINT "is the key to opening the message. You must know the password to that"ãPRINT "particular message in order to decode it. Once you have finished writing"ãPRINT "the message, you may view it by selecting the option at the main menu."ãPRINT "Then just type in the message name and the password for that message,"ãPRINT "and it will be decoded. I included a print option so you can print"ãPRINT "out each of the messages. I hope you like the program. Enjoy!"ãPRINT ""ãPRINT "Darryl Schneider"ãPRINT "fish2@datanet.ab.ca"ãPRINT "The QBasic Zone"ãPRINT "http://www.geocities.com/SiliconValley/8191/"ããLINE (270, 405)-(370, 440), 11, BF          'draw the box at theãLINE (270, 405)-(370, 440), 12, B           'bottom of the screenãLOCATE 27, 38: PRINT "Main Menu"ããPUT (275, 415), CURSORãDOãG1 = INKEY$ãIF G1 = ENTER THEN GOSUB MAINMENU           'return to the main menuãLOOPããQUIT:ãENDãã'End of QCodeãJonathan Leger                 FAST PRINT REPLACEMENT         leger@mail.dtx.net             08-01-96 (11:34)       QB, QBasic, PDS        230  9505     XPRINT.BAS  ' This is a TWO part snippet (XPRINT.BAS and XPRINT.8 to follow)ãã'******************ã'*** XPRINT.BAS ***ã'****************************************************************************ã'*** This program will demonstrate the superior speed of Xprint over      ***ã'*** Qbasic and QuickBASIC's PRINT, COLOR and LOCATE statements.          ***ã'*** Xprint is typically about 350% - 400% faster than Qbasic and from    ***ã'*** 30% - 60% faster than QuickBASIC.                                    ***ã'***                                                                      ***ã'*** HOWEVER!  Please note that Xprint() performs _no_ error checking     ***ã'*** except for making sure the string is longer than 0 bytes, while      ***ã'*** QuickBASIC wont let you print off the screen, etc.  If this program  ***ã'*** did that error checking, it would be as slow as QuickBASIC, which    ***ã'*** would defeat the purpose! Absence of this error checking is not      ***                                         ã'*** dangerous unless you're printing a string that's longer than 16,000  ***ã'*** bytes to the screen (and I'm not even sure if that's completely      ***ã'*** dangerous...), which will go outside the bounds of your screen       ***ã'*** memory.  Anyone, however, who would do this is clearly not too swift ***ã'*** (mentally speaking) and probably needs to have his computer crash on ***ã'*** him every now and again to wake him up.                              ***ã'****************************************************************************ã'*** This demonstration program and the Xprint() routines were written by ***ã'*** Jonathan Leger (leger@mail.dtx.net), and may be freely distributed   ***ã'*** to anybody.  These routines are 100% absolutely no lies or nothin'   ***ã'*** FREE to the general public.  You can send me e-mail to praise my     ***ã'*** genious if you want, but I require nothing more. *grin*              ***ã'****************************************************************************ããDEFINT A-Zãã'*** The declaration of Absolute() is required for QB, which must be loadedã'*** with "/L QB" for it to work.  The declartion in Qbasic is optional.ãDECLARE SUB Absolute (arg1%, arg2%, arg3%, arg4%, arg5%, arg6%, arg7%, offset%)ãã'*** readyXprint() stores the machine language Xprint() routine, and must beã'*** called before using the Xprint.  Note, though, that it only needs to beã'*** called _once_.ãDECLARE SUB readyXprint ()ãã'*** The actual Xprint() routine.  Prints s$ to coordintes (x%,y%) on theã'*** screen in color fore%, back%.  Notice, though, that to keep the feelã'*** of BASIC's LOCATE, which is in the format LOCATE Y, X, the Y precedesã'*** the X in the Xprint() routine also.ãDECLARE SUB Xprint (s$, y%, x%, fore%, back%)ãã'*** This sub is used only in the demonstration, so you can trash it if youã'*** don't want it.ãDECLARE SUB testXprint ()ããSCREEN 0ãWIDTH 80, 25ããreadyXprint       'This routine must be called before using Xprint!ã                  'You only have to call it once though. :)ããtestXprint        'Lessee some comparisons...ããDEFSNG A-Zã'**********************ã'*** readyXprint()    *ã'**************************************************************************ã'*** This routine loads the xprint machine-language program into the    ***ã'*** xprint.asm$ string for use by the Xprint() routine.  This program  ***ã'*** _must_ be called before using the Xprint() routine, or the program ***ã'*** will crash!                                                        ***ã'**************************************************************************ã'*** All questions and comments welcome.  Send inquries to the me at    ***ã'*** leger@mail.dtx.net                                                 ***ã'**************************************************************************ãSUB readyXprintããSHARED asm$ãã'*** This is the actual X-print program.ã'*** It was written using A86--a truly beautiful assembler!ããasm$ = ""ãasm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(131)ãasm$ = asm$ + CHR$(126) + CHR$(10) + CHR$(0) + CHR$(116) + CHR$(66)ãasm$ = asm$ + CHR$(139) + CHR$(126) + CHR$(14) + CHR$(131) + CHR$(239)ãasm$ = asm$ + CHR$(1) + CHR$(137) + CHR$(251) + CHR$(193) + CHR$(231)ãasm$ = asm$ + CHR$(7) + CHR$(193) + CHR$(227) + CHR$(5) + CHR$(3)ãasm$ = asm$ + CHR$(251) + CHR$(131) + CHR$(110) + CHR$(12) + CHR$(1)ãasm$ = asm$ + CHR$(209) + CHR$(102) + CHR$(12) + CHR$(3) + CHR$(126)ãasm$ = asm$ + CHR$(12) + CHR$(139) + CHR$(86) + CHR$(18) + CHR$(193)ãasm$ = asm$ + CHR$(226) + CHR$(4) + CHR$(3) + CHR$(86) + CHR$(16)ãasm$ = asm$ + CHR$(30) + CHR$(142) + CHR$(94) + CHR$(8) + CHR$(139)ãasm$ = asm$ + CHR$(118) + CHR$(6) + CHR$(80) + CHR$(184) + CHR$(0)ãasm$ = asm$ + CHR$(184) + CHR$(142) + CHR$(192) + CHR$(88) + CHR$(139)ãasm$ = asm$ + CHR$(78) + CHR$(10) + CHR$(138) + CHR$(4) + CHR$(38)ãasm$ = asm$ + CHR$(136) + CHR$(5) + CHR$(38) + CHR$(136) + CHR$(85)ãasm$ = asm$ + CHR$(1) + CHR$(70) + CHR$(71) + CHR$(71) + CHR$(226)ãasm$ = asm$ + CHR$(242) + CHR$(31) + CHR$(93) + CHR$(203)ããEND SUBããDEFINT A-ZãSUB testXprintããLOCATE , , 0ãCLSããLOCATE 1, 1ãCOLOR 7, 0ãPRINT "XPRINT"ããt.xprint# = TIMERãFOR redraw = 1 TO 100ã   back = INT(RND * 7) + 1ã   FOR y = 2 TO 25ã       Xprint STRING$(80, " "), y, 1, 7, backã   NEXT yãNEXT redrawãt.xprint# = TIMER - t.xprint#ããCLSãLOCATE 1, 1ãCOLOR 7, 0ãPRINT "BASIC"ãt.basic# = TIMERãFOR redraw = 1 TO 100ã   COLOR 7, INT(RND * 7) + 1ã   FOR y = 2 TO 25ã      LOCATE y, 1ã      PRINT STRING$(80, " ");ã   NEXT yãNEXT redrawãt.basic# = TIMER - t.basic#ããCOLOR , 0ãCLSãPRINT "XPrint redrew the screen 100 times in"; t.xprint#; "seconds."ãPRINT "BASIC redrew the screen 100 times in"; t.basic#; "seconds."ãPRINTãPRINT "XPrint was approximately"; INT((t.basic# / t.xprint#) * 100); "% faster."ãEND SUBãã'*****************ã'*** Xprint()    *ã'**************************************************************************ã'*** Arguments:                                                         ***ã'***     s$       =     string to print                                 ***ã'***     y%       =     line to print at                                ***ã'***     x%       =     column to print at                              ***ã'***     fore%    =     foreground color (normal BASIC numbering used)  ***ã'***     back%    =     background color (normal BASIC numbering used)  ***ã'**************************************************************************ã'*** This routine was written by Jonathan Leger (leger@mail.dtx.net)    ***ã'*** using the A86 assembler.  The assembly-language file can be viewed ***ã'*** for further study (XPRINT.8).                                      ***ã'**************************************************************************ã'*** All questions and comments welcome.  Send inquries to the above    ***ã'*** e-mail address.                                                    ***ã'**************************************************************************ãSUB Xprint (s$, y%, x%, fore%, back%)ããSHARED asm$ããDEF SEG = VARSEG(asm$)ã   CALL Absolute(BYVAL back%, BYVAL fore%, BYVAL y%, BYVAL x%, BYVAL LEN(s$), BYVAL VARSEG(s$), BYVAL SADD(s$), SADD(asm$))ãDEF SEGããEND SUBãã;--------------------8<----[ Begin XPRINT.8 ]---->8---------------------ãã;*** Xprint for BASIC.ã;*** Prints a string to coordintes y%, x%, with color f%, b%, real fast. :)ã;*** call like this:ã;***ã;*** Call Absolute (b%, f%, y%, x%, len(s$), sadd(s$), varptr(s$), offset%)ã;***ã;*** WARNING:  This routine does _no_ error checking to see if you're goingã;***           off-screen with the string (for speed purposes), so pleaseã;***           be sure to check that in your program!ããPUSH BP     ;preserve BP!ãMOV BP,SPããSTRUC [BP]ã  JUNK1   DW  ?ã  JUNK2   DW  ?ã  JUNK3   DW  ?             ;the junk we don't need!ã  STR_OFF DW  ?             ;our string pointer [bp+6]ã  STR_SEG DW  ?             ;our string segment [bp+8]ã  LEN     DW  ?             ;our string length [bp+0a]ã  X       DW  ?             ;our x location [bp+0c]ã  Y       DW  ?             ;our y location [bp+0e]ã  FORE    DW  ?             ;foreground color [bp+10]ã  BACK    DW  ?             ;background color [bp+12]ãENDSããCMP LEN,00ãJE DoneããMOV DI,Y                    ;get the offset for the starting characterãSUB DI,1                    ;using the formula:ãMOV BX,DI                   ;     ( ( ( Y - 1 ) * 80 ) + X )ãSHL DI,7ãSHL BX,5ãADD DI,BXãSUB X,1ãSHL X,1ãADD DI,X                    ;DI now contains the starting offset.ããMOV DX,BACK                 ;calculate the color value using the formula:ãSHL DX,4                    ;     ( FOREGROUND + ( BACKGROUND * 16 ) )ãADD DX,FOREããPUSH DSããMOV DS,STR_SEG              ;string segmentãMOV SI,STR_OFF              ;string offsetãMOV ES,0B800                ;screen offset for color scren 0ãMOV CX,LENããPrintChar:ãMOV AL,DS:[SI]              ;put next character into ALãMOV ES:B[DI],AL             ;write it to screenãMOV ES:B[DI+1],DL           ;write color value to screenãINC SI                      ;next characterãINC DI,2                    ;next screen coordinateãLOOP PrintCharããDone:ããPOP DS                     ;restore DS for BASICãPOP BP                     ;restore BP for BASICãRETF                       ;return to BASIC!ãKurt Kuzba                     LINE INPUT REPLACEMENT         FidoNet QUIK_BAS Echo          03-21-96 (00:00)       QB, QBasic, PDS        82   3422     ELVIS.BAS   '>   Is here a way to get rig of cntrl-break?ã'>................ã'   Use INKEY$ instead of INPUT. Have a look at this.ã'_|_|_|   ELVIS.BASã'_|_|_|   This program allows the input of 'larger than life'ã'_|_|_|   strings with limited editing windows on the screen.ã'_|_|_|   BACKSPACE, HOME, END, LEFT, RIGHT, INSERT, DELETE,ã'_|_|_|   and ESCAPE are all active in the input routine.ã'_|_|_|   No warrantees or guarantees are given or implied.ã'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (3/21/96)ãDECLARE SUB Elvus (prompt$, max%, winsiz%, S$, sequins%)ãDECLARE FUNCTION Elvis$ (prompt$, max%, winsiz%, S$, sequins%)ãPRINTãPath$ = "C:\": p$ = "Please Enter Your Path =>"ãMystr$ = Elvis$(p$, 32, 8, Path$, 0)ãPRINT : PRINT UCASE$(Path$): PRINT Mystr$ãPass$ = "": p$ = "Please Enter Your Password =>"ãMystr$ = Elvis$(p$, 32, 8, Pass$, 1)ãPRINT : PRINT UCASE$(Pass$): PRINT Mystr$ãIF Mystr$ <> "friend" THEN PRINT "Wrong Password":  ELSE PRINT "OK"ãFUNCTION Elvis$ (prompt$, max%, winsiz%, S$, sequins%)ã   Elvus prompt$, max%, winsiz%, S$, sequins%: Elvis$ = S$ãEND FUNCTIONãSUB Elvus (prompt$, max%, winsiz%, S$, sequins%)ã   S$ = LTRIM$(RTRIM$(S$)): Cursor% = LEN(S$) - (Cursor% < max%)ã   F$ = "_": IF sequins% <> 0 THEN F$ = " "ã   Fill$ = STRING$(max%, F$)ã   S$ = LEFT$(S$ + Fill$, max%): INS% = -1: PRINT prompt$; " ";ã   Ybase% = POS(0)ã   WHILE done$ <> "DONE"ã      Sbase% = Cursor% - winsiz% + 1: IF Sbase% < 1 THEN Sbase% = 1ã      LOCATE , Ybase%, 0: Hid$ = STRING$(LEN(RTRIM$(S$)), "*")ã      IF sequins% = 0 THENã         PRINT MID$(S$ + Fill$, Sbase%, winsiz%); " ";ã      ELSEã         PRINT MID$(Hid$ + Fill$, Sbase%, winsiz%); " ";ã      END IFã      LOCATE , Ybase% + Cursor% - Sbase%, 1ã      k$ = "": WHILE k$ = "": k$ = INKEY$: WENDã      k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))ã      SELECT CASE k%ã         CASE 32 TO 127ã            IF INS% AND Cursor% < max% THENã               MID$(S$, Cursor% + 1) = MID$(S$, Cursor%)ã               S$ = LEFT$(S$, max%)ã            END IFã            MID$(S$, Cursor%, 1) = k$ã            IF Cursor% = max% THEN SOUND 999, 1ã            Cursor% = Cursor% - (Cursor% < max%)ã         CASE 13: IF S$ = Fill$ THEN S$ = ""ã            IF INSTR(S$, F$) > 0 THEN S$ = LEFT$(S$, INSTR(S$, F$) - 1)ã            EXIT SUBã         CASE 8ã            IF Cursor% > 1 THENã               Cursor% = Cursor% - 1ã               MID$(S$, Cursor%) = MID$(S$, Cursor% + 1)ã               MID$(S$, max%) = F$ã            ELSEã               SOUND 999, .7ã            END IFã         CASE 27: S$ = "": EXIT SUBã         CASE -71: Cursor% = 1ã         CASE -79: Cursor% = INSTR(S$, F$)ã            IF Cursor% = 0 THEN Cursor% = max%ã         CASE -82: INS% = -(INS% + 1): SOUND 1500 + 800 * INS%, .5ã         CASE -83ã            IF Cursor% < max% THENã               MID$(S$, Cursor%) = MID$(S$, Cursor% + 1)ã               MID$(S$, max%) = F$ã            ELSEã               SOUND 999, .7ã            END IFã         CASE -75: Cursor% = Cursor% - 1ã            lim% = INSTR(S$, F$): lim% = lim% - max% * (lim% = 0)ã            IF Cursor% < 1 THEN Cursor% = lim%ã         CASE -77: Cursor% = Cursor% + 1ã            lim% = INSTR(S$, F$): lim% = lim% - max% * (lim% = 0)ã            IF Cursor% > lim% THEN Cursor% = 1ã      END SELECTã   WENDãEND SUBã'_|_|_|   end   ELVIS.BASãRyan White                     R-RAD TYPER                    BIGFOOT@InfoAve.Net            09-21-96 (17:53)       QB, QBasic, PDS        131  3934     KRAD.BAS    'Rrad typer...  Kinda like krad, only made by me so I can understand it.ã'By Ryan Whiteã'Feel free to change and mess with it.ã'Suggested edits: make colors 1-15 more intense with out-commands, put in aã'                 text menu like interface, make the characters where U canã'                 read them your way, make it where you type a normal page,ã'                 and the program converts the page to Rrad.ã' Warning to newbies  DONT use ASC #'s 0 to 32!!!   Just dont.ãSCREEN 0, 0, 0, 0ãCLSãWIDTH 80, 50ãCOLOR 15, 0ãON KEY(1) GOSUB chngcol: KEY(1) ONãON KEY(2) GOSUB clr: KEY(2) ONãON KEY(3) GOSUB redo: KEY(3) ONãON KEY(4) GOSUB enditnow: KEY(4) ONãPRINT "This is R-rad typer.    Just type the letter and it's done."ãPRINT "Commands: Press F1 to change colors, F2 to clear screen, F3 to restart,"ãPRINT "and F4 to quit.  ****  To get the effect of pressin enter.. you must type"ãPRINT "an appostrophe(`)  The thing next to the 1.": PRINTãINPUT "Enter new filename and extension:", fle$ãOPEN fle$ FOR OUTPUT AS #1ãCLSãst:ãDOãAns$ = INKEY$ãLOOP UNTIL Ans$ <> ""ãIF col >= 75 THEN col = 0: PRINT : PRINT #1,ãSELECT CASE UCASE$(Ans$)ã CASE "A"ã  PRINT ""; : PRINT #1, ""; : col = col + 1ã CASE "B"ã  PRINT "á"; : PRINT #1, "á", : col = col + 1ã CASE "C"ã  PRINT "<"; : PRINT #1, "<"; : col = col + 1ã CASE "D"ã  PRINT "|)"; : PRINT #1, "|)"; : col = col + 2ã CASE "E"ã  PRINT "ä"; : PRINT #1, "ä"; : col = col + 1ã CASE "F"ã  PRINT ""; : PRINT #1, ""; : col = col + 1ã CASE "G"ã  PRINT "G"; : PRINT #1, "G"; : col = col + 1ã CASE "H"ã  PRINT "]-["; : PRINT #1, "]-["; : col = col + 3ã CASE "I"ã  PRINT "³"; : PRINT #1, "³"; : col = col + 1ã CASE "J"ã  PRINT "õ"; : PRINT #1, "õ"; : col = col + 1ã CASE "K"ã  PRINT "]<"; : PRINT #1, "]<"; : col = col + 2ã CASE "L"ã  PRINT ""; : PRINT #1, ""; : col = col + 1ã CASE "M"ã  PRINT "/\/\"; : PRINT #1, "/\/\"; : col = col + 4ã CASE "N"ã  PRINT "ü"; : PRINT #1, "ü"; : col = col + 1ã CASE "O"ã  PRINT "()"; : PRINT #1, "()"; : col = col + 2ã CASE "P"ã  PRINT ""; : PRINT #1, ""; : col = col + 1   'just imaging the t wasn't thereã CASE "Q"ã  PRINT "q"; : PRINT #1, "q"; : col = col + 1ã CASE "R"ã  PRINT "â"; : PRINT #1, "â"; : col = col + 1ã CASE "S"ã  PRINT "$"; : PRINT #1, "$"; : col = col + 1ã CASE "T"ã  PRINT "Ñ"; : PRINT #1, "Ñ"; : col = col + 1ã CASE "U"ã  PRINT ""; : PRINT #1, ""; : col = col + 1ã CASE "V"ã  PRINT "\/"; : PRINT #1, "\/"; : col = col + 2ã CASE "W"ã  PRINT "\/\/"; : PRINT #1, "\/\/"; : col = col + 4ã CASE "X"ã  PRINT "><"; : PRINT #1, "><"; : col = col + 2ã CASE "Y"ã  PRINT ""; : PRINT #1, ""; : col = col + 1ã CASE "Z"ã  PRINT "z"; : PRINT #1, "z"; : col = col + 1ã CASE "!"ã  PRINT "­"; : PRINT #1, "­"; : col = col + 1ã CASE "?"ã  PRINT "¨"; : PRINT #1, "¨"; : col = col + 1ã CASE "1"ã  PRINT "I"; : PRINT #1, "I"; : col = col + 1ã CASE "2"ã  PRINT "II"; : PRINT #1, "II"; : col = col + 1ã CASE "3"ã  PRINT "III"; : PRINT #1, "III"; : col = col + 1ã CASE "4"ã  PRINT "IV"; : PRINT #1, "IV"; : col = col + 1ã CASE "5"ã  PRINT "V"; : PRINT #1, "V"; : col = col + 1ã CASE "6"ã  PRINT "VI"; : PRINT #1, "VI"; : col = col + 1ã CASE "7"ã  PRINT "VII"; : PRINT #1, "VII"; : col = col + 1ã CASE "8"ã  PRINT "VIII"; : PRINT #1, "VIII"; : col = col + 1ã CASE "9"ã  PRINT "IX"; : PRINT #1, "IX"; : col = col + 1ã CASE "0"ã  PRINT "§"; : PRINT #1, "§"; : col = col + 1ã CASE "`"ã  PRINT : PRINT #1, : col = 0ã CASE "."ã  PRINT "."; : PRINT #1, "."; : col = col + 1ã CASE " "ã  PRINT " "; : PRINT #1, " "; : col = col + 1ãEND SELECTãGOTO stããchngcol:ãc = INT(RND * 15) + 1ãCOLOR cãRETURNãclr:ãCLS     'WOWãRETURNãredo:ãCLOSE #1ãOPEN fle$ FOR OUTPUT AS #1ãCLS : PRINT "Filename is empty..."ãPRINT "Type on...": PRINT : PRINTãRETURNãenditnow:ãCLOSE #1ãPRINT "Done editing.  "; fle$; "is alive now.   Have fun.  Byebye"ãENDãKurt Kuzba                     FAST GET/PUT TEXT              FidoNet QUIK_BAS Echo          09-24-96 (00:00)       QB, PDS                105  6894     GPTXT.BAS   DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2ãSUB V1:OPEN "O",1,"GPTXT.ZIP",4^6:Z&=4898:?STRING$(50,177);ãU"%up()%9%%%R-%=d7qFg\6+GF'.%%k(%%%.%%%%lu(y'yS#tgoD&atm9mvA#8q>EãU"ofleesTe99GI3<5_v<W3buQth<Q9gSg]CMahD%MmGm\pho[H>bnCJaUr\$'lab.ãU"J-QGf5mVw8kIcEYIQ<1[pQs82lE%.nIU8ruwWhp3WKNDE_p3<Zsw-L?lgr#>']9ãU"pYe/)KR.uLT:q%FIEF3U,<AfEe8yyKiPA==;tT\jK3q?yUOy[h;)Y3MCO\#Z(dTãU"JP^7fiEVHLG:<.X$5+6f<ZyVj=[hfUm0-HapYy.kxJrJIXp%ma2ZCA:;vg\v%HYãU"hz2y(iSQmcd&gi(T;_<1j<9IwQ,)qpTVzUODz1ZQmM$'=I'B9Ue]*P$0vx'1I(TãU"UU7+xbQSe_9B2(b[fQ,f:1?cW&N,ou>1g=dJlSJ+WZ#_MA/&LH/NY1Kc+[&RlM=ãU"Adp+Gr6[8+j6bK/90BViE/0'+8L92jTc-Ml5Ax3d(a#l939skj68E/i/hw4&Hh/ãU"h?_.740hK:0;qum_9fwic>p0k52l?Ss<#xN6NN,I&Z0/^3,,_4'n.C8fVdp<5e&ãU"ytIp7qsYQd5wfBZ/BzM0;E(-C_*p*:)\r&H6AJ2IU0E/V=a]MT#wG2T=/N^1-AnãU"*aoa&roX7#.8gn2le5#^EHzDr\NFjxGTM'A()aSRB\5wjR,NSS-Zr_lB7S\K=j9ãU"Q/I+UPHcsg1Qt(__2YjPOXoOBgZ>qBun[(Fle5b*r^arGB:.bwiHXO4izmWI&CcãU"OpK,>>=%fSyG>MIgy)sX]OSXNG8uqtjb1F8Wkr)]QXk=:8Q0-==]wI?F]xj<iXvãU"EKbrAlF2Y1j[*CNa'#Dup%()9%%%%-%*\dqFTpCRe'32%%'N:%%%.%%%#luy'%yãU"SvqOgfgJACyze$?FzVW3d'c^FR=b[1KR<XiSQw%N*F8(3H:5#hmw_C/_s(\HfE(ãU"H'3:Kq1oSOGGbeR/R=D;%'_S98*-V8RCh^P1+XVV]I-F/OGS)pD7if-WK(MKHpMãU"*+fwXNHe)xxXlvoHfbBoc$iWj3G9;5vX/xYRG'qAX6YLjY<N-TaW]Ae8bbgb&iCãU"-g&5&Pgu/%C(pe^8GA-SO<9)0)6;';>Rpf+La&L3:8?&\+(k<%VxG=a4g*L7e;AãU"(E>/Fw.%pP<Ia.%Pa<:[)+8e&b'Y5].^sR0929S>UaCU0K09Y_*BkeV'7-O9wBYãU"*tQazYj)j3-RF8/#Q.EoOC?%-A&L?:PYQB1-kOe3_5+/PV/A8g%g(14PN&[^EDEãU"1(4o/'M&*aC2M2%VRf9://PG<oe't9+&iVU1FN#E(C[+.n/A)K,0MDk*V0xXsJKãU"<]5tb/;.M':2GX-6;g'>RpIfL'WH/41-]CWKK\zE-sN9nO;LosI?+5AwGfV&i9_ãU"NQCie[^$wlxlNl^X.b4lk%\sdAHSD>DcUBgty2-S)W_2Z&2N#u..]Sn=(c[3MaGãU"v26?+2B%=rM4^)11(N2(P2;s[3Q%)a140%WFa*nWrktZd-.[w/zXBOVThC4GY,cãU":V74N)x3Dj)5bbIierWNO\yLVtDc*c_xB3Oj40ak-_%B<xUv6&N#V,k%_S^3kwDãU"jlMQdeu8<VUNy^%W$W\qicWhcu1qmY=o#AKAY]UrOaN0L9?Y5dYqw^f5V[rVc?xãU"]?>jjuELkz)104:2A6r&P:$j)QHY7*A$_Qgs=KKEZ/OUh\DSgQ&]WDgpVG4%p=GãU"DAG]qg%#rP?k\%NNqek7D]&lAC7682#k&B_fv_G*X[hk]QxBk0F];ykqw(fV&bLãU"brG$x+:_7xm&Dp#\FI.2<RtShd$TIwM61j3vL4sEJ3LM0JohTK^UdapmLZA\LY\ãU"5=='hgGGGbHvX_zwUncDOn$.MGn,B0#Gb59e7AOSLAD/5Bm,dJnTh/*hzH\<h#eãU"=hcJ*WT24ckSm=XPwm->ZesfM4N6v^]5SASFCwpAueI3k,-SpTF2x,DXqGaG(MrãU"H[kr<kJt0Ca)q3CEG<a_LGZ<(K-uDSiNMdL68jw]]w>dV$m^Bk92:LaMhZgWAsEãU"v3H^P878YKrH8^9Z>\*9\J\)&rPm9-wE:YFwqx&:uqiL$'oqZ4h'/1ST41QS%/hãU"F^*<9g8C*\MH5L:[tvi4'$Y7/8K^/]p0iK&UtP;f'$Y'/8']/Kw-1F:AFlZ<+]:ãU"I/(/A*NkB<tj+c:jY%ReKI?IbITUA:E88TQ22fAUpHJkXGSiaiVPb1?rzriPG,#ãU"di:h-qFTk'upB+:+m&nVSU\%U5eb#+lk$(8Bo$cc]\16.2+%6?pzf->D77r_j1>ãU"p$<'>*>R;K.l:yb[MR>$uKNx&X)?0tN4.wB&xpBfj>NgyvYMZUNANvfV[BSqWIoãU"=3ZOGJOmMDBnhEKQ$;$>52v/YmX*,SMNoWlklqI^Z)yQ.KDteS>qCPYhKcmUuWOãU"dVuMK;rF7)tn2'P]f^KJPXPdf,j;V#YN%SB[fJ8F1YZMH?\f]FG?;ojk[T*3AKcãU".Dcoc[/)UnMLVp;Fob+p8RD3bj8I:OC/L&rtlq)0C6lBudjbl,vQoFkJ;0#DonFãU"i>(K?6n(oF1yE,$o^kc);5CQUDBX0vr?x>YDPjjTF#)U<)g9x:TUhBP)?[;kqO$ãU"kLO9n(2OvBF>SdTiV[xCVtE8Xkv]oT/>t-01D4Z8z,.x,EmIltjI2IFg_+LShTaãU"xa]nu4]DkIU>dglorG6_TUNB?+4>Cjyexx,4h?=HwgBnD0j[<;YiiX2+aaM&trCãU"l0o-AWS9\.KupGcgne4[Tu3lux?&od(R_#eJ494IMWn/YJ_HHgt;5R/0qY46SA2ãU"_?ekrF*o]I;#.jKerEAe]QpDBib3pGZ48r=doP(2lKO#ONiyPlff_K*jPhIkx7)ãU"83h-=SIEkA's:JS'i\nZH#_?dp0$4;9$oDr0$<kc?a?L%AvVbxq[eTSe5?FFE_FãU",I>ti2cB21\(MnKvP6AKZ)ULxL^:x/s5e$w7h1O;n%<P9UV/YBIrS$w8G5Mi\FWãU"]rfSBvW'JrL6QsE31Z,^U,xtdx4N07zsO8DbwJ53%eg)S9psYagf9/Q/8WooTd;ãU"hX,BQP0Wg6v9*[\#c#-q]8w,flfo3q$d-obT0]F3y2lKkWi.X=2DL2QtZpYmERNãU"8MRkJ8sIswmp#A7H<^>S\NfaZgPEhjSH47h8=q%0<QO<f^?I>:vQmP/s&q5OZ8HãU"ZvoD1oh7-6nJxX43NRi1Z_rHWaRMGfk<XXnZpxqLrR8A$PFxoel,,kvtd,AvTY&ãU"i/9t9uO7*H&b%8kdQhJJ--NcpE6rMGqEF[ZaIQE.Fv]x6a=$Ma=UY;,ue]I'a0oãU"<*c]gWitu7([s[sZ#Qc\WP.FqoAX]r9VKCrd4]<5,ff$gH$&;3xsm1*m]?=rSP\ãU".n:;8TL$k],t=71'Lz9l6_;TDUlKgAU50v9fMkI49f76>dSw#xTZh<pxmLr\5sNãU"cJ/cgmPw_gxnt3AFJ]+fqA-n:d4kuYN5g\HnBaH>+8a?HmYFVV/idj^,?oF8Gk#ãU"JE$62m]p\EHGRhkXbER3iGu?o(-6x^5j:(Kh6(k^YA_Y;:K6,]5jF(CM6^A%E9(ãU"F6Cjk:BZ_]%SIX<6tSkRY;1F6Z]YzY%aT,OGyU^zZ;U.6.k4R^;>26DkZt?O=RTãU"(]lAc_\qZ6EH(XG6D^JYQ,X?Koa6zF^tR6e:]*DHRh]*HHRpk0vP6#g]Jh,h\k<ãU"ZJ;P6>GAo;6ZxGREZGW\;(,6$^6dY;<q6NYeq^kf^e;D6Vkkn?OcDR&G=cYeh?GãU")XD,B?^$HER%6[l]$C3RvkBH$e)6hRkl]q;W,HF]tX6;nBo*_6v]tYa,LktL<R0ãU";klZQcER^GLS?EXc,h^4&U8H&.XemHRV%B]5':<EO3urMsCh-L4Eo4%<u+TD$3lãU"o$q5dGF7RREOaRERFoGOFG1Rllz#_$\JEgk^BL03i0cxjF8Xhuu>8nXj]fEkNVGãU"GSlnr\Px3iovn^bDJ;6+?a8x[^_>aGSb3R)uvqS=vw?9XTm%-5NBcPBC+N)V>bCãU"S;]$g:)IfyE'mCN_2MacS2CicGdYlYGrpwm.*I1Nr0MTaK(.,Qb&Xdw19mPbV)RãU"e:H#bJb5qNlEm)QcK8hC\c*;(zXE<n2nk/Iza2P)t%XY)-sFks*E&qMfWW#N>jJãU"Z0mbvlSq^>(/[YMN.WMnIp[RufXo%Juh5Ww5Fbw=^Tjna5<_N8hi/%=u14EDgjHãU"QRFMmfBPhIx5bjIQ6)k>S<M)1MjOYx=B3SD<B:Z5uZ+4&\\Y>M_JcU5rmM*4M&<ãU"a9,z9aklW;pj>_6Emm^mRsdxO,ll1uVtF+,whXxhf%NQmAHC#NF84iuxHFJGG7ZãU"FbYs0_o-)&ui6Hbi2:_&.?.BH/Lrc*SCsc#T1saNTYC+u:>pL^Wg6Nm5(uwpD3hãU"eNHqCXg#PztH)8-Nm^l6wFkPJJLb9X<3zIS<MMgT>]gkfu[I-vkxgHt]LSUC$TTãU")mcpjrx>^Pc=bZJ$X37s5FRU$a.x#*O5GaX23ZeVp8\KnUs,#(b1il0kX?*%IY%ãU"lWTk6aLZ3W(zb,PN3jsLD3r'(3_fc_*P(gZilYplZ.TLj3%L-d7X.Js78csv.n=ãU"ta3g9Pz3c_v:POH&vH0A\uGFMTF(tmwlgcE#zPj8zZ&zWA,hxn<E0(?B,5fhzCJãU"c;LZnKl0#.$dxa-F6%MzO8fQlNfDYr/OfBh,I'p>#WE#GCHHDRlj,4uBP*fz%q7ãU"5g5DHwMkITiz&*5mK=s2w33TCJNdlDA(&lEH<'P=I+3a:HTAdRSU^6o]3z>IccOãU"he$2/6,1w-6[K3g(s5[zr1z6WHs?OA<]X//?puu7,^Pl8J=YIy05Iky4Zse\pj6ãU"oq/ezH9I4'>w5Yoyhla;7i$PZc7HS>2ms_ZHrXi6,I7V^$b#_0X/pqB&0g6hyODãU"L/ur1[Tvs#fg?jE>Km#bb'o>drhs.W+u/pgk[w%3(y:e^ahG%daF).Y&jty,zmCãU"c]E20LQW)_4i0&8IV;s7yr/(,-Oas9nW%U4;oV4sPDXHu.-^<)\:?c?K\.8__+iãU"DZr0nC4.h[Yu%,;0XXm0r2JbuCJ.GDSg_f5##;t;'oODJe[I2>d9#:ix?x&XP;JãU"nI[MMTOzd*BazU--0*4]#aM-vOgnm\K7#M00bc0Z&%j#V5b(%pu64*2r'uG,C]9ãU"Z&k&cmns(Q-1+C#pXSKrJ:om9qdu*lFQY%&0Ft#^&ncMMRO(Pj.,9Mb,UqIO,$cãU"_]wM_C3;4SBW$4m/HDbqsQrror9&CU;&5<X&72S8fU9<S5[E;)KBNLFpm8r-,$;ãU"]N$$m>%FyULIXdN==[^WUmil5N=&72]VQhR^VaB:kZ%2rG,1v4u%p()9%%%%-4%ãU"KdqLFK\\,z6&%%%h(%%%0%%%%ljy&.uzy%SgfxJdx,>Aje5KFl[d[5qQP+m6hf/ãU"c1c(Y(0pFe*YkKt=;'(SAa(NkrttwqdC5;#atfF&qEVR2/l:kR]wY4=fj-,=DByãU"$E[Op,1G*'=G4.G93Wwd:2tkw]ASY:[<Vj%^ef$*zn^<\.tH/FP%<<Zbb9NH$H9ãU"+?036m9Fu5%I>(B$jl'0[l%zG(:>:j-d<ob+]ZO3rF%Yt7wq-uBRcqT+2D9*/9KãU"*c[28qUS5J\NfVq-uw;n/T[Gu-J5_o's<_q;qIrCKP[1PlL5sBv)Fu]4MFEOCVwãU"pDqt,/r;p,LGDVvP/_:JpX&WNIxAY(k:$usl+wah66i)>_N8gxTl;74Njm.Gp=9ãU"Ii.[X.+heSaj3>Y7(1I-N_slwm&dh9)Fr;9LLW+js7:P=9dN[i>7;6o#s:F#lW-ãU"k\W.x7>TrF2vZ+M>CsM=geIIJma#NHzl,Y:$M&un,.A%Y46')Qpq4[>vPddE1c5ãU":k?O&wLL'FGZqe0sjvh^zR7.b#+0?i1XeSBtYZ[hu?Rmbnn#pkK8aGtL8x<dp8pãU"op/>#;?.*(2kz&Jd(,n>Pt%#8C&.up&%'9%9%%%%-4%=dqaFg\+*GF'%(%k(%%%ãU".%%%%%%%%%%%E%%%%%%%%%l.uy'y%Stgo%up&'%9%9%%%%-%*\dqFTpCRe'32%%ãU"'N:%%%.%%%%%%%%%%%E%.%%m'%%%lu(y'yS%vqgu%p&'9%%9%%[%-%KAdqFKh\\ãU"z6%&%%h%(%%0%%%%%%%%%&%%E%%(%N5%%%ljy&.uzy%Sgfx%up*+%%%%%%(%(%&ãU"v%%%&47%%%%%ãEND SUBãCLOSE:IF S=116AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!ãSUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32ãIF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1ãS=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUBãKurt Kuzba                     FILE SEARCH TO FIND TEXT       FidoNet QUIK_BAS Echo          02-28-96 (00:00)       QB, QBasic, PDS        50   1947     FINDTEXT.BAS'>   I want to write a program that searchs through a fileã'>   to find a specified string.  This program is prettyã'>   common to those who want to test their programmingã'>   knowledge, but I've never attempted it.ã'>   I need suggestions/guidance.ã'>........ã'   How about a working example?ã'_|_|_|   FINDTEXT.BASã'_|_|_|   This program performs a fast file search for any givenã'_|_|_|   text, selectively allowing case sensitivity.ã'_|_|_|   Full overlapping is implemented for instances where theã'_|_|_|   text might span the input buffer boundaries.ã'_|_|_|   No guarantees or warrantees are given or implied.ã'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (2/28/96)ãON ERROR GOTO OOpsãFileToSearch$ = "": COLOR 2, 0: CLS : LOCATE 3, 1ãINPUT " Enter file name => ", FileToSearch$ãIF FileToSearch$ = "" THEN CLOSE 1: ENDãINPUT " Enter text to find => ", text$ãPRINT " Search case sensitive (y/n)? ";ãIF text$ = "" THEN END:  ELSE L% = LEN(text$): Overlap$ = ""ãDOã   sensitive% = INSTR(" YN", UCASE$(INKEY$))ãLOOP WHILE sensitive% < 2ãPRINT MID$(" YN", sensitive%, 1)ãIF sensitive% = 3 THEN text$ = UCASE$(text$)ãOPEN FileToSearch$ FOR BINARY AS #1ãPRINT TIME$ãWHILE NOT EOF(1)ã   test$ = Overlap$ + INPUT$(4096, 1): TL% = LEN(test$): strpos% = 0ã   IF sensitive% = 3 THEN test$ = UCASE$(test$)ã   WHILE strpos% < TL%ã      found% = INSTR(strpos% + 1, test$, text$)ã      IF found% THENã         strpos% = found%ã         PRINT "Text found at"; LOC(1) - LEN(test$) + found%;ã         PRINT "   O>=* hit a key *=<O"ã         WHILE INKEY$ <> "": WENDã         k$ = "": WHILE k$ = "": k$ = INKEY$: WENDã         IF k$ = CHR$(27) THEN CLOSE 1: ENDã      ELSEã         Overlap$ = RIGHT$(test$, L%): strpos% = TL%ã      END IFã   WENDãWEND: CLOSE 1ãPRINT "end of file": PRINT TIME$: ENDãOOps:ã PRINT " Disk error or bad file name ["; ERR; "]"ã CLOSE 1: ENDã'_|_|_|   end   FINDTEXT.BASã