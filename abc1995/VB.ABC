Christy Gemmell                PATHNAME OF CURRENT PROGRAM    PATHNAME,CURRENT,PROGRAM       Unknown Date           VBDOS                  68   3576     PATHNAME.BAS'  > Does anyone know how to find the directory a program was run„'  > from, from inside that program? I hate the idea of hard coding„'  > the directory names into the program as a poor solution...„„'The function below will do it. I've tested it with DOS and Windows95„'and it works fine.  Be aware, though, that it will only work properly„'in a stand-alone program. If you run it in the IDE it returns the„'path of VBDOS.EXE.„„'--- cut here ----------------------------------------------------------------„' PATHNAME.BAS  demonstrates function to extract the pathname of the„'               current program.„'„'   Author:     Christy Gemmell„'„'  $INCLUDE: 'vbdos.bi'„'„    DECLARE FUNCTION PathName$ (ProgName$)„„    A$ = PathName$(B$)„    PRINT A$, B$„END„„'   Returns the directory path from where the current program was„'   launched. Also extracts the program filename.„'„FUNCTION PathName$ (ProgName$)„    DIM Regs AS RegType                         ' To hold register values„    Regs.ax = &H6200                            ' DOS Service 98„    INTERRUPT &H21, Regs, Regs                  '  - find PSP segment„    DEF SEG = Regs.bx                           ' Segment of current program„    EnvSeg& = PEEK(&H2C) + PEEK(&H2D) * 256&    ' Get environment pointer„    DEF SEG = EnvSeg&                           ' Environment segment„    I% = 0                                      ' Shuffle„    DO                                          '   through„       DO                                       '     environment„          ThisByte% = PEEK(I%)                  '       strings„          I% = I% + 1                           '         looking„       LOOP WHILE ThisByte%                     '           for two„       ThisByte% = PEEK(I%)                     '             successive„       I% = I% + 1                              '               null„    LOOP WHILE ThisByte%                        '                 bytes„    I% = I% + 2                                 ' Skip over some junk„    ProgName$ = ""                              ' To hold the program name„    DO                                          ' Read„       ThisByte% = PEEK(I%)                     '   each„       IF ThisByte% THEN                        '     character„          ProgName$ = ProgName$ + CHR$(ThisByte%)  '    of program„       END IF                                   '         name until„       I% = I% + 1                              '           we find„    LOOP WHILE ThisByte%                        '             null byte„    DEF SEG                                     ' Restore default segment„    L% = LEN(ProgName$)                         ' Did we find anything?„    IF L% THEN                                  ' If so„       DO                                       '   scan„          C$ = MID$(ProgName$, L%, 1)           '     backwards„          IF C$ = "\" THEN EXIT DO              '       looking„          L% = L% - 1                           '         for the„       LOOP WHILE L%                            '           path„    END IF                                      '             delimiter„    IF L% THEN                                  ' Seperate„       PathName$ = LEFT$(ProgName$, L%)         '   directory„       ProgName$ = MID$(ProgName$, L% + 1)      '     path„    ELSE                                        '       from„       PathName$ = ""                           '         program„    END IF                                      '           name„END FUNCTION„„Christy Gemmell                READ HARD DRIVE BOOT SECTOR    READ,HARD,DRIVE,BOOT,SECTOR    07-04-95 (00:00)       VBDOS                  109  4095     BOOTSEC.BAS ' BOOTSEC.BAS   reads the hard drive boot sector into memory.„'„'   Author:     Christy Gemmell„'   Additions:  Martin Overton„'               David Milton„'   Date:       4/7/1995„'„'   $INCLUDE: 'VBDOS.BI'„'„	DECLARE SUB BootSex (Drive$, ParTable%, Done%)„„	CONST FALSE = 0, TRUE = NOT FALSE„„	DIM SHARED Regs AS RegTypeX„	DIM SHARED Sector AS STRING * 512„	DIM SHARED Part AS STRING * 512„„	CLS : PRINT : Drive$ = "C:"         ' Read from drive C:„	BootSex Drive$, ParTable%, Done%    ' Read boot sector„	IF Done% THEN                       ' If successful...„	   PRINT "Boot Sector for Drive "; Drive$„	   PRINT "========================"„	   PRINT "Media descriptor  = "; HEX$(ASC(MID$(Sector, 22, 8)))„	   PRINT "OEM Identifier    = "; MID$(Sector, 4, 8)„	   PRINT "Volume label      = "; MID$(Sector, 44, 11)„	   PRINT "Serial number     = ";„	   FOR I% = 43 TO 40 STEP -1„			   PRINT RIGHT$("0" + HEX$(ASC(MID$(Sector, I%, 1))), 2);„			   IF I% = 42 THEN PRINT "-";„	   NEXT I%„	   PRINT : PRINT "File system       = "; MID$(Sector, 55, 8)„	   PRINT„	   IF ParTable% THEN„			  PRINT "Partition Table for Drive "; Drive$„			  PRINT "============================"„			  I% = 447: P% = 1„			  DO„					 PRINT "Partition"; P%;„					 IF ASC(MID$(Part, I%, 1)) = 128 THEN„							PRINT TAB(21); "ACTIVE PARTITION";„					 END IF„					 OS% = ASC(MID$(Part, I% + 4, 1))„					 PRINT TAB(41);„					 SELECT CASE OS%„							 CASE 0„									  PRINT "Empty"„							 CASE 1„									  PRINT "DOS 12-bit FAT"„							 CASE 4„									  PRINT "DOS 16-bit FAT (up to 32MB)"„							 CASE 5„									  PRINT "Extended partition"„							 CASE 6„									  PRINT "16-bit FAT (over 32MB)"„							 CASE 7„									  PRINT "OS/2 HPFS or Windows NTFS"„							 CASE ELSE„									  PRINT„					 END SELECT„					 I% = I% + 16: P% = P% + 1„			  LOOP UNTIL P% > 4„			  PRINT„			  Sig& = ASC(MID$(Part, I%, 1)) + (256& * ASC(MID$(Part, I% + 1, 1)))„			  IF Sig& = 43605 THEN„					 PRINT "Valid boot block"„			  END IF„	   END IF„	   PRINT "-----------------------------------------------------------"„	END IF„END„„'   Read the boot sector and partition table of a specified drive.„'„SUB BootSex (Drive$, ParTable%, Done%)„	LSET Sector = STRING$(512, 0)       ' Fill sector buffer with zeroes„	Disk% = ASC(UCASE$(Drive$)) - 65    ' Get drive number„	Head% = 0                           ' Floppies use head zero„	IF Disk% > 1 THEN                   ' Adjust„	   Disk% = (Disk% + 128) - 2        '   for hard„	   Head% = 1                        '     disk„	END IF                              '       drives„	Regs.cx = &H1                       ' Get sector 1 of track zero„	Regs.dx = (Head% * 256) + Disk%     '   of selected drive„	Regs.ax = &H201                     ' Read one full sector„	Regs.bx = VARPTR(Sector)            ' Offset of read buffer„	Regs.es = VARSEG(Sector)            ' Segment of read buffer„	INTERRUPTX &H13, Regs, Regs         ' Read sector into memory„	IF Regs.flags AND 1 THEN            ' Test carry flag for error„	   Done% = FALSE                    ' If set report an error„	ELSE                                ' Otherwise„	   IF Disk% > 1 THEN                ' Hard drive„			  LSET Part = STRING$(512, 0)   ' Fill partition buffer with zeroes„			  Head% = 0                     ' Partition table is under head zero„			  Regs.cx = &H1                 ' Get sector 1 of track zero„			  Regs.dx = (Head% * 256) + Disk% ' of selected drive„			  Regs.ax = &H201               ' Read one full sector„			  Regs.bx = VARPTR(Part)        ' Offset of read buffer„			  Regs.es = VARSEG(Part)        ' Segment of read buffer„			  INTERRUPTX &H13, Regs, Regs   ' Read sector into memory„			  IF Regs.flags AND 1 THEN      ' Test carry flag for error„				 ParTable% = FALSE          ' If set report failure„			  ELSE                          ' Otherwise„				 ParTable% = TRUE           ' Report success„			  END IF„	   END IF„	   Done% = TRUE                     ' report success„	END IF„END SUB„„