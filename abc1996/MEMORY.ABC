Brian Roche                    MORE PEEK AND POKE ROUTINES    FidoNet QUIK_BAS Echo          01-11-96 (09:20)       QB, QBasic, PDS        292  11424    PEEKPOKE.BAS' > Does any one have a list of all those area where you Poke and Peek;„' > what they mean.„„' *All* those areas ? Well, here's a list of different stuff like „' that, that I keep layin' around...„„' ======== ROM BIOS STUFF ===================================„ To use any of the Addresses below, you have to put yourself into„ The ROM BIOS Data Area, like so: DEF SEG=&H40 „ (Make Sure to specify DEF SEG when your'e done!)„„ PEEK &H00      -  RS232 Addresses on your IBM PC.„                  (Number of Addresses = How many Com Ports you have)„ PEEK &H08      -  Printer Addresses on your IBM PC.„                  (Number of Printer Addresses=Number of Printers)„ PEEK &H10      -  Equipment Flag.„                  This Integer has 16 different values - each having„                  a different meaning:„                  Bit 0 -  Machine has Floppy Drives„                  Bit 2,3 - Ram Size (00=16K 10=32K 01=48K 11=64K)„                  Bit 4,5 - Video Mode „                            00=Unused„                            10=40x25 Color„                            01=80x25 Color„                            11=80x25 Mono„                  Bit 6,7 - Number of Floppy Drives„                            (If Bit 0 = 1)„                            00=1 10=2 01=3 11=4„                  Bit 9,10,11 - Number of RS232 Cards attached„                  Bit 12  - Game I/O Attached„                  Bit 14,15  - Number of Printers „     &H13      -  Memory Size in Kilobytes.„     &H17      -  Keyboard Flag „                  This Integer has 16 bits fields, as well, for the KeyBoard„                  Byte 1:„                  &H80 - Insert On„                  &H40 - Caps Lock changed„                  &H20 - Num Lock changed„                  &H10 - Scroll Lock changed„                  &H08 - Alternate Shift pressed„                  &H04 - Control Shift key pressed„                  &H02 - Left Shift key pressed„                  &H01 - Right Shift key pressed„                  Byte 2;„                  &H80 - Insert Key is pressed„                  &H40 - Caps Lock Key is pressed„                  &H20 - Num Lock Key is pressed„                  &H10 - Scroll Lock key is pressed„                  &H08 - Suspend key has been toggled„     &H49      -  Current Screen mode„                  &H00 - 40x25 BW„                  &H01 - 40x25 Color„                  &H02 - 80x25 BW„                  &H03 - 80x25 Color„                  &H04 - 320x200 Color„                  &H05 - 320x200 BW„                  &H06 - 640x200 BW„     &H4A      -  Number of Screen columns„     &H50      -  Cursor Position „     &H60      -  Cursor mode„     &H6C      -  Low word of Timer count„     &H6E      -  High word of Timer count„„     ' The next two below I believe have been moved since the XT ..„„     &HFA6E    -  Beginning of character regen memory„     &HFF53    -  PRTSC routine address„ ======================= End of ROM BIOS Peeks =============================„   DEF SEG=&HB800 - Color Monitor memory„   DEF SEG=&HA000 - B&W Monitor memory„ =========================================================================„ '.....  A Coupla Real Routines you could use in your programs...„„ ' To Read/Find the PSP ...„   DO„    Inchar$=CHR$(PEEK &H81+N)„    PSP$=PSP$+Inchar$„    N=N+1„   LOOP UNTIL INCHAR$=CHR$(&H0D)„  '===================================================================„  ' Machine Independent delay ..„   Pause%=8        ' Number of Clock Ticks to Wait„   Def Seg = 0„     Do Until Pause% < 1„       CurrentTick% = Peek(&H46C)„       Do While CurrentTick% = Peek(&H46C):LOOP„       Pause%=Pause% - 1„    Loop„   Def Seg„  (I'm pretty sure this one's from Joe Negron..)„ '===================================================================„  ' ReBoot the computer ..„    DEF SEG = &HFFFF„    CALL Absolute(0)„ '===================================================================„ ' Reset the KeyBoard„   DEF SEG = 64„   DO„   FOR c = 0 TO 1„     FOR b = 0 TO 1„       FOR a = 0 TO 1„         POKE 23, a * 16 + b * 32 + c * 64„         IF INKEY$ > "" THEN POKE 23, 0: END„         FOR delay = 1 TO 12000: NEXT„       NEXT„     NEXT„   NEXT„   LOOP„ '===================================================================„ ' Toggle the KeyBoard lights ..„ ' Should use keyBoard clear routine above, first ..„ DEF SEG = 64„ POKE 23, 32„ DO„   a = (a MOD 96) + 48„   FOR i = 1 TO 2„     POKE 23, PEEK(23) XOR a„     IF INKEY$ > "" THEN EXIT DO„     FOR delay = 1 TO 6500: NEXT„   NEXT„ LOOP„ POKE 23, 0„ '===================================================================„ ' Save and restore a Text Window ... to restore the 'BackGround'„ ' after you're done popping up a Window in your program ..„„ DEFINT A-Z„ DIM SHARED ScreenInfo(0 TO 3999)„ DECLARE SUB GetWindow (X1,Y1,X2,Y2)„ DECLARE SUB PutWindow (X1,Y1,X2,Y2)„  ' Now save a Window from text posititon 3,5 to position 24,79„  GetWindow 3,5,24,79            ' Store Screen portion in Array„  WHILE INKEY$="":WEND           ' Wait for a KeyPress„  PutWindow 3,5,24,79            ' Put Screen portion back onto Display„ END„ SUB PutWindow (X1,Y1,X2,Y2)„ DEF SEG = &HB800                               ' Assume Color Monitor„ ScreenPos = 0                                  ' Initialize Array Location„    FOR I = Y1-1 TO Y2-1                        ' Change for Partial Window„    FOR J = X1-1 to X2-1                        ' Change For Partial Window„       PokeChar = ScreenInfo(ScreenPos)         ' Get Char from array„       PokePos = (I * 160) + (J * 2)            ' Figure Screen Location„       POKE PokePos, PokeChar                   ' Poke Character to Screen„       PokeAttr = ScreenInfo(ScreenPos + 1)     ' Get Color Attrib from Array„       POKE PokePos + 1, PokeAttr               ' Poke Color Attrib to Screen„       ScreenPos = ScreenPos + 2                ' Update counter„    NEXT J, I„ DEF SEG„ END SUB„ SUB GetWindow (X1,Y1,X2,Y2)„ DEF SEG = &HB800                               ' Assume Color Monitor„ ScreenPos = 0                                  ' Initialize Array Location„    FOR I = Y1-1 TO Y2-1                        ' Change for Partial Window„    FOR J = X1-1 to X2-1                        ' Change For Partial Window„       PeekPos = (I * 160) + (J * 2)            ' Figure Screen Location„       ScreenInfo(ScreenPos) = PEEK(PeekPos)    ' Get Char from Memory„       ScreenInfo(ScreenPos+1) = PEEK(PeekPos+1)  ' Get Attrib from Memory„       ScreenPos = ScreenPos + 2                ' Update counter„    NEXT J, I„ DEF SEG„ END SUB„ '===================================================================„ ' How about using a Mouse in Interpreted QBasic ?„  DEF SEG = 0„  P207 = PEEK(207): P206 = PEEK(206)„  P205 = PEEK(205): P204 = PEEK(204)„  ' Those of you who have seen a routine of this type may notice„  ' a slight difference from the one floating around for GWBasic„  ' ... the GWBasic code would not work in QB, for some reason ...„„   Mouseg = 256 * P207 + P206: Mouse% = 256 * P205 + P204 + 2„   DEF SEG = Mouseg„    ' Now see if a Mouse Driver is installed:„   IF (Mouseg OR (Mouse% - 2)) AND PEEK(Mouse% - 2) <> 207 THEN„   ELSE„    PRINT "Mouse Driver not found!": END„  END IF„ „ ' Now we want to reset the Mouse Driver :„   M1% = 0: CALL Absolute(M1%, M2%, M3%, M4%, Mouse%)„ ' And then show the Mouse Cursor ....„    M1% = 1: CALL Absolute(M1%, M2%, M3%, M4%, Mouse%)„ ' Now, we'll parse both the Mouse positions, and Button„ ' clicks in a loop .... loop aborts on first keypress ...„    M1% = 3„   DO„   CALL Absolute(M1%, M2%, M3%, M4%, Mouse%)„   IF M2% = 1 THEN LOCATE 1, 1: PRINT "Left Button Pressed "„   IF M2% = 2 THEN LOCATE 1, 1: PRINT "Right Button Pressed"„   IF M2% = 3 THEN LOCATE 1, 1: PRINT "Both Buttons Pressed"„   LOCATE 2, 1: PRINT M3%:    'Horizontal cursor position„   LOCATE 2, 6: PRINT M4%:    'Vertical cursor position„   A$ = INKEY$„ LOOP UNTIL A$ <> ""„„ ' Jump out of loop once a key is pressed„ M1% = 2: CALL Absolute(M1%, M2%, M3%, M4%, Mouse%)  ' Make Cursor Invisible„ DEF SEG        ' Reset segment„ CLS : SYSTEM   ' And we're outta here ...„ '===================================================================„   ' Checking the (Returned) Errorlevel of a Shelled Program ..„   DEF SEG = 0„     ErrorLevel% = PEEK(&H4FE)„   DEF SEG„ '===================================================================„ ' Using Com 3 and 4 in Basic ..„ ' We swap the address of Com1 and Com3, or Com2 with Com4 ..„ ' Then, when you OPEN COM1:, youre really reading COM3„ ' or when you OPEN COM2:, you're really using COM4 ..„„   ' Swapping COM1 & 3„        DEF SEG=64: POKE &H00,&HE8„   'Make sure to reset the Port when you're done..„      POKE &H00,&HF8„„   ' Swapping COM2 & 4„       DEF SEG=64: POKE &H02,&HE8„   'Make sure to reset the Port when you're done..„      POKE &H02,&HF8„ '===================================================================„„ '      QuickBasic Routine to Disable Floppy Drive "A" by„ '    Altering the Diskette Controller Infomation in the ROM„ '                  BIOS Data Segment„„ ' First, Check the Machine Model Byte -„ ' This Routine should not be used (does not work) for an XT/PC„   DEF SEG = &HF000: Model = PEEK(&HFFFE)„„ ' If Model Byte = 255, 254, or 251, then it is an XT or a PC, and„ ' We won't Modify the Floppy Byte.„   IF Model = 255 OR Model = 254 OR Model = 251 THEN END„„ ' Get any Passed Command Line Parameter„   Param$ = LTRIM$(RTRIM$(COMMAND$))„„ ' If _any_ Param is passed, then _enable_ the Floppy„ ' Drive, but if not, then We'll Disable the Drive.„   ParamLen = LEN(Param$)„   IF LEN(Param$) THEN Value = 1„  „ ' Now POKE the Value into ROM BIOS Data Area, Offset 8F„   DefSeg = &Hex40:POKE &H8F, Value:DEF SEG„ '===================================================================„ ' To force a Cold Boot with Ctrl-Alt-Del:„    POKE &H72, 0„ '===================================================================„ ' To restore Warm Boot Status :„   POKE &H72, &H1234„ '===================================================================„  ' To Disable Print-Screen Operation ..„    DEF SEG = &H50„    POKE 0, 1„    DEF SEG„ '===================================================================„  ' To Re-Enable Print-Screen Operation ..„    DEF SEG = &H50„    POKE 0, 0„    DEF SEG„ '===================================================================„ '  To read the (16 Byte) Intra-App Communications area:„    DEF SEG = &H40„     FOR I = 0 TO 15„      Status% = PEEK(&HFF + I)„      PRINT CHR$(Status%);„     NEXT„    DEF SEG„ '===================================================================„ ' Extract the ROM Version„   DEF SEG = &HF000„    PRINT "ROM Bios Date : ";„    FOR I = 0 TO 7„     PRINT CHR$(PEEK(&HFFF5 + I));„    NEXT„   PRINT„„  IDByte = PEEK(&HFFFE)„   SELECT CASE IDByte„    CASE &HFF TO &HFD„     Model$ = "PC"„    CASE &HFC, &HFA„     Model$ = "286"„    CASE &HFB„     Model$ = "PC/XT"„    CASE &HF8„     Model$ = "386"„    CASE ELSE„     Model$ = "UnKnown"„    END SELECT„    PRINT "Model : "; Model$, HEX$(IDByte)„   DEF SEG„ '===================================================================„Dave Navarro, Jr.              FIND FREE XMS AVAILABLE        comp.lang.basic.misc           02-13-96 (14:36)       PB                     39   812      FREEXMS.BAS 'FUNCTION to return the total amount of free XMS memory available„'Optimized from original code in Fido Conference by unknown author.„'by Dave Navarro, Jr.„'„'WARNING!  Might not work if RUN from within the IDE.„„DEFINT A-Z„„'If not in the IDE„IF BIT(pbvHost, 5) = 0 THEN„  PRINT STR$(TotalFoundXms); "k bytes free XMS"„END IF„„END„„'----------------------------------------------------------------------------„„FUNCTION TotalFoundXms() PUBLIC AS INTEGER„„  DIM Pointer AS SHARED DWORD„„  IF Pointer = 0 THEN„    ! push DS„    ! mov  AX, &h4310„    ! int  &h2f„    ! mov  Word Ptr Pointer[0], BX„    ! mov  Word Ptr Pointer[2], ES„    ! pop  DS„  END IF„„  ! push DS„  ! mov  AH, 8„  ! mov  BL, 0„  ! call Dword Ptr Pointer„  ! mov  FUNCTION, DX„  ! pop  DS„„END FUNCTION„„David I. Schneider             PC MAGAZINE'S POKES & PEEKS    Rolf@ice.prima.ruhr.de         11-12-85 (19:44)       TEXT                   1614 70414    PEEKPOKE.TXT                   *  * * POKES & PEEKS * * *„„     Did you know that there is a lot of information that may be „accessed from the ROM BIOS area in your IBM PC regarding the operating „characteristics and options found on your own IBM PC?  After careful „analysis of data found in the IBM Technical Reference manual a summary „of the most useful information and where and how it may be referenced „has been prepared.  „     By specifying a DEF SEG=&H40 in any BASIC program, it is possible „to reference the following vectors (fields) in the ROM BIOS area by „using a PEEK function and the following offsets from the current „segment as defined by the DEF SEG statement.  „„     &H0 - RS232 Addresses on your IBM PC.  This will allow you to „tell how many (up to four) async cards are attached, if any.  „„     &H8 -  Printer Addresses on your IBM PC.  This will tell you what „printer addresses, and how many (up to four) exist.  Each is addressed „by a two-byte hex value.„„     &H10 - Equipment Flag.  This field describes the setting of the „options switches.  It describes what optional devices are attached to „the system.  The following lists the bit-significance of this field: „„          Bit 0 - indicates that there are disk drives on the system  „          Bit 1 - not used  „          Bit 2,3 - Planar Ram Size (00=16K 10=32K 01=48K 11=64K) „          Bit 4,5 - Initial Video Mode (00=Unused; 10=40x25 Color „                    01=80x25 Color 1; 1=80x25 Mono) „          Bit 6,7 - Number of Disk Drives (00=1; 10=2; 01=3; 11=4 „                    only if bit 0 = 1)„          Bit 8 -  Unused„          Bit 9,10,11 - Number of RS232 Cards attached „          Bit 12 - Game I/O Attached „          Bit 13 - Not used  „          Bit 14,15 - Number of printers attached „„     &H13 - Memory Size in K bytes„„     &H15 - I/O RAM Size in K bytes„„     &H17 - Keyboard Flag.  The following lists the masks set to „            describe current keyboard status: „„          Byte 1:„               &H80 - Insert state active  „               &H40 - CapsLock state has been toggled „               &H20 - NumLock state has been toggled „               &H10 - ScrollLock state has been toggled  „               &H08 - Alternate shift key depressed „               &H04 - Control shift key depressed „               &H02 - Left shift key depressed „               &H01 - Right shift key depressed „          Byte 2:„               &H80 - Insert key is depressed „               &H40 - CapsLock key is depressed  „               &H20 - NumLock key is depressed  „               &H10 - ScrollLock key is depressed „               &H08 - Suspend key has been toggled „               &H49 - Current CRT mode &H00 - 40x25 BW  „               &H01 - 40x25  Color  „               &H02 - 80x25  BW  „               &H03 - 80x25  Color „               &H04 - 320x200 Color „               &H05 - 320x200 BW „               &H06 - 640x200 BW „               &H07 - 80x25 B&W Card -- speS)CG\+MF;uuse, used internal „               to the video routines.   „               &H4A - Number of CRT columns „               &H50 - Cursor Position (one of eight)„               &H60 - Current cursor mode  „               &H6C - Low word of Timer count „               &H6E - High word of Timer count„               &H71 - &H07 - Break key de8gIae--UROeTBHg„               44E - Beginning of character regen memory  „               &HFF53 - PrtSc routine address  „„-----------------------------------------------------------------„                   PEEKing at Your PC's Memory„  (PC Magazine Vol 4 No 23 Nov 12, 1985 by David I. Schneider)„„     Would you like to know the next number that will be generated by„BASIC's random number generator?  Would you like to know the date 1,000„days from now?  Would you like to determine which of your printers is„on-line?  Or have six palettes at your disposal in medium-resolution„graphics mode instead of the normal two?„„     These and many more tasks are easily accomplished by PEEKing„(looking into a memory location), POKEing (placing a number into a„memory location), INPing (reading a number from a port), or OUTing„(sending a number to a port).  This article attempts to give a thorough„documentation of the varied uses of these statements.  While the„explanations are in BASIC, most of the information is applicable to„every programming language.„„- - - - -„Before You Start:  Before entering and executing any of the PEEK and„POKE statements in this article, be sure this statement is executed„first:  DEF SEG = 0.  PC Magazine tried the PEEKs and POKEs in this„article on standard IBM equipment, and they worked flawlessly.„However, since they bypass many built-in safeguards to work directly„with your system's memory, playing with them carelessly or on non-IBM„equipment is like playing with fire, so type them in carefully, observe„the proper DEF SEG, and don't try any variations unless you know what„you're doing.„- - - - -„„     PEEKs, POKEs, INPs and OUTs reveal the inner workings of the„computer and thus give the programmer direct control.  IBM discourages„the use of PEEK, POKE, INP and OUT, however, since the company cannot„guarantee that future releases of DOS or future ROM chips will use the„current memory locations.  Also, ports associated with nonstandard„hardware might function in different ways.  To be safe, widely„distributed and commercial programs should avoid such undocumented„features.  On the other hand, IBM has been quite consistent so far.„Most of the memory locations and ports presented in this article hold„for all existing versions of DOS and BASIC.  Of course, this might„change with some future release.„„     Theoretically, the IBM PC can directly address 1048576 memory„locations, numbered 0 through 1048575.  Normally, a maximum of 640K„locations of RAM is available for user programs.  The remainder„consists of ROM or is otherwise reserved for present or future system„applications.„„     A segment is a 64K portion of memory beginning at a location that„is a multiple of 16.  Segment 0 consists of memory locations 0, 1, 2,„3, ...65535.  Segment 1 consists of memory locations 16, 17, 18, ...„65551.  Segment 2 consists of memory locations 32, 33, 34, ...65567.„In general, then, segment m consists of memory locations 16*m, 16*m+1,„16*m+2, ...16*m+65535.„„     Within each segment, the first memory location is said to have„offset 0, the second memory location is at offset 1, and so forth;„the last memory location is said to have an offset of 65535.  Memory„locations are specified by giving a segment that contains the location,„together with the offset of that location within the segment.  Most„memory locations can thus be specified in many ways.  For instance,„the designations "segment 0:offset 34," "segment 1:offset 18," and„"segment 2:offset 2" actually refer to the same memory location.„„     Each memory location holds a number from 0 to 255.  These numbers„are often called bytes.  In BASIC (either in immediate mode or in a„program), to read the number in the memory location segment m:offset n,„you execute:  DEF SEG = m : PRINT PEEK (n).  The DEF SEG statement„specifies the mth segment as the current segment, and the value of„PEEK(n) is the number contained in the memory location of offset n„in the current segment.  In a similar way, to insert the number r„into the memory location segment m:offset n, you execute:  DEG SEG =„m : POKE n,r.  This POKE statement places the number r into the„memory location of offset n in the mth segment.„„     The PC's microprocessor receives data from and sends data to the„various components of the computer through ports.  There are ports„associated with the keyboard, the disk drives, the speaker, and the„screen, for example.  A byte of data consists of a number from 0 to„255, and each port has a number assigned to it.  The value of the„function INP(n) is the value of the byte read from port n.  The„statement OUT n,m sends byte m to port n.„„     The listings presented here deal with memory locations in„segment 0, which is often referred to as low memory.  The program,„LOMEMRY.BAS, illustrates many of the applications.„„     Two important procedural considerations must be stressed if you„intend to enter the listings from the keyboard to try them out.  First,„the statement:  DEF SEG = 0  should be executed before the PEEK and„POKE statements in this section are executed.  Second, to prevent a„Syntax Error message, remember to type PRINT before each of the PEEK„statements, so the result will be displayed on the screen.  The words„AND and OR in these listings are logical operators and do not mean„"the sum of" or "an alternative to."„„                            KEYBOARD„„     1.  The following statements are used to set or determine the„status of the keyboard toggle keys.„„     CapsLock Key:  "PEEK (1047) AND 64" has a value of 0 if the„keyboard is in lowercase mode and a value of 64 if the uppercase mode„is active.  To specify lowercase:  POKE 1047, PEEK(1047) AND 191.„To specify uppercase:  POKE 1047, PEEK(1047) OR 64.  To toggle between„upper and lowercase:  POKE 1074, PEEK(1047) XOR 64.  The statement„"PEEK(1048) AND 64" has a value of 64 if the key is pressed, 0„otherwise.„„     NumLock Key:  The statement "PEEK(1047) AND 32" has a 0 value in„the cursor-control mode and a value of 32 for the numeric-keybad state.„To specify the cursor-control state:  POKE 1047,PEEK(1047) AND 223.„To specify the numeric-keypad state:  POKE 1047,PEEK(1047) OR 32.„To toggle between states:  POKE 1047,PEEK(1047) XOR 32.  The statement„"PEEK(1048) AND 32" has a value of 32 if the key is pressed and a„value of 0 otherwise.„„     Ins Key:  The statement "PEEK(1047) AND 128" has a value of 128„for the insert state, 0 otherwise.  To specify the insert mode:„POKE 1047,PEEK(1047) OR 128.  To specify noninsert mode:  POKE 1047,„PEEK(1047) AND 127.  To toggle the state:  POKE 1047,PEEK(1047) XOR„128.  The statement "PEEK(1048) AND 128" has a value of 128 if the key„is pressed a a 0 value otherwise.„„     ScrollLock Key:  The statement "PEEK(1047) AND 16" has a value of„16 when ScrollLock is on and a value of 0 otherwise.  To specify the„ScrollLock state:  POKE 1047,PEEK(1047) OR 16.  To specify the„alternate state:  POKE 1047,PEEK(1047) AND 239.  To toggle states:„POKE 1047,PEEK(1047) XOR 16.  The statement "PEEK(1048) AND 16" has a„value of 16 if the key is pressed a a value of 0 otherwise.„„     2.  The following statements test the status of some special keys.„The statement "PEEK(1047) AND 8" has a value of 8 if the Alt key is„pressed and a value of 0 otherwise.  The statement "PEEK(1047) AND 4"„has a value of 4 if the Ctrl key is pressed, 0 otherwise.  The„statement "PEEK(1047) AND 1" has a value of 1 if the right Shift key„is pressed and a 0 value otherwise.  The statement "PEEK(1047) AND 3"„has a value of 0 if neither shift key is pressed.  The statement„"PEEK(1048) AND 4" has a value of 4 if the Sys Req key is pressed;„otherwise its value is 0 (PC AT only).„„     3.  In the numeric keypad state, the character with an ASCII„value n can be displayed on the screen by holding down the Alt key,„typing the number n on the numeric keypad, and they releasing the Alt„key.  PEEK(1049) has a value of n from the time the number is typed„until the Alt key is released.„„     4.  The circular keyboard buffer begins at location PEEK(1050) +„1024 and ends (possibly after cycling back to location 1054) at„location PEEK(1052)+1023.  Ordinary characters use every other„location.  Extended characters use two locations, the first location„containing the null character (CHR$(0)).  The statement "POKE 1050,„PEEK(1052)" clears the keyboard buffer.  The contents of the buffer„can be read by PEEK without first being removed from the buffer.„Further, characters can be POKEd into the buffer to ensure the„continuation of a program even if a program-terminating statement is„executed.  For instance, if the string:  "GOTO 99" + CHR$(13) is POKEd„into the buffer and a LIST command is executed, the program will„continue execution at line 99 after the LISTing has been completed,„which overcomes BASIC's annoying habit of stopping dead after certain„operations.„„     5.  With PCs whose motherboard can hold 256K bytes of RAM, the„keyboard buffer can be assigned a different location and length.„The following program places the beginning of the keyboard buffer at„memory location 1024 + B and gives it the capacity of holding L„characters.„„10 DEG SEG=0:H=INT(B/256)„20 POKE 1152,B-H*256:POKE 1153,H„30 T=B+2*L+2:H=INT(T/256)„40 POKE 1154,T=H*256:POKE 1155,H„50 POKE 1050,PEEK(1152):POKE 1051,PEEK(1153)„60 POKE 1052,PEEK(1152):POKE 1053,PEEK(1153)„„The buffer contents always begin at:   PEEK(1050)+256*PEEK(1051)+1024„and end (possibly after cycling back from location 1085 to location„1024+B) at location:  PEEK(1052)+256*PEEK(1053)+1024.  You must use„case in choosing B and L.  Two possibilities are B=144, L<55 and„B=301,L<233.„„     6.  To disable Ctrl-Break, enter:  FOR I=0 TO 3:POKE(108+I),„PEEK(112+I):NEXT I.  Before disabling Ctrl-Break, use PEEK to record„the bytes in locations 108-111.  You can then POKE these bytes back in„to reenable Ctrl-Break.„„     7.  The statement "PEEK(1137) AND 128" has a the value of 128 if„the Ctrl-Break sequence has been used since startup to terminate the„execution of a program.„„     8.  To disable the keyboard (PC & XT only), send "OUT 97, INP(97)„OR 128".  Remember that when the keyboard is disabled, subsequent„keystrokes are ignored.„„     9.  To reenable the keyboard (PC & XT only), send "OUT 97, INP(97)„AND 127".„„     10.  To disable all keyboard interrupts:  OUT 33,130.  If keys are„pressed after the interrupts are disabled, the scan codes of the first„20 keys will be held in a buffer located in the keyboard unit.  These„codes will be read after the interrupts are reenabled.„„     11.  To reenable keyboard interrupts:  OUT 33,128.„„     12.  Each key has an identifying number called its scan code.  The„following program will usually obtain the scan code of a key.  After„typing RUN, you must press the Enter key quickly.  They press any key„to obtain its scan code.  (The program will not work on the PC AT or„certain IBM PC-compatibles.)„„10 OUT 33,130„20 WHILE INP(96)=0:WEND„30 PRINT INP(96)„40 OUT 33,128„„     13.  For the PC AT only, when a key is held down for more than 1/2„second (the default delay time), it repeats ten times per second (the„default typematic rate).  To change the delay rate do d quarter-seconds„(d=1,2,3 or 4) and the typematic rate to approximately r repetitions„per second (r between 2 and 30), you would enter:  OUT 96,243:OUT 96,n„where n = (d-1) * 32 + CINT(11.5 * LOG(29/r)).  Conversely, the„statement:  OUT 96,243:OUT 96,n  with n=0,1, ...127, specifies a delay„rate of 1+(n\32) quarter seconds and a typematic rate of 1/((8+(n MOD„8))*2^((n AND 24)/8)*.00417) repetitions per second.  The default state„corresponds to n=44.„„     14.  For the PC AT only, the green lights that indicate CapsLock,„NumLock and ScrollLock status can be turned on and off without„altering any of the states.  The statement:  OUT 96,237:OUT 96,n„produces the following results:„„n = 7   all indicators on„n = 6   ScrollLock indicator off, others on„n = 5   NumLock indicator off, others on„n = 4   CapsLock indicator on, others off„n = 3   CapsLock indicator off, others on„n = 2   NumLock indicator on, others off„n = 1   ScrollLock indicator on, others off„n = 0   all indicators off„„                         MONITOR STATUS„„     1.  To check the type of display:„„PEEK(1040) AND 48 = 0 is no monitors„PEEK(1040) AND 48 = 16 is a 40 x 25 graphics monitor„PEEK(1040) AND 48 = 32 is a 80 x 25 graphics monitor„PEEK(1040) AND 48 = 48 is a monochrome display„„     2.  To select a display:„          Monochrome   POKE 1040,PEEK(1040) OR 48„          Graphics     POKE 1040,(PEEK(1040) AND 207) OR 16„The first POKE should be followed by:  SCREEN 0:WIDTH 40:WIDTH 80:„LOCATE ,,1,12,13.  The second should be followed by:  SCREEN 1,0,0,0:„SCREEN 0:WIDTH 40:LOCATE ,,1,7,7.  Before switching monitor types, it„is a good idea to record (in an array) the numbers that are contained„in memory locations 1097 to 1126.  These values can then be confidently„restored after the return to the first display.„„     3.  To check screen mode:„„PEEK(1097) = 0 text mode, WIDTH 40, color disabled„PEEK(1097) = 1 text mode, WIDTH 40, color enabled„PEEK(1097) = 2 text mode, WIDTH 80, color disabled„PEEK(1097) = 3 text mode, WIDTH 80, color enabled„PEEK(1097) = 4 medium resolution graphics, color enabled„PEEK(1097) = 5 medium resolution graphics, color disabled„PEEK(1097) = 6 high-resolution graphics„PEEK(1097) = 7 monochrome display„„PEEK(1098)+256*PEEK(1099) gives the width in columns.  Color can be„suppressed only on composite monitors.  RGB monitors will display color„even if you are in one of the color-disabled modes listed above.„„     4.  Subscripts and superscripts can be displayed in the top half„of the graphics screens.  The following programs place the string B$ as„a subscript of the string A$.  The value of R must be between 1 and 12,„and the value of C can be at most one more than the width of the screen„minus the sum of the lengths of the two strings.  To display B$ as a„superscript of A$, replace the R in line 40 by R-1.„„10 SCREEN 1:CLS                         10 SCREEN 2:CLS„20 LOCATE R,C:PRINT A$;                 20 LOCATE R,C:PRINT A$;„30 POKE 1098,20                         30 POKE 1098,40„40 LOCATE 2*R:PRINT B$                  40 LOCATE 2*R:PRINT B$„50 POKE 1098,40                         50 POKE 1098,80„„     5.  The contents of the graphics screen are stored in a buffer„beginning at offset:  PEEK(1102)+256*PEEK(1103)  in a portion of„memory that physically resides on a graphics board.  The size of this„buffer is given by:  PEEK(1100)+256*PEEK(1101)„„     6.  When using text mode with a graphics monitor, there are„several memory pages at your disposal.  The cursor locations for the„various pages are given as follows:  Let CR(n) and CC(n) be the Cursor„Row and Cursor Column for page n.  Then:  PEEK(1105)+2*n)  has a value„of CR(n)-1, and:  PEEK(1104+2*n)  has a value of CC(n)-1.„„     7.  The shape of the cursor can be set with a statement of the„form:  LOCATE ,,,I,J.  In this LOCATE statement, "PEEK(1121) AND 31"„has value I, and "PEEK(1120) AND 31" has value J.  If "PEEK(1121) AND„32" has a value of 32, then the cursor is not displayed.„„     8.  To obtain the number of the visual page (that is, the page„currently being displayed), you simply "PEEK(1122)".„„     9.  The adapter boards can be given instructions by OUTing to„ports on a chip known as the CRT controller chip.  To determine the„number of the index register port for the adapter board currently in„use, "PEEK(1123)+256*PEEK(1124)".  The value will be 948 for the„monochrome display board and 980 for the color/graphics adapter.„„     10.  The following statements check the mode settings on the CRT„mode register currently in use:„„PEEK(1125) AND 1    has value 1 if in text mode, width 80„PEEK(1125) AND 2    has value 2 if in graphics mode„PEEK(1125) AND 4    has value 4 if color is disabled (for instance, if„                      the statement SCREEN 1,1 has been executed)„PEEK(1125) AND 8    has value 8 if video is enabled, that is, not„                      blanked„PEEK(1125) AND 16   has value 16 if in high-resolution graphics mode„PEEK(1125) AND 32   has value 32 if blinking is enabled„„     The value of PEEK(1125) will change after appropriate SCREEN or„WIDTH statements are executed.  It is not affected by OUT statements,„however.  It will not always reflect the true status of the monitor,„therefore, unless it is updated after OUTs to port 984 or 952.„„     11.  In the medium-resolution graphics mode, the background color„and palette are selected by the statement COLOR b,p.  The statement„"PEEK(1126) AND 15" will have the balue b, and "(PEEK(1126) AND 32)/32"„will have the value p.  In text mode, with a color monitor, the value„of "PEEK(1126) MOD 16" will be the border color and "PEEK(1126) AND 16"„will be 16 if the current color was specified by a statement of the„form COLOR f,b in which f is 0 through 15 and b>7.„„     The value of PEEK(1126) will change after appropriate SCREEN or„COLOR statements are executed.  However, it is not affected by OUT„statements.  Therefore, it will not always reflect the true status of„the monitor unless it is updated after OUTs to port 985.„„     12.  In graphics mode, the statement "PRINT CHR$(n)" where n is a„number from 128 to 254, causes the computer to display the character„in an 8 by 8 rectangle of pixels.  Each character is described by a„sequence of eight bytes.  The eight bytes describing CHR$(128) are„contained in the eight successive memory locations beginning with the„location at offset "PEEK(124)+256*PEEK(125)" in segment "PEEK(126)+„256*PEEK(127)".  The pattern for CHR$(129) is contained in the next„eight locations, and so on.  To create a character set for ASCII values„from 128 to 254:„          a. Select the portion of memory to hold the bytes describing„the characters.„          b. POKE the pattern for character 128 into the first eight„memory locations, the pattern for character 129 into the next eight„locations, and so on.„          c. POKE the offset and segment of the first byte into„locations 124 to 127.„„     13.  The video parameter table consists of 64 bytes beginning at„memory location of offset "PEEK(116)+256*PEEK(117)" in segment„"PEEK(118)+256*PEEK(119)".  The first 16 bytes are numbers that are„OUTed to registers on the color/graphics adapter board when the 40 by„25 text mode is initialized.  The next two 16-byte sequences are„associated with the 80 by 25 text and graphics modes on the color/„graphics adapter.  The final sequence of 16 bytes is used to initialize„the monochrome display.  You must be very careful when changing these„bytes.  Certain values for the first 10 bytes in each sequence could„damage your monitor.„„                             PRINTER„„     1.  The number of printer adapters installed is given by "(PEEK„(1041) AND 192)/64".„„     2.  To determine the first port associated with LPTn, "PEEK(1030„+2*n)+256*PEEK(1031+2*n)".  If this number is 0, then LPTn is not„available.  To swap two printers, interchange their initial port„numbers.  Denote the first port associated with LPTn by Pn.  The value„of P1 will by 956 if LPT1 is attached to the IBM monochrome display„and parallel printer adapter.„„     3.  The ASCII value of the last character sent to the printer by„LPRINT or PRINT# is:  INP(Pn).„„     4.  To determine printer status:  LET X = INP(Pn+1)„„X AND 128   has value 128 if the printer is busy or off line„X AND 64    has value 0 if the printer has acknowledged that data has„              been sent and is ready to receive more„X AND 32    has value 32 if the printer is out of paper„X AND 16    has value 16 if the printer is on-line„X AND 8     has value 0 if there is an I/O error„„     5.  To initialize the printer, send:  OUT Pn+2,8:OUT Pn+2,12„„     6.  With PCs having 256K RAM motherboards, the parallel printer„timeout values can be read and set.  The timeout value for LPTn is„approximately:  1.6*PEEK(1143+n)  seconds.  To set the timeout value„for LPTn to S seconds:  POKE 1143+n,.64*S.„„                           DISK DRIVES„„     1.  To determine the number of diskette drives:  (PEEK(1040) AND„1)*(1+PEEK(1040)\64).„„     2.  In determining the status of a drive motor:  PEEK(1087) AND„128  has a value of 128 when a disk drive is being written to, and:„PEEK(1087) AND 15  has a value of 0 when no drive motor is running.„If drive L is running, then the value of  "PEEK(1087) AND 2 ^ (ASC„("L")-65)" will be 1.  Drive L here is A, B, C or D, and the letter„must be typed in uppercase.  These value are not affected if an OUT„was used to turn on the motor.„„     3.  To turn on drive L for n seconds, where n is at most 14:„POKE 1088,18.2*n:OUT 1010,2^(ASC("L")-61)+ASC("L")-53.  Location 1088„holds the countdown, in clock ticks, until the diskette motor is shut„off.„„     4.  To turn off all drives, send:  OUT 1010,12„„     5.  To determine the diskette track that was last accessed, use:„PEEK(1093).„„     6.  To determine which diskette head (0 or 1) was last accessed,„use:  PEEK(1094).„„     7.  Similarly, to determine which diskette sector was last„accessed:  PEEK(1095).  When single-sided diskettes are used, items„5, 6 and 7 above may specify the sector following the one most recently„accessed.„„     8.  The number of bytes per sector on a diskette is given by:„128*2^PEEK(1096).„„     9.  The diskette parameter table consists of 11 bytes.  To explore„this:  LET D = PEEK(120)+256*PEEK(121).  Then, after executing:„DEF SEG = PEEK(122)+256*PEEK(123)  you can derive the following table:„„(PEEK(D) AND 240)\8     is the time (in milliseconds) required for the„                          diskette drive to move from track to track„(PEEK(D) AND 15)*32     is the head unload time (in milliseconds) after„                          a read or write operation has occurred„(PEEK(D+1) AND 240)\4   is the head load time (in milliseconds)„PEEK(D+1) AND 15        is the Direct Memory Access mode„PEEK(D+2)               is the wait time until turning the motor off„PEEK(D+3)               is the number of bytes per sector on the disk;„                          a value of v specifies 128*2^v bytes per„                          sector, for v=0 to 3„PEEK(D+4)               is the number of sectors per track, usually„                          8 or 9„PEEK(D+5)               is the gap length (in bytes) between sectors„PEEK(D+6)               is the data length that you read out or write„                          into a sector when the sector length is not„                          specified„PEEK(D+7)               is the gap length used when formatting„PEEK(D+8)               is the value the format operation uses to„                          initialize diskette sectors, usually 256„PEEK(D+9)               is the number of milliseconds allowed for the„                          heads to stabilize„PEEK(D+10)              is the number of eighths of a second to allow„                          for motor startup„„Changing the values of PEEK(D+3) and PEEK(D+4) can modify the way that„diskettes are read and might require you to format your diskettes„manually.„„     10.  The number of hard disks on a PC-XT can be found with:„PEEK(1141).„„     11.  If a single diskette drive is used for both drives A: and„B:, its current roles is:  CHR$(65 + PEEK(1284))„„                        RS-232 INTERFACE„„     1.  The number of RS-232 cards attached can be found with:„(PEEK(1041) AND 14)/2„„     2.  To determine the first of the seven ports associated with„COMn:  PEEK(1022+2*n)+256*PEEK(1023+2*n).  If this number is 0, then„COMn is not available.  To swap two RS-232 interfaces, interchange„their initial port numbers.  Denote the initial port associated with„COMn by Pn.  Normally, the value of P1 is 1016 and the value of P2 is„760.„„     3.  Interrupt enabling:„„OUT Pn+1,1   enables an interrupt when a character has been received„OUT Pn+1,2   enables an interrupt when a character has been transmitted„OUT Pn+1,4   enables an interrupt when an error has occurred„OUT Pn+1,8   enables an interrupt when the modem status has changed„„To enable several of the above interrupts at the same time, OUT the„sum of the associated numbers to port Pn+1.„„     4.  To identify interrupts, use the port number determined above„(Pn) and:  LET X = INP(Pn+2).  "X AND 1" has a value of 1 as long as no„interrupts have been issued because of communications port activity.„Similarly, "X AND 6" is used to identify the highest priority interrupt„pending, as indicated in the table "Interrupt Control Functions" in the„IBM Technical Reference manual.„„     5.  To establish the number of data bits (d), the number of stop„bits (s), and the parity (p=0 for no parity, p=1 for odd parity, p=3„for even parity), send:  OUT Pn+3, d-5 + 4*(s-1) + 8 * p.„„     6.  To establish the baud rate:  H=INP(Pn+3):OUT Pn+3,H OR 128:„OUT Pn,DL:OUT Pn+1,DH:OUT Pn+3,H.  Use values DL=128 and DH=1 for 300„baud, and DL=96 and DH=0 for baud rate 1200.  Otherwise, DL=d MOD 256„and DH=d\256, where d is the divisor number given by the IBM Technical„Reference manual in the table "Baud Rate at 1.853 MHz."„„     7.  To produce a break signal:  X=INP(Pn+3):OUT Pn+3,X OR 64:PLAY„"MF":SOUND 32767,6:SOUND 32767,1:OUT Pn+3,X.  The PLAY and SOUND„statements produce a delay of 1/3 second.„„     8.  To control the modem, use:„„OUT Pn+4,1     to assert that the data terminal is ready (DTR)„OUT Pn+4,2     to raise a request to send (RTS)„OUT Pn+4,16    to perform loopback testing„„To accomplish several of the above tasks simultaneously, OUT the sum„of the associated numbers to port Pn+4.„„     9.  To determine the status of data transfer, begin with:„LET X = INP(Pn+5).  Now:„„X AND 64    has a value of 64 if the transmitter shift register is idle„X AND 32    is 32 if the transmitter holding register is ready to„              accept a character for transmission„X AND 16    has the value 16 if the received data input is held in the„              spacing state too long (that is, if a break was received)„X AND 8     has the value 8 if the received character did not have a„              valid stop bit; that is, if a framing error occurred„X AND 4     has the value 4 if the received character does not have„              the correct parity„X AND 2     is 2 if the received data destroyed the previous character„              (an overrun error)„X AND 1     has value 1 if a character is ready to be read from the„              received buffer register„„     10.  INP(Pn) will read the ASCII value of a character from the„serial port, provided:  (INP(Pn+5) AND 1) = 1„„     11.  You can use OUT Pn,m to write the character with ASCII value„m to the serial port, provided that:  (INP(Pn+5) AND 32) = 32„„     12.  To determine the status of the modem, use:  X = INP(Pn+6).„Then:„„X AND 128    has the value 128 if a Carrier signal has been detected„X AND 64     is 64 if the modem is ringing„X AND 32     has a value of 32 if the modem has asserted Data Set Ready„X AND 16     is 16 if the modem has asserted Clear to Send„X AND 8      is 8 if the Carrier Detect has changed state„X AND 4      has the value 4 if the Ring Indicator input has changed„               from On to Off„X AND 2      is 2 if the Data Set Ready input has changed state since„               the last time it was read„X AND 1      has a value of 1 if the Clear to Send input has changed„               state since it was last read„„                             SPEAKER„„     1.  The timer chip determines the frequency of the sound produced„by the speaker.  To prepare to send a value to the timer chip, send:„OUT 67,182„„     2.  The human ear can perceive sounds varying in frequency from„about 20 to 20,000 Hz.  To set the timer chip to produce a frequency„of F Hz:  A=INT(1193182/F):H=INT(a/256):L=A-H*256:OUT 66,L:OUT 66,H„„     3.  To turn the speaker on, use:  OUT 97,INP(97) OR 3„„     4.  Conversely, to turn the speaker off:  OUT 97,INP(97) AND 252„„                      CASETTE PORT CONTROL„„     1.  To turn the cassette motor on:  OUT 97,INP(97) AND 247„„     2.  To turn the cassette motor off:  OUT 97,INP(97) OR 8„„„Even if a cassette player is not attached, toggling the cassette motor„produces a clicking sound.  Repeated togglings can produce interesting„sound effects, but since the relay involved is not designed as a„musical instrument, excessive use may cause its failure.„„                          MISCELLANEOUS„„     1.  The number of game adapters attached is shown with:  (PEEK„(1041) AND 16)/16„„     2.  To find the size of RAM in kilobytes, use:  PEEK(1043) +„256*PEEK(1044)„„     3.  The internal clock ticks 18.20648 times per second.  The„number of ticks that have occurred since midnight is given by:„PEEK(1132)+256*PEEK(1133)+65536PEEK(1134).  This value increases until„it reaches 1,533,039 (an instant before midnight), and at midnight it„is reset to 0.  The value of PEEK(1136) is increased by 1 as a result„of the reset.  Executing either TIME$ or DATE$ changes the value of„PEEK(1136) back to 0.„„     To determine the date N days from now, execute:  FOR I=1 TO N:„POKE 1136,1:A$=DATE$:NEXT I:PRINT DATE$.  With versions of DOS prior„to 3.0, when N is less than 256, the entire FOR...NEXT loop can be„replaced by POKE 1136,N.„„     4.  Memory locations 1264 to 1279 are not used by either DOS or„BASIC.  Data can be passed from one program to another by POKEing it„into these locations and PEEKing it later.„„     5.  To exit BASIC and complicate reinvoking it, you can:  POKE„1295,2:SYSTEM.  Memory location 1295 is set to 2 when the BASIC„command SHELL is executed.„„     6.  The segment number of BASIC's data segment may be found with:„PEEK(1296)+256*PEEK(1297)„„     7.  To disable the nth interrupt:  POKE n*4,83:POKE n*4+1,255:„POKE n*4+2,0:POKE n*4+3,240.  Prior to executing these statements, use„PEEK to record the contents of the four memory locations.  To reenable„the interrupt, use POKE to restore these locations to their original„state.„„     This part of the article is divided into sections that each deal„with the memory locations found in a specified, common segment.  When„typing in the applications that follow, you must be careful to execute„the proper DEF SEG statement for each section and to preface each PEEK„with a PRINT statement.  The three programs, DEMO1.BAS, DEMO2.BAS and„DEMO3.BAS illustrate many of these applications.„„                      BASIC's Data Segment„„Prefix with DEF SEG unless otherwise noted„„„     The segment of memory that is allocated to BASIC is referred to as„BASIC's Data Segment.  When BASIC is first invoked, it is the current„segment.  Also, the BASIC statement DEF SEG, when used without any„additional address, specifies this memory segment.  BASIC's Data„Segment is partitioned into seven regions.  The first of these is the„interpreter work area; the remaining six regions will be referred to„as BASIC's storage area.„„A. Interpreter Work Area„„     In the following discussion, Classic PCs are the original PCs,„produced in 1981 and 1982, with a maximum of 64K bytes of RAM on the„motherboard.  Their ROM chips are usually dated 4/24/81 or 10/19/81.„New PCs consist of all subsequent PCs, including the XT and the AT.„„     1.  With a New PC, using BASIC versions 2.0, 2.1 or 3.0, you can„determine the last random number to be generated with„„          (1+PEEK(11)+256*PEEK(12)+65536*PEEK(13))/2^24„„When using a Classic PC or using a New PC with BASIC 3.1, do not add„in the initial number 1.  The procedure above assumes that RANDOMIZE„has not been executed since the last random number was generated.  On„a New PC, the result will occasionally differ from the actual value of„RND in the last digit.  The number 1 was added in the formula for New„PCs to reduce round-off errors.„„     2.  To determine the next random number to be generated:„Successive random numbers are generated by a formula involving two„parameters, A# and B#, below.  These two numbers vary according to the„type of PC and the version of BASIC.  Some combinations are:  A# =„214013, B# = 13737667 (a New PC and a version of BASIC prior to 3.1);„A# = 17405, B# = 10395331 (a Classic PC and a version of BASIC prior„to 3.1); A# = 214013, B# = 2531011 (a New PC and BASIC 3.1); and A# =„214013, B# = 10395331 (A Classic PC and BASIC 3.1).  The following„program will compute the numbers A# and B# for your particular„configuration.  Record the values of A# and B# for future use.„„10 POKE 11,0:POKE 12,0:POKE 13,0:T=RND„20 B#=PEEK(11)+256*PEEK(12)+65536#*PEEK(13)„30 POKE 11,1:POKE 12,0:POKE 13,0:T=RND„40 A#=PEEK(11)+256*PEEK(12)+65536#*PEEK(13)-B#„50 PRINT "A# =";A#;"B# =";B#„„AT any time, the following program will determine the next random„number to be generated by a Classic PC using any version of BASIC or„a New PC using BASIC 3.1.„„10 S#=PEEK(11)+256*PEEK(12)+65536#*PEEK(13)„20 X#=A#*S#+B#„30 T#=X#-2#^24*INT(X#/2#^24)„40 PRINT "The next random number will be";CSNG(T#/2#^24)„„„„For a New PC and a version of BASIC preceding 3.1, replace lines 10„and 30 with:„„10 S#=PEEK(11)+256#*PEEK(12)„30 T#=1+x#-2#^24*INT(X#/2#^24)„„POKEing numbers into locations 11, 12 and 13 reseeds the random-number„generator.„„     3.  PEEK(40) returns the number of the most recent error message.„„     4.  Normally, the first 24 lines of the screen scroll as the„screen fills.  However, the scrolling portion of the screen can consist„of any rectangular portion beginning on the left side of the screen.„The following statements specify that the scrolling portion of the„screen consists of the first c positions of lines a through b.  Once„the cursor has been moved to this region, it will be confined there.„„          POKE 41,c:POKE 91,a:POKE 92,b„„To prevent all scrolling, even when characters are PRINTed into the„last line, execute:  POKE 92.0.  (Be careful to POKE another number„into location 92 before the program terminates.)  To scroll all 25„lines, execute:  KEY OFF:POKE 92,25„„     5.  For the current BASIC line number, PEEK(46)+256*PEEK(47)„„     6.  To determine the screen mode,„„PEEK(72) = 0 text mode, WIDTH 40, color burst disabled„         = 1 text mode, WIDTH 40, color burst enabled„         = 2 text mode, WIDTH 80, color burst disabled„         = 3 text mode, WIDTH 80, color burst enabled„         = 4 medium-resolution graphics, color burst enabled„         = 5 medium-resolution graphics, color burst disabled„         = 6 high-resolution graphics, color burst disabled„         = 7 monochrome display„„     7.  To determine the text-mode foreground color, PEEK(75)„„     8.  For the text-mode background color, PEEK(76)„„     9.  For the text-mode border color, PEEK(77)„„     10.  For medium-resolution text color, PEEK(78) AND 3„„     11.  To set the text color in medium-resolution graphics mode to„color c of the current palette (c = 1, 2 or 3), POKE 78,c„„     12.  For the medium-resolution background color, PEEK(81) AND 15„„     13.  For the medium-resolution palette, PEEK(82) MOD 2„„„„     14.  The row number of the cursor is given by, PEEK(86).  The„column number is given by, PEEK(87).„„     15.  For the WIDTH of each line printed on LPT1, PEEK(98).  To set„the WIDTH to w, execute:  POKE(98),w.„„     16.  The position of the print head within the buffer of LPT1 is„given by:  PEEK(99).  To move the print head to position n, execute:„PEEK(99),n„„     17.  PEEK(100) returns a value of 1 if the cassette motor is off,„0 if the motor is on.„„     18.  To determine if the soft keys are displayed on line 25:„„PEEK(113) = 0    not displayed„          = 1    displayed ever since BASIC was invoked„          = 255  displayed as a result of executing KEY ON„„If the soft keys are displayed and 0 is POKEd into location 113, the„keys will continue to be displayed.  However, the combination of LOCATE„and PRINT will be able to display characters on the 25th line, and CLS„will erase the 25th line.„„     19.  To determine the exact user response to an INPUT, LINE INPUT,„INPUT#, or LINE INPUT# statement, use:„„A$="":N=503:WHILE PEEK(N)<>0:A$=A$+CHR$(PEEK(N)):N=N+1:WEND:? A$„„(Note:  This line must be part of a program.  If executed in direct„mode, it will just read itself.  While numeric responses are often„rounded, truncated, or converted to floating-point form, the string A$„will consist of the exact digits typed.)„„     20.  To show the location of the end of the last statement„executed:  PEEK(835)+256*PEEK(836).  (Note:  This pointer points to„either the null character at the end of a line or to the colon„separating a pair of statements.)„„     21.  The memory location pointed to by the BASIC stack pointer is„returned by:  PEEK(837)+256*PEEK(838)„„     22.  The line number of the last BASIC error is shown by:„PEEK(839)+256*PEEK(840)„„     23.  For the location of the program line n specified in an ON„ERROR GOTO n statement:  PEEK(845)+256*PEEK(846)„„„„„„„„„     24.  The segment number of BASIC's Data Segment is returned by:„PEEK(848)+256*PEEK(849).  Machine language programs must be POKEd into„an unused portion of memory where they can be CALLed.  One safe place„is the segment whose number is 4096 higher than the segment number of„BASIC's Data Segment.  The available space can be determined by„executing:  DEF SEG=0:PRINT PEEK(1043)+256*PEEK(1044).  This returns„the size of the random access memory in kilobytes.„„     25.  The memory location (in the text of a program) of the byte„following the most recently READ piece of DATA is shown by:„PEEK(862)+256*PEEK(863)„„     26.  The minimum allowable value for array subscripts is at:„PEEK(1116)„„     27.  To protect the current program so that it cannot be LISTed„or EDITed:  POKE 1125,255„„     28.  To determine if the current program is protected:  PEEK(1124)„has value 0 if the program is not protected; the message "Illegal„function call" is produced if the program is protected.„„     29.  To show the number of files specified by the /F option when„BASIC was invoked, use:  PEEK(1247)„„     30.  To determine the File Control Blocks:  LET X=PEEK(1248) +„256*PEEK(1249).  Then the File Control Block for the nth file begins„at the location shown by:  PEEK(X+2*n)+256*PEEK(X+2*n+1).  Bytes 3„through 13 of the File Control Block contain the name of the file.„The drive containing the file is:  CHR$(64+PEEK(2nd location)).„„     31.  The disk drive containing the file most recently accessed by„BASIC is:  CHR$(64+PEEK(1264))„„     32.  The name of the file most recently accessed by BASIC is„given by:  FOR I=0 TO 10:PRINT CHR$(PEEK(1265+I));:NEXT I„„     33.  For the coordinates of the last point referenced:  PEEK(1341)„+256*PEEK(1342)  is the x coordinate; PEEK(1339)+256*PEEK(1340)  is the„y coordinate.„„     34.  To set the coordinates of the last point referenced to (a,b),„use:  POKE 1341,a MOD 256:POKE 1342,a\256„      POKE 1339,b MOD 256:POKE 1340,b\256„„     35.  Strings of up to 15 characters can be assigned to the„function keys with the KEY statement.  These strings are stored in the„160 memory locations beginning with the location of offset 1619.  Every„16th memory location and the unused locations contain a null character.„You can use this information, in conjunction with redefining the scroll„window, to customize the display that normally occupies the 25th line„of the screen.„„„„     36.  The current color to be used by DRAW statements is returned„by:  PEEK(1782) AND 3.  To change the color to color c of the current„palette, execute:  POKE 1782,85*c.  (Note: Any graphics statement„containing a color parameter changes the value of PEEK(1782) AND 3 to„the specified color.)„„     37.  BASIC's environment begins at offset 0 in segment ENV, where„the numeric value of ENV can be determined with the following program.„Each equation in the environment is followed by a null character, and„the final equation is followed by two null characters.„„10 DEF SEG„20 PSP=PEEK(1794)+256*PEEK(1795)  'Program Segment Prefix„30 DEF SEG=PSP„40 ENV=PEEK(44)+256*PEEK(45)„„     38.  The following listing will show the program that was executed„and the options (such as /F:4) that were specified when BASIC was„invoked.„„10 DEF SEG„20 PSP=PEEK(1794)+256*PEEK*1795)   'Program Segment Prefix„30 DEF SEG=PSP„40 FOR I=130 TO 129+PEEK(128)„50 PRINT CHR$(PEEK(I));„60 NEXT„„     39.  The buffer size for random files specified by the /S option„when BASIC was invoked is returned by:  PEEK(N)+256*PEEK(N+1)  where„N = 1851, 1854, 1858 and 1858 for BASIC Versions 2.0, 2.1, 3.0, and„3.1, respectively.„„     40.  Similarly, for the communications buffer size specified by„the /C: option when BASIC is invoked:  PEEK(N)+256*PEEK(N+1)  where„N = 1861, 1864, 1868 and 1870 for BASIC Versions 2.0, 2.1, 3.0, and„3.1, respectively.„„     41.  To locate the communications buffer in BASICA 2.1:„„LET X=PEEK(1866)+256*PEEK(1867)  for COM1:„LET X=PEEK(1868)+256*PEEK(1869)  for COM2:„„     The buffer for receiving data when using the Asynchronous„Communications Adapter begins at location  PEEK(X+1)+256*PEEK(X+2)„and it ends at  PEEK(X+3)+256*PEEK(X+4)-1.  The buffer for transmitting„data begins at location  PEEK(X+5)+256*PEEK(X+6)  and ends at„PEEK(X+7)+256*PEEK(X+8)-1.„„     The numbers 1866-1869 should be changed to 1863-1866, 1870-1873,„and 1872-1875 for BASICA Versions 2.0, 3.0, and 3.1, respectively.„„„„„„     42.  The position of the print head within the buffer of LPT2 is„returned by PEEK(N) where N = 1875, 1878, 1882, and 1884 in BASIC„Versions 2.0, 2.1, 3.0, and 3.1, respectively.  To move the print head„to position n, execute POKE N,n.„„     43.  Similarly, the position of the print head within the buffer„of LPT3 is returned by PEEK(N) where N = 1876, 1879, 1883, and 1885 in„BASIC Versions 2.0, 2.1, 3.0, and 3.1, respectively.  To move the print„head to position n, execute POKE N,n.„„     44.  For the WIDTH of each line printed by LPT2: PEEK(N) where„N = 1877, 1880, 1884, and 1886 in BASIC Versions 2.0, 2.1, 3.0, and„3.1, respectively.  To set the WIDTH to w, execute POKE N,w.„„     45.  Similarly, for the WIDTH of each line printed by LPT3:„PEEK(N) where N = 1878, 1881, 1885, and 1887 in BASIC Versions 2.0,„2.1, 3.0, and 3.1, respectively.  To set the WIDTH to w, execute„POKE N,w.„„     46.  In direct mode, pressing Ctrl-PrtSc causes the printer to„print all output as it appears on the screen.  This is referred to as„an echo to the printer.  In program (or direct) mode, the statement„POKE N,255 turns on echoing and the statement POKE N,0 turns off„echoing, where N = 1880, 1883, 1887, or 1889 in BASIC Versions 2.0,„2.1, 3.0, or 3.1, respectively.„„     47.  To determine the music parameters in BASICA 2.1:„„PEEK(2140) has value 0 for the Music Foreground mode and values 1 or„     255 for the Music Background mode.„PEEK(2141) is the current octave number.„PEEK(2142) is the current tempo in quarters per minute.„PEEK(2143) is the reciprocal of the length of a standard note.„„     It is set by the statement PLAY "Ln".„„PEEK(2145) has the value 1, 2, or 3 to demote Music Legato, Music„     Staccato, or Music Normal, respectively.„„     The numbers 2140-2145 should be changed to 2144-2149 and 2149-2154„for BASICA Versions 3.0 and 3.1, respectively.  In BASICA Version 2.0,„2141-2145 should be changed to 2136-2140, and 2140 should be changed to„2141.„„     48.  PEEK(N) shows the scale to be used by DRAW, where N = 2161,„2163, 2167, and 2172 in BASICA Versions 2.0, 2.1, 3.0, and 3.1,„respectively.  To set the scale to n, execute POKE N,n.„„     49.  Use the following statements to determine the angle at which„future DRAWings will be turned in BASICA 2.1.  (Such angles are set by„the statement DRAW "TA n", where n is the number of degrees in the„angle.)„„„„PEEK(2165) is the low byte in the integer representation of n.  (Hence,„if n is between 0 and 255 degrees, PEEK(2165)=n.)„„CVS(CHR$(PEEK(2166))+CHR$(PEEK(2167))+CHR$(PEEK(2168))+CHR$(PEEK(2169)))„„is the cosine of the angle n.„„CVS(CHR$(PEEK(2170))+CHR$(PEEK(2171))+CHR$(PEEK(2172))+CHR$(PEEK(2173)))„„is -1/1.2 times the sine of the angle in SCREEN mode 1.„„CVS(CHR$(PEEK(2174))+CHR$(PEEK(2175))+CHR$(PEEK(2176))+CHR$(PEEK(2177)))„„is 1.2 times the sine of the angle in SCREEN mode 1.„„     Replace 1.2 with 2.4 for SCREEN mode 2.  This information can be„used to compute the cosine and sine of the angle, and hence the value„of the angle.„„     The numbers 2165-2177 should be chanted to 2163-2175, 2169-2181,„and 2174-2186 for BASICA Versions 2.0, 3.0, and 3.1, respectively.„„     50.  To determine status of light-pen trapping in BASICA 2.1, use:„„PEEK(2203) = 0 if trapping of light pen is OFF„           = 1 if trapping of light pen is ON„           = 2 if trapping of light pen is STOPped while OFF„           = 3 if trapping of light pen is STOPpen while ON„„Activating the light pen causes the program to branch to the program„line stored at location PEEK(2204)+256*PEEK(2205).  The numbers 2203-„2205 should be changed to 2201-2203, 2207-2209, and 2212-2214 for„BASICA Versions 2.0, 3.0, and 3.1, respectively.„„     51.  To determine the status of key-trapping in BASICA 2.1, use:„„PEEK(2203+3*n) = 0 if trapping of key n is OFF„               = 1 if trapping of key n is ON„               = 2 if trapping of key n is STOPped while OFF„               = 3 if trapping of key n is STOPped while ON„„Pressing key n causes the program to branch to the program line stored„at location PEEK(2204+3*n)+256*PEEK(2205+3*n).  The numbers 2203-2205„should be changed to 2201-2203, 2207-2209, and 2212-2214 for BASICA„Versions 2.0, 3.0, and 3.1, respectively.„„     52.  To determine the status of joystick-button trapping in„BASICA 2.1, use:„„PEEK(2266+3*n/2) = 0 if trapping of button n is OFF„                 = 1 if trapping of button n is ON„                 = 2 if trapping of button n is STOPped while OFF„                 = 3 if trapping of button n is STOPped while ON„„„Buttons 0 and 4 are the lower and upper buttons of the first joystick,„and buttons 2 and 6 are the lower and upper buttons of the second„joystick.  Pressing button n causes the program to branch to the line„stored at location PEEK(2267+3*n/2)+256*PEEK(2268+3*n/2).  The numbers„2266-2268 should be changed to 2264-2266, 2270-2272, and 2275-2277 for„BASICA Versions 2.0, 3.0, and 3.1, respectively.„„     53.  To determine the status of ON PLAY(n) trapping BASICA 2.1:„„PEEK(2278) = 0 if trapping is OFF„           = 1 if trapping is ON„           = 2 if trapping is STOPped while OFF„           = 3 if trapping is STOPped while ON„„When the changing of the number of notes in the music background buffer„from n to n-1 is trapped, the program branches to the program line„stored at location PEEK(2279)+256*PEEK(2280).  The numbers 2278-2280„should be changed to 2276-2278, 2282-2284, and 2287-2289 for BASICA„Versions 2.0, 3.0, and 3.1, respectively.  The value of n is PEEK(N),„where N = 2142, 2146, 2150, and 2155 in BASICA Versions 2.0, 2.1, 3.0,„and 3.1, respectively.„„     54.  To determine the status of the ON TIMER(n) trapping in„BASICA 2.1:„„PEEK(2281) = 0 if trapping is OFF„           = 1 if trapping is ON„           = 2 if trapping is STOPped while OFF„           = 3 if trapping is STOPped while ON„„The elapsing of n seconds causes the program to branch to the program„line stored at location PEEK(2282)+256*PEEK(2283).  The numbers 2281-„2283 should be changed to 2279-2281, 2285-2287, and 2290-2292 for„BASICA Versions 2.0, 3.0, and 3.1, respectively.  The value of n is„PEEK(N)+256*PEEK(N+1)+65536*PEEK(N+2), where N = 2145, 2149, 2153, and„2158 in BASICA Versions 2.0, 2.1, 3.0, and 3.1, respectively.  At any„time, the number of seconds remaining until a branching occurs is„PEEK(n+3)+256*PEEK(N+4).  To induce a branching as soon as possible,„execute POKE N+4,0:POKE N+3,1.  (Note: For values of n between 65536„and 86400, the ON TIMER statement causes a branching after just„n-65536 seconds.)„„     55.  To determine the keys or key combinations associated with the„user-defined key traps in BASICA Version 2.1: If PEEK(2284)+2*(n-15))=„0, then the key with scan code PEEK(2285+2*(n-15)) is associated with„Fn.  (Here n = 15, 16, ....or 20.)  Otherwise, the key combination„consisting of one or more latched keys along with the key having scan„code PEEK(2285+2*(n-15)) is associated with Fn.  The following table„gives the latched keys included in the combination.„Let L% = PEEK(2284+2*(n-15)).„„„„„„L% AND 3  = 3   Shift key„L% AND 4  = 4   Ctrl key„L% AND 8  = 8   Alt key„L% AND 32 = 32  NumLock key„L% AND 64 = 64  CapsLock key„„The numbers 2284-2285 should be changed to 2282-2283, 2288-2289, and„2293-2294 for BASICA Versions 2.0, 3.0, and 3.1, respectively.„„     56.  To determine the status of a VIEWport in BASICA Versions 2.1:„„If PEEK(2323) = 1, a viewport has been established„If PEEK(2324) = 0, then VIEW has been executed„If PEEK(2324) = 1, then VIEW SCREEN has been executed„„The x coordinates of the points in the viewpoint are stored in the„range from PEEK(2315)+256*PEEK(2316) to PEEK(2317)+256*PEEK(2318), and„the y coordinates range from PEEK(2319)+256*PEEK(2320) to PEEK(2321)+„256*PEEK(2322).  The numbers 2315-2324 should be changed to 2313-2322,„2319-2328, and 2324-2333 for BASICA Versions 2.0, 3.0, and 3.1,„respectively.„„     57.  In the world coordinate system of BASICA 2.1, PEEK(2359) has„the value 1 if a WINDOW statement has been executed.  If so, the„coordinate system is right-handed if PEEK(2360)=0 and left-handed if„PEEK(2360)=1.  The x coordinates range from x1 to x2, and the y„coordinates range from y1 to y2, where„„x1 = CVS(CHR$(PEEK(2361))+CHR$(PEEK(2362))+CHR$(PEEK(2363))+CHR$„     (PEEK(2364)))„„y1 = CVS(CHR$(PEEK(2365))+CHR$(PEEK(2366))+CHR$(PEEK(2367))+CHR$„     (PEEK(2368)))„„x2 = CVS(CHR$(PEEK(2369))+CHR$(PEEK(2370))+CHR$(PEEK(2371))+CHR$„     (PEEK(2372)))„„y2 = CVS(CHR$(PEEK(2373))+CHR$(PEEK(2374))+CHR$(PEEK(2375))+CHR$„     (PEEK(2376)))„„To return the physical coordinate system:  POKE 2359,0.  The numbers„2359-2376 should be changed to 2357-2374, 2363-2380, and 2368-2385 for„BASICA Versions 2.0, 3.0, and 3.1, respectively.  The world coordinates„can be altered by appropriate POKEing.)„„     58.  The music buffer is a circular buffer analagous to the„keyboard buffer.  In BASICA 2.1 it consists of the number of bytes„returned by PEEK(2417)+256*PEEK(2418), and it extends from the location„PEEK(2427)+256*PEEK(2428) to the location preceding PEEK(2425)+256*„PEEK(2426).  The notes to be played are stored in the bytes extending„from PEEK(2421)+256*PEEK(2422) (the head) to the location preceding„PEEK(2423)+256*PEEK(2424) (the tail), after possibly cycling back to„the beginning of the buffer.  Each note is described by 4 bytes.  The„„„duration of the note is (256*[1st byte]+[2nd byte])/583 seconds and the„frequency is 596591/(256*[3rd byte]+[4th byte]) Hertz.  In Music„Background mode, the number of bytes remaining in the buffer at any„time is given by PEEK(2419)+256*PEEK(2420).  (Note: The beginning and„end of the buffer are also given by PEEK(2394)+256*PEEK(2395) and„PEEK(2396)+256*PEEK(2397)).„„     The numbers 2394-2428 should be changed to 2420-2454, 2398-2432,„and 2403-2437 for BASICA Versions 2.0, 3.0, and 3.1, respectively.„„     The music buffer can be enlarged and relocated by POKEing into the„above-mentioned memory locations.  The buffer normally holds 32 notes.„The program DEMO1.BAS shows how to create a buffer capable of holding„N = 125 notes.  By changing the value of N (which appears twice in the„program), you can create even larger buffers.  (Note: In the Music„Normal or Music Staccato modes, the pause between successive notes is„counted as a note.)„„B.  BASIC's Storage Area„„     The six regions in BASIC's storage area hold the text of the„program, the values of the variables, and BASIC's stack.„„     1.  The program text begins at PEEK(48)+256*PEEK(49) and ends,„with a terminating null character appended at PEEK(854)+256*PEEK(855).„(Note: The second value will be zero unless requested in direct mode„after the execution of the program.  From within the program mode it„can be computed as PEEK(856)+256*PEEK(857)-3.)  Key words are„tokenized, and each 2-byte line number is preceeded with the 2-byte„offset of the beginning of the next line.„„     This information can be used to recover a program after NEW has„been executed, provided you know the first line.  To illustrate,„suppose that the first line of a program is:  0 REM Can unNEW.„„This line is stored in 16 bytes: 2 bytes for the pointer to the„location of the next line, 2 bytes for the line number, 1 byte for the„token of REM, 1 byte for the space after REM, 9 bytes for "Can unNEW",„and 1 null byte at the end of the line.  To recover the program,„„     a) Execute PRINT PEEK(48)+256*PEEK(49)  (This is referred to as„the number X, but be sure not to declare it as a variable, X.)„„     b) Execute POKE X,(X+16) MOD 256:POKE *x+1,(X+16)\256„„     c) SAVE the program in ASCII format.„„     d) LOAD the program.„„     e) LIST the program.  Every line will appear.  (Note: As a„precaution against losing a program, then, you can always make the„first line 0 REM Can unNEW.  Otherwise, in step (b), replace 16 with„the number of bytes needed to store the first line of your program.)„„„     2. Simple variables (that is, all variables except arrays) are„stored beginning at PEEK(856)+256*PEEK(857).  This region contains the„values of the numeric variables and pointers to the locations of the„string variables.„„     3. Array variables are stored beginning at PEEK(858)+256*PEEK(859)„„     4. Free space begins at PEEK(860)+256*PEEK(861).  New variables„take locations from the beginning of free space and new strings take„locations from the end.„„     5.  String space occupies the region extending from PEEK(815)+„256*PEEK(816) to PEEK(778)+256*PEEK(779).  New strings are added to„the bottom of string space by taking memory locations from free space.„„     6.  The space allocated for BASIC's stack follows the sgring space„and extends to PEEK(44)+256*PEEK(45), the end of the portion of memory„available to BASIC.  (Normally, it is the end of BASIC's Data Segment,„but it can be restricted by a CLEAR statement.)  At any time, the byte„on the top of the stack is in location PEEK(837)+256*PEEK(838).„„„                          Monochrome Display„„DEF SEG = 45056„„     The 4000 memory locations at the beginning of segment &HB000„reside on the monochrome display adapter board and hold the contents„of the screen.  Each of the following PEEK and POKE statements should„be preceded by DEF SEG = 45056 (or DEF SEG = &HB000).  (Caution: The„OUTs discussed in this section might cause physical damage if executed„with a board other than the IBM monochrome display adapter.)„„     1. To place the character having ASCII value n in row r, column c:„„POKE 2*(80(r-1)+(c-1)),n„„To define the attribute for this character:„„POKE 2*(80(r-1)+(c-1))+1,a„„where a =   7 when normal (that is, white on black)„        =   1 when normal and underlined„        = 112 when reverse video (that is, black on white).„„Add 8 to each of the first two numbers to obtain high-intensity white„and add 128 to any of the numbers to cause the characters to blink.„(Note: When POKEd, the ASCII values 7, 9, 10, 11, 12, 13, 28, 29, 30,„and 31 produce symbols.)„„     2. To disable blinking:  OUT 952,15„„     3. To blank the screen:  OUT 952,1„„„     4. To restore the screen (and enable blinking):  OUT 952,255„„     5. To turn off all but the first n rows of the screen:„OUT 948,6:OUT 949,n„„„                           Graphics Monitor„„DEF SEG = 47104„„     The 16K memory locations at the beginning of segment &HB800 reside„on the color/graphics adapter board and hold the contents of the„screen.  The graphics screen has three modes: text, medium-resolution„graphics, and high-resolution graphics.  Each of the following PEEK or„POKE statements should be preceded by DEF SEG = 47104 (of DEF SEG =„&HB800).  (Caution: The OUTs discussed in this section might cause„physical damage if executed with a board other than the IBM color/„graphics adapter.)„„A. Text Mode„„     In text mode (invoked by the statement SCREEN 0), characters can„be displayed in rows of either 40 characters (invoked by the statement„WIDTH 40) or 80 characters (invoked by the statement WIDTH 80).„„     1. To place the character having ASCII value n in row r, column c,„with foreground color f and background color b:  POKE a,n:POKE a+1,k„where a = 160*(r-1)+2*(c-1) in WIDTH 80 and = 80*(r-1)+2*(c-1) in WIDTH„40, and where k = 16*b+f if the foreground should not blink and„= 16*b+f+128 if the foreground should blink.  The number f ranges from„0 to 15, and b ranges from 0 to 7.  (Note: These locations correspond„to page 0.  To obtain the analogous results for page p, add p*4096 to a„in WIDTH 80 and add p*2048 to a in WIDTH 40.)„„     2. To disable blinking:  OUT 984,8 in width 40„                              OUT 948,9 in width 80„„(Note: With blinking disabled, the number b in item 1 can range from„0 to 15.)„„     3. To blank the screen:  OUT 984,32 in width 40„                              OUT 984,33 in width 80„„     4. To restore the screen:  OUT 984,40  width 40, blinking enabled„                                OUT 984,8   width 40, blinking disabled„                                OUT 984,41  width 80, blinking enabled„                                OUT 984,9   width 80, blinking disabled„„     5. To set the border color to d:  OUT 985,d„„     6. The color/graphics adapter board contains 16K bytes of memory.„Each pair of locations holds the information for one character.  (The„first location holds the ASCII value of the chracter and the second„„„holds the attribute.)  Any consecutive block of 2000 (in 40 by 25 mode)„or 4000 pairs (in 80 by 25 mode) can be used to determine the„characters appearing on the screen.  To display the characters„determined by pairs N, N+1, N+2, ...:„„OUT 980,12:OUT 981,N\256:OUT 980,13:OUT 981,N MOD 256„„(To display the pth page in 40 by 25 mode, use N = p*2048.  In 80 by 25„mode, use N = p*4096.)„„B. Medium-Resolution Graphics Mode„„     In medium-resolution graphics mode, which is invoked by the„statement SCREEN 1, the screen is partitioned into 320 by 200 pixels.„„     1. To turn on the pixel with coordinates x,y in color c of the„current palette:„„Z=40*y+x\4+8152*(y MOD 2):W=2^(6-2*(x MOD 4)):POKE Z,(PEEK(Z) AND„     (255-3*W))+c*W„„     2. To use background color c and palette p:  OUT 984,c+32*p„The palette colors can be intensified by adding 16 to the number„c+32*p.  Therefore, four different palettes are available.„„     3. With an RGB monitor, an undocumented palette (and its„intensified version) is available.  To obtain the background color c„and a palette consisting of the colors cyan, red, and white:„„OUT 984,46:OUT 985,c„„(Note: The palette colors can be intensified by adding 16 to the„number c.  Hence, there are actually 6 palettes available with an„RGB monitor.)„„     4. To reverse the foreground and background colors (and„interchange colors 1 and 2 of the palette) on the current display, use:„„FOR I% = 0 TO 16191:POKE I%,PEEK(I%) XOR 255:NEXT„„(Note: This procedure is sometimes valuable before doing a graphics„dump to the printer.)„„     5. To blank the screen:  OUT 984,2„„     6. To restore the screen:  OUT 984,10„„C. High-Resolution Graphics Mode„„     In high-resolution graphics mode (invoked by the statement SCREEN„2), the screen is partitioned into 640 by 200 pixels.„„„„„     1. To turn on the pixel with coordinates x,y:„„Z=40y+x\8+8152*(y MOD 2):POKE Z,PEEK(Z) OR 2^(7-x MOD 8)„„     2. To turn off the pixel with coordinates x,y:„„Z=40y+x\8+8152*(y MOD 2):POKE Z,PEEK(Z) AND (255-2^(7-x MOD 8))„„     3. To change the foreground color to c:  OUT 985,c„(The background color is normally black.)„„     4. To reverse the foreground and background colors of the current„display, use:„„FOR I% = 0 TO 16191: POKE I%,PEEK(I%) XOR 255:NEXT„„     5. To blank the screen:  OUT 984,18„„     6. To restore the screen:  OUT 984,26„„D. Low-Resolution Graphics Mode„„     The following programs set up a 160 by 100 pseudo-graphics mode„with background color B.„„10 KEY OFF:SCREEN 0,0,0:WIDTH 80„20 OUT 984,9„30 OUT 980,4:OUT 981,127„40 OUT 980,6:OUT 981,100„50 OUT 980,7:OUT 981,112„60 OUT 980,9:OUT 981,1„70 DEF SEG=&HB800„80 FOR I%=0 TO 16382 STEP 2„90 POKE I%,222:POKE I%+1,17*B„100 NEXT„„Although text cannot be PRINTed and pixels cannot be lit with PSET, the„point with coordinates X,Y can be turned on in any one 16 colors, C, by„executing:„„200 S=X AND 1„210 A=160*Y+(X OR 1)„220 POKE A,(PEEK(A) AND (15+S*225))+(C*(16-15*S))„„E. All Modes„„     1. The following program allows a graphics monitor and a„monochrome display to be used at the same time.  Suppose that BASIC„is currently writing to the monochrome display.  After this program is„executed, data can be PRINTed onto the monochrome display and POKEd„into the color/graphics adapter as in sections A, B, C, and D of the„Graphics Monitor portion of this article.„„„„10 FOR R=0 TO 15„20 READ V:OUT 980,R:OUT 981,V„30 NEXT„40 READ M:OUT 984,M„50 DATA 56,40,45,10,127,6,100,112,2,1,6,7,0,0,0,0,42„„     This program results in medium-resolution graphics.  To obtain„high-resolution graphics, replace the last number in the DATA statement„with 26.  To obtain text mode with 40 characters per line, replace line„50 with:„„50 DATA 56,40,45,10,31,6,25,28,2,7,6,7,0,0,0,0,40„„and to obtain text mode with 80 characters per line, replace line 50:„„50 DATA 113,80,90,10,127,6,100,112,2,1,6,7,0,0,0,0,9„„     2. To move the screen horizontally by approximately h characters„from the standard position:„„OUT 980,2:OUT 981,45+h  in width 40„OUT 980,2:OUT 981,90+h  in width 80„„(Note: If h is positive, the screen moves left; if h is negative, the„screen moves right.)„„     3. To move the screen vertically by about v pixels or characters„from the standard position:„„OUT 980,7:OUT 981,112+v  in graphics mode„OUT 980,7:OUT 981,28+v   in text mode„„(NOte: If v is positive, the screen moves up; if v is negative, the„screen moves down.)„„     4. To turn off all but the first n rows of the screen:„„OUT 980,6:OUT 981,n„„     5. To decrease the amount of snow on the screen when POKEing„characters or pixels into the screen, precede each POKE (or small„group of POKEs) with:„„WHILE 1 AND INP(986):WEND:WHILE NOT(1 AND INP(986)):WEND„„                           Read Only Memory„„DEF SEG = 61440„„     The following memory locations are part of read only memory (ROM).„Each PEEK in this section should be preceded by DEF SEG = 61440 (or„DEF SEG = &HF000).„„„„     1. Error messages with numbers ranging from 1 to 30 and 50 to 67„are stored in ROM in the 741 memory locations beginning with the„location at offset 25525.  A null character appears at the end of each„message, and question marks serve as place holders for the numbers with„no messages.  This information can be used, with ON ERROR and ERR, to„display the nature of an error without first terminating the program„currently in operation.„„     2. The strings that are assigned to the ten function keys when„BASIC is first invoked are stored in ROM in the 71 memory locations„beginning with the location of offset 44269.  A null character appears„at the end of each string.  This information can be used to restore the„original values to the function keys in the even that reassignments„have been made with the KEY statement.„„     3. To determine possible parameters for BASIC's random number„generator:„„PEEK(49771)+256*PEEK(49772)+65536*PEEK(49773)=214013„PEEK(49774)+256*PEEK(49775)+65536*PEEK(49776)=2531011„„These numbers sometimes serve as parameters for the random number„generator.  In particular, they are the values of A# and B# for a New„PC using BASIC 3.1.„„     4. In graphics mode, each character is displayed in an 8 by 8„array of pixels that can be stored as a sequence of 8 bytes.  The bytes„for the characters having ASCII values 0 to 127 are stored in the„memory locations having offsets from 64110 to 65113.  This information„can be used to write a program that will display characters upside-„down, enlarged, or sideways and to create banners with a printer.„„     5. To obtain the machine part number:„„FOR I=57344 TO 57350:PRINT CHR$(PEEK(I));:NEXT I„„     6. To obtain the IBM copyright notice:„„FOR I=57352 TO 57365:PRINT CHR$(PEEK(I));:NEXT I„„(Note: This information can be used to determine if the computer is an„IBM or an IBM compatible.)„„     7. To obtain the version date of the ROM BIOS:„„FOR I=65525 TO 65532:PRINT CHR$(PEEK(I));:NEXT I„„(Note: Certain hardware, such as the IBM enhanced graphics monitor, can„be used only if this date is sufficiently recent.)„„„„„„„     8. To determine the computer being used:„„PEEK(65534) = 255  PC„            = 254  PC-XT or Portable PC„            = 253  PCjr„            = 252  PC AT„„(Note: The identification numbers of PC compatibles will most likely„differ from these numbers.  Some early XTs have a machine ID code of„255.)„„Exceptions for the PCjr„„     The PEEKs, POKEs, INs, and OUTs presented in this article hold„for the IBM PC, XT and AT; however, many of the items do not hold for„the PCjr, such as outs to the color/graphics adapter and the POKEs„that relocate the music buffer.  And for non-IBM compatibles, remember„that compatible is as compatible does.„Tyler Barnes                   MEMORY VIEW                    FidoNet QUIK_BAS Echo          02-25-96 (22:04)       QB, PDS                556  13648    MEMVIEW.BAS DECLARE SUB TLOAD (File$, StartPos&)„DECLARE SUB TSAVE (File$, StartPos&, EndPos&)„DECLARE FUNCTION FileExist% (T$)„DECLARE FUNCTION GETINPUT$ (CHARS%)„DECLARE FUNCTION GETDEC$ (CHARS%)„DECLARE FUNCTION ProgramName$ ()„DECLARE SUB Box (topRow%, topCol%, lowRow%, lowCol%, Frg%, Bkg%)„DECLARE FUNCTION GETHEX$ (CHARS%)„DECLARE SUB FPRINT (NAT$, FL%)„CONST yes = 1, No = 0„'$INCLUDE: 'qb.bi'„SCREEN 0„DEFINT A-Z„StartLoc& = 0„StartSeg& = &H40„BorderColour% = 9„MemColour% = 7„InfoColour% = 15„Mode$ = "H"„LiveBytes% = yes„Lines% = 25„DIM Mods%(0 TO ((Lines% / 25) * 1439))„WIDTH , Lines%„Max& = 65535 - ((Lines% / 25) * 1439)„Main:„Invalid% = No„CurEdit% = 0„COLOR MemColour%, 0„DIM Regs AS RegType„LOCATE , , 0„CLS„COLOR BorderColour%, 0„LOCATE Lines% - CINT((Lines% / 25) * 6.5), 1: PRINT STRING$(80, 196)„COLOR 0, MemColour%„FOR I% = (Lines% - 2) TO Lines%„LOCATE I%, 1„FPRINT STRING$(80, " "), No„NEXT I%„LOCATE Lines% - 2, 1„FPRINT "   F1=Edit  F2=Goto Addr  F3=Config  F4=Load file into memory  F5=Memory Dump", No„LOCATE Lines% - 1, 1„FPRINT "       F6=Compare  F7=About MemoryView  F8=Mode  F9=Mem Search  ESC=Exit", No„LOCATE Lines%, 1„FPRINT "   Use Pgup, Pgdn, Home, End, and arrow keys to move inside selected segment", No„Update% = yes„DO„K$ = INKEY$„IF LEN(K$) THEN GOSUB Move„IF Update% = yes THEN„Regs.ax = &HB00„Regs.bx = BorderColour%„CALL INTERRUPT(&H10, Regs, Regs)„COLOR MemColour%, 0„COLOR InfoColour%, 0„IF LiveBytes% = yes THEN Update% = No„LOCATE Lines% - 5, 1: FPRINT "Segment: " + HEX$(StartSeg&) + "h     ", No„LOCATE Lines% - 4, 1: FPRINT "Offset: " + HEX$(StartLoc&) + "h to ", No„FPRINT HEX$(StartLoc& + ((Lines% / 25) * 1439)) + "h          ", No„LOCATE Lines% - 3, 1„PRINT "Mode: ";„IF Mode$ = "H" THEN PRINT "Hex" ELSE PRINT "Dec"„END IF„SL% = -2„IF LiveBytes% = yes OR (LiveBytes% = No AND Update% = yes) THEN„Update% = No„FOR I& = StartLoc& TO StartLoc& + INT(Lines% / 25) * 1439„SL% = SL% + 2„DEF SEG = StartSeg&„Char% = PEEK(I&)„DEF SEG = &HB800„POKE SL%, Char%„NEXT I&„END IF„LOOP„Move:„SELECT CASE K$„CASE CHR$(0) + "M", "6": StartLoc& = StartLoc& + 1„IF StartLoc& > Max& THEN StartLoc& = Max&„CASE CHR$(0) + "K", "4": StartLoc& = StartLoc& - 1„IF StartLoc& < 0 THEN StartLoc& = 0„CASE CHR$(0) + "H", "8": StartLoc& = StartLoc& - 80„IF StartLoc& < 0 THEN StartLoc& = StartLoc& + 80„CASE CHR$(0) + "P", "2": StartLoc& = StartLoc& + 80„IF StartLoc& > Max& THEN StartLoc& = StartLoc& - 80„CASE CHR$(0) + "Q", "3": StartLoc& = StartLoc& + 1440„IF StartLoc& > Max& THEN StartLoc& = StartLoc& - 1440„CASE CHR$(0) + "I", "9": StartLoc& = StartLoc& - 1440„IF StartLoc& < 0 THEN StartLoc& = StartLoc& + 1440„CASE CHR$(0) + "G", "7": StartLoc& = 0„CASE CHR$(0) + "O", "1": StartLoc& = Max&„CASE CHR$(0) + "A"„IT% = InfoColour%: BT% = BorderColour%„Box 5, 26, 12, 52, InfoColour%, BorderColour%„COLOR InfoColour%, BorderColour%„LOCATE 6, 28„SOUND 50, 1„FPRINT "  MemView Version 0.3", No„LOCATE 8, 28„FPRINT "By D. Tyler Barnes,1996", No„LOCATE 10, 28„FPRINT "       FREEWARE!", No„LOCATE 11, 28„FPRINT " Tested on a 486dx2 80", No„InfoColour% = IT%: BorderColour% = BT%„DO: Junk$ = INKEY$: LOOP UNTIL LEN(Junk$)„DEF SEG = &HB800„FOR C% = 691 TO 2027 STEP 2„POKE C%, MemColour%„NEXT C%„CASE "", "", CHR$(0) + "", "Q", "q", "X", "x"„COLOR 7, 0„Regs.ax = &HB00„Regs.bx = 0„CALL INTERRUPT(&H10, Regs, Regs)„CLS„END„CASE CHR$(0) + "<"„LOCATE Lines% - 5, 40, 1„COLOR InfoColour%, 0: FPRINT "Segment:Offset = ", No„LastKey$ = ""„Seg$ = GETHEX$(4)„IF Seg$ = "" THEN GOTO NoMatter„LOCATE Lines% - 5, 62„FPRINT ": ", No„Off$ = GETHEX$(4)„IF Off$ = "" THEN Off$ = "0000"„StartLoc& = VAL("&H" + Off$)„IF StartLoc& < 0 THEN StartLoc& = StartLoc& + 65536„IF StartLoc& > Max& THEN StartLoc& = Max&„StartSeg& = VAL("&H" + Seg$)„IF StartSeg& < 0 THEN StartSeg& = StartSeg& + 65536„NoMatter:„LOCATE Lines% - 5, 40, 0„2 FPRINT SPACE$(29), No„CASE CHR$(0) + ";": GOSUB ByteEditor: GOTO Main„CASE CHR$(0) + "?"„TryAgain:„FOR R% = (Lines% - 5) TO (Lines% - 3)„LOCATE R%, 30, 0„FPRINT SPACE$(40), No„NEXT R%„LOCATE Lines% - 5, 30, 1„FPRINT "Save memory dump as:", No„F$ = GETINPUT$(12)„IF F$ = "" THEN GOTO Finished„FE% = FileExist(F$)„IF FE% = yes THEN„FOR R% = Lines% - 5 TO Lines% - 3„LOCATE R%, 30, 0„FPRINT SPACE$(40), No„NEXT R%„BEEP„LOCATE Lines% - 5, 30: PRINT "File Exists!"„LOCATE Lines% - 4, 30: PRINT "Hit any key..."„DO: A$ = INKEY$: LOOP UNTIL LEN(A$)„GOTO TryAgain„END IF„ON ERROR GOTO InvalidFilename„OPEN F$ FOR BINARY AS 1„ON ERROR GOTO EH„CLOSE 1„IF Invalid% = yes THEN Invalid% = No: GOTO TryAgain„LOCATE Lines% - 4, 30: FPRINT "Offset ____h to ____h", No„LastKey$ = ""„LOCATE Lines% - 4, 37: FO$ = GETHEX$(4)„LOCATE Lines% - 4, 46: SO$ = GETHEX$(4)„DEF SEG = StartSeg&„LOCATE Lines% - 3, 29„TSAVE F$, VAL("&H" + FO$), VAL("&H" + SO$)„Finished:„COLOR MemColour%, 0„FOR R% = Lines% - 5 TO Lines% - 3„LOCATE R%, 30, 0„FPRINT SPACE$(40), No„NEXT R%„CASE CHR$(0) + ">"„LOCATE Lines% - 5, 30, 1„FPRINT "Load File:", No„F$ = GETINPUT$(12)„LOCATE , , 0„IF FileExist(F$) = No THEN„BEEP„LOCATE Lines% - 5, 30„FPRINT "File Not Found!", No„LOCATE Lines% - 4, 30„FPRINT "Hit Any Key...", No„DO: A$ = INKEY$: LOOP UNTIL LEN(A$)„GOTO FinishedLoad„END IF„LOCATE Lines% - 4, 30„FPRINT "Offset:____h", No„LOCATE Lines% - 4, 37, 1„LastKey$ = ""„O$ = GETHEX$(4)„DEF SEG = StartSeg&„LOCATE Lines% - 3, 30, 0„TLOAD F$, VAL("&H" + O$)„FinishedLoad:„FOR L% = Lines% - 5 TO Lines% - 3„LOCATE L%, 30, 0„FPRINT SPACE$(20), No„NEXT L%„CASE "[", "<", ",": StartSeg& = StartSeg& - 1„IF StartSeg& < 0 THEN StartSeg& = 0„CASE "]", ".", ">": StartSeg& = StartSeg& + 1„IF StartSeg& > 65535 THEN StartSeg& = 65535„END SELECT„EndSelect:„LOCATE , , 0„Update% = yes„RETURN„ByteEditor:„COLOR 0, MemColour%„FOR I% = Lines% - 2 TO Lines%„LOCATE I%, 1„FPRINT SPACE$(80), No„NEXT I%„LOCATE Lines% - 2, 1„FPRINT "F1 = Enter Hex Value   F2 = Enter Decimal Value   F3 = Quit   F4 = Save and Quit", No„LOCATE Lines% - 1, 1„LOCATE Lines%, 1„FPRINT "        Use Pgup, Pgdn, Home, End, and arrow keys to move within window", No„COLOR InfoColour%, 0„U2% = yes: Typed% = No: SaveIt% = No„LOCATE , , 1„CurCol% = CurEdit%„FOR I% = 0 TO ((Lines% / 25) * 1439)„DEF SEG = StartSeg&„Mods%(I%) = PEEK(StartLoc& + I%)„DEF SEG = &HB800„POKE I% * 2, Mods%(I%)„NEXT I%„DO„K$ = INKEY$„NewVal:„IF LEN(K$) THEN U2% = yes„SELECT CASE K$„CASE CHR$(0) + "M", "6": CurCol% = CurCol% + 2„IF CurCol% > 2879 THEN CurCol% = CurCol% - 2„CASE CHR$(0) + "K", "4": CurCol% = CurCol% - 2„IF CurCol% < 0 THEN CurCol% = CurCol% + 2„CASE CHR$(0) + "H", "8": CurCol% = CurCol% - 160„IF CurCol% < 0 THEN CurCol% = CurCol% + 160„CASE CHR$(0) + "P", "2": CurCol% = CurCol% + 160„IF CurCol% > 2879 THEN CurCol% = CurCol% - 160„CASE CHR$(0) + "G": CurCol% = 0„CASE CHR$(0) + "O": CurCol% = (Lines% / 25) * 2878„CASE CHR$(0) + "I": CurCol% = CurCol% - ((Y% - 1) * 160)„CASE CHR$(0) + "Q": CurCol% = CurCol% + ((17 * 160) - ((Y% - 1) * 160))„CASE CHR$(0) + ";"„LOCATE Lines% - 5, 20, 1„FPRINT "Hex:", No„LastKey$ = ""„H$ = GETHEX$(2)„K$ = CHR$(VAL("&H" + H$))„LOCATE Lines% - 5, 20, 0: PRINT "       ";„GOTO NewVal„CASE CHR$(0) + "<"„ReEnter:„LOCATE Lines% - 5, 20, 0„PRINT SPACE$(30);„LOCATE Lines% - 5, 20, 1„FPRINT "Dec:", No„LastKey$ = ""„H$ = GETDEC$(3)„IF VAL(H$) > 255 THEN GOTO ReEnter„K$ = CHR$(VAL(H$))„LOCATE Lines% - 5, 20, 0: PRINT "       ";„GOTO NewVal„CASE ""„CASE CHR$(0) + "=": SaveIt% = No: EXIT DO„CASE CHR$(0) + ">": SaveIt% = yes: EXIT DO„CASE ELSE„Typed% = yes„Mods%(INT(CurCol% / 2)) = ASC(K$)„CurCol% = CurCol% + 2„IF CurCol% > ((Lines% / 25) * 2878) THEN CurCol% = ((Lines% / 25) * 2878)„END SELECT„IF U2% = yes THEN„Y% = INT(CurCol% / 160) + 1„X% = (INT(CurCol% / 2) + 1) - (80 * (INT(CurCol% / 160)))„MemPos& = INT(CurCol% / 2) + StartLoc&„DEF SEG = StartSeg&„CurByte% = Mods%(INT(CurCol% / 2))„FOR C% = Lines% - 5 TO Lines% - 3„LOCATE C%, 1: PRINT SPACE$(80);„NEXT C%„LOCATE Lines% - 5, 1: PRINT "Segment: "; HEX$(StartSeg&) + "h"„LOCATE Lines% - 4, 1: PRINT "Offset: "; HEX$(MemPos&) + "h"„LOCATE Lines% - 3, 1: PRINT "Char:"; HEX$(CurByte%) + "h (" + LTRIM$(STR$(CurByte%)) + "d)"„DEF SEG = &HB800„LOCATE Y%, X%, 1: POKE CurCol%, CurByte%„IF Typed% = yes THEN POKE CurCol% - 2, Mods%(INT((CurCol% - 2) / 2)): Typed% = No„U2% = No„END IF„LOOP„IF SaveIt% = yes THEN„DEF SEG = StartSeg&„FOR I% = 0 TO (Lines% / 25) * 1439„POKE StartLoc& + I%, Mods%(I%)„NEXT I%„END IF„LOCATE , , 0„RETURN„EH:„CLS„COLOR 7, 0„PRINT "FATAL ERROR; PROGRAM HALTED."„PRINT "Error#"; ERR„END„InvalidFilename:„Invalid% = yes„RESUME NEXT„„SUB Box (topRow%, topCol%, lowRow%, lowCol%, Frg%, Bkg%)„COLOR Bkg%, Bkg%„IF Bkg% >= 8 THEN Bkg% = Bkg% - 8„FOR I% = topRow% TO lowRow%„LOCATE I% + 1, topCol% + 2„PRINT STRING$(lowCol% - topCol% + 1, 176)„NEXT I%„COLOR Bkg%, Frg%„FOR I% = topRow% TO lowRow%„LOCATE I%, topCol%„PRINT STRING$(lowCol% - topCol% + 1, 219)„NEXT I%„COLOR Frg%, Bkg%„LOCATE topRow%, topCol%„PRINT "⁄" + STRING$(lowCol% - topCol% - 1, 196) + "ø"„FOR I% = (topRow% + 1) TO (lowRow% - 1)„LOCATE I%, topCol%„PRINT "≥"„LOCATE I%, lowCol%„PRINT "≥"„NEXT„LOCATE lowRow%, topCol%„PRINT "¿" + STRING$(lowCol% - topCol% - 1, 196) + "Ÿ"„COLOR 7, 0„END SUB„„DEFSNG A-Z„FUNCTION FileExist% (T$)„DEFINT A-Z„DIM F AS STRING * 64„DIM Inx AS RegTypeX„DIM Outx AS RegTypeX„Inx.ax = &H2F00„CALL INTERRUPTX(&H21, Inx, Outx)„DTASeg = Outx.es„DTAAddr = Outx.bx„F$ = LTRIM$(RTRIM$(UCASE$(T$))) + CHR$(0)„Inx.ds = VARSEG(F$)„Inx.dx = VARPTR(F$)„Inx.ax = &H4E00„Inx.cx = -1„CALL INTERRUPTX(&H21, Inx, Outx)„IF Outx.flags AND 1 THEN„FileExist% = 0„ELSE„FileExist% = 1„END IF„END FUNCTION„„SUB FPRINT (NAT$, FL%)„YT = (80 - POS(0)) + 1„BS = INSTR(LEFT$(NAT$, YT), "")„IF BS < 1 THEN„PRINT LEFT$(NAT$, YT);„ELSE„BST$ = LEFT$(NAT$, YT): GOSUB PrintWithBackspaces„END IF„IF LEN(NAT$) - YT > 0 THEN„BS = INSTR(RIGHT$(NAT$, LEN(NAT$) - YT), "")„ELSE„BS = 0„END IF„IF BS < 1 THEN„IF LEN(NAT$) - YT > 0 THEN PRINT RIGHT$(NAT$, LEN(NAT$) - YT);„ELSE„BST$ = RIGHT$(NAT$, LEN(NAT$) - YT): GOSUB PrintWithBackspaces„END IF„IF FL = yes THEN PRINT„EXIT SUB„PrintWithBackspaces:„DO UNTIL INSTR(BST$, "") < 1„TBP = INSTR(BST$, "")„PRINT LEFT$(BST$, TBP - 1);„IF POS(0) > 1 THEN„LOCATE CSRLIN, POS(0) - 1: PRINT " "; : LOCATE CSRLIN, POS(0) - 1„END IF„BST$ = RIGHT$(BST$, LEN(BST$) - TBP)„LOOP„PRINT BST$;„RETURN„END SUB„„FUNCTION GETDEC$ (CHARS)„SHARED LastKey$„LOCATE , , 1„DO„IF LEN(LastKey$) THEN„A$ = LastKey$„LastKey$ = ""„ELSE„A$ = UCASE$(INKEY$)„END IF„SELECT CASE A$„CASE ""„IF Counter > 0 THEN„Counter = Counter - 1„PRINT " ";„Total$ = LEFT$(Total$, LEN(Total$) - 1)„END IF„CASE ""„CASE "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"„IF Counter < CHARS THEN„Counter = Counter + 1„PRINT A$;„Total$ = Total$ + A$„ELSE„LastKey$ = A$„EXIT DO„END IF„END SELECT„LOOP UNTIL A$ = CHR$(13)„DO UNTIL LEN(Total$) = CHARS„Total$ = "0" + Total$„LOOP„PRINT„GETDEC$ = Total$„END FUNCTION„„FUNCTION GETHEX$ (CHARS)„SHARED LastKey$„LOCATE , , 1„DO„IF LEN(LastKey$) THEN„A$ = LastKey$„LastKey$ = ""„ELSE„A$ = UCASE$(INKEY$)„END IF„SELECT CASE A$„CASE ""„IF Counter > 0 THEN„Counter = Counter - 1„PRINT " ";„Total$ = LEFT$(Total$, LEN(Total$) - 1)„END IF„CASE ""„CASE "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"„IF Counter < CHARS THEN„Counter = Counter + 1„PRINT A$;„Total$ = Total$ + A$„ELSE„LastKey$ = A$„EXIT DO„END IF„END SELECT„LOOP UNTIL A$ = CHR$(13)„IF LEN(Total$) THEN„DO UNTIL LEN(Total$) = CHARS„Total$ = "0" + Total$„LOOP„END IF„PRINT„GETHEX$ = Total$„END FUNCTION„„FUNCTION GETINPUT$ (CHARS)„LOCATE , , 1„DO„A$ = UCASE$(INKEY$)„SELECT CASE A$„CASE ""„IF Counter > 0 THEN„Counter = Counter - 1„PRINT " ";„Total$ = LEFT$(Total$, LEN(Total$) - 1)„END IF„CASE "", ";", "*", "?", "/", "\", ":", ""„CASE CHR$(13): EXIT DO„CASE ELSE„IF Counter < CHARS THEN„Counter = Counter + 1„PRINT A$;„Total$ = Total$ + A$„END IF„END SELECT„LOOP UNTIL A$ = CHR$(13)„PRINT„GETINPUT$ = Total$„END FUNCTION„„FUNCTION ProgramName$ STATIC„DIM Regs AS RegType„Regs.ax = &H5100„INTERRUPT &H21, Regs, Regs„DEF SEG = Regs.bx„EnvSeg% = PEEK(&H2C) + PEEK(&H2D) * 256„DEF SEG = EnvSeg%„DO„Byte% = PEEK(Offset%)„IF Byte% = 0 THEN„Count% = Count% + 1„IF Count% AND EXEFlag% THEN„EXIT DO„ELSEIF Count% = 2 THEN„EXEFlag% = -1„Offset% = Offset% + 2„END IF„ELSE„Count% = 0„IF EXEFlag% THEN„Temp$ = Temp$ + CHR$(Byte%)„END IF„END IF„Offset% = Offset% + 1„LOOP„DEF SEG„ProgramName$ = Temp$„Temp$ = ""„END FUNCTION„„SUB TLOAD (File$, StartPos&)„L = CSRLIN: C = POS(0)„IF StartPos& < 0 THEN StartPos& = StartPos& + 65536„IF EndPos& < 0 THEN EndPos& = EndPos& + 65536„Z% = FREEFILE„OPEN File$ FOR BINARY AS Z%„FLength& = LOF(Z%)„DO UNTIL EOF(Z%)„Data$ = INPUT$(1, Z%)„IF LEN(Data$) THEN POKE StartPos&, ASC(Data$)„LOCATE L, C, 0„PRINT INT((LOC(Z%) / FLength&) * 100); "%";„StartPos& = StartPos& + 1„LOOP„CLOSE Z%„END SUB„„SUB TSAVE (File$, StartPos&, EndPos&)„L = CSRLIN: C = POS(0)„IF StartPos& < 0 THEN StartPos& = StartPos& + 65536„IF EndPos& < 0 THEN EndPos& = EndPos& + 65536„Z% = FREEFILE„OPEN File$ FOR OUTPUT AS Z%„FOR C& = StartPos& TO EndPos& STEP 1„PRINT #Z%, CHR$(PEEK(C&));„LOCATE L, C, 0„PRINT INT((C& / EndPos&) * 100); "%";„NEXT C&„CLOSE Z%„END SUB„„Jonathan Leger                 USING EMS WITH MEMCOPY ROUTINE leger@mail.dtx.net             07-11-96 (22:56)       QB, QBasic, PDS        357  12711    EMS.BAS     DECLARE FUNCTION NumEMSHandles% ()„DECLARE FUNCTION NumEMSPages% (Handle%)„DECLARE FUNCTION GetEMS% (numpages%)„DECLARE FUNCTION EMSPages% (func%)„DECLARE FUNCTION PageFrame% ()„DECLARE FUNCTION EMSstatus% ()„DECLARE SUB ReleaseEMS (Handle%)„DECLARE SUB MapEMS (Handle%, block%)„„DECLARE SUB MemCopy (fromseg%, fromoff%, toseg%, tooff%, bytes%)„„SCREEN 0: WIDTH 80, 25„CLS„„'**** Show some EMS stats.„IF EMSstatus% THEN„   PRINT "EMS installed."„  „   '*** Open up a 12 page block of EMS memory and store the„   '*** handle info for later use.„   EmsHandle1% = GetEMS%(12)„„   '*** Store the PageFrame% segment so we can write to it later.„   EMSsegment1% = PageFrame%„„   PRINT "Number of EMS handles in use:"; NumEMSHandles%„   PRINT "Total EMS pages:"; EMSPages%(0)„   PRINT "Available EMS pages:"; EMSPages%(1)„   PRINT "Free EMS memory (in bytes):"; EMSPages%(1) * 16000#„   PRINT "Page segment is at: "; HEX$(EMSsegment1%)„   PRINT„   PRINT "<press a key>"„ELSE„   PRINT "EMS not installed.  Aborting."„   PRINT„   PRINT "<press a key>"„   END„END IF„„WHILE INKEY$ = "": WEND„„SCREEN 13„„'*** Draw some stuff on the screen.„FOR x = 1 TO 100„   CIRCLE (159, 99), x, x„NEXT x„„EMSsegment2% = &HD000„„MapEMS EmsHandle1%, 0„MemCopy &HA000, 0, EMSsegment2%, 0, &HFA00„„LOCATE 1, 1: PRINT "This image has been copied into EMS."„LOCATE 2, 1: PRINT "<press a key>"„WHILE INKEY$ = "": WEND„„CLS„FOR x = 1 TO 100„   LINE (x, x)-(319 - x, 199 - x), x, B„NEXT x„MapEMS EmsHandle1%, 4„MemCopy &HA000, 0, EMSsegment2%, 0, &HFA00„„LOCATE 1, 1: PRINT "This image has also been copied into EMS."„LOCATE 2, 1: PRINT "<press a key>"„WHILE INKEY$ = "": WEND„„CLS„FOR x = 1 TO 100„   LINE (x, x)-(319 - x, 199 - x), x„NEXT x„MapEMS EmsHandle1%, 8„MemCopy &HA000, 0, EMSsegment2%, 0, &HFA00„„LOCATE 1, 1: PRINT "This, too, has been copied into EMS."„LOCATE 2, 1: PRINT "<press a key>"„WHILE INKEY$ = "": WEND„„CLS„„'*** Show the first image we saved.„MapEMS EmsHandle1%, 0„MemCopy EMSsegment2%, 0, &HA000, 0, &HFA00„„WHILE INKEY$ = "": WEND„„'*** Show the second image we saved.„MapEMS EmsHandle1%, 4„MemCopy EMSsegment2%, 0, &HA000, 0, &HFA00„„WHILE INKEY$ = "": WEND„„'*** Show the last image we saved.„MapEMS EmsHandle1%, 8„MemCopy EMSsegment2%, 0, &HA000, 0, &HFA00„„'*** Release the memory we were using for the demo.„ReleaseEMS EmsHandle1%„„WHILE INKEY$ = "": WEND„SCREEN 0: WIDTH 80„„'************* EMSPages%() ****************„'*** When func% is 0, returns the total ***„'*** number of 16k pages, when func% is ***„'*** 1, returns the number of available ***„'*** 16k pages.                         ***„'******************************************„FUNCTION EMSPages% (func%)„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(180)„asm$ = asm$ + CHR$(66) + CHR$(205) + CHR$(103) + CHR$(139) + CHR$(126)„asm$ = asm$ + CHR$(6) + CHR$(137) + CHR$(29) + CHR$(139) + CHR$(126)„asm$ = asm$ + CHR$(8) + CHR$(137) + CHR$(21) + CHR$(93) + CHR$(203)„„TotalPages% = 0: AvailablePages% = 0„„DEF SEG = VARSEG(asm$)„   CALL Absolute(TotalPages%, AvailablePages%, SADD(asm$))„DEF SEG„„IF func% = 0 THEN„   EMSPages% = TotalPages%„ELSE„   EMSPages% = AvailablePages%„END IF„„END FUNCTION„„'**************** EMSstatus%() ******************„'*** Returns whether EMS is available.  -1 is ***„'*** returned if it is available, 0 otherwise ***„'************************************************„FUNCTION EMSstatus%„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(180)„asm$ = asm$ + CHR$(64) + CHR$(205) + CHR$(103) + CHR$(176) + CHR$(0)„asm$ = asm$ + CHR$(139) + CHR$(94) + CHR$(6) + CHR$(137) + CHR$(7)„asm$ = asm$ + CHR$(93) + CHR$(203)„„EMS% = -1„DEF SEG = VARSEG(asm$)„   CALL Absolute(EMS%, SADD(asm$))„DEF SEG„„IF EMS% = 0 THEN„   EMSstatus = -1         'EMS installed, set to BASIC's TRUE value.„ELSE„   EMSstatus = 0          'EMS not installed, set to FALSE.„END IF„„END FUNCTION„„'********************** GetEMS%() ********************„'*** Function returns the handle value for a block ***„'*** of EMS memory that consists of numpages% 16k  ***„'*** pages.  You _must_ keep the handle value for  ***„'*** later calls that require the handle.  Example:***„'***                                               ***„'*** EmsHandle% = GetEMS%(5)                       ***„'***                                               ***„'*** EmsHandle% holds the handle info for a block  ***„'*** of memory 5 16k pages in size, or 80k.        ***„'*****************************************************„FUNCTION GetEMS% (numpages%)„„'pageoffset% = EMSPages%(0) - EMSPages%(1)„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(139)„asm$ = asm$ + CHR$(94) + CHR$(8) + CHR$(180) + CHR$(67) + CHR$(205)„asm$ = asm$ + CHR$(103) + CHR$(139) + CHR$(94) + CHR$(6) + CHR$(137)„asm$ = asm$ + CHR$(23) + CHR$(93) + CHR$(203)„„Handle% = 0„DEF SEG = VARSEG(asm$)„   CALL Absolute(BYVAL numpages%, Handle%, SADD(asm$))„DEF SEG„„'asm$ = ""„'asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(139)„'asm$ = asm$ + CHR$(86) + CHR$(8) + CHR$(139) + CHR$(126) + CHR$(6)„'asm$ = asm$ + CHR$(139) + CHR$(118) + CHR$(10) + CHR$(177) + CHR$(0)„'asm$ = asm$ + CHR$(48) + CHR$(237) + CHR$(180) + CHR$(68) + CHR$(136)„'asm$ = asm$ + CHR$(200) + CHR$(137) + CHR$(243) + CHR$(205) + CHR$(103)„'asm$ = asm$ + CHR$(70) + CHR$(65) + CHR$(57) + CHR$(254) + CHR$(117)„'asm$ = asm$ + CHR$(242) + CHR$(93) + CHR$(203)„'„'DEF SEG = VARSEG(asm$)„'   CALL Absolute(BYVAL pageoffset%, BYVAL Handle%, BYVAL numpages%, SADD(asm$))„'DEF SEG„„GetEMS% = Handle%„„END FUNCTION„„'***************** MapEMS () ***********************************„'*** Sets the page of a memory block (identified by Handle%) ***„'*** that is located at the beginning of the page frame.     ***„'*** Example:                                                ***„'***                                                         ***„'*** EmsHandle% = GetEMS%(8)                                 ***„'*** MapEMS EmsHandle%, 4                                    ***„'***                                                         ***„'*** When the page frame segment is next written to, the info***„'*** will be placed starting at the 4th page in the block of ***„'*** memory represented by EmsHandle%.  This could be use,   ***„'*** for instance, to store multiple SCREEN 13 images in one ***„'*** EMS block, by moving the first 64k image into the first ***„'*** 4 16k pages (16000 * 4 = 64000) by using:               ***„'***                                                         ***„'*** MapEMS EmsHandle%, 0                                    ***„'***                                                         ***„'*** And then putting the next 64k image into the next 4 EMS ***„'*** pages by using:                                         ***„'***                                                         ***„'*** MapEMS EmsHandle%, 4                                    ***„'***                                                         ***„'*** ... and then moving the image into the memory block.    ***„'***************************************************************„SUB MapEMS (Handle%, pageoffset%)„„numpages% = 4„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(139)„asm$ = asm$ + CHR$(86) + CHR$(8) + CHR$(139) + CHR$(126) + CHR$(6)„asm$ = asm$ + CHR$(139) + CHR$(118) + CHR$(10) + CHR$(177) + CHR$(0)„asm$ = asm$ + CHR$(48) + CHR$(237) + CHR$(180) + CHR$(68) + CHR$(136)„asm$ = asm$ + CHR$(200) + CHR$(137) + CHR$(243) + CHR$(205) + CHR$(103)„asm$ = asm$ + CHR$(70) + CHR$(65) + CHR$(57) + CHR$(249) + CHR$(117)„asm$ = asm$ + CHR$(242) + CHR$(93) + CHR$(203)„„DEF SEG = VARSEG(asm$)„   CALL Absolute(BYVAL pageoffset%, BYVAL Handle%, BYVAL numpages%, SADD(asm$))„DEF SEG„„END SUB„„DEFINT A-Z„'******************************* MemCopy() ***********************„'*** Copies the number of bytes specified in 'bytes' from the  ***„'*** memory location fromseg:fromoff to the memory location    ***„'*** toseg:tooff.  To copy more than 32,767 bytes (max. of     ***„'*** 65,536 bytes) put the 'bytes' value in HEX form.          ***„'*****************************************************************„SUB MemCopy (fromseg, fromoff, toseg, tooff, bytes)„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(30)„asm$ = asm$ + CHR$(139) + CHR$(70) + CHR$(10) + CHR$(142) + CHR$(192)„asm$ = asm$ + CHR$(139) + CHR$(70) + CHR$(14) + CHR$(142) + CHR$(216)„asm$ = asm$ + CHR$(139) + CHR$(118) + CHR$(8) + CHR$(139) + CHR$(126)„asm$ = asm$ + CHR$(12) + CHR$(139) + CHR$(78) + CHR$(6) + CHR$(243)„asm$ = asm$ + CHR$(164) + CHR$(31) + CHR$(93) + CHR$(203)„„DEF SEG = VARSEG(asm$)„   CALL Absolute(BYVAL fromseg, BYVAL fromoff, BYVAL toseg, BYVAL tooff, BYVAL bytes, SADD(asm$))„DEF SEG„„„END SUB„„DEFSNG A-Z„'****************************** NumEMSHandles%() *********************„'*** Returns the number of EMS handles presently being used (there ***„'*** are a maximum of 256 handles possible at any given time).     ***„'*********************************************************************„FUNCTION NumEMSHandles%„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(180)„asm$ = asm$ + CHR$(75) + CHR$(205) + CHR$(103) + CHR$(139) + CHR$(126)„asm$ = asm$ + CHR$(6) + CHR$(137) + CHR$(29) + CHR$(93) + CHR$(203)„„NumHandles% = 0„DEF SEG = VARSEG(asm$)„   CALL Absolute(NumHandles%, SADD(asm$))„DEF SEG„„NumEMSHandles% = NumHandles%„„END FUNCTION„„'***************************** NumEMSPages%() *************************„'*** Returns the number of 16k pages being used by the memory block ***„'*** that is represented by Handle%.                                ***„'**********************************************************************„FUNCTION NumEMSPages% (Handle%)„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(139)„asm$ = asm$ + CHR$(86) + CHR$(6) + CHR$(180) + CHR$(76) + CHR$(205)„asm$ = asm$ + CHR$(103) + CHR$(139) + CHR$(126) + CHR$(8) + CHR$(137)„asm$ = asm$ + CHR$(29) + CHR$(93) + CHR$(203)„„DEF SEG = VARSEG(asm$)„   CALL Absolute(numpages%, Handle%, SADD(asm$))„DEF SEG„„NumEMSPages% = numpages%„„END FUNCTION„„'******************************* PageFrame% ***************************„'*** Returns the segment that you will need to write to in order to ***„'*** store your data into EMS memory.  For example, PageFrame% may  ***„'*** return D000 (HEX, -12288 decimal), and then you might do this: ***„'***                                                                ***„'*** DEF SEG = PageFrame%        'D000                              ***„'*** MyData$ = "This is a block of data I want to store in EMS."    ***„'*** FOR X = 1 TO LEN(MyData$)                                      ***„'***   POKE X, ASC(MID$(MyData$, X, 1))                             ***„'*** NEXT X                                                         ***„'*** DEF SEG                                                        ***„'***                                                                ***„'*** Note, though, that you have to have a block of EMS opened with ***„'*** GetEMS%() and maped with MapEMS before you can write to the    ***„'*** block.                                                         ***„'**********************************************************************„FUNCTION PageFrame%„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(180)„asm$ = asm$ + CHR$(65) + CHR$(205) + CHR$(103) + CHR$(139) + CHR$(126)„asm$ = asm$ + CHR$(6) + CHR$(137) + CHR$(29) + CHR$(93) + CHR$(203)„„PageFrameAddr% = 0„DEF SEG = VARSEG(asm$)„   CALL Absolute(PageFrameAddr%, SADD(asm$))„DEF SEG„„PageFrame% = PageFrameAddr%„„END FUNCTION„„'****************************** ReleaseEMS() **************************„'*** Releases the EMS memory associated with Handle%.  This is very ***„'*** important to do before you exit your program, otherwise the    ***„'*** memory being used by your open handles will not be available   ***„'*** again until you reboot.                                        ***„'**********************************************************************„SUB ReleaseEMS (Handle%)„„asm$ = ""„asm$ = asm$ + CHR$(85) + CHR$(137) + CHR$(229) + CHR$(180)„asm$ = asm$ + CHR$(69) + CHR$(139) + CHR$(86) + CHR$(6) + CHR$(205)„asm$ = asm$ + CHR$(103) + CHR$(93) + CHR$(203)„„DEF SEG = VARSEG(asm$)„   CALL Absolute(BYVAL Handle%, SADD(asm$))„DEF SEG„„END SUB„Bob Perkins                    DIFFERENCE BETWEEN SADD/VARPTR FidoNet QUIK_BAS Echo          07-09-96 (21:36)       QB, QBasic, PDS        50   1973     ADDRESS.BAS ' >        Does anyone know if there is a difference between „' > SADD and VARPTR?  If„„'  They are both provided to find the offset (address) of a variable.  VARSEG„'is used to get the segment.  Though they may appear similar in function, they„'do have differences.  SADD is not to be used with TYPEs or fixed-length„'strings.  VARPTR is used with those.  VARPTR can be used with simple string„'variables, but it does not return the offset of the string but rather the„'offset of the string descriptor.  From that you can determine the address and„'length of the string.  Note: Be careful playing around with poking directly„'into strings in memory.  You could find yourself facing a "String Space„'Corrupt" error message if you inadvertantly change the length.  Following is„'some rambling code examples to show how to use VARPTR, VARSEG, and SADD.  Hope„'it helps you to understand better.„„ CLS„ s$ = "test"„ segment% = VARSEG(s$)„ PRINT "Segment of s$ returned by VARSEG="; segment%„ PRINT„ '„ offset% = SADD(s$)„ PRINT "Offset of s$ as returned by SADD="; offset%„ DEF SEG = segment%„ PRINT "Contents of s$ = ";„ FOR x% = 0 TO LEN(s$) - 1„ PRINT CHR$(PEEK(offset% + x%));„ NEXT x%„ PRINT : PRINT„ '„ descroffset% = VARPTR(s$)„ strlength% = PEEK(descroffset%) + PEEK(descroffset% + 1) * 256„ stroffset% = PEEK(descroffset% + 2) + PEEK(descroffset% + 3) * 256„ PRINT "Offset of s$'s string descriptor returned by VARPTR="; descroffset%„ PRINT "Offset of s$ from string descriptor="; stroffset%„ PRINT "Length of s$ from string descriptor="; strlength%„ '„ PRINT„ DIM fixed AS STRING * 10„ fixed = "0123456789"„ offset% = VARPTR(fixed)„ segment% = VARSEG(fixed)„ PRINT "Offset of fixed length variable from VARSEG="; segment%„ PRINT "Offset of fixed length variable from VARPTR="; offset%„ PRINT "Contents of fixed length string=";„ DEF SEG = segment%„ FOR x% = 0 TO 9„   PRINT CHR$(PEEK(offset% + x%));„ NEXT x%„ PRINT„Erika Schulze                  PB XMS ROUTINES                100775.2275@CompuServe.com     08-24-96 (12:03)       PB                     249  16316    XMS.BAS     ' Load/run under PowerBASIC to extract XMS.ZIP„„DEFINT A-Z:SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"XMS.ZIP",4^6:Z&=11938:?STRING$(50,177);„U"%up()%9%%%R-%&Yd=Fmf3gFj'.%%f)%%%/%%%%wj%firj%SVxyIzx,>BSe5Ku0]„U"x)Rd%USVc_]x(57jz:'yLKZcTR-T<Zol\BDFb?(hU>pm:BKMHFEFk5oK8h2y4<u„U"m1C,G.D2dA)^Fd06nbYs^Hat/1_.RZ+lumoi1BfDs\:8jWC1N$v2q>_;0IPFy*R„U"\WekMYhC\aQqm9(CO5,8A$JfSh/=tt&mJzRq8Y4vdrooFe]T.9SaY+U;<5tB]<_„U"vrO?<tWik'D<Jf)Fz6sNJakp)+H7f7(Dj\jp,>I:UbW8hrl1V>^:08HpO<Uhr6b„U"1/wz8n9XtjaTCPb=3-(Hk57'&44&UUMsT;64i-sX)I:i#R13oRt5fo;0Y):hKoj„U"%+j6ftT^v3oO#.z.Re/J<Rs-R+*L\sCiboK-^1Ir%#Gq&<V'h&V_f9,Mf1?(QEZ„U"k+>hqz[;a&%][wCY87e89=G(K[R6PNUu00sVUi)EM<<=<BNCe#N5X]hQErTrAD7„U"GVRU/B9RfXfOT1:_XySJ-_jv=hKQY>'kJ%+G[<(O1#9EeQ.?%DBIKkIS#Cj&.kY„U"0WWfabjWHuvS?]d^o.Hf.Bv)U([r<5yYiA/\EIt'WFP=4QFjQoSN-M^rkDNw0Cs„U"4xtuFG*;:dfJy0rJ6<&fm6Ka$/fNXoGCiT;ZFi,f=+/opmjIUMkr6o_m#5$Qc00„U"1Cd)I8X:*uZG?o-0?8G.;sO8f\CIUuw71app7e*qSYSA<_1Cf?hVtdnP^rVde-r„U"9i2b0003PSme:>r0;\8[=\STY?d14.*;n6,w6.\a,?P]G*Jh$>Go#_0DUq2VZ9R„U")<IYS<[kc.CiDl>w;?iUS'l#_d^$jq?5RJ7WLsbtQ:LYVVVkTiv0)$7UUTkZg(K„U"N&u%p()9%%%%-4%&Y=jF)vn-()&%(%^*%%%,%%(%'rx%SnshK&y<>]SU5wm17xZ„U"+y&WmGrSDw8y'R;X:;=ZAoDBAp9^='fG3:oidJEQF)ejdPitC]XDXlkXD$=<PBJ„U"8Z3n3M8ILhGNNq9\9Hd-d[u\]ZC+pu[=5..)R8$P6,90hAzCoaO^m?j<jfvQQrA„U"A%PxbkKtVLC2N?2=0:-=Ie*_#,kiUeEw62&V4C<#v4i'\r2)ad&uo.9k.fJcHm>„U"nUp048_D_^=9BGs7NFIlENDZcHS=[K#gFxPNshCdvMHP0=FQs/-:N0xRS6K_OXl„U"?NC=[sqlF_slMPpHqzYJ]6aC>d3zq\H'9[_O\'mIafq'lW>S$[8'd3;5s3XmP%*„U"^M<Bd&es>2ejBmc7bb+J*=?Eh\VyMFkkw*au,9;MLcYMBQ:Nc5=WFVDIINhIk.v„U"*iPk8KN?\Dg\Z&&L5o$0rV?IVfLTh-XwinfwD[Gj',>T(jI>iUEDf$Z%b5Ovzat„U"0D-xfX/%vu=d9=r_Bg0GN8V>Qx<oAce1Xe&629FL,K#w4XE][Ml/$Wr2]sd;nt_„U"3&%[_-Lic[]GaX$z[?Dw(%up()%9%%%R-%&YR=F%R.Ld^,.%%y6%%%,%.%%'r%x„U"SugOq&f<.qy&?*#n$X+1(/>^+y6AqpYN-Y]-)zPX30c<ZtDUdQ1oJSy<_QU86g_„U"hJ6w%1FZ*rSoxD'W&=diumK3h<V=VY.FF<nVY80,4cgvrHv+[(-\3VNW?EL5To^„U"$htpp[via$Bxl$unXu2p2$9>0\dJ6s(A7%]ve84-d$)]+,om3+tuJLf.7uxl>Q>„U";ffAF-m;UnI'VQ7P_I:fc0/<%:12)s/*JOm#-93Le>>wu0<XVuSNRVA-53T*v,j„U"=41sn4EnYk6VFwP\1yFN5kuCo]gy+fno14dIjY<vO8SxSuPQrD,8X4>9,\*&jEL„U"r.dOZtmL,2S(RkFgNaf&\\dhkEqR&D>8dW:j?tWDtY9rnVv[Q+r&T'Iv23bvmbp„U"14S)(o[wHv2\azebIioL5i=PWYVNM0:ZFAL,nFy%1]Mg>HEvg5:b)rNTS0iDeuA„U"\N*2Y&q85oJ6\b[0im+2AF]W3%Hf-0)_es0>NEkT>k8V(D$]psJVnhqL[9Vrl:?„U"Qv1'259..^]i;,6.L*&9_%_J=]o>E4+_pM&*$x2cQftxqVk[mJO$**$3gQCh35y„U"6V?FvC=B9#%hDR>ke4cew<cTHBH9ZYUi$pSLDxYq542#>^T)%i$R<kK<#jHXT9b„U"[pc_O.aBN,j8FGtTO5?SVb[0HqJvTSZL-qQ'RApqJRVj_WD^E3=3fa-1q96dx,-„U"^lH;dh0?o'0iHKOOt5CzALGl^qLAsP+h)yB_ee[4XJ$K%l0])SYX6V=uB*]#7kD„U"Ohh=x/b:--wS%4mpO7_?OXoUbDVC>CTp8B*dh-%x0p#\pU?JBB-emb(KGDf#.aU„U"7;?6rw;6rsyepprrIopH(RXT>RwGUD>kAb\O^>w4Eh_A>14:4et,];&jS%.rq(\„U".g;9OpdJ6n;bI&=Y>L%_WbUn^$nLtwXZjC\dM%1)c&Ur&r:p7n1(x4HNSD]B^EH„U"WA\1N$I?6K)pLtuA3;79Z;KI7N\\)8Xvr,]PtwMK2*M_kim+D7KQuB=:Zx1iK&-„U"/wAWi<nbej)(66Jnx1lI[2/zrjz_N'&$Na0&e=CsS8=ucnQtqRDwqOi(A26RC_]„U",+5/7*9ZWM(9EC?'L7>t8:&Hmmx=lIHGI.j&n7oW^y#ytWKdqyC\0+O^O%6[YFJ„U"-C.9%a?vYGnPPU5%lpv,lBVr&$H8Qky+c']q_N3-&nE4K?9,6TB8+Yp<Tf=pFGi„U"R[c[K\QuYz9Uchqy?UVq1QB*'1P'_b_?o_W8&6E;zC:uLr'*=sYMNpW>Y];nM$g„U"lo[Wu23#:JmIKXM,uLd;-;_Joa]ZdLK3f#5qXQ..X(xgq2>JHQksD)+]jHs^C$&„U"tq.f<I*D%ALSN9c1].R:gm[[aaoK1-R5uPyiY*x+fQE^Wc_)2n-a6s8c^bwMHJ]„U".BB]Oj9bQ14iQoqE9sc?qOkWB27ipWxcP$.7AP1F-*Vu/^Mhk_b26&:j=K3rpYS„U"KMhN_jJKr0[Wkmnxnj9;$'[j/3oz*XxO>rhCmKT*B2FZO[:3uE##:?c#o,p>Z^E„U"TDk><#CtCLGWexUY*&U4vi1]^LedvMO2giY4LNiH1.Yf<+iPL^nrYr.[uBxX*_9„U"LH%:X5d$Y0vK;eP]%(eiRf)P5F%$K)W5z^q'<EV%T)-LX*-0/,Y*#VSDB;9N-dR„U"Q,>S4bg&R;eiX*TtSn/ReIk'hGg&k0e,\*Fl;s\RoSR%Xti&6;WslR9s6OhFq%z„U")wG//_Sonl,NFJ%dhf&C06t:/;;<sZR_sM%pFfO60VP'.i/BCwS5ZGGGmW&k3+u„U"wK\u)hl_\_DE/erCEd$(uQXBQRNoSQTe#d7:x4=EGZ#>>.vqgSZdt'sC,/Ut.L$„U"XTcD^Na#9/F9[(wxcu5piM2O\ThkIi8Kq[a,dIT_aaI$m'ba5pk+.Bdm3gaKt#w„U"N.8+ERh7%I>Kn_$sn'k$ud]+KBdn*g$]BCgymmaKRlKLlq_k[K^tk+[B,I2._Kn„U"BkZnPFxAKa%BI,mBsnsa1qa+I92s+e9+qkTAa,It7SF.I#rI&aK<I#a/fu?zM-B„U"4040q/4'u)9mr;nj0TC:A5$h+f_Z8R*p9HoicJZb'm_,+_cQWsAHH\6bnVdnN,c„U"R3xGkT\dR03U>;PWgst*Dz=xEQG$*I<P-?4f/=hYX*[(Hf&92W,sukR,;''l?W(„U"$sW7*^q='2(kk?F/iUv%gChv&d,EURPZp3L?$RA4&5+U89iRA-(AT0]\pW*'LHC„U"N_\^/*s/AA4AUEPep*i24V*i:ej,,APBkS\R0/'^KB+*,ndPcPhU/HQHpd>TTZU„U"6/RA2Y%'90pa2D.,'2TJ5rJe$G;^c_h[5*g*-d$Tj>4<2Dz%s$t[6/UMJ%=nY3-„U"QA<D%'ogW)<2<T%gCm=B/U<0%gKU=,/+k8.T4.+k^RZ0VCtT9-TA64%+5q[R/U7„U"FPP%$?$l2;A'IQbkq$pV>n4O?w-sd%up()%9%%%R-%&Y.=Fnp>g(\'7%%<,%%%,„U"%.%%'r#xSy'Cytz*+tTU95M(cdr)vl/IGfcAO#d%sYe+.QAOk[\:buG.MGsEEre„U"C9(rX#KI#5=yjq.yQ$rk,eL%6nq&I7YQ3M=t%o=x)P-#^nJ3LC6?KA:vJg1eWBr„U"8F5^M\3Ojec;6sp(W[[EgRc?XkuhD5OsHVxmW[G+dW-]'svUiBZO,D4eKX7s#%U„U"c^;/Io:]/dr5m3QPim7+)4%8)8<;IP/E<NVZN-h;fUPP:/?%-1(7Aa0I_(z>q?m„U"JsZ\fZO'bb4%P1lf<6-OU'aVdng7E;Nrfb^kJAn4lg/.16d4NeBRdnU_6SqIP\h„U"U$#pDvVWOi&%F>+eA;&W[j2x;huf<eGEk=oW99A>2\ga;1>9wt?%:-KToNzb\WL„U"M7RK.x#EYqj*#1Kx1cahsPha[p,)=2_%SN-,As;j<3wl:a7uhpYm#IdZ<%k-GtK„U"H-*O&Qc>O$:yk*IX0R9($PPyL#/pHJQe+Jd3Vb?-/GP\ZQ&l/D_m7Yc?&&[A_R,„U"D7#9mQ*mN\OHD/-cRL<D).N%Rv1g>H^gC:5V,tp*f?aUDYt-GetkIR[%*p;9&qe„U"$8kB**GgLoaeer+UE][T/tA%gZ-v5XSdp\'$wGdU>dp)mFKgNo/:**IR1CRsEa2„U"H#g-YulfnD%na1DtTIifyuftibR>4PsK.;t0bjK7G2Ak%KV',WtKn.IlJFcSIuj„U"(Itr(2$>]ilrqdvdikA5^R_=Ac\U)3_y-g+\^9bfbTYG^cQU%7)8=8Nd8=W<%vY„U"M(m9sq#b2\$Rl<?*;[.TLu#T//F'4/K$=,_W9t+KH-8OvQLMoDTLgP0XppRh&V'„U".?RPznnomu^aorOFQ)VZYr7&Jtnu.6K9:baWQ.r;i-ar'z[hu>,E%yXQLl-g=#)„U"=w(5Z?RO+jLA.N:d]Tp>$A^_1^9vFV$S;5Qerl:i\DAK^s.r7<PHl,%up()%9%%„U"%R-%&Y7=F#u5[Gf,.%%?Q%%%/%.%%'r%xfxr%SfxrEN)p>'T]5c7Xew(mTj/&47„U"Q86MG4GZjaJ/Ze3vvQ[9j3+4j#9JmvEb=6b(.37No-qXN/\C18-kmQ<Z?5lqFR;„U"Yd*ppDBOBrWT8:j4M^Qr.lGqNuXWSW:gWE)FpJN2/crQYq[rmO7d$u'^Tza+0bU„U"]k(=.LaG3JB0J\I6[h_IQDM[sawGmY]uAkYuo+c6HEu^BZNPpvib3TSs']Xx;[7„U"NLf(*<B,m5Fe<0pOQQxupkDB0[WYgHwG7m[)dMlZjJ0z<L53M)LS36l?K8[q:af„U"&Ci=g(p)Tpad8g,rAAm=u/2aK5_S2fj)W54E/As$qH29hQ]BBn&$#ksR2W/4he1„U"bv\%VLg?V-AC8\UVBv#YI;8dMjXKL%krhJ^r'0H/6:SdFHkDU,p_yS+*$^c00Y$„U"PQhDNRuQ/7gqaUC(t^Tt(sfYWG_gQyOdYKi^5[lU[,/T][cQ+E?46F2]Br0;$jg„U"Wua46LeNa??Mb[P=6arDKrZ6TU_ZUG7-LA.l.5-9PdNJU-BO%0zO?xmDl]#8Ws6„U"B*g5)T*fAM:fr2Zur5NHSX#K+#YE2A#m)0(nc7r2kBzQ4UhVCkex?Y_en]YQ<A,„U"3XbT,4R$t,xUMT4oe17t0PGFl-:sTFSGgZC=h08r8-%&jafV65djIUz^h%DDYWO„U"-]%i+9cf7PLUlQa]AOoHT'ilwR65W[G08LdzI&H?a-M*#PX+EjXWGH-qSpkF2Y5„U"e^D)&;XHWB%tx::\La'(;jB1j[[vOM6hwGWHp5P'Y_k*c%xuQ:K1]Bch3)OQud-„U"%B%+K08hL)ktkRa.&hYB-E_L_+<^dun/C]6kh$R?U,IJ25MH(NXzNGJi23b+;cJ„U"pqcVfvYd-RkAXtc\/x#W>P&kfCr9SAW6k-4C49<CVsOiV3QZ_utX<aT?#GeUKM8„U"N]\6,hZ3J66\$E/(SsuL'<%/4+jj_w_J?a8(;t]cKe&5(j.M5tfH^U\(&b<qCqt„U"R%Ba0[La6':uwtHf22ZYqf-6n1(=hBiUYTC>F?(B[UGI;fXst0/6NZVVUG*_O2>„U"1_-J]X'oBK[AC(xldw/07t7CCts+jXml4;2c_h.*gsXe[8e,>WGk'amRHMG(HiB„U"f#:.s%bS$FpHVSF&Sbrjm/X_gY**[hWz>qEmI1UbZGBrwzI\-]hVt?_pMJNu$$d„U"YI075[kU,KZM):eF2';)r.)wfK]/0hSZQdp/;kn#zNzkC7V2fCes^^/G:WYiqI3„U"3O&q8r.eIS3;2xD%a/a%GYJ'Stf2y_aKtUJN2?RJ=k;vu)U]/U2&[RIg^lY[A[j„U"0zB>p$d'-qnf5iQ<5R&<N-?+_Ky(s2<E\,]PT2Q6wCr8fV&:S1?]l5H2.>CFAUH„U"HlxI>JcFd7aGMJI(2C:EK8u=#gnPiCg36a%?6u?0gB(D&TQNn#5hghs)$rcf'3[„U"V'(g4w/]dHP$BMb]>#=HP$:yJG0*xiMw1]g5%.rT?q[)ROlJ6)NQPy$*yKiy]=3„U"?ooN]Pp-$':RNj6N26XrOj&i3EBlJXXNn]P$5k)=a4(Kq'wG)FRrxR9><+#]%>T„U"CV/PI5'kzyS(d-Zd_Npv;6-k.o&q?S0cnZ1SN=4?%^5<\%)j1iu,fZ;vn1(Rfi,„U"qLs:0h,k'K5NMNO?^-L_k)AftptG.zDLZS7-P/?qB<g]<&63bK80[gNPu*Ks4=p„U"H)7akRWwXZL[77A2jmm>1k[w8$)sUKl3QC=-lkmuj*F^FN%LhFN=PV3JdXL++3Q„U"mlV<s_=O3x0.6B6<;s,1.pVpeA78c/BSArawY0B:,#eMo#SAy=N=r]A^?#4+3R&„U"0qA#0-=CyLZb.q=RF:3=xlWvI]+-1;'0c=um0WQMGgQb&S5)LAsGx]7fZ^/&9Mz„U"5&F,TY8k>EP(SM<.a&QggC465t4?aOF#TeyVPs+a8.-vW)u3oaU/oSPCskf&,s8„U"1$;iK?E\dnC=K-9M]m'.o/55?WZ%nDpg6ptavdHw9:$t=N&xW7s)rM$r>-d)\DF„U"oZ;'+G\pD>+aPcurnA6PN;Nk+F3W[=W2<o+8mw1u8z0rSnH3UkiQZCkjj%b5fcO„U"ls&,$cBDO\#[_w&%)]_vSTXHrKQjef%6+i'T9niA56S>a5Y?/D2[LU?JFIzde3a„U"rNN1oh*6Pe/(MeCTx^dt#&f+QH%tRLJds4QSQP,fFxMPf**frX2$/l9TcpM;.6B„U"5Xt^gD0C:WedjViN:+ss;8QXgVRGutrU.dHcUH>mZkf'Aa^YWzN+n;NHBd[3-Hw„U"P]y4$+Mk-^',IT<mc;3E7QNQD,?F-wXy4Vsjb]Ak)GOfUI9qPW^dD4lM$z_86o%„U"o5xP7#j_^.+AL16c'kiUi<SjqLuuR%$Wwp^.GVkT-]Eql7pjHHM]MXms'bS)ENi„U"Ez94&DSEUz:n.-OWOAr,V,X26KuJ);ANQI'G,]v/R-q.O./6*_v#F9CrmL,Az.>„U"&c(S&zouR-nx%u%p()9%%%%-4%&Y=+FimJ'%7'%(%s'%%%/%%(%'rx%fxrS#tgo„U"<5$::8n,9>H\jqLLCI\FSDO7g9/p$*I^S+yaJ_qu$dIHbbXiZ,pJP+Tu&TI*fB=„U"/S5)kQxM$NY0f\.65TkOL\S[dhu[7g5reh_G.[sg=>2uUt4$i6FURe]EC0rN(f-„U"'_m2$s(Y52NN=;5ecs6&NN'.:S6WO)N4B6BgHBHg$KPB#Z[$(>O7LNkFPS&Q_tL„U"&1QFT&JNt0WHB>yk4*_(5p[n-&oPblkmJ&l4iHl,qkk/XF+&gw2h1\ecoT7y%7/„U"gUDx7Nf7vN'ed:T3VgYF:cIA;%eD=AIVegCIm\Y_e9uo&,ToM2w.&PJS<O>BW>'„U"A3's&zXGd9L%TqiQ<des)#]=Doaz:uN8ZeU;W*GAED.u=Ljs&VUZbu;EY&k5;;N„U"?'<,rj]+4L.r/HRwU40H'Veq^pw7^kZC]G0CnQr?4pDSgq3edYqTtY,RlkJ3'Rw„U"Jl+]PGCf^4XkVvGEdl%=;E8VhYW401Pmpf^;.86+e]773=*2b)3VQC:MG?Pv8BY„U"JRB=ArAC0#lb>,JJg)3ZYB[RWml+vuboBUA?hdHHBm%x5Pa%j9ZPIBaq&tHiier„U"8R%MlXWJJDOnYhRdH*O[dPVJVnvbYK=).p8uo3N9*.xd.OD%RE_>58ebCAseWxV„U"aLC$vs'xndqeE7q>fB9dL?1>_DoLTaw%'up(%)9%%[%-%&AY=FIr7_ck%'%%y%/„U"%%/#%%%'%rxgf%xSgf4x&ev,>[]5DOn<XTxU&%pp*bgrQE0P2m=F:.g5$'Riegy„U"MJBbPM)D;3s$-utf.hw/'$)uzddE2uSL>H3R7cs#R'\VzkjdEdK\EiG2BWv8ada„U"LLc9%q[\H]/x(0/;,afXQq&bvAkR&I\?<W=n(jdku_$Ps,xC7yN.Vml0*rf%$[W„U"vU*(JNEt_g4S6E8+*W_$%<sM*\.Dc+1&0:]a,)-,AAvN]+Yp#8'g7OZ-J%Mo9\D„U"l%G\XX<7&/*mH,[-/inppEHz-OjS9Gx0w3,]0gqXgM4QxY(%>=<Eh,Zv276zD]$„U"5L6=MmTRVO?iA-?rU=]TJX[e8]mx%_dRBCL?\iW:qYxVuQ<QpuURB3bz\V(hqqR„U"&H+#v^m'n*ecIN6VziHQsMi$Y>J,9imvR;o9t\qYu5b7%lfmRV?>2Ie9l:<Au2?„U"epoL?u,5Rxbv'n-ti^fU?L=KiK&Rb3W4603xi8i;+&C2+9e'Av7+Mhs:c&*nRa5„U"?YSpgqTpAOb<RQe*\0</$,he]>$?i\hO2_X%-uiI8segl:vu%VzxMiD5'TE:x8>„U"y(&07nT/&Cppu'D3ZReX(Vcp+\ptGRv8N=ZM.A#3jFIBrHTcH29>Y=W6JSV$aYU„U"+WMM#:29'CMlu\iW+AM<i:0THr&62X6\a7XnEVp<A,F*Am=a1\$%hrOS++-=x<c„U"%y4mG<jORrYBAPSlJ%AMCg=[6Dq_N%\[b4V2)9#\&r:S;:0Ts5?wN6XKIyQb6+>„U"^0rZI(\T1]wCRA6ktnM]=Va]Um%b<gq6$q])TW7[%9420]FpKacFfZL\$L^7^XQ„U"m*9=C$<%Jb\YcCV>oC^Iy9+f^,,UjrM/a4t(/eo[ZwlmNUmj?'/&'OLL[pSG3MP„U"*b=Pc.s;0^?N;alyYzo;=5&R:O>+Sp39iG8l2(Fj)W\MnM/z;KTqYExH<eaV5X3„U"S&Ah219K?rfvk-4n8u%p()9%%%%-4%&Y=aFQYx)s(*%%%v3%%%/%%(%'rx%gfxS„U"[ugz&2f.79RlA#6QhG9qX7BV8'==KY8x.c[HN-/9<B8KK:YX:IA<iP=e=L#BuWg„U"*4#<27WdZgxQ6QS%uqS]Ow30%ZtUlxIYK/J^LaOswt+E>GY;qQ^_X$84COKGrbY„U";70nNX6EF3wkZH8(2ZMG58-pJW;X<ZTWSUEw>b7%4_:h.mh$u,/#oyP\;B\TPLQ„U"#/u1ppKe5*ejBdqp#OpdJr\J\+fj[>naPSaH<n9je\&TCCX^b9AIBa3'I[V:pCp„U"Lz^Ir1n/i[gGE$FH]dQ2<m$exBVs$k&ovRA\9%1K:b1e#'1cdLfW8;=)w-rW>qQ„U"#I&nV,tDuoJuAk)$PSnqF9QrvABCP->V[+9[CK3jI1#jm[ZoaIEm*u-6JhGI0fW„U"=10Si%CtO+76CPTrf6qGy%/b(eDD/E#Z_n51#%=KKCOA\R68R?.q6[bX)ch3Yet„U"9rQ)Lb1g2iQA?G(LI,y^#),;/qrKDF,t1VTvFqHNOtzrU#>:(,RF4#_yv#Y1LZ&„U"0Y6A)<L\<Sb&?YvA^Lj&T8A-o(?D/Ri\V(Wn9,u'rbTee9E_nb=MU3+>U1m%Cel„U"aWFhp7[+->\8W000Jq&bbU[maGm6(*LP_nkv</3EqtLta)/6Y;:LsXm<4)uYbn+„U"]Y32r.I5T;159).g#d2iX2k]48EN%L$(D5%9Cs[1s,t=CD8wyF<*L9STHk$c89]„U"U?</$NT;QbeV#aP=jQ,Pup==XCK;3s1ZW;^%C%#opo/t7Nyf5L?wXLf_kkOX?AG„U"EpX69ZwgQfc1ziGLK#P6Zf]bSU2e69QO)BZTX.dgT68Z9m2YRrdE<Sky[YF_eFg„U"2XKe$bZZi4UMl+5_YG[=G$UI;>TgzC.2KU5OjpxEE)qVABO7J2]]W76[2.zFj49„U"\7o%i0]_(SqjA06LqJFA6Tq%)lLi=y>J,pGy_aJ260];wWc]._Pq+P]GX7I2lnW„U"hwXrlpG9_adx6<]BaX6<6_aB6W.?mT_W)^s7wifA/LJqs,]7;v%4l<iuM#J0mG?„U"YaMaWEB_CH;&%l8w$M#KA9\9WcjXv>ZvBr$Z#231A'qx)\[]/B$/Eh7tDN0EEC3„U"8yphWfTRqu?/RLn9X;$LWC[.<1#w#Dx]cE2*S)wMTvAjZ2fWklli,ve1^JDn;rn„U"coeeFuF*w?J<6:aJ;SeH4u&NZ9%#E[e95.Zh(AP]28#&[lbWXEw,Qq<GQ'jwV9Q„U")J*;$UAf(AT](9jB=ZbWXFg%giHa/a5zF9/emg15WR59#EGf;+Pq:9[K=d45lqa„U"S%e%T9Q+J4%V'V38#'[a.iC1?f[4Wt.502aS%g%V;7RQ*_$P]EtQ&Ct0*'yhO_S„U"S-[k)*aa#m(TUrT;ltbEr48_B5vlG'B.bV.<'Zw-$hQ$Wx7?34bk*>sDPfMAW_-„U"p?0ZYLZ#H3uC+_R24W6>MLfgM\,e^&pgrzL^lxkCbjN2FDDP]:yqunkxhl>aVsu„U"b;,e6dtrm*Kf4SJXIlNYzr5*+pV0c?coW(RDFib'tAfmm-)*cSwnIB+0.WofMmb„U"hog^l7gbpBd6bF-&wIV64hK_S%P665e\lUM%HnHenl7MlI-a,a0[gg#c-6leFZI„U"7Zo(jio=9-XnbfaB6P?<D%I,4*hgk\sO6L+RlY3(ib,c6.R?<vYIL+fiM7zKK4R„U"JFL6<&I;^3h?Dqlo>9ZwB$hR7^K;:c6ADqLo>5ReDFU_omEEC-bq<4nmOjuWb5j„U"xZz\3$.1-<w:nD%up()%9%%%R-%&Y[=Fv?5eCZ/7%%$F%%%0%.%%'r%xijr%tSg„U"fOx>(*,F[m3hMUBqg4ikB_<iU?dK\5RA-SsV)<=,mt.o&)X0i?E;#ye5Q_P>x,K„U":sEklEsH0s*2n/nyaosJR#8-6XzOCC^]*>?[N0QXsb]KRD%)oF.5j1gk5=7Q>(<„U"=qgU8qg'DI$vbg4($xhz]LSTHQD3MH0whggsFx%d:,ctY#muOWKkTZH\zuuw7eP„U"k[4,IeIW#tKa(6*xSP&L<R=vJZipQ(aS<)5uCTOs)S%vp7Y+E72X#?mbv'2*.fE„U"6hgiI[LLw4nObcWWHEu8vT'Ir8u(Uk$aM6BI1<pa-]oCsu677JO\+W]LHw1T6Iw„U"Q6O^r=OrxZ7RtCV[Orl:B>;;TTUiJPshcG\pf4Ii\MZOV%fYU.9Dk#-e+9%]xuW„U"-O?5JT%OcwSCVN:d5+A,9/TH\QO4)tIM>q=I<_R9k\0ZTeU\arBZ#7yEU.&eC2A„U"+pk1lrL=8t%D8KHHLeEa+lgN5au%;,^N9?o4lVm.f_\BDuZ\X,C#xyAtCEOV+La„U"\l=U52fpCnZ8UaHMYAM:0AUEKc&tjG;>qQABWcd/ecjq);_[D,E;<NYj%m.GZrZ„U"MEabZx[$56g2hc<xQH,cqqpsceOA0XXE0c)*pp8X26JCf0:7jJY$'5Y1Og7'UBq„U"XpuY1[gYoE=mO>FjeG]UOWi=IhN=MW?o&J.gR:OZkV;/?K,jirOXW1dji\=Jd7$„U"dmM,F%mU/4#MVT#We.W0KePuk2DO[t=LL>5tlC%0ie9(LUePZ=R^T$726U[/U0$„U"5BCp&hi3iYM)oY+T;H'C&,%PK/SXBJ770*oUOM]l.o<L'.hl=h>VH&rPOcsBF;Y„U"v^ex*F7U4iv=k*rK\%8tSwori=b#_AeJsUf.?55lBKSf'gM_g#og\NgF),x^7s;„U"dFg_EL2v]drwv9F(Z3$TD:xnsgIbo1F_=ddaV9Pbva[E35T[uAco&=<-dmQmW.3„U"qZq*jtL^mgn[sGNffmYq*Kraq\,u\R2UHDOAm'E/Fnx59_&_5pjOdm5cMNcAfDi„U"u7..beu]h$4W>$OUwJ?jA\vZ<IiYkyBr\2Tmy(mse2CT*wJT[+=vo#b5\sRv&/W„U"V:T'3Bj<=[^w#RR;9)=L.QsxTC:lV=[$cf>>7%[h05ZK%MFF+]q*St;/t#gxOSN„U"b9^hz86M#%xmWPXJway(TdPsOw+cN'0#R&L7_WoGJU&W1Q:\6MYLm#:vC,wH1Nc„U"%d<nVhcK[9DwJgW+T]ZB3JF$G7NIfGqSzxi]q=dREN?4iV]dSG$Kw$S%#3urNxW„U"I42r2YSy<kv1K,(O0G6ISfFZ[CCjLS8QPq*:&+?:B06cb;<'g\,m=O^p[:8s-Al„U"J.5Os)AX7Tb.eULu%(T24?dMCDx'$AXPwJ[avEpOl<S7RSRXi;tq]+r>Xu)$?k3„U"kBUfpqj[-CIZ9[g_tiMtV%c$Ci5BDaF\4(Gkfd6-a.Vf4,FPV4-7nL:_HNE60[_„U"MyQb^Ng8zH3y,;pKvE&FNX4s]7d_dY\<.V]V2(2uhUP9P9zHJa-[W0u\>,^'w6?„U"[sYAem[k<Lw#/MSj'WcbYV#q0_.j$^4cD;-mOAmjU]%k$Q>6P&\P%'\P_y0&F,B„U"J(/.M<\g*^$sBujaU.^uf<j^HJsKZee\xyQZ3qHXCBZ0Y8^Sf4KJ<UBh)Dnmmit„U"$?q$#P_7.3WQx4KF&7$J0+]&P]SC%2M=E.ZH%Oki6X2_6lHG;sgp0/UPA<d]'^b„END SUB„SUB V2„U"oQlMGjUXEtb58Wr:cHCxMP$[u%mb0NY6OeV0QRIjX(?\pLkl;kBG=0/B<g317H'„U"czdGfBI+vBgJIxy10I:rS9D,R3CS>o>El,PR(Q=:A\3U:H#2v)xMSkdb04Hju_<„U"fxMPer6l,cgGM=bo<:n,4as9NAxcd)Z2;.+uM6.bzC\>j'xOcE2eIkq9DCY<EPs„U"Q8+Q,FkbK8Mlo=5;=]Xu'j(bh$ikx?e8xgM2Gu%njEl9Le2Y$%=qA6Zq$=\4Og^„U"6-MI]$k),P4n3M7d>$,isfO<v&cl#GBz;2;0dgSeX](>L9.j36?)+-wA:&F::cJ„U"/oL8lRwst^E+%sJ/YWE=n#(3SLe6gI8(?ptom_;fdNtgg2$vwp+bc,Grc',NsnD„U"Qn>1+?sBemM;E$.DPlCXY9Sm%Q(sXWcxQ6dKDUyy2wP/gz?t;<lMh<2SZ6HvUlu„U"Kdu,'#6a,3u=mm.rt;#T)Z%8iSLybF\cztWgHazJ&)#TqSbgFK]Y,e)I4ieX]WC„U"dR+8XeMZ^j30[Sg?B?PU,d7QD=g/WjC/1RA*hRJn&ALE'aOKn'w+[.'\;[Rm]&u„U"ieAM&sqySmMr'[*-?FQSm$oXNTK_>OOZKTKT9KVoK,-[wsPIE-Wr#I-#09Jf8xX„U"SCf#pm0+Nd_zzW%gO?,VCkBiln/fvX'xBwS>N>h847'7kajs_>dJg??059Hi8G%„U"V/RqUGZla)FB.'+C2HXjR+6ns)T,R.IP[>'&$rcw3Qrc=GjBuw2T%l;9pW3Ilv3„U"/[3:XpbGAku>P.H\3Ur(NQE4Sa\g9-/>bzD$i?l''PZ<^6N(p/C(d/ckfp'LnJ;„U"ip(wcbq:Wo).\ARvl'gHF/h[*;;B(Ajhkot[IHYO%,rJLe)v4+J?.sfYN.X9n]S„U"Dlk*7Y$i(r1]S:KKYW]/wlLhna6%;]v\q]K(L,Y<s?vG2pkATxh;&#YH^/1*Dx:„U"C>lDdSc)9r+Tjn:_MRlqm%X5RKA#)\Kb#s*a.VsaNlW]<:xq.w0&Nt^\/b&O(8/„U"b,YkIfS4cPn(WdfHP8\)QmDO\A?ag08sKUmPBFe.)wSe%NA7e.Vslal)K1Wwu%2„U"J$X^\T8.pa&UW%e,]b+GvQRa,DMp]b^Mz%egM^7&9ZCR]nG]L]5P3Eh^\nM$?rw„U"*)4iH16ii=/4l0UjlD.;X;^>KQT;zXagq%o:L.]ZvM*xH('DCQlo0iL-<+%GsPd„U"^39rTmo13vciLGrbXBn?xf0Av/L9+%F>yEV8u=UuLBqtvLgT:as<.;vEGCDLvbh„U"fB\>FHTm>?>aGB^c&?s&>hRt,n)^FbV4M9h*d1rm==HDlW0)S&*=TUbM,ri&Xb#„U"uWgPqe'\Uc+cP2Bb1F$F;C5n&NsqL%_6:ys,sRtPkEZV.+mP?5AbtkhBBEVjI<u„U"7[W$<^LkHM:E;$]lbN2q6Ze-b6xSrS$fHErAH2oosB+LMgv>gV-:CmiFB-7tIv_„U"RY8I'&t&HEsKj3jf;^=$djm],tdQ;84+qIlt=iCGWg(C=US]+Jfo'bld4$83h=P„U"W$jfTtGBcoGDP:LF&IhqNB&\W[J[*7-ME;oOI41A&T/UdS<aDWw_yrO'N#iC=c'„U"'8/(.pX/:k4TSTU'<Uu]2N2H-/BLwuE?O-6_kT7dLzn.MZ[P$;fIkF&P-0\llNP„U"*uG?SBKs[8xSR]u(S37iRsN-zsWu-[evT'wjN%up&'%9%9%%%%-%*&Y=FYmfgF&„U"j'%%&f)%%%/%%%%%%%%%&%E%%%%%%%%%wj%firj%SVxy%up&'%9%9%%%%-%*&Y=„U"Fr)vn(')&%%&^*%%%,%%%%%%%%%&%E%7%%<'.%%'r%xSns%hup&%'9%9%%%%-4%„U"&Y=4F%RL(d^,%(%y6%%%,%%%%%%%%%%%E#%%%g#)%%'%rxSu%gqup%&'9%%9%%%„U"R-%&Y.=Fnp>g(\'7%%<,%%%,%%%%%%%%%&%%E%%%%q1%%&'rxS(y'yu%p&'9%%9„U"%%[%-%&\Y=F#Uu[Gf#,%%?%Q%%/%%%%%%%%%&%%E%%%%y4%(%'rx%fxrS%fxru%„U"p&'9%%9%%[%-%&\Y=Fi7mJ%7#'%%s%'%%/%%%%%%%%%%%%E%%%%8<%(%'rx%fxr„U"S%tgou%p&'9%%9%%[%-%&AY=FIr7_ck%'%%y%/%%/%%%%%%%%%&%%E%%%%r>%(%„U"'rx%gfxS%gfxu%p&'9%%9%%[%-%&\Y=FQOYxs(%*%%v%3%%/%%%%%%%%%%%%E%%„U"(%6A%(%'rx%gfxS%ugzu%p&'9%%9%%[%-%&&Y=FvW?eCZ[/%%$%F%%0%%%%%%%%„U"%&%%E%%+%aF%(%'rx%ijrt%Sgfx%up*+%%%%%%.%.%'i&%%&kQ%%%%%„END SUB„V2„CLOSE:IF S=238AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Kurt Kuzba                     VIEW CONTENTS OF RAM           FidoNet QUIK_BAS Echo          02-21-96 (00:00)       QB, QBasic, PDS        93   4299     QBMEMV.BAS  '>>   The segment before BIOS holds the interrupt vectors,„'>   So 0000:0000 is the first byte in memory, then from„'>   there, the pointers are placed for the ISR's, each„'>   pointer requiring 4 bytes.  That would put the end of„'>   the last pointer at 0000:0400, which is 1k (or 1024„'>   bytes) of memory used for storing pointers.  What„'>   starts at 0000:0401 and what's after that?„'>.............„'   The interrupt vectors actually extend from 0000:0000 to„'0000:03ff, or 0030:00ff. This allows for 256 interrupts.„'You should recognize DEF SEG = &H40 as setting to the BIOS„'area segment. Here you will find all the parameters for„'your current system configuration, such as address for the„'COM ports and PRN ports, your keyboard buffer, cursor x and„'y position definitions, shift status register, color status„'register, screen mode register, BIOS clock, and so on.„'After that?? Have you ever seen my posting of QBMEMV.BAS?„'It will allow you to peek into these areas and see what is„'going on in there. I believe the next portion is also set„'aside for SYSTEM usage, at least in DOS.„„'_|_|_|   QBMEMV.BAS„'_|_|_|   This program allows the user to view the contents of„'_|_|_|   their system's RAM, up to 1 Megabyte.„'_|_|_|   No guarantees or warrantees are given or implied.„'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (2/21/96)„COLOR 4, 0: CLS : f$ = CHR$(178): DIM BMem(256) AS STRING * 1„PRINT : PRINT "  QUICKBASIC": PRINT : PRINT "   MEMVIEW": COLOR 10„FOR t% = 1 TO 6: LOCATE t%, 16: PRINT STRING$(49, f$): NEXT„COLOR 14, 5: LOCATE 2, 4, 0„LOCATE , 19: PRINT " Cursor    UP  +256 "„LOCATE , 19: PRINT " Cursor  DOWN  -256 "„LOCATE , 19: PRINT " Cursor RIGHT  +4 K "„LOCATE , 19: PRINT " Cursor  LEFT  -4 K ": LOCATE 2„LOCATE , 42: PRINT " Page     UP  +64 K "„LOCATE , 42: PRINT " Page   DOWN  -64 K "„LOCATE , 42: PRINT " RETURN to EXIT     "„LOCATE , 42: PRINT " ESCAPE to EXIT     ": COLOR 10, 2„FOR t% = 7 TO 25: LOCATE t%, 2: PRINT STRING$(77, f$); : NEXT„LOCATE 8, 4: COLOR 1, 3: PRINT "       ";„FOR t% = 0 TO 15: PRINT RIGHT$("0" + HEX$(t%), 2); " "; : NEXT„COLOR 15, 1: CurSeg& = &H0„FOR t% = 0 TO 15: LOCATE 9 + t%, 10: PRINT SPACE$(49); : NEXT„DO„„   FOR t% = 0 TO 15„      COLOR 1, 3: LOCATE 9 + t%, 4„„      'Was: PRINT(RIGHT$("0000" + HEX$(CurSeg&),4); HEX$(t%); ":";„      'Corrected by Richard Backus 9/18/96 to correct the linear addressing„      'on left column.„„      PRINT LEFT$(RIGHT$("0000" + HEX$(CurSeg&), 4), 3); HEX$(t%); "0:";„      DEF SEG = CurSeg&: COLOR 15, 1: PRINT " ";„„      FOR byte% = 0 TO 15„         PRINT RIGHT$("0" + HEX$(PEEK(t% * 16 + byte%)) + " ", 3);„      NEXT„   NEXT: COLOR 0, 7„   FOR t% = 9 TO 24: LOCATE t%, 61: PRINT SPACE$(16); : NEXT„   COLOR 15, 1„   DO„      DEF SEG = CurSeg&„      FOR t% = 0 TO 15: FOR byte% = 0 TO 15„         BMem(t% * 16 + byte%) = CHR$(PEEK(t% * 16 + byte%))„      NEXT: NEXT: DEF SEG = &HB800„      FOR t% = 0 TO 15: LOCATE t% + 9, 11: FOR byte% = 0 TO 15„         PRINT RIGHT$("0" + HEX$(ASC(BMem(t% * 16 + byte%))) + " ", 3);„         POKE 1400 + t% * 160 + byte% * 2, ASC(BMem(t% * 16 + byte%))„      NEXT: NEXT„      Key$ = INKEY$: IF Key$ = "" THEN Key$ = " "„      K% = ASC(Key$): IF K% = 0 THEN K% = -ASC(MID$(Key$, 2))„      SELECT CASE K%„         CASE -72: CurSeg& = CurSeg& - 16: Key$ = "LOOP"„            IF CurSeg& < 0 THEN CurSeg& = 65535„         CASE -80: CurSeg& = CurSeg& + 16: Key$ = "LOOP"„            IF CurSeg& > 65535 THEN CurSeg& = 0„         CASE -75: CurSeg& = CurSeg& - 256: Key$ = "LOOP"„            IF CurSeg& < 0 THEN CurSeg& = 65535„         CASE -77: CurSeg& = CurSeg& + 256: Key$ = "LOOP"„            IF CurSeg& > 65535 THEN CurSeg& = 0„         CASE -73: CurSeg& = CurSeg& - 4096: Key$ = "LOOP"„            IF CurSeg& < 0 THEN CurSeg& = 65535„         CASE -81: CurSeg& = CurSeg& + 4096: Key$ = "LOOP"„            IF CurSeg& > 65535 THEN CurSeg& = 0„         CASE 13, 27: out$ = "OUT": Key$ = "LOOP"„      END SELECT„   LOOP WHILE Key$ <> "LOOP"„LOOP WHILE out$ <> "OUT"„COLOR 14, 0: LOCATE 2, 67: PRINT "Thank You"„LOCATE 3, 67: PRINT "for using": LOCATE 4, 67: PRINT "QuickBasic"„LOCATE 5, 67: PRINT "MemView.": LOCATE 24, 1„'_|_|_|   end   QBMEMV.BAS„