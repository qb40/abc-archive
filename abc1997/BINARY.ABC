Joe Caverly                    BINARY SEARCH ROUTINE          74214.637@CompuServe.COM       11-02-96 (15:01)       QB, QBasic, PDS        59   2091     BSEARCH.BAS '  I looked through the ABC Text for a binary search routine, but found none. I„'have this very large text file that is downloaded from the Mainframe each day,„'which is presently at 151,000 records, and growing. Each record is 328„'characters wide. The file is sorted by a 7-character customer number. I needed a„'means of rapidly looking up a customer number. However, instead of reading this„'very large text file into a database, I figured there had to be a way to rapidly„'search the file as-is. The code below does just that.„„CLS„DIM RecordIn AS STRING * 9„LET RecLen = 9„LET TEST = FREEFILE„OPEN "C:\SETUP\ADANUM.TXT" FOR BINARY AS #TEST LEN = RecLen„LET wsmin = 0„LET wsmax = (LOF(TEST) / RecLen) + 1„LET wsmaxptr = (wsmax * RecLen) + 1„LET wsKey$ = "1218537"„DO„  LET wsmid = wsmin + ((wsmax - wsmin) \ 2)„  LET wsptr = (wsmid * RecLen) + 1„  IF wsmin > wsmax THEN„    PRINT "Not Found!"„    PRINT "Near Record Number "; wsmid„    EXIT DO„  END IF„  GET #TEST, wsptr, RecordIn„  LET wsRecordIn$ = LEFT$(RecordIn, 7)„  SELECT CASE wsRecordIn$„    CASE IS = wsKey$„      PRINT wsRecordIn$ + " equals " + wsKey$„      EXIT DO„    CASE IS < wsKey$„      'What we want is in the upper half„      PRINT wsRecordIn$ + " Less Than " + wsKey$„      LET wsmin = wsmid + 1„    CASE IS > wsKey$„      'What we want is in the lower half„      PRINT wsRecordIn$ + " Greater Than " + wsKey$„      LET wsmax = wsmid - 1„  END SELECT„LOOP„CLOSE #TEST„PRINT "Done!"„END„„'Please note that the above program works with a fixed-width file where each„'record is 9 characters wide (7 characters of data plus a carriage return and„'line feed). If you want to generate a file to test this program with, here's a„'small program that will do just that. The above program would need to be„'modified to accept a record that is 13 characters wide (11 characters of data„'plus a carriage return and line feed).„„OPEN "c:\setup\test.dat" FOR OUTPUT AS #1„FOR cntr = 1 TO 151000„  PRINT #1, USING "Line ######"; cntr„NEXT cntr„CLOSE #1„PRINT "Done!"„END„Kurt Kuzba                     FULL 16-BIT SHIFTING ROUTINE   FidoNet QUIK_BAS Echo          12-08-96 (13:50)       QB, QBasic, PDS        37   1251     SHIFT.BAS   '>   I would like to know if anyone knows a simple right bit-„'>   shift routine for QBasic.„'>......„'   I wrote one of those a while ago when someone posted a PB„'program using SHIFT(). I recently stumbled across a means to„'accurately convert bit patterns for INTEGER values to LONG when„'the value is negative, so I did an update to the process.„'It now allows a full 16-bit shift where it only allowed 15 before.„„'_|_|_|   SHIFT.BAS„'_|_|_|   A simple bit-shifting routine for Qbasic„'_|_|_|   No warrantee or guarantee is given or implied.„'_|_|_|   Released   PUBLIC DOMAIN   by Kurt Kuzba.  (12/7/96)„DECLARE FUNCTION shift% (D%, V%, T%)„DO„   INPUT "number => ", N%„   sh% = N%„   PRINT shift%(0, sh%, 1), shift%(1, sh%, 1)„LOOP WHILE N% > 0„END„FUNCTION shift% (D%, V%, T%)„   '_|_|_|   A simple bit-shifting routine for Qbasic„   '_|_|_|   shift V% right or left T% places„   '_|_|_|   if D% = 0 then shift right, else shift left„   S& = V%„   IF S& < 0 THEN S& = 65536 + S&„   FOR T% = T% TO 1 STEP -1„      IF D% = 0 THEN„         S& = S& \ 2„      ELSE„         S& = (S& * 2) AND 65535„      END IF„   NEXT„   IF S& > 32767 THEN S& = S& - 65536„   shift% = S&„END FUNCTION„'_|_|_|   end   SHIFT.BAS„Byron Smith                    SET BIT                        unol@sat.net                   01-25-97 (16:41)       QB, QBasic, PDS        43   1039     BITSTR.BAS  DECLARE SUB BON (S%, O%, B%)„DECLARE SUB BOFF (S%, O%, B%)„DECLARE SUB TOGGLE (S%, O%, B%)„DECLARE FUNCTION BIT% (S%, O%, B%)„DIM A(0) AS DOUBLE„CLS„A(0) = CVD(STRING$(7, 170) + CHR$(126))„FOR X% = 63 TO 0 STEP -1„  PRINT USING "#"; BIT%(VARSEG(A(0)), VARPTR(A(0)), X%);„NEXT„PRINT„„'Turn ON bit #2„BON VARSEG(A(0)), VARPTR(A(0)), 2„„FOR X% = 63 TO 0 STEP -1„  PRINT USING "#"; BIT%(VARSEG(A(0)), VARPTR(A(0)), X%);„NEXT„PRINT„„'Turn OFF bit #2„BOFF VARSEG(A(0)), VARPTR(A(0)), 2„„FOR X% = 63 TO 0 STEP -1„  PRINT USING "#"; BIT%(VARSEG(A(0)), VARPTR(A(0)), X%);„NEXT„PRINT„„FUNCTION BIT% (S%, O%, B%)„  DEF SEG = S%: BIT% = -((PEEK(O% + B% \ 8) AND 2 ^ (B% MOD 8)) > 0)„END FUNCTION„„SUB BOFF (S%, O%, B%)„  DEF SEG = S%: POKE O% + B% \ 8, PEEK(O% + B% \ 8) AND 255 - 2 ^ (B% MOD 8)„END SUB„„SUB BON (S%, O%, B%)„  DEF SEG = S%: POKE O% + B% \ 8, PEEK(O% + B% \ 8) OR 2 ^ (B% MOD 8)„END SUB„„SUB TOGGLE (S%, O%, B%)„  DEF SEG = S%: POKE O% + B% \ 8, PEEK(O% + B% \ 8) XOR 2 ^ (B% MOD 8)„END SUB„Alexander Podkolzin            UUENCODE/DECODE FOR PB         app@nw.sbank.e-burg.su         04-25-97 (09:12)       PB                     316  8317     UUENCODE.BAS'---------------------------------------------------------------------------„'                                                                          '„' Alexander Podkolzin. <App@nw.sbank.e-burg.su>                            '„' Demo program for PB3.2 compiller.                                        '„' PUBLIC DOMAIN UUencode and UUdecode functions.                           '„' USE IT ON YOUR OWN RISC!                                                 '„'                                                                          '„' UUencode and UUdecode snippet from my working NewsReader program.        '„' I use it about a year or so. It works fine for me.                       '„' Test it before using!                                                    '„'                                                                          '„' Special thanks to David J. Arigan, whos ideas I used in my program.      '„'                                                                          '„' I do not use here ASM, but functions works very fast ( I hope they are   '„' the fastest from functions written in pure BASIC :) due to pointers ...  '„' Sorry, code is not commented enought, as I feel not free with my English.'„'                                                                          '„' Pleeeease, IF YOU WILL ENHANCE THIS CODE SEND ME YOUR IDEAS !!!          '„'                                                                          '„'---------------------------------------------------------------------------„'„' Demo here:„'„  „  DEFINT A-Z„  „  COLOR 7,0„  CLS„  INPUT "Input FileName to UUencode ", FileName$„  IF NOT fFileHere(FileName$) THEN„    PRINT FileName$; " <- File not found!"„    END„  END IF„„  Attach$ = "$$temp$$.$$$"„  Fs& = fFileSize(FileName$)      ' File size„  PRINT "File size ="; Fs&; "bytes."„„  COLOR 28,0„  LOCATE 1,70„  PRINT "Encoding..."„„  t# = TIMER„'///////////////////////////////////////////////////////////„„  AttachUUEncode FileName$, Attach$    ' UU Encoding„„'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\„  COLOR 7,0„  LOCATE 1,70„  PRINT "           "„„  LOCATE 3,1„  PRINT "UU Encoding Done!  Time of encoding="; USING$("###.##s",TIMER-T#)„  SOUND 880,.5„„  PRINT "Press a key..." : s$ = INPUT$(1)  ' Pause„„  COLOR 28,0„  LOCATE 1,70„  PRINT "Decoding..."„„  t# = TIMER„'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\„„  ExtractUU Attach$                    ' UU Decoding„„'///////////////////////////////////////////////////////////„  COLOR 7,0„  LOCATE 1,70„  PRINT "           "„„  LOCATE 5,1„  PRINT "UU Decoding Done!  Time of decoding="; USING$("###.##s",TIMER-T#)„  SOUND 440,.5„„  PRINT„  PRINT "THANK YOU VERY MUCH FOR TESTING THIS PROGRAM !"„„  END„'„'---------------------------------------------------------------------------„' FileName$ - File name to UUencode„' Attach$   - File to append to„'„ SUB AttachUUEncode(FileName$,Attach$)„'„    file$ = FileName$                   '„    pnam$ = file$                       '„    unam$ = file$                       '„'„    n = RInstr(1,pnam$, "\")„    IF n THEN„       pnam$ = MID$(pnam$, n + 1)„    END IF„'„    unam$ = MID$(file$, RInstr(1,file$, "\") + 1)„    n = INSTR(unam$,".")„    IF n THEN„       unam$ = LEFT$(unam$, n - 1)„    END IF„'„    Src% = FREEFILE„    OPEN file$ FOR BINARY AS Src%„    SrcU% = FREEFILE„    OPEN Attach$ FOR OUTPUT AS Srcu%       ' Or APPEND, if file exists„    PRINT #SrcU%, ""„    PRINT #SrcU%, ""„    PRINT #SrcU%, "+++++++++++++++++++++   Attachment :   ++++++++++++++++++++++"„    PRINT #SrcU%, ""„'„    M1$="begin 644 "„    M2$="end"„    LP$="`"„    cl$ = SPACE$(45)„'„    PRINT #SrcU%,M1$+Pnam$                 'print header line„'„    WHILE NOT EOF(src%)„       BufIn$=cl$„       GET$ #Src%,45,BufIn$„       LineOut$ = EncodeLine(BufIn$)„       Temp = 3 * LEN(LineOut$) \ 4        'get unencoded character count„       LineOut$ = CHR$(32+Temp) + LineOut$ 'add count to line„       PRINT #SrcU%,LineOut$„       LineOut$ = ""„    WEND„    PRINT #SrcU%,LP$„    PRINT #SrcU%,M2$                       'output "end" line„    CLOSE Src%, SrcU%„'„ END SUB„'___________________________________________________________________________„'„ SUB ExtractUU(Unam$)„  SrcFile$ = Unam$„  Src = FREEFILE„  OPEN SrcFile$ FOR INPUT AS Src„  WHILE NOT EOF(Src)„    LINE INPUT #Src, l$„    INCR LineNumber„    IF LEFT$(l$, 5) = "begin" THEN„        DestFile$ = MID$(l$,11)„        Dest = FREEFILE„        OPEN DestFile$ FOR BINARY AS Dest„        DO„          LINE INPUT #Src, l$„          INCR LineNumber„          IF LCASE$(LEFT$(l$, 3)) = "end" THEN EXIT DO„          IF LEN(l$) THEN„            s$ = DecodeLine(MID$(l$,2))„            PUT Dest, , s$„          END IF„        LOOP UNTIL EOF(Src)„        CLOSE Dest„    END IF„  WEND„  CLOSE Src„ END SUB„'___________________________________________________________________________„'„  FUNCTION EncodeLine$(l$)„'„    DIM Iptr AS BYTE PTR„    DIM Optr AS BYTE PTR„'„    l = LEN(l$)„    m = l MOD 3„'„    IF m = 1 THEN„       l$ = l$ + "  "„       INCR l,2„    ELSEIF m = 2 THEN„       l$ = l$ + " "„       INCR l„    END IF„'„    n = l \ 3„    o$ = SPACE$( n * 4 )„'„    Iptr = STRPTR32(l$)„    Optr = STRPTR32(o$)„'„    FOR i=1 TO n„      EncodeCell Iptr,Optr„      INCR Iptr,3„      INCR Optr,4„    NEXT„'„    REPLACE " " WITH "`" IN o$„'„    FUNCTION = o$„'„  END FUNCTION„'___________________________________________________________________________„'„  SUB EncodeCell( InCell AS DWORD, OutCell AS DWORD )„'„    DIM ICell AS BYTE PTR„    DIM OCell AS BYTE PTR„'„    ICell = InCell???„    OCell = OutCell???„'„    a? = @ICell„    a1? = (@ICell AND 252) \  4„    a2? = (a? AND   3)     * 16„'„    INCR ICell„    b? = @ICell„    b1? = (b? AND 240)     \ 16„    b2? = (b? AND  15)     *  4„'„    INCR ICell„    c? = @ICell„    c1? = (c? AND 192)     \ 64„    c2? = (c? AND  63)„'„    @OCell = 32+a1?„    INCR OCell„    @OCell = 32+a2?+b1?„    INCR OCell„    @Ocell = 32+b2?+c1?„    INCR OCell„    @OCell = 32+c2?„'„  END SUB„'___________________________________________________________________________„'„  FUNCTION DecodeLine$(l$)„'„    DIM Iptr AS BYTE PTR„    DIM Optr AS BYTE PTR„'„    REPLACE "`" WITH " " IN l$„    n = LEN(l$) \ 4„    o$ = SPACE$( n * 3 )„'„    Iptr = STRPTR32(l$)„    Optr = STRPTR32(o$)„'„    FOR i=1 TO n„      DecodeCell Iptr,Optr„      INCR Iptr,4„      INCR Optr,3„    NEXT„'„'„    FUNCTION = o$„'„  END FUNCTION„'___________________________________________________________________________„'„  SUB DecodeCell( InCell AS DWORD, OutCell AS DWORD )„'„    DIM ICell AS BYTE PTR„    DIM OCell AS BYTE PTR„'„    ICell = InCell???„    OCell = OutCell???„'„    a?  = @ICell - 32„    a1? = a? * 4„'„    INCR ICell„    b?  = @ICell - 32„    a2? = (b? AND 48) \ 16„    b1? = (b? AND 15) * 16„'„    INCR ICell„    c?  = @ICell - 32„    b2? = (c? AND 60) \  4„    c1? = (c? AND  3) * 64„'„    INCR ICell„    d?  = @ICell - 32„    c2? = (d? AND 63)„'„    @OCell = a1? + a2?„    INCR OCell„    @OCell = b1? + b2?„    INCR OCell„    @Ocell = c1? + c2?„'„  END SUB„'___________________________________________________________________________„'„  FUNCTION RInstr(BYVAL start, BYVAL Main$, BYVAL Search$) PUBLIC„    lm = LEN(Main$)„    ls = LEN(Search$)„    FOR i = lm - ls + 1 TO 1 STEP -1„      IF MID$(Main$,i,ls) = Search$ THEN„        FUNCTION = i„        EXIT FUNCTION„      END IF„    NEXT„    FUNCTION = 0„  END FUNCTION„'„'---------------------------------------------------------------------------„  FUNCTION fFileHere%(FileNAME$) PUBLIC„     FUNCTION = ( DIR$(FileNAME$) <> "" )„  END FUNCTION„'---------------------------------------------------------------------------„ FUNCTION fFileSize&(FileName$)„   IF fFileHere(FileName$) THEN„     f% = FREEFILE„     OPEN "r",f%,FileName$„     l& = LOF(f%)„     CLOSE f%„   ELSE„     l& = -1„   END IF„   FUNCTION = l&„ END FUNCTION„'___________________________________________________________________________„Mark Otter                     ENCRYPT YOUR BASIC PROGRAMS    loutre@xs4all.nl               05-03-97 (17:48)       QB, QBasic, PDS        95   2967     CODE.BAS    DECLARE FUNCTION EnCrypt$ (Txt$)„'Hello everybody,„'This program wrote I some days ago because I like to do what this can do„'This program reads your .BAS file (saved as text for QB 4.x) and writes it„'to another text file (also .BAS) but al the strings between "" are coded,„'this means (for QB 4.x owners also after compiling), it is hard to much„'harder to cheat your program!„'Thanks are always welcome!! (Mark Otter(14) : loutre@xs4all.nl)„'Please put some were my name in your program, Small letters are allowed :-)„'This is Public Domain„'„'See ya!„'„'PS I did not do much syntax cheking (or how do you call it)„'PS.PS. When you have made this program better than i did, please send it to„'       me and the ABC Reader?!„'„'Now you may try it it„CLS„InFile$ = "SONGS.BAS"    'File to read (BAS Text file)„OutFile$ = "CODEOUT.BAS"  'File to write to (Also BAS Text file)„„OPEN InFile$ FOR INPUT AS #1              'Open Infile„PRINT "Initializing " + InFile$ + "..."   'Search for function CHW$ and hope not been found„DO WHILE (NOT (EOF(1)))„   LINE INPUT #1, A$„   A$ = UCASE$(LTRIM$(RTRIM$(A$)))„   IF LEFT$(A$, 21) = "FUNCTION CHW$ (FAST$)" THEN„	  PRINT "ERROR: FUNCTION CHW$ (Fast$) does already exist!"„	  BEEP„	  END„   END IF„LOOP„CLOSE #1„'Code all the strings„PRINT "Coding " + InFile$ + " to " + OutFile$ + "..."„OPEN InFile$ FOR INPUT AS #1„OPEN OutFile$ FOR OUTPUT AS #2„DO WHILE (NOT (EOF(1)))„   LINE INPUT #1, A$„   A$ = LTRIM$(RTRIM$(A$))„   IF A$ <> "" THEN„	  IF INSTR(A$, CHR$(34)) = 0 THEN„		 PRINT #2, A$„	  ELSE„		 InString% = 0„		 OutBuffer$ = ""„		 FOR Q% = 1 TO LEN(A$)„			 T$ = MID$(A$, Q%, 1)„			 IF T$ <> CHR$(34) THEN„				IF InString% = 0 THEN„				   OutBuffer$ = OutBuffer$ + T$„				ELSE„				   C$ = EnCrypt$(T$)„				   IF ASC(C$) > 31 THEN„					  OutBuffer$ = OutBuffer$ + C$„				   ELSE„					  Number$ = LTRIM$(STR$(ASC(C$)))„					  OutBuffer$ = OutBuffer$ + CHR$(34) + "+CHR$(" + Number$ + ")+" + CHR$(34)„				   END IF„				END IF„			 ELSE„				IF InString% = 0 THEN„				   OutBuffer$ = OutBuffer$ + "CHW$( " + CHR$(34)„				   InString% = 1„				ELSE„				   OutBuffer$ = OutBuffer$ + CHR$(34) + ") "„				   IF InString% = 1 THEN InString% = 0„				END IF„			 END IF„		 NEXT Q%„		 PRINT #2, OutBuffer$„	  END IF„   END IF„LOOP„CLOSE #1„PRINT #2, "    "„PRINT #2, "defint a-z"„PRINT #2, "function chw$(fast$)"„PRINT #2, "cpuspeed$=" + CHR$(34) + CHR$(34)„PRINT #2, "for music=1 to len(fast$)"„PRINT #2, "bios=asc(mid$(fast$,music,1))"„PRINT #2, "harddisk=255-bios"„PRINT #2, "cpuspeed$=cpuspeed$+chr$(harddisk)"„PRINT #2, "next music"„PRINT #2, "chw$=cpuspeed$"„PRINT #2, "end function"„CLOSE #2„PRINT "Done" 'We're done.„„FUNCTION EnCrypt$ (Txt$)„EnCrypt$ = CHR$(255 - ASC(Txt$))„'This is a simple way to code a character and it's easy to crack in a binary„'file but in an executable-file this is very difficult (I Think)„END FUNCTION„Andrew Below                   INVERT BITS IN A FILE          bel@obninsk.ru                 07-20-97 (20:12)       QB, QBasic, PDS        64   1787     INVBITS.BAS 'Hi!„'Here is a simple program, that inverts bits in„'specified file and writes modified bytes in another file.„'Encode algorithm:  1. Get byte;„'                   2. Extract bits from byte;„'                   3. Invert bits: 01101011 (in);„'                                   10010100 (out);„'                   4. Write modified byte.„'„'If you can do it faster, please E-mail me your variants.„'Thanx.„'„'Andrew Below, H.A.S.„'E-mail: bel@obninsk.ru, onxman@geocities.com„'   WWW: http://www.geocities.com/SiliconValley/Vista/4318„'„DECLARE FUNCTION Invert$ (Char$)„DECLARE FUNCTION GetDec& (Binary$)„DEFINT A-Z„DIM SHARED Bits(0 TO 7)„Bits(0) = 1„FOR i = 1 TO 7„ Bits(i) = (Bits(i - 1) * 2)„NEXT i„CLS„LINE INPUT "Enter input file name [INVERT.BAS]: ", FileName$„IF LTRIM$(RTRIM$(FileName$)) = "" THEN FileName$ = "INVERT.BAS"„LINE INPUT "Enter output file name [INVERT.BIT]: ", OutFile$„IF LTRIM$(RTRIM$(OutFile$)) = "" THEN OutFile$ = "INVERT.BIT"„DIM s AS STRING * 1„OPEN FileName$ FOR BINARY AS #1„ OPEN OutFile$ FOR BINARY AS #2„  Lenght& = LOF(1)„  PRINT "Total:"; Lenght&„  PRINT "Current:"; : y = CSRLIN: x = POS(0)„  FOR i& = 1 TO Lenght&„    LOCATE y, x: PRINT i&„    GET #1, i&, s$„    s$ = Invert$(s$)„    PUT #2, i&, s$„  NEXT i&„ CLOSE #2„CLOSE #1„„FUNCTION GetDec& (Binary$)„Binary$ = LTRIM$(RTRIM$(Binary$))„Length = LEN(Binary$)„Decimal& = 0„FOR i = 1 TO Length„   Digit$ = MID$(Binary$, i, 1)„   IF Digit$ = "0" OR Digit$ = "1" THEN„      Decimal& = 2 * Decimal& + VAL(Digit$)„   END IF„NEXT i„GetDec& = Decimal&„END FUNCTION„„FUNCTION Invert$ (Char$)„Bin$ = ""„FOR i = 0 TO 7„ Bin$ = Bin$ + LTRIM$(RTRIM$(STR$((ASC(Char$) AND Bits(i)) \ Bits(i))))„NEXT i„Invert$ = CHR$(GetDec&(Bin$))„END FUNCTION„Tommi Utriainen                DATA SENDER TO LPT1            tomppa@pcuf.fi                 09-14-97 (21:42)       QB, QBasic, PDS        326  7624     COVOX.BAS   DECLARE SUB popup (rivit%, sij%, sij2%, lteksti$(), rvari%, pvari%, tvari%, fiu%)„DEFINT A-X„CLS„„OUT 888, 255„„rivit = 7: sij = 0: sij2 = 9:„lteksti$(1) = "                                "„lteksti$(2) = "       TMP SoftWare Presents:       "„lteksti$(3) = "                                     "„lteksti$(4) = "    Data sender to LPT1 (0387h)"„lteksti$(5) = "                                     "„lteksti$(6) = "        Copyright 27.8.1991"„lteksti$(7) = "                                "„„rvari = 1: pvari = 7: tvari = 1„„fiu = 1„CALL popup(rivit%, sij%, sij2%, lteksti$(), rvari%, pvari%, tvari%, fiu)„„SLEEP 1„„OUT 888, 0„„lteksti$(1) = "                                "„lteksti$(2) = "      Please wait a moment...        "„lteksti$(3) = "                                     "„lteksti$(4) = "      Loading data to send..."„lteksti$(5) = "                                     "„lteksti$(6) = "     (c) TMP SoftWare Co. 1991"„lteksti$(7) = "                                "„CALL popup(rivit%, sij%, sij2%, lteksti$(), rvari%, pvari%, tvari%, fiu)„„LOCATE 1, 1:„„COLOR 10, 0: PRINT "Sending:";„„FOR t = 65 TO 122„        FOR v = 1 TO 2000: NEXT„„        PRINT CHR$(t);„„        OUT 888, t„        OUT 888, 0„„NEXT„LOCATE 2, 1„PRINT "Testing: ";„„FOR t = 0 TO 7„        FOR v = 1 TO 12000: NEXT„        OUT 888, 0„        PRINT " Bit"; t; ";";„        OUT 888, 2 ^ t„        FOR v = 1 TO 12000: NEXT„NEXT„„DO„LOCATE 14, 1„INPUT "Enter Bit 0-7:", b„IF b > 7 THEN EXIT DO„OUT 888, 0„OUT 888, 2 ^ b„LOOP„„CLS„„PRINT "This program was made by TMP SoftWare Co. 1991"„„' Ikkunan avaus 'popup' tyyliin.„SUB popup (rivit, sij, sij2, lteksti$(), rvari, pvari, tvari, fiu)„'PiirtÑÑ Command barin ikkunat„„'CALL MouseHide„„PCOPY 0, 1„SCREEN 0, 1, 1, 0„„„„'CALL MouseHide„„„tek = 0„        FOR silm1 = 1 TO rivit„                FOR silm2 = 1 TO rivit„                IF LEN(lteksti$(silm2)) > tek THEN tek = LEN(lteksti$(silm2))„                NEXT„        NEXT„sij = (40 - INT(tek / 2))„sij2 = (12 - INT(rivit / 2))„„LOCATE sij2, sij„COLOR rvari, pvari: PRINT "’";„PRINT STRING$(tek + 2, "Õ");„PRINT "∏": COLOR alkup, alkup2„        FOR silm2 = 1 TO rivit„        LOCATE sij2 + silm2, sij„        PRINT ; : COLOR rvari, pvari:„        IF lteksti$(silm2) <> "" THEN PRINT "≥ "; : COLOR tvari, pvari: PRINT lteksti$(silm2); : PRINT TAB(tek + sij + 2); : COLOR rvari, pvari: PRINT " ≥"„        IF lteksti$(silm2) = "" THEN„                PRINT "√ƒ"; : REM COLOR tvari, pvari:„                FOR v = 1 TO tek: PRINT "ƒ"; : NEXT„                'PRINT lteksti$(silm2); : PRINT TAB(tek + sij + 2); :„                COLOR rvari, pvari: PRINT "ƒ¥"„        END IF„        NEXT„COLOR alkup, alkup2„LOCATE sij2 + rivit + 1, sij„COLOR rvari, pvari: PRINT "‘";„PRINT STRING$(tek + 2, "Õ");„PRINT "æ"„COLOR alkup, alkup2„„„„„„„FOR y% = 1 TO rivit + 1„        IF sij + tek + 4 <= 80 THEN„        x = SCREEN(sij2 + y%, sij + tek + 4):„        vari = SCREEN(sij2 + y%, sij + tek + 4, 1)„        COLOR 8, 0„        LOCATE sij2 + y%, sij + tek + 4„        PRINT CHR$(x)„        END IF„        IF sij + tek + 4 <= 80 THEN„        x = SCREEN(sij2 + y%, sij + tek + 5)„        vari = SCREEN(sij2 + y%, sij + tek + 5, 1)„        LOCATE sij2 + y%, sij + tek + 5„        COLOR 8, 0„        PRINT CHR$(x)„        END IF„NEXT„„FOR varjo% = 2 TO tek + 5„        IF sij + varjo% <= 80 THEN„        x = SCREEN(sij2 + rivit + 2, sij + varjo%)„        vari = SCREEN(sij2 + rivit + 2, sij + varjo%, 1)„        COLOR 8, 0„        LOCATE sij2 + rivit + 2, sij + varjo%„        PRINT CHR$(x)„        END IF„NEXT„„„„SCREEN 0, 1, 0, 0„„„laatikko3:„tek = 0„        FOR silm1 = 1 TO rivit„                FOR silm2 = 1 TO rivit„                IF LEN(lteksti$(silm2)) > tek THEN tek = LEN(lteksti$(silm2))„                NEXT„        NEXT„IF sij = 0 THEN sij = (40 - INT(tek / 2))„„sij2 = (12 - INT(rivit / 2))„„asij = sij: bsij = sij2: pisin = tek: arivi = rivit„ke = INT(tek / rivit)„„„„„„rivit = 1: tek = 1„        r = 300„DO„„„        IF tek = pisin AND rivit = arivi THEN EXIT DO„„        FOR s% = 1 TO ke„        IF tek < pisin THEN tek = tek + 1„„        NEXT„„        IF fiu = 1 THEN r = r + 50: SOUND r, 1„„„„        IF rivit < arivi THEN rivit = rivit + 1:„         „        „sij = (40 - INT(tek / 2))„sij2 = (12 - INT(rivit / 2))„„GOSUB piirtorutiini„„LOOP„„„ „„PCOPY 1, 0„„„'CALL MouseShow„„EXIT SUB„„„„„„„„„piirtorutiini:„„LOCATE sij2, sij„COLOR rvari, pvari: PRINT "’";„PRINT STRING$(tek + 2, "Õ");„PRINT "∏": COLOR alkup, alkup2„        FOR silm2 = 1 TO rivit„        LOCATE sij2 + silm2, sij„        PRINT ; : COLOR rvari, pvari:„        IF lteksti$(silm2) <> "" THEN„                PRINT "≥ "; : COLOR tvari, pvari:„                'PRINT lteksti$(silm2); :„                PRINT TAB(tek + sij + 2); :„                COLOR rvari, pvari: PRINT " ≥"„„        END IF„        IF lteksti$(silm2) = "" THEN„                PRINT "√ƒ"; : REM COLOR tvari, pvari:„                FOR v = 1 TO tek: PRINT "ƒ"; : NEXT„                'PRINT lteksti$(silm2); : PRINT TAB(tek + sij + 2); :„                COLOR rvari, pvari: PRINT "ƒ¥"„        END IF„        NEXT„COLOR alkup, alkup2„LOCATE sij2 + rivit + 1, sij„COLOR rvari, pvari: PRINT "‘";„PRINT STRING$(tek + 2, "Õ");„PRINT "æ"„COLOR alkup, alkup2„„RETURN„„„„END SUB„„DEFSNG A-X„'PiirtÑÑ Command barin ikkunat„SUB windows (rivit, sij, sij2, lteksti$(), rvari, pvari, tvari)„„'CALL MouseHide„PCOPY 0, 3„SCREEN 0, 1, 0, 3„„„laatikko2:„tek = 0„        FOR silm1 = 1 TO rivit„                FOR silm2 = 1 TO rivit„                IF LEN(lteksti$(silm2)) > tek THEN tek = LEN(lteksti$(silm2))„                NEXT„        NEXT„IF sij = 0 THEN sij = (40 - INT(tek / 2))„„LOCATE sij2, sij„COLOR rvari, pvari: PRINT "’";„PRINT STRING$(tek + 2, "Õ");„PRINT "∏": COLOR alkup, alkup2„        FOR silm2 = 1 TO rivit„        LOCATE sij2 + silm2, sij„        PRINT ; : COLOR rvari, pvari:„        IF lteksti$(silm2) <> "" THEN PRINT "≥ "; : COLOR tvari, pvari: PRINT lteksti$(silm2); : PRINT TAB(tek + sij + 2); : COLOR rvari, pvari: PRINT " ≥"„        IF lteksti$(silm2) = "" THEN„                PRINT "√ƒ"; : REM COLOR tvari, pvari:„                FOR v = 1 TO tek: PRINT "ƒ"; : NEXT„                'PRINT lteksti$(silm2); : PRINT TAB(tek + sij + 2); :„                COLOR rvari, pvari: PRINT "ƒ¥"„        END IF„        NEXT„COLOR alkup, alkup2„LOCATE sij2 + rivit + 1, sij„COLOR rvari, pvari: PRINT "‘";„PRINT STRING$(tek + 2, "Õ");„PRINT "æ"„COLOR alkup, alkup2„„„„„„„FOR y% = 1 TO rivit + 1„        IF sij + tek + 4 <= 80 THEN„        x = SCREEN(sij2 + y%, sij + tek + 4):„        vari = SCREEN(sij2 + y%, sij + tek + 4, 1)„        COLOR 8, 0„        LOCATE sij2 + y%, sij + tek + 4„        PRINT CHR$(x)„        END IF„        IF sij + tek + 4 <= 80 THEN„        x = SCREEN(sij2 + y%, sij + tek + 5)„        vari = SCREEN(sij2 + y%, sij + tek + 5, 1)„        LOCATE sij2 + y%, sij + tek + 5„        COLOR 8, 0„        PRINT CHR$(x)„        END IF„NEXT„„FOR varjo% = 2 TO tek + 5„        IF sij + varjo% <= 80 THEN„        x = SCREEN(sij2 + rivit + 2, sij + varjo%)„        vari = SCREEN(sij2 + rivit + 2, sij + varjo%, 1)„        COLOR 8, 0„        LOCATE sij2 + rivit + 2, sij + varjo%„        PRINT CHR$(x)„        END IF„NEXT„„„SCREEN 0, 1, 0, 0„„'CALL MouseShow„„END SUB„Mark Junker                    MBF TO IEEE CONVERSION         mjs@prg.hannover.sgh-net.de    10-25-97 (10:49)       QB, QBasic, PDS        108  2469     MBF.BAS     'here is a source that converts the MBF (Microsoft Binary Format) to the  „'local floating point representation (mostly IEEE). This may be needed by  „'some programmers working with old file formats ...„„' MBF.BAS - written by Mark Junker (mjs@prg.hannover.sgh-net.de)„'„' Shows how numbers in the MBF format can be decoded.„' QB/PDS source. PB uses must use MKMD$ and MKMS$„„DECLARE SUB PrintHexStr (a$)„DECLARE SUB PrintMBF (a$)„DEFINT A-Z„„CLS„„PRINT "nr", "HEX dump : "; "base", "exp", "val"„FOR a# = -1 TO 3 STEP .25„'FOR a# = -3 TO 3„  ' create MBF number:„  ' - MKDMBF$() for 8-byte values„  ' - MKSMBF$() for 4-byte values„  h$ = MKDMBF$(a#)„  PRINT a#,„  CALL PrintHexStr(h$)„  PRINT ; " : ";„  CALL PrintMBF(h$)„  PRINT„NEXT„„END„„SUB PrintHexStr (a$)„  ' print HEX dump„  FOR a = LEN(a$) TO 1 STEP -1„    PRINT RIGHT$(HEX$(256 + ASC(MID$(a$, a, 1))), 2);„  NEXT„END SUB„„SUB PrintMBF (a$)„  ' split all bytes for data into several bytes„  DIM b(0 TO 7)„  isNull = -1„  FOR a = 1 TO LEN(a$)„    b(a - 1) = ASC(MID$(a$, a, 1))„    isNull = isNull AND (b(a - 1) = 0)„  NEXT„„  IF isNull THEN„    ' special handling for NULL„    vExp = 0„    vBase# = 0„    vBaseSign = 0„„  ELSEIF LEN(a$) = 4 THEN„    ' single MBF value„„    ' 76543210 76543210 76543210 76543210„    ' eeeeeeee smmmmmmm mmmmmmmm mmmmmmmm„    '„    ' e = exponent + 129„    ' s = sign of value„    ' m = mantissa„„    vExp = b(3)„„    vBase# = b(0) + b(1) * 256& + (b(2) AND &H7F) * 65536„    vBase# = vBase# / ((256 ^ 3) / 2)„„    IF b(2) AND &H80 THEN vBaseSign = -1 ELSE vBaseSign = 1„    vExp = vExp - 129„  ELSE„    ' double MBF value„„    ' 76543210 76543210 76543210 76543210 76543210 76543210 76543210 76543210„    ' eeeeeeee smmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm„    '„    ' e = exponent + 129„    ' s = sign of value„    ' m = mantissa„„    vExp = b(7)„„    vBase# = 0„    FOR a = 0 TO 5„      vBase# = b(a) * 256 ^ a„    NEXT„    vBase# = vBase# + (b(6) AND &H7F) * 256 ^ 6„    vBase# = vBase# / ((256 ^ 7) / 2)„„    IF b(6) AND &H80 THEN vBaseSign = -1 ELSE vBaseSign = 1„    vExp = vExp - 129„  END IF„„  if isNull=0 then„    ' if not NULL then add implied 1 to mantissa„    vBase# = 1 + vBase#„  end if„„  PRINT vBase#, vExp,„„  IF isNull THEN„    result# = 0„  ELSE„    result# = (vBase# * 2 ^ vExp) * vBaseSign„  END IF„„  PRINT result#;„END SUB„