Brent Ashley                   POSTIT! 5.0 FOR VB/DOS         QBTIPS_I.DOC                   03-02-93 (15:50)       VBDOS                  815  22307    VBPOSTIT.BAS'I've rewritten the recent PostIt v4.0 for VB/DOS as v5.0.„'You will notice I have cleaned up the code considerably,„'imposing a consistent style, insulating modules from„'each other, eliminating global variables, and added a„'forms-based interface.„'„'I plan to finish a cleaned up QB version soon, too.„'„'Here is the make file for the project, called PI.MAK:„'„'POSTIT.FRM„'PROGRESS.FRM„„'In the following messages are the two files listed above.„„'Version 1.00„BEGIN Form frmPostit„  BackColor    = QBColor(3)„  BorderStyle  = 1„  Caption      = "PostIt!"„  ControlBox   = 0„  Height       = Char(18)„  Left         = Char(9)„  MaxButton    = 0„  MinButton    = 0„  Top          = Char(2)„  Width        = Char(51)„  BEGIN CommandButton cmdGo„    BackColor    = QBColor(3)„    Caption      = "&Do that PostIt magic!"„    Default      = -1„    Height       = Char(3)„    Left         = Char(0)„    TabIndex     = 16„    Top          = Char(13)„    Width        = Char(35)„  END„  BEGIN CommandButton cmdExit„    BackColor    = QBColor(3)„    Cancel       = -1„    Caption      = "E&xit"„    Height       = Char(3)„    Left         = Char(35)„    TabIndex     = 17„    Top          = Char(13)„    Width        = Char(14)„  END„  BEGIN Frame fraOpt„    BackColor    = QBColor(3)„    Caption      = "Options"„    Height       = Char(10)„    Left         = Char(24)„    TabIndex     = 8„    Top          = Char(3)„    Width        = Char(25)„    BEGIN Frame fraFmt„      BackColor    = QBColor(3)„      Caption      = "Format"„      Height       = Char(4)„      Left         = Char(1)„      TabIndex     = 13„      Top          = Char(4)„      Width        = Char(21)„      BEGIN OptionButton optFmt„        BackColor    = QBColor(3)„        Caption      = "&Text MsgSplit"„        Height       = Char(1)„        Index        = 1„        Left         = Char(1)„        TabIndex     = 15„        TabStop      = 0„        Top          = Char(1)„        Value        = 0„        Width        = Char(18)„      END„      BEGIN OptionButton optFmt„        BackColor    = QBColor(3)„        Caption      = "&Binary PostIt"„        Height       = Char(1)„        Index        = 0„        Left         = Char(1)„        TabIndex     = 14„        Top          = Char(0)„        Value        = -1„        Width        = Char(18)„      END„    END„    BEGIN Label lblRsvd„      BackColor    = QBColor(3)„      BorderStyle  = 0„      Caption      = "&Reserved Lns:"„      Height       = Char(1)„      Left         = Char(1)„      TabIndex     = 11„      Top          = Char(2)„      Width        = Char(14)„    END„    BEGIN TextBox txtRsvd„      BackColor    = QBColor(3)„      BorderStyle  = 1„      Height       = Char(1)„      Left         = Char(15)„      MultiLine    = 0„      TabIndex     = 12„      Text         = "3"„      Top          = Char(2)„      Width        = Char(7)„    END„    BEGIN Label lblLen„      BackColor    = QBColor(3)„      BorderStyle  = 0„      Caption      = "Page &Length:"„      Height       = Char(1)„      Left         = Char(1)„      TabIndex     = 9„      Top          = Char(0)„      Width        = Char(13)„    END„    BEGIN TextBox txtLen„      BackColor    = QBColor(3)„      BorderStyle  = 1„      Height       = Char(1)„      Left         = Char(15)„      MultiLine    = 0„      TabIndex     = 10„      Text         = "95"„      Top          = Char(0)„      Width        = Char(7)„    END„  END„  BEGIN CommandButton cmdSource„    BackColor    = QBColor(3)„    Caption      = "&Open..."„    Height       = Char(3)„    Left         = Char(40)„    TabIndex     = 2„    Top          = Char(0)„    Width        = Char(9)„  END„  BEGIN Frame fraOut„    BackColor    = QBColor(3)„    Caption      = "Output"„    Height       = Char(10)„    Left         = Char(0)„    TabIndex     = 3„    Top          = Char(3)„    Width        = Char(23)„    BEGIN Label lblExt„      BackColor    = QBColor(3)„      BorderStyle  = 0„      Caption      = "&Extension:"„      Height       = Char(1)„      Left         = Char(1)„      TabIndex     = 6„      Top          = Char(5)„      Width        = Char(11)„    END„    BEGIN Label lblPrefix„      BackColor    = QBColor(3)„      BorderStyle  = 0„      Caption      = "&Prefix:"„      Height       = Char(1)„      Left         = Char(1)„      TabIndex     = 4„      Top          = Char(2)„      Width        = Char(8)„    END„    BEGIN TextBox txtPrefix„      BackColor    = QBColor(3)„      BorderStyle  = 1„      Height       = Char(3)„      Left         = Char(9)„      MultiLine    = 0„      TabIndex     = 5„      Text         = "POSTIT"„      Top          = Char(1)„      Width        = Char(11)„    END„    BEGIN TextBox txtExt„      BackColor    = QBColor(3)„      BorderStyle  = 1„      Height       = Char(3)„      Left         = Char(12)„      MultiLine    = 0„      TabIndex     = 7„      Text         = "PIT"„      Top          = Char(4)„      Width        = Char(8)„    END„  END„  BEGIN Frame fraSource„    BackColor    = QBColor(3)„    Caption      = "&Source File:"„    Height       = Char(3)„    Left         = Char(0)„    TabIndex     = 0„    Top          = Char(0)„    Width        = Char(40)„    BEGIN TextBox txtSource„      BackColor    = QBColor(3)„      BorderStyle  = 0„      Height       = Char(1)„      Left         = Char(0)„      MultiLine    = 0„      TabIndex     = 1„      Text         = ""„      Top          = Char(0)„      Width        = Char(38)„    END„  END„END„'$FORM frmProgress„'$INCLUDE: 'constant.bi'„' Requires: CMNDLG.LIB/QLB„„'„' PostIt! - version 5.0 for VB/DOS„'„' this code is in the PUBLIC DOMAIN„'„'         *********************************************************„'         *      PostIt! THE Binary <-> BASIC Script Creator      *„'         *********************************************************„'                                   * * *„'„' Purpose:„'„'   To enable the posting of  compressed  listings  on a text only net.„'   This program takes a binary or BASIC input file and converts it to„'   a series of small, postable files which other people can capture„'   and run to get the original binary file.„'„' Credits:„'„'   PostIt! meaty bits by Rich Geldreich„'„'   MsgSplit meaty bits by Scott Wunsch and Victor Yiu„'„'   with mods by:„'                Jim Giordano„'                Mark H. Butler„'                Quinn Tyler Jackson„'„'   this VB/DOS version written by Brent Ashley March 1st, 1993„'„'   Changes include modularizing and clarifying, imposing„'   a consistent coding style, commenting, and speeding up„'   PostIt module with single buffer grab„'„„SUB cmdExit_Click ()„  ' pretty straightforward...„  END„END SUB„„SUB cmdGo_Click ()„  ' dir$ will crap out if given an invalid filename (i.e. ":" )„  ON LOCAL ERROR RESUME NEXT„  IF LEN(LTRIM$(txtSource.text)) = 0 THEN„    BEEP„    MSGBOX "You must choose a source file", 0, "Oops!"„  ELSEIF LEN(DIR$(txtSource.text)) = 0 THEN„    BEEP„    MSGBOX "The file `" + txtSource.text + "' doesn't exist", 0, "Oops!"„  ELSE„    ' all ok - do it„    LOAD frmProgress„  END IF„END SUB„„SUB cmdSource_Click ()„„  ' get filespec using common dialog„  CALL FileOpen(FileName$, PathName$, "*.*", "Choose Source File", 0, 7, 0, Cancel)„„  IF NOT Cancel THEN„    ' ensure trailing \„    IF RIGHT$(PathName$, 1) <> "\" THEN PathName$ = PathName$ + "\"„    ' check for file too big„    FileNum = FREEFILE„    OPEN PathName$ + FileName$ FOR BINARY AS #FileNum„    IF LOF(FileNum) > 24575& THEN„      m$ = "Sorry - that file is bigger than the 24k limit!"„      BEEP„      MSGBOX m$, 0, "Oops!"„      EXIT SUB„    END IF„„    ' analyse for binary or msgsplit„    Buf$ = SPACE$(32)„    GET #FileNum, , Buf$„    IsBinary = FALSE„    FOR I = 1 TO LEN(Buf$)„      SELECT CASE ASC(MID$(Buf$, I, 1))„        CASE 0 TO 8, 14 TO 31„          ' control codes„          IsBinary = TRUE„          EXIT FOR„        CASE 128 TO 178, 219 TO 255„          ' might be binary, might not„          HiAscii = HiAscii + 1„        CASE ELSE„          ' text ascii or linedraw„          ' passes through„      END SELECT„    NEXT„    ' set option according to analysed type„    IF IsBinary OR (HiAscii > 8) THEN„      optFmt(0).Value = TRUE„    ELSE„      optFmt(1).Value = TRUE„    END IF„„    ' assign filespec to text box„    txtSource.text = PathName$ + FileName$„„    ' extract prefix (first up to 6 chars of filename)„    DotPos = INSTR(FileName$, ".")„    IF DotPos THEN„      txtPrefix.text = LEFT$(LEFT$(FileName$, DotPos - 1), 6)„    ELSE„      txtPrefix.text = LEFT$(FileName$, 6)„    END IF„„    ' we've got a file - get ready to do it„    cmdGo.SETFOCUS„  END IF„„END SUB„„SUB Form_Load ()„  ' get source filename from command line„  FileSpec$ = COMMAND$„  IF LEN(DIR$(FileSpec$)) THEN„    txtSource.text = FileSpec$„„    ' extract base filename from input filename„    FileBase$ = ""„    FOR I = LEN(FileSpec$) TO 1 STEP -1„      ThisChar$ = MID$(FileSpec$, I, 1)„      SELECT CASE ThisChar$„        CASE "\", ":", " "„          EXIT FOR„        CASE ELSE„          FileBase$ = ThisChar$ + FileBase$„      END SELECT„    NEXT„„    ' extract prefix (first up to 6 chars of filename)„    DotPos = INSTR(FileBase$, ".")„    IF DotPos THEN„      txtPrefix.text = LEFT$(LEFT$(FileBase$, DotPos - 1), 6)„    ELSE„      txtPrefix.text = LEFT$(FileBase$, 6)„    END IF„„  END IF„„  ' set up border and title colours„  SCREEN.ControlPanel(ACTIVE_BORDER_BACKCOLOR) = CYAN„  SCREEN.ControlPanel(TITLEBAR_BACKCOLOR) = BLUE„  SCREEN.ControlPanel(TITLEBAR_FORECOLOR) = YELLOW„„  frmPostit.SHOW„  IF LEN(FileSpec$) = 0 THEN„    nl$ = CHR$(13) + CHR$(10)„    m$ = "           PostIt v5.0 for VB/DOS"„    m$ = m$ + nl$ + "                    ***" + nl$„    m$ = m$ + nl$ + "  PostIt by Rich Geldreich"„    m$ = m$ + nl$ + "  MsgSplit by Scott Wunsch and Victor Yiu  "„    m$ = m$ + nl$ + "  with mods by:"„    m$ = m$ + nl$ + "                Jim Giordano"„    m$ = m$ + nl$ + "                Mark H. Butler"„    m$ = m$ + nl$ + "                Quinn Tyler Jackson"„    m$ = m$ + nl$„    m$ = m$ + nl$ + "  VB/DOS version by Brent Ashley"„    m$ = m$ + nl$„    m$ = m$ + nl$ + "  PostIt! is in the PUBLIC DOMAIN"„    MSGBOX m$, 0, "Credits"„  END IF„END SUB„„SUB txtExt_Change ()„  ' save cursor position„  Cursor = txtExt.SelStart„  ' uppercase and limit to three chars„  txtExt.text = LEFT$(UCASE$(txtExt.text), 3)„  ' restore cursor position„  txtExt.SelStart = Cursor„END SUB„„SUB txtLen_KeyPress (KeyAscii AS INTEGER)„  ' limit to numbers„  SELECT CASE KeyAscii„    CASE ASC("0") TO ASC("9"), KEY_SPACE, KEY_DELETE, KEY_BACK„      'okiedokie„    CASE ELSE„      BEEP„      ' ignore key„      KeyAscii = 0„  END SELECT„END SUB„„SUB txtLen_LostFocus ()„  ' ensure valid Len value„  txtLen.text = LTRIM$(STR$(VAL(txtLen.text)))„  IF VAL(txtLen.text) > 99 THEN txtLen.text = "99"„  IF VAL(txtLen.text) < 3 THEN txtLen.text = "3"„END SUB„„SUB txtPrefix_Change ()„  ' save cursor position„  Cursor = txtPrefix.SelStart„  ' uppercase and limit to six characters„  txtPrefix.text = LEFT$(UCASE$(txtPrefix.text), 6)„  ' restore cursor position„  txtPrefix.SelStart = Cursor„END SUB„„SUB txtRsvd_KeyPress (KeyAscii AS INTEGER)„  ' limit to numbers„  SELECT CASE KeyAscii„    CASE ASC("0") TO ASC("9"), KEY_SPACE, KEY_DELETE, KEY_BACK„      'okiedokie„    CASE ELSE„      BEEP„      ' ignore key„      KeyAscii = 0„  END SELECT„END SUB„„SUB txtRsvd_LostFocus ()„  ' ensure valid Rsvd value„  txtRsvd.text = LTRIM$(STR$(VAL(txtRsvd.text)))„  IF VAL(txtRsvd.text) > 50 THEN txtRsvd.text = "50"„  IF VAL(txtRsvd.text) < 0 THEN txtRsvd.text = "0"„END SUB„„BEGIN Form frmProgress„  BackColor    = QBColor(3)„  BorderStyle  = 3„  Caption      = "Progress"„  ControlBox   = 0„  Height       = Char(14)„  Left         = Char(32)„  MaxButton    = 0„  MinButton    = 0„  Top          = Char(9)„  Width        = Char(40)„  BEGIN Label lblBar„    BackColor    = QBColor(3)„    BorderStyle  = 1„    Caption      = ""„    Height       = Char(3)„    Left         = Char(8)„    TabIndex     = 0„    Top          = Char(5)„    Width        = Char(27)„  END„  BEGIN Label lblPct„    BackColor    = QBColor(3)„    BorderStyle  = 0„    Caption      = "000%"„    Height       = Char(1)„    Left         = Char(2)„    TabIndex     = 1„    Top          = Char(6)„    Width        = Char(4)„  END„  BEGIN Label lblWrit„    BackColor    = QBColor(3)„    BorderStyle  = 0„    Caption      = "Now Writing File:"„    Height       = Char(1)„    Left         = Char(1)„    TabIndex     = 2„    Top          = Char(2)„    Width        = Char(18)„  END„  BEGIN Label lblCurFile„    BackColor    = QBColor(3)„    BorderStyle  = 1„    Caption      = ""„    Height       = Char(3)„    Left         = Char(20)„    TabIndex     = 3„    Top          = Char(1)„    Width        = Char(16)„  END„  BEGIN CommandButton cmdAbort„    BackColor    = QBColor(3)„    Cancel       = -1„    Caption      = "&Abort"„    Height       = Char(3)„    Left         = Char(11)„    TabIndex     = 4„    Top          = Char(9)„    Width        = Char(18)„  END„END„DECLARE FUNCTION ShowProgress% (Percent%, CurFile$)„DECLARE SUB MsgSplit (InFileName$, OutPrefix$, Ext$, LPP%, Reserve%, LineLength%)„DECLARE SUB PostIt (InFileName$, OutPrefix$, Ext$, LPP%, Reserve%, LineLength%)„„'$FORM frmPostit„'$INCLUDE: 'constant.bi'„DIM SHARED InProgress, Abort„„SUB cmdAbort_Click ()„  SHARED InProgress, Abort„„  ' button performs two functions - Abort or Exit„  IF InProgress THEN„    ' abort„    Abort = TRUE„  ELSE„    ' exit„    UNLOAD frmProgress„  END IF„END SUB„„SUB Form_Load ()„  SHARED InProgress, Abort„„  ' turn off underlying form controls„  frmPostit.Enabled = FALSE„„  ' get call parameters from control values„  InFileName$ = LTRIM$(RTRIM$(frmPostit.txtSource.text))„  OutPrefix$ = LTRIM$(RTRIM$(frmPostit.txtPrefix.text))„  Ext$ = LTRIM$(RTRIM$(frmPostit.txtExt.text))„  LPP = VAL(frmPostit.txtLen.text)„  Reserve = VAL(frmPostit.txtRsvd.text)„  LineLength = 72„„  ' show current form„  frmProgress.SHOW„„  ' do it„  InProgress = TRUE„  IF frmPostit.optFmt(0).Value THEN„    ' binary postit„    frmProgress.Caption = "Binary Postit"„    PostIt InFileName$, OutPrefix$, Ext$, LPP, Reserve, LineLength„  ELSE„    ' text msgsplit„    frmProgress.Caption = "Text MsgSplit"„    MsgSplit InFileName$, OutPrefix$, Ext$, LPP, Reserve, LineLength„  END IF„  BEEP„  InProgress = FALSE„„  ' show result on exit button„  IF Abort THEN„    cmdAbort.Caption = "Aborted - E&xit"„  ELSE„    cmdAbort.Caption = "Done - E&xit"„  END IF„END SUB„„SUB Form_Unload (Cancel AS INTEGER)„  ' re-enable main form controls„  frmPostit.Enabled = TRUE„  ' set focus to exit button„  frmPostit.cmdExit.SETFOCUS„  ' clear flag for further calls„  Abort = FALSE„END SUB„„SUB MsgSplit (InFileName$, OutPrefix$, Ext$, LPP, Reserve, LineLength)„„  ' initialize things„  Ver$ = "v5.0"„  Tab$ = CHR$(9)„  Quote$ = CHR$(34)„  Snip1$ = "______O_/_________________| SNIP |________________\_O_____"„  Snip2$ = "      O \                 | HERE |                / O"„  LinesOut = Reserve + 1„  FileOutNum = 1„  LPP = LPP - 4   ' lines per page„„  ' extract base filename from input filename„  InFileBase$ = ""„  FOR I = LEN(InFileName$) TO 1 STEP -1„    ThisChar$ = MID$(InFileName$, I, 1)„    SELECT CASE ThisChar$„      CASE "\", ":", " "„        EXIT FOR„      CASE ELSE„        InFileBase$ = ThisChar$ + InFileBase$„    END SELECT„  NEXT„„  ' open input file and get file length„  InFile = FREEFILE„  OPEN InFileName$ FOR INPUT AS #InFile„  FileLen = LOF(InFile)„„  DO„    ' build outfile name - use leading zeros so filenames sort properly„    OutN$ = OutPrefix$ + RIGHT$(STR$(100 + FileOutNum), 2) + "." + Ext$„„    OutFile = FREEFILE„    OPEN OutN$ FOR OUTPUT AS #OutFile„„    IF FileOutNum > 1 THEN„      PRINT #OutFile, "'>>> Start of page"; STR$(FileOutNum); " of "; InFileBase$„      PRINT #OutFile,„    ELSE„      PRINT #OutFile, Snip1$„      PRINT #OutFile, Snip2$„      PRINT #OutFile, "'This file created by PostIt! "; Ver$„      PRINT #OutFile, "'>>> Start of page"; STR$(FileOutNum); " of "; InFileBase$„      PRINT #OutFile,„    END IF„        PRINT #OutFile,„      END IF„„      CLOSE #OutFile„„      IF NOT EOF(InFile) THEN„        ' update counter„        FileOutNum = FileOutNum + 1„        LinesOut = 1„      END IF„„  LOOP UNTIL EOF(InFile)„„  ' show 100% if not aborted„  IF UserAbort = 0 THEN Dummy = ShowProgress(100, OutN$)„  CLOSE #InFile, #OutFile„„END SUB„„SUB PostIt (InFileName$, OutPrefix$, Ext$, LPP, Reserve, LineLength)„„  Ver$ = "v5.0"„„  ' initialization stuff„  DIM Shift(5)„  Shift(0) = 1„  Shift(1) = 2„  Shift(2) = 4„  Shift(3) = 8„  Shift(4) = 16„  Shift(5) = 32„„  LinesOut = LinesOut + 2„„  ValidChars$ = "abcdefghijklmnopqrstuvwxyz"„  ValidChars$ = ValidChars$ + "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789()"„„  Qt$ = CHR$(34)„  Prefix$ = "G" + Qt$„„  CurrentPage = 1„  Work$ = Prefix$„  CurrentBit = 0„  Char = 0„„  ' extract base filename from input filename„  InFileBase$ = ""„  FOR I = LEN(InFileName$) TO 1 STEP -1„    ThisChar$ = MID$(InFileName$, I, 1)„    SELECT CASE ThisChar$„      CASE "\", ":", " "„        EXIT FOR„      CASE ELSE„        InFileBase$ = ThisChar$ + InFileBase$„    END SELECT„  NEXT„„  ' Open input file„  InFile = FREEFILE„  OPEN InFileName$ FOR BINARY AS #InFile„  FileLen = LOF(InFile)„„  ' Open output file.„  F$ = OutPrefix$ + RIGHT$(STR$(100 + CurrentPage), 2) + "." + Ext$„  OutFile = FREEFILE„  'use 8k output buffer for a little speed„  OPEN F$ FOR OUTPUT AS #OutFile LEN = 8192„„  ' initialise progress with filename„  Dummy = ShowProgress(0, F$)„„  'Print the first 2 lines of the loader.„  PRINT #OutFile,"CLS:?STRING$(50,178):'This file created by PostIt! "; Ver$„  PRINT #OutFile, "DEFINT A-Z:FOR A=0 TO 6:P(A)=2^A:NEXT:OPEN "; Qt$; "B"; Qt$; ",1,"; Qt$; InFileBase$; Qt$„  PRINT #OutFile,"T$=";Qt$;"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789()"; Qt$„„  ' we've already determined the file is less than 24k„  ' so we'll assume there's enough string space to hold it„  Buf$ = SPACE$(FileLen)„  GET #InFile, , Buf$„„  FOR CurrentByte = 1 TO FileLen„    'shift the 8 bit character into the work buffer„    Char = Char + ASC(MID$(Buf$, CurrentByte, 1)) * Shift(CurrentBit)„„    'we've got 8 more bits now„    CurrentBit = CurrentBit + 8„„    'write the 6 bit codes now„    DO WHILE CurrentBit > 5         'do we have at least 6 bits left?„      GOSUB PutByte„      Char = Char \ 64              'shift it right 6 places„      CurrentBit = CurrentBit - 6  '6 bits less now„    LOOP„  NEXT„„  'flush the input buffer if it contains any bits„  IF CurrentBit > 0 THEN GOSUB PutByte„„  'flush the line buffer if it contains any characters„  'Add a CHR$(34) to it just in case a mail reader decides to add„  'some extra spaces to the end...„„  IF LEN(Work$) > 2 THEN„    TheLine$ = Work$ + Qt$„    GOSUB PrintLine„  END IF„„  ' main loader by Rich Geldreich with mods by Jim Giordiano„  TheLine$ = "N=" + LTRIM$(STR$(FileLen)) + ":K=255:IF LEN(C$)<>"„  TheLine$ = TheLine$ + LTRIM$(STR$(BytesOut)) + " THEN ?" + Qt$„  TheLine$ = TheLine$ + "Incomplete script file!" + Qt$ + ":BEEP:END"„  GOSUB PrintLine„„  TheLine$ = "FOR A=1 TO N:LOCATE 1:?STRING$(50*(A/N),177):IF L=0"„  TheLine$ = TheLine$ + " THEN GOSUB G:L=6"„  GOSUB PrintLine„„  TheLine$ = "W=T\P(6-L):GOSUB G:W=W OR T*P(L):L=L-2:B$=CHR$(W AND"„  TheLine$ = TheLine$ + " K):PUT 1,,B$:NEXT"„  GOSUB PrintLine„„  TheLine$="?:IF C<>" + LTRIM$(STR$(CheckSum)) + " THEN ?" + Qt$ + "Bad"„  TheLine$ = TheLine$ + " checksum!" + Qt$ + ":BEEP:END ELSE ?" + Qt$„  TheLine$ = TheLine$ + "Success!" + Qt$ + ":END"„  GOSUB PrintLine„„  TheLine$ = "G:I=I+1:T=INSTR(T$,MID$(C$,I,1))-1:C=(C+T)*2:C=C\256+(C"„  TheLine$ = TheLine$ + " AND K):RETURN"„  GOSUB PrintLine„„  TheLine$ = "SUB G(A$):SHARED C$:C$=C$+LEFT$(A$," + LTRIM$(STR$(LineLength - 2))„  TheLine$ = TheLine$ + "):END SUB"„  GOSUB PrintLine„„Finish:„  CLOSE #InFile, #OutFile„„  IF UserAbort = 0 THEN Dummy = ShowProgress(100, F$)„„  EXIT SUB„„PutByte:„  'write out the first 6 bits„  BytesOut = BytesOut + 1„„  TheByte = Char AND 63„  'translate the output character into something safe„  Work$ = Work$ + MID$(ValidChars$, TheByte + 1, 1)„„  'calculate a checksum on the encoded data stream„  CheckSum = (CheckSum + TheByte) * 2„  CheckSum = CheckSum \ 256 + (CheckSum AND 255)„„  'if we have a complete line then write it out„  IF LEN(Work$) = LineLength THEN„    TheLine$ = Work$„    GOSUB PrintLine„    IF UserAbort THEN GOTO Finish„    Work$ = Prefix$„  END IF„  RETURN„„PrintLine:„  UserAbort = ShowProgress(100& * CurrentByte \ FileLen, F$)„  ' don't just goto abort - we have to clean up gosub first„  IF UserAbort THEN RETURN„„  IF NewFileFlag THEN„    NewFileFlag = 0„    CurrentPage = CurrentPage + 1„    PRINT #OutFile, "'>>> Continued on Page "; CurrentPage„    CLOSE #OutFile„„    F$ = OutPrefix$ + RIGHT$(STR$(100 + CurrentPage), 2) + "." + Ext$„    OPEN F$ FOR OUTPUT AS #OutFile LEN = 8192„    PRINT #OutFile, "'>>> Start of Page "; CurrentPage; " of "; InFileBase$„    LinesOut = 1„  END IF„„  PRINT #OutFile, TheLine$; " "„  LinesOut = LinesOut + 1„  IF LinesOut >= LPP THEN NewFileFlag = -1„„  RETURN„„END SUB„„FUNCTION ShowProgress (Percent, CurFile$)„  SHARED Abort„„  ' update status display„  lblCurFile.Caption = CurFile$„  lblPct.Caption = STR$(Percent) + "%"„  lblBar.Caption = STRING$(Percent \ 4, 177)„„  ' return abort status (set TRUE in cmdAbort event)„  Dummy = DOEVENTS()„  ShowProgress = Abort„END FUNCTION„Rob Smetana                    HEX VIEWER                     Calvin French                  04-25-96 (21:10)       QB, QBasic, PDS        188  6813     HEXVIEW.BAS '>I guess I'll have to use QB to write a hex viewer to look at my„'>directory listings.  Then I'll be able to see if the first„„'    Calvin French has a hex viewer he posted here.  This is the„'    optimized code reposted by Rob Smetana.„„' Look for <rws> for some of the major changes.  A challenge to you:„'„' * Replace "Print" with a "quickprint" routine (Victor's FastPrint?).„' * Adapt this so one could "page" through huge files.„' * Add ScrollUp/ScrollDown options to this needn't re-paint„'   the entire screen each line down/up.  BIOS function 10h„'   services 6h/7h are easy to implement using Call Interrupt.„„DEFINT A-Z„DECLARE FUNCTION HexLine$ (Bytes$, FPtr%)  'replaces hvGetLinHex$„DECLARE FUNCTION YesOrNo% (Text$)„DECLARE FUNCTION CheckFile% (File$)„DECLARE SUB HexView (File$)„DECLARE SUB hvDrawScreen (File$)„DECLARE SUB hvInfoLine (Text$)„DECLARE FUNCTION hvCheckFile (File$)„DIM SHARED FLen AS LONG„DIM SHARED FPtr AS LONG         '...Use a long Calvin.  We don't„                                '   need this here, but ...„„c$ = COMMAND$                   '...QBASIC users remove this„„COLOR 15, 1: CLS„IF LEN(c$) = 0 THEN„  PRINT "HexView 1.0 by Calvin French"„  LINE INPUT "View which file:  "; File$„  IF LEN(File$) = 0 THEN END„ELSE„  File$ = c$„END IF„IF CheckFile(File$) = 0 THEN PRINT File$; " not found!": END„HexView File$„„FUNCTION CheckFile (File$)„    OPEN File$ FOR BINARY AS #1„    IF LOF(1) = 0 THEN„        CLOSE : KILL File$„    ELSE„    CLOSE : CheckFile = -1„    END IF„END FUNCTION„„FUNCTION HexLine$ (Bytes$, FPtr)„    SHARED FLen AS LONG„    '...<rws> Eliminate string creation/concatenation.„    DIM Lin AS STRING * 78, ThisChar AS STRING * 2, Temp AS STRING * 1„    LSET Lin = ""                   '...always start clean„    Offset = 2„    FOR x = 1 TO 16„        IF FPtr + x > FLen THEN EXIT FOR„        LSET Temp = MID$(Bytes$, FPtr + x - 1, 1)„        Tmp = ASC(Temp)„        '...<rws> If we use an ASM "QuickPrint" routine, the following„        '   wouldn't be necessary and we could display ALL chars.„        SELECT CASE Tmp„            CASE 7, 9 TO 13, 28 TO 31: LSET Temp = "."„        END SELECT„        MID$(Lin, 60 + x, 1) = Temp„        IF Tmp < 16 THEN            '...insist on 2-byte values„            LSET ThisChar = "0" + HEX$(Tmp)„        ELSE„            LSET ThisChar = HEX$(Tmp)„        END IF„        MID$(Lin, Offset, 2) = ThisChar„        IF x = 8 THEN„            Offset = Offset + 7„        ELSE„            Offset = Offset + 3„        IF (x MOD 2) = 0 THEN Offset = Offset + 1„        END IF„NEXT„HexLine$ = Lin„END FUNCTION„„SUB HexView (File$)„    FPtr = 1„    DIM LastFPtr AS LONG     '...you'll need LONG for large files„    '...<rws> Eliminate Keys$, etc.; use faster integer compares below.„    hvDrawScreen File$„    '...<rws> Calvin, "Len = 1" has no affect in Binary mode„    OPEN File$ FOR BINARY AS #1„    FLen = LOF(1)„    IF FLen > 32000 THEN FLen = 32000    '...keep it small here„    '...<rws> Eliminate slow, 2-byte GETs.  Do it in 1 gulp.„    Bytes$ = SPACE$(FLen): GET #1, , Bytes$: CLOSE„    '...<rws> No need to DIM Lines$(); just print HexLine$.„DO„    LOCATE , , 0: COLOR 15, 1„    '...<rws> Replace 3 loops with 1.„    '   Instead of checking LastFPtr <> FPtr inside For/Next,„    '   skip the entire loop and speed up the process.„    IF LastFPtr <> FPtr THEN„        FOR n = 0 TO 20„            LOCATE n + 3, 2„            PRINT HexLine$(Bytes$, FPtr + n * 16);„            LOCATE , 80:  PRINT CHR$(176);„        NEXT„    END IF„    LastFPtr = FPtr„    LOCATE 3 + (FPtr / FLen) * 21, 80: PRINT CHR$(178);„    LOCATE 24, 3: PRINT USING "*###########,*"; FPtr;„    LOCATE 2, 1, 1  '(distracting?) LOCATE 2, 1, 1, 0, 15„    DO: Key$ = INKEY$: LOOP UNTIL LEN(Key$)„    '...<rws> Use numeric compares for speed (since we thrash a lot).„    Ky = ASC(RIGHT$(Key$, 1)): IF LEN(Key$) = 2 THEN Ky = -Ky„    SELECT CASE Ky„    CASE -80, -77       '...Down/Right„        FPtr = FPtr + 16„    CASE -72, -75       '...Up/Left„        FPtr = FPtr - 16„    CASE 43, 61         '...plus/=„        FPtr = FPtr + 1„        IF FPtr > FLen - 1 THEN FPtr = FLen - 1„    CASE 45             '...minus„        FPtr = FPtr - 1„    CASE -73            '...PgUp„        FPtr = FPtr - 346„    CASE -81            '...PgDn„        FPtr = FPtr + 346„    CASE -79            '...End„        FPtr = FLen - 346„    CASE -71            '...Home„        FPtr = 1„    CASE 27, 113, 81    '...Esc, Q/q„        IF YesOrNo(" Exit program to DOS? ") THEN COLOR 7, 0: CLS : END„    END SELECT„    '...<rws> Do once instead of several times above.„    IF FPtr > FLen - 320 THEN FPtr = FLen - 320„    IF FPtr < 1 THEN FPtr = 1„LOOP„END SUB„„SUB hvDrawScreen (File$)    ' note line concantenation below!„COLOR 15, 4„PRINT " HexView v1.0 Hex Viewer                                 " + ""+"    Calvin French 1993 "„'...<rws>  Why print this in the main loop?„hvInfoLine "[Q]uit  [+,-]byte  [Up,Dn]line  [PgUp,PgDn]pages " + ""+" [Home,End]file"„COLOR 15, 1: LOCATE 2, 1: PRINT CHR$(254);„COLOR 15, 1: PRINT STRING$(77, 196); CHR$(180)„LOCATE 2, 40 - (LEN(File$) + 2) \ 2: PRINT CHR$(180);„COLOR 15, 3: PRINT " "; UCASE$(LTRIM$(RTRIM$(File$))); " ";„COLOR 15, 1: PRINT CHR$(195)„'...<rws> Needn't print chr$(176); we'll do it later.„FOR n = 3 TO 23: PRINT CHR$(179): NEXT„PRINT CHR$(192); STRING$(77, 196); CHR$(180);„'...<rws> Eliminate DEG SEG approach (why limit to color monitors?)„COLOR 0, 7„LOCATE 2, 80: PRINT CHR$(24);„LOCATE 24, 80: PRINT CHR$(25);„END SUB„„SUB hvInfoLine (Text$)„    LOCATE 25, 1: COLOR 15, 3: PRINT SPACE$(80);„    LOCATE 25, 40 - LEN(Text$) \ 2: PRINT Text$;„END SUB„„FUNCTION YesOrNo (Text$)„    PCOPY 0, 1„    x1 = 40 - LEN(Text$) \ 2: x2 = 40 + LEN(Text$) \ 2„    a$ = SPACE$(x2 - x1 + 8)„    COLOR 14, 4: LOCATE 9, x1 - 4„    PRINT CHR$(218); STRING$(x2 - x1 + 8, 196); CHR$(191)„    LOCATE , x1 - 4: PRINT CHR$(179); a$; CHR$(179)„    LOCATE , x1 - 4: PRINT CHR$(179); a$; CHR$(179)„    LOCATE , x1 - 4: PRINT CHR$(179); a$; CHR$(179)„    LOCATE , x1 - 4„    PRINT CHR$(192); STRING$(x2 - x1 + 8, 196); CHR$(217);„    COLOR 8, 0„    FOR n = x1 - 2 TO x2 + 7„        LOCATE 14, n: PRINT CHR$(SCREEN(14, n));„    NEXT„    FOR n = 10 TO 14„        LOCATE n, x2 + 6: PRINT CHR$(SCREEN(n, x2 + 6));„        LOCATE , x2 + 7: PRINT CHR$(SCREEN(n, x2 + 7));„    NEXT„    COLOR 15, 4: LOCATE 11, x1: PRINT Text$; " ";„    COLOR 14, 0: PRINT "N"; CHR$(29);„    LOCATE , , 1, 14, 15: DO: Key$ = INKEY$: LOOP UNTIL LEN(Key$)„    '...<rws> Eliminate duplicitous & unneeded code.„    IF UCASE$(Key$) = "Y" THEN YesOrNo = -1„    PCOPY 1, 0„END FUNCTION„Dave Navarro, Jr.              HEX/DECIMAL/BINARY CONVERSIONS dave@powerbasic.com            05-01-96 (19:28)       PB                     58   1465     HEXCONV.BAS '=============================================================================„'                   Source code snippet: PowerBASIC for DOS„'„'           Author: Dave Navarro, Jr. (dave@powerbasic.com)„' Copyright status: Public Domain„'„' Various hex, decimal, and binary conversion routines.„'„'=============================================================================„„' Return the value of a hex string„FUNCTION HexVal(BYVAL h AS STRING) AS INTEGER„„  FUNCTION = VAL( "&H" + h )„„END FUNCTION„„' Return the value of a binary string„FUNCTION BinVal(BYVAL b AS STRING) AS INTEGER„„  FUNCTION = VAL( "&B" + h )„„END FUNCTION„„' Convert a hex string to a binary string„FUNCTION HexToBin(BYVAL h AS STRING) AS STRING„„  FUNCTION = BIN$( HexVal( h ) )„„END FUNCTION„„' Convert a binary string to a hex string„FUNCTION BinToHex(BYVAL b AS STRING) AS STRING„„  FUNCTION = HEX$( HexBin( b ) )„„END FUNCTION„„' Return a hex string padded to 4 places„FUNCTION Hex4(BYVAL n AS INTEGER) AS STRING„„  FUNCTION = RIGHT$("0000" + HEX$(n), 4)„„END FUNCTION„„' Return a binary string padded to 16 places„FUNCTION Bin16(BYVAL n AS INTEGER) AS STRING„„  FUNCTION = RIGHT$("0000000000000000" + BIN$(n), 16)„„END FUNCTION„„' Return a decimal string padded to 'n' places„FUNCTION StrN(BYVAL n AS SINGLE, BYVAL places AS INTEGER) AS STRING„„  FUNCTION = RIGHT$(STRING$(places, "0") + MID$(STR$(n), 2), places)„„END FUNCTION„Luis Espinoza                  BIT MANIPULATION FUNCTIONS     FidoNet QUIK_BAS Echo          07-13-92 (00:00)       QB, QBasic, PDS        97   3265     SHIFTBIT.BAS'> > Ok, this is an extremely useful internal PB command, one of many„'> > such as shift right, shift left, bit toggle, and so forth which„'> > obviously affects bits of bytes.  In my code, the background [...]„'>„'> I'll give some thought to shift right this„'> afternoon and see what I come up with.„„'Follows are a few bit manipulation FUNCTIONs posted by Luis Espinoza„'here a few years ago - they include FUNCTIONs LShift%() and RShift%()„'which I believe are the equivalent of the SHIFTR/SHIFTL:„„DEFINT A-Z„„DECLARE FUNCTION LShift% (Byte%, Bits%)„DECLARE FUNCTION ReadBit% (Byte%, Bit%)„DECLARE FUNCTION ResetBit% (Byte%, Bit%)„DECLARE FUNCTION RShift% (Byte%, Bits%)„DECLARE FUNCTION SetBit% (Byte%, Bit%)„DECLARE FUNCTION ToggleBit% (Byte%, Bit%)„„'***********************************************************************„'* FUNCTION LShift%„'*„'* PURPOSE„'*    Shifts Byte% left by specified number of Bits%.„'*„'* CREDIT(S)„'*    Luis Espinoza, RIME QuickBASIC conference, 07-13-92.„'***********************************************************************„FUNCTION LShift% (Byte%, Bits%) STATIC„   LShift% = (Byte% * (2 ^ Bits%)) MOD 256„END FUNCTION„„'***********************************************************************„'* FUNCTION ReadBit%„'*„'* PURPOSE„'*    Returns bit specified by Bit% (0-7) in Byte% (0-32767).„'*„'* CREDIT(S)„'*    Luis Espinoza, RIME QuickBASIC conference, 07-04-92.„'***********************************************************************„FUNCTION ReadBit% (Byte%, Bit%) STATIC„   ReadBit% = ABS(((2 ^ (Bit%)) AND Byte%) > 0)„END FUNCTION„„'***********************************************************************„'* FUNCTION ResetBit%„'*„'* PURPOSE„'*    Resets the bit in Byte% specified by Bit%.„'*„'* CREDIT(S)„'*    Luis Espinoza, RIME QuickBASIC conference, 07-13-92.„'***********************************************************************„FUNCTION ResetBit% (Byte%, Bit%) STATIC„   ResetBit% = Byte% AND (255 - (2 ^ Bit%))„END FUNCTION„„'***********************************************************************„'* FUNCTION RShift%„'*„'* PURPOSE„'*    Shifts Byte% right by specified number of Bits%.„'*„'* CREDIT(S)„'*    Luis Espinoza, RIME QuickBASIC conference, 07-13-92.„'***********************************************************************„FUNCTION RShift% (Byte%, Bits%) STATIC„   RShift% = Byte% \ (2 ^ Bits%)„END FUNCTION„„'***********************************************************************„'* FUNCTION SetBit%„'*„'* PURPOSE„'*    Sets the bit in Byte% specified by Bit%.„'*„'* CREDIT(S)„'*    Luis Espinoza, RIME QuickBASIC conference, 07-13-92.„'***********************************************************************„FUNCTION SetBit% (Byte%, Bit%) STATIC„   SetBit% = Byte% OR (2 ^ Bit%)„END FUNCTION„„'***********************************************************************„'* FUNCTION ToggleBit%„'*„'* PURPOSE„'*    Toggles the bit in Byte% specified by Bit%.„'*„'* CREDIT(S)„'*    Luis Espinoza, RIME QuickBASIC conference, 07-13-92.„'***********************************************************************„FUNCTION ToggleBit% (Byte%, Bit%) STATIC„   ToggleBit% = Byte% XOR (2 ^ Bit%)„END FUNCTION„Martin Lindhe                  COUNTING BINARY NUMBERS        m-35728@mailbox.swipnet.se     06-08-96 (12:44)       QB, QBasic, PDS        21   650      BINARY.BAS  ' Here is a algoritm for counting binary numbers.„„' 128 64 32 16 8 4 2 1      ; this is the numbers used„'   1  0  0  1 1 0 0 1      ; and here is the binary number„' 128 + 16 + 8 + 1 = 153    ; if you add the numbers above the 1's you„'                           ; will get the correct ascii number.„' That means: 10011001 = 153„„' This routine was written by Martin Lindhe, contact me with e-mail at„' m-35728@mailbox.swipnet.se„„Tmp = 1„Bin$ = "10011001"„„FOR a = LEN(Bin$) TO 1 STEP -1„    Temp$ = MID$(Bin$, a, 1)„    IF Temp$ = "1" THEN Answer = Answer + Tmp„    Tmp = Tmp * 2„NEXT„PRINT Bin$; " is"; Answer; "in ascii."„„Steve Harmon                   POSTIT! VERSION 7.3            sharmon@shelbynet.net          06-14-96 (15:15)       QB, QBasic, PDS        1227 49571    POSTIT73.BASDEFINT A-Z„'--- PostIt! subroutines.„DECLARE SUB ParseCmdLine (cmd$, Params$(), Found%)„DECLARE SUB SepPath (a$, Drive$, path$, tName$)„DECLARE FUNCTION Decode% (oSwitch%, InSpec$, OutSpec$)„DECLARE FUNCTION Encode% (Op%, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InSpec$, OutSpec$)„DECLARE SUB ExpandLine (a$, Lines$(), LineLength%, NumLines%)„DECLARE FUNCTION FASC% (a$)„DECLARE FUNCTION GrabNum& (a$, Lower&, Upper&, Default&)„DECLARE FUNCTION UnTab$ (b$, TabStops%)„'--- ImportIt! subroutines.„DECLARE SUB ImportIt (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference%)„DECLARE SUB CreateRep (BBSID$, ArcCommand$)„DECLARE SUB AddToRep (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference%, ErrorCode$)„DECLARE SUB IIParse (cmd$, toname$, fromname$, conference%, BBSID$)„'„' --- beta test release --- released by Calvin French, August 1993 ---„'„' This SHOULD work perfectly. Please test it, tangle it, and report any„' bugs you find in it to Victor, Me, or (lastly only because he is very„' very busy), Rich.„'„' - Calvin -„'„' --------------------------------------------------------------------„'„' PostIt! v7.2 Script Encoder/Decoder-Public Domain-August 1993„' By Rich Geldreich & Victor Yiu. Many  contributions,   fixups,  and„' features by Mark H. Butler,  Quinn Tyler Jackson, and Scott Wunsch.„' QWK compatable .REP file support by Calvin French.„' Decoding instructions in header by Steve Harmon.„'„' PostIt! can  encode   any  binary   file  into  a  series  of self-„' extracting  script  files  that  can  be  reliably  distributed  on„' text-only  conferences  or  networks.   The  script  files  can  be„' extracted with  this  program,  or  with  any  Microsoft QuickBASIC„' language (DOS 5's QBASIC, QB4.5, PDS, VB-DOS) because  each  script„' contains its own small QuickBASIC decoder.„'„' PostIt!   can  also  format  QuickBASIC  source  code  suitable for„' distribution on conferences, and reconstruct source code  formatted„' by  this  program.   This  allows  QuickBASIC programmers to easily„' exchange BASIC source code without worrying about the annoying line„' length and message limitations of most networks.„'„' ImportIt!, a new part of PostIt!, can toss the output files created„' by PostIt! into a QWK compatable .REP file.„'„' New 7.3 Features:„'„' o  Added decoding instructions to the header.„'„' New 7.2 Features:„'„' o  QWK  compatable  .REP file support  has been  included! No  more„'    importing tons of files into your reply packets via your offline„'    mail reader!„'„' New 7.1 Features:„'„' o  Totally rewritten source code!„' o  Much  more efficient  encoding algorithm (MOD 86 encoding)  with„'    a smaller and faster self extractor!„' o  Huge binary scripts now supported, up to 150k!„' o  The  script decoding & unfiltering functions  are now automated!„'    As  long  as a few  simple rules are followed (see the  notes on„'    the Decode command), no  user intervention  is needed to extract„'    multiple scripts from the same capture file.„' o  PostIt!  is  finally  a command line utility! Error codes can be„'    returned  to batch  files if  you're compiling   with  VBDOS  or„'    QBX.   Look  at the source to  find out  which error  code means„'    which.„' o  The format of PostIt!'s   message  headers has finally been well„'    thought out and (hopefully) finalized.  Although   compatibility„'    with  previous versions of PostIt!  has been sacrificed, scripts„'    created by  newer versions  of  PostIt!   should be decodable by„'    this version because of a common message header format.„'„' Explanation of Commands„'„' E = Encodes  any binary  file less than 150k into a self-extracting„'     text-only script.  If the -s  option is used with this command,„'     the entire script will be written to one output file; otherwise„'     the script will be split into multiple output files, where each„'     output file contains one message.   (Note:  Scripts created  by„„'     this  command  cannot  be  extracted  by  previous  versions of„'     PostIt!.)„'„' F = Filters QuickBASIC source code for  posting  on  a  conference.„'     This  command  actually  performs  two filtering functions.  It„'     splits very long  lines  with  continuation characters (special„'     precautions are taken to ensure  quoted strings and remarks are„'     split correctly), and chops the source code into multiple files„'     so each file corresponds to one message  (unless the -s  option„'     is used).The filtered file can still be executed or compiled by„'     QuickBASIC, just as the original could.  (Note: DATA statements„'     split by filtering cannot be unsplit correctly by QB! This will„'     hopefully  be fixed  soon...   Files  filtered  by this command„'     cannot by unfiltered by previous versions of PostIt!.)„'„' D = Decodes binary/text scripts.  Multiple scripts can  be  decoded„'     from the same  input  file  with  this  function.  The decoding„'     algorithm  automatically  decides  which  method  was  used  to„'     encode the source file(binary script or source code filtering).„'„'     If  any  errors  are  encountered during decoding the script is„'     skipped  and the  partly decoded  file is deleted.„'„'     Binary and text scripts created by previous versions of PostIt!„'     cannot be decoded with this command, because of the new  header„'     format employed by this version of PostIt!.„'„'     (Notes:  Pages of a script MUST appear in increasing order.  In„'     other words, page 2 must follow page 1, page 3 must follow page„'     2, etc.  When posting  files  created  by  the E or F commands,„'     don't modify or remove the message headers because the decoding„'     algorithm expects these to indicate the beginning and ending of„'     each page.  (All message headers begin with a "'>>>" sequence.)„'     Finally, if an output file is specified on  the  command  line,„'     for  example "POSTIT D capture.txt c:\q\coolcode.zip", only the„'     specified output file  (COOLCODE.ZIP  in  the  example) will be„'     decoded if its script can be  located.   The  pathname  of  the„'     output  file  will  be  the  destination  path specified on the„'     command line.  In the  example,  the  file COOLCODE.ZIP will be„'     written to the C:\Q directory.)„'„' -Q  This  switch  will cause  PostIt!  to invoke  ImportIt!, a  new„'     feature available with version 7.2. ImportIt! will toss all the„'     files that PostIt! creates  into a QWK compatable reply  packet„'     (.REP file.) You  MUST specify  at least three  more paramaters„'     for this capability, however. They are:„'„'     [to:to_name] (optional)„'     This is the name that you would like in the "to" field (who you„'     are sending the message to.)  If it is not specified, ImportIt!„'     will substitute the name "ALL".„'„'     from:from_name„'     This is the name that you would like in the "from" field (which„'     is, more often than not, your own name)„'„'     NOTE: With  both names, if a  space is needed, use a period  in„'     the command  line (e.g.,  to:Victor.Yiu from:Calvin.French) and„'     ImportIt! will translate it to a space.„'„'     conf:conf_number„'     This is the number of the  FidoNet echomail conference that you„'     would like the  the messages to be  tossed into. This is really„'     the only very important  thing you need to remember in order to„'     use  ImportIt!  NOTE:  This  is NOT  the  NAME of the  echomail„'     conference (e.g., QUIK_BAS), but  rather the NUMBER (e.g., 32).„'     It should also  be mentioned that  sometimes this number is not„'     the same number as may appear  on your BBS's Message Base list.„'     It is suggested that  you check this  number carefully via your„'     offline  mail reader  as the  wrong  number will  toss  all the„'     messages into the wrong area.„'„'     bbsid:BBSID„'     This is  the BBS  identification  name of the  BBS you will  be„'     uploading  your  reply  packet  to.  According  to  the  naming„'     conventions outlined in the QWK format (version 1.6), this will„'     be the file name (not including the extention) of your .QWK and„'     .REP file  (QWK mail packet and reply  packet).  ImportIt! will„'     use this name to access the reply packet, so it is important to„'     get it right.„'„' Completely Stupid and Irrelevant Examples for the Average Fool„'„' postit e maim.zip -p95 -b20 c:\scripts\mc„' (Encodes a binary script of MAIM.ZIP. All output file(s) are written„'  to the C:\SCRIPTS directory and begin with the "MC" suffix. The„'  message length is 95 lines, and 20 blank lines are reserved on the„'  first message.)„' postit -a f x-ray.bas -o -s„' (Filters the file X-RAY.BAS for posting. All blank lines are padded„'  with a space, no prompting is done for file overwrites, and no„'  message splitting is performed.)„' postit d zebra.txt q\„' (Decodes all scripts from the file ZEBRA.TXT to the Q directory.)„' postit e graphics.zip -p95 -b0 -q to:You from:Me conf:32 bbsid:MYBBS„' (Encodes a binary script of GRAPHICS.ZIP. Output files are then„'  attached, or rather merged into MYBBS.REP. The messages will be from„'  YOU to ME in fidonet conference are #32. If to: was not specified,„'  it would be from YOU to ALL.) Tip: Since ImportIt! tosses files„'  directly into the .REP file, there is usually no need to reserve„'  blank lines on the first message.„'„TYPE MsgHeaderType„  Status          AS STRING * 1„  ConfNumASCII    AS STRING * 7„  MsgDate         AS STRING * 8„  MsgTime         AS STRING * 5„  ToField         AS STRING * 25„  FromField       AS STRING * 25„  SubjectField    AS STRING * 25„  PassWord        AS STRING * 12„  MsgRefNumber    AS STRING * 8„  NumBlocks       AS STRING * 6„  Flag            AS STRING * 1„  ConfNum         AS INTEGER          ' should be UNSIGNED INTEGER„  PacketMsgNumber AS STRING * 2„  NetworkTag      AS STRING * 1„END TYPE„' change the following to the name of the archiver you would like„' to use. Must be ZIP, ARJ or LHA„CONST PreferredArchiveMethod$ = "ZIP"„'CONST PreferredArchiveMethod$ = "ARJ"„'CONST PreferredArchiveMethod$ = "LHA"„DIM SHARED OutPutFile$(1 TO 256)„DEFINT A-Z„CONST true = -1, false = 0, Debug% = false„DIM SHARED GERR%: ON ERROR GOTO ErrHandler„LOCATE , , 1„PRINT "PostIt! v7.3 QuickBASIC Compatible Encoder/Decoder"„PRINT "Public Domain by Rich Geldreich and Victor Yiu"„PRINT„IF FRE(-1) < 65536 THEN ErrLvl% = 1: PRINT "Not enough memory": GOTO AllDone„DIM Params$(1 TO 10)„'The following line must be modified for DOS 5 QBASIC.„ParseCmdLine COMMAND$, Params$(), NumParams%„IF NumParams% = 0 THEN ErrLvl% = 2: GOTO ShowHelp„FOR I% = 1 TO NumParams%„  q$ = Params$(I%)„  IF LEFT$(q$, 1) <> "-" AND LEN(q$) = 1 THEN„    Command% = INSTR("EFD", q$)„    IF Command% <> 0 THEN„      Params$(I%) = "": EXIT FOR„    ELSE„      PRINT "Bad command: "; q$: PRINT : ErrLvl% = 3: GOTO ShowHelp„    END IF„  END IF„NEXT„IF Command% = 0 THEN PRINT "No command specified.": PRINT : ErrLvl% = 4: GOTO ShowHelp„IF Command% = 2 THEN DefaultLineLength% = 72 ELSE DefaultLineLength% = 65„sSwitch% = false: pSwitch% = 85: lSwitch% = DefaultLineLength%„tSwitch% = 4: oSwitch% = false: bSwitch% = 0: aSwitch% = false„iSwitch% = false: cSwitch% = false: qSwitch = 0„FOR I% = 1 TO NumParams%„  q$ = Params$(I%): Z$ = MID$(q$, 3)„  IF LEN(q$) THEN„    IF LEFT$(q$, 1) = "-" OR LEFT$(q$, 3) = "TO:" OR LEFT$(q$, 5) = "FROM:" OR LEFT$(q$, 5) = "CONF:" OR LEFT$(q$, 6) = "BBSID:" THEN„      IF LEFT$(q$, 3) <> "TO:" AND LEFT$(q$, 5) <> "FROM:" AND LEFT$(q$, 5) <> "CONF:" AND LEFT$(q$, 6) <> "BBSID:" THEN„        SELECT CASE MID$(q$, 2, 1)„          CASE "S": sSwitch% = true„          CASE "P": pSwitch% = GrabNum&(Z$, 45, 1000, 85)„          CASE "L": lSwitch% = GrabNum&(Z$, 60, 80, CLNG(DefaultLineLength%))„          CASE "T": tSwitch% = GrabNum&(Z$, 1, 8, 4)„          CASE "O": oSwitch% = true„          CASE "B": bSwitch% = GrabNum&(Z$, 0, 30, 0)„          CASE "A": aSwitch% = true„          CASE "I": iSwitch% = true„          CASE "C": cSwitch% = true„          CASE "Q"„            qSwitch% = true„            IIParse COMMAND$, toname$, fromname$, conference%, BBSID$„            qError$ = ""„            IF fromname$ = "" THEN„              qError$ = "From name not specified! "„            ELSEIF conference% = 0 THEN„              qError$ = qError$ + "Conference not specified! "„            ELSEIF BBSID$ = "" THEN„              qError$ = qError$ + "BBSID not specified! "„            END IF„            IF qError$ <> "" THEN„              PRINT LTRIM$(qError$)„              ErrLvl = 3„              qSwitch = false„              GOTO ShowHelp„            END IF„          CASE ELSE: PRINT "Bad switch: "; q$: PRINT : ErrLvl% = 3: GOTO ShowHelp„        END SELECT„      END IF„    ELSE„      SELECT CASE J%„      CASE 0: InputSpec$ = q$„      CASE 1: OutputSpec$ = q$„      CASE ELSE: PRINT "Too many filenames.": PRINT : ErrLvl% = 5: GOTO ShowHelp„      END SELECT: J% = J% + 1„    END IF„  END IF„NEXT„IF J% < 1 THEN PRINT "Must specify input file.": PRINT : ErrLvl% = 5: GOTO ShowHelp„SepPath InputSpec$, InputDrive$, InputPath$, InputName$„IF INSTR(InputName$, ".") = 0 THEN„  IF Command% = 1 THEN     'encoding  .ZIP„    InputSpec$ = InputSpec$ + ".ZIP"„  ELSEIF Command% = 2 THEN 'filtering .BAS„    InputSpec$ = InputSpec$ + ".BAS"„  ELSEIF Command% = 3 THEN 'decoding  .TXT„    InputSpec$ = InputSpec$ + ".TXT"„  END IF„ELSE„  IF Command% = 1 THEN„    SELECT CASE MID$(InputName$, INSTR(InputName$, ".") + 1, 3)„    CASE "ZIP", "LZH", "ARJ", "GIF", "SQZ", "ZOO", "ARC", "HAP", "JPG"„    CASE ELSE: PRINT "Warning: Uncompressed files should not be" + " encoded" + " into binary scripts!": PRINT„  END SELECT„  END IF„END IF„OPEN InputSpec$ FOR INPUT AS #1: CLOSE #1„IF GERR% THEN PRINT "Can't open "; InputSpec$: ErrLvl% = 6: GOTO AllDone„SepPath OutputSpec$, OutDrive$, OutPath$, OutName$„TestFile$ = OutDrive$ + OutPath$ + "pi742875.2yz"„OPEN TestFile$ FOR OUTPUT AS #1: CLOSE #1„IF GERR% THEN PRINT "Bad output specification.": ErrLvl% = 7: GOTO AllDone„KILL TestFile$„SELECT CASE Command%„CASE 1: Status% = Encode%(0, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InputSpec$, OutputSpec$)„CASE 2: Status% = Encode%(1, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InputSpec$, OutputSpec$)„CASE 3: Status% = Decode%(oSwitch%, InputSpec$, OutputSpec$)„END SELECT„IF Status% < 0 THEN ErrLvl% = 8 ELSE IF Status% > 0 THEN ErrLvl% = 9 ELSE ErrLvl% = 0„GOTO AllDone„ShowHelp:„PRINT "Usage: POSTIT [switch] command inputfile [outputfile] [-q" + " options]"„PRINT„PRINT "Commands:"„PRINT "e [E]ncode any file <150k into a self extracting binary script"„PRINT "f [F]ilter QB source into a text script"„PRINT "d [D]ecode captured text or binary script(s)"„PRINT„PRINT "Switches:"„PRINT "-s  Don't split output file into multiple messages"„PRINT "-o  Don't prompt for file overwrites"„PRINT "-b# Reserve # blank lines on first message (0-30, default=0)"„PRINT "-t# Set tab stops to # characters (1-8, default=4)"„PRINT "-l# Set line length to # characters (60-80, default=65 or 72)"„PRINT "-p# Set message length to # lines (45-1000, default=85)"„PRINT "-a  Padd blank lines with a space when filtering"„PRINT "-i  Ignore blank lines when filtering"„PRINT "-c  Crush space characters from start of lines when filtering"„PRINT„PRINT "ImportIt! (QWK compatable .REP file support):"„PRINT "-q [to:to_name] from:from_name conf:conf_num bbsid:BBSID"„AllDone:„IF qSwitch = true THEN„  IF GERR < 0 THEN„    IF Debug% THEN PRINT "Exiting with an errorlevel of"; ErrLvl%„    END„  END IF„  FOR n = 1 TO 256„    a$ = OutPutFile$(n)„    IF a$ = "" THEN EXIT FOR„  NEXT n„  NumFiles = n - 1„  DIM MsgFiles$(1 TO NumFiles)„  FOR n = 1 TO NumFiles„    MsgFiles$(n) = OutPutFile$(n)„  NEXT n„  FOR n = LEN(InputSpec$) TO 1 STEP -1„    IF MID$(InputSpec$, n, 1) = "\" THEN StartFname = n + 1„  NEXT n„  IF StartFname <> 0 THEN„    TitleFile$ = MID$(InputSpec$, StartFname, 1)„  ELSE„    TitleFile$ = InputSpec$„  END IF„  FOR n = 1 TO LEN(toname$)„    IF MID$(toname$, n, 1) = "." THEN MID$(toname$, n, 1) = " "„  NEXT n„  FOR n = 1 TO LEN(fromname$)„    IF MID$(fromname$, n, 1) = "." THEN MID$(fromname$, n, 1) = " "„  NEXT n„  ImportIt BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference%„END IF„IF Debug% THEN PRINT "Exiting with an errorlevel of"; ErrLvl%„END„ErrHandler: GERR% = ERR„  IF Debug% THEN IF GERR% <> 53 THEN PRINT "Global error #"; GERR%„RESUME NEXT„„SUB AddToRep (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference, ErrorCode$)„  DIM MsgHeader     AS MsgHeaderType„  DIM QWKRecBuff    AS STRING * 128„  DIM QWKByteBuff   AS STRING * 1„  DIM ArcHeader     AS STRING * 3„  ' test for file„  OPEN BBSID$ + ".REP" FOR BINARY AS #1„  IF LOF(1) = 0 THEN„    CLOSE #1„    KILL BBSID$ + ".REP"„    ErrorCode$ = "Reply packet (.REP file) not found!"„    EXIT SUB„  END IF„  ' test for messages„  NumMessages = UBOUND(MsgFiles$)„  IF NumMessages = 0 THEN„    CLOSE #1„    ErrorCode$ = "No files to add to reply (.REP) packet!"„    EXIT SUB„  END IF„  ' check ToName$„  IF toname$ = "" THEN„    toname$ = "ALL"„  END IF„  ' check FromName$„  IF fromname$ = "" THEN„    CLOSE #1„    ErrorCode$ = "No from field (name) specified!"„    EXIT SUB„  END IF„  CLOSE #1„  ' process mail packet„  PRINT„  PRINT "Unarchiving "; BBSID$ + ".REP";„  ' determine archive type„  OPEN BBSID$ + ".REP" FOR BINARY AS #1„  ' PKZIP file?„  SEEK 1, 1„  GET #1, , ArcHeader„  IF ArcHeader = "PK" + CHR$(3) THEN„    DeArcCommand$ = "PKUNZIP"„    ArcCommand$ = "PKZIP"„    ArcType$ = "ZIP"„  END IF„  ' LZH file?„  SEEK 1, 3„  GET #1, , ArcHeader„  IF ArcHeader = "-lh" THEN„    DeArcCommand$ = "LHA E"„    ArcCommand$ = "LHA A /M"„    ArcType$ = "LZH"„  END IF„  ' ARJ file?„  SEEK 1, 1„  GET #1, , ArcHeader„  IF LEFT$(ArcHeader, 2) = "'" + CHR$(234) THEN„    DeArcCommand$ = "ARJ E"„    ArcCommand$ = "ARJ A -Y"„    ArcType$ = "ARJ"„  END IF„  ' dearchive file„  PRINT " using "; ArcType$„  SHELL DeArcCommand$ + " " + BBSID$ + ".REP"„  CLOSE #1„  ' test for file„  OPEN BBSID$ + ".MSG" FOR BINARY AS #1„  IF LOF(1) = 0 THEN„    ErrorCode$ = "Error occured during DeArchiving. File " + BBSID$ + ".MSG not found in archive"„    CLOSE #1„    KILL BBSID$ + ".MSG"„    EXIT SUB„  END IF„  ' read messages„  PRINT„  PRINT "Reading Messages from "; BBSID$; ".MSG..."„  SEEK 1, 1„  GET #1, , QWKRecBuff„  DO„    GET #1, , MsgHeader„    NewHighest = VAL(MsgHeader.MsgRefNumber)„    IF NewHighest > Highest THEN Highest = NewHighest„    ' read until next message„    FOR n = 1 TO VAL(MsgHeader.NumBlocks) - 1„      GET #1, , QWKRecBuff„    NEXT n„  LOOP UNTIL SEEK(1) >= LOF(1)„  PRINT„  PRINT "Writing new messages..."„  PRINT„  PRINT "To:     "„  PRINT "From:   "„  PRINT "Subj:   "„  PRINT "Conf:   "„  PRINT "Date:   "„  PRINT "Time:   "„  PRINT "Number: "„  StartLin = CSRLIN - 7„  FOR msg = 1 TO NumMessages„    LOCATE StartLin, 1„    Subj$ = "[" + LTRIM$(STR$(msg)) + "/" + LTRIM$(STR$(NumMessages)) + "] " + TitleFile$„    conf$ = LTRIM$(STR$(conference))„    num$ = LTRIM$(STR$(msg + Highest - 1))„    dat$ = LEFT$(DATE$, 6) + RIGHT$(DATE$, 2)„    tim$ = LEFT$(TIME$, 5)„    PRINT "To:     "; toname$„    PRINT "From:   "; fromname$„    PRINT "Subj:   "; Subj$„    PRINT "Conf:   "; conf$„    PRINT "Date:   "; dat$„    PRINT "Time:   "; tim$„    PRINT "Number: "; num$„    PRINT "Writing File: "; MsgFiles$(msg);„    TotalLen& = 0„    OPEN MsgFiles$(msg) FOR INPUT AS #2„    OPEN "~IIBETA.TMP" FOR BINARY AS #3„    DO WHILE NOT EOF(2)„      LINE INPUT #2, text$„      text$ = text$ + CHR$(227)„      PUT #3, , text$„    LOOP„    TotalLen& = SEEK(3)„    TotalLen& = TotalLen& + 128       ' for tagline„    QWKRecBuff = CHR$(227) + " * ImportIt! v1.0b [BETA] * ImportIt!" + " [PD] by Calvin French, August 1993" + CHR$(227) + CHR$(227)„    PUT #3, , QWKRecBuff„    ExtraString$ = SPACE$(128 - (TotalLen& MOD 128))„    TotalLen& = TotalLen& + LEN(ExtraString$)„    PUT #3, , ExtraString$„    Blocks$ = LTRIM$(STR$((TotalLen& / 128) + 1))„    MsgHeader.Status = "-"            ' public, read„    MsgHeader.ConfNumASCII = conf$    ' conference (.REP only)„    MsgHeader.MsgDate = dat$          ' date„    MsgHeader.MsgTime = tim$          ' time„    MsgHeader.ToField = toname$       ' to„    MsgHeader.FromField = fromname$   ' from„    MsgHeader.SubjectField = Subj$    ' subject„    MsgHeader.PassWord = SPACE$(12)   ' password„    MsgHeader.MsgRefNumber = num$     ' message number„    MsgHeader.NumBlocks = Blocks$     ' blocks in message„    MsgHeader.Flag = CHR$(225)        ' active flag„    MsgHeader.ConfNum = conference    ' conference (.REP and .QWK)„    MsgHeader.PacketMsgNumber = " "   ' not sure what this is.„    MsgHeader.NetworkTag = " "        ' network tagline„    PUT #1, , MsgHeader„    SEEK 3, 1„    FOR n = 1 TO TotalLen& / 128„      GET #3, , QWKRecBuff„      PUT #1, , QWKRecBuff„    NEXT n„    CLOSE #3„    CLOSE #2„    KILL "~IIBETA.TMP"„  NEXT msg„  CLOSE #1„  PRINT„  PRINT„  PRINT "Rearchiving Packet..."„  SHELL ArcCommand$ + " " + BBSID$ + ".REP " + BBSID$ + ".MSG"„  PRINT„  PRINT "Deleting " + BBSID$ + ".MSG..."„  PRINT„  KILL BBSID$ + ".MSG"„  ErrorCode$ = "Packet Successfully Processed!"„END SUB„„SUB CreateRep (BBSID$, ArcCommand$)„„DIM QWKRecBuff AS STRING * 128„„PRINT„PRINT "Creating message data file (.MSG file)..."„PRINT„„OPEN BBSID$ + ".MSG" FOR BINARY AS #1„„QWKRecBuff = UCASE$(BBSID$)„„PUT #1, , QWKRecBuff„„CLOSE #1„„PRINT "Archiving file..."„„SHELL ArcCommand$ + " " + BBSID$ + ".REP " + BBSID$ + ".MSG"„„PRINT„PRINT "Deleting message data file (.MSG file)..."„„KILL BBSID$ + ".MSG"„„END SUB„„FUNCTION Decode% (oSwitch%, InSpec$, OutSpec$)„  DIM Lines$(1 TO 256), ValidChar%(255)„  FOR q% = 0 TO 85 'Valid encoding characters„    IF q% = 27 THEN„      ValidChar%(ASC("#")) = true„    ELSEIF q% = 59 THEN„      ValidChar%(ASC("$")) = true„    ELSE„      ValidChar%(q% + 37) = true„    END IF„  NEXT„  GERR% = 0: Z$ = "OPEN " + CHR$(34) + "O" + CHR$(34) + ",1," + CHR$(34)„  SepPath OutSpec$, OutDrive$, OutPath$, OutName$„  OutPath$ = OutDrive$ + OutPath$„  InputHandle% = FREEFILE„  OPEN InSpec$ FOR INPUT AS InputHandle% LEN = 8192„  OutputHandle% = FREEFILE„  DO„    IF FoundNewScript% = false THEN„      DO UNTIL EOF(InputHandle%)„        M% = M% + 1: IF M% = 16 THEN GOSUB AbortCheck„        LineNum& = LineNum& + 1„        LINE INPUT #1, a$: a$ = LTRIM$(RTRIM$(UCASE$(a$)))„        IF GERR% THEN PRINT "Error while reading from input file!": GOTO DecodeExit„        IF LEFT$(a$, 14) = "'>>> PAGE 1 OF" AND INSTR(a$, "BEGINS" + " HERE") > 0 AND INSTR(a$, "TYPE:") > 0 THEN EXIT DO„      LOOP„      IF EOF(InputHandle%) THEN EXIT DO„    END IF„    FoundNewScript% = false„    OutFile$ = LTRIM$(MID$(a$, 15))„    OutFile$ = RTRIM$(LEFT$(OutFile$, INSTR(OutFile$, "BEGINS") - 1))„    IF LEN(OutFile$) = 0 THEN GOTO FindNext„    IF LEN(OutName$) = 0 OR OutFile$ = OutName$ THEN„      FilesCRC% = -1: FilesLength& = -1: ScrDone% = false„      BadScript% = false: NumLines% = 0: K% = 0: s% = 0: b& = 0„      q% = INSTR(a$, "TYPE:") + 5„      SELECT CASE MID$(a$, q%, 3)„      CASE "BAS": ScriptType% = 0„      CASE "BIN"„        ScriptType% = 1„        EncodeVer% = FASC%(MID$(a$, q% + 3, 1)) - 65„        ExtractVer% = FASC%(MID$(a$, q% + 4, 1)) - 65„        IF ExtractVer% <> 0 THEN PRINT "Unsupported encoding algorithm" + "" + " for file "; OutFile$: PRINT : GOTO FindNext„      CASE ELSE: PRINT "Unsupported script type for file "; OutFile$: PRINT : GOTO FindNext„      END SELECT„      GOSUB CheckLine„      OPEN OutPath$ + OutFile$ FOR INPUT AS OutputHandle%: CLOSE OutputHandle%„      IF GERR% = 0 THEN„        IF oSwitch% = false THEN„          PRINT OutPath$ + OutFile$; " already exists. [O]verwrite, or" + "" + " [A]bort(o/a)? ";„          DO: DO: a$ = INKEY$: LOOP UNTIL LEN(a$): a$ = UCASE$(a$)„          LOOP UNTIL INSTR("OA" + CHR$(27), a$)„          LOCATE , 1: PRINT SPACE$(78); : LOCATE , 1„          SELECT CASE a$„          CASE "A", CHR$(27): GERR% = -1: PRINT "Aborted by user!": GOTO DecodeExit„          END SELECT„        END IF„      END IF„      GERR% = 0: OPEN OutPath$ + OutFile$ FOR OUTPUT AS OutputHandle%„      IF GERR% THEN PRINT "Error while opening "; OutPath$ + OutFile$; "!": GOTO DecodeExit„      OutSpecOpened% = true„      IF ScriptType% = 0 THEN PRINT "Unfiltering ";  ELSE PRINT "Decoding ";„      PRINT OutPath$ + OutFile$; "... ";„      LookingForNextPage% = false„      CurrentPage% = 1„      DO UNTIL EOF(InputHandle%)„        IF GERR% THEN PRINT "Error #"; STR$(GERR%); " while processing" + "" + " file!": GOTO DecodeExit„        M% = M% + 1: IF M% = 16 THEN GOSUB AbortCheck„        LineNum& = LineNum& + 1„        LINE INPUT #InputHandle%, a$: a$ = RTRIM$(a$)„        IF ScriptType% = 1 THEN a$ = LTRIM$(a$)„        IF LEFT$(a$, 4) = "'>>>" THEN„          GOSUB CheckLine„          IF UCASE$(LEFT$(a$, 10)) = "'>>> PAGE " THEN„            a$ = UCASE$(a$)„            IF LEFT$(a$, 15) = "'>>> PAGE 1 OF " AND INSTR(a$, "BEGINS" + "" + " HERE") > 0 THEN„              PRINT "Premature end of script on line"; LineNum&„              FoundNewScript% = true: BadScript% = true: EXIT DO„            END IF„            IF GrabNum&(MID$(a$, 11), 1, 256, -1) <> CurrentPage% THEN PRINT "Page out of sync on line"; LineNum&: BadScript% = true: EXIT DO„            IF INSTR(a$, "BEGINS HERE") THEN„              IF LookingForNextPage% = false THEN PRINT "Page"; CurrentPage%; " was encountered more than once on line"; LineNum&: BadScript% = true: EXIT DO„              LookingForNextPage% = false„            ELSEIF INSTR(a$, "ENDS HERE") THEN„              IF LookingForNextPage% = true THEN PRINT "Page"; CurrentPage%; "was terminated prematurely on line"; LineNum&: BadScript% = true: EXIT DO„              LookingForNextPage% = true„              CurrentPage% = CurrentPage% + 1„              IF INSTR(a$, "LAST PAGE") THEN ScrDone% = true: EXIT DO„            ELSE„              PRINT "Bad page header on line"; LineNum&: BadScript% = true: EXIT DO„            END IF„          END IF„        ELSE„          IF LookingForNextPage% = false THEN„            IF ScriptType% = 0 THEN„              GOSUB ShrinkLine„            ELSE„              IF LEFT$(a$, 1) = "U" AND LEFT$(LTRIM$(MID$(a$, 2)), 1) = CHR$(34) THEN GOSUB DecodeLine„            END IF„          END IF„        END IF„      LOOP„      IF BadScript% = false THEN„        IF ScrDone% = false THEN PRINT "Premature end of script on" + " line"; LineNum&: BadScript% = true: GOTO DecodeDone„        GoodScripts% = GoodScripts% + 1„        IF ScriptType% = 0 THEN„          IF NumLines% > 0 THEN a$ = "": GOSUB ShrinkLine„          PRINT "Ok"„        ELSE„          IF FilesLength& = -1 THEN„            PRINT "Warning: File's length could not be located!"„          ELSEIF FilesLength& <> b& THEN„            PRINT "Warning: Decoded file's length is incorrect."„          ELSEIF FilesCRC% = -1 THEN„            PRINT "Warning: File's checksum could not be located!"„          ELSEIF FilesCRC% <> s% THEN„            PRINT "Warning: Decoded file's checksum is incorrect."„          ELSE„            PRINT "Ok"„          END IF„        END IF„      END IF„DecodeDone:„      CLOSE OutputHandle%„      IF GERR% THEN PRINT "Error while writing to output file!": GOTO DecodeExit„      IF BadScript% THEN KILL OutPath$ + OutFile$„      OutSpecOpened% = false„      PRINT : IF OutFile$ = OutName$ THEN EXIT DO„    END IF„FindNext:„  LOOP UNTIL EOF(InputHandle%)„'----------------------------------------------------------„DecodeExit:„  q% = GERR%: CLOSE InputHandle%: CLOSE OutputHandle%„  IF q% = 0 THEN PRINT LTRIM$(STR$(GoodScripts%)); " script(s) decoded" + "" + " successfully."„  IF q% <> 0 AND OutSpecOpened% THEN KILL OutPath$ + OutFile$„  Decode% = q%„EXIT FUNCTION„'----------------------------------------------------------„ShrinkLine:„  FoundIt% = FASC(RIGHT$(a$, 1)) = 95„  IF FoundIt% THEN„    InQuote% = false„    FOR I% = 1 TO LEN(a$)„      IF MID$(a$, I%, 1) = CHR$(34) THEN InQuote% = NOT InQuote%„    NEXT„    'Don't combine lines that are part of binary scripts„    IF InQuote% THEN FoundIt% = false„  END IF„  IF FoundIt% OR NumLines% > 0 THEN„    IF NumLines% = 256 THEN„      PRINT "Too many line continuations!": BadScript% = true: GOTO DecodeDone„    END IF„    NumLines% = NumLines% + 1: Lines$(NumLines%) = a$„    IF FoundIt% = false THEN 'last line?„      a$ = ""„      FOR a% = 1 TO NumLines%„        b$ = Lines$(a%)„        'can we combine two quoted strings together?„        CombineQuote% = false„        IF RIGHT$(a$, 2) = "+_" AND LEN(a$) > 3 THEN„          IF RIGHT$(RTRIM$(LEFT$(a$, LEN(a$) - 2)), 1) = CHR$(34) THEN„            IF FASC(LTRIM$(b$)) = 34 THEN CombineQuote% = true„          END IF„        END IF„        IF CombineQuote% THEN„          a$ = RTRIM$(LEFT$(a$, LEN(a$) - 2))„          a$ = LEFT$(a$, LEN(a$) - 1) + MID$(LTRIM$(b$), 2)„        ELSE„          InQuote% = false„          'can we combine two remarks together?„          FOR I% = 1 TO LEN(a$)„            q$ = MID$(a$, I%, 1)„            IF q$ = CHR$(34) THEN„              InQuote% = NOT InQuote%„            ELSEIF InQuote% = false THEN„              IF q$ = "'" OR UCASE$(MID$(a$, I%, 4)) = "REM " THEN„                IF LEFT$(LTRIM$(b$), 1) = "'" THEN b$ = MID$(b$, 2)„                EXIT FOR„              END IF„            END IF„          NEXT„          'eradicate trailing "_" character„          IF LEN(a$) THEN a$ = LEFT$(a$, LEN(a$) - 1)„          a$ = a$ + b$„        END IF„      NEXT„      PRINT #OutputHandle%, a$: NumLines% = 0„    END IF„  ELSE„    PRINT #OutputHandle%, a$„  END IF„  IF GERR% THEN PRINT "Error while writing to output file!": GOTO DecodeExit„RETURN„'----------------------------------------------------------„DecodeLine: '**MOD 86 Decoder**„  a$ = MID$(LTRIM$(MID$(a$, 2)), 2)„  IF RIGHT$(a$, 1) = CHR$(34) THEN a$ = LEFT$(a$, LEN(a$) - 1)„  FOR a% = 1 TO LEN(a$)„    C% = ASC(MID$(a$, a%, 1))„    IF ValidChar%(C%) = false THEN PRINT "Illegal character found on" + " line"; LineNum&: BadScript% = true: GOTO DecodeDone„    C% = C% - 37: IF C% < 0 THEN C% = 91 + C% * 32„    IF K% < 4 THEN„      IF C% > 80 THEN PRINT "Decode out of sync/illegal character" + " found" + " on line"; LineNum&: BadScript% = true: GOTO DecodeDone„      K% = C% + 243„    ELSE„      T% = C% + (K% MOD 3) * 86: IF T% > 255 THEN PRINT "Illegal" + " character found on line"; LineNum&: BadScript% = true: GOTO DecodeDone„      PRINT #OutputHandle%, CHR$(T%);„      IF GERR% THEN PRINT "Error while writing to output file!": GOTO DecodeExit„      b& = b& + 1: K% = K% \ 3„    END IF„    s% = (s% + C%) AND 255„  NEXT„RETURN„'----------------------------------------------------------„CheckLine:„  q% = INSTR(a$, "TLEN:")„  IF q% THEN FilesLength& = GrabNum&(MID$(a$, q% + 5), 1, 153600, -1)„  q% = INSTR(a$, "TCHK:")„  IF q% THEN FilesCRC% = GrabNum&(MID$(a$, q% + 5), 0, 255, -1)„RETURN„'----------------------------------------------------------„AbortCheck: M% = 0: K$ = INKEY$„  IF K$ = CHR$(27) OR K$ = CHR$(0) + CHR$(0) THEN GERR% = -1: PRINT "Aborted by user!": GOTO DecodeExit„RETURN„END FUNCTION„„FUNCTION Encode% (Op%, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InSpec$, OutSpec$)„  ' following SHARED is for ImportIt!„  DIM Bucket%(1 TO 4), Lines$(64)„  GERR% = 0: q$ = CHR$(34)„'----------------------------------------------------------„  SepPath InSpec$, OutDrive$, OutPath$, InName$„  SepPath OutSpec$, OutDrive$, OutPath$, OutName$„  IF LEN(OutName$) = 0 THEN„    OutName$ = InName$„    IF INSTR(OutName$, ".") THEN OutName$ = LEFT$(OutName$, INSTR(OutName$, ".") - 1)„  END IF„  IF INSTR(OutName$, ".") THEN„    OutExt$ = MID$(OutName$, INSTR(OutName$, "."))„    OutName$ = LEFT$(OutName$, INSTR(OutName$, ".") - 1)„  END IF„  IF LEN(OutExt$) = 0 THEN IF Op% THEN OutExt$ = ".PST" ELSE OutExt$ = ".PI"„'----------------------------------------------------------„  InputHandle% = FREEFILE„  IF Op% THEN„    OPEN InSpec$ FOR INPUT AS InputHandle% LEN = 8192„  ELSE„    OPEN InSpec$ FOR BINARY AS InputHandle%„  END IF„  InputFileSize& = LOF(InputHandle%)„  IF Op% = 0 AND InputFileSize& > (150 * 1024&) THEN„    PRINT "Can't encode files larger than 150k."„    GERR% = -1: GOTO EncodeExit„  ELSEIF InputFileSize& = 0 THEN„    PRINT "Input file is null.": GERR% = -2: GOTO EncodeExit„  END IF„'----------------------------------------------------------„  IF Op% THEN PRINT "Filtering ";  ELSE PRINT "Encoding ";„  PRINT InSpec$; " ("; LTRIM$(STR$((InputFileSize& + 1023) \ 1024)); "k)"„  PRINT„'----------------------------------------------------------„  OutputHandle% = FREEFILE: LinesInPage% = 0„'----------------------------------------------------------„  IF Op% = 0 THEN„    Work$ = "U" + q$ + SPACE$(lSwitch% - 2): WorkPos% = 3„    CurrentSub% = 0: LinesInSub% = 0: FlagScaler% = 1„    GOSUB PrintDecodeHeader„    BytesLeft& = InputFileSize&: BufferSize% = 4096„    Buffer$ = SPACE$(BufferSize)„    DO„      IF GERR% THEN PRINT "- Error #"; STR$(GERR%); " while encoding" + " file!": GOTO EncodeExit„      IF BytesLeft& < BufferSize% THEN Buffer$ = SPACE$(BytesLeft&): BufferSize% = BytesLeft&„      GET InputHandle%, , Buffer$„      IF GERR% THEN PRINT "- Error while reading from input file!": GOTO EncodeExit„      GOSUB EncodeBlock„    LOOP WHILE BytesLeft&„    IF NumCodes% THEN GOSUB FlushCodeBuffer„    IF WorkPos% > 3 THEN Work$ = LEFT$(Work$, WorkPos% - 1): GOSUB PutSubLine„    IF LinesInSub% THEN L$ = "END SUB": GOSUB PutLine„    FOR a% = 2 TO CurrentSub%: L$ = "V" + HEX$(a%): GOSUB PutLine: NEXT„    GOSUB PrintDecodeTrailer„  ELSE„    BytesLeft& = InputFileSize&„    DO UNTIL EOF(InputHandle)„      IF GERR% THEN PRINT "- Error #"; STR$(GERR%); " while filtering" + "" + " file!": GOTO EncodeExit„      LINE INPUT #InputHandle, a$: a$ = RTRIM$(UnTab$(a$, tSwitch%))„      IF GERR% THEN PRINT "- Error while reading from input file!": GOTO EncodeExit„      IF cSwitch% THEN a$ = LTRIM$(a$)„      BytesLeft& = BytesLeft& - LEN(a$) - 2„      IF LEN(a$) > 0 OR iSwitch% = false THEN„        ExpandLine a$, Lines$(), lSwitch%, NumLines%„        'Don't let split lines cross page boundries, because QB won't„        'put them back together.„        IF sSwitch% = false AND (NumLines% > 1) AND (LinesInPage% + 1 + NumLines%) > pSwitch% THEN„          PRINT #OutputHandle%, "'>>> Page"; STR$(NumOutputFiles%); " of "; InName$; " ends here. Continued on next page."„          LinesInPage% = LinesInPage% + 1: GOSUB CloseOutputFile„        END IF„        FOR a% = 1 TO NumLines%„          L$ = Lines$(a%)„          'Don't let blank lines proceed the first page header.„          IF LinesInPage% <> 0 OR LEN(RTRIM$(L$)) > 0 THEN„            'The padding option is for those unfortunates that post„            'source online in RBBS's grubby line oriented text editor...„            IF aSwitch% THEN IF LEN(L$) = 0 THEN L$ = " "„            GOSUB PutLine„          END IF„        NEXT„      END IF„    LOOP„  END IF„'----------------------------------------------------------„  L$ = "'>>> Page" + STR$(NumOutputFiles%) + " of " + InName$ + " ends" + "" + " here. Last page."„  IF Op% = 0 THEN L$ = L$ + " TCHK:" + LTRIM$(STR$(CheckSum%))„  GOSUB PutLine: GOSUB CloseOutputFile: PRINT„  PRINT LTRIM$(STR$(TotalLines%)); " lines in"; STR$(NumOutputFiles%); " message(s) written."„'----------------------------------------------------------„EncodeExit:„  q% = GERR%„  CLOSE InputHandle%: CLOSE OutputHandle%„  IF q% <> 0 THEN FOR a% = 1 TO NumOutputFiles%: KILL OutPutFile$(a%): NEXT„  Encode% = q%„EXIT FUNCTION„'----------------------------------------------------------„EncodeBlock: '**MOD 86 Encoder**„  FOR I% = 1 TO BufferSize%„    Byte% = ASC(MID$(Buffer$, I%, 1)): BytesLeft& = BytesLeft& - 1„    CurrentFlag% = CurrentFlag% + (Byte% \ 86) * FlagScaler%„    FlagScaler% = FlagScaler% * 3: NumCodes% = NumCodes% + 1„    Bucket%(NumCodes%) = Byte% MOD 86„    IF NumCodes% = 4 THEN GOSUB FlushCodeBuffer„  NEXT„RETURN„'----------------------------------------------------------„FlushCodeBuffer:„  q% = CurrentFlag%: GOSUB PutByte„  FOR J% = 1 TO NumCodes%: q% = Bucket%(J%): GOSUB PutByte: NEXT„  NumCodes% = 0: CurrentFlag% = 0: FlagScaler% = 1„RETURN„'----------------------------------------------------------„PutByte:„  CheckSum% = (CheckSum% + q%) AND 255„  IF q% = 27 THEN„    MID$(Work$, WorkPos%) = "#"„  ELSEIF q% = 59 THEN„    MID$(Work$, WorkPos%) = "$"„  ELSE„    MID$(Work$, WorkPos%) = CHR$(q% + 37)„  END IF„  WorkPos% = WorkPos% + 1: IF WorkPos% > lSwitch% THEN GOSUB PutSubLine„RETURN„'----------------------------------------------------------„PutSubLine:„  IF LinesInSub% = 0 THEN„    CurrentSub% = CurrentSub% + 1„    IF CurrentSub% = 1 THEN„      L$ = "SUB V1:OPEN " + q$ + "O" + q$ + ",1," + q$ + InName$ + q$ + ",4^6:Z&=" + LTRIM$(STR$(LOF(1))) + ":?STRING$(50,177);"„    ELSE„      L$ = "SUB V" + HEX$(CurrentSub%)„    END IF„    GOSUB PutLine„  END IF„  L$ = Work$: GOSUB PutLine„  LinesInSub% = LinesInSub% + 1„  IF LinesInSub% = 200 THEN L$ = "END SUB": GOSUB PutLine: LinesInSub% = 0„  WorkPos% = 3„RETURN„'----------------------------------------------------------„PutLine:„  IF LinesInPage% = 0 THEN GOSUB OpenNewOutputFile„  PRINT #OutputHandle%, L$„  IF GERR% THEN PRINT "- Error writing to output file!": GOTO EncodeExit„  LinesInPage% = LinesInPage% + 1„  IF sSwitch% = false THEN„    'make sure last page has some meat on it„    IF LinesInPage% = (pSwitch% - 1) OR (BytesLeft& < 256 AND LinesInPage% > (pSwitch% - 10)) THEN„      PRINT #OutputHandle%, "'>>> Page"; STR$(NumOutputFiles%); " of "; InName$; " ends here. Continued on next page."„      LinesInPage% = LinesInPage% + 1: GOSUB CloseOutputFile„    END IF„  END IF„  'Check the blower for contol+c and escape every few lines...„  IF (LinesInPage% AND 7) = 1 THEN„    a$ = INKEY$: IF a$ = CHR$(27) OR a$ = CHR$(0) + CHR$(0) THEN GERR% = -3: PRINT "- Aborted by user!": GOTO EncodeExit„  END IF„RETURN„'----------------------------------------------------------„OpenNewOutputFile:„  IF NumOutputFiles% = 256 THEN GERR% = -4: PRINT "Too many output" + " files!": GOTO EncodeExit„  NumOutputFiles% = NumOutputFiles% + 1„  IF sSwitch% = true THEN„    J$ = OutName$„  ELSE„    J$ = LTRIM$(STR$(NumOutputFiles%))„    J$ = LEFT$(OutName$, 8 - LEN(J$)) + J$„  END IF„  OutFile$ = OutDrive$ + OutPath$ + J$ + OutExt$: GERR% = 0„  OPEN OutFile$ FOR INPUT AS OutputHandle%: CLOSE OutputHandle%„  IF GERR% = 0 THEN„    IF oSwitch% = false THEN„      PRINT OutFile$; " already exists. [O]verwrite, overwrite [R]est," + "" + " or [A]bort(o/r/a)? ";„      DO: DO: a$ = INKEY$: LOOP UNTIL LEN(a$): a$ = UCASE$(a$)„      LOOP UNTIL INSTR("ORA" + CHR$(27), a$)„      LOCATE , 1: PRINT SPACE$(78); : LOCATE , 1„      SELECT CASE a$„      CASE "A", CHR$(27): GERR% = -3: PRINT "Aborted by user!"„        NumOutputFiles% = NumOutputFiles% - 1: GOTO EncodeExit„      CASE "R": oSwitch% = true„      END SELECT„    END IF„  END IF„  PRINT "Now writing: "; OutFile$; " ";„  GERR% = 0: OPEN OutFile$ FOR OUTPUT AS OutputHandle% LEN = 4096„  OutPutFile$(NumOutputFiles%) = OutFile$„  IF GERR% THEN„    PRINT "- Error opening output file!"„    NumOutputFiles% = NumOutputFiles% - 1: GOTO EncodeExit„  END IF„  LinesInPage% = 1„  IF NumOutputFiles% = 1 THEN„    FOR I% = 1 TO bSwitch%„      IF aSwitch% THEN PRINT #OutputHandle, " " ELSE PRINT #OutputHandle,„    NEXT„    LinesInPage% = LinesInPage% + bSwitch%„  END IF„  PRINT #OutputHandle%, "'>>> Page"; STR$(NumOutputFiles%); " of "; InName$; " begins here.";„  IF NumOutputFiles% > 1 THEN„    PRINT #OutputHandle%,„  ELSE„    IF Op% = 0 THEN„      'The first letter after "BIN" is  which algorithm was used„      'to encode the file. The second letter is the minimum decoding„      'algorithm required to extract the file. Both range from A-Z.„      PRINT #OutputHandle%, " TYPE:BINAA";„      'TLEN stands for "total length".„      PRINT #OutputHandle%, " TLEN:"; LTRIM$(STR$(InputFileSize&))„      'In the future, other information may be put onto this line,„      'such as the file's date and time. (Actually, any line„      'starting will "'>>>" will be scanned for information by„      'the Decode function.)„    ELSE„      PRINT #OutputHandle%, " TYPE:BAS"„    END IF„  END IF„  GERR% = 0„RETURN„'----------------------------------------------------------„CloseOutputFile:„  CLOSE OutputHandle%„  IF GERR% THEN PRINT "- Error while writing to output file!": GOTO EncodeExit„  PRINT : TotalLines% = TotalLines% + LinesInPage%: LinesInPage% = 0„RETURN„'----------------------------------------------------------„PrintDecodeHeader:„ „'This section added 5/23/96 by Steve Harmon„'This section modified 6/11/96 by Steve Harmon„  L$ = "'-------------------------------------------------------------"„  GOSUB PutLine„  L$ = "'                  INSTRUCTIONS FOR DECODING"„  GOSUB PutLine„  L$ = "'If there are multiple parts to this file, merge them into one"„  GOSUB PutLine„  L$ = "'file using  COPY PART1.EXT+PART2.EXT FILENAME.EXT  Remove all"„  GOSUB PutLine„  L$ = "'message header and footer information (everything outside the"„  GOSUB PutLine„  L$ = "'" + CHR$(34) + ">>> Page x of..." + CHR$(34) + " lines),  load the result into your version"„  GOSUB PutLine„  L$ = "'of Basic (QBASIC, QuickBASIC, etc.) then RUN it. The original"„  GOSUB PutLine„  L$ = "'file will be decoded into the current directory on your disk."„  GOSUB PutLine„  L$ = "'-------------------------------------------------------------"„  GOSUB PutLine„'End section added 5/23/96 by Steve Harmon„„„  L$ = "DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.3"„  GOSUB PutLine„RETURN„'----------------------------------------------------------„PrintDecodeTrailer:„  L$ = "CLOSE:IF S=" + LTRIM$(STR$(CheckSum%))„  L$ = L$ + "AND B&=Z&THEN?" + q$ + " :) Ok!" + q$ + "ELSE?" + q$ + " " + "" + ":( Bad!"„  GOSUB PutLine„  L$ = "SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN" + " C=91+C*32"„  GOSUB PutLine„  L$ = "IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1"„  GOSUB PutLine„  L$ = "S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB"„  GOSUB PutLine„RETURN„END FUNCTION„„'This self containted subroutine for splitting QB lines was made by„'Victor Yiu and a few other folks on the QUIK_BAS echo.„SUB ExpandLine (a$, Lines$(), LineLength%, NumLines%)„  NumLines% = 0„  'check to see if the line has already been split„  FOR I% = LEN(a$) TO 1 STEP -1„    SELECT CASE MID$(a$, I%, 1)„    CASE "_": NoSplit% = true„    CASE " "„    CASE ELSE: EXIT FOR„    END SELECT„  NEXT„  DO WHILE NoSplit% = false AND LEN(a$) > LineLength%„    'locate a place to split the line„    WrapPoint% = 0„    FOR I% = LineLength% TO LineLength% - 20 STEP -1„      SELECT CASE MID$(a$, I%, 1)„      CASE " ", ".", ",", ":", ";": WrapPoint% = I%: EXIT FOR„      END SELECT„    NEXT„    IF WrapPoint% = 0 THEN WrapPoint% = LineLength%„    'avoid wrapping on quote chars„    IF MID$(a$, WrapPoint% - 1, 1) = CHR$(34) THEN WrapPoint% = WrapPoint% - 1„    InQuote% = false: HasComment% = false„    'check to see if the line contains a remark„    FOR I% = 1 TO WrapPoint% - 1„      q$ = MID$(a$, I%, 1)„      IF q$ = CHR$(34) THEN„        InQuote% = NOT InQuote%„      ELSEIF InQuote% = false THEN„        IF q$ = "'" OR UCASE$(MID$(a$, I%, 4)) = "REM " THEN„          HasComment% = true: EXIT FOR„        END IF„      END IF„    NEXT„    NumLines% = NumLines% + 1„    IF InQuote% THEN„      Lines$(NumLines%) = LEFT$(a$, WrapPoint% - 1) + CHR$(34) + "+_"„    ELSE„      Lines$(NumLines%) = LEFT$(a$, WrapPoint% - 1) + "_"„    END IF„    a$ = MID$(a$, WrapPoint%)„    IF HasComment% THEN„      a$ = "'" + a$„    ELSEIF InQuote% THEN„      a$ = CHR$(34) + a$„    END IF„  LOOP„  NumLines% = NumLines% + 1: Lines$(NumLines%) = a$„END SUB„„FUNCTION FASC% (a$)„  IF LEN(a$) = 0 THEN FASC% = -1 ELSE FASC% = ASC(a$)„END FUNCTION„„FUNCTION GrabNum& (a$, Lower&, Upper&, Default&)„  FOR I% = 1 TO LEN(a$)„    q$ = MID$(a$, I%, 1): IF (q$ < "0" OR q$ > "9") THEN EXIT FOR„    J& = J& * 10& + ASC(q$) - 48„    IF J& > Upper& THEN GrabNum& = Default&: EXIT FUNCTION„  NEXT„  GrabNum& = J&: IF LEN(a$) = 0 OR J& < Lower& OR J& > Upper& THEN GrabNum& = Default&„END FUNCTION„„SUB IIParse (cmd$, toname$, fromname$, conference%, BBSID$)„  ' this short sub parses cmd$ and returns values for use with ImportIt!„  FOR n = 1 TO LEN(cmd$)„    IF MID$(cmd$, n, 4) = " -Q " THEN„      qLoc = n + 4„    END IF„  NEXT n„  FOR n = qLoc TO LEN(cmd$)„    IF MID$(cmd$, n, 3) = "TO:" THEN„      toname$ = LTRIM$(RTRIM$(MID$(cmd$, n + 3, INSTR(n, cmd$, "FROM:") - (n + 3))))„    ELSEIF MID$(cmd$, n, 5) = "FROM:" THEN„      fromname$ = LTRIM$(RTRIM$(MID$(cmd$, n + 5, INSTR(n, cmd$, "CONF" + ":") - (n + 5))))„    ELSEIF MID$(cmd$, n, 5) = "CONF:" THEN„      conference% = VAL(LTRIM$(RTRIM$(MID$(cmd$, n + 5, INSTR(n, cmd$, "BBSID:") - (n + 5)))))„    ELSEIF MID$(cmd$, n, 6) = "BBSID:" THEN„      BBSID$ = LTRIM$(RTRIM$(LTRIM$(RTRIM$(MID$(cmd$, n + 6)))))„    END IF„  NEXT n„END SUB„„SUB ImportIt (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference)„  PRINT„  PRINT "ImportIt! v1.0"; CHR$(225); " QuickBASIC Compatable QWK format" + " file importer."„  PRINT "For use with PostIt! QuickBASIC Compatable Encoder/Decoder."„  PRINT "Public Domain by Calvin French, August 1993"„  PRINT„  PRINT "Adding encoded files to reply packet (.REP file)"„  AddToRep BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference, ErrorCode$„  PRINT„  PRINT "Status returned: "; ErrorCode$„  IF ErrorCode$ = "Reply packet (.REP file) not found!" THEN„    ArcMethod$ = PreferredArchiveMethod$„    SELECT CASE ArcMethod$„      CASE "ARJ"„        ArcCommand$ = "ARJ A"„      CASE "LHA"„        ArcCommand$ = "LHA A"„      CASE "ZIP"„        ArcCommand$ = "PKZIP"„    END SELECT„    CreateRep BBSID$, ArcCommand$„    AddToRep BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference, ErrorCode$„    PRINT "Status returned: "; ErrorCode$„    PRINT„  END IF„END SUB„„'This parsing sub does NOT mistake filenames like "F-14G.ZIP" as„'containing a switch. That's why it looks so big.„SUB ParseCmdLine (cmd$, Params$(), Found%)„  Found% = 0: Sep$ = "-/": Temp$ = LTRIM$(RTRIM$(cmd$)): InParam% = 0„  FOR p% = 1 TO LEN(Temp$)„    C$ = MID$(Temp$, p%, 1)„    IF InParam% = -1 THEN 'Inside of a switch?„      IF INSTR(Sep$, C$) THEN 'Found another switch?„        'Terminate current switch, then start parsing the next one.„        GOSUB MakeParam: MID$(Temp$, p%, 1) = LEFT$(Sep$, 1)„        ParamStart% = p%„      ELSEIF ASC(C$) = 32 OR ASC(C$) = 9 THEN„        GOSUB MakeParam: InParam% = 0 'Terminate current switch.„      END IF„    ELSEIF InParam% = -2 THEN 'Inside of a parameter?„      IF ASC(C$) = 32 OR ASC(C$) = 9 THEN 'Terminate parameter with„        GOSUB MakeParam: InParam% = 0     'space or TAB.„      END IF„    ELSE„      IF INSTR(Sep$, C$) THEN 'Found start of a switch?„        'Make sure all switches start with "-".„        MID$(Temp$, p%, 1) = LEFT$(Sep$, 1): InParam% = -1„        ParamStart% = p%„      ELSEIF ASC(C$) <> 32 AND ASC(C$) <> 9 THEN 'If char isn't a„        InParam% = -2: ParamStart% = p% 'space or TAB it's a parameter.„      END IF„    END IF„  NEXT„ IF InParam% THEN GOSUB MakeParam„  EXIT SUB„MakeParam:„  Found% = Found% + 1„  Params$(Found%) = MID$(Temp$, ParamStart%, p% - ParamStart%)„  IF Found% = UBOUND(Params$) THEN EXIT SUB„RETURN„END SUB„„SUB SepPath (a$, Drive$, path$, tName$)„  FOR I% = LEN(a$) TO 1 STEP -1„    IF INSTR("\:", MID$(a$, I%, 1)) THEN EXIT FOR„  NEXT„  IF I% > 0 THEN„    path$ = UCASE$(MID$(a$, 1, I%)): tName$ = UCASE$(MID$(a$, I% + 1))„  ELSE„    path$ = "": tName$ = UCASE$(a$)„  END IF„  Temp% = INSTR(path$, ":"): Drive$ = ""„  IF Temp% THEN Drive$ = LEFT$(path$, Temp%): path$ = MID$(path$, Temp% + 1)„END SUB„„FUNCTION UnTab$ (b$, TabStops%)„  a$ = b$: T% = INSTR(a$, CHR$(9))„  IF T% THEN„    DO: Temp% = (T% - 1) MOD TabStops%„    a$ = LEFT$(a$, T% - 1) + SPACE$(TabStops% - Temp%) + MID$(a$, T% + 1)„    T% = INSTR(T%, a$, CHR$(9)): LOOP WHILE T%„  END IF„  UnTab$ = a$„END FUNCTION '(last subroutine)„Jason Laviska                  DECIMAL TO BINARY FORMAT       jason.laviska@outdoor.com      06-22-96 (14:11)       QB, QBasic, PDS        37   1014     DEC2BIN.BAS 'Decimal to Binary format by Jason Laviska.„'LaserArts' Library Function B-01-A„'--- Public Domain --- Use at your own risk ---„„'This is a simple program that functions just like the Hex$ command„'but outputs your number into a binary format.  The output of Bin$„'will always end up in groups of 4 digits/characters.„„CLS„PRINT "Hex           Decimal       Binary"„PRINT "============  ============  ================================"„„FOR Temp& = -10 TO 10„  PRINT HEX$(Temp&), Temp&, Bin$(Temp&)„NEXT Temp&„„FUNCTION Bin$ (Decimal&)„„H$ = HEX$(Decimal&)„Temp$ = ""„FOR A% = 1 TO LEN(H$)„  NextChar$ = MID$(H$, A%, 1)„  NextNum% = INSTR("ABCDEF", NextChar$)„  IF NextNum% <> 0 THEN NextNum% = NextNum% + 9 ELSE NextNum% = VAL(NextChar$)„  BinValue% = 0„  FOR B% = 3 TO 0 STEP -1„    IF 2 ^ B% + BinValue% <= NextNum% THEN„      Temp$ = Temp$ + "1"„      BinValue% = BinValue% + 2 ^ B%„    ELSE„      Temp$ = Temp$ + "0"„    END IF„  NEXT B%„NEXT A%„Bin$ = Temp$„„END FUNCTION„Paul Kuliniewicz               ENIGMA CODING PROGRAM          home.aol.com/Borg953           07-10-96 (00:00)       QB, QBasic, PDS        761  26994    ECP.BAS     ' ***************************************************************************„' ***                       Enigma Coding Program                         ***„' ***************************************************************************„' written by Paul Kuliniewicz„' version 1.0„' WARNING!  ANY TAMPERING WITH THIS FILE MAY CAUSE IT TO MALFUNCTION AND„' DAMAGE ANY FILES YOU WORK WITH!  THE AUTHOR IS NOT RESPONSIBLE FOR DAMAGE„' CAUSED BY EDITING THIS FILE!„' This file is Public Domain.  You may distribute this file as you wish„' freely, as long as the file has not been altered in any way.„' Notice to Windows Users: only run this file in FULL SCREEN!  (this file„' writes and reads directly to and from screen memory.  Running in a window„' may cause unexpected, and possibly dangerous, results)„' *** Prepare for Operation Routine ***„DECLARE SUB CenterText (text$)„DECLARE SUB Shadow (urr%, urc%, llr%, llc%, lrr%, lrc%)„DECLARE SUB LoadImage (showme%())„DECLARE SUB SaveImage (saveme%())„DECLARE SUB StatusLine (message$, sector$)„DECLARE FUNCTION MessWithByte$ (original$)„DECLARE FUNCTION PseudoNOT$ (bit$)„DECLARE FUNCTION MakeBinary$ (convert%)„DECLARE FUNCTION MakeDecimal% (byte$)„DECLARE FUNCTION ConvBlock% (row%, column%, colormem%)„DECLARE FUNCTION ConvColor% (fore%, back%)„DECLARE FUNCTION Character$ ()„CLEAR„ON ERROR GOTO HandleError„KEY OFF„CLS„'$STATIC„DIM mainimage%(0 TO 4001)„DIM screenimage%(0 TO 4001)„DIM mainstatus$(1 TO 6)„DIM helpstatus$(1 TO 6)„FOR counter% = 1 TO 6„  READ mainstatus$(counter%)„NEXT counter%„FOR counter% = 1 TO 6„  READ helpstatus$(counter%)„NEXT counter%„CONST TRUE = -1„CONST FALSE = 0„firsttime% = FALSE„DEF SEG = &HB800„' *** Title Screen Display Routine ***„FOR counter% = ConvBlock%(1, 1, 1) TO ConvBlock%(24, 80, 1) STEP 2„  POKE counter%, ConvColor%(7, 1)„NEXT counter%„FOR counter% = ConvBlock%(25, 1, 1) TO ConvBlock%(25, 80, 1) STEP 2„  POKE counter%, ConvColor%(4, 7)„NEXT counter%„COLOR 7, 1„LOCATE 4, 1„CenterText "EEEEEE    CCCC    PPPPP "„CenterText "EEEEEE   CCCCCC   PPPPPP"„CenterText "EE       CC  CC   PP  PP"„CenterText "EE       CC       PP  PP"„CenterText "EEEEE    CC       PPPPPP"„CenterText "EEEEE    CC       PPPPP "„CenterText "EE       CC       PP    "„CenterText "EE       CC  CC   PP    "„CenterText "EEEEEE   CCCCCC   PP    "„CenterText "EEEEEE    CCCC    PP    "„PRINT„PRINT„CenterText "Enigma Coding Program v1.0"„PRINT„CenterText "1995 Paul Kuliniewicz"„StatusLine "Welcome to the Enigma Coding Program!  Press any key to continue.", "WELCOME"„SLEEP: trash$ = INKEY$„GOTO MainMenu„' *** Main Menu Routine ***„MainMenu:„IF firsttime% = FALSE THEN„  LOCATE 1, 1„  COLOR 4, 7„  PRINT "⁄ƒƒƒƒƒMAIN MENUƒƒƒƒƒø"„  PRINT "≥  1. Code a file   ≥"„  PRINT "≥  2. Decode a file ≥"„  PRINT "≥  3. Kill a file   ≥"„  PRINT "≥  4. Shell to DOS  ≥"„  PRINT "≥  5. Help          ≥"„  PRINT "≥  6. Leave ECP     ≥"„  PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 2, 22, 9, 2, 9, 22„  SaveImage mainimage%()„  firsttime% = TRUE„ELSE„  LoadImage mainimage%()„END IF„min% = 2„max% = 7„oldarrow% = 2„newarrow% = 2„choice% = 1„entered% = FALSE„DO„  POKE ConvBlock%(oldarrow%, 3, 0), ASC(" ")„  POKE ConvBlock%(newarrow%, 3, 0), ASC("Ø")„  StatusLine mainstatus$(choice%), "MENU"„  pressed$ = Character$„  oldarrow% = newarrow%„  IF LEN(pressed$) = 2 AND RIGHT$(pressed$, 1) = CHR$(72) THEN„    IF choice% = 1 THEN„      newarrow% = max%„      choice% = 6„    ELSE„      newarrow% = newarrow% - 1„      choice% = choice% - 1„    END IF„  ELSEIF LEN(pressed$) = 2 AND RIGHT$(pressed$, 1) = CHR$(80) THEN„    IF choice% = 6 THEN„      newarrow% = min%„      choice% = 1„    ELSE„      newarrow% = newarrow% + 1„      choice% = choice% + 1„    END IF„  ELSEIF pressed$ = CHR$(13) THEN„    entered% = TRUE„  END IF„LOOP UNTIL entered% = TRUE„ON choice% GOTO Code, Decode, Delete, DOS, Help, Quit„' *** Coding Routine ***„Code:„COLOR 4, 7„LOCATE 3, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒCODEƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 4, 3: PRINT "≥ Enter the file (and path, if needed) you wish to code. ≥"„LOCATE 5, 3: PRINT "≥ >                                                      ≥"„LOCATE 6, 3: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 4, 61, 7, 4, 7, 61„SaveImage screenimage%()„StatusLine "Type in the file name to code.", "CODE"„LOCATE 5, 6„LINE INPUT "", filename$„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒCODEƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ Coding file.  Please wait. ≥"„LOCATE 7, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 35, 8, 6, 8, 35„Tinker:„StatusLine "Please wait.  Accessing Disk.", "CODE"„info$ = SPACE$(10000)„OPEN filename$ FOR BINARY AS #1„IF LOF(1) = 0 THEN„  CLOSE #1„  KILL filename$„  ERROR 53„END IF„trash$ = MessWithByte$("NEW")„length& = LOF(1)„FOR counter& = 1 TO length& - (length& MOD 10000) STEP 10000„  GET #1, counter&, info$„  FOR count% = 1 TO LEN(info$)„    MID$(info$, count%, 1) = MessWithByte$(MID$(info$, count%, 1))„  NEXT count%„  PUT #1, counter&, info$„NEXT counter&„info$ = SPACE$(length& MOD 10000)„GET #1, (length& - (length& MOD 10000)) + 1, info$„FOR count% = 1 TO LEN(info$)„  MID$(info$, count%, 1) = MessWithByte$(MID$(info$, count%, 1))„NEXT count%„PUT #1, (length& - (length& MOD 10000)) + 1, info$„CLOSE #1„IF choice% = 2 THEN GOTO AllDone„LoadImage screenimage%()„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒCODEƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ Coding finished. ≥"„LOCATE 7, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 25, 8, 6, 8, 25„StatusLine "Press any key to continue.", "CODE"„SLEEP: trash$ = INKEY$„GOTO MainMenu„' *** Decoding Routine ***„Decode:„COLOR 4, 7„LOCATE 3, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒDECODEƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 4, 3: PRINT "≥ Enter the file (and path, if needed) you wish to decode. ≥"„LOCATE 5, 3: PRINT "≥ >                                                        ≥"„LOCATE 6, 3: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 4, 63, 7, 4, 7, 63„SaveImage screenimage%()„StatusLine "Type in the file name to decode.", "DECODE"„LOCATE 5, 6„LINE INPUT "", filename$„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒDECODEƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ Decoding file.  Please wait. ≥"„LOCATE 7, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 37, 8, 6, 8, 37„StatusLine "Please wait.  Accessing disk.", "DECODE"„GOTO Tinker„info$ = SPACE$(10000)„OPEN filename$ FOR BINARY AS #1„IF LOF(1) = 0 THEN„  CLOSE #1„  KILL filename$„  ERROR 53„END IF„trash$ = MessWithByte$("NEW")„length& = LOF(1)„FOR counter& = 1 TO length% - (length& MOD 10000) STEP 10000„  GET #1, counter&, info$„  FOR count% = 1 TO LEN(info$)„    MID$(info$, count%, 1) = MessWithByte$(MID$(info$, count%, 1))„  NEXT count%„  PUT #1, counter&, info$„NEXT counter&„info$ = SPACE$(length& MOD 10000)„GET #1, (length& - (length& MOD 10000)) + 1, info$„FOR count% = 1 TO LEN(info$)„  MID$(info$, count%, 1) = MessWithByte$(MID$(info$, count%, 1))„NEXT count%„PUT #1, (length& - (length& MOD 10000)) + 1, info$„CLOSE #1„AllDone:„LoadImage screenimage%()„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒDECODEƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ Decoding finished. ≥"„LOCATE 7, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 27, 8, 6, 8, 27„StatusLine "Press any key to continue.", "DECODE"„SLEEP: trash$ = INKEY$„GOTO MainMenu„' *** Killing Routine ***„Delete:„COLOR 4, 7„LOCATE 3, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒKILLƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 4, 3: PRINT "≥ Enter the file (and path, if needed) you wish to kill. ≥"„LOCATE 5, 3: PRINT "≥ >                                                      ≥"„LOCATE 6, 3: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 4, 61, 7, 4, 7, 61„SaveImage screenimage%()„StatusLine "Type in the file to kill.", "KILL"„LOCATE 5, 6„LINE INPUT "", filename$„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒDANGERƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ KILLING A FILE WILL TOTALLY DESTROY IT BEYOND ALL HOPE OF ≥"„LOCATE 7, 5: PRINT "≥ REPAIR!  NOT EVEN AN UNDELETE PROGRAM CAN SAVE IT!  ARE   ≥"„LOCATE 8, 5: PRINT "≥ YOU SURE YOU WANT TO DO THIS?  (Y/N)                      ≥"„LOCATE 9, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 66, 10, 6, 10, 66„StatusLine "Press Y for YES or N for NO.", "KILL"„DO„  rusure$ = UCASE$(Character$)„LOOP UNTIL rusure$ = "Y" OR rusure$ = "N"„IF rusure$ = "N" THEN GOTO MainMenu„LoadImage screenimage%()„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒWARNINGƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ THERE IS NO WAY TO RECOVER THIS FILE IF YOU KILL  ≥"„LOCATE 7, 5: PRINT "≥ IT.  ARE YOU ABSOLUTELY SURE YOU WANT TO DO THIS? ≥"„LOCATE 8, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 58, 9, 6, 9, 58„StatusLine "Press Y for YES or N for NO.", "KILL"„DO„  rusure$ = UCASE$(Character$)„LOOP UNTIL rusure$ = "Y" OR rusure$ = "N"„IF rusure$ = "N" THEN GOTO MainMenu„LoadImage screenimage%()„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒKILLƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ Killing file.  Please wait. ≥"„LOCATE 7, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 36, 8, 6, 8, 36„StatusLine "Please wait.  Accessing disk.", "KILL"„info$ = STRING$(10000, 0)„OPEN filename$ FOR BINARY AS #1„IF LOF(1) = 0 THEN„  CLOSE #1„  KILL filename$„  ERROR 53„END IF„length& = LOF(1)„FOR counter& = 1 TO length& - (length% MOD 10000) STEP 10000„  PUT #1, counter&, info$„NEXT counter&„info$ = SPACE$(length& MOD 10000)„PUT #1, (length& - (length& MOD 10000)) + 1, info$„CLOSE #1„KILL filename$„LoadImage screenimage%()„LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒKILLƒƒƒƒƒƒƒƒø"„LOCATE 6, 5: PRINT "≥ Killing finished. ≥"„LOCATE 7, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 6, 26, 8, 6, 8, 26„StatusLine "Press any key to continue.", "KILL"„SLEEP: trash$ = INKEY$„GOTO MainMenu„' *** DOS Shell Routine ***„DOS:„COLOR 4, 7„LOCATE 3, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒSHELLƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 4, 3: PRINT "≥ Initiating DOS Shell.  Type EXIT to  ≥"„LOCATE 5, 3: PRINT "≥ return to the Enigma Coding Program. ≥"„LOCATE 6, 3: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 4, 43, 7, 4, 7, 43„StatusLine "Press any key to shell to DOS.", "SHELL"„SLEEP: trash$ = INKEY$„COLOR 7, 0„CLS„SHELL„COLOR 4, 7„GOTO MainMenu„' *** Help Routine ***„Help:„LoadImage mainimage%()„COLOR 4, 7„LOCATE 3, 3: PRINT "⁄ƒƒƒƒƒHELP MENUƒƒƒƒƒø"„LOCATE 4, 3: PRINT "≥  1. Overview      ≥"„LOCATE 5, 3: PRINT "≥  2. Coding files  ≥"„LOCATE 6, 3: PRINT "≥  3. Killing files ≥"„LOCATE 7, 3: PRINT "≥  4. Shell to DOS  ≥"„LOCATE 8, 3: PRINT "≥  5. Disclaimer    ≥"„LOCATE 9, 3: PRINT "≥  6. Exit Help     ≥"„LOCATE 10, 3: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 4, 24, 11, 4, 11, 24„min% = 4„max% = 9„oldarrow% = 4„newarrow% = 4„helped% = 1„entered% = FALSE„DO„  POKE ConvBlock%(oldarrow%, 5, 0), ASC(" ")„  POKE ConvBlock%(newarrow%, 5, 0), ASC("Ø")„  StatusLine helpstatus$(helped%), "HELP"„  pressed$ = Character$„  oldarrow% = newarrow%„  IF LEN(pressed$) = 2 AND RIGHT$(pressed$, 1) = CHR$(72) THEN„    IF helped% = 1 THEN„      newarrow% = max%„      helped% = 6„    ELSE„      newarrow% = newarrow% - 1„      helped% = helped% - 1„    END IF„  ELSEIF LEN(pressed$) = 2 AND RIGHT$(pressed$, 1) = CHR$(80) THEN„    IF helped% = 6 THEN„      newarrow% = min%„      helped% = 1„    ELSE„      newarrow% = newarrow% + 1„      helped% = helped% + 1„    END IF„  ELSEIF pressed$ = CHR$(13) THEN„    entered% = TRUE„  END IF„LOOP UNTIL entered% = TRUE„SELECT CASE helped%„CASE 1„  LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒOVERVIEWƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 6, 5: PRINT "≥ The Enigma Coding Program is a useful file safety device ≥"„  LOCATE 7, 5: PRINT "≥ for coding, decoding, and killing files.  This program   ≥"„  LOCATE 8, 5: PRINT "≥ can code files in a way that only it can decode.  Also,  ≥"„  LOCATE 9, 5: PRINT "≥ to completely destroy files, you can kill them.  All     ≥"„  LOCATE 10, 5: PRINT "≥ this comes with an easy-to-use, window-based interface.  ≥"„  LOCATE 11, 5: PRINT "≥ The other options in the Help Menu will give you details ≥"„  LOCATE 12, 5: PRINT "≥ about these particular operations.  Please read the dis- ≥"„  LOCATE 13, 5: PRINT "≥ claimer before using this program.                       ≥"„  LOCATE 14, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 6, 65, 15, 6, 15, 65„CASE 2„  LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒCODINGƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 6, 5: PRINT "≥ The Enigma Coding Program can code files so other people ≥"„  LOCATE 7, 5: PRINT "≥ can't use them.  This process works with any file, whe-  ≥"„  LOCATE 8, 5: PRINT "≥ ther it's an *.EXE, *.BAT, *.WMF, *.INI, etc.  To code a ≥"„  LOCATE 9, 5: PRINT "≥ file, choose Code a File from the Main Menu and follow   ≥"„  LOCATE 10, 5: PRINT "≥ the simple instructions.  To decode a file, choose De-   ≥"„  LOCATE 11, 5: PRINT "≥ code a File from the Main Menu and follow the similar    ≥"„  LOCATE 12, 5: PRINT "≥ instructions.                                            ≥"„  LOCATE 13, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 6, 65, 14, 6, 14, 65„CASE 3„  LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒKILLINGƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 6, 5: PRINT "≥ The Enigma Coding Program can wipe out files.  This is   ≥"„  LOCATE 7, 5: PRINT "≥ not the same as erasing!  When you kill a file, all the  ≥"„  LOCATE 8, 5: PRINT "≥ bytes in the file are assigned the null (0) value before ≥"„  LOCATE 9, 5: PRINT "≥ being deleted.  Even an undelete program will only bring ≥"„  LOCATE 10, 5: PRINT "≥ back a bunch of null characters.  To kill a file, choose ≥"„  LOCATE 11, 5: PRINT "≥ Kill a File from the Main Menu and follow the simple     ≥"„  LOCATE 12, 5: PRINT "≥ instructions.                                            ≥"„  LOCATE 13, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 6, 65, 14, 6, 14, 65„CASE 4„  LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒSHELLINGƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 6, 5: PRINT "≥ The Enigma Coding Program allows you to temporarily use  ≥"„  LOCATE 7, 5: PRINT "≥ DOS while the program is running.  While in the shell,   ≥"„  LOCATE 8, 5: PRINT "≥ you can execute any commands you normally can.  When you ≥"„  LOCATE 9, 5: PRINT "≥ are finished, type EXIT to end the shell.  To execute    ≥"„  LOCATE 10, 5: PRINT "≥ the shell, choose Shell to DOS from the Main Menu.       ≥"„  LOCATE 11, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 6, 65, 12, 6, 12, 65„CASE 5„  LOCATE 5, 5: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒDISCLAIMERƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 6, 5: PRINT "≥ DO NOT TAMPER WITH OR EDIT THIS FILE IN ANY WAY!  DOING  ≥"„  LOCATE 7, 5: PRINT "≥ SO MAY CAUSE THIS PROGRAM TO MALFUNCTION AND DAMAGE ANY  ≥"„  LOCATE 8, 5: PRINT "≥ AND ALL FILES YOU WORK WITH!  THE AUTHOR IS NOT RESPON-  ≥"„  LOCATE 9, 5: PRINT "≥ SIBLE FOR ANY DAMAGE DUE TO ANY EDITING!  YOU ARE FREE   ≥"„  LOCATE 10, 5: PRINT "≥ TO COPY AND DISTRIBUTE THIS PROGRAM TO ANYONE YOU WISH,  ≥"„  LOCATE 11, 5: PRINT "≥ AS LONG AS THE FILE IS UNALTERED IN ANY CONCEIVABLE WAY! ≥"„  LOCATE 12, 5: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 6, 65, 13, 6, 13, 65„END SELECT„IF helped% = 6 THEN GOTO MainMenu„StatusLine "Press any key to return to the Help Menu.", "HELP"„SLEEP: trash$ = INKEY$„GOTO Help„' *** Exit Program Routine ***„Quit:„COLOR 4, 7„LOCATE 3, 3: PRINT "⁄ƒƒƒƒƒƒƒBYEƒƒƒƒƒƒƒƒø"„LOCATE 4, 3: PRINT "≥ Have a nice day! ≥"„LOCATE 5, 3: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„Shadow 4, 23, 6, 4, 6, 23„StatusLine "Press any key to exit ECP.", "BYE"„SLEEP: trash$ = INKEY$„SYSTEM„' *** Error Handler Routine ***„HandleError:„COLOR 4, 7„RESET„SELECT CASE ERR„CASE 52„  RESUME MainMenu„CASE 53„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ That file could not be found on the ≥"„  LOCATE 9, 7: PRINT "≥ indicated drive and directory.      ≥"„  LOCATE 10, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 46, 11, 8, 11, 46„CASE 61„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ There is not enough free space on that drive. ≥"„  LOCATE 9, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 56, 10, 8, 10, 56„CASE 64„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ That file name contains invalid DOS characters. ≥"„  LOCATE 9, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 58, 10, 8, 10, 58„CASE 70„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ That disk is write-protected. ≥"„  LOCATE 9, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 40, 10, 8, 10, 40„CASE 71„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ That disk drive is open or there is no disk inside. ≥"„  LOCATE 9, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 62, 10, 8, 10, 62„CASE 72„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ That disk's surface is physically flawed. ≥"„  LOCATE 9, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 52, 10, 8, 10, 52„CASE 75„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ You can't code, decode, or kill a path. ≥"„  LOCATE 9, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 50, 10, 8, 10, 50„CASE 76„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ That path can't be found on this drive. ≥"„  LOCATE 9, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 50, 10, 8, 10, 50„CASE ELSE„  LOCATE 7, 7: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒERRORƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„  LOCATE 8, 7: PRINT "≥ Unidentified error";„  PRINT USING " ### "; ERR;„  PRINT "reported!  Please contact the ≥"„  LOCATE 9, 7: PRINT "≥ author via e-mail at Borg953@aol.com.  Unfortunatly, ≥"„  LOCATE 10, 7: PRINT "≥ ECP cannot recover.                                  ≥"„  LOCATE 11, 7: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„  Shadow 8, 63, 12, 8, 12, 63„  StatusLine "Press any key to abort ECP.", "ERROR"„  SLEEP: trash$ = INKEY$„  SYSTEM„END SELECT„StatusLine "Press any key to return.", "ERROR"„SLEEP: trash$ = INKEY$„IF choice% >= 1 AND choice% <= 3 THEN LoadImage screenimage%()„SELECT CASE choice%„CASE 1„  RESUME Code„CASE 2„  RESUME Decode„CASE 3„  RESUME Delete„CASE ELSE„  RESUME MainMenu„END SELECT„' *** Data for Main Menu Status Line ***„DATA "Code a file with the ECP technique."„DATA "Decode a file coded with the ECP technique."„DATA "Totally destroy a file."„DATA "Use DOS without exiting ECP."„DATA "Additional help with ECP."„DATA "Returns you to your operating system."„' *** Data for Help Menu Status Line ***„DATA "Read the overview of ECP."„DATA "Read about coding and decoding files."„DATA "Read about killing files."„DATA "Read about the DOS Shell."„DATA "Read very important warnings."„DATA "Return to the Main Menu."„' *** End of file "ECP.BAS" ***„„SUB CenterText (text$)„  blanks% = INT((80 - LEN(text$)) / 2)„  PRINT TAB(blanks%); text$„END SUB„„FUNCTION Character$„  DO„    justpushed$ = INKEY$„  LOOP UNTIL justpushed$ <> CHR$(0)„  Character$ = justpushed$„END FUNCTION„„FUNCTION ConvBlock% (row%, column%, colormem%)„  ConvBlock% = (((column% * 2) - 2) + ((row% * 160) - 160)) + colormem%„END FUNCTION„„FUNCTION ConvColor% (fore%, back%)„  ConvColor% = fore% + (back% * 16)„END FUNCTION„„SUB LoadImage (showme%())„  FOR counter% = 0 TO 4001„    POKE counter%, showme%(counter%)„  NEXT counter%„END SUB„„FUNCTION MakeBinary$ (convert%)„  equiv$ = HEX$(convert%)„  IF convert% <= 15 THEN equiv$ = "0" + equiv$„  FOR counter% = 1 TO LEN(equiv$)„    onepart$ = MID$(equiv$, counter%, 1)„    IF onepart$ = "0" THEN„      result$ = result$ + "0000"„    ELSEIF onepart$ = "1" THEN„      result$ = result$ + "0001"„    ELSEIF onepart$ = "2" THEN„      result$ = result$ + "0010"„    ELSEIF onepart$ = "3" THEN„      result$ = result$ + "0011"„    ELSEIF onepart$ = "4" THEN„      result$ = result$ + "0100"„    ELSEIF onepart$ = "5" THEN„      result$ = result$ + "0101"„    ELSEIF onepart$ = "6" THEN„      result$ = result$ + "0110"„    ELSEIF onepart$ = "7" THEN„      result$ = result$ + "0111"„    ELSEIF onepart$ = "8" THEN„      result$ = result$ + "1000"„    ELSEIF onepart$ = "9" THEN„      result$ = result$ + "1001"„    ELSEIF onepart$ = "A" THEN„      result$ = result$ + "1010"„    ELSEIF onepart$ = "B" THEN„      result$ = result$ + "1011"„    ELSEIF onepart$ = "C" THEN„      result$ = result$ + "1100"„    ELSEIF onepart$ = "D" THEN„      result$ = result$ + "1101"„    ELSEIF onepart$ = "E" THEN„      result$ = result$ + "1110"„    ELSEIF onepart$ = "F" THEN„      result$ = result$ + "1111"„    END IF„  NEXT counter%„  MakeBinary$ = result$„END FUNCTION„„FUNCTION MakeDecimal% (byte$)„  result% = 0„  IF LEFT$(byte$, 1) = "1" THEN result% = result% + 128„  IF MID$(byte$, 2, 1) = "1" THEN result% = result% + 64„  IF MID$(byte$, 3, 1) = "1" THEN result% = result% + 32„  IF MID$(byte$, 4, 1) = "1" THEN result% = result% + 16„  IF MID$(byte$, 5, 1) = "1" THEN result% = result% + 8„  IF MID$(byte$, 6, 1) = "1" THEN result% = result% + 4„  IF MID$(byte$, 7, 1) = "1" THEN result% = result% + 2„  IF RIGHT$(byte$, 1) = "1" THEN result% = result% + 1„  MakeDecimal% = result%„END FUNCTION„„FUNCTION MessWithByte$ (original$)„  STATIC style%„  IF original$ = "NEW" THEN„    style% = 0„    EXIT FUNCTION„  END IF„  style% = style% + 1„  IF style% > 20 THEN style% = 1„  decimal% = ASC(original$)„  base2$ = MakeBinary$(decimal%)„  bit1$ = LEFT$(base2$, 1)„  bit2$ = MID$(base2$, 2, 1)„  bit3$ = MID$(base2$, 3, 1)„  bit4$ = MID$(base2$, 4, 1)„  bit5$ = MID$(base2$, 5, 1)„  bit6$ = MID$(base2$, 6, 1)„  bit7$ = MID$(base2$, 7, 1)„  bit8$ = RIGHT$(base2$, 1)„  SELECT CASE style%„      CASE 1„        bit1$ = PseudoNOT$(bit1$)„        bit4$ = PseudoNOT$(bit4$)„        bit6$ = PseudoNOT$(bit6$)„        bit7$ = PseudoNOT$(bit7$)„      CASE 2„        bit2$ = PseudoNOT$(bit2$)„        bit3$ = PseudoNOT$(bit3$)„        bit5$ = PseudoNOT$(bit5$)„        bit8$ = PseudoNOT$(bit8$)„      CASE 3„        SWAP bit1$, bit2$„        SWAP bit3$, bit4$„        SWAP bit5$, bit6$„        SWAP bit7$, bit8$„      CASE 4„        SWAP bit1$, bit8$„        SWAP bit2$, bit7$„        SWAP bit4$, bit5$„      CASE 5„        bit1$ = PseudoNOT$(bit1$)„        bit2$ = PseudoNOT$(bit2$)„        bit3$ = PseudoNOT$(bit3$)„        bit4$ = PseudoNOT$(bit4$)„        SWAP bit5$, bit8$„        SWAP bit6$, bit7$„      CASE 6„      CASE 7„        bit1$ = PseudoNOT$(bit1$)„        SWAP bit2$, bit3$„        bit4$ = PseudoNOT$(bit4$)„        bit5$ = PseudoNOT$(bit5$)„        SWAP bit6$, bit7$„        bit8$ = PseudoNOT$(bit8$)„      CASE 8„        SWAP bit1$, bit3$„        SWAP bit2$, bit4$„      CASE 9„        bit1$ = PseudoNOT$(bit1$)„        bit2$ = PseudoNOT$(bit2$)„        bit3$ = PseudoNOT$(bit3$)„        bit4$ = PseudoNOT$(bit4$)„        bit5$ = PseudoNOT$(bit5$)„        bit6$ = PseudoNOT$(bit6$)„        bit7$ = PseudoNOT$(bit7$)„        bit8$ = PseudoNOT$(bit8$)„      CASE 10„        SWAP bit1$, bit5$„        SWAP bit2$, bit6$„        SWAP bit3$, bit7$„        SWAP bit4$, bit8$„      CASE 11„        bit1$ = PseudoNOT$(bit1$)„        SWAP bit2$, bit3$„        bit4$ = PseudoNOT$(bit4$)„        bit5$ = PseudoNOT$(bit5$)„        SWAP bit6$, bit8$„        bit7$ = PseudoNOT$(bit7$)„      CASE 12„        SWAP bit1$, bit3$„        SWAP bit2$, bit6$„        bit4$ = PseudoNOT$(bit4$)„        SWAP bit5$, bit8$„        bit7$ = PseudoNOT$(bit7$)„      CASE 13„        SWAP bit1$, bit6$„        bit2$ = PseudoNOT$(bit2$)„        SWAP bit3$, bit8$„        bit4$ = PseudoNOT$(bit4$)„        bit5$ = PseudoNOT$(bit5$)„        bit7$ = PseudoNOT$(bit7$)„      CASE 14„        SWAP bit2$, bit7$„        SWAP bit4$, bit5$„      CASE 15„        bit1$ = PseudoNOT$(bit1$)„        SWAP bit2$, bit4$„        bit3$ = PseudoNOT$(bit3$)„        bit7$ = PseudoNOT$(bit7$)„        bit8$ = PseudoNOT$(bit8$)„      CASE 16„        SWAP bit1$, bit6$„        SWAP bit2$, bit7$„        SWAP bit3$, bit8$„        SWAP bit4$, bit5$„      CASE 17„        bit1$ = PseudoNOT$(bit1$)„        SWAP bit2$, bit4$„        bit3$ = PseudoNOT$(bit3$)„        bit5$ = PseudoNOT$(bit5$)„        SWAP bit6$, bit8$„        bit7$ = PseudoNOT$(bit7$)„      CASE 18„        SWAP bit1$, bit2$„        bit3$ = PseudoNOT$(bit3$)„        SWAP bit4$, bit8$„        SWAP bit5$, bit7$„        bit6$ = PseudoNOT$(bit6$)„      CASE 19„        SWAP bit1$, bit5$„        bit2$ = PseudoNOT$(bit2$)„        bit3$ = PseudoNOT$(bit3$)„        SWAP bit4$, bit6$„        bit7$ = PseudoNOT$(bit7$)„        bit8$ = PseudoNOT$(bit8$)„      CASE 20„        SWAP bit1$, bit8$„        bit2$ = PseudoNOT$(bit2$)„        bit3$ = PseudoNOT$(bit3$)„        bit4$ = PseudoNOT$(bit4$)„        bit5$ = PseudoNOT$(bit5$)„        bit6$ = PseudoNOT$(bit6$)„        bit7$ = PseudoNOT$(bit7$)„      END SELECT„  base2$ = bit1$ + bit2$ + bit3$ + bit4$ + bit5$ + bit6$ + bit7$ + bit8$„  decimal% = MakeDecimal%(base2$)„  MessWithByte$ = CHR$(decimal%)„END FUNCTION„„FUNCTION PseudoNOT$ (bit$)„  IF bit$ = "1" THEN„    PseudoNOT$ = "0"„  ELSE„    PseudoNOT$ = "1"„  END IF„END FUNCTION„„SUB SaveImage (saveme%())„  FOR counter% = 0 TO 4001„    saveme%(counter%) = PEEK(counter%)„  NEXT counter%„END SUB„„SUB Shadow (urr%, urc%, llr%, llc%, lrr%, lrc%)„  FOR counter% = ConvBlock%(urr%, urc%, 1) TO ConvBlock%(lrr%, lrc%, 1) STEP 160„    POKE counter%, ConvColor%(8, 0)„  NEXT counter%„  FOR counter% = ConvBlock%(llr%, llc%, 1) TO ConvBlock%(lrr%, lrc%, 1) STEP 2„    POKE counter%, ConvColor%(8, 0)„  NEXT counter%„END SUB„„SUB StatusLine (message$, sector$)„  display$ = SPACE$(72)„  area$ = SPACE$(7)„  LSET display$ = message$„  RSET area$ = sector$„  total$ = display$ + "≥" + area$„  FOR counter% = 1 TO 80„    POKE ConvBlock%(25, counter%, 1), ConvColor%(7, 4)„  NEXT counter%„  FOR counter% = 1 TO 80„    POKE ConvBlock%(25, counter%, 0), ASC(MID$(total$, counter%, 1))„  NEXT counter%„END SUB„Jonathan Leger                 XOR ENCRYPTION/DECRYPTION      leger@mail.dtx.net             08-10-96 (12:55)       QB, QBasic, PDS        168  6372     XOR.BAS     '(*** XOR.BAS ***)„'(*************************************************************************)„'(*** This is a small demonstration of the XOR encryption/decryption    ***)„'(*** method that will encrypt this file (assuming the name is XOR.BAS) ***)„'(*** and put it in the file XOR.XOR.  If you want it to decrypt the    ***)„'(*** XOR.XOR file once it's been encrypted, merely change the FILE$    ***)„'(*** to XOR.XOR and the OUTPUT$ to XOR.BAS (or whatever).  The key     ***)„'(*** we will be using is 15.  You can change that for your purposes,   ***)„'(*** but the key must be a value from 0 to 255.                        ***)„'(*************************************************************************)„'(*** This method of encryption is not very secure, since it can be     ***)„'(*** broken easily by the brute force method (though it used to be a   ***)„'(*** very popular form of encryption).  However, for most purposes,    ***)„'(*** such as game high scores or passwords, etc, it serves quite well, ***)„'(*** since the person has no way to know that the file was encrypted   ***)„'(*** using this method, and most people wouldn't think to try and      ***)„'(*** decrypt it themselves anyway.                                     ***)„'(*************************************************************************)„'(*** The File.XOR function returns a FALSE value (0) if the input file ***)„'(*** (FILE$) does ***) not exist, otherwise it returns TRUE (-1).      ***)„'(*************************************************************************)„„DECLARE FUNCTION File.XOR% (FILE$, output$, ekey%, sbarx%, sbary%, sbarlen%)„„SCREEN 0„WIDTH 80, 25„COLOR 7, 0„CLS„„FILE$ = "xor.bas"       '(*** We'll encrypt this file... ***)„output$ = "xor.xor"     '(*** ...and put the results here. ***)„ekey% = 15              '(*** Our encryption key will be 15. ***)„„LOCATE 1, 1„PRINT "Using XOR method of encryption/decription on " + UCASE$(FILE$) + "..."„„'(*** Use a status bar for the encryption. ***)„COLOR 15, 1„ErrVal = File.XOR%(FILE$, output$, ekey%, 1, 2, 40)„„IF ErrVal THEN    '(*** No errors! ***)„   LOCATE 1, 1: COLOR 7, 0„   PRINT STRING$(80, " ");„   LOCATE 1, 1„   PRINT "Success!  Results in file (" + UCASE$(output$) + ")."„ELSE„   '(*** The file didn't exist! ***)„   LOCATE 1, 1: COLOR 7, 0„   PRINT STRING$(80, " ");„   LOCATE 1, 1„   PRINT "Input file ("; UCASE$(FILE$); ") does not exist."„END IF„„DEFINT A-Z„'(*** File.XOR () ****)„'(*** ----------- ****)„'(*** Thie function will take a file (INPUT$) and XOR each byte with  ***)„'(*** the given encryption key (EKEY), puting the results into a file ***)„'(*** (OUTPUT$).  If you want a status bar showing progress, pass the ***)„'(*** x and y location of the status bar on-screen (SBARX, SBARY). If ***)„'(*** no status bar is desired, pass a 0 for the x and y.  SBARLEN is ***)„'(*** the length you want the status bar to be.                       ***)„'(*** NOTICE:  To unXOR the file, just pass the XORed file the the    ***)„'(*** function with the _SAME_ encryption key.  Given the nature of   ***)„'(*** XOR, an individual decryption scheme is not needed.  Note, too, ***)„'(*** that EKEY can only be from 0 to 255.                            ***)„'(*** --------------------------------------------------------------- ***)„FUNCTION File.XOR (FILE$, output$, ekey, sbarx, sbary, sbarlen)„„'(*** Check if the input file passed exist. ***)„'(*** If the input file doesn't exist, exit with error  ***)„'(*** value 0 [FALSE].                                  ***)„filenum = FREEFILE„OPEN FILE$ FOR BINARY AS filenum„„IF LOF(filenum) = 0 THEN„   '(*** Pass error value back since file didn't exist. ***)„   File.XOR = 0„   CLOSE filenum„   '(*** Kill the 0 byte file we made by opening it. ***)„   KILL FILE$„   EXIT FUNCTION„END IF„„'(*** Both files exist, open them. ***)„CLOSE filenum„OPEN FILE$ FOR INPUT AS filenum„outputnum = FREEFILE„OPEN output$ FOR OUTPUT AS outputnum„„'(*** If we want a status bar, do the encryption with a status bar! ***)„IF sbarx > 0 THEN„   '(*** Draw empty status bar and reset the byte count# to 0. ***)„   LOCATE sbary, sbarx: PRINT STRING$(sbarlen, 177);„   count# = 0„   '(*** Encrypt/Decrypt the file. ***)„   DO WHILE NOT EOF(1)„   „      '(*** Read a byte from the file. ***)„      bytes.left# = LOF(filenum) - LOF(outputnum)„      IF bytes.left# < 100 THEN„         read.bytes$ = INPUT$(bytes.left#, filenum)„         chunk = bytes.left#„      ELSE„         read.bytes$ = INPUT$(100, filenum)„         chunk = 100„      END IF„     „      '(*** Increment byte count#. ***)„      count# = count# + chunk„„      '(*** XOR the bytes with encryption key. ***)„      FOR byte.count = 1 TO chunk„         changed.byte$ = changed.byte$ + CHR$(ASC(MID$(read.bytes$, byte.count, 1)) XOR ekey)„      NEXT byte.count„     „      '(*** Print it to the output file. ***)„      PRINT #outputnum, changed.byte$;„      changed.byte$ = ""„„      '(*** If a chunk of 100 bytes has been read, update status bar. ***)„      IF count# MOD 1000 = 0 THEN„         LOCATE sbary, sbarx„         PRINT STRING$(sbarlen * (count# / LOF(1)), 219);„      END IF„„   LOOP„     „      LOCATE sbary, sbarx„      PRINT STRING$(sbarlen, 219);„„ELSE„'(*** We didn't want a status bar, so skip the status bar.  This will ***)„'(*** give some extra speed because the print code is ignored.        ***)„  „   DO WHILE NOT EOF(1)„     „      '(*** Read a byte from the file. ***)„      bytes.left# = LOF(filenum) - LOF(outputnum)„      IF bytes.left# < 100 THEN„         read.bytes$ = INPUT$(bytes.left#, filenum)„         chunk = bytes.left#„      ELSE„         read.bytes$ = INPUT$(100, filenum)„         chunk = 100„      END IF„    „      '(*** XOR the bytes with encryption key. ***)„      FOR byte.count = 1 TO chunk„         changed.byte$ = changed.byte$ + CHR$(ASC(MID$(read.bytes$, byte.count, 1)) XOR ekey)„      NEXT byte.count„    „      '(*** Print it to the output file. ***)„      PRINT #outputnum, changed.byte$;„      changed.byte$ = ""„„   LOOP„„END IF„„'(*** Close the files we used. ***)„CLOSE filenum, outputnum„„'(*** All done with no errors, so return a TRUE value. ***)„File.XOR = -1„„END FUNCTION„„Kurt Kuzba                     8-BIT TO 6-BIT ENCODER/DECODER FidoNet QUIK_BAS Echo          06-01-96 (00:00)       QB, QBasic, PDS        44   1821     826_BIT.BAS '>   But my question is: Can we talk about and share code for„'>   en/decoders? Since this topic is on my mind anyway, has„'>   anyone programmed a MIME-en/decoder and/or a UUEn/Decoder?„'>........................................„'   One of the simplest forms of encoding to text is to convert„'from an 8-bit value to 6-bit. This allows you to have three„'normal ASCII characters coverted to four characters  within the„'range of the lower, message format usable, ASCII. Try this:„'_|_|_|  826_BIT.BAS„'_|_|_|  This program demonstrates one method of encoding data„'_|_|_|  to conform to low ASCII requirements by turning three„'_|_|_|  8-bit values into four 6-bit values and vice-verse.„'_|_|_|  No warrantees or guarantees are given or implied.„'_|_|_|  Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (6/1/96)„DECLARE FUNCTION ENCODE$ (Bytes3$)„DECLARE FUNCTION UNCODE$ (Bytes4$)„PRINT : PRINT„test$ = CHR$(176) + CHR$(177) + CHR$(178)„PRINT test$, ENCODE$(test$), UNCODE$(ENCODE$(test$))„test$ = CHR$(254) + CHR$(219) + CHR$(129)„PRINT test$, ENCODE$(test$), UNCODE$(ENCODE$(test$))„test$ = CHR$(17) + CHR$(21) + CHR$(7)„PRINT test$, ENCODE$(test$), UNCODE$(ENCODE$(test$))„test$ = "ABC"„PRINT test$, ENCODE$(test$), UNCODE$(ENCODE$(test$))„FUNCTION ENCODE$ (Bytes3$)„   Result$ = "": B& = 0„   FOR t% = 3 TO 1 STEP -1„      B& = B& * 256 + ASC(MID$(Bytes3$, t%))„   NEXT„   FOR t% = 1 TO 4„      Result$ = Result$ + CHR$(48 + (B& AND 63)): B& = B& \ 64„   NEXT: ENCODE$ = Result$„END FUNCTION„FUNCTION UNCODE$ (Bytes4$)„   Result$ = "": B& = 0„   FOR t% = 4 TO 1 STEP -1„      B& = B& * 64 + ASC(MID$(Bytes4$, t%)) - 48„   NEXT„   FOR t% = 1 TO 3„      Result$ = Result$ + CHR$(B& AND 255): B& = B& \ 256„   NEXT: UNCODE$ = Result$„END FUNCTION„'_|_|_|   end   826_BIT.BAS„Scott Turchin                  XOR ENCRYPTION                 nitehawk@tscnet.com            10-14-96 (23:58)       QB, QBasic, PDS        20   791      ENCRYPT.BAS 'This SUB is old by internet standards of encryption, and there are „'certain legalities for certain encryption methods due to a patent on „'some types of encryption. But this one utilizes the XOR and again, is „'old by internet standards, but EXCELLENT for encrypting strings inside „'an executable or a library (Registration purposes etc.) I've tested it „'with executable files and it will apparantly encrypt anything.„'PW$ is the password, if given again exactly the same as it was used to „'ENCRYPT St$, it will DECRYPT, otherwise it will re-ENCRYPT the St$„SUB ENCRYPT (PW$,St$) PUBLIC„Z=0„target$=""„FOR Y=1 TO LEN(St$)„	A$=MID$(St$,Y,1)„	INCR Z,1„	IF Z > LEN(PW$) THEN Z=1„	B$=MID$(PW$,Z,1)„	Target$=Target$+CHR$(ASCII(A$) XOR ASCII(B$))„NEXT„St$=Target$„END SUB„