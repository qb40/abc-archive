Keith Jennings                 QB Shooter                     sturmges@aol.com               03-16-03 (  :  )       QB, PDS                808  27928    abash.bas   REM abash.bas„REM Keith Jennings„„REM controls :-„REM left CTRL - move left„REM right ALT - move right„REM right SHIFT - fire„REM F key - cheat !„REM Q key - quit„„TYPE alien„x AS INTEGER„y AS INTEGER„mx AS INTEGER„my AS INTEGER„mxc AS INTEGER„myc AS INTEGER„mr AS INTEGER„fired AS INTEGER„angle AS INTEGER„typ AS INTEGER    ' -1 = destroyed„xc AS INTEGER„yc AS INTEGER„r AS INTEGER„point1 AS INTEGER ' pointer to angles„point2 AS INTEGER ' pointer to times„point3 AS INTEGER ' pointer to graphics()„speed AS INTEGER„count AS INTEGER„dir AS INTEGER    ' left/right„xp AS INTEGER„yp AS INTEGER„temp AS INTEGER„ftime AS INTEGER      ' flight time„setup AS INTEGER„clockw AS INTEGER     '1= cwise 2= a cwise„health AS INTEGER„mspeed AS INTEGER„END TYPE„„TYPE explode„x AS INTEGER„y AS INTEGER„pointer AS INTEGER„END TYPE„„TYPE ship„x AS INTEGER„y AS INTEGER„END TYPE„„TYPE missile„x AS INTEGER„y AS INTEGER„END TYPE„„COMMON player AS ship„„SCREEN 9„WIDTH 80, 43„DEFINT A-Z„DEF SEG = 0„POKE &H417, 0: POKE &H418, 0„CLS„„CONST left = 1, right = 2, north = 3, south = 4„CONST llimit = 12, rlimit = 616„CONST normal = 0, expand = 1, swoop = 2, home = 3„CONST ulimit = 0, lrlimit = 326, cheat = 1„„DIM SHARED aliens(40) AS alien, angles(80), choices(16), times!(40)„DIM SHARED expl(40) AS explode, shots(3) AS missile, graphics(800), „pmax(8)„DIM SHARED pow(100), mbase(100), cmisl(100), pmisl(100), cas!(359), „sas!(359)„„REM set up graphics„FOR j = 0 TO 799 STEP 100„FOR y = 0 TO 11„FOR x = 0 TO 11„READ co„PSET (x, y), co„NEXT x, y„GET (0, 0)-(11, 11), graphics(j)„NEXT j„REM explosion„FOR y = 0 TO 11„FOR x = 0 TO 11„READ co„PSET (x, y), co„NEXT x, y„GET (0, 0)-(11, 11), pow(0)„PUT (0, 0), pow, XOR„REM pmisl(),cmisl()„FOR l = 1 TO 2„FOR y = 0 TO 10„FOR x = 0 TO 7„READ co„PSET (x, y), co„NEXT x, y„IF l = 1 THEN GET (0, 0)-(7, 10), pmisl(0)„IF l = 2 THEN GET (0, 0)-(7, 10), cmisl(0)„NEXT l„PUT (0, 0), cmisl(0), XOR„REM mbase()„FOR y = 0 TO 6„FOR x = 0 TO 11„READ co„PSET (x, y), co„NEXT x, y„GET (0, 0)-(11, 6), mbase(0)„FOR j = 1 TO 8: READ pmax(j): NEXT j„FOR j = 1 TO 8: choices(j) = j * 10: NEXT j„FOR j = 9 TO 16„choices(j) = 280 + j * 10„NEXT j„FOR j = 0 TO 359„cas!(j) = COS(j * 3.1415 / 180): sas!(j) = SIN(j * 3.1415 / 180)„NEXT j„h& = 0„DO„CLS„nPerRow = 2: height = 120: lives = 5: player.x = 200: player.y = 307: „fq! = .95: als = 0: new& = 10000: upcount = 0„PUT (player.x, player.y), mbase, XOR„lvx = 12„FOR j = 1 TO lives„PUT (lvx, 343), mbase, XOR„lvx = lvx + 14„NEXT j„lvx = lvx - 14: s& = 0: acc = 5„LINE (llimit + 2, 314)-(rlimit + 4, 314), 2„COLOR 2„LOCATE 42, 3: PRINT "Score :"; STR$(s&) + STRING$(8 - LEN(STR$(s&)), „32); "High :"; STR$(h&);„DO„max = nPerRow * 4„GOSUB init„RANDOMIZE TIMER: s = CINT(RND * 30): t! = TIMER: expandF = 0: hits = 0„s2 = CINT(RND * 5): t2! = TIMER: count = 0: tcount = INT(max / 3): form „= 0: t3! = TIMER„mcount = 0: nshots = 0: pass1 = 0: pass2 = 0: scol = 1: ecol = nPerRow: „newDir = -1„REM main„DO„a$ = UCASE$(INKEY$)„status = PEEK(&H418)„kbd = PEEK(&H417)„IF (kbd AND 4) AND player.x > llimit + 8 THEN„PUT (player.x, player.y), mbase, XOR„player.x = player.x - 8„PUT (player.x, player.y), mbase, XOR„END IF„IF (kbd AND 8) AND player.x < rlimit - 8 THEN„PUT (player.x, player.y), mbase, XOR„player.x = player.x + 8„PUT (player.x, player.y), mbase, XOR„END IF„FOR aliens = scol TO ecol„IF (aliens(aliens).typ <= normal AND expandF < 2) OR „(aliens(aliens).typ > expand AND expandF < 2) THEN„IF aliens(aliens).typ = normal THEN PUT (aliens(aliens).x, „aliens(aliens).y), graphics(aliens(aliens).point3 * 100 - 100), XOR„SELECT CASE aliens(aliens).dir„CASE right„aliens(aliens).x = aliens(aliens).x + 2„CASE left„aliens(aliens).x = aliens(aliens).x - 2„END SELECT„IF aliens(aliens).typ = normal OR form = 1 THEN„REM check bounds„IF aliens(aliens).x = llimit2 THEN„aliens(aliens).dir = right: newDir = right„ELSEIF aliens(aliens).x = rlimit2 THEN„aliens(aliens).dir = left: newDir = left„END IF„REM show„IF aliens(aliens).typ = normal THEN„IF aliens(aliens).point3 = pmax(aliens(aliens).point3) THEN „aliens(aliens).point3 = aliens(aliens).point3 - 1 ELSE aliens(aliens).point3 = „aliens(aliens).point3 + 1„PUT (aliens(aliens).x, aliens(aliens).y), „graphics(aliens(aliens).point3 * 100 - 100), XOR„END IF„END IF„END IF„NEXT aliens„IF newDir > -1 THEN„FOR j = 1 TO ecol„aliens(j).dir = newDir„NEXT j„IF ecol = nPerRow * 4 THEN newDir = -1„END IF„REM break formation„IF TIMER - t2! >= s2 AND count < tcount THEN„tries = 0„DO„tries = tries + 1: IF tries = 50 THEN EXIT DO„j = CINT(RND * (max - 1) + 1)„LOOP UNTIL aliens(j).typ = normal OR (aliens(j).typ = expand AND „aliens(j).temp = 0)„IF tries < 50 THEN„count = count + 1„aliens(j).typ = swoop: aliens(j).speed = CINT(RND + 1)„times!(aliens(j).point2) = TIMER: aliens(j).count = 0„aliens(j).ftime = CINT(RND * 5 + 5): aliens(j).r = 0„angles(aliens(j).point1) = choices(CINT(RND * 15 + 1))„aliens(j).xc = aliens(j).x: aliens(j).yc = aliens(j).y„aliens(j).xp = aliens(j).x: aliens(j).yp = aliens(j).y„s2 = CINT(RND * 5): t2! = TIMER„GOSUB normtest„END IF„END IF„REM diving invader„FOR rep = 1 TO 7„DO„als = als + 1„IF als > max THEN GOTO skipover„LOOP UNTIL aliens(als).typ = swoop OR aliens(als).typ = home„IF aliens(als).typ = swoop AND TIMER - times!(aliens(als).point2) <= „aliens(als).ftime THEN„aliens(als).count = aliens(als).count + 1„IF aliens(als).count MOD aliens(als).speed = 0 THEN    ' ready to move„aliens(als).count = 0„aliens(als).r = aliens(als).r + 2„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR„SELECT CASE angles(aliens(als).point1)„CASE IS > 270„tempx! = aliens(als).xc - aliens(als).r * cas!(90 - „(angles(aliens(als).point1) MOD 360))„tempy! = aliens(als).yc + aliens(als).r * sas!(90 - „(angles(aliens(als).point1) MOD 360))„aliens(als).xp = tempx!„aliens(als).yp = tempy!„CASE IS < 90„tempx! = aliens(als).xc + aliens(als).r * „cas!(angles(aliens(als).point1))„tempy! = aliens(als).yc + aliens(als).r * „sas!(angles(aliens(als).point1))„aliens(als).xp = tempx!„aliens(als).yp = tempy!„END SELECT„IF aliens(als).xp > rlimit OR aliens(als).xp < llimit THEN„IF aliens(als).xp > rlimit THEN aliens(als).xp = llimit„IF aliens(als).xp < llimit THEN aliens(als).xp = rlimit„aliens(als).xc = aliens(als).xp: aliens(als).yc = aliens(als).yp: „aliens(als).r = 0„END IF„IF aliens(als).yp > lrlimit THEN„aliens(als).yp = ulimit: aliens(als).xc = aliens(als).xp„aliens(als).yc = aliens(als).yp: aliens(als).r = 0„END IF„hitF = 0: j = als: GOSUB hit1„IF hitF = 0 THEN„IF aliens(als).point3 = pmax(aliens(als).point3) THEN „aliens(als).point3 = aliens(als).point3 - 1 ELSE aliens(als).point3 = aliens(als).point3 „+ 1„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR„IF aliens(als).yp < height AND expandF < 2 THEN aliens(als).typ = home„END IF„END IF„END IF„REM looping invader„IF aliens(als).typ = swoop AND aliens(als).setup = 0 AND TIMER - „times!(aliens(als).point2) > aliens(als).ftime THEN„SELECT CASE angles(aliens(als).point1)„CASE IS < 90„aliens(als).clockw = 1„aliens(als).r = CINT(RND * 70 + 10)„aliens(als).xc = aliens(als).xp - aliens(als).r * cas!((90 - „angles(aliens(als).point1)))„aliens(als).yc = aliens(als).yp + aliens(als).r * sas!((90 - „angles(aliens(als).point1)))„angles(aliens(als).point1) = 360 - (90 - angles(aliens(als).point1))„start = angles(aliens(als).point1)„turns = CINT(RND + 1)„min = 370 - start: maxi = 440 - start„add = CINT(RND * (maxi - min)) + min„angles(aliens(als).point1 + 1) = start + turns * 360 + add„CASE IS > 270„aliens(als).clockw = 2„aliens(als).r = CINT(RND * 70 + 10)„aliens(als).xc = aliens(als).xp + aliens(als).r * „cas!(angles(aliens(als).point1) MOD 360)„aliens(als).yc = aliens(als).yp + aliens(als).r * „sas!(angles(aliens(als).point1) MOD 360)„angles(aliens(als).point1) = (angles(aliens(als).point1) MOD 360) - 180„start = angles(aliens(als).point1)„turns = CINT(RND + 1)„min = -190 - start: maxi = -260 - start„add = CINT(RND * (maxi - min)) + min„angles(aliens(als).point1 + 1) = start - turns * 360 + add„END SELECT„aliens(als).setup = 1: aliens(als).count = 0„END IF„REM circular pattern„IF aliens(als).typ = swoop AND aliens(als).setup = 1 THEN„aliens(als).count = aliens(als).count + 1„IF aliens(als).count MOD aliens(als).speed = 0 THEN„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR: aliens(als).count = 0„IF aliens(als).clockw = 1 THEN angles(aliens(als).point1) = „angles(aliens(als).point1) + 2 ELSE angles(aliens(als).point1) = „angles(aliens(als).point1) - 2„ang = angles(aliens(als).point1): ang = ang MOD 360„IF ang < 0 THEN ang = ang + 360„aliens(als).xp = aliens(als).xc + aliens(als).r * cas!(ang)„aliens(als).yp = aliens(als).yc + aliens(als).r * sas!(ang)„hor = aliens(als).xp - aliens(als).xc: ver = aliens(als).yp - „aliens(als).yc„IF hor < 0 THEN hor = hor * -1: IF ver < 0 THEN ver = ver * -1„IF aliens(als).xp < llimit THEN aliens(als).xp = rlimit - 8: „aliens(als).xc = rlimit + hor - 8„IF aliens(als).xp > rlimit THEN aliens(als).xp = llimit + 8: „aliens(als).xc = llimit - hor + 8„IF aliens(als).yp < ulimit THEN aliens(als).yp = lrlimit - 8: „aliens(als).yc = lrlimit + ver - 8„IF aliens(als).yp > lrlimit THEN aliens(als).yp = ulimit + 8: „aliens(als).yc = ulimit - ver + 8„hitF = 0: j = als: GOSUB hit1„IF hitF = 0 THEN„IF aliens(als).point3 = pmax(aliens(als).point3) THEN „aliens(als).point3 = aliens(als).point3 - 1 ELSE aliens(als).point3 = aliens(als).point3 „+ 1„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR„IF aliens(als).yp < height AND expandF < 2 THEN aliens(als).typ = home: „aliens(als).setup = 0„IF (aliens(als).clockw = 1 AND angles(aliens(als).point1) >= „angles(aliens(als).point1 + 1)) OR (aliens(als).clockw = 2 AND „angles(aliens(als).point1) <= angles(aliens(als).point1 + 1)) THEN„IF aliens(als).clockw = 2 THEN angles(aliens(als).point1) = „(angles(aliens(als).point1) MOD 360) + 270„aliens(als).setup = 0: aliens(als).count = 0: aliens(als).speed = „CINT(RND + 1)„times!(aliens(als).point2) = TIMER„aliens(als).ftime = CINT(RND * 5) + 5: aliens(als).r = 0„aliens(als).xc = aliens(als).xp: aliens(als).yc = aliens(als).yp„END IF„END IF„END IF„END IF„REM rejoin battle group„IF aliens(als).typ = home THEN„IF aliens(als).xp = aliens(als).x AND aliens(als).yp = aliens(als).y „AND expandF < 2 THEN aliens(als).typ = normal: count = count - 1: s2 = „CINT(RND * 5): t2! = TIMER: form = 0„IF aliens(als).xp = aliens(als).x AND aliens(als).yp = aliens(als).y „AND expandF = 2 THEN„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR„IF aliens(als).point3 = pmax(aliens(als).point3) THEN „aliens(als).point3 = aliens(als).point3 - 1 ELSE aliens(als).point3 = aliens(als).point3 „+ 1„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR„END IF„IF aliens(als).xp <> aliens(als).x OR aliens(als).yp <> aliens(als).y „THEN„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR„IF aliens(als).xp < aliens(als).x THEN aliens(als).xp = aliens(als).xp „+ 1„IF aliens(als).xp > aliens(als).x THEN aliens(als).xp = aliens(als).xp „- 1„IF aliens(als).yp < aliens(als).y THEN aliens(als).yp = aliens(als).yp „+ 1„IF aliens(als).xp < llimit THEN aliens(als).xp = rlimit„IF aliens(als).xp > rlimit THEN aliens(als).xp = llimit„IF aliens(als).point3 = pmax(aliens(als).point3) THEN „aliens(als).point3 = aliens(als).point3 - 1 ELSE aliens(als).point3 = aliens(als).point3 „+ 1„PUT (aliens(als).xp, aliens(als).yp), graphics(aliens(als).point3 * 100 „- 100), XOR„IF aliens(als).xp = aliens(als).x AND aliens(als).yp = aliens(als).y „AND expandF < 2 THEN aliens(als).typ = normal: count = count - 1: s2 = „CINT(RND * 5): t2! = TIMER: form = 0„END IF„END IF„NEXT rep„skipover:„IF als > max THEN als = 0„REM expansion„xdiv = (nPerRow / 2) * 12 + xstart„FOR aliens = scol TO ecol„IF aliens(aliens).typ = expand THEN„IF aliens(aliens).temp = 0 THEN PUT (aliens(aliens).x, „aliens(aliens).y), graphics(aliens(aliens).point3 * 100 - 100), XOR„IF aliens(aliens).x >= xdiv THEN angle = 75 ELSE angle = 115„SELECT CASE aliens(aliens).dir„CASE south„aliens(aliens).r = aliens(aliens).r + 1„aliens(aliens).x = aliens(aliens).xc + aliens(aliens).r * cas!(angle)„aliens(aliens).y = aliens(aliens).yc + aliens(aliens).r * sas!(angle)„CASE north„aliens(aliens).r = aliens(aliens).r - 1„aliens(aliens).x = aliens(aliens).xc + aliens(aliens).r * cas!(angle)„aliens(aliens).y = aliens(aliens).yc + aliens(aliens).r * sas!(angle)„END SELECT„IF aliens(aliens).r = 0 THEN aliens(aliens).dir = south„IF aliens(aliens).r = 80 THEN aliens(aliens).dir = north„IF aliens(aliens).point3 = pmax(aliens(aliens).point3) THEN „aliens(aliens).point3 = aliens(aliens).point3 - 1 ELSE aliens(aliens).point3 = „aliens(aliens).point3 + 1„IF aliens(aliens).temp = 0 THEN PUT (aliens(aliens).x, „aliens(aliens).y), graphics(aliens(aliens).point3 * 100 - 100), XOR„END IF„NEXT aliens„IF expandF = 1 THEN„FOR j = 1 TO max STEP nPerRow„IF aliens(j).x = xstart AND aliens > max THEN EXIT FOR„NEXT j„IF j <= max THEN„FOR j = 1 TO max„IF aliens(j).typ < normal THEN aliens(j).temp = aliens(j).typ„IF aliens(j).typ <= normal THEN„tdir = aliens(j).dir„aliens(j).typ = expand„aliens(j).dir = south„aliens(j).xc = aliens(j).x„aliens(j).yc = aliens(j).y„aliens(j).r = 0„t! = TIMER: s = CINT(RND * 20): expandF = 2„END IF„NEXT j„END IF„END IF„IF TIMER - t! >= s AND expandF = 2 AND aliens > max THEN„FOR j = 1 TO max„IF aliens(j).x = aliens(j).xc AND aliens(j).y = aliens(j).yc AND „aliens(j).typ = expand THEN„FOR j = 1 TO max„IF aliens(j).temp = 0 AND aliens(j).typ = expand THEN aliens(j).typ = „normal: aliens(j).dir = tdir„IF aliens(j).temp = -1 THEN aliens(j).typ = aliens(j).temp: „aliens(j).dir = tdir„NEXT j„expandF = 0: t! = TIMER: s = CINT(RND * 30)„x = xstart: y = height„FOR j = 1 TO max„IF aliens(j).x <> x THEN aliens(j).x = x„IF aliens(j).y <> y THEN aliens(j).y = y„IF aliens(j).typ = swoop THEN aliens(j).dir = tdir„IF aliens(j).typ = home AND aliens(j).xp = aliens(j).x AND aliens(j).yp „= aliens(j).y THEN aliens(j).typ = normal: aliens(j).dir = tdir: count „= count - 1: s2 = CINT(RND * 5): t2! = TIMER: form = 0„x = x + 12„IF x > xstart + (nPerRow - 1) * 12 THEN x = xstart: y = y + 12„NEXT j„EXIT FOR„END IF„NEXT j„END IF„REM fire !„FOR j = 1 TO max„IF (aliens(j).fired = 1 AND aliens(j).angle > 0) THEN„PUT (aliens(j).mx, aliens(j).my), cmisl, XOR„aliens(j).mr = aliens(j).mr + aliens(j).mspeed„aliens(j).mx = aliens(j).mxc + aliens(j).mr * cas!(aliens(j).angle)„aliens(j).my = aliens(j).myc + aliens(j).mr * sas!(aliens(j).angle)„IF aliens(j).mx < llimit THEN aliens(j).mx = rlimit: aliens(j).mxc = „rlimit: aliens(j).myc = aliens(j).my: aliens(j).mr = 0„IF aliens(j).mx > rlimit THEN aliens(j).mx = llimit: aliens(j).mxc = „llimit: aliens(j).myc = aliens(j).my: aliens(j).mr = 0„IF aliens(j).my <= lrlimit THEN GOSUB hit2„IF aliens(j).my > lrlimit OR lives <= 0 OR hits = max THEN „aliens(j).fired = 0: mcount = mcount - 1„IF aliens(j).my <= lrlimit AND hits < max AND lives > 0 THEN PUT „(aliens(j).mx, aliens(j).my), cmisl, XOR„END IF„NEXT j„tries = 0„DO„tries = tries + 1„j = CINT(RND * (max - 1) + 1)„LOOP UNTIL (aliens(j).typ > expand AND aliens(j).xp <> player.x AND „aliens(j).yp < player.y - 24 AND aliens(j).fired = 0) OR (aliens(j).typ = „expand AND aliens(j).temp = 0 AND aliens(j).x <> player.x AND „aliens(j).fired = 0) OR (aliens(j).typ = normal AND aliens(j).fired = 0) OR „tries = 50„IF RND > fq! AND mcount < 5 AND lives > 0 AND tries < 50 THEN„IF aliens(j).typ <= expand THEN x = aliens(j).x: y = aliens(j).y ELSE x „= aliens(j).xp: y = aliens(j).yp„hor = x - player.x: ver = player.y - y„IF hor < 0 THEN hor = hor * -1„rand! = RND„WHILE 1 - rand! >= .6„rand! = rand! + RND * rand!„WEND„hor = hor + rand! * acc * 16„IF aliens(j).typ > normal THEN aliens(j).angle = ATN(ver / hor) * 57.3 „ELSE aliens(j).angle = 90„IF player.x < x THEN aliens(j).angle = (90 - aliens(j).angle) + 90„aliens(j).fired = 1: aliens(j).mx = x + 2: aliens(j).my = y + 12„aliens(j).mxc = aliens(j).mx: aliens(j).myc = aliens(j).my: „aliens(j).mr = 0„PUT (aliens(j).mx, aliens(j).my), cmisl, XOR: mcount = mcount + 1„IF nPerRow > 6 AND RND > 1 - ((max - hits) / max) THEN aliens(j).mspeed „= 8 ELSE aliens(j).mspeed = 4„END IF„FOR j = 1 TO 3„IF shots(j).x > 0 THEN„PUT (shots(j).x, shots(j).y), pmisl, XOR„shots(j).y = shots(j).y - 4„IF shots(j).y >= ulimit THEN GOSUB hit3„IF shots(j).y < ulimit OR lives = 0 OR hits = max THEN shots(j).x = 0: „nshots = nshots - 1„IF shots(j).y >= ulimit AND hits < max AND lives > 0 THEN PUT „(shots(j).x, shots(j).y), pmisl, XOR„END IF„NEXT j„IF (kbd AND 1) AND nshots < 3 AND TIMER - t3! > .5 AND lives > 0 THEN„FOR j = 1 TO 3„IF shots(j).x = 0 THEN„shots(j).x = player.x + 2„shots(j).y = player.y - 12„PUT (shots(j).x, shots(j).y), pmisl, XOR„PLAY "mbmll64o4aco3faa"„EXIT FOR„END IF„NEXT j„nshots = nshots + 1: t3! = TIMER„END IF„IF TIMER - t! >= s AND expandF = 0 AND form = 0 THEN expandF = 1„REM remove explosions„FOR j = 1 TO max„IF (expl(j).pointer > 0 AND TIMER - times!(expl(j).pointer) > 1.5) OR „hits = max OR lives <= 0 THEN„IF expl(j).pointer > 0 THEN PUT (expl(j).x, expl(j).y), pow, XOR„expl(j).pointer = 0„END IF„NEXT j„scol = ecol + 1: pass1 = pass1 + 1„IF pass1 = 1 THEN ecol = nPerRow * 2„IF pass1 = 2 THEN ecol = nPerRow * 3„IF pass1 = 3 THEN ecol = nPerRow * 4„IF pass1 = 4 THEN scol = 1: ecol = nPerRow: pass1 = 0„IF a$ = "Q" THEN lives = 0„IF a$ = CHR$(70) AND hits < max AND cheat THEN„DO„j = CINT(RND * (max - 1) + 1)„LOOP UNTIL (aliens(j).typ = expand AND aliens(j).temp = 0) OR „aliens(j).typ = normal OR aliens(j).typ > expand„IF aliens(j).typ = normal OR aliens(j).typ = expand THEN„PUT (aliens(j).x, aliens(j).y), graphics(aliens(j).point3 * 100 - 100), „XOR„x = aliens(j).x: y = aliens(j).y„ELSE„PUT (aliens(j).xp, aliens(j).yp), graphics(aliens(j).point3 * 100 - „100), XOR„x = aliens(j).xp: y = aliens(j).yp„END IF„hits = hits + 1: IF aliens(j).typ > expand THEN count = count - 1„point2 = aliens(j).point2„GOSUB explode: SOUND 0, 0: PLAY "mbmll64o2da"„aliens(j).typ = -1: aliens(j).temp = -1„s& = s& + (5 - pmax(aliens(j).point3) / 2) * 100„IF s& >= new& THEN new& = new& + 10000„LOCATE 42, 10: COLOR 2: PRINT STR$(s&);„GOSUB normtest„END IF„IF lives <= 0 OR hits = max THEN pass2 = pass2 + 1„IF upcount > 0 THEN„upcount = upcount - 1„IF upcount = 0 OR lives <= 0 THEN„msgx1 = 256: msgx2 = 391: GOSUB hide„LOCATE 42, 32: PRINT STRING$(18, 32);„GOSUB hide„END IF„END IF„LOOP UNTIL (hits = max OR lives <= 0) AND pass2 = 2„height = height - 24„nPerRow = nPerRow + 2: acc = acc - 1: IF acc < 1 THEN acc = 5„IF height < 24 THEN height = 120„IF nPerRow > 10 THEN nPerRow = 2„IF nPerRow > 4 THEN fq! = .9 ELSE fq! = .95„IF nPerRow = 10 OR nPerRow = 8 THEN fq! = .8„LOOP UNTIL lives <= 0„IF s& > h& THEN LOCATE 42, 24: COLOR 2: PRINT STR$(s&);„LOCATE 18, 35: COLOR 14: PRINT "GAME OVER";„LOCATE 20, 29: IF s& > h& THEN PRINT "You have a high score": h& = s&„LOCATE 22, 35: PRINT "More (Y/N)"„DO„a$ = UCASE$(INKEY$)„LOOP UNTIL a$ = "Y" OR a$ = "N"„LOOP UNTIL a$ = "N"„CLS„END„„explode:„FOR k = 1 TO max„IF expl(k).x = 0 THEN„expl(k).x = x: expl(k).y = y„expl(k).pointer = point2„PUT (x, y), pow, XOR„times!(point2) = TIMER„EXIT FOR„END IF„NEXT k„RETURN„„normtest:„form = 0„FOR ja = 1 TO max„IF aliens(ja).typ = normal OR (aliens(ja).typ = expand AND „aliens(ja).temp = 0) THEN EXIT FOR„NEXT ja„IF ja > max THEN form = 1„RETURN„„REM ship hits player„hit1:„IF ABS(aliens(j).xp - player.x) <= 11 AND ((aliens(j).yp > player.y AND „aliens(j).yp - player.y <= 6) OR aliens(j).yp <= player.y AND player.y „- aliens(j).yp <= 11) THEN„hits = hits + 1: count = count - 1: lives = lives - 1„IF lvx >= 0 THEN PUT (lvx, 343), mbase, XOR„lvx = lvx - 14„hitF = 1: aliens(j).typ = -1: aliens(j).temp = -1„x = aliens(j).xp: y = aliens(j).yp: point2 = aliens(j).point2: GOSUB „explode„SOUND 0, 0: PLAY "mbmll64o2da"„END IF„RETURN„„REM missile hits player„hit2:„IF (aliens(j).mx < player.x AND player.x - aliens(j).mx <= 7) OR „(aliens(j).mx >= player.x AND aliens(j).mx - player.x <= 11) THEN„IF (aliens(j).my < player.y AND player.y - aliens(j).my <= 10) OR „(aliens(j).my >= player.y AND aliens(j).my - player.y <= 6) THEN„lives = lives - 1„IF lvx >= 0 THEN PUT (lvx, 343), mbase, XOR„PLAY "mbmll64o2acaceggacac"„lvx = lvx - 14„aliens(j).my = lrlimit + 1„END IF„END IF„RETURN„„REM missile hits alien„hit3:„FOR l = 1 TO max„IF (aliens(l).typ = expand AND aliens(l).temp = 0) OR aliens(l).typ = „normal OR aliens(l).typ > expand THEN„IF aliens(l).typ = normal OR aliens(l).typ = expand THEN„x = aliens(l).x: y = aliens(l).y„ELSE„x = aliens(l).xp: y = aliens(l).yp„END IF„IF (shots(j).x < x AND x - shots(j).x <= 7) OR (shots(j).x >= x AND „shots(j).x - x <= 11) THEN„IF (shots(j).y < y AND y - shots(j).y <= 10) OR (shots(j).y >= y AND „shots(j).y - y <= 11) THEN„REM a hit„aliens(l).health = aliens(l).health - 1„shots(j).y = ulimit - 1: IF aliens(l).health > 0 THEN PLAY „"mbmll64o4dc": RETURN„PUT (x, y), graphics(aliens(l).point3 * 100 - 100), XOR„point2 = aliens(l).point2: GOSUB explode„SOUND 0, 0: PLAY "mbmll64o2da"„hits = hits + 1: IF aliens(l).typ > expand THEN count = count - 1„s& = s& + (5 - pmax(aliens(l).point3) / 2) * 100„IF s& >= new& AND lives < 10 THEN„lives = lives + 1: lvx = lvx + 14„PUT (lvx, 343), mbase, XOR„msgx1 = 256: msgx2 = 391: GOSUB hide: PLAY „"mbmll64o2geco3geco4geco3agagagag"„LOCATE 42, 32: COLOR 14: PRINT "1 UP - WELL DONE !";„GOSUB hide: upcount = 100: new& = new& + 10000„END IF„msgx1 = 80: msgx2 = (9 + LEN(STR$(s&))) * 8 - 1: GOSUB hide„LOCATE 42, 10: COLOR 2: PRINT STR$(s&);„GOSUB hide: aliens(l).typ = -1: aliens(l).temp = -1„GOSUB normtest„EXIT FOR„END IF„END IF„END IF„NEXT l„RETURN„„hide:„FOR v = 1 TO max„IF (aliens(v).fired = 1 AND aliens(v).angle > 0) THEN„IF (aliens(v).mx > msgx1 AND aliens(v).mx - msgx1 <= msgx2 - msgx1) OR „(aliens(v).mx <= msgx1 AND msgx1 - aliens(v).mx <= 7) THEN„IF (aliens(v).my > 336 AND aliens(v).my - 336 <= 7) OR (aliens(v).my <= „336 AND 336 - aliens(v).my <= 10) THEN„PUT (aliens(v).mx, aliens(v).my), cmisl, XOR„END IF„END IF„END IF„NEXT v„FOR v = 1 TO max„IF aliens(v).typ = swoop THEN„IF (aliens(v).xp > msgx1 AND aliens(v).xp - msgx1 <= msgx2 - msgx1) OR „(aliens(v).xp <= msgx1 AND msgx1 - aliens(v).xp <= 11) THEN„IF (aliens(v).yp > 336 AND aliens(v).yp - 336 <= 7) OR (aliens(v).yp <= „336 AND 336 - aliens(v).yp <= 11) THEN„PUT (aliens(v).xp, aliens(v).yp), graphics(aliens(v).point3 * 100 - „100), XOR„END IF„END IF„END IF„NEXT v„RETURN„„init:„xstart = (640 - (nPerRow * 12)) / 2„x = xstart: y = height„llimit2 = xstart - 80: rlimit2 = xstart + nPerRow * 12 + 68„FOR j = 1 TO max„IF j / nPerRow <= 1 THEN pointer = 1„IF j / nPerRow > 1 AND j / nPerRow <= 2 THEN pointer = 3„IF j / nPerRow > 2 AND j / nPerRow <= 3 THEN pointer = 5„IF j / nPerRow > 3 THEN pointer = 7„aliens(j).point3 = pointer + (j MOD 2)„PUT (x, y), graphics(aliens(j).point3 * 100 - 100), XOR„aliens(j).x = x: aliens(j).y = y: aliens(j).r = 0: aliens(j).setup = 0„aliens(j).dir = right: aliens(j).typ = 0: aliens(j).temp = 0: „aliens(j).fired = 0„aliens(j).point1 = j * 2 - 1: x = x + 12: aliens(j).point2 = j„IF x > xstart + (nPerRow - 1) * 12 THEN x = xstart: y = y + 12„aliens(j).count = 0: aliens(j).angle = 0: aliens(j).health = CINT(RND * „2 + 1)„NEXT j„FOR j = 1 TO max„expl(j).x = 0„NEXT j„FOR j = 1 TO 3„shots(j).x = 0„NEXT j„RETURN„„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,3,3,0,0,3,3,0„DATA 0,3,3,0,3,3,3,3,0,3,3,0,0,3,3,3,3,3,3,3,3,3,3,0„DATA 0,3,3,8,8,3,3,8,8,3,3,0,0,3,3,8,8,3,3,8,8,3,3,0„DATA 3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,3,3,3,3,3,3,0,0,0„DATA 0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0„DATA 0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0„DATA 0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0„DATA 0,3,3,8,8,3,3,8,8,3,3,0,0,3,3,8,8,3,3,8,8,3,3,0„DATA 0,3,3,3,3,3,3,3,3,3,3,0,0,3,3,3,3,3,3,3,3,3,3,0„DATA 0,3,3,0,0,3,3,0,0,3,3,0,0,3,3,0,0,0,0,0,0,3,3,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0„DATA 0,0,0,4,4,4,4,4,4,0,0,0,0,0,4,7,7,4,4,7,7,4,0,0„DATA 0,0,4,7,7,4,4,7,7,4,0,0,0,4,4,4,4,4,4,4,4,4,4,0„DATA 0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,12,0,4,4,0,12,0,0,0„DATA 0,0,12,12,0,4,4,0,12,12,0,0,0,12,12,12,0,4,4,0,12,12,12,0„DATA 0,12,12,12,0,4,4,0,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,12,12,12,0,4,4,0,12,12,12,0„DATA 0,12,12,12,0,4,4,0,12,12,12,0,0,0,12,12,0,4,4,0,12,12,0,0„DATA 0,0,0,12,0,4,4,0,12,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0„DATA 0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,0,0„DATA 0,0,4,7,7,4,4,7,7,4,0,0,0,0,4,7,7,4,4,7,7,4,0,0„DATA 0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,5,5,0,0„DATA 0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,0,0,0,0,0,0,5,0„DATA 0,5,0,0,5,5,5,5,0,0,5,0,0,5,5,5,5,2,2,5,5,5,5,0„DATA 0,0,5,5,5,2,2,5,5,5,0,0,0,0,0,5,5,5,5,5,5,0,0,0„DATA 0,0,5,0,0,5,5,0,0,5,0,0,0,5,5,0,0,5,5,0,0,5,5,0„DATA 0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,5,5,0,0„DATA 0,0,0,5,0,0,0,0,5,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0„DATA 0,0,5,5,5,2,2,5,5,5,0,0,0,5,5,5,5,2,2,5,5,5,5,0„DATA 0,5,0,5,5,5,5,5,5,0,5,0,5,0,0,0,0,5,5,0,0,0,0,5„DATA 5,0,0,0,0,0,0,0,0,0,0,5,5,0,0,5,0,0,0,0,5,0,0,5„DATA 0,5,5,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,6,6,0„DATA 0,0,6,6,0,0,0,0,6,6,0,0,0,0,6,6,6,6,6,6,6,6,0,0„DATA 0,0,6,6,6,6,6,6,6,6,0,0,0,6,6,1,1,6,6,1,1,6,6,0„DATA 0,6,6,1,1,6,6,1,1,6,6,0,0,0,6,6,6,6,6,6,6,6,0,0„DATA 0,0,0,6,6,0,0,6,6,0,0,0,0,0,6,6,0,0,6,6,0,0,0,0„DATA 0,6,6,0,0,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,6,6,0,0,0„DATA 0,0,6,6,0,0,0,0,6,6,0,0,0,0,6,6,6,6,6,6,6,6,0,0„DATA 0,0,6,6,6,6,6,6,6,6,0,0,0,6,6,1,1,6,6,1,1,6,6,0„DATA 0,6,6,1,1,6,6,1,1,6,6,0,0,0,6,6,6,6,6,6,6,6,0,0„DATA 0,0,0,6,6,0,0,6,6,0,0,0,0,0,0,0,6,6,0,0,6,6,0,0„DATA 0,0,0,0,0,6,6,0,0,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,15,0,0,0,0,7,0„DATA 0,0,7,0,0,0,15,0,0,7,0,0,0,0,0,7,0,15,0,0,7,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,0,7,0,0,0,0,15,0„DATA 0,15,0,0,0,0,7,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,7,0,15,0,0,7,0,0,0,0,0,7,0,0,0,15,0,0,7,0,0„DATA 0,7,0,0,0,15,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,12,12,0,0,0,0,0,12,12,12,12,0,0„DATA 0,0,12,12,12,12,0,0,0,0,0,0,0,0,0,0„DATA 0,0,0,12,12,0,0,0,0,0,0,12,12,0,0,0„DATA 0,0,0,12,12,0,0,0,0,12,0,12,12,0,12,0„DATA 12,12,0,12,12,0,12,12,12,12,0,12,12,0,12,12„DATA 0,0,0,12,12,0,0,0,0,0,0,10,10,0,0,0„DATA 10,10,0,10,10,0,10,10,10,10,0,10,10,0,10,10„DATA 0,10,0,10,10,0,10,0,0,0,0,10,10,0,0,0„DATA 0,0,0,10,10,0,0,0,0,0,0,10,10,0,0,0„DATA 0,0,0,0,0,0,0,0,0,0,10,10,10,10,0,0„DATA 0,0,10,10,10,10,0,0,0,0,0,10,10,0,0,0„DATA 0,0,0,0,0,12,12,0,0,0,0,0,0,0,0,0,0,12,12,0,0,0,0,0„DATA 0,0,0,12,12,12,12,12,12,0,0,0,0,0,12,12,12,12,12,12,12,12,0,0„DATA „0,12,12,12,12,12,12,12,12,12,12,0,12,12,12,12,12,12,12,12,12,12,12,12„DATA 12,12,12,12,12,12,12,12,12,12,12,12„DATA 2,2,4,4,6,6,8,8„Dieter Folger                  Master Mind                    ba2049@bnv-bamberg.de          06-13-03 (  :  )       RAPID-Q                245  16035    MMIND.BAS   '>>> Page 1 of MMIND.ZIP begins here. TYPE:BINAA TLEN:11254„'-------------------------------------------------------------„'                  INSTRUCTIONS FOR DECODING„'If there are multiple parts to this file, merge them into one„'file using  COPY PART1.EXT+PART2.EXT FILENAME.EXT  Remove all„'message header and footer information (everything outside the„'">>> Page x of..." lines),  load the result into your version„'of Basic (QBASIC, QuickBASIC, etc.) then RUN it. The original„'file will be decoded into the current directory on your disk.„'-------------------------------------------------------------„DEFINT A-Z:DIM SHARED K,S,B&:V1 'Created by PostIt! 7.4„SUB V1:OPEN "O",1,"MMIND.ZIP",4^6:?STRING$(50,177);„U"%up()%9%%%%-%%%epSl_*khA)%%%K)%%%*%%%%VS%gruZ)bHqxR,A#Nrh7Xd2JL„U"co%N*4Eb+^?+WZPE<-%em[2u;/Haz2.GIq;dg9E0(N[-_-:COVEvB^M)I?6ong'„U"33OS.oKQS:8,-O(X5]8uVE3<stkrltfuktZw7h6=k\iTVzLCL4Sr.)53ii/Kcd.„U"2c)+kDPwVuB\ilA<YRs_uQl4FN5rqoYjo7<rPYfX>XAGwqu^iwJ]g0kL<IWF]8;„U"Zc^p8O>].=X'Ks2%&6qz##'ZK].nLWPnpfmKSC(jxAy__X.+Ae)zsA61ylf+3\+„U"CK]ZB=%X,SiHWDuFgh>407O/j+;CMv.k*CciItW)+5AG5%9Hy>#F_=nkqR*bsCI„U"4F^3OP%6LLrzC<<Tc_T=hbRaElO&.1i>P_^W/74gg(B[Mgm+eAha\y_V>tHeMmT„U")C9r%\3Dd\(7HH-_j0USq5Zd&0i^S5w9X((=#'HBcug\Ek*VMR8sOaGM6>n6E.D„U"%T1YS93^e\Y;bRj\\ri&;rXXLtErMzcoq$K(:6vTU\0\kp&0yDKue=uHdpH570&„U"*?YN0Nlk9/6ZP(6m/FbK4B#[>ZHf.-3>6>V-LfDRsyVEs*6$%26>6%vLtW]7ND9„U">K37U^I1XY3rOf'/(.c?bpt=RM77K^=Q3HdcKBiVm5kHLY$,5/#4K[1\[XzZZD(„U"_C-'8Q4]IT&T%(y:U?FYPt++,FnQeKc#iRi(B_i.jBg4w'(OUkm?_TVDi#hw?O-„U"77Stc35))36Ol)Ck\)+*;4kGnKw+ckvI^g7IM6P/B<1\Ia3HJ7VEr4OvE<1?bF.„U"D=(aG[*g[pOF&]MQ/n(u85dawU%\B\L)(Ndfun5YE0DHLT37y*q-T3Mr\(9iU^7„U"SbE=NjVj)Bx[P;vg#d,Pi_vAp+8B5CqDvHK5QLsF6uHYuD(utmuN^VKe,:;#(cH„U"4OkIm6K;p?a%0f(Lb?7&)7GJs</r-;C8\0elVkZ8ITrJkt%u[1u_NINA6zB-r>%„U"(eWF(*Kh)$L062DfDt:3KT\BS$pSWmO\#WAGi]_*bibZjoWeI9jr-m<BTdy,NHC„U"MIAd#cTnkV]Np=Y4F.NNw4[2'(?lT=\--PLc>r455MN+Afc7SKwKYJX71c(lIsf„U"+Qm$aDF4>PNYe8loluYlw46,P*3)BuVkEQr\/+2lhNCQmWCie3mW:R5Qf)*)wSc„U"DpSaq5<1V5=nUirY2p,I-8+?,Bg)$)#+TWQWF;DF9BbR<,VVGz#yTN'DYxtSMdj„U"n8d?7eFX2Dlf+L8?M.G10aK[;Z,B;A'7c]B?%J'Z\(B;6ED<=jrK*'oNn.:88i$„U"T]5*X?h0V_DvpXpN2$m5,DehQkBP90)K)BN(u%p()9%%%%-#%%%p4SWva&VW-%+„U"%'#%%%+%%%%rrS#gfxdh'JB\912xd+Xr3]5,g1Z,-(RdBSnTBN\VaG]clsoVE>t„U"n81V/Kl+ad]c3b<c'PQeoU94B#ZO,,p'i(e%d)f_PVnMeF_H#bf:Te/XFBHk\(f„U"N&Tma'#VHrWDW0Vl[BEUWf<V4QN;?/Zr2#kcp'F)pa'f,-hiWXA</?>04b[&V0Q„U"UOX:TeWDO8Re,*ORlViL=gX6+JXi>_M?G]got/B?V^$BrDXG9p=]iAhG,AR4mr9„U":2S0:qz/&d+(.4vYn19E;BARTNP##LYBjhST?ct;;_V#GRVtz=$Z+R1V)sANYXO„U"\7V\Et>;-%LMGKM/-uNlws8)7t7uG*/d#o+jRiIIEQ'<61819+CVgd>89P2a0NA„U")/DbUgQq&3S(eHc\WmSQi1JSouQ=[L_Fef^?Iv%LU=$A;Ji%wzHLB^LAHmhMEHQ„U"q.z&5di92R[hGZO#)W=jk<<LC<,qP2qm8<buaU,Z/c?[k^f*06j$r5ae=d&NcA3„U"/\I3f_[Ya/l>x&5r*Nv5mzwAt6<bHZAm2L.%k[=6XJ^pU+D'1IaT8bRf<lJqp4g„U"Hi>Bw-AEH6U-k0Y[f?/Z(]S#^o1cw>>SrIIWgGo8%r-N9v&9+WAOFff19)fos+&„U"Dou\GR3Jw8ff67lmAQV%Ej\]#SV17BNX3$d'Je(H-K>Zb'o7DYS(2O.(Acu%6dg„U"z%-TTkWo?KF2;'K>*9[BC'URP7^D'W]0W6#m#.[9hV,*)_ooWcv+c]a=gIpH=i5„U"0zP\XDCbV';qp6%R0CITwuMra>vxFCjr(4A4:[D/;,b0j%[TO0T8*F+mL2SAv<\„U"ZSYfne=%ZI[HPLlERRN+.DtP1FEL-'pQljeqp]-fEG\o3'*gi=;K*Sw,)%mk_yR„U"t<3j;8dBQsBEeTTN;/-7\'pwR8]+j7F0;Q+\8,*$XoDXVbISUf'DDiuCCJX_qWV„U"kSB,L&%0q8-6S$#gTTUk]V.S5?HrRpfNUH>lb^*rY>ag;wW9B2U+d'Lh1.LFTRE„U"1cv..0uiAunXK:H]9N)BEO9)_]_d*=G^LB,Ze.\mpZ[71a<>2:edA;c5Y#fRnc3„U"x6b\/oAB;^=a*.1JXj^wHmReTIdKW;mIJbYq/B&Hs.8VsF-HWI.VFTFs*MtFIcu„U"12<tzE<#XVgX.$QNJl<:UaRf=GbRob6^ArDa7,F0nc]OaDsEF31,'r(FkGpmYtu„U"&kBChNJ-]+b#G4g:K?^(R^49<F^+y3WtVJ<^8W4j4p?&quZr0za;DpCQQ8EM_wt„U"dG]7h7tra6F^TcPu5;_nyNpUDoC5,J-Adp773-&;1L0T,H[+9Yl$0SoZLTgAY*&„U"Tc?pU*86uL/8U.8f1,e^m]OOu&3T;i=sqtHj_ay<C6CK#,K-X34o:VKN1iFy[jF„U"nMgAOtVQB^A_8qo?sb2GCtt>.pdRkbkja&hOnIPj-,vHN1$?EevnN&7<z>oxXc7„U"MhZ7eCNMZT<jZ?qmpX7#q^hv$Wkcn#)thNmI^\m0\o0;>>5grs=+r#alsRwhCO\„U"qD<Y&/;lDw3k'&E2=d5x*21O]n*kVEl4bclkc/sWYc.2jTd73oCF,[Ap]h#i\:D„U"EvO+KOJ3#?ANBu2:ItHm\w8)oa(s,1;r)d^9MmM(ayh#LctmR0U#(MC$OKX8B2#„U"rr2=rZgtk(9,iN$,MhYz:U=AxZl&mp'[XR&$$Se4cYQd%M1[%y?:SeGzV<1H91P„U"8:eH^9y4_q'JgK+Opd7)/^8q*f5N$8=eS3VoqN)D:)/OrD_Y1znOO_ZZqVMAtwD„U",%M_J]ScPS7cJS^+PS^J]SbPS7bJS$OPSbq#LXruMc9^^gf#sEro*&4UhqLnt\_„U"LjN8;']2vQq_:uhO:2h-,d[nZ:Bb4FftBw'bbC[J/9=oNi+.Kp6a36yXi:j#L)%„U"z]wDY8dc]mmDlF>)=GB:p-Zq1whhZ,p7n\Yc\-Kq&Tn7+/d(OQShz7\Nej$/L:l„U"4twa7(,qt&:H6pzs9bPc[Qw&wxeT7l0I,Yp3RC*dirj\hZ=^[(qLa/;KNH2pGEE„U"8=?a(<l$PyO9jG9QY><9g*(mu4s4Uv>P*Xyw&I]L)_j&r>d_?2fRM-fgK0A*vp,„U"K%]zB&e/Pb3XR_LQcJx/]ftL%JT4i*K)<ARpZo;]rmkEe*(wIEN0g2^o__r=-*J„U"l*jJ[>IWNe('#do21_zMQx=Nd3o/tU<noj\+,GrbB&i+Ap[&?yRyPx%y#_8Nefi„U"ibGDqqhvm^O16RDf&6zVJyi7a#Z..AZ_T=$%4aNjPmfJfeSvge=?%7rQ8YJ].uh„U"m/RJL0PyIlmCr.\=AABD6Hihk(tq[s]Zd7:\f-X<=:tS-xU38_QWCX\o,%Y:f*N„U"0^<Cr(&ejg'R^5gd7F#v0mM;^c(o)yv:KiOBD\2JCL_#DfL>%g*D?(p;9Om:\6R„U"Usx&m.;r#zi']5WDIn-6DPpGma*59IC'yC..OL&F3&UZVKFh5LLM1TOq0;kdC(D„U"e91CzxTjvO39rn?<URIS*uYH'sh*mFr4.J.Z8Ld+f3cmv&SWhI0^eEa5sdGgz-U„U"2IR].xt2L?O&9ugz+Cu0qnt%Vy4,y<IKRQeLFS2Sq<Ih2^JMM2Y'6ic%+mt8[m4„U"Q]K^HKgNZCH;WCDG]6XG6$5nOi\7TrcD9'>FJhhqBb%HAS6/)]#n8o%x%(up(%)„U"9%%%%-%%C%pS,pJBor[%%%w%'%%+%%%%r%rSnhjtF]*+o=e5MUNRT-C*,;9/<%Q„U"u.0)DbRqE0?^[r%sS79*5T.gKYlF;(KSQ'W,f[-NdxQ[,B4^1P\Rh#xfRdN7blB„U"5Y8OPH4d6y69+>$*$b6XEm#x4>E+m?(NUxS[f_yy]<F2>(q:9p;zGGuky<Hr)#8„U"Iv;mdv(EE8#o,2f=liw5$f(NL>&u8+AdwOUvzfMl_4tQn'KPlLn3f'7dMi+rguh„U"nB\X?deIbz?U3Gj1p?zUog\C8E<6Dh(kMS'pU[1r.Nr>qpY%-obrT&oCHt(^$>n„U"tRZVDvLD2fXq$nn9fN4L.f*f.-motmff*'7&up%()9%%%%-%.%%pSZDH1y&-&%%„U"&E&%%%.%%%&&mny%jSgrIuZ_,%pGv=VO^0JEJDdpG.)d/>Rg3M'PYZ72,''GNtO„U"qZ4/,7e0MzF)7ZYbp%PyQjSl^Gh4>D8w$3gBM6VnR2BB-WWTg##KcY2^Hl>tmp6„U"DqY'3AKeAY$ump.'1R&9euX&\c1n;i,'1#6Z./]'g$KFZe8DldEmVD/zVMD'v_Z„U"[UVzKj)#.]l+e2h-5,g._3.)zv[?q_luk;_s_yD#lC)q)h7,EY4WG7mIMdE8==6„U"T.])#6M=#]b_X/SSBNtxTfG>8^]4uL5Fcdc1VHDbXqe.MW;V-FJ>+a%TtUk/u5T„U"3;qJ6:Gdxxt<U0c*nUE-'F'x+UEe1'?T9uC#d6tftGjrbuf.tKk;0=>O3>cI?t^„U"p4-[KmiT;$j>l4VL19h/.36<vu5%2%gMVjRB3MU1xAo&wrp'8Oc;#^&F)fwDabi„U"VQu'YGgsU4T)Kd-CvBu%p()9%%%%-#%%%p%S+dH*21&%(%E&%%%.%%%%gqf%hpS„U"g#ruZ_BFpG#+=#DTjpwij6.j4?qu5AIA#kRu[VvPV_,'[e-ODJpB+WiW/_3,i79„U"B4z&CvIi>J#<CES;BEYSw*30C4KslHpJqXcj=xI3Ysp<gpapdB]/=?4ZL6qyy7o„U"Nst)2N^6i4u<5p#YM_%B'PzZ%Qwnd+37;CmC=5L[3AQ^H2kae[b)flf<W;/>S%i„U"A];\jE+kRJ3K828X5iv:Dt-^hPeCWDaU7-A0_1.ap=DisNAYi)J[sp153++)VV^„U"Y;?F.QjZg7e9u&G-Ybk,:?zM%9%;HV*%6T=YR6X\kYDCMsBVJrRGq4Na,weh3OK„U"7G7>KlL;aFBl*QA$lg7BtQ5sJB1Nk7[n)%fG],tqY]_N\hd3jK2nbqkYSW0'tZ+„U">W*[Devw_f9\K?kg%L=MGrH$Z7Y7N7bdno3TS7E:/U[Raav$J:<dAjz'kPZd&Wj„U"=WsH,%up()%9%%%%-%%%\pS*k.<yT&.%%y)%%%-%%%%mj%quSgmru.LBDpO079%„U"i8divSE)7rX?1v3HP.5PYC.yuXjm9Rg_,AZG9m):JDHI-,tsNN;C%r0\RKtPq7(„U"v/gSP9TTj'PqBDhrg^(1nqt_nQ,G_LAMKk3l#UK%SoF8V,;w/4xidJUe5c:5;xm„U",li=RhB1QYY/3&v%ULp*hAz*qq)MZTL5_cT+=g;JwZlw=k2jh45ui2RHD%t5G&1„U"5p0kh0QImacxrcdZahMy%GGOG,nfD)^^*ldJ?Agdd[C5>'OTQEXQOO%6MkEo]E5„U"sQqsdBG&GY6<4s1LUAaMIBjxMfxdhl[;MW4bTsKo)FowY$17yc[3%8m%*bBMLS^„U"IPLEA'['eqGzdQbBvEQ2]<(XnNBi'Uw(O*>P^6$)*$hAS?pZxXZC?N7&qJ6vJQ9„U"\-.lAKez630ndrf&'pSb'1K]n:r8p8U(LT;mn',u)TkS?lW/YF7akw.Snzw<EQL„U"JuJ%$86$k,HjQ&ORC-U2TrB+9v^3gQ>-4v4u%p()9%%%%-#%%%pIS)m9(Vo(%%%„U"K)%%%*%%%%XSgIru4bD(>?&49#vwYntIvMMQy>HQe1R=>?eUB<c[/Gf>0ZH9=UG„U"hXFjQBQ3++g$X,#m0IQ?Ms9Q<B/WXS:y\sw/xDpwNVw.o)y9jJks-Yskbw&puZw„U"g2'Kb,fFdx=7W<<^Z8%cvL.D&n&gBin57t,32Rjv&t=sNk<?2Q6jVf:I7];1+MP„U"=<r$QIWrl4orYGan3h#SrN3A8(nWt\1?y9r_#4R['3D[O/q,;*)jH*nJ'gJ9Uv/„U"n?6sIP2,dW%%F6oe([W-JI7&[O0)1ceA,a>.3%PIJCqPvyQFe4Nt77wH;r%_<*=„U"_56AZE&^*#1G51IV0JX1d]A,,(9hJIrAT^;e]td+/vrf/la]ERHsp)STG[,j#5-„U"M(AT'.K8x99)n(WDoAXyE)huz)-<uno.oRE3m3twg+O9.I[[MV6BbQ5&wlO+'>E„U"Q:2:C905=-g2X[UM69K#-OpXu:negfv,k)&v$&6%uM[9U9^kC,gE7Sc=hd9-59N„U"eREnZHdpGDU,svuV_)ZTvkMsLx2)tERstv77%iIVj$oW\S138&Z*pEV\%R><>*K„U")(6l-8lZY'97XWcA3-*C+9&1NE&Iyc$[r%e_r]'=$/Q1%4,V(vNT%]gAF]uC.II„U"=]UMq$/S1-TLh.H[Zj2v%1?58DjI#gRTBL'A(K%+hO9lb.)pbo<d[R2,?vr<FhF„U"<(<?7KdPjbS$NpoO#Pj[U_d>w2hnh%2O6T0%yH<U1>g+_DO*'rqmxjAZCUK5h;2„U"Fdk0nywEL^dNOt8-*6W-)+lsFI0Z<sYzRY%M95dIg4?bZn>EMrsJO]Yjnniq=Pq„U"EabLXqg_fYj00>uxu\(kb<kDd^a/da0slkq6vhw>lSVrIHU.^Ko3LX:tTv#nz0T„U"BhGI:\o[aptnj\00o0\8wGeUoJ?6wZFZ#K[;ubs3V4TnIJK/aRy>00<a+6jSRj5„U"TxNuv6]wYMcrZtK*qFQjj0cpEQ:9?eUmjZw%L6/\+,Rg<6uhN1,LbOvxIKA=bcj„U"+o>Cbi5N?)nlq>\n:P*^Q>M%qOuAb3H6fv<AiT#3r&C)x5/o=Yq$'VxtItj:?oJ„U"ZsugB:LQe\vhZ<;r8QrcaquAp$xJlHiM*R7YMu3qu>-Bjv[2JC(QmyoXKfnob'b„U"b.OvgFlIfW2Lp3hi9_Xb$No2k)7=fb-Jyd4csN%-9Xup%()9%%%%-%.%%pSW0zl„U"U'p(%%%K)%%%*%%%%YSgr#uZw<%qAz9Z6hFjkhvOgQ+AVC)pKQQ.0Mqe.5ppm%0„U"j&d2ysX;XV*=w*J/qr.\j)#Bvv2T+o09/-OK+0AcR*5MF666n6<o,1;)T7UV\Ki„U"C?[Ve_a/NJb8.LpXIpHHN$mJ.AHr+PI,Mch7Nxpd=6=<hVKss^a4Z.2:BaFZFJQ„U"jPs8U5TD>Bsloe#e-omD,mcpo2S)HnE+ce5lm:o=(hEk?cn4%9Zs_f*9Vs7Ht&l„U"OBR&3#zEYV3jCbna/ms2Kr#p;DD<L9&BO0T+MYC5\tK3)^J9e$]vA\*Kdp0>67/„U"zkcf%)88OSm.fO\X0]gAh/vX;o->/\tALXVLPHG8j%-r_&rUE8=_VVsTYmG(51n„U"qQs%J]:h._kh=n4&C?IySuBRNK(oV?&x8u0aitdj\OL3g#?xQTDE9(GbNO,]I#.„U"\<%I($$#e>1%tOPd6xRQ1_qwSpS=_?D6HsaQljPe9vl-?I(FXg7I8?);_TIXDSy„U"kw/mKJUJH4b5tSp+eJV_,bHr\Vm\j(=$Hu.ZJ(Mkqm*sRP9CGwyz.?>u._p5/0R„U"5];qJ=/I(T3pFM)%*ZUa_+-I0L$3U>cArV1odl%%O5YMZN_AwTH>^0_eCNI&_']„U"?A;9C2ci2A<>?TJPU%e\6Hms'[A3XHo)KO?e(rW^imN_NCRfZF<_/K?^9-wjB)u„U"Q)nB?r8.$-,*aN-k\^hNa/R8x-Y*E9>HKDO5swgzR^cAKnVBInVZ#i3j)VNFWWt„U"sm>n%[Yllt6pkkb6<bUw^1h-/a&5j:nv/aO4WOSMh&I1)jMpfFNrFA[&F[KQ=ld„U"OY/$pTtW2I35I&S]INdm:qh#eaM?Ki7?f.jrlnXqi**Q::js0h7lYfr9I3v:Fr:„U"K(0?p:Ld^\&(H<0l%QX<5NXv&\_tnTc>Mqn1_-mE)-b2kK]IV$ot[DtIHrn8&?x„U"YU>&[2t%\m,]_hdQ7BX+sg-]\sBCp#8o+pB/Q*cbS?.?b;;a1xMpN-Rr-sk#D$u„U",w2MkkG&qv,U3r\9XYCZjxc$xZ]Bll:P,cgULolJC%;'o8jmbtsr4\0Zjxpt5S6„U"re[nMks.SqWT*C=W-Fv=a:;S(_?.LStGJgiAn]J%NMMt[V7&Km4-_ekK.7z'Up]„U"1fp7HT-?b?lTrwK1\rPZUuF=h9s*tM7Do19_e5Q]dkRkil-Q*c(&k]B6Em-<]Gk„U"=GjR?vKufoltvXjSQT)+l]hF:D>p'Lm-0ABCP]TGo]1XE5Z0m^#gbOl.i4te^Be„U"2Zg7D2Z\LUSluasX&20m<o;c(D9_,q<%up()%9%%%%-%%%epSd+,MPD)%%%K)%%„U"%*%%%%[S%gruZDbHqjJDAVNA>T/t0\MURV_9[1HiSDj1V#5XL_2[#J=1PUk#n?d„U"I%>_D<)xUiD0Z#;.-y/]f<Z]/UuI8>ZX/mT(C[GuI/)*o?9U1+tAQKcg#Dn]url„U"BlUrMrL,CoZ7rqFh[l=YSx#4)3R[<8)v3#Z82\9^GL&1-1PkUN)>X(B6kkidnW:„U"q^ZLsWLrhB]9KcC\fYrF7FE[%G_y&8rO&6g%':I'9+9CiKErF?r;-\PaHV.d]t\„U"x2aakiH[?,so=++G5V?,$.Hu%PKFoz-2Rxc_<URF_8h:fA6wg+N;Z$u*KZ'Zk\c„U"oq$[%34[/#%f,G,w/+]Z6X+sGl3kmj[bQSo1h8ec;Bxrq,oVD')QZkg;ui%])[#„U"Ds5%-1Sch4-k7&\&YenNLyHR'>AlNwcVpk4KM3O)2=e%PK2q%9#eg/cAi'wHg)-„U"=Y9NaKz1&c&fFS4rwB%+Z\Dce?1SL6.ycZEToAeN%csbO[,4:eo)%cNZ>joZa(A„U"3,;3+88R/H3lh/*V,wx:Ht.*h9:TS94N[,Ff6zV2T'p:WpiZQq2hB]/si_;F41A„U"Q%E0OT>sOPWW3T:,,l-cVAHesSO6k_aD/cu_2u?$GiB[Jp^iQMO7jos^-94-W&A„U".:j^u<B6Av\?H#9W%V8oH:HX3sE3kol#9i%T9d/r#ItrZm%3C\Z6f:+t,FEwDwE„U"4BjE#KMItX[Zqy<H=%vEY61t8QQ,T_crr-$OWF<tj$s^\6W9Ln/5IZ,'Q^eu:3d„U"v/eSOwT%ix4jq9<(TT_s1fQXS'ZiR(0'pbZWQO4WFT$w0]rO#W:cn.$on1JW*)Q„U"ChOUPVY$i&qBbYI_;=jMHJEZc,\PmWrAu*Jvb:$hNIx7qdWNbnG<wgUB7j6q4Kk„U"^h*S*F^u:0*#tAY[GT1A$\ztdQunNtvN<MNjoxEGdsb[nKr5B(E040m%Mof1<(J„U"1cHVrUu24Taaug6DwFj7ZE7ruKf\E6ROnt.^pPltuv/Bx3b'Y6%HMN[+w.*;Jw)„U"Tf>2f$qBJ&#wq5pFIv)L0CjBdqJ8\rMjjJ630Fa[d[dK[Y\WoStIiD$WDfeLI3%„U"C9UZy+w)9\ZL>T.mk2gqmHFtew%&Lf$cu?7$AJ.Cu6L\INlZ*2=+P(E)m3f?1O[„U"8%K61otU6K*.J7cd5Ic4]S=.*<e(;ZpatJeVa*:uWN)6_hwJTfb>&:TCgpqCn5w„U"xm6%%s5MQouP7m)\-RMd_Iya1W7Z48\e5b=0_l?q5WhgsKnI[tpu2?>#8qn6qDV„U"q-[/q%[1%3M6.8[>]?CRyY)si\\fNG#p:luw[v>vBB+NDCjD)9/9xe/UqP(>02O„U"uPdjx'p4up%()9%%%%-%.%%pSjGfv?%C)%%%K)%%%*%%%%WSgrIuZbH1qbF=3#N„U">TTGsi7JX]3UN*4]4A#l;e.R#3KGj+doIARTdIg60A8Sh_+;;q/oD/O-R2pO'5(„U"p:(mut/hR4g2),Q1%2O,QLV6#Nq_SW0>,5qjn]lN$b>m#POKkX*w^,k^(IU-r85„U"-a'HNouvH$ajr)]I4>EU&g'%2?skfF5VuU<4&vGsAF4DqNB4EtGLs-#t<f9XR.(„U"sg.B=q??%7+%k\#bsmh0G2Xse?>_Bp/oH0;Y]eKE5sO&'VX[nd#t>:pq\l4o^6_„U"T.?QSVo5=Wg(O0<n)HJSB(8O9<qx#]%'.$FL(YdQ#]>53Ff*WEq1]0iap'MpW&q„U",tBf?J;*Op;%C1Wn8pe^NOeTo4%/syUu%/Jo>&XWMVhZhaDq$d),st*kD.^JdT5„U"k%Klpv&%c0dV^&P?DWnlbcYA-Bk6JCVSG_GcEm$XWK,(iRTk[j/hYl_;H2,r3mL„U"M?[NM7b'T5V,Mf'k^%oC=8a:N&;q3/mKE9YP/''3^aExIdimH%F+Jaw0$ME:cf3„U"3xMX1.OvS*8WxfCZGsb:8.8S.y_dG_C;s2?S8u\I3Mum+wMsT/O2lX\u':?5tnQ„U"%b+>r=q=[(R4,pr_#wL(''p8OO$:[bPG#6?Yt2eaL/ow2r-DhO(?-AieR6A0P4U„U"N1lCP9p60FBLP5r2b(D^1(^utyj.wWOef;96ri]fAGfNUiSI]bLKGgUt)=g%/EK„U"4b?=:c?wflYV4xr4^r8lVt7KZ_B4p3Rjm*_S8E4hOH)Gq87o3uOd(#qF)?pOtXH„U"Be#VAnrjp.Nt&OOrL3vn2PBXrd-<o$%ruoO7)m.)njW:&^LuLr&/J\&0oh?7Fbj„U"/D3oxu]uu4Q^C;s,JYi6^Af>oaP[2kXBXa%m1;('H:\I$<ycdXSFq/x,F>:kQ%X„U"npX8#0%adxYC0T,Xr4\8hFWjWE\qd'uXAxN439o6-&euC?u3Up=v>o1&?%4UOtj„U"MMq?/ZBW$]&Y_<FXfiweA#Fu'UfHdYKdNi?(M'tL%5=)bNF[nrdglr7mRDt1H5Y„U"]N72?gJwd;mMq<=:8f;HJ't,ET>u*?ZMOLb]ngtk+44=2BnW6+hA0(0sM4\T8l^„U"ZY$EB.95<x1q)D7ue[/r0Hp3\RG8$&9=HK2KQ40?#*UyHbGJ#VcCU1OKKaQ[u+3„U"aH6:a3;;c))=)67?r[DH=Lnh-^Go?]aCwQWUK\ENuK#(0=%%(Zp)s0cvb?F\.73„U"%>kokUK]Q6Mreeq.BPn^qeSDp0l;5:OxLfVB?Y)Xb2)2PGJw;T7v9<6+7<r_X'P„U"Yup3A-SG;&AnHuG[(UZ=61F>fJV)Cg>l'FK1#c>m[;+xp4u%p()9%%%%-#%%%pO„U"S=Vl,kf(%%%K)%%%*%%%%ZSg#ruzbS*qS6==?8JZ4g>iqIyK3Au/OW\'i5w_OWe„U">/96P:%th&4*-t_49-]T3R4q&%;yt&wFtEGY\):fYPN;02ejS(+;4(KSZ4Q>15I„U"2jJjXt2T:JJkbP>7KHVNHWZ]pPSHBq9AzeOUhi86Du.%m'D:=bjWD&TC0f^5qkI„U"t_#0q?.6l0;Lt-/j7C(+q9p*6M0C9?OXeRrUFqjLExNAYV;UOU4A6AZ1TnNSf4U„U"T;Cos:l$G5L$T)xQ1Uo<lts*h<64M+VlB*4AQr;*ac2Dz]xJaj4t9_hby)EAcd&„U"\NIv[^.1a\CCTn>QYejt4ZEEQ=:M[UE]2?cMXbIOg\$we;w=JA(OLdKGtrA:8Br„U"nHEKY=3rHwG:HMCXgZDq..2<]l#-3he8KS'QJV+$AL-cNU.Fs6m+mEW71l$-wOh„U"Z%vkZ-hk4K3+lhfy8O^fLU5[.e]+8:Wd=QUH8Q%yWdF1x?YKjpZwLGTn>tX++QG„U"c73L8f+HvUdqvE_k8E+&XnuVyR0%Xi00w,oEEe*l#G08A246'oN+w$pf+9&VROw„U"W5)y;<Y7(qfuM0ll&uLHLUASk<>j&iCj^V&gH;Pa,):L8KIJeGR.2b&0Sk8a&M4„U"4D:kGS3n$r:(KeJc=ka3sxqPrXA%Ldk%u$IDWTc/;MXS+^BwIDeMne60^xRYK<A„U"4f,xJvVXu\xtu#&f/)yDT1z.BpV*nAIn,)0YbhZnlE+piu.anor;z7DwnDVchck„U"F4Mqe8<YtApv&dclo0PN>GJ>tO[x5C2d[]pz%53764O7fKt9l(ck%V$qwY,pdTW„U"drmJ$p?V6OTYtHNmaaqZ4B_Lbjcc>*urds5SDsx,g%EQT-?o_?Vc%%p.o?Bz=b%„U"_VgvVz+<hhjVtKhP8MMHFCZq$J*oq4pvH)BC7N+Hj%*7N%%JQkkB0\*t9D$eF9T„U"Ezp#2[bq#^04\6u.,(?tMwtnZZJh>rwH2wcTQ-%Z,&dks&d_w#1%=]MU?NfuF=P„U"I6^_QP:h+vHHAe6*i/cE-?NtO6p^+m7g>mKNLWHonuS.q)/hu;Z)mVE]Ze#O*Ng„U"7t&(>9#p3hS=QDZJ(f2<?\Bk<3V0F_or]^<Uv1/0.ni*oE6a+AXX1E<#9VMLgJ/„U"f7x64fQa-OQg33(V%K,tmB.b#3<<2$LK6s66^^Sd</][-<*ijaU1XX$A?Q5W/<Q„U";dp?m0St5Fo^q:2HFk]f]b'YB4_N.\JREq%=T,$\dmb?jfJ'\'H=112$maY16ji„U"%pBT#T;[2',$V4WjQw.+%u0u%p()9%%%%-#%%%pXS1Oq(.:'%(%Y*%%%-%%%%qt„U"l%tSgr+uFxb,]U_1[;\$FnzqG1Xmn?c^)sAT5r[DX$+,+)b3l+:4;bbh]]'f3I%„U"&AgjYBX+CtmDJF[RG44-IonGL]lYck(d%9MnWL;Ldmr*KfnfiVzz5Zt$%&Zrrqw„END SUB„SUB V2„U"qMKt'r7Kv%1cLKue>D9nuiX8cKHJJ1=H9B*]8A&9*$o]n/$fUxC=#^^3L>PXm/5„U",LC6/g5G]=aPHLpAU\3;x=CX-^$#c:n=J*Vj$+PO(7/&K4wmuqi]5zn'20Pg3L1„U"Cw^a)]=d?2Ar;'QR:=02y&a;n*xLcFMv*R3/vcQXT2M15q_/)*lyK.>_3\H)(a.„U"5Y,QHg[e_qXAUAlpCmQy(N-mCX^_dQui9t\3_+,Vr(e5%37IQe+8[]MyET1baJ=„U"X]72^EWF5^3n,Rl.\_;icQ+KLxV<Hf.cq-)W<Y1g-aY7N800Ik/:]ib7-bo?A)>„U"Vi:TG>CW3e#3[(Ye<x'_uT==-qmiQ-_j]'/>TnG1>Q?T]Pa<D\/=R_4Hl%:'$(^„U"(S;<upB13cuVn]IK(^8&l_m-?hDEM[[VMT+YtaVn/sLyc;XYl]nZJ[GVD2tFvzE„U"4j-dX02GShcBFs_(vz9%Q$8m:<)R%lrZa5N68WF==&8)V'Yl1)px'_Je1Ef2d(U„U"%c?pul$RPWeu>lBM.cgL$*&IV\KJh)]]f^(]YiHU7b;+r^GeG\Z^nr%>Yu85grN„U"07fl-8rWURg>s#s5_BW:w4zp&lD9&iUXw*v;fSV*'#j0QjA^Xa2C*32b,w]rbU6„U"bg'vH]CY5pO1_=zcMc>x8.Px(%up&'%9%9%%%%-%.%%pSYl_kh%A)%%%K)%%%*%„U"%%%%%%%%%%E%%%%%%%%%VS%gruu%p&'9%%9%%%%-%%^%pSW/vaVW[-%%'%#%%+%„U"%%%%%%%%&%%E%%%%d)%%%rrS%gfxu%p&'9%%9%%%%-%%C%pS,pJBor[%%%w%'%%„U"+%%%%%%%%%%%%E%%(%d1%%%rrS%nhtu%p&'9%%9%%%%-%%^%pSDQH1y-#&%%E%&„U"%%.%%%%%%%%%&%%E%%+%+2%(%&mn%yjSg%ruup%&'9%%9%%%%-%%%&pS+d4H21&„U".%%E&%%%.%%%%%%%%%%%%E%%%%\4%%%gqfh%pSgr%uup&%'9%9%%%%-#%%%p7S*„U"k<(yT&%(%y)%%%-%%%%%%%%%%%E[%%%9%5%%m%jquS%gruu%p&'9%%9%%%%-%%(„U"%pS)Dm9Vo%(%%K%)%%*%%%%%%%%%%%%E%%(%:7%%%XSg%ruup%&'9%%9%%%%-%%„U"%SpS0z<lUp(%%%K)%%%*%%%%%%%%%%%%E%%%%S;%%%YSgr%uup&%'9%9%%%%-#%„U"%%pUSd+M'PD)%%%K)%%%*%%%%%%%%%%%E%%%%m%?%%[%Sgru%up&'%9%9%%%%-%„U".%%pSjGfv?%C)%%%K)%%%*%%%%%%%%%%%E%.%%YC%%%WS%gruu%p&'9%%9%%%%-„U"%%^%pS=hVlkf%(%%K%)%%*%%%%%%%%%%%%E%%+%DG%%%ZSg%ruup%&'9%%9%%%%„U"-%%%npS1O/q.:'.%%Y*%%%-%%%%%%%%%%%%E%%%'TK%%%qtlt%Sgru%up*+%%%%„U"%%1%1%&C'%%&;N%%%%%„END SUB„V2„CLOSE:IF S=182AND B&=11254THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\11254,219);:END SUB„'>>> Page 1 of MMIND.ZIP ends here. Last page. TCHK:182„Richard D. Clark               Black Box - An Old Board Game  rickclark58@yahoo.com          18-18-02 (  :  )       WXBASIC                658  17615    blackbox.wx ' Blackbox„' Richard D. Clark„' rickclark58@yahoo.com„' Portions of code by:„' (c) 2002 David Cuny„Option Explicit„„Randomize„„'Menus „Common wxID_SHOWDISKS = wxID_HIGHEST + 10„Common wxID_EASY = wxID_HIGHEST + 11„Common wxID_MEDIUM = wxID_HIGHEST + 12„Common wxID_HARD = wxID_HIGHEST + 13„Common wxID_PATH = wxID_HIGHEST + 14„'Ray direction.„Common GoUp = wxID_HIGHEST + 20„Common GoDown = wxID_HIGHEST + 21„Common GoLeft = wxID_HIGHEST + 22„Common GoRight = wxID_HIGHEST + 23„„'Prog info„Common progName = "Blackbox 1.0",„       bmpX     = 500,„       bmpY     = 484,„       Skill    = wxID_EASY,„       InGame = 1„„'Background„Const BlackBrush = wxBrush( wxColor( 0x00, 0x00, 0x00), wxSOLID )„'Cell height and width„Const CellHW = 50„'Board array„Common Board[8,8]„'Board coordinates array„Common BoardCO[8,8]„'Disk array„Common Disks[8,8]„'Fire array„Common Fire[8,8]„'Disk counters.„Common myDisks = 0„Common hdDisks = 0„'Show path„Common ShowPath = 0„„' create the frame„Common frame = New wxFrame( Null, -1, progName, wxPoint(10, 10), wxSize(500, 550), wxSIMPLE_BORDER | wxCAPTION | wxSYSTEM_MENU | wxMINIMIZE_BOX)„frame.CreateStatusBar( 1 )„frame.SetStatusText("")„'Menu builder code„Common mBar = new wxMenuBar()„frame.SetMenuBar(mBar)„'Menu builder menu definition„Common mGame= new wxMenu()„mBar.Append(mGame, "&Game")„mGame.Append(wxID_NEW, "&New\tAlt-N","Start a new game")„mGame.Append(wxID_SHOWDISKS, "Show &Disks\tAlt-S","Show disks")„mGame.AppendSeparator()„mGame.Append(wxID_EXIT, "E&xit\tAlt-X","Exit Program")„Common mSettings= new wxMenu()„mBar.Append(mSettings, "&Settings")„mSettings.Append(wxID_EASY, "&Easy","Easy skill setting", 1)„mSettings.Append(wxID_MEDIUM, "&Medium","Medium skill setting", 1)„mSettings.Append(wxID_HARD, "&Hard","Hard skill setting", 1)„mSettings.AppendSeparator()„mSettings.Append(wxID_PATH, "Show &Path","Show ray path", 1)„'Set the skill setting„mSettings.Check( Skill, 1 )„„' create pens„Common NewColor = 0„Common BoardPens[25]„Common BoardBrush[25]„BoardPens[0] = wxPenFromColorName( "Red", 3, wxSOLID )„BoardBrush[0] = wxBrushFromColorName( "Red", wxSOLID )„BoardPens[1] = wxPenFromColorName( "Orange", 3, wxSOLID )„BoardBrush[1] = wxBrushFromColorName( "Orange", wxSOLID )„BoardPens[2] = wxPenFromColorName( "Yellow", 3, wxSOLID )„BoardBrush[2] = wxBrushFromColorName( "Yellow", wxSOLID )„BoardPens[3] = wxPenFromColorName( "Green", 3, wxSOLID )„BoardBrush[3] = wxBrushFromColorName( "Green", wxSOLID )„BoardPens[4] = wxPenFromColorName( "Blue", 3, wxSOLID )„BoardBrush[4] = wxBrushFromColorName( "Blue", wxSOLID )„BoardPens[5] = wxPenFromColorName( "Purple", 3, wxSOLID )„BoardBrush[5] = wxBrushFromColorName( "Purple", wxSOLID )„BoardPens[6] = wxPenFromColorName( "Black", 3, wxSOLID )„BoardBrush[6] = wxBrushFromColorName( "Black", wxSOLID )„BoardPens[7] = wxPenFromColorName( "White", 3, wxSOLID )„BoardBrush[7] = wxBrushFromColorName( "White", wxSOLID )„BoardPens[8] = wxPenFromColorName( "Aquamarine", 3, wxSOLID )„BoardBrush[8] = wxBrushFromColorName( "Aquamarine", wxSOLID )„BoardPens[9] = wxPenFromColorName( "Coral", 3, wxSOLID )„BoardBrush[9] = wxBrushFromColorName( "Coral", wxSOLID )„BoardPens[10] = wxPenFromColorName( "Cornflower Blue", 3, wxSOLID )„BoardBrush[10] = wxBrushFromColorName( "Cornflower Blue", wxSOLID )„BoardPens[11] = wxPenFromColorName( "Firebrick", 3, wxSOLID )„BoardBrush[11] = wxBrushFromColorName( "Firebrick", wxSOLID )„BoardPens[12] = wxPenFromColorName( "Maroon", 3, wxSOLID )„BoardBrush[12] = wxBrushFromColorName( "Maroon", wxSOLID )„BoardPens[13] = wxPenFromColorName( "Indian Red", 3, wxSOLID )„BoardBrush[13] = wxBrushFromColorName( "Indian Red", wxSOLID )„BoardPens[14] = wxPenFromColorName( "Khaki", 3, wxSOLID )„BoardBrush[14] = wxBrushFromColorName( "Khaki", wxSOLID )„BoardPens[15] = wxPenFromColorName( "Medium Forest Green", 3, wxSOLID )„BoardBrush[15] = wxBrushFromColorName( "Medium Forest Green", wxSOLID )„BoardPens[16] = wxPenFromColorName( "Medium Orchid", 3, wxSOLID )„BoardBrush[16] = wxBrushFromColorName( "Medium Orchid", wxSOLID )„BoardPens[17] = wxPenFromColorName( "Medium Sea Green", 3, wxSOLID )„BoardBrush[17] = wxBrushFromColorName( "Medium Sea Green", wxSOLID )„BoardPens[18] = wxPenFromColorName( "Medium Violet Red", 3, wxSOLID )„BoardBrush[18] = wxBrushFromColorName( "Medium Violet Red", wxSOLID )„BoardPens[19] = wxPenFromColorName( "Midnight Blue", 3, wxSOLID )„BoardBrush[19] = wxBrushFromColorName( "Midnight Blue", wxSOLID )„BoardPens[20] = wxPenFromColorName( "Navy", 3, wxSOLID )„BoardBrush[20] = wxBrushFromColorName( "Navy", wxSOLID )„BoardPens[21] = wxPenFromColorName( "Sienna", 3, wxSOLID )„BoardBrush[21] = wxBrushFromColorName( "Sienna", wxSOLID )„BoardPens[22] = wxPenFromColorName( "Turquoise", 3, wxSOLID )„BoardBrush[22] = wxBrushFromColorName( "Turquoise", wxSOLID )„BoardPens[23] = wxPenFromColorName( "Wheat", 3, wxSOLID )„BoardBrush[23] = wxBrushFromColorName( "Wheat", wxSOLID )„BoardPens[24] = wxPenFromColorName( "Thistle", 3, wxSOLID )„BoardBrush[24] = wxBrushFromColorName( "Thistle", wxSOLID )„„' create a bitmap for double buffering„Common bmp = wxEmptyBitmap( bmpX, bmpY )„' create a store for the graphic„Common bmpDC = wxMemoryDC()„bmpDC.SelectObject( bmp )„bmpDC.SetBackground( BlackBrush )„bmpDC.Clear()„„'Split routine for delimited lists„Sub Split(alist[], expression, delimiter)„	Dim tempstr  'Working string„	Dim stritem 'Delimited string„	Dim i       'Instr position„	Dim count = 0  'Array counter„	„	'Clear the passed array.„	Erase alist[]„	expression = RTrim$(expression)„	delimiter = RTrim$(delimiter)„	'See if we have an expression„	If Len(expression) > 0 And Len(delimiter) > 0 Then„		'See if we have a delimiter„		i = Instr(expression, delimiter)„		If i > 0 Then„			'Get a working copy of expression.„			tempstr = expression„		Else„			'Force this var to a string„			tempstr = ""„		End If„		'Get all the items.„		While i > 0„			'Get the array item.„			stritem = Left$(tempstr, i - 1)„			'Add it to the array w/o delimiter„			alist[count] = stritem„			'Clip off item and delimiter„			tempstr = Mid$(tempstr, i + Len(delimiter), Len(tempstr) - Len(delimiter))„			'Look for the next delimiter„			i = Instr(tempstr, delimiter)„			'Inc the array counter„			count += 1„		End While„		'Check to see if we have any items left.„		If Len(tempstr) > 0 Then„			'Add them to array„			alist[count] = tempstr„		End If„	End If„End Sub„„'Board Drawing routines.„Sub InitBoard()„	Dim x = 10,„		y = 6„	Dim i, j, cnt = 0„	Dim temp = ""„	'Clear the board„	bmpDC.Clear()„	For i = 1 To 8„		For j = 1 To 8„			If i = 1 OR j = 1 OR i = 8 OR j = 8 Then„				'Create a red pen„				bmpDC.SetPen( BoardPens[0] )„				bmpDC.SetBrush( BoardBrush[7] )„			Else„				'Create a white pen„				bmpDC.SetPen( BoardPens[7] )„				bmpDC.SetBrush( BoardBrush[7] )„			End If„			'Don't draw corners.„			If (i = 1 AND j = 1) OR ( i = 1 AND j = 8) OR (i = 8 AND j = 1) OR (i = 8 AND j = 8) Then„				BoardCO[i,j] = "0,0"„			Else„				'Draw the cell on the form„				bmpDC.DrawRoundedRectangle(x, y, CellHW, CellHW, 5)„				'bmpDC.SetPen( BoardPens[0] )„				'bmpDC.DrawText(i & "," & j, x, y)„				'Save the coordinates.„				BoardCO[i,j] = x & "," & y„			End If„			'Inc the cell„			x = x + CellHW + 10„		Next„		x = 10„		y = y + CellHW + 10„	Next„End Sub„„Sub GetCell(x, y, cx, cy)„	Dim coord[]„	Dim i,j„	Dim temp = ""„	Dim tx, ty„	Dim found = 0„	„	cx = 0„	cy = 0„	For i = 1 To 8„		For j = 1 To 8„			'Skip corner cells„			If (i = 1 AND j = 1) OR ( i = 1 AND j = 8) OR (i = 8 AND j = 1) OR (i = 8 AND j = 8) Then„				cx = 0„				cy = 0„			Else„				'Get the cell coordinates„				temp = BoardCO[i,j]„				Split(coord[], temp, ",")„				'See if the passed xy are in cell„				tx = Val(coord[0])„				ty = Val(coord[1])„				'Do the passed x,y fall inside the current cell„				If x >= tx AND x <= tx + CellHW Then„					If y >= ty AND y <= ty + CellHW Then„						'Grab the array index„						cx = i„						cy = j„						found = 1„						Exit For„					End If„				End If„			End If„		Next„		'Did we find a disk?„		If found = 1 Then„			Exit For„		End If„	Next„	'ShowBoard()„End Sub„„'Shoot a ray into the grid„Sub FireRay(i, j)„	Dim dir„	Dim done = False„	Dim coord[]„	Dim tx, ty„	Dim temp = ""„	Dim chk„	Dim chkd1, chkd2, chkd3, chkd4„	„	'Set the start direction.„	If i = 1 Then„		dir = GoDown„	ElseIf i = 8 Then„		dir = GoUp„	ElseIf j = 1 Then„		dir = GoRight„	ElseIf j = 8 Then„		dir = GoLeft„	End If„	'Iterate through grid„	While done = False„		'Set indexes based on direction.„		If dir = GoDown Then„			i += 1„		ElseIf dir = GoUp Then„			i -= 1„		ElseIf dir = GoRight Then„			j += 1„		ElseIf dir = GoLeft Then„			j -= 1„		End If„		'Did we hit the border?„		If i = 1 OR i = 8 Then„			Fire[i,j] = 1„		ElseIf j = 1 OR j = 8 Then„			Fire[i,j] = 1„		End If„		'Show the path„		If (ShowPath = 1 Or Fire[i,j] = 1) AND Disks[i,j] = 0 Then„			'Get the coordinates.„			temp = BoardCO[i, j]„			Split(coord[], temp, ",")„			tx = Val(coord[0])„			ty = Val(coord[1])„			'Show the firing.„			bmpDC.SetPen( BoardPens[NewColor] )„			bmpDC.SetBrush( BoardBrush[NewColor] )„			bmpDC.DrawRoundedRectangle(tx+5, ty+5, CellHW-10, CellHW-10, 20)„			'bmpDC.SetPen( BoardPens[0] )„			'bmpDC.DrawText(i & "," & j, tx, ty)„		End If„		'Did we hit a disk.„		If Disks[i,j] = 1 OR Fire[i,j] = 1 Then„			done = True„		End If„		'Set the flags„		chk = True„		'So we don't just spin in place„		chkd1 = False„		chkd2 = False„		chkd3 = False„		chkd4 = False„		While chk = True„			'Check for disk above.„			If dir = GoLeft Or dir = GoRight Then„				If i - 1 > 1 Then„					If Disks[i-1,j] = 1 And chkd1 = False Then„						dir = GoDown„						chkd1 = True„						Continue„					End If„				End If„			End If„			'Check for disk to left.„			If dir = GoDown Or dir = GoUp Then„				If j - 1 > 1 Then„					If Disks[i,j-1] = 1 And chkd2 = False Then„						dir = GoRight„						chkd2 = True„						Continue„					End If„				End If„			End If„			'Check for disk below„			If dir = GoLeft Or dir = GoRight Then„				If i + 1 < 8 Then„					If Disks[i+1,j] = 1 And chkd3 = False Then„						dir = GoUp„						chkd3 = True„						Continue„					End If„				End If„			End If„			'Check for disk to right.„			If dir = GoDown Or dir = GoUp Then„				If j +1 < 8 Then„					If Disks[i,j+1] = 1 And chkd4 = False Then„						dir = GoLeft„						chkd4 = True„						Continue„					End If„				End If„			End If„			chk = False„		End While„		„	End While„End Sub„„'The frame event handler.„Sub onEvent( event )„	Dim x, y, type„	Dim cx, cy, tx, ty„	Dim coord[]„	Dim temp = ""„	„	frame.SetStatusText("")„	'Get event info„    x = event.GetX()„    y = event.GetY()„    type = event.GetEventType()„    If InGame = 1 Then„		Select Case type„			Case wxEVT_LEFT_UP„				GetCell(x, y, cx, cy)„				If cx > 0 AND cy > 0 Then„					'Make sure the player clicked the outer edge cells„					If (cx = 1 OR cx = 8) OR (cy = 1 OR cy = 8) Then„						'See if we have already fired a ray from here.„						If Fire[cx, cy] = 0 Then„							'Set the fire flag„							Fire[cx, cy] = 1„							'Fire a ray.„							frame.SetStatusText("Firing ray...")„							'Get the coordinates.„							temp = BoardCO[cx, cy]„							Split(coord[], temp, ",")„							tx = Val(coord[0])„							ty = Val(coord[1])„							'Show the firing.„							bmpDC.SetPen( BoardPens[NewColor] )„							bmpDC.SetBrush( BoardBrush[NewColor] )„							bmpDC.DrawRoundedRectangle(tx+5, ty+5, CellHW-10, CellHW-10, 20)„							'Follow ray into grid„							FireRay(cx, cy)„							'Inc color pointer„							NewColor += 1„							If NewColor = 7 Then„								NewColor = 8„							ElseIf NewColor > 24 Then„								NewColor = 0„							End If„							'Show the board.„							ShowBoard()„						End If„					End If„				End If„			Case wxEVT_RIGHT_UP„				GetCell(x, y, cx, cy)„				If cx > 0 AND cy > 0 Then„					If cx > 1 AND cx < 8 Then„						If cy > 1 AND cy < 8 Then„							'Get the coordinates of cell„							temp = BoardCO[cx,cy]„							Split(coord[], temp, ",")„							tx = Val(coord[0])„							ty = Val(coord[1])„							'Toggle disk marker„							If Board[cx,cy] = 0 Then„								'Make sure all disks haven't ben used.„								If myDisks < hdDisks Then„									'Use red color„									bmpDC.SetPen( BoardPens[0] )„									bmpDC.SetBrush( BoardBrush[7] )„									'Draw a circle in the cell„									bmpDC.DrawRoundedRectangle(tx, ty, CellHW, CellHW, 20)„									ShowBoard()„									myDisks += 1„									Board[cx, cy] = 1„								Else„									frame.SetStatusText("You have used all your disks.")„								End If„							Else„								'Use white color„								bmpDC.SetPen( BoardPens[7] )„								bmpDC.SetBrush( BoardBrush[7] )„								'Draw a circle in the cell„								bmpDC.DrawRoundedRectangle(tx, ty, CellHW, CellHW, 20)„								ShowBoard()„								If myDisks > 0 Then„									myDisks -= 1„								End If„								Board[cx, cy] = 0„							End If„						End If„					End If„				End If„		End Select„	End If„End sub„„' attach callbacks„Connect( frame, -1, wxEVT_LEFT_UP, "onEvent" )„Connect( frame, -1, wxEVT_RIGHT_UP, "onEvent" )„„Sub ShowBoard()„	Dim dc„„    dc = wxClientDC( frame )„    dc.BeginDrawing()„    dc.Blit( 0, 0, bmpX, bmpY, bmpDC, 0, 0 )„    dc.EndDrawing()„End Sub„„„Sub onPaint( event )„	Dim dc„	„    ' get the DC of the frame„    dc = wxPaintDC( frame )„    dc.BeginDrawing()„„    ' blit the bitmap„    dc.Blit( 0, 0, bmpX, bmpY, bmpDC, 0, 0 )„„    dc.EndDrawing()„End Sub„Connect( frame, -1, wxEVT_PAINT, "onPaint" )„„Sub HideDisks()„	Dim i, j, x, y„	„	hdDisks = 0„	myDisks = 0„	'Clear the disks„	For i = 1 To 8„		For j = 1 To 8„			Disks[i,j] = 0„			Fire[i,j] = 0„		Next„	Next„	'Load the disks based on the skill level.„	If Skill = wxID_EASY Then„		'4 disks„		For i = 1 to 4„			'Disks must be inside outer cells„			x = Rnd(6) + 1„			y = Rnd(6) + 1„			'Make sure we don't put a disk in an occupied cell„			While Disks[x,y] = 1„				x = Rnd(6) + 1„				y = Rnd(6) + 1„			End While„			hdDisks += 1„			Disks[x,y] = 1„		Next„	ElseIf Skill = wxID_MEDIUM Then„		'5 disks„		For i = 1 to 5 „			x = Rnd(6) + 1„			y = Rnd(6) + 1„			While Disks[x,y] = 1„				x = Rnd(6) + 1„				y = Rnd(6) + 1„			End While	„			hdDisks += 1„			Disks[x,y] = 1„		Next„	Else„		'6 disks„		For i = 1 to 6 „			x = Rnd(6) + 1„			y = Rnd(6) + 1„			While Disks[x,y] = 1„				x = Rnd(6) + 1„				y = Rnd(6) + 1„			End While	„			hdDisks += 1„			Disks[x,y] = 1„		Next„	End If„End Sub„„' callback for the New menu option„Sub OnNew( event )„    InitBoard()„    HideDisks()„    ShowBoard()„	frame.SetStatusText("")„	InGame = 1„	NewColor = 0„End Sub„Connect( frame, wxID_NEW, wxEVT_COMMAND_MENU_SELECTED, "OnNew" )„„Sub OnPath( event )„	If ShowPath = 0 Then„		'Set the skill setting„		mSettings.Check( wxID_PATH, 1 )„		ShowPath = 1„	Else„		'Set the skill setting„		mSettings.Check( wxID_PATH, 0 )„		ShowPath = 0„	End If„End Sub„Connect( frame, wxID_PATH, wxEVT_COMMAND_MENU_SELECTED, "OnPath" )„„„//Event Sub for the Show_Disks menu option„Sub OnMenuShow_Disks ( event )„	Dim coord[]„	Dim i,j„	Dim x = 0, „		y = 0„	Dim temp = ""„	Dim cnt1 = 0„	Dim cnt2 = 0„	'Blue color„	bmpDC.SetPen( BoardPens[4] )„	'Look for the disks„	For i = 1 To 8„		For j = 1 To 8„			'Do we have a disk?„			If Disks[i,j] = 1 Then„				'Inc the disk counter„				cnt1 += 1„				'Did the player mark this disk?„				If Board[i,j] = 1 Then„					'Inc the player disk counter„					cnt2 += 1„				End If„				'Get the coordinates of the cell„				temp = BoardCO[i,j]„				'coord saved as string in x,y format„				Split(coord[], temp, ",")„				x = coord[0] „				y = coord[1]„				'Draw a blue circle in the cell„				bmpDC.DrawRoundedRectangle(x, y, CellHW, CellHW, 20)„			End If„		Next„	Next„	'Show the disks„	InGame = 0„	ShowBoard()„	frame.SetStatusText("You found " & cnt2 & " of " & cnt1 & " disks.")„End Sub„Connect( frame, wxID_SHOWDISKS, wxEVT_COMMAND_MENU_SELECTED, "OnMenuShow_Disks" )„„//Event Sub for the Exit menu option„Sub OnMenuExit ( event )„	End„End Sub„Connect( frame, wxID_EXIT, wxEVT_COMMAND_MENU_SELECTED, "OnMenuExit" )„Connect( frame, wxEVT_CLOSE_WINDOW, "OnMenuExit" )„„//Event Sub for the Easy menu option„Sub OnMenuEasy ( event )„	'Set the skill setting„	mSettings.Check( Skill, 0 )„	Skill = wxID_EASY„	mSettings.Check( Skill, 1 )„    InitBoard()„    HideDisks()„    ShowBoard()„	InGame = 1„End Sub„Connect( frame, wxID_EASY, wxEVT_COMMAND_MENU_SELECTED, "OnMenuEasy" )„„//Event Sub for the Medium menu option„Sub OnMenuMedium ( event )„	'Set the skill setting„	mSettings.Check( Skill, 0 )„	Skill = wxID_MEDIUM„	mSettings.Check( Skill, 1 )„    InitBoard()„    HideDisks()„    ShowBoard()„	InGame = 1„End Sub„Connect( frame, wxID_MEDIUM, wxEVT_COMMAND_MENU_SELECTED, "OnMenuMedium" )„„//Event Sub for the Hard menu option„Sub OnMenuHard ( event )„	'Set the skill setting„	mSettings.Check( Skill, 0 )„	Skill = wxID_HARD„	mSettings.Check( Skill, 1 )„    InitBoard()„    HideDisks()„    ShowBoard()„	InGame = 1„End Sub„Connect( frame, wxID_HARD, wxEVT_COMMAND_MENU_SELECTED, "OnMenuHard" )„„'Startup„InitBoard()„HideDisks()„ShowBoard()„'Show the frame.„frame.Show(True)„Richard D. Clark               Color Crazy - Rubiks Cub2 in 2Drickclark58@yahoo.com          18-18-02 (  :  )       WXBASIC                1    13724    ColorCrazy.w' Crazy Color
' Richard D. Clark
' rickclark58@yahoo.com
' Portions of code by:
' (c) 2002 David Cuny
' reminder grahpic by TronDoc
Option Explicit

Const RedColor = 1,
	  YellowColor = 2,
	  GreenColor = 3,
	  BlueColor = 4

//Pen
Const BlackPen = wxPenFromColorName( "Black", 3, wxSOLID )
//Brush
Const RedBrush = wxBrushFromColorName( "Red", wxSOLID ),
	  YellowBrush = wxBrushFromColorName( "Yellow", wxSOLID ),
	  GreenBrush = wxBrushFromColorName( "Green", wxSOLID ),
	  BlueBrush = wxBrushFromColorName( "Blue", wxSOLID ),
	  WhiteBrush = wxBrushFromColorName( "White", wxSOLID )
	  
//Menu ids
Const wxID_NewGame = wxID_HIGHEST + 1,
      wxID_Solve = wxID_HIGHEST + 2,
      wxID_Replay = wxID_HIGHEST + 3

//Working vars
Common NumberofMoves = 0
Common MovesToSolve = 0
Common Solution = ""
Common board[4,4]
Common shuffleboard[4,4]


//Define a frame
Common frame = new wxFrame(Null, -1, "Color Crazy",wxPoint(156,119),wxSize(390,430),wxSIMPLE_BORDER | wxCAPTION | wxSYSTEM_MENU | wxMINIMIZE_BOX)
frame.CreateStatusBar( 1 )
frame.SetStatusText("Ready")
//Button definition.
Common cmdRow1 = new wxButton(frame, -1, "Row 0", wxPoint(296,16), wxSize(69,65))
//Button definition.
Common cmdRow2 = new wxButton(frame, -1, "Row 1", wxPoint(296,84), wxSize(69,65))
//Button definition.
Common cmdRow3 = new wxButton(frame, -1, "Row 2", wxPoint(296,152), wxSize(69,65))
//Button definition.
Common cmdRow4 = new wxButton(frame, -1, "Row 3", wxPoint(296,220), wxSize(69,65))
//Button definition.
Common cmdCol1 = new wxButton(frame, -1, "Col 0", wxPoint(14,296), wxSize(65,65))
//Button definition.
Common cmdCol2 = new wxButton(frame, -1, "Col 1", wxPoint(82,296), wxSize(65,65))
//Button definition.
Common cmdCol3 = new wxButton(frame, -1, "Col 2", wxPoint(150,296), wxSize(65,65))
//Button definition.
Common cmdCol4 = new wxButton(frame, -1, "Col 3", wxPoint(218,296), wxSize(65,65))

//Menu
Common mBar = New wxMenuBar()
frame.SetMenuBar(mBar)
Common mMenu1 = New wxMenu()
mBar.Append(mMenu1, "&Game")
mMenu1.Append(wxID_NewGame, "&New Game", "Start a New Game")
mMenu1.Append(wxID_Solve, "&Solve", "Solve the Puzzle")
mMenu1.Append(wxID_Replay, "&Replay", "Replay Last Puzzle")
mMenu1.AppendSeparator()
mMenu1.Append(wxID_EXIT, "E&xit", "Exit the Game")

Common bmpX = 280,
	   bmpY = 280
' create a bitmap for double buffering
Common bmp = wxEmptyBitmap( bmpX, bmpY )
' create a store for the graphic
Common bmpDC = wxMemoryDC()
bmpDC.SelectObject( bmp )
bmpDC.SetBackground( WhiteBrush )
bmpDC.SetPen( BlackPen )
bmpDC.Clear()
Common reDC = wxMemoryDC()

'load the bitmap, return device context
Sub LoadReminder()
    Dim myBMP = New wxEmptyBitmap( 50, 50 )
    Dim dc
    
    If myBMP.LoadFile( "ccremind.bmp", wxBITMAP_TYPE_BMP ) Then
		reDC.SelectObject( myBMP )
    	dc = wxClientDC( frame )
    	dc.BeginDrawing()
    	dc.Blit( 306, 299, 50, 50, reDC, 0, 0 )
    	dc.EndDrawing()
    End If
End Sub


'Split routine for delimited lists
Sub Split(alist[], expression, delimiter)
	Dim tempstr  'Working string
	Dim stritem 'Delimited string
	Dim i       'Instr position
	Dim count = 0  'Array counter
	
	'Clear the passed array.
	Erase alist[]
	expression = RTrim$(expression)
	delimiter = RTrim$(delimiter)
	'See if we have an expression
	If Len(expression) > 0 And Len(delimiter) > 0 Then
		'See if we have a delimiter
		i = Instr(expression, delimiter)
		If i > 0 Then
			'Get a working copy of expression.
			tempstr = expression
		Else
			'Force this var to a string
			tempstr = ""
		End If
		'Get all the items.
		While i > 0
			'Get the array item.
			stritem = Left$(tempstr, i - 1)
			'Add it to the array w/o delimiter
			alist[count] = stritem
			'Clip off item and delimiter
			tempstr = Mid$(tempstr, i + Len(delimiter), Len(tempstr) - Len(delimiter))
			'Look for the next delimiter
			i = Instr(tempstr, delimiter)
			'Inc the array counter
			count += 1
		End While
		'Check to see if we have any items left.
		If Len(tempstr) > 0 Then
			'Add them to array
			alist[count] = tempstr
		End If
	End If
End Sub

'Returns the brush of the selected color
Function GetBrush(Color)
	Select Case Color
		Case RedColor
			Return RedBrush
		Case YellowColor
			Return YellowBrush
		Case GreenColor
			Return GreenBrush
		Case BlueColor
			Return BlueBrush
	End Select
End Function

Sub DrawBoard()
	Dim myBrush
	
	bmpDC.SetBackground( WhiteBrush )
	bmpDC.Clear()
	'Draw the red squares
	myBrush=GetBrush(board[0,0])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(4, 4, 64, 64, 5)
	myBrush=GetBrush(board[0,1])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(72, 4, 64, 64, 5)
	myBrush=GetBrush(board[1,0])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(4, 72, 64, 64, 5)
	myBrush=GetBrush(board[1,1])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(72, 72, 64, 64, 5)
	
	'Draw the yellow squares
	myBrush=GetBrush(board[0,2])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(140, 4, 64, 64, 5)
	myBrush=GetBrush(board[0,3])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(208, 4, 64, 64, 5)
	myBrush=GetBrush(board[1,2])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(140, 72, 64, 64, 5)
	myBrush=GetBrush(board[1,3])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(208, 72, 64, 64, 5)

	'Draw the Green squares
	myBrush=GetBrush(board[2,0])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(4, 140, 64, 64, 5)
	myBrush=GetBrush(board[2,1])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(72, 140, 64, 64, 5)
	myBrush=GetBrush(board[3,0])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(4, 208, 64, 64, 5)
	myBrush=GetBrush(board[3,1])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(72, 208, 64, 64, 5)

	'Draw the Blue squares
	myBrush=GetBrush(board[2,2])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(140, 140, 64, 64, 5)
	myBrush=GetBrush(board[2,3])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(208, 140, 64, 64, 5)
	myBrush=GetBrush(board[3,2])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(140, 208, 64, 64, 5)
	myBrush=GetBrush(board[3,3])
	bmpDC.SetBrush( myBrush )
	bmpDC.DrawRoundedRectangle(208, 208, 64, 64, 5)
End Sub

Sub InitBoard()
		
	'Draw the red squares
	board[0,0] = RedColor
	board[0,1] = RedColor
	board[1,0] = RedColor
	board[1,1] = RedColor
	
	'Draw the yellow squares
	board[0,2] = YellowColor
	board[0,3] = YellowColor
	board[1,2] = YellowColor
	board[1,3] = YellowColor

	'Draw the Green squares
	board[2,0] = GreenColor
	board[2,1] = GreenColor
	board[3,0] = GreenColor
	board[3,1] = GreenColor

	'Draw the Blue squares
	board[2,2] = BlueColor
	board[2,3] = BlueColor
	board[3,2] = BlueColor
	board[3,3] = BlueColor
	
	DrawBoard()
	NumberofMoves = 0
	MovesToSolve = 0
	Shuffle()
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
	
End Sub

'Updates the board
Sub ShowBoard()
	Dim dc

    dc = wxClientDC( frame )
    dc.BeginDrawing()
    dc.Blit( 10, 12, bmpX, bmpY, bmpDC, 0, 0 )
    dc.EndDrawing()
End Sub

'Rows are number 0 to 3
'Dir = 1, move right, Dir = -1, move left
Sub MoveRow(Row, Dir)
	Dim SaveColor
	Dim i
	
	'Moving column down
	If Dir = 1 Then
		'Save the color in last cell
		SaveColor = board[Row, 3]
		'Move cells down one
		For i = 3 to 1 Step -1
			board[Row, i] = board[Row, i-1]
		Next
		'Add in saved color to top cell.
		board[Row, 0] = SaveColor
	'Moving column up.
	Else
		'Save the color in last cell
		SaveColor = board[Row, 0]
		'Move cells down one
		For i = 0 to 2 
			board[Row, i] = board[Row, i+1]
		Next
		'Add in saved color to top cell.
		board[Row, 3] = SaveColor
	End If
	DrawBoard()
	ShowBoard()
End Sub

'Columns are number 0 to 3
'Dir = 1, move down, Dir = -1, move up
Sub MoveColumn(Col, Dir)
	Dim SaveColor
	Dim i
	
	'Moving column down
	If Dir = 1 Then
		'Save the color in last cell
		SaveColor = board[3, Col]
		'Move cells down one
		For i = 3 to 1 Step -1
			board[i, Col] = board[i-1, Col]
		Next
		'Add in saved color to top cell.
		board[0, Col] = SaveColor
	'Moving column up.
	Else
		'Save the color in last cell
		SaveColor = board[0, Col]
		'Move cells down one
		For i = 0 to 2 
			board[i, Col] = board[i+1, Col]
		Next
		'Add in saved color to top cell.
		board[3, Col] = SaveColor
	End If
	DrawBoard()
	ShowBoard()
End Sub

'Shuffles the board
'This is treated as playing the game backward.
Sub Shuffle()
	Dim Row = 0
	Dim Col = 0
	Dim i = 0
	Dim j = 0
	
	Randomize
	
	'Reset the solution
	Solution = ""
	'Get the number of shuffle moves.
	MovesToSolve = Rnd(10) + 8
	For i = 1 to MovesToSolve
		Row = Rnd(5) - 1
		While Row < 0
			Row = Rnd(5) - 1
		Wend
		Col = Rnd(5) - 1
		While Col < 0
			Col = Rnd(5) - 1
		Wend
		Solution = Solution & "C" & LTrim(Str(Col)) & ","
		MoveColumn(Col, 1)
		Solution = Solution & "R" & LTrim(Str(Row)) & ","
		MoveRow(Row, 1)
	Next
	MovesToSolve = (MovesToSolve * 2)
	'Get rid of last comma
	If Mid(Solution,Len(Solution),1) = "," Then
		Solution = Mid(Solution, 1, Len(Solution) - 1)
	End If
	'Save the shuffled board
	For i = 0 to 3
		For j = 0 to 3
			shuffleboard[i,j] = board[i, j]
		Next
	Next
End Sub

Sub Delay()
	Dim myTicks
	
    myTicks = Ticks()
    While Ticks() < myTicks + 1000
    Wend

End Sub

Sub Solve()
	Dim i = 0
	Dim j = 0
	Dim ch = ""
	Dim RowCol = 0
	Dim sol[]
	Dim NewSolution = ""
	
	'Reset the board to suffled board.
	'Save the shuffled board
	For i = 0 to 3
		For j = 0 to 3
			board[i,j] = shuffleboard[i, j]
		Next
	Next
	'Get the soluton parameters.
	Split(sol[], Solution, ",")
	For i = UBound(sol[], 1) to 0 Step -1
		ch = sol[i]
		frame.SetStatusText("Move: " & ch)
		NewSolution = NewSolution & ch & " "
		RowCol = Val(Mid(ch, 2, 1))
		If Mid(ch, 1, 1) = "C" Then
			MoveColumn(RowCol, -1)
		ElseIf Mid(ch, 1, 1) = "R" Then
			MoveRow(RowCol, -1)
		End If
		Delay	
	Next
	'Show the solution.
	wxMessageBox("Solution:\n" & NewSolution)	
End Sub

Sub onPaint( event )
	Dim dc
	
    ' get the DC of the frame
    dc = wxPaintDC( frame )
    dc.BeginDrawing()

    ' blit the bitmap
    dc.Blit( 10, 12, bmpX, bmpY, bmpDC, 0, 0 )
	'blit the reminder graphic
	dc.Blit( 306, 299, 50, 50, reDC, 0, 0 )
	
    dc.EndDrawing()
    
    
End Sub
Connect( frame, -1, wxEVT_PAINT, "onPaint" )

//Event Sub for the wxID_NewGame menu option
Sub OnMenuEvent3 ( event )
	InitBoard()
	ShowBoard()
End Sub
//***Change 'frame' to form name used***
Connect( frame, wxID_NewGame, wxEVT_COMMAND_MENU_SELECTED, "OnMenuEvent3" )

//Event Sub for the wxID_Solve menu option
Sub OnMenuEvent4 ( event )
	Solve()
End Sub
//***Change 'frame' to form name used***
Connect( frame, wxID_Solve, wxEVT_COMMAND_MENU_SELECTED, "OnMenuEvent4" )

//Event Sub for the wxID_Replay menu option
Sub OnMenuEvent5 ( event )
	Dim i = 0
	Dim j = 0
	
	'Reset the board to suffled board.
	'Save the shuffled board
	For i = 0 to 3
		For j = 0 to 3
			board[i,j] = shuffleboard[i, j]
		Next
	Next
	DrawBoard()
	ShowBoard()
	NumberofMoves = 0
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
		
End Sub
//***Change 'frame' to form name used***
Connect( frame, wxID_Replay, wxEVT_COMMAND_MENU_SELECTED, "OnMenuEvent5" )


//cmdRow1 event code.
Sub cmdRow1_Click ( event )
	MoveRow(0, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdRow1 connector.
Connect( cmdRow1, wxEVT_COMMAND_BUTTON_CLICKED, "cmdRow1_Click" )


//cmdRow2 event code.
Sub cmdRow2_Click ( event )
	MoveRow(1, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdRow2 connector.
Connect( cmdRow2, wxEVT_COMMAND_BUTTON_CLICKED, "cmdRow2_Click" )


//cmdRow3 event code.
Sub cmdRow3_Click ( event )
	MoveRow(2, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdRow3 connector.
Connect( cmdRow3, wxEVT_COMMAND_BUTTON_CLICKED, "cmdRow3_Click" )


//cmdRow4 event code.
Sub cmdRow4_Click ( event )
	MoveRow(3, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdRow4 connector.
Connect( cmdRow4, wxEVT_COMMAND_BUTTON_CLICKED, "cmdRow4_Click" )


//cmdCol1 event code.
Sub cmdCol1_Click ( event )
	MoveColumn(0, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdCol1 connector.
Connect( cmdCol1, wxEVT_COMMAND_BUTTON_CLICKED, "cmdCol1_Click" )


//cmdCol2 event code.
Sub cmdCol2_Click ( event )
	MoveColumn(1, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdCol2 connector.
Connect( cmdCol2, wxEVT_COMMAND_BUTTON_CLICKED, "cmdCol2_Click" )


//cmdCol3 event code.
Sub cmdCol3_Click ( event )
	MoveColumn(2, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdCol3 connector.
Connect( cmdCol3, wxEVT_COMMAND_BUTTON_CLICKED, "cmdCol3_Click" )


//cmdCol4 event code.
Sub cmdCol4_Click ( event )
	MoveColumn(3, -1)
	NumberofMoves += 1
	frame.SetStatusText("Move: " & NumberofMoves & " To Solve: " & MovesToSolve)
End Sub
//cmdCol4 connector.
Connect( cmdCol4, wxEVT_COMMAND_BUTTON_CLICKED, "cmdCol4_Click" )



'Add in the form exit event sub
Sub onFileExit( event )
	Dim dialog = new wxMessageDialog( frame, "Are you sure?", "Exiting Program", wxYES_NO + wxCENTRE + wxICON_QUESTION )
	Dim result = dialog.ShowModal()
	Delete dialog

	If result = wxID_YES Then
		End
	End If
End Sub
Connect( frame, wxID_EXIT, wxEVT_COMMAND_MENU_SELECTED, "onFileExit" )
Connect( frame, wxEVT_CLOSE_WINDOW, "onFileExit" )


'Set the reminder graphic
LoadReminder()
'DrawBoard
InitBoard()

'Show the frame
frame.Show (True)
„Richard D. Clark               Golf Card Game - A Remake      rickclark58@yahoo.com          18-18-02 (  :  )       IBASIC                 804  18939    ibgolf.iba  '    Copyright (C) 2003  Richard D. Clark„'	 rickclark58@yahoo.com„„'    This program is free software; you can redistribute it and/or modify„'    it under the terms of the GNU General Public License as published by„'    the Free Software Foundation; either version 2 of the License, or„'    (at your option) any later version.„„'    This program is distributed in the hope that it will be useful,„'    but WITHOUT ANY WARRANTY; without even the implied warranty of„'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the„'    GNU General Public License for more details.„„'    You should have received a copy of the GNU General Public License„'    along with this program; if not, write to the Free Software„'    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA„„' Required in Form Load to use dll„DECLARE "qcard32.dll",InitializeDeck(hwnd:INT),INT„' Reset all card values to defaults„DECLARE "qcard32.dll",SetDefaultValues()„' Set the currently used card back design for cards 105 to 109„DECLARE "qcard32.dll",SetCurrentBack(nIndex:INT)„' Card drawing "qcard32.dll",s„DECLARE "qcard32.dll",DrawSymbol(hwnd:INT, nValue:INT, x:INT, y:INT)„DECLARE "qcard32.dll",DealCard(hwnd:INT, nCard:INT, x:INT, y:INT)„DECLARE "qcard32.dll",DrawCard(hwnd:INT, nCard:INT, x:INT, y:INT)„DECLARE "qcard32.dll",RemoveCard(hwnd:INT, nCard:INT)„DECLARE "qcard32.dll",DrawBack(hwnd:INT, nValue:INT, x:INT, y:INT)„' Get card information "qcard32.dll",s„DECLARE "qcard32.dll",GetCardValue(nCard:INT),INT„DECLARE "qcard32.dll",GetCardBlocked(nCard:INT),INT„DECLARE "qcard32.dll",IsCardDisabled(nCard:INT),INT„DECLARE "qcard32.dll",GetCardX(nCard:INT),INT„DECLARE "qcard32.dll",GetCardY(nCard:INT),INT„' Set card information "qcard32.dll",s„DECLARE "qcard32.dll",SetCardStatus(nCard:INT, bValue:INT)„DECLARE "qcard32.dll",AdjustCardBlocked(nCard:INT, bValue:INT)„DECLARE "qcard32.dll",SetCardDisabled(nCard:INT, bValue:INT)„' Dragging "qcard32.dll",s and "qcard32.dll",s„DECLARE "qcard32.dll", InitDrag(hwnd:INT, x:INT, y:INT),INT„DECLARE "qcard32.dll", AbortDrag()„„'Golf declarations.„DECLARE LoadCards()„DECLARE DrawCards()„DECLARE CardClick(x:INT, y:INT)„DECLARE StartUp()„DECLARE ShowHelp()„DECLARE DrawCardBacks()„DECLARE SelectCardBack(x:INT, y:INT)„DECLARE LoadCardSettings(pname:STRING)„DECLARE SaveCardSettings()„DECLARE ShowHighScores()„DECLARE ShowWin()„„TYPE playpref„	DEF playname:STRING„	DEF design:INT„	DEF highscore:INT„ENDTYPE„DEF playerpref:playpref„„CONST FACEDOWN = 0„CONST FACEUP = 1„CONST CARDWIDTH = 71„CONST CARDHEIGHT = 96„CONST OFFSET = 16„CONST TRUE = 1„CONST FALSE = 0„CONST PLACEX = 1„CONST PLACE0 = 2„CONST PLACEC = 3„CONST WINWIDTH = 700„CONST WINHEIGHT = 400„„DEF run:INT„DEF w:WINDOW „DEF d1:DIALOG„DEF draw[16]:INT„DEF stack[7,5]:INT„DEF played[52]:INT„DEF cardsleft:INT„DEF playptr:INT„DEF backcolor:INT„DEF ingame:INT„DEF playy:INT„DEF ret:INT„DEF score:INT„DEF bonus:INT„DEF selectback:INT„DEF showhs:INT„DEF gamewon:INT„„DIALOG d1,0,0,234,108,0x80C80080,0,"Enter Name",dHandler„CONTROL d1,"T,Name:,7,16,42,20,0x5000010B,1"„CONTROL d1,"E,Player,47,15,144,20,0x50800000,2"„CONTROL d1,"B,&OK,82,63,70,20,0x50000001,3"„„'Get the player's name.„DOMODAL d1„„WINDOW w,0,0,WINWIDTH,WINHEIGHT,@SIZE|@MINBOX|@NOAUTODRAW|@MAXBOX,0,"IBasic Golf",main „CENTERWINDOW w „MENU w,"T,&Game,0,0","I,New,0,1","I,-,0,0","I,Quit,0,2"„INSERTMENU w,1,"T,&Options,0,0","I,Card Design,0,3","I,High Scores,0,4"„INSERTMENU w,2,"T,&Help,0,0","I,Contents,0,5"„„'The window color - standard green.„backcolor = RGB(0, 130, 0)„'Set the default for the select cards.„selectcard = FALSE„'Can only cal this once.„ret = InitializeDeck(w)„IF ret = FALSE„	'If we can't load the dll then exit.„	MESSAGEBOX w,"Cannot initialize Qcards32.dll.","IBasic Golf"„	run = 0„ELSE„	'Ket's go.„	StartUp„	run = 1 „ENDIF„'Strat main event loop.„WAITUNTIL run=0 „CLOSEWINDOW w:END „„„SUB main „	SELECT @CLASS „	CASE @IDCLOSEWINDOW „		'Save the current settings.„		SaveCardSettings„		'Exit flag„		run = 0„	CASE @IDPAINT„		'Show the design selection screen.„		IF selectback = TRUE„			DrawCardBacks„		ELSE„			'Show the high scores„			IF showhs = TRUE„				ShowHighScores„			ELSE„				'Did the player win the game?„				IF gamewon = TRUE„					ShowWin„				ELSE„					'Draw the cards„					DrawCards„				ENDIF„			ENDIF„		ENDIF„	CASE @IDLBUTTONUP„		'Get the selected card design„		IF selectback = TRUE„			SelectCardBack @MOUSEX, @MOUSEY„		ELSE„			'Clear the high scores„			IF showhs = TRUE„				showhs = FALSE„				SETWINDOWCOLOR w, backcolor„			ELSE„				'Process the move„				IF ingame = TRUE„					CardClick @MOUSEX, @MOUSEY„				ENDIF„			ENDIF„		ENDIF„	CASE @IDMENUPICK„		SELECT @MENUNUM„			CASE 1„				'New„				Startup„				DrawCards„			CASE 2„				'Quit„				run = 0„			CASE 3„				'Card design„				selectback = TRUE„				SETWINDOWCOLOR w, backcolor„			CASE 4„				'High scores„				showhs = TRUE„				SETWINDOWCOLOR w, backcolor„			CASE 5„				'Display the help file.„				ShowHelp„		ENDSELECT„	ENDSELECT „RETURN „„SUB dHandler„	DEF answer:STRING„„	SELECT @CLASS„   	CASE @IDCONTROL„		SELECT @CONTROLID„        CASE 3„			'Player clicked the OK button.„			answer = GETCONTROLTEXT(d1, 2)„   		    CLOSEDIALOG d1,@IDOK„			LoadCardSettings answer„        ENDSELECT„	CASE @IDINITDIALOG„ 	   CENTERWINDOW d1„	ENDSELECT„RETURN„„SUB LoadCards„	DEF i,j:INT„	DEF temp:INT„	DEF k:INT„	DEF deck[52]:INT„	DEF cnt:INT„	DEF carddisabled:INT„„	'Load all the cards„	FOR i = 0 TO 51„		deck[i] = i + 1„	NEXT i	„	'Shuffle the cards.	„	FOR i = 0 TO 51„		'Get a random slot.„		k = RND(52) - 1„		'Get the value for the slot.„		temp = deck[k]„		'Swap the values with the current slot.„		deck[k] = deck[i]„		deck[i] = temp„	NEXT i„	'Load the stacks.„	FOR i = 0 to 6„		FOR j = 0 to 4„			stack[i,j] = deck[cnt]„			'Block the card„			AdjustCardBlocked(stack[i,j], TRUE)„			carddisabled = GetCardBlocked(stack[i,j])„			cnt = cnt + 1„		NEXT j„	NEXT i„	'Unblock the cards in the last rows of the stacks.„	FOR i = 0 to 6„		AdjustCardBlocked stack[i,4], FALSE„	NEXT i„	'Load the rest of the cards, except the last into the draw stack.„	FOR i = 0 TO 15„		draw[i] = deck[cnt]„		cnt = cnt + 1„		'Increment the cards left counter.„		cardsleft = cardsleft + 1„	NEXT i„	'Put the last card in play.„	played[0] = deck[51]„	'Set the current play spot.„	playptr = 0„RETURN„„SUB DrawCards„	DEF x,y:INT„	DEF i,j:INT„„	'Draw the table cards.„	x = -CARDWIDTH + OFFSET:y = 0„	FOR i = 0 TO 6„		x = x + CARDWIDTH + 2„		y = OFFSET„		FOR j = 0 TO 4„			'Deal the table cards„			IF stack[i, j]<>0„				DealCard w, stack[i, j], x, y„				y = y + OFFSET„			ENDIF„		NEXT j„	NEXT i„	y = 200„	'Save this for the message.„	playy = y„	x = OFFSET„	'If we are out of draw cards, sraw the placeholder„	IF cardsleft = 0„		DrawSymbol w, PLACEX, x, y„	ENDIF„	'Set the card back„	SetCurrentBack(playerpref.design)„	'The draw pile.„	FOR i = 0 TO 15„		IF draw[i]<>0„			'Deal it face down.„			SetCardStatus draw[i], FACEDOWN„			Dealcard w, draw[i], x, playy„		ENDIF„	NEXT i„	'Draw the played cards.„	x = CARDWIDTH + (OFFSET * 2)„	FOR i = 0 to playptr„		IF played[i]<>0„			'Deal the played card.„			Dealcard w, played[i], x, y„			'Diasble it so it is out of play.„			SetCardDisabled played[i], TRUE„			x = x + 8„		ENDIF„	NEXT i„	WriteMessage„RETURN„„SUB CardClick(x:INT, y:INT)„	DEF source:INT„	DEF sourcevalue:INT„	DEF destvalue:INT„	DEF i,j,k:INT„	DEF found:INT„	DEF carddisabled:INT„	DEF cardx:INT„	DEF cardy:INT„„	'Get the source card.„	source = InitDrag(w, x, y)„	'Abort the drag. We are only trying to get the selected card.„	AbortDrag„	'Get the old location„	cardx = GetCardX(source)„	cardy = GetCardY(source)„	'Is the card blocked?„	carddisabled = GetCardBlocked(source)„	'Is a valid card selected.„	IF (source > 0) & (carddisabled = FALSE)„		'Check to see if the card is in the draw pile.„		found = FALSE„		FOR i = 0 to 15„			IF draw[i] = source„				'We found the card„				found = TRUE„				'Remove it from the pile.„				RemoveCard w, source„				'Set the card to face up„				SetCardStatus draw[i], FACEUP„				'Add the card to the play pile.„				playptr = playptr + 1„				played[playptr] = draw[i]„				draw[i] = 0„				cardsleft = cardsleft - 1„				'Reset the bonus.„				bonus = 0„				'Redraw the window„				Drawcards„				'*** Test win sub„				'playptr = 51„				'Did the player win?„				IF playptr = 51„					'Thousand point bonus„					score = score + 1000„					IF score > playerpref.highscore„						playerpref.highscore = score„					ENDIF„					ingame = FALSE„					'Do the win routine.„					gamewon = TRUE„					SETWINDOWCOLOR w, backcolor„				ENDIF„				GOTO GetOut„			ENDIF„		NEXT i„„		'Look for the card in the card stack.„		IF found = FALSE„'stop„			FOR i = 0 to 6„				FOR j = 0 to 4„					IF (stack[i,j] = source) „						'Get the source value.„						sourcevalue = GetCardValue(source)„						'Get the top dest card value.„						destvalue = GetCardValue(played[playptr])„						'Is the card playable?„						IF ABS(sourcevalue - destvalue) = 1„							'Remove the card from the screen.„							RemoveCard w, source„							'Clear the stack array„							stack[i,j] = 0„							'Set the previous card, if any, to unblocked.„							IF (j - 1) >= 0„								AdjustCardBlocked stack[i,j-1], FALSE„							ENDIF„							'Add the card to the play pile.„							playptr = playptr + 1„							played[playptr] = source„							'Increment the score„							score = score + (10 * sourcevalue)„							score = score + bonus„							'Add in the bonus„							bonus = bonus + 10„							'New high score?„							IF score > playerpref.highscore„								playerpref.highscore = score„							ENDIF„							'Repaint the window„							RECT w, cardx, cardy, CARDWIDTH, CARDHEIGHT , RGB(0,130,0), RGB(0,130,0)„							DrawCards„							'Did the player win?„							IF playptr = 51„								'Thousand point bonus„								score = score + 1000„								IF score > playerpref.highscore„									playerpref.highscore = score„								ENDIF„								ingame = FALSE„								'Do the win routine.„								gamewon = TRUE„								SETWINDOWCOLOR w, backcolor„							ENDIF„							'Get out of the loop.„							GOTO GetOut„						ENDIF„					ENDIF„				NEXT j„			NEXT i„		ENDIF„	ENDIF„GetOut: „RETURN„„SUB WriteMessage()„	'Set the defaults„	MOVE w, OFFSET, playy + CARDHEIGHT + 2„	FRONTPEN w, RGB(255, 255, 255)„	BACKPEN w, backcolor„	'How many cards left in draw pile„	PRINT w, "Cards: " + STR$(cardsleft) + "  "„	RECT w, 545, OFFSET, 130, 90 , RGB(255,255,0), RGB(0,130,0)„	MOVE w, 545 + OFFSET + 10, OFFSET + 10„	'write the title„	PRINT w, "IBasic Golf"„	MOVE w, 545 + OFFSET - 5, OFFSET + 35„	PRINT w, "By Richard Clark"„	MOVE w, 545 + OFFSET + 10, OFFSET + 60„	PRINT w, "Version 1.0"„	'write the score.„	MOVE w, 545, OFFSET + 100„	PRINT w, "Score: " + STR$(score)„	'Write the current bonus.„	MOVE w, 545, OFFSET + 125„	PRINT w, "Bonus: " + STR$(bonus) + "    "„	'Write the highscore.„	MOVE w, 545, OFFSET + 150„	PRINT w, "High Score: " + STR$(playerpref.highscore) + "    "„	„RETURN„„SUB StartUp„	DEF i:INT„	DEF j:INT„„	'Save the current settings.„	SaveCardSettings„	'Clear the window.„	SETWINDOWCOLOR w, backcolor„	'Reset the card dll„	SetDefaultValues„	'Clear the deck.„	FOR i = 0 to 51„		RemoveCard w, i + 1„	NEXT i„	'Clear the work arrays.„	FOR i = 0 TO 15„		draw[i] = 0„	NEXT i„	FOR i = 0 to 6„		FOR j = 0 to 4„			stack[i,j] = 0„		NEXT j„	NEXT i„	FOR i = 0 to 51„		played[i] = 0„	NEXT i„	'Reset the values.„	ingame = TRUE„	cardsleft = 0„	score = 0„	bonus = 0„	selectback = FALSE„	showhs = FALSE„	gamewon = FALSE„	'Load all the cards into the deck array.„	LoadCards„RETURN„„SUB DrawCardBacks„	DEF i:INT„	DEF x,y:INT„„	'Draw the card backs.„	x = 50:y = 100„	DrawBack w, 1, x, y„	x = 150:y = 100„	DrawBack w, 2, x, y„	x = 250:y = 100„	DrawBack w, 3, x, y„	x = 350:y = 100„	DrawBack w, 4, x, y„	x = 450:y = 100„	DrawBack w, 5, x, y„	x = 550:y = 100„	DrawBack w, 6, x, y„„	FRONTPEN w, RGB(255, 255, 255)„	BACKPEN w, backcolor„	MOVE w, 280, 50„	PRINT w, "Select Card Design"„	MOVE w, 160, 250„	PRINT w, "Click on card to select design or green area to cancel."„	„RETURN„„SUB SelectCardBack(x:INT, y:INT)„	„	'Which card did player select.„	IF (x >= 50) & (x <= 50 + CARDWIDTH)„		IF (y >= 100) & (y <= 100 + CARDHEIGHT)„			playerpref.design = 1„			GOTO GetOutSelectCard„		ENDIF„	ENDIF„	IF (x >= 150) & (x <= 150 + CARDWIDTH)„		IF (y >= 100) & (y <= 100 + CARDHEIGHT)„			playerpref.design = 2„			GOTO GetOutSelectCard„		ENDIF„	ENDIF„	IF (x >= 250) & (x <= 250 + CARDWIDTH)„		IF (y >= 100) & (y <= 100 + CARDHEIGHT)„			playerpref.design = 3„			GOTO GetOutSelectCard„		ENDIF„	ENDIF„	IF (x >= 350) & (x <= 350 + CARDWIDTH)„		IF (y >= 100) & (y <= 100 + CARDHEIGHT)„			playerpref.design = 4„			GOTO GetOutSelectCard„		ENDIF„	ENDIF„	IF (x >= 450) & (x <= 450 + CARDWIDTH)„		IF (y >= 100) & (y <= 100 + CARDHEIGHT)„			playerpref.design = 5„			GOTO GetOutSelectCard„		ENDIF„	ENDIF„	IF (x >= 550) & (x <= 550 + CARDWIDTH)„		IF (y >= 100) & (y <= 100 + CARDHEIGHT)„			playerpref.design = 6„			GOTO GetOutSelectCard„		ENDIF„	ENDIF„„GetOutSelectCard:„	selectback = FALSE„	SETWINDOWCOLOR w, backcolor„RETURN„„SUB ShowHelp„	DEF helpfile:STRING„	DEF ret:INT„„	'Get the program folder.„	helpfile = GETSTARTPATH„	IF RIGHT$(helpfile,1)<>"\"„		helpfile = helpfile + "\"„	ENDIF„	helpfile = helpfile + "ibgolf.chm"„	'Show the help file.„	SYSTEM helpfile„RETURN„„SUB LoadCardSettings(pname:STRING)„	DEF cfgfile:STRING„	DEF f:FILE„	DEF fret:INT„	DEF item:STRING„	DEF fread:INT„	DEF rdata:STRING„	DEF isep:INT„„	'Set the default balues.„	playerpref.playname = pname„	playerpref.design = 1„	playerpref.highscore = 0„	'Get the program folder.„	cfgfile = GETSTARTPATH„	IF RIGHT$(cfgfile,1)<>"\"„		cfgfile = cfgfile + "\"„	ENDIF„	cfgfile = cfgfile + "ibgolf.cfg"„	fret = OPENFILE(f, cfgfile,"R")„	IF fret = 0„		'Get the file data.„		WHILE EOF(f) = FALSE„			fread = READ(f, item)„			IF fread = 0„				'Parse the string.„				isep = INSTR(item, ";")„				IF isep > 0„					'Get the name„					rdata = LEFT$(item, isep - 1)„					'Do we have a match.„					IF rdata = pname„						'Clip off the name.„						item = MID$(item, isep + 1)„						'Get card design„						isep = INSTR(item, ";"„						IF isep > 0„							rdata = LEFT$(item, isep - 1)„							playerpref.design = VAL(rdata)„							'Clip off the design„							item = MID$(item, isep + 1)„							'Save the highscore„							playerpref.highscore = VAL(item)„							GOTO GetOutLoadCards„						ENDIF„					ENDIF„				ENDIF„			ENDIF„		ENDWHILE„	ENDIF„GetOutLoadCards:„	IF fret = 0„		CLOSEFILE f„	ENDIF„RETURN„„SUB SaveCardSettings„	DEF cfgfile:STRING„	DEF tempfile:STRING„	DEF folder:STRING„	DEF f:FILE„	DEF f1:FILE„	DEF fret:INT„	DEF fret1:INT„	DEF item:STRING„	DEF rdata:STRING„	DEF pdata:STRING„„'stop	„	'Get the program folder.„	folder = GETSTARTPATH„	'Build the ini filename„	IF RIGHT$(folder,1)<>"\"„		folder = folder + "\"„	ENDIF„	cfgfile = folder + "ibgolf.cfg"„	tempfile  = folder + "ibgolf.tmp"„	'Try and open the config file.„	fret = OPENFILE(f, cfgfile,"R")„	IF fret <> 0„		'Create a new file.„		fret = OPENFILE(f, cfgfile,"A")„		item = RTRIM$(playerpref.playname) „		rdata = LTRIM$((STR$(playerpref.design)) „		pdata = LTRIM$(STR$(playerpref.highscore))„		item = item + ";" + rdata + ";" + pdata„		WRITE f, item„		CLOSEFILE f„		GOTO GetOutSaveFile„	ENDIF„	'Copy the items to a temp file.„	fret1 = OPENFILE(f1, tempfile,"A")„	IF (fret = 0) & (fret1 = 0)„		'Write out the player info first.„		item = RTRIM$(playerpref.playname) „		rdata = LTRIM$((STR$(playerpref.design)) „		pdata = LTRIM$(STR$(playerpref.highscore))„		item = item + ";" + rdata + ";" + pdata„		WRITE f1, item„		'Get the file data.„		WHILE EOF(f) = FALSE„			fread = READ(f, item)„			IF fread = 0„				'Parse for the string.„				isep = INSTR(item, ";")„				IF isep > 0„					'Get the name„					rdata = LEFT$(item, isep - 1)„					'Do we have a match.„					IF rdata <> playerpref.playname„						'Write out the data„						WRITE f1, item„					ENDIF„				ENDIF„			ENDIF„		ENDWHILE„	ENDIF„	'Close the files.„	IF fret = 0„		CLOSEFILE f„	ENDIF„	IF fret1 = 0„		CLOSEFILE f1„	ENDIF„	'Copy over the new file.„	IF (fret = 0) & (fret1 = 0)„		COPYFILE tempfile, cfgfile, 0„		DELETEFILE tempfile„	ENDIF„GetOutSaveFile:„RETURN„„SUB ShowHighScores„	DEF cfgfile:STRING„	DEF fret:INT„	DEF f:FILE„	DEF x,y:INT„	DEF isep:INT„	DEF rdata:STRING„	DEF outdata:STRING„	DEF item:STRING„„	'Save the current settings.„	SaveCardSettings„	'Draw the border.	„	RECT w, 20, 20, WINWIDTH - 40, WINHEIGHT - 80 , RGB(255,255,0), BACKCOLOR„	'Set the pen markers.„	FRONTPEN w, RGB(255, 255, 0)„	BACKPEN w, backcolor„	'Print the header.„	x = 30:y = 10„	MOVE w, x, y„	PRINT w, " * High Scores * "„	FRONTPEN w, RGB(255, 255, 255)„	'Get the program folder.„	cfgfile = GETSTARTPATH„	IF RIGHT$(cfgfile,1)<>"\"„		cfgfile = cfgfile + "\"„	ENDIF„	cfgfile = cfgfile + "ibgolf.cfg"„	fret = OPENFILE(f, cfgfile, "R")„	IF fret = 0„		'Get the file data.„		WHILE EOF(f) = FALSE„			fread = READ(f, item)„			IF fread = 0„				'Parse the string.„				isep = INSTR(item, ";")„				IF isep > 0„					'Get the name„					rdata = LEFT$(item, isep - 1)„					'Save the name„					outdata = rdata + ": "„					'Clip off the name.„					item = MID$(item, isep + 1)„					'Clip off the card design„					isep = INSTR(item, ";"„					IF isep > 0„						'Get the high score„						item = MID$(item, isep + 1)„						outdata = outdata + item„						'Adjust the columns„						y = y + 20„						IF y > (WINHEIGHT - 100)„							x = x + 50„							y = 10„						ENDIF„						MOVE w, x, y„						PRINT w, outdata„					ENDIF„				ENDIF„			ENDIF„		ENDWHILE		„	ENDIF„	'Close the file.„	IF fret = 0„		CLOSEFILE f„	ENDIF„	'Print close instructions.„	MOVE w, 30, WINHEIGHT - 70„	PRINT w, " Click window to return to game. "„	„RETURN„„SUB ShowWin„	DEF x,y:INT„	DEF i:INT„	DEF msg:STRING„	„	'The win message„	msg = " Wow! You won the game! "„	FOR i = 1 TO 113„		x = RND(WINWIDTH)„		Y = RND(WINHEIGHT)„		DrawCard w, i, x, y„	NEXT i„	FOR i = 1 TO 113„		x = RND(WINWIDTH)„		Y = RND(WINHEIGHT)„		DrawCard w, i, x, y„	NEXT i„	'Set the pen markers.„	FRONTPEN w, RGB(255, 255, 255)„	BACKPEN w, backcolor„	'Print close instructions.„	RECT w, 250, 30, 190, 30, RGB(255,255,0), backcolor„	MOVE w, 258, 35„	PRINT w, msg„RETURN„Richard D. Clark               One Minute Solitaire           rickclark58@yahoo.com          18-18-02 (  :  )       IBASIC                 692  15915    omsol.iba   DECLARE "user32",GetSysColor(nIndex:INT),INT„„DECLARE "qcard32.dll",InitializeDeck(hwnd:INT),INT„DECLARE "qcard32.dll",SetDefaultValues()„DECLARE "qcard32.dll",SetCardStatus(nCard:INT, bValue:INT)„DECLARE "qcard32.dll",SetCurrentBack(nIndex:INT)„DECLARE "qcard32.dll",DrawSymbol(hwnd:INT, nValue:INT, x:INT, y:INT)„DECLARE "qcard32.dll",DrawCard(hwnd:INT, nCard:INT, x:INT, y:INT)„DECLARE "qcard32.dll",DealCard(hwnd:INT, nCard:INT, x:INT, y:INT)„DECLARE "qcard32.dll",RemoveCard(hwnd:INT, nCard:INT)„DECLARE "qcard32.dll",GetCardSuit(nCard:INT),INT„DECLARE "qcard32.dll",GetCardValue(nCard:INT),INT„DECLARE "qcard32.dll",ReturnDrag(hwnd:INT, nCard:INT, nOldX:INT, nOldY:INT)„„'Local declares.„DECLARE DrawWindow()„DECLARE StartUp()„DECLARE ShowTime()„DECLARE LoadAllImages()„DECLARE DeleteAllImages()„DECLARE Shuffle()„DECLARE DrawButtonUp(tbtn:btn)„DECLARE DrawButtonDn(tbtn:btn)„DECLARE CheckButton(x:INT, y:INT)„DECLARE DrawButtons()„DECLARE PlayCard()„DECLARE MoveToDiscard()„DECLARE ReloadDeck()„DECLARE ShowWin()„DECLARE ShowCardTotal()„DECLARE DoPlay()„DECLARE DoDiscard()„DECLARE PrePlay()„DECLARE StartPrePlay()„„'Custom button type„TYPE btn„	DEF top:INT„	DEF left:INT„	DEF width:INT„	DEF height:INT„	DEF caption:STRING„ENDTYPE„„„'Useful card consts„CONST FACEDOWN = 0„CONST FACEUP = 1„CONST CARDWIDTH = 71„CONST CARDHEIGHT = 96„CONST OFFSET = 16„CONST IMGBITMAP = 0„CONST TRUE = 1„CONST FALSE = 0„CONST PLACEHOLDER = 2„CONST CX = 200„CONST CY = 100„'Custom button info„CONST COLOR_APPWORKSPACE = 12„CONST COLOR_BTNTEXT = 18„CONST COLOR_BTNSHADOW = 16„CONST COLOR_BTNHIGHLIGHT = 20„CONST COLOR_BTNFACE = 15„CONST BTN_NUM = 2„'Window„CONST WINWIDTH = 640„CONST WINHEIGHT = 300„„DEF run:INT„DEF w:WINDOW „DEF ret:INT„DEF omb:INT„DEF cmb:INT„'App path„DEF ppath:STRING„'Clock defs„DEF currclock:INT„DEF digits[10]:INT„'Card defs„DEF savedeck[52]:INT„DEF deck[52]:INT„DEF deckptr:INT„DEF discard[52]:INT„DEF discardptr:INT„DEF pile[52]:INT„DEF pileptr:INT„DEF instart:INT„DEF playedtotal:INT„'Button color vars.„DEF btnface:INT„DEF btnhighlight:INT„DEF btnshadow:INT„DEF appworkspace:INT„DEF btntext:INT„DEF bclick:INT„'Button array„DEF tbutton[BTN_NUM]:btn„DEF ingame:INT„'Window defs„DEF backcolor:INT„DEF mykey:INT„DEF debug:INT„DEF inreload:INT„DEF preplaycount:INT„DEF replay:INT„DEF firstgame:INT„DEF skillsecond:INT„DEF skillmenu:INT„„'Testing„LET debug, FALSE„'Init vars„LET inreload, FALSE„LET replay, FALSE„LET firstgame, FALSE„'Skill settings„LET skillsecond, 1„LET skillmenu, 6„„'Load the system colors.„LET backcolor, RGB(0, 99, 0)„LET btnface, GetSysColor(COLOR_BTNFACE)„LET btnhighlight, GetSysColor(COLOR_BTNHIGHLIGHT)„LET btnshadow, GetSysColor(COLOR_BTNSHADOW)„LET appworkspace, GetSysColor(COLOR_APPWORKSPACE)„LET btntext, GetSysColor(COLOR_BTNTEXT)„„'Get the program path.„LET ppath, GETSTARTPATH„IF RIGHT$(ppath,1)<> "\"„	LET ppath,"\"„ENDIF„„WINDOW w,0,0,WINWIDTH,WINHEIGHT,@SIZE|@MINBOX|@NOAUTODRAW,0,"One Minute Solitaire",main „MENU w,"T,&Game,0,0","I,&New,0,1","I,&Preplay,0,2","I,&Replay,0,3","I,-,0,0","I,&Quit,0,4"„INSERTMENU w,1,"T,&Skills,0,0","I,Beginner,0,5","I,Normal,0,6","I,Master,0,7"„„CENTERWINDOW w „SETWINDOWCOLOR w, backcolor„'Set the font for the window„SETFONT w, "Tahoma", 0, 0„„'Init the deck.„LET ret, InitializeDeck(w)„IF ret = FALSE„	'If we can't load the dll then exit.„	MESSAGEBOX w,"Cannot initialize Qcards32.dll.","One Minute Solitaire"„	LET run, 0„ELSE„	LET run, 1 „ENDIF„'Load all the image files.„LoadAllImages„„WAITUNTIL run=0 „CLOSEWINDOW w„'Clear all the image files.„DeleteAllImages„END „„SUB main „SELECT @CLASS „	CASE @IDMENUINIT„		CHECKMENUITEM w, skillmenu, TRUE„	CASE @IDCHAR„		LET mykey, @CODE„		'z, 1 is play„		IF (mykey = 122) | (mykey = 49)„			IF inreload = FALSE„				DoPlay„			ENDIF„		ENDIF„		'x, 2 is discard„		IF (mykey = 120) | (mykey = 50)„			IF inreload = FALSE„				DoDiscard„			ENDIF„		ENDIF„ 	CASE @IDLBUTTONDN„		'See if the mouse hit the button„		LET bclick, CheckButton(@MOUSEX, @MOUSEY)„		'Animate the button„		IF bclick > -1„			IF inreload = FALSE„				DrawButtonDn tbutton[bclick]„			ENDIF„		ENDIF„ 	 CASE @IDLBUTTONUP„		'See if the mouse hit the button„		LET bclick, CheckButton(@MOUSEX, @MOUSEY)„		'Animate the button„		IF bclick > -1„			IF inreload = FALSE„				DrawButtonUp tbutton[bclick]„				'Handle button clicks here.„				SELECT bclick„					'Play„					CASE 0„						DoPlay„					'Discard„					CASE 1„						DoDiscard„				ENDSELECT„			ENDIF„		ENDIF„     CASE @IDCLOSEWINDOW „		run = 0„	 CASE @IDPAINT„		DrawWindow„	CASE @IDTIMER„		'show the remaining time„		IF @CODE = 1„			IF currclock > 0 „				LET currclock, currclock -1„				ShowTime„			ELSE„				IF debug = FALSE„					LET ingame, FALSE„				ENDIF„				STOPTIMER w, 1„				PLAYWAVE ppath + "ding.wav", @SNDASYNC„			ENDIF„		ENDIF„		'The computer is playing.„		IF @CODE = 2„			PrePlay„		ENDIF„	 CASE @IDMENUPICK„		SELECT @MENUNUM„			CASE 1„				'New„				LET replay, FALSE„				Startup„			CASE 2„				'Preplay„				LET replay, FALSE„				StartPrePlay„			CASE 3„				'Replay„				IF firstgame = FALSE„					MESSAGEBOX w, "You must play at least one game first.","One Minute Solitaire"„				ELSE„					LET replay, TRUE„					StartUp„				ENDIF„			CASE 4„				'Quit„				run = 0„			CASE 5„				'Beginner„				LET skillsecond, 2„				CHECKMENUITEM w, skillmenu, FALSE„				LET skillmenu, 5„				CHECKMENUITEM w, skillmenu, TRUE„			CASE 6„				'Normal„				LET skillsecond, 1„				CHECKMENUITEM w, skillmenu, FALSE„				LET skillmenu, 6„				CHECKMENUITEM w, skillmenu, TRUE„			CASE 7„				'Master„				LET skillsecond, 0„				CHECKMENUITEM w, skillmenu, FALSE„				LET skillmenu, 7„				CHECKMENUITEM w, skillmenu, TRUE„		ENDSELECT„ENDSELECT „RETURN „„'The card drawing routine.„SUB DrawWindow„	DEF i:INT„„	'Draw the graphic images.„	SHOWIMAGE w, omb, IMGBITMAP, 0, 0, 640, 200„	SHOWIMAGE w, cmb, IMGBITMAP, 10, 105, 64, 64„	'Draw the place holders.„	DrawSymbol w, PLACEHOLDER, CX, CY„	DrawSymbol w, PLACEHOLDER, CX + CARDWIDTH + 100, CY„	IF instart = FALSE„		'Draw the play cards.„		FOR i = 0 TO deckptr„		DealCard w, deck[i], CX, CY„		NEXT i„		'Draw the pile.„		FOR i = 0 TO pileptr„			DealCard w, pile[i], CX + CARDWIDTH + 100, CY„		NEXT i„	ENDIF„	'Draw the custom buttons„	DrawButtons„	'Show the timer.„	ShowTime„RETURN„„SUB StartUp„	LET instart,TRUE„	STOPTIMER w, 1„	RECT w, 0, 0, WINWIDTH, WINHEIGHT, backcolor, backcolor„	DrawWindow„	LET ingame, TRUE„	'Reset the timer.„	currclock = 60„	ShowTime„	'Shuffle the deck.„	Shuffle„	'Start the timer„	STARTTIMER w, 1000, 1 „	LET instart,FALSE„RETURN„„SUB ShowTime„	DEF x,y:INT„	DEF tens:INT„	DEF ones:INT„	„	'Set the display location.„	LET x,26„	LET y,138„	'Get the tens position.„	LET tens, INT(currclock / 10)„	'Display the first digit„	SHOWIMAGE w, digits[tens], IMGBITMAP, x, y, 16, 16„	'Get the ones position.„	LET ones, currclock - (INT(currclock / 10) * 10)„	'Display the second digit.„	SHOWIMAGE w, digits[ones], IMGBITMAP, x+16, y, 16, 16„RETURN„„SUB LoadAllImages„	DEF i:INT„	„	'Load the background image.„	LET omb, LOADIMAGE(ppath + "omsol.bmp", IMGBITMAP)„	'Load the clock image.„	LET cmb, LOADIMAGE(ppath + "clock.bmp", IMGBITMAP)„	'Load the digit files.„	FOR i = 0 TO 9„		LET digits[i], LOADIMAGE(ppath + LTRIM$(STR$(i)) + ".bmp", IMGBITMAP)„	NEXT i„RETURN„„SUB DeleteAllImages„	DEF i:INT„	„	'Delete all the images.„	DELETEIMAGE omb, IMGBITMAP„	DELETEIMAGE cmb, IMGBITMAP„	FOR i = 0 TO 9„		DELETEIMAGE digits[i], IMGBITMAP„	NEXT i„„RETURN„„SUB Shuffle„	DEF i,j:INT„	DEF k:INT„	DEF temp:INT„	DEF msg:STRING„	„	LET inreload, TRUE	„	'Play the shuffle sound.„	PLAYWAVE ppath + "shuffle.wav", @SNDASYNC„	'Reset the deck.„	SetDefaultValues„	'Is this a replay?„	IF replay = TRUE„		FOR i = 0 to 51„			LET deck[i], savedeck[i]„			LET pile[i], 0„			LET discard[i], 0„		NEXT i„	ELSE„		'Set the deck load flag.„		LET firstgame, TRUE„		'Load all the cards„		FOR i = 0 TO 51„			LET deck[i],i + 1„			LET pile[i],0„			LET discard[i], 0„		NEXT i	„		FOR j = 1 to 10„			'Shuffle the cards.	„			FOR i = 0 TO 51„				'Get a random slot.„				LET k, RND(52) - 1„				'Get the value for the slot.„				LET temp, deck[k]„				'Swap the values with the current slot.„				LET deck[k], deck[i]„				LET deck[i], temp„			NEXT i„		NEXT j„		'Save the deck.„		FOR i = 0 to 51„			'Save the deck.„			LET savedeck[i], deck[i]„		NEXT i„	ENDIF„	'Set all the cards to face up and deal out„	FOR i = 0 TO 51„		SetCardStatus deck[i], FACEUP„		DealCard w, deck[i], CX, CY„	NEXT i„	'Set the card pointers„	LET deckptr,51„	LET discardptr,0„	LET pileptr,0„	'Draw over the first play card„	FOR i = CX TO CX + CARDWIDTH + 100 STEP 2„		ReturnDrag w, deck[deckptr], i, CY„	NEXT i„	'Sync up card„	ReturnDrag w, deck[deckptr], CX + CARDWIDTH + 100, CY„	'Move the top card to the play pile.„	LET pile[pileptr],deck[51]„	'Set the card pointers„	LET deck[deckptr], 0„	LET deckptr, 50„	LET playedtotal, 1„	ShowCardTotal„	'For debugging„	IF debug = TRUE„		MOVE w, 0, 0„		PRINT w, "Shuffle: deck:" + STR$(deckptr) + " pile:" + STR$(pileptr) + " discard:" + STR$(discardptr) + "  "„	ENDIF„	LET inreload, FALSE„RETURN„„SUB DrawButtons„	DEF btop:INT„	DEF bleft:INT„	DEF bheight:INT„	DEF bwidth:INT„	DEF i:INT„	„	'Build the deal button„	LET tbutton[0].top, CY„	LET tbutton[0].left, CX + (CARDWIDTH * 2) + 150„	LET tbutton[0].height, 25„	LET tbutton[0].width, 70„	LET tbutton[0].caption, "    Play "„	'Draw the button in the up position„	DrawButtonUp tbutton[0]„„	'Build the discard button„	LET tbutton[1].top, CY + tbutton[0].height + 10„	LET tbutton[1].left, tbutton[0].left „	LET tbutton[1].height, 25„	LET tbutton[1].width, 70„	LET tbutton[1].caption, "  Discard "„	'Draw the button in the up position„	DrawButtonUp tbutton[1]„	„RETURN„„SUB DrawButtonUp(tbtn:btn)„	'Draw the button„	RECT w, tbtn.left, tbtn.top, tbtn.width, tbtn.height, btnshadow, btnface„	RECT w, tbtn.left, tbtn.top, tbtn.width - 1, 1, btnhighlight, btnhighlight„	RECT w, tbtn.left, tbtn.top, 1, tbtn.height - 1, btnhighlight, btnhighlight„	FRONTPEN w, btntext„	BACKPEN w, btnface„	MOVE w, tbtn.left + 1, tbtn.top + 1„	PRINT w, tbtn.caption„RETURN„„SUB DrawButtonDn(tbtn:btn)„	'Draw the button„	RECT w, tbtn.left, tbtn.top, tbtn.width, tbtn.height, btnhighlight, btnface„	RECT w, tbtn.left, tbtn.top, tbtn.width - 1, 1, btnshadow, btnhighlight„	RECT w, tbtn.left, tbtn.top, 1, tbtn.height - 1, btnshadow, btnhighlight„	FRONTPEN w, btntext„	BACKPEN w, btnface„	MOVE w, tbtn.left + 2, tbtn.top + 2„	PRINT w, tbtn.caption„RETURN„„SUB CheckButton(x:INT, y:INT)„	DEF i:INT„	DEF ret:INT„„	'Set the default.„	ret = -1„	'See if the mouse click was on the button.„	FOR i = 0 TO BTN_NUM - 1„		IF (x >= tbutton[i].left) & (x <= tbutton[i].left + tbutton[i].width)„			IF (y >= tbutton[i].top) & (y <= tbutton[i].top + tbutton[i].height)„				ret = i„				GOTO GetOut„			ENDIF„		ENDIF„	NEXT i„GetOut:„RETURN ret„„SUB PlayCard„	DEF pilesuit:INT„	DEF playsuit:INT„	DEF pilevalue:INT„	DEF playvalue:INT„	DEF i:INT„	„	LET inreload, TRUE	„	'Get the suit of the facing cards„	LET pilesuit,GetCardSuit(pile[pileptr])„	LET playsuit,GetCardSuit(deck[deckptr])„	'Get the values„	LET pilevalue,GetCardValue(pile[pileptr])„	LET playvalue,GetCardValue(deck[deckptr])„	'If the cards are the same suit or value play it.„	IF (pilesuit = playsuit) | (pilevalue = playvalue)„		'Remove the card from the deck stack„		RemoveCard w, deck[deckptr]„		'Add it to the play stack.„		DealCard w, deck[deckptr], CX + CARDWIDTH + 100, CY„		LET pileptr, pileptr + 1„		LET pile[pileptr], deck[deckptr]„		LET deck[deckptr], 0„		LET deckptr, deckptr - 1„		'Adjust the card total„		LET playedtotal, playedtotal + 1„		LET preplaycount, 0„		ShowCardTotal„		'Add a second to the time.„		LET currclock, currclock + skillsecond„		IF currclock > 60„			LET currclock, 60„		ENDIF„		ShowTime„	ELSE„		'Play the beep.„		PLAYWAVE ppath + "error.wav", @SNDASYNC„	ENDIF„	'For debugging„	IF debug = TRUE„		MOVE w, 0, 0„		PRINT w, "Play: deck:" + STR$(deckptr) + " pile:" + STR$(pileptr) + " discard:" + STR$(discardptr) + "  "„		MOVE w, 0, 20„		PRINT w, "PileSuit:" + STR$(pilesuit) + " PileValue:" + STR$(pilevalue) + " PlaySuit:" + STR$(playsuit) + " PlayValue:" + STR$(playvalue) + "   "„	ENDIF„	'Check to see if we need to reload deck„	IF (deckptr < 0) & (pileptr < 51)„		ReloadDeck„	ENDIF„	LET inreload, FALSE„RETURN„„SUB MoveToDiscard„	LET inreload, TRUE„	LET discard[discardptr], deck[deckptr]„	RemoveCard w, deck[deckptr]„	LET deck[deckptr], 0„	LET deckptr, deckptr - 1„	LET discardptr, discardptr + 1„	'For debugging„	IF debug = TRUE„		MOVE w, 0, 0„		PRINT w, "Discard: deck:" + STR$(deckptr) + " pile:" + STR$(pileptr) + " discard:" + STR$(discardptr) + "  "„	ENDIF„	IF (deckptr < 0) „		ReloadDeck„	ENDIF„	LET inreload, FALSE„RETURN„„SUB ReloadDeck„	DEF j:INT„	„	'Set up the flags.„	LET inreload, TRUE„	LET preplaycount, preplaycount + 1„	LET j, 0„	FOR i = discardptr - 1 TO 0 STEP -1„		LET deck[j], discard[i]„		DealCard w, deck[j], CX, CY„		LET discard[i], 0„		LET j, j+1„	NEXT i„	LET deckptr, discardptr - 1„	LET discardptr, 0„	'For debugging„	IF debug = TRUE„		MOVE w, 0, 0„		PRINT w, "Reload: deck:" + STR$(deckptr) + " pile:" + STR$(pileptr) + " discard:" + STR$(discardptr) + "  "„	ENDIF„	LET inreload, FALSE„RETURN„„SUB ShowWin„	DEF x,y:INT„	DEF i:INT„	DEF msg:STRING„	„	'The win message„	LET msg," Wow! You won the game! "„	FOR i = 1 TO 113„		LET x, RND(WINWIDTH)„		LET Y, RND(WINHEIGHT)„		DrawCard w, i, x, y„	NEXT i„	FOR i = 1 TO 113„		LET x, RND(WINWIDTH)„		LET Y, RND(WINHEIGHT)„		DrawCard w, i, x, y„	NEXT i„	'Set the pen colors.„	FRONTPEN w, RGB(255, 255, 255)„	BACKPEN w, backcolor„	'Print the message„	RECT w, 250, 30, 210, 30, RGB(255,255,0), backcolor„	MOVE w, 258, 35„	PRINT w, msg„RETURN„„SUB ShowCardTotal„	DEF cardsleft:INT„	„	'Calc the number of cards not played.„	LET cardsleft, 52 - playedtotal„	'Set the pen colors.„	FRONTPEN w, RGB(255, 255, 255)„	BACKPEN w, backcolor„	'Print the cards left to play„	MOVE w, CX, CY + CARDHEIGHT + 10„	PRINT w, "Remaining:" + STR$(cardsleft) + "    "„	'Print the already played„	MOVE w, CX + CARDWIDTH + 100, CY + CARDHEIGHT + 10„	PRINT w, "Played:" + STR$(playedtotal) + "    "„RETURN„„SUB DoPlay„	IF ingame„		PlayCard„		'Check for a win.„		IF pileptr >= 51„			LET ingame, FALSE„			STOPTIMER w, 1„			PLAYWAVE ppath + "tada.wav", @SNDASYNC„			ShowWin„		ENDIF„	ENDIF„RETURN„„SUB DoDiscard„	IF ingame„		MoveToDiscard„	ENDIF„RETURN„„SUB StartPrePlay„	'Set up the flags.„	LET preplaycount, 0„	LET inreload, TRUE„	StartUp„	STARTTIMER w, 500, 2„RETURN„„SUB PrePlay„	DEF pilesuit:INT„	DEF playsuit:INT„	DEF pilevalue:INT„	DEF playvalue:INT„„	LET inreload, TRUE„	'Get the suit of the facing cards„	LET pilesuit,GetCardSuit(pile[pileptr])„	LET playsuit,GetCardSuit(deck[deckptr])„	'Get the values„	LET pilevalue,GetCardValue(pile[pileptr])„	LET playvalue,GetCardValue(deck[deckptr])„	'If the cards are the same suit or value play it.„	IF (pilesuit = playsuit) | (pilevalue = playvalue)„		DoPlay„	ELSE„		DoDiscard„	ENDIF„	'Have we gone through two complete discard reloads without playing?„	IF preplaycount > 2 „		PLAYWAVE ppath + "ding.wav", @SNDASYNC„		ingame = FALSE„	ENDIF„	'Is the game over?„	IF ingame = FALSE„		STOPTIMER w, 1„		STOPTIMER w, 2„		MOVE w, CX, CY + CARDHEIGHT + 30„		PRINT w, "Game Over.         "„	ENDIF„	LET inreload, FALSE„RETURN„Richard D. Clark               Yabalon - Acy-Deucy Card Game  rickclark58@yhoo.com           10-18-03 (  :  )       IBASIC                 548  12858    yablon.iba  '    Copyright (C) 2003  Richard D. Clark„'	 rickclark58@yahoo.com„„'    This program is free software; you can redistribute it and/or modify„'    it under the terms of the GNU General Public License as published by„'    the Free Software Foundation; either version 2 of the License, or„'    (at your option) any later version.„„'    This program is distributed in the hope that it will be useful,„'    but WITHOUT ANY WARRANTY; without even the implied warranty of„'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the„'    GNU General Public License for more details.„„'    You should have received a copy of the GNU General Public License„'    along with this program; if not, write to the Free Software„'    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA„„' Required in Form Load to use dll„DECLARE "qcard32.dll",InitializeDeck(hwnd:INT),INT„' Reset all card values to defaults„DECLARE "qcard32.dll",SetDefaultValues()„' Set the currently used card back design for cards 105 to 109„DECLARE "qcard32.dll",SetCurrentBack(nIndex:INT)„DECLARE "qcard32.dll",SetCardStatus(nCard:INT, bValue:INT)„' Card drawing "qcard32.dll",s„DECLARE "qcard32.dll",DrawSymbol(hwnd:INT, nValue:INT, x:INT, y:INT)„DECLARE "qcard32.dll",DealCard(hwnd:INT, nCard:INT, x:INT, y:INT)„DECLARE "qcard32.dll",DrawCard(hwnd:INT, nCard:INT, x:INT, y:INT)„' Get card information "qcard32.dll",s„DECLARE "qcard32.dll",GetCardValue(nCard:INT),INT„DECLARE "qcard32.dll",ReturnDrag(hwnd:INT, nCard:INT, nOldX:INT, nOldY:INT)„„'Yablon subs„DECLARE "kernel32",Sleep(dwMilliseconds:INT)„DECLARE Shuffle()„DECLARE DrawWindow()„DECLARE DealCardToLocation (card:INT, x:INT, y:INT)„DECLARE Startup()„DECLARE PrintMoney()„DECLARE PrintStatus()„DECLARE PrintBet()„DECLARE DoBet()„DECLARE CalcSpread(c1:INT, c2:INT)„DECLARE DoRaise()„DECLARE DoTie()„DECLARE DoPair()„DECLARE ChangeCardBack(x:INT, y:INT)„„'Useful consts„Const FACEDOWN = 0„Const FACEUP = 1„Const CARDWIDTH = 71„Const CARDHEIGHT = 96„Const OFFSET = 16„CONST TRUE = 1„CONST FALSE = 0„CONST IBBITMAP = 0„CONST PLACEX=1„CONST PLACEHOLDER = 3„CONST GBET = 0„CONST GRAISE = 1„„DEF run:INT„DEF w:WINDOW „DEF ret:INT„DEF ihback:INT„DEF ihpay:INT„DEF appath:STRING„DEF backcolor, ycolor, wcolor:INT„DEF deck[52]:INT„DEF deckptr:INT„DEF p1x,p2x,p3x,py,px,bx,by:INT„DEF mx, my, money:INT„DEF mbet, mraise:INT„DEF turn:INT„DEF ix, iy:INT„DEF statusmsg:STRING„DEF card1, card2, spread:INT„DEF cv1, cv2:INT„DEF ingame:INT„DEF inshuffle:INT„DEF cardback:INT„„'The card back.„cardback = 1„'Dark green.„backcolor = RGB(0, 99, 0)„'Yellow„ycolor = RGB(255, 255, 0)„'White„wcolor = RGB(255, 255, 255)„'Get the application path.„appath = GETSTARTPATH„IF RIGHT$(appath,1)<>"\"„	appath = appath + "\"„ENDIF„'The play area„p1x = CARDWIDTH + 20„p2x = CARDWIDTH + CARDWIDTH + 40„p3x = CARDWIDTH + CARDWIDTH + CARDWIDTH + 60„'The draw area.„py = 110:px = 10„'The money print location.„mx = 10:my = py + CARDHEIGHT + 20„'The status statusmsgages.„ix = 10:iy = my + 30„'Load the bitmaps„ihback = LOADIMAGE(appath + "yab1.bmp", IBBITMAP)„ihpay = LOADIMAGE(appath + "yab2.bmp", IBBITMAP)„„WINDOW w,0,0,640,380,@SIZE|@MINBOX|@NOAUTODRAW|@SIZE,0,"Yablon",main „MENU w,"T,&Game,0,0","I,&New,0,1","I,-,0,0","I,&Quit,0,2"„CENTERWINDOW w„CONTROL w,"E,,19,my + 80,70,20,0x50800000,1"„'SETCONTROLCOLOR w, 1, ycolor, backcolor„CONTROL w,"B,Bet,95,my + 80,49,20,0x50008000,2"„SETCONTROLCOLOR w, 2, ycolor, backcolor„CONTROL w,"B,Raise,150,my + 80,49,20,0x50008000,3"„SETCONTROLCOLOR w, 3, ycolor, backcolor„CONTROL w,"B,Stay,205,my + 80,49,20,0x50008000,4"„SETCONTROLCOLOR w, 4, ycolor, backcolor„'Set the bet statusmsgage location.„bx = 275:by = my + 80„'Set the back color„SETWINDOWCOLOR w, backcolor„'Set the font for the window„SETFONT w, "Tahoma", 0, 0„'Set the back pen color.„BACKPEN w, backcolor„'Init the deck.„ret = InitializeDeck(w)„IF ret = FALSE„	'If we can't load the dll then exit.„	MESSAGEBOX w,"Cannot initialize Qcards32.dll.","Yablon"„	run = 0„ELSE„	Startup„	run = 1 „ENDIF„„run = 1 „WAITUNTIL run=0 „CLOSEWINDOW w„'Delete the images.„DELETEIMAGE ihback, IBBITMAP„DELETEIMAGE ihpay, IBBITMAP„END „„„SUB main „SELECT @CLASS„     CASE @IDCLOSEWINDOW „		run = 0„	 CASE @IDPAINT„		DrawWindow„	 CASE @IDLBUTTONUP„		ChangeCardBack @MOUSEX, @MOUSEY„	 CASE @IDCONTROL„		SELECT @CONTROLID„			CASE 4„				'Stay„				IF (turn = GRAISE) & (ingame = TRUE) & (inshuffle = FALSE)„					mraise = 0„					DoRaise„				ENDIF„			CASE 3„				'Raise„				mraise = VAL(GETCONTROLTEXT(w, 1))„				IF (turn = GRAISE) & (ingame = TRUE) & (inshuffle = FALSE)„					IF mraise = 0„						MESSAGEBOX w,"Raise must be greater than zero.","Yablon"„					ELSE„						IF mraise > (money - mbet)„							MESSAGEBOX w,"You don't have enough money to place this bet.","Yablon"„						ELSE„							DoRaise„						ENDIF„					ENDIF„				ENDIF„			CASE 2„				'Bet„				mbet = VAL(GETCONTROLTEXT(w, 1))„				IF (turn = GBET) & (ingame = TRUE) & (inshuffle = FALSE)„					IF mbet = 0„						MESSAGEBOX w,"Bet must be greater than zero.","Yablon"„					ELSE„						IF mbet > money„							MESSAGEBOX w,"You don't have enough money to place this bet.","Yablon"„						ELSE„							DoBet„						ENDIF„					ENDIF„				ENDIF„		ENDSELECT„	 CASE @IDMENUPICK„		SELECT @MENUNUM„			CASE 1„				'New„				Startup„				DrawWindow„			CASE 2„				'Quit„				run = 0„		ENDSELECT„ENDSELECT „RETURN„„SUB Shuffle„	DEF i,j:INT„	DEF k:INT„	DEF temp:INT„	DEF msg:STRING„	„	'Play the shuffle sound.„	PLAYWAVE appath + "shuffle.wav", @SNDASYNC„	'Reset the deck.„	SetDefaultValues„	'Set the shuffle flag.„	inshuffle = TRUE„	'Load all the cards„	FOR i = 0 TO 51„		deck[i] = i + 1„	NEXT i	„	FOR j = 1 to 10„		'Shuffle the cards.	„		FOR i = 0 TO 51„			'Get a random slot.„			k = RND(52) - 1„			'Get the value for the slot.„			temp = deck[k]„			'Swap the values with the current slot.„			deck[k] = deck[i]„			deck[i] = temp„		NEXT i„	NEXT j„	'Set the deck card pointer„	deckptr = 51„	FOR i = 0 TO 51„		'Deal the draw pile.„		SetCardStatus deck[i], FACEDOWN„		Dealcard w, deck[i], px, py„	NEXT i„	inshuffle = FALSE„RETURN„„SUB DrawWindow„	DEF i:INT„	„	'Paint the background image.„	SHOWIMAGE w, ihback, IBBITMAP, 0, 0, 400, 100„	'Paint the payoff image.„	SHOWIMAGE w, ihpay, IBBITMAP, 400, 0, 220, 300„	'Draw the card placeholders.„	'DrawSymbol w, PLACEX, px, py„	DrawSymbol w, PLACEHOLDER, p1x, py„	DrawSymbol w, PLACEHOLDER, p2x, py„	DrawSymbol w, PLACEHOLDER, p3x, py„	'Place the draw cards„	FOR i = 0 TO 51„		IF deck[i]<>0„			SetCardStatus deck[i], FACEDOWN„			DealCard w, deck[i], px, py„		ENDIF„	NEXT i„	'Draw the face up cards.„	IF card1<>0„		SetCardStatus card1, FACEUP„		DealCard w, card1, p1x, py„	ENDIF„	IF card2<>0„		SetCardStatus card2, FACEUP„		DealCard w, card2, p2x, py„	ENDIF„	'Print the statusmsgages.„	PrintMoney„	PrintStatus„	PrintBet„RETURN„„SUB DealCardToLocation (card:INT, x:INT, y:INT)„	DEF i:INT„„	'Play the deal sound.„	PLAYWAVE appath + "deal.wav", @SNDASYNC„	SetCardStatus card, FACEUP„	FOR i = px TO x STEP 2„		ReturnDrag w, card, i, y„	NEXT i„	ReturnDrag w, card, x, y„RETURN„„SUB Startup„	'Reset cards.„	SetDefaultValues„	'Shuffle the cards.„	Shuffle„	'Set the money amount.„	money = 1000„	'Start with the bet routine.„	turn = GBET„	'Set the first statusmsgage.„	statusmsg = "Place your bet for the deal.        "„	card1 = 0:card2 = 0„	mbet = 0:mraise = 0„	ingame = TRUE„RETURN„„SUB PrintMoney„	'Print the current money amount„	MOVE w, mx, my„	FRONTPEN w, ycolor„	PRINT w, "Your current cash amount is $" + LTRIM$(STR$(money)) + ".     "„RETURN„„SUB PrintStatus„	'Print the current status statusmsgage.„	MOVE w, ix, iy„	FRONTPEN w, wcolor„	IF ingame = TRUE„		PRINT w, statusmsg + "            "„	ELSE„		PRINT w, "Game over.                    "„	ENDIF„RETURN„„SUB PrintBet„	'Print the current status statusmsgage.„	MOVE w, bx, by„	FRONTPEN w, wcolor„	IF ingame = TRUE „		PRINT w, "Bet:" + STR$(mbet) + " Raise:" + STR$(mraise) + "           "„	ELSE„		PRINT w, "                                 "„	ENDIF„RETURN„„SUB DoBet„	'Toggle turn to raise.„	turn = GRAISE„	'Print the messages„	PrintBet„	'Deal the first two cards.„	card1 = deck[deckptr]„	'Move the card to the location„	DealCardToLocation card1, p1x, py„	'Clear this card from the deck.„	deck[deckptr] = 0„	'Move the deck pointer„	deckptr = deckptr -1„	'Get the second card„	card2 = deck[deckptr]„	DealCardToLocation card2, p2x, py„	deck[deckptr] = 0„	deckptr = deckptr -1„	'Get the spread.„	spread = CalcSpread(card1, card2)„	'Do we have consecutive cards.„	IF spread = 0„		DoTie„	ELSE„		'Do we have a pair.„		IF spread = -1„			DoPair„		ELSE„			statusmsg = "Raise or Stay. Spread is" + STR$(spread) + ".       "„		ENDIF„	ENDIF„	PrintStatus„RETURN„„SUB CalcSpread(c1:INT, c2:INT)„	DEF ret:INT„„	'Get the card values.„	cv1 = GetCardValue(c1)„	'If an ace bump to 14„	IF cv1 = 1„		cv1 = 14„	ENDIF„	cv2 = GetCardValue(c2)„	IF cv2 = 1„		cv2 = 14„	ENDIF„	'Calc the spread„	ret = ABS(cv1 - cv2) - 1„RETURN ret„„SUB DoRaise„	DEF card3:INT„	DEF temp:INT„	DEF winnings:INT„	DEF cv3:INT„„	PrintBet„	'Deal the third card.„	card3 = deck[deckptr]„	DealCardToLocation card3, p3x, py„	deck[deckptr] = 0„	deckptr = deckptr -1„	'Get the card value of the third card.„	cv3 = GetCardValue(card3)„'stop„	'If an ace, then the value is 14„	IF cv3 = 1„		cv3 = 14„	ENDIF„	'Arrange the cards in order of value.„	IF cv1 > cv2„		temp = cv1„		cv1 = cv2„		cv2 = temp„	ENDIF„	'Does the card fall in between the first two?„	IF (cv3 > cv1) & (cv3 < cv2)„		PLAYWAVE appath + "money.wav", @SNDASYNC„		'Player gets original bet amount.„		winnings = mbet„		'Calc the bonus amount.„		IF spread = 1„			winnings = winnings + (5 * mraise)„		ENDIF„		IF spread = 2„			winnings = winnings + (4 * mraise)„		ENDIF„		IF spread = 3„			winnings = winnings + (2 * mraise)„		ENDIF„		IF spread > 3„			winnings = winnings + mraise„		ENDIF„		'Update the all the vars.„		statusmsg = "You win $" + LTRIM$(STR$(winnings)) + ".             "„		PrintStatus„		'Pause for a second.„		Sleep 2000„		money = money + winnings„	ELSE„		'Player loses money.„		statusmsg = "You lose.                "„		PrintStatus„		Sleep 1000„		'Update the vars.„		money = money - (mraise + mbet)„		'Does the player have any money left?„		IF money <= 0„			ingame = FALSE„		ENDIF„	ENDIF„	'Check to see if we need to shuffle.„	IF deckptr < 3„		statusmsg = "Shuffling cards...         " „		PrintStatus„		Shuffle„	ENDIF„	'Reset the game vars.„	statusmsg = "Place your bet for the deal.          "„	turn = GBET„	mbet = 0:mraise = 0„	card1 = 0:card2 = 0„	DrawWindow„RETURN„„SUB DoTie„	statusmsg = "Tie. You get your bet back.       "„	PrintStatus„	Sleep 2000„	'Check to see if we need to shuffle.„	IF deckptr < 3„		statusmsg = "Shuffling cards...         " „		PrintStatus„		Shuffle„	ENDIF„	turn = GBET„	mbet = 0:mraise = 0„	card1 = 0:card2 = 0„	statusmsg = "Place your bet for the deal.          "„	DrawWindow„RETURN„„SUB DoPair„	DEF card3:INT„	DEF cv3:INT„	DEF winnings:INT„„	statusmsg = "Pair. Dealing third card.           "„	PrintStatus„	Sleep 1000„	'Deal the third card.„	card3 = deck[deckptr]„	DealCardToLocation card3, p3x, py„	deck[deckptr] = 0„	deckptr = deckptr -1„	'Get the card value of the third card.„	cv3 = GetCardValue(card3)„	'If an ace, then the value is 14„	IF cv3 = 1„		cv3 = 14„	ENDIF„	'If three of a kind, then pay out 11:1.„	IF cv3 = cv2„		PLAYWAVE appath + "clap.wav", @SNDASYNC„		'win big„		winnings = 11 * mbet„		'Add to the money pool„		money = money + winnings„		statusmsg = "Three of a kind. You win $" + LTRIM$(STR$(winnings)) + "."„		PrintStatus„		Sleep 2000„	ELSE„		statusmsg = "You lose.                             "„		PrintStatus„		Sleep 1000„		money = money - mbet„		'Does the player have any money left?„		IF money <= 0„			ingame = FALSE„		ENDIF„	ENDIF„	'Reset the vars.„	turn = GBET„	mbet = 0:mraise = 0„	card1 = 0:card2 = 0„	'Check to see if we need to shuffle.„	IF deckptr < 3„		statusmsg = "Shuffling cards...         " „		PrintStatus„		Shuffle„	ENDIF„	statusmsg = "Place your bet for the deal.                 "„	DrawWindow„RETURN„„SUB ChangeCardBack(x:INT, y:INT)„	„	'See if the mouse coordinates are in the draw pile.„	„	IF (x >= px) & (x <= px + CARDWIDTH)„		IF (y >= py) & (y <= py + CARDHEIGHT)„			cardback = cardback + 1„			IF cardback > 6„				cardback = 1„			ENDIF„			SetCurrentBack cardback„			DrawWindow„		ENDIF„	ENDIF„„RETURN„Michael Webster                Text Based Mine Sweeper        mfwebster@pdq.net              10-19-03 (  :  )       QB, PDS                1141 37208    MINES.BAS   ' MINES.BAS„'„' This is a QuickBASIC text-mode ripoff of the„' Windows Minesweeper game. I believe I coded this„' soon after the Windows Minesweeper game appeared,„' whenever that was. In case you're wondering why„' the program does not use color and checks for„' video mode 7, it was coded on a system with an„' MDA and a green phosphor display.„'„' Note that this game requires a mouse - it cannot„' be played with the keyboard alone.„„DECLARE SUB GetBackground ()„DECLARE SUB ShowHelp ()„DECLARE SUB PutBackground ()„DECLARE SUB MouseLocate (row%, col%)„DECLARE FUNCTION AllMarked% ()„DECLARE SUB Box (row1%, col1%, row2%, col2%, border%, fill%, title$)„DECLARE SUB ClearAround (row%, col%)„DECLARE SUB DrawBoard ()„DECLARE FUNCTION FieldClick% (fieldRow%, fieldCol%, mouseLeft%)„DECLARE SUB InitMineField ()„DECLARE FUNCTION InputBox$ (row%, col%, textLength%)„DECLARE SUB MainLoop ()„DECLARE SUB MouseDriver (m0%, m1%, m2%, m3%)„DECLARE SUB MouseHide ()„DECLARE FUNCTION MouseInit% ()„DECLARE SUB MousePoll (mouseRow%, mouseCol%, mouseLeft%, mouseRight%)„DECLARE SUB MouseShow ()„DECLARE FUNCTION NewButtonClick% ()„DECLARE FUNCTION OnFieldSquare% (mouseRow%, mouseCol%, fieldRow%, fieldCol%)„DECLARE SUB RecordBestTime ()„DECLARE FUNCTION ShiftFlags% ()„DECLARE SUB UpdateElapTime (resetFlag%)„DECLARE SUB UpdateCount ()„DECLARE FUNCTION VideoMode% ()„DECLARE SUB UncoverAll ()„DEFINT A-Z„„CONST FALSE = 0, true = NOT FALSE„„' Define data type and declare global variables for„' the InterruptX routine.„TYPE RegTypeX„    ax      AS INTEGER„    bx      AS INTEGER„    cx      AS INTEGER„    dx      AS INTEGER„    bp      AS INTEGER„    si      AS INTEGER„    di      AS INTEGER„    Flags   AS INTEGER„    ds      AS INTEGER„    es      AS INTEGER„END TYPE„DIM SHARED inRegs AS RegTypeX„DIM SHARED outRegs AS RegTypeX„DECLARE SUB InterruptX (intnum AS INTEGER, inRegs AS RegTypeX, outRegs AS RegTypeX)„„' Had to increase the stack size for expert mode.„CLEAR , , 8196„„' Declare and initialize a global string to store the„' background for the help screen.„DIM SHARED background$„background$ = SPACE$(4000)„„' Declare a global variables to store the initial„' number of mines and the number of unmarked mines.„DIM SHARED mineCount, unmarkedMines„„' Declare global variables to store the difficulty„' level and minefield size.„DIM SHARED expertMode, fieldCols„„' Check for expert option and set operating parameters.„IF INSTR(COMMAND$, "E") THEN„    expertMode = true„    fieldCols = 16„    mineCount = 20„    unmarkedMines = 20„ELSE„    fieldCols = 8„    mineCount = 10„    unmarkedMines = 10„END IF„„' Define a data type for storing the labels, tags, and screen coordinates„' of the minefield squares.  The tag element is used to indicate that the„' square has been processed.„TYPE MineFieldType„    label       AS STRING * 1„    tag         AS STRING * 1„    row         AS INTEGER„    col         AS INTEGER„END TYPE„„' Declare a 2 dimensional array of the above type.„' Make the array larger than the actual minefield„' so the initialization code can be cleaner and„' simpler.„DIM SHARED minefield(10, fieldCols + 2) AS MineFieldType„„' Declare a global variable to store the elapsed„' time and the state of the timer.„DIM SHARED elapsedTime, timerOn„„' Initialize the minefield array character elements.„InitMineField„„' Declare a global variable to store the and the„' error code from the most recent file operation.„DIM SHARED errorCode„„CLS„„' Attempt to initialize the mouse. If the„' initialization fails, then display an error„' message and quit.„IF MouseInit = 0 THEN„    LOCATE 10, 25„    PRINT "MINE requires a mouse.";„    END„END IF„„' Draw the game board.„DrawBoard„„' Switch the mouse cursor on.„MouseShow„„' Start the main loop.„MainLoop„„MouseHide„CLS„END„„ErrorHandler:„„    ' Handles any error that results from„    ' the attempt to open MINE.INI.„    errorCode = ERR„    RESUME NEXT„„FUNCTION AllMarked„„    ' Returns true if all the mines are marked.„„    FOR row = 1 TO 8„        FOR col = 1 TO fieldCols„            IF minefield(row, col).label = "*" AND minefield(row, col).tag <> "X" THEN EXIT FUNCTION„        NEXT„    NEXT„    AllMarked = true„„END FUNCTION„„SUB Box (row1, col1, row2, col2, border, fill, title$) STATIC„   „    ' Displays a text mode window with a single or„    ' double line border, an optional fill, and an„    ' auto-centered title.„„    IF border = 1 THEN„        upperLeft = 218„        upperRight = 191„        lowerLeft = 192„        lowerRight = 217„        horz = 196„        vert = 179„    ELSE„        upperLeft = 201„        upperRight = 187„        lowerLeft = 200„        lowerRight = 188„        horz = 205„        vert = 186„    END IF„„    DIM row$(1 TO 25)„„    IF title$ <> "" THEN„        leftLength = (col2 - col1 - LEN(title$) - 3) \ 2„        rightLength = (col2 - col1 - LEN(title$) - leftLength - 3)„        row$(row1) = CHR$(upperLeft) + STRING$(leftLength, horz) + " " + title$ + " " + STRING$(rightLength, horz) + CHR$(upperRight)„    ELSE„        row$(row1) = CHR$(upperLeft) + STRING$(col2 - col1 - 1, horz) + CHR$(upperRight)„    END IF„„    IF fill THEN„        FOR row = row1 + 1 TO row2 - 1„            row$(row) = CHR$(vert) + SPACE$(col2 - col1 - 1) + CHR$(vert)„        NEXT„    END IF„„    row$(row2) = CHR$(lowerLeft) + STRING$(col2 - col1 - 1, horz) + CHR$(lowerRight)„„    LOCATE row1, col1, 0„    IF fill THEN„        FOR row = row1 TO row2„            LOCATE row, col1„            PRINT row$(row);„        NEXT„    ELSE„        PRINT row$(row1);„        FOR row = row1 + 1 TO row2 - 1„            LOCATE row, col1„            PRINT CHR$(vert);„            LOCATE row, col2„            PRINT CHR$(vert);„        NEXT„        LOCATE row2, col1„        PRINT row$(row2);„    END IF„„END SUB„„SUB ClearAround (row, col)„„    ' Displays the label for all minefield squares„    ' adjacent to the square at <row, col>. If the„    ' corresponding label for any adjacent square„    ' is a "0", then this procedure clears around„    ' that square by performing a recursive call.„    ' The tag element is used to ensure that each„    ' square is processed only once.  Otherwise,„    ' the resulting unlimited recursion would„    ' quickly consume the stack.„„    FOR r = row - 1 TO row + 1„        FOR c = col - 1 TO col + 1„            IF r > 0 AND r <= 8 AND c > 0 AND c <= fieldCols THEN„                IF minefield(r, c).tag = CHR$(0) THEN„                    LOCATE minefield(r, c).row, minefield(r, c).col + 1„                    MouseHide„                    PRINT minefield(r, c).label„                    MouseShow„                    minefield(r, c).tag = minefield(r, c).label„                    IF minefield(r, c).label = "0" THEN ClearAround r, c„                END IF„            END IF„        NEXT„    NEXT„„END SUB„„SUB DrawBoard„   „    ' Draws the game board, initializes the mine„    ' count and timer boxes, and loads the minefield„    ' square screen coordinates.„„    IF expertMode THEN„        Box 2, 6, 23, 74, 2, FALSE, "Mines"„        Box 3, 10, 5, 18, 1, FALSE, ""„        UpdateCount„        Box 3, 36, 5, 44, 1, FALSE, ""„        LOCATE 4, 39„        PRINT "New"„        Box 3, 62, 5, 70, 1, FALSE, ""„        LOCATE 6, 8„        PRINT "⁄ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒø";„        LOCATE 7, 8„        PRINT "≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥";„        FOR row = 8 TO 20 STEP 2„            LOCATE row, 8„            PRINT "√ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ¥";„            LOCATE row + 1, 8„            PRINT "≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥";„        NEXT„        LOCATE 22, 8„        PRINT "¿ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒŸ";„    ELSE„        Box 2, 22, 23, 58, 2, FALSE, "Mines"„        Box 3, 24, 5, 32, 1, FALSE, ""„        UpdateCount„        Box 3, 36, 5, 44, 1, FALSE, ""„        LOCATE 4, 39„        PRINT "New"„        Box 3, 48, 5, 56, 1, FALSE, ""„        LOCATE 6, 24„        PRINT "⁄ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒø";„        LOCATE 7, 24„        PRINT "≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥";„        FOR row = 8 TO 20 STEP 2„            LOCATE row, 24„            PRINT "√ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ¥";„            LOCATE row + 1, 24„            PRINT "≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥";„        NEXT„        LOCATE 22, 24„        PRINT "¿ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒŸ";„    END IF„„    timerOn = true„    UpdateElapTime true„    timerOn = FALSE„„    FOR row = 1 TO 8„        FOR col = 1 TO fieldCols„            minefield(row, col).row = 7 + (row - 1) * 2„            IF fieldCols = 8 THEN„                minefield(row, col).col = 25 + (col - 1) * 4„            ELSE„                minefield(row, col).col = 9 + (col - 1) * 4„            END IF„        NEXT„    NEXT„„END SUB„„FUNCTION FieldClick (fieldRow, fieldCol, mouseLeft)„„    ' Monitors and controls the minefield squares.„    ' If the left or right mouse button is down and„    ' the mouse cursor is on a minefield square, then„    ' the mouse cursor is positioned at the center of„    ' the square and the square is highlighted. If„    ' the mouse cursor is moved off the minefield„    ' square, or the mouse button is released, then„    ' the highlighted square is un-highlighted.„    ' Returns true if the mouse button is released„    ' with the mouse cursor on a minefield square.„    ' Note that this procedure does not return while„    ' a minefield square is highlighted. The arguments„    ' are used to return the minefield grid coordinates„    ' and the identity of the mouse button.„„    DO„        MousePoll mouseRow, mouseCol, mouseLeft, mouseRight„        IF NOT mouseLeft AND NOT mouseRight AND NOT highlight THEN EXIT FUNCTION„        IF highlight THEN„            IF mouseLeft OR mouseRight THEN„                IF OnFieldSquare(mouseRow, mouseCol, fieldRow, fieldCol) THEN„                    IF fieldRow <> highlightRow OR fieldCol <> highlightCol THEN„                        LOCATE minefield(highlightRow, highlightCol).row, minefield(highlightRow, highlightCol).col„                        MouseHide„                        PRINT " "; minefield(highlightRow, highlightCol).tag; " ";„                        MouseShow„                        LOCATE minefield(fieldRow, fieldCol).row, minefield(fieldRow, fieldCol).col„                        MouseHide„                        PRINT " "; minefield(fieldRow, fieldCol).tag; " ";„                        MouseShow„                    END IF„                ELSE„                    LOCATE minefield(highlightRow, highlightCol).row, minefield(highlightRow, highlightCol).col„                    MouseHide„                    PRINT " "; minefield(highlightRow, highlightCol).tag; " ";„                    MouseShow„                    highlight = FALSE„                    EXIT FUNCTION„                END IF„            ELSE„                LOCATE minefield(highlightRow, highlightCol).row, minefield(highlightRow, highlightCol).col„                MouseHide„                PRINT " "; minefield(highlightRow, highlightCol).tag; " ";„                MouseShow„                FieldClick = true„                mouseLeft = prevMouseLeft„                EXIT FUNCTION„            END IF„        ELSE„            IF OnFieldSquare(mouseRow, mouseCol, fieldRow, fieldCol) THEN„                prevMouseLeft = mouseLeft„                COLOR 0, 7„                LOCATE minefield(fieldRow, fieldCol).row, minefield(fieldRow, fieldCol).col„                MouseHide„                PRINT " "; minefield(fieldRow, fieldCol).tag; " ";„                MouseShow„                COLOR 7, 0„                highlight = true„                highlightRow = fieldRow„                highlightCol = fieldCol„            ELSE„                EXIT FUNCTION„            END IF„        END IF„    LOOP„„END FUNCTION„„SUB GetBackground„„    ' Crude (and slow) procedure to copy the screen„    ' contents to a global buffer. SCREEN 0 (80 X 25„    ' text) and display page 0 are assumed.„„    IF VideoMode = 7 THEN„        DEF SEG = &HB000„    ELSE„        DEF SEG = &HB800„    END IF„„    FOR i = 0 TO 3999„        MID$(background$, i + 1, 1) = CHR$(PEEK(i))„    NEXT„„    DEF SEG„„END SUB„„SUB InitMineField„„    ' Initializes the mineField array label elements.„    ' The array is larger than the actual field so„    ' the code in this procedure can be cleaner and„    ' simpler. Places mines in mineCount ramdomly„    ' selected elements and the number of adjacent„    ' mines in the elements without mines.„„    RANDOMIZE TIMER„    FOR mine = 1 TO mineCount„        DO„            row = INT(RND * 8) + 1„            col = INT(RND * fieldCols) + 1„        LOOP UNTIL minefield(row, col).label <> "*"„        minefield(row, col).label = "*"„    NEXT„„    FOR row = 1 TO 8„        FOR col = 1 TO fieldCols„            IF minefield(row, col).label <> "*" THEN„                count = 0„                FOR r = row - 1 TO row + 1„                    FOR c = col - 1 TO col + 1„                        IF minefield(r, c).label = "*" THEN count = count + 1„                    NEXT„                NEXT„                minefield(row, col).label = RIGHT$(STR$(count), 1)„            END IF„        NEXT„    NEXT„„END SUB„„FUNCTION InputBox$ (row, col, textLength)„„    ' Reads and returns a single line of text from„    ' the keyboard. The input area is surrounded by„    ' a single line box. The coordinates <row> and„    ' <col> are for the upper left hand corner of„    ' the box. The box is 3 characters tall and„    ' (<textLength> + 4) characters wide. The maximum„    ' input line length is 32K (no check). If the„    ' input line length exceeds the maximum visible„    ' length (<textLength>), then the text will scroll„    ' horizontally. The editing features are similar„    ' to the INPUT statement. Returns the current text„    ' when the user presses Enter. Returns a null„    ' string when the user presses Escape. If the„    ' video mode is 7 then then a monochrome display„    ' is assumed. If the video mode is not 7 then CGA„    ' cursor emulation is assumed.„„    IF VideoMode = 7 THEN„        insertStart = 12„        insertStop = 13„        typeOverStart = 0„        typeOverStop = 13„    ELSE„        insertStart = 7„        insertStop = 8„        typeOverStart = 0„        typeOverStop = 7„    END IF„„    Box row, col, row + 2, col + textLength + 3, 1, true, ""„„    firstChar = 1„    firstCol = col + 2„    lastCol = col + textLength + 2„    currentCol = firstCol„    tabStops = 8„    insertState = -1„„    DO„„        LOCATE row + 1, firstCol„„        ' Print temporary string„        PRINT MID$(temp$, firstChar, textLength);„„        ' Fill to end of box to overwrite any unused„        cursorCol = POS(0)„        IF cursorCol < lastCol THEN PRINT SPACE$(lastCol - cursorCol);„„        ' Locate cursor, make visible, and set size„        IF insertState THEN„            LOCATE , currentCol, 1, insertStart, insertStop„        ELSE„            LOCATE , currentCol, 1, typeOverStart, typeOverStop„        END IF„„        ' Wait for the user to press a key„        DO„            key$ = INKEY$„        LOOP UNTIL key$ <> ""„„        ' Process the key„        SELECT CASE key$„            CASE CHR$(8)                    ' Backspace„                IF currentCol > firstCol OR firstChar > 1 THEN„                    leftPart$ = LEFT$(temp$, firstChar + currentCol - firstCol - 2)„                    rightPart$ = MID$(temp$, firstChar + currentCol - firstCol)„                    IF currentCol > firstCol THEN„                        currentCol = currentCol - 1„                    ELSEIF firstChar > 1 THEN„                        firstChar = firstChar - 1„                    END IF„                ELSE„                    leftPart$ = LEFT$(temp$, firstChar + currentCol - firstCol - 1)„                    rightPart$ = MID$(temp$, firstChar + currentCol - firstCol + 1)„                END IF„                temp$ = leftPart$ + rightPart$„            CASE CHR$(13)                   ' Enter„                EXIT DO„            CASE CHR$(27)                   ' Escape„                temp$ = ""„                EXIT DO„            CASE CHR$(0) + CHR$(71)         ' Home„                firstChar = 1„                currentCol = firstCol„            CASE CHR$(0) + CHR$(75)         ' Left„                IF currentCol > firstCol THEN„                    currentCol = currentCol - 1„                ELSEIF currentCol = firstCol AND firstChar > 1 THEN„                    firstChar = firstChar - 1„                END IF„            CASE CHR$(0) + CHR$(77)         ' Right„                IF currentCol < lastCol THEN„                    currentCol = currentCol + 1„                ELSEIF currentCol = lastCol THEN„                    firstChar = firstChar + 1„                END IF„„            CASE CHR$(0) + CHR$(79)         ' End„                tempLength = LEN(temp$)„                IF tempLength > textLength THEN„                    firstChar = tempLength - textLength + 1„                ELSE„                    firstChar = 1„                END IF„                currentCol = firstCol + tempLength„                IF currentCol > lastCol THEN currentCol = lastCol„„            CASE CHR$(0) + CHR$(82)         ' Ins„                ' Toggle insert state„                insertState = NOT insertState„„            CASE CHR$(0) + CHR$(83)         ' Delete„                leftPart$ = LEFT$(temp$, firstChar + currentCol - firstCol - 1)„                rightPart$ = MID$(temp$, firstChar + currentCol - firstCol + 1)„                temp$ = leftPart$ + rightPart$„„            CASE CHR$(32) TO CHR$(126)„                spaceCount = firstChar + currentCol - firstCol - LEN(temp$) - 1„                IF spaceCount > 0 THEN„                    temp$ = temp$ + SPACE$(spaceCount)„                END IF„                leftPart$ = LEFT$(temp$, firstChar + currentCol - firstCol - 1)„                IF insertState THEN„                    rightPart$ = MID$(temp$, firstChar + currentCol - firstCol)„                ELSE„                    rightPart$ = MID$(temp$, firstChar + currentCol - firstCol + 1)„                END IF„                temp$ = leftPart$ + key$ + rightPart$„                IF currentCol < lastCol THEN„                    currentCol = currentCol + 1„                ELSEIF currentCol = lastCol THEN„                    firstChar = firstChar + 1„                END IF„        END SELECT„„        ' Make cursor invisible before looping.„        ' Partial fix for minor visual flaw in„        ' LOCATE statement.„        LOCATE , , 0„    LOOP„„    ' Return string„    InputBox$ = temp$„„    ' Make the cursor invisible before leaving.„    LOCATE , , 0„„END FUNCTION„„SUB MainLoop„„    ' Processes user input, looping until the user„    ' presses the Escape key. If the user presses F1„    ' then a help screen is displayed. If the user„    ' clicks the new-game button, then the game is„    ' re-initialized. If the user clicks a minefield„    ' square with the left mouse button, then the„    ' label for that square is uncovered. If the„    ' label is a "*" (a mine), then the game is over„    ' (the timer stops but the user can continue to„    ' uncover labels). If any uncovered label is a„    ' "0", then the labels for the adjacent squares„    ' are uncovered. If the user clicks a blank square„    ' with the right mouse button, then the square is„    ' marked with an "X" and the mine count is„    ' decremented. If the user clicks a marked square„    ' with the left mouse button, then the label for„    ' that square is uncovered and the mine count is„    ' incremented. Each time a label is uncovered or„    ' a square is marked, the corresponding tag is set.„    ' The user wins the game when all the mines are„    ' marked and no mines have been uncovered. If the„    ' elapsed time for the game is lower than the„    ' previous best, then the user is prompted for„    ' a name.„„    DO„        IF FieldClick(fieldRow, fieldCol, mouseLeft) THEN„            IF mouseLeft THEN„                IF NOT timerLock AND NOT timerOn THEN„                    timerOn = true„                    UpdateElapTime true„                END IF„                LOCATE minefield(fieldRow, fieldCol).row, minefield(fieldRow, fieldCol).col + 1„                MouseHide„                PRINT minefield(fieldRow, fieldCol).label;„                MouseShow„                IF minefield(fieldRow, fieldCol).tag = "X" THEN„                    minefield(fieldRow, fieldCol).tag = minefield(fieldRow, fieldCol).label„                    unmarkedMines = unmarkedMines + 1„                    UpdateCount„                END IF„                minefield(fieldRow, fieldCol).tag = minefield(fieldRow, fieldCol).label„                IF minefield(fieldRow, fieldCol).label = "0" THEN„                    ClearAround fieldRow, fieldCol„                ELSEIF minefield(fieldRow, fieldCol).label = "*" THEN„                    minefield(fieldRow, fieldCol).tag = "*"„                    timerOn = FALSE„                    timerLock = true„                    SOUND 120, 1„                    SOUND 80, 1„                    SOUND 40, 2„                END IF„            ELSE„                IF NOT timerLock AND NOT timerOn THEN„                    timerOn = true„                    UpdateElapTime true„                END IF„                IF minefield(fieldRow, fieldCol).tag = CHR$(0) AND unmarkedMines > 0 THEN„                    LOCATE minefield(fieldRow, fieldCol).row, minefield(fieldRow, fieldCol).col + 1„                    MouseHide„                    PRINT "X";„                    MouseShow„                    minefield(fieldRow, fieldCol).tag = "X"„                    unmarkedMines = unmarkedMines - 1„                    UpdateCount„                    IF AllMarked THEN„                        UncoverAll„                        timerOn = FALSE„                        RecordBestTime„                        UpdateElapTime true„                    END IF„                END IF„            END IF„        END IF„„        IF NewButtonClick THEN„            timerLock = FALSE„            FOR row = 1 TO 8„                FOR col = 1 TO fieldCols„                    minefield(row, col).label = CHR$(0)„                    minefield(row, col).tag = CHR$(0)„                NEXT„            NEXT„            unmarkedMines = mineCount„            InitMineField„            DrawBoard„        END IF„„        UpdateElapTime FALSE„„        key$ = INKEY$„„        IF key$ = CHR$(0) + CHR$(59) THEN„            MouseHide„            GetBackground„            ShowHelp„            DO„            LOOP UNTIL INKEY$ = CHR$(27)„            CLS„            PutBackground„            MouseShow„        END IF„„    LOOP UNTIL key$ = CHR$(27)„„END SUB„„SUB MouseDriver (m0, m1, m2, m3) STATIC„  „    ' Provides a call interface for mouse driver„    ' functions. The first argument must specify„    ' the function, and the remaining arguments„    ' must specify any additional parameters„    ' required by that function. You must verify„    ' the presence of the mouse driver before„    ' calling this procedure.„„    inRegs.ax = m0„    inRegs.bx = m1„    inRegs.cx = m2„    inRegs.dx = m3„    InterruptX &H33, inRegs, outRegs„    m0 = outRegs.ax„    m1 = outRegs.bx„    m2 = outRegs.cx„    m3 = outRegs.dx„„„END SUB„„SUB MouseHide STATIC„„    ' Decrements the mouse driver's internal cursor„    ' flag and hides the mouse cursor. The cursor„    ' flag is decremented for each call even if the„    ' mouse cursor is hidden.„„    MouseDriver 2, 0, 0, 0„   „END SUB„„FUNCTION MouseInit„    „    ' Checks for an installed mouse driver and„    ' attempts to reset the driver. Returns TRUE„    ' if successful, or FALSE if the mouse driver„    ' is not found or the reset failed. If the„    ' driver interrupt vector is 0000:0000 or the„    ' vector points to an IRET instruction, then„    ' the mouse driver is not installed. The mouse„    ' driver reset function (function 0) will return„    ' with m0 = 0 if the reset fails.„„    DEF SEG = 0„    mouseSegment& = &H100& * PEEK(&HCF) + PEEK(&HCE)„    mouseOffset& = &H100& * PEEK(&HCD) + PEEK(&HCC)„    DEF SEG = mouseSegment&„„    IF (mouseSegment& OR mouseOffset&) AND PEEK(mouseOfsetf&) <> &HCF THEN„        MouseDriver m0, m1, m2, m3„    END IF„    MouseInit = m0„    DEF SEG„„END FUNCTION„„SUB MouseLocate (row, col)„„    ' Positions the mouse cursor at <row>,<col>.„    ' SCREEN 0 (80 X 25 text) is is assumed.„    ' The cursor postion is specified in character„    ' coordinates. The mouse driver expects the„    ' cursor position to be in virtual-screen„    ' coordinates (640 X 200).„„    m2 = col * 8 - 1„    m3 = row * 8 - 1„    MouseDriver 4, m1, m2, m3„„END SUB„„SUB MousePoll (mouseRow, mouseCol, mouseLeft, mouseRight) STATIC„  „    ' Returns the current mouse cursor position and„    ' button status. SCREEN 0 (80 X 25 text) is assumed.„    ' The cursor postion is returned in character„    ' coordinates. The mouse driver returns the cursor„    ' position in virtual-screen coordinates (640 X 200).„   „    MouseDriver 3, m1, m2, m3„    mouseRow = m3 \ 8 + 1„    mouseCol = m2 \ 8 + 1„    IF m1 AND 1 THEN mouseLeft = true ELSE mouseLeft = FALSE„    IF m1 AND 2 THEN mouseRight = true ELSE mouseRight = FALSE„„END SUB„„SUB MouseShow STATIC„„    ' Increments the mouse driver's internal cursor flag.„    ' The mouse cursor will be displayed if the cursor„    ' flag is 0 after being incremented. The cursor flag„    ' will never be > 0.„„    MouseDriver 1, 0, 0, 0„„END SUB„„FUNCTION NewButtonClick STATIC„„    ' Monitors and controls the new-game button.„    ' If the left mouse button is down and the„    ' mouse cursor is on the new-game button, then„    ' the new-game button is highlighted. If the„    ' mouse cursor is moved off the new-game button,„    ' or if the mouse button is released, then the„    ' new-game button is un-highlighted. Returns„    ' true if the mouse button is released with the„    ' mouse cursor on the new-game button. The„    ' return value must be set to false for each call„    ' because all local variables retain there values„    ' between calls.„„    NewButtonClick = FALSE„„    MousePoll mouseRow, mouseCol, mouseLeft, mouseRight„„    IF mouseRow = 4 AND mouseCol > 36 AND mouseCol < 42 THEN„        IF highlight THEN„            IF NOT mouseLeft THEN„                LOCATE 4, 38„                MouseHide„                PRINT " New ";„                MouseShow„                highlight = FALSE„                NewButtonClick = true„                EXIT FUNCTION„            END IF„        ELSE„            IF mouseLeft THEN„                COLOR 0, 7„                LOCATE 4, 38„                MouseHide„                PRINT " New ";„                MouseShow„                COLOR 7, 0„                highlight = true„            END IF„        END IF„    ELSE„        IF highlight THEN„            LOCATE 4, 38„            MouseHide„            PRINT " New ";„            MouseShow„            highlight = FALSE„        END IF„    END IF„„END FUNCTION„„FUNCTION OnFieldSquare (mouseRow, mouseCol, fieldRow, fieldCol)„„    ' Returns true if the mouse cursor is on a minefield„    ' square. The arguments <fieldRow> and <fieldCol> are„    ' used to return the position of the mouse cursor in„    ' minefield grid coordinates.„„    FOR fieldRow = 1 TO 8„        FOR fieldCol = 1 TO fieldCols„            IF mouseRow = minefield(fieldRow, fieldCol).row AND mouseCol >= minefield(fieldRow, fieldCol).col AND mouseCol < minefield(fieldRow, fieldCol).col + 3 THEN„                OnFieldSquare = true„                EXIT FUNCTION„            END IF„        NEXT„    NEXT„„END FUNCTION„„SUB PutBackground„„    ' Crude (and slow) procedure to restore the„    ' screen contents from the global buffer.„    ' SCREEN 0 (80 X 25 text) and display page 0„    ' are assumed.„„    IF VideoMode = 7 THEN„        DEF SEG = &HB000„    ELSE„        DEF SEG = &HB800„    END IF„„    FOR i = 0 TO 3999„        POKE i, ASC(MID$(background$, i + 1, 1))„    NEXT„„    DEF SEG„„END SUB„„SUB RecordBestTime„„    ' Compares the elapsed time to the previous„    ' best time for the current mode and, if lower,„    ' records the user's name along with the new„    ' best time. Reads and writes the file„    ' MINES.INI. Creates a new file with default„    ' values if errors in the current file.„    ' Re-initializes the game when finished.„„    ON ERROR GOTO ErrorHandler„    OPEN "MINES.INI" FOR INPUT AS 1„    IF errorCode = 0 THEN„        LINE INPUT #1, line$„        IF line$ = "[Minesweeper]" THEN„            LINE INPUT #1, line$„            time1Pos = INSTR(line$, "Time1=")„            IF time1Pos THEN„                bestTime1 = VAL(MID$(line$, time1Pos + 6))„                IF bestTime1 < 1 THEN badFile = true„                LINE INPUT #1, line$„                time2Pos = INSTR(line$, "Time2=")„                IF time2Pos THEN„                    bestTime2 = VAL(MID$(line$, time2Pos + 6))„                    IF bestTime2 < 1 THEN badFile = true„                    LINE INPUT #1, line$„                    name1Pos = INSTR(line$, "Name1=")„                    IF name1Pos THEN„                        bestName1$ = MID$(line$, name1Pos + 6)„                        IF bestName1$ = "" THEN badFile = true„                        LINE INPUT #1, line$„                        name2Pos = INSTR(line$, "Name2=")„                        IF name2Pos THEN„                            bestName2$ = MID$(line$, name2Pos + 6)„                            IF bestName2$ = "" THEN badFile = true„                        ELSE„                            badFile = true„                        END IF„                    ELSE„                        badFile = true„                    END IF„                ELSE„                    badFile = true„                END IF„            ELSE„                badFile = true„            END IF„        ELSE„            badFile = true„        END IF„        CLOSE 1„    END IF„„    IF badFile OR errorCode THEN„        bestTime1 = 999„        bestTime2 = 999„        bestName1$ = "Anonymous"„        bestName2$ = "Anonymous"„    END IF„„    Box 6, 24, 16, 56, 1, true, ""„    IF expertMode THEN„        IF elapsedTime < bestTime2 THEN„            LOCATE 8, 28„            PRINT "You have the fastest time";„            LOCATE 9, 30„            PRINT "for the expert level.";„            LOCATE 11, 29„            PRINT "Please type your name:";„            newName$ = LEFT$(InputBox(12, 28, 21), 25)„            IF newName$ <> "" THEN„                bestName2$ = newName$„                bestTime2 = elapsedTime„            END IF„        END IF„    ELSE„        IF elapsedTime < bestTime1 THEN„            LOCATE 8, 28„            PRINT "You have the fastest time";„            LOCATE 9, 29„            PRINT "for the beginner level.";„            LOCATE 11, 29„            PRINT "Please type your name:";„            newName$ = LEFT$(InputBox(12, 28, 21), 25)„            IF newName$ <> "" THEN„                bestName1$ = newName$„                bestTime1 = elapsedTime„            END IF„        END IF„    END IF„    errorCode = 0„    OPEN "MINES.INI" FOR OUTPUT AS 1„    IF errorCode = 0 THEN„        PRINT #1, "[Minesweeper]"„        PRINT #1, "Time1="; MID$(STR$(bestTime1), 2)„        PRINT #1, "Time2="; MID$(STR$(bestTime2), 2)„        PRINT #1, "Name1="; bestName1$„        PRINT #1, "Name2="; bestName2$„        CLOSE 1„    END IF„„    ON ERROR GOTO 0„„    Box 6, 24, 16, 56, 1, true, "Fastest Minesweepers"„    LOCATE 8, 30„    PRINT "Beginner:"; bestTime1; "seconds";„    LOCATE 10, 40 - LEN(bestName1$) \ 2„    PRINT bestName1$;„    LOCATE 12, 31„    PRINT "Expert:"; bestTime2; "seconds";„    LOCATE 14, 40 - LEN(bestName2$) \ 2„    PRINT bestName2$;„„    DO„        key$ = INKEY$„    LOOP UNTIL key$ <> "" OR NewButtonClick„„    FOR row = 1 TO 8„        FOR col = 1 TO fieldCols„            minefield(row, col).label = CHR$(0)„            minefield(row, col).tag = CHR$(0)„        NEXT„    NEXT„    unmarkedMines = mineCount„    InitMineField„    DrawBoard„„END SUB„„FUNCTION ShiftFlags„   „    ' Returns the BIOS shift flags byte (0040:0017).„  „    DEF SEG = &H40„    ShiftFlags = PEEK(&H17)„    DEF SEG„„END FUNCTION„„SUB ShowHelp„„    Box 1, 1, 25, 80, 1, true, "Mines Help"„    LOCATE 3, 3„    PRINT "Mines is a simple text mode rip-off of the Windows Minesweeper game."„    LOCATE 4, 3„    PRINT "The game board consist of a mine count box, a new-game button, an elapsed"„    LOCATE 5, 3„    PRINT "time box, and a minefield represented as a grid of squares."„    LOCATE 6, 3„    PRINT "The object of the game is to mark all the squares containing a mine as"„    LOCATE 7, 3„    PRINT "quickly as possible without uncovering any squares containing a mine."„    LOCATE 8, 3„    PRINT "  Use the right mouse button to mark a square. Use the left mouse button to"„    LOCATE 9, 3„    PRINT "uncover a square. If you uncover a square with a mine then the game is over."„    LOCATE 10, 3„    PRINT "If you uncover a square without a mine, then a number will appear. This"„    LOCATE 11, 3„    PRINT "number indicates the number of mines in the adjacent squares. If any"„    LOCATE 12, 3„    PRINT "uncovered square contains a 0, then the program will uncover the adjacent"„    LOCATE 13, 3„    PRINT "squares for you."„    LOCATE 14, 3„    PRINT "  The mine count box initially contains the number of mines in the minefield."„    LOCATE 15, 3„    PRINT "The value in the mine count box is decreased each time you mark a square,"„    LOCATE 16, 3„    PRINT "even if you mark it incorrectly. The value in the mine count box is"„    LOCATE 17, 3„    PRINT "increased each time you uncover a marked square."„    LOCATE 18, 3„    PRINT "  The default is an 8 X 8 minefield with 10 mines. The Expert command line"„    LOCATE 19, 3„    PRINT "option increases this to a 16 X 8 minefield with 20 mines."„    LOCATE 20, 3„    PRINT "  The previous fastest times along with the names of the associated players"„    LOCATE 21, 3„    PRINT "are saved in the file MINES.INI. Delete that file to reset the saved data"„    LOCATE 22, 3„    PRINT "to default."„    „END SUB„„SUB UncoverAll„„    ' Uncovers all minefield squares without mines.„    FOR row = 1 TO 8„        FOR col = 1 TO fieldCols„            IF minefield(row, col).label <> "*" THEN„                LOCATE minefield(row, col).row, minefield(row, col).col + 1„                MouseHide„                PRINT minefield(row, col).label;„                MouseShow„            END IF„        NEXT„    NEXT„„END SUB„„SUB UpdateCount„„    ' Displays the current value of the global„    ' variable unmarkedMines.„„    unmarkedMines$ = MID$(STR$(unmarkedMines), 2)„    IF expertMode THEN LOCATE 4, 13 ELSE LOCATE 4, 27„    PRINT STRING$(3 - LEN(unmarkedMines$), "0"); unmarkedMines$;„„END SUB„„SUB UpdateElapTime (resetFlag) STATIC„„    ' Updates the elapsed time display if the global„    ' variable timerOn is true. Resets the elapsed„    ' time (to 0) if <resetFlag>. Correctly handles„    ' the midnight rollover.„    „    IF timerOn THEN„        tm& = TIMER„        IF resetFlag THEN startTime& = tm&„        et& = tm& - startTime&„        IF et& < 0 THEN et& = 86400 - startTime& + tm&„        IF et& < 999 THEN„            elapsedTime = et&„            IF resetFlag OR elapsedTime > prevElapsedTime THEN„                prevElapsedTime = elapsedTime„                elapsedTime$ = MID$(STR$(elapsedTime), 2)„                IF expertMode THEN LOCATE 4, 65 ELSE LOCATE 4, 51„                MouseHide„                PRINT STRING$(3 - LEN(elapsedTime$), "0"); elapsedTime$;„                MouseShow„            END IF„        END IF„    END IF„„END SUB„„FUNCTION VideoMode„„    ' Returns the current video mode setting from„    ' the BIOS data area.„„    DEF SEG = &H40„    VideoMode = PEEK(&H49)„    DEF SEG„„END FUNCTION„„