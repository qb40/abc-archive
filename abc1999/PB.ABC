Don Schullian                  FORMAT TITLE                   d83@ath.forthnet.gr            12-02-98 (16:01)       PB, PBCC               165  7833     FMTTITLE.BAS$if 0„    ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∑                        PowerBASIC v3.50„ ⁄ƒƒ¥          DASoft          «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∑„ ≥  √ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂    Copyright 1998    ≥ DATE: 1998-12-02 «ƒ∑„ ≥  ≥ FILE NAME   FMTTITLE.BAS ∫          by          ‘ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕƒ ∫ ∫„ ≥  ≥                          ∫  Don Schullian, Jr.                     ∫ ∫„ ≥  ‘ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº                                         ∫ ∫„ ‘Õ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº ∫„   ‘ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº„„  There are 2 versions of the function fFormatTitle. The first one is for„  PowerBASIC v3.5 while the other is for PB/cc.„„  All this function does is format an incoming string into a standard„  configuration that is used by titles. (eg: books, stories, songs)„  It ain't much but may come in handy now and again.„  eg:  INCOMING:  "The liTTle train That Could"„      RETURNING:  "Little Train That Could, The"„„  C'ya,„„   ____    _    ____      ____  _____„  |  _ \  / \  / ___) __ | ___)(_   _) Don Schullian„  | |_)  / _ \ \____\/  \|  _)   | |    d83@DASoftVSS.com„  |____//_/ \_\(____/\__/|_|     |_|    www.DASoftVSS.com„  ___________________________________   www.basicguru.com„      Vertical Software Solutions„„$endif„„DECLARE FUNCTION fFormatTitle(BYVAL Title AS STRING) AS STRING„„$if 1                             ' PowerBASIC v3.5„  DIM  T(5) AS STRING„  DIM  X    AS INTEGER„„  CLS„  FOR X = 1 TO 5„    READ T(X)„  NEXT„  FOR X = 1 TO 5„    PRINT fFormatTitle(T(X))„  NEXT„„  DATA "The  Bridge Over The River"„  DATA "A day in the  park"„  DATA "An Answer to   My Question"„  DATA "JUST 'ANOTHER' BOOK"„  DATA "i WAS       HERE"„„FUNCTION fFormatTitle (BYVAL Title AS STRING) AS STRING„„  DIM F     AS LOCAL INTEGER„  DIM P     AS LOCAL INTEGER                     'position variable„  DIM Temp  AS LOCAL STRING                      'working string„  DIM T_ptr AS LOCAL BYTE PTR                    'ptr to chars in Title$„                                                 '„  Title = TRIM$(Title)                           'strip all outside spaces„  WHILE INSTR(Title,"  ") > 0                    'remove all double spaces„    REPLACE "  " WITH " " IN Title               '„  WEND                                           '„  Title = LCASE$(Title)                          'most obvious case„                                                 '„  P = INSTR(Title," ")                           'find first space„  IF P > 0 AND P < 5 THEN                        'check for 1st word„    RESTORE FormatTitleDATA                      ' set local data„    DECR P                                       ' back up before the <space>„    FOR F = 1 TO 3                               ' check all 3 1st words„      READ Temp                                  ' get the word„      IF LEFT$(Title,P) = Temp THEN              ' if the first word then„        Title = MID$(Title,P+2) & ", " & Temp    '  create the new title„        EXIT FOR                                 '  all done!„      END IF                                     '„    NEXT                                         '„  END IF                                         '„                                                 '„  T_ptr = STRPTR32(Title)                        'set the pointer„  F     = 1                                      'set ucase flag for 1st char„  FOR P = 0 TO LEN(Title)-1                      'check all other characters„    IF @T_ptr[P] = 32 THEN                       ' if a <space>„        F = 1                                    '  set ucase flag„      ELSEif ISTRUE F THEN                       ' if ucase flag is set„        IF ( @T_ptr[P] >  96 ) AND _             '  if char is a -> z then„           ( @T_ptr[P] < 123 ) THEN              '„          BIT TOGGLE @T_ptr[P], 5  '             '   ucase the letter„          F = 0                                  '   reset the ucase flag„        END IF                                   '„    END IF                                       '„  NEXT                                           '„                                                 '„  FUNCTION = Title                               ' RETURN the formatted $„                                                 '---------------------------„  FormatTitleDATA:                               ' local data„    DATA "a"                                     '  the 1st words to be moved„    DATA "an"                                    '  to the end the titles„    DATA "the"                                   '„„END FUNCTION„„$else                      ' PowerBASIC Console Compiler„„FUNCTION PBmain ()„„  DIM  T AS LOCAL STRING„  DIM  X AS LOCAL LONG„„  FOR X = 1 TO DATACOUNT„    T = READ$(X)„    PRINT fFormatTitle(T)„  NEXT„  WAITKEY$„„  DATA "The  Bridge Over The River"„  DATA "A day in the  park"„  DATA "An Answer to   My Question"„  DATA "JUST 'ANOTHER' BOOK"„  DATA "i WAS       HERE"„„END FUNCTION„„FUNCTION fFormatTitle (BYVAL Title AS STRING) AS STRING„„  DIM F     AS LOCAL LONG„  DIM P     AS LOCAL LONG                        'position variable„  DIM Temp  AS LOCAL STRING                      'working string„  DIM T_ptr AS LOCAL BYTE PTR                    'pointer to characters in Title string„                                                 '„  Title = TRIM$(Title)                           'strip all outside spaces„  WHILE INSTR(Title,"  ") > 0                    'remove all double spaces„    REPLACE "  " WITH " " IN Title               '„  WEND                                           '„  Title = LCASE$(Title)                          'most obvious case„                                                 '„  P = INSTR(Title," ")                           'find first space„  IF P > 0 AND P < 5 THEN                        'check for 1st word„    DECR P                                       '  back up before the <space>„    Temp = READ$(P)                              '  get the word we're looking for„    IF LEFT$(Title,P) = Temp THEN                '  if it is the first word then„      Title = MID$(Title,P+2) & ", " & Temp      '    create the new title„    END IF                                       '„  END IF                                         '„                                                 '„  T_ptr = STRPTR(Title)                          'set the pointer„  F     = 1                                      'set ucase flag for 1st character„  FOR P = 0 TO LEN(Title)-1                      'check all other characters„    IF @T_ptr[P] = 32 THEN                       '  if a <space>„        F = 1                                    '    set ucase flag„      ELSEif ISTRUE F THEN                       '  if ucase flag is set„        IF ( @T_ptr[P] >  96 ) AND _             '    if char is a -> z then„           ( @T_ptr[P] < 123 ) THEN              '„          BIT TOGGLE @T_ptr[P], 5  '             '      ucase the letter„          F = 0                                  '      reset the ucase flag„        END IF                                   '„    END IF                                       '„  NEXT                                           '„                                                 '„  FUNCTION = Title                               ' RETURN the formatted string„                                                 '--------------------------------------------„  DATA "a"                                       ' the 1st words to be moved to the end of„  DATA "an"                                      ' the titles„  DATA "the"                                     '„„END FUNCTION„„$endif„Dieter Folger                  RECURSIVE FILE FIND ROUTINE    folger@bamberg.baynet.de       03-10-99 (19:43)       PB                     187  6635     FILEFIND.BAS'----------------------------------------------------------------------------„' FINDFILE.BAS for PowerBasic„' Fast file search in specified dir and its subdirs.„' Found files are shown with name, size, date, time, attrib, and long„' filename (if possible). Summery reports number of found files, total„' bytes of files and number of subdirs.„' "C:\" as Path$ and "*.*" as Mask$ show all files on this drive (any„' attribute).„' Freeware (c) 1997-99 by Dieter Folger„'-- Note: -------------------------------------------------------------------„' A former version of this program worked recursivly, but the increasing„' harddisk capacity multiplied the number of subdirectories on a drive„' enormously. There was a stack error when too many recursions had to be„' done (= subdirs scanned), even with the stack set to maximum size (32766).„' This version uses the GOTO command instead, which is less elegant but„' avoids a stack error.„' Demo program searches for all files (*.*) in current directory and its„' subdirs.„'----------------------------------------------------------------------------„DEFINT A-Z„ Path$ = CURDIR$ + "\"„ P$ = Path$             ' save path name as it is changed by SearchTree„ Mask$ = "*.*"          ' all files, any attribute„ CLS„ SearchTree Path$, Mask$„ PRINT "Path ";P$;Mask$;FileFound;"files found -";DirFound;"subdirs scanned"„ DSize$=LTRIM$(USING$(",############",DSize&))„ REPLACE "," WITH "." IN DSize$  ' German conversion„ PRINT DSize$;" bytes used by these files"„END„'----------------------------„SUB SearchTree (Path$, Mask$)„'----------------------------„DIM DTABuffer$(100), P$(100)„SHARED FileFound, DirFound, DSize&, d„IF RIGHT$(Path$,1) <> "\" THEN Path$ = Path$ + "\" ' makes sure that Path$„                                                   ' ends with backlash„LNames = Lfn ' Check if long filenames are supported„             ' Comment the line if you don't want long names„Again:       ' Jump here for more dirs and files search„  SaveDTA                     ' save current DTA for later use„  F$ = DIR$(Path$ + Mask$, 7) ' get all types of files, any attr„  IF LEN(F$) THEN„     PRINT "DIR "; Path$;„     IF LNames THEN PRINT "  (";DirLn$;")" ELSE PRINT ' show long name of dir„  END IF„  WHILE LEN(F$)         ' repeat until no more files are found in this dir„      INCR FileFound„      FileStuff Fs&, Fd$, Ft$, Att$„      PRINT USING "  \            \";F$;„      FSize$ = USING$(",##########",Fs&)„      REPLACE "," WITH "." IN FSize$ ' German conversion„      PRINT FSize$;" ";Fd$;" ";Ft$;" ";Att$; " ";„      IF LEN(F$) THEN IF Lnames THEN PRINT LongName$(Path$+F$) ELSE PRINT„      Dsize& = Dsize& + Fs&    ' add filesize to dirsize„      F$ = DIR$ 'get next file„      IF INKEY$ = CHR$(27) THEN END 'if user wants to cancel„  WEND„  D$ = DIR$(Path$ + "*.*", 55) ' search for all subdirs, any attr„  INCR d: P$(d) = Path$        ' save current path„  DO„     IF LEN(D$) AND (Attr? AND 16) = 16 THEN ' directory found„        IF Lnames THEN DirLn$ = LongName$(Path$+"\"+D$) ' long name of dir„        Path$ = RTRIM$(Path$,"\") + "\" + D$ + "\"„        INCR DirFound ' count dir for summery„        GOTO Again    ' start search loop again in this dir„     END IF„     D$ = DIR$        ' next dir„     IF D$ = "" THEN  ' no more subdirs„        DECR d : Path$ = P$(d) ' restore old path and„        RestoreDTA             '   old DTA to continue search„     END IF„     IF INKEY$ = CHR$(27) THEN END„  LOOP UNTIL d = 0„END SUB„'----------------------------„SUB GetDTA (DTASeg&, DTAOfs&)„'----------------------------„  ! mov ax, &h2F00„  ! int &h21„  ! mov s&,es„  ! mov o&,bx„ DTAOfs& = o&:DTASeg& = s&„END SUB„'-------------„FUNCTION Attr?„'-------------„ GetDTA DTASeg&, DTAOfs&„ DEF SEG = DTASeg&„   Attr? = PEEK(DTAOfs& + 21)„ DEF SEG„END FUNCTION„'-------------------------------------------„SUB FileStuff (FSize&, FDate$, FTime$, Att$)„'-------------------------------------------„ GetDTA DTASeg&, DTAOfs&„ DEF SEG = DTASeg&„   FSize& = PEEKL(DTAOfs& + 26)„   FDate$ = FILEDATE$(PEEKI(DTAOfs& + 24))„   FTime$ = FILETIME$(PEEKI(DTAOfs& + 22))„   Att?   = PEEK(DTAOfs& + 21)„ DEF SEG„ Att$ = "...."„ IF BIT(Att?, 0) THEN MID$(Att$, 2, 1) = "R" 'read only„ IF BIT(Att?, 1) THEN MID$(Att$, 3, 1) = "H" 'hidden„ IF BIT(Att?, 2) THEN MID$(Att$, 4, 1) = "S" 'system„ IF BIT(Att?, 5) THEN MID$(Att$, 1, 1) = "A" 'archive„END SUB„'----------„SUB SaveDTA„'----------„ SHARED d, DTABuffer$()„ GetDTA DTASeg&, DTAOfs&„ DEF SEG = DTASeg&„   DTABuffer$(d) = PEEK$(DTAofs&, 21)„ DEF SEG„END SUB„'-------------„SUB RestoreDTA„'-------------„ SHARED d, DTABuffer$()„ GetDTA DTASeg&, DTAOfs&„ DEF SEG = DTASeg&„   POKE$ DTAofs&, DTABuffer$(d)„ DEF SEG„END SUB„'--------------------------„FUNCTION FileDate$ (FDate)„'--------------------------„ 'Convert DOS date to string„ DateY = (FDate \ 512) + 80„ Year$ = RIGHT$("00" + MID$(STR$(DateY), 2), 2)„ DateM = (FDate AND 511) \ 32„ Month$ = RIGHT$("00" + MID$(STR$(DateM), 2), 2)„ DateD = FDate AND 31„ Day$ = RIGHT$("00" + MID$(STR$(DateD), 2), 2)„ FileDate$ = Day$ + "." + Month$ + "." + Year$„END FUNCTION„'--------------------------„FUNCTION FileTime$ (FTime)„'--------------------------„ 'Convert DOS time to string„ TimeH = FTime \ 2048„ IF TimeH < 0 THEN INCR TimeH, 31„ Hour$ = RIGHT$("00" + MID$(STR$(TimeH), 2), 2)„ TimeM = (FTime AND 2047) \ 32„ Minute$ = RIGHT$("00" + MID$(STR$(TimeM), 2), 2)„ FileTime$ = Hour$ + ":" + Minute$„END FUNCTION„'-----------„FUNCTION Lfn„'-----------„' checks if Windows is installed„' (= if long file names are supported)„  ! mov ax, &h1600„  ! int &h2F„  ! mov LfMode, al„ IF LfMode > 3 THEN FUNCTION = LfMode„END FUNCTION„'-------------------------„FUNCTION LongName$ (File$)„'-------------------------„' Returns long filename of File$„ DIM Ldta AS STRING * 500„ DIM FindHandle AS Byte„ F$ = File$ + CHR$(0)„ LSeg = VARSEG(Ldta)„ LOff = VARPTR(Ldta)„ FSeg = STRSEG(F$)„ FOff = STRPTR(F$)„  ! push ds„  ! mov ax, &h714E     ;find first matching file„  ! mov si, 0          ;see Ralph Brown's„  ! mov cx, &hFF       ;interrupt list„  ! mov es, LSeg       ;for further details„  ! mov di, LOff„  ! mov dx, FOff„  ! mov ds, FSeg„  ! int &h21„  ! pop ds„  ! mov FindHandle, ax„  ! mov ax, &h71A1     ;terminate search and„  ! mov bx, FindHandle ;reset file handle„  ! int &h21„ FUNCTION  = RTRIM$(MID$(Ldta,45,260), CHR$(0))„END FUNCTION„'==== eof ==================================================================„Dieter Folger                  RECOLOR PART OF SCREEN         folger@bamberg.baynet.de       04-04-99 (16:14)       PB                     38   1331     RECOLOR.BAS '----------------------------------------------------„' RECOLOR.BAS for PowerBasic„' Recolor a part of screen from OldAttr to NewAttr„' Demo program shows usage„' Freeware (c) 1999 by Dieter Folger„'----------------------------------------------------„DEFINT A-Z„FOR i = 1 TO 25 'fill the screen with something„    IF i MOD 2 THEN„       COLOR 15,1 : PRINT STRING$(80, "*");„    ELSE„       COLOR 14,3 : PRINT STRING$(80, "@");„    END IF„NEXT„LOCATE 12, 28 : COLOR 11,4 : PRINT "Press a key to end demo";„„DO„  DELAY 2„  ReColor 5,10,15,70,31,32 'change color attributes within the window„                           'from bright white on blue to black on green„  DELAY 2„  ReColor 5,10,15,70,32,31 'Restore old color attributes„LOOP UNTIL INSTAT 'repeat demo until user presses a key„COLOR 7,0 : CLS„END„'-----------------------------------------------------------------„SUB ReColor (StartRow, StartCol, EndRow, EndCol, OldAttr, NewAttr)„'-----------------------------------------------------------------„ IF (pbvScrnCard AND 1) = 0 THEN Address = &HB800 ELSE Address = &HB000„ DEF SEG = Address„ FOR i = StartRow TO EndRow„     FOR j= StartCol TO EndCol„         Offset = (160 * i) + (2 * j) + 1„         IF PEEK (Offset) = OldAttr THEN POKE Offset, NewAttr„     NEXT„ NEXT„ DEF SEG„END SUB„Donald R. Darden               LIST ALL FILES ON DRIVE        oldefoxx@earthlink.net         04-06-99 (16:06)       PB                     161  5397     ALLFILES.BAS$if 0„LIST ALL FILES - a program to list ALL the files on a single drive.„by Donald R. Darden, April 1999.„„This is a FREEWARE PowerBASIC Snippet.„„The program is easily modifiable, for instance you can replace the "C:\"„with any drive letter, possibly as part of a FOR loop:„„           FOR drive=asc("C") to asc("Z")„             a$=chr$(drive)+":\"„             if dir$(a$+"*.*",23)="" then iterate for„             ydir$(1)=zz$+a$„             ...„           NEXT„„Additionally, you can search for specific files by conditioning the ?a$b$„line like so:„               ...„               if instr(b$,".BAK") then ?a$b$„„Or instead of ?a$b$, you could use:„„               ...„               if instr(b$,".BAK") then kill a$b$„„(Be careful whenever you attempt to automate any KILL process, as you„might inadvertantly delete needed files!  Best test your code with the PRINT„command first)„„Ahother alternative might be to write the output to another file to use„for other processes later, such as:„„               Open "filename.lst" for output as #2„„or if you want to add to an existing file:„„               Open "filename.lst: for append as #2„„then when you find the right file(s):„„               if instr(b$,".LOG") then ?a$b$:?#2a$b$„„Note that the current DIM statement assumes that you only have a maximum„of 1,000 total directories\subdirectories on the drive.  When doing„multiple drives, you must include an ERASE command to clear the ydir$()„array before going to the next drive.  If 1,000 is too small a number, you„can make it larger.  Each ydir$() entry consists of a 2-byte MKI$(index)+„"<NAME>", where the index points to the next higher entry in the tree and„the <NAME> is assigned to the current directory.  This makes for a simple„program with limited storage required to track the tree, as files are not„added to it.  Attempting to open a directory as a file produces the Error„75 code, which makes it easy to determine if a file or directory was„returned by the DIR$ command.  The DIR$ attribute of 23 ensures that all„files and directories are returned, but not the volume label.„„If you are first searching for a directory, then want to work with all the„files in that particular directory, you can either (1) DIM another array„to track the file names, as was done directories by ydir$(),  (2) Erase„ydir$() and reuse it (or create another array), keeping only the directory„reference (a$ here), or (3) Pack the filenames into a string as was done„with c$, as a temporary means of storing the filenames without requiring„an array. (Notice the use of the nul character (0) to separate one file„name from the next. You could use any character that is not considered„valid in a file name, such as slash (/), backslash (\), asterick (*),„question mark (?), or semi-colon (;).  Actually, a chr$(0) COULD appear„in a filename, but I never resort to non-printable characters for a file„or directory name, so in my case the chr$(0) is a good separator).„„This program does not directly support file attributes, date, or size, or„the use of long file names as allowed under Windows9x/NT.  However, you„should be able to extended this code to accomodate them as well.  Look at„DIRUNIT.BAS and DOSUNIT.BAS that comes with PowerBASIC as to what it takes„to work with file attributes, date, and size, then look for mention of„Long File Names (LFN) on the PowerBASIC PBXtra code disk (or elsewhere,„including the InterNet via a search engine such as www.snap.com,„www.lycos.com, www.hotbot.com, www.altavista.digital.com, or others).„„What could you use this snippet for?  Aside from finding all *.BAK files„and erasing them, you might:„„         o   Compare files by name, or size and date, then„             content, to determine if they are duplicates„„         o   Look for all zero-length files, with the possibility„             of deleting them„„         o   Create a Map of how your drive is layed out„„         o   Create a cross-index of all files by extension (type)„„         o   copy or move all files of a type (i.e., *.ZIP) into„             a designated directory on a designated drive„„         o   Identify all system, hidden, and read-only files on„             your system„„         o   Identify all system, hidden, and read-only directories„„         o   search for specific files or file types„„         o   use these tools to write your own file manager„„         o   use these tools to write your own backup/restore program„„$endif„„$stack 8192„$compile exe„„defint a-z„dim ydir(0 to 1000) as string„yidx=1„xidx=0„z$=chr$(0)„zz$=chr$(0,0)„color 15,1„cls„ydir$(1)=zz$+"C:\"„do while xidx<yidx„  incr xidx„  a$=ydir$(xidx)„  do„    a=cvi(a$)„    if a=0 then exit do„    a$=ydir$(a)+mid$(a$,3)„  loop„  a$=mid$(a$,3)„  b$=dir$(a$+"*.*",23)„  c$=""„  do while b$>""„    c$=c$+b$+z$„    b$=dir$„  loop„  do„    a=instr(c$,z$)„    if a=0 then exit do„    b$=left$(c$,a-1)„    c$=mid$(c$,a+1)„    bad=0„    on error goto override„    open a$+b$ for input as #1„    on error goto 0„    if bad=75 then„      incr yidx„      ydir$(yidx)=mki$(xidx)+b$+"\"„    elseif bad then„      stop„    else„      ?a$b$„    end if„    close 1„  loop„loop„?"Done!"„end„„override:„bad=err„if bad=0 then bad=-1„resume next„Donald R. Darden               FIND RATIONAL EQUIVALENT       oldefoxx@earthlink.net         04-14-99 (16:46)       PB                     90   3562     RATIONAL.BAS$option cntlbreak„DEFDBL A-Z„COLOR 15,1„CLS„?„?"                    RATIONAL.BAS  By Donald R. Darden„?"             Copyright Nov 11, 1976 (HP25 Calculator version)„?"          Copyright September 9, 1991 (IBM Compatable PC version)„?"     Offered as FREEWARE April 14, 1999, on the following conditions:„?"     a.  That embedded algorythm and/or process included are both„?"           credited to the author (a little recognition, please).„?"     b.  That I am informed where and how this proved applicable.„?"     c.  Any ideas for improvements are shared publicly.„?"========================================================================„?" The purpose of this program is to determine a rational equivalent of any„?" entered real number (such as 3.141592654...).  The program will proceed„?" through a series of approximations, attempting to narrow the range of„?" error until an acceptable limit of error is reached.  This process„?" involves approximations based on the relationship between the unresol-„?" ved portion of the whole number and the fractional part that remains."„?"========================================================================„?" Comment:  It is interesting to note that the hint that this algorythm„?" could be derived came during an investigation into the possible integers„?" to approximate PI, which is best achieved by 355/113 which is accurate to„?" six decimal places.  It was noted that .25 was 1/4, and 4 is the result of„?" taking the reciprocal (1/.25=4).  Also .333333... was 3 after 1/.33333,„?" and a more advanced example of converting .666666... should provide 2/3.„?" The pivotable behavior around the decimal point on taking reciprocals„?" became the key to the algorythm.„?"Press any key to continue...";„sleep„do„loop while inkey$>""„cls„$if 0„„  I now wonder if there is other pivotable behaviour, say in deducing what„  the private encryption key might be after decrypting an encrypted message„  that was created with a public key.  Of course that is a far more extreme„  case.  But consider this program that I developed, which is somewhat„  difficult do describe in mathematical terms, since it involves such„  unconventional methods, such as using INT and FRAC, partial values, and„  conditional flow which do not lend themselves to a simple expression.„„  So perhaps our present limitation in trying to find the primes to an„  encryption process is due more to our inability to conceptualize a method„  that works with just the tools that we've learned, rather than creating„  tools that capitalize on the nature of the problem and its inherant„  one-ness with itself.„                                                        -- Don Darden„$endif„„DOit:„PRINT„INPUT "What Number to Rationalize: ", a$„if a$="" then„  ?"Done!"„  end„end if„r0 = VAL(a$)„a = INSTR(a$, ".")„r9 = LEN(a$) - a„IF r9 < 6 THEN r9 = 4„r9 = INT(10 ^ (r9 + 2) + .5)„IF r0 = 0 THEN„  ?"This number cannot be rationalized"„  GOTO DOit„END IF„r1 = 1 / r0„r5 = 1„?"Expression = Value:"; TAB(52); "Amount of Error:"„DO„  r5 = r1 * r5„  r2 = 1 / r1„  r1 = r2 - INT(r2)„  IF r1 = 0 THEN r1 = 1„  r3 = r2 / r1„  r5 = r5 * r3„  r4 = INT(r5)„  r7 = INT(r4 * r0 + .5)„  r6 = r7 / r4 - r0„  r8 = INT(r6 * 100000000)„  a$ = STR$(r6)„  a = INSTR(2, a$, "-")„  IF a THEN„    a$ = LEFT$(a$, 1) + LEFT$(".00000000000000", VAL(MID$(a$, a + 1))) + MID$(a$, 2, 1) + MID$(a$, 4, a - 5)„  END IF„  ?r7; "/"; r4; "="; r7 / r4; TAB(52); a$„LOOP WHILE r8„GOTO DOit„Alexander Podkolzin            PB CHESS GAME PROGRAMMING      app@nw.sbank.e-burg.su         04-23-99 (12:18)       PB                     557  17114    CH.BAS      '---------------------------------------------------------------------------„'  PowerBasic chess game programming.„'  First steps. Simpliest computer chess graphics and board representation.„'  Author: Alexander Podkolzin.„'  As I think, it's about 1% of work under real chess programme...„'  Next step will be "Generating of possible moves" or something like this.„'  Sorry, I do not know of English chess terminology, but source code is„'  self-explanatory.„'  Now the programme can do nothing but removing pieces from one place„'  to another, as a kid. Hope we'll tech it !?:)„'  Mouse functions are rewritten in pure basic, as native source code„'  is copyrighted by PowerBasic Inc. Names of mouse functions are the same.„'  Public domain.„'  Have fun!„'---------------------------------------------------------------------------„ $DIM ALL„ $LIB GRAPH„ $COMPILE MEMORY ' EXE„ $DYNAMIC„'---------------------------------------------------------------------------„ %FLAGS = 0: %AX = 1: %BX = 2: %CX = 3: %DX = 4„ %SI    = 5: %DI = 6: %BP = 7: %DS = 8: %ES = 9„'---------------------------------------------------------------------------„ %True = -1„ %False = 0„ %Debug = 1„ %ESC_key = &H001B„ %Mouse_Click_Left = 1„ %Mouse_Click_Right = 2„ %Mark = 1„ %Unmark = 0„ %Pawn = 1„ %Knight = 2„ %Bishop = 3„ %Rook = 4„ %Queen = 5„ %King = 6„ %WhiteSide = 0„ %BlackSide = 1„'---------------------------------------------------------------------------„ Declare Function MsButtons() As Integer„ Declare Function MsThere() As Integer„ Declare Sub MsCursorOff()„ Declare Sub MsCursorOn()„ Declare Sub MsLocate( _„         Byval Row As Integer, _„         Byval Column As Integer _„         )„ Declare Sub MsSetWindow( _„         Byval Row As Integer, _„         Byval Col As Integer, _„         Byval Rows As Integer, _„         Byval Cols As Integer _„         )„ Declare Sub MsStatus( _„         Button As Integer, _„         Row As Integer, _„         Column As Integer _„         )„'---------------------------------------------------------------------------„ Declare Sub MkBoard()„ Declare Sub MkField( _„         Byval X As Integer, _„         Byval Y As Integer, _„         Byval C As Integer _„         )„ Declare Function fColorOfBox( _„         Byval X As Integer, _„         Byval Y As Integer _„         ) As Integer„ Declare Sub MarkIt( _„         Byval X As Integer, _„         Byval Y As Integer, _„         Byval State As Integer _„         )„ Declare Function fGetKey( _„         Row As Integer, _„         Col As Integer _„         ) As Integer„ Declare Sub DoMove( _„         Byval X1 As Integer, _„         Byval Y1 As Integer, _„         Byval X2 As Integer, _„         Byval Y2 As Integer _„         )„ Declare Sub PrepareGame()„ Declare Sub Show( _„         Byval Num As Integer, _„         Byval x As Integer, _„         Byval y As Integer, _„         Byval Colr As Integer)„ Declare Sub GetScrXY( _„         Byval X As Integer, _„         Byval Y As Integer, _„         sX As Integer, _„         sY As Integer)„'---------------------------------------------------------------------------„ Dim WhiteBox As Shared Integer„ Dim BlackBox As Shared Integer„ Dim Side As Shared Integer„ Dim Piece(%Pawn To %King) As Shared String„ Dim WhiteC As Shared Integer„ Dim BlackC As Shared Integer„ Dim i As Integer„ Dim MouseX As Integer„ Dim MouseY As Integer„ Dim CurX As Shared Integer„ Dim CurY As Shared Integer„ Dim OldX As Shared Integer„ Dim OldY As Shared Integer„ Dim Pointed As Shared Integer„ Dim MarkerColor As Shared Integer„ Dim ChessBoard(8, 8) As Shared Integer„'---------------------------------------------------------------------------„„ Piece(%Pawn)   = "E2REHERE8U5HLHER2EH4U3E4R3F4D3G4FR2FGL2D6F8RFGFRF2L32"„ Piece(%Rook)   = "E2REHER2U6R3U12HL2U7R3D3R3U3R3D3R3U3R3D3R3U3R3D7L2GD1" + _„                  "2R3D6R2FGFRF2L32"„ Piece(%Knight) = "E2REHER3U4EREH2U4E3REREREREU2HL2GLGL2G3LHLU3E5UE4R3EU" + _„                  "E2FERD4FRF4DFDFD6GDGDG2LG3DFRFD4R3FGFRF2L32"„ Piece(%Bishop) = "E2R2U1H1E1R3U5E1U6E1U5E1U4E5U3R3D3F5D4F1D5F1D6F1D4F1R" + _„                  "3F1G1F1R1F2L33"„ Piece(%Queen)  = "E2REHER2EU3ER2EH13UE3F4G2F2RFRFRFRU2HUHUHUH5E4F4G2DF5" + _„                  "U8H3UE4RF4DG3D8E5UH2E4F4G5DGDGDGD2RERERERE2H2E4F3DG13" + _„                  "FR2FD3FR2FGFRF2L32"„ Piece(%King)   = "E3H1E2R2U3E2R2H11U4E6R5F3R1U2H2U1E4R1F4D1G2D2R1E3R5F6" + _„                  "D4G11R2F2D3R2F2G1F3L32"„„ WhiteBox = 7„ BlackBox = 0„ WhiteC = 10„ BlackC =  9„ MarkerColor = 12„ Side = %WhiteSide                               'Human side„' Side = %BlackSide                               'Human side„„ Screen 12„ MkBoard„ PrepareGame„„ MsCursorOn„ MsSetWindow 4, 4, 383, 386„ MsLocate 194, 194„„ Do„   i = fGetKey(MouseX, MouseY)„   Select Case i„   Case %Mouse_Click_Left„     CurX = MouseX : CurY = MouseY„     If Pointed Then                             'Marked field„       If (OldX = CurX) And (OldY = CurY) Then   'At the same place„         Pointed = %False                        '„         OldX = 0                                '„         OldY = 0                                '„         MarkIt CurX, CurY, %Unmark              'Remove marker„       Else                                      'Another place„         MarkIt OldX, OldY, %Unmark              'Remove marker„         DoMove OldX, OldY, CurX, CurY           'Replace piece„         Pointed = %False                        '„         OldX = 0                                '„         OldY = 0                                '„       End If                                    '„     Else                                        'Not marked field„       If ChessBoard(CurX, CurY) = 0 Then        'Can not„         Exit Select                             'mark empty„       End If                                    'field„       Pointed = %True                           '„       OldX = CurX                               '„       OldY = CurY                               '„       MarkIt CurX, CurY, %Mark                  'Make marker„     End If                                      '„„   Case %ESC_key, %Mouse_Click_Right„     Exit Loop„„   Case %Mouse_Click_Left„   End Select„„ Loop„„ Screen 0,0,0,0„ End„'---------------------------------------------------------------------------„ Function fGetKey(Col As Integer, Row As Integer) As Integer„„   Dim s As String„   Dim Button As Integer„   Dim x As Integer„   Dim y As Integer„„   Do„     s = Inkey$„     MsStatus Button, y, x„     x = (x - 3) \ 48 + 1„     y = (y - 3) \ 48 + 1„„     If Side Then                                'Calculating„       Col = 9 - x : Row = y                     'chess board„     Else                                        'coordinates„       Col = x     : Row = 9 - y                 'of a piece„     End If                                      '„„     Color 14„     Locate 1, 70: Print Time$„     Locate 27, 25„     Print Mid$("ABCDEFGH", Col, 1); Ltrim$(Str$(Row))„„     If Button Then„       Function = Button„       Do„         MsStatus Button, y, x„       Loop Until Button = 0„       CurX = Col„       CurY = Row„       Exit Function„     End If„   Loop Until Len(s)„   Function = Cvi(s + Chr$(0))„„ End Function„'---------------------------------------------------------------------------„ Sub DoMove(Byval X1 As Integer, _„            Byval Y1 As Integer, _„            Byval X2 As Integer, _„            Byval Y2 As Integer)„„   Dim Man As Integer„   Dim cp As Integer„   Dim cba As Integer„   Dim cbb As Integer„   Dim k As Integer„   Dim i As Integer„   Dim x As Integer„   Dim y As Integer„„   Man = ChessBoard(X1, Y1)„   ChessBoard(X1, Y1) = 0„   ChessBoard(X2, Y2) = Man„   x = X2„   y = Y2„„   If Man > 0 Then„     cp = WhiteC„   Elseif Man < 0 Then„     cp = BlackC„   Else„     Exit Sub„   End If„„   cba = fColorOfBox(X1, Y1)„   cbb = fColorOfBox(X2, Y2)„„   GetScrXY X1, Y1, X1, Y1„   GetScrXY X2, Y2, X2, Y2„„   MsCursorOff„   k = (X1 - 1) * 48 + 3„   i = (Y1 - 1) * 48 + 3„   Line(k, i) - (k + 47, i + 47), cba, BF„   k = (X2 - 1) * 48 + 3„   i = (Y2 - 1) * 48 + 3„   Line(k, i) - (k + 47, i + 47), cbb, BF„   Show Abs(Man), x, y, cp„   MsCursorOn„„ End Sub„'---------------------------------------------------------------------------„ Sub GetScrXY(Byval X As Integer, _„              Byval Y As Integer, _„              sX As Integer, _„              sY As Integer)„   If Side Then„     sX = 9 - X : sY = Y„   Else„     sX = X     : sY = 9 - Y„   End If„„ End Sub„'---------------------------------------------------------------------------„ Sub MarkIt(Byval X As Integer, Byval Y As Integer, Byval State As Integer)„„   Dim k As Integer„   Dim i As Integer„   Dim c As Integer„„   If State Then„     c = MarkerColor„   Else„     c = fColorOfBox(X, Y)„   End If„„   GetScrXY X, Y, X, Y„„   k = (X - 1) * 48 + 4„   i = (Y - 1) * 48 + 4„„   MsCursorOff„   Line(k, i) - (k + 45, i + 45), c, B„   Line(k + 1, i + 1) - (k + 44, i + 44), c, B„   MsCursorOn„„ End Sub„'---------------------------------------------------------------------------„ Function fColorOfBox(Byval X As Integer, Byval Y As Integer) As Integer„„   Dim cb As Integer„   Dim cw As Integer„„   GetScrXY X, Y, X, Y„   If (X + Y) Mod 2 Then„     Function = BlackBox„   Else„     Function = WhiteBox„   End If„„ End Function„'---------------------------------------------------------------------------„ Sub MkBoard()„„   Dim X As Integer„   Dim Y As Integer„   Dim CBlack As Integer„   Dim CWhite As Integer„„   CBlack = BlackBox„   CWhite = WhiteBox„„   For X = 1 To 8„     For Y = 1 To 8„       Swap CBlack, CWhite„       MkField X, Y, CBlack„     Next„     Swap CBlack, CWhite„   Next„„   Line (0, 0) - (389, 389), 2, B„   Line (1, 1) - (388, 388), 2, B„„   Color 2„   Locate 26, 4„   If Side Then„     Print "H     G     F     E     D     C     B     A"„     For Y = 1 To 8„       Locate 2 + (Y - 1) * 3, 51: Print Mid$("12345678", Y, 1)„     Next„   Else„     Print "A     B     C     D     E     F     G     H"„     For Y = 1 To 8„       Locate 2 + (Y - 1) * 3, 51: Print Mid$("12345678", 9 - Y, 1)„     Next„   End If„   Color 7„„ End Sub„'---------------------------------------------------------------------------„ Sub PrepareGame()„„   Dim i As Integer„   Dim k As Integer„   Dim c As Integer„„   For i = 1 To 8„     ChessBoard(i, 2) = %Pawn„     ChessBoard(i, 7) = -%Pawn„   next„„   ChessBoard(1, 1) = %Rook„   ChessBoard(8, 1) = %Rook„   ChessBoard(1, 8) = -%Rook„   ChessBoard(8, 8) = -%Rook„   ChessBoard(2, 1) = %Knight„   ChessBoard(7, 1) = %Knight„   ChessBoard(2, 8) = -%Knight„   ChessBoard(7, 8) = -%Knight„   ChessBoard(3, 1) = %Bishop„   ChessBoard(6, 1) = %Bishop„   ChessBoard(3, 8) = -%Bishop„   ChessBoard(6, 8) = -%Bishop„„   If Side Then„     ChessBoard(5, 1) = %Queen„     ChessBoard(5, 8) = -%Queen„     ChessBoard(4, 1) = %King„     ChessBoard(4, 8) = -%King„   Else„     ChessBoard(4, 1) = %Queen„     ChessBoard(4, 8) = -%Queen„     ChessBoard(5, 1) = %King„     ChessBoard(5, 8) = -%King„   End If„„   For i = 1 To 8„     For k = 1 To 8„       If ChessBoard(i, k) > 0 Then„         c = WhiteC„       Elseif ChessBoard(i, k) < 0 Then„         c = BlackC„       Else„         Iterate For„       End If„       Show Abs(ChessBoard(i, k)), i, k, c„     Next„   Next„„ End Sub„'---------------------------------------------------------------------------„ Sub MkField(Byval X As Integer, _„             Byval Y As Integer, _„             Byval C As Integer)„   Dim Xb As Integer„   Dim Yb As Integer„   Dim Xe As Integer„   Dim Ye As Integer„„   Xb = 3 + (X - 1) * 48„   Yb = 3 + (Y - 1) * 48„   Xe = Xb + 47„   Ye = Yb + 47„„   Line (Xb, Yb) - (Xe, Ye), C, BF„„ End Sub„'---------------------------------------------------------------------------„ Sub Show(Byval Num As Integer, _„          Byval Xx As Integer, _„          Byval Yy As Integer, _„          Byval Colr As Integer)„„   Dim x As Integer„   Dim y As Integer„„   GetScrXY Xx, Yy, Xx, Yy„„   x = (Xx - 1) * 48 + 10„   y = (Yy - 1) * 48 + 46„„   Draw "C8BM" + Str$(x) + "," + Str$(y)„   Draw Piece(Num)„'„'  Painting some additional stuff„'„   Select Case Num„   Case %Knight„     Draw "C8BM" + Str$(x + 12) + "," + Str$(y - 31)„     Draw "URG"„„   Case %Bishop„   Case %Rook„   Case %Queen„     Draw "C8BM" + Str$(x + 1) + "," + Str$(y - 24)„     Draw "UFL"„     Draw "C8BM" + Str$(x + 32) + "," + Str$(y - 24)„     Draw "UGR"„     Draw "C8BM" + Str$(x + 8) + "," + Str$(y - 29)„     Draw "HEFG"„     Draw "C8BM" + Str$(x + 25) + "," + Str$(y - 29)„     Draw "HEFG"„     Draw "C8BM" + Str$(x + 16) + "," + Str$(y - 33)„     Draw "HERFGL"„„   Case %King„     Draw "C8BM" + Str$(x + 6) + "," + Str$(y - 21)„     Draw "UEHURFERDGFDLHGL"„     Draw "C8BM" + Str$(x + 23) + "," + Str$(y - 21)„     Draw "UEHURFERDGFDLHGL"„     Draw "C8BM" + Str$(x + 16) + "," + Str$(y - 32)„     Draw "HUERFDG"„„   End Select„„   If Num <> %Pawn Then„     Draw "C8BM" + Str$(x + 16) + "," + Str$(y - 10)„     Draw "U4L3UR3U4RD4R3DL3D4L"„   End If„„   Draw "BM" + _                                 'Filling area„        Str$(x + 17) + "," + _„        Str$(y - 2) + "P" + _„        Str$(Colr) + ",8"„„ End Sub„'---------------------------------------------------------------------------„'         MsThere - Returns true if mouse driver is present.„ Function MsThere() Public As Integer„   Reg %AX, 0„   Call Interrupt &H33„   If Reg(%AX) Then„     Function = %True„   End If„ End Function„'---------------------------------------------------------------------------„'         MsButtons - Returns number of buttons if a mouse is installed.„ Function MsButtons() Public As Integer„   Reg %AX, 0„   Call Interrupt &H33„   If Reg(%BX) Then„     Function = Reg(%BX)„   End If„ End Function„'---------------------------------------------------------------------------„'    MsCursorOn - Turn mouse cursor on.„ Sub MsCursorOn() Public„   Reg %AX, 1 : Call Interrupt &H33„ End Sub„'---------------------------------------------------------------------------„'    MsCursorOff - Turn mouse cursor off.„ Sub MsCursorOff() Public„   Reg %AX, 2 : Call Interrupt &H33„ End Sub„'---------------------------------------------------------------------------„'    MsStatus - Return button(s) pressed, row and column of cursor.„'    Button = Current button(s) pressed.„'    Left button - 1„'    Right button - 2,„'    Middle button - 4„'    Row    = Current mouse cursor row„'    Column = Current mouse cursor column„ Sub MsStatus(Button As Integer, Row As Integer, Column As Integer) Public„   Reg %AX, 3 : Call Interrupt &H33„   Button = Reg(%BX) : Row = Reg(%DX) : Column = Reg(%CX)„   If (Pbvscrnmode = 7) Or (Pbvscrnmode = 0) Then„     Row = (Row \ 8) + 1                         'If text mode, then„     Column = (Column \ 8) + 1                   'fix coordinates„   End If„ End Sub„'---------------------------------------------------------------------------„'    MsLocate - Locates the mouse cursor at Row, Column.„'    Row    = New mouse cursor row„'    Column = New mouse cursor column„ Sub MsLocate(Byval Row As Integer, Byval Column As Integer) Public„   If (Pbvscrnmode = 7) Or (Pbvscrnmode = 0) Then„     Row = (Row - 1) * 8                         'If text mode, then„     Column = (Column - 1) * 8                   'fix coordinates„   End If„   Reg %AX, 4 : Reg %CX, Column : Reg %DX, Row : Call Interrupt &H33„ End Sub„'---------------------------------------------------------------------------„'    MsSetWindow - defines window for mouse cursor.  The mouse„'    cursor will not be allowed outside of this defined area.„'    Row  = Top row for mouse window boundary„'    Col  = Left column for mouse window boundary„'    Rows = Total rows for mouse window boundary„'    Cols = Total columns for mouse window boundary„ Sub MsSetWindow(Byval Row As Integer, Byval Col As Integer, _„                 Byval Rows As Integer, Byval Cols As Integer) Public„   Rows = Row + Rows - 1                         'Adjust cols to„'                                                'real coordinates„   If (Pbvscrnmode = 7) Or (Pbvscrnmode = 0) Then„     Row = Row * 8 : Rows = Rows * 8             'If text mode,„     Col = Col * 8 : Cols = Cols * 8             'adjust coordinates„   End If„   Reg %AX, 8 : Reg %CX, Row : Reg %DX, Rows : Call Interrupt &H33„   Reg %AX, 7 : Reg %CX, Col : Reg %DX, Cols : Call Interrupt &H33„   MsLocate Row, Col                             'Move mouse cursor to„'                                                'upper left corner„ End Sub„'---------------------------------------------------------------------------„Donald R. Darden               DETERMINE PORTS IN USE         oldefoxx@earthlink.net         04-27-99 (16:50)       PB                     112  4993     PORTUSE.BAS defint a-z„color 15,1„cls„if instr(command$,"?") then„  ?"PORT USE, by Donald R. Darden, 1999, offered as FREEWARE"„  ?„  ?"This program scans the port addresses from 000 to 3FF and tries to determine"„  ?"which ones are attached to a hardware adapter of some sort, and which ones„  ?"are still available to be assigned to new hardware.  It works by using the„  ?"fact that PCs are designed to return a high or all-ones condition (&hFF or„  ?"255 decimal) when not attached to an external device.  Because individual„  ?"registers in an adapter can also return an all-ones condition, it is very„  ?"important to consider the adjacent addresses when testing ports in this„  ?"fashion.  For instance, 8 consecutive ports are unlikely to all be set to„  ?"255 when attached to an adapter, but it could happen, whereas any one NOT„  ?"being set to 255 would surely indicate that an adapter is present.„  ?„  ?"As submitted, this program makes four assumptions:  (1)  The range of„  ?"possible port addresses is from 0 to 4095.  (It could concievably be from„  ?"0 to 65535).  (2)  That the interest is primarily in 8-port groups (which„  ?"correspond to the number of ports needed for additional serial ports).„  ?"(3)  That the particular multiport card to be added has eight serial ports,„  ?"and these all need to be adjacent to each other (a block of 64 consecutive„  ?"ports is needed).  And  (4)  that for addressing purposes, the first serial„  ?"port must start on an exact multiple of 64 boundary (000, 040, 080, 0C0,„  ?"100, etc.).  If all these conditions are satisfied, the corresponding line„  ?"in the output file (default name: A:\portuse.txt) will end with ***. (All„  ?"lines having :: should be :FF:, but are compressed for readability.)„  ?,"Press any key to continue... ";„  locate ,,1„  sleep„  cls„  ?"This information can be of particular value when checked against the list of„  ?"I/O ports maintained by Ralf Brown (as a part of his comprehensive list of„  ?"PC Interrupts and other related information, available from the Internet,„  ?"without charge.  Check out sites that cover PC Assembly Language Programming„  ?"(by using a search engine such as www.hotbot.com, www.lycos.com, www.snap.„  ?"com, www.altavista.digital.com, among others).  By matching your used ports„  ?"against with what the PORTS list indicates, and consulting your PC Setup„  ?"screen or documentation, you should be able to get a pretty good handle on„  ?"what you have installed and where it resides in your PC.„  ?„  ?"Note that many adapters can be reconfigured to work from different port„  ?"locations and/or with different Interrupts (IRQs).  This can be very„  ?"important if you have two adapters whose settings put them at the same or„  ?"overlapping ports.  You can't allow this, because this can lock up your PC,„  ?"or cause other problems.  If you don't have the documentation for your„  ?"adapters, you can still see what different PORT settings are allowed for„  ?"them (if listed in the PORTS list, or by checking out the venders' sites„  ?"on the internet to see if they offer that information on line)."„  ?„  ?"One precaution about working with unknown hardware/ports.  It is generally„  ?"safe to use the INP(port_addr) command as demonstrated by this program, but„  ?"the same cannot be said for the OUT command.  That is because the PC and„  ?"attached hardware are vulnerable to changes that you can make in timing,„  ?"interrupt states, what is enabled and disabled, and so on.  So be careful."„  ?,"Press any key now to run the program... ";„  locate ,,1„  sleep„  cls„end if„„open "a:\portuse.txt" for output as #1„d=0„for a=0 to 4095-64 step 8„  do„    e=0„    for b=a to a+63„      bad=0„      on error goto override„      if inp(b)<&hff then incr e„      on error goto 0„    next„    if a>=d then„      if e then„        ?"Ports "right$("00"+hex$(a),3)" - "right$("00"+hex$(a+7),3)":  ";„        ?#1,"Ports "right$("00"+hex$(a),3)" - "right$("00"+hex$(a+7),3)":  ";„        for b=a to a+7„          ?":";„          ?#1,":";„          if inp(b)<&hff then„            ?hex$(inp(b));„            ?#1,hex$(inp(b));„          end if„        next„        ?„        ?#1,""„      else„         if (a mod &H40)=0 then„           ?"Ports "right$("00"+hex$(a),3)" - "right$("00"+hex$(a+63),3) _„            ":  appears to be available. ***"„           ?#1,"Ports "right$("00"+hex$(a),3)" - "right$("00"+hex$(a+63),3) _„            ":  appears to be available. ***"„           incr a,56„         else„           ?"Ports "right$("00"+hex$(a),3)" - "right$("00"+hex$(a+7),3) _„            ":  appears to be available."„           ?#1,"Ports "right$("00"+hex$(a),3)" - "right$("00"+hex$(a+7),3) _„            ":  appears to be available."„         end if„      end if„    end if„  loop until 1„next„close„?"Done!"„end„„override:„bad=0„if bad=0 then bad=-1„resume next„Dieter Folger                  VGA COLORS & PALETTES          folger@bamberg.baynet.de       05-15-99 (18:33)       PB                     263  8051     VGACOL.BAS    '***********************************„  '*      VGA Colors & Palettes      *„  '*       Colors Demo Program       *„  '*    Developed by Ray Ligocki     *„  '*  Programmed in QuickBASIC 4.5   *„  '*    F R E E W A R E ... enjoy    *„  '*                                 *„  '*    Converted to Power Basic     *„  '*      by Dieter Folger 1997      *„  '***********************************„ON ERROR GOTO ErrorHandle„SCREEN 12 ' VGA 640 X 480 X 16 colors„' Dimension and read draw character strings„DIM ch$(0:42)„FOR x = 0 TO 42: READ ch$(x): NEXT„FirstScreen„MainScreen„'Set preliminary colors for display„Blue = 63: Green = 43: Red = 63„SetPalette 1, 0, 0, Blue„SetPalette 2, 0, Green, 0„SetPalette 4, Red, 0, 0„SetPalette 13, Red, Green, Blue„PrintValue„Arrow$ = CHR$(25): Place = 19„LOCATE 18, Place: PRINT Arrow$„„' Main loop - forces user to use arrow keys or quit and monitor palette„DO„     DO: a$ = INKEY$: LOOP UNTIL LEN(a$)„     IF LEN(a$) = 2 THEN a$ = RIGHT$(a$, 1)„     SELECT CASE a$„     CASE CHR$(77) 'right„         LOCATE 18, Place: PRINT " "„         INCR Place, 19„         IF Place > 57 THEN Place = 19„         LOCATE 18, Place: PRINT Arrow$„     CASE CHR$(75) 'left„         LOCATE 18, Place: PRINT " "„         DECR Place, 19„         IF Place < 19 THEN Place = 57„         LOCATE 18, Place: PRINT Arrow$„     CASE CHR$(72)„          IF Place = 57 THEN„             INCR Blue„             IF Blue > 63 THEN Blue = 0„             SetPalette 1, 0, 0, Blue„             PrintValue„          END IF„          IF Place = 38 THEN„             INCR Green„             IF Green > 63 THEN Green = 0„             SetPalette 2, 0, Green, 0„             PrintValue„          END IF„          IF Place = 19 THEN„             INCR Red„             IF Red > 63 THEN Red = 0„             SetPalette 4, Red, 0, 0„             PrintValue„          END IF„     CASE CHR$(80)„          IF Place = 57 THEN„             DECR Blue„             IF Blue < 0 THEN Blue = 63„             PrintValue„             SetPalette 1, 0, 0, Blue„          END IF„          IF Place = 38 THEN„             DECR Green„             IF Green < 0 THEN Green = 63„             SetPalette 2, 0, Green, 0„             PrintValue„          END IF„          IF Place = 19 THEN„             DECR Red„             IF Red < 0 THEN Red = 63„             SetPalette 4, Red, 0, 0„             PrintValue„          END IF„     CASE "Q", "q", CHR$(27)„          END„     END SELECT„     SetPalette 13, Red, Green, Blue„LOOP„„'Data for characters„DATA brhu4erfd4gnlbr2„DATA r2u6ngd6r2„DATA bu5er2fdgl2gd2r4„DATA bu5er2fdgnlfdgl2nhbr3„DATA br3u6g3r4bd3„DATA bufr2eu2hl3u2r4bd6„DATA bu3r3fdgl2hu4er2bd6br„DATA bu6r4dg3d2br3„DATA brhuer2euhl2gdfr2fdgnl2br„DATA brr2eu4hl2gdfr3bd3„DATA br4,br4,br4,br4,br4,br4,br4„DATA u5er2fd2nl4d3„DATA ru6nlr2fdgnl2fdgnl3br„DATA br4bu5hl2gd4fr2ebd„DATA ru6nlr2fd4gnl2br„DATA u6nr4d3nr3d3r4„DATA u3nr3u3r4bd6„DATA buu4er3bd4nld2l3nhr3„DATA u3nu3r4nu3d3„DATA r2u6nl2nr2d6r2„DATA bunufr2enu5bd„DATA u3nu3rne3f3„DATA nu6r4„DATA u6f2due2d6„DATA u6f4nu4d2„DATA brhu4er2fd4gnl2br„DATA u6r3fdgl3d3br4„DATA brhu4er2fd4gnl2buhf2„DATA u6r3fdgl3rf3„DATA bufr2euhl2huer2fbd5„DATA bu6r4l2d6br2„DATA bunu5fr2enu5bd„DATA bu6d4f2e2u4bd6„DATA nu6e2udf2nu6„DATA ue4nug2h2nuf4d„DATA bu6df2e2nug2d3br2„DATA bu6r4dg4dr4„„ErrorHandle:„ CLS : PRINT "This program is for VGA only !"„ PRINT "Sorry .............."„END„'---------------------------------„SUB SetPalette (BYVAL C?, r, g, b)„'---------------------------------„  LOCAL Col?„  ! mov ax,&h1007„  ! mov bl,C?„  ! Int &h10„  ! mov Col?,bh„  OUT &H3C8, Col?„  OUT &H3C9, r„  OUT &H3C9, g„  OUT &H3C9, b„END SUB„'-------------„SUB PrintValue„'-------------„ ' print values held in Blue, Green and Red variable„ SHARED Blue, Red, Green„ LOCATE 22, 62: PRINT Blue„ LOCATE 22, 43: PRINT Green„ LOCATE 22, 24: PRINT Red„END SUB„'--------------„SUB FirstScreen„'--------------„ LINE (130, 100)-(520, 200), 1, BF„ LINE (131, 101)-(519, 199), 14, B„ LINE (133, 103)-(517, 197), 14, B„ DRAW "bm162,145c0s20": m$ = "VGA COLORS": WriteChar m$„ DRAW "bm163,145": WriteChar m$„ DRAW "bm164,145": WriteChar m$„ DRAW "bm155,148c14": WriteChar m$„ DRAW "bm156,148": WriteChar m$„ DRAW "bm157,148": WriteChar m$„ DRAW "bm246,180s4c14": m$ = "DEVELOPED BY RAY LIGOCKI": WriteChar m$„ DRAW "bm210,430s8c12": m$ = "THIS IS FREEWARE": WriteChar m$„ LOCATE 15, 16„ PRINT "Originally programmed in QuickBASIC 4.5 (April 1990)"„ LOCATE 16, 17„ PRINT "Converted to Power Basic by D. Folger (April 1997)"„ LOCATE 24, 35: PRINT "Press a key"„ DO: K$ = INKEY$: LOOP UNTIL LEN(K$)„END SUB„'-------------„SUB MainScreen„'-------------„ CLS„ LINE (0, 0)-(639, 40), 15, BF„ LINE (2, 2)-(637, 38), 1, B„ m$ = "THE PALETTE SHOP"„ DRAW "bm80,35c12s16": WriteChar m$„ v = 34„ FOR x = 81 TO 86„     DRAW "bm" + STR$(x) + "," + STR$(v): v = v - 1„     WriteChar m$„ NEXT x„ ' Draw paint cans„ CIRCLE (150, 360), 30, 7, 3, , .6„ CIRCLE (150, 310), 30, 7, , , .6„ CIRCLE (150, 310), 25, 7, , , .6„ DRAW "bm120,310s4c7d50br60u50"„ PAINT (150, 310), 4, 7„ PAINT (150, 330), 14, 7„ CIRCLE (150, 350), 26, 4, , , .6„ PAINT (150, 350), 15, 4„ DRAW "bm137,346c0": m$ = "LIGO": WriteChar m$„ DRAW "bm134,356": m$ = "PAINT": WriteChar m$„ DRAW "bm148,359c4r4fl6gr8gl6fr4"„ CIRCLE (300, 360), 30, 7, 3, , .6„ CIRCLE (300, 310), 30, 7, , , .6„ CIRCLE (300, 310), 25, 7, , , .6„ DRAW "bm270,310s4c7d50br60u50"„ PAINT (300, 310), 2, 7„ PAINT (300, 330), 14, 7„ CIRCLE (300, 350), 26, 4, , , .6„ PAINT (300, 350), 15, 4„ DRAW "bm287,346c0": m$ = "LIGO": WriteChar m$„ DRAW "bm284,356": m$ = "PAINT": WriteChar m$„ DRAW "bm298,359c2r4fl6gr8gl6fr4"„ CIRCLE (450, 360), 30, 7, 3, , .6„ CIRCLE (450, 310), 30, 7, , , .6„ CIRCLE (450, 310), 25, 7, , , .6„ DRAW "bm420,310s4c7d50br60u50"„ PAINT (450, 310), 1, 7„ PAINT (450, 330), 14, 7„ CIRCLE (450, 350), 26, 4, , , .6„ PAINT (450, 350), 15, 4„ DRAW "bm437,346c0": m$ = "LIGO": WriteChar m$„ DRAW "bm434,356": m$ = "PAINT": WriteChar m$„ DRAW "bm448,359c1r4fl6gr8gl6fr4"„ ' User instructions„ LOCATE 16, 4„ PRINT "Use " + CHR$(27) + CHR$(26) + " keys to select paint color & ";„ PRINT CHR$(18) + " keys for brightness control."„ 'Draw pipe from bottom of cans to top of test tile„ DRAW "bm146,380c1d30f10r420e10u330h10l270g10d20r10u15e5r260f5d318g5l116u29l10d29l140u29l10d29l134h5u24l10"„ PAINT (150, 382), 7, 1„ ' Create a brown border around the test tile„ LINE (80, 100)-(560, 220), 15, B„ LINE (92, 122)-(548, 206), 15, B„ PAINT (90, 105), 6, 15„ ' Draw boxes and fill with default colors„ DRAW "bm600,100c15d320r20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20nl20u20l20"„ v = 125: FOR x = 1 TO 15: PAINT (610, v), x, 15: v = v + 20: NEXT x„ v = 112: FOR x = 0 TO 15: DRAW "bm618," + STR$(v) + "c15s4": m$ = STR$(x): WriteChar m$: v = v + 20: NEXT„ DRAW "bm590,432s4c15": m$ = "DEFAULT"„ WriteChar m$: DRAW "bm594,442": m$ = "COLORS": WriteChar m$„ ' Show off my handle„ DRAW "bm135,117s8c15"„ m$ = "LIGO PAINT COMPANY TEST TILE": WriteChar m$„ DRAW "bm94,124c12s4r451d80l225nu80l226u80"„ PAINT (100, 130), 15, 12„ ' put color for palette 13 on a white and black background„ LINE (116, 138)-(300, 190), 13, BF„ LINE (344, 138)-(524, 190), 13, BF„ ' More user information„ LOCATE 30, 29: PRINT "Press Q or Esc to quit";„ LOCATE 28, 16„ PRINT "64 X 64 X 64 = 262,144 possible color combinations !"„ LOCATE 4, 5„ PRINT "Command: SetPalette 13, Red, Green, Blue (I am changing color 13)"„END SUB„'-----------------„SUB WriteChar (m$)„'-----------------„' Draw character subprogram„ SHARED ch$()„ FOR z = 1 TO LEN(m$)„     m = ASC(MID$(m$, z, 1)) - 48„     IF m = -16 THEN DRAW "br4" ELSE DRAW ch$(m)„     DRAW "br3"„ NEXT z„END SUB„'=== eof =================================================================„Donald R. Darden               FIND TEXT ANYWHERE             oldefoxx@earthlink.net         06-09-99 (19:43)       PB                     457  9916     FT.BAS      defint a-z„declare function GetStrLoc (BYVAL AllocHandle%) AS LONG„dim a$(20),b%(20)„q$=chr$(34)„'dim subdir as string 'subdir is huge„def seg=GetPSP%„for a=129 to 255„  if peek(a)=13 then exit for„next„a$=peek$(129,a-129)„def seg„b$=a$„b=0„! mov  ax,a$„! push ax„! call GetStrLoc„! or   cx,cx„! jz   loop0„! mov  es,dx„! mov  di,ax„! mov  ah,32„loop1:„! mov  al,byte ptr es:[di]„! cmp  al,ah„! jl   loop2„! cmp  al,123„! jl   loop3„loop2:„! mov  al,ah„loop3:„! stosb„! loop loop1„loop0:„„hd$=curdir$„cd$=hd$„sweep=instr(" "+a$+" "," /S ")„if sweep then„  a$=left$(a$,sweep-1)+mid$(a$,sweep+3)„  sweep=-1„end if„down1=instr(" "+a$+" "," /1 ")„if down1 then„  a$=left$(a$,down1-1)+mid$(a$,down1+3)„  down1=-1„  sweep=-1„end if„a=instr(a$,":")„b=instr(a$,"\")„c=instr(a$+" "," ")„if a and a<c or b and b<c then„  cd$=left$(a$,c-1)„  if mid$(cd$,2,1)=":"then chdrive left$(cd$,2)„  chdir cd$„  a$=mid$(a$,c+1)„end if„view text (1,1)-(80,25)„color 15,1„cls„longa=0„longb=25„do„  a$=trim$(a$)„  if a$="" then exit do„  a=instr(a$+" "," ")„  b=instr(a$,chr$(34))„  if b and b<a then a=b„  b=instr(a$,"'")„  if b and b<a then a=b„  b=instr(a$,"`")„  if b and b<a then a=b„  b=instr(a$,"~")„  if b and b<a then a=b„  select case mid$(a$,a,1)„  case ""„    b$=lcase$(a$)„    a$=""„merge1:„    select case b$„    case "/p"„      printer=-1„      iterate do„    case "/f"„      if filename$="" then filename$=mid$(b$,3)„      if filename$="" then filename$="ft.tmp"„      iterate do„    case "/s"„      sweep=-1„      iterate do„    case "/1","-1"„      down1=-1„      sweep=-1„      iterate do„    case "/cr","/lf", "/crlf"„      b$=chr$(10)„      carret=-1„    case else„    end select„    incr i„    a$(i)=b$„    b(i)=0„  case " "„    b$=lcase$(left$(a$,a-1))„    a$=mid$(a$,a+1)„    goto merge1„  case chr$(34),"~"„    b=instr(a+1,a$,mid$(a$,a,1))„    if b=0 then b=len(a$)+2„    incr i„    a$(i)=mid$(a$,a+1,b-a-1)„    b(i)=-1„    a$=mid$(a$,b+1)„  case else„    b=instr(a+1,a$,mid$(a$,a,1))„    if b=0 then b=len(a$)+2„    incr i„    a$(i)=lcase$(mid$(a$,a+1,b-a-1))„    b(i)=0„    a$=mid$(a$,b+1)„  end select„  b=len(a$(i))„  if b then„    if b>longa then longa=b„    longb=longb+b„  else„    decr i„  end if„loop„if i=0 or help then„  cls„  ?"    FIND TEXT, a program by Donald R. Darden, 1999, Released as FreeWare.„  ?„  ?"  This program searches all files in the current or given directory for„  ?"  text matches that can be specified as case sensitive or insensitive.„  ?„  ?"  Further, this program will look for words that are adjacent if they are„  ?"  grouped by quotes (with "q$" ' ` and ~ serving as different types of quote„  ?"  symbols).  The symbols "q$" and ~ preserve the enclosed upper and lower„  ?"  case letters; any other quote symbol implies that either case will match.„  ?"  Groups must start and end with same quote symbol.  Words that are not„  ?"  enclosed by quotes must be within approximately a 64-character limit of„  ?"  each other to be considered valid, and in the same order as entered.„  ?„  ?"  All non-viewable characters are reduced to a single space separation„  ?"  between words for matches and for display purposes, unless you include„  ?"  /CR parameter(s), in which case the carrage return and line feed codes„  ?"  are also considered during matches.  Quotes will preserve spacing.„  ?„  ?"  Using /S means scan subdirectories as well, and -1 means skip scanning„  ?"  the parent or current directory; only do subdirectories.  A /F<filename>„  ?"  and /P means write results to file <filename> and/or printer, respectively.„  ?„  ?"  Example:  ft dim 'is huge'   -- this would search for every file that had„  ?"  the word "q$"dim"q$" and group "q$"is huge"q$", in either case, and in that same order.„  goto abort„end if„view text (1,1)-(80,24)„if right$(cd$,1)<>"\"then cd$=cd$+"\"„cd$=cd$+chr$(0)„if filename$>"" then open filename$ for append as #2„if printer then open "LPT1:" for output as #3„do„resweep:„  if cd$="" then exit do„  a=instr(cd$,chr$(0))„  cdir$=left$(cd$,a-1)„  cd$=mid$(cd$,a+1)„  bd$=""„  b$=dir$(cdir$+"*.*",23)„  do while b$>""„    bd$=bd$+b$+chr$(0)„    b$=dir$„  loop„  do while bd$>""„    a=instr(bd$,chr$(0))„    if a=0 then goto resweep„    b$=left$(bd$,a-1)„    bd$=mid$(bd$,a+1)„    if sweep then„      color 14,1„      locate ,1„      ?space$(8)cdir$space$(80-pos)„      color 15,1„    end if„    select case inkey$„    case ""„    case chr$(3)„      goto abort„    case chr$(27)„      do„        select case inkey$„        case ""„        case " "„          exit do„        case chr$(3)„          goto abort„        case else„        end select„      loop„    case else„    end select„    bad=0„    on error goto override„    open cdir$+b$ for input as #1„    on error goto 0„    close 1„    if bad then„      if bad=75 and sweep then cd$=cd$+cdir$+b$+"\"„      iterate do„    end if„    if down1 then iterate do„    open cdir$+b$ for binary as#1„    if lof(1)=0 then„      close 1„      kill b$„      iterate do„    end if„    row=csrlin„    col=pos„    view text (1,1)-(80,25)„    locate 25,1„    color 14,1„    ?cdir$b$space$(80-pos);„    view text (1,1)-(80,24)„    locate row,col,1„    if found and pos>1 then„      ?„    else„      locate ,1„    end if„    color 15,1„    ?b$"...";„    col=pos„    ?space$(16-pos);„    locate ,col,1„    e$=space$(25)„    a=0„    found=0„    do while seek(1)<lof(1)„      select case inkey$„      case ""„      case chr$(3)„        goto abort„      case chr$(27)„        do„          select case inkey$„          case ""„          case " "„            exit do„          case chr$(3)„            goto abort„          case else„          end select„        loop„      case else„      end select„      if len(e$)<longb or len(e$)<80 then„        if seek(1)+2048>lof(1)then„          d$=space$(lof(1)-seek(1))„        else„          d$=space$(2048)„        end if„        get 1,,d$„        e$=e$+d$„      end if„      ! mov ax,e$„      ! push ax„      ! call GetStrLoc„      ! or   cx,cx„      ! jz   loopa0„      ! mov  bx,carret„      ! push ds„      ! mov  ds,dx„      ! mov  si,ax„      ! mov  es,dx„      ! mov  di,ax„      ! xor  dx,dx„      ! xor  ah,ah„      ! cld„loopa1:„      ! lodsb„      ! cmp  al,32„      ! jge  loopa2„      ! or   bx,bx„      ! jz   loopa2a„      ! cmp  al,10„      ! je   loopa4„      ! cmp  al,13„      ! je   loopa1a„      ! cmp  al,12„      ! jne  loopa2a„loopa1a:„      ! mov  al,10„loopa2:„      ! cmp  al,123„      ! jl   loopa4„loopa2a:„      ! mov  al,32„loopa3:„      ! cmp  al,ah„      ! jne  loopa4„      ! cmp  al,32„      ! je   loopa5„loopa4:„      ! mov  ah,al„      ! inc  dx„      ! stosb„loopa5:„      ! loop loopa1„      ! pop  ds„      ! mov  cx,dx„loopa0:„      ! mov  b,cx„      e$=left$(e$,b)„      if len(e$)<longb and eof(1)=0 then iterate do„      f$=lcase$(e$)„      a=0„      b=25„      c=0„      d=0„      for j=1 to i„        if b(j) then„          b=instr(b+1,e$,a$(j))„        else„          b=instr(b+1,f$,a$(j))„        end if„        if b=0 then exit for„        if b>d then d=b„        if c=0 or b<c then„          if a=0 or c<a then a=c„          c=b„        elseif b<a then„          a=b„        end if„      next„      if c=0 then„        c=len(e$)=longb+1„        if c<longa then c=len(c$)-longa+1„        if c<2 then c=len(e$)+1„        e$=mid$(e$,c-25)„        iterate do„      end if„      if a<=c then a=c+1„      if d-c>60 or j<=i then„        e$=mid$(e$,a-25)„        iterate do„      end if„      if found=0 then„        locate ,1„        found=-1„      elseif pos>1 then„        ?„      end if„      f$=mid$(e$,c)„      ! mov  ax,f$„      ! push ax„      ! call GetStrLoc„      ! or   cx,cx„      ! jz   loopb0„      ! mov  bx,carret„      ! push ds„      ! mov  ds,dx„      ! mov  si,ax„      ! mov  es,dx„      ! mov  di,ax„      ! xor  dx,dx„      ! xor  ah,ah„loopb1:„      ! lodsb„      ! cmp  al,ah„      ! jne  loopb2„      ! cmp  al,32„      ! je   loopb3„loopb2:„      ! mov  ah,al„      ! inc  dx„      ! stosb„loopb3:„      ! loop loopb1„      ! pop  ds„loopb0:„      ! mov  b,dx„      f$=rtrim$(left$(f$,b))„      if carret then replace chr$(10) with " " in f$„      g$=mid$(e$,c-25,25)„      ! mov  ax,g$„      ! push ax„      ! call GetStrLoc„      ! or   cx,cx„      ! jz   loopc0„      ! push ds„      ! mov  ds,dx„      ! mov  si,ax„      ! mov  es,dx„      ! mov  di,ax„      ! xor  ah,ah„      ! xor  dx,dx„      ! cld„loopc1:„      ! lodsb„      ! cmp  al,32„      ! jle  loopc2„      ! cmp  al,123„      ! jl   loopc3„loopc2:„      ! mov  al,32„loopc3:„      ! cmp  al,ah„      ! jne  loopc4„      ! cmp  al,32„      ! je   loopc5„loopc4:„      ! inc  dx„      ! mov  ah,al„      ! stosb„loopc5:„      ! loop loopc1„      ! pop  ds„      ! mov  cx,dx„loopc0:„      ! mov  b,cx„      rset g$=left$(g$,b)„      g$=mid$(g$,15)+f$„      f$=space$(64)„      mid$(f$,1)=g$„      ?b$":"space$(16-pos)f$„      if filename$>"" then ?#2,b$":"tab(16)f$„      if printer then ?#3,b$":"tab(16)f$„      mid$(b$,1)=space$(len(b$))„      e$=mid$(e$,c+32)„    loop„    close 1„    down1=0„  loop„loop„row=csrlin„col=pos„view text (1,1)-(80,25)„locate row,col,1„?„?"Done."space$(80-pos)„abort:„close„chdrive left$(hd$,2)„chdir hd$„if pos>1 then ?„end„„override:„bad=err„resume next„„FUNCTION GetPSP% LOCAL PUBLIC„  REG 1, &H62*256     ' set AH to 62h„  CALL INTERRUPT &H21 ' call DOS services„  GetPSP% = REG(2)    ' PSP segment is returned in BX„END FUNCTION„Donald R. Darden               PATTERN MATCHER                oldefoxx@earthlink.net         06-11-99 (17:03)       PB                     810  35582    PATTERNS.BAS$if 0„PATTERNS.BAS   by Donald R. Darden, (c) 1999„Offered as FREEWARE SNIPPIT CODE  -- Sample Code that may be of value in„creating higher-level processes.  The format is:„„        DEMO CODE - calls the related sub or function„„        SUB OR FUNCTION - demonstrates a particular feature„        The CODE within a SUB or FUNCTION consists of one or two sections:„„           Section One:  A PowerBASIC approach to the problem„„           Section Two (if present):  An enhanced ASM solution as well„„           Note:  if Section Two is present, there will be timing code„           to demonstrate the relative speed of the two approaches.„           Since only one section is actually needed, you can comment„           out the unneeded section or delete it.  The advantage of the„           PowerBASIC section is that it is easily customizable.  The„           ASM section usually has the advantage of speed, and it also„           demonstrates some of the constructs of creating inline code„           in PowerBASIC.„„           *** OF SPECIAL NOTE: *** When adding ASM (Assembler) code to„           PowerBASIC where you will be exchanging values between the„           Assembler registers and PowerBASIC variables, you MUST DEFINE„           all interger variables with a DEFINT a-z (or whatever leading„           letters are used) as being the default type INTEGER.  This is„           because PowerBASIC's inline assembler does not recognize any„           type except itergers, and you will have difficulties in passing„           a value with a mov <var>,ax, or a mov ax,<var> command.  You„           CAN reference other types, but you will have to use an offset„           pointer to the memory location and possibly add a constant like„           so:  mov ax,word ptr a[0] for the lower two bytes, and mov ax,„           word ptr a[2] for the upper two bytes.  In this case we are„           assuming that a is a LONG variable.  But the inline assembler„           only recognizes the string ($) identifier, specifically for„           passing the PowerBASIC string allocated handle for use with„           internal procedures (use F1 for HELP on these procedures).„           You cannot include other types, such as a%, a?, a!, or a#, and„           have the assembler accept them.  SO MAKE SURE YOU INCLUDE A„           DEFINT A-Z (or specific leading letter group for the veriables„           you intend to use with the inline assembler) if you decide to„           include inline assembler code in your program.„„Concerning the measurement of time:  The timer updates approximately 18.2„times a second, meaning that time measurements are relatively course using„timer references via any BASIC version. The integer portion of the time only„updates once every second.  Due to the slight inaccuracies in the timing„mechanism, most documentation indicates that the update is every 1/18ths of a„second and lets it go at that.  The timer is reset at midnight, or by a„restart of the computer.  So to measure time, you have to note its initial„setting, which is what the sub STARTTIME does, and then calculate the„difference when you stop, which is what the function MARKTIME does.„„Most processes are far too fast on a modern PC to get effective measurements„this way, and consequently, most serious programmers look for some other„method to mark the passage of time.  There are other processes that„can be supported by drivers or TSRs.  Some of the most common are:„„(1)  Speed up the timer. This can have a major impact on how frequently„other chained processes are polled, and how much time they regards as having„elapsed.  It would normally make your realtimeclock (RTC) reference be off„as well, because it would update too fast.„„(2)  Install a driver to monitor the video card's horizontal or vertical„retrace signals.  The vertical retrace usually ranges from 60 Hz (cycles„per second) to as high as 90 Hz, depending upon the mode of operation and„the type of video card installed.  The horizontal rate is hundreds to times„higher than that, based on the vertical resolution of the screen and the„vertical retrace rate, as well as whether it is in interlace mode, or for„better quality monitors, non-interlace (NI) mode.  For a non-interlace„mode that supports a 640x400 (horizontal to vertical) resolution in non-„interlace mode with a refresh rate to 72 Hz, the horizontal rate would be„72*400, or 28,880 horizontal retraces per second.  For an interlace mode,„the horizontal refresh rate would be exactly half that rate.  This is fast„enough to mean that a relatively slow processor could not adequately„interface between retraces.  It is also probably a lot faster than any„application really requires, except for software timing loops to test the„efficiency of code.  So most often, this method is limited to use with the„vertical retrace signal, which is still fast enough to have a person "see"„continuous activity without evident pauses.„„(3)  A third method is a variation on the first:  Speed up the clock, then„tick off how many times it attempts to update before allowing the ticks to„filter through to other processes.  For instance, raise the tick rate to„91 ticks a second (five times normal), then only allow every 5th tick„through to the downstream process (back to 18.2 ticks per second for their„processes).  You could do this for any multiple of 18.2, but you should keep„the rate near the low end to prevent the results from overstimulating the„background activity in your machine.  Processes like this steal CPU cycles„away from other activities, so you want to use some judgement here.„„(4)  There are also other means, some very creative, for establishing a„faster timer function for game updates and real time activities, but they„are not covered here.  This is just to indicate that if you want tighter or„more accurate timing measurements than BASIC generally provides, you will„have to look at adopting such techniques yourself -- but be warned:  they„often call for a lot of research into different computer environments and„a comparison of fast time to normal tick time to establish a usable ratio„to keep activities from being either too fast or too slow on a given PC.„„If you want to master tricks like this, Read a programmers' reference„book on DOS for more information on how to access and use the video port„and/or BIOS/DOS-supported interrupts.  Or get comfortable with real-time„game development software.  The INT86 library that comes on the PBXtra„CDROM is also a great reference.„„$endif„„DECLARE FUNCTION GetStrLoc(BYVAL AllocHandle%) AS LONG„defint a-z        'REQUIRED for including inline assembler code„dim marker as single                  'we use this for keeping time„q$=chr$(34)„color 15,1„cls„?„?"PATTERNS.BAS, by Donald R. Darden, offered as FREEWARE, 1999„?„?" There is a program devoted to giving you some nifty functions and subs that„?" can be used in your own program development.  Basically, these demonstrate„?" different ways in which you can prepare text to be scanned in a Pattern„?" Matching fashion.  These are processes you can do in any BASIC, but have„?" been optimized for use in PowerBASIC.  You can build your own applications„?" around the examples here.„?„?" If you are not familiar with the idea of pattern matching, then suppose„?" I show you a pattern of "q$"99:99:99"q$", and say that the 9's could be any„?" digit, what is this?  You should be able to say, "q$"Why, that probably shows„?" an hour, minute, and second, right?"q$", and of course you would be right.„?„?" Then if I should you a group that was "q$" Aaa 99, 9999 "q$", and said that the„?" capital A represents an upper case letter, and the small a represents a lower„?" case letter, and everything except the 9's is unchanged, what is this?, you„?" might say, "q$"It's a date, right?"q$".  Now you understand pattern matching.„?„?" It's a technique used to find information within text or fields using computer„?" software by not having to look for every combination of specific data -- we„?" don't need to search for all combinations of Jan, Feb, Mar, Apr, May, Jun„?" Jul, Aug, Sep, Oct, Nov, Dec, and every possible day combination from 1 to„?" 31, as well as every year from 1980 to 2020, to identify a date field now .„sleep„cls„?„?" Of course there are variations that you have to allow for, such as also being„?" able to match on "q$" 9:99 aa "q$" which might be 4:05 pm, or something else„?" entirely.  And a "q$" AAA 9, 99 "q$" could also be a date reference.  So„?" you may have to break up your pattern matching efforts into smaller groups„?" to allow for this type of problem.  But then other patterns become possible„?" as well.  For instance, you could write a pattern creator that allows only„?" certain changes to happen such as for a date, it would correspond to "„?" "q$" AAA 9, 99"q$".  This might mean "q$"One or more spaces, followed by three or more„?" letters, followed by one or more digits, followed by a comma, followed by one„?" or more spaces, followed by two or more digits"q$".„?„?" As it happens, I first thought to challenge someone else to do this, but it„?" looked interesting and useful enough that I took an hour to work it out„?" myself. So you now have the benefit of another useful function which I„?" named DeltaPattern$() in this package as well.„?„?" There are a lot of details and efforts to compare ways to modify and use„?" the supplied routines, as well as an effort to show just how fast they„?" really are.  Unfortunately, timer accuracy is not a strong suit for PCs,„?" DOS, or BASIC, so the times used to attempt to show relative speed of the„?" different routines may not do much (for more information on how to get„?" better timing done in your program, scan the comments in this program that„?" have been included for off-line viewing).„sleep„cls„?„?" If you still don't understand quite how to use a pattern process, this„?" may help:  You must actually change the original text using the pattern„?" process, but you must also keep a copy of the original text to go back to„?" after you find the pattern, so that you can use the original data from„?" it.  The last example (sequences of characters) is particularly hard to„?" do, cause the 1-to-1 correlation in character position is changed. So„?" you probably would need an array to track positional changes between the„?" different start positions in the original and the pattern version,„?„?" Well, now we are ready to run the Demo.  This just takes the DESPACE$()„?" functions that are provided and attemps to compares the time it takes for„?" each different approach to get the job done.  One way involves Assembler„?" code, and when written efficiently, this should always be the fastest and„?" smallest executable approach.  But as you will see, variations that just„?" use PowerBASIC statements are also very fast, meaning you don't have to be„?" an assembler programmer to make this stuff happen.  You just have to think„?" the problem through and find an effective way to do the task in hand.„?„?" After DESPACE (de-space) is run each way, the results of the last run are„?" shown to demonstrate what it does.  Now there are several other functions„?" in PATTERNS that will allow you to try other things, or combinations of„?" things.  And of course, you can reuse the routines elsewhere, or just„?" study them to help you in your own future development efforts.„sleep„cls„?" Now when you are ready, press any key and the Demo of DESPACE$() will run.„sleep„a$="  This  is    a   test of    DESPACE    "„b$=despace$(a$)„?„?"Original line surrounded with double-quotes:"„?chr$(34)a$chr$(34)„?"Resulting line surrounded with double-quotes:"„?chr$(34)b$chr$(34)„sleep„cls„?„?"DEMO version of PATTERNS by Donald R. Darden, (c) 1999„a$="This is a test string for the Pattern process begun on "+date$+" "+time$„?„?a$„?„b$=pattern$(a$)„?„?"Results of test:"„?a$„?b$„sleep„cls„a$="Jan and Marge, now 12 and 13, at 2112 Jay Court, will give a joint birthday party" + _„   " on September 23, 1999."„b$=" AAA 9, 99"„?„?"Now a more sophisticated pattern matching tool:  DeltaPattern()„?„?" Looking for a possible date and position in a string using a variable-„?" length pattern specified by a second string, using DeltaPattern():„?„?" String to be searched:"„?q$a$q$„?„?" Date pattern being sought:  "q$b$q$„?„„a=deltapattern(1,a$,b$)„if a=0 then„  ?"Could not find a valid date format in "a$„  end„end if„?"DeltaPattern returns a pointer to where the specified pattern starts:„?„?q$a$q$„locate csrlin,a mod 80+1„?chr$(179)„?tab(a+1)chr$(212)" right here"„sleep„cls„?„?"Patterns recognition is incredably important when it comes to generalizing„?"theories from sample data.  Now it should be evident that reversing the„?"process allows us to use the general case to quickly find the specific„?"information involved.  And as we find more specific cases that do not fit,„?"we extend the pattern, whereas when all data fits, we can refine the„?"pattern.  This is known as getting smarter.„?„?"This task of using patterns is one that computers are well suited to, but„?"most computer languages are not.  Next would be to teach computers how to„?"relate specific data samplings to each other and find the best patterns to„?"fit.  Then you have computers that are able to begin building their own„?"languages and tools, and even to postulate their own theories.  However,„?"computers are not conscious, meaning I do not forsee an era where they,„?"of their own violation, become rivals to living things, including Man.„?„?"My definition of a proof:  The process of taking an abstract conjuecture„?"and sucessfully subjecting it to the rigors of deductive reasoning.„?„?"Please note:  98% of this program is just stuff I added - comments, print„?"statements, notations, things to try and put this whole thing into some„?"sort of perspective and make it more useful to you.  Strip that out, and„?"what's left will fit into your own code quite nicely.  Good Luck!„end„„Function pattern(aa$)static as string 'Converts AlphaNumerics to A, a, or 9„$if 0„„PATTERN converts a string into specific symbols to simplify groups-of-„characters recognition.  For instance, guess what this group might„represent:  99/99/99.  Or this group:  Aaa 9, 9999.  Or this group:„9-999-999-9999.  Or even this group:  999-99-9999.  If you guessed date,„date, phone number, and social security number, then you can see where„much of essential data in our lives correspond to some understood format.„That is what pattern helps you find.  PATTERN converts A through Z to a„capital "A", lowercase "a" through "z" to a lowercase "a", and digits„0 through 9 to a "9".  Everything else remains the same.„„$endif„„'Section One:  The PowerBASIC version...„starttime "Testing PATTERN using PowerBASIC REPLACE Command..."„a$="012345678BCDEFGHIJKLMNOPQRSTUVWXYZbcdefghijklmnopqrstuvwxyz"„b$="999999999AAAAAAAAAAAAAAAAAAAAAAAAAaaaaaaaaaaaaaaaaaaaaaaaaa"„c$=aa$„replace any a$ with b$ in c$„function=c$„'------------------------ end of section one --------------------------------„a!=marktime„„'============== Section Two:  The enhanced ASM version: =====================„„starttime "Testing PATTERN using ASM approach..."„'--------------------------- end of section two -----------------------------„b!=marktime„a$=AsmPattern$(aa$)„?"Pattern results";„if a$<>c$ then ?" DO NOT";„?" Match."„if a!>b! then„  ?"PowerBASIC took longer."„elseif a!<b! then„  ?"ASM took longer."„else„  ?"Times were the same within the limits of the measurements done."„end if„?"Inherantly, the ASM approach should be faster for very large strings or when„?"handling a large number of strings."„end function                   'and we're done„„function AsmPattern(aa$)static as string„local a$„a$=aa$„! mov  ax,a$                   ;put PowerBASIC string handle for a$ in ax„! push ax                      ;put string handle on stack for GetStrLoc„! call GetStrLoc               ;PowerBASIC function to return DX:AX pointer„! or   cx,cx                   ;returned # chars in A$ in CX, check for nil„! jz   xpattern                ;if no chars, we're outta here!„! push ds                      ;work to do, hold ds on stack for later„! mov  ds,dx                   ;move DX -> DS for LODSB reads using DS:SI„! mov  si,ax                   ;move AX -> SI for LODSB reads using DS:SI„! mov  es,dx                   ;move DX -> ES for STOSB writes using ES:DI„! mov  di,ax                   ;move AX -> DI for STOSB writes using ES:DI„! cld                          ;clear direction flag so SI and DI increment„pattern1:                      'loop point to read/write all of a$ bytes„! lodsb                        ;load current DS:SI byte -> al, increment SI„! cmp  al,90                   ;compare al to code for "Z"„! jg   pattern3                ;if > "Z", go check for a-z instead„! mov  ah,65                   ;put code for "A" in ah„! cmp  al,ah                   ;compare to code for "A"„! jge  pattern4                ;code ranges from "A" to "Z", go replace„pattern2:                      'if < "A" so check for 0-9„! mov  ah,57                   ;put code for "9" in ah„! cmp  al,ah                   ;see if between "9" and "A"„! jg   pattern5                ;greater than"9", so go use original byte„! cmp  al,48                   ;compare to code for "0"„! jge  pattern4                ;if >= "0", go replace with code for "9"„! jmp short pattern5           ;jump to where we use the original code„pattern3:                      'here we check for "a" to "z"„! cmp  al,122                  ;compare to code for "z"„! jg   pattern5                ;if > "z", go use original code„! mov  ah,97                   ;put code for "a" in ah„! cmp  al,ah                   ;compare to code for "a"„! jl   pattern5                ;if < "a", go use original code„pattern4:                      'merge point to replace original code„! mov  al,ah                   ;copy replacement code into al„pattern5:                      'merge point to use original code„! stosb                        ;store al-> address at ES:DI, increment DI„! loop  pattern1               ;if CX<>0, decrement CX and jump to pattern1„! pop   ds                     ;restore ds for use by PowerBASIC„xpattern:                      'this is where we got outta here to„function=a$                    'we return the modified local string„end function„„function deltapattern(offset,somestr$,dpattern$) static as integer„$if 0„„DeltaPattern calls AsmPattern, which is actually a subpart of the PATTERN„function which represents an Asm code approach to doing pattern.  We just„stripped out the specific code and put it into AsmPattern$() to support its„use by this function as well.„„DELTAPATTERN (Delta Pattern) is the most sophisticated and complicated„pattern matching routine included in PATTERNS.  In effect it uses sort of a„variable width pattern for alpha characters (which are all treated as„uppercase), for any groups of digits, and for "white" spaces (this term is„used to refer to all non-printable characters).  So if the pattern being„checked has an "A" in it, it will be satisfied by any size group of letters, from„"A" to "zed".  If there is a "9", than any group of digits from "0" to„"9999999999"  It also treats all "white" white spaces, so a carriage„return, line feed, tab, form feed, and other non printable characters tha„occur in text are covered by including as single space (" ").„„Suppose you want to search for a valid date, and the pattern you elect to„use is " AAA 9, 99".  Try matching this to "Jan and Marge, now 12 and 13,„will give a joint birthday party on September 23, 1999.".  Typically, most„pattern matching process would have a difficult time not picking up Jan 12„1999, or picking up Mar 13, 1999 instead.  But deltapattern will zero right„in on the fact that the only pattern match here begins with the space„before September, even though we only indicated " AAA " at the start of our„pattern.  But this indicated one or more white spaces followed by 3 or„more letters grouped together followed by one or more white spaces, and so„on, until each group was identified in sequence.„„Calling deltapattern is simple:„„a$="Jan and Marge, now 12 and 13, will give a joint birthday party" + _„   " on September 23, 1999.""„b$=" AAA 9, 99"„a=deltapattern(1,a$,b$)„if a=0 then„  ?"Could not find a valid date format in "a$„  end„end if„„Using datapattern results is also easy:„„b$=ucase$(AsmPattern$(a$))„a=instr(a+1,b$,"A")„month$=mid$(a$,a,3)„select case month$„case "JAN","FEB","MAR","APR","MAY","JUN"„case "JUL","AUG","SEP","OCT","NOV","DEC"„case else„  ?"Month "month$" is invalid."„  end„end select„a=instr(a+1,b$,"9")„day=val(mid$(a$,a))„select case day„case 1 to 31„case else„  ?"The"day"is invalid."„  end„end select„a=instr(a+1,",")„a=instr(a+1,"9")„year=val(mid$(a$,a))„select case year„case 1980 to 2020„case else„  ?"The"year" is invalid."„  end„end select„„Normally, in free form data, you have an issue with whether any specific„data can be found without analyzing every possible group as to having a„specific content.  If you found 3 or more characters, you would have to„check them to see if they matched to JAN, Jan, FEB, Feb, MAR, Mar, etc.„That is a lot of testing.  If you did it without skipping smartly over„spaces, you would scan something  like "... on September 23, 1999" the hard„way:„„Scans using a 3-character window for "... on September 23, 1999"„# 1                                   [...]    - check for Sep, no match„# 2                                    [.. ]       "    "    "     "    "„# 3                                     [. o]      "    "    "     "    "„# 4                                      [ on]     "    "    "     "    "„# 5                                       [on ]    "    "    "     "    "„# 6                                        [n S]   "    "    "     "    "„# 7                                         [ Se]  "    "    "     "    "„# 8                                          [Sep]     - found Sep, get day„# 9                                           [ept]         - not a valid day„# 10                                           [pte]        - not a valid day„# 11                                            [tem]       - not a valid day„# 12                                             [emb]      - not a valid day„# 13                                              [mbe]     - not a valid day„# 14                                               [ber]    - not a valid day„# 15                                                [er ]   - not a valid day„# 16                                                 [r 2]  - not a valid day„# 17                                                  [ 23]    - possible day„# 18                                                   [23,]   - got day 23„„if you had put in September 3, 1999 instead, the 18th step would have also„had to check for a match on [ 3,], or narrow its window to two characters.„And note that this approach would also have to check all other possibilities„as well:  [ 1,], [ 2,], [ 3,], [ 4,] ... [28,], [29,], [30,], and [31,].„„So far, a lot of steps, and we haven't even gotten to the year yet.  And of„couse you wound not want to do this for every month, every day of every„month, and every valid valid month and day in every valid year -- we would„never get it all done this way!„„Working smartly means you can greatly simplify a lot of tasks by first„turning the data into patterns and start with analysing those, rather than„trying to jump right in by focusing too soon on the specific data at hand.„We used datapattern() to identify where each field started, then we just„went to the start point of each unique part of the pattern for check for the„specific data there to see if it was valid.  So far so good, and it was„both quick and easy.  To do the job properly, we would then have to rule out„any invalid combinations.  For instance, there is no year 0, or February 30,„or September 31, and there is no February 29th except during leap years,„and not every 4th year is a leap year.  In fact, years evenly divisible by„4 are leap years unless they are also evenly divisible by 100 (most century„years (1700, 1800, 1900, etc.) are not leap years, unless again they are„evenly divisible by 400 (the century years 1200, 1600, 2000 are examples of„valid leap years).  This can be expressed with a simple boolean expression:„„leapyear=((year mod 4)=0)-((year mod 100)>0)+((Year mod 400)=0)„„leapyear will be -1 only if it is a valid leap year.„„$endif„„if dpattern$="" then„  function=0„  exit function„end if„aa$=AsmPattern$(somestr$)  'We work from an initial pattern of course„aa$=ucase$(aa$)    'add this if you want letters to match regardless of case„ab$=dpattern$„ac$=left$(ab$,1)„select case ac$„case "a","9"," ","A"    'remove "A" if you want 1-to-1 for any capitals„                   'remove "a" if you want 1-to-1 for any lower case letters„                   ' for instance, remove "A" and leave "a","9"," " would„                   ' then match for leading capital words like "Last" if you„                   ' used a pattern of "Aa"„  for a=2 to len(ab$)„    if mid$(ab$,a,1)<>ac$ then exit for„  next„  decr a„  ad$=left$(ab$,a)„case else„  ad$=ac$„end select„a=offset„do„  a=instr(a+1,aa$,ac$)„  if a=0 then exit do„  select case ac$„  case "A","9"," "„    for b=a+1 to len(aa$)„      if mid$(aa$,b,1)<>ac$ then exit for„      'change this to:  "if mid$(lcase$(aa$),b,1)<>ac$ then exit for" if„      'want to match on first groups that start with a capital, but which„      'may also have additional capitals in them, such as MacDougal, McCloud„      'or O'Brien.  Note that O'Brien won't match unless you classify the„      '(') as an alpha character.  You may also have to do this for the„      'hyphen (-) and period (.) when checking for patterns in names.  You„      'might encounter something like "MacDougal-Turner, Chas." someday.„      'You can easily replace one pattern symbol with another.  Use REPLACE„      'any "-." with "aa" in <pattern$>.  This does not disturb the original„      'text on which the pattern was based, which you can revert to later.„    next„   case else„    b=a+1„  end select„  ae$=mid$(aa$,b,1)„  c=len(ad$)+1„  if ae$=mid$(ab$,c,1)then„    'the suggestions given above can also be extended to the lines below„    'if you want to have upper and lower case letters mixed together in the„    'subsequent groups.  Not applying the same rules below means that you„    'will have one (or more) capitals as additional groups and one (or more)„    'lowercase letters seen as additional groups, even though they adjoin„    'each other.  For instance, without the same changes, "Keith R. D'angelo"„    'would appear to fit the following pattern group: "Aa A. A'a".  It would„    'not match the standard pattern for First M. Last, which would be„    '"Aa A. Aa".  You can of course employ multiple patterns, but then you„    'are getting back into the game of dealing with specific data.  But here„    'are a few patterns you could try, and one advantage is that since most„    'names follow the norm, it could be quite a bit faster going this way:„    '      "Aa, Aa A."        Norm pattern (Last, First M.)„    '      "A'A, Aa A."       for O'Brien, D'Angelo (not D'angelo) & company„    '      "A'a, Aa A."       for people who don't known when to capitalize„    '      "AaAa, Aa A."      for McCloud, LaFrance and MacDougal„    '      repeat the above without the period after A. for people having„    '                          middle initials but no middle names„    '      repeat the above without the " A." for people with no middle„    '                          initial or name„    '      "Aa AA, Aa A."     for JR, SR, II, IV, or VI after the last name„    '      "Aa AAA, Aa A."    for III after the last name„    'As you can see, this can begin to get very messy fast.  So adding a„    'bit of code at the core of the pattern process can really make life„    'a lot simpler at the higher levels of your program.„„    do while c<=len(ab$)„      select case ae$„      case "a","A","9"," "„        for d=c to len(ab$)„          if mid$(ab$,d,1)<>ae$ then exit for„        next„        af$=mid$(ab$,c,d-c)„      case else„        af$=ae$„        d=c+1„      end select„      if mid$(aa$,b,len(af$))<>af$ then goto incra„      select case ae$„      case "A","9"," "„        for b=b+len(af$) to len(aa$)„          if mid$(aa$,b,1)<>ae$ then exit for„        next„      case else„        incr b„      end select„      c=d„      ae$=mid$(ab$,c,1)„    loop„    exit do„  end if„incra:„loop„function=a„end function„„„sub starttime(testname$) static„?"Beginning of "testname$"..."„shared marker!„marker!=timer„do„loop while marker!>=timer„marker!=timer„end sub„„function marktime static as single„shared marker!„do„  aa!=timer-marker!„loop while aa!<0„ab$=using$("##:",aa#\3600 mod 24)+using$("##:",aa#\60 mod 60)+ _„    using$("##",aa# mod 60)+"."+using$("####",aa#*10000+.5 mod 10000)„replace " " with "0" in ab$„?"Lapsed Time: "ab$„function=aa#„end function„„function despace(aa$)static as string„local a,b,a$,b$„$if 0„„DESPACE converts TABs to SPACE codes and removes all duplicate spaces from„a string.  It does NOT remove the leading and trailing space that may be„in the string, since these may be important during the subsequent parsing„or combining of strings.  However, additional code is included to show„how to modify the function so that it either deletes trailing spaces,„or both leading and trailing spaces, as desired.„„$endif„'================== Section One: PowerBASIC Methods: =======================„'Method 1:  Using simple REPLACE process: ----------------------------------„?„starttime "DESPACE PowerBASIC Method 1:"„a$=aa$„replace chr$(9) with " " in a$„do while instr(a$,"  ")„  replace "  " with " " in a$„loop„function=a$„marktime„'exit function            'un-comment in order to not use remaining methods„'end of method 1 ----------------------------------------------------------„'Method 2:  Improving REPLACE by adding an INSTR pointer: -----------------„?„starttime "DESPACE PowerBASIC Method 2:"„a$=aa$„replace chr$(9) with " " in a$„a=0„do„  a=instr(a+1,a$,"  ")„  if a=0 then exit do„  a$=left$(a$,a)+ltrim$(mid$(a$,a+1))„loop„function=a$„marktime„'exit function            'un-comment in order to not use remaining methods„'end of method 2: ---------------------------------------------------------„„'Method 3:  Building a new String using INSTR pointers: -------------------„?„starttime "DESPACE PowerBASIC Method 3:"„a$=aa$„b$=""„a=0„replace chr$(9) with " " in a$„do„  b=instr(a+1,a$,"  ")„  if b then„    b$=b$+mid$(a$,a+1,b-a-1)„    a=b„  else„    b$=b$+mid$(a$,a+1)„  end if„loop while b„function=b$„marktime„'exit function            'un-comment in order to not use remaining methods„'end of method 3: ----------------------------------------------------------„„'Method 4:  Building a new string at the left end of the old string: -------„?„starttime "DESPACE PowerBASIC Method 4:"„a$=aa$„replace chr$(9) with " " in a$„a=1„b=len(a$)„do„  a=instr(a,a$,"  ")„  if a=0 or a>=b then exit do„  mid$(a$,a)=mid$(a$,a+1)„  decr b„loop„if right$(a$,1)=" " then incr b  'remove this line to delete training space„function=left$(a$,b)„marktime„'exit function            'un-comment in order to not use remaining methods„'end of method 4: ----------------------------------------------------------„„'Method 5: Building within string and using LTRIM$() for smart removal: ----„?„starttime "DESPACE PowerBASIC Method 5:"„a$=aa$„b=len(a$)„a=1„do„  a=instr(a,a$,"  ")„  if a=0 or a>=b then exit do„  incr a„  b$=ltrim$(mid$(a$,a))„  mid$(a$,a)=b$„  b=b+len(b$)+a-len(a$)-(b$>"")„loop while b$>""„if b$="" then decr b„function=left$(a$,b)„marktime„'exit function            'un-comment in order to not use remaining methods„'end of method 5: ---------------------------------------------------------„'-------------------------- end of section one ----------------------------„„'==================== Section two: DESPACE using ASM code:=================„?„starttime "DESPACE Inline ASM Method:"„a$=aa$„a=0„! mov  ax,a$„! push ax„! call GetStrLoc„! or   cx,cx„! jz   xdespace„! push ds„! mov  ds,dx„! mov  si,ax„! mov  es,dx„! mov  di,ax„! xor  bx,bx„! xor  ah,ah                   ;change to mov ah,32 to remove leading spaces„! cld„despace1:„! lodsb„! cmp  al,9„! jnz  despace2„! mov  al,32„despace2:„! cmp  al,32„! jnz  despace3„! cmp  al,ah„! jz   despace4„despace3:„! mov  ah,al„! inc  bx„! stosb„despace4:„! loop despace1„'! cmp  al,32                   ;un-comment to keep a trailing space„'! jnz  despace5                ; "    "    "   "   "    "       "„'! dec  bx                      ; "    "    "   "   "    "       "„despace5:„! pop  ds„! mov  a,bx„xdespace:„function=left$(a$,a)„marktime„end function„„sub pause (reason)static„$if 0„The process allows you to insert an effective STOP into code that takes„effect only if the program is running.  An example for calling if from„withing your program might be PAUSE 250.  The number could also be used„as a lookup code for an error table, or whatever.„„In the IDE, it makes sence to put a breakpointon the ky$=inkey$ line.„This means that after pausing the execution, your next step will„automatically take you out of the loop and let you return to the point„in your program where you issued the pause 250 statement.  You can then„continue to single-step or run your program, which the STOP command does„not allow you to do.  This also overcomes an occasional "twitch" that„the IDE has where you can't continue properly after reaching the breakpoint,„or the breakpoint becomes dislodged by edits that happened to lines„previous to it.  I usually put the pause sub at the back end of my code to„make it easy to find, when I want to set or clear its breakpoint (just„<ctl><PgDn> to it), but you could also put it much higher and just use a„search to find SUB PAUSE or KY$=INKEY$.  That just takes a few more steps.„„Try this with this routine:  Call it with the demo code to see how it„normally works.  Also change the call to PAUSE 0 to see how it eliminates„the message to the screen.  Then try it both ways with the KY$=INKEY$„line marked with a breakpoint.  You can also set the watch to then scope„variable changes at that point, or further changes as you single step„through the remainder of the process.„„$endif„a!=timer+.125„if a!>timer then„  if a!>timer then„    b=1„    do„      a!=timer+.125„      ky$=inkey$„      if a!>timer then„        if b then„          ?"PAUSED, Reason ="reason„          b=0„        end if„      else„        b=1„      end if„    loop while ky$="" and b=0„  end if„end if„end sub„Alexander Podkolzin            EMS QUICK SORTING PROCEDURE    APP@nw.sbank.e-burg.su         06-23-99 (15:06)       PB                     127  3974     VS.BAS      '---------------------------------------------------------------------------„' EMS quick sorting procedure with demo.„' Quick sorting (non recursive) algorithm is from„' Ethan Winer's book "BASIC Techniques and Utilities".„' Thank you Ethan from all of us!„' Hope this program will be usefull for PB-programmers.„' Copyright status - PUBLIC DOMAIN.„'---------------------------------------------------------------------------„ $DIM ALL„ $COMPILE MEMORY„ %Ss = 512                         ' Max length of a string„ %Ascending  =  1„ %Descending = -1„'---------------------------------------------------------------------------„ Declare Sub VirtualSortString( _„         Txt() As String * %Ss, _„         Byval FirstElement As Integer, _„         Byval NumberOfElements As Integer, _„         Byval StartPosition As Integer, _„         Byval NumberOfPositions As Integer, _„         Byval Order As Integer _„         )„'---------------------------------------------------------------------------„ If Fre(-11) = 0 Then„   Print "EMS unavailable!"„   End„ End If„„ Dim i As Integer„ Dim n As Integer„ Dim q As Integer„ Dim s As string„„ Cls„ n = 1000„„ Dim Virtual x(1:n) As String * %Ss„„ ? "Filling array of" + Str$(n) + " random virtual strings...";„ ? "Done!"„ For i = 1 To n„   s = Using$("#####", Rnd(1, n))„   x(i) = Left$(s + String$( %Ss - 5, "A"), 80)„ Next i„„ ? "Before sorting (first and last elements):"„ ? Left$(x(1), 80);„ ? Left$(x(n), 80);„„ ? "Sorting...";„ VirtualSortString x(), 1, n, 1, 5, %Ascending„„ ? "Done!"„ ? "After sorting (first and last elements):"„ ? Left$(x(1), 80);„ ? Left$(x(n), 80);„ ? "----------------------"„ ? "Thanks to Ethan Winer!"„ End„„'---------------------------------------------------------------------------„ Sub VirtualSortString(Txt() As String * %Ss, _„                       Byval FirstElement As Integer, _„                       Byval NumberOfElements As Integer, _„                       Byval StartPosition As Integer, _„                       Byval NumberOfPositions As Integer, _„                       Byval Order As Integer)„„   Dim Temp As String„   Dim TempForSwap As String * %Ss„   Dim StackPtr As Integer„   Dim I As Integer„   Dim J As Integer„   Dim QStack(0) As Integer„   Dim LastElement As Integer„„   If NumberOfElements < 2 Then Exit Sub    'Nothing to sort„   LastElement = FirstElement + NumberOfElements - 1„„   Redim QStack(LastElement \ 5 + 10)„   StackPtr = 0„   Do„     Do„       Temp = Mid$(Txt((LastElement \ 2) + (FirstElement \ 2)), _„              StartPosition, NumberOfPositions)„„       I = FirstElement: J = LastElement„       Do„         If Order = 1 Then             'Ascending„           Do While Mid$(Txt(I), StartPosition, NumberOfPositions) < Temp„             Incr I„           Loop„           Do While Mid$(Txt(J), StartPosition, NumberOfPositions) > Temp„             Decr J„           Loop„         Else                          'Descending„           Do While Mid$(Txt(I), StartPosition, NumberOfPositions) > Temp„             Incr I„           Loop„           Do While Mid$(Txt(J), StartPosition, NumberOfPositions) < Temp„             Decr J„           Loop„         End If„         If I > J Then Exit Do„         If I < J Then„           TempForSwap = Txt(J)„           Txt(J) = Txt(I)„           Txt(I) = TempForSwap„         End If„         Incr I„         Decr J„       Loop While I <= J„       If I < LastElement Then„         QStack(StackPtr) = I„         QStack(StackPtr + 1) = LastElement„         Incr StackPtr, 2„       End If„       LastElement = J„     Loop While FirstElement < LastElement„     If StackPtr = 0 Then Exit Do„     Decr StackPtr, 2„     FirstElement = QStack(StackPtr)„     LastElement = QStack(StackPtr + 1)„   Loop„   Erase QStack„ End Sub„'---------------------------------------------------------------------------„Marius Andra                   DRAWING WINDOWS GUI            marius.andra@mail.ee           08-07-99 (13:54)       PB                     390  25828    DRAW.BAS    ' Drawing Windows for PowerBASIC, to extract DRAW.ZIP, Load/Run this in PB„DEFINT A-Z:SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"DRAW.ZIP",4^6:Z&=19072:?STRING$(50,177);„U"%up()%9%%%#-%O=m,LW.<e/,/%%%fT%%%-%%%%iw(f&Sg7fxf?q,BT1$j,XsL4*„U"\B)p9UlUua&G2q3;lr7GcSs>T2oGuL,YJQG]8%whw6YD87'#%I&X$+dAV9dhvJt„U"?8*4h'/07Z/xa&H4n_[H6bQ]o+()Z_Y^x9/v9QM5ZZ$bK+](BsWwl^D=KG_4,OV„U"4TVvB7JDcKG:XZ+sAf8Z/lK>fdZltDj2:0]Y-F;4ykG9DY/G;S11k?#$LC.+-Y\„U"T&j6H\:MtxY[_a;GS(Lt>NR'L$M^9']J-b74:k2^zj0kz9?*]l(34u4865?w^9/„U"(.C%L)CH&F]5,,gpd\(Tr&.?pAtY'cl9uoVL?.NSiDZEdZuc_=_+q:hsmj;X=S(„U"'OX0T&9)ErwoOVnEzU>&7m%S7CmsCSHqbh;bD^XWHA'_1wd&0Q'T/RAM'jbAoQr„U"kk%PMsb#u=3j\U[sm>xn515t_A%M,$k&)O9u<NB=5iruk7\yGE$-WNATV#.&*7-„U"dAR$]9$0A<ZNrzE:.Rk:c%/0wF5Yl2__kN_6dj]TtF#Y9Fup\HY3/*v9hpvF$-O„U"XTd^C'o4bo_6gfCA_E*h_t)ulMVB1)Vg<Sk6?&_F2jbIm#q&.WD=eZFA?3+axiV„U"(.SIVm^G1w&)5BG;naCdR2_3R?'V3/[G[.+d9zmx2I8p;L).-^Q2(,Cf/PH3X[s„U";q#('s&^_meBNW=,^rxHHB(o.0[DIs51KKWLHmY#DUTBk_5iTh:&)Q;3CmqaxZA„U":7Tr^NWIfD9xax*B3nj.Yc*fO?G=hrXbVr>LoxAoxDBj<$(G)uDnFvbn7Y;POtC„U"i)Gz9aa-2V.0dGj,owh=KCy.3k1Zv3rjnga.2z9IniR[Lb2AQIQmh6B14>;%.lh„U"Se9VCXX=7*XAk%3sF'Ae,>?46f%W(/qYpOQwJ/V4,KHeR#ACjg_6YJJNRsKV7n]„U":5$Lv*gQ<rn0rX6b.4wW%QsE=jvA1)LWjEN&Et/X*eoU)Cl7oX#_QvV7*O;'79a„U":Qq['LJJ)?$BXHk$\TYweoBi+D8Uk?M0AX_19P[Q5%MmG&GW;L8ucHSuF]o.#eU„U"B]Q5ne[1h,AsB[uQtQieKUEs-ZVC[4ygKGLFm^T8$53Dlo-0LuZ.,Ub4<+,&)FQ„U"q3RMZIEtR03K8zo:$r$:);&idonMI>pQC\INWfn<JpJ964ootK6^W#hBhF604Q>„U"1;(bnN=DJGhjmN(>IMY_qQ0bdt?#*_3r7&>?QxQ.&thhf3STuJU/_Q\/UIAWtwQ„U"S,Hp:L_AS&5(*Tn0d)4<sn>cThQqO_cV-m2tj=uJCtZE6(F'XTWF';\KlG's+QL„U"t)/k&6Iq'idbo1yde$0.t(N1?_RSDVYy]=6Bg'$f/nQ5EQWKj&*SGmH,nZh?pWS„U"mUX*bA#*R9d9]9Z7D9EF0w'^Kj\gA1#Mi$1bndELtQ+67EeU+PskAR)/,crC1kD„U"ajHj_G7hImh_,dnQ]PJsk.?[>_l&Jlh-OVxg)algU%#LF^I;4Hk[y4o=>s+Q0X.„U"&*9T*q$+B[3PsIl2VU;371wAY.G.Pf[dyar+j5SOYQW<Gx\]LJWtUnVg;KhbNt:„U"i8D_A(Q\h5.9Omq>SREVf&\Q*SdHSP37x4P5)VTL)),T'LT0mH5yPfQ4[-3raG/„U"w&e;AyOc02w0#5RP%qUqG*,$&[2M0vy3Gy3>oefM;a;TWtM;WQE0PRX()]hAfPe„U"k#c1,CGHW&TNpDN+Gp+c&SRc</*aR&V]iLdE[<Wg2bkt<YrS+UL#'.bD]Z64BEQ„U"U4)DP].6BBx>MZC[j?5(0GCLOW_cEc[W)85qgGT5>:;(X.MaXqqRtxFiBpP\C\y„U"BUiLV-P7DsJU(D5(AtP/r0k.W'^fl=xG2*7^/&93l+Eu<fW*_rg%.]>H&PVM3Ja„U"jeHm=ZR5:O+-vkm,S?OMK[vSTuO9U&6YbOW_UjEGN/$E4Qeje,N8<os%7iAB7n:„U"X+pwWTYeCrsB:N__2MPg/D.pECCloiCTpHA]S96?j:X6[>wf?+*jfPmqT4iTa)5„U"$)\?Y9V6[JBPh=YB_bqg)dWhJu$+Vk7rS*4;L?rU(l6uHZaw.-MDbX?1<6w;/'B„U"A1[6mKrcJ5%MF'b47;&'R\jCHnBYie+Q:g9_7cgslj'KK^%Q\Hv=Invm:%[[%2Z„U"StNYj7=U+I.>:pu8TWYgo&<\INv;qy1k;kT(u/Cb(:ZF_k(5f2thnk3BL+q':^F„U"t_xXo$BnYlbf52:2Z]'$u(A$&RJM:GMYfUWJdli+JEwR;X9_EN(5zRDi^'8OerZ„U"MuHYSx&R_(<z^Gw7J0(w*,XDbjrn>Mb6a^'8/&\Y0\&YQ?RI23GwQPDQiYD.wcI„U"YH^oh-k*.j-THKcM6>Sg\XBvfoqPm6t,Qo+0]090bw\m8gYlW&r[<sRS(4HcG]q„U"r:FDA?Ex719nTD7^,g0I<;NzeUY$q2TU9QXiH*JuT.e2T<YNUwyFzZ?+4s$AfZ#„U"ulg7])hx[fcGQaR9TI:BZuV6<5i,+><C6kYxbD=RKDiE$k).<$hW]nfG-fbr:k3„U"j9(>JNtV.zfY[L'>UT.RGR&ui%)H.Yj'53(OFqpLmeCf=>d3MRKw$/WauT[#)83„U"Jz*2N<L1O]CqW39<8<-G%Kat_xaBr4A_Cq('%(:/^/M1H\4OYBbf[nSSp62%y$U„U"=<1.[h_T\(t#ATgaYZ)'3u-CkRXh1#z5H#;Vj)YeZ8%Ugdg6d(-q)P#8%DO^j<J„U"D9.DjwE,6P=g'LjD5>owBnPJ.DGz:MH=tNFshc[q=GuGn$l%+5p<)5p-kd0T.X]„U"#U'tr[8tXy7/O9F6okb4vTdAz%EuJ&GYM:y2f<l%vY,MOf[]e1uS3dWlb>d&+ya„U"mT:BJg3DuM/p5)F&UAVY$ZTEuUay9Lr*$MgIX*'hk+;T>'v2i^Dd-F.:rs8^rPp„U"_RPl$d\GRW.WQ([#C,+,Ot19TIAXv\5wa/1n]q]kSt2'K<vnJAncG=7ucfo]y6d„U"/XXU6JTam9_R7\1K;yCq#Aq3m7bIXnZrv=q*T>40*-C2TuYqY,fR_f0HI/X/>>5„U"*qP?+5S_;PLRaGuvW$wXE+p6onU,SxCu=xPqItAT:9iEnC7<Fd59SLK9>l7PL/l„U"0Kj=;?LEO(12-c[Hfx?s=;j\V]iGl,U\a9IF#32#,V1U,18bb?0TZIh&vd'+F>u„U"HKr,RFtW\uYa=CcQ&X'au[GZ5U>C2xFisi6B_W$6]+E;OBax>aoZ6bU;1*+(ItB„U"fCHGNncofG[85l41pKTnT=s8hMG#';sF%v2Aj5TtpfaITLsEog1VK=^$^Bgea1I„U"TvkfD$Q_LIswQ_./f4dsGa10<JCm_lfj/%7K7?2j:)M8JQ23C<q'H)rpWHbCaM1„U"qW(_?#&CwK%:6*OO[sC]'DgTCkqP_PrOA('A3_tP4/.8>VC4KTSG4C7K)xkJX$H„U"6$1Ov.$BFgMT.IS$3'r\'PZ0SsrNo=Xi\D4aWg++,>pj=#ZPQQnKd?X::MnW;De„U"r9qVx%%up(%)9%%%%-%h(YMGo$Z49O%+%%%%5%%/%%%%x#hwf&%qSksLyD&>&7#„U"l;oXM3..F_(rChh5lc6f.0mDg4MZ:0B<Nn6<k=)uZc/sD)qi4$TU[u6ixs];0RH„U"A+vdA+SsAVPzZInT$gD&Lod9.'n/JF>>nS2*78B0S9f))vc71FR:9lMD>E5_E6[„U"]pL_mTZpWEjZpW5h/dCRbjwxCoRdDVhIqwMy>J4tr6l:xI0LM;&RQR?GOq,GYtC„U"6Tfqy9B\kE0:#0\nN3LuXbNA,<4iWFJ]n9tuH#mk[bDqjZP(\NyLkqPmXgOS.zd„U"+oDGHIu7Z()YqmwlHhmg,^>yj#Vr8ZDJ->It8x,8WH].)73Vab8BitoF$kTTju,„U"'+,;TO:Xr;^7YNK/b0vvhS+s0H-4JnGT&$LU/&V3fA:/gpBuqjE;6VpN(%-pwag„U"V9yQMtetq-SrZTny5+Y&G(#Y%a-F:%eYH%VG/dW-R?u#=quan9cy#yfr,]lERul„U"cNUIF9jUEXV^1?AK>pl_'&IVuQ1+5'L&$#dIWAFgK4^.m$hDNCMKnR5LVLMRYTg„U"]vTM\<sr5N4g4dlu;qcQF4U\+?k3Eac<9'Mfjn>v>r5[IpvM#=G&%Cv>I[j6JgC„U"tcWNPR*<B+bqTmn,(-95-LN%gRF>tv(OuhWuLuY(\v<dr?p3^^>s6^+:fq>mFQM„U"xSG>B6sEDp5z$8?I7=T0M2eTgSpqdk-^?Dn5xWWCdP73diXIC3V'RzU0)bB,r4d„U"^0.'?u9jk_44k?4&a43f*TmtWdd\yF.n5$UJNnK1%+hAfJqXE8&.:7(EOIGcBBq„U"v]\0<GPd$;%t=SW=8ZX?mK6qGv8)^tP+]2jpfRN2Ubrt^wAwW\*3H[[rs9VvOt#„U"CPO+e7e8iW2tLffr;:$[8]^>NsjUg12;uMfHO.SN-U2I>3b1,w&;.(t63sF9PSN„U",G/_l[]%as2GR]\pWDk.Fq,'or\6,RBbTT,oslFd5>,O_Wd>>XqRhh(>mlupss3„U"k>DTdd>ZT_c6RW,&tJH_l3BVM$e35ltpAawd_m2hvF>3UR#VHlC6f$?22K6?qAs„U"=t_ZZ<#wgUAs5hKPvK.o7V$j;L#]<FEM#siSC7r7nnUO5o2hY_O4LfUKgNn#s#-„U"A7P%foF=K8_65$U4&Fr6?Dc/PfQk;jU)ixy$n-T<jYEQk0phTWrB'_dNenR'+F?„U"NshRJ=5^c>NdrL.d5=%zP2#QEi_=us'u-dYd.VaslTJU'/rv#J5S7rMnjNED:Dm„U"c^d*-sv=lx3SrZ=1Cng[#UaSk^DO\W$F3kO*(HJUo,'r,ijc;9g,].9'g'p6)Hx„U"i#;iq%rhO&5Kr(79MgPmI<lA<hZu.URR#0<;>XDpSjmIzOn'qXhl%>BBX)[KW9V„U"1j1ZL\;$EfiMs/_W:EG's?exLzEQ7V_M%R;Y3ltGNd,UGlP*rlJS1M-THM'llBu„U"Y'8Ak/Snt0mHqs%L)mj//HlUWCr*mush#vB#H\d*^3##Fa)pm7.K7c+JY]4sKrv„U"g+I-H-vrWY7P/ls*enQic=Jcnm.3]64TPm;_D.TL0WKPKv/Ns^gGH5#nTV1FmuK„U"kZnPf*2Kt+lsL3)nne.ThVe:$=d0B/H\Hbvq;gbm\j#7XpdEa6+nUemhF*wN;9&„U"wCnZjrv[-LEFCTfDf5BjB^B0C^qbYw40?>v.Lj4k;wXba1fY?#NBDTsy[Io1)=M„U"+bY+Fn;NSBHWXle0B(cBd]%.24r.+5_V5OBHcD]Y:_C.f]mnH?,0G1fAFIEqbUY„U"nI#Y+'dR1>p_UB/<DJU03%\cZOqM-v(6q2JgEuoL/Lx3j[]d9BsEDK5HXu8L0Kk„U"EwDIe3k]fdb$1WgOv$:iWwG7YEaH$=.<VR;9MvE8ma7(T9414)[$70uttw<;;9*„U"qH&17*3>*f\JFc7$76t^6M4OA:YQ\,3PvZmj.dTnX.owI]6:*eFDlL'(ta-[A-\„U"%XDN\';F)I<OS7kjVYbfrdl0pJp?,jPl?cn>O4^iIsS5W]StoStlBp8*Gg&9bdQ„U"VxkAJ)f9L*:B^:^].n8c9$P*pD*g^6Gp1d9K,l^gBdqWuv%DVZH-;'5zJ'dD-Gm„U"GLd+EuQ>tULl$_<h+_+RI5*fB<OT'*8o#$X/H1tO85%wD%9'fO2AA>7-+TQ88gS„U"&?vcp11F:/K9k''dhhLhyy8LQB#KrxY-Tof7PZT/IoIo$BCm,/O/^BgG5Kb(jD)„U"ddb01WbT+ReJZd4iTGIiu/[7%iQk<BH;IDn4*iNu%p()9%%%%-F%*zdpFv/#**Y„U"*%%%%5%%%0%%%%inl%nyfq%SksyVD&H:E\%5%--;VJFICwY5o:%<(8A1bII_g'%„U"VG2bun)6]du72/apBFmfKeT[=-,qu#o.R3u(TToS>MdD&\-FQ(r7FYoV5o).R9Y„U"t\]4kcuEtv]um,:wsYl_F$Ej\hEBgeEtGq<Zlh(.7oE=H+hN=NsQj>Z[P:euOcI„U",^006utsQ.3d4\*szi+MDGl&?e:E0%(M&WIN]0%y,iwbMqXYG_CpT>Fg4v#(e:[„U"B-,m<$H53Mpcw2DkO:OkkRnRnhlllHux3ZwjaVyW5%0m_>S.3\5RJGY?1b/-,n3„U"\bk&'d$buhrjoaCS/9vu=<F):HOg&.9xucccdKp6SUZB/0j=I4Wq47CO2Uq(G-_„U"wA)PA4ys82hh8N$?+dl2,TF&bx;Pn*%-v]-]7?j\alv.Kc]YQ:/kS&[NxE*/9-Q„U"YS7[L5hbiUuSFxL[N\cj+\N89fR,D>ctH44Wrij,,f,Fp)gWJi2a>TJdA4<N.:S„U")O1>o1EZBc:LBCODZmP7;L?TRxK<Iqe]gjW&qf0sRu??#jJ*oO5l0d-%:GL'fj5„U"R/._A']J8'e5AU#n8&:^T&;kSld0OpMsLyz6c<GzQGftiT$o9[*l?nU3',c:U7$„U"(wI;5$W;TL,I'P<CIKBZozrG^wmdIDzw#faRt6[?g%Mc^tKc%A*hXow&1XTGF6o„U",']wJh)iMkJMfsE&kd#HkuM%lenIHJmB,kJmKX[:L%_lTxZxwcumY.mQF8r$nsT„U"k6J>I<rdn_uV\Bo$=+:K7HXXyM;##jTl$:a6+99hFSV,K-hY:V^HCez,_f==Jgt„U"*3nKFNtM&#(6^8)[w4C>=l4iP?[&Y#4X6udRnvYw'm*8e'*D/5QqREmXad]kU-u„U"0:[/ElfpX7-N?Fcc0X5NcfQouB)t/'p&T;?mkimdu:\66u#F?Von'qtHtX%LNb^„U"9n[D>bROHaHRmcWxSF=I=A-A^2N=I\*'NQG'\2L+^4WPS5lfD,h7OGvZ2P'wZ,*„U"B8*MPA[n8NfZeb2YKeE]Ub10FI\\clqp0rq6$+:*<:H,/kpUTQp,40lB-Dxi*>w„U"dp.Rns>7dn'VtwDfbBnIdT#YPwOb&-1W6MIm1KVRrr&^[4d4Y]sROtA][sjdiSC„U"s;r72oOh\Idb7ruRhhLsvbmg%-Xql.sXnVIQ6wP#pb]Jetc:]n6Pdsb[w?)1Kg$„U"kUY?o*Np;#]u)ITEDVL>\gduB13MgA;9HUbTrxq.MmVIXFm6A^mUCPPKO,i\Jed„U"czojEPubVswpX<I1Vd2\pr:3jFmLb\OVDUIXqs$WRpcPP4=4'AEQoHqsP-p0#rt„U"'.H[+7R&ul46MJY-uq7)\zQQ$9Ffbp-dFhs[NtIP5^M45bwl4lmHvHunHd(3m^B„U"\[k^Kqj/>_v6'iOY,mPD;)SMCQ4B3KMTh/eXhAFowI=_CNpBv%bd$seLuHksu\^„U"anmTj^fAISDzi<xzDZt</S+FS8ZC8NW\[^\MzDmtKnRVGpHq-L^PP5Ht(c'7:BZ„U"sRW+E4DV28rrx^?b63d2\K^8d4Je4^4=c:9V/_<+F3sUUHZjJ/mM38oXJW(-f*w„U"LkASA4A=h[nDc:b+m>+TVu$s6,t)tW&3G&1b;t>Xib?'.l?8i:WS+AWIag]lo\j„U")e1[eTnaYDC>N.kR4]s$wV;G6HHd;[X:bsc[DkMc[(<7IDgNCM<EiVu-VktLFH(„U"o>.vnGXxgHGRqiCLU#>T[uHGHD[P-h*U-V?mo-,3c700mme#OJF]_B\)GXP#j<x„U"h/%PT0ZZuhFK^g/ct9GlVN]f3L)vSS9?,'q4up%()9%%%%-%1n'dFVg(Z#%i*%%„U"%%5%%%0%%%%ijkf%zqyS#ksyL/&d:H%l9DA<Q9J^]V504u2[C>C&H.Z7)l7g/iy„U"ZTG;'=Q^O6FDZW2jFb?sYrI3+0V0&;fgREj1a,i<-'.c:5[?hFX\Kdpm;>sX7\Y„U">W8HV>e6olsk^DrDjdDZDSY=iRDFTW'z&SA_ezIP7j0)XvA,;Q4VAmU^+<1b^.-„U"P]8_jT+$U%njbEY0q>ZElQh'>=c'h1xYGiF8fR'dE.-(4Aj[IGkBfI&i]gCYw?i„U"g<$Von0j5hRkT<,</Y0kD64u46Uh(C5D:^cW+#&2^cCRi,GK3GH<2_5TKqj[sfD„U"*^>lmC/%rmDYu68TUyW0nUFdb\zNk+9_Nk#i;r'?AkMpAehL[I/;[b)]76w5-ji„U"UrAzoo1.pztce.bQUh37[*1,+LBm/-I'?w..zJB$zqiayx%a,0rEtb52K[M:G68„U"'f7SH-fnaF,ce%L6^\B:a%=8ILw3,A%u8Lc/BX+5OJ7]=&tdEagtq71>5:c$#[>„U"2B-Y>/gKp)5A$3l([9j[6]jU8&g)R^FNO_[6f;tB9:2_:7iO:n&(c/6cQw'0L/+„U"+e8\V2[dAhW4qa;rH%'wQNC9C]vVlB(I)k-(&,*C%0)(iqf?%dh*yt'jHoQ5VQV„U"3,*Be<R-a(sFo?8l[uLr#cdT35OlKlQO(jufqs2Ugn<6ocDE&)6v['z8Rdh#EQy„U"Q0rL\?4q+$T(2HcAs0mZjLZ27p'W>i=*irfJtp1N7'W[P\rn^##HfL]Aduds#9i„U"WuvXCE04kdwcnDUl0*OEL'.:Mn=6-;n;'UtH0/wl+=_fYvI:uZbInzdQ[cRY;+x„U"q7sD0<ZHD1A$$db]_Hxwe<T(NeU&'xUi)b76c5[p;(DlKJZSdchM,oG*K>Oto).„U"+9c07ufN_\69*1fswumJ,k3g%[KS/z<ot[7'apbM(qDloo$u:]M^oQ9S6^lmcqi„U"in0I55:hVnWk[g\VU](e2bGg'%E=0eSGQKc0_n&q=B>om-.Qtrow,Yc+9vBUm_T„U"UumeCCikxo4>$sss1mzlG,k-JUoe2DurPS>0L<-06e00.?/nM,k7PMMMw1TwfK9„U"%DM<]i0;M:,VBeaVCxUiqU5E=fes#TEzVot+x9sp>\c>][<2?auU7\>#hu4$cv.„U"dXnTd#+w/fa8$DMl4hk,Gr%QwJl))nYu9NJ\aK7d^Jy*=mt<x9DUu<d0uX/t8TS„U"Zevid:?=ZNq]ZGxO,BbP_,laB=<qTMD=Pfvu/]/K&A26PMf5e2_]isc9ANO-_/Q„U"N\d-f;?UG=r:GuF(YJ]TR)=*Qo']o1Q1xLq4jM7xSf=0K.I;1i'M&70uvldhH<H„U"4NVUn8Nm2duDH-hFVglimE-0.g+91Tx9F^rchV?SuvZAN'H=GB.m-R<g/?f^uIt„U"_$5diBFLru)$)'H87LLWKZ#(5/x(W1.EjI+FxX0ufbQ$?Ws,E1clf\rdl5j4S]^„U"kkLv,XB8vmb-9X8DRdj=.Kdv>LX<SLZ1<N$T>v(d6,r(veo4C6csv1EGl\N1*V'„U"hl[3h%Z;h]>:hODQ>QU(XpN:FS^h7pHl.B(i0stx88T]r_XTuJQMUu7:rt91Ilw„U"m2PUgcJU,Z0?W%P<uMi/T_$E&O6YN9',>#KqH]p4A3=qNrPnMDGQw0.FT%kBVLE„U"Q+'0RCAOBnavJW+ORLQL.PsKb?+q9VxlE+1Z'VItgEqnSA-:dQ/:OZG2MsoS&3J„U"pO1.)qN&u%p()9%%%%-#%gYM.G?x$'tN)%%%%-%%%,%%.%]']%SksyRrz69%Il5„U"S%IXs+D8lZ77^^I(XY/Rjho(P1f9T?Bgj\3Sm/+,JZ3:f$bcd&5'Z*sA%$:1-(K„U"9[a.3k-[ba+hJ3WOVCS&zpkM+rlity'wcN0*_wu3rl_)=Dxz7h$Ud%2z>g,?>)K„U"hT2-1/Q9=7%:3eMdJ%UZ9bCf,su_eERM=g&hFFztuZid<ZX6p%L>2cwZ=bpvdwS„U"m0/&<&<[<ddOqzFcbOn6*,Y>4I<W(0h/FC_,J)W).vgN0W9o9zTw2ECC)3lZqQ^„U"0>^O)y1$Y4#Q--)o&j&nXa]A4ecoJ5(PDBh_lg:Jk%T,,0-9]_j^I&Ad7IcP4BA„U"(C+Ko_Q'/HV^e\<KdYuc>-k:TfWdifS*M)p&9q8q25/Mo1j&C-CC6k;o)N#KFuD„U"J37=+P%\B4l,AgF$I)RcT-^Oa#CvGymFNp*LV^mI<3gZ)%IJ#)eAZX'BqA$2'Uo„U"ixMi5:uKeC6xijaO87oKY,,R;V9ZrJ$XJ464VGgCiTXD<_MEJoGpeEkt.SDlj52„U"M_Qn.hR*$<CQ\TTR5BCVq[l$Jc/UY^i['^^\&AitFK/7?7C2FjDhMD;iu4QQnk:„U"aChDiec4S56vEVStax]N1mx^oUo9VaD;L=AJx;Wa*%j4lIUYh<InNi7;Mra'T(p„U"(7GQGX=?8IE'^])[PFW0.=Z_hmooZs#JCAee9^Cdykcsh[d*EDWB*^sySS*#h<L„U"]5Qc-_')Gem%mU/O5rm1=Hl7]$'e-;D&CneK[L-Y:i_1NNo=h8jZUiK/0wDP5:z„U"KANH]U,juVNuxVxDc*NvG_G+_/OO'c2sCx51rO&Xe2O[Xbt5BpoXf>n*LgTvA7u„U"kb=/S/wjzT1xi,8Ulb0ETNj7pz=aVd*^Fr1yfl*hUVJ_B$QQC=Dy:Ct(1\IHbpU„U"n_vkQiJ&*6*%SGMKuzLG-HW[_V7=rTw[^PZl*T;VE.s8P>,HEq:0V/?x/f?'_)U„U"X,xhp%8t:>jWv?UNf'%A>BrH\d)uDS%obrGo/k]-)8Xhe$B=/uNOwX2l\PPeto1„U"'iFtjq5vmPcxu7?DjgD,IXn$F5$u'F5EUXDn4['nHfmfkSrT44iZ^$Zs.aa7wVd„U"8T=?X=Vc26:M^dnVJk[GuFq(^FNh_davwAfcjv^&f,C4Oo\_d>OMH5r9vUsp[NU„U"Sr?\n\Tijkun4F[WV]WVT/7#7jrk^mkaIUv+QQju#.GCepA7h(?W72EBYkO%vrb„U"Zd>Fj(H.[>wXc].dYO$9]_B3:,_q?L,?\KQGl6?KGAmzqb#7aN3qzh;=8ucI]_I„U"h)S^D<fQ-waeT,hH4Wv*qhhsj%1EHNT6tC.;U8D/INxMDuN]^b>,<E<Ne<]zY%d„U"up(%)9%%%%-%gCYMGMO),9V%)%%%%-%%0%%%%]&']ym%nsSk%syrzCV:A&75CO#„U"-*>Gb:3P/]eAtj>)+QVPU^g>M4^&-[,f4hIOfAxQhBkQKB15Sk:H;Wn(gT'NPS:„U"TM:eiu,&PfSw/ssrk,dN*:E;%FERXXhlZ]RTjqjHl_JLX>5d3AhVLdF^^2E\xtr„U"dblSLazyyfE)W%M3m4(+zvPW0:/$&%ioj%MDLMQ0oZwRc&09MmLl##mlLnUhl^M„U"T-XXDP6&.Yq?-+1G?^ieZHk>tM,Mt__sz$$caYS^4Yy'GE<9jfy_l(46&iMWOCo„U"WEPlBDfHC#\+Cj[,qABw>X%b2Q3F;9S,FF)[91)R?g9S%F[Q)C'2xu+GlUmEp/c„U"]&)^Zr(_Ti\=m-o('COv/a=K7nW_2k^oC]sdN5F4t_oKhI43-o?6-tIEsf'sL-Q„U"OC1j%4*d$QT1n#s?_,R<%a4DFBu03$'DRN5bF^-oiRI0x<W7\b&E>WS6O;7QBpk„U"^]uE+pEM=>\tJ4$_fc=L$mn(ZX0(s.h5jb[CdGirb3kh#,5ENH3wY&.5J)#N&p[„U"2+:#JYD2[P=f;]X\I]>RX*T($[PeD<-9xKw=UY>L_A#'Xg*nLDT%/kn$e<Lj)gR„U"$?X<_bwO:7[O,k,+v3OEUCm(iNI4fMBeT3BBcVch1cbD2-VM?feBn[aD5hHpt4P„U"PSrGd+^RrM(TZ8=f$i2Q5paL4-?]K=DR7<Jc003.-YU5NN(r&/XM^vtbttIdjAH„U"jjo5lVg_2e2_1N;?4Gou*4T5ACJ$D#a;BCn^M_^EEI_ps)UY4&.NqPGtA\N=vu]„U"96P]iHefhn0'YZuSS$wFQBVXi9T6DJw6q[c_VlA><uA^8MQ1[<?3P6I4eX&\-gM„U"=CuW5+&>e?)dXf_;Eki0fc+/_*LvUmQg'Yqa=ea[ya_l:C>G,ExW#T\W=dHNqgx„U"8:(ZV7M#TeA7^>AH_J>D+?g/r_ZGOWMG-7NX=00iE+N%ChPN7KjjZ0OHf[r)2]K„U"ne_b.Pb.*vo1:rNan=GbhRob$/lEW7K2RDX8(O2Fu(O?>Q0>&>&j2742VpZLtCq„U"u9bld,ea,lzKeLFvK[*jn;1cq8):-*I)<YJ=;oF^,?Tl5OjcW4t8iurtXj1WLoE„U"\m,KO2Qb\_sfYI4/8bCLeK/npLNR$rmfLx]a:DI,TtKc2^CXTUBCFK>y8mnIdJ+„U"DNktN\Z/mdiml4S4j71?wq*=wNf0r0nT;s)I?3g-RhV2PvOTiMOYe)kJN)M9G-h„U"O<=OtFI)ILbl%^$+xtMIImZl:[9VWqn[8u2nSsm6x5LZ1A'E6=w_SFAF^i''&Q2„U"bY:7._2xp5Lfr8?O%%;?L?\e$9MY3$*6-T*ica.l\K,C%]Je&u+P=o5^JfZOgDf„U"0+_TB_+eDYInEtz6\JJZ'&BrsMseaGCl+tLq[:af2_:piH]/l2/8*\3W]S>?0T_„U"?G]=97VMapy_MD1NR1Gl&vPhpApt4(B\6T:rV-L?]QG^jI1px%&up(%)9%%%%-%„U"N#b\HC.[)4g%*%%%%5%%.%%%%k%qnum%SksyVL&F9[Hl5gRjUo0o)SDK)o0)nNA„U"H/oh&o05H%9L.R(nA0?E9aE\001*^f1?XKk/MOb+k/:<)/Qx1E&REl#a1+bJmfe„U"MsyNz'#so[BK\z,h,N,NE<mvJuldFF?VfFrq:?0fl3t,P*.%gm\oW^-'qUNNo]j„U"*T'f]TAq=0*#V)Sd.;lqVb2=OsCs;FtpsrZrpi0FF0ipUN6cswYFJPw5S&P/3#Y„U"75x2%D(B2m4YwkHjDloW8FlPNRk>Zb,*Zk](+,<'*A44F+(9M>&&'\VAB6y9W^l„U"^H$&ZgpZiYTlaX=0&NbEN,'OvGEc)I(2,IV>kU%v(St=Bi5vA>-J^Wh#JqQ]3#9„U"XgR]:e7qn)mjS-<<IN.pNXRV4hqK0n-Ax8oV?C5?njugeOEnc(&RdWRo%y?,3-C„END SUB„SUB V2„U"lEc[#1vLuv.GiAcMTKl:-T\]/<MP%GSm>$G2uWJ4)jqP?;9qH[&Hk;U#?2L/kN6„U"zILcb>U*R)QU&2kSn.r+gnSw;(t'<zvz/dr>[[NiS:<Y:,ZjI\gi/b-?2k3)Sn3„U"S6z4h'S^8M*'ntYP^=0tR&4CgaW)^t^)s,_sGM\$m6I8lc:I6Am3o*#R55X1+8K„U"1d:u1>=DTl[%(4,XSBeR']a(F?u?8_]+rsK_M83Orn7mO(?d3rnG2Un<b6oPEs&„U")v[/)zRd<hBQOpr0L2H?<m$ZT(7anAfmNol027Wm'>i<=*r<GHt1NT*S,dN\r^B„U"i#^a%tAdTou#9W3GvXE0^4kw7G'AP0W*OL'L/:n=h6-n%0HUHXD*Nj;cAoxan/l„U"B=*nzGXjyQ;+*xqsDr06HLW%C$d#BivyXweT(A(h&'TxK)buA65[Op;.mo?NSdN„U"chlr2G-5OMto.k7\c7uJf.\6Fz*zt&wvJ,Hk3%[5KKz<,o07'65iMtsrDooG$u]„U"Mobo9Sq6^mmZ5jn0kI5:hMV#K[BgRL]N(ebG&g'E=.0eGQ;aS_nJ&q*4oom^QRt„U"rw&cYc6sT4/_T8jDAhL>MsLGh+cxU8=N$ll%&]YpvQVJ8c0#J'DH'4TI<'VkOXP„U"c5(D.aDc0c8t3d,Tn*uUX*n:0dWu[kX9P7p^>B540w+Bz7\MPdi)MeDSEYs(\R2„U"903=G+_WxRsxr<IKoJIAvH75t],KnvbKSv-DobNMQeIL]?Dlm1XhN0$9P<l2Tdo„U"iWMSnI=$r6qdK2Ztbs)(b?Zc9rmP,0G*iDEEF5.0YxN5F,ohPb$l*ACZ+x.:g;a„U"]-;t%HJ&HgRLV]&I,,;>_n/)\js\LeYes6/=s93[?Z\_kVB6;vrgr,1UEkt=X%J„U"v,mY[mH.]7/d8JL<MMoxLui;f8Uh#3TZ,Mg>:Tg1?.wVqAkLaWZ-rL<dz,Klia:„U"P$+VTs9SDrRxEHHrPbhsWk0H02,NLtEsx<^u#9w#nGDe/8^hwLs;SL*Xt6n^(fK„U"_TG>O$HW\,A.sSts4W7ND_<oP8tLcMYWl8OrWTsS-v7<TwQe.s.PIHk.r_OUbsN„U"Ur?htl#LJ\7YZ$=>X&km^AXUoWd)X[),7h]xg-D_Vek_18-Xk%ml3\bE73E&EY[„U"Ri0>?wmcSB5ay</094Wpfl1*;Ma/8D5bQr3lSp'u6J:[2bU]YiMd<tQbQhsbIk(„U"INZWdTN7H'H3jZd/>z8V,w'KJ%?_bthPIOIV'%QfiN-,%%+ptnNVgf&5ToXlI/q„U"<?H?t+n4z\7yjeJ's<up%()9%%%%-%.hYMG.m6ya%P+%%%%5%%%.%%%%wtrf%sS„U"ks1yD&r,WTk9_%Rv=/q_93e0o+(R.c]/PYKgo8=j,ZJZnR*dg.tmVs;E;(N1VN\„U"GrO5#n3FV)tVR2FV6[T<WIEF(&FBib'UYm5//\.7p3JRq()C_p5s7JG[_l=4d\,„U"df6\>WqjHl6\$[(08#Z3bf1_71FqgLR]#v7n>h%rVjfY'R+-D.I<J#%nXa*YpZI„U"?$T1qO+<EJ.nYe7YYa#T_J=aY)PmYr:6J8R6LDa_q_c&\&b;=D?Qj2LSwlN<kjj„U"mX1<b3RCIy1Of^AZ7mPA<*;KLkj$lQ4^8h*VK41J$$j$4'<PqcAo<<m7S9n(paM„U"A?]+KQ>#k9j\8U+,wuvsooNo4gBEg7Oestm?Zua[Bk.ktbeVe;O.FQB)xDm0Ge9„U"MUnim\2gEu+6=,8x;X=:d.Ky#y#nraO%B#Qp<'S=7s7H\ET4Q%#<FpP2dH;Hf]#„U"'IV]KGr6)&?b6GuhuO^Bh)^QH\gLF8u-F4R(M(EtL9oc&,kgF-tJBa-2TJE<e]5„U":1DK+&e4g9W+*+1<)=/Uz0Kjp#08&]pnGu+V2)4z8LRR4PD'LTg8KHW[Uz$q5-1„U"?HpDe^bwK=SL)PD[8zcY+Pa[0RknPDH,<xw0.[1-PiO^*_xCq'pld>Z+9uT^k;q„U"1x4?=O51IlI4?</L'C(MckntUec8IFDLp2l#H_4eT=D5n$6RHxPsHe>'G2oij(7„U"HTDKhSO$?5&I<c\kqKL<Z%9;X<2.)68RKflN(oKX(q[&Uy-9*1hQ4\EL.q$3bbZ„U"<oSfT4A?Vv3lHTb?Kx;UGtPCtDlDDLqXSh,?R5(l.m[>?msif0vUTI7^jV,NbYt„U"Yl\Y?0x8Z,B\^eeTLkQrR^jEFv>.J[w/&6]$JGpcp0WpR5r<PCq>yK8A=D3UqMb„U"Z5DkJ7au[JErs5A30-FXSMon.='snqH'P6y6N+GfItC?NFn1fYo^)DHf.^w:k?J„U"zQ7;WEgn)%'BQZK18>,Pw,gn)mo71<m[UqFu:Sf/4m$$FFv0'T))tU^Ck1PhudI„U"*_m1anX<sNkXbE_^SPqQidVSf7bw=jeq6tUnYT$-OLM>e3/OX)A'aP?Qhr]PqGk„U"+o6%/t6)7(bg&uax3%4/Q3evxATi7aa'oW3q9,q^L_,xcKa71y[0t4;AY_mcQh$„U"mvw?W\kc(yOPVBOcNOeMzad>Wh8MX&d$,H?Q#?bI0Mx#96U4Sv(%XYYe1AO52RO„U"C^Zj/=vMZ3B4xrQ-^qe\g>lXlb[EO1r99u9kKCMShn<wnkPNI*IvfelaJYb>,-M„U"t_mDI'OU0%dVuqDd^TsE\4HR,2('?^chdzzUmdMf#wsEDnvHJL$Nf%w0wW&atEg„U"R7LmkQHvMU4%dXK?P31aT(LJjPnPL'vczTRF)t\PBuS69q)'+mf-t.(:s<+nv2]„U".j,dhjBhz=XX7q)IMZPj&l6o9tFDSEYA>CjSM\E=Dl+vdpml\Nljlp.]^h3JwqF„U")kr['Nwqa[lB$0GC>uKI*<z0+==ncp<=koLI=IsrRHC(SC?]m348N$FHF0+DUar„U"/<E>()tf=cruc8,$\n7g^eOlbiH:esZJ7LM5a8jDnyDmX\G^H+:Lg[>Ntn#3l%C„U"Ht>63GlYwYdpla:m&CTJ5ZAzw;^%KH<T;i&fvDq'hvZATDc0<_XWPM?K-)(^:ZS„U"z:H*2fv*L#ATFa;5/Ljc2jPkTsIUm;^6oaIbj^B]rKa\fe&%*-'_$T<&/C>FaXQ„U"p<UGgtE=r;_VuQ(FJa(^g/0TVh=^]#vT%f4J9k:4Do;zq:)L75x/I+PC0b2:Tr,„U"M&xsh._tY6QErd0[k#n.k;$0s(Q3qf^*o]c2ZO&]mO;6dX%%HPHn/H*tV8[sVqh„U"4$kL1_&>lReL'hh5zvJZ[>17WA-39QHfFDRT>PeMD1JCh0TS8a7f/GSTiQvz37-„U"31Xj'O?bL_W2+o<XS.8gl*;r&?mJLrM0)PEQ_GASF6t-;k(%\gc-IT;u#0dvvgi„U"^#&23TC=fnG\Ms1.KOi9(7w*%up()%9%%%7-%1QA8AK#-].U*%%%%5%%%-%%%%x„U"f%sxSkIsyL&:t:\kd9<(IpnGLTrIg]+mDe-Y#-OA'0s:I<TVj6W4[m_ZCy7\ffv„U"-TI8BTv3R&6<kgi]Z:c'BN7hc1'iEs/YLY>w7vPSwk/uxmWEW5Hx5#9bfBuv$nn„U"ZfFnD522)OaZXMN1]\y,uMR*\E#(rxZAlF5RHigH1(RT5\02u*gq8;_'1%gduED„U"P(oDaA$=\00\&BPdBtLvF%F(EGza1Aj\u_8qoIG*+=dD1Nxc_v#9ptj#OdSSerg„U"K.)vX4f<E?Xh04Tf,F^u[Jb-hnm][^H>cQKW]RroK%7fuuD^kK08Su9.Q+oBCOp„U"3#B[Ap9D+lZ8c0hDjp;QiaMb8[]6MRs^G\-SH/f.L:zykzPo#(%EPLt;bxdQ=/:„U"%WrP]?'JFo0t^bycPvt>%&^q,*#j:l(4BHUBisPTu7'n%zRNO/[D4S;tLQ7r,3?„U"4G*j8_XUm6Lohzk\)Fg-'BXWE\9+w&$YMB>27n\\m)qW(VF^KT(p3X;D^)?D$RJ„U"C$\#A$vM3k&,e^;*h%gU3iSm:9t?mlpUuWeR(^T:G#0X2[tk5EA+t0DfqCmj,-Y„U"ZbgXF(-1DHuu.Xi(->vQbLyDoogoC%C2WA><PoD>+6.?K/erLRLZ3L?Qx72j>bH„U"du?X.fA)o\-Z3^eIK'?+L_g;-n[3PR/oTj$m8*,4C;Ea^AG0nDFcvscEJ.pZiWe„U"^Q6r^nOn?aAD$X[7AaiQ^&G8-6ohE$n#cE'mZ*1SdzPdR7HbTeZ30scn;]q.z%x„U"Rw0P.MpR,5t2X(k]=G\.V.(4n5P;AAI;7/elM7-J98_uScwS*icI$d%^yDfXu1a„U"Y^t(n/Q[;-T8=gn'sJCm0yWN]=.SvKRN4A<nkAxx+f6goJDuxM<H3xwe-NH&^3S„U"MD[I7Edq90qzv0g;pdh:mMQCZhTt#eiC?nuBQDnEoWd'9u2#)I-AS_g%mjuY8[=„U"dAcs%joXHiE4J369iGZWq104wHXS&,&TJ%#uB=Hw^3f,hLc*Wv#-f#cqK\.RHDM„U"Ca.GoTUmmz>P#C:Z'fnB.Clsjku:Wrg5[h'MO\d=lLCh477G:AKY]9/jaug,EQw„U"cuVn,G'6X3X/BVrFdgH1b>ADBulBSdSH_dgmdvGk4hkGp3Xo9Pc_v)sK[A[l]48„U"5DPzQ2HKnFhcUu=xV6+%NQhNP2u0,nn8_p^t9H[K_Oo?,\Ffu0A3XD]EMBATw.<„U"9K<Z6:'yN:b\i_45Jj6iM<Y#aP6Snl%UO#'7;Fz\4,kUBx6L6qPfp8Lt\Yx\UaL„U"n^[x;N\Sq,%M)gn.,LHddHu>dNc8\Djaao(_Qr=/6*8l:bT\hv,lenV)ZgYk,<e„U"BPc?bB.mKT8#?DJT]2KsgwPo7?cl[XTw<oj(f,SPdGh?v$b*b*fG^]kT60.lj.+„U"Q\HhNsyI0\?67VB\ftK<QrN?N^8]0/?X,Ydj2+.0kr:G>9f>qpLaXfn[t25JTPM„U"9E_Of(iG0ga-Rh^(<Xb\4du7LRl-)p<Qr(^pxuCUxn/T;I?cUphxS;_kMM5.h9S„U"A&1)+vXYG1\>?vr1OoqR+jgrZ1U8UPn;DEtyXr;VI?QV+;lG+cw2N%?6\-Mk?jC„U"E1sNADHaVDN$6?s+rP6X=reDTjX65rXCL'QCDFD\itUWX*Fnsx(Zp<xH_(#4UV^„U"fs=]ptz^>2TDmXMiq.meX^b[x#iH'Zdup%()9%%%%-%0*zdFtv/#*&Y*%%%%5%%„U"%/%%%(x(xy%jrSkIsyD&WH:\%p5%-;[VJICgwYo:A%<8A%1bI_)g'VGm2bn)-6]„U"u7b2/pB=FmKebT[-,'quo.pR3(T6To>M3dD\-#FQr77FYV5-o)R9/Yt]4skcEtu„U"v]m,c:wYlZ_FEjX\hBggeEGqu<Zh(>.7E=QH+N=tNsj>hZ[:equOI,=^06unts.„U"32d4*saziMD.Gl?e7:E%(SM&IN*]0y,diwMqjXY_CgpTFg'4v(e::[-,Um<H5F3„U"Mcwl2DO:kOkRnPRnlltlHx3cZwaVkyW%0em_S.f3\RJnGY1bf/-n3d\b&'kd$uh„U"=rjaC?S/vu]=<):CHO&.t9xcc?cdp6qSUB/$0jI4]Wq7CAO2q(NG-wA4)P4yLs8„U"hhS8N?+Odl,TeF&x;XPn%-mv]]7.?jal=v.c]DYQ/k'S&Nx4E*9-/QY7[NL5bi5„U"UuFxWL[\c2j+N8+9f,Di>cH4Z4Wij?,,,FGp)WJbi2>T4Jd4<CN.S)fO1o19EZc„U":CLBODgZm7;;L?Rx*K<qe_]gW&>qfsRnu?#j9J*O5-l0-%G:G'f)j5/.<_A]J.8„U"'5A5U#8&?:^&;rkSd0POpsLqyzc<nGzGf;ti$oW9[l?RnU',Ac:7$*(w;5M$WTL„U"9,IP<7CIBZVozG^-wmID,zwfapRt[?Jg%c^qtK%Aa*how$&1TG<F6,'6]wh)hiM„U"JMYfs&kpd#kupM%en5IHmB2,kmKDX[L%9_lxZrxwum+Y.QFZ8rnssTkJ>SI<dnQ„U"_u\B$o$+:oK7XXLyM##ojT$:ba699.hFV,NK-Y:tV^CeLz,f=F=Jt*>3nFN2tM#„U"(.6^)[Bw4>=Ul4P?k[&#4rX6dRlnvw'3m*e'0*D5QSqRmX:adkU=-u:[n/EfptX„U"7N?mFc0Xs5NfQ=ou)tC/'&T-;?kiumd:\u66#F??Vn'uqttXU%Lb^)9nD>abRHa„U")HRcWcxS=Ip=AA^[2NI\T*'QGM'\L+S^4PS<5lD,bh7GvhZ2'wVZ,B8d*MA[Vn8„U"fZMebYK8eEUba10I\p\cqpP0r6$Z+:<:.H,kpnUTp,q40B-YDx*>Gwd.Rlns7dK„U"n'twiDfBn=Id#Y$Pwb&V-16MEImKVSRr&^-[44Y,]sOt*A]sj4diCs*;r2o0OhI„U"dXb7uRHhhsvDbm%-tXq.sPXnIQi6w#p2b]et;c:n6aPdb[Qw?1Kdg$UYY?oNp7;„U"#u)XITDV1L>gdFuB3MJgA9H9UbrxNq.mV_IXm6(A^UC?PPO,2i\ed;czjElPuVs„U"awp<I*1V2\Gpr3jBFmb\MOVUI^Xq$WuRpPPa4='A8EQHqusPp0d#r'.cH[7Rm&u„U"46kMJ-uNq7\zRQQ9FFfb-dcFh[NltI5^hM4bwnl4mHtvHnHZd(m^&B\k^aKq/>t„U"_v'ieOYmPID;SM[CQB38KMh/NeXAF,ow=_DCNBv-%b$steLHk6su^a=nmj^*fAS„U"DVzixzfDZ</cS+S81ZCNWB\[\M+zDtKQnRGprHqL^dPPHt8(c7:[BZRWc+EDVS2„U"8rxl^?634d2K^a8dJe\4^=cJ:9/_$<+3spUUZj(J/M3c8oJW<(-*w5LkSA^4Ah[„U"onD:bj+m+TTVus6O,ttWd&3&1gb;>Xuib'.0l?i:]WSAW#Ia]lbo\)e51[TnPaY„U"C>gN.R4Y]swVs;GHH&d;X:sbs[DskM[(+<7DgMNC<EqiV-VHktFHh(o.v]nGxg*„U"HGqiECL#>rT[HG-HDP-Fh*-V<?m-,-3c000mm#O>JF_Bj\)XPU#jxhf/%T0qZZh„U"FHK^/ckt9lV:N]3L5)vS9<?,q4%up()%9%%%I-%Yi/dFZo&CGx*%%%%5%%%.%%%„U"%ym%nhpS#ksyLe&d:][k9Dgb/N=&BL.GE0TP^9l*9RMK]PsF*.dV'2R4W=]V[NL„U"K$(+b(T$J0YE\s+-%\Q=jsFpV6cO?gtbp_hs#>GTjZO>Xnj\hXN5H12VaAr#u2u„U"qteANt?8A(X;BwpHAmc%NRN*,AkBN9Kk30<jIEU0Ft3i'ZIJE$sE<6=n8Hw?*1f„U":RN6Xir^)rl6jetVdwg?'8O?*1'Q)(tSU?,ZLG(W3MWn4NU+[nfeNZQdO;m;;GD„U"\qXex)QSgnVl$vEnFfZ\b_Ge4rUQm5#'_LnGu%:%KF)xZ=:[jFT'XHNMu3,%g]3„U"_$cbIhU<5_bvYG>KY<6k-p=*B/rE6Y<DYI1lX&6ow;=cGW8fqzdN'oaB]\VlV#(„U",%Pi%2a&6cA.H'($Y517-?VDhm&mx2usL:%kV8%6bgu_MLKq;Lg#v(r?r?a$=dH„U"'Cuggg'=YE+WRu,+Y<K'\WBL&E1R0SrQ#y4Kj5S<UR,2Wh[dK<.?fWk7XqE4vfe„U"=cL3)P[>fD-j17^Q)RW1oVra2Yq%=rt62aS3A#BsxJTfJEEK-C'U(0r*SnSD6z4„U"';S^H2N%^:9.^V.dMIFdDDtZD7O5qDSjQ^QZ#om4UrHU)7N2HKKqK'N'QWT%q.f„U"Keu[&'PWT=Y(m?9<fx;d:U0/LESN2F(,gL*dfd11?(ctbn4oNIk9[p$xfE,M2^%„U"GxJd^&$_]wI?D/z*3Ur4I?dfY$UM$a=7p0mFkx&M<QHvOoOIWCZ8KT6uqI+[Px\„U"r^F,#TH4ArKo\7JmUTthn*A3#-)2ENNT/F<eTF)$g'0tUe^rj./cm]bRs]DXh2s„U"buTvCZnrr*0UD#$C<[R:Ps3RAx#lDRQEWuu8fD+8%NoJ(J)M%HdX1E^g#P(Wqai„U"Z'L1#oJ%$MT3[lWzRof87IOD.w8=slD(j;?NSyyBP'5S%H9Hln']Mn-iZv&<^hu„U"4JtCmMA.o17)oBRH2K/.D9bLyO,nb3R%W\l;X8nN<?<p9O<3%%SaD:/O_n\&q8>„U"0omDu7%[xxb?n?vJlWI.01+PancnnvQqn$\+NZ0Q\?[cH\Ij<Sa4.<][8/O%8^S„U"%<]a[&_$YFEhTdlfVNsQI8H<sfL:&N*-TcHFz^%ra>Qd.:7$?k%#_x8u')NopL4„U"LFfTH?W';Jf=^lKldwnon_9SV-^ZIj.[XuJoc)a0h?p-oslD;2Mau[hIxXhgzx)„U"Y>0)v(pkZ-*QnIF,Ex(^ofdPm\KN+N5PM;JP9_,lBo=<qMjD=PvUu/]Kp&9*\rg„U"K8f$3UnKP+)bb3t(\?k?6alX-pp9*.19tIK8Bj'fTP&mk108qtT#NEgndpXxawP„U"Q?$3M%OiT/eq3_6?&7tN?uuul?qr4/sdbDMfpFA1KIItHk?&f[]*a33u>D=e.uq„U"NIZ,2tTk$gOse(ep6/8_nx0rYdIq0I#*PKIB'91D'4htlKjqNM*IVXfuJlJxf[#„U"hz6#k2VzjtAd#wr61)lb^'Lwu7cJQ_m#b*)Okc^UG1*q3vWuHp/fRt)GO'>^OFc„U"4r7R\TcRr(tL2a^^:u3r]?*tt.q.X)YQethJ;4Qtz?HUFe,2Le,A&Ht2QX$CFH/„U"pJ&d(W_JLdVXtRuPuLm'Crgj6>O8>XKQ$WD/9OWwgFQ?TXnLln/o8QZtTDj5$6N„U"g*Tn0D#9WGk%9O\rAvi:7jedG8>QIIHV.1b^DHVwlhDYNM/8y5K4fW+NtB#Q9]j„U"lOIstj/<.ob?-J8up%()9%%%%-%3gcdF<%&3L&J*%%%%5%%%-%%%%ymns%SksyV„U"D&8:[Hl9W,W>6fLM2b1U00hh^J%N'V)Q)eS4U;spWf_1H;1u4>Q1;6?#+e29CFE„U"6A;z^?bb9ZpULSU0VK<c:#qeAU8<3\wYTQFjfXX2$qbTpLnJXlWf5\>W>IpItk.„U"7Lrlkfj-LTG-.QPnDhWpt?#4*A1IC^YXbO+vM(SefI&Xa(d+bB'7ihvipu?q*]t„U"J+At8L97HHZvwvDON]j:EX;qu/O.nFE?O=4#m=UG#Y-&Z;TvqHB9sNNFeaxK^#N„U"7sZ>^[=8(Rh;Sf*\\Z.o_=Z.4R-S:mhm1ESmM]xU,uf$anH-$H\MX=FA0S[.:#V„U"Z3S02^=hX2.5A/J8CR-QIliMf^\\B*;sog'Hev9ndf41*;,rv1A6(zO>/3(/;q>„U"h7?He>e\k$&hO0Eo-^S>F4jO75SqGYteM8T1+5j^c8]tw&>kAbh,:3;/d>uZlP-„U"L67<ocCMMwR$4;q-DUrTgPU12xoDX#M7sb_rhA&KsHKtA,T]EaGGoD+lyYF\s2?„U"t'=(n2,Sv:+=U;pIhU%U.asO8GOY:[\V.z5[XOW]fm^Vjuw=+UgUnB^+S,Si^r.„U"N]0et40DWg09YM35[sTtZ(.4DYgB%Di?-skYrjpG&iGg:\,cBse9r<QAs-)=N(n„U"-/xK()6]nuKC_B0;=NfHAW4k/fN.s0'<Z)#iGC<ne2s5SNsj?mW>[mOX$ZSOh'f„U"].ktn?'lBBBsAehhofnGolSQ>_;.qf8ZkLL[J6%b2RbDAbWQ>aGNG<JXjX8/1JZ„U"YVa^VNLcT#RgEj6cEjH&]=C3nK_T,MIp/;hNvuseOL[ck)<-t32ksK7%brmSKWx„U"Yp_R#QhpXnr:Mll$c,KBMST'fN,[5O3CN'.rLIu;h_&)WcRW3#ZMW*ar8ocLEE6„U"FT*rNa]>Qr(i**R9YoHDq.EO/m(<CPwCdI%es.bL.%t.awGl.XNl71ZeXW[r]hI„U"o&8naaKEP6r::aaw^B*;9SIkXlBR?n2d%q7Xsf$KOAS5qkG?]&y)yxa]6W8?T)O„U"Fk,)<N\:zt?N)D:C6x?[cl8i+I*.WqL]\a\RSAxTMS)\EG3;/$DQ;8x6)#itKV^„U"p')fs_NQ)ICcP2.Wld&CcpCcRr&6kQ>x7fB.F01'^T^ScxCG(P_*OWNF?fr#^l,„U"$,n^RjBG5Nj1ijkHXCD1T$80&QlW?9KfLd*TrfeG.8zoW=F/d.r6?Rg_XGhtGb)„U"7GFJcX<;lAq)35P)sPvD1Es&o8[Hb,3hta<oET?O75kKY=)Wo^#.T(t24IdIg#N„U"7O$znzd$lEL&GnTt=hi'P6=AJJk:SJwtVT8HCRBD)G+vW#.U55VZE)IkaR*n;xl„U"hcp$('c;'[\4aIc>8m2FK/5=<iXhw1]cfHthueH889QDmUKgAuG$=#Hw.pP%;PF„U"n>KPthQ^bE]\wso2C*H+3^glX,0TkZIeLQvN]M?fcTZr#zVjk]oe,dD$evX$Z9)„U"n<5SkZK,fxc6K>8b2ft&Qn>GtsT5,^Xv]G.-4wj[U+e8*,Ix=1_NtlGuqS/#0RT„U"CTq-97S;P67kF&gAK-d9CKn?gDTsqUpm?VcpNtkpP+Wx/pR\HEPjm/I]I8K?vVT„U"fdRK>2>0>;o#29HDj+*=ML0b5%-CdssD,e0#NV0c+T:v]JKyIdcBpXsLlllVBr;„U"Ktdxs_h^+iTg.bSoqF0#39vjv<mT0uHYM6A[iwh%6ZUa08K0RGJGLV-+7xhhej%„U"3P/A^;nDjR,Aqf9pg<uNLP%l04PMHZwa2)JzZ$rT/X'mZ]$i4C;Nu%p&'9%%9%%„U"%%-%O\=,LWl.e/,%/%%f%T%%-%%%%%%%%%&%%E%%%%%%%%%iwf&&Sgf%xup&%'9„U"%9%%%%-#%hYMRGoZ4+9O+%%%%5%%%/%%%%%%%%%%%E[%%%R%/%%x#hwf&%qSks%„U"yup&%'9%9%%%%-F%*zdpFv/#**Y*%%%%5%%%0%%%%%%%%%%%E[%%%P%6%%i%nln„U"y%fqSk%syup%&'9%%9%%%#-%n'JdFg(*Z#i*%%%%5%%%0%%%%%%%%%%%%E%%%&Y„U"<%%%ijkf%zqyS%ksyu%p&'9%%9%%%%-%g(YMG?8x$tN%)%%%%-%%,%%%%%%%%%%„U"%%E%%+%pA%.%]']%Sksy%up&'%9%9%%%%-%.gYMGSM),9&V)%%%%-%%%0%%%%%%„U"%%%%%E%%%%jF#%%]'%]ymn%sSks%yup&%'9%9%%%%-%%Nb\(HC[)&4g*%%%%5%%„U"%.%%%%%%%%%%%E[%%%n%J%%k%qnum%Sksy%up&'%9%9%%%%-%.hYMG.m6ya%P+%„U"%%%5%%%.%%%%%%%%%%%E%.%%-P%%%wt%rfsS%ksyu%p&'9%%9%%[%-%1(Q8AK>#„U"].U%*%%%%5%%-%%%%%%%%%%%%E%%+%)V%%%xfs%xSks%yup&%'9%9%%%%-F%*zd„U"pFv/#**Y*%%%%5%%%/%%%%%%%%%%%E%%%%+%\%%x&(xyj%rSks%yup&%'9%9%%%„U"%-L%YidCFZoC%Gx*%%%%5%%%.%%%%%%%%%%%E[%%%1%a%%y%mnhp%Sksy%up&'%„U"9%9%%%%-%3gcdF<%&3L&J*%%%%5%%%-%%%%%%%%%%%E%%%%Wg%%%ym%nsSk%syu„U"p%*+%%%%%1%.1%f'7%%Ll%%%%%„END SUB„V2„CLOSE:IF S=174AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Mathew Wilson                  A BASIC SHELL V1.0             lastime16@hotmail.com          08-14-99 (20:50)       PB                     186  6414     SHELL.BAS   ' This is the Source Code for "A Basic Shell".„' This Source Code and Program is copyrighted by Mathew Wilson„' This Source Code was Written in Power Basic Ver 3.2„'„' This File may be changed and distributed as long as the original„' "A Basic Shell.exe" (or "ABASIC~1.exe"), Shell.bas and Shell.txt„' is distributed with the changed file/files.„'„' Any further Questions can be sent to lastime16@hotmail.com„'„'„'„'„'„'„'„'„'„'Starting Variables„shell "c:"„shell "cd\"„current_drive$ = "c:"„directory_series$ = ""„current_directory$ = ""„Press_Key$ = ""„Run_Program$ = ""„„„'Credits„cls„locate 7,31: Print "_______________________"„locate 8,30: Print "|     A Basic Shell     |"„locate 9,30: Print "|      Version 1.0      |"„locate 10,30: Print "|                       |"„locate 11,30: Print "|    Copyrighted and    |"„locate 12,30: Print "|      Created  By      |"„locate 13,30: Print "|     Mathew Wilson     |"„locate 14,30: Print "|                       |"„locate 15,30: Print "| lastime16@hotmail.com |"„locate 16,30: Print "|_______________________|"„„Loop_A:„Press_Key$ = Inkey$„If Press_Key$="" goto Loop_A:„„„'Start Screen„Start_Screen:„cls„locate 1,5: Print "Directory"„locate 2,5: Print "^"„locate 1,20: Print "Run"„locate 2,20: Print "^"„locate 1,29: Print "Options"„Locate 2,29: Print "^"„locate 1,43: Print "Dos"„locate 2,45: Print "^"„Locate 1,52: Print "Quit"„Locate 2,52: Print "^"„locate 4,1: Shell "dir/w"„„Loop_B:„Press_Key$ = Inkey$„If Press_Key$="D" goto Directory:„If Press_Key$="d" goto Directory:„If Press_Key$="R" goto Runn:„If Press_Key$="r" goto Runn:„If Press_Key$="O" goto Options:„If Press_Key$="o" goto Options:„If Press_Key$="S" goto Dos:„If Press_Key$="s" goto Dos:„If Press_Key$="Q" goto Quit:„If Press_Key$="q" goto Quit:„Goto Loop_B:„„„'Change Drive/Directory Routine„Directory:„locate 1,5:  Print "DIRECTORY"„locate 2,5:  Print "~~~~~~~~~"„locate 4,1:  Print " __________________________________________________"„locate 5,1:  Print "| Current Drive:                                   |"„locate 6,1:  Print "|         ^    "; Current_Drive$;"                                  |"„locate 7,1:  Print "|                                                  |"„locate 8,1:  Print "| Current Directory:                               |"„Locate 9,1:  Print "| ^                "Directory_Series$;"                                |"„locate 10,1: Print "|                                                  |"„locate 11,1: Print "|                   Okay                           |"„locate 12,1: Print "|                   ^                              |"„Locate 13,1: Print "|__________________________________________________|"„„Loop_C:„Press_Key$ = Inkey$„If Press_Key$="D" goto Change_Drive:„If Press_Key$="d" goto Change_Drive:„If Press_Key$="C" goto Change_Directory:„If Press_Key$="c" goto Change_Directory:„If Press_Key$="O" goto Start_Screen:„If Press_Key$="o" goto Start_Screen:„Goto Loop_C:„„Change_Drive:„Locate 5,3: Print "CURRENT DRIVE"„Locate 6,3: Print "~~~~~~~ ~~~~~"„Locate 7,17: Input Current_Drive$„Locate 16,5: Shell Current_Drive$„Goto Directory:„„Change_Directory:„Locate 8,3: Print "CURRENT DIRECTORY"„Locate 9,3: Print "~~~~~~~ ~~~~~~~~~"„Locate 10,17: Input Current_Directory$„Locate 16,5: Shell "cd "+Current_Directory$„Directory_Series$ = Directory_Series$ + "\" + Current_Directory$„Goto Directory:„„„'Run Program Routine„Runn:„locate 1,20: Print "RUN"„locate 2,20: Print "~~~"„locate 4,1:  Print " __________________________________________________"„locate 5,1:  Print "|                                                  |"„locate 6,1:  Print "| Run:                                             |"„locate 7,1:  Print "|                                                  |"„Locate 8,1:  Print "|__________________________________________________|"„locate 7,6:  Input Run_Program$„If Run_Program$ = "" Then Goto Start_Screen:„Shell Run_Program$„Goto Start_Screen:„„'Change Options Routine„Options:„locate 1,29: Print "OPTIONS"„Locate 2,29: Print "~~~~~~~"„locate 4,1:  Print " __________________________________________________"„locate 5,1:  Print "|                                                  |"„locate 6,1:  Print "|          There are currently no options.         |"„locate 7,1:  Print "|               Check Later Versions.              |"„Locate 8,1:  Print "|__________________________________________________|"„„Loop_D:„Press_Key$ = Inkey$„If Press_Key$="" goto Loop_D:„Goto Start_Screen:„„„'Dos Prompt Routine„Dos:„locate 1,43: Print "DOS"„locate 2,43: Print "~~~"„locate 4,1:  Print " __________________________________________________"„locate 5,1:  Print "|                                                  |"„locate 6,1:  Print "|  A Basic Shell - DOS Mode - Type Exit to return  |"„Locate 7,1:  Print "|__________________________________________________|"„Locate 8,1:  Print "                                                                           "„Print "                                                                             "„Print "                                                                             "„Print "                                                                             "„Print "                                                                             "„Print "                                                                             "„Print "                                                                             "„Print "                                                                             "„Print "                                                                             "„locate 6,1:  Shell„Goto Start_Screen:„„„'Quit Program„Quit:„locate 4,1:  Print " __________________________________________________"„locate 5,1:  Print "|                                                  |"„locate 6,1:  Print "|  Yes         Do You Want to Quit?            No  |"„locate 7,1:  Print "|  ^                                           ^   |"„Locate 8,1:  Print "|__________________________________________________|"„„Loop_E:„Press_Key$ = Inkey$„If Press_Key$="y" goto End_:„If Press_Key$="Y" goto End_:„If Press_Key$="n" goto Start_Screen:„If Press_Key$="N" goto Start_Screen:„Goto Loop_E:„„„End_:„Dieter Folger                  TSR ASSISTANT FOR PB IDE       folger@bamberg.baynet.de       09-19-99 (19:36)       PB                     396  13783    PBASSI.BAS  $IF 0„  ---------------------------------------------------------------------------„  PBASSI.BAS for PowerBasic„  A TSR program for moving quickly to functions and subs in the IDE.„  Freeware (c) 1996 by Dieter Folger„  ---------------------------------------------------------------------------„  PB-ASSIstant is a handy little TSR for Power Basic programmers. It helps„  you to move quickly to functions and procedures in your source code when„  you are in the Power Basic IDE.„  When PBASSI is resistant, press Alt-F2 and you get a box with a list of„  all FUNCTIONs and SUBs in your source. You can choose by moving the„  cursor up and down and then pressing Enter. As quickly as lightning you„  are at the procedure and can work there. When you choose "Return to„  previous line" you are back at the line where you started from.„„  If you have written a new procedure you should press F2 (=Save). Next„  time PBASSI is invoked, the program will read the source again and the„  list of procs is updated.„„  You can remove the program from memory with Alt-F2 at the DOS prompt.„  First you get a message that you can only use the program within the IDE.„  If you press 'U' now PBASSI is uninstalled.„„  PBASSI supports the mouse. Left button works like Return, right button„  like Esc. If there are more procedures that the window can show, click„  the down arrow for PgDn or the up arrow for PgUp.„  --------------------------------------------------------------------------„$ENDIF„ POPUP MULTIPLEX &HC000, 254   ' reg AX and DX get this pattern as an ID„ REG 1, &HC000 : REG 4, 254    ' set pattern to check for already installed„ CALL INTERRUPT &H2F           ' do the multiplex interrrupt„ IF REG(1)<> &HC000 AND REG(4)<> 254 THEN END„ SaveScreen Temp$„ Box 16, 20, 4, 41, 15, 3„ LOCATE 17, 22„ PRINT "       P B - A S S I S T A N T        "„ LOCATE 18, 22„ PRINT "Now installed. Use in IDE with ALT-F2 "„ LOCATE 19,22„ PRINT "            (Press a key)             "„ WaitKey„ COLOR 7, 0„ RestoreScreen Temp$„ x& = SETMEM(-600000)„ x& = SETMEM(1024)„ POPUP KEY CHR$(8, 60, 119)     ' Alt-F2 is hot key„ SwapFile$ = LEFT$(CURDIR$, 2)+ "\"+ "PBASSI.SWP"„ REG 1, &HC001 : REG 4, 252„ POPUP SLEEP USING EMS, SwapFile$„ WHILE NOT Done„       IF REG(1)= &HC000 AND REG(4)= 254 THEN„          Jingle„          PRINT " PBASSI already installed.  "„          PRINT " If you want to uninstall press ALT-F2 "„          PRINT " and then 'U' to remove it from memory "„       ELSE„          'check if we are in Power Basic's IDE:„          Sc$ = ScreenRead$ (1, 1, 28)„          IF Sc$ <>  "     File     Edit     Search" THEN„             SaveScreen Temp$„             Box 16, 21, 4, 39, 15, 3„             LOCATE 17, 22„             PRINT "   Use PBASSI in PowerBasic IDE only  "„             LOCATE 18, 22„             PRINT "If you want to uninstall press 'U' now"„             LOCATE 19, 22„             PRINT "     or any other key to continue     "„             DO: K$= UCASE$(INKEY$): LOOP UNTIL LEN(K$)„             COLOR 7, 0„             IF K$= "U" THEN„                IF POPUP(1) THEN„                   RestoreScreen Temp$„                   PRINT : PRINT "PBASSI removed from memory"„                   END„                ELSE„                   Jingle„                END IF„             END IF„             RestoreScreen Temp$„             GOTO Go2Sleep„          ELSE„             File$= WorkFile$„             S$= ScreenRead(6, 20, 1)„             IF File$="" OR S$="…Õ" THEN„                Jingle„                SaveScreen Temp$„                Box 16, 23, 3, 34, 15, 3„                LOCATE 17, 24„                PRINT "Cannot continue. Quit menu first."„                LOCATE 18, 24„                PRINT "          (Press a key)          "„                Waitkey„                RestoreScreen Temp$„                GOTO Go2Sleep„             END IF„             IF DIR$(File$)= "" THEN     'we have an empty new file„                Jingle„                GOTO Go2Sleep„             END IF„             OPEN File$ FOR INPUT AS #1  ' Read sourcefile and get„             Fs&= LOF(1)                 '      filesize„             IF Fs&<> Ofs& THEN          ' when old and new size do„                Ofs&= Fs&                ' not match read source again„                Procs = 100              ' increase value for large programs„                REDIM Cmd$(Procs)        ' the source file again„                FOR i= 1 TO Procs: Cmd$(i)= "": NEXT„                MaxCmd= 1„                Cmd$(MaxCmd)= "Return to previous line"„                WHILE NOT EOF(1)„                      LINE INPUT #1, L$„                      L$= LTRIM$(UCASE$(L$))„                      IF INSTR(L$, "FUNCTION")= 1 OR INSTR(L$, "SUB")= 1 THEN„                         IF INSTR(L$,"FUNCTION") AND INSTR(LTRIM$(MID$(L$,9)),"=") = 1 THEN EXIT IF„                         INCR MaxCmd„                         IF MaxCmd > Procs THEN EXIT LOOP„                         IF INSTR(L$,"'") THEN L$ = LEFT$(L$,INSTR(L$,"'")-1)„                         Cmd$(MaxCmd)= LTRIM$(RTRIM$(L$))„                         LL= LEN(Cmd$(MaxCmd))„                         IF LL> Length THEN Length= LL„                      END IF„                WEND„             END IF„             CLOSE„             IF Cmd$(2)= "" THEN  'It's a program without„                Jingle            ' functions and subs„                GOTO Go2Sleep„             END IF„             IF StartLine$= "" THEN„                IF Screen (21, 1)= 192 THEN„                   StartLine$= ScreenRead$ (21, 4, 4)„                ELSE„                   StartLine$= ScreenRead$ (24, 4, 4)„               END IF„            END IF„            SaveScreen Temp$„            Again:„            F$= ChooseBox$„            IF F$= "Return to previous line" THEN„               IF Screen (21, 1)= 192 THEN„                  PresentLine$= ScreenRead$ (21, 4, 4)„               ELSE„                  PresentLine$= ScreenRead$ (24, 4, 4)„               END IF„               IF StartLine$ = PresentLine$ THEN„                  Jingle„                  GOTO Again„               END IF„            END IF„            RestoreScreen Temp$„            IF LEN(F$) THEN„               IF F$= "Return to previous line" THEN„                  IF LEN(StartLine$) THEN„                     Stuf$= CHR$(0, 0, 31)       'Alt-S = Search„                     POPUP STUFF Stuf$, 5, 0„                     DELAY .07„                     Stuf$= "G"                  'G = Goto line number„                     POPUP STUFF Stuf$, 5, 0„                     DELAY .07„                     Stuf$= Startline$+ CHR$(13) 'Line number + Cr„                     POPUP STUFF STUF$, 5, 0„                     DELAY .07„                     StartLine$= ""„                  END IF„               ELSE„                  DELAY .07„                  Stuf$= CHR$(0,0)+ CHR$(118) 'Ctrl-PgDn = Goto end of text„                  POPUP STUFF Stuf$, 5, 0„                  Stuf$= CHR$(17)+ "F"        'Ctrl-Q+F = Find...„                  POPUP STUFF Stuf$, 5, 0„                  Stuf$= F$+ CHR$(13)         'Insert proc name„                  POPUP STUFF STUF$, 5, 0„                  Stuf$= "BU"+ CHR$(13)       'Search whole text, any case„                  POPUP STUFF STUF$, 3, 0„               END IF„            END IF„         END IF„       END IF„       Go2Sleep:„       REG 1, &HC001: REG 4, 252„       POPUP SLEEP„ WEND„'-----------------------------------„FUNCTION ScreenRead$ (y, x, Length)„'-----------------------------------„ Sc$= ""„ FOR i= x TO x+ Length„   Sc$= Sc$+ CHR$(SCREEN(Y, i))„ NEXT„ ScreenRead$= Sc$„END FUNCTION„'----------------------------------------„FUNCTION WorkFile$ 'Read name of PB file„'----------------------------------------„ F$ = ScreenRead$(2, 2, 73)„ IF INSTR(F$,"ƒ") THEN„    File$ = ""      'IDE-Menu active„    EXIT FUNCTION  'window covers filename„ END IF„ REPLACE "Õ" WITH "" IN F$„ WorkFile$= F$„END FUNCTION„'------------------------------------„SUB SaveScreen (Scrn$) PUBLIC SHARED„'------------------------------------„  cy%= CSRLIN: cx%= POS(0)„  LOCATE ,, 0„  IF (pbvScrnCard AND 1) = 0 THEN„	Address= &HB800„  ELSE„	Address= &HB000„  END IF„  DEF SEG= Address„      Scrn$= PEEK$(0, 4000)„  DEF SEG„END SUB„'---------------------------------------„SUB RestoreScreen (Scrn$) PUBLIC SHARED„'---------------------------------------„  IF (pbvScrnCard AND 1)= 0 THEN„	Address= &HB800„  ELSE„	Address= &HB000„  END IF„  DEF SEG= Address„      POKE$ 0, Scrn$„  DEF SEG„  LOCATE cy%, cx%, 1„END SUB„'-----------------------------------------------„SUB Box (Row, Col, Rows, Cols, Fgc, Bgc) PUBLIC„'-----------------------------------------------„ COLOR Fgc, Bgc„ LOCATE Row, Col„ PRINT "⁄"+ STRING$(Cols- 1, "ƒ")+ "ø"„ LOCATE Row+ Rows, Col„ PRINT "¿"+ STRING$(Cols- 1, "ƒ")+ "Ÿ"„ FOR i= 1 TO Rows- 1„     LOCATE Row+ i, Col„     PRINT "≥"+ SPACE$(Cols- 1)+ "≥"„ NEXT„END SUB„'---------------------------------„FUNCTION ChooseBox$ PUBLIC SHARED„'---------------------------------„ Mouse = M.There„ IF L < 10 THEN Rows = L + 1 ELSE Rows = 11„ Row= 10: Col= 25: Rows= 10: Cols= 30„ Box Row, Col, Rows, Cols, 15,3„ LOCATE Row, Col+ 3„ PRINT " Press RETURN to select "„ LOCATE Row+ Rows, Col+ 6„ PRINT " Press ESC to quit "„ BarLine= Row+ 1„ Start= 1: Offset= 1„ GOSUB WriteBox„ IF Mouse THEN„    M.Window Row+ 1, Col, Rows- 1, Cols+ 1„    M.Cursor 1„ END IF„ DO„   DO„     K$= INKEY$„     IF Mouse THEN„        M.Event Rgt, Lft, Mrow, MCol„        IF Rgt THEN K$= CHR$(27)„        IF Lft THEN„           IF SCREEN(MRow, MCol)= 25 THEN K$= CHR$(0, 81): EXIT IF 'Down„           IF SCREEN(MRow, MCol)= 24 THEN K$= CHR$(0,73): EXIT IF 'Up„           IF MRow> Row AND MRow< Row+ Rows AND MCol> Col _„              AND MCol< Col+ Cols THEN„              ChooseBox$ = Cmd$(Start+ MRow- 11)„              EXIT FUNCTION„           END IF„        END IF„     END IF„   LOOP UNTIL LEN(K$) OR Lft„   SELECT CASE K$„          CASE CHR$(0, 77)  ' Cursor right„               IF Offset< Length- 18 THEN INCR Offset„          CASE CHR$(0, 75)  ' Cursor left„               IF Offset> 1 THEN DECR Offset„          CASE CHR$(0, 80)  ' Cursor down„               IF BarLine< Row+ Rows- 1 AND Barline- Row+ Start- 1< MaxCmd THEN„                  INCR BarLine„               ELSE„                  IF Start+ Rows- 2< MaxCmd THEN INCR Start„               END IF„          CASE CHR$(0, 72)  ' Cursor up„               IF Barline> Row+ 1 THEN„                  DECR Barline„               ELSE„                  IF Start> 1 THEN DECR Start„               END IF„         CASE CHR$(0, 81)  ' Page down„              IF MaxCmd> Rows- 1 THEN„                 INCR Start, Rows- 1„                 IF Start+ Rows- 1> MaxCmd THEN Start= MaxCmd- Rows+ 2„              END IF„         CASE CHR$(0,73)   ' Page up„              DECR Start, Rows- 1: IF Start< 1 THEN Start= 1„         CASE CHR$(0,79)   ' End„              IF Rows<= MaxCmd THEN„                 Start= MaxCmd- (Rows- 2)„              END IF„              Barline= MaxCmd- Start+ Row+ 1„         CASE CHR$(0,71)   ' Home„              Start= 1: BarLine= Row+ 1„         CASE ELSE: EXIT SELECT„  END SELECT„  GOSUB WriteBox„ LOOP UNTIL K$= CHR$(27) OR K$= CHR$(13)„ IF K$= CHR$(27) THEN ChooseBox$= ""„ IF K$= CHR$(13) THEN ChooseBox$= Cmd$(Start+ Barline- Row- 1)„ EXIT FUNCTION„'---------„ WriteBox:„'---------„ IF Mouse THEN M.Cursor 0„ FOR i= Row+ 1 TO Row+ Rows- 1„    IF Start+ i- Row- 1> MaxCmd THEN EXIT FOR„    LOCATE i, Col+ 1„    IF i= Barline THEN COLOR 15, 4 ELSE COLOR 0, 3„    PRINT MID$(Cmd$(Start+ i- Row- 1)+ SPACE$(Cols), Offset, Cols- 2)„    COLOR 14, 3„    LOCATE Row+ Rows- 1,Col+ Cols„    IF Start+ Rows- 1< MaxCmd THEN„       COLOR 14, 1: PRINT CHR$(25)„    ELSE„       COLOR 15, 3: PRINT "≥"„    END IF„    LOCATE Row+ 1, Col+ Cols„    IF Start> 1 THEN„       COLOR 14, 1: PRINT CHR$(24)„    ELSE„       COLOR 15, 3: print "≥"„    END IF„ NEXT„ COLOR 15, 3„ IF Mouse THEN M.Cursor 1„ RETURN„END FUNCTION„'-----------„SUB WaitKey„'-----------„ DO: K$= INKEY$: LOOP UNTIL LEN(K$)„END SUB„'----------„SUB Jingle„'----------„ SOUND 300, .3: SOUND 700, .3„END SUB„'----------------------------------„FUNCTION M.There PUBLIC AS INTEGER„'----------------------------------„ REG 1, 0„ CALL INTERRUPT &H33„ M.There = REG(1)„END FUNCTION„'--------------------------„SUB M.Cursor (Mode) PUBLIC„'--------------------------„ IF Mode THEN REG 1, 1 ELSE REG 1, 2„ CALL INTERRUPT &H33„END SUB„'-------------------------------------------------„SUB M.Event (R.Button, L.Button, Row, Col) PUBLIC„'-------------------------------------------------„ R.Button = 0 : L.Button = 0 : Row = 0 : Col = 0„ REG 1, 3„ CALL INTERRUPT &H33„ SELECT CASE REG(2)„        CASE 1 : L.Button = 1„        CASE 2 : R.Button = 1„ END SELECT„ IF R.Button=0 AND L.Button=0 THEN EXIT SUB„ Row = REG(4) \ 8 + 1„ Col = REG(3) \ 8 + 1„ ' wait until the button is released„ DO„    REG 1, 3„    CALL INTERRUPT &H33„ LOOP UNTIL REG(2) = 0„END SUB„'------------------------------------------„SUB M.Window (Row, Col, Rows, Cols) PUBLIC„'------------------------------------------„ REG 3, 8 * (Col + Cols - 2)„ REG 4, 8 * (Col - 1)„ REG 1, 7„ CALL INTERRUPT &H33„ REG 3, 8 * (Row - 1)„ REG 4, 8 * (Row + Rows - 2)„ REG 1, 8„ CALL INTERRUPT &H33„END SUB„'=== eof ================================================================„Randall L. Glass               GET DIRECTORY INFORMATION      rlglass@yahoo.com              10-25-99 (18:05)       PB                     67   2549     DIRINFO.BAS '-------------------------------------------------------------------------„'„'                         GetDirInfo„'                      BY Randall L Glass„'                      CopyRight Aug3,1999„'„'---------------------------------------------------------------------------„'„' Email rlglass@yahoo.com„' Snail Mail RR1,BOX 248,McLeansboro,IL 62859„'---------------------------------------------------------------------------„'„' This Program is Public Domain(PowerBasic Code)„'„'  You Must Call this routine after each DIR$ to get directory infomation„'„'----------------------------------------------------------------------------„„„SUB GetDirInfo(DirDate$,DirTime$,DirSize???,DirAttrib?) PUBLIC„  LOCAL DirDate??,DirTime??,DirAttr?,Dsize???„  ! mov  AX, &H2F00              ; function 2Fh, get DTA location„  ! int  &H21                    ; call DOS„  ! MOV  AX,ES:[BX + 24]„  ! MOV  DirDate??,AX„  ! MOV  AX,ES:[BX + 22]„  ! MOV  DirTime??,AX„  ! MOV  AX,ES:[BX +26]„  ! MOV  DSize???[0],AX„  ! MOV  AX,ES:[BX +28]„  ! MOV  DSize???[2],AX„  ! MOV  AL,ES:[BX +21]„  ! MOV  DirAttr?,AL„  DirSize??? = DSize???„  DirAttrib? = DirAttr?„    GetDateAndTime DirDate??,DirTime??,DirDate$,DirTime$„END SUB„„SUB GetDateAndTime(Filedate??,FileTime??,Filedate$,FileTime$) PUBLIC„       Year?? = (Filedate?? AND &B1111111000000000):SHIFT RIGHT Year??,9„       INCR Year??,1980„       Month?? = Filedate?? AND &B0000000111100000:SHIFT RIGHT Month??,5„       Day?? = Filedate?? AND &B0000000000011111„       Hours?? = FileTime?? AND &B1111100000000000:SHIFT RIGHT Hours??,11„       Minutes?? = FileTime?? AND &B0000011111100000:SHIFT RIGHT Minutes??,5„       Seconds?? = (FileTime?? AND &B0000000000011111) * 2„„       Month$ = LTRIM$(STR$(Month??))„       Day$ = LTRIM$(STR$(Day??))„       IF LEN(Month$) = 1 THEN Month$="0"+Month$„       IF LEN(Day$) = 1 THEN Day$ = "0"+Day$„       'IF Hours?? > 12 THEN„       '	Hours?? = Hours?? -12:AmPm$ = "p & "„       'ELSE„       '	AmPm$ = "a & "„       'END IF„       Hours$ = LTRIM$(STR$(Hours??))„       Minutes$ = LTRIM$(STR$(Minutes??))„       Seconds$ = LTRIM$(STR$(Seconds??))„       IF LEN(Hours$) = 1 THEN Hours$="0"+Hours$„       IF LEN(Minutes$) = 1 THEN Minutes$="0"+Minutes$„       IF LEN(Seconds$) = 1 THEN Seconds$="0"+Seconds$„„       Filedate$ = Month$ + "-" + Day$ + "-" + LTRIM$(STR$(Year??))„       FileTime$ = Hours$ + ":" + Minutes$ + ":" + Seconds$„       'FileTime$ = Hours$ + ":" + Minutes$ + AmPm$ + Seconds$ +"s"„END SUB„Randall L. Glass               VIEW ZIP FILES                 rlglass@yahoo.com              10-25-99 (18:05)       PB                     728  24075    VIEWZIP.BAS '-------------------------------------------------------------------------„'„'                   ViewZip BY Randall L Glass„'                      CopyRight Aug3,1999„'„'---------------------------------------------------------------------------„'„' Email rlglass@yahoo.com„'„'---------------------------------------------------------------------------„'„' This Program is Freeware„' You may do anything with this program AS long AS you give me credit„' somewhere in the documentation.„'„' No frills Program to view ZIP Files for PB by Randall Glass.„'„' Use this program to add an ZIP & Lzh viewer in Dosshell.„'„' You must SET the value of TEMP in your autoexec.bat file.„' Example SET TEMP = D:\TMP„'„' OR Rewrite the code in the program to set TempDir to your tempory directory.„' And Rewrite the code to your editor or file viewer.„'„' Example SET Association in Dosshell For ZIP and LZH Files.„'„' C:\path\Viewzip.exe edit.com„'„' Dosshell beats Win 95 Windows Explorer any old time.„'„' To Run from DOS.„'„' Syntax  ViewZip [Editor OR File View Program] [ Zip OR Lzh File]„'„' Example >  ViewZip edit wetspot.zip„'„'----------------------------------------------------------------------------„„$STACK 15000„DEFINT A-Z„„TYPE ZipType„    Signature      AS DWORD„    Version        AS WORD„    GPBFlag        AS WORD„    Compress       AS WORD„    FileTime       AS WORD„    Filedate       AS WORD„    CRC32          AS DWORD„    CompressSize   AS DWORD„    UnCompressSize AS DWORD„    FileNameLen    AS WORD„    ExtraField     AS WORD„END TYPE„„TYPE LZHHead„     HeadSize       AS BYTE„     CheckSum       AS BYTE„     Id1            AS STRING * 3„     Method         AS BYTE„     Id2            AS BYTE„     CompressSize   AS DWORD„     UnCompressSize AS DWORD„     FileTime       AS WORD„     FileDate       AS WORD„     Attrs          AS BYTE„     HeaderLevel    AS BYTE„     FileNameLen    AS BYTE„     FileName       AS STRING * 12„END TYPE„„DECLARE Function GetKey%() AS INTEGER„DECLARE SUB GetStrLoc()„DECLARE SUB BoxBorder ()„DECLARE SUB Scroll(BYVAL TopRow%,BYVAL TopLeftCol%,BYVAL BottomRow%,BYVAL BottomRightCol%,BYVAL TotalLines%,BYVAL Attr%,BYVAL WhichWay%)„„DIM ScreenSegment AS shared WORD„DIM DirStack$(10)„„SHARED Viewer$,TempDir$,Level%,StackPos%,DirStack$(),Archiver$,ViewCmd$„SHARED StartLine$,EndLine$,FileList$,Response$,ExtractCmd$,ExtractReponse$„„„%PkSig = &H04034B50             ' Signature„%UpArrow = -72:%DownArrow = -80:%Enter = 13:%Escape = 27„%Home = -71:%PageDown = -81:%PageUp = -73:%EndKey = -79„%Up = 6:%Down = 7:%LeftArrow = -75:%RightArrow = -77„%U = 85„%ReadOnly = 0:%Hidden = 1:%System = 2:%Volume = 3:%SubDir = 4:%Archive = 5„%TotalFiles = 0„„IF(PBVScreenCARD AND 1) = 0 THEN„      ScreenSegment?? = 47104       '&HB800          'color monitor„ELSE„      ScreenSegment?? = 45056       '&HB000          'mono monitor„END IF„„CLS„LOCATE 1,1,0„Cmd$ = UCASE$(COMMAND$)„Viewer$ = Extract$(Cmd$," ")„File$ = Trim$(Remove$(Cmd$,Viewer$))„Ext$ = Extension$(File$)„File$ = TrueName$(File$)„IF ISFALSE FileExist%(File$) THEN END„„TempDir$ = ENVIRON$("TEMP")„„PushDir TempDir$„„ViewZip File$„„COLOR 7,0„CLS„END„„SUB ViewZip(File$)„IF ISFALSE FileExist%(File$) THEN„	LOCATE 5,15:PRINT File$;" doesn't exist !";„      EXIT SUB„END IF„DIM ArchiveFiles$(1000),ArchiveInfo$(1000),ArchiveDir$(1000)„  Choice% = 1:DisplayPos% = 1:LowFIle% = 1:HiFile% = 18„  Ky% = 0„  InfoLine$ = "   FileName"+"       Size"+"     Date" + "       Time"„  CLS„  Ext$ = Extension$(File$)„   IF Ext$ = ".ZIP" OR Ext$ = ".LZH" THEN„      PresentDir$ = CURDIR$„      PresentDrive$ = CURDRIVE$„      CHDRIVE Left$(File$,1)„      CHDIR GetDirectory$(File$)„      SELECT CASE Ext$„          CASE ".ZIP"„                ZipView GetFileName$(File$), ArchiveFiles$(), ArchiveInfo$(), FilesInfo$,Success%„          CASE ".LZH"„                LzhView GetFileName$(File$), ArchiveFiles$(), ArchiveInfo$(), FilesInfo$„      END SELECT„      CHDRIVE PresentDrive$„      CHDIR PresentDir$„      TotalFiles?? = CVWRD(ArchiveFiles$(%TotalFiles))„      'ARRAY SORT ArchiveFiles$(1) FOR TotalFiles??,TAGARRAY ArchiveInfo$()„      DO„               Pick% = ChooseProgram%( ArchiveInfo$(),ArchiveFiles$(),FilesInfo$,InfoLine$,Choice%,DisplayPos%,LowFile%,HiFile%,Ky%)„               Choice% = Pick%„                SELECT CASE Ky%„                        CASE %Escape„                                EXIT SUB„                        CASE %Enter„                                IF Pick% > 0 THEN„                                		Pick$ = UCASE$(ArchiveFiles$(Pick%))„                                          RealName$ = GetFileName$(Pick$)„                                        	PickExt$ = Extension$(Pick$)„                                        	IF PickExt$ =".ZIP" OR PickExt$ = ".LZH" THEN„                                                PushDir "TEMP"„                                                RealDir$ = TrueDir$ + "\"„                                                IF ISFALSE FileExist%(RealDir$+Pick$) THEN„                                                        CLS„                                                        SELECT CASE Ext$„                                                        CASE ".ZIP"„                                                                SHELL "PkUnzip -e -o " + File$ + " " + Pick$ + " " + RealDir$ + " >NUL"„                                                        CASE ".LZH"„                                                                SHELL "lha e /pn2 " + File$ + " " + RealDir$ + " "+ Pick$„                                                  END SELECT„                                                END IF„„                                                ViewZip RealDir$ + RealName$„                                                SHELL "DELTREE /Y " + Rtrim$(RealDir$,"\") + " >NUL"„                                                PopDir„                                                CLS„                                                DELAY .2„                                                ITERATE LOOP„                                        	ELSE„                                                CLS„                                                RealDir$ = TrueDir$ + "\"„                                                SELECT CASE Ext$„                                                        CASE ".ZIP"„                                                                SHELL "PkUnzip -e -o " + File$ + " " + Pick$ + " " + RealDir$ + " >NUL"„                                                        CASE ".LZH"„                                                                SHELL "lha e /pn2 " + File$ + " " + RealDir$ + " "+ Pick$„                                                END SELECT„                                        	END IF„                                        'CLS„                                        PresentDir$ = CURDIR$„                                        PresentDrive$ = CURDRIVE$„                                        CHDRIVE LEFT$(TrueDir$,1)„                                        CHDIR TrueDir$„                                        SHELL Viewer$ + " " + RealName$„                                        CLS„                                        KILL RealName$„                                        CHDRIVE PresentDrive$„                                        CHDIR PresentDir$„                                        DELAY .2„                                        COLOR 7,0„                                    END IF„                        'CASE %U„                END SELECT„      LOOP„   END IF„END SUB„„FUNCTION ChooseProgram%(ArchiveInfo$(),ArchiveFile$(),InfoLine1$,InfoLine2$ ,Choice%, DisplayPos%,LowFile%, HiFile%,Ky%)„   DIM PrintLine AS STRING * 47„   DIM DirLine AS STRING * 80„   DisplayLine% = 18„„   TotalFiles% = CVWRD(ArchiveInfo$(0))„   IF TotalFiles% < DisplayLine% THEN HiFile% = TotalFiles%„„     BottomDisplayLine% = DisplayLine%„     COLOR 7,1„     CLS„     COLOR 0,7„     LOCATE 1,1:PRINT SPACE$(80);„     COLOR 7,1„     LOCATE 2,2:PRINT Ltrim$(InfoLine1$)„     LOCATE 4,2:PRINT InfoLine2$„„   DO„      COLOR 15, 1„      LinePos% = 0„      IF TotalFiles% < 15 THEN BottomDisplayLine% = TotalFiles%„      IF ScrollIt% = 0 THEN„	      'POKE$ 0, SaveScreen$ : LOCATE y%, x%       'restore old screen„	      FOR ArchiveFile% = LowFile% TO HiFile%„	         INCR LinePos%„               LSET PrintLine$ = ArchiveInfo$(ArchiveFile%)„	         IF LinePos% = DisplayPos% THEN„	            QPrint 5 + LinePos%,1, PrintLine$ ,71„	         ELSE„	            QPRINT 5 + LinePos%,1,PrintLine$,23„	         END IF„	      NEXT ArchiveFile%„		LSET PrintLine$ = ""„            FOR I% = LinePos% + 1 To DisplayLine%„	            QPRINT 5 + I%,1,PrintLine$,23„            NEXT I%„      ELSE„		LSET PrintLine$ = ArchiveInfo$(Choice%)„            QPRINT 5 + DisplayPos%,1,PrintLine$,71„      END IF„„      DirLine$ = SPACE$(80)„      MID$(DirLine$,2) = ArchiveFile$(Choice%)„      COLOR 0,7:LOCATE 25,1:PRINT DirLine$;„„      ScrollIt% = 0„      ClearBuffer„      DO: k$ = UCASE$(INKEY$): LOOP WHILE k$ = ""„      Ky% = ASC(k$): IF Ky% = 0 THEN Ky% = -ASC(MID$(k$, 2))„       SELECT CASE Ky%„         CASE %Enter„         	ChooseProgram% = choice%: EXIT DO„         CASE %Escape„         	ChooseProgram% = 0: EXIT DO„         CASE %Home„         	choice% = 1:LowFile% = 1„            HiFile% = BottomDisplayLine%„            DisplayPos% = 1„         CASE %EndKey„            Choice% = TotalFiles%„            DisplayPos% = MODTYPE(Choice%, BottomDisplayLine%)„            LowFile% = Choice% - DisplayPos% + 1„            HiFile% = TotalFiles%„         CASE %PageDown„            INCR Choice%, DisplayLine%„            INCR LowFile%,DisplayLine%„            HiFile% = LowFile% + BottomDisplayLine% -1„            IF HiFile% > TotalFiles% THEN HiFile% = TotalFiles%„		IF choice% > TotalFiles% THEN„			Choice% = TotalFiles%„                        DisplayPos% = ModType(Choice%, BottomDisplayLine%)„			LowFile% = Choice% - DisplayPos% + 1„			HiFile% = TotalFiles%„	      END IF„„         CASE %PageUp„            DECR Choice%,DisplayLine%„            DECR LowFile%,DisplayLine%„            HiFile% = LowFile% + DisplayLine% -1„            IF LowFile% < 1 THEN LowFile% = 1:HiFile% = BottomDisplayLine%„	      IF Choice% <=1 THEN„              Choice% = 1„              LowFile% = 1„              HiFile% = BottomDisplayLine%„              DisplayPos% = 1„      	END IF„         CASE %DownArrow„            INCR Choice%„            IF Choice% <= TotalFiles% THEN„                  INCR DisplayPos%„            ELSE„            	Choice% = TotalFiles%„            END IF„	      IF DisplayPos% > BottomDisplayLine% THEN„                DisplayPos% = BottomDisplayLine%„                LowFile% = Choice% -BottomDisplayLine% + 1„                IF HiFile%  >= TotalFiles% THEN„                   HiFile% = TotalFiles%„                ELSE„                   HiFile% = LowFile% + BottomDisplayLine% -1„                END IF„                PrintAtr BottomDisplayLine%+5, 1, 47, 23„                Scroll 5,1, BottomDisplayLine%+4,47, 1,23,%Up„                ScrollIt% = 1„      	END IF„         CASE %UpArrow„             DECR choice%„             DECR DisplayPos%„             IF choice% <=1 THEN„             	choice% = 1„             	LowFile% = 1„             	HiFile% = BottomDisplayLine%„             	DisplayPos% = 1„             ELSE„	            IF DisplayPos% < 1 THEN„		             DisplayPos% = 1„		             LowFile% = Choice%„		             HiFile% = Choice% + BottomDisplayLine% -1„                         IF HiFile%  >= TotalFiles% THEN„            		       HiFile% = TotalFiles%„                         ELSE„            		       HiFile% = LowFile% + BottomDisplayLine% -1„                         END IF„                         PrintAtr 6, 1, 47, 23„                         Scroll 5,1, BottomDisplayLine%+4,47, 1,23,%Down„                         ScrollIt% = 1„                  END IF„             END IF„      	CASE ELSE„            	EXIT DO„      END SELECT„   LOOP„   COLOR 7,0„END FUNCTION„„„SUB Scroll(BYVAL TopRow%,BYVAL TopLeftCol%,BYVAL BottomRow%,BYVAL BottomRightCol%,BYVAL TotalLines%,BYVAL Attr%,BYVAL WhichWay%)„!       PUSH DS„!       PUSH BP„!       MOV AH,WhichWay%„!       MOV AL, TotalLines%„!       MOV BH, Attr%„!       MOV CH, TopRow%„!       MOV CL, TopLeftCol%„!       MOV DH, BottomRow%„!       MOV DL, BottomRightCol%„!       INT &H10„!       POP BP„!       POP DS„END SUB„„SUB QPrint(BYVAL Row, BYVAL Col, BYVAL Text$, BYVAL attr) PUBLIC„ScreenSeg??  = ScreenSegment??„„   ! push DS                 ; save DS for PowerBASIC„   ! mov             ax,Row%         ; get the row„   ! dec             al              ; convert row to zero base„   ! mov             bl,80           ; get the number of cols„   ! mul             bl              ; multiply # of cols * rows„   ! add             ax,Col%         ; add the column„   ! dec             al              ; convert column to zero base„   ! mov             di,ax           ; offset within video page„   ! shl             di,1            ; account for color/attribute„„   ! push WORD PTR Text$     ; push string handle on the stack„   ! call GetStrLoc          ; find the string„   ! jcxz QPExit             ; if it's Null, exit„   ! mov  DS, DX             ; put segment in DS„   ! mov  SI, AX             ; put offset in SI„   ! mov  ES, ScreenSeg??    ; move to ES„   ! mov  AH, attr           ; put attribute in AH„   WriteChar:„   ! lodsb                   ; get Char from string„   ! stosw                   ; write Char and attribute to screen„   ! loop WriteChar          ; do it all CX times„   QPExit:„   ! pop  DS                 ; restore DS for PowerBASIC„END SUB„„SUB PrintAtr(byval Row%, byval Col%,ByVal LineWidth%, byval Attr%)„ScreenSeg??  = ScreenSegment??„!           push    ds              ;save the good stuff„!           mov     ax,Row%         ; get the row„!           dec     al              ; convert row to zero base„!           mov     bl,80           ; get the number of cols„!           mul     bl              ; multiply # of cols * rows„!           add     ax,Col%         ; add the column„!           dec     al              ; convert column to zero base„!           mov     di,ax           ; offset within video page„!           shl     di,1            ; account for color/attribute„!           mov     es,ScreenSeg??  ;put video segment into ax„!           mov     ah,Attr%        ;the color attribute will be needed„!           mov     cx,LineWidth%„forloop:„!           inc     di              ;increment to the next vidram position„!           mov     es:[di],ah      ;poke the attribute into vidram„!           inc     di„!           loop    forloop         ;loop until cx = 0„!           pop     ds„END SUB„„FUNCTION GetKey%() Public„While ISFALSE INSTAT:Wend„ky$ = Inkey$„IF len(ky$) = 2 then„	GetKey% = -ascii(right$(ky$,1))„ELSE„	GetKey% = ascii(ky$)„END IF„END FUNCTION„„SUB ClearBuffer„DO:LOOP UNTIL INKEY$ = ""„END SUB„„SUB GetDir(Spec$,Attr%,Directory$(),TotalFiles%)„DirFile$ = DIR$(Spec$,Attr%)„IF DirFile$ <> "" THEN„	Attribute% = Attrib(DirFile$)„	IF BIT(Attribute%,Attr%) THEN„      	INCR FileNum%„      	Directory$(FileNum%) = DirFile$„	END IF„ELSE„      TotalFiles% = 0„	EXIT SUB„END IF„„DO„	DirFile$ = DIR$„	IF DirFile$ <> "" THEN„		Attribute% = Attrib(DirFile$)„		IF BIT(Attribute%,Attr%) THEN„	      	INCR FileNum%„	      	Directory$(FileNum%) = DirFile$„	      END IF„	ELSE„		EXIT SUB„	END IF„LOOP„END SUB„„SUB GetRegDir(Spec$,Attr%,Directory$(),TotalFiles%)„DirFile$ = DIR$(Spec$,Attr%)„IF DirFile$ <> "" THEN„	INCR FileNum%„	Directory$(FileNum%) = DirFile$„ELSE„      TotalFiles% = 0„	EXIT SUB„END IF„„DO„	DirFile$ = DIR$„	IF DirFile$ <> "" THEN„      	INCR FileNum%„      	Directory$(FileNum%) = DirFile$„	ELSE„		EXIT SUB„	END IF„LOOP„END SUB„„FUNCTION Extension$(File$)„      FOR I% = LEN(File$) TO 1 STEP -1„		Period$ = MID$(File$,I%,1)„            IF Period$ = "." THEN Extension$ = MID$(File$,I%):EXIT FUNCTION„	NEXT I%„END FUNCTION„„FUNCTION Trim$(S$)„Trim$ = Ltrim$(Rtrim$(S$))„END FUNCTION„„FUNCTION GetFileName$(F$)„FOR I% = LEN(F$) TO 1 STEP -1„	Char$ = MID$(F$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN„      	GetFileName$ = File$„            EXIT FUNCTION„	ELSE„      	File$ = Char$ + File$„      END IF„NEXT I%„GetFileName$ = File$„END FUNCTION„„FUNCTION GetDirectory$(D$)„Ln% = LEN(D$)„FOR I% = Ln% TO 1 STEP -1„      Char$ = MID$(D$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN EXIT FOR„NEXT I%„IF I% <> 3 THEN„	TheDir$ = LEFT$(D$,I%-1)„ELSE„	TheDir$ = LEFT$(D$,I%)„END IF„GetDirectory$ = TheDir$„END FUNCTION„„FUNCTION FileDirExist%(d$)„Ln% = LEN(D$)„FOR I% = Ln% TO 1 STEP -1„      Char$ = MID$(D$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN EXIT FOR„NEXT I%„FileDirExist% = I%„END FUNCTION„„SUB PushDir(Directory$)„INCR StackPos%„DirStack$(StackPos%) = Directory$„IF Directory$ = "" THEN EXIT SUB„IF  DirExist%(TrueDir$) = 0 THEN MKDIR TrueDir$„END SUB„„SUB PopDir„DECR StackPos%„END SUB„„FUNCTION TrueDir$()„D$ = DirStack$(1)„FOR I% = 2 to StackPos%„D$ = D$ + "\" + DirStack$(I%)„NEXT I%„TrueDir$ = D$„END FUNCTION„„FUNCTION DirExist%(Directory$)„DirName$ = DIR$(Directory$,16)„IF DirName$ = "" THEN EXIT FUNCTION„Exists% = ATTRIB(Directory$)„Exists% = BIT(Exists%,4)„IF Exists% THEN DirExist% = 1„END FUNCTION„„FUNCTION FileExist%(Directory$)„D$ = DIR$(Directory$)„IF D$ <> "" THEN FileExist% = 1„END FUNCTION„„FUNCTION TrueName$(Directory$)„DIM DirName2 AS STRING * 128„DirName$ = Directory$ +CHR$(0)„DirNamePtr??? = STRPTR32(DirName$)„DirNamePtr2??? = VARPTR32(DirName2$)„LOCAL DosError??„!PUSH DS„!LDS SI,DirNamePtr???„!LES DI,DirNamePtr2???„!MOV AH,&H60„!INT &H21„!MOV DosError??,Ax„!POP DS„IF DosError?? = 2 OR DosError?? = 3 THEN PRINT "Can't Get TrueName !":END„TrueName$ = EXTRACT$(DirName2$,CHR$(0))„END FUNCTION„„FUNCTION CURDRIVE$„Curdrive$ = LEFT$(CURDIR$,1)„END FUNCTION„„FUNCTION MODTYPE??(Number%,ModNumber%)„ M% = Number% MOD ModNumber%„ IF M% = 0 THEN„ 	ModType% = ModNumber%„ ELSE„ 	ModType% = M%„ END IF„END FUNCTION„„SUB LzhView(LzhFile$,ArchiveFiles$(),ArchiveInfo$(), FilesInfo$)„ DIM Lzh AS LZHHead„ DIM FileName AS STRING * 8„ DIM Ext AS STRING * 4„„  FilePos??? = 0: QUIT% = 0„„  Handle% = FREEFILE„„  OPEN LzhFile$ FOR BINARY AS Handle%„  RestOfFileSize??? = LOF(Handle%)„  IF RestOfFileSize??? = 0 THEN„    CLOSE Handle%„    PRINT LzhFile$+" has an FileSize of Zero !"„    EXIT SUB„  END IF„„„  DO„          GET  Handle%,FilePos???,Lzh„          IF Lzh.Id1 = "-lh" Or Lzh.Id1 = "-lz" Or Lzh.Id1 = "-lZ" THEN„            IF Lzh.HeadSize AND (Lzh.HeadSize < RestOfFileSize???) THEN„                Get Handle%,FilePos??? + Lzh.HeadSize,DirLen??„                SEEK Handle%,FilePos??? + Lzh.HeadSize+3„„                IF DirLen?? > 0 AND DirLen?? < 256 THEN„                              GET$ Handle%,DirLen??-3,Directory$„                              REPLACE  CHR$(255) WITH "\" IN Directory$„                ELSE„                              Directory$ = ""„                END IF„„                INCR FilePos???, Lzh.CompressSize + Lzh.HeadSize + 2„                DECR RestOfFileSize???, FilePos???„„                INCR FileNumber??„„                File$ = LEFT$(Lzh.FileName,Lzh.FileNameLen)„                LSET FileName$ = Extract$(File$,".")„                LSET Ext$ = Extension$(File$)„                GetDateAndTime Lzh.Filedate,Lzh.FileTime,Filedate$,FileTime$„                IF DirLen?? THEN„                	DirSign$ = " + "„                ELSE„                	DirSign$ = "   "„                END IF„                ArchiveFiles$(FileNumber??) = Directory$ + File$„                ArchiveInfo$(FileNumber??)  = DirSign$ + FileName$ + Ext$ + USING$("########",Lzh.UnCompressSize) + " " + Filedate$ + "  "+FileTime$„            END IF„          ELSE„                INCR FilePos???, 2„           	    DECR RestOfFileSize???, FilePos???„          END IF„„  Loop UNTIL Lzh.HeadSize = 0 Or Lzh.HeadSize > RestOfFileSize??? OR FilePos??? = RestOfFileSize???„„  Close Handle%„  FilesInfo$ =  LzhFile$ + ":" + STR$(FileNumber??)+" Files"„  ArchiveFiles$(0) = MKWRD$(FileNumber??)„  ArchiveInfo$(0)  = MKWRD$(FileNumber??)„„END SUB„„SUB ZipView(ZipFile$,ArchiveFiles$(),ArchiveInfo$(),FilesInfo$,Success%)  ' View the ZIP File„ DIM Zip AS ZipType„ DIM FileName AS STRING * 8„ DIM Ext AS STRING * 4„ FileNumber?? = 0„ Success% = 0„„  Handle% = FREEFILE„  OPEN ZipFile$ FOR BINARY AS Handle%„  FileSize??? = LOF(Handle%)„  IF FileSize??? = 0 THEN               ' Check if files exists„    '?ZipFile;" has an FileSize of Zeor !"    ' if not, exit„    CLOSE Handle%„    EXIT SUB„  END IF„„    DO„    	GET Handle%,ZipPos???,SIG???                   ' Read File Header„      IF Sig??? = %PkSig Then FilePos??? = ZipPos???:EXIT LOOP„      INCR ZipPos???,2„      IF ZipPos??? > 200 THEN CLOSE Handle%:EXIT SUB„    LOOP„„  DO„    GET Handle%,FilePos???,Zip                   ' Read File Header„„    IF (Zip.Signature = %PkSig) THEN„      INCR FilePos???, Zip.CompressSize + 30 + Zip.FileNameLen + ZIP.ExtraField„      INCR FileNumber??„	GET$ Handle%,Zip.FileNameLen,File$„      TheFile$ = GetFileName$(File$)„      IF TheFile$ = "" THEN„      	DECR FileNumber??„            ITERATE DO„      END IF„„      LSET FileName$ = Extract$(TheFile$,".")„      LSET Ext$ = Extension$(File$)„      GetDateAndTime Zip.Filedate,Zip.FileTime,Filedate$,FileTime$„      ArchiveFiles$(FileNumber??) = File$„„	IF FileDirExist%(File$) THEN„		DirSign$ = " + "„	ELSE„		DirSign$ = "   "„	END IF„„      ArchiveInfo$(FileNumber??)  = DirSign$ + FileName$ + Ext$ + USING$("########",Zip.UnCompressSize) + "  "+Filedate$+"  "+FileTime$„  END IF„„  LOOP WHILE Zip.Signature = %PkSig„  CLOSE Handle%„„  FilesInfo$ =  ZipFile$ + ":" + STR$(FileNumber??)+" Files"„  ArchiveInfo$(0) = MKWRD$(FileNumber??) 'Total Number of FIles„  ArchiveFiles$(0) = MKWRD$(FileNumber??)„  IF FileNumber?? > 1 THEN ARRAY SORT ArchiveFiles$(1) FOR FileNumber??,TAGARRAY ArchiveInfo$()„  Success% = 1„„END SUB„„SUB GetDateAndTime(Filedate??,FileTime??,Filedate$,FileTime$)„       Year?? = (Filedate?? AND &B1111111000000000):SHIFT RIGHT Year??,9„       INCR Year??,1980„       Month?? = Filedate?? AND &B0000000111100000:SHIFT RIGHT Month??,5„       Day?? = Filedate?? AND &B0000000000011111„       Hours?? = FileTime?? AND &B1111100000000000:SHIFT RIGHT Hours??,11„       Minutes?? = FileTime?? AND &B0000011111100000:SHIFT RIGHT Minutes??,5„       Seconds?? = (FileTime?? AND &B0000000000011111) * 2„„       Month$ = LTRIM$(STR$(Month??))„       Day$ = LTRIM$(STR$(Day??))„       IF LEN(Month$) = 1 THEN Month$="0"+Month$„       IF LEN(Day$) = 1 THEN Day$ = "0"+Day$„       'IF Hours?? > 12 THEN„       '	Hours?? = Hours?? -12:AmPm$ = "p & "„       'ELSE„       '	AmPm$ = "a & "„       'END IF„       Hours$ = LTRIM$(STR$(Hours??))„       Minutes$ = LTRIM$(STR$(Minutes??))„       Seconds$ = LTRIM$(STR$(Seconds??))„       IF LEN(Hours$) = 1 THEN Hours$="0"+Hours$„       IF LEN(Minutes$) = 1 THEN Minutes$="0"+Minutes$„       IF LEN(Seconds$) = 1 THEN Seconds$="0"+Seconds$„„       Filedate$ = Month$ + "-" + Day$ + "-" + LTRIM$(STR$(Year??))„       FileTime$ = Hours$ + ":" + Minutes$ + ":" + Seconds$„       'FileTime$ = Hours$ + ":" + Minutes$ + AmPm$ + Seconds$ +"s"„„END SUB„Randall L. Glass               GET LZH LIST                   rlglass@yahoo.com              10-25-99 (18:05)       PB                     154  5089     GETLZH.BAS  '----------------------------------------------------------------------------„'„'                                 Get Lzh List„'                               BY Randall Glass„'                                Copyright 1999„'„'----------------------------------------------------------------------------„'„' FREEWARE„'„' You may use this as long as you give me credit somewhere in the documentation„'„' Email rlglass@yahoo.com„'„'--------------------------------------------------------------------------„„DEFINT A-Z„„TYPE LZHHead„     HeadSize       AS BYTE„     CheckSum       AS BYTE„     Id1            AS STRING * 3„     Method         AS BYTE„     Id2            AS BYTE„     CompressSize   AS DWORD„     UnCompressSize AS DWORD„     FileTime       AS WORD„     FileDate       AS WORD„     Attrs          AS BYTE„     HeaderLevel    AS BYTE„     FileNameLen    AS BYTE„     FileName       AS STRING * 12„END TYPE„„DIM ArchiveFiles$(200),ArchiveInfo$(200)„„GetLzhList Command$, ArchiveFiles$(), ArchiveInfo$(), FilesInfo$„TotalFiles?? = CVWRD(ArchiveFiles$(%TotalFiles))„„FOR I% = 1 to TotalFiles??„        PRINT ArchiveInfo$(I%)„NEXT I%„„END„„SUB GetLzhList(LzhFile$,ArchiveFiles$(),ArchiveInfo$(), FilesInfo$)„ DIM Lzh AS LZHHead„ DIM FileName AS STRING * 8„ DIM Ext AS STRING * 4„„  FilePos??? = 0: QUIT% = 0„„  Handle% = FREEFILE„„  OPEN LzhFile$ FOR BINARY AS Handle%„  RestOfFileSize??? = LOF(Handle%)„  IF RestOfFileSize??? = 0 THEN„    CLOSE Handle%„    PRINT LzhFile$+" has an FileSize of Zero !"„    EXIT SUB„  END IF„„„  DO„          GET  Handle%,FilePos???,Lzh„          IF Lzh.Id1 = "-lh" Or Lzh.Id1 = "-lz" Or Lzh.Id1 = "-lZ" THEN„            IF Lzh.HeadSize AND (Lzh.HeadSize < RestOfFileSize???) THEN„                Get Handle%,FilePos??? + Lzh.HeadSize,DirLen??„                SEEK Handle%,FilePos??? + Lzh.HeadSize+3„„                IF DirLen?? > 0 AND DirLen?? < 256 THEN„                              GET$ Handle%,DirLen??-3,Directory$„                              REPLACE  CHR$(255) WITH "\" IN Directory$„                ELSE„                              Directory$ = ""„                END IF„„                INCR FilePos???, Lzh.CompressSize + Lzh.HeadSize + 2„                DECR RestOfFileSize???, FilePos???„„                INCR FileNumber??„„                File$ = LEFT$(Lzh.FileName,Lzh.FileNameLen)„                LSET FileName$ = Extract$(File$,".")„                LSET Ext$ = Extension$(File$)„                GetDateAndTime Lzh.Filedate,Lzh.FileTime,Filedate$,FileTime$„                IF DirLen?? THEN„                	DirSign$ = " + "„                ELSE„                	DirSign$ = "   "„                END IF„                ArchiveFiles$(FileNumber??) = Directory$ + File$„                ArchiveInfo$(FileNumber??)  = DirSign$ + FileName$ + Ext$ + USING$("########",Lzh.UnCompressSize) + " " + Filedate$ + "  "+FileTime$„            END IF„          ELSE„                INCR FilePos???, 2„           	    DECR RestOfFileSize???, FilePos???„          END IF„„  Loop UNTIL Lzh.HeadSize = 0 Or Lzh.HeadSize > RestOfFileSize??? OR FilePos??? = RestOfFileSize???„„  Close Handle%„  FilesInfo$ =  LzhFile$ + ":" + STR$(FileNumber??)+" Files"„  ArchiveFiles$(0) = MKWRD$(FileNumber??)„  ArchiveInfo$(0)  = MKWRD$(FileNumber??)„„END SUB„„SUB GetDateAndTime(Filedate??,FileTime??,Filedate$,FileTime$)„       Year?? = (Filedate?? AND &B1111111000000000):SHIFT RIGHT Year??,9„       INCR Year??,1980„       Month?? = Filedate?? AND &B0000000111100000:SHIFT RIGHT Month??,5„       Day?? = Filedate?? AND &B0000000000011111„       Hours?? = FileTime?? AND &B1111100000000000:SHIFT RIGHT Hours??,11„       Minutes?? = FileTime?? AND &B0000011111100000:SHIFT RIGHT Minutes??,5„       Seconds?? = (FileTime?? AND &B0000000000011111) * 2„„       Month$ = LTRIM$(STR$(Month??))„       Day$ = LTRIM$(STR$(Day??))„       IF LEN(Month$) = 1 THEN Month$="0"+Month$„       IF LEN(Day$) = 1 THEN Day$ = "0"+Day$„       'IF Hours?? > 12 THEN„       '	Hours?? = Hours?? -12:AmPm$ = "p & "„       'ELSE„       '	AmPm$ = "a & "„       'END IF„       Hours$ = LTRIM$(STR$(Hours??))„       Minutes$ = LTRIM$(STR$(Minutes??))„       Seconds$ = LTRIM$(STR$(Seconds??))„       IF LEN(Hours$) = 1 THEN Hours$="0"+Hours$„       IF LEN(Minutes$) = 1 THEN Minutes$="0"+Minutes$„       IF LEN(Seconds$) = 1 THEN Seconds$="0"+Seconds$„„       Filedate$ = Month$ + "-" + Day$ + "-" + LTRIM$(STR$(Year??))„       FileTime$ = Hours$ + ":" + Minutes$ + ":" + Seconds$„       'FileTime$ = Hours$ + ":" + Minutes$ + AmPm$ + Seconds$ +"s"„„END SUB„„FUNCTION Extension$(File$)„      FOR I% = LEN(File$) TO 1 STEP -1„		Period$ = MID$(File$,I%,1)„            IF Period$ = "." THEN Extension$ = MID$(File$,I%):EXIT FUNCTION„	NEXT I%„END FUNCTION„„FUNCTION FileDirExist%(d$)„Ln% = LEN(D$)„FOR I% = Ln% TO 1 STEP -1„      Char$ = MID$(D$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN EXIT FOR„NEXT I%„FileDirExist% = I%„END FUNCTION„Randall L. Glass               VIEW DIRECTORIES/FILES ZIP/LZH rlglass@yahoo.com              10-25-99 (18:05)       PB                     1451 49327    VIEWER.BAS  '-------------------------------------------------------------------------„'„'                   Shell BY Randall L Glass„'                      CopyRight Aug3,1999„'„'---------------------------------------------------------------------------„'„' Email rlglass@yahoo.com„'„'---------------------------------------------------------------------------„'„' This Program is Freeware„' You may do anything with this program AS long AS you give me credit„' somewhere in the documentation.„'„'===========================================================================„'„' Program to view directoryies and files ,Including ZIP and Lzh„'„' Credit to Author: Jamshid Khoshrangi for his BOYER-MOORE INSTR              Code: PB„' Thanks to William Yu FOR his ZipView & LzhView progam.„'„'„' You must SET the value of TEMP in your autoexec.bat file.„' Example SET TEMP = D:\TMP„'„' OR Rewrite the code in the program to set TempDir to your tempory directory.„' And Rewrite the code to your editor or file viewer.„'„' This includes an text viewer to view huge files up to 32700 lines„' Possible size 2.6 Gig„'„' List File Viewer is Faster„' You Can always replace my file viewer with an shell to List.com„'„' Look for SUB viewer„'„'----------------------------------------------------------------------------„$DYNAMIC„$HUGE„$STACK 10000„„DEFINT A-Z„„TYPE ZipType                 ' Zip File Header„    Signature      AS DWORD„    Version        AS WORD„    GPBFlag        AS WORD          ' Not sure„    Compress       AS WORD          ' Compression type„    FileTime       AS WORD„    Filedate       AS WORD         ' Took a while to figure out„    CRC32          AS DWORD„    CompressSize   AS DWORD„    UnCompressSize AS DWORD„    FileNameLen    AS WORD„    ExtraField     AS WORD„END TYPE„„TYPE LZHHead„     HeadSize       AS BYTE„     CheckSum       AS BYTE„     Id1            AS STRING * 3„     Method         AS BYTE„     Id2            AS BYTE„     CompressSize   AS DWORD„     UnCompressSize AS DWORD„     FileTime       AS WORD„     FileDate       AS WORD„     Attrs          AS BYTE„     HeaderLevel    AS BYTE„     FileNameLen    AS BYTE„     FileName       AS STRING * 12„END TYPE„„DECLARE Function GetKey%() AS INTEGER„DECLARE SUB GetStrLoc()„DECLARE SUB BoxBorder ()„DECLARE SUB Scroll(BYVAL TopRow%,BYVAL TopLeftCol%,BYVAL BottomRow%,BYVAL BottomRightCol%,BYVAL TotalLines%,BYVAL Attr%,BYVAL WhichWay%)„„„DIM ScreenSegment AS shared WORD„DIM DirStack$(10),ShellDir$(10)„DIM Directory$(1000), DirInfo$(1000)„„SHARED Directory$(), DirInfo$()„„SHARED Viewer$,TempDir$,StackPos%,DirStack$()„SHARED StartLine$,EndLine$,FileList$,Response$,ExtractCmd$,ExtractReponse$„SHARED DosError??,ShellDir$(),ShellPos%,ExitShell%„SHARED NextHandle%,LineSeg??,LinePtr??„„IF(PBVScreenCARD AND 1) = 0 THEN„      ScreenSegment?? = 47104       '&HB800          'color monitor„ELSE„      ScreenSegment?? = 45056       '&HB000          'mono monitor„END IF„„„%SIG = &H04034B50             ' Signature„%UpArrow = -72:%DownArrow = -80:%Enter = 13:%Escape = 27„%Home = -71:%PageDown = -81:%PageUp = -73:%EndKey = -79„%Up = 6:%Down = 7:%LeftArrow = -75:%RightArrow = -77„%AltHome = -151„%U = 85„%ReadOnly = 1:%Hidden = 2:%System = 4:%Volume = 8:%SubDir = 16:%Archive = 32„%AllFiles = 33„„CLS„'Viewer$ = "listr.com"„LastDir$ = CURDRIVE$ + ":\"„CHDIR LastDir$„IF(PBVScreenCARD AND 1) = 0 THEN„      ScreenSegment?? = 47104       '&HB800          'color monitor„ELSE„      ScreenSegment?? = 45056       '&HB000          'mono monitor„END IF„„EXIT FAR AT BackHome„DO„	ShellPos% = 0„	DosShell LastDir$„BackHome:„LOOP WHILE ShellPos%„END„„SUB DosShell(ShellDirectory$)„„Choice% = 1:DisplayPos% = 1:LowFIle% = 1:HiFile% = 18:Ky% = 0„InfoLine$ = "   FileName"+"       Size"+"     Date" + "       Time"„PushDir2 ShellDirectory$,ShellDir$(),ShellPos%„„DO„„        TotalFiles% = 0„        RealDir$ = AddSlash$(TrueDir2$(ShellDir$(), ShellPos%))„        GetDirAndFiles RealDir$ + "*.*", %SubDir  , Directory$(), DirInfo$(), FilesInfo$, TotalFiles%„        DirNum% = TotalFiles%„        IF DirNum% > 1 THEN ARRAY SORT Directory$(1) FOR TotalFiles%,TagArray DirInfo$()„        GetDirAndFiles RealDir$ + "*.*", %AllFiles, Directory$(), DirInfo$(), FilesInfo$, TotalFiles%„        SortNumber% = TotalFiles - DirNum%„        IF SortNumber% > 1 THEN„            FileStart% = DirNum% + 1„        	ARRAY SORT Directory$(FileStart%) FOR SortNumber%,TagArray DirInfo$()„        END IF„        Pick% = ChooseProgram%( DirInfo$(),Directory$(),FilesInfo$,InfoLine$,Choice%,DisplayPos%,LowFile%,HiFile%,Ky%,DirNum%,"Directory")„        SELECT CASE Ky%„           CASE %RightArrow,%Enter„                IF Attrib(RealDir$ + Directory$(Pick%)) = 16 THEN„                		DosShell(Directory$(Pick%))„                        COLOR 7,1„                        CLS„                ELSEIF Attrib(RealDir$ + Directory$(Pick%)) <> 16 THEN„				Ext$ = Extension$(Directory$(Pick%))„                        SELECT CASE Ext$„                  		CASE ".ZIP",".LZH"„						ShowZip(RealDir$ + Directory$(Pick%))„                        	CASE ELSE        '".TXT",".DOC"„                                Viewer RealDir$ + Directory$(Pick%)„                              	CLS„                              	DELAY .2„                              	COLOR 7,0„                  	END SELECT„                END IF„        	CASE %LeftArrow,%Escape„			DECR ShellPos%„                  EXIT LOOP„„        	CASE %AltHome„                  EXIT FAR„        END SELECT„LOOP„END SUB„„SUB ShowZip(File$)„CLS„LOCATE 1,1,0„Ext$ = Extension$(File$)„File$ = TrueName$(File$)„IF ISFALSE FileExist%(File$) THEN EXIT SUB„TempDir$ = ENVIRON$("TEMP") + "\dosview"„PushDir TempDir$„ViewZip File$„PopDir„SHELL "DELTREE /Y " + Rtrim$(RealDir$,"\") + " >NUL"„COLOR 7,0„CLS„END SUB„„SUB ViewZip(File$)„IF ISFALSE FileExist%(File$) THEN„	LOCATE 5,15:PRINT File$;" doesn't exist !";„      EXIT SUB„END IF„DIM ArchiveFiles$(1000),ArchiveInfo$(1000),ArchiveDir$(1000)„  Choice% = 1:DisplayPos% = 1:LowFIle% = 1:HiFile% = 18„  Ky% = 0„  InfoLine$ = "   FileName"+"       Size"+"     Date" + "       Time"„  CLS„  Ext$ = Extension$(File$)„   IF Ext$ = ".ZIP" OR Ext$ = ".LZH" THEN„      PresentDir$ = CURDIR$„      PresentDrive$ = CURDRIVE$„      CHDRIVE Left$(File$,1)„      CHDIR GetDirectory$(File$)„      SELECT CASE Ext$„          CASE ".ZIP"„                ZipView GetFileName$(File$), ArchiveFiles$(), ArchiveInfo$(), FilesInfo$, Success%„          CASE ".LZH"„                LzhView GetFileName$(File$), ArchiveFiles$(), ArchiveInfo$(), FilesInfo$, Success%„      END SELECT„      CHDRIVE PresentDrive$„      CHDIR PresentDir$„      IF ISFALSE Success% THEN EXIT SUB„      TotalFiles?? = CVWRD(ArchiveFiles$(0))„      'ARRAY SORT ArchiveFiles$(1) FOR TotalFiles??,TAGARRAY ArchiveInfo$()„      DO„               Pick% = ChooseProgram%( ArchiveInfo$(),ArchiveFiles$(),FilesInfo$,InfoLine$,Choice%,DisplayPos%,LowFile%,HiFile%,Ky%,0,"")„               Choice% = Pick%„                SELECT CASE Ky%„                        CASE %Escape,%LeftArrow„                                EXIT SUB„                        CASE %RightArrow„                                IF Pick% > 0 THEN„                                		Pick$ = UCASE$(ArchiveFiles$(Pick%))„                                          RealName$ = GetFileName$(Pick$)„                                        	PickExt$ = Extension$(Pick$)„                                        	IF PickExt$ =".ZIP" OR PickExt$ = ".LZH" THEN„                                                PushDir "TEMP"„                                                RealDir$ = TrueDir$ + "\"„                                                IF ISFALSE FileExist%(RealDir$+Pick$) THEN„                                                        CLS„                                                        SELECT CASE Ext$„                                                        CASE ".ZIP"„                                                                SHELL "PKUNZIP -e -o " + File$ + " " + Pick$ + " "  + RealDir$ + " >NUL"„                                                                'SHELL "UNZIP " + File$ + " " + Pick$ + " " + "-d" + RealDir$ '+ " >NUL"„                                                        CASE ".LZH"„                                                                SHELL "lha.exe e /pn2 " + File$ + " " + RealDir$ + " "+ Pick$„                                                  END SELECT„                                                END IF„                                                fe% = FetchErrorLevel%„                                                IF FetchErrorLevel% > 0 THEN„                                                        SHELL "DELTREE /Y " + Rtrim$(RealDir$,"\") + " >NUL"„                                                        EXIT SUB„                                                END IF„                                                ViewZip RealDir$ + RealName$„                                                SHELL "DELTREE /Y " + Rtrim$(RealDir$,"\") + " >NUL"„                                                PopDir„                                                CLS„                                                DELAY .2„                                                ITERATE LOOP„                                        	ELSE„                                                CLS„                                                RealDir$ = TrueDir$ + "\"„                                                SELECT CASE Ext$„                                                        CASE ".ZIP"„                                                                SHELL "PKUNZIP -e -o " + File$ + " " + Pick$ + " "  + RealDir$ + " >NUL"„                                                                'SHELL "UNZIP " + File$ + " " + Pick$ + " " + "-d" + RealDir$ ' + " >NUL"„                                                        CASE ".LZH"„                                                                SHELL "lha.exe e /pn2 " + File$ + " " + RealDir$ + " "+ Pick$„                                                END SELECT„                                        	END IF„                                        'CLS„                                        fe% = FetchErrorLevel%„                                        IF FetchErrorLevel% > 0 THEN„                                                SHELL "DELTREE /Y " + Rtrim$(RealDir$,"\") + " >NUL"„                                                EXIT SUB„                                        END IF„„                                        PresentDir$ = CURDIR$„                                        PresentDrive$ = CURDRIVE$„                                        CHDRIVE LEFT$(TrueDir$,1)„                                        CHDIR TrueDir$„                                        Viewer RealName$„                                        CLS„                                        KILL RealName$„                                        CHDRIVE PresentDrive$„                                        CHDIR PresentDir$„                                        DELAY .2„                                        COLOR 7,0„                                    END IF„                        'CASE %U„                END SELECT„      LOOP„   END IF„END SUB„„FUNCTION ChooseProgram%(ArchiveInfo$(),ArchiveFile$(),InfoLine1$,InfoLine2$ ,Choice%, DisplayPos%,LowFile%, HiFile%,Ky%,DirNum%,ChooseType$)„   DIM PrintLine AS STRING * 47„   DIM DirLine AS STRING * 80„   DisplayLine% = 18„„   TotalFiles% = CVWRD(ArchiveInfo$(0))„   IF TotalFiles% < DisplayLine% THEN HiFile% = TotalFiles%„„     BottomDisplayLine% = DisplayLine%„     COLOR 7,1„     CLS„     COLOR 0,7„     LOCATE 1,1:PRINT SPACE$(80);„     COLOR 7,1„     LOCATE 2,2:PRINT Ltrim$(InfoLine1$)„     LOCATE 4,2:PRINT InfoLine2$„„   DO„      COLOR 15, 1„      LinePos% = 0„      IF TotalFiles% < 15 THEN BottomDisplayLine% = TotalFiles%„      IF ScrollIt% = 0 THEN„	      'POKE$ 0, SaveScreen$ : LOCATE y%, x%       'restore old screen„	      FOR ArchiveFile% = LowFile% TO HiFile%„	         INCR LinePos%„               LSET PrintLine$ = ArchiveInfo$(ArchiveFile%)„	         IF LinePos% = DisplayPos% THEN„	            QPrint 5 + LinePos%,1, PrintLine$ ,71„	         ELSE„	            QPRINT 5 + LinePos%,1,PrintLine$,23„	         END IF„	      NEXT ArchiveFile%„		LSET PrintLine$ = ""„            FOR I% = LinePos% + 1 To DisplayLine%„	            QPRINT 5 + I%,1,PrintLine$,23„            NEXT I%„      ELSE„		LSET PrintLine$ = ArchiveInfo$(Choice%)„            QPRINT 5 + DisplayPos%,1,PrintLine$,71„      END IF„„      DirLine$ = SPACE$(80)„      MID$(DirLine$,2) = ArchiveFile$(Choice%)„      COLOR 0,7:LOCATE 25,1:PRINT DirLine$;„„      ScrollIt% = 0„      ClearBuffer„      DO: ky$ = UCASE$(INKEY$): LOOP WHILE ky$ = ""„      Ky% = ASC(ky$): IF Ky% = 0 THEN Ky% = -ASC(MID$(ky$, 2))„       SELECT CASE Ky%„         CASE %Enter,%RightArrow„         	ChooseProgram% = choice%: EXIT DO„         CASE %Escape„         	ChooseProgram% = 0: EXIT DO„         CASE %Home„         	choice% = 1:LowFile% = 1„            HiFile% = BottomDisplayLine%„            DisplayPos% = 1„         CASE %EndKey„            Choice% = TotalFiles%„            DisplayPos% = MODTYPE(Choice%, BottomDisplayLine%)„            LowFile% = Choice% - DisplayPos% + 1„            HiFile% = TotalFiles%„         CASE %PageDown„            INCR Choice%, DisplayLine%„            INCR LowFile%,DisplayLine%„            HiFile% = LowFile% + BottomDisplayLine% -1„            IF HiFile% > TotalFiles% THEN HiFile% = TotalFiles%„		IF choice% > TotalFiles% THEN„			Choice% = TotalFiles%„                        DisplayPos% = ModType(Choice%, BottomDisplayLine%)„			LowFile% = Choice% - DisplayPos% + 1„			HiFile% = TotalFiles%„	      END IF„„         CASE %PageUp„            DECR Choice%,DisplayLine%„            DECR LowFile%,DisplayLine%„            HiFile% = LowFile% + DisplayLine% -1„            IF LowFile% < 1 THEN LowFile% = 1:HiFile% = BottomDisplayLine%„	      IF Choice% <=1 THEN„              Choice% = 1„              LowFile% = 1„              HiFile% = BottomDisplayLine%„              DisplayPos% = 1„      	END IF„         CASE %DownArrow„            INCR Choice%„            IF Choice% <= TotalFiles% THEN„                  INCR DisplayPos%„            ELSE„            	Choice% = TotalFiles%„            END IF„	      IF DisplayPos% > BottomDisplayLine% THEN„                DisplayPos% = BottomDisplayLine%„                LowFile% = Choice% -BottomDisplayLine% + 1„                IF HiFile%  >= TotalFiles% THEN„                   HiFile% = TotalFiles%„                ELSE„                   HiFile% = LowFile% + BottomDisplayLine% -1„                END IF„                PrintAtr BottomDisplayLine%+5, 1, 47, 23„                Scroll 5,1, BottomDisplayLine%+4,47, 1,23,%Up„                ScrollIt% = 1„      	END IF„         CASE %UpArrow„             DECR choice%„             DECR DisplayPos%„             IF choice% <=1 THEN„             	choice% = 1„             	LowFile% = 1„             	HiFile% = BottomDisplayLine%„             	DisplayPos% = 1„             ELSE„	            IF DisplayPos% < 1 THEN„		             DisplayPos% = 1„		             LowFile% = Choice%„		             HiFile% = Choice% + BottomDisplayLine% -1„                         IF HiFile%  >= TotalFiles% THEN„            		       HiFile% = TotalFiles%„                         ELSE„            		       HiFile% = LowFile% + BottomDisplayLine% -1„                         END IF„                         PrintAtr 6, 1, 47, 23„                         Scroll 5,1, BottomDisplayLine%+4,47, 1,23,%Down„                         ScrollIt% = 1„                  END IF„             END IF„        CASE 48 TO 57,65 TO 90„            IF ChooseType$ = "Directory" THEN„                  ScanFiles% = TotalFiles% - Choice%„			ARRAY SCAN ArchiveInfo$(Choice% + 1) FOR ScanFiles% ,FROM 2 TO 2,=Ky$,To PossibleChoice%„                  IF PossibleChoice% > 0 THEN„                  	Choice% = Choice% + PossibleChoice%„                  ELSEIF PossibleChoice% = 0 THEN„                  	ARRAY SCAN ArchiveInfo$(1) FOR Choice% - 1 ,FROM 2 TO 2,=Ky$,To PossibleChoice%„                        IF PossibleChoice% > 0 THEN Choice% = PossibleChoice%„                  END IF„                  IF PossibleChoice% > 0 THEN„	                  LowFile% = Choice% - DisplayPos% + 1„	                  HiFile% = LowFile% + BottomDisplayLine% -1„	                  IF LowFile% < 1 THEN LowFile% = 1:HiFile% = BottomDisplayLine%:DisplayPos% = Choice%„	                  IF HiFile% > TotalFiles% THEN HiFile% = TotalFiles%„			END IF„        	END IF„        CASE ELSE„            	EXIT DO„      END SELECT„   LOOP„„   COLOR 7,0„END FUNCTION„„„SUB Scroll(BYVAL TopRow%,BYVAL TopLeftCol%,BYVAL BottomRow%,BYVAL BottomRightCol%,BYVAL TotalLines%,BYVAL Attr%,BYVAL WhichWay%)„!       PUSH DS„!       PUSH BP„!       MOV AH,WhichWay%„!       MOV AL, TotalLines%„!       MOV BH, Attr%„!       MOV CH, TopRow%„!       MOV CL, TopLeftCol%„!       MOV DH, BottomRow%„!       MOV DL, BottomRightCol%„!       INT &H10„!       POP BP„!       POP DS„END SUB„„SUB QPrint(BYVAL Row, BYVAL Col, BYVAL Text$, BYVAL attr) PUBLIC„ScreenSeg??  = ScreenSegment??„„   ! push DS                 ; save DS for PowerBASIC„   ! mov             ax,Row%         ; get the row„   ! dec             al              ; convert row to zero base„   ! mov             bl,80           ; get the number of cols„   ! mul             bl              ; multiply # of cols * rows„   ! add             ax,Col%         ; add the column„   ! dec             al              ; convert column to zero base„   ! mov             di,ax           ; offset within video page„   ! shl             di,1            ; account for color/attribute„„   ! push WORD PTR Text$     ; push string handle on the stack„   ! call GetStrLoc          ; find the string„   ! jcxz QPExit             ; if it's Null, exit„   ! mov  DS, DX             ; put segment in DS„   ! mov  SI, AX             ; put offset in SI„   ! mov  ES, ScreenSeg??    ; move to ES„   ! mov  AH, attr           ; put attribute in AH„   WriteChar:„   ! lodsb                   ; get Char from string„   ! stosw                   ; write Char and attribute to screen„   ! loop WriteChar          ; do it all CX times„   QPExit:„   ! pop  DS                 ; restore DS for PowerBASIC„END SUB„„SUB PrintAtr(byval Row%, byval Col%,ByVal LineWidth%, byval Attr%)„ScreenSeg??  = ScreenSegment??„!           push    ds              ;save the good stuff„!           mov     ax,Row%         ; get the row„!           dec     al              ; convert row to zero base„!           mov     bl,80           ; get the number of cols„!           mul     bl              ; multiply # of cols * rows„!           add     ax,Col%         ; add the column„!           dec     al              ; convert column to zero base„!           mov     di,ax           ; offset within video page„!           shl     di,1            ; account for color/attribute„!           mov     es,ScreenSeg??  ;put video segment into ax„!           mov     ah,Attr%        ;the color attribute will be needed„!           mov     cx,LineWidth%„forloop:„!           inc     di              ;increment to the next vidram position„!           mov     es:[di],ah      ;poke the attribute into vidram„!           inc     di„!           loop    forloop         ;loop until cx = 0„!           pop     ds„END SUB„„FUNCTION GetKey%() Public„While ISFALSE INSTAT:Wend„ky$ = Inkey$„IF len(ky$) = 2 then„	GetKey% = -ascii(right$(ky$,1))„ELSE„	GetKey% = ascii(ky$)„END IF„END FUNCTION„„SUB ClearBuffer„DO:LOOP UNTIL INKEY$ = ""„END SUB„„SUB GetDirAndFiles(Spec$, Attr%, Directory$(), DirInfo$(), FilesInfo$, TotalFiles%)„ IF Attr% <> %SubDir THEN Attr% = 33„ DIM FileName AS STRING * 8„ DIM Ext AS STRING * 4„ DirFile$ = DIR$(Spec$,Attr%)„ IF DirFile$ <> "" THEN„	GetDirInfo DirDate$,DirTime$,DirSize???,DirAttr?„      IF Attr% = 16 AND DirAttr? = 16 THEN„		INCR TotalFiles%„		Directory$(TotalFiles%) = DirFile$„	      LSET FileName$ = Extract$(DirFile$,".")„	      LSET Ext$ = Extension$(DirFile$)„      	IsDir$ = "<DIR>"„      	DirInfo$(TotalFiles%)  =  " " + FileName$ + Ext$ + "  " + IsDir$ + "        " + "  "+DirDate$ + "  " + DirTime$„      ELSEIF Attr% <> 16 AND DirAttr? <> 16 THEN„		INCR TotalFiles%„		Directory$(TotalFiles%) = DirFile$„	      LSET FileName$ = Extract$(DirFile$,".")„	      LSET Ext$ = Extension$(DirFile$)„      	IsDir$ = "     "„      	DirInfo$(TotalFiles%)  =  " " + FileName$ + Ext$ + "  " + IsDir$ + USING$("########",DirSize???) + "  "+DirDate$ + "  " + DirTime$„      END IF„ END IF„„ DO„	DirFile$ = DIR$„	IF DirFile$ <> "" THEN„      	GetDirInfo DirDate$,DirTime$,DirSize???,DirAttr?„            IF Attr% = 16 AND DirAttr? = 16 THEN„            	INCR TotalFiles%„            	Directory$(TotalFiles%) = DirFile$„            	LSET FileName$ = Extract$(DirFile$,".")„            	LSET Ext$ = Extension$(DirFile$)„            	IsDir$ = "<DIR>"„            	DirInfo$(TotalFiles%)  =  " " + FileName$ + Ext$ + "  " + IsDir$ + "        " + "  "+DirDate$ + "  " + DirTime$„	      ELSEIF Attr% <> 16 AND DirAttr? <> 16 THEN„      		INCR TotalFiles%„			Directory$(TotalFiles%) = DirFile$„	      	LSET FileName$ = Extract$(DirFile$,".")„	      	LSET Ext$ = Extension$(DirFile$)„      		IsDir$ = "     "„      		DirInfo$(TotalFiles%)  =  " " + FileName$ + Ext$ + "  " + IsDir$ + USING$("########",DirSize???) + "  "+DirDate$ + "  " + DirTime$„      	END IF„	ELSE„		EXIT LOOP„	END IF„ LOOP„ FilesInfo$ =  Spec$ + ":" + STR$(TotalFiles%)+" Directories And Files"„ DirInfo$(0)   = MKWRD$(TotalFiles%)„ Directory$(0) = MKWRD$(TotalFiles%)„„END SUB„„SUB GetRegDir(Spec$,Attr%,Directory$(),TotalFiles%)„DirFile$ = DIR$(Spec$,Attr%)„IF DirFile$ <> "" THEN„	INCR FileNum%„	Directory$(FileNum%) = DirFile$„„ELSE„      TotalFiles% = 0„	EXIT SUB„END IF„„DO„	DirFile$ = DIR$„	IF DirFile$ <> "" THEN„      	INCR FileNum%„      	Directory$(FileNum%) = DirFile$„	ELSE„		EXIT SUB„	END IF„LOOP„END SUB„„FUNCTION Extension$(File$)„      FOR I% = LEN(File$) TO 1 STEP -1„		Period$ = MID$(File$,I%,1)„            IF Period$ = "." THEN Extension$ = MID$(File$,I%):EXIT FUNCTION„	NEXT I%„END FUNCTION„„FUNCTION Trim$(S$)„Trim$ = Ltrim$(Rtrim$(S$))„END FUNCTION„„FUNCTION GetFileName$(F$)„FOR I% = LEN(F$) TO 1 STEP -1„	Char$ = MID$(F$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN„      	GetFileName$ = File$„            EXIT FUNCTION„	ELSE„      	File$ = Char$ + File$„      END IF„NEXT I%„GetFileName$ = File$„END FUNCTION„„FUNCTION GetDirectory$(D$)„Ln% = LEN(D$)„FOR I% = Ln% TO 1 STEP -1„      Char$ = MID$(D$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN EXIT FOR„NEXT I%„IF I% <> 3 THEN„	TheDir$ = LEFT$(D$,I%-1)„ELSE„	TheDir$ = LEFT$(D$,I%)„END IF„GetDirectory$ = TheDir$„END FUNCTION„„FUNCTION GetLastDir$(D$)„Ln% = LEN(D$)„Slash$ = RIGHT$(D$,1)„IF Slash$ = "\" OR Slash$ = "/" THEN DECR Ln%„„FOR I% = Ln% TO 1 STEP -1„      Char$ = MID$(TheDir$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN EXIT FOR„NEXT I%„IF I% <> 3 THEN„	TheDir$ = INDEX$(D$,I%,Ln%)„ELSE„	TheDir$ = LEFT$(D$,I%)„END IF„GetLastDir$ = TheDir$„END FUNCTION„„FUNCTION INDEX$(M$,StartPos%,LastPos%)„INDEX$ = MID$(M$,StartPos%,LastPos% - StartPos% + 1)„END FUNCTION„„FUNCTION GetDirAndSlash$(D$)„Ln% = LEN(D$)„FOR I% = Ln% TO 1 STEP -1„      Char$ = MID$(D$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN EXIT FOR„NEXT I%„IF I% <> 3 THEN„	TheDir$ = LEFT$(D$,I%)„ELSE„	TheDir$ = LEFT$(D$,I%)„END IF„GetDirAndSlash$ = TheDir$„END FUNCTION„„FUNCTION AddSlash$(D$)„TheDir$ = TrueName$(D$)„IF LEN(TheDir$) > 3 AND RIGHT$(TheDir$,1) <> "\" THEN„	AddSlash$ = TheDir$ + "\"„ELSE„	AddSlash$ = TheDir$„END IF„END FUNCTION„„FUNCTION FileDirExist%(d$)„Ln% = LEN(D$)„FOR I% = Ln% TO 1 STEP -1„      Char$ = MID$(D$,I%,1)„	IF Char$ = "\" OR CHAR$ = "/" THEN EXIT FOR„NEXT I%„FileDirExist% = I%„END FUNCTION„„SUB PushDir(Directory$)„IF Directory$ = "" THEN EXIT SUB„INCR StackPos%„DirStack$(StackPos%) = Directory$„IF  DirExist%(TrueDir$) = 0 THEN MKDIR TrueDir$„END SUB„„SUB PopDir()„DECR StackPos%„END SUB„„FUNCTION TrueDir$()„D$ = DirStack$(1)„FOR I% = 2 to StackPos%„IF RIGHT$(DirStack$(I% -1),1) <> "\" THEN„	D$ = D$ + "\" + DirStack$(I%)„ELSE„	D$ = D$ + DirStack$(I%)„END IF„NEXT I%„TrueDir$ = D$„END FUNCTION„„SUB PushDir2(Directory$,Stack$(),StackPos2%) PUBLIC„IF Directory$ = "" THEN EXIT SUB„INCR StackPos2%„Stack$(StackPos2%) = Directory$„END SUB„„SUB PopDir2(StackPos2%) PUBLIC„DECR StackPos2%„END SUB„„FUNCTION TrueDir2$(Stack$(), StackPos2%) PUBLIC„D$ = Stack$(1)„FOR I% = 2 to StackPos2%„IF RIGHT$(Stack$(I% -1),1) <> "\" THEN„	D$ = D$ + "\" + Stack$(I%)„ELSE„	D$ = D$ + Stack$(I%)„END IF„NEXT I%„TrueDir2$ = D$„END FUNCTION„„FUNCTION DirExist%(Directory$)„DirName$ = DIR$(Directory$,16)„IF DirName$ = "" THEN EXIT FUNCTION„Exists% = ATTRIB(Directory$)„Exists% = BIT(Exists%,4)„IF Exists% THEN DirExist% = 1„END FUNCTION„„FUNCTION FileExist%(Directory$)„D$ = DIR$(Directory$)„IF D$ <> "" THEN FileExist% = 1„END FUNCTION„„FUNCTION TrueName$(Directory$)„DIM DirName2 AS STRING * 128„DirName$ = Directory$ +CHR$(0)„DirNamePtr??? = STRPTR32(DirName$)„DirNamePtr2??? = VARPTR32(DirName2$)„DosError?? = 0„„!PUSH DS„!LDS SI,DirNamePtr???„!LES DI,DirNamePtr2???„!MOV AH,&H60„!INT &H21„!POP DS„„!JNC NoError„!MOV DosError??,AX„NoError:„„TrueName$ = EXTRACT$(DirName2$,CHR$(0))„END FUNCTION„„FUNCTION CURDRIVE$„Curdrive$ = LEFT$(CURDIR$,1)„END FUNCTION„„FUNCTION MODTYPE??(Number%,ModNumber%)„ M% = Number% MOD ModNumber%„ IF M% = 0 THEN„ 	ModType% = ModNumber%„ ELSE„ 	ModType% = M%„ END IF„END FUNCTION„„SUB LzhView(LzhFile$,ArchiveFiles$(),ArchiveInfo$(), FilesInfo$, Success%)„ DIM Lzh AS LZHHead„ DIM FileName AS STRING * 8„ DIM Ext AS STRING * 4„„  FilePos??? = 0: QUIT% = 0„„  Handle% = FREEFILE„„  OPEN LzhFile$ FOR BINARY AS Handle%„  RestOfFileSize??? = LOF(Handle%)„  IF RestOfFileSize??? = 0 THEN„    CLOSE Handle%„    PRINT LzhFile$+" has an FileSize of Zero !"„    Success% = 0„    EXIT SUB„  END IF„„„  DO„          GET  Handle%,FilePos???,Lzh„          IF Lzh.Id1 = "-lh" Or Lzh.Id1 = "-lz" Or Lzh.Id1 = "-lZ" THEN„            IF Lzh.HeadSize AND (Lzh.HeadSize < RestOfFileSize???) THEN„                Get Handle%,FilePos??? + Lzh.HeadSize,DirLen??„                SEEK Handle%,FilePos??? + Lzh.HeadSize+3„„                IF DirLen?? > 0 AND DirLen?? < 256 THEN„                              GET$ Handle%,DirLen??-3,Directory$„                              REPLACE  CHR$(255) WITH "\" IN Directory$„                ELSE„                              Directory$ = ""„                END IF„„                INCR FilePos???, Lzh.CompressSize + Lzh.HeadSize + 2„                DECR RestOfFileSize???, FilePos???„„                INCR FileNumber??„„                File$ = LEFT$(Lzh.FileName,Lzh.FileNameLen)„                LSET FileName$ = Extract$(File$,".")„                LSET Ext$ = Extension$(File$)„                GetDateAndTime Lzh.Filedate,Lzh.FileTime,Filedate$,FileTime$„                IF DirLen?? THEN„                	DirSign$ = " + "„                ELSE„                	DirSign$ = "   "„                END IF„                ArchiveFiles$(FileNumber??) = Directory$ + File$„                ArchiveInfo$(FileNumber??)  = DirSign$ + FileName$ + Ext$ + USING$("########",Lzh.UnCompressSize) + " " + Filedate$ + "  "+FileTime$„            END IF„          ELSE„                INCR FilePos???, 2„           	    DECR RestOfFileSize???, FilePos???„          END IF„„  Loop UNTIL Lzh.HeadSize = 0 Or Lzh.HeadSize > RestOfFileSize??? OR FilePos??? = RestOfFileSize???„„  Close Handle%„  FilesInfo$ =  LzhFile$ + ":" + STR$(FileNumber??)+" Files"„  ArchiveFiles$(0) = MKWRD$(FileNumber??)„  ArchiveInfo$(0)  = MKWRD$(FileNumber??)„  IF FileNumber?? > 1 THEN ARRAY SORT ArchiveFiles$(1) FOR FileNumber??,TAGARRAY ArchiveInfo$()„  Success% = 1„END SUB„„SUB ZipView(ZipFile$,ArchiveFiles$(),ArchiveInfo$(),FilesInfo$,Success%)  ' View the ZIP File„ DIM Zip AS ZipType„ DIM FileName AS STRING * 8„ DIM Ext AS STRING * 4„ FileNumber?? = 0„„  Handle% = FREEFILE„  OPEN ZipFile$ FOR BINARY AS Handle%„  FileSize??? = LOF(Handle%)„  IF FileSize??? = 0 THEN               ' Check if files exists„    ?ZipFile;" has an FileSize of Zeor !"    ' if not, exit„    CLOSE Handle%„    Success% = 0„    EXIT SUB„  END IF„„    GET$ Handle%,2,PK$                   ' Read File Header„    IF PK$ = "PK" THEN„    	FilePos??? = 0„    ELSE„    	SEEK Handle%,2„      GET$ Handle%,2,PK$                   ' Read File Header„	IF PK$ = "PK" THEN„      	FilePos??? = 2„	ELSE„		Success% = 0„            EXIT SUB„      END IF„    END IF„„  DO„    GET Handle%,FilePos???,Zip                   ' Read File Header„„    IF (Zip.Signature = %Sig) THEN„      INCR FilePos???, Zip.CompressSize + 30 + Zip.FileNameLen + ZIP.ExtraField„      INCR FileNumber??„	GET$ Handle%,Zip.FileNameLen,File$„      TheFile$ = GetFileName$(File$)„      IF TheFile$ = "" THEN„      	DECR FileNumber??„            ITERATE DO„      END IF„„      LSET FileName$ = Extract$(TheFile$,".")„      LSET Ext$ = Extension$(File$)„      GetDateAndTime Zip.Filedate,Zip.FileTime,Filedate$,FileTime$„      ArchiveFiles$(FileNumber??) = File$„„	IF FileDirExist%(File$) THEN„		DirSign$ = " + "„	ELSE„		DirSign$ = "   "„	END IF„„      ArchiveInfo$(FileNumber??)  = DirSign$ + FileName$ + Ext$ + USING$("########",Zip.UnCompressSize) + "  "+Filedate$+"  "+FileTime$„  END IF„„  LOOP WHILE Zip.Signature = %Sig„  CLOSE Handle%„„  FilesInfo$ =  ZipFile$ + ":" + STR$(FileNumber??)+" Files"„  ArchiveInfo$(0) = MKWRD$(FileNumber??) 'Total Number of FIles„  ArchiveFiles$(0) = MKWRD$(FileNumber??)„  IF FileNumber?? > 1 THEN ARRAY SORT ArchiveFiles$(1) FOR FileNumber??,TAGARRAY ArchiveInfo$()„  Success% = 1„„END SUB„„SUB GetDirInfo(DirDate$,DirTime$,DirSize???,DirAttrib?) PUBLIC„  LOCAL DirDate??,DirTime??,DirAttr?,Dsize???„  ! mov  AX, &H2F00              ; function 2Fh, get DTA location„  ! int  &H21                    ; call DOS„  ! MOV  AX,ES:[BX + 24]„  ! MOV  DirDate??,AX„  ! MOV  AX,ES:[BX + 22]„  ! MOV  DirTime??,AX„  ! MOV  AX,ES:[BX +26]„  ! MOV  DSize???[0],AX„  ! MOV  AX,ES:[BX +28]„  ! MOV  DSize???[2],AX„  ! MOV  AL,ES:[BX +21]„  ! MOV  DirAttr?,AL„  DirSize??? = DSize???„  DirAttrib? = DirAttr?„    GetDateAndTime DirDate??,DirTime??,DirDate$,DirTime$„END SUB„„SUB GetDateAndTime(Filedate??,FileTime??,Filedate$,FileTime$) PUBLIC„       Year?? = (Filedate?? AND &B1111111000000000):SHIFT RIGHT Year??,9„       INCR Year??,1980„       Month?? = Filedate?? AND &B0000000111100000:SHIFT RIGHT Month??,5„       Day?? = Filedate?? AND &B0000000000011111„       Hours?? = FileTime?? AND &B1111100000000000:SHIFT RIGHT Hours??,11„       Minutes?? = FileTime?? AND &B0000011111100000:SHIFT RIGHT Minutes??,5„       Seconds?? = (FileTime?? AND &B0000000000011111) * 2„„       Month$ = LTRIM$(STR$(Month??))„       Day$ = LTRIM$(STR$(Day??))„       IF LEN(Month$) = 1 THEN Month$="0"+Month$„       IF LEN(Day$) = 1 THEN Day$ = "0"+Day$„       'IF Hours?? > 12 THEN„       '	Hours?? = Hours?? -12:AmPm$ = "p & "„       'ELSE„       '	AmPm$ = "a & "„       'END IF„       Hours$ = LTRIM$(STR$(Hours??))„       Minutes$ = LTRIM$(STR$(Minutes??))„       Seconds$ = LTRIM$(STR$(Seconds??))„       IF LEN(Hours$) = 1 THEN Hours$="0"+Hours$„       IF LEN(Minutes$) = 1 THEN Minutes$="0"+Minutes$„       IF LEN(Seconds$) = 1 THEN Seconds$="0"+Seconds$„„       Filedate$ = Month$ + "-" + Day$ + "-" + LTRIM$(STR$(Year??))„       FileTime$ = Hours$ + ":" + Minutes$ + ":" + Seconds$„       'FileTime$ = Hours$ + ":" + Minutes$ + AmPm$ + Seconds$ +"s"„„END SUB„„SUB Viewer(ViewFileName$)„DIM LinePt???(32700)„„NextHandle% = FREEFILE„OPEN ViewFIleName$ FOR INPUT AS NextHandle%„DO„        INCR I???„        LinePt???(I???) = SEEK(NextHandle%)„        LINE INPUT #NextHandle%,Dummy$„LOOP UNTIL EOF(NextHandle%)„LinePt???(0) = I???„ViewFile LinePt???()„CLOSE NextHandle%„END SUB„„SUB ViewFile(FileLines???())„„   DIM PrintLine AS STRING * 80,Lines AS STRING * 1000„   SHARED LineSeg??,LinePtr??„   LineSeg?? = VARSEG(Lines$)„   LinePtr?? = VARPTR(Lines$)„   DisplayLine% = 23„   PrintLine$ = SPACE$(80)„   LowFile& = 1:HiFile& = 23„   TotalLines& = FileLines???(0)„   DisPlayPos% = 1„   HorzPos% = 1„   Choice% = 1„   IF TotalLines& < DisplayLine% THEN HiFile& = TotalLines&„„     BottomDisplayLine% = DisplayLine%„     COLOR 7,1„     CLS„     COLOR 0,7„     LOCATE 1,1:PRINT SPACE$(80);„     LOCATE 25,1:PRINT SPACE$(80);„     COLOR 7,1„„„   DO„      COLOR 15, 1„      LinePos% = 0„      IF TotalLines& < 23 THEN BottomDisplayLine% = TotalLines&„      IF ScrollIt% = 0 THEN„      	WAIT &H3DA,8„              FOR ViewLines??? = LowFile& TO HiFile&„	         INCR LinePos%„               SEEK NextHandle%,FileLines???(ViewLines???)„               Line Input #NextHandle%, LineInput$„               REPLACE CHR$(9) WITH "      " IN LineInput$„               Lines$ = LineInput$„               IF LinePos% = DisplayPos% THEN„                        QuickPrintLine 1 + LinePos%,HorzPos%,71„                        IF Find% THEN PrintAtr 1 + LinePos%, Find%-HorzPos% + 1,SearchLen%, 48„	         ELSE„                        QuickPrintLine 1 + LinePos%, HorzPos%,23„	         END IF„              NEXT ViewLines???„            FOR I% = LinePos% + 1 To DisplayLine%„	            QPRINT 1 + I%, 1 ,PrintLine$,23„            NEXT I%„      ELSE„               SEEK NextHandle%,FileLines???(Choice&)„               Line Input #NextHandle%, LineInput$„               REPLACE CHR$(9) WITH "      " IN LineInput$„               Lines$ = LineInput$„               QuickPrintLine 1 + DisplayPos%, HorzPos% ,71„      END IF„      COLOR 0,7„      LOCATE 1,1„      PRINT "ViewFile";„      LOCATE 1,10„      PRINT ;Choice&;„      LOCATE 1,18„      PRINT ;TotalLines&;„      LOCATE 1,27:PRINT HorzPos%;„      LOCATE 1,34:PRINT "1000";„      COLOR 7,1„      ScrollIt% = 0„      ClearBuffer„      FindLine% = 0:Find% = 0:SearchLen% = 0„      DO: ky$ = UCASE$(INKEY$): LOOP WHILE ky$ = ""„      Ky% = ASC(Ky$)„      IF Ky%= 0 THEN Ky% = -ASC(Right$(ky$,1))„       SELECT CASE Ky%„         CASE %RightArrow„                IF HorzPos% < 1000 THEN INCR HorzPos%„         CASE %LeftArrow„                IF HorzPos% > 1 THEN DECR HorzPos%„         CASE %Escape„         	    EXIT DO„         CASE %Home„         	Choice& = 1:LowFile& = 1„            HiFile& = BottomDisplayLine%„            DisplayPos% = 1„         CASE %EndKey„            Choice& = TotalLines&„            DisplayPos% = ModType2??(Choice&, BottomDisplayLine%)„            LowFile& = Choice& - DisplayPos% + 1„            HiFile& = TotalLines&„         CASE %PageDown„            INCR Choice&, DisplayLine%„            INCR LowFile&,DisplayLine%„            HiFile& = LowFile& + BottomDisplayLine% -1„            IF HiFile& > TotalLines& THEN HiFile& = TotalLines&„		IF Choice& > TotalLines& THEN„			Choice& = TotalLines&„                        DisplayPos% = ModType2??(Choice&, BottomDisplayLine%)„			LowFile& = Choice& - DisplayPos% + 1„			HiFile& = TotalLines&„	      END IF„„         CASE %PageUp„            DECR Choice&,DisplayLine%„            DECR LowFile&,DisplayLine%„            HiFile& = LowFile& + DisplayLine% -1„            IF LowFile& < 1 THEN LowFile& = 1:HiFile& = BottomDisplayLine%„	      IF Choice& <=1 THEN„              Choice& = 1„              LowFile& = 1„              HiFile& = BottomDisplayLine%„              DisplayPos% = 1„      	END IF„         CASE %DownArrow„            INCR Choice&„            IF Choice& <= TotalLines& THEN„                  INCR DisplayPos%„            ELSE„            	Choice& = TotalLines&„            END IF„	      IF DisplayPos% > BottomDisplayLine% THEN„                DisplayPos% = BottomDisplayLine%„                LowFile& = Choice& -BottomDisplayLine% + 1„                IF HiFile&  >= TotalLines& THEN„                   HiFile& = TotalLines&„                ELSE„                   HiFile& = LowFile& + BottomDisplayLine% -1„                END IF„                PrintAtr BottomDisplayLine%+1, 1, 80, 23„                Scroll 1, 0, BottomDisplayLine%, 79, 1, 23, %Up„                ScrollIt% = 1„      	END IF„         CASE %UpArrow„             DECR Choice&„             DECR DisplayPos%„             IF Choice& <=1 THEN„             	Choice& = 1„             	LowFile& = 1„             	HiFile& = BottomDisplayLine%„             	DisplayPos% = 1„             ELSE„	            IF DisplayPos% < 1 THEN„		             DisplayPos% = 1„		             LowFile& = Choice&„		             HiFile& = Choice& + BottomDisplayLine% -1„                         IF HiFile&  >= TotalLines& THEN„            		       HiFile& = TotalLines&„                         ELSE„            		       HiFile& = LowFile& + BottomDisplayLine% -1„                         END IF„                         PrintAtr 2, 1, 80, 23„                         Scroll 1,0, BottomDisplayLine%,79, 1,23,%Down„                         ScrollIt% = 1„                  END IF„             END IF„        CASE 70 'F„            LOCATE 25,1:COLOR 0,7„            PRINT Space$(50);„            LOCATE 25,1„            LINE INPUT; "FIND >";Search$„            COLOR 7,1„            Search$ = UCASE$(Search$)„            FOR I??? = Choice& + 1 TO TotalLines&„                  SEEK NextHandle%,FileLines???(I???)„                  Line Input #NextHandle%, LineInput$„                  REPLACE Chr$(9) WITH "      " IN LineInput$„                  Find% = BINSTR% (1,UCASE$(LineInput$),Search$)„                  IF Find% THEN EXIT FOR„            NEXT I???„            IF Find% = 0 THEN„                  FOR I??? =  1 TO Choice& -1„                          SEEK NextHandle%,FileLines???(I???)„                          Line Input #NextHandle%, LineInput$„                          REPLACE Chr$(9) WITH "      " IN LineInput$„                          Find% = BINSTR% (1,UCASE$(LineInput$),Search$)„                          IF Find% THEN EXIT FOR„                  NEXT I???„            END IF„            IF Find% THEN„			GOSUB ResetValues„            END IF„            EXIT SELECT„        CASE 65 'N„            FOR I??? = Choice& + 1 TO TotalLines&„                  SEEK NextHandle%,FileLines???(I???)„                  Line Input #NextHandle%, LineInput$„                  REPLACE Chr$(9) WITH "      " IN LineInput$„                  Find% = BINSTR% (1,UCASE$(LineInput$),Search$)„                  IF Find% THEN EXIT FOR„            NEXT I???„            IF Find% = 0 THEN„                  FOR I??? =  1 TO Choice& -1„                  	SEEK NextHandle%,FileLines???(I???)„	                  SEEK NextHandle%,FileLines???(I???)„	                  Line Input #NextHandle%, LineInput$„	                  REPLACE Chr$(9) WITH "      " IN LineInput$„	                  Find% = BINSTR% (1,UCASE$(LineInput$),Search$)„                        IF Find% THEN EXIT FOR„                  NEXT I???„            END IF„            IF Find% THEN„			GOSUB ResetValues„            END IF„            EXIT SELECT„        CASE ELSE„            	EXIT DO„      END SELECT„   LOOP„„   COLOR 7,0„   EXIT SUB„„ResetValues:„               SearchLen% = LEN(Search$)„		   Choice& = I???„               FindLine% = I???„               DisplayPos% = ModType2??(Choice&, BottomDisplayLine%)„               LowFile& = Choice& - DisplayPos% + 1„               HiFile& = LowFile& + BottomDisplayLine% -1„               IF LowFile& < 1 THEN LowFile& = 1:HiFile& = BottomDisplayLine%:DisplayPos% = Choice&„               IF HiFile& > TotalLines& THEN HiFile& = TotalLines&„               IF HorzPos% > Find% THEN HorzPos% = 1„               IF Find% > HorzPos% + 80 -1  THEN HorzPos% = Find% -80 + SearchLen% + 80\SearchLen% -1„RETURN„END SUB„„FUNCTION ModType2??(Number&,ModNumber%)„ M?? = Number& MOD ModNumber%„ IF M?? = 0 THEN„ 	ModType2?? = ModNumber%„ ELSE„ 	ModType2?? = M??„ END IF„END FUNCTION„„SUB QuickPrintLine(BYVAL Row , BYVAL HorzPos%,BYVAL attr) PUBLIC„„   ! push DS                 ; save DS for PowerBASIC„   ! mov             ax,Row%         ; get the row„   ! dec             al              ; convert row to zero base„   ! mov             bl,80           ; get the number of cols„   ! mul             bl              ; multiply # of cols * rows„   ! mov             di,ax           ; offset within video page„   ! shl             di,1            ; account for color/attribute„   ! mov  CX,1000„   ! mov  BX, 80„   ! sub  CX, HorzPos%„   ! CMP  CX, 80„   ! Jg   GoAhead„   ! SUB BX, CX„   ! JMP DoIt„   GoAhead:„   ! MOV CX,80„   ! MOV BX,0„   DoIt:„   ! MOV  SI, LinePtr??      ; put segment in DS„   ! MOV  DS, LineSeg??„   ! add  SI, HorzPos%„   ! DEC  SI„   ! mov  ES, ScreenSegment??    ; move to ES„   ! mov  AH, attr           ; put attribute in AH„   ! jcxz RestOfLine         ; if it's Null, exit„   WriteChar2:„   ! lodsb                   ; get Char from string„   ! stosw                   ; write Char and attribute to screen„   ! loop WriteChar2         ; do it all CX times„   RestOfLine:„    ! MOV  AH, attr          ; put attribute in AH„    ! MOV AL,32„    ! MOV CX,BX„    ! jcxz Quit3              ; if it's Null, Do Rest of Line„    ! REP stosw„    Quit3:„    ! pop  DS                ; restore DS for PowerBASIC„END SUB„„„%SMALLEST.PATTERN = 2„%SMALLEST.BUFFER  = 4„„FUNCTION BINSTR%(TheStart%, Target$, Rule$) PUBLIC„„    ' ES:DI Target$„    ' DS:SI Rule$„„    PatLen%      = LEN(Rule$)„    BuffLen%     = LEN(Target$)„„    IF BuffLen% < %SMALLEST.BUFFER THEN„        FUNCTION = INSTR(TheStart%, Target$, Rule$)„        EXIT FUNCTION„    ELSE„        IF PatLen% < %SMALLEST.PATTERN THEN„            FUNCTION = INSTR(TheStart%, Target$, Rule$)„            EXIT FUNCTION„        END IF„    END IF„„    IF TheStart% > BuffLen% THEN      ' we might as well not even bother„        EXIT FUNCTION„    END IF„„    StackSeg??    = 0                 ' We do this for later inline ASM„„    PatSeg??      = STRSEG(Rule$)„    PatPtr??      = STRPTR(Rule$)„    BuffSeg??     = STRSEG(Target$)„    BuffPtr??     = STRPTR(Target$) + TheStart%„    TrueBuffPtr?? = BuffPtr??„„    !   cld„    !   push    sp„    !   push    si             ;preserve caller's register variables„    !   push    di„    !   push    es„    !   push    ds„    !   sub     sp, 256*2      ;allocate space for SkipTable on our„    !                          ; stack„„„    !   mov     ax,PatLen%„    !   and     ax,ax          ;return an instant match if the„    !   jz      InstantMatch   ; pattern 0-length„„    !   mov     StackSeg??,ss„    !   mov     es,StackSeg??„    !   mov     di,sp          ;point to SkipBuffer„„    !   mov     cx,256„    !   rep     stosw„„    !   mov     es,BuffSeg??„    !   mov     ds,PatSeg??„„    !   dec     ax             ;from now on, we only need„    !   mov     PatLen%,ax      ; PatLen% - 1„„    '   Point to last (rightmost) byte of first potential pattern match„    '   location in buffer.„„    !   add     BuffPtr??, ax„„„    !   sub     BuffLen%,ax„    !   jbe     NoMatch„„„    !   mov     si,PatPtr??      ;point to start of pattern„    !   and     ax,ax          ;are there any skips to set?„    !   jz      SetSkipDone    ;no„    !   mov     di,sp          ;point to SkipBuffer„„SetSkipLoop:„    !   sub     bx,bx          ;prepare for word addressing off byte value„    !   mov     bl,ds:[si]     ;get the next pattern byte„    !   inc     si             ;advance the pattern pointer„    !   shl     bx,1           ;prepare for word look-up„    !   mov     ss:[di+bx],ax  ;set the skip value when this byte value„    !                          ;is the mismatch value in the buffer„    !   dec     ax„    !   jnz     SetSkipLoop„„SetSkipDone:„    !   mov     dl,ds:[si]     ;DL=rightmost pattern byte from now on„    !   dec     si             ;point to next-to-rightmost byte of pattern„    !   mov     PatPtr??,si      ; from now on„„    '   Search the buffer.„„    !   std                    ;for backward REPZ CMPSB„    !   mov     di,BuffPtr??     ;point to the first search location„    !   mov     cx,BuffLen%     ;# of match locations to check„„SearchLoop:„    !   mov     si,sp          ;point SI to SkipTable„„    '   Skip through until there's a match for the rightmost pattern„    '   byte.„„    '   We jump this way to avoid a FIXUP OVERFLOW under PB... <sigh>„    !   jmp     QuickSearchLoop„„InstantMatch:„    !   mov     ax,BuffPtr??„    !   jmp     short Done„„    '   Compare the pattern and the buffer location, searching from high„    '   memory toward low (right to left).„„FullCompare:„    !   mov     BuffPtr??,di     ;save the current state of„    !   mov     BuffLen%,cx     ; the search„    !   mov     cx,PatLen%      ;# of bytes yet to compare„    !   jcxz    Matched        ;done if there was only one character„    !   mov     si,PatPtr??      ;point to next-to-rightmost bytes„    !   dec     di             ; of buffer location and pattern„„    !   repz    cmpsb          ;compare the rest of the pattern„„    !   jz      Matched        ;that's it; we've found a match„„    '   It's a mismatch; let's see what we can learn from it.„„    !   inc     di             ;compensate for 1-byte overrun of REPZ CMPSB;„    !                          ; point to mismatch location in buffer„    !                          ; # of bytes that did match.„    !   mov     si,BuffPtr??„    !   sub     si,di„„„    !   sub     bx,bx          ;prepare for word addressing off byte value„    !   mov     bl,es:[di]     ;get the value of the mismatch byte in buffer„    !   add     bx,bx          ;prepare for word look-up„    !   add     bx,sp          ;SP points to SkipTable„    !   mov     cx,ss:[bx]     ;get the skip value for this mismatch„    !   mov     ax,1           ;assume we'll just advance to the next„    !                          ; potential match location„    !   sub     cx,si          ;is the skip far enough to be worth taking?„    !   jna     MoveAhead      ;no, go with the default advance of 1„    !   mov     ax,cx          ;yes; this is the distance to skip ahead from„    !                          ; the last potential match location checked„„MoveAhead:„    '   Skip ahead and perform the next comparison, if there's any buffer„    '   left to check.„„    !   mov     di,BuffPtr??„    !   add     di,ax          ;BuffPtr?? += Skip„    !   mov     cx,BuffLen%„    !   sub     cx,ax          ;BuffLen% -= Skip;„    !   ja      SearchLoop     ;continue if any buffer left„„    '   Return a NULL pointer for no match.„„NoMatch:„    !   sub     ax,ax„    !   jmp     short Done„„    '   Return start of match in buffer (BuffPtr?? - (PatLen% - 1)).„„Matched:„    !   mov ax, BuffPtr??„    !   sub ax, TrueBuffPtr??„    !   sub ax, PatLen%„„    !   les bx, [bp+&HE]„    !   add ax, es:[bx]         ; Parameter: TheStart%„„    !   inc ax„    !   mov FUNCTION, ax„„Done:„    !   cld„    !   add     sp,256*2       ;deallocate space for SkipTable„    !   pop     ds„    !   pop     es„    !   pop     di             ;restore caller's register variables„    !   pop     si„    !   pop     sp„„EXIT FUNCTION„„QuickSearchLoop:„    !   mov     bl,es:[di]     ;rightmost buffer byte at this location„    !   cmp     dl,bl          ;does it match the rightmost pattern byte?„    !   jz      FullCompare    ;yes, so keep going„    !   sub     bh,bh          ;convert to a word„    !   add     bx,bx          ;prepare for look-up in SkipTable„„    !   mov     ax,ss:[si+bx]  ;get skip value from skip table for this„    !                          ; mismatch value„„    !   add     di,ax          ;BuffPtr?? += Skip;„    !   sub     cx,ax          ;BuffLen% -= Skip;„    !   ja      QuickSearchLoop;continue if any buffer left„    !   jmp     short NoMatch„„    '   Return a pointer to the start of the buffer (for 0-length„    '   pattern).„„END FUNCTION„Randall L. Glass               SCROLL TEXT SCREEN             rlglass@yahoo.com              10-25-99 (18:05)       PB                     102  2119     SCRLTEXT.BAS'-------------------------------------------------------------------------„'„'                      Scroll Text Screen„'                      BY Randall L Glass„'                      CopyRight Aug3,1999„'„'---------------------------------------------------------------------------„'„' Email rlglass@yahoo.com„' Snail Mail RR1,BOX 248,McLeansboro,IL 62859„'---------------------------------------------------------------------------„'„' This Program is Public Domain(PowerBasic Code)„'„'----------------------------------------------------------------------------„„DEFINT A-Z„DIM ScreenBuffer??(2000)„SHARED ScreenSegment??, ScreenAdress???,VideoBufferSeg??„IF(PBVScreenCARD AND 1) = 0 THEN„      ScreenSegment?? = 47104       '&HB800          'color monitor„      ScreenAdress??? = 47104 * 65536„ELSE„      ScreenSegment?? = 45056       '&HB000          'mono monitor„      ScreenAdress??? = 45056 * 65536„END IF„VideoBufferSeg?? = ScreenSegment??„CLS„COLOR 0,7„LOCATE 1,1:PRINT SPACE$(80);„COLOR 7,1„FOR Row% = 2 to 24„	FOR Col% = 1 to 80„            INCR I%„            IF Row% = 2 THEN„            	COLOR 0,6„            ELSE„            	COLOR 7,1„            END IF„		LOCATE ROW%,Col%:PRINT CHR$((I% MOD 26)+64);„	NEXT COL%„NEXT Row%„COLOR 0,7„LOCATE 25,1:PRINT SPACE$(80);„COLOR 7,1„„FOR I% = 1 TO 23„DO:LOOP UNTIL INKEY$ <> ""„ScrollDown„NEXT i%„'ScrollRight„END„„SUB ScrollLeft()„WAIT &H3DA,8„! push ds„! mov es,ScreenSegment??„! mov ds,ScreenSegment??„! mov cx,1838„! mov si,162„! mov di,160„! cld„! rep movsw„! pop ds„END SUB„„SUB ScrollRight()„WAIT &H3DA,8„! push ds„! mov es,ScreenSegment??„! mov ds,ScreenSegment??„! mov cx,1839„! mov si,3836„! mov di,3838„! STD„! REP movsw„! pop ds„END SUB„„SUB ScrollUp()„! PUSH DS„! mov es,VideoBufferSeg??„! mov ds,VideoBufferSeg??„! mov cx,1760„! mov DI,160„! mov SI,320„! CLD„! rep movsw„! pop ds„END SUB„„SUB ScrollDown()„! PUSH DS„! mov es,VideoBufferSeg??„! mov ds,VideoBufferSeg??„! mov cx,1760„! mov si,3678„! mov di,3838„! STD„! rep movsw„! pop ds„END SUB„Randall L. Glass               PRINT CHARACTER                rlglass@yahoo.com              10-25-99 (18:05)       PB                     97   4442     PRINTCHR.BAS'----------------------------------------------------------------------------„'„'                                  PrintChar„'                               BY Randall Glass„'                                Copyright 1999„'„'----------------------------------------------------------------------------„' FREEWARE„'„' You may use this as long as you give me credit somewhere in the documentation„'„' Email rlglass@yahoo.com„'„'--------------------------------------------------------------------------„„IF(PBVScreenCARD AND 1) = 0 THEN„      ScreenSegment?? = 47104       '&HB800          'color monitor„ELSE„      ScreenSegment?? = 45056       '&HB000          'mono monitor„END IF„„SUB PrintAtr(byval Row%, byval Col%,ByVal LineWidth%, byval Attr%)„ScreenSeg??  = ScreenSegment??„!           push    ds              ;save the good stuff„!           mov     ax,Row%         ; get the row„!           dec     al              ; convert row to zero base„!           mov     bl,80           ; get the number of cols„!           mul     bl              ; multiply # of cols * rows„!           add     ax,Col%         ; add the column„!           dec     al              ; convert column to zero base„!           mov     di,ax           ; offset within video page„!           shl     di,1            ; account for color/attribute„!           mov     es,ScreenSeg??  ;put video segment into ax„!           mov     ah,Attr%        ;the color attribute will be needed„!           mov     cx,LineWidth%„forloop:„!           inc     di              ;increment to the next vidram position„!           mov     es:[di],ah      ;poke the attribute into vidram„!           inc     di„!           loop    forloop         ;loop until cx = 0„!           pop     ds„END SUB„„SUB PrintVertChars(byval Row%, byval Col%,BYVAL Rows%,BYVAL CharVal?, byval Attr?)„ScreenSeg??  = ScreenSegment??„!       push        ds              ;save the good stuff„!       push        di              ;because we're gonna destroy it„!       push        si„!       mov         ax,Row%         ; get the row„!       dec         al              ; convert row to zero base„!       mov         bl,80           ; get the number of cols„!       mul         bl              ; multiply # of cols * rows„!       add         ax,Col%         ; add the column„!       dec         al              ; convert column to zero base„!       mov         di,ax           ; offset within video page„!       shl         di,1            ; account for color/attribute„!       mov         es,ScreenSeg??  ;put video segment into es„!       mov         ah,Attr?        ;the color attribute will be needed„!       mov         al,CharVal?„!       mov         cx,Rows%„forloop2:„!       mov         es:[di],al	;poke the attribute into vidram„!       inc         di              ;increment to the next vidram position„!       mov         es:[di],ah	;poke the attribute into vidram„!       add         DI,159„!       inc         si              ;increment to the next string position„!       loop        forloop2		;loop until cx = 0„„END SUB„„SUB PrintvertAtrs(byval Row%, byval Col%,BYVAL SWidth%, byval Attr?)„ScreenSeg??  = ScreenSegment??„„!       push        ds              ;save the good stuff„!       push        di              ;because we're gonna destroy it„!       push        si„!       mov         ax,Row%         ; get the row„!       dec         al              ; convert row to zero base„!       mov         bl,80           ; get the number of cols„!       mul         bl              ; multiply # of cols * rows„!       add         ax,Col%         ; add the column„!       dec         al              ; convert column to zero base„!       mov         di,ax           ; offset within video page„!       shl         di,1            ; account for color/attribute„!       mov         es,ScreenSeg??    ;put video segment into es„!       mov         ah,Attr?            ;the color attribute will be needed„!       mov         cx,SWidth%„!       inc         di                  ;increment to the next vidram position„forloop3:„!       mov         es:[di],ah          ;poke the attribute into vidram„!       ADD         di,160„!       loop        forloop3             ;loop until cx = 0„!       pop         si                  ;restore the good stuff„!       pop         di„!       pop         ds„„END SUB„Randall L. Glass               BINARY SEARCH                  rlglass@yahoo.com              10-25-99 (18:05)       PB                     485  4899     BNSEARCH.BAS'----------------------------------------------------------------------------„'„'                                Binary Search„'                               BY Randall Glass„'                                Copyright 1999„'„'----------------------------------------------------------------------------„' FREEWARE„'„' You may use this as long as you give me credit somewhere in the documentation„'„' Email rlglass@yahoo.com„'„'--------------------------------------------------------------------------„„dim varArray$(1 to 550)„open "pbcomand.dat" for input as #1„„i% = 0„„do„	incr i%„	input #1,VarArray$(i%)„Loop until eof(1)„close„total% = i%„array sort VarArray$(1) for total%„mtimer„k% = BinSearch (1,total%,"INSERT", VarArray$() )„m?? = Mtimer„print m??„stop„„DEFINT A-Z„„FUNCTION BinSearch (byval MinPos%,byval MaxPos%,Find$, AStringArray$()) Public„'MinPos% = start at first element„'MaxPos% = through last element„!       push DS„!       mov Cx,MinPos%„!       mov Dx,MaxPos%„TryAgain:„!       mov ax,cx        ;CX = Minpos%„!       add ax,dx        ;DX = MaxPos%„!       shr ax,1         ;ax = Try„!       mov Try,ax„'  Try = (MaxPos% + MinPos%) \ 2         'start testing in middle„„  IF AStringArray$(Try) = Find$ THEN     'found it!„        BinSearch = Try„!       jmp JustDone„	'BiSearch = Try              'return matching element„'	EXIT LOOP                     'all done„  END IF„„  IF AStringArray$(Try) > Find$ THEN     'too high, cut in half„	!      mov  dx,ax„      !      dec  dx„'     MaxPos% = Try - 1„  ELSE„      !  mov cx,ax„      !  Inc cx„'	MinPos% = Try + 1               'too low, cut other way„  END IF„!      cmp  dx,cx„!      jae   TryAgain„'if    MaxPos% >= MinPos%  then goto tryagain„JustDone:„!     Pop   DS„END FUNCTION„'-------------------------------------------------------------------------„$ALIAS„$CODE„$COM„$COM1„$COM2„$COMPILE„$CPU„$DEBUG„$DIM„$DYNAMIC„$ELSE„$ENDIF„$ERROR„$EVENT„$FLOAT„$HUGE„$IF„$INCLUDE„$INLINE„$LIB„$LINK„$LIST„$OPTIMIZE„$OPTION„$SEGMENT„$SOUND„$STACK„$STATIC„$STRING„ABS„ABSOLUTE„ACCESS„ALIAS„ALL„AND„ANY„APPEND„ARRAY„AS„ASC„ASCEND„ASCII„ASM„AT„ATN„ATTRIB„BASE„BCD„BEEP„BIN$„BINARY„BIT„BITS„BLOAD„BSAVE„BYTE„BYVAL„CALL„CASE„CBCD„CBYT„CCUR„CDBL„CDECL     „CDWD„CEIL„CEXT„CFIX„CHAIN„CHDIR„CHDRIVE„CHR$„CINT„CIRCLE„CLEAR„CLNG„CLOSE„CLS„CODEPTR„CODESEG„COLLATE„COLOR„COM„COMMAND$„COMMON„COS„CQUD„CSNG„CSRLIN„CURDIR$„CVB„CVBYT„CVD„CVDWD„CVE„CVF„CVI„CVL„CVMD„CVMS„CVQ„CVS„CVWRD„CWRD„DATA„DATE$„DECLARE„DECR„DEF„DEFBCD„DEFBYT„DEFCUR„DEFDBL„DEFDWD„DEFEXT„DEFFIX„DEFFLX„DEFINT„DEFLNG„DEFQUD„DEFSNG„DEFSTR„DEFWRD„DELAY„DELETE„DESCEND„DIM„DIR$„DO„DOUBLE„DRAW„DWORD„DYNAMIC„ELSE„ELSEIF„EMS„END„ENDMEM„ENVIRON„ENVIRON$„EOF„EQV„ERADR„ERASE„ERDEV„ERDEV$„ERL„ERR„ERROR„ERRTEST„EVENT„EXE„EXECUTE„EXIT„EXP„EXP10„EXP2„EXTERNAL„EXTRACT$„FAR„FIELD„FILEATTR„FILES„FIX„FIXDIGITS„FLEXCHR$„FLUSH„FN„FOR„FRAC„FRE„FREEFILE„FROM„FUNCTION„GET„GET$„GO„GOSUB„GOTO„HEX$„IF„IMP„IN„INCR„INKEY$„INLINE„INP„INPUT„INPUT$„INSERT„INSTAT„INSTR„INT„INTEGER„INTERRUPT„IOCTL„IOCTL$„IS„ISFALSE„ISTRUE„ITERATE„KEY„KILL„LBOUND„LCASE$„LEFT„LEFT$„LEN„LET„LINE„LIST„LOC„LOCAL„LOCATE„LOCK„LOF„LOG„LOG10„LOG2„LONG„LOOP„LPOS„LPRINT„LSET„LTRIM$„MAP„MAX„MAX$„MAX%„MEMPACK„MEMSET„MID$„MIN„MIN$„MIN%„MKB$„MKBYT$„MKD$„MKDIR„MKDWD$„MKE$„MKF$„MKI$„MKL$„MKMD$„MKMS$„MKQ$„MKS$„MKWRD$„MOD„MTIMER„MULTIPLEX„NAME„NEXT„NOT„OCT$„OFF„ON„OPEN„OPTION„OR„OUT„OUTPUT„PAINT„PALETTE„PBVBINBASE„PBVCPU„PBVCURSOR1„PBVCURSOR2„PBVCURSORVIS„PBVDEFSEG„PBVERR„PBVFIXDIGITS„PBVFLEXCHR„PBVHOST„PBVMINUSONE„PBVNPX„PBVONE„PBVREVISION„PBVREVLTR„PBVSCRNAPAGE„PBVSCRNBUFF„PBVSCRNCARD„PBVSCRNCOLS„PBVSCRNMODE„PBVSCRNPXLATTR„PBVSCRNROWS„PBVSCRNTXTATTR„PBVSCRNVPAGE„PBVSWITCH„PBVUSERAREA„PBVUSINGCHRS„PBVVTXTX1„PBVVTXTX2„PBVVTXTY1„PBVVTXTY2„PBVZERO„PEEK„PEEK$„PEEKI„PEEKL„PEN„PLAY„PMAP„POINT„POKE„POKE$„POKEI„POKEL„POPUP„POS„PRESET„PRINT„PRIVATE„PSET„PTR„PUBLIC„PUT„PUT$„QUIET„RANDOM„RANDOMIZE„READ„REDIM„REG„REM„REMOVE$„REPEAT$„REPLACE„RESET„RESTORE„RESUME„RETURN„RIGHT„RIGHT$„RMDIR„RND„ROTATE„ROUND„RSET„RTRIM$„RUN„SAVE„SCAN„SCREEN„SEEK„SEG„SELECT„SETMEM„SGN„SHARED„SHELL„SHIFT„SIGNED„SIN„SINGLE„SLEEP„SORT„SOUND„SPACE$„SPC„SQR„STATIC„STEP„STICK„STOP„STR$„STRIG„STRING„STRING$„STRPTR32„STRPTR„STRSEG„STUFF„SUB„SWAP„SYSTEM„TAB„TAGARRAY„TALLY„TAN„THEN„TIME$„TIMER„TO„TROFF„TRON„TYPE„UBOUND„UCASE„UCASE$„UEVENT„UNION„UNIT„UNLOCK„UNTIL„USING„USING$„USR„VAL„VARPTR„VARPTR$„VARSEG„VERIFY„VIEW„WAIT„WEND„WHILE„WIDTH„WINDOW„WITH„WORD„WRITE„XOR„Randall L. Glass               COPY TEXT BUFFER               rlglass@yahoo.com              10-25-99 (18:05)       PB                     27   974      COPYTEXT.BAS'-------------------------------------------------------------------------„'„'                       Copy Text Buffer„'                      BY Randall L Glass„'                      CopyRight Aug3,1999„'„'---------------------------------------------------------------------------„'„' Email rlglass@yahoo.com„' Snail Mail RR1,BOX 248,McLeansboro,IL 62859„'---------------------------------------------------------------------------„'„' This Program is Public Domain(PowerBasic Code)„'„'----------------------------------------------------------------------------„„SUB CopyTextBuffer()„WAIT &H3DA,8      ;Wait for vertical retrace„! PUSH    DS              ;Save the Destination Segment„! LES     DI,VideoAdress???„! MOV     SI,VideoBufferPtr??„! MOV     DS,VideoBufferSeg??„! MOV     CX,2000         ;Number of words to copy (2000)„! CLD„! REP     MOVSW           ;Move the words!„! POP     DS              ;Reset the Destination Segment„END SUB„