Earl Montgomery                BLOWING BUBBLES                FidoNet QUIK_BAS Echo          10-27-95 (23:10)       QB, QBasic, PDS        47   973      BUBBLES.BAS ' This graphic shorty depicts bubbles being blown through a„' soda straw.„DEFINT A-Z„RANDOMIZE TIMER„SCREEN 12„CLS„st = 4„COLOR 15„LOCATE 4, 36: PRINT "BUBBLES";„firstdraw:„FOR x = 20 TO 320„CIRCLE (x, 240), 4, 15„NEXT„CIRCLE (320, 240), 4, 7„PAINT (320, 240), 7, 7„CIRCLE (320, 240), 2, 4„PAINT (320, 240), 4, 4„SLEEP (3)„pickrad:„h = RND * 600: v = RND * 460„r = RND * 8„IF r < 2 THEN GOTO pickrad„IF h < 12 THEN GOTO pickrad„IF v < 12 THEN GOTO pickrad„drawcircles:„IF POINT(h, v) = 0 OR POINT(h, v) = 15 THEN GOTO pickrad„c = RND * 15„IF c = 0 THEN GOTO drawcircles„cc = RND * 15„r2 = RND * 4„IF r2 = 0 THEN r2 = 2„CIRCLE (h, v), r, c„PAINT (h, v), c, c„CIRCLE (h, v), r / 2, cc„PAINT (h, v), cc, cc„cntr = cntr + 1„IF cntr = 4000 THEN cntr = 0: GOTO web„GOTO pickrad„web:„FOR x = 320 TO 1 STEP -st„CIRCLE (320, 240), x, 0„NEXT„st = st - 1„SLEEP (1)„IF st > 0 THEN GOTO web„SLEEP (3): SCREEN 0: CLS : END„                „Tika Carr                      GRAPHICAL USER INTERFACE       FidoNet QUIK_BAS Echo          11-04-95 (00:00)       QB, PDS                344  8201     GUI.BAS     ' Graphical User Interface V. 1.0„„' Written by Tika Carr„' Released into the Public Domain on November 4, 1995„' Please keep me posted on any changes you make, so I can add them on too.„' E-Mail: Delta4@VivaNET.com„  „DECLARE SUB Mouse2 ()„DECLARE SUB Overlay (x1%, y1%, x2%, y2%, Klr%, OFlg%)„DECLARE SUB OvrWin (x1%, y1%, x2%, y2%, Klr%)„DECLARE SUB Mouse ()„DECLARE SUB CircleBtn ()„DECLARE SUB VScreen (x1%, y1%, x2%, y2%, Bkgn%)„DECLARE SUB startmouse ()„DECLARE SUB showmouse ()„DECLARE SUB getmousecord (btn%, M3%, M4%)„DECLARE SUB hidemouse ()„DECLARE SUB MakeButton (P$, XL%, KKr%, KKh%)„DECLARE SUB ButtonDraw ()„DECLARE SUB gprint (S$, x%, y%, Klr%)„  „' This uses VGA graphics mode 12:  640 x 480/16 color, 80 x 60 text area„  „DEFINT A-Z„'$INCLUDE: 'QB.BI'„  „TYPE COORD„ bx1 AS INTEGER„ bx2 AS INTEGER„ Flag AS INTEGER„END TYPE„  „DIM SHARED Inregs AS RegType, Outregs AS RegType„DIM SHARED Buttons(1 TO 9) AS COORD„COMMON SHARED BN, Flg, Bkgn, VW, CFlag, PI, x, y, btn„PI = 3.141593„  „  „SCREEN 12: CLS„WIDTH 80, 60„  „'Possible Palettes:„  „'PALETTE 0, (65536 * 47 + 256 * 47 + 47) ' Grey Background„PALETTE 0, (65536 * 45 + 256 * 45 + 63)  ' Baby Pink Background„'PALETTE 0, (65536 * 57 + 256 * 57 + 57)  ' White Background„'PALETTE 0, (65536 * 50 + 256 * 47 + 0)   ' Cyan Background„  „'Help Button Hide/Display default„  „HideHelp = 0: CFlag = 1„  „'Circle Button for Help - 0 is 'Display (don't hide)„  „IF HideHelp = 0 THEN„ CALL CircleBtn„END IF„  „'Syntax: MakeButton(Title, XLocation(LOCATE), Text Color, Highlight Color)„  „'NOTE: Flg=1 is button is "out"; Flg=0 is button is "in"„  „BN = 2: Flg = 1: CALL MakeButton("File", 8, 8, 1)„  „' NOTE: Bkgn MUST be LESS than 8 (Bkgn values must be 0-7)„'       Other combinations may or may not work.  Test values before„'       using them.  GPRINT uses a BIOS video write to put text on screen.„  „'Syntax: VScreen(x1, y1, x2, y2, Bkgn)„  „CALL VScreen(0, 30, 639, 479, 7)„VW = 1: CALL gprint("Hello", 45, 23, 6)  'VW is view window is "on" for GPRINT„  „startmouse„showmouse„  „'Start Input„  „Inloop:„  „Mouse„IF btn = 2 THEN GOTO Done„  „'Check Mouse Coordinates„  „'Help Button„  „IF x < 21 AND y < 21 THEN„ x1 = 314: y1 = 153: x2 = 554: y2 = 394: Klr = 3„ ga = 4 + INT(((x2 - x1 + 1) * (1) + 7) / 8) * 4 * ((y2 - y1) + 1)„ DIM OvScn(1 TO ga) AS INTEGER„ GET (x1, y1)-(x2, y2), OvScn„ CFlag = 0„ CALL CircleBtn„ CALL OvrWin(x1, y1, x2, y2, Klr)„ CALL gprint("This is the Help Screen.", 42, 23, 2)„ CALL gprint("Click Mouse to Continue.", 42, 25, 13)„„ Mouse„ hidemouse„ PUT (x1, y1), OvScn, PSET„ ERASE OvScn„ showmouse„ CFlag = 1„ CALL CircleBtn„END IF„  „' File Menu Activated.„  „IF x >= 51 AND y >= 2 AND x <= 90 AND y <= 18 THEN„ Flg = 0„ ButtonDraw„  „ x1 = 32: y1 = 34: x2 = 115: y2 = 146: Klr = 3„ ga = 4 + INT(((x2 - x1 + 1) * (1) + 7) / 8) * 4 * ((y2 - y1) + 1)„ DIM OvScn(1 TO ga) AS INTEGER„ GET (x1, y1)-(x2, y2), OvScn„ VW = 1: OFlg = 1„ CALL Overlay(x1, y1, x2, y2, Klr, OFlg)„ CALL gprint("New", 5, 2, 13)„ CALL gprint("Open", 5, 4, 13)„ CALL gprint("Save", 5, 6, 13)„ CALL gprint("Save As..", 5, 8, 13)„ CALL gprint("Print", 5, 10, 13)„ CALL gprint("Exit", 5, 12, 13)„  „ Mouse„  „ 'Exit Option„  „ mx1 = 35: my1 = 123: mx2 = 112: my2 = 138: mKlr = 3: mOFlg = 0„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„  hidemouse„ CALL Overlay(mx1, my1, mx2, my2, mKlr, mOFlg)„  CALL gprint("Exit", 5, 12, 1)„  showmouse„  Mouse2„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„  END„ ELSE„ GOTO DDN„ END IF„ END IF„  „ 'Print Option„  „ 'The mx values are 16 less that that of the Exit option„ '(8 pixels/row so since they are every other row, 8 * 2 = 16)„  „ mx1 = 35: my1 = 107: mx2 = 112: my2 = 122: mKlr = 3: mOFlg = 0„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„  hidemouse„ CALL Overlay(mx1, my1, mx2, my2, mKlr, mOFlg)„  „  'Note here we change gprint to reflect the Print option and its„  'y coordinate location.„  „  CALL gprint("Print", 5, 10, 1)„  showmouse„  Mouse2„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„  „  'Action for Print Option goes here.„  „ ELSE„ GOTO DDN„ END IF„ END IF„DDN:„  hidemouse„  PUT (x1, y1), OvScn, PSET„  showmouse„  ERASE OvScn„  „  Flg = 1„  ButtonDraw„  „END IF„  „GOTO Inloop„  „Done:„  „'Pause Display and Wait for Keypress„'Pause$ = INPUT$(1)„  „hidemouse„„SUB ButtonDraw„hidemouse„yb = Buttons(BN).bx2 - Buttons(BN).bx1„IF Flg = 1 THEN k1 = 15: k2 = 8 ELSE k1 = 8: k2 = 15„DRAW "C" + STR$(k1) + "BM" + STR$(Buttons(BN).bx1) + ",18U15R" + STR$(yb)„DRAW "C" + STR$(k2) + "BM" + STR$(Buttons(BN).bx1) + ",18R" + STR$(yb) + "U15"„showmouse„END SUB„„SUB CircleBtn„  „hidemouse„ LINE (9, 0)-(11, 11), 0, BF„ CIRCLE (10, 11), 10, 8„ PAINT (10, 11), 12, 8„ IF CFlag = 1 THEN c1 = 15: c2 = 8 ELSE c1 = 8: c2 = 15„ CIRCLE (10, 11), 9, c1, 1, INT(PI + 1)„ CIRCLE (10, 11), 9, c2, INT(PI + 1), .5„  „ VW = 0: CALL gprint("?", 1, 2, 3)  'Note: VW is view window ON/OFF; 0=OFF„  „ 'NOTE: above colors for GPRINT: 2 is Yellow, 3 is White„ '      for last number: GPRINT($, x, y, color)„  „showmouse„END SUB„„SUB getmousecord (btn%, M3%, M4%)„Inregs.ax% = 3„CALL INTERRUPT(&H33, Inregs, Outregs)„M3% = Outregs.cx%„M4% = Outregs.dx%„btn% = Outregs.bx%„END SUB„„SUB gprint (S$, x, y, Klr)„IF VW = 1 THEN y = y + 5„  „IF Klr < 10 THEN„ Klr = Klr + 8„ B = (Bkgn XOR Klr) - 8„ELSE„ B = Bkgn XOR Klr„END IF„  „IF B < 10 THEN B$ = "&HF" + HEX$(B) ELSE B$ = "&HF" + HEX$(B)„Inregs.bx% = VAL(B$)„Inregs.cx% = 1„AH$ = "9"„  „FOR count = 1 TO LEN(S$)„ A$ = MID$(S$, count, 1)„ AL$ = HEX$(ASC(A$))„ Inregs.ax% = VAL("&H" + AH$ + AL$)„ LOCATE y, x + count„ CALL INTERRUPT(&H10, Inregs, Outregs)„NEXT count„  „END SUB„„SUB hidemouse„Inregs.ax% = 2„CALL INTERRUPT(&H33, Inregs, Outregs)„END SUB„„SUB MakeButton (P$, XL, KKr, KKh)„  „'Highlight First Character„  „PH$ = LEFT$(P$, 1): PR$ = RIGHT$(P$, LEN(P$) - 1)„COLOR KKh: LOCATE 2, XL: PRINT PH$;„COLOR KKr: PRINT PR$„  „Buttons(BN).bx1 = (XL - 1) * 8 - 4„Buttons(BN).bx2 = Buttons(BN).bx1 + (LEN(P$) * 8) + 6„  „LINE (Buttons(BN).bx1 - 1, 2)-(Buttons(BN).bx2 + 1, 19), 8, B„  „CALL ButtonDraw„  „END SUB„„SUB Mouse„  „DO„ getmousecord btn, x, y„ LOCATE 59, 5„ PRINT x, y, btn;„  „LOOP WHILE btn = 0„  „END SUB„„SUB Mouse2„DO„ getmousecord btn, x, y„ LOCATE 59, 5„ PRINT x, y, btn;„  „LOOP WHILE btn <> 0„DO„ getmousecord btn, x, y„ LOCATE 59, 5„ PRINT x, y, btn;„ „„LOOP WHILE btn = 0„  „END SUB„„SUB Overlay (x1, y1, x2, y2, Klr, OFlg)„ IF OFlg = 1 THEN c1 = 15: c2 = 8 ELSE c1 = 8: c2 = 15„ hidemouse„ LINE (x1, y1)-(x2, y2), 8, B„ PAINT (x1 + 1, y1 + 1), Klr, 8„ DRAW "c" + STR$(c1) + "bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "U" + STR$(y2 - y1 - 2) + "R" + STR$(x2 - x1 - 2)„ DRAW "c" + STR$(c2) + "bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "R" + STR$(x2 - x1 - 2) + "U" + STR$(y2 - y1 - 2)„ showmouse„END SUB„„SUB OvrWin (x1, y1, x2, y2, Klr)„  „A = x1 + 1: B = y2 - 1: C = y2 - y1 - 2„E = x1 + 9: F = y2 - 9: G = y2 - y1 - 18„  „LINE (x1, y1)-(x2, y2), 8, B„PAINT (x1 + 10, y1 + 10), Klr, 8„  „LINE (x1 + 8, y1 + 9)-(x2 - 8, y2 - 8), 8, B„PAINT (x1 + 10, y1 + 10), Klr, 8„  „DRAW "C15BM" + STR$(A) + "," + STR$(B) + "U" + STR$(C) + "R" + STR$(C)„DRAW "C8BM" + STR$(A) + "," + STR$(B) + "R" + STR$(C - 1) + "U" + STR$(C - 1)„DRAW "C8BM" + STR$(E) + "," + STR$(F) + "U" + STR$(G) + "R" + STR$(G)„DRAW "C15BM" + STR$(E) + "," + STR$(F - 1) + "R" + STR$(G - 1) + "U" + STR$(G - 1)„  „END SUB„„SUB showmouse„Inregs.ax% = 1„CALL INTERRUPT(&H33, Inregs, Outregs)„END SUB„„SUB startmouse„Inregs.ax% = 0„CALL INTERRUPT(&H33, Inregs, Outregs)„MouseInitialize% = Outregs.ax%„END SUB„„SUB VScreen (x1, y1, x2, y2, Bkgn)„LINE (x1, y1)-(x2, y2), 8, B„PAINT (x1 + 1, y1 + 1), Bkgn, 8„DRAW "c8bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "u" + STR$(y2 - y1) + "r" + STR$(x2 - x1)„DRAW "c15bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "r" + STR$(x2 - x1 - 2) + "u" + STR$(y2 - y1)„END SUB„„Steven L. Oliveras             PLANET ORBITAL                 Software Vault CD              01/92 (00:00)          QB, QBasic, PDS        107  7008     ORBIT.BAS   '>>> Page 1 of ORBIT.ZIP begins here. TYPE:BINAA TLEN:4896„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"ORBIT.ZIP",4^6:Z&=4896:?STRING$(50,177);„U"%up()%9%%%I-%fO/:D5]8JQ2)%%%u1%%%1%%%%uq%fstw%gySgIfxt&:r>\[a95„U"T)_NoL;'4,$v7/vX/Ay*=hAEypqsgCB_j4m-mTpDsUAsNPj0VG7%uB[5ZWLjZfH„U";\]5n)3e_W_UF^Ml0b%[lR+odG1:.s9,U,MV&55]rQlOjXNFHmw0lrg8^HaVZ%k„U"bCq)cl%$R28^Hbl:^-kC4beK06Ol#Cd=KtHYfefg'G46=^h6#c%1#6xLmn\mHP&„U"RYF3+HDT$3jnK%p\dwXq+\ZHD4s&-'Kzp33X9VWMiHIk3VP6/yXJ9cHkGl>q'7s„U"i9N40+TatVMmTM4H5'8CV(+wn8Nm_,V8cX6T/<,/t)e4,80,&+,5GH]#YC[cA&6„U"N])G%lndwFa6KfbmV1,xh_juld+4MF)Zmqb2#r-i>U^NjWp1NzYwf^v)]IvvdW%„U"9d9IHZ%A6LhxI4\btYOnA+6m&XoOP)yr1==2C7#ho3jfCGIRM<S-L4-;.04Lw>b„U"w_yOJ*<<m^m.=z3f'geNeAs7RgHqW;s&iRm3,l]PzJEeZ+bPix<lR%'?fgnRQ*T„U"Is$29(<L4UlnUbx]\E*[LKy360aHGuNw]f%kbEq7J%Gt3J&/qH[3L1jEO;0J&)I„U"I,M,f^(Wy0hl=J2oFHklroC<\_,cj'[iUmfOI3#5LPUZ.0Jm9uMbair&sCYOt#2„U"4Tn%v;L&,)6-e&pgt/?g0-jg1-;/X4v9AU]/6Bj7sL.]hAD.KPuXDy\HaD<bkb-„U"*lSHXt3*</Aav<nZXkYYwErP3jyW&B]&M:C0_]yZ6Zpc,\gy.9V,U6EnjpzF+BC„U"t\eU\%2n-x.PsCfTs.EZ=fgS\UD;E26Otm,06<C9t?#U_5j&3ja6'Zd^/ICJ_/5„U"bVxbo4JY=?G70Zv[J/ibRr4f>VGsA?jtQ%Dj.dckniCN(6AmJLm7meNq7jpVp^#„U"MS%=kub3f?.;-\(E?kS^^93Z?,n'0g)=1S1L0QHEmeOoFJ=0KV<,8-m52hFCR,$„U".;OAE]leG[_?-Wha3qE5Rm,IHsbd#m2h&FC,$DFd)EqEx=+YV9/jJ;v/oA8iVvN„U"JMF5:dYjMhhhs=rB'q<79p+#,0o$AkA*&&SgJ\DASZxakZ[:Ln\Lrsg:<=dgI7B„U"QpUtfL/.#&PeeQ,0E/27WRK5x(+8hQV42=vecuT8&9AI_5)(5d90$qrqWXyKDeg„U"YE9fFvD\8$.<3u;Eq6jAuqhrNZRU/r'JGbe>J#UDk&A41c(3_am_<I)J05s;\WE„U"t,X4wE/wWcIek\J,jarV6ePN#Ps*RR\>#Yu#\1nnYIJK/?ChQ:aPxZ,=+r[oh0,„U"xAYHx_vl?E93hW>mG<V[0z)8/A?R]I.Tf,%j?\_tCGi(9zAdSZ$/Y\1#6Xgot-o„U"E#4BB1nj-GN*zcY=dbfFX%G$4LW/;<pg>z66Slsra%#*4tmTl8bjqZ8Qt-?#'2s„U"ea.AS;4]O=??RPr:Z5^J8oPquWh<9G/9VXHq-;c2qE0n*5Ngh8'r2Pb/-+9QaIX„U"0zEPHti(V-l8D'^#b?#Z3_4AsZU#]xO]T'*'Mkch=XBl#)Mw?mT8u%p()9%%%%-„U"4%9AIm?CS6(F^2%%%Jo%%%.%%%%uqf%sYSidfy\U^naJ2m2)I6$EC&&'s-)mn?]„U"xBS3O3NhB^YuoCzSd;Y$:&X)rtnOcknNQxdnwHn8dLRqz.zJHzuBcn$doMXz[zk„U"8;$vq^%8CSzWfziqr\4N0zJVk#'UbV-4ezkJp#Xk0(zrUj4$\a\Z3pOBoLVM*CL„U"V>9V0B9pBOWm28G4Th\0xXqpAMQXoMk>^3c;KAl49qy=xO'f3^r*okVrro>FW$/„U"tMHSawCr:Jgtm9bK8RcM]$]KKTewIpyb>/jx:fEG0/xLTXiK\ZSv3c0OJdIaYsM„U"_58rG:ox^dk7QHn/uF<Qgp*2OS%r-]Kt3;Nguh?W8LdM_V9gg$6pKX;RlrN8Du0„U"_qZWmXIoL$maUKLGmrV3xONn<J.UOK**j)et_3I-YO(8]iTAdKA8u6M-O4tZ<ho„U"t<ACf%DJp=XnvuMQ&rTH5XeH(w)hkm$O-FD*Xk7fF?7>-0)+pfwOjMNO$)Fdl3x„U"Pa(v).etb[Wbs&1mITyf%+ZsUr_8\(XYeSK=[ldOmP=0T^L6ucm801fZnm?KTga„U"t29F4CTY1T9Ed*LLrcf$h*XA^/8I3vt4k?Vk5j6G+uU1ccMH7Or1DG9AV<j8?d'„U")DXo8Sm_.M:w4cKFaDR,9m[MY\Dx8nYr$nRNtptu%/H<Z=rVMyO=#w0I/:I>NC]„U"kEP3R$4(leB^6eA0lm3$+TbB+;UPAb%5f2q)3abfmmObpZD*tMBb(=4l[B&FA4S„U"wWR$2*:3GDarwTHQ&Hm0I;_=I6_qZM2iucX[?aQ,iK[^Box?n-^IMT$&nmo;6&e„U",Dpxv&$PWX4LkyXedor\3:wJ7i3Tsikh,7jMBM=12C3d?RtToPR$-6t?J$u8KoO„U"YkH&uHn[pB4+b%-9Ax'hhAB8z'*N+c#h_nf.M,,VgDi7f4FTq).-X%y7<a>tjRx„U"p?ViV#DoRtUPe$\5Q+8qN=avUK=wXERpRL$TqQJ.:x8;ZGvOQ9\zuH$T&paJ&wW„U"R:tI)T>#KkZy[qpZepa[>L8)O.z;wYMU%R:cAM4FgEH]+HfOB2u9WT$T]rUE]*C„U"H^BHumg6bM$lD1*d;5/XR,G>O0R$g\>wh7+=$&5]sXo85Ch)hkg^oCSsZ+flO:]„U"+q-g*X)F'rX+>MYBpRf&X'vXl]7[lQ[FlQ?:4uoMl:pQj0?N^v=0pu)SH<SD2.N„U"o*Ve2UWXX-K7OXvW-(6:-(&MduaMGXJMt\Bok1,cG9>RvxDC,Cgy[c([auneE$v„U"?IK28gX.&adkVF[7aAK6M0'%;Do5viIH#w6syc5CNk6281k1o3:wiB=HE&fiol=„U"E*:exlOl_3oj_u*oE&$f?.X1D4\9&V<xOl$+7R44VAO^juKax7N7$ae7,myKE9q„U"Mr&PhK7LJWMFqyNKAH7)7Hw[UDr3MXHC_9lT_+qfg4TO%<Or_^,1Bee%dxt#Q\i„U"4N6uUxYjgv=5v<E)_p\v1f<RH]2Qw0oO8'8LF&.q4i;Beo7b5sJV9hCS8z1f,jF„U"m$M(WdNr:rTw_NJJfxAjg:EaC?3C]G0$(rRHFGK<]EvmDA\'F]wv4LoblVh)me(„U"XpD^tP4kx8KKL2+O%*5DGl*xxk1fPmWVhPv;i9QBPUV07BbW/qK-;Czm*b.oe?*„U"OK>)#Ra19)*>fPv)Dkhtt-M-B=N>>D2b7ZrV9]K[8vL>t<iLXL78G.9]h$cuKvL„U"02>y^qxOfoVclwY5lwu<,QTlGA?edpNtX^IQ)1uUKDoQR1m0K;W4a]1HqUnElK>„U"e7B.F;1KBA[*LvY(*BhczJi&8eg48i#H]E9l?UJe-,6;M5O#.R$u9v<a(')7<Z=„U"O%<KQ?.;e\ZQJ+8-JkF.MJ9^m;8/e-:+x$LX(>fNel'MMs#%:q\A5)CN97'PV>U„U")C#FoDf$c)Ai^N\pOhW)sJ&)^l')T*evY/vbw6nL#ctrLrFV%)OC+1Lcaa,qkub„U"nCe4DDc.W)BQ38$NknfK9W8T7]WeoP3w?#(kSrFri\[u_<^:,go&Vw<KHM#'eRD„U"T40#e;;G*Y4(+CZKD_Sd#fk*c#TDU4F.tw-L-rl4tXEV0m?cZbJm[1(6IG-969N„U"r,4;zobJ>PoAgy\d;8zIhXTd6f?neMwMtlfEh-9FARv+cEt-0l3fV4rSel3?=5r„U"3xq)*T_tiRHw4?D+n5I?J4Fkgo3DEWWZ:)9CfBlN/FXQogW5Aej_ctdg*K(bI,k„U"k%Dq'n46R+27<(IUl8&2+)1Q_&+;^S/ZOfj;kc/3UkyDq$Q46gQ+aF(;3KTKDr5„U"o*gVr<]6kq<hDrC-4f6x&cc0FY/0Fg=LB9>/tbp<eBaxpBgqSgdo+57(Z7qx3EH„U"G2EMhdrB.3TD#C7lRLvYD&l+rpt-&,?n=?9S'1Gpr86_ruERUYFR5grKi>r:Yt6„U"Nu$ZIMfSXuo<Bkbx(p9-X.)5V.cD4R]KOYS2*/Q_W<m[&(F6,Hc]':UxagbmB>K„U"H-Ap7t2mi:dnt#zQp+SeJ'ue$e(G01u*N.2aZ><]zIFf2gFQ=9lBuQB9-p/$sTk„U"1_diJOS_ipP=Kk#Jtk,dI?)&90Av,XEAT_NIPv#F./yuN.frD2M#y:Ei2UUKG44„U"QZj>d*3QaVw83K?z='Zg?>SfjM4NJE(+S-1,pCW8E'\k,eT/CIkQ0gkRg4'H1s+„U"AcK2M.:9_>.U:,IR.Q:NcI#p?VW;ONGs-tEZHFohrCEo>cG\/l&xM1VvCw&uU(Q„U"Xi-4Ur<MHLRV,5d.bttVX2Dz8VaXtr0tC0GCkNIILYGLuqls.=b3S-]D?Mx8Ybj„U"vP>Z(N%+T7MHjpYrmJSMx58W6x68J9bJfP5hm)2.shiN/dF8pCbfhV,iX4)juY<„U"0t5&%Fgt59>hiMr<tt-c+P&dpZdd[7%dmZ:9stcc]DB+R9hwLyGutQF(U4dt&tN„U"y=p$1c1R7[_SJ\l02U:Ttd)]#yxM0;s?38p2O1zu0o^xwU7XlP*nDiuWD48g_?/„U"VeWv)w4OxO\ZipKj7S'2Y)uW2Db,8D#,Y\3rw8?)u=/:K[t9hrCC(K>]?45Ks59„U"hNC3&(MEd8&MhEd8M&hEdD8&fZo4jGrI(zu=X/N)zs14C)8z14/0S(S;7erLUnt„U"Ofg_8Ft4tJSVLoWFeg_0F44YJQVjuV6RVtjV6rYHsgkmX\TNFgbxB.C3<$G>dxB„U"pB^KhHW&3EVzRUHLptxxQ%ODz,DEJuJECIEcCGP&Q&E3SlfJt-j:ppfGe27wrTH„U"VG$dECt-HIq2RZr<33$Tl<ESRVV&CPv4rf*2LYfKWc]8>.T]ppZb<(hr/]T*A/p„U"0g+l$/]4Eu4V#^KG]yxhe]+E'ev_?*kF[5J129iJUN3Se4caK;$ht,RNBfbu\tK„U"63=0hwIOJm/8U:c?2d?6VfNJMZ*G1MZZ/ZG1^orL_h[xu[<CALalm&KBdB*p41m„U"puvjCpqW1##nO_t#Ipp0r\]9w'T*4qbI]PBp8HML9hC3Fj:*_xXfC51h/i7bZnt„U"qDX$23-$io=/Tm?Pxbj^f3N3Wf:ZjMID<LsE8\-*oP3tFg&&w3N&WD*gRrCG=:/„U"_BZ/_FtuZ'LGh^C]pirrb-h^iY8b'*ggZoZ3=,Y:A[<1%'8bV)K<s,]Cr)a5D;g„U"7N3(I>_N^Y5dZ+:zVm\ti:vlmu\bgW073%AMY*PBO%QT]w3/ZaJI:sm8'TN9#Jr„U"dZP*6Olol+TOtA\Vg<,pd)w*P#d8JNgr9[C>b%aTGMeuoegSvA\r^T_-$1,XwIk„U"Mi3uL1vlJ1p2A4Q>c9ID<F.DoJuhnKXu213bCT:-8p3pr#Sh(vhAY:EZjHMeu3N„U"kU^GXM_Nr-iINVjp$/Kt9xUxkW6/vWfv$k8sVx?K17LR3UO.)4Pp=#MU'yD<g^]„U"G:V_9rUISHr2^MCBC#V:pp2z+]HTY'ieSU3]^cIViUhNo,F]Ks-IJThC+f96o,%„U"(gG1DC_e&O1>c4psC=9\%A&3$nJv'bpcu))D_%5Bv1>',O&]'J]xc<?X;qkhd8i„U"/U.FIX0Hl8?\uWRLT/E)hH;Mr4/iK+x00pN9_u=OL+WRZ6^?;BxZ</^NRYrDC^y„U"W*0?wEZHq;4JJi]rr[jtOi??%#o)FBT83Ld3qe;,4Rzhe,4RXzI9]W/u)9Kwvhe„U"uB'kqD2&^E.:YV8g_&pKbsL7G8NM4oHaV^vYqmgkJZf8F=t44rSY]prHmV^6tse„U"gVZgWfx_<2L$u(#oDswoM<Ng-E-0Rxfbu.N:-=_A2$IZr*4o.S&ObtN__m=Em]q„U"cl0fZ5&f^Br3o*aVlITGMJl8W44gTZKOHk12Ds4k0'6TQ(vw8H+lwJ4U_lMff,h„U"(-Sope^oJx_?9/vSm5?SHsX(/fV&QM%^F&lb,g<ADK.yWCQ/v.b#MB/hY>UoN(L„U"P5jXu<-s:h1g86SS(VA6orbs1kxr%Tup&%'9%9%%%%-L%fO:CD5]J+Q2)%%%u1%„U"%%1%%%%%%%%%&%E%%%%%%%%%u%qfst%wgyS%gfxu%p&'9%%9%%[%-%9&AI?CHS6„U"F^%2%%J%o%%.%%%%%%%%%&%%E%%+%\)%%%uqf%sYSi%fyup%*+%%%%%'%.'%#%.„U"%%h7%%%%%„END SUB„CLOSE:IF S=199AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„'>>> Page 1 of ORBIT.ZIP ends here. Last page. TCHK:199„Rich Geldreich                 WIREFRAME-3D                   FidoNet QUIK_BAS Echo          04-28-93 (00:00)       PDS, VBDOS             790  24707    WIREF.BAS   'WIREF4.BAS By Rich Geldreich„'Last modified April 28, 1993.„'For PDS/VB-DOS only. This program isn't totally completed, and„'doesn't have much documentation, yet. I'd appreciate your„'feedback!„'„DEFINT A-Z„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„CONST True = -1, False = 0„CONST MaxObject = 9„CONST MaxPlane = 99„CONST MaxPoint = (MaxPlane + 1) * 3 - 1„CONST MaxLine = (MaxPlane + 1) * 3 - 1„CONST PerspectiveScaler& = 768„CONST RotateScaler = 2048„CONST UserPlane = 75„'Constants for SCREEN 9, the EGA's 640x350x16 two page mode.„CONST XScreenRatio = 5, YScreenRatio = 4„CONST MinX = 0, MinY = 0„CONST MaxX = 639, MaxY = 349„CONST MidX = 320, MidY = 175„CONST LineColor = 15„CONST ViewDistance& = 7000& * 7000„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„DEF FNV (A) = ((A MOD 360) + 360) MOD 360„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„TYPE VectType„    A1              AS INTEGER„    A2              AS INTEGER„    A3              AS INTEGER„END TYPE„ „TYPE OrgType„    Ox              AS INTEGER„    Oy              AS INTEGER„    Oz              AS INTEGER„END TYPE„ „TYPE SineCosType„    S1              AS LONG„    C1              AS LONG„    S2              AS LONG„    C2              AS LONG„    S3              AS LONG„    C3              AS LONG„END TYPE„ „TYPE PointType„    x               AS INTEGER„    y               AS INTEGER„    z               AS INTEGER„    Rx              AS INTEGER„    Ry              AS INTEGER„    Rz              AS INTEGER„END TYPE„ „TYPE ObjectType„    Org             AS OrgType„    Direction       AS VectType„    PlaneIndice     AS INTEGER„    PointIndice     AS INTEGER„    MaxPlane        AS INTEGER„    MaxPoint        AS INTEGER„    MaxCord         AS INTEGER„    CullFlag        AS INTEGER„END TYPE„ „TYPE PlaneType„    Points(0 TO 3)  AS INTEGER„    MaxPoint        AS INTEGER„END TYPE„ „TYPE LineType„    sx              AS INTEGER„    sy              AS INTEGER„    ex              AS INTEGER„    ey              AS INTEGER„END TYPE„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'Number of objects to read.„DATA 8„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'--Objects Follow--„ „'    To  speed  things  up  I  recommend that very large, complicated„'objects be split up  into  numerous  smaller objects because objects„'which are totally behind the viewer are ignored.  If most of a gaint„'object is visible, then the entire object must be processed.  If the„'object is built of smaller objects then less of it will be processed„'when part of it is behind the user.„ „'--Object 0, box.„'Object's starting XYZ coordinates.„DATA -60,0,-200„'Object's starting rotatation angles.„DATA 0,0,0„ „'    If this value not zero, then the object can be culled.  (Culling„'removes hidden polygons from the object to  speed  up  plotting  and„'improve  clarity.)  For  culling  to work properly all planes in the„'object must be specified  in  counter-clockwise  order as if you are„'looking directly at it!„DATA -1„ „'Planes„'    The first number specifies  the  number  of points in the plane.„'If the plane contains 4 points, then a 3 would appear as  the  first„'number  on  the  DATA statement(0-3=4 points).  Planes with 3 points„'would be proceeded with a  2.  The  remaining numbers point into the„'point list.  A plane may have 2,3,  or  4  points.   Planes  with  2„'points cannot be culled and are treated as single lines.„ „DATA 3,0,1,2,3„DATA 3,1,5,6,2„DATA 3,5,4,7,6„DATA 3,4,0,3,7„DATA 3,4,5,1,0„DATA 3,3,2,6,7„'End the plane list with -32768.„DATA -32768„ „'Points„'       Each  XYZ  point in the object follows.  The plane list above„'refers to this list.  A point  may  be shared by more than one plane„'in its object, but points cannot be shared between objects.„DATA -100,-100,100„DATA 100,-100,100„DATA 100,100,100„DATA -100,100,100„DATA -100,-100,-100„DATA 100,-100,-100„DATA 100,100,-100„DATA -100,100,-100„'End the point list with -32768,0,0.„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'--Object 1, box.„DATA 0,0,300, 0,0,0, -1„DATA 3,0,1,2,3, 3,1,5,6,2, 3,5,4,7,6, 3,4,0,3,7, 3,4,5,1,0,3,3,2,6,7„DATA -32768„DATA -100,-100,100, 100,-100,100, 100,100,100, -100,100,100„DATA -100,-100,-100, 100,-100,-100, 100,100,-100, -100,100,-100„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'--Object 2, house.„DATA 0,0,0, 0,0,0, 0„DATA 3,0,1,2,3, 3,4,5,6,7, 1,1,5, 1,0,4, 1,3,7, 1,2,6„DATA -32768„DATA -1000,-400,1000, 1000,-400,1000, 1000,100,1000,-1000,100,1000„DATA -1000,-400,-1000, 1000,-400,-1000, 1000,100,-1000,-1000,100,-1000„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'--Object 3, doorway and sidewalk.„ „DATA 0,0,0, 0,0,0, 0„DATA 1,0,1, 1,2,3, 1,4,5, 1,6,7, 1,8,9„DATA -32768„DATA 150,100,1000, 150,-250,1000, -150,100,1000, -150,-250,1000„DATA -150,-250,1000, 150,-250,1000, -150,100,1000, -150,100,2500„DATA 150,100,1000, 150,100,2500„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'--Object 4, first window.„DATA 0,0,0, 0,0,0, 0„DATA 3,0,1,2,3„DATA -32768„DATA -500,-100,1000, -300,-100,1000, -300,-250,1000,-500,-250,1000„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'--Object 5, second window.„DATA 0,0,0, 0,0,0, 0„DATA 3,0,1,2,3„DATA -32768„DATA 500,-100,1000, 300,-100,1000, 300,-250,1000, 500,-250,1000„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'--Object 6, pyramid.„DATA 0,100,3000, 0,0,0, -1„DATA 3,3,2,1,0, 2,4,2,3, 2,4,1,2, 2,4,0,1, 2,4,3,0„DATA -32768„DATA -300,0,-300, 300,0,-300, 300,0,300, -300,0,300, 0,-350,0„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„'Object 7, roof„DATA 0,0,0, 0,0,0, 0„DATA 1,0,4, 1,1,4, 1,2,4, 1,3,4„DATA -32768„DATA 1000,-400,-1000, -1000,-400,-1000„DATA -1000,-400,1000, 1000,-400,1000, 0,-800,0„DATA -32768,0,0„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„DIM SHARED SineTable(0 TO 359 + 90) AS LONG„DIM SHARED Objects(0 TO MaxObject) AS ObjectType„DIM SHARED Planes(0 TO MaxPlane) AS PlaneType„DIM SHARED Points(0 TO MaxPoint) AS PointType„DIM SHARED PlaneIndice, ObjectIndice, PointIndice„ „DIM SHARED WorldOrg AS OrgType„DIM SHARED WorldVect AS VectType„DIM SHARED WorldSineCos AS SineCosType„DIM SHARED WorldSpeed„ „DIM SHARED LinesToErase(0 TO 1, 0 TO MaxLine) AS LineType„DIM SHARED MaxLineToErase(0 TO 1)„ „DIM SHARED LowX, LowY, HighX, HighY„ „DIM SHARED VidPage„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-„PrintInstructions„InitializeTables„ReadObjects„InitializeWorld„ „LOCATE , 1„PRINT "Press any key!";„A$ = INPUT$(1)„DO„    A$ = INKEY$„    ProcessKey A$„    DoFrame„LOOP UNTIL A$ = CHR$(27)„END„ „'This function checks a plane to see if it can be  seen.   There  are„'faster  ways that don't involve all of this math, but this method is„'very elegant and easy to implement.„FUNCTION Check4Cull (BYVAL x0, BYVAL y0, BYVAL x1, BYVAL y1,BYVAL x2, BYVAL y2)„    Check4Cull = (CLNG(x1 - x0) * (y2 - y0) - CLNG(x2 - x0) *(y1 - y0)) >= 0„END FUNCTION„ „'This subroutine displays each object in the scene.„ „SUB DisplayObjects„    DIM ObjectVect AS VectType„    DIM ObjectSineCos AS SineCosType„    DIM ObjOrg AS PointType„ „    FOR A = 0 TO ObjectIndice„ „        ObjOrg.x = Objects(A).Org.Ox - WorldOrg.Ox„        ObjOrg.y = Objects(A).Org.Oy - WorldOrg.Oy„        ObjOrg.z = Objects(A).Org.Oz - WorldOrg.Oz„        RotateOrigPoint ObjOrg, WorldSineCos„ „        IF ObjOrg.Rz >= Objects(A).MaxCord THEN„ „            IF (CLNG(ObjOrg.x) * ObjOrg.x) + (CLNG(ObjOrg.y) *ObjOrg.y) + (CLNG(ObjOrg.z) * ObjOrg.z) < ViewDistance& THEN„ „            ObjectVect = Objects(A).Direction„            IF ObjectVect.A1 = 0 AND ObjectVect.A2 = 0 AND ObjectVect.A3 = 0 THEN„                FOR B = Objects(A).PointIndice TO Objects(A).PointIndice + Objects(A).MaxPoint„                    RotateOrigPoint Points(B), WorldSineCos„                    Points(B).Rx = Points(B).Rx + ObjOrg.Rx„                    Points(B).Ry = Points(B).Ry + ObjOrg.Ry„                    Points(B).Rz = Points(B).Rz + ObjOrg.Rz„                NEXT„            ELSE„                LookUpSineCos ObjectVect, ObjectSineCos„                FOR B = Objects(A).PointIndice TO Objects(A).PointIndice + Objects(A).MaxPoint„                    RotateOrigPoint Points(B), ObjectSineCos„                    Points(B).Rx = Points(B).Rx + ObjOrg.x„                    Points(B).Ry = Points(B).Ry + ObjOrg.y„                    Points(B).Rz = Points(B).Rz + ObjOrg.z„                    RotateNewPoint Points(B), WorldSineCos„                NEXT„            END IF„ „            I = MaxLineToErase(VidPage)„            LowX = 32767: LowY = 32767„            HighX = -32768: HighY = -32768„ „            IF Objects(A).CullFlag = True THEN„                FOR B = Objects(A).PlaneIndice TO Objects(A).PlaneIndice + Objects(A).MaxPlane„                    ProjectPlane Planes(B)„                NEXT„            ELSE„                FOR B = Objects(A).PlaneIndice TO Objects(A).PlaneIndice + Objects(A).MaxPlane„                    SELECT CASE Planes(B).MaxPoint„                    CASE 1„                        ProjectLine Points(Planes(B).Points(0)), Points(Planes(B).Points(1))„                    CASE 2„                        ProjectLine Points(Planes(B).Points(0)),Points(Planes(B).Points(1))„                        ProjectLine Points(Planes(B).Points(1)),Points(Planes(B).Points(2))„                        ProjectLine Points(Planes(B).Points(2)),Points(Planes(B).Points(0))„                    CASE ELSE„                        ProjectLine Points(Planes(B).Points(0)),Points(Planes(B).Points(1))„                        ProjectLine Points(Planes(B).Points(1)),Points(Planes(B).Points(2))„                        ProjectLine Points(Planes(B).Points(2)),Points(Planes(B).Points(3))„                        ProjectLine Points(Planes(B).Points(3)),Points(Planes(B).Points(0))„                    END SELECT„                NEXT„            END IF„ „            IF (LowX <= MaxX) AND (LowY <= MaxY) AND (HighX >=0) AND (HighY >= 0) THEN„                FOR B = I + 1 TO MaxLineToErase(VidPage)„                    LINE (LinesToErase(VidPage, B).sx,LinesToErase(VidPage, B).sy)-(LinesToErase(VidPage, B).ex,LinesToErase(VidPage, B).ey), LineColor„                NEXT„            ELSE„                MaxLineToErase(VidPage) = I„            END IF„ „            END IF„ „        END IF„ „    NEXT„ „END SUB„ „SUB DoFrame„ „    UpdateObjects„    SwitchScreen„    EraseScreen„    DisplayObjects„ „END SUB„ „'This subroutine plots one line to the screen and enters it into the„'current page's erase list.„SUB DrawLine (BYVAL x0, BYVAL y0, BYVAL x1, BYVAL y1)„    DIM LineToPlot AS LineType„ „    IF x0 < LowX THEN LowX = x0„    IF y0 < LowY THEN LowY = y0„    IF x1 < LowX THEN LowX = x1„    IF y1 < LowY THEN LowY = y1„ „    IF x0 > HighX THEN HighX = x0„    IF y0 > HighY THEN HighY = y0„    IF x1 > HighX THEN HighX = x1„    IF y1 > HighY THEN HighY = y1„ „    LineToPlot.sx = x0„    LineToPlot.sy = y0„    LineToPlot.ex = x1„    LineToPlot.ey = y1„ „    A = MaxLineToErase(VidPage) + 1„    LinesToErase(VidPage, A) = LineToPlot„    MaxLineToErase(VidPage) = A„ „END SUB„ „'This subroutine erases all lines previously drawn on the current„'video page.„SUB EraseScreen„ „    FOR A = 0 TO MaxLineToErase(VidPage)„        LINE (LinesToErase(VidPage, A).sx, LinesToErase(VidPage,A).sy)-(LinesToErase(VidPage, A).ex, LinesToErase(VidPage,A).ey), 0„    NEXT„ „    MaxLineToErase(VidPage) = -1„END SUB„ „'This subroutine initializes the  sine  &  cosine lookup table.  Each„'entry is scaled up by a constant to avoid  floating  point  math  at„'runtime(in  assembly  this would already be calculated and stored as„'data.)„SUB InitializeTables„    FOR A = 0 TO 359„        SineTable(A) = INT(SIN(A / 57.2957) * RotateScaler + .5)„    NEXT„    FOR A = 360 TO 360 + 90 - 1„        SineTable(A) = SineTable(A - 360)„    NEXT„END SUB„ „'This subroutine initializes the variables used to describe the user's„'location and viewing angle.„SUB InitializeWorld„ „    WorldOrg.Ox = 0„    WorldOrg.Oy = -230„    WorldOrg.Oz = -600„    WorldVect.A1 = 0„    WorldVect.A2 = 0„    WorldVect.A3 = 0„ „    MaxLineToErase(0) = -1„    MaxLineToErase(1) = -1„    VidPage = 1„ „END SUB„ „'This function limits an integer into an inclusive range.„FUNCTION Limit (BYVAL A, BYVAL l, BYVAL H)„    IF A < l THEN A = l„    IF A > H THEN A = H„    Limit = A„END FUNCTION„ „FUNCTION LongLimit (BYVAL A&)„ „    IF A& >= -32768 AND A& <= 32767 THEN„        LongLimit = A&„    ELSE„ „        IF A& < 0 THEN„            LongLimit = -1„        ELSE„            LongLimit = MaxX + 1„        END IF„ „    END IF„ „END FUNCTION„ „'This subroutine takes a vector (3 angles) and looks them up in the„'sine & cosine table.„SUB LookUpSineCos (V AS VectType, A AS SineCosType)„    A.S1 = SineTable(V.A1)„    A.C1 = SineTable(V.A1 + 90)„ „    A.S2 = SineTable(V.A2)„    A.C2 = SineTable(V.A2 + 90)„ „    A.S3 = SineTable(V.A3)„    A.C3 = SineTable(V.A3 + 90)„END SUB„ „'This subroutine prints the instructions to the screen. (duh <g>)„SUB PrintInstructions„    PRINT "Simple Object Based Wireframe 3-D"„    PRINT "By Rich Geldreich (Zeek of Renaissance) April, 1993"„    PRINT "Use these keys to control position: (Turn NUMLOCK on!)"„    PRINT "4.............Turn Head Left"„    PRINT "6.............Turn Head Right"„    PRINT "8.............Go Forward"„    PRINT "9.............Go Backward"„    PRINT "5.............Stop motion"„    PRINT "A.............Total Reset"„    PRINT "Up Arrow......Turn Head Upward"„    PRINT "Down Arrow....Turn Head Downward"„    PRINT "Left Arrow....Tilt Head"„    PRINT "Right Arrow...Tilt Head"„    PRINT "U.............Y Coordinate -"„    PRINT "D.............Y Coordinate +"„    PRINT "L.............X Coordinate -"„    PRINT "R.............X Coordinate +"„    PRINT "ESC...........Quits"„    PRINT„    PRINT "Wait a sec!";„END SUB„ „'This subroutine gets called after each frame. It processes any„'keystrokes from the user and updates the location & viewing„'parameters.„SUB ProcessKey (A$) STATIC„ „    IF A$ <> "" THEN„        A = (ASC(RIGHT$(UCASE$(A$), 1))) * ((LEN(A$) > 1) OR 1)„        SELECT CASE A„        CASE 85„            WorldOrg.Oy = WorldOrg.Oy - 30„        CASE 68„            WorldOrg.Oy = WorldOrg.Oy + 30„        CASE 76„            WorldOrg.Ox = WorldOrg.Ox - 30„        CASE 82„            WorldOrg.Ox = WorldOrg.Ox + 30„        CASE 65„            WorldSpeed = 0„            A1 = 0: A2 = 0: A3 = 0„            WorldVect.A1 = 0„            WorldVect.A2 = 0„            WorldVect.A3 = 0„            WorldOrg.Ox = 0„            WorldOrg.Oy = -130„            WorldOrg.Oz = 0„        CASE -72 'up„            A3 = A3 - 3„        CASE -80 'down„            A3 = A3 + 3„        CASE -75 'left„            A2 = A2 + 3„        CASE -77 'right„            A2 = A2 - 3„        CASE 56  '8„            WorldSpeed = WorldSpeed - 15„        CASE 50  '2„            WorldSpeed = WorldSpeed + 15„        CASE 53, 32„            WorldSpeed = 0„            A1 = 0: A2 = 0: A3 = 0„        CASE 48„            A1 = 0: A2 = 0: A3 = 0„        CASE 52„            A1 = A1 - 3„        CASE 54„            A1 = A1 + 3„        END SELECT„        A1 = Limit(A1, -30, 30)„        A2 = Limit(A2, -30, 30)„        A3 = Limit(A3, -30, 30)„        WorldSpeed = Limit(WorldSpeed, -160, 160)„    END IF„ „    WorldVect.A1 = FNV(WorldVect.A1 + A1)„    WorldVect.A2 = FNV(WorldVect.A2 + A2)„    WorldVect.A3 = FNV(WorldVect.A3 + A3)„ „END SUB„ „'This  subroutine  takes  a  line  in  3-D  space  and calculates the„'starting and ending points of  the  line  on the viewing screen.  If„'the line passes the viewing plane, it is cut so the entire  line  is„'visible before the perspective calculation is applied.„SUB ProjectLine (p1 AS PointType, p2 AS PointType)„ „    x1 = p1.Rx„    y1 = p1.Ry„    z1 = p1.Rz„ „    x2 = p2.Rx„    y2 = p2.Ry„    z2 = p2.Rz„ „    IF (z1 < UserPlane) OR (z2 < UserPlane) THEN„        IF (z1 < UserPlane) AND (z2 < UserPlane) THEN EXIT SUB„ „        IF z1 < UserPlane THEN„            SWAP x1, x2„            SWAP y1, y2„            SWAP z1, z2„        END IF„ „        Xd& = x2 - x1„        Yd& = y2 - y1„        Zd& = z2 - z1„ „        z2 = UserPlane„        x2 = x1 + (Xd& * (UserPlane - z1)) \ Zd&„        y2 = y1 + (Yd& * (UserPlane - z1)) \ Zd&„    END IF„    sx = LongLimit(MidX + XScreenRatio * ((x1 *PerspectiveScaler&) \ z1) \ 10)„    sy = LongLimit(MidY + YScreenRatio * ((y1 *PerspectiveScaler&) \ z1) \ 10)„    ex = LongLimit(MidX + XScreenRatio * ((x2 *PerspectiveScaler&) \ z2) \ 10)„    ey = LongLimit(MidY + YScreenRatio * ((y2 *PerspectiveScaler&) \ z2) \ 10)„ „    DrawLine sx, sy, ex, ey„ „END SUB„ „SUB ProjectPlane (Plane AS PlaneType)„    DIM PointCut(0 TO 3)„ „    MP = Plane.MaxPoint„ „    IF MP = 1 THEN„        ProjectLine Points(Plane.Points(0)),Points(Plane.Points(1))„        EXIT SUB„    END IF„ „    FOR A = 0 TO MP„        IF Points(Plane.Points(A)).Rz < UserPlane THEN„            PointCut(A) = True„            PointsCut = PointsCut + 1„        END IF„    NEXT„ „    IF PointsCut = 0 THEN„        p0 = Plane.Points(0): p1 = Plane.Points(1)„        p2 = Plane.Points(2): p3 = Plane.Points(3)„        SELECT CASE MP„        CASE 2„            ProjectPoint Points(p0), x0, y0„            ProjectPoint Points(p1), x1, y1„            ProjectPoint Points(p2), x2, y2„        CASE 3„            ProjectPoint Points(p0), x0, y0„            ProjectPoint Points(p1), x1, y1„            ProjectPoint Points(p2), x2, y2„            ProjectPoint Points(p3), x3, y3„        END SELECT„        IF Check4Cull(x0, y0, x1, y1, x2, y2) = False THEN„            SELECT CASE MP„            CASE 2„             DrawLine x0, y0, x1, y1„             DrawLine x1, y1, x2, y2„             DrawLine x2, y2, x0, y0„            CASE ELSE„             DrawLine x0, y0, x1, y1„             DrawLine x1, y1, x2, y2„             DrawLine x2, y2, x3, y3„             DrawLine x3, y3, x0, y0„            END SELECT„        END IF„    ELSEIF PointsCut - 1 = MP THEN„        EXIT SUB„    ELSE„ „        FOR A = 0 TO MP„            IF PointCut(A) = False THEN EXIT FOR„        NEXT„ „        LastP = (A - 1): IF LastP < 0 THEN LastP = MP„        NextP = (A + 1): IF NextP > MP THEN NextP = 0„ „        A = Plane.Points(A)„        LastP = Plane.Points(LastP)„        NextP = Plane.Points(NextP)„ „        SplitLine Points(A), Points(LastP), XL, YL„        SplitLine Points(A), Points(NextP), XN, YN„        ProjectPoint Points(A), XM, YM„ „        IF Check4Cull(XM, YM, XN, YN, XL, YL) = False THEN„            p0 = Plane.Points(0): p1 = Plane.Points(1)„            p2 = Plane.Points(2): p3 = Plane.Points(3)„            SELECT CASE MP„            CASE 2„                ProjectLine Points(p0), Points(p1)„                ProjectLine Points(p1), Points(p2)„                ProjectLine Points(p2), Points(p0)„            CASE ELSE„                ProjectLine Points(p0), Points(p1)„                ProjectLine Points(p1), Points(p2)„                ProjectLine Points(p2), Points(p3)„                ProjectLine Points(p3), Points(p0)„            END SELECT„        END IF„    END IF„END SUB„ „SUB ProjectPoint (P AS PointType, nx, ny)„ „    nx = LongLimit(MidX + XScreenRatio * ((P.Rx *PerspectiveScaler&) \ P.Rz) \ 10)„    ny = LongLimit(MidY + YScreenRatio * ((P.Ry *PerspectiveScaler&) \ P.Rz) \ 10)„ „END SUB„ „SUB ReadObjects„    RESTORE„    READ ObjectIndice„ „    PlaneIndice = 0„    PointIndice = 0„ „    FOR Object = 0 TO ObjectIndice - 1„        READ Objects(Object).Org.Ox„        READ Objects(Object).Org.Oy„        READ Objects(Object).Org.Oz„        READ Objects(Object).Direction.A1„        READ Objects(Object).Direction.A2„        READ Objects(Object).Direction.A3„        READ Objects(Object).CullFlag„ „        Objects(Object).PlaneIndice = PlaneIndice„        Objects(Object).PointIndice = PointIndice„ „        NumPlanes = 0„        DO„            READ A„            IF A <> -32768 THEN„                Planes(PlaneIndice).MaxPoint = A„                FOR B = 0 TO A„                    READ A„                    Planes(PlaneIndice).Points(B) = A +PointIndice„                NEXT„                PlaneIndice = PlaneIndice + 1„                NumPlanes = NumPlanes + 1„            ELSE„                EXIT DO„            END IF„        LOOP„        Objects(Object).MaxPlane = NumPlanes - 1„ „        NumPoints = 0„        Max = -32768„        DO„            READ A, B, C„            IF A <> -32768 THEN„                IF ABS(A) > Max THEN Max = ABS(A)„                IF ABS(B) > Max THEN Max = ABS(B)„                IF ABS(C) > Max THEN Max = ABS(C)„                Points(PointIndice).x = A„                Points(PointIndice).y = B„                Points(PointIndice).z = C„                PointIndice = PointIndice + 1„                NumPoints = NumPoints + 1„            ELSE„                EXIT DO„            END IF„        LOOP„        Objects(Object).MaxPoint = NumPoints - 1„        Objects(Object).MaxCord = -(Max + 200)„    NEXT„    ObjectIndice = ObjectIndice - 1„ „    PlaneIndice = PlaneIndice - 1„    PointIndice = PointIndice - 1„END SUB„ „SUB RotateNewPoint (P AS PointType, A AS SineCosType)„ „    x1 = (P.Rx * A.C1 - P.Rz * A.S1) \ RotateScaler„    z1 = (P.Rx * A.S1 + P.Rz * A.C1) \ RotateScaler„ „    P.Rz = (z1 * A.C3 - P.Ry * A.S3) \ RotateScaler„    y2 = (z1 * A.S3 + P.Ry * A.C3) \ RotateScaler„ „    P.Rx = (x1 * A.C2 + y2 * A.S2) \ RotateScaler„    P.Ry = (y2 * A.C2 - x1 * A.S2) \ RotateScaler„ „END SUB„ „SUB RotateOrigPoint (P AS PointType, A AS SineCosType)„ „    x1 = (P.x * A.C1 - P.z * A.S1) \ RotateScaler„    z1 = (P.x * A.S1 + P.z * A.C1) \ RotateScaler„ „    P.Rz = (z1 * A.C3 - P.y * A.S3) \ RotateScaler„    y2 = (z1 * A.S3 + P.y * A.C3) \ RotateScaler„ „    P.Rx = (x1 * A.C2 + y2 * A.S2) \ RotateScaler„    P.Ry = (y2 * A.C2 - x1 * A.S2) \ RotateScaler„ „END SUB„ „SUB SplitLine (p1 AS PointType, p2 AS PointType, x0, y0)„ „    x1 = p1.Rx„    y1 = p1.Ry„    z1 = p1.Rz„ „    x2 = p2.Rx„    y2 = p2.Ry„    z2 = p2.Rz„ „    IF (z2 < UserPlane) THEN„ „        Xd& = x2 - x1„        Yd& = y2 - y1„        Zd& = z2 - z1„ „        z2 = UserPlane„        x2 = x1 + (Xd& * (UserPlane - z1)) \ Zd&„        y2 = y1 + (Yd& * (UserPlane - z1)) \ Zd&„ „    END IF„ „    x0 = LongLimit(MidX + XScreenRatio * ((x2 *PerspectiveScaler&) \ z2) \ 10)„    y0 = LongLimit(MidY + YScreenRatio * ((y2 *PerspectiveScaler&) \ z2) \ 10)„ „END SUB„ „SUB SwitchScreen„    VidPage = 1 - VidPage„    SCREEN 9, , VidPage, 1 - VidPage„    WAIT &H3DA, 8, 8„    WAIT &H3DA, 8„END SUB„ „SUB UpdateObjects„    STATIC Init, XMove, ZMove„ „    IF Init = False THEN„        XMove = 6„        ZMove = -4„        Init = True„    END IF„ „    Objects(1).Direction.A3 = FNV(Objects(1).Direction.A3 + 4)„    Objects(6).Direction.A1 = FNV(Objects(6).Direction.A1 - 4)„ „    x = Objects(1).Org.Ox„    x = x + XMove„    IF x < -800 OR x > 800 THEN XMove = -XMove: x = x + XMove„ „    Objects(1).Org.Ox = x„    z = Objects(1).Org.Oz„    z = z + ZMove„    IF z < -800 OR z > 800 THEN ZMove = -ZMove: z = z + ZMove„    Objects(1).Org.Oz = z„ „    mx = (WorldSpeed * WorldSineCos.C3) \ RotateScaler„    my = (WorldSpeed * WorldSineCos.S3) \ RotateScaler„    Mz = (mx * WorldSineCos.C1) \ RotateScaler„    mx = (mx * WorldSineCos.S1) \ RotateScaler„    WorldOrg.Ox = Limit(WorldOrg.Ox - mx, -16000, 16000)„    WorldOrg.Oy = Limit(WorldOrg.Oy + my, -16000, 16000)„    WorldOrg.Oz = Limit(WorldOrg.Oz - Mz, -16000, 16000)„    LookUpSineCos WorldVect, WorldSineCos„ „END SUB„ „'    That's all! Sorry that it only works under PDS or VB/DOS, but I love„'using BYVAL and having arrays in TYPE structures.„Eliram Haklay                  FLYING STARS                   comp.lang.basic.misc           11-21-95 (00:35)       QB, QBasic, PDS        82   2710     FLYSTAR.BAS 'Here's A program I wrote.„'It's pretty simple, you can get nice effects if you use the arrows, and „'also if you press 'w', 's', 'a', 'd'.„'Have fun.„„SCREEN 12„COLOR 15„n = 15„g = 1„DIM r(n), alfa(n), s(n), c(n)„DEF fnx (r, alfa) = SIN(alfa) * r + 320„DEF fny (r, alfa) = COS(alfa) * r + 240„DEF fnr (x, y) = SQR((x - 320) ^ 2 + (y - 240) ^ 2)„DEF fnalfa (x, y) = ATN((x - 320) / (y - 240.001)) + 3.1415 * (y < 240)„'„' This Program was made by Eliram Haklay - elirama@freud.tau.ac.il„'„FOR i = 1 TO n„ r(i) = RND * 400„ alfa(i) = RND * 6.283„ s(i) = RND * 10„ c(i) = RND * 15„ COLOR c(i)„ CIRCLE (fnx(r(i), alfa(i)), fny(r(i), alfa(i))), r(i) * s(i) / 400„ 'CALL star(fnx(r(i), alfa(i)), fny(r(i), alfa(i)), r(i) * s(i) / 400)„NEXT i„„start:„FOR i = 1 TO n„ COLOR 0„ CIRCLE (fnx(r(i), alfa(i)), fny(r(i), alfa(i))), r(i) * s(i) / 400„ 'CALL star(fnx(r(i), alfa(i)), fny(r(i), alfa(i)), r(i) * s(i) / 400)„ r(i) = r(i) + s(i) * g * r(i) / 200„ IF shift <> 0 THEN GOSUB shft„ IF r(i) > 400 OR r(i) < 9 THEN„                                r(i) = RND * 400„                                alfa(i) = RND * 6.283„                                s(i) = RND * 30„                                c(i) = RND * 15„                           END IF„ alfa(i) = alfa(i) + rot„ COLOR c(i)„ CIRCLE (fnx(r(i), alfa(i)), fny(r(i), alfa(i))), r(i) * s(i) / 400„ 'CALL star(fnx(r(i), alfa(i)), fny(r(i), alfa(i)), r(i) * s(i) / 400)„NEXT i„ b$ = INKEY$„ rot = 0„ IF shift <> 0 THEN shift = shift - sh„ IF b$ <> "" THEN GOSUB keyp„GOTO start„„keyp:„IF b$ = CHR$(0) + "M" THEN rot = .03„IF b$ = CHR$(0) + "K" THEN rot = -.03„IF b$ = CHR$(0) + "H" THEN g = g + .1„IF b$ = CHR$(0) + "P" THEN g = g - .1„IF b$ = "s" THEN shift = 40: direct = 1: sh = 4„IF b$ = "w" THEN shift = -40: direct = 1: sh = -4„IF b$ = "a" THEN shift = 40: direct = 2: sh = 4„IF b$ = "d" THEN shift = -40: direct = 2: sh = -4„IF b$ = CHR$(27) THEN END„RETURN„„shft:„IF direct = 1 THEN„                   r1 = fnr(fnx(r(i), alfa(i)), fny(r(i), alfa(i)) + sh)„                   alfa = fnalfa(fnx(r(i), alfa(i)), fny(r(i), alfa(i)) + sh)„              ELSE„                   r1 = fnr(fnx(r(i), alfa(i)) + sh, fny(r(i), alfa(i)))„                   alfa = fnalfa(fnx(r(i), alfa(i)) + sh, fny(r(i), alfa(i)))„              END IF„r(i) = r1„alfa(i) = alfa„RETURN„„SUB star (x, y, s)„'a = RND * 6.28„FOR i = 0 TO 6.28 STEP 1.256„ LINE (SIN(i + a) * s + x, COS(i + a) * s + y)-(SIN(i + .628 + a) * s / 2 + x, COS(i + .628 + a) * s / 2 + y)„ LINE (SIN(i + .628 + a) * s / 2 + x, COS(i + .628 + a) * s / 2 + y)-(SIN(i + 1.256 + a) * s + x, COS(i + 1.256 + a) * s + y)„NEXT i„END SUB„jackmott@ix.netcom.com         STARFIELD                      comp.lang.basic.misc           11-18-95 (04:15)       QB, QBasic, PDS        190  5376     STRFIELD.BAS'I wrote the following with QuickBasic 4.5 (the commercial one) if you run this„'with Qbasic that comes with DOS it will go REAL slow, but there is a variable„'you can change that I will comment profusely that will speed it up with a lack„'of quality..also you can just change the screen resolution and stuff if it is„'too slow, I am on a p90 for reference.„„'    This program makes a random and very cool starfield, then makes graphs„'various things that resemble black holes and galaxies..makes good screen saver„'type thing, and show it to your math teacher for extra credit...„„'I have this written in pascal at the highschool if anyone wants it in that let„'me know, its an easy conversion.„„„„SCREEN 12           'Check help files for other settings, this is good hi-res„RANDOMIZE TIMER„„radians = 1.57079632679#        'constant for 90 degrees in radians„   „„„DO      'Main body„		DO                        'Big Stars„„				x = INT(RND * 640 + 1)      'This part makes really really„				y = INT(RND * 480 + 1)      'cool looking stars„				COLOR 15„				PSET (x, y)„„				COLOR 7„				PSET (x - 1, y)„				PSET (x + 1, y)„				PSET (x, y - 1)„				PSET (x, y + 1)„				COLOR 8„				PSET (x - 2, y)„				PSET (x + 2, y)„				PSET (x, y - 2)„				PSET (x, y + 2)„				i = i + 1„		LOOP UNTIL i = 20     'Big stars - change the value here for more stars„	   „'The parts below make normal single pixel stars       „„COLOR 8„i = 0„		DO                     'Dim little stars„				x = INT(RND * 640 + 1)„				y = INT(RND * 480 + 1)„				PSET (x, y)„				i = i + 1„		LOOP UNTIL i = 180     'Dim little stars„„COLOR 15„i = 0„		DO                     'Bright litte stars„				x = INT(RND * 640 + 1)„				y = INT(RND * 480 + 1)„				PSET (x, y)„				i = i + 1„		LOOP UNTIL i = 90      'Bright little stars„„COLOR 7„i = 0„		DO                      'medium little stars„				x = INT(RND * 640 + 1)„				y = INT(RND * 480 + 1)„				PSET (x, y)„				i = i + 1„		LOOP UNTIL i = 150       'medium little stars„„„„„„theta = 1„„c = INT(RND * 15 + 1)  'color scheme, picks a random NON-black color„if c = 0 then c = 4„color c„„hole = INT(RND * 16 + 1)    'Random value to select type of graph„DO              'Black hole main loop„„		„„				r = 1.01 ^ theta                    'black hole main formula„„			   „SELECT CASE hole      'Variations of the graph„		CASE 1„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x + theta„		y = y + 240„		CASE 2„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x - theta + 640„		y = y + 240„	   „		CASE 3„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x - theta + 640„		y = y - theta + 480„„		CASE 4„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x + theta„		y = y + theta„„		CASE 5, 14„	  „				y = (COS(theta)) * r            'Convert polar to cartesian y„				x = (SIN(90 - theta)) * r        'Convert polar to cartesian x„		x = x + 320„		y = y + 240„	   „		CASE 15, 16„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		„		x = x + 320„		y = y + 240„		„		CASE 6„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x * theta / 85 + 320„		y = y + theta„		CASE 7„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x * theta / 85 + 320„		y = y - theta + 480„„		CASE 8„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x + theta„		y = y * theta / 100 + 240„„		CASE 9„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x - theta + 640„		y = y * theta / 100 + 240„„		CASE 10„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x + theta / r + 320„		y = y + theta„„		CASE 11„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x + theta / r + 320„		y = y - theta + 480„„		CASE 12„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x + theta„		y = y + theta / r + 240„„		CASE 13„				y = (SIN(theta)) * r            'Convert polar to cartesian y„				x = (SIN(radians - theta)) * r  'Convert polar to cartesian x„		x = x - theta + 640„		y = y + theta / r + 240„„END SELECT„„„				PSET (x, y)                             'Place the dots„				theta = theta + .01  'Make this bigger for more speed!!!!!!!„„				breakout$ = INKEY$„„		LOOP UNTIL theta > 750 OR breakout$ <> ""„„		i = 0„		CLS„„		IF breakout$ <> "" THEN END„LOOP                    'Main body„Mike Beckman                   CIRCLE FUNCTIONS               mhscards@aol.com               12-17-95 (11:37)       QB, QBasic, PDS        96   2276     CIRCLE.BAS  DEFINT A-Z„DECLARE FUNCTION Distance! (x1, y1, x2, y2)„SCREEN 12„„DO„   CLS„   PRINT "You must choose at least 2 points."„   INPUT "How many points do you want the computer to choose randomly"; a„   IF a > 1 THEN EXIT DO„LOOP„„PRINT„PRINT "Do you want the computer to choose the center of the circle,"„PRINT "or would you like to choose it?"„PRINT "(Press C for computer to choose or anything else to choose)"„DO: abc$ = INKEY$: LOOP UNTIL abc$ <> ""„PRINT abc$„IF INSTR("cC", abc$) THEN„   RANDOMIZE TIMER„   x = INT(RND * 640)„   y = INT(RND * 480)„   radius = INT(RND * 200) + 20„ELSE„   DO„      INPUT "X Coordinate"; x„      IF x >= 0 AND x <= 639 THEN EXIT DO„   LOOP„   DO„      INPUT "Y Coordinate"; y„      IF y >= 0 AND x <= 479 THEN EXIT DO„   LOOP„   DO„      INPUT "Radius (20 - 220)"; radius„      IF radius >= 20 OR radius <= 220 THEN EXIT DO„   LOOP„END IF„„PRINT "Now choosing random points..."„„   RANDOMIZE TIMER„   DIM x1(1 TO a)„   DIM y1(1 TO a)„„FOR ab = 1 TO a„   x1(ab) = INT(RND * 640)„   y1(ab) = INT(RND * 480)„NEXT ab„„PRINT "Done!"„PRINT„PRINT "Now I'm going to draw the screen."„PRINT "The circle will be blue, the center of the circle will be red, and"„PRINT "all the points will be yellow."„PRINT„PRINT "Then I will tell you how many points are on the circle, how many"„PRINT "are inside the circle, and how many are outside the circle."„DO: LOOP UNTIL LEN(INKEY$)„„CLS„„FOR ab = 1 TO a„   PSET (x1(ab), y1(ab)), 14„NEXT ab„„CIRCLE (x, y), radius, 9„„DO: LOOP UNTIL LEN(INKEY$)„„CLS„inside = 0„outside = 0„oncircle = 0„timey! = TIMER„FOR ab = 1 TO a„   dist! = Distance(x, y, x1(ab), y1(ab))„   IF dist! = radius THEN oncircle = oncircle + 1„   IF dist! > radius THEN outside = outside + 1„   IF dist! < radius THEN inside = inside + 1„NEXT ab„stoptime! = TIMER - timey!„„SCREEN 0„PRINT "Total Points on the screen:"; a„PRINT "Total Points on the circle:"; oncircle„PRINT "Total Points outside the circle:"; outside„PRINT "Total Points inside the circle:"; inside„PRINT "Radius of the circle:"; radius„PRINT "Seconds to calculate:"; stoptime!„END„„FUNCTION Distance! (x1, y1, x2, y2)„„Distance! = SQR((x2 - x1) ^ 2 + (y2 - y1) ^ 2)„„END FUNCTION„„John Rodgers                   LAVA EFFECT                    Wizard Productions             Unknown Date           QB, QBasic, PDS        138  4419     LAVA.BAS    '                                LAVA.BAS„'                              John Rodgers„'                           Wizard Productions„'                             Too Cool Fool„'                            coolfool@flinet.com„'                           john@compconn.com„'„' LAVA.BAS was written to take advantage of an effect I had seen in my earlier„'screen savers. When you issue a PAINT statement on a graphic that is linked„'by small lines, the color crawls along the lines until the edges are reached„'or all the pixels have changed to the new color. This program draws a screen„'full of circles and colored pixels and issues random PAINT statements to„'random points on the screen. Occasionally these points are linked to large„'areas and the color "crawls" across the screen. Like a lava lamp it takes„'awhile it to warm up (for the screen to fill with circles).„'As a screen saver it may not be ideal as some of the PAINT statements take„'awhile to complete before the program surrenders control.„„„DECLARE SUB drawCircles ()„DECLARE SUB pxsett ()„ „ON ERROR GOTO eror:„„SCREEN 9„„CLS„RANDOMIZE TIMER„DO„„pxsett„drawCircles„ „c% = INT(RND * 16)„xpos% = INT(RND * 640)„ypos% = INT(RND * 480)                 'initiate random numbers„„PAINT (xpos%, ypos%), c%, 0            'the following statements are to„                                        'partialy clear the screen occasionaly„„IF xpos% = 50 THEN PAINT (xpos%, ypos%), 0, 0    'on these numbers paint black„IF xpos% = 150 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 250 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 450 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 550 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 55 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 155 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 255 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 355 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 455 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 555 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 51 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 151 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 251 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 351 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 451 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 551 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 52 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 152 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 252 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 352 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 452 THEN PAINT (xpos%, ypos%), 0, 0„IF xpos% = 552 THEN PAINT (xpos%, ypos%), 0, 0„ „LOOP UNTIL LEN(INKEY$)„„SYSTEM„„eror:                                     'simple error trap„„SELECT CASE ERR„„CASE 5                                 'runtime error 5-Illegal Function Call„ SCREEN 0                               ' SCREEN ERROR„ CLS„ COLOR 15„ LOCATE 2, 22„ PRINT "ERROR!! ILLEAGLE FUNCTION CALL"„ COLOR 7„ LOCATE 3, 5„ PRINT "LAVA.BAS works best in screen modes 8, 9 and 12.";„ PRINT "The effect is somewhat "„ PRINT "noticable in screen modes 7 and 13."„ PRINT "    The effect is lost in other modes, however SCREEN 10 offers some"„ PRINT " interesting effects if you are bored."„ LOCATE 8, 1„ PRINT "PAX,"„ PRINT "TCF"„ PRINT„ INPUT "Press ENTER to return to DOS", d$„ SYSTEM„CASE ELSE„ RESUME NEXT„END SELECT„ RESUME„„SUB drawCircles„ FOR k = 1 TO 110„row% = INT(RND * 640)„col% = INT(RND * 480)                   'initiate random numbers„arow% = INT(RND * 640)„acol% = INT(RND * 480)„„ra% = INT(RND * 5)„s = INT(RND * 900)„IF s <= 600 THEN c% = 8                 'get c% (color)„IF s > 600 AND s <= 790 THEN c% = 4„IF s > 790 AND s <= 800 THEN c% = 14„IF s > 800 AND s <= 825 THEN c% = 9„IF s > 825 AND s <= 875 THEN c% = 3„IF s > 875 AND s <= 900 THEN c% = 6„„CIRCLE (row%, col%), ra%, c%           'draw circle„NEXT k„„END SUB„„SUB pxsett„DO                           'pxsett helps make and break circle„c% = 1                        'connections for the paint statements to„                              ' have greater effect    „„xpos% = INT(RND * 640)„ypos% = INT(RND * 480)„row% = INT(RND * 640)„col% = INT(RND * 480)                   'initiate random numbers„„„PSET (xpos%, col%), 4„PSET (row%, ypos%), 0                  'paint random pixels 3 colors„PSET (xpos%, ypos%), 4„PSET (row%, col%), 1„lop% = lop% + 1„„LOOP UNTIL lop% >= 20„„END SUB„„Ronny Schwachofer              3D POLYGONS                    FidoNet QUIK_BAS Echo          01-29-96 (17:08)       QB, QBasic, PDS        130  3758     3D-POLY.BAS SCREEN 12„PALETTE 0, 65536 * 63 + 256 * 63 + 63„begin:„COLOR 4: LOCATE 26, 1: PRINT "Gebruik `t' om tekst aan en uit te zetten"„LOCATE 27, 1: PRINT "Gebruik " + CHR$(26) + " en " + CHR$(27) + " om sneller of langzamer te laten draaien"„LOCATE 28, 1: PRINT "Gebruik + en - om hetaantal vlakken te vermeerderen/verminderen"„COLOR 15„LINE (1, 1)-(310, 250), 15, B„LINE (2, 2)-(309, 249), 15, B„LINE (1, 1 + 260)-(310, 310), 15, B„LINE (2, 2 + 260)-(309, 311), 15, B„LINE (1 + 315, 1)-(310 + 315, 250), 15, B„LINE (2 + 315, 2)-(309 + 315, 249), 15, B„LINE (1 + 315, 1 + 260)-(310 + 315, 390), 15, B„LINE (2 + 315, 2 + 260)-(309 + 315, 391), 15, B„LOCATE 1, 3: PRINT " Output 1 "„LOCATE 1, 42: PRINT " Output 2 "„spiet = 51„hoeveel = 5„REDIM x(1 TO hoeveel * 2)„REDIM y(1 TO hoeveel * 2)„REDIM xx(1 TO hoeveel * 2)„REDIM yy(1 TO hoeveel * 2)„FOR i = 1 TO hoeveel„x(i) = 0„y(i) = 0„xx(i) = 0„yy(i) = 0„NEXT„z = hoeveel + 1„FOR i = 63 TO 0 STEP -1„PALETTE 0, 65536 * i + 256 * i + i„NEXT„DO„„FOR n = 0 TO 22 / 3.5 / hoeveel STEP hoeveel / (hoeveel * spiet)„IF x$ = CHR$(27) THEN GOTO einde„IF x$ = CHR$(0) + CHR$(77) THEN spiet = spiet - 1„IF x$ = CHR$(0) + CHR$(75) THEN spiet = spiet + 1„IF x$ = CHR$(0) + CHR$(80) THEN spiet = 51„IF x$ = "+" THEN hoeveel = hoeveel + 1„IF x$ = "-" THEN hoeveel = hoeveel - 1„IF LCASE$(x$) = "t" AND t$ <> "on" THEN t$ = "on": x$ = ""„IF LCASE$(x$) = "t" AND t$ <> "off" THEN t$ = "off": x$ = ""„IF spiet < 1 THEN spiet = 1„IF spiet > 150 THEN spiet = 150„IF hoeveel < 1 THEN hoeveel = 1„IF hoeveel > 15 THEN hoeveel = 15„x$ = INKEY$„„LOCATE 18, 5: PRINT "Snelheid: "; 151 - spiet„LOCATE 19, 5: PRINT "Vlakken : "; hoeveel„„FOR i = 1 TO z - 2„LINE (x(i), y(i))-(x(i + 1), y(i + 1)), 0„NEXT„LINE (x(z - 1), y(z - 1))-(x(1), y(1)), 0„FOR i = 1 TO z - 2„LINE (x(i) + 100, y(i) - 50)-(x(i + 1) + 100, y(i + 1) - 50), 0„LINE (xx(i), yy(i))-(xx(i + 1), yy(i + 1)), 0„NEXT„LINE (x(z - 1) + 100, y(z - 1) - 50)-(x(1) + 100, y(1) - 50), 0„FOR i = 1 TO z - 1„LINE (x(i), y(i))-(x(i) + 100, y(i) - 50), 0„„NEXT„LINE (xx(z - 1), yy(z - 1))-(xx(1), yy(1)), 0„FOR i = 1 TO z - 2„LINE (xx(i), yy(i) - 150)-(xx(i + 1), yy(i + 1) - 150), 0„NEXT„LINE (xx(z - 1), yy(z - 1) - 150)-(xx(1), yy(1) - 150), 0„FOR i = 1 TO z - 1„LINE (xx(i), yy(i))-(xx(i), yy(i) - 150), 0„„NEXT„REDIM x(1 TO hoeveel * 2)„REDIM y(1 TO hoeveel * 2)„REDIM xx(1 TO hoeveel * 2)„REDIM yy(1 TO hoeveel * 2)„z = 1„FOR i = n TO 22 / 3.5 STEP (22 / 3.5 / hoeveel)„x(z) = COS(i) * 50 + 100„y(z) = SIN(i) * 50 + 150„xx(z) = COS(i) * 50 + 470„yy(z) = SIN(i) * 10 + 200„z = z + 1„IF t$ = "on" THEN LOCATE i + 18, 47: PRINT "x("; z; ")="; CINT(x(z - 1)); "->"„IF t$ = "on" THEN LOCATE i + 18, 62: PRINT "y("; z; ")="; CINT(y(z - 1))„„NEXT„FOR i = 1 TO z - 2„LINE (x(i), y(i))-(x(i + 1), y(i + 1))„NEXT„LINE (x(z - 1), y(z - 1))-(x(1), y(1))„FOR i = 1 TO z - 2„LINE (x(i) + 100, y(i) - 50)-(x(i + 1) + 100, y(i + 1) - 50)„NEXT„LINE (x(z - 1) + 100, y(z - 1) - 50)-(x(1) + 100, y(1) - 50)„FOR i = 1 TO z - 1„LINE (x(i), y(i))-(x(i) + 100, y(i) - 50)„NEXT„„FOR i = 1 TO z - 2„LINE (xx(i), yy(i))-(xx(i + 1), yy(i + 1))„NEXT„LINE (xx(z - 1), yy(z - 1))-(xx(1), yy(1))„FOR i = 1 TO z - 2„LINE (xx(i), yy(i) - 150)-(xx(i + 1), yy(i + 1) - 150)„NEXT„LINE (xx(z - 1), yy(z - 1) - 150)-(xx(1), yy(1) - 150)„FOR i = 1 TO z - 1„LINE (xx(i), yy(i))-(xx(i), yy(i) - 150)„NEXT„„CIRCLE (100, 150), 2, 15„CIRCLE (200, 100), 2, 15„LINE (100, 150)-(200, 100), 15„„CIRCLE (470, 200), 2, 15, , , .5„CIRCLE (470, 50), 2, 15, , , .5„LINE (470, 50)-(470, 200)„NEXT n„„LOOP„einde:„FOR i = 0 TO 63„PALETTE 0, 65536 * i + 256 * i + i„NEXT„SCREEN 0, 0, 0: WIDTH 80, 25: CLS : END„„Steve Harmon                   VGA MAZE GENERATOR             FidoNet QUIK_BAS Echo          02-04-96 (00:59)       QB, QBasic, PDS        44   1892     VGAMAZE.BAS 'Don't remember if I wrote this or picked it up somewhere and modified it„'for VGA. It's a little slow, but it works.„„100 SCREEN 12„110 CLS„115 DEFINT A-Z„120 A = 106 'width„130 B = 118 'height„140 DIM F(A, B)„150 FORE = 3: BACK = 0„240 FOR Y = 0 TO B * 4 STEP 4„242 FOR X = 0 TO 6 * A„244 PSET (X, Y), FORE: NEXT X, Y„290 FOR X = 0 TO 6 * A STEP 6„292 FOR Y = 0 TO 4 * B„294 PSET (X, Y), FORE: NEXT Y, X„340 FOR E = 1 TO B„342 FOR D = 1 TO A„344 F(D, E) = 0: NEXT D, E„390 J = INT(A / 2): K = INT(B / 2): X = -3: Y = -2: F(J, K) = 2„440 FOR E = 1 TO B: Y = Y + 4„442 FOR D = 1 TO A: X = X + 6„444   IF F(D, E) = 2 THEN GOSUB 540„450   IF INKEY$ <> "" THEN END„452 NEXT D: X = -3: NEXT E: Y = -2: GOTO 440„540 L = INT(RND(1) * 4 + 1)„550 IF D - 1 <> 0 AND F(D - 1, E) = 0 THEN F(D - 1, E) = 1„560 IF D = A THEN 570 ELSE IF F(D + 1, E) = 0 THEN F(D + 1, E) = 1„570 IF E - 1 <> 0 AND F(D, E - 1) = 0 THEN F(D, E - 1) = 1„580 IF B = E THEN 590 ELSE IF F(D, E + 1) = 0 THEN F(D, E + 1) = 1„590 IF L = 1 AND D - 1 <> 0 AND F(D - 1, E) = 1 THEN GOSUB 650„600 IF D = A THEN 610 ELSE IF L = 2 AND F(D + 1, E) = 1 THEN GOSUB 650„610 IF L = 3 AND E - 1 <> 0 AND F(D, E - 1) = 1 THEN GOSUB 720„620 IF B = E THEN 630 ELSE IF L = 4 AND F(D, E + 1) = 1 THEN GOSUB 720„630 IF A * B - 1 = M THEN 790„640 RETURN„650 IF L = 1 THEN F(D - 1, E) = 2: R = X - 3 ELSE IF L = 2 THEN F(D + 1, E) = 2: R = X + 3„660 FOR S = Y - 1 TO Y + 1: PSET (R, S), BACK: NEXT S: M = M + 1: RETURN„720 IF L = 3 THEN F(D, E - 1) = 2: S = Y - 2 ELSE IF L = 4 THEN F(D, E + 1) = 2: S = Y + 2„730 FOR R = X - 2 TO X + 2: PSET (R, S), BACK: NEXT R: M = M + 1: RETURN„790 X = 0: Y = INT(RND(1) * B + 1) * 4 - 3: FOR Y = Y TO Y + 2: PSET (X, Y), BACK: NEXT Y„800 X = A * 6: Y = INT(RND(1) * B + 1) * 4 - 2: FOR Y = Y TO Y + 2: PSET (X, Y), BACK: NEXT Y„890 BEEP: WHILE INKEY$ = "": WEND: END„„Kevin Krumwiede/Aaron Zabudsky SIERPINSKI GASKET              FidoNet QUIK_BAS Echo          02-13-96 (22:15)       QB, QBasic, PDS        42   904      TRIANGLE.BAS' Sierpinski Gasket Proggy by Kevin Krumwiede„' Rulz!„' (I took too many math courses...)„„SCREEN 12„DEFINT X-Y„FOR y = 0 TO 255„  FOR x = 0 TO y„    IF (x AND (y - x)) = 0 THEN„    PSET (x + 158 - .5 * y, y + 30)„    END IF„  NEXT x„NEXT y„END„„'-------8<---[ Begin Aaron Scott Zabudsky's Triangle thingy ]--->8------„„RANDOMIZE TIMER„SCREEN 12„x1 = 100: y1 = 400„x2 = 500: y2 = 400„x3 = 300: y3 = 54„PSET (x1, y1), 14„PSET (x2, y2), 14„PSET (x3, y3), 14„gamex = x1„gamey = y1„WHILE c < 10000„dice = INT(RND(1) * 3)„   IF dice = 0 THEN„      gamex = gamex + (x1 - gamex) / 2„      gamey = gamey + (y1 - gamey) / 2„   ELSEIF dice = 1 THEN„      gamex = gamex + (x2 - gamex) / 2„      gamey = gamey + (y2 - gamey) / 2„   ELSEIF dice = 2 THEN„      gamex = gamex + (x3 - gamex) / 2„      gamey = gamey + (y3 - gamey) / 2„   END IF„   PSET (gamex, gamey), 15„WEND„„Joseph M. Brooks               UPSIDE DOWN TEXT               FidoNet QUIK_BAS Echo          02-14-96 (17:29)       QB, QBasic, PDS        180  5155     UPSIDOWN.BAS ' > This is kind of an interesting thought... is there any way, in QB,„ ' > to shift the screen, so that instead of displaying things„ ' > horizontally, it'll do it vertically? Or even upside-down? That„ ' > could be a fun toy to play with... :)„„' Bogus Monitor Benchmark Program Version 1.1 by Joseph M. Brooks.„' (C) 1995, All Rights Reserved.„' Permission to use this code within your own program is granted„' free of charge provided I am given appropriate credit within your program.„„' Requires EGA or higher video card.„„' Initialize Defaults, Constants, and Arrays„„DEFINT A-Z: OPTION BASE 1„CONST BitPlanes = 4, CharWidth = 8, CharHeight = 14„CONST LeftMostX = 23, TopmostY = 9, LongestLine = 36, MessageLines = 4„DIM NumBits AS LONG, BitHolder(2, 16)„„' Calculate minimum size for GET/PUT arrays and DIMension them.„„X = (LeftMostX - 1) * CharWidth„Y = (TopmostY - 1) * CharHeight„XOffset = LongestLine * CharWidth - 1„YOffset = MessageLines * CharHeight - 1„NumBits = (XOffset + 1&) * (YOffset + 1&) * BitPlanes„NumBytes = CINT(NumBits / 8)„NumInts = CINT(NumBytes / 2)„RecMax = NumInts + 2„DIM message(RecMax), Message2(RecMax)„„' Set screen to 80x25 to make sure GET winds up getting text, not blank„'     area of the screen.„„WIDTH 80, 25„„„' Select hidden EGA screen for output, Print Message, GET Message„SCREEN 9, , 0, 0„LOCATE 9, 23: PRINT "This computer screen is upside-down."„LOCATE 11, 25: PRINT "Please flip over the monitor to"„LOCATE 12, 29: PRINT "correct this situation."„GET (X, Y)-(X + XOffset, Y + YOffset), message„' Copy first 4 bytes of Message() (size of GET block) into Message2()„„Message2(1) = message(1): Message2(2) = message(2)„„' Select visible screen for output, display bogus set-up message„CLS„SCREEN 9, , 0, 0„PRINT„PRINT "Monitor performance benchmark - please wait while monitor is tested."„PRINT„SLEEP 1„BEEP„PRINT "WARNING!  This software has detected an error in your monitor."„PRINT "It seems one of the parts was installed upside-down at the factory."„PRINT "Please wait while this error is corrected."„PRINT "Checking monitor part #"„„' Turn Message() image upside-down and store in Message2() (speed counts)„„FOR I = 3 TO RecMax„„' Give user visible indicator program is working„„  LOCATE 7, 24: PRINT I„„' Initialize new array element (integer) to store in Message2()„„  NewNum = 0„„' Separte 16-bit integer into separate bits„„  FOR Bit = 1 TO 16„    SELECT CASE Bit„      CASE 1„        BitHolder(1, 1) = message(I) AND -32768„      CASE 2„        BitHolder(1, 2) = message(I) AND &H4000„      CASE 3„        BitHolder(1, 3) = message(I) AND &H2000„      CASE 4„        BitHolder(1, 4) = message(I) AND &H1000„      CASE 5„        BitHolder(1, 5) = message(I) AND &H800„      CASE 6„        BitHolder(1, 6) = message(I) AND &H400„      CASE 7„        BitHolder(1, 7) = message(I) AND &H200„      CASE 8„        BitHolder(1, 8) = message(I) AND &H100„      CASE 9„        BitHolder(1, 9) = message(I) AND &H80„      CASE 10„        BitHolder(1, 10) = message(I) AND &H40„      CASE 11„        BitHolder(1, 11) = message(I) AND &H20„      CASE 12„        BitHolder(1, 12) = message(I) AND &H10„      CASE 13„        BitHolder(1, 13) = message(I) AND &H8„      CASE 14„        BitHolder(1, 14) = message(I) AND &H4„      CASE 15„        BitHolder(1, 15) = message(I) AND &H2„      CASE 16„        BitHolder(1, 16) = message(I) AND &H1„    END SELECT„„' Reverse bits in integer to get new number„„    IF BitHolder(1, Bit) THEN„      SELECT CASE Bit„        CASE 1„          BitHolder(2, 16) = &H1„        CASE 2„          BitHolder(2, 15) = &H2„        CASE 3„          BitHolder(2, 14) = &H4„        CASE 4„          BitHolder(2, 13) = &H8„        CASE 5„          BitHolder(2, 12) = &H10„        CASE 6„          BitHolder(2, 11) = &H20„        CASE 7„          BitHolder(2, 10) = &H40„        CASE 8„          BitHolder(2, 9) = &H80„        CASE 9„          BitHolder(2, 8) = &H100„        CASE 10„          BitHolder(2, 7) = &H200„        CASE 11„          BitHolder(2, 6) = &H400„        CASE 12„          BitHolder(2, 5) = &H800„        CASE 13„          BitHolder(2, 4) = &H1000„        CASE 14„          BitHolder(2, 3) = &H2000„        CASE 15„          BitHolder(2, 2) = &H4000„        CASE 16„          BitHolder(2, 1) = -32768„      END SELECT„    ELSE„      BitHolder(2, 16 - Bit + 1) = 0„    END IF„„' Add component values to get new integer with bits reversed„„    NewNum = NewNum + BitHolder(2, 16 - Bit + 1)„  NEXT Bit„„' Assign value to Message2() array element in reverse order from Message()„„  Message2(RecMax - I + 3) = NewNum„NEXT I„„' Signal user done and display rest of bogus set-up message„„BEEP„PRINT„PRINT "The defective part has been found!"„PRINT„PRINT "Now implementing solution...."„SLEEP 3„„' Deliver punch-line and display upside-down message„„CLS„PUT (X, 350 - Y), Message2, PSET„„' Wait for keypress and set screen back before exiting„„Continue$ = INPUT$(1)„SCREEN 0, , 0, 0: SYSTEM„„Sean Smith                     ROTATING DNA ANALYSIS          FidoNet QUIK_BAS Echo          03-10-96 (09:59)       QB, QBasic, PDS        338  9160     DNA.BAS     '        Here's some cool code I found.  Does a dna string analysis.„'Definately something new!  Its on 4 different messages starting now.  I„'did not write this code though.  :(„„SCREEN 12„„CLS„molcol = 15„barcol = 8„scancol = 4„center = 75„interval = .1„length = 75„radius = 4„ky = 275„jy = 250„iy = 225„hy = 200„gy = 175„fy = 150„ey = 125„dy = 100„cy = 75„by = 50„y = 25„obs = 200„REM hscandir = 1„REM vscandir = 1„„LINE (0, 0)-(151, 301), 8, B„LINE (1, 1)-(150, 300), 7, B„LINE (2, 2)-(149, 299), 15, B„LINE (3, 3)-(148, 298), 7, B„LINE (4, 4)-(147, 297), 8, B„„LOCATE 20, 1„COLOR 8„PRINT "   [";„COLOR 15„PRINT "DNA Analysis";„COLOR 8„PRINT "]"„COLOR 15„PRINT : COLOR 8: PRINT " Õ"; : COLOR 7: PRINT "Õ";„COLOR 15: PRINT "[ Building structure  ]";„COLOR 7: PRINT "Õ"; : COLOR 8: PRINT "Õ"„message = 2„GOTO 20„5 FOR angle = 0 TO 36000 STEP interval„„REM -------SCAN--------„„10„IF scanned = 1 THEN GOTO 20„IF message = 2 THEN LOCATE 22, 5: COLOR 15: PRINT " Scaning DNA String  "„IF hscan < 15 THEN hscandir = 1„IF hscan > 290 THEN hscandir = 0„IF hscandir = 0 THEN hscan = hscan - 5: LINE (5, hscan + 5)-(145, hscan + 5), 0„IF hscandir = 1 THEN hscan = hscan + 5: LINE (5, hscan - 5)-(145, hscan - 5), 0„LINE (5, hscan)-(145, hscan), scancol„„IF vscan < 15 THEN vscandir = 1: pass = pass + .5„IF vscan > 140 THEN vscandir = 0:„IF vscandir = 0 THEN vscan = vscan - 5: LINE (vscan + 5, 5)-(vscan + 5, 295), 0„IF vscandir = 1 THEN vscan = vscan + 5: LINE (vscan - 5, 5)-(vscan - 5, 295), 0„LINE (vscan, 5)-(vscan, 295), scancol„„IF pass = 3 THEN scanned = 1: message = 3: LINE (5, hscan)-(145, hscan), 0:„LINE (vscan, 5)-(vscan, 295), 0: FOR delay = 1 TO 5000: NEXT delay: GOTO 5„GOTO 20„IF scanned = 0 THEN GOTO 10„REM --------1------------„20„ IF message = 3 THEN LOCATE 22, 5: COLOR 15: PRINT " Testing Integrity "„ zangle = angle + 1„ x1 = (center - (COS(zangle) * (length / 2)))„ x2 = (center + (COS(zangle) * (length / 2)))„ a1 = obs - (SIN(zangle) * (length))„ a2 = obs + (SIN(zangle) * (length))„„ radiusx1 = (obs / a1) * radius„ radiusx2 = (obs / a2) * radius„ LINE (lastx1, y)-(lastx2, y), 0„ CIRCLE (lastx1, y), lastrx1, 0„ CIRCLE (lastx2, y), lastrx2, 0„ LINE (x1, y)-(x2, y), barcol„ CIRCLE (x1, y), radiusx1, molcol„ CIRCLE (x2, y), radiusx2, molcol„„ lastx1 = x1„ lastx2 = x2„ lastrx1 = radiusx1„ lastrx2 = radiusx2„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„REM-----------2-------------„ bangle = angle + 1.5„ bx1 = (center - (COS(bangle) * (length / 2)))„ bx2 = (center + (COS(bangle) * (length / 2)))„ ba1 = obs - (SIN(bangle) * (length))„ ba2 = obs + (SIN(bangle) * (length))„„ bradiusx1 = (obs / ba1) * radius„ bradiusx2 = (obs / ba2) * radius„ LINE (blastx1, by)-(blastx2, by), 0„ CIRCLE (blastx1, by), blastrx1, 0„ CIRCLE (blastx2, by), blastrx2, 0„„ LINE (bx1, by)-(bx2, by), barcol„ CIRCLE (bx1, by), bradiusx1, molcol„ CIRCLE (bx2, by), bradiusx2, molcol„„ blastx1 = bx1„ blastx2 = bx2„ blastrx1 = bradiusx1„ blastrx2 = bradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------3-------------„ cangle = angle + 2„ cx1 = (center - (COS(cangle) * (length / 2)))„ cx2 = (center + (COS(cangle) * (length / 2)))„ ca1 = obs - (SIN(cangle) * (length))„ ca2 = obs + (SIN(cangle) * (length))„„ cradiusx1 = (obs / ca1) * radius„ cradiusx2 = (obs / ca2) * radius„ LINE (clastx1, cy)-(clastx2, cy), 0„ CIRCLE (clastx1, cy), clastrx1, 0„ CIRCLE (clastx2, cy), clastrx2, 0„„ LINE (cx1, cy)-(cx2, cy), barcol„ CIRCLE (cx1, cy), cradiusx1, molcol„ CIRCLE (cx2, cy), cradiusx2, molcol„„ clastx1 = cx1„ clastx2 = cx2„ clastrx1 = cradiusx1„ clastrx2 = cradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------4-------------„ dangle = angle + 2.5„ dx1 = (center - (COS(dangle) * (length / 2)))„ dx2 = (center + (COS(dangle) * (length / 2)))„ da1 = obs - (SIN(dangle) * (length))„ da2 = obs + (SIN(dangle) * (length))„„ dradiusx1 = (obs / da1) * radius„ dradiusx2 = (obs / da2) * radius„ LINE (dlastx1, dy)-(dlastx2, dy), 0„ CIRCLE (dlastx1, dy), dlastrx1, 0„ CIRCLE (dlastx2, dy), dlastrx2, 0„„ LINE (dx1, dy)-(dx2, dy), barcol„ CIRCLE (dx1, dy), dradiusx1, molcol„ CIRCLE (dx2, dy), dradiusx2, molcol„„ dlastx1 = dx1„ dlastx2 = dx2„ dlastrx1 = dradiusx1„ dlastrx2 = dradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------5-------------„ eangle = angle + 3!„ ex1 = (center - (COS(eangle) * (length / 2)))„ ex2 = (center + (COS(eangle) * (length / 2)))„ ea1 = obs - (SIN(eangle) * (length))„ ea2 = obs + (SIN(eangle) * (length))„„ eradiusx1 = (obs / ea1) * radius„ eradiusx2 = (obs / ea2) * radius„ LINE (elastx1, ey)-(elastx2, ey), 0„ CIRCLE (elastx1, ey), elastrx1, 0„ CIRCLE (elastx2, ey), elastrx2, 0„„ LINE (ex1, ey)-(ex2, ey), barcol„ CIRCLE (ex1, ey), eradiusx1, molcol„ CIRCLE (ex2, ey), eradiusx2, molcol„„ elastx1 = ex1„ elastx2 = ex2„ elastrx1 = eradiusx1„ elastrx2 = eradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------6-------------„ fangle = angle + 3.5„ fx1 = (center - (COS(fangle) * (length / 2)))„ fx2 = (center + (COS(fangle) * (length / 2)))„ fa1 = obs - (SIN(fangle) * (length))„ fa2 = obs + (SIN(fangle) * (length))„„ fradiusx1 = (obs / fa1) * radius„ fradiusx2 = (obs / fa2) * radius„ LINE (flastx1, fy)-(flastx2, fy), 0„ CIRCLE (flastx1, fy), flastrx1, 0„ CIRCLE (flastx2, fy), flastrx2, 0„„ LINE (fx1, fy)-(fx2, fy), barcol„ CIRCLE (fx1, fy), fradiusx1, molcol„ CIRCLE (fx2, fy), fradiusx2, molcol„„ flastx1 = fx1„ flastx2 = fx2„ flastrx1 = fradiusx1„ flastrx2 = fradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------7-------------„ gangle = angle + 4„ gx1 = (center - (COS(gangle) * (length / 2)))„ gx2 = (center + (COS(gangle) * (length / 2)))„ ga1 = obs - (SIN(gangle) * (length))„ ga2 = obs + (SIN(gangle) * (length))„„ gradiusx1 = (obs / ga1) * radius„ gradiusx2 = (obs / ga2) * radius„ LINE (glastx1, gy)-(glastx2, gy), 0„ CIRCLE (glastx1, gy), glastrx1, 0„ CIRCLE (glastx2, gy), glastrx2, 0„„ LINE (gx1, gy)-(gx2, gy), barcol„ CIRCLE (gx1, gy), gradiusx1, molcol„ CIRCLE (gx2, gy), gradiusx2, molcol„„ glastx1 = gx1„ glastx2 = gx2„ glastrx1 = gradiusx1„ glastrx2 = gradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------8-------------„ hangle = angle + 4.5„ hx1 = (center - (COS(hangle) * (length / 2)))„ hx2 = (center + (COS(hangle) * (length / 2)))„ ha1 = obs - (SIN(hangle) * (length))„ ha2 = obs + (SIN(hangle) * (length))„„ hradiusx1 = (obs / ha1) * radius„ hradiusx2 = (obs / ha2) * radius„ LINE (hlastx1, hy)-(hlastx2, hy), 0„ CIRCLE (hlastx1, hy), hlastrx1, 0„ CIRCLE (hlastx2, hy), hlastrx2, 0„„ LINE (hx1, hy)-(hx2, hy), barcol„ CIRCLE (hx1, hy), hradiusx1, molcol„ CIRCLE (hx2, hy), hradiusx2, molcol„„ hlastx1 = hx1„ hlastx2 = hx2„ hlastrx1 = hradiusx1„ hlastrx2 = hradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------9-------------„ iangle = angle + 5„ ix1 = (center - (COS(iangle) * (length / 2)))„ ix2 = (center + (COS(iangle) * (length / 2)))„ ia1 = obs - (SIN(iangle) * (length))„ ia2 = obs + (SIN(iangle) * (length))„„ iradiusx1 = (obs / ia1) * radius„ iradiusx2 = (obs / ia2) * radius„ LINE (ilastx1, iy)-(ilastx2, iy), 0„ CIRCLE (ilastx1, iy), ilastrx1, 0„ CIRCLE (ilastx2, iy), ilastrx2, 0„„ LINE (ix1, iy)-(ix2, iy), barcol„ CIRCLE (ix1, iy), iradiusx1, molcol„ CIRCLE (ix2, iy), iradiusx2, molcol„„ ilastx1 = ix1„ ilastx2 = ix2„ ilastrx1 = iradiusx1„ ilastrx2 = iradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------10-------------„ jangle = angle + 5.5„ jx1 = (center - (COS(jangle) * (length / 2)))„ jx2 = (center + (COS(jangle) * (length / 2)))„ ja1 = obs - (SIN(jangle) * (length))„ ja2 = obs + (SIN(jangle) * (length))„„ jradiusx1 = (obs / ja1) * radius„ jradiusx2 = (obs / ja2) * radius„ LINE (jlastx1, jy)-(jlastx2, jy), 0„ CIRCLE (jlastx1, jy), jlastrx1, 0„ CIRCLE (jlastx2, jy), jlastrx2, 0„„ LINE (jx1, jy)-(jx2, jy), barcol„ CIRCLE (jx1, jy), jradiusx1, molcol„ CIRCLE (jx2, jy), jradiusx2, molcol„„ jlastx1 = jx1„ jlastx2 = jx2„ jlastrx1 = jradiusx1„ jlastrx2 = jradiusx2„„IF STAT = 0 THEN FOR delay = 1 TO 500: NEXT delay„„REM-----------11------------„ kangle = angle + 6„ kx1 = (center - (COS(kangle) * (length / 2)))„ kx2 = (center + (COS(kangle) * (length / 2)))„ ka1 = obs - (SIN(kangle) * (length))„ ka2 = obs + (SIN(kangle) * (length))„„ kradiusx1 = (obs / ka1) * radius„ kradiusx2 = (obs / ka2) * radius„ LINE (klastx1, ky)-(klastx2, ky), 0„ CIRCLE (klastx1, ky), klastrx1, 0„ CIRCLE (klastx2, ky), klastrx2, 0„„ LINE (kx1, ky)-(kx2, ky), barcol„ CIRCLE (kx1, ky), kradiusx1, molcol„ CIRCLE (kx2, ky), kradiusx2, molcol„„ klastx1 = kx1„ klastx2 = kx2„ klastrx1 = kradiusx1„ klastrx2 = kradiusx2„„IF STAT = 0 THEN STAT = 1: GOTO 10„IF scanned = 0 THEN GOTO 10„IF INKEY$ <> "" THEN LOCATE 22, 5: PRINT " Analysis Aborted ": END„interval = interval + .01„NEXT angle„„David J. Arigan                BLOCK FILL                     FidoNet QUIK_BAS Echo          03-10-96 (20:22)       QB, QBasic, PDS        140  4232     BLOKFILL.BAS'Hmmm... I went back and examined my source.  I tried it with a few more„'shapes and managed to crash it.  It is also a little slow.  So I went back„'and rewrote it with an entirely new algorithm that I developed.  I was„'kind of surprised to find as to how fast it filled in areas.  Depending„'on how complex the shape is, it can be a bit of a memory hog.  It uses both„'a stack and recursion to prevent stack and memory errors (which would have„'happened in a worse case scenario).  It may seem to pause on large fill„'areas but don't worry... just give it a sec.  Well here it is:„'„' BLOKFILL.BAS„' Developed and written by David J. Arigan„' Copyright (C)1996 - not to be used in any commercial product without„' written consent from the author.„DEFINT A-Z„„SCREEN 9„„'LINE (100, 100)-(200, 150), 4„'LINE (100, 100)-(300, 100), 4„'LINE (300, 100)-(300, 150), 4„'LINE (300, 150)-(200, 150), 4„'fill 112, 102, 7, 4„„FOR i = 0 TO 310 STEP 6„  CIRCLE (320, 175), i, 4, 0, 6         ' very complex shape„NEXT„fill 639, 0, 7, 4„„SUB fill (xp, yp, fc, bc)„  DIM xs(1500), ys(1500)„  xs(0) = xp: ys(0) = yp: stk = 1„  WHILE stk > 0„    stk = stk - 1„    x1 = xs(stk): fx1 = 0: y1 = ys(stk): fy1 = 0„    x2 = xs(stk): fx2 = 0: y2 = ys(stk): fy2 = 0„    WHILE (fx1 + fy1 + fx2 + fy2) <> 4„      IF fx1 = 0 THEN„        IF x1 = 0 THEN„          fx1 = 1„        ELSE„          x1 = x1 - 1„          FOR i = y1 TO y2„            nc = POINT(x1, i)„            IF nc = fc OR nc = bc THEN fx1 = 1: x1 = x1 + 1: EXIT FOR„          NEXT„        END IF„      END IF„      IF fx2 = 0 THEN„        IF x2 = 639 THEN„          fx2 = 1„        ELSE„          x2 = x2 + 1„          FOR i = y1 TO y2„            nc = POINT(x2, i)„            IF nc = fc OR nc = bc THEN fx2 = 1: x2 = x2 - 1: EXIT FOR„          NEXT„        END IF„      END IF„      IF fy1 = 0 THEN„        IF y1 = 0 THEN„          fy1 = 1„        ELSE„          y1 = y1 - 1„          FOR i = x1 TO x2„            nc = POINT(i, y1)„            IF nc = fc OR nc = bc THEN fy1 = 1: y1 = y1 + 1: EXIT FOR„          NEXT„        END IF„      END IF„      IF fy2 = 0 THEN„        IF y2 = 349 THEN„          fy2 = 1„        ELSE„          y2 = y2 + 1„          FOR i = x1 TO x2„            nc = POINT(i, y2)„            IF nc = fc OR nc = bc THEN fy2 = 1: y2 = y2 - 1: EXIT FOR„          NEXT„        END IF„      END IF„    WEND„    LINE (x1, y1)-(x2, y2), fc, BF„    m1 = -1: m2 = -1„    FOR i = x1 TO x2„      WHILE stk >= 1499„        fill xs(stk - 1), ys(stk - 1), fc, bc: stk = stk - 1„      WEND„      IF y1 > 0 THEN„        nc = POINT(i, y1 - 1)„        IF nc <> bc AND nc <> fc THEN„          IF m1 = -1 THEN m1 = i„          nc = POINT(i + 1, y1 - 1)„          IF i = x2 OR nc = bc OR nc = fc THEN„            xs(stk) = (i - m1) \ 2 + m1: ys(stk) = y1 - 1: stk = stk + 1„            m1 = -1„          END IF„        END IF„      END IF„      IF y2 < 349 THEN„        nc = POINT(i, y2 + 1)„        IF nc <> bc AND nc <> fc THEN„          IF m2 = -1 THEN m2 = i„          nc = POINT(i + 1, y2 + 1)„          IF i = x2 OR nc = bc OR nc = fc THEN„            xs(stk) = (i - m2) \ 2 + m2: ys(stk) = y2 + 1: stk = stk + 1„            m2 = -1„          END IF„        END IF„      END IF„    NEXT i„    m1 = -1: m2 = -1„    FOR i = y1 TO y2„      WHILE stk >= 1499„        fill xs(stk - 1), ys(stk - 1), fc, bc: stk = stk - 1„      WEND„      IF x1 > 0 THEN„        nc = POINT(x1 - 1, i)„        IF nc <> bc AND nc <> fc THEN„          IF m1 = -1 THEN m1 = i„          nc = POINT(x1 - 1, i + 1)„          IF i = y2 OR nc = bc OR nc = fc THEN„            xs(stk) = x1 - 1: ys(stk) = (i - m1) \ 2 + m1: stk = stk + 1„            m1 = -1„          END IF„        END IF„      END IF„      IF x2 < 639 THEN„        nc = POINT(x2 + 1, i)„        IF nc <> bc AND nc <> fc THEN„          IF m2 = -1 THEN m2 = i„          nc = POINT(x2 + 1, i + 1)„          IF i = y2 OR nc = bc OR nc = fc THEN„            xs(stk) = x2 + 1: ys(stk) = (i - m2) \ 2 + m2: stk = stk + 1„            m2 = -1„          END IF„        END IF„      END IF„    NEXT i„  WEND„END SUB„Rich Gordley                   ANOTHER PAINT REPLACEMENT      FidoNet QUIK_BAS Echo          03-09-96 (09:28)       QB, QBasic, PDS        168  3240     PAINTING.BAS'This was harder than I anticipated, but I was surprised at how fast it is.„'Could be made faster if the POINT functions were replaced by PEEKs but I„'didn't want to spend the time researching SCREEN 9 to implement them„„DEFINT A-Z„„SCREEN 9„„'several shapes to show universal applicability„„'LINE (100, 100)-(300, 150), 4, B„'RECTANGLE„'CIRCLE (112, 105), 30, 4„'CIRCLE„' an hourglass like figure„LINE (200, 100)-(100, 50), 4„LINE (100, 50)-(300, 50), 4„LINE (300, 50)-(250, 100), 4„LINE (250, 100)-(300, 150), 4„LINE (300, 150)-(100, 150), 4„LINE (100, 150)-(200, 100), 4„„'initv = 105   'FOR CIRCLE OR FOR RECTANGLE„'inith = 112„'v = 105„'h = 112„inith = 225   'for the irregular polygon„initv = 95„h = 225„v = 95„stuck = 0„found = 0„     GOSUB makeline„        DO„        IF found = 1 THEN„        GOSUB reloc„        GOSUB makeline„        END IF„        LOOP UNTIL found <> 1„„'relocate to initial coordinates„     v = initv: h = inith„     GOSUB makeline2„     DO„     IF found = 1 THEN„     GOSUB reloc„     GOSUB makeline2„     END IF„     LOOP UNTIL found <> 1„„DO„A$ = INKEY$„LOOP UNTIL A$ <> ""„END„„setpoint:„      PSET (h, v), 3„RETURN„„makeline:„'draws a line from initial position all the way to the left and„'all the way to the right, looking for the first hole in the„'ceiling it can find.„„'move left„found = 0„holev = 0„holeh = 0„'look up before moving to see if there is a hole„DO„IF found = 0 THEN„'if no hole yet found then check for one„IF POINT(h, v - 1) <> 4 THEN„          holev = v - 1: holeh = h„          found = 1„     END IF„END IF„h = h - 1„„IF POINT(h, v) <> 4 THEN   'can we move left?„  GOSUB setpoint    'mark and move„ELSE„  h = h + 1„  stuck = 1„END IF„LOOP UNTIL stuck = 1„„'move right„'reset flag„stuck = 0„DO„IF found = 0 THEN 'if no hole yet found then check for one„     IF POINT(h, v - 1) <> 4 THEN„          holev = v - 1: holeh = h„          found = 1„     END IF„END IF„h = h + 1„„IF POINT(h, v) <> 4 THEN   'can we move right?„  GOSUB setpoint    'mark and move„ELSE„  h = h - 1„  stuck = 1„END IF„LOOP UNTIL stuck = 1„„stuck = 0„RETURN„„„reloc:„h = holeh„v = holev„RETURN„„makeline2:„'draws a line from initial position all the way to the left and„'all the way to the right, looking for the first hole in the„'floor it can find.„„'move left„found = 0„holev = 0„holeh = 0„'look up before moving to see if there is a hole„DO„IF found = 0 THEN 'if no hole yet found then check for one„     IF POINT(h, v + 1) <> 4 THEN„          holev = v + 1: holeh = h„          found = 1„     END IF„END IF„h = h - 1„„IF POINT(h, v) <> 4 THEN   'can we move left?„  GOSUB setpoint    'mark and move„ELSE„  h = h + 1„  stuck = 1„END IF„LOOP UNTIL stuck = 1„„'move right„'reset flag„stuck = 0„DO„IF found = 0 THEN 'if no hole yet found then check for one„     IF POINT(h, v + 1) <> 4 THEN„          holev = v + 1: holeh = h„          found = 1„     END IF„END IF„h = h + 1„„IF POINT(h, v) <> 4 THEN   'can we move right?„   GOSUB setpoint          'mark and move„ELSE„  h = h - 1„  stuck = 1„END IF„„LOOP UNTIL stuck = 1„„stuck = 0„„RETURN„„Isaac Grover                   LINE BOUNCER                   FidoNet QUIK_BAS Echo          03-18-96 (01:09)       QB, QBasic, PDS        25   1112     LNBOUNCE.BASSCREEN 12: RANDOMIZE TIMER„Row1% = INT(RND * 473) + 1: Column1% = INT(RND * 633) + 1„Row2% = INT(RND * 473) + 1: Column2% = INT(RND * 633) + 1„ChangeInRow1% = 1: ChangeInColumn1% = 1„ChangeInRow2% = 1: ChangeInColumn2% = 1„DO UNTIL INKEY$ <> ""„  LINE (Column1%, Row1%)-(Column2%, Row2%), 10„  IF Row1% <= 0 THEN ChangeInRow1% = -ChangeInRow1%„  IF Row1% >= 480 THEN ChangeInRow1% = -ChangeInRow1%„  IF Row2% <= 0 THEN ChangeInRow2% = -ChangeInRow2%„  IF Row2% >= 474 THEN ChangeInRow2% = -ChangeInRow2%„  IF Column1% <= 0 THEN ChangeInColumn1% = -ChangeInColumn1%„  IF Column1% >= 634 THEN ChangeInColumn1% = -ChangeInColumn1%„  IF Column2% <= 0 THEN ChangeInColumn2% = -ChangeInColumn2%„  IF Column2% >= 634 THEN ChangeInColumn2% = -ChangeInColumn2%„  OldColumn1% = Column1%: OldRow1% = Row1%„  OldColumn2% = Column2%: OldRow2% = Row2%„  Column1% = Column1% + ChangeInColumn1%„  Row1% = Row1% + ChangeInRow1%„  Column2% = Column2% + ChangeInColumn2%„  Row2% = Row2% + ChangeInRow2%„  FOR Delay% = 1 TO 5000: NEXT„  LINE (OldColumn1%, OldRow1%)-(OldColumn2%, OldRow2%), 0„LOOP: SYSTEM„„Mathew Robertson               WRITE 640X480X16 .BMP FILES    FidoNet QUIK_BAS Echo          03-28-96 (17:45)       QB, QBasic, PDS        72   2834     SAVEBMP.BAS 'Programed by: Mathew Robertson    '1994„'This Is a very easy example of how to write 640x480x16 windows„'Bitmap files. It should not be that hard to change to make it„'accept other sizes. The code is not commented to well so to„'make such changes it will reguire abit of knowledge on the„'subject and the time to make the changes, Unfortunaly I do„'not have the time to do so. Other possible changes would be„'to use direct memory access to read the screen instead of point„'which is rather slow. This type of change would make it work„'faster on slower systems.„'Anyone who does want to make the changes and has the time„'to do so, go ahead. The one Restriction is if you improve on„'the code that I get a copy of the modified code.„'This code is slow so if it looks like it has stopped its still going„'just after the original screen draw there is no more visual output.„'when finished running pop into your favorite graphics viewer that„'supports this format (most do support windows bitmaps)„'--------------------------------<cut here>----------------------------------„'Set the screen mode clear screen„SCREEN 12: CLS„'Set up variables„DIM B(1345), a&(16): kur = 0„'the name of the file to use to save the screen two„file$ = "test2.bmp"„'well this one is sort of self explainitory„RANDOMIZE TIMER„'Get some new colors„FOR i = 0 TO 15„a&(i) = INT(RND * 64) + INT(RND * 64) * 256 + INT(RND * 64) * 65536„NEXT„'Change the palette„PALETTE USING a&(0)„'Draw something pretty on the screen„FOR i = 20 TO 400: CIRCLE (320, 240), i, i AND 15: NEXT„'Well since we like are picture so much lets save it as a Windows Bitmap„GOSUB SAVEASwBMP„'end the program„END„SAVEASwBMP: 'the main save routines„'open the file up to save to.„OPEN file$ FOR OUTPUT AS #1„'Select the Windows Bitmap data„RESTORE wbmpdata„'place the Windows Bitmap data into the file header„FOR i = 0 TO 53: READ a: PRINT #1, CHR$(a); : NEXT„'Place the colors used in the picture into the file header„FOR i = 0 TO 15„PRINT #1, CHR$(((a&(kur + i) AND 65536 * 63) / 65536) * 4);„PRINT #1, CHR$(((a&(kur + i) AND 256 * 63) / 256) * 4);„PRINT #1, CHR$((a&(kur + i) AND 63) * 4);„PRINT #1, CHR$(0);„NEXT„'make sure the variable point$ has nothing in it„point$ = ""„'start a loop for the y value„FOR i = 479 TO 0 STEP -1„'start a loop for the x value„FOR j = 0 TO 639 STEP 2„'collect and store color data„point$ = point$ + CHR$(POINT(j, i) * 16 + POINT(j + 1, i))„NEXT„'write color data to file„PRINT #1, point$; : point$ = ""„NEXT„'close file„CLOSE : RETURN„'information for the file header of a windows 16 color bitmap„wbmpdata:„DATA 66,77,118,88,2,0,0,0 : DATA 0,0,118,0,0,0,40,0„DATA 0,0,128,2,0,0,224,1,0 : DATA 0,1,0,4,0,0,0,0,0,0„DATA 88,2,0,132,61,0,0,132 : DATA 61,0,0,0,0,0,0,0,0,0: DATA 0,0,0,0„„Stephan Doughty                GRAVITY LINES                  hbj@pop.ntplx.net              04-12-96 (14:36)       QB, QBasic, PDS        35   2337     GRAVLINE.BAS'Written By Stephen Doughty„'Watch, learn, play, enjoy.„„5 REM Gravline.BAS„10 K = 35: S = 7: I = 1                         'K must be a multiple of 7„15 RANDOMIZE TIMER„20 DEF FNR = (INT(RND * 5) + 5)                 'Line separation„30 DEF FNZ = (INT((RND * 2) + 1) * 2 - 3)       'Makes -1 or 1„40 DIM X(K): DIM Y(K): DIM A(K): DIM B(K): DIM H(S): DIM C(S)„50 FOR Q = 0 TO 6: READ C(Q): H(Q) = K * (S - Q) / S: NEXT Q     'Loads line separation array with data„60 DATA 0,4,6,14,2,1,5                       „70 X = INT(RND * 640) + 1: XB = FNR * FNZ       'Picks X,Y and A,B points„80 Y = INT(RND * 480) + 1: YB = FNR * FNZ       'and line step values„90 A = INT(RND * 640) + 1: AB = FNR * FNZ„100 B = INT(RND * 480) + 1: BB = FNR * FNZ„110 G1 = FNZ: G2 = FNZ                          'Gravity (- or +)„120 SCREEN 12„130 M = X - A: N = Y - B: XY = (M * M + N * N): IF XY < 10 THEN G1 = -G1: G2 = -G2          'Lines 130-150 are a Gravity routine„140 XB = XB - 100 * (G1 * M + XB / 3) / XY: YB = YB - 100 * (G1 * N + YB / 3) / XY„150 AB = AB - 100 * (G2 * M + AB / 3) / XY: BB = BB - 100 * (G2 * N + BB / 3) / XY„160 IF X + XB < 0 OR X + XB > 640 THEN XB = -SGN(XB) * FNR: YB = YB * FNZ: G1 = -SGN(G1)    'Checks for edges of screen„170 IF Y + YB < 0 OR Y + YB > 480 THEN YB = -SGN(YB) * FNR: XB = XB * FNZ: G1 = -SGN(G1)    'if off screen then change line variable„180 IF A + AB < 0 OR A + AB > 640 THEN AB = -SGN(AB) * FNR: BB = BB * FNZ: G2 = -SGN(G2)    'and change gravity„190 IF B + BB < 0 OR B + BB > 480 THEN BB = -SGN(BB) * FNR: AB = AB * FNZ: G2 = -SGN(G2)„200 X = X + XB: Y = Y + YB: A = A + AB: B = B + BB      'Adds movement variables to XY coordinates„210 X(I) = X: Y(I) = Y: A(I) = A: B(I) = B              'Puts points in an array„220 I = I + 1 + ((I = K) * K)                           'increments point array„230 FOR Q = 6 TO 0 STEP -1                              'for next loop for color and erase„240 J = I + H(Q) + (I + H(Q) > K) * K                   'Divides array for color change„250 LINE (X(J), Y(J))-(A(J), B(J)), C(Q)„260 LINE (640 - X(J), 480 - Y(J))-(640 - A(J), 480 - B(J)), C(Q)„270 LINE (X(J), 480 - Y(J))-(A(J), 480 - B(J)), C(Q)„280 LINE (640 - X(J), Y(J))-(640 - A(J), B(J)), C(Q)„290 NEXT Q„300 IF INKEY$ <> "" THEN END ELSE 130                   'Used to escape„Stephan Doughty                BOUNCING LINES IN 3D BOX       hbj@pop.ntplx.net              04-11-96 (13:51)       QB, QBasic, PDS        83   4971     BOWBOX.BAS  'This program is the first I have writen in 15 years. This explains the archaic„'code used. You may play with it any way you please. I will try to explain it„'with REM statements. It is a try at displaying three dots (xyz axis) and bouncing„'them around a three-D cube. I have also tried to implement a kind of gravity„'factor for each dot (- or +). the palette is played with also. And an attempt at„'making the lines "fade" as they grow "old". Have fun, Stephen Doughty„'To contact me please use email address, hbj@ntplx.net (its a work address)„10 REM BOWBOX.BAS                 'program name„20 K = 6 * 4: S = 6: I = 1        'K must be a multiple of 6 to work properly„30 RANDOMIZE TIMER: SCREEN 12     'sets SCREEN and RND„40 DEF FNR = RND * 4 + 4          'determines line spacing„50 DEF FNZ = INT((RND * 2) + 1) * 2 - 3       'Picks a number (-1 or 1)„60 DIM X(K): DIM Y(K): DIM Z(K): DIM A(K): DIM B(K): DIM C(K) 'XYZ ABC PQR are for holding line cordinates„70 DIM P(K): DIM Q(K): DIM R(K): DIM H(S)                     'H is for line redraw for fading lines„80 FOR H = 1 TO 6: H(H) = K * (S - H) / S: NEXT H             'sets up line spacing using K„86 FOR S = 1 TO 13 STEP 3                          'Loads palettes for each line„88 PALETTE S, (S + 3) * 4 - 1                      'Red„90 PALETTE S + 1, (S + 2) * 4 + (S + 2) * 4 * 256  'Green„92 PALETTE S + 2, (S + 1) * 4 * 65536              'Blue„96 NEXT S„100 X = RND * 300 + 1: XB = FNR * FNZ              'Picks line coordinates for„110 Y = RND * 300 + 1: YB = FNR * FNZ              'XYZ ABC PQR and there movement factor„120 Z = RND * 300 + 1: ZB = FNR * FNZ„130 A = RND * 300 + 1: AB = FNR * FNZ„140 B = RND * 300 + 1: BB = FNR * FNZ„150 C = RND * 300 + 1: CB = FNR * FNZ„160 P = RND * 300 + 1: PB = FNR * FNZ„170 Q = RND * 300 + 1: QB = FNR * FNZ„180 R = RND * 300 + 1: RB = FNR * FNZ„190 G1 = FNZ: G2 = FNZ: G3 = FNZ                   'Initializes Gravity for each dot (- or +)„210 M1 = X - A: N1 = Y - B: O1 = Z - C             '210 to 260 set variables for gravity routine„220 M2 = X - P: N2 = Y - Q: O2 = Z - R„230 M3 = A - P: N3 = B - Q: O3 = A - R„240 XYZ = SQR(M1 * M1 + N1 * N1 + O1 * O1)„250 ABC = SQR(M2 * M2 + N2 * N2 + O2 * O2)„260 PQR = SQR(M3 * M3 + N3 * N3 + O3 * O3)„270 IF XYZ < 10 THEN G1 = -G1: G2 = -G2            'If dots are to close together then change gravity„280 IF ABC < 10 THEN G1 = -G1: G3 = -G3„290 IF PQR < 10 THEN G2 = -G2: G3 = -G3„300 XB = XB - G1 * (M1 + M2) / (XYZ + ABC)         ' Gravity routine (I think)„310 YB = YB - G1 * (N1 + N2) / (XYZ + ABC)         ' May not be correct„320 ZB = ZB - G1 * (O1 + O2) / (XYZ + ABC)„330 AB = AB - G2 * (M1 + M3) / (XYZ + PQR)„340 BB = BB - G2 * (N1 + N3) / (XYZ + PQR)„350 CB = CB - G2 * (O1 + O3) / (XYZ + PQR)„360 PB = PB - G3 * (M2 + M3) / (ABC + PQR)„370 QB = QB - G3 * (N2 + N3) / (ABC + PQR)„380 RB = RB - G3 * (O2 + O3) / (ABC + PQR)„390 IF X + XB < 0 OR X + XB > 300 THEN XB = -SGN(XB) * FNR: G1 = -G1    'Checks for out-of-bounds„400 IF Y + YB < 0 OR Y + YB > 300 THEN YB = -SGN(YB) * FNR: G1 = -G1    'if so, it changes movement factor„410 IF Z + ZB < 0 OR Z + ZB > 300 THEN ZB = -SGN(ZB) * FNR: G1 = -G1    'and gravity„420 IF A + AB < 0 OR A + AB > 300 THEN AB = -SGN(AB) * FNR: G2 = -G2„430 IF B + BB < 0 OR B + BB > 300 THEN BB = -SGN(BB) * FNR: G2 = -G2„440 IF C + CB < 0 OR C + CB > 300 THEN CB = -SGN(CB) * FNR: G2 = -G2„450 IF P + PB < 0 OR P + PB > 300 THEN PB = -SGN(PB) * FNR: G3 = -G3„460 IF Q + QB < 0 OR Q + QB > 300 THEN QB = -SGN(QB) * FNR: G3 = -G3„470 IF R + RB < 0 OR R + RB > 300 THEN RB = -SGN(RB) * FNR: G3 = -G3„480 X = X + XB: Y = Y + YB: Z = Z + ZB        'Adds line and movement factor together„490 A = A + AB: B = B + BB: C = C + CB„500 P = P + PB: Q = Q + QB: R = R + RB„510 X(I) = X: Y(I) = Y: Z(I) = Z              'Remembers lines in array„520 A(I) = A: B(I) = B: C(I) = C              'for fade routine and„530 P(I) = P: Q(I) = Q: R(I) = R              'erase„540 I = I + 1 + ((I = K) * K)                 'Cycles line by adding one, if >K then (1) again„545 GOSUB 1000: S = 16                        'Gosub 1000 refreshes cube. S is palette information„550 FOR H = 1 TO 6„560 J = I + H(H) + (I + H(H) > K) * K         'Which line fades next„565 S = S - 1„580 LINE (X(J) + Z(J) / 2, Y(J) + Z(J) / 2)-(A(J) + C(J) / 2, B(J) + C(J) / 2), S„585 S = S - 1 - (S = 0)„590 LINE (A(J) + C(J) / 2, B(J) + C(J) / 2)-(P(J) + R(J) / 2, Q(J) + R(J) / 2), S„595 S = S - 1 - (S = 0)„600 LINE (P(J) + R(J) / 2, Q(J) + R(J) / 2)-(X(J) + Z(J) / 2, Y(J) + Z(J) / 2), S„610 NEXT H„620 IF INKEY$ <> "" THEN END ELSE 210         'if any key then stop„1000 COLOR 7                                  'Subroutine for cube„1010 LINE (0, 0)-(300, 300), , B„1050 LINE (150, 150)-(450, 450), , B„1090 LINE (0, 0)-(150, 150)„1100 LINE (0, 300)-(150, 450)„1110 LINE (300, 300)-(450, 450)„1120 LINE (300, 0)-(450, 150)„1130 RETURN„Richard Dale                   FLYING BEES & WASP             FidoNet QUIK_BAS Echo          04-21-96 (09:47)       QB, QBasic, PDS        90   3442     FLYBEES.BAS ' Works best when number of bees is 5 to 100 in INPUT statement for a„' 386, slightly higher on 486.  Experiment, though.  A really high„' number can provide a visual excitement, though may take some time to„' set up the display.  May not run on CGA.  All I have is VGA.„DECLARE SUB wasp (wx%(), wy%())„DECLARE SUB bees (wx%(), wy%(), x%(), y%(), xv%(), yv%(), bcolor%)„DEFINT A-Z„COMMON SHARED winW, winH, winX, winY, border, NoBees„DEFLNG T: CLS„INPUT "Number of bees (1 to 10000)"; NoBees„IF NoBees < 1 OR NoBees > 10000 THEN RUN„SCREEN 12: RANDOMIZE TIMER: CLS„DIM wx(0 TO 2): DIM wy(0 TO 2)„DIM x(0 TO 2, 1 TO NoBees): DIM y(0 TO 2, 1 TO NoBees)„DIM xv(1 TO NoBees): DIM yv(1 TO NoBees)„winW = 0: winH = 0: winX = 0: winY = 0: maxx = 640: maxy = 480„' wasp will not go closer than this to the edges„    border = INT(RND * 75): winW = maxx: winH = maxy„' Initialize the wasp„    wx(0) = 640 / 2: wy(0) = 480 / 2: wx(1) = wx(0): wy(1) = wy(0)„'Initialize the bees„    FOR b = 1 TO NoBees„        x(0, b) = INT(RND * winW): x(1, b) = x(0, b)„        y(0, b) = INT(RND * winH): y(1, b) = y(0, b)„        xv(b) = 7 * (RND - .5): yv(b) = 7 * (RND - .5)„    NEXT b„    bcolor = 9: t1 = TIMER„    DO UNTIL INKEY$ <> ""„    CALL wasp(wx(), wy()):CALL bees(wx(), wy(), x(), y(), xv(), yv(), bcolor)„' change bee colors„    IF TIMER - t1 > 2 THEN„        bcolor = bcolor + 1„        IF bcolor = 14 THEN bcolor = 9„        t1 = TIMER„    END IF„    LOOP: SCREEN 0„END„DEFINT T„SUB bees (wx(), wy(), x(), y(), xv(), yv(), bcolor)„' Do not let things settle down„    bb = INT(NoBees * RND + 1)„    xv(bb) = xv(bb) + (RND - .5) * 3: yv(bb) = yv(bb) + (RND - .5) * 3„FOR b = 1 TO NoBees„' Age position arrays„    x(2, b) = x(1, b): y(2, b) = y(1, b)„    x(1, b) = x(0, b): y(1, b) = y(0, b)„    dx = wx(1) - x(1, b): dy = wy(1) - y(1, b)„    distance = ABS(dx) + ABS(dy)    ' Approximation„    IF distance = 0 THEN distance = 1„    bee.acc = 3„' Accelerate„    xv(b) = xv(b) + dx * bee.acc / distance„    yv(b) = yv(b) + dy * bee.acc / distance„    bee.vel = 11„' Speed Checks„    IF xv(b) > bee.vel THEN xv(b) = bee.vel„    IF xv(b) < -bee.vel THEN xv(b) = -bee.vel„    IF yv(b) > bee.vel THEN yv(b) = bee.vel„    IF yv(b) < -bee.vel THEN yv(b) = -bee.vel„' Move the bees„    x(0, b) = x(1, b) + xv(b): y(0, b) = y(1, b) + yv(b)„    LINE (x(1, b), y(1, b))-(x(2, b), y(2, b)), 0„    LINE (x(0, b), y(0, b))-(x(1, b), y(1, b)), bcolor„NEXT b„END SUB„SUB wasp (wx(), wy()) STATIC„' Age the arrays„    wx(2) = wx(1): wx(1) = wx(0): wy(2) = wy(1): wy(1) = wy(0)„' Accelerate (bias random variable to ensure wasp convers entire screen)„    wasp.acc = 5„    wxv = wxv + INT((RND - .4) * wasp.acc)„    wyv = wyv + INT((RND - .4) * wasp.acc)„' Speed limit checks„    wxv.max = INT(RND * 30) + 20: wyv.max = INT(RND * 30) + 20„    IF wxv > wxv.max THEN wxv = wxv.max„    IF wxv < -wxv.max THEN wxv = -wxv.max„    IF wyv > wyv.max THEN wyv = wyv.max„    IF wyv < -wyv.max THEN wyv = -wyv.max„' Move wasp„    wx(0) = wx(1) + wxv: wy(0) = wy(1) + wyv„' Bounce checks„    IF wx(0) < border OR wx(0) > winW - border - 1 THEN„        wxv = -wxv: wx(0) = wx(0) + wxv„    END IF„    IF wy(0) < border OR wy(0) > winH - border - 1 THEN„        wyv = -wyv: wy(0) = wy(0) + wyv„    END IF„    LINE (wx(1), wy(1))-(wx(2), wy(2)), 0„    LINE (wx(0), wy(0))-(wx(1), wy(1)), 15„END SUB„Cam Spowart                    A STAR FIELD                   slyboots@supernet.ab.ca        04-30-96 (06:36)       QB, QBasic, PDS        62   1267     STARS.BAS   SCREEN 12: CLS„„DIM x(1 TO 50) AS INTEGER„DIM y(1 TO 50) AS INTEGER„DIM xinc(1 TO 50) AS SINGLE„DIM yinc(1 TO 50) AS SINGLE„xcenter = 320„ycenter = 240„FOR a = 1 TO 50 STEP 1„RANDOMIZE TIMER„'x(a) = INT(RND * 32) + 304„'y(a) = INT(RND * 20) + 229„x(a) = xcenter„y(a) = ycenter„xinc(a) = RND * 1„yinc(a) = RND * 1„neg = INT(RND * 2)„neg1 = INT(RND * 2)„IF neg = 0 THEN xinc(a) = xinc(a)„IF neg = 1 THEN xinc(a) = xinc(a) * -1„IF neg1 = 1 THEN yinc(a) = yinc(a)„IF neg1 = 1 THEN yinc(a) = yinc(a) * -1„NEXT a„„DO UNTIL INKEY$ = " "„„getbackin:„FOR b = 1 TO 50 STEP 1„PSET (x(b), y(b)), 0„„x(b) = x(b) + xinc(b)„y(b) = y(b) + yinc(b)„„IF x(b) < 0 OR x(b) > 639 OR y(b) < 0 OR y(b) > 479 THEN GOTO revamp„PSET (x(b), y(b)), 15„xinc(b) = xinc(b) * 1.01„yinc(b) = yinc(b) * 1.01„„NEXT b„„LOOP„SCREEN 0„CLS„END„„revamp:„'x(b) = INT(RND * 32) + 304„'y(b) = INT(RND * 20) + 229„x(b) = xcenter„y(b) = ycenter„xinc(b) = RND * 5„yinc(b) = RND * 5„neg = INT(RND * 2)„neg1 = INT(RND * 2)„IF neg = 0 THEN xinc(b) = xinc(b)„IF neg = 1 THEN xinc(b) = xinc(b) * -1„IF neg1 = 1 THEN yinc(b) = yinc(b)„IF neg1 = 1 THEN yinc(b) = yinc(b) * -1„PSET (x(b), y(b)), 0„'CIRCLE (320, 240), 15, 1„'PAINT (320, 240), 9„GOTO getbackin„Tika Carr                      GRAPHICAL USER INTERFACE 1.01  FidoNet QUIK_BAS Echo          05-02-96 (00:00)       QB, PDS                362  8528     GUI101.BAS  ' Graphical User Interface V. 1.01„' Written by Tika Carr„' Released into the Public Domain on November 4, 1995„' Please keep me posted on any changes you make, so I can add them on too.„' E-Mail: (as of 5/2/96, Internet E-mail Address is pending)„' FidoNet: 1:2613/601„„' Bug Fixes:„'„' May 2, 1996 v. 1.01 - Fixed Menu Flipping when holding mouse button„'                       on a menu button. Thank You to Justin Pasher„'                       for the code fix and ClearMouse Sub.„„„DECLARE SUB Mouse2 ()„DECLARE SUB Overlay (x1%, y1%, x2%, y2%, Klr%, OFlg%)„DECLARE SUB OvrWin (x1%, y1%, x2%, y2%, Klr%)„DECLARE SUB Mouse ()„DECLARE SUB ClearMouse ()„DECLARE SUB CircleBtn ()„DECLARE SUB VScreen (x1%, y1%, x2%, y2%, Bkgn%)„DECLARE SUB startmouse ()„DECLARE SUB showmouse ()„DECLARE SUB getmousecord (btn%, M3%, M4%)„DECLARE SUB hidemouse ()„DECLARE SUB MakeButton (P$, XL%, KKr%, KKh%)„DECLARE SUB ButtonDraw ()„DECLARE SUB gprint (S$, x%, y%, Klr%)„„' This uses VGA graphics mode 12:  640 x 480/16 color, 80 x 60 text area„„DEFINT A-Z„'$INCLUDE: 'QB.BI'„„TYPE COORD„ bx1 AS INTEGER„ bx2 AS INTEGER„ Flag AS INTEGER„END TYPE„„DIM SHARED Inregs AS RegType, Outregs AS RegType„DIM SHARED Buttons(1 TO 9) AS COORD„COMMON SHARED BN, Flg, Bkgn, VW, CFlag, PI, x, y, btn„PI = 3.141593„„„SCREEN 12: CLS„WIDTH 80, 60„„'Possible Palettes:„„'PALETTE 0, (65536 * 47 + 256 * 47 + 47) ' Grey Background„PALETTE 0, (65536 * 45 + 256 * 45 + 63)  ' Baby Pink Background„'PALETTE 0, (65536 * 57 + 256 * 57 + 57)  ' White Background„'PALETTE 0, (65536 * 50 + 256 * 47 + 0)   ' Cyan Background„„'Help Button Hide/Display default„„HideHelp = 0: CFlag = 1„„'Circle Button for Help - 0 is 'Display (don't hide)„„IF HideHelp = 0 THEN„ CALL CircleBtn„END IF„„'Syntax: MakeButton(Title, XLocation(LOCATE), Text Color, Highlight Color)„„'NOTE: Flg=1 is button is "out"; Flg=0 is button is "in"„„BN = 2: Flg = 1: CALL MakeButton("File", 8, 8, 1)„„' NOTE: Bkgn MUST be LESS than 8 (Bkgn values must be 0-7)„'       Other combinations may or may not work.  Test values before„'       using them.  GPRINT uses a BIOS video write to put text on screen.„„'Syntax: VScreen(x1, y1, x2, y2, Bkgn)„„CALL VScreen(0, 30, 639, 479, 7)„VW = 1: CALL gprint("Hello", 45, 23, 6)  'VW is view window is "on" for GPRINT„„startmouse„showmouse„„'Start Input„„Inloop:„„ClearMouse„Mouse„IF btn = 2 THEN GOTO Done„„'Check Mouse Coordinates„„'Help Button„„IF x < 21 AND y < 21 THEN„ x1 = 314: y1 = 153: x2 = 554: y2 = 394: Klr = 3„ ga = 4 + INT(((x2 - x1 + 1) * (1) + 7) / 8) * 4 * ((y2 - y1) + 1)„ DIM OvScn(1 TO ga) AS INTEGER„ GET (x1, y1)-(x2, y2), OvScn„ CFlag = 0„ CALL CircleBtn„ CALL OvrWin(x1, y1, x2, y2, Klr)„ CALL gprint("This is the Help Screen.", 42, 23, 2)„ CALL gprint("Click Mouse to Continue.", 42, 25, 13)„ ClearMouse„ Mouse„ hidemouse„ PUT (x1, y1), OvScn, PSET„ ERASE OvScn„ showmouse„ CFlag = 1„ CALL CircleBtn„END IF„„' File Menu Activated.„„IF x >= 51 AND y >= 2 AND x <= 90 AND y <= 18 THEN„ Flg = 0„ ButtonDraw„   „ x1 = 32: y1 = 34: x2 = 115: y2 = 146: Klr = 3„ ga = 4 + INT(((x2 - x1 + 1) * (1) + 7) / 8) * 4 * ((y2 - y1) + 1)„ DIM OvScn(1 TO ga) AS INTEGER„ GET (x1, y1)-(x2, y2), OvScn„ VW = 1: OFlg = 1„ CALL Overlay(x1, y1, x2, y2, Klr, OFlg)„ CALL gprint("New", 5, 2, 13)„ CALL gprint("Open", 5, 4, 13)„ CALL gprint("Save", 5, 6, 13)„ CALL gprint("Save As..", 5, 8, 13)„ CALL gprint("Print", 5, 10, 13)„ CALL gprint("Exit", 5, 12, 13)„ ClearMouse„ Mouse„   „ 'Exit Option„„ mx1 = 35: my1 = 123: mx2 = 112: my2 = 138: mKlr = 3: mOFlg = 0„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„  hidemouse„ CALL Overlay(mx1, my1, mx2, my2, mKlr, mOFlg)„  CALL gprint("Exit", 5, 12, 1)„  showmouse„  Mouse2„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„  END„ ELSE„ GOTO DDN„ END IF„ END IF„„ 'Print Option„„ 'The mx values are 16 less that that of the Exit option„ '(8 pixels/row so since they are every other row, 8 * 2 = 16)„„ mx1 = 35: my1 = 107: mx2 = 112: my2 = 122: mKlr = 3: mOFlg = 0„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„  hidemouse„ CALL Overlay(mx1, my1, mx2, my2, mKlr, mOFlg)„ „  'Note here we change gprint to reflect the Print option and its„  'y coordinate location.„ „  CALL gprint("Print", 5, 10, 1)„  showmouse„  Mouse2„ IF x > mx1 AND x < mx2 AND y > my1 AND y < my2 THEN„ „  'Action for Print Option goes here.„„ ELSE„ GOTO DDN„ END IF„ END IF„DDN:„  hidemouse„  PUT (x1, y1), OvScn, PSET„  showmouse„  ERASE OvScn„   „  Flg = 1„  ButtonDraw„„END IF„„GOTO Inloop„„Done:„„'Pause Display and Wait for Keypress„'Pause$ = INPUT$(1)„„hidemouse„„SUB ButtonDraw„hidemouse„yb = Buttons(BN).bx2 - Buttons(BN).bx1„IF Flg = 1 THEN k1 = 15: k2 = 8 ELSE k1 = 8: k2 = 15„DRAW "C" + STR$(k1) + "BM" + STR$(Buttons(BN).bx1) + ",18U15R" + STR$(yb)„DRAW "C" + STR$(k2) + "BM" + STR$(Buttons(BN).bx1) + ",18R" + STR$(yb) + "U15"„showmouse„END SUB„„SUB CircleBtn„   „hidemouse„ LINE (9, 0)-(11, 11), 0, BF„ CIRCLE (10, 11), 10, 8„ PAINT (10, 11), 12, 8„ IF CFlag = 1 THEN c1 = 15: c2 = 8 ELSE c1 = 8: c2 = 15„ CIRCLE (10, 11), 9, c1, 1, INT(PI + 1)„ CIRCLE (10, 11), 9, c2, INT(PI + 1), .5„„ VW = 0: CALL gprint("?", 1, 2, 3)  'Note: VW is view window ON/OFF; 0=OFF„„ 'NOTE: above colors for GPRINT: 2 is Yellow, 3 is White„ '      for last number: GPRINT($, x, y, color)„„showmouse„END SUB„„SUB ClearMouse„DO„ getmousecord btn, x, y„ LOCATE 59, 5„ PRINT x, y, btn;„„LOOP UNTIL btn = 0„„END SUB„„SUB getmousecord (btn%, M3%, M4%)„Inregs.ax% = 3„CALL INTERRUPT(&H33, Inregs, Outregs)„M3% = Outregs.cx%„M4% = Outregs.dx%„btn% = Outregs.bx%„END SUB„„SUB gprint (S$, x, y, Klr)„IF VW = 1 THEN y = y + 5„„IF Klr < 10 THEN„ Klr = Klr + 8„ B = (Bkgn XOR Klr) - 8„ELSE„ B = Bkgn XOR Klr„END IF„„IF B < 10 THEN B$ = "&HF" + HEX$(B) ELSE B$ = "&HF" + HEX$(B)„„Inregs.bx% = VAL(B$)„Inregs.cx% = 1„AH$ = "9"„„FOR count = 1 TO LEN(S$)„ A$ = MID$(S$, count, 1)„ AL$ = HEX$(ASC(A$))„ Inregs.ax% = VAL("&H" + AH$ + AL$)„ LOCATE y, x + count„ CALL INTERRUPT(&H10, Inregs, Outregs)„NEXT count„„END SUB„„SUB hidemouse„Inregs.ax% = 2„CALL INTERRUPT(&H33, Inregs, Outregs)„END SUB„„SUB MakeButton (P$, XL, KKr, KKh)„„'Highlight First Character„„PH$ = LEFT$(P$, 1): PR$ = RIGHT$(P$, LEN(P$) - 1)„COLOR KKh: LOCATE 2, XL: PRINT PH$;„COLOR KKr: PRINT PR$„„Buttons(BN).bx1 = (XL - 1) * 8 - 4„Buttons(BN).bx2 = Buttons(BN).bx1 + (LEN(P$) * 8) + 6„„LINE (Buttons(BN).bx1 - 1, 2)-(Buttons(BN).bx2 + 1, 19), 8, B„„CALL ButtonDraw„„END SUB„„SUB Mouse„„DO„ getmousecord btn, x, y„ LOCATE 59, 5„ PRINT x, y, btn;„„LOOP WHILE btn = 0„„END SUB„„SUB Mouse2„DO„ getmousecord btn, x, y„ LOCATE 59, 5„ PRINT x, y, btn;„„LOOP WHILE btn <> 0„DO„ getmousecord btn, x, y„ LOCATE 59, 5„ PRINT x, y, btn;„„LOOP WHILE btn = 0„„END SUB„„SUB Overlay (x1, y1, x2, y2, Klr, OFlg)„ IF OFlg = 1 THEN c1 = 15: c2 = 8 ELSE c1 = 8: c2 = 15„ hidemouse„ LINE (x1, y1)-(x2, y2), 8, B„ PAINT (x1 + 1, y1 + 1), Klr, 8„ DRAW "c" + STR$(c1) + "bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "U" + STR$(y2 - y1 - 2) + "R" + STR$(x2 - x1 - 2)„ DRAW "c" + STR$(c2) + "bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "R" + STR$(x2 - x1 - 2) + "U" + STR$(y2 - y1 - 2)„ showmouse„END SUB„„SUB OvrWin (x1, y1, x2, y2, Klr)„„A = x1 + 1: B = y2 - 1: C = y2 - y1 - 2„E = x1 + 9: F = y2 - 9: G = y2 - y1 - 18„„LINE (x1, y1)-(x2, y2), 8, B„PAINT (x1 + 10, y1 + 10), Klr, 8„„LINE (x1 + 8, y1 + 9)-(x2 - 8, y2 - 8), 8, B„PAINT (x1 + 10, y1 + 10), Klr, 8„„DRAW "C15BM" + STR$(A) + "," + STR$(B) + "U" + STR$(C) + "R" + STR$(C)„DRAW "C8BM" + STR$(A) + "," + STR$(B) + "R" + STR$(C - 1) + "U" + STR$(C - 1)„DRAW "C8BM" + STR$(E) + "," + STR$(F) + "U" + STR$(G) + "R" + STR$(G)„DRAW "C15BM" + STR$(E) + "," + STR$(F - 1) + "R" + STR$(G - 1) + "U" + STR$(G - 1)„„END SUB„„SUB showmouse„Inregs.ax% = 1„CALL INTERRUPT(&H33, Inregs, Outregs)„END SUB„„SUB startmouse„Inregs.ax% = 0„CALL INTERRUPT(&H33, Inregs, Outregs)„MouseInitialize% = Outregs.ax%„END SUB„„SUB VScreen (x1, y1, x2, y2, Bkgn)„LINE (x1, y1)-(x2, y2), 8, B„PAINT (x1 + 1, y1 + 1), Bkgn, 8„DRAW "c8bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "u" + STR$(y2 - y1) + "r" + STR$(x2 - x1)„DRAW "c15bm" + STR$(x1 + 1) + "," + STR$(y2 - 1) + "r" + STR$(x2 - x1 - 2) + "u" + STR$(y2 - y1)„END SUB„Matt E. Hart                   3D GRAPHIC ROUTINES            charlie@charlie.seanet.com     04-12-95 (09:24)       QB, QBasic, PDS        170  4254     ROTATE.BAS  ' Rotate.bas by Matt E. Hart„'„' One alternate image of a star polygon is included.  Just RESTORE„' to CUBE or STAR in the line just below INIT:„'„SCREEN 9„REDIM acos!(0 TO 359)„REDIM asin!(0 TO 359)„CPi = 3.141592654# / 180„FOR i = 0 TO 359„    acos!(i) = COS(i * CPi)„    asin!(i) = SIN(i * CPi)„NEXT„GOSUB Init„DO„    GOSUB ShowIt„    a$ = INKEY$„    IF LEN(a$) = 0 THEN GOTO Skip„    KeyPress = ASC(RIGHT$(a$, 1))„    IF LEN(a$) = 2 THEN KeyPress = -KeyPress„    SELECT CASE KeyPress„        CASE 27: EXIT DO                        ' Escape„        CASE 45, 95                             ' -_„            IF S > 1 THEN S = 1„            S = S - .01„        CASE 43, 61                             ' +=„            IF S < 1 THEN S = 1„            S = S + .01„        CASE -72, 56                            ' Up arrow, 8„            XA = XA + 1: IF XA > 359 THEN XA = 0„        CASE -80, 50                            ' Dn„            XA = XA - 1: IF XA < 0 THEN XA = 359„        CASE -75, 52                            ' Left, 4„            ZA = ZA + 1: IF ZA > 359 THEN ZA = 0„        CASE -77, 54                            ' Right, 6„            ZA = ZA - 1: IF ZA < 0 THEN ZA = 359„        CASE 55                                 ' 7„            YA = YA + 1: IF YA > 359 THEN YA = 0„        CASE 57                                 ' 9„            YA = YA - 1: IF YA < 0 THEN YA = 359„        CASE 32: GOSUB Init                     ' Space (reset)„    END SELECT„Skip:„LOOP„SCREEN 0„END„Init:„    CLS„    RESTORE CUBE„    READ n„    REDIM x(1 TO n), y(1 TO n), z(1 TO n)„    REDIM xe(1 TO n), ye(1 TO n)„    FOR i = 1 TO n„        READ x(i), y(i), z(i)„    NEXT„    READ XF, YF, ZF„    READ XO, YO, ZO„    S = 1„    YA = 0: XA = 0: ZA = 0„RETURN„ShowIt:„    FOR i = 1 TO n„        IF x(i) <> -1 THEN  ' use -1 X coord to define a new plane„            GOSUB RotateX„            GOSUB RotateZ„            GOSUB RotateY„            SELECT CASE KeyPress„                CASE 45, 95, 43, 61 ' scaling„                    x(i) = x(i) * S + XF * (1 - S)    ' Scaling„                    y(i) = y(i) * S + YF * (1 - S)„                    z(i) = z(i) * S + ZF * (1 - S)„            END SELECT„        END IF„    NEXT„    KeyPress = 0„    Start = -1„    FOR i = 1 TO n„        IF x(i) <> -1 THEN„            IF x(i) <> xe(i) OR y(i) <> ye(i) THEN„                IF Start THEN„                    PSET (xe(i), ye(i)), 0„                    PSET (x(i), y(i)), 15„                    Start = 0„                ELSE„                    LINE (xe(i - 1), ye(i - 1))-(xe(i), ye(i)), 0„                    LINE (x(i - 1), y(i - 1))-(x(i), y(i)), 15„                END IF„            END IF„        ELSE„            Start = -1„        END IF„    NEXT„    FOR i = 1 TO n„        xe(i) = x(i)„        ye(i) = y(i)„    NEXT„RETURN„RotateZ:„    xs = x(i)       ' preserve x(i) for the y(i) calculation„    x(i) = XO + (x(i) - XO) * acos!(ZA) + (y(i) - YO) * asin!(ZA)„    y(i) = YO + (y(i) - YO) * acos!(ZA) - (xs - XO) * asin!(ZA)„RETURN„RotateY:„    xs = x(i)„    x(i) = XO + (x(i) - XO) * acos!(YA) - (z(i) - ZO) * asin!(YA)„    z(i) = ZO + (z(i) - ZO) * acos!(YA) + (xs - XO) * asin!(YA)„RETURN„RotateX:„    ys = y(i)„    y(i) = YO + (y(i) - YO) * acos!(XA) + (z(i) - ZO) * asin!(XA)„    z(i) = ZO + (z(i) - ZO) * acos!(XA) - (ys - YO) * asin!(XA)„RETURN„CUBE:„DATA 33„DATA 100,100,100„DATA 100,200,100„DATA 200,200,100„DATA 200,100,100„DATA 100,100,100„DATA -1,-1,-1„„DATA 100,100,200„DATA 100,200,200„DATA 200,200,200„DATA 200,100,200„DATA 100,100,200„DATA -1,-1,-1„„DATA 100,100,100„DATA 100,100,200„DATA -1,-1,-1„„DATA 200,100,200„DATA 200,100,100„DATA -1,-1,-1„„DATA 200,200,100„DATA 200,200,200„DATA -1,-1,-1„DATA 100,200,200„DATA 100,200,100„DATA -1,-1,-1„„DATA 150,150,100„DATA -1,-1,-1„„DATA 100,125,125„DATA -1,-1,-1„„DATA 100,175,175„DATA -1,-1,-1„„DATA 125,125,125„DATA 175,175,175„DATA -1,-1,-1„„DATA 150,150,0„DATA 150,150,150„„STAR:„DATA 6„DATA 100,200,100„DATA 150,100,100„DATA 200,200,100„DATA 100,150,100„DATA 200,150,100„DATA 100,200,100„„DATA 150,150,0„DATA 150,150,100„Bob Ellis                      PB VGA MAZE GENERATOR/SOLVER   www.voicenet.com/~rellis/      05-16-96 (00:00)       PB                     275  6440     PBMAZE.BAS    rem - VGAMAZE2.BAS - 16 May 96 - Bob Ellis (rellis@voicenet.com)„„  rem - based on VGA Maze Generator by Steve Harmon, who commented:„„'Don't remember if I wrote this or picked it up somewhere and modified it„'for VGA. It's a little slow, but it works.„„  rem - modified to increase speed, change aspect ratio to 1/1, solve maze„  rem - tested on a Gateway 2000 386DX25 system running under the„  rem - PowerBasic 3.20 IDE:„  rem -   33% decrease in grid size„  rem -   97% decrease in run time (using optimal starting cell)„„  DEFINT A-Z„„  x_boxes = 106  ' vertical lines - 1„  x_pixels = 6   ' pixels from 1 vertical line to the next„  x_linlen = x_boxes * x_pixels„  A = x_boxes - 1„  x_gap = x_pixels - 1„„  y_boxes = 79   ' horizontal lines -1„  y_pixels = 6   ' pixels from 1 horizontal line to the next„  y_linlen = y_boxes * y_pixels„  B = y_boxes - 1„  y_gap = y_pixels - 1„„  DIM F(A, B)„  DIM box_dat1?(A, B)„„  FORE = 7 : BACK = 0 : dead_end = 4„„Start:„  CLS„  PRINT "Maze Generator / Solver - VGA (640x480 x 16 colors)"„  PRINT„  PRINT "This program will create a 106x79 cell maze."„  PRINT„  PRINT "If you press any key before the maze is complete the program will pause,"„  PRINT " with the next keypress causing the program to return here."„  PRINT„  PRINT "When the maze is complete, you will hear a beep.  Pressing any key at this"„  PRINT " time will cause the program to begin solving the maze."„  PRINT„  PRINT "Pressing any key before the solution of the maze is complete will cause the"„  PRINT " program to pause, with the next keypress causing the program to return"„  PRINT " here."„  PRINT„  PRINT "Ready to generate a maze (Y/N): ";„„  LOCATE , , 1„  DO„    DO„      a$ = INKEY$„    LOOP UNTIL a$ <> ""„    SELECT CASE UCASE$ (a$)„      CASE "Y"„        EXIT LOOP„      CASE "N"„        END„    END SELECT„    BEEP„  LOOP„„  SCREEN 12„  CLS„„  FOR Y = 0 TO y_linlen STEP y_pixels„    LINE (0,Y) - (x_linlen, Y), FORE„  NEXT Y„„  FOR X = 0 TO x_linlen STEP x_pixels„    LINE (X,0) - (X, y_linlen), FORE„  NEXT X„„  RANDOMIZE TIMER„„  FOR E = 0 TO B„    FOR D = 0 TO A„      F(D, E) = 0„      box_dat1?(D, E) = 15?„    NEXT D„  NEXT E„„  x_first = INT (x_boxes * RND (1))„  y_first = INT (y_boxes * RND (1))„  F(x_first, y_first) = 2„„  DO„    D = A„    E = -1„    last_elmt = 0„    DO„      incr D„      IF D > A THEN„        D = 0„        INCR E„        IF E > B THEN EXIT LOOP„      END IF„      ARRAY SCAN F(D, E), =2, TO elmt„      IF elmt = 0 THEN EXIT LOOP„      last_elmt = elmt„      INCR D, elmt - 1„      WHILE D > A„        DECR D, x_boxes„        INCR E„      WEND„      X = D * x_pixels„      Y = E * y_pixels„      GOSUB Check_lines„      IF INKEY$ <> "" THEN All_done„    LOOP„  LOOP UNTIL last_elmt = 0„„Set_entry_exit:„  X = 0„  E = INT (RND (1) * y_boxes)„  BIT RESET box_dat1?(0, E), 3„  Y = E * y_pixels„  LINE (X, Y + 1) - (X, Y + y_gap), BACK„„  X = x_linlen„  E = INT (RND (1) * y_boxes)„  BIT RESET box_dat1?(A, E), 1„  Y = E * y_pixels„  LINE (X, Y + 1) - (X, Y + y_gap), BACK„„  BEEP„  WHILE INKEY$ = "" : WEND„„Solve_It:„  FOR E = 0 TO B„    FOR D = 0 TO A„      i = D„      j = E„      DO„        i1 = i„        j1 = j„        GOSUB Check_4_Dead_End„      LOOP UNTIL (i = i1) AND (j = j1)„      IF INKEY$ <> "" THEN All_Done„    NEXT D„  NEXT E„„All_Done:„  BEEP„  WHILE INKEY$ = "" : WEND„  SCREEN 0„  GOTO Start„„Check_4_Dead_End:„  SELECT CASE box_dat1?(i, j) AND 15?„    CASE 14?„      box_dat1?(i, j) = 31?„      LINE ((i * x_pixels) + 1, (j * y_pixels)) _„       - ((i * x_pixels) + x_gap, (j * y_pixels) + y_gap), dead_end, BF„      DECR j„      BIT SET box_dat1?(i, j), 2„    CASE 13?„      box_dat1?(i, j) = 31?„      LINE ((i * x_pixels) + 1, (j * y_pixels) + 1) _„       - (((i + 1) * x_pixels), (j * y_pixels) + y_gap), dead_end, BF„      INCR i„      BIT SET box_dat1?(i, j), 3„    CASE 11?„      box_dat1?(i, j) = 31?„      LINE ((i * x_pixels) + 1, (j * y_pixels) + 1) _„       - ((i * x_pixels) + x_gap, ((j + 1) * y_pixels)), dead_end, BF„      INCR j„      BIT SET box_dat1?(i, j), 0„    CASE 7?„      box_dat1?(i, j) = 31?„      LINE ((i * x_pixels), (j * y_pixels) + 1) _„       - ((i * x_pixels) + x_gap, (j * y_pixels) + y_gap), dead_end, BF„      DECR i„      BIT SET box_dat1?(i, j), 1„  END SELECT„  RETURN„„Check_lines:„  todo = 0„„  IF D > 0 THEN„    SELECT CASE F(D - 1, E)„      CASE 0„        F(D - 1, E) = 1„        INCR todo„      CASE 1„        INCR todo„    END SELECT„  END IF„„  IF D < A THEN„    SELECT CASE F(D + 1, E)„      CASE 0„        F(D + 1, E) = 1„        INCR todo„      CASE 1„        INCR todo„    END SELECT„  END IF„„  IF E > 0 THEN„    SELECT CASE F(D, E - 1)„      CASE 0„        F(D, E - 1) = 1„        INCR todo„      CASE 1„        INCR todo„    END SELECT„  END IF„„  IF E < B THEN„    SELECT CASE F(D, E + 1)„      CASE 0„        F(D, E + 1) = 1„        INCR todo„      CASE 1„        INCR todo„    END SELECT„  END IF„„  IF todo = 0 THEN F(D, E) = 3 : RETURN„„  SELECT CASE CEIL(RND(1) * 4)„    CASE 1„      IF D > 0 THEN„        IF F(D - 1, E) = 1 THEN„          F(D - 1, E) = 2„          BIT RESET box_dat1?(D, E), 3„          BIT RESET box_dat1?(D - 1, E), 1„          r = X„          GOSUB Del_vert_line„        END IF„      END IF„    CASE 2„      IF D < A THEN„        IF F(D + 1, E) = 1 THEN„          F(D + 1, E) = 2„          BIT RESET box_dat1?(D, E), 1„          BIT RESET box_dat1?(D + 1, E), 3„          r = X + x_pixels„          GOSUB Del_vert_line„        END IF„      END IF„    CASE 3„      IF E > 0 THEN„        IF F(D, E - 1) = 1 THEN„          F(D, E - 1) = 2„          BIT RESET box_dat1?(D, E), 0„          BIT RESET box_dat1?(D, E - 1), 2„          s = Y„          GOSUB Del_horz_line„        END IF„      END IF„    CASE 4„      IF E < B THEN„        IF F(D, E + 1) = 1 THEN„          F(D, E + 1) = 2„          BIT RESET box_dat1?(D, E), 2„          BIT RESET box_dat1?(D, E + 1), 0„          s = Y + y_pixels„          GOSUB Del_horz_line„        END IF„      END IF„  END SELECT„  RETURN„„Del_vert_line:„  LINE (r, Y + 1) - (r, Y + y_gap), BACK„  RETURN„„Del_horz_line:„  LINE (X + 1, s) - (X + x_gap, s), BACK„  RETURN„Martin Klingensmith            USING SPRITES                  MarsbarsII@aol.com             05-18-96 (13:55)       QB, QBasic, PDS        54   1036     SPRITE.BAS  '   This is an example of using sprites in QBasic. Hasn't been tested in any„'   Other BASIC, but will most likely work.„'„'   Written by Martin Klingensmith [A.K.A. Marsbars]„'„'   MarsbarsII@aol.com (for a little while at least)„'„'„'„DIM a(500)„SCREEN 12„CLS„„DRAW "c2bm320,200 r5d5l5u5"„GET (319, 199)-(326, 206), a(1)„CLS„„DO„   FOR x = 1 TO 630„   PUT (x, 1), a(1), PSET„   DO„      a = a + 1„   LOOP WHILE a < 50„   a = 0„   a$ = INKEY$: IF a$ > "" THEN SYSTEM„   NEXT x„   FOR x = 1 TO 470„   PUT (630, x), a(1), PSET„  „   DO„      a = a + 1„   LOOP WHILE a < 50„   a = 0„   a$ = INKEY$: IF a$ > "" THEN SYSTEM„   NEXT x„„   FOR x = 630 TO 1 STEP -1„      PUT (x, 470), a(1), PSET„      DO„         a = a + 1„      LOOP WHILE a < 50„      a = 0„      a$ = INKEY$: IF a$ > "" THEN SYSTEM„   NEXT x„„   FOR x = 470 TO 1 STEP -1„      PUT (1, x), a(1), PSET„      DO„         a = a + 1„      LOOP WHILE a < 50„      a = 0„   a$ = INKEY$: IF a$ > "" THEN SYSTEM„   NEXT x„LOOP„Tika Carr                      BUTTON WORKSHOP                FidoNet QUIK_BAS Echo          05-21-96 (22:15)       QB, QBasic, PDS        129  3905     BUTTONS.BAS ' Button Workshop„' Popups, radio buttons, check boxes, buttons, frames!„' by Tika Carr 1:2613/601„' kari@rochgte.fidonet.org„'„' 5/21/96„'„' This code is part of my work on my GUI Interface, and is also hereby„' donated to the Basic Compiler Project as long as these terms are„' followed:„'„' 1. You may use this code in any of your own programs as long as you„'    put somewhere in the program where users can see it:„'      Popup (or button, check box, or whatever you used) code written„'      by Tika Carr copyright (c) 1996. Used with permission.„'    NOTE: If you do this, you always have my permission. :)„'„' 2. BASIC Compiler Project: It could read that some of the code„'    was written by me. You don't have to list what routines. Just give me„'    credit for contributing. :)„'„' 3. This code is not for COMMERCIAL use (ie. software packages sold in„'    shrinkwrapped boxes in stores) unless you contact me for arrangements„'    first.„„' *** CODE FOLLOWS ***„„DECLARE SUB drwbtn (ds!, dc!, dfs!, dfc!, dx1!, dy1!, dx2!, dy2!)„„SCREEN 12: CLS      '640 x 480 16 color VGA 80 x 30 text„„'** PALETTE ASSIGNMENT **„„FOR count = 0 TO 15„    READ b, g, r„    PALETTE count, (65536 * b + 256 * g + r)„NEXT„„'Background Color 0 = Aqua (Cyan)„DATA 42,42,0„„'1 = black      4 = white   7 = brown    10 = green      13 = blue„'2 = dk. grey   5 = pink    8 = orange   11 = dk. green  14 = dk. blue„'3 = lt. greay  6 = red     9 = yellow   12 = aqua       15 = violet„„DATA 0,0,0,21,21,21,45,45,45,63,63,63,45,45,63,20,18,63„DATA 0,26,45,0,28,63,0,55,60,8,50,8,0,24,0,42,42,0„DATA 63,26,0,50,0,0,63,0,40„„'**************** Main Examples Here *******************„„' Demo of Pop up styles„'„' Syntax:„'     drwbtn (ds!, dc!, dfs!, dfc!, dx1!, dy1!, dx2!, dy2!)„'„'ds = style, dc = color, dfs = frame size, dfc=frame color„'dx1, dy1 upper left; dx2, dy2 lower right„„CALL drwbtn(1, 3, 0, 0, 3, 3, 55, 18)       'Plain On Button„CALL drwbtn(2, 3, 0, 0, 75, 3, 121, 18)     'Plain Off Button„CALL drwbtn(3, 6, 10, 5, 3, 25, 103, 125)   'Frame Style 3 (On/Off)„CALL drwbtn(4, 3, 10, 2, 110, 25, 210, 125) 'Frame Style 4 (Off/On)„CALL drwbtn(5, 8, 10, 7, 220, 25, 320, 125) 'Frame Style 5 (On/On)„CALL drwbtn(6, 11, 10, 10, 340, 25, 440, 125)'Frame Style 6 (Off/Off)„CALL drwbtn(7, 4, 0, 0, 3, 135, 18, 150)      'Plain Check Box„CALL drwbtn(8, 4, 0, 0, 23, 135, 38, 150)    'Plain Check Box Checked„CALL drwbtn(9, 9, 8, 0, 50, 143, 0, 0)     'Radio Button„CALL drwbtn(10, 9, 8, 15, 70, 143, 0, 0)   'Radio Button On„„'Pause„Pause$ = INPUT$(1)„„'Normal Screen/End„SCREEN 0, 0, 0: COLOR 7, 0: CLS : END„„SUB drwbtn (ds, dc, dfs, dfc, dx1, dy1, dx2, dy2)„IF ds >= 3 AND ds <= 6 THEN c = dfc ELSE c = dc„SELECT CASE ds„    CASE 1: GOSUB dOn„    CASE 2: GOSUB dOff„    CASE 3: GOSUB dOn: GOSUB Inside: GOSUB dOff„    CASE 4: GOSUB dOff: GOSUB Inside: GOSUB dOn„    CASE 5: GOSUB dOn: GOSUB Inside: GOSUB dOn„    CASE 6: GOSUB dOff: GOSUB Inside: GOSUB dOff„    CASE 7: GOSUB Dsqu„    CASE 8: GOSUB Dsqu: LINE (dx1, dy1)-(dx2, dy2), 1: LINE (dx1, dy2)-(dx2, dy1), 1„    CASE 9: GOSUB Dcir„    CASE 10: GOSUB Dcir: CIRCLE (dx1, dy1), (15 - dfs) \ 2, dfc: PAINT (dx1, dy1), dfc, dfc„END SELECT„„GOTO Ddone„„Dsqu:„    LINE (dx1, dy1)-(dx2, dy2), 1, B„    PAINT (dx2 - 4, dy2 - 4), c, 1„RETURN„„DBold:„    GOSUB Dsqu„    LINE (dx1 + 1, dy1 + 1)-(dx2 - 1, dy2 - 1), 1, B„RETURN„„dOn:„    GOSUB DBold„    LINE (dx1 + 1, dy2 - 1)-(dx2 - 1, dy2 - 1), 4„    LINE -(dx2 - 1, dy1 + 1), 4„RETURN„„dOff:„    GOSUB DBold„    LINE (dx1 + 1, dy2 - 1)-(dx1 + 1, dy1 + 1), 4„    LINE -(dx2 - 1, dy1 + 1), 4„RETURN„„Dcir:„    CIRCLE (dx1, dy1), dfs, 1„    PAINT (dx1, dy1), dc, 1„RETURN„„Inside:„    dx1 = dx1 + dfs: dy1 = dy1 + dfs„    dx2 = dx2 - dfs: dy2 = dy2 - dfs„    c = dc„RETURN„„Ddone:„„END SUB„Brendan Price                  3D STEROGRAM                   Bprice@sebas.vic.edu.au        05-23-96 (13:34)       QB, QBasic, PDS        109  2838     3DSTERO.BAS 'This program creates 3d pictures like the ones in magic eye books.„'At the moment, the image is of my initials, but that can easily be„'changed. The code is EGA, small and tight, with heaps of remarks,„'for QuickBasic. Have fun!„„' 3D stereogram program„' by Brendan Price.„' Bprice@sebas.vic.edu.au„„' QuickBasic 4.5„„DECLARE SUB MakeImage ()„DECLARE SUB Randomiser ()„DECLARE SUB BoxAdd (Tlx%, Tly%, Brx%, Bry%, dep%)„DECLARE SUB DrawObject ()„„' Arrays can be made larger for better resolution, you'll need to adjust„' the drawobject routine. This was, however, the limit of my 1mb memory!„„DIM SHARED mapping(200, 100) AS INTEGER„DIM SHARED Lines(100) AS SINGLE„DIM SHARED Imager(20, 100) AS INTEGER„„„PRINT "Working . . ."„MakeImage„Randomiser„DrawObject„SLEEP  'so you can get a good look, or print it off if you want„       ' to print, simply load GRAPHICS.COM before you run this program,„       ' then use PrintScrn. It looks good even in 9-pin black and white!„„„„„' Adds a box shape to the 3D image mapping, raised above the plane„' by dep% units.„SUB BoxAdd (Tlx%, Tly%, Brx%, Bry%, dep%)„ PRINT "Adding Box . . . ."; dep%„ IF dep% = 0 THEN„  FOR x = Tlx% TO Brx%„   FOR y = Tly% TO Bry%„    mapping(x, y) = 0„   NEXT„  NEXT„ ELSE„  FOR x = Tlx% TO Brx% STEP 20„   FOR y = Tly% TO Bry%„    mapping(x, y) = dep%„   NEXT„  NEXT„ END IF„END SUB„„SUB DrawObject„' This generates the 3D image in an EGA mode„CLS : SCREEN 9„FOR x = 1 TO 199„ FOR y = 1 TO 99„  g = g + 1„  IF g = 21 THEN g = 1„  Lines(y) = Lines(y) + mapping(x, y)„  pa = x - Lines(y)„  IF pa > 0 AND pa < 180 THEN„   LINE (pa * 2, y * 2)-(pa * 2 + 1, y * 2 + 1), Imager(g, y), BF„   ' A pset function, a higher res mode and larger array sizes could„   ' be used, but will require bigger arrays and speed. Feel free to„   ' experiment yourself.„   END IF„ NEXT„NEXT„END SUB„„SUB MakeImage„' This generates the mapping of the image. This routine will„' eventually be replaced by a mouse draw routine, but in the„' meantime, it's okay to just design on paper and put the„' numbers in below.„„' BigB„BoxAdd 40, 10, 80, 90, 1„BoxAdd 50, 20, 70, 45, 0„BoxAdd 50, 55, 70, 80, 0„BoxAdd 70, 10, 80, 20, 0„BoxAdd 70, 80, 80, 90, 0„„' BigP„BoxAdd 100, 10, 140, 90, 1„BoxAdd 110, 20, 130, 45, 0„BoxAdd 110, 55, 140, 90, 0„„' Small symbol in foreground„BoxAdd 85, 30, 95, 33, 2„BoxAdd 85, 48, 95, 50, 2„BoxAdd 89, 39, 95, 41, 3„            „END SUB„„SUB Randomiser„' This creates a random plane of pixels, about 20 wide, to be repeated„' across the image. This routine could also be replaced with a mousedraw„' or perhaps even a scanned image.„RANDOMIZE„PRINT "Creating Random Plane ..."„FOR t = 1 TO 20„FOR s = 1 TO 100„Imager(t, s) = INT(RND * 15)„NEXT s, t„END SUB„Ryan White                     LINE PATTERN DESIGNS           BIGFOOT@SunBelt.Net            05-31-96 (16:26)       QB, QBasic, PDS        207  10593    DESIGNS.BAS ' Welcome one and all to Ryan's remade colored line moving thingie.„' Press F1 to make the colors change„' Press F2 to make the screen clear off„' Press F3 to change the coloring style„' Press F4 to change the finese of the lines  <==-- try and you'll figure„' Press F5 to change the shape of the lines„' Press F10 to make the lines stop forming or make them start again„' Press ESC to quit„' Have fun and please change the code all you want„„DECLARE FUNCTION nnn! ()„DECLARE FUNCTION num! ()„„DIM rox(16), gox(16), box(16)„„'this just makes the lines style not 0„style = 1: shape = 1: grad = 1„„SCREEN 12„RANDOMIZE TIMER„„ON KEY(1) GOSUB pp: KEY(1) ON„ON KEY(2) GOSUB tt: KEY(2) ON„ON KEY(3) GOSUB csty: KEY(3) ON„ON KEY(4) GOSUB inc: KEY(4) ON„ON KEY(5) GOSUB shpcng: KEY(5) ON„ON KEY(10) GOSUB stopitnow: KEY(10) ON„„GOSUB pp„„x = INT(RND * 640) + 1: xb = num * nnn„y = INT(RND * 480) + 1: yb = num * nnn„a = INT(RND * 640) + 1: ab = num * nnn„b = INT(RND * 480) + 1: bb = num * nnn„G1 = nnn„G2 = nnn        'Gravity (- or +)„„DO„IF wannaseeit = 1 THEN GOTO notgonadoit„m = x - a: N = y - b: XY = (m * m + N * N): IF XY < 10 THEN G1 = -G1: G2 = -G2„xb = xb - 100 * (G1 * m + xb / 3) / XY: yb = yb - 100 * (G1 * N + yb / 3) / XY„ab = ab - 100 * (G2 * m + ab / 3) / XY: bb = bb - 100 * (G2 * N + bb / 3) / XY„IF x + xb < 0 OR x + xb > 640 THEN xb = -SGN(xb) * num: yb = yb * nnn: G1 = -SGN(G1)„IF y + yb < 0 OR y + yb > 480 THEN yb = -SGN(yb) * num: xb = xb * nnn: G1 = -SGN(G1)„IF a + ab < 0 OR a + ab > 640 THEN ab = -SGN(ab) * num: bb = bb * nnn: G2 = -SGN(G2)„IF b + bb < 0 OR b + bb > 480 THEN bb = -SGN(bb) * num: ab = ab * nnn: G2 = -SGN(G2)„„x = x + xb / grad: y = y + yb / grad: a = a + ab / grad: b = b + bb / grad„„„SELECT CASE shape„  CASE 1„      LINE (x, y)-(a, b), c: LINE (640 - x, 480 - y)-(640 - a, 480 - b), c„      LINE (x, 480 - y)-(a, 480 - b), c: LINE (640 - x, y)-(640 - a, b), c„  CASE 2„      LINE (x, y)-(a, b), c, B: LINE (640 - x, 480 - y)-(640 - a, 480 - b), c, B„      LINE (x, 480 - y)-(a, 480 - b), c, B: LINE (640 - x, y)-(640 - a, b), c, B„  CASE 3„      CIRCLE (x, y), 3, c: CIRCLE (a, b), 3, c: CIRCLE (640 - x, 480 - y), 3, c: CIRCLE (640 - a, 480 - b), 3, c„      CIRCLE (x, 480 - y), 3, c: CIRCLE (a, 480 - b), 3, c: CIRCLE (640 - x, y), 3, c: CIRCLE (640 - a, b), 3, c„  CASE 4„    'heart 1„      LINE (x - 9, y)-(x - 6, y - 3), c: LINE -(x - 4, y - 3), c: LINE -(x - 2, y - 2), c: LINE -(x, y - 1), c: LINE -(x + 2, y - 2), c: LINE -(x + 4, y - 3), c: LINE -(x + 6, y - 3), c: LINE -(x + 8, y), c: LINE -(x + 4, y + 5), c: LINE -(x, y + 8) , c„      LINE -(x - 6, y + 4), c: LINE -(x - 8, y + 1), c: LINE (a - 9, b)-(a - 6, b - 3), c: LINE -(a - 4, b - 3), c: LINE -(a - 2, b - 2), c: LINE -(a, b - 1), c: LINE -(a + 2, b - 2), c: LINE -(a + 4, b - 3), c: LINE -(a + 6, b - 3), c„      LINE -(a + 8, b), c: LINE -(a + 4, b + 5), c: LINE -(a, b + 8), c: LINE -(a - 6, b + 4), c: LINE -(a - 8, b + 1), c„    'heart 2„      LINE (640 - (x - 9), 480 - y)-(640 - (x - 6), 480 - (y - 3)), c: LINE -(640 - (x - 4), 480 - (y - 3)), c: LINE -(640 - (x - 2), 480 - (y - 2)), c: LINE -(640 - x, 480 - (y - 1)), c: LINE -(640 - (x + 2), 480 - (y - 2)), c: LINE -(640 - (x + 4) , 480 - (y - 3)), c„      LINE -(640 - (x + 6), 480 - (y - 3)), c: LINE -(640 - (x + 8), 480 - y), c: LINE -(640 - (x + 4), 480 - (y + 5)), c: LINE -(640 - x, 480 - (y + 8)), c: LINE -(640 - (x - 6), 480 - (y + 4)), c: LINE -(640 - (x - 8), 480 - (y + 1)), c„      LINE (640 - (a - 9), 480 - b)-(640 - (a - 6), 480 - (b - 3)), c: LINE -(640 - (a - 4), 480 - (b - 3)), c: LINE -(640 - (a - 2), 480 - (b - 2)), c: LINE -(640 - a, 480 - (b - 1)), c: LINE -(640 - (a + 2), 480 - (b - 2)), c: LINE -(640 - (a + 4) , 480 - (b - 3)), c„      LINE -(640 - (a + 6), 480 - (b - 3)), c: LINE -(640 - (a + 8), 480 - b), c: LINE -(640 - (a + 4), 480 - (b + 5)), c: LINE -(640 - a, 480 - (b + 8)), c: LINE -(640 - (a - 6), 480 - (b + 4)), c: LINE -(640 - (a - 8), 480 - (b + 1)), c„    'heart 3„      LINE (x - 9, 480 - y)-(x - 6, 480 - (y - 3)), c: LINE -(x - 4, 480 - (y - 3)), c: LINE -(x - 2, 480 - (y - 2)), c: LINE -(x, 480 - (y - 1)), c: LINE -(x + 2, 480 - (y - 2)), c: LINE -(x + 4, 480 - (y - 3)), c„      LINE -(x + 6, 480 - (y - 3)), c: LINE -(x + 8, 480 - y), c: LINE -(x + 4, 480 - (y + 5)), c: LINE -(x, 480 - (y + 8)), c: LINE -(x - 6, 480 - (y + 4)), c: LINE -(x - 8, 480 - (y + 1)), c„      LINE (a - 9, 480 - b)-(a - 6, 480 - (b - 3)), c: LINE -(a - 4, 480 - (b - 3)), c: LINE -(a - 2, 480 - (b - 2)), c: LINE -(a, 480 - (b - 1)), c: LINE -(a + 2, 480 - (b - 2)), c: LINE -(a + 4, 480 - (b - 3)), c„      LINE -(a + 6, 480 - (b - 3)), c: LINE -(a + 8, 480 - b), c: LINE -(a + 4, 480 - (b + 5)), c: LINE -(a, 480 - (b + 8)), c: LINE -(a - 6, 480 - (b + 4)), c: LINE -(a - 8, 480 - (b + 1)), c„    'heart 4„      LINE (640 - (x - 9), y)-(640 - (x - 6), y - 3), c: LINE -(640 - (x - 4), y - 3), c: LINE -(640 - (x - 2), y - 2), c: LINE -(640 - x, y - 1), c: LINE -(640 - (x + 2), y - 2), c: LINE -(640 - (x + 4), y - 3), c„      LINE -(640 - (x + 6), y - 3), c: LINE -(640 - (x + 8), y), c: LINE -(640 - (x + 4), y + 5), c: LINE -(640 - x, y + 8), c: LINE -(640 - (x - 6), y + 4), c: LINE -(640 - (x - 8), y + 1), c„      LINE (640 - (a - 9), b)-(640 - (a - 6), b - 3), c: LINE -(640 - (a - 4), b - 3), c: LINE -(640 - (a - 2), b - 2), c: LINE -(640 - a, b - 1), c: LINE -(640 - (a + 2), b - 2), c: LINE -(640 - (a + 4), b - 3), c„      LINE -(640 - (a + 6), b - 3), c: LINE -(640 - (a + 8), b), c: LINE -(640 - (a + 4), b + 5), c: LINE -(640 - a, b + 8), c: LINE -(640 - (a - 6), b + 4), c: LINE -(640 - (a - 8), b + 1), c„  CASE 5„      PSET (x, y), c: PSET (a, b), c: PSET (640 - x, 480 - y), c: PSET (640 - a, 480 - b), c„      PSET (x, 480 - y), c: PSET (a, 480 - b), c: PSET (640 - x, y), c: PSET (640 - a, b), c„  CASE 6„      LINE (x, y)-(319, 240), c: LINE (a, b)-(319, 240), c: LINE (640 - x, 480 - y)-(319, 240), c: LINE (640 - a, 480 - b)-(319, 240), c„      LINE (x, 480 - y)-(319, 240), c: LINE (a, 480 - b)-(319, 240), c: LINE (640 - x, y)-(319, 240), c: LINE (640 - a, b)-(319, 240), c„      LINE (x, y)-(a, b), c: LINE (640 - x, 480 - y)-(640 - a, 480 - b), c„      LINE (x, 480 - y)-(a, 480 - b), c: LINE (640 - x, y)-(640 - a, b), c„  CASE 7„      LINE (x, y)-(319, 240), c: LINE (a, b)-(319, 240), c: LINE (640 - x, 480 - y)-(319, 240), c: LINE (640 - a, 480 - b)-(319, 240), c„      LINE (x, 480 - y)-(319, 240), c: LINE (a, 480 - b)-(319, 240), c: LINE (640 - x, y)-(319, 240), c: LINE (640 - a, b)-(319, 240), c„  CASE 8„      FOR mm = 1 TO 4„       IF mm = 1 THEN xd = 0: yd = 0„       IF mm = 2 THEN xd = 639: yd = 0„       IF mm = 3 THEN xd = 0: yd = 479„       IF mm = 4 THEN xd = 639: yd = 479„       LINE (x, y)-(xd, yd), c: LINE (a, b)-(xd, yd), c: LINE (640 - x, 480 - y)-(xd, yd), c: LINE (640 - a, 480 - b)-(xd, yd), c„       LINE (x, 480 - y)-(xd, yd), c: LINE (a, 480 - b)-(xd, yd), c: LINE (640 - x, y)-(xd, yd), c: LINE (640 - a, b)-(xd, yd), c„      NEXT mm„  CASE 9„      LINE (x, y)-(x + 15, y + 15), c: LINE -(x - 15, y + 15), c: LINE -(x, y), c: LINE (a, b)-(a + 15, b + 15), c: LINE -(a - 15, b + 15), c: LINE -(a, b), c„      LINE (640 - x, 480 - y)-(640 - x + 15, 480 - y + 15), c: LINE -(640 - x - 15, 480 - y + 15), c: LINE -(640 - x, 480 - y), c: LINE (640 - a, 480 - b)-(640 - a + 15, 480 - b + 15), c: LINE -(640 - a - 15, 480 - b + 15), c: LINE -(640 - a, 480 -  b), c„      LINE (x, 480 - y)-(x + 15, 480 - y + 15), c: LINE -(x - 15, 480 - y + 15), c: LINE -(x, 480 - y), c: LINE (a, 480 - b)-(a + 15, 480 - b + 15), c: LINE -(a - 15, 480 - b + 15), c: LINE -(a, 480 - b), c„      LINE (640 - x, y)-(640 - x + 15, y + 15), c: LINE -(640 - x - 15, y + 15), c: LINE -(640 - x, y), c: LINE (640 - a, b)-(640 - a + 15, b + 15), c: LINE -(640 - a - 15, b + 15), c: LINE -(640 - a, b), c„  CASE ELSE„      PRINT "ERROR!!!! heEHHEhhaHHAhaHAHa"„END SELECT„„„„„SELECT CASE style„  CASE 1„      'color pulsing„      c = c + 1: IF c = 16 THEN c = 1„  CASE 2„      'color blending„      IF c >= 15 THEN cc = 1 ELSE IF c <= 1 THEN cc = 0„      IF cc = 1 THEN c = c - 1 ELSE IF cc = 0 THEN c = c + 1„END SELECT„„notgonadoit:„mycount = mycount + 1: IF mycount > 5 THEN mycount = 0: GOSUB pal„„LOOP UNTIL INKEY$ <> ""„END„„tt:„CLS„RETURN„„pp:„redo:„rr = INT(RND * 14) + 1„IF rr = lrr THEN GOTO redo            'ensures a new color each push„lrr = rr„FOR cx = 1 TO 15„IF rr = 1 THEN rx = cx: gx = 0: bx = 0      'red„IF rr = 2 THEN rx = 0: gx = cx: bx = 0      'green„IF rr = 3 THEN rx = 0: gx = 0: bx = cx      'blue„IF rr = 4 THEN rx = cx: gx = cx: bx = cx    'white to black„IF rr = 5 THEN rx = cx: gx = cx: bx = 0     'yellow„IF rr = 6 THEN rx = 0: gx = cx: bx = cx     'aquaish„IF rr = 7 THEN rx = cx: gx = 0: bx = cx     'purplish„IF rr = 8 THEN rx = INT(cx / 2): gx = INT(cx / 6.3): bx = INT(cx / 6.3)'brown„IF rr = 9 THEN rx = cx: gx = INT(cx / 2): bx = 0'orange„IF rr = 10 THEN rx = cx: gx = INT(cx / 1.3): bx = INT(cx / 6.3)'gold„IF rr = 11 THEN rx = cx: gx = INT(cx / 4.5): bx = INT(cx / 1.5)'hotpink„IF rr = 12 THEN rx = INT(cx / 2): gx = INT(cx / 1.9): bx = INT(cx / 1.75)'cold grey„IF rr = 13 THEN rx = INT(cx / 2.3): gx = INT(cx / 1.3): bx = INT(cx / 6.3)'slime„IF rr = 14 THEN rx = INT(cx / 1.6): gx = cx: bx = INT(cx / 6)'yelow-gren„OUT &H3C8, cx: OUT &H3C9, (rx * 4) + 3: OUT &H3C9, (gx * 4) + 3: OUT &H3C9, (bx * 4) + 3„OUT &H3C8, 0: FOR mca = 1 TO 3: OUT &H3C9, 0: NEXT mca„NEXT cx„GOSUB getorg„RETURN„„getorg:„FOR sx = 1 TO 15„OUT &H3C7, sx: rox(sx) = INP(&H3C9): gox(sx) = INP(&H3C9): box(sx) = INP(&H3C9)„NEXT sx„RETURN„„pal:„FOR xx = 1 TO 15„dd = xx - 1: IF dd = 0 THEN dd = 15„OUT &H3C8, xx: OUT &H3C9, rox(dd): OUT &H3C9, gox(dd): OUT &H3C9, box(dd)„NEXT xx„GOSUB getorg„RETURN„„inc:„IF grad = 1 THEN grad = 2: GOTO ymcam„IF grad = 2 THEN grad = 4: GOTO ymcam„IF grad = 4 THEN grad = 8: GOTO ymcam„IF grad = 8 THEN grad = 16: GOTO ymcam„IF grad = 16 THEN grad = 20: GOTO ymcam„IF grad = 20 THEN grad = 1„ymcam:„RETURN„„shpcng:„shape = shape + 1„IF shape = 10 THEN shape = 1„RETURN„„csty:„style = style + 1„IF style >= 3 THEN style = 1„RETURN„„stopitnow:„IF wannaseeit = 1 THEN GOTO alrty„IF wannaseeit = 0 THEN wannaseeit = 1: GOTO alrty2„alrty:„wannaseeit = 0„alrty2:„RETURN„„FUNCTION nnn  'neg 1 or pos 1„nnn = (INT((RND * 2) + 1) * 2 - 3)„END FUNCTION„„FUNCTION num    '5-9„num = (INT(RND * 5) + 5)„END FUNCTION„Douglas H. Lusher              MANDELBROT VIEWING PROGRAM     FidoNet QUIK_BAS Echo          06-03-96 (20:04)       QB, QBasic, PDS        281  8667     MANDVIEW.BAS'>     By now you should know that I have managed to do repeated zoom„'>     using my own method in the MODEX version. But I would love to„'>     see what you come up in this regard.„„'Well, it's still somewhat rough, but here it is.„'You will have to begin by entering values and computing a„'starting screen. When you save a screen, the values are saved„'along with it. Then you can load the file, move the cursor„'around the image, change the size of the cursor, etc. When„'you decide what you want to magnify, just press ENTER. Once„'that image is made, you can save it, reload it in the left„'window and magnify part of it, etc. It would certainly be„'possible - it would be pretty easy, in fact - to make it so„'that you could press a key and see the cursor on the new„'image without having to reload it, but I just haven't gotten„'that far yet. I'm not sure I will, either, I need to start„'giving some time to other projects, I'm afraid.„„ CONST PgUpKey = -73, PgDnKey = -81„ CONST UpArrow = -72, DnArrow = -80„ CONST LArrow = -75, RArrow = -77„ CONST ENTER = 13, ESC = 27„ DEFSNG A-Z„ Abort% = 0: Disp$ = "##.#######"„ NumColors% = 16: Maxdwell! = 150„„ Beginning:„ SCREEN 0: WIDTH 80„ COLOR 7, 1: CLS„ PRINT "Mandlebrot Viewing Program"„ PRINT„ DO„   PRINT "Begin with a [F]ile or by entering [V]alues? (F/V) ";„   LOCATE , , 1„   A$ = UCASE$(INPUT$(1))„   SELECT CASE A$„     CASE "F": PRINT A$„       INPUT "Enter file name: ", FileName$„       IF LEN(FileName$) THEN EXIT DO„     CASE "V": PRINT A$„       GOSUB GetCoords: IF Range! <> 0 THEN EXIT DO„     CASE CHR$(27): PRINT„       END„     CASE ELSE„       BEEP„   END SELECT„ LOOP„„ SCREEN 12„ Size% = 304„ CursSize% = Size% \ 4„ TopMarg% = 12„ LeftMarg% = 332„ LINE (LeftMarg% - 1, TopMarg% - 1)-STEP(Size% + 1, Size% + 1), 8, B„ LeftMarg% = 4„ LINE (LeftMarg% - 1, TopMarg% - 1)-STEP(Size% + 1, Size% + 1), 8, B„„ SELECT CASE A$„   CASE "F": GOSUB GetImageFromFile„   CASE "V": GOSUB GetImageFromValues„ END SELECT„„ CursX% = LeftMarg%: CursY% = TopMarg% + Size% - 1„ GOSUB ResizeCursorArray„ GOSUB DrawCursor„„ LOCATE 25, 2: PRINT "Use the arrow keys to move the cursor around";„ LOCATE 26, 2: PRINT "Use the PageUp & PageDn keys to resize the cursor";„ LOCATE 27, 2: PRINT "Press Enter to magnify the area within the cursor";„„ DO„   DO WHILE LEN(INKEY$): LOOP„   CALL GetKeypress(Keycode%)„   SELECT CASE Keycode%„     CASE UpArrow„       Temp% = CursY% - 1„       IF Temp% - CursSize% >= TopMarg% THEN„         GOSUB EraseCursor: CursY% = Temp%: GOSUB DrawCursor„       ELSE BEEP„       END IF„     CASE DnArrow„       Temp% = CursY% + 1„       IF Temp% < TopMarg% + Size% THEN„         GOSUB EraseCursor: CursY% = Temp%: GOSUB DrawCursor„       ELSE BEEP„       END IF„     CASE LArrow„       Temp% = CursX% - 1„       IF Temp% >= LeftMarg% THEN„         GOSUB EraseCursor: CursX% = Temp%: GOSUB DrawCursor„       ELSE BEEP„       END IF„     CASE RArrow„       Temp% = CursX% + 1„       IF Temp% + CursSize% < LeftMarg% + Size% THEN„         GOSUB EraseCursor: CursX% = Temp%: GOSUB DrawCursor„       ELSE BEEP„       END IF„     CASE PgUpKey„       IF CursSize% < Size% \ 2 THEN„         GOSUB EraseCursor„         CursSize% = CursSize% + 1„         GOSUB ResizeCursorArray„         GOSUB DrawCursor„       END IF„     CASE PgDnKey„       IF CursSize% > 5 THEN„         GOSUB EraseCursor„         CursSize% = CursSize% - 1„         GOSUB ResizeCursorArray„         GOSUB DrawCursor„       END IF„     CASE ENTER„       Real! = Range! * ((CursX% - LeftMarg%) / Size%) + Real!„       Imag! = Range! * ((Size% - (CursY% - TopMarg%)) / Size%) + Imag!„       Range! = Range! * (CursSize% / Size%)„       LeftMarg% = 332„       GOSUB GetImageFromValues„       GOTO Beginning„     CASE ESC„       EXIT DO„   END SELECT„ LOOP„ SCREEN 0: WIDTH 80„ END„„ GetImageFromFile:„ File% = FREEFILE„ OPEN FileName$ FOR BINARY AS #File%„   SEEK #File%, LOF(File%) - 11„   GET #File%, , Real!„   GET #File%, , Imag!„   GET #File%, , Range!„ CLOSE #File%„ GOSUB ShowCoords„ CALL BLOADnPUT(LeftMarg%, TopMarg%, FileName$)„ RETURN„ GetImageFromValues:„ GOSUB ShowCoords„ LOCATE 25, 1: PRINT SPC(79); " ";„ LOCATE 26, 1: PRINT SPC(79); " ";„ LOCATE 27, 1: PRINT SPC(79); " ";„ LOCATE 26, 22: PRINT "Please wait while image is created...";„ GOSUB CreateImage„ LOCATE 26, 1: PRINT SPC(79); " ";„ IF NOT Abort% THEN„   LOCATE 28, 1: INPUT "Enter file name: ", FileName$„   IF LEN(FileName$) THEN„     LOCATE 28, 1: PRINT SPC(79); " ";„     X1% = LeftMarg%: Y1% = TopMarg%„     X2% = LeftMarg% + Size% - 1: Y2% = TopMarg% + Size% - 1„     CALL GETnBSAVE(X1%, Y1%, X2%, Y2%, 12, FileName$)„     File% = FREEFILE„     OPEN FileName$ FOR BINARY AS #File%„       SEEK #File%, LOF(File%) + 1„       PUT #File%, , Real!„       PUT #File%, , Imag!„       PUT #File%, , Range!„     CLOSE #File%„   END IF„ END IF„ RETURN„„ GetCoords:„ DO„   PRINT "The value of Real! must be between -2 and +2."„   INPUT "Enter a value for Real!: ", Real!„ LOOP UNTIL Real! >= -2 AND Real! <= 2„ DO„   PRINT "The value of Imag! must be between -2 and +2."„   INPUT "Enter a value for Imag!: ", Imag!„ LOOP UNTIL Imag! >= -2 AND Imag! <= 2„ DO„   PRINT "The value of Range! must be between 0 and 4."„   INPUT "Enter a value for Range!: ", Range!„ LOOP UNTIL Range! >= 0 AND Range! <= 4„RETURN„„ ResizeCursorArray:„ Bytes% = ((CursSize% \ 8) + 1) * (CursSize% + 1) * 4 + 4„ REDIM CursArray%(Bytes% \ 2)„ RETURN„„ DrawCursor:„ GET (CursX%, CursY% - CursSize%)-STEP(CursSize%, CursSize%), CursArray%„ LINE (CursX%, CursY%)-STEP(CursSize%, -CursSize%), 15, B„ Rl! = Range! * ((CursX% - LeftMarg%) / Size%) + Real!„ Ig! = Range! * ((Size% - (CursY% - TopMarg%)) / Size%) + Imag!„ Rg! = Range! * (CursSize% / Size%)„ R% = (TopMarg% + Size%) \ 16 + 2„ LOCATE R%, 43: PRINT "FracX = "; USING Disp$; Rl!;„ LOCATE R% + 1, 43: PRINT "FracY = "; USING Disp$; Ig!;„ LOCATE R% + 2, 43: PRINT "Range = "; USING Disp$; Rg!;„ RETURN„„ EraseCursor:„ PUT (CursX%, CursY% - CursSize%), CursArray%, PSET„ RETURN„„ ShowCoords:„ R% = (TopMarg% + Size%) \ 16 + 2„ C% = LeftMarg% \ 8 + 2„ LOCATE R%, C%: PRINT "FracX = "; USING Disp$; Real!;„ LOCATE R% + 1, C%: PRINT "FracY = "; USING Disp$; Imag!;„ LOCATE R% + 2, C%: PRINT "Range = "; USING Disp$; Range!;„ RETURN„„ CreateImage:„ highdwell = 0„ Gap = Range / Size%„ AC = Real„ FOR X% = LeftMarg% TO LeftMarg% + Size% - 1„   AC = AC + Gap„   BC = Imag„   FOR Y% = TopMarg% + Size% - 1 TO TopMarg% STEP -1„     IF INKEY$ = CHR$(27) THEN Abort% = -1: EXIT FOR„     BC = BC + Gap„     AZ = 0„     BZ = 0„     Count% = 0„     Size! = 0„     WHILE (Size! < 4) AND (Count% < Maxdwell)„       Temp = AZ * AZ - BZ * BZ + AC„       BZ = 2 * AZ * BZ + BC„       AZ = Temp„       Size! = AZ * AZ + BZ * BZ„       Count% = Count% + 1„     WEND„     IF (Count% < Maxdwell) AND (Count% > highdwell) THEN highdwell = Count%„     IF Count% <> Maxdwell THEN„       Culler% = Count% MOD (NumColors% - 1) + 1„       PSET (X%, Y%), Culler%„     END IF„   NEXT„   IF Abort% THEN EXIT FOR„ NEXT„ RETURN„„ SUB BLOADnPUT (X1%, Y1%, FileName$)„ Temp% = 0„ File% = FREEFILE„ OPEN FileName$ FOR BINARY AS File%„   GET #File%, 6, Temp%„ CLOSE File%„ Bytes& = Temp% AND &HFFFF&„ REDIM Image%(Bytes& \ 2)„ DEF SEG = VARSEG(Image%(0))„ BLOAD FileName$, VARPTR(Image%(0))„ PUT (X1%, Y1%), Image%„ DEF SEG„ END SUB„„ SUB GetKeypress (Keycode%) STATIC„ DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)„ Keycode% = ASC(Ky$): IF Keycode% = 0 THEN Keycode% = -ASC(MID$(Ky$, 2))„ END SUB„„ DEFSNG A-Z„ SUB GETnBSAVE (X1%, Y1%, X2%, Y2%, Mode%, FileName$)„ SELECT CASE Mode%„   CASE 1: BitsPerPixel% = 2: BitPlanes% = 1„   CASE 2: BitsPerPixel% = 1: BitPlanes% = 1„   CASE 7: BitsPerPixel% = 1: BitPlanes% = 4„   CASE 8: BitsPerPixel% = 1: BitPlanes% = 4„   CASE 9: BitsPerPixel% = 1: BitPlanes% = 4„     'in SCREEN 9, if EGA memory < 64K then BitPlanes% = 2„   CASE 11: BitsPerPixel% = 1: BitPlanes% = 1„   CASE 12: BitsPerPixel% = 1: BitPlanes% = 4„   CASE 13: BitsPerPixel% = 8: BitPlanes% = 1„   CASE ELSE: ERROR 5„ END SELECT„ X% = ABS(X2% - X1%) + 1    'number of pixel columns„ Y% = ABS(Y2% - Y1%) + 1    'number of pixel rows„ Bytes& = CLNG(((X% * BitsPerPixel%) + 7) \ 8) * Y% * BitPlanes% + 4„ IF Bytes& > 65535 THEN ERROR 5„ REDIM Image%(Bytes& \ 2)„ GET (X1%, Y1%)-(X2%, Y2%), Image%„ DEF SEG = VARSEG(Image%(0))„ BSAVE FileName$, VARPTR(Image%(0)), Bytes&„ DEF SEG„ END SUB„John Wantland                  FOUNTAIN FIREWORKS             kwantlan@coffey.com            06-06-96 (18:21)       QB, QBasic, PDS        39   995      FIREWORK.BASREM fountain fireworks„n = 100          'how many sparks on the screen at one time. Change if you have a slower computer„DIM y(n)„DIM x(n)„DIM d(n)„DIM c(n)„DIM h(n)„DIM n(n)„DIM ox(n)„t = INT(RND * 640 + 1)„SCREEN 12: CLS„FOR i = 1 TO n„RANDOMIZE TIMER„x(i) = t„y(i) = 480„d(i) = INT(RND * 2 + 1)„c(i) = INT(RND * 15 + 1)„h(i) = INT(RND * 400 + 100)„ox(i) = x(i)„n(i) = INT(RND * 5)„NEXT i„DO„FOR i = 1 TO n„PSET (x(i), y(i)), 0„IF d(i) = 1 THEN y(i) = y(i) - 5: x(i) = x(i) - n(i): IF y(i) <= h(i) THEN d(i) = 3„IF d(i) = 2 THEN y(i) = y(i) - 5: x(i) = x(i) + n(i): IF y(i) <= h(i) THEN d(i) = 4„IF d(i) = 3 THEN y(i) = y(i) + 5: x(i) = x(i) - n(i): IF y(i) > 480 THEN GOSUB 4„IF d(i) = 4 THEN y(i) = y(i) + 5: x(i) = x(i) + n(i): IF y(i) > 480 THEN GOSUB 4„a$ = INKEY$: IF a$ <> "" THEN END„PSET (x(i), y(i)), c(i)„NEXT i„LOOP„4 PSET (x(i), y(i)), 0„x(i) = ox(i)„y(i) = 480„d(i) = INT(RND * 2 + 1)„n(i) = INT(RND * 5)„h(i) = INT(RND * 300 + 100)„RETURN„John Wantland                  SNOW FALL                      kwantlan@coffey.com            06-07-96 (12:37)       QB, QBasic, PDS        37   794      SNOWFALL.BAS' snow„' sorry it's so slow, but isn't real snow„j = 0„RANDOMIZE TIMER„n = 100         'heaviness of snow„DIM y(n)„DIM x(n)„DIM d(n)„DIM c(n)„DIM h(n)„DIM n(n)„DIM ox(n)„SCREEN 12: CLS„FOR i = 1 TO n„x(i) = INT(RND * 640 + 1)„y(i) = INT(RND * 480 + 1)„d(i) = INT(RND * 2 + 1)„n(i) = 1„NEXT i„DO„FOR i = 1 TO n„PSET (x(i), y(i)), 0„IF d(i) = 1 THEN y(i) = y(i) + n(i): IF y(i) >= 479 THEN y(i) = 479: GOSUB 4„IF d(i) = 2 THEN y(i) = y(i) + n(i): IF y(i) >= 479 THEN y(i) = 479: GOSUB 4„IF POINT(x(i), y(i) + 1) = 15 THEN GOSUB 4„a$ = INKEY$: IF a$ <> "" THEN END„PSET (x(i), y(i)), 7„NEXT i„LOOP„4 PSET (x(i), y(i)), 15„x(i) = INT(RND * 640 + 1)„y(i) = 1„d(i) = INT(RND * 2 + 1)„n(i) = 1„h(i) = INT(RND * 300 + 100)„j = j + 1: IF j >= 306560 THEN CLS„RETURN„John Wantland                  BLACK HOLE                     kwantlan@coffey.com            06-08-96 (09:40)       QB, QBasic, PDS        28   658      BLACKHOL.BASREM black hole„n = 50  'number of objects pulled in„DIM x(n)„DIM y(n)„DIM s(n)„SCREEN 12„1 CLS„c = 0„RANDOMIZE TIMER„g1 = INT(RND * 640 + 1)„g2 = INT(RND * 480 + 1)„FOR i = 1 TO n„y(i) = INT(RND * 480 + 1)„x(i) = INT(RND * 640 + 1)„s(i) = 0„NEXT i„DO„FOR i = 1 TO n„PSET (x(i), y(i)), 0         'If you want to trace, take out„IF x(i) < g1 THEN x(i) = x(i) + 1„IF x(i) > g1 THEN x(i) = x(i) - 1„IF y(i) < g2 THEN y(i) = y(i) + 1„IF y(i) > g2 THEN y(i) = y(i) - 1„IF s(i) = 0 THEN PSET (x(i), y(i)), 15„IF x(i) = g1 AND y(i) = g2 AND s(i) = 0 THEN c = c + 1: s(i) = 1: IF c = n THEN 1„a$ = INKEY$: IF a$ <> "" THEN END„NEXT i„LOOP„John Wantland                  TORNADO SIMULATOR              kwantlan@coffey.com            06-14-96 (20:20)       QB, QBasic, PDS        45   1005     TORNADO.BAS REM tornado„' sorry about the mess at first, but I haven't found out what's wrong yet.„SCREEN 12: CLS„RANDOMIZE TIMER„n = 50    'how thick tornado is. change if you want„j = 0„DIM x(n)„DIM y(n)„DIM c(n)„DIM d(n)„DIM l(n)„DIM g(n)„DIM j(n)„FOR i = 1 TO n„y(i) = INT(RND * 480 + 1)„d(i) = INT(RND * 2 + 1)„j(i) = 0„GOSUB 4„x(i) = INT(RND * (g(i) - l(i) + 1) + l(i))„NEXT i„DO„FOR i = 1 TO n„PSET (x(i), y(i)), 0„IF d(i) = 1 THEN x(i) = x(i) + 2: c(i) = 7: IF x(i) >= g(i) THEN d(i) = 2„IF d(i) = 2 THEN x(i) = x(i) - 2: c(i) = 15: IF x(i) <= l(i) THEN d(i) = 1„y(i) = y(i) + 1: IF y(i) >= 480 THEN GOSUB 2„j(i) = j(i) + 1: IF j(i) > 2 THEN j(i) = 0: g(i) = g(i) - 1: l(i) = l(i) + 1„a$ = INKEY$: IF a$ <> "" THEN END„PSET (x(i), y(i)), c(i)„NEXT i„LOOP„2 y(i) = 1„d(i) = INT(RND * 2 + 1)„j(i) = 0„GOSUB 4„x(i) = INT(RND * (g(i) - l(i)) + l(i))„RETURN„4 g(i) = 500„l(i) = 100„FOR t = 1 TO 480„g(i) = g(i) - 1„l(i) = l(i) + 1„IF t = y(i) THEN RETURN„NEXT t„RETURN„John Wantland                  BOUNCING BALLS                 kwantlan@coffey.com            06-21-96 (11:24)       QB, QBasic, PDS        37   1040     WORMS.BAS   REM bouncing balls„' I came up with the idea for this while working on a program to„' bounce balls on the screen. I accidently deleted the erasing line, and„' presto. Worms!„RANDOMIZE TIMER„n = 2              'number of worms works best with no more than five„DIM y(n)„DIM x(n)„DIM d(n)„DIM m(n)„DIM c(n)„FOR i = 1 TO n„x(i) = INT(RND * 600 + 40)„y(i) = INT(RND * 440 + 40)„d(i) = INT(RND * 2 + 1)„m(i) = INT(RND * 2 + 1)„1 c(i) = INT(RND * 15 + 1): IF c = 1 THEN 1„NEXT i„SCREEN 12: CLS„DO„FOR i = 1 TO n„' erase the apostrophe to make balls instead of worms„' PAINT (x(i), y(i)), 0„c(i) = c(i) + 1: IF c(i) > 15 THEN c(i) = 2„IF d(i) = 1 THEN y(i) = y(i) - 1„IF d(i) = 2 THEN y(i) = y(i) + 1„IF m(i) = 1 THEN x(i) = x(i) - 1„IF m(i) = 2 THEN x(i) = x(i) + 1„IF y(i) < 11 THEN d(i) = 2„IF y(i) > 469 THEN d(i) = 1„IF x(i) < 11 THEN m(i) = 2„IF x(i) > 629 THEN m(i) = 1„CIRCLE (x(i), y(i)), 10, c(i)  '10 is size Change if you want„PAINT (x(i), y(i)), c(i)„a$ = INKEY$: IF a$ <> "" THEN END„NEXT i„LOOP„Edward Blake                   BOUNCING LINES                 eblake2@quebectel.com          06-28-96 (18:02)       QB, QBasic, PDS        95   2905     BOUNCLIN.BAS' 1996 Edward Blake, Bouncing lines similar to windows screen saver mystify„' But can be more customized, up to making a multicolor rectangle„' The constants below are for customizing.„DEFINT A-Z             ' Make em all integers! need speed!„CONST LINE1COL = 1     ' Line #1's color„CONST LINE2COL = 2     ' Line #2's color„CONST LINE3COL = 3     ' Line #3's color„CONST LINE4COL = 4     ' Line #4's color„CONST LINE1SCOL = 12   ' Line #1's interval color„CONST LINE2SCOL = 11   ' Line #2's interval color„CONST LINE3SCOL = 10   ' Line #3's interval color„CONST LINE4SCOL = 9    ' Line #4's interval color„CONST NUMLINES = 10    ' The "width" of the polygone„CONST INTERVALSCOL = 2 ' make Interval after N times of repainting polygone„„DIM LASTLINEX(NUMLINES)„DIM LASTLINEY(NUMLINES)„DIM LASTLINEX2(NUMLINES)„DIM LASTLINEY2(NUMLINES)„DIM LASTLINEX3(NUMLINES)„DIM LASTLINEY3(NUMLINES)„DIM LASTLINEX4(NUMLINES)„DIM LASTLINEY4(NUMLINES)„SCREEN 12„XD = 1„YD = 2„XD2 = 3„YD2 = 4„XD3 = 5„YD3 = 6„XD4 = 7„YD4 = 8„X = 320„Y = 241„X2 = 320„Y2 = 241„CLS„DO„FOR I = 1 TO INTERVALSCOL„X = X + XD„Y = Y + YD„X2 = X2 + XD2„Y2 = Y2 + YD2„X3 = X3 + XD3„Y3 = Y3 + YD3„X4 = X4 + XD4„Y4 = Y4 + YD4„LINE (X, Y)-(X2, Y2), LINE1COL„LINE (X, Y)-(X4, Y4), LINE2COL„LINE (X2, Y2)-(X3, Y3), LINE3COL„LINE (X3, Y3)-(X4, Y4), LINE4COL„IF X >= 640 THEN XD = -INT(RND * 5)„IF X <= 0 THEN XD = INT(RND * 5)„IF Y >= 480 THEN YD = -INT(RND * 5)„IF Y <= 0 THEN YD = INT(RND * 5)„IF X2 >= 640 THEN XD2 = -INT(RND * 5)„IF X2 <= 0 THEN XD2 = INT(RND * 5)„IF Y2 >= 480 THEN YD2 = -INT(RND * 5)„IF Y2 <= 0 THEN YD2 = INT(RND * 5)„IF X3 >= 640 THEN XD3 = -INT(RND * 5)„IF X3 <= 0 THEN XD3 = INT(RND * 5)„IF Y3 >= 480 THEN YD3 = -INT(RND * 5)„IF Y3 <= 0 THEN YD3 = INT(RND * 5)„IF X4 >= 640 THEN XD4 = -INT(RND * 5)„IF X4 <= 0 THEN XD4 = INT(RND * 5)„IF Y4 >= 480 THEN YD4 = -INT(RND * 5)„IF Y4 <= 0 THEN YD4 = INT(RND * 5)„LASTLINEX(NUMLINES) = X„LASTLINEY(NUMLINES) = Y„LASTLINEX2(NUMLINES) = X2„LASTLINEY2(NUMLINES) = Y2„LASTLINEX3(NUMLINES) = X3„LASTLINEY3(NUMLINES) = Y3„LASTLINEX4(NUMLINES) = X4„LASTLINEY4(NUMLINES) = Y4„FOR T = 0 TO NUMLINES - 1„LASTLINEX(T) = LASTLINEX(T + 1)„LASTLINEY(T) = LASTLINEY(T + 1)„LASTLINEX2(T) = LASTLINEX2(T + 1)„LASTLINEY2(T) = LASTLINEY2(T + 1)„LASTLINEX3(T) = LASTLINEX3(T + 1)„LASTLINEY3(T) = LASTLINEY3(T + 1)„LASTLINEX4(T) = LASTLINEX4(T + 1)„LASTLINEY4(T) = LASTLINEY4(T + 1)„NEXT T„LINE (LASTLINEX(0), LASTLINEY(0))-(LASTLINEX2(0), LASTLINEY2(0)), 0„LINE (LASTLINEX(0), LASTLINEY(0))-(LASTLINEX4(0), LASTLINEY4(0)), 0„LINE (LASTLINEX2(0), LASTLINEY2(0))-(LASTLINEX3(0), LASTLINEY3(0)), 0„LINE (LASTLINEX3(0), LASTLINEY3(0))-(LASTLINEX4(0), LASTLINEY4(0)), 0„NEXT I„LINE (X, Y)-(X2, Y2), LINE1SCOL„LINE (X, Y)-(X4, Y4), LINE2SCOL„LINE (X2, Y2)-(X3, Y3), LINE3SCOL„LINE (X3, Y3)-(X4, Y4), LINE4SCOL„LOOP„Steven Anthony Morisi          ETCH-A-SKETCH                  steve179@ix.netcom.com         05/96 (00:00)          QB, QBasic, PDS        194  3577     ETCH.BAS    DECLARE SUB instructions ()„DECLARE SUB pause ()„DECLARE SUB errtone ()„DECLARE SUB drawetch ()„DECLARE SUB quake ()„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„' Program  :  Etch Etch     Date : 5/96„' Author   :  Steve Morisi„' Comments :  Not much to the program but my son & daughter ( 8 & 12)„'             thought it was cute. Also I did use 2 snippets from the„'             ABC packets.„'             My son Paul Anthony thought of incorporating the QUAKE„'             as a sub routine.    „'             Credit for the Quake code goes to William Yu. It was in one„'             of the ABC packets in the Graphic section under the name of„'             EARTHQUAKE EFFECT DEMO.„'„'             Another snippet I used was ENDS.BAS written by RATBOY„'             If you invoke the code by QBASIC /RUN ETCH„'             then when you end the program you'll back out to the„'             prompt rather than the QBASIC editor.„'„'             I'd appreciate any comments/suggestions at„'             STEVE179@IX.NETCOM.COM„'„'             Thanks„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'etch a sketch emulator„DIM box%(1 TO 30000)„„SCREEN 9„x = 280„y = 175„„'Assign names to colors„blue = 1„greenB = 2„cyan = 3„red = 4„magenta = 5„rust = 6„white = 7„grey = 8„blueB = 9„green = 10„cyanB = 11„orange = 12„magentaB = 13„yellow = 14„whiteB = 15„„'Set up keys„KEY(2) ON    'F2„KEY(11) ON   'Up arrow„KEY(12) ON   'Left„KEY(13) ON   'Right„KEY(14) ON   'Down„instructions„drawetch ' initialize drawing area„„'Drawing routine„DO WHILE (key.Press$ <> CHR$(27))„„   PSET (x, y), 0„   key.Press$ = INKEY$„„   ON KEY(2) GOSUB newscreen„   ON KEY(11) GOSUB arrow.up„   ON KEY(12) GOSUB arrow.left„   ON KEY(13) GOSUB arrow.right„   ON KEY(14) GOSUB arrow.down„„LOOP„CLS„SYSTEM„REM CHAIN "menu"„END„„arrow.up:„IF y < 76 THEN„   errtone„   RETURN„END IF„y = y - 1„   „RETURN„„arrow.left:„IF x < 121 THEN„   errtone„   RETURN„END IF„x = x - 1„RETURN„„arrow.right:„IF x > 439 THEN„   errtone„   RETURN„END IF„x = x + 1„RETURN„„arrow.down:„IF y > 274 THEN„   errtone„   RETURN„END IF„y = y + 1„RETURN„„newscreen:„  quake„  CLS 0„  drawetch„  x = 280„  y = 175„RETURN„„SUB drawetch„errtone„'colors„blue = 1„greenB = 2„cyan = 3„red = 4„magenta = 5„rust = 6„white = 7„grey = 8„blueB = 9„green = 10„cyanB = 11„orange = 12„magentaB = 13„yellow = 14„whiteB = 15„„„'draw etch sketch„LINE (120, 75)-(440, 275), blueB, B„LINE (70, 30)-(500, 330), blueB, B„PAINT (1, 1), cyan, blueB„PAINT (71, 31), red, blueB„PAINT (121, 76), grey, blueB„CIRCLE (145, 300), 20, blueB„CIRCLE (410, 300), 20, blueB„PAINT (400, 300), white, blueB„PAINT (150, 300), white, blueB„„'text„LOCATE 2, 26„PRINT " F2=CLEAR  ESC=QUIT "„LOCATE 22, 22„PRINT "  Etch Etch by MorisiWare  "„LOCATE 23, 22„PRINT "      Copyright 1996       "„„END SUB„„SUB errtone„SOUND 450, 2„SOUND 500, 4„SOUND 450, 2„„END SUB„„SUB instructions„SCREEN 9„CLS„FOR i = 50 TO 90 STEP 5„LINE (125, 1 + i)-(500, 250 - i), 3, B„'LINE (125, 1 + i + 1)-(500, 5 + i), 4, B„FOR delay% = 1 TO 15000: NEXT delay%„NEXT i„LOCATE 9, 18„PRINT " Draw by using Arrow keys on the Number Pad "„LOCATE 11, 18„PRINT "               Press Enter                  "„pause„END SUB„„SUB pause„DO UNTIL INKEY$ <> ""„LOOP„END SUB„„SUB quake„delay = 5500„FOR x = 1 TO delay„OUT &H3D4, 8: OUT &H3D5, x„NEXT x„„END SUB„Kurt Kuzba                     WRITING PIXELS IN MODE 12H     FidoNet QUIK_BAS Echo          06-22-96 (00:00)       QB, QBasic, PDS        48   2029     PUTPIX12.BAS'   I also worked out a pixel location algorithm for 4-plane„'graphics memory and designed a mode 12h putpixel with it.„'Notice that there is a four-step process in the pix12 routine„'which could be served by a FOR/NEXT loop. Unrolling such loops„'is a standard method of speed optimization.„„'_|_|_|   PUTPIX12.BAS„'_|_|_|   An example of writing pixels in video mode 12h.„'_|_|_|   No warrantees or guarantees are given or implied.„'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba.  (6/22/96)„DEFINT A-Z„DECLARE SUB pix12 (vertical%, horizontal%, c%)„DIM SHARED bitfield(7) AS INTEGER„   bitfield(0) = 128: bitfield(1) = 64: bitfield(2) = 32„   bitfield(3) = 16: bitfield(4) = 8: bitfield(5) = 4„   bitfield(6) = 2: bitfield(7) = 1„SCREEN 12„FOR y = 0 TO 639: pix12 y / 1.3, y, 5: NEXT„FOR y = 0 TO 639: pix12 479 - (y / 1.3), y, 14: NEXT„FOR y = 0 TO 639: pix12 y / 1.3, y, 14: NEXT„FOR y = 0 TO 639: pix12 479 - (y / 1.3), y, 5: NEXT„FOR c = 15 TO 0 STEP -1„   FOR y = 308 - 5 * c TO 316 + 5 * c„      FOR x = 234 - 5 * c TO 242 + 5 * c„         pix12 x, y, c: IF INKEY$ <> "" THEN SCREEN 0: END„      NEXT„   NEXT„NEXT: WHILE INKEY$ = "": WEND: SCREEN 0„SUB pix12 (vertical%, horizontal%, c%)„   IF (vertical% < 0) OR (horizontal% < 0) THEN EXIT SUB„   IF (vertical% > 479) OR (horizontal% > 639) THEN EXIT SUB„   DEF SEG = &HA000: OUT &H3CE, 4: OUT &H3C4, 2„   P& = vertical%: P& = P& * 80 + horizontal% \ 8„   bit% = bitfield(horizontal% AND 7): bitmask% = 255 - bit%„   OUT &H3CF, 0: OUT &H3C5, 1: B% = PEEK(P&) AND bitmask%„   IF (c% AND 1) <> 0 THEN B% = B% OR bit%„   POKE P&, B%„   OUT &H3CF, 1: OUT &H3C5, 2: B% = PEEK(P&) AND bitmask%„   IF (c% AND 2) <> 0 THEN B% = B% OR bit%„   POKE P&, B%„   OUT &H3CF, 2: OUT &H3C5, 4: B% = PEEK(P&) AND bitmask%„   IF (c% AND 4) <> 0 THEN B% = B% OR bit%„   POKE P&, B%„   OUT &H3CF, 3: OUT &H3C5, 8: B% = PEEK(P&) AND bitmask%„   IF (c% AND 8) <> 0 THEN B% = B% OR bit%„   POKE P&, B%„END SUB„'_|_|_|   end   PUTPIX12.BAS„Tika Carr                      GUI PROGRAMMER'S LIBRARY V1.23 FidoNet QUIK_BAS Echo          08-09-96 (17:04)       QB, PDS                259  6892     GUI123.BAS  'GUI123.BAS 8/9/96„'GUI Interface Programmer's Library v. 1.23„'for QuickBasic 4.5„'Copyright 1996 by Tika Carr„„'Contact:„'Tika Carr 1:2613/601„'kari@rochgte.fidonet.org„„DECLARE SUB clrscrn (clr%)„DECLARE SUB drwbtn (ds%, dc%, dfs%, dfc%, dx1%, dy1%, dx2%, dy2%)„DECLARE SUB gprint (z$, x%, y%, c%)„DECLARE SUB Mouse (a%)„DECLARE SUB PopInp (Prompt$, T2Len%, x1%, y1%, CurClr%)„„'$INCLUDE: 'qb.bi'„„COMMON SHARED mb%, mi%, mt%, mx%, my%        'mouse variables„COMMON SHARED black%, white%                 'used for palette„COMMON SHARED T2$                            'PopInp results„DIM SHARED Inregs AS RegType, Outregs AS RegType        'Interrupt„DIM SHARED Regs AS RegTypeX                             'InterruptX„„SCREEN 12: CLS      '640 x 480 16 color VGA 80 x 30 text„„'** PALETTE ASSIGNMENT **„„' Color 0 and Color 15 are system colors (black and white) and should„' not be changed as they are used for buttons and such.„„black% = 0: white% = 15„„DEFINT A-Z„„WIDTH 80, 60„„'Clear the screen to color #3 (Cyan)„CALL clrscrn(3)„„'Change white to be 7, causing the boarder highlight to be grey„'instead of white. Change the menu bar to be white, then draw menu„'bar, and change white back to color #14 (white)„„white = 7„CALL drwbtn(2, 15, 0, 0, 0, 0, 639, 20)„white = 15„„'The "Exit" box in the upper left.„CALL drwbtn(2, 7, 0, 0, 2, 2, 18, 18)„CALL gprint("X", 6, 4, 0)„„'The "Help" box in the upper right.„CALL drwbtn(2, 7, 0, 0, 619, 2, 637, 18)„CALL gprint("?", 624, 4, 0)„„'Menu Options„CALL gprint("File", 55, 3, 0)„CALL gprint("Edit", 107, 3, 0)„„' A boxed frame text box„CALL drwbtn(4, 9, 10, 1, 10, 30, 629, 459)„„' Some text in the box„a$(1) = "Here is an example of some things you can do in the GUI interface."„a$(2) = "I want to thank Douglas H. Lusher for his help in writing the gprint"„a$(3) = "routine. He developed a faster way to print text on the screen. This"„a$(4) = "routine does what the PRINT statement can't: Prints text virtually"„a$(5) = "anywhere on the screen, and transparently over the graphics."„„y = 34„FOR g = 1 TO 5„    y = y + g + 16„    CALL gprint(a$(g), 32, y, 14)„NEXT g„„Start:„'Loop to trap mouse events„CALL Mouse(0)       'initialize mouse„CALL Mouse(1)       'show mouse„„WHILE mb = 0        'trap events„    CALL Mouse(3)„    LOCATE 60, 1„    PRINT mx, my, mb;„WEND„„'The "Exit" box in the upper left clicked on.„IF mx > 2 AND my > 3 AND mx < 18 AND my < 18 THEN„    CALL Mouse(2)   'hide mouse„    CALL drwbtn(1, 7, 0, 0, 2, 2, 18, 18)„    CALL gprint("X", 6, 4, 0)„    FOR delay = 1 TO 30000: NEXT„    CALL drwbtn(2, 7, 0, 0, 2, 2, 18, 18)„    CALL gprint("X", 6, 4, 0)„    CALL PopInp("Do You Really Want To Quit?", 1, 160, 120, 3)„    IF LCASE$(T2$) = "n" THEN RUN ELSE END„END IF„„GOTO Start„„SUB clrscrn (clr%)„LINE (0, 0)-(639, 479), clr%, BF„END SUB„„SUB drwbtn (ds, dc, dfs, dfc, dx1, dy1, dx2, dy2)„IF ds >= 3 AND ds <= 6 THEN c = dfc ELSE c = dc„SELECT CASE ds„    CASE 1: GOSUB dOn„    CASE 2: GOSUB dOff„    CASE 3: GOSUB dOn: GOSUB Inside: GOSUB dOff„    CASE 4: GOSUB dOff: GOSUB Inside: GOSUB dOn„    CASE 5: GOSUB dOn: GOSUB Inside: GOSUB dOn„    CASE 6: GOSUB dOff: GOSUB Inside: GOSUB dOff„    CASE 7: GOSUB Dsqu„    CASE 8: GOSUB Dsqu: LINE (dx1, dy1)-(dx2, dy2), black%: LINE (dx1, dy2)-(dx2, dy1), black%„    CASE 9: GOSUB Dcir„    CASE 10: GOSUB Dcir: CIRCLE (dx1, dy1), (15 - dfs) \ 2, dfc: PAINT (dx1, dy1), dfc, dfc„END SELECT„„GOTO Ddone„„Dsqu:„    LINE (dx1, dy1)-(dx2, dy2), black%, B„    PAINT (dx2 - 4, dy2 - 4), c, black%„RETURN„„DBold:„    GOSUB Dsqu„    LINE (dx1 + 1, dy1 + 1)-(dx2 - 1, dy2 - 1), black%, B„RETURN„„dOn:„    GOSUB DBold„    LINE (dx1 + 1, dy2 - 1)-(dx2 - 1, dy2 - 1), white%„    LINE -(dx2 - 1, dy1 + 1), white%„RETURN„„dOff:„    GOSUB DBold„    LINE (dx1 + 1, dy2 - 1)-(dx1 + 1, dy1 + 1), white%„    LINE -(dx2 - 1, dy1 + 1), white%„RETURN„„Dcir:„    CIRCLE (dx1, dy1), dfs, black%„    PAINT (dx1, dy1), dc, black%„RETURN„„Inside:„    dx1 = dx1 + dfs: dy1 = dy1 + dfs„    dx2 = dx2 - dfs: dy2 = dy2 - dfs„    c = dc„RETURN„„Ddone:„dx1 = dx1 - dfs: dy1 = dy1 - dfs„dx2 = dx2 + dfs: dy2 = dy2 + dfs„„END SUB„„SUB gprint (z$, x%, y%, c%)„Regs.ax = &H1130„Regs.bx = &H600„CALL INTERRUPTX(&H10, Regs, Regs)„CharSegment% = Regs.es: CharOffset% = Regs.bp„CharWid% = 8: CharHgt% = 16„„DEF SEG = CharSegment%„XX% = x„FOR Char% = 1 TO LEN(z$)„   Ptr% = CharHgt% * ASC(MID$(z$, Char%, 1)) + CharOffset%„   FOR Ln% = 0 TO CharHgt% - 1„     BitPattern& = PEEK(Ptr% + Ln%) * 256&„     LineFormat% = (BitPattern& - 32768) XOR -32768„     LINE (XX%, y + Ln%)-STEP(CharWid% - 1, 0), c, , LineFormat%„   NEXT„   XX% = XX% + CharWid%„NEXT„DEF SEG„END SUB„„SUB Mouse (a%)„Inregs.ax = a%„CALL INTERRUPT(&H33, Inregs, Outregs)„mb = Outregs.bx     'button 0 = off 1 = left 2 = right„mx = Outregs.cx     'x coordinate„my = Outregs.dx     'y coordinate„mi = Outregs.ax     'init (dummer variable)„„END SUB„„DEFSNG A-Z„SUB PopInp (Prompt$, T2Len%, x1%, y1%, CurClr%)„„IF LEN(Prompt$) > T2Len% THEN PBoxLen = LEN(Prompt$) ELSE PBoxLen = T2Len%„x2% = x1% + (PBoxLen + 2) * 8: y2% = y1% + 64: nx = x1%: ny = y1%„„CALL Mouse(2)„BitsPerPixel = 1: planes = 4        'Screen Mode 12„Ary% = 4 + INT(((x2% - x1% + 1) * (BitsPerPixel) + 7) / 8) * planes * ((y2% - y1%) + 1)„„DIM VScreen(1 TO Ary%)„GET (x1%, y1%)-(x2%, y2%), VScreen„„CALL drwbtn(2, 7, 0, 0, x1%, y1%, x2%, y2%)„x1% = x1% + 8„CALL gprint(Prompt$, x1%, y1% + 8, 0)„„Inloop:„y1% = y1% + 32„'Input Field„CALL gprint(">", x1%, y1%, 0)„CALL gprint(STRING$(T2Len%, 219), x1% + 8, y1%, 15)„„'** Turn on and show cursor„x1% = x1% + 8„cursor$ = CHR$(219)„CALL gprint(cursor$, x1%, y1%, 4)„„'** Get Input and move cursor„„T2$ = ""„1 T1$ = INKEY$: IF T1$ = "" THEN 1 'wait for keypress„st = ASC(T1$)„„'Backspace and erase„„IF st = 8 THEN„        'checks to make sure its in field„        x1% = x1% - 8: IF x1% < nx + 16 THEN x1% = nx + 16: GOTO 1„        CALL gprint(cursor$, x1% + 8, y1%, 15)„        CALL gprint(RIGHT$(T2$, 1), x1%, y1%, 0)„        CALL gprint(cursor$, x1%, y1%, 4)„        'subtracts deleted character from string„        IF LEN(T2$) >= 1 THEN T2$ = LEFT$(T2$, LEN(T2$) - 1)„        GOTO 1„END IF„„IF T1$ = CHR$(13) THEN GOTO 2  'End of input when ENTER is pressed.„„IF st < 32 OR st > 127 THEN BEEP: GOTO 1  'check for illegal character„„T2$ = T2$ + T1$„CALL gprint(cursor$, x1%, y1%, 15)„CALL gprint(T1$, x1%, y1%, 0)„x1% = x1% + 8„'checks to make sure its in field„IF x1% > (nx + T2Len% * 8 + 8) THEN BEEP: GOTO 1„CALL gprint(cursor$, x1%, y1%, 4)„„'Get more input„GOTO 1„„2 'Erase menu, restore what was underneath„PUT (nx, ny), VScreen, PSET„ERASE VScreen„CALL Mouse(1)„„END SUB„Kris Reeves                    QUICK MAZE MAKER               kc7hrh@seamac.wa.com           08-20-96 (15:44)       QB, QBasic, PDS        179  11255    QMM.BAS     'Batch Installation instructions:„'You MUST have PKUNZIP in your path statement for the install batch program to„'work. it would be best if you extract the zip file and the install batch„'program into the C:\  directory. Otherwise, you will need to move the QMMPRO„'directory to your root directory after installation.„„'Manual Installation instructions:„'Make a directory named "QMMPRO" on the root directory. move the zip file to„'this directory. Unzip the ZIP file USING THE STORED PATHS (-d switch if„'you're using PKUNZIP).„„'To Run QMazMakrPRO:„'>From the DOS prompt in the C:\QMMPRO directory, simply type: QMMPRO <ENTER>„'This program is made to run from DOS and quit back to dos, so if you have„'QBASIC, you don't have to fiddle around inQbasic with running and quitting.„„'Notes:„'This is the first program I've ever completed and uploaded somewhere. I would„'really appreciate comments on any aspect of the program, suggestions, etc.„'Please write me about the "Checking" feature explained in the .BAS file! I'm„'a little confused as to whether or not i even need that! Also, I have little„'experience with saving files and doing so efficiently. Please tel me if you„'know of a better way to save my files!„„'You can e-mail me at KC7HRH@Seamac.WA.COM with comments, suggestions,„'questions, or problems.„„'I plan on making installation improvements and some other stuff in the future„'if enough people like this program, including much more flexible„'installation, possibly taking out the "Checking" feature (explained in the„'.BAS file) and compressing saved maze files.„„'Thanks for trying out QMazMakrPRO!„„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"QMM.ZIP",4^6:Z&=6937:?STRING$(50,177);„U"%up()%9%%%#%%wS%1F%%%%%%%%%%%%%%%+%%%%rf&)jxT%up()%/%%%I%%zU71F„U"XT%9LF%%%%F%%%%0%%%%hf%yfqt%lSrr%uEXE%2/ij%rtrf&)j2/%ijrt/.y&t%„U"2/ij.rt.X%2/up%()9%%'%-%(3Y1FB6kc[%>%%%%M%%%%/%%%%vrru%wtSh%klx„U"UmWzY^7wU-)A$5[g3mFB(..#QJ&P)%u%p()9%%'%-.%yY1CFq3N%Z.7%1%j3%%%„U"/%%%%vrr%uwtS[gfxfjaTATs]+h'fkdC1DxYYadBpEeN=26&D$8p4AXyiH9.^.T„U"N-S'+Lpsfs/1P.Z9lb,z*$&3?'Y*Efq,;HeLA&'dA')?L%h\S2sYX9kr$BPwQW.„U">LuanFfo&:IPX01mlO%sSK[H&*$^RIB6b0bUoH9ngg-R0)?K?<gH52$zXT+h#B%„U"(-b-XL-fluhVqoS;<S#;R$f8t?7;;ejxKl&OuegEJKL?:h+[Xs)iNlP6lx,5TdH„U"=+v%wA-p/#o)W$u5'S0igTJ*o[/OBO8g'T#60tOGc*;+8=Ur;pUq[0[VClgM&e[„U"4gQ]X-)l&j#7U$oz9NWAjFW%#+zE<Z70//Fx1xt5BGEMEuO34g1;Cu.s&8k(=mR„U"PrV02308Ev<M0<=699Spo<A;)BN=uK,.EP=u-S?^[P/Uj0g-ra2D=XQP_f]8tPf„U"W+us(A7<8?U#PcBjV-45D1_BoDl$w7sA]a;&5:$u36H7,C/SL8EL2s/VqrH)PwR„U"sY)L<X-9\rTFed:NP*l+'prmBjVr[$$FxesnsDjWBWpwB\w3E50aS8ZG)$%UFoY„U"2EOH&/68s3aaDJ7O-vQFXi#D5lR>)GF1'F-5%]mT-#bD^umUX?Osb^?ZU;AHItT„U"1Wue5'F=N4jqD1Ud2,?Hhga4d]\xT&VT?\uxS+EfI9x44XWDa]AKctC]FgAK7)[„U"aCkr*MLDuc0j$jG<-vL*_tK3Qst%XEVB79Tq8m:)fj*J,M8EJLuV+Y%^V7eTYOH„U"PEiY[/9L$G7-nDM%RN8S0JuI;G/cIHSs_\=ZoqiPWb1e&N*M\]4%V2IFUhP_NP.„U">S7xh;6uje5%U'Snf,tm\TT?4*Iy+h<-9<WAEXS?ih28R7-BC>)GZD=qeir#%yQ„U"c?Ll2XaU</1=zR0vm<eaE^-E>,hkwB$rZzf&cf&X6WR8mDF]8Wi5R/8e1DD(W-_„U",?Y(Q7#(Tvgh&SP;MTqQASKH3s)6W7LXkBt&J*.wypr/yPW$fHzCfM*q;0kHL>c„U"bi?amV'<'u6\R2ZpW*9NJ>=65-0vd_j1S,6l864.juH)lienn4rV-XM-/0q(rmM„U"Xe*<T^U9:Y49G.40%DZ1aRTguI]G+LOyB*c4Z/z/*Jo<&&0X+v/#XF0u1O9MkJ[„U"cNgs9BCV;F7]B*^u:s#9D&3I+-e#wB9yy*^TyS=D9NLTSa?l(/f2(j47Rpb*n=o„U"V;+(=8^nB/.lf&gpOxII;n;^J&0_lCJkCF3/K^+aWUgp(I>>HEFu^Hp6ft%5W#\„U"w*z<P7c5A_N>T(&)yt7\e\+c/Ta8uIYUeLxUJ&:(3aTnc&wk_f):3=hb&JN7(nV„U"*kzy#L#['UT/E729xxJ$_utX3GQ+SK;6+c3/p'[S]wRTdI::;q$T]jZsH##Z_v:„U"$g[VRW0o0S(#Q(Zcqu6M855u5l(7P^r-Ji+Re2=;>&hOtFm0_%i](;1bP'=n70t„U"i&wdNK-haNN))+.hDYP6cN^uhRU$QBm.At)wbLZ-bL-uc'Hy;(3iowDzFQ,(IGI„U"8'%BadUjY8L<'cp90c/A^l,Oo;kd0N93-640<YM[qg.KBA%b3b[5.HTCuQlITs.„U"QId5S4iq=Lfb'rfk;wj_e#(*4n5<;_cE&YI[_C.4[s$HneVjIsbkj:l33^<BFDn„U"Ec=m?%;4LmSV6.RJ*W5b922'BQFZ^q]w63,0M6/RlrNrVOOk(j(qf-jFSTPATRb„U"RRU3n:PdOp,osU\+tTHtjVlDw?RHxxSJCN1:vD5tl/3>$+;V(M5sht1g$W$K3f.„U"p2\nSn(Fp[x-;LkM(qFb%>]?pUief5cx$L<RdQdYw),DhDQl6,lkd#Y1(fx3IFV„U"9[^\wuVLYx<5Y1ui]U750L5#:2E=D:1HUlIglj^cvT8NgLOZgeWl4>?(0F\idF\„U"ZG:Hh75:pdPS4Q52&mcDUxmPq6&ml<Wr6Ij>M1D%B'Vp,J+nq&m<sspjO^(L5eL„U"5?iMtWoTCBBqg.45WaCJS8w#wLaV2cLuYg_7ItcJJdLHX7+#tk_m+AqKRi/tq1r„U"Y91N7.mSoN_?4&&YCiOhyK'ECZ49IVFCJ+>REXlQ6yI%Nf&=M9d7N;d$&_zgxsR„U"IF'QTsXl'55hgX:X;.$MI+r8i#z4Af&(%mMRA0aM*m'mfhTG1pdXA4^C.7[Lo\[„U"Fbp#hi0q/mpsU-H\Q6YaJ=QRN[&2pF.r,ivX3B9a-r^ZOW#f3Y]r+=[2<hmI,>#„U"ioj,zrU,<39HN8=$lpY^[6Qst;2hCkV_GX=\;[E+y:p/_gkau/RJHp,>tf,ZOE_„U",VLCVqjW(*b)+HcgN.$N,^CQkbwSQnTnr;fKR+z1>g>vE^k]D*F\T]M,kNN$Pg9„U"W9/ybP,Ur[5ENE52o+hfh:WF[#Pl.Hc&J2oant+[2[e.fz;B$T+^'#k8;>End7M„U"e%p%85xP<K:z4ae(C4;camGf#Xo<8Nl2/^FB\vP%ha41d=Xe>31$5u0G5zvDASb„U"uO1.j&m(FOGpFJv/S$kUB54&K>>Z7$01:_8Ipc*<\-jRwC)d^A$YXFD2s+v26Jd„U"1<jcSUOtcRWWF?gjo;q*-PXTJD1-r%LQW'[pyQ$[:muW.h\<E]DOfF8vr+kAcLg„U"-OkcjsA_$Pl:AFgEQP$G>.:#6U0WhJ]wS1um*d$?\\<3vq>LH\sLUJIZG$(LC*5„U"add*aD?;82cv0%c_,IL-R,3Ibj*I=Ci_3blWs;klMXtaf;U>D?=2Yl(u'\nV1gD„U"KErKO1x(RHwd7dtm#x5<J7gx1f_Y]i+uLWlP&z'pCDroheCa3$6TC+sef[RqG3q„U"fDB7#cUqXn&K&/ZAO:-p%Q_TXh4:SMm]TQ9I$V0)'=LY3$l_9Uwn^&wf'-2BobJ„U"N=LatJ37u=xMDE^l7^4<MBUTnWprCOK_v.w_7>5VT*4'Ueu7*WOD\Pp6J0p#hVD„U"nlQJ?HKokk\YTqMgxBATYB<pA#)\k'H\[VN93VAht'Iui>8FdtD:MEd26PBVMSq„U"u^>ou$v;*PU,u88?xE49P_64wv\0MLyR#(Q3Z6%mgTawQMmI5jhEdECACCz'MV8„U"s9-SGQAHaN)a4RI63MG?Gm9Gt&jQPRBK19Iz3sq1=R4e;3YsdoS(5eMQRJsVZ2/„U"aR8k^V\7u[-=W)T,Iw2APE.%Y3l#<IHe;#R%5UW5YaixT#0Jj#VN/eIrWA<*AE\„U"g;.1K#P\l985ph4#2HgRa_+:]8DZ-d+vM[E<RfppHN#t60pK^Y%8O>P;M;Z0cdR„U"Pz7$i3;0pN$aHxYfdW8+)&igsE<78:.>f<zK$y3_osDUj*at4nScyeGo2k:?8i'„U"g9>X2U-13n1)]ngH)-M\&\Ip[);#[CaM:I'ZGYN5p&s/68+5pp>UBAR\Qfsx[YG„U"oI-U2Y$/L7>.m:jkisj$Yxsl*#^2$VT2<aanZV<*WAx]_GkN)/t5.OfA\I^<6D+„U"4UtF'xS;a/Bdyr24Cae6nj3B:EX-u<AHiv1G_<>^umf;774Aw,;_MN^un0;wVkA„U"qr5,EodQMPNn&9Hwq4F/vQ<;_m%/U?)WqtuIJka;Rs'jB%9*l(Iz+5T15Tg]7+L„U"^Q(E2Zo'5Xt<_T%;0orkh:'87KJ?uik>-U6T_#&0H-rk:q'=7JO__j>*.e2Pki&„U"2AVY5d'<,qR_(Kl[8*f)^ABl(TzQRPDR6j==xmL6,6IMYUFU.'uhaBop,XzLegT„U"vMO[KJbkl9oU3<K0(:oNpaOEgY&#M74'GMk-p_?[-HQ5=c?K7Z)eZi1f3?vLsrM„U"y:m2ED[TpGer>jPEV(0:K>.DfuMFY52i%c2ifkv,jN3H2%1/gG)DHL*H3>ArKRQ„U"\]DZp_]Vhzt.F.iC7.aP*J?3/sEBO;g]+J6tCSU=>eqCzk\qZR_P6\MY&lt>x4m„U"Er<JS.)P0+EjgLbo].iT=T8u+A:c9%Q;untp41wH\it+lu(8w+E[(2$LcNgmbpb„U"8Ebq]lxNeeOwC$S=G[\\x;=XhiaGxM3%idH4(Fa3,8cJXBC#P$>AmhZHa7<\7\/„U"6ndxcH#yT8DUl17aJc-XXsS2jUxMSE9jP/:0H'^'EQnuH>$O<cYRZD<.cJcOBl9„U"<fmb>?^8E\<3U3&\Ja8FOVl^HP6r^\#JjaY#i\hmFum5B,E*m\HQ-XBUJdTg?O_„U"JHIOw2.TGR6q4Cbxbq(RbjeVK4\6HICNE^imEYid80xVa%B:\Z_Jt#cF$s:ML_r„U"6pGg-Gkhp/f&);[]Uq))8RO5p1-(n6<Vlleeu^Kh539%/C=092=b2^xbI.t7ej<„U"v(sk2-4NV=>8Nw9k:X#Xt'MiRZGcQAA&?xL?5fX=1p&8GA-^?>LiW0gB)\C(/j+„U"v-aiAuW?\gVO2pk#[?SfH7;fIMVbWAb-P4N_QS<'pSyLi0y=_mc^^n(Wbd<+pqV„U"c#Nrj]5NBx6624(w*eteBYyO.rY+l5Q9]XRmM,:t-O-+ls-2W*G>%wMGZCp_B,&„U"$/T(sm$xl;EUBfwtetJfF^9)2-NYn2SDT*_+Zzi(cB'CO=NZMTJ?heAZKo([kyN„U"2-WbON=</A2DBlp8mGu?&FaHb%PG8wAtGip<K'+lNG.l%;*3GSP^.npGS$P;bf5„U"M<M*euQi:cA20uX7bi[^?V1b%+fS]\BAB:gM_''<o3WA=Sy1qcH0NH<ka0j/Rr]„U"(G9U-lFq$\8SmgTTARH5wD^Y%[-GVVB0V$QUwYef\n8]>ORa'q:X6I_\^\R:pI'„U"zZ$\v5I6RXnb+oT8$DQ/b6RZ3n7Y+$;Y0kY&OhN86kUs=vX-N3F[1HPsJzlNV_q„U"qitM6'2pF_3FSPRCY:li[+OV<n6e&ql1<HWYzvc1i&LBI/7/Mg_+OD4HYxGk.gW„U"/qqPY7vn)9,Mt]L1,Z)fO*QlG02crKO/B)cbZrNEWAX.1jRPY.;m%%<eu:L2t%m„U"n-bq8U&L1f:4N1m%U[ThPrJKk8YV37PW%_P\5(vC5>6>RjrEW,[>+4r^.U0JLnu„U".66U+1'5g,bg5/=mY]9EiBymZ$PYckL;z=I;[4-b'H;?Q00(Z5A-);7/OUo;a:T„U"1#n'LcOy1bXR<2\XNcGJZl(=2Cp,4r9,eOOst:T$iM_KuVUt[jdg8d0_XE=4uT1„U"Wa5eE%a^[.T:JLVSmeEHT>FOLe:.LNJddKezmRjb6_6;LP6j:kHjJ<G1g)JWL?6„U"19AFE;#F;cSWK*&k(B-^6Be(^ToiH&q-RRu2bGup*3mt+$G[itBwtxJj7x2tKxf„U"x>2kd'K_EXFQ:&U1'rEjQh+B/)7&1)>Q&t)/T\6NOd(q0yQPj^&Wj5*[*5?jI$i„U"FwKWK)s=:Nn[pl#07?EGqclv,m*Ua$t%pb%bqn=d7D2o44^2qU]r.c1maA;B6W7„U"a*6Y^$+=rt[4kb-Q]0,ok(#H\LE$xmpa/SS8AL<rEM''U^GGF'D8G[8hrZtn0f%„U"p$RM'l1zSA6x6-B$fv=P49X3B;F&i03P2h3SLp2UnIVn_i=eBGT;[e<rGwTruQe„U"$=#6]anK/d2>$([2h?Z_s*J1/l0k$=?L-P/r%(Gu7pXgw[2G9dLmd=T5c7W]PQ?„U"E9N*^^uDE)AS8+7?n8tn\]Ghir$X510c[x;XB)YhYj1zQ1[IZVjcH1:+&&/J<+#„U"vjdqfN89jdVf^eTKqeV(q_fmrPN2BS=&x$;]ar4Fe%#0;eq)a#QVc+0d0[6Zit.„U"1oP6i:J)DYZ,Od#)9'UP]FIwP<YlqMNdRB7\_2Rx2tzKJv>b'p)^fmX<Um%eTW$„U"\Z.cWnPqnQ.]at,\]dlX(o^NVRL\=N0J<i(<gQrwgqqrNS8k9WmtFQ6/[bIi5jB„U"_ihawt$Em;qahk0cK#d+Dc-qeMaqFNSsD6g]mHjhHwAPI)0Hjp<,Uw4%up()%9%„U"'%#-%L4[1FVa3ok5&7%%3*%%%7%%%%rf&)jxT%ijrt.rf)j%SrruS,yD$\2V-5-„U"4C^]2Thibmq%qAaAseubp%DINII4*^7.ZIukdtXQdrGLNv-:lkBvJ8CTDOMIc0m„U"^G_(oE2XzIcb%JLDTqV:^^AMB6&40T,gt6zFsXG5v5Al_)2LWAb4BDpX1>5R8;&„U"jG_$ErWJ?<>*h(Ls5:\QROnEJ=<WEu<+2,B/t[6^MU.%p(S:>4/E\Ox/f?\%kq8„U"*cO7csK#U^JR/u2oj+Xi=ULUagfPB+ICHZqK'tL##kzPLGan'1ing5<n(M$QX5:„U"egT/q7?Jdf)1]DFh4h0M2;>l]%XELh1]dE,ppXJ0Pr0-jaCV\liS(6b8y7hDT5M„U"qR8UO9.StYxYBtjcFP[pn0g=dsLz4i8:lUU31iSlFFuhJ8Mfs:V-5.\2_-;1l7L„U"]XD/IY%a_'hL8Z.;XtC<i>g[/ZjGaHm?'v%NLN<=;<sM]4#zd;Ic+<iK'x,up%(„U")9%%'%-%)aS1FLsxl7&9&%%'3*%%%7%%%.rf)j%xTij.rt.y&&tSr.ru4y:f=<U„U"a14,AODsS=K93JO,J]3acavtRh3XaU;px\M#;rwALCn.^NtIKK9t=lb6w5-CrWP„U"$XoYdL.f%'Dl8?agnY+eTLe0T1'dlKHM]xPh)DB1m'5iYL3OJh4\&w,P%+L45IM„U"W1[o.+fUW)IaJLif1RdY9_MKp%21m/=9AMnT$3b4VqOnQLr1)=$(Yv:MJfFtUOa„U"fHBTJJgb(oa2Sre1;\,5KAU(u-/>V$'/P^_0C):<egDAL-1m[Zu'xAIVBM:He%f„U"VwzArzTqS0IKsI6O3Zp/kZ6$*YD2V\TcJF1pICe/9(X]POn09+$,<B3Ii0rMX+J„U"do_#Z,.;Uv6RN0fJ(Dw,^1UkGJ)Mw_F[Ya%(L6RA/C'27diRy$ZONfErk#iR\$_„U"]*=cxTi>q*IR=[sEbnaC>QsTlF8*HfZ3<#V)=g)sdM7_k\UaC#L8DO2Hj8T[.NX„U"Y2(.%up()%9%'%I-%zU#1FPa*'qO(%%%U3%%%5%%%%rf&)jxT%ijrt&.XSrIru<„U"&:n]]U+14\u_NwLE/QC/C/ocA3=aavtZb+&T&A25y.ws1p[Ij^HOd8n^t^$H8ut„U"p#suvnrsuvpn.X+O^BA\ccK^DKB$NCK\mW,lDBqrVp\u'pUk97c4L8',p#d;8)w„U"5ztLTZO^tGfE/^pD-fPY%-A6lF+_]29=nH6a\OpaLE#5YF*);V4An)aY2t5QC_v„U"Zj2S66fr4BEblGKQ%81+Oz11B.WkrV0\Viz<Vu]J*[<]7;-IW.;kP&=:<I/d6Qm„U"ZJH8Z9jE,baj_QTEha7&+/i[$%e1>2tu569p3GI5+edHHXK1ieZstMb%-Nb[h,h„U"F79FBx#9'y[_HU\)Y6Jx7IBKSCduyx0_S;u_(GU+Q/04+?-W:(g-VBRaAn\fMuX„U"\M(0a^rV^6Ja.9iO+'u;'K]2t4m*5s>Yx##yD8qYgB=;27eh.Mq?hN0aPW84(MQ„U"*)6?LS4(0M+T24$T=z'):R_pGS[0W(2ppPJhKCL+4:?\H#?t81l=\obg9oT$4e,„U"DXao52P?L#KDUqaYOKFG?sSp2dr/Gbrt.MI741P&>t.QmHgC:Le).xxu:K]qpTU„U"ClNw*G/I*j[9<p=/$m4LoUCDSiv#,W+kK$HIZ>F+jWT<#b>X6>rmM3%wJa.&W.6„U"[^=0[XbqEW3u4BW>c[B6^)xsn\:2kwo4zS-?kB\O%129jjU+Kn3NoGQ/3+A<<0C„U"8:w1Dt,0,EJukVYYl-Ko=%LU[UM\+qwfv+v3DyrUT[SD#o26PC*$O/pra*hK%ED„U"IL><_NbrD\&MU[SIHTeroHrN&q^9w[:(xmWC4%NfEizR?YWbW8tdFq.+:)v'pKb„U"qQ_wqY^51[_[rd)%k#%P_rJwkc--khyNar(\KFStVY1+K;$D:-#mbs/b4e_;lO9„U"$M)-pL-+JsE<J-)utsxQEa)$BfaMl-G3FX-EJUqd1'%T6oiqNrTAhCo8zgMP0v/„U"023[aD;6W[dtq%a0Q%4hw5;U//_,LKVb;A\PBuGu%gv5Ef,]eOjGJ03N;Faw1.^„U"QK(%up&'%9%9%%%%%%(wS1F%%%%%%%%%%%%%%%%+%%%%%%%%%&%U%%%%%%%%%rf„U"&)jxT%up&'%9%/%%%%%%)zU1F'XT9L%F%%%%F%%%%0%%%%%%%%%&%E%%%%I%%%%„U"hf%yfqt%lSrr%uup&%'9%9%%'%-.%3Y1+F6kc&[>%%%%M%%%%/%%%%%%%%%&%E#„U"%%%=%%%%v%rruw%tShk%lup&%'9%9%%'%-.%yY1CFq3N%Z.7%1%j3%%%/%%%%%%„U"%%%&%E[%%%(%%%%v%rruw%tSgf%xup&%'9%9%%'%-.%L41mFVao)k5&%+%3*%%%„U"7%%%%%%%%%&%E[%%%Y%7%%r(f)jx%Tijr#trf)%jSrr%uup&%'9%9%%'%-1%aS1„U"IFsxl)79&%+%3*%%%7%%%%%%%%%&%E#%%%E%9%%r(f)jx%TijrCt.y&%tSrr%uu„U"p&%'9%9%%'%-1%zU1dFPa'&qO(%%%U3%%%5%%%%%%%%%&%E%%%%5%;%%r(f)jx%„U"Tijr(t.XS%rruu%p*+%%%%%,#%,%j#&%%7%>%%%%%„END SUB„CLOSE:IF S=37AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Don Schullian/Jim Oliver       DRAW A CADIOID (DAISY)         d83@hol.gr                     08-30-96 (10:20)       QB, QBasic, PDS        156  6160     CARDIOID.BAS'Here's one for you that Jim and I got together on. It's kinda fun.„'Ok, this is it! No more beta versions of this thing! I'm DONE!„'Unless, of course, someone comes up with some improvements. :)„„'The code below runs under Qbasic but is slower than growing„'rocks so you may want to just draw one daisy and leave it at that.„„'Those of you with PowerBASIC will want to add BYVAL and„'LOCAL PUBLIC to the sub's declare line then tweek it all a bit„'to get it back into fighting posture; if you decide to keep it.„„'Anyhow, thanks for the great idea. I'm putting this one in the„'box with my polygon routines for later. It may just come in handy.„„'This, the final version will correctly draw Cadioid Curves (daisies)„'  **  of any number from 1 up to ???„'  **  uses the "ASPECT" variable like CIRCLE„'  **  will draw the curves at any degree of rotation„„'One of the demo's (RollingWheel) draws a wheel as it rolls up off„'the screen. CanioidCurves is used to draw in the spokes and ASPECT„'is imployed to provide perspective.„„'The other demo routine, (Daisies) draws 20 daisies on the screen then„'rotates them clockwize until the next lobe/petal/loop comes up to the„'12o'clock position.„„'Both these are pretty crude and intended to show the use of the main„'routine. In short, Speilberg and Lucas can rest easy for a while yet.„„'It may be worthy to mention here that this routine uses DEGREES of„'the circle and not RADIANS. I find it easier to work/think in„'DEGREES so that's the way I made it.„„'You will also want to play with the Aspect! variable. Try numbers„'between .5 and 1.6 for some neat effects with screen 12 or .75 to„'get round circles with SCREEN 9.„„'Anyhow, this one goes into the PUBLIC DOMAIN so have at it!„„'=================„' START TEST CODE„'=================„SCREEN 12„RollingWheel„Daisies„„'============================================================„'===  THIS CODE IS RELEASED INTO THE PUBLIC DOMAIN„'===  USE AT YOUR OWN RISK and all that legal rott„'============================================================„' CONCEPT: Jim Oliver        jim.oliver@welcom.net.nz„'CODED BY: Don Schullian, DASoft Software, d83@hol.gr„'CODED IN: The code is pretty well generic but may require„'          some small changes to run.„' PURPOSE: Draw a cadioid (daisy) to the graphics screen (12)„'  PARAMS: Col%    center column (pixel)„'          Row%    center row    (pixel)„'          Radius% radius in pixels„'          Asp!    aspect ratio  1 = normal for VGA„'          StartD! starting degree for "top" lobe„'                  0 is 12o'clock, 90 is 3o'clock, etc„'          Lobes%  number of lobes/loops/petals„'          Colour% color to draw in„'============================================================„SUB CadioidCurves (Col%, Row%, Radius%, Asp!, StartD!, Lobes%, Colour%)„„  IF (Lobes% MOD 2) = 1 THEN              ' an odd number of lobes„      Petals% = Lobes%                    '„      T% = 1                              '  stop after 1st pass„    ELSE                                  ' even number of lobes„      IF (Lobes% MOD 4) = 0 THEN T% = 2   '  only 1 pass required„      Petals% = (Lobes% / 2)              '  decrease # lobes„  END IF                                  '„  Pi2! = (8 * ATN(1))                     ' pi * 2„  Srad! = StartD! - (90 \ Petals%) - 90   ' adjust to find top„  XRad! = Radius%                         ' horizontal radius„  YRad! = Radius%                         ' vertical radius„  IF Asp! > 1 THEN                        ' aspect = 1 for VGA is normal„      XRad! = Radius% / Asp!              '   squish vertically„    ELSEIF Asp! < 1 THEN                  '„      YRad! = Radius% * Asp!              '   squish horizontally„  END IF                                  '„                                          '„  DO                                      '„    IF T% = 1 THEN                        ' compute starting degree„      Srad! = Srad! + (180 \ Petals%)     '„    END IF                                '„    Sr! = Srad! * (Pi2! / 360)            ' compute radians for degrees„    PSET (Col%, Row%), Colour%            ' center dot - sets LPR„    FOR T! = .01 TO Pi2! STEP .01         ' start drawing„      L! = SIN(Petals% * T!)              '  compute factors to„      P! = T! - Sr!                       '  use to compute X and Y„      R! = XRad! * L!                     '  general purpose radius„      X% = Col% + (R! * COS(P!))          '  compute column for pixel„      IF Asp! <> 1 THEN R! = YRad! * L!   '  if aspect other than normal„      Y% = Row% - (R! * SIN(P!))          '  compute row for pixel„      LINE -(X%, Y%), Colour%             ' draw line from LPR to new XY„    NEXT                                  '„    T% = T% + 1                           ' increase pass counter„  LOOP UNTIL (T% > 1)                     ' all done!„„END SUB„„' ------------------„' ---  DEMO SUBS ---„' ------------------„„SUB Daisies„„  CLS„  Col% = 50„  Row% = 50„  Rad% = 50„  Aspect! = 1!„  Colour% = 14„„  FOR Lobes% = 20 TO 1 STEP -1„    I% = (360 \ Lobes%)„    FOR StartD! = 0 TO I%„      CadioidCurves Col%, Row%, Rad%, Aspect!, StartD!, Lobes%, Colour%„      IF StartD! = 0 AND C% > 0 THEN SLEEP .5„      IF StartD! = I% THEN EXIT FOR„      G$ = INKEY$: IF LEN(G$) > 0 THEN EXIT SUB„      LINE (Col% - Rad%, Row% - Rad%)-(Col% + Rad%, Row% + Rad%), 0, BF„    NEXT„    Col% = Col% + 110„    IF Col% > 580 THEN„      Row% = Row% + 110„      Col% = 50„    END IF„  NEXT„END SUB„„SUB RollingWheel„„  CLS„  Row% = 400„  Rad% = 40„  Aspect! = 1.2„  StartD! = 0„  Lobes% = 11„  Colour% = 15„„  Col% = Rad%„  Sincr! = (360 \ Lobes%)„  DO„    CIRCLE (Col%, Row%), Rad%, Colour%, , , Aspect!„    CadioidCurves Col%, Row%, Rad%, Aspect!, StartD!, Lobes%, Colour%„    G$ = INKEY$: IF LEN(G$) > 0 THEN EXIT SUB„    Col% = Col% + 1„    Row% = Row% - 1„    StartD! = StartD! - Sincr!„    LINE (Col% - Rad% - 2, Row% - Rad% - 2)-(Col% + Rad% + 2, Row% + Rad% + 2), 0, BF„  LOOP UNTIL (Col% > 639) OR (Row% < Rad%)„END SUB„Douglas H. Lusher              VGA 640X480 PANNING            comp.lang.basic.misc           10-04-96 (09:52)       QB, QBasic, PDS        252  8318     VGAPAN.BAS  ' Greetings, fellow BASIC programmers.„' I just finished working out how to do pixel-by-pixel scrolling„' on a VGA card and I thought that this might interest some of„' you, so here's a quick demo. What this code does is this: it„' creates a virtual screen much larger than the usual SCREEN 12„' 640x480, then prints graphics to this larger virtual screen.„' When you press a key, the graphics stop being printed and you„' can use the arrow keys to pan around and observe different„' parts of the virtual screen.„„' When the VGA card sets up a screen mode, the Offset Register„' &H3D5, index &H13 contains the amount of display memory to be„' used per horizontal scan line. The virtual screen is made wider„' than the ordinary screen by increasing this value. The Start„' Address High and Start Address Low registers, &H3D5 index &HC„' & &HD contain the MSB and LSB respectively of the address in„' video memory where the displayed screen begins. Increasing or„' decreasing this value by 1 pans the screen left or right by„' 8 pixels. Changing this value by the amount of memory per scan„' line pans the screen up or down. Notice that horizontal panning„' by this method alone moves the screen 8 pixels at a time. To„' pan horizontally a pixel at a time involves the Horizontal„' PEL Panning register &H3C0 index &H13. Rotating the values of„' this register from 0 through 7 pans the screen pixel-column „' by pixel-column. Note that this register must only be changed„' during a vertical retrace and that an INP(&H3DA) command must„' preceed a change to this register. Also, bit 5 must always be„' set.„„' It is worth noting also that the normal BASIC graphics commands„' will not work on the larger virtual screen, so I have provided„' my own code to create the graphics in this demo. While the code„' for these graphics commands is good, it is just BASIC and is „' not necessarily optimised, so I realized that it is slow. That„' particular aspect is not the focus of this demo.„„ DECLARE SUB QPrint (X%, Y%, Text$, Culler%)„ DECLARE SUB DrawCircle (X%, Y%, Radius%, Culler%)„ DECLARE SUB PutPixel (X%, Y%, Culler%)„ DECLARE SUB DrawLine (X1%, Y1%, X2%, Y2%, Culler%)„ DEFINT A-Z„ REDIM BitMask%(0 TO 7)„ Mask% = 128„ FOR Bit% = 0 TO 7„   BitMask%(Bit%) = Mask%: Mask% = Mask% \ 2„ NEXT„„ RANDOMIZE TIMER„ SCREEN 12: ScrnWid% = 640: ScrnHgt% = 480„„ 'the width of the virtual screen in pixels:„ VScrnWid% = 832„ 'In SCREEN 12, the following must be true:„ '  VScrnWid% must be equal to or greater than 640„ '  VScrnWid% must be less than or equal to 1088„ '  VScrnWid% must be evenly divisible by 16„ HPanLimit% = VScrnWid% - ScrnWid%„ BytesPerLine% = VScrnWid% \ 8„„ 'the height of the virtual screen in pixels:„ VScrnHgt% = 624„ 'In SCREEN 12, the following must be true:„ '  VScrnHgt% must be equal to or greater than 480„ '  VScrnHgt% must be less than or equal to 819„ '  The product of VScrnHgt% multiplied by VScrnWid% must be less„ '      than or equal to 524288„ VPanLimit% = VScrnHgt% - ScrnHgt%„„ 'create the virtual screen:„ OUT &H3D4, &H13: OUT &H3D5, VScrnWid% \ 16„„ 'put up some graphics„ MinX% = 0: MaxX% = VScrnWid% - 1„ MinY% = 0: MaxY% = VScrnHgt% - 1„ CALL DrawLine(MinX%, MinY%, MaxX%, MinY%, 1)„ CALL DrawLine(MaxX%, MinY%, MaxX%, MaxY%, 2)„ CALL DrawLine(MaxX%, MaxY%, MinX%, MaxY%, 3)„ CALL DrawLine(MinX%, MaxY%, MinX%, MinY%, 4)„„ RR% = VScrnHgt%: IF VScrnWid% < VScrnHgt% THEN RR% = VScrnWid%„ DO UNTIL LEN(INKEY$)„   X1% = INT(RND * VScrnWid%)„   Y1% = INT(RND * VScrnHgt%)„   X2% = INT(RND * VScrnWid%)„   Y2% = INT(RND * VScrnHgt%)„   C% = INT(RND * 14) + 1„   CALL DrawLine(X1%, Y1%, X2%, Y2%, C%)„   R% = INT(RND * (RR% \ 4))„   X1% = INT(RND * (VScrnWid% - R% * 2)) + R%„   Y1% = INT(RND * (VScrnHgt% - R% * 2)) + R%„   C% = INT(RND * 14) + 1„   CALL DrawCircle(X1%, Y1%, R%, C%)„ LOOP„ CALL QPrint(8, 8, "Upper Left", 15)„ CALL QPrint(VScrnWid% - 96, 8, "Upper Right", 15)„ CALL QPrint(8, VScrnHgt% - 16, "Lower Left", 15)„ CALL QPrint(VScrnWid% - 96, VScrnHgt% - 16, "Lower Right", 15)„„ 'allow the user to pan around the virtual screen„ X% = 0: Y% = 0„ DO„  DO WHILE LEN(INKEY$): LOOP„  DO: KP$ = INKEY$: LOOP UNTIL LEN(KP$)„  KP% = ASC(KP$): IF KP% = 0 THEN KP% = -ASC(MID$(KP$, 2))„  SELECT CASE KP%„    CASE 27„      EXIT DO„    CASE 52, -75  'Four, LArrow„      IF X% > 0 THEN„        X% = X% - 1„        DO: LOOP WHILE (INP(&H3DA) AND 8) = 0„        OUT &H3C0, &H33: OUT &H3C0, X% MOD 8„      ELSE„        BEEP„      END IF„    CASE 54, -77   'Six, RArrow„      IF X% < HPanLimit% THEN„        X% = X% + 1„        DO: LOOP WHILE (INP(&H3DA) AND 8) = 0„        OUT &H3C0, &H33: OUT &H3C0, X% MOD 8„      ELSE„        BEEP„      END IF„    CASE 56, -72  'Eight, UpArrow„      IF Y% > 0 THEN„        Y% = Y% - 1„      ELSE„        BEEP„      END IF„    CASE 50, -80  'Two, DnArrow„      IF Y% < VPanLimit% THEN„        Y% = Y% + 1„      ELSE„        BEEP„      END IF„  END SELECT„  Ptr% = (Y% * BytesPerLine%) + (X% \ 8)„  OUT &H3D4, &HD: OUT &H3D5, Ptr% MOD 256„  OUT &H3D4, &HC: OUT &H3D5, Ptr% \ 256„ LOOP„ SCREEN 0: WIDTH 80„ END„„ SUB DrawCircle (X%, Y%, Radius%, Culler%)„ 'a routine to draw circles using only integers and integer math„ 'an implementation of Bresenham's algorithm„ 'by Douglas H. Lusher, 05-09-1996„ A% = 0„ B% = Radius%„ D% = (1 - Radius%) * 2„ XX1% = X%: YY1% = Y% + B%„ XX2% = X%: YY2% = Y% - B%„ XY1% = X% + B%: YX1% = Y%„ XY2% = X% - B%: YX2% = Y%„ DO WHILE B% >= A%„   CALL PutPixel(XX1%, YY1%, Culler%)„   CALL PutPixel(XX1%, YY2%, Culler%)„   CALL PutPixel(XX2%, YY1%, Culler%)„   CALL PutPixel(XX2%, YY2%, Culler%)„   CALL PutPixel(XY1%, YX1%, Culler%)„   CALL PutPixel(XY1%, YX2%, Culler%)„   CALL PutPixel(XY2%, YX1%, Culler%)„   CALL PutPixel(XY2%, YX2%, Culler%)„   IF D% + B% > 0 THEN„     B% = B% - 1„     D% = D% - (B% * 2) + 1„     YY1% = YY1% - 1: YY2% = YY2% + 1„     XY1% = XY1% - 1: XY2% = XY2% + 1„   END IF„   IF A% > D% THEN„     A% = A% + 1„     D% = D% + (A% * 2) + 1„     XX1% = XX1% + 1: XX2% = XX2% - 1„     YX1% = YX1% + 1: YX2% = YX2% - 1„   END IF„ LOOP„ END SUB„ „ SUB DrawLine (X1%, Y1%, X2%, Y2%, Culler%)„ 'a routine to draw lines using only integers and integer math„ 'an implementation of Bresenham's algorithm„ 'by Douglas H. Lusher, 05-08-1996„ A% = X2% - X1%„ B% = Y2% - Y1%„ DX2% = 1: DY2% = 1„ IF A% < 0 THEN A% = -A%: DX2% = -1„ IF B% < 0 THEN B% = -B%: DY2% = -1„ DX1% = DX2%: DY1% = 0„ IF A% < B% THEN SWAP A%, B%: DX1% = 0: DY1% = DY2%„ I1% = B% * 2„ D% = I1% - A%„ I2% = D% - A%„ X% = X1%: Y% = Y1%„ FOR I% = 0 TO A%„  CALL PutPixel(X%, Y%, Culler%)„  IF D% < 0 THEN„    X% = X% + DX1%„    Y% = Y% + DY1%„    D% = D% + I1%„  ELSE„    X% = X% + DX2%„    Y% = Y% + DY2%„    D% = D% + I2%„  END IF„ NEXT„ END SUB„„ SUB PutPixel (X%, Y%, Culler%)„ SHARED BitMask%(), BytesPerLine%„ DEF SEG = &HA000„ Offset& = (CLNG(Y%) * BytesPerLine%) + (X% \ 8)„ OUT &H3CE, 5: OUT &H3CF, 2„ OUT &H3CE, 8: OUT &H3CF, BitMask%(X% AND 7)„ Byte% = PEEK(Offset&): POKE Offset&, Culler%„ END SUB„„ SUB QPrint (X%, Y%, Text$, Culler%)„ 'this routine uses the VGA hardware to print text„ '  in 16 color graphics modes„ 'by Douglas H. Lusher, 06-08-1996„ SHARED BytesPerLine%„„ ' 8 x 8 char box, CGA„ CharSegment% = &HFFA6: CharOffset% = &HE: CharHgt% = 8„„ ' 8 x 16 char box, VGA„ 'DIM Regs AS RegTypeX„ 'Regs.AX = &H1130„ 'Regs.BX = &H600„ 'CALL InterruptX(&H10, Regs, Regs)„ 'CharSegment% = Regs.ES: CharOffset% = Regs.BP: CharHgt% = 16„„ REDIM BitPattern%(1 TO CharHgt%)„ Temp& = (CLNG(Y%) * BytesPerLine%) + (X% \ 8)„ VideoSegment% = &HA000 + (Temp& \ 16)„ VideoOffset% = (Temp& MOD 16) - 1„ OUT &H3CE, 5: OUT &H3CF, 2: OUT &H3CE, 8„ FOR Char% = 1 TO LEN(Text$)„   Ptr% = CharHgt% * ASC(MID$(Text$, Char%, 1)) + CharOffset% - 1„   DEF SEG = CharSegment%„   FOR Ln% = 1 TO CharHgt%„     BitPattern%(Ln%) = PEEK(Ptr% + Ln%)„   NEXT„   VideoPtr% = VideoOffset% + Char%„   DEF SEG = VideoSegment%„   FOR Ln% = 1 TO CharHgt%„     OUT &H3CF, BitPattern%(Ln%)„     Byte% = PEEK(VideoPtr%): POKE VideoPtr%, Culler%„     VideoPtr% = VideoPtr% + BytesPerLine%„   NEXT„ NEXT„ END SUB„Tika Carr                      GUI LIBRARY V1.23 W/DOCS       itaiya@juno.com                10-25-96 (14:07)       QB, PDS                380  11252    GUI123.BAS  ===================== GUI Interface Programmer's Library v 1.23 Docs„GUI Interface Programmer's Library v. 1.23 for QuickBasic 4.5 8/9/96„Copyright 1996 by Tika Carr„„These routines use the QB.QLB library.  I put everything you need into one„file, which is also a demo of some of the things that the GUI routines can do.„„CALL Mouse(x) x = 0 Initialize Mouse, 1 Show Mouse, 2 Hide Mouse,„3 Get mouse information„„You MUST CALL Mouse(0) to start the mouse. Then CALL Mouse(1) to show„the mouse. mx, my is the mouse coordinates and mb is the mouse button,„if you use CALL Mouse(3). These are global variables defined in GUI.BI.„„CALL gprint ("Text", x, y, color)„„This routine lets you print text on screen according to pixel location. Put„the Text in quotes. X and Y are Pixel locations, not LOCATE locations, so you„can go x up to 640 and Y up to 480. color is from 0 to 15 (standard VGA„colors). See GUI.BI for more info on Palettes and Colors.„„Buttons, Pop Up Menus, Frames, Check Boxes, Radio Buttons:„„CALL drwbtn (style, color, frame offset, frame color, x1, y1, x2, y2)„               |      |         |             |        |           |„               --------         ---------------        -------------„                Inside             Outside             Coordinates„            of button/frame        of frame„„3-D Push Buttons:„„Style 1 and Style 2 are for making those push buttons like "OK" or„"Escape", etc. Style 1 is a pushed in button, and Style 2 is a normal„button.„„CALL drwbtn(1, 3, 0, 0, 3, 3, 55, 18)   'Button is pushed (selected).„CALL drwbtn(2, 3, 0, 0, 75, 3, 121, 18) 'Button is not pushed.„„Note that the frame offset and color values are not used for push buttons.„„Framed Pop-Ups:„„There are four styles of framed popup type windows that give a 3-D„look:„„CALL drwbtn(3, 6, 10, 5, 3, 25, 103, 125)   'Frame Style 3 (On/Off)„CALL drwbtn(4, 3, 10, 2, 110, 25, 210, 125) 'Frame Style 4 (Off/On)„CALL drwbtn(5, 8, 10, 7, 220, 25, 320, 125) 'Frame Style 5 (On/On)„CALL drwbtn(6, 11, 10, 10, 340, 25, 440, 125)'Frame Style 6 (Off/Off)„„Style 3: Inlaid frame with embossed interior.„Style 4: Embossed frame with inlaid interior.„Style 5: Inlaid frame and interior.„Style 6: Embossed frame and interior.„„Note that we used an offset of 10 in the above 4 examples. This gives„us a nice frame boarder. You can set this at any size in pixels that„you wish. The color value after style is the color of the interior and„the color value after frame offset is the color of the surrounding„frame. The other values are the upper left and lower right corners of„the entire pop up.„„Check Boxes:„„Styles 7 and 8 create check boxes:„„CALL drwbtn(7, 4, 0, 0, 3, 135, 18, 150)     'Plain Check Box„CALL drwbtn(8, 4, 0, 0, 23, 135, 38, 150)    'Plain Check Box Checked„„Note again that the frame values are not used.„„Radio Buttons:„„Radio buttons use the values a bit differently from the others. They are:„„drwbtn(style, color, radius, center mark color, x, y, nul, nul)„„Styles 9 and 10 provide you with the standard circular radio buttons:„„CALL drwbtn(9, 9, 8, 0, 50, 143, 0, 0)     'Radio Button„CALL drwbtn(10, 9, 8, 15, 70, 143, 0, 0)   'Radio Button On„„The center mark color is the color of the dot that goes in the center„of a selected radio button. Only the x and y coordinates are needed,„and the other x and y parameters are 0 (not used).„„Popup Input Box:„„(New for Version 1.23)„„PopInp(Prompt$, T2Len, x1, y1, CurClr)„„Prompt$ is what you'd like to ask the user. T2Len is the maximum„amount of characters you will allow in the input field. x1 and y1 are the„upper left corner coordinates. CurClr is the color of the cursor.„„Example:„„CALL PopInp("Do You Really Want To Quit?", 1, 160, 120, 3)„„I think I'll stop here with the GUI project, due to the fact I just don't have„time to develop it much further. Of course, anyone is invited to add to it.„Hopefully this was a start.  This code is usable by anyone who wishes, as long„as they give credit to the proper people in their program code and in the„on-screen of the finished product (ie. in an "About" menu).  The code in this„library is not for commercial use.„„Tika Carr 1:2613/601„„CREDITS: All routines written by Tika Carr, except the GPrint routine,„which was written by Douglas Lusher.„„„================= GUI Interface Programmer's Library v. 1.23 Source Code„'GUI123.BAS 8/9/96„'GUI Interface Programmer's Library v. 1.23„'for QuickBasic 4.5„'Copyright 1996 by Tika Carr„„'Contact:„'Tika Carr 1:2613/601„'kari@rochgte.fidonet.org„„DECLARE SUB clrscrn (clr%)„DECLARE SUB drwbtn (ds%, dc%, dfs%, dfc%, dx1%, dy1%, dx2%, dy2%)„DECLARE SUB gprint (z$, x%, y%, c%)„DECLARE SUB Mouse (a%)„DECLARE SUB PopInp (Prompt$, T2Len%, x1%, y1%, CurClr%)„„'$INCLUDE: 'qb.bi'„„COMMON SHARED mb%, mi%, mt%, mx%, my%        'mouse variables„COMMON SHARED black%, white%                 'used for palette„COMMON SHARED T2$                            'PopInp results„DIM SHARED Inregs AS RegType, Outregs AS RegType        'Interrupt„DIM SHARED Regs AS RegTypeX                             'InterruptX„„SCREEN 12: CLS      '640 x 480 16 color VGA 80 x 30 text„„'** PALETTE ASSIGNMENT **„„' Color 0 and Color 15 are system colors (black and white) and should„' not be changed as they are used for buttons and such.„„black% = 0: white% = 15„„DEFINT A-Z„„WIDTH 80, 60„„'Clear the screen to color #3 (Cyan)„CALL clrscrn(3)„„'Change white to be 7, causing the boarder highlight to be grey„'instead of white. Change the menu bar to be white, then draw menu„'bar, and change white back to color #14 (white)„„white = 7„CALL drwbtn(2, 15, 0, 0, 0, 0, 639, 20)„white = 15„„'The "Exit" box in the upper left.„CALL drwbtn(2, 7, 0, 0, 2, 2, 18, 18)„CALL gprint("X", 6, 4, 0)„„'The "Help" box in the upper right.„CALL drwbtn(2, 7, 0, 0, 619, 2, 637, 18)„CALL gprint("?", 624, 4, 0)„„'Menu Options„CALL gprint("File", 55, 3, 0)„CALL gprint("Edit", 107, 3, 0)„„' A boxed frame text box„CALL drwbtn(4, 9, 10, 1, 10, 30, 629, 459)„„' Some text in the box„a$(1) = "Here is an example of some things you can do in the GUI interface."„a$(2) = "I want to thank Douglas H. Lusher for his help in writing the gprint"„a$(3) = "routine. He developed a faster way to print text on the screen. This"„a$(4) = "routine does what the PRINT statement can't: Prints text virtually"„a$(5) = "anywhere on the screen, and transparently over the graphics."„„y = 34„FOR g = 1 TO 5„	y = y + g + 16„	CALL gprint(a$(g), 32, y, 14)„NEXT g„„Start:„'Loop to trap mouse events„CALL Mouse(0)       'initialize mouse„CALL Mouse(1)       'show mouse„WHILE mb = 0        'trap events„	CALL Mouse(3)„	LOCATE 60, 1„	PRINT mx, my, mb;„WEND„„'The "Exit" box in the upper left clicked on.„IF mx > 2 AND my > 3 AND mx < 18 AND my < 18 THEN„	CALL Mouse(2)   'hide mouse„	CALL drwbtn(1, 7, 0, 0, 2, 2, 18, 18)„	CALL gprint("X", 6, 4, 0)„	FOR delay = 1 TO 30000: NEXT„	CALL drwbtn(2, 7, 0, 0, 2, 2, 18, 18)„	CALL gprint("X", 6, 4, 0)„	CALL PopInp("Do You Really Want To Quit?", 1, 160, 120, 3)„	IF LCASE$(T2$) = "n" THEN RUN ELSE END„END IF„„GOTO Start„„SUB clrscrn (clr%)„LINE (0, 0)-(639, 479), clr%, BF„END SUB„„SUB drwbtn (ds, dc, dfs, dfc, dx1, dy1, dx2, dy2)„IF ds >= 3 AND ds <= 6 THEN c = dfc ELSE c = dc„SELECT CASE ds„	CASE 1: GOSUB dOn„	CASE 2: GOSUB dOff„	CASE 3: GOSUB dOn: GOSUB Inside: GOSUB dOff„	CASE 4: GOSUB dOff: GOSUB Inside: GOSUB dOn„	CASE 5: GOSUB dOn: GOSUB Inside: GOSUB dOn„	CASE 6: GOSUB dOff: GOSUB Inside: GOSUB dOff„	CASE 7: GOSUB Dsqu„	CASE 8: „		GOSUB Dsqu„		LINE (dx1, dy1)-(dx2, dy2), black%„		LINE (dx1, dy2)-(dx2, dy1), black%„	CASE 9: GOSUB Dcir„	CASE 10:„		GOSUB Dcir„		CIRCLE (dx1, dy1), (15 - dfs) \ 2, dfc„		PAINT (dx1, dy1), dfc, dfc„END SELECT„„GOTO Ddone„„Dsqu:„	LINE (dx1, dy1)-(dx2, dy2), black%, B„	PAINT (dx2 - 4, dy2 - 4), c, black%„RETURN„„DBold:„	GOSUB Dsqu„	LINE (dx1 + 1, dy1 + 1)-(dx2 - 1, dy2 - 1), black%, B„RETURN„„dOn:„	GOSUB DBold„	LINE (dx1 + 1, dy2 - 1)-(dx2 - 1, dy2 - 1), white%„	LINE -(dx2 - 1, dy1 + 1), white%„RETURN„„dOff:„	GOSUB DBold„	LINE (dx1 + 1, dy2 - 1)-(dx1 + 1, dy1 + 1), white%„	LINE -(dx2 - 1, dy1 + 1), white%„RETURN„„Dcir:„	CIRCLE (dx1, dy1), dfs, black%„	PAINT (dx1, dy1), dc, black%„RETURN„„Inside:„	dx1 = dx1 + dfs: dy1 = dy1 + dfs„	dx2 = dx2 - dfs: dy2 = dy2 - dfs„	c = dc„RETURN„„Ddone:„dx1 = dx1 - dfs: dy1 = dy1 - dfs„dx2 = dx2 + dfs: dy2 = dy2 + dfs„„END SUB„„SUB gprint (z$, x%, y%, c%)„Regs.ax = &H1130„Regs.bx = &H600„CALL INTERRUPTX(&H10, Regs, Regs)„CharSegment% = Regs.es: CharOffset% = Regs.bp„CharWid% = 8: CharHgt% = 16„„DEF SEG = CharSegment%„XX% = x„FOR Char% = 1 TO LEN(z$)„   Ptr% = CharHgt% * ASC(MID$(z$, Char%, 1)) + CharOffset%„   FOR Ln% = 0 TO CharHgt% - 1„	 BitPattern& = PEEK(Ptr% + Ln%) * 256&„	 LineFormat% = (BitPattern& - 32768) XOR -32768„	 LINE (XX%, y + Ln%)-STEP(CharWid% - 1, 0), c, , LineFormat%„   NEXT„   XX% = XX% + CharWid%„NEXT„DEF SEG„END SUB„„SUB Mouse (a%)„Inregs.ax = a%„CALL INTERRUPT(&H33, Inregs, Outregs)„mb = Outregs.bx     'button 0 = off 1 = left 2 = right„mx = Outregs.cx     'x coordinate„my = Outregs.dx     'y coordinate„mi = Outregs.ax     'init (dummer variable)„„END SUB„„DEFSNG A-Z„SUB PopInp (Prompt$, T2Len%, x1%, y1%, CurClr%)„„IF LEN(Prompt$) > T2Len% THEN PBoxLen = LEN(Prompt$) ELSE PBoxLen = T2Len%„x2% = x1% + (PBoxLen + 2) * 8: y2% = y1% + 64: nx = x1%: ny = y1%„„CALL Mouse(2)„BitsPerPixel = 1: planes = 4        'Screen Mode 12„Ary% = 4 + INT(((x2% - x1% + 1) * (BitsPerPixel) + 7) / 8) * planes * ((y2% - y1%) + 1)„„DIM VScreen(1 TO Ary%)„GET (x1%, y1%)-(x2%, y2%), VScreen„„CALL drwbtn(2, 7, 0, 0, x1%, y1%, x2%, y2%)„x1% = x1% + 8„CALL gprint(Prompt$, x1%, y1% + 8, 0)„„Inloop:„y1% = y1% + 32„'Input Field„CALL gprint(">", x1%, y1%, 0)„CALL gprint(STRING$(T2Len%, 219), x1% + 8, y1%, 15)„„'** Turn on and show cursor„x1% = x1% + 8„cursor$ = CHR$(219)„CALL gprint(cursor$, x1%, y1%, 4)„„'** Get Input and move cursor„„T2$ = ""„1 T1$ = INKEY$: IF T1$ = "" THEN 1 'wait for keypress„st = ASC(T1$)„„'Backspace and erase„„IF st = 8 THEN„		'checks to make sure its in field„        x1% = x1% - 8: IF x1% < nx + 16 THEN x1% = nx + 16: GOTO 1„		CALL gprint(cursor$, x1% + 8, y1%, 15)„		CALL gprint(RIGHT$(T2$, 1), x1%, y1%, 0)„		CALL gprint(cursor$, x1%, y1%, 4)„		'subtracts deleted character from string„		IF LEN(T2$) >= 1 THEN T2$ = LEFT$(T2$, LEN(T2$) - 1)„		GOTO 1„END IF„„IF T1$ = CHR$(13) THEN GOTO 2  'End of input when ENTER is pressed.„„IF st < 32 OR st > 127 THEN BEEP: GOTO 1  'check for illegal character„„'Character ok, add to string, move cursor„„T2$ = T2$ + T1$„CALL gprint(cursor$, x1%, y1%, 15)„CALL gprint(T1$, x1%, y1%, 0)„x1% = x1% + 8„'checks to make sure its in field„IF x1% > (nx + T2Len% * 8 + 8) THEN BEEP: GOTO 1„CALL gprint(cursor$, x1%, y1%, 4)„„'Get more input„GOTO 1„„2 'Erase menu, restore what was underneath„PUT (nx, ny), VScreen, PSET„ERASE VScreen„CALL Mouse(1)„„END SUB„