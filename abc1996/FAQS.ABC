Joe Krzton                     READ & WRITE DATA FILES        FidoNet QUIK_BAS Echo          11-17-95 (12:34)       TEXT                   101  3529     DATAFILE.FAQ' > For various reasons, like storing graphics, game „' > scores, information, yadda yadda, I would like to learn „' > how to read and write data files.  Can someone assist „' > me in learning?„„Ya know, data files are good for storing things in... :)„„Well, the most structured (easiest) way I know to store data files, is to„create a TYPE, and then use RANDOM mode...  But, if you've got more than one„type in a data file, you'll need to use BINARY mode and then compute the„locations yourself...„„For instance, say I want to store some config. info...  First, I have to make„my TYPE.„„TYPE cfgtype„        user as string * 20„        hitcurr as integer„        hitmax as integer„        age as integer„END TYPE„„Ok, now I've got my characters information made, I gotta DIM a variable as„this type...„„DIM stats as cfgtype„„Ok, I got both of those done, BTW, you have to do those whether you want to„read info or write info...  Anyway, say you put a lot of stuff in your stats„variable, and now you want to save it...  Here's how: First, open your„datafile...„„ff=freefile„open "whatever.dat" for random as ff len=len(stats)„„Now, put the data there...„„put #ff,1,stats„„If you have more than 1 variable to put here, and they're all the same TYPE,„then you can replace that 1 with whatever record you want to put it at.„„Now, close your file...„„close ff„„And your data is written.„„To read it back in, do this„„ff=freefile„open "whatever.dat" for random as ff len=len(stats)„get #1,1,stats„close ff„„You see, the only thing different is I used GET instead of PUT.„„Now, if you've got more than one TYPE to put in it, it's a little different. „You can either use RANDOM access, with the len= set to the largest TYPE you„have (wastes space), OR you can figure out what you maxes are, and do„something like this...  Say you have another variable that describes the„screen we're using„„TYPE scrntype„        rows as integer„        columns as integer„        colors as integer„END TYPE„„DIM scrvar as scrntype„„OK, now this is where I can't go step by step with you, since this depends a„lot on what exactly you're doing...  BUT, what you should do, is figure out„which variables should come first...  ScrVar or Stats...  Let's say you„decided on Stats.  Now, say that you know you will never have more than 5„Stats variables...  What you do is say„„PUT ff,len(Stats)*(rec-1)+1,Stats„„This says that rec should be the record number you want to write to, base 1„like RANDOM access, and it puts it there.  Now, to put a ScrVar variable, say„„PUT ff,len(Stats)*rec+1+(len(ScrVar)*(scrrec-1)),ScrVar„       \--------------/ \----------------------/„       This figures out This figures out where„       the LOWEST place to put the ScrVar, and„       you could put a  when scrrec=1, this =0„       ScrVar variable.„„Ok, I thought the explanations above were kind of needed, because I tend to go„a little overboard on the math sometimes...  Anyway, "rec" is the maximum„number of Stats variables there will ever be, while scrrec is the record you„want to put scrvar at...  It's a lot like calculating where a given„char/attribute is in the video memory, but a little different... :)„„Oh yeah, to get the info back, use the same formulas with GET instead of PUT,„and when you're using more than one TYPE, remember to use BINARY instead of„RANDOM.„„Well, that concludes our class on rudimentary data files... :)  Hope it helped„someone.„Jamshid Khoshrangi             FAQ ON SORTING/HASHING         qjackson@direct.ca             03-28-93 (00:00)       TEXT                   936  33362    HASHING.FAQ 								QUIK_BAS FAQ2.1„„		****************************************************************„		*                                                              *„		*     The QUIK_BAS List of Frequently Asked Questions with     *„		*             Some Simple Public Domain Solutions              *„		*                                                              *„		****************************************************************„„								Written by„							 Jamshid Khosrangi„				 (aka Quinn Tyler Jackson)„„								with source„							   samples  from„							 "Various Sources"„„			Internet: qjackson@direct.ca„„„TABLE OF CONTENTS:„„		q1.0    The BASICS of BASIC„				s1.0    QUIKSORT.BAS    -- recursive quicksort SUB„„		q2.0    Commonly Requested Routines„				s2.0    HUTHSORT.BAS    -- iterative quicksort SUB„				s3.0    BISEARCH.BAS    -- binary search FUNCTION„„		q3.0    Advanced Topics         -- "Hashing in QuickBASIC"„				t1.0    Hashing Collision Table„				s4.0    FSTPRIME.BAS    -- generates 4K+3 prime number„				t2.0    List Management System Ratings„				s5.0    WORDHASH.BAS    -- word distribution counter„„		q4.0    Structured BASIC Techniques„„„		NOTE:  Certain pieces of other people's public domain„		code has been spliced into this FAQ for purely demonstrative„		purposes, and it is by no means to be assumed that Quinn Tyler„		Jackson is claiming ownership of such pieces of source code.„		All source remains the property of those who originally wrote it,„		as understood by Canadian, American, and International Treaty.„„		The text portion of this file itself is hereby released into the„		"Public Domain" for the purposes of education and enlightenment.„„„Q1.0    The BASICS of BASIC:„„Q1.4    Okay, Quinn, I've figured out FUNCTIONs and SUBs, and have even„		started using them with some kind of skill.  Now, thing is, I„		come up to this thing called 'recursion.'  What's this all about,„		and can you show me some practical application of it?„„A1.4    There is an old joke about the cryptic nature of dictionaries that„		goes something like this:„„		re'CUR'sion (noun) 1. see recursion„„		Actually, that's a pretty sad joke.  One computer scientist's„		definition states:„„		"... a recursive algorithm is one that contains a copy of itself„		within one of its instructions.  Thus, a recursive algorithm is„		reminiscent of a set of mirrors in which you can see yourself„		looking at yourself looking at yourself."  [J. Glenn Brookshear]„„		Recursion is a powerful programming tool, and any comprehensive„		programming language allows it.  QuickBASIC and its dialects are„		no exception.  A simple example of recursion:„„		SUB recurse„		recurse„		END SUB„„		This thing will go in circles until the stack is full, crashing„		the program should it ever be called.  It illustrates two of the„		main pitfalls of recursion:„„				1. recursion in QuickBASIC eats the stack for breakfast„				2. there must be a terminating condition to exit the loop„„		Since each call to a SUB or FUNCTION does some pushing to the„		stack, it must always be remembered that recursive routines will„		require a bit of the stack for every instance they are called.„		It is sometimes hard to know in advance how many times a recursive„		routine will end up calling itself, and therefore, one cannot„		know with any accuracy how much a given recursive routine will„		decide to rob from the stack.  Be warned!„„		This also leads to the next issue: there must ALWAYS be a„		terminating condition to exit the loop.  Sometimes it is easy to„		overlook this point.  Consider the above simple example.  It„		never stops calling itself, does it?  Were a theoretical computer„		to exist that had a theoretically infinitely large stack that could„		never be consumed by even the deepest level of recursion, what„		happens if that routine goes off into a corner and keeps calling„		itself?  It results in a permanent time out known as a crash.„		(The moral of this?  A bug on a i486 system is still a bug, just„		a bug that happens sooner.)„„		An example of a terminating condition added to the above code:„„		SUB recurse(n%)„		n% = n% + 1„		IF n% < 10 THEN„				recurse„		END IF„		END SUB„„		This SUB will call itself only until n% is equal to ten, at which„		point, it will reach its terminating state, and be finished on its„		job.  This is a simple example, I admit, but NEVER forget to„		include a terminating statement in your recursive routines, or„		you will pay for it with a crash.„„		Now that we have that out of the way, let's kill two birds with one„		stone.  (It could be argued, in fact that the act of killing two„		birds with only one stone probably involves recursion somewhere in„		the solution.)  Everyone wants to know a good QuickSort algorithm,„		and most implementations of that use recursion.  So, a modified„		version of the QuickSort SUB from Microsoft, one that sorts„		an array passed to it:„„S1.0    QUIKSORT.BAS [F210S01.BAS]„„DEFINT A-Z„SUB QuickSortSTR (Array() AS STRING, Low, High)„'            /^\              /^\„'             |                |„'    Change these to any BASIC data type for this routine to„'    handle other types of data arrays other than strings.„'„'============================== QuickSortXXX ================================„'  QuickSortXXX works by picking a random "pivot" element in Array(), then„'  moving every element that is bigger to one side of the pivot, and every„'  element that is smaller to the other side.  QuickSortXXX is then called„'  recursively with the two subdivisions created by the pivot.  Once the„'  number of elements in a subdivision reaches two, the recursive calls end„'  and the array is sorted.„'============================================================================„'„'            Microsoft's source code modified by Quinn Tyler Jackson„'„„STATIC BeenHere„„IF NOT BeenHere THEN„		Low = LBOUND(Array)„		High = UBOUND(Array)„		BeenHere = -1„END IF„„DIM Partition AS STRING  ' Change STRING to any BASIC data type„						 ' for this QuickSort routine to work with„						 ' things other than strings.„„   IF Low < High THEN„„	  ' Only two elements in this subdivision; swap them if they are out of„	  ' order, then end recursive calls:„	  IF High - Low = 1 THEN ' we have reached the terminating condition!„		 IF Array(Low) > Array(High) THEN„			SWAP Low, High„			BeenHere = 0„		 END IF„	  ELSE„„		 ' Pick a pivot element at random, then move it to the end:„		 RandIndex = INT(RND * (High - Low + 1)) + Low„		 SWAP Array(High), Array(RandIndex)„		 Partition = Array(High)„		 DO„„			' Move in from both sides towards the pivot element:„			I = Low: J = High„			DO WHILE (I < J) AND (Array(I) <= Partition)„			   I = I + 1„			LOOP„			DO WHILE (J > I) AND (Array(J) >= Partition)„			   J = J - 1„			LOOP„„			' If we haven't reached the pivot element, it means that two„			' elements on either side are out of order, so swap them:„			IF I < J THEN„			   SWAP Array(I), Array(J)„			END IF„		 LOOP WHILE I < J„„		 ' Move the pivot element back to its proper place in the array:„		 SWAP Array(I), Array(High)„„		 ' Recursively call the QuickSortSTR procedure (pass the smaller„		 ' subdivision first to use less stack space):„		 IF (I - Low) < (High - I) THEN„			QuickSortSTR Array(), Low, I - 1„			QuickSortSTR Array(), I + 1, High„		 ELSE„			QuickSortSTR Array(), I + 1, High„			QuickSortSTR Array(), Low, I - 1„		 END IF„	  END IF„   END IF„END SUB„„=======>8 SAMPLE 1.0 ENDS HERE 8<=========„„Q1.5    So that's how to use recursion!  That's great!  I think I'm„		starting to get a hang of things with QuickBASIC now, thanks.„		But, how is it possible for it to call itself over and over„		like that without all those variables interfering with„		each other?  I mean, I'm kind of used to GW-BASIC, and well,„		I just can't figure out why all those High and Low variables„		don't just write over one another.  My docs say something about„		local and global scope, but it's all kind of confusing.  What's„		the real difference between local, STATIC, COMMON, SHARED, COMMON„		SHARED, and all other flavors of variables?„„A1.5    Beginners with QuickBASIC sometimes have a hard time decrypting„		all of the different types of variable scope.  Microsoft hasn't„		really helped anything with all the funny names for variable„		scope.  GLOBAL would have made more sense than SHARED for most.„		Okay, let's look at how the QuickBASIC program is inevitably„		structured:„„				1.  First, there is the 'module' level.  That is the„					main part of the QuickBASIC program, the part where„					execution starts, and most programmers declare their„					constants, and put their main documentation.„„				2.  Second, there is the SUB and FUNCTION level.  Each„					SUB and FUNCTION could be thought of as a miniprogram„					unto itself.  That's why SUBs are called that:„					subprogram.„„				3.  Third, if you write bigger programs, you may actually„					have two or more modules, each one having its own„					SUBs and FUNCTIONs.„„		Okay, then, any variable used at the modular level, or level 1, is„		accessible, or in the 'scope' of the modular level.  If there is„		a variable called Foo at the modular level, with a value of 7, then„		any Foo at the SUB or FUNCTION level could also be called Foo,„		without interfering with the modular Foo.  Think of each module„		level variable and each SUB and FUNCTION variable as being on„		different continents.  They can have the same name with no problem.„„		But, suppose you want a SUB or FUNCTION to have access to the Foo„		that was declared at the modular level.  This is where the SHARED„		declarator comes in.  In the SUB somesubprog, to have access to„		the Foo that was declared at the modular level, just add the„		declaration:„„		SHARED Foo„„		Any SUB or FUNCTION that doesn't want to have access to the„		modular Foo doesn't have to declare it as SHARED.  This is a„		powerful feature, once you get the hang of it and feel confident„		enough to use it wisely.„„		Now, suppose that you want a number of your SUBs or FUNCTIONs to„		have access to a common group of variables.  At the modular level,„		the declaration would be:„„		DIM SHARED Foo„„		This would give ALL of the SUBs and FUNCTIONs of a given module„		access to the variable Foo.  Any access of Foo at any level will„		alter the global variable.„„		Now, suppose you have a multimodule program that has FIRST.BAS and„		SECOND.BAS linked together.  Suppose you want them to communicate„		with one another via a common global variable.  This is where„		COMMON SHARED comes in.„„		Now that we've covered this, there is the issue of the STATIC„		declarator.  Normally, variables at the SUB and FUNCTION level„		are dynamic, which means they disappear when the routine returns„		to the place that it was called from.  By declaring a variable„		STATIC, we can be assured that whatever the variable's value was„		when we left, it will be when we return.  To declare only a few„		of the variables as STATIC, use the form:„„		SUB FooSub ()„		STATIC Variable1, Variable2, etc.„		:„		:„		END SUB„		„		But, if you want ALL the variables to be STATIC, use the following„		method:„„		SUB FooSub () STATIC„		:„		:„		:„		END SUB„„		There are certain speed advantages to STATIC SUBs and FUNCTIONs,„		since variables are not created on the stack, but that is a more„		advanced issue.„„		So, in summary:„„		1.  SHARED allows SUBs and FUNCTIONs to use modular variables,„		2.  COMMON allows modules to share variables between themselves,„		3.  STATIC allows variables to retain their value between„			calls to the SUB or FUNCTION in question.„„Q2.0    Commonly Requested Routines:„„Q2.4    Okay, I've looked the whole thing over, Quinn, and I've realized„		something: the recursive QuickSortXXX routine eats the stack up„		pretty fast.  Is there another way?  Is there a way to implement„		a QuickSort SUB without using recursion?„„A2.4    Yes, indeed there is.  Cornel Huth implemented an iterative„		quicksort algorithm, which I then tweaked a bit.  It is actually„		a bit faster than the other, and doesn't use too much of the stack.„		It accomplishes this by using an array to simulate a stack.  The„		modified version follows:„„S2.0    HUTHSORT.BAS [P210S02.BAS]„„' HUTHSORT.BAS written by Cornel Huth„' Iterative QuickSort Routine„'„' Tweaked by Quinn Tyler Jackson„„SUB subHuthSortSTR (Array() AS STRING)„'               ^  TWEAK THESE    ^„'               | FOR OTHER TYPES |„'               `--+--------------'„'                  V„  DIM compare AS STRING„„TYPE StackType„  low AS INTEGER„  hi AS INTEGER„END TYPE„„DIM aStack(1 TO 128) AS StackType„„  StackPtr = 1„  aStack(StackPtr).low = LBOUND(Array)„  aStack(StackPtr).hi = UBOUND(Array)„  StackPtr = StackPtr + 1„„  DO„	StackPtr = StackPtr - 1„	low = aStack(StackPtr).low„	hi = aStack(StackPtr).hi„	DO„	  i = low„	  j = hi„	  mid = (low + hi) \ 2„	  compare = Array(mid)„	  DO„		DO WHILE Array(i) < compare„		  i = i + 1„		LOOP„	DO WHILE Array(j) > compare„		  j = j - 1„		LOOP„		IF i <= j THEN„		  SWAP Array(i), Array(j)„		  i = i + 1„		  j = j - 1„		END IF„	  LOOP WHILE i <= j„	  IF j - low < hi - i THEN„		IF i < hi THEN„		  aStack(StackPtr).low = i„		  aStack(StackPtr).hi = hi„		  StackPtr = StackPtr + 1„		END IF„		hi = j„	  ELSE„		IF low < j THEN„		  aStack(StackPtr).low = low„		  aStack(StackPtr).hi = j„		  StackPtr = StackPtr + 1„		END IF„		low = i„	  END IF„	LOOP WHILE low < hi„	'IF StackPtr > maxsp THEN maxsp = StackPtr„  LOOP WHILE StackPtr <> 1„END SUB„„=======>8 SAMPLE 2.0 ENDS HERE 8<=========„„Q2.5    Now that I've got so many neat ways to sort a list, I'd sure like„		to be able to locate an entry in it quickly.  I hear that a binary„		search is fast, but I just can't figure out how to do that.  How„		do I do a binary search?„„A2.5    Binary searches are the fastest overall search method for standard„		sorted lists.  Such lists can be divided in two, looked at, and„		divided again as necessary.  A good search method is demonstrated„		here:„„S3.0    BISEARCH.BAS [F210S03.BAS]„„„DEFINT A-Z„FUNCTION BiSearchSTR (Find AS STRING, Array() AS STRING)„„Min = LBOUND(Array)             'start at first element„Max = UBOUND(Array)             'consider through last„„DO„  Try = (Max + Min) \ 2         'start testing in middle„„  IF Array(Try) = Find THEN     'found it!„	BiSearch = Try              'return matching element„	EXIT DO                     'all done„  END IF„„  IF Array(Try) > Find THEN     'too high, cut in half„	Max = Try - 1„  ELSE„	Min = Try + 1               'too low, cut other way„  END IF„LOOP WHILE Max >= Min„„END FUNCTION„„=======>8 SAMPLE 3.0 ENDS HERE 8<=========„„Q3.0    Advanced Topics -- "Hashing in QuickBASIC"„„Q3.1    That's pretty fast!  I was so used to doing a sequential search on„		an unsorted list.  Now that I have the QuickSort and the BiSearch„		routines, I can use them as a pair for faster list searches.  The„		thing is, as soon as I want to add something to the list, it„		puts everything out of order by only one entry, and that hardly„		seems worth sorting all over again, even with something as fast„		as Cornel Huth's iterative QuickSort algorithm.  Are there any„		alternatives to this way of doing things?  I've heard talk of„		something called 'hashing' but I don't have any idea of what that„		is all about.  How would I use hashing to avoid having to either„		resort the list, or use a slow insertion algorithm?  Insertion is„		horrendously slow with disk files.„„A3.1    Hashing is a very efficient method of record access, be it in RAM„		or be it with a disk file.  Basically, hashed arrays or data files„		can be quickly searched for a given item by a key index.  Whenever„		you have to add an item to the list, you can at lightening speed,„		and since hashing "sorts" the array on-the-fly, as it were, there is„		no need to push records around to add new items to a hashed record.„„		The first concept you must understand with hashing is the key index.„		Every data structure you design with hashing in mind has to have„		one field that is unique.  This is a prerequisite that you just can't„		get around.  Of course, you could actually combine several fields„		to generate this unique key, which effectively serves the same„		purpose.  A good application of this is a Fidonet nodelist that uses„		the node address as the hashing key.  No two alike in theory.„„		But just how does this key work?  First of all, let's take a look„		at the Fidonet example.  Every full Fidonet address is unique to„		one node.  Assume that the full nodelist has about 15000 entries.„		Okay, if you want a hashing table to hold 15000 unique entries, then„		research has shown that the table should be at least 30% greater„		than the number of entries in it.  That would make 19500 table„		entries.  This means that 4500 entries in the list will be left„		empty for best hashing results.„„		Now, another problem comes up.  How does the key come into play?„		Well, let's look at a simple key: 1153999.  Since the list is 19500„		long, we certainly can't just put this in record 1153999.  Hashing„		involves dividing the key by the table size and taking the remainder„		and using that as the record number:„„						   59„					----------  R 3499„			   19500) 1153999„„„		Okay, 3499 is the record number in which we would put the data.„		This is the basic idea behind hashing.  There is a trouble, however.„		Collision occurs whenever a node address, when divided by 19500 has„		a remainder of 3499.  That 'bucket' is already full!  So, what to„		do?  Generate another bucket number, see if that bucket is full,„		and if it is, keep generating new buckets until we find an empty„		bucket.„„		To find an item in a hashed table, we get its key, divide by the„		table size, and look at the bucket that is represented by the„		remainder.  If that isn't the one, we generate the next bucket„		address, until we arrive at an empty bucket.  If we encounter„		the correct key BEFORE we arrive at an empty bucket, then we've„		found our entry.  If we arrive at an empty bucket, the record is„		not in the table.  And there you have hashing.„„		A well designed hashing table will yield this number of collisions„		per insertion or search:„„„T1.0    Hashing Collision Table„„		TABLE FULLNESS          COLLISIONS„		==================================„			 50%                   2.0„			 60%                   2.5„			 70%                   3.3„			 90%                  10.0„„„=======>8 TABLE 1.0 ENDS HERE 8<=========„„		That shows better results than even the binary search, with large„		lists!„„		Research has shown that the most efficient hashing tables, that is,„		the ones with the least number of collisions, have a prime„		number of entries.  A table size of 1019 should produce less„		collisions than one of 1000.  Research has also shown that if the„		prime is of the form 4K+3, where K is any positive integer, then„		collisions are reduced even further.  1019 also meets this second„		requirement.  But, since a table size twice the size of the maximum„		number of entries it will ever hold is inefficient, the 4K+3„		criterion should be abandoned at a certain point in favor of any„		prime number.  Since most of us aren't idiot savants who can just„		come up with that number to suit our needs, here is a FUNCTION,„		written by Charles Graham, that accepts the maximum number of„		entries a table will have, and returns the proper type of prime„		number, to be used as a hashing table size:„„S4.0    FSTPRIME.BAS [F210S04.BAS]„„DEFINT A-Z„' This FUNCTION returns a prime number that is at least 30% greater than„' threshold.  It will TRY to return a prime number that also fits into the„' form 4K+3, where k is any integer, but if the prime number is twice the„' size of the threshold, it will ignore this criterion.„'„'       Written by Charles Graham, Tweaked by Quinn Tyler Jackson„'„FUNCTION funFirstPrime (threshold)„CONST TRUE = -1„CONST FALSE = NOT TRUE„„tp30 = INT((threshold * 1.3) + .5)„IF tp30 / 2 = tp30 \ 2 THEN„	tp30 = tp30 + 1„END IF„c = tp30 - 2„IF c < 1 THEN„	c = 1„END IF„t2 = threshold * 2„DO„	c = c + 2„	FOR z = 3 TO SQR(c)„		ind = TRUE„		IF c / z = c \ z THEN„			ind = FALSE„			EXIT FOR„		END IF„	NEXT z„	IF ind THEN„		IF (c - 3) / 4 = INT((c - 3) / 4) OR c > t2 THEN„			funFirstPrime = c„			EXIT DO„		END IF„	END IF„LOOP„END FUNCTION„„=======>8 SAMPLE 4.0 ENDS HERE 8<=========„„Q3.1    How do I know when to use sequential searches, when to use„		binary searches, and when to use hashing?  Are there any sort„		of guidelines?„„A3.1    Well, first let's consider where hashing is in its prime.  (You'll„		pardon that one, okay?)  It is best suited to dynamic list„		generation where items need to be added on a regular basis, but„		not deleted, since deletion is fairly difficult to implement on„		a hashed list.  The main strength of a hashing system is its„		ability to quickly insert new items into the table in such a„		manner that they can be located quickly "on-the-fly."   (See T1.0„		for the average number of collisions before locating the correct„		entry.)  Since the collisions increase with the ratio of full„		buckets to empty buckets, and not with the size of the actual„		table involved, hashing is more efficient than even binary„		searches when lists start to become huge.  Also, because the„		binary method of searching demands a sorted list, insertion of„		items at a later time becomes very cumbersome, even with such„		techniques as the QuickSort and pushing all entries after the„		insertion up by one.  (Try that technique on a list of 30,000„		items, when you only want to add two new items that land near„		the beginning of the list, and you'll know what disk wear and„		tear is all about!)„„		Typical applications of the hashing algorithm involve word„		distribution counts, dictionary table generators that involve„		dictionaries that will be added to dynamically, and things of„		that nature.„„		Consider the word distribution count problem.  Each word is a„		unique key, and so is perfect for hashing.  Sequential methods„		only work well up until the table has so many entries in it that„		looking up entries in the table becomes a real effort.  Remember,„		words already in the list do not need to be added twice.  Binary„		methods allow for quick searching, but each case of a new word„		being added to the list requires a sort or cumbersome insertion.„		This takes time, if a text file is of even average length.„„		Hashing, on the other hand, can increment the count of words„		already in the list, or add new words to the list, without„		the overhead of sorting, sequential searches, or push-type„		insertion.  Also, remember that entry deletion is a problem with„		hashing.  Word distribution counts NEVER require entries to be„		struck, and so are well-suited to hashing systems.„„		A good rule of thumb to determine which method may be best for a„		given problem is to cosider the points on this table:„„T2.0    List Management System Ratings„„									  List  Type„						SEQUENTIAL      BINARY          HASHED„				=====================================================„small list                  1              3              2„medium list                 3              1              2„large list                  3              2              1„huge list                   3              2              1„„Insertion                   2              3              1„Modification                3              2              1„Deletion                    1              2              3„Browsing                    2              1              3„„					 (Systems are ranked first, second, or third)„„=======>8 TABLE 2.0 ENDS HERE 8<=========„„		Using this table, we can see that the best method for short„		lists that require frequent deletions might be the sequential„		list.  The best for huge lists that require insertions,„		modifications, but not deletions (such as a nodelist index) is„		probably a hashed list.  A hashed list, however, will not do„		much for you if you regularly want to access the next item,„		first item in the list, or last item, such as in a list browsing„		system.  Hashed lists have no logical beginning or end, and„		for this reason, there is no such thing as a "first item" or„		"next item" in a hashed list.  Each entry is a single entity,„		retrievable only as a single entity, with no relation to any„		other entry in the hashed list.  This excludes applications„		that require browsing, as I have mentioned, but is perfect„		for symbol tables, dictionaries, and the like.„„Q3.2    This is all pretty new to me.  Give me a practical review.„„A3.2    Okay.  In the hashed list there is no sense of sequence in„		the classic sense of the concept.  Items are put into buckets„		based upon the type of calculation I have already discussed, and„		if the bucket is already in use, a new bucket is found according„		to a set system. Therefore, two similar items in a hashed table„		may actually have a physical distance of 500 entries between them.„„		A practical example:„„		We have a hash table 7 buckets big, and you want to store three„		entries in it, using hashing.  For simplicity, let's just store the„		characters A, B, and C, using their ASCII values as keys.  Their„		buckets would be:„„		Item   Formula    Bucket„		=========================„		  A    65 MOD 7     2„		  B    66 MOD 7     3„		  C    67 MOD 7     4„„		No collisions have occured here, since this is a simple case.„		Now, let us add just one more item: H.  The first bucket that„		H will request is 72 MOD 7, or 2, which is being used by A.„		This is collision.  Now, we must find an empty bucket, and so,„		we apply a common method to the old bucket: we subtract an„		offset from 2.  The offset is calulated thus:„„				Offset = TableSize - Bucket, or„				Offset = 7 -2„				Offset = 5„„		Okay, now, whenever a collision occurs, we recalculate a position„		using this formula:„„				NewPos = OldPos - Offset„				NewPos = 2 - 5„				NewPos = -3„„		In cases where NewPos is less than 0, we then add the table size„		to the interim result:„„				NewPos = NewPos + TableSize, or„				NewPos = -3 + 7„				NewPos = 4„„		We see that this new bucket, 4, is being used by C, and so we„		have to recalculate the bucket one more time:„„				NewPos = OldPos - Offset, or„				NewPos = 4 - 5„				NewPos = -1„„				NewPos <0 so„				NewPos = NewPos + TableSize, or„				NewPos = -1 + 7„				NewPos = 6„„		We see that 6 is an empty bucket, and therefore, our table now„		looks something like this:„		„		Entry   Bucket„		==============„				  1 (empty bucket)„		 A        2 (no collisions)„		 B        3 (no collisions)„		 C        4 (no collisions)„				  5 (empty bucket)„		 H        6 (arrived at after two collisions)„				  7 (empty bucket)„„		Now, remember from past explanations that searches are conducted„		by comparing each entry to the key until an empty bucket is reached.„		Therefore, to find A in the table, we calculate a bucket of„		65 MOD 7, or 2.  We look in bucket 2, and see that our key of A is„		the same as the table entry A.  We have therefore found our entry in„		one look!  Now, let's look for I.  That's a bit different, since„		it isn't in the list.  How many looks are needed to tell us that„		it isn't?  Well 73 MOD 7 is 3, and we see immediately that bucket„		3 is a B, not an I.  We recalculate the next bucket, and get:„„				Offset = 4„				NewPos = (3 - 4) or -1„				Less than 0, so„				NewPos = 6„„		Bucket 6 is occupied by an H, and so we calculate the next bucket:„„				Offset = 4„				NewPos = (6-4) = 2„„		Bucket 2 is occupied by an A, and so:„„				NewPos = (2 - 4)„				NewPos = -2 + 7 = 5„„		Finally, bucket 5 is empty.  Therefore, since we've arrived at„		an empty bucket BEFORE arriving at I, we can say that I is not„		in the list.  How many steps required?  Four.  Quite a bit of„		overhead on a short list of 7 entries, but consider a list of„		100,000 entries!  Four searches to find an item is fast!„„Q3.3    Okay, how about a real working example of hashing in QuickBASIC,„		Quinn?  Theory is fine for CompSci freaks, but I'm a coffee and„		pizza programmer, not an egghead.„„A3.3    I mentioned that one perfect use of hashing is for word distribution„		counters.  Here is one from Rich Geldreich that has been tweaked„		by me to account for some things that Rich did not know then„		about hashing table sizes.„„S5.0    WORDHASH.BAS [F210S05.BAS]„„'WORDHASH.BAS v1.10 By Rich Geldreich 1992„' Modified by Quinn Tyler Jackson for demonstrative purposes.„'„'Uses hashing to quickly tally up the frequency of all of the words in a„'text file. (This program assumes that words are seperated by either tab„'or space characters. Also, all words are converted to uppercase before„'the search.)„'„„DEFINT A-Z„DECLARE SUB Show.Counts ()„DECLARE SUB Process.Line (A$)„DECLARE SUB UpdateFreq (A$, KeyIndex)„CONST TRUE = -1, FALSE = 0„„DIM SHARED TableSize„„Main:„ FileName$ = COMMAND$„ CLS„ LOCATE 1, 1„ PRINT "WORDHASH.BAS By Rich Geldreich 1992"„ PRINT "     Tweaked by Quinn Tyler Jackson 1993"„ OPEN FileName$ FOR INPUT AS #1 LEN = 16384„„' In Rich's original version, the TableSize was set at 7000.  My version„' guesses at how large the table needs to be based on this:„„' There are 5.5 characters in the average word.  Therefore, divide the„' text file length by 5.5.  For safety, assume that as many as„' half of those will be unique.  In normal text, half the words are in the„' hundred most common list, so this plays it pretty safe!  It will die„' if you take a file that is over about 50% unique words, however!  This„' is for NORMAL text files, not word dictionaries, where all entries are„' unique!„'„'SPLICE IN FROM EARLIER SAMPLE 4.0 IN THIS FAQ„'           VVVVVVVVVVVVV„TableSize = funFirstPrime(LOF(1) * .09)„REDIM SHARED WordTable$(TableSize)„REDIM SHARED Counts(TableSize)„DIM SHARED New.Words„„ DO UNTIL EOF(1)„	 LINE INPUT #1, A$„	 Process.Line A$„	 N = N + 1„	 LOCATE 3, 1: PRINT N; "lines processed,"; New.Words; "words found"„ LOOP„„SUB Process.Line (A$)„„	ASEG = SSEG(A$) 'QuickBASIC 4.5 users change this to VARSEG(A$)„	AOFS& = SADD(A$)„	DEF SEG = ASEG + AOFS& \ 16„„	AAddress = AOFS& AND 15„	Astart = AAddress„	AEndAddress = AAddress + LEN(A$)„„	'get a word„	GOSUB GetAWord„	'update the frequency of the word until there aren't any words left„	DO WHILE Word$ <> ""„		UpdateFreq Word$, KeyIndex„		GOSUB GetAWord„	LOOP„„	EXIT SUB„„GetAWord:„	Word$ = ""„„	'find a character„	P = PEEK(AAddress)„	DO WHILE (P = 32 OR P = 9) AND AAddress <> AEndAddress„		AAddress = AAddress + 1„		P = PEEK(AAddress)„	LOOP„„	'if not at end of string then find a space„	IF AAddress <> AEndAddress THEN„		KeyIndex = 0„		GOSUB UpdateKeyIndex„„		'remember where the character started„		WordStart = AAddress„„		AAddress = AAddress + 1„		P = PEEK(AAddress)„		GOSUB UpdateKeyIndex„		'find the leading space„		DO UNTIL (P = 32 OR P = 9) OR AAddress = AEndAddress„			AAddress = AAddress + 1„			P = PEEK(AAddress)„			GOSUB UpdateKeyIndex„		LOOP„		KeyIndex = KeyIndex - L„		'make the word„   Word$ = UCASE$(MID$(A$, WordStart - Astart + 1, AAddress - WordStart))„„	END IF„RETURN„„UpdateKeyIndex:„	IF P >= 97 AND P <= 122 THEN„		L = P - 32„		KeyIndex = KeyIndex + L„	ELSE„		L = P„		KeyIndex = KeyIndex + L„	END IF„RETURN„„END SUB„„SUB UpdateFreq (A$, KeyIndex)„STATIC collisions„	'adjust the keyindex so its within the table„	KeyIndex = KeyIndex MOD TableSize„	'calculate an offset for retries„	IF KeyIndex = 0 THEN„		Offset = 1„	ELSE„		Offset = TableSize - KeyIndex„	END IF„	'main loop of hashing„	DO„		'is this entry empty?„		IF WordTable$(KeyIndex) = "" THEN„			'add this entry to the hash table„			WordTable$(KeyIndex) = A$„			New.Words = New.Words + 1„			IF New.Words = TableSize THEN„				BEEP„				PRINT : PRINT "Not enough room in word table!"„				END„			END IF„			EXIT SUB„		'is this what we're looking for?„		ELSEIF WordTable$(KeyIndex) = A$ THEN„			'increment the frequency of the entry„			Counts(KeyIndex) = Counts(KeyIndex) + 1„			EXIT SUB„		'this entry contains a string other than what we're looking for:„		'adjust the KeyIndex and try again„		ELSE„			collisions = collisions + 1„			LOCATE 5, 1: PRINT "Collisions: "; collisions„			KeyIndex = KeyIndex - Offset„			'wrap back the keyindex if it's <0„			IF KeyIndex < 0 THEN„				KeyIndex = KeyIndex + TableSize„			END IF„		END IF„	LOOP„„END SUB„„=======>8 SAMPLE 5.0 ENDS HERE 8<=========„„						  END OF QUIK_BAS FAQ2.1„„„Bill White                     QUICK SHUFFLE                  FidoNet QUIK_BAS Echo          12-10-95 (13:30)       QB, QBasic, PDS        36   1446     QSHUFFLE.BAS'> I am working on a program that needs to have random numbers„'> between 0 and 255 without repeating any number once.... and„'> i would also like to know how to store each number in an„'> array and compare it to the imput of a file.„„'     Here's my routine for shuffling cards. You can„' expand and adapt it to your needs:„ „ 'Quick Shuffle„„ 'This shuffle routine is faster than what people usually use„ 'because there is no need to check for duplications.„ 'In the programs in which this has been used, all computations„ 'have been done with the numbers from 1 to 52 for simplicity.„ 'The conversion to suits and rank was done only at print-out time.„„ COLOR 7, 1„ CLS„ DIM card(52)„ RANDOMIZE TIMER„„ 'Initialize pack                    'Make each element in the array„ FOR i = 1 TO 52                     'equal to its position value, i.e.,„     card(i) = i                     'first card = 1, second card = 2, etc.„ NEXT i                              'Like a new deck of cards: no dupes.„„ 'Shuffle                            'Exchange each card in the pack with„ FOR i = 1 TO 52                     'a card picked at random.„     r = INT(RND(1) * 52) + 1„     SWAP card(i), card(r)„ NEXT i„„ 'View results                       'Just a demo of the results.„ FOR i = 1 TO 52                     'This is where you pick the card(s)„     PRINT card(i),                  'you want to use (deal).„ NEXT i„John & Jeff Klein              MILLION-COLOR PALETTE          Rolf@ice.prima.ruhr.de         12/85 (00:00)          TEXT                   235  10735    COLORS.TXT                  Million-Color Palette for IBM PC„    (COMPUTE! Magazine December 1985 by John and Jeff Klein)„„     No longer is your PC restricted to a palette of 16 colors and an„inability to display them all in higher resolutions.  The secret is„a combination of a techniques called tile painting and the trick of„fooling a TV or composite monitor into displaying new solid colors.„„     Graphics images are stored differently in the computer's memory„for each different graphics mode or screen.  The color of each pixel„is stored in a section of memory.  This video memory is arranged by„its location or coordinates on the screen.  The image you see on the„screen, therefore, is a copy of the contents of video memory.  To„figure out how many pixels can be represented in a byte of memory,„remember that a byte is made up of 8 bits.  Simply divide the amount„of memory required for a certain screen mode by the number of pixels„on the screen.  The memory requirements for each screen mode are:„„Screen                   # of      Memory„ Mode     Resolution    Colors   per Screen   Pixels/Byte   Bits/Pixel„„  1       320 x 200       4         16K            4            2„  2       620 x 200       2         16K            8            1„„     Remember that RGB stands for the three primary colors of light:„red, green and blue.  All colors can be made by mixing these three„primary colors.  That's why RGB monitors, color TVs and composite color„monitors have three electron guns, all of which are controlled by the„computer to produce color.  If none of the guns is lighting a pixel,„the pixel appears black.„„     Colors are represented in memory by arranging bits to denote„which electron guns should be turned on or off when lighting the„corresponding pixel.  For instance, if a certain pixel is supposed to„be blue, the group of bits representing that pixel in memory shows the„blue gun is on and the others off.  All the possible combinations of„the three electron guns account for eight colors.  To get eight more„colors, the intensity, also called luminance, is varied by mixing a„little white with the first eight colors.  That's why the IBM PC has„a total of 16 color variations -- two shades each of eight colors.„The 16 colors are represented by the following bit combinations.„„„                    Bits„Luminance     Red  Green  Blue     Color„    0          0     0     0       Black„    0          0     0     1       Blue„    0          0     1     0       Green„    0          0     1     1       Cyan„    0          1     0     0       Red„    0          1     0     1       Magenta„    0          1     1     0       Brown„    0          1     1     1       Light Gray„    1          0     0     0       Dark Gray„    1          0     0     1       Light Blue„    1          0     1     0       Light Green„    1          0     1     1       Light Cyan„    1          1     0     0       Pink„    1          1     0     1       Light Magenta„    1          1     1     0       Yellow„    1          1     1     1       White„„Remember that each bit turns an electron gun either on or off.  Notice„how many bits its takes to represent all the possible combinations.„It takes four bits, or half a byte (sometimes called nybble) to„represent all 16 colors.  So all screen modes which use four bits to„represent a pixel are 16-color modes.  Only four-color combinations„are possible with two bits, and only two combinations are possible„with one bit.  That's why some screen modes can display only four or„two colors at a time.„„     Once you're familiar with how pixels are represented in video„memory, the technique of tile painting is easy to understand.  Tile„painting uses the PAINT command to fill the bytes of screen memory„with certain patterns of ones and zeros.  The pattern is programmable,„and it represents what is displayed on the TV or monitor.  Instead of„painting with the actual color, you paint with the bit pattern of the„color.  By using bit patterns, you can actually paint with more than„one color around some specified border color:„„PAINT (x,y),CHR$(bit pattern) + CHR$(bit pattern) + ...,boundary color„„     The bit pattern consists of eight bits, so its decimal equivalent„can range from 0 to 255 (integers only).  The bit pattern must„represent the colors of the pixels per byte of the screen mode you're„using.  The color patterns are put in memory next to each other as„vertical lines on the screen.  This example paints SCREEN 1 with„vertical bands of blue and green lines:„„10 SCREEN 1:CLS„20 PAINT (1,1),CHR$(102),3„„The reason why the lines are blue and green can be seen when the„number 102 is expressed in binary, revealing the bit pattern:„„102 = 01100110„„Decimal 102 is derived from this binary number by:„„Value for„each digit   128   64   32   16   8   4   2   1   01 = 0001 = blue„                                                  10 = 0010 = green„Binary         0    1    1    0   0   1   1   0„„128 * 0 =  0„ 64 * 1 = 64„ 32 * 1 = 32„ 16 * 0 =  0„  8 * 0 =  0„  4 * 1 =  4„  2 * 1 =  2„  1 * 0 =  0„         102„„„SCREEN 1 stores four pixels per byte, so the pattern works out to:„„01       10        01       10„blue     green     blue     green„„     Here's where things get tricky.  If the computer is plugged into„a color TV or composite color monitor (not an RGB monitor), you won't„see the blue and green vertical lines that are supposed to be there.„Instead, you'll see a solid bar of color that's sort of blue.  And the„blue is not one of the normal 16 colors available.  It is a new color„-- one of the 16 shades that can be created on SCREEN 1 of the PC.„„     What's happening is something called artifacting.  This effect„takes advantage of the limited resolution of TVs and composite color„monitors.  When two very small pixels are placed next to each other„on these screens, there isn't enough resolution to display them„properly.  As a result, the pixels tend to blend together and create„a false color -- an artifact color.  The color wouldn't be visible if„the screen had more resolution.  RGB monitors have enough resolution„to display the pixels as they're supposed to appear.„„     If the binary pattern 10 01 10 01 is used in the above example„instead of 01 10 01 10, the ahsde is slightly different -- blue-green-„blue-green does not appear the same as green-blue-green-blue on a„color TV or composite monitor.  They mix differently to create an„entirely new shade of blue-green.„„     The PC has only two graphics modes, SCREEN 1 and SCREEN 2.  Tile„painting produces only 16 colors in SCREEN 1 and five shades of gray„in SCREEN 2.  In SCREEN 1, tile painting lets us display up to 16 hues„simultaneously.  Program 1 displays 16 shades.  Vertical bands with„four colors don't blend in this mode, so somehow bands of two must be„painted.  The secret is in line 40.  Since there are four pixels per„byte, the last half of the byte has to be reflected in the first half.„This technique insures that only two colors are in each band of four.„The first half is the same as the last half, so the first band of two„will be the same as the last band of two.„„     Tile painting doesn't work correctly in SCREEN 2, high resolution„with two colors, because this screen is always in black and white.„However, you can get five shades of gray, as shown in Program 2.„Solid lines form the brightest white.  Lines separated by two or three„lines of black yield the next two shades.  The middle gray can't be„displayed when using the PAINT command, because it's not possible to„create a bit pattern that represents two blacks and then a white.„These bit patterns generate the various shades of gray:„„„„„                Binary        Decimal   Hex      Shade„color 1  =  1 1 1 1 1 1 1 1  =  256  =  &HFF  =  White„            0 1 0 1 0 1 0 1  =   85  =  &H55  =  Dull White„            (Not accessible)                  =  Middle Gray„            0 0 0 1 0 0 0 1  =   17  =  &H11  =  Dark Gray„color 0  =  0 0 0 0 0 0 0 0  =    0  =  &H00  =  Black„„     Program 3 provides a demo of tile painting in SCREEN 1.  It fills„the screen with circles, displaying up to 16 colors on the PC.„„     Program 4, for the PC with an RGB monitor, demonstrates the„usefulness of the many new colors in a fascinating experiment.  It„uses SCREEN 1 and tile painting, but in a different way than Program 3.„Closely spaced vertical lines don't blend together on an RGB monitor,„so the previous technique won't work.  Program 4 uses the second part„of the PAINT command.  The first CHR$(bit pattern) controls the„horizontal line above the second CHR$(bit pattern).  Now the PAINT„command can control the horizontal as well as the vertical lines,„forming a checkerboard.  Although the checkerboard blends the lines„together to create new colors, the colors aren't as solid as those„produced by vertical lines on a TV or composite monitor.  Indeed, the„effect won't look very pretty on a TV or composite monitor; it's„passable on an RGB.„„     To use the new colors in your own programs, choose one of the„example programs.  This table summarizes the programs and the number„of color variations possible in each.„„           Screen     Max     Colors per    Display„Program     Mode     Colors     Screen       Device„„   1       SCREEN 1    16         16        TV or CC„   2       SCREEN 2     5          5        TV or CC„   3       SCREEN 1    16         16        TV or CC„   4       SCREEN 1    20         10          RGB„„Program 1:„10 SCREEN 1:CLS:KEY OFF:COLOR ,0„20 RANDOMIZE VAL(RIGHT$(TIME$,2)):Z=-1:A=INT(320/16):Y=0„30 FOR X=0 TO 15:Z=Z+1„40 LINE (X*A,0)-(X*A+A,200),3,B„50 IF Z<>0 THEN PAINT (X*A+1,1),CHR$(Z+Z*16),3„60 LINE (X*A,0)-(X*A+A,200),0,B„70 NEXT X„„Program 2:„10 SCREEN 2,1:CLS:KEY OFF„20 FOR X=1 TO 100:LINE (X,1)-(X,200),1:NEXT X„30 FOR X=101 TO 200 STEP 2:LINE (X,1)-(X,200),1:NEXT X„40 FOR X=201 TO 300 STEP 3:LINE (X,1)-(X,200),1:NEXT X„50 FOR X=301 TO 400 STEP 4:LINE (X,1)-(X,200),1:NEXT X„60 GOTO 60„„„„Program 3:„10 SCREEN 1:CLS:KEY OFF:COLOR ,0„20 RANDOMIZE VAL(RIGHT$(TIME$,2))„30 X=RND*320:Y=RND*200:R=RND*10+10:TILE=INT(RND*(15)+1)„40 CIRCLE (X,Y),R,3:PAINT (X,Y),CHR$(TILE+TILE*16),3:CIRCLE (X,Y),R,0„50 GOTO 20„„Program 4:„10 SCREEN 1:CLS:KEY OFF:COLOR ,0„20 RANDOMIZE VAL(RIGHT$(TIME$,2)):Z=-1:A=INT(320/16):Y=0:C=0„30 FOR X=0 TO 15:Z=Z+1„40 LINE (X*A,0)-(X*A+A,200),3,B:Y=Z+Z*16:Q=Y*4:R=INT(Q/256):Q=Q-R*256+R„50 IF Z<>0 THEN PAINT (X*A+1,1),CHR$(Y)+CHR$(Q),3„60 LINE (X*A,0)-(X*A+A,200),0,B„70 NEXT X„Mike Huff                      VGA/SVGA INTERRUPTS            FidoNet QUIK_BAS Echo          03-03-96 (20:38)       Text                   26   1180     GRAPHICS.FAQ'> inreg.ax = &H1C ' Sets 640X480X256 mode „'> CALL INTERRUPT(&H10, inreg, outreg)„„This routine doesn't work so great on my machine (or at least my Trident VESA„card.) You used the wrong value for the AX register. Here's a list that„should work on any VGA/SVGA machine:„„AX      Resolution     Text H/W         Segment      „--------------------------------------------------------------------------„5Ch for 640x400x256     (80x25)          A000h       „5Dh for 640x480x256     (80x30)          A000h„6Ch for 640x480x16M     (80x30)          A000h       „5Bh for 800x600x16      (100x75)         A000h       „5Eh for 800x600x256     (100x75)         A000h       „5Fh for 1024x768x16     (128x48)         A000h       „62h for 1024x768x256    (128x48)         A000h       „63h for 1280x1024x16    (160x64)         A000h       „64h for 1280x1024x256   (160x64)         A000h       „„Some of the higher res or color modes may not work on every video card.„You should also use direct memory writes instead of the extremely slow BIOS„"PSET" routines. Here's an example in case you don't know:„„DEF SEG = &HA000„POKE (Xmax& * Y& + X&), TheColorYaWant%„DEF SEG„Wim Osterholt                  I/O PORT ADDRESSES             FidoNet QUIK_BAS Echo          02-06-94 (08:29)       Text                   2114 78926    PORTS.LST   [This file was provided by Wim Osterholt (2:512/56.198).]„Last Change: 2/6/94„„„„		XT, AT and PS/2	 I/O port addresses„„      Do NOT consider this information as complete and accurate.„      If you want to do harware programming check ALWAYS the„      appropriate data sheets. Be aware that erroneously programming„      can put your hardware or your data at risk. „„      There is a memory mapped address in use for I/O functions of which I„      think it should be mentioned here. See at the end of this list.„„-------------------------------------------------------------------------------„0000-001F ----	DMA 1	(first Direct Memory Access controller 8237)„„0000	r/w	DMA channel 0  address	byte  0, then byte 1.„0001	r/w	DMA channel 0 word count byte 0, then byte 1.„0002	r/w	DMA channel 1  address	byte  0, then byte 1.„0003	r/w	DMA channel 1 word count byte 0, then byte 1.„0004	r/w	DMA channel 2  address	byte  0, then byte 1.„0005	r/w	DMA channel 2 word count byte 0, then byte 1.„0006	r/w	DMA channel 3  address	byte  0, then byte 1.„0007	r/w	DMA channel 3 word count byte 0, then byte 1.„„0008	r	DMA channel 0-3 status register„		 bit 7 = 1  channel 3 request„		 bit 6 = 1  channel 2 request„		 bit 5 = 1  channel 1 request„		 bit 4 = 1  channel 0 request„		 bit 3 = 1  channel terminal count on channel 3„		 bit 2 = 1  channel terminal count on channel 2„		 bit 1 = 1  channel terminal count on channel 1„		 bit 0 = 1  channel terminal count on channel 0„„0008	w	DMA channel 0-3 command register„		 bit 7 = 1  DACK sense active high„		       = 0  DACK sense active low„		 bit 6 = 1  DREQ sense active high„		       = 0  DREQ sense active low„		 bit 5 = 1  extended write selection„		       = 0  late write selection„		 bit 4 = 1  rotating priority„		       = 0  fixed priority„		 bit 3 = 1  compressed timing„		       = 0  normal timing„		 bit 2 = 1  enable controller„		       = 0  enable memory-to-memory„„0009	w	DMA write request register„„000A	r/w	DMA channel 0-3 mask register„		 bit 7-3 = 0   reserved„		 bit 2	 = 0   clear mask bit„			 = 1   set mask bit„		 bit 1-0 = 00  channel 0 select„			 = 01  channel 1 select„			 = 10  channel 2 select„			 = 11  channel 3 select„„000B	w	DMA channel 0-3 mode register„		 bit 7-6 = 00  demand mode„			 = 01  single mode„			 = 10  block mode„			 = 11  cascade mode„		 bit 5	 = 0   address increment select„			 = 1   address decrement select„		 bit 3-2 = 00  verify operation„			 = 01  write to memory„			 = 10  read from memory„			 = 11  reserved„		 bit 1-0 = 00  channel 0 select„			 = 01  channel 1 select„			 = 10  channel 2 select„			 = 11  channel 3 select„„000C	w	DMA clear byte pointer flip-flop„000D	r	DMA read temporary register„000D	w	DMA master clear„000E	w	DMA clear mask register„000F	w	DMA write mask register„„-------------------------------------------------------------------------------„0010-001F ----	DMA controller (8237) on PS/2 model 60 & 80„„-------------------------------------------------------------------------------„0018	w	PS/2 extended function register„„-------------------------------------------------------------------------------„001A		PS/2 extended function execute„„-------------------------------------------------------------------------------„0020-003F ----	PIC 1	(Programmable Interrupt Controller 8259)„„0020	w	PIC initialization command word ICW1„		 bit 7-5 = 0  only used in 80/85 mode„		 bit 4	 = 1  ICW1 is being issued„		 bit 3	 = 0  edge triggered mode„			 = 1  level triggered mode„		 bit 2	 = 0  successive interrupt vectors use 8 bytes„			 = 1  successive interrupt vectors use 4 bytes„		 bit 1	 = 0  cascade mode„			 = 1  single mode, no ICW3 needed„		 bit 0	 = 0  no ICW4 needed„			 = 1  ICW4 needed„„0021	w	PIC  ICW2,ICW3,ICW4 after ICW1 to 0020„		ICW2:„		 bit 7-3 = address lines A0-A3 of base vector address for PIC„		 bit 2-0 = reserved„		ICW3:„		 bit 7-0 = 0  slave controller not attached to corresponding„			      interrupt pin„			 = 1  slave controller attached to corresponding„			      interrupt pin„		ICW4:„		 bit 7-5 = 0  reserved„		 bit 4	 = 0  no special fully-nested mode„			 = 1  special fully-nested mode„		 bit 3-2 = 0x nonbuffered mode„			 = 10 buffered mode/slave„			 = 11 buffered mode/master„		 bit 1	 = 0  normal EOI„			 = 1  Auto EOI„		 bit 0	 = 0  8085 mode„			 = 1  8086/8088 mode„„0021	r/w	PIC master interrupt mask register„		OCW1:„		 bit 7 = 0  enable parallel printer interrupt„		 bit 6 = 0  enable diskette interrupt„		 bit 5 = 0  enable fixed disk interrupt„		 bit 4 = 0  enable serial port 1 interrupt„		 bit 3 = 0  enable serial port 2 interrupt„		 bit 2 = 0  enable video interrupt„		 bit 1 = 0  enable keyboard, mouse, RTC interrupt„		 bit 0 = 0  enable timer interrupt„		OCW2:„		 bit 7-5 = 000	rotate in auto EOI mode (clear)„			 = 001	nonspecific EOI„			 = 010	no operation„			 = 011	specific EOI„			 = 100	rotate in auto EOI mode (set)„			 = 101	rotate on nonspecific EOI command„			 = 110	set priority command„			 = 111	rotate on specific EOI command„		 bit 4	 = 0	reserved„		 bit 3	 = 0	reserved„		 bit 2-0	interrupt request to which the command applies„„0020	r	PIC  interrupt request/in-service registers by OCW3„		request register:„		 bit 7-0 = 0  no active request for the corresponding int. line„			 = 1  active request for corresponding interrupt line„		in-service register:„		 bit 7-0 = 0  corresponding line not currently being serviced„			 = 1  corresponding int. line currently being serviced„„0020	w	PIC OCW3„		 bit 7	 = 0   reserved„		 bit 6-5 = 0x  no operation„			 = 10  reset special mask„			 = 11  set special mask„		 bit 4	 = 0   reserved„		 bit 3	 = 1   reserved„		 bit 2	 = 0   no poll command„			 = 1   poll command„		 bit 1-0 = 0x  no operation„			 = 10  read int.request register on next read at 0020„			 = 11  read int.in-service register on next read 0020„„-------------------------------------------------------------------------------„0022-002B ----	Intel 82355, part of chipset for 386sx„		 initialisation in POST will disable these addresses,„		 only a hard reset will enable them again.„„0022	r/w	82335 MCR memory configuration register„0024		82335 RC1 roll compare register„0026		82335 RC2 roll compare register„0028		82335 CC0 compare register„002A		82335 CC1 compare register„„		  values for CC0 and CC1:„		  00F9,0000  enable range compare CC0 0-512K  CC1 disable„		  00F1,0000  enable range compare CC0 0-1024K CC1 disable„		  00F1,10F9  enable range compare CC0 0-1M    CC1 1M-1M5„		  00E1,0000  enable range compare CC0 0-2M    CC1 disable„		  00E1,0000  enable range compare CC0 0-2M    CC1 disable„		  00C1,0000  enable range compare CC0 0-4M    CC1 disable„		  00C1,40E1  enable range compare CC0 0-4M    CC1 4M-6M„		  0081,0000  enable range compare CC0 0-8M    CC1 disable„„-------------------------------------------------------------------------------„0038-003F ----	PC radio by CoZet Info Systems„		The I/O address range is dipswitch selectable from:„		   038-03F and 0B0-0BF„		   078-07F and 0F9-0FF„		   138-13F and 1B0-1BF„		   178-17F and 1F9-1FF„		   238-23F and 2B0-2BF„		   278-27F and 2F0-2FF„		   338-33F and 3B0-3BF„		   378-37F and 3F0-3FF„		All of these addresses show a readout of FF in initial state.„		Once started, all of the addresses show	 FB, whatever might„		happen.„„-------------------------------------------------------------------------------„0040-005F ----	PIT  (Programmable Interrupt Timer  8253, 8254)„		 XT & AT uses 40-43    PS/2 uses 40, 42,43,44, 47„„0040	r/w	PIT  counter 0, counter divisor	      (XT, AT, PS/2)„0041	r/w	PIT  counter 1, RAM refresh counter   (XT, AT)„0042	r/w	PIT  counter 2, cassette & speaker    (XT, AT, PS/2)„„0043	r/w	PIT  mode port, control word register for counters 0-2„		 bit 7-6 = 00  counter 0 select„			 = 01  counter 1 select	  (not PS/2)„			 = 10  counter 2 select„		 bit 5-4 = 00  counter latch command„			 = 01  read/write counter bits 0-7 only„			 = 10  read/write counter bits 8-15 only„			 = 11  read/write counter bits 0-7 first, then 8-15„		 bit 3-1 = 000 mode 0 select„			 = 001 mode 1 select - programmable one shot„			 = x10 mode 2 select - rate generator„			 = x11 mode 3 select - square wave generator„			 = 100 mode 4 select - software triggered strobe„			 = 101 mode 5 select - hardware triggered strobe„		 bit 0	 = 0   binary counter 16 bits„			 = 1   BCD counter„„0044	r/w	PIT  counter 3 (PS/2, EISA)„		used as fail-safe timer. generates an NMI on time out.„		for user generated NMI see at 0462.„„0047	w	PIT  control word register counter 3 (PS/2, EISA)„		 bit 7-6 = 00  counter 3 select„			 = 01  reserved„			 = 10  reserved„			 = 11  reserved„		 bit 5-4 = 00  counter latch command counter 3„			 = 01  read/write counter bits 0-7 only„			 = 1x  reserved„		 bit 3-0 = 00„„0048		EISA„004A		EISA„004B		EISA„„-------------------------------------------------------------------------------„0060-006F ----	Keyboard controller (8041, 8042)  (or PPI (8255) on XT)„		 XT uses 60-63,	 AT uses 60-64„„		 AT keyboard controller input port bit definitions„		  bit 7	  = 0  keyboard inhibited„		  bit 6	  = 0  CGA, else MDA„		  bit 5	  = 0  manufacturing jumper installed„		  bit 4	  = 0  system RAM 512K, else 640K„		  bit 3-0      reserved„„		 AT keyboard controller input port bit definitions by Compaq„		  bit 7	  = 0  security lock is locked„		  bit 6	  = 0  Compaq dual-scan display, 1=non-Compaq display„		  bit 5	  = 0  system board dip switch 5 is ON„		  bit 4	  = 0  auto speed selected, 1=high speed selected„		  bit 3	  = 0  slow (4MHz), 1 = fast (8MHz)„		  bit 2	  = 0  80287 installed, 1= no NDP installed„		  bit 1-0      reserved„„		 AT keyboard controller output port bit definitions„		  bit 7 =    keyboard data output„		  bit 6 =    keyboard clock output„		  bit 5 = 0  input buffer full„		  bit 4 = 0  output buffer empty„		  bit 3 =    reserved (see note)„		  bit 2 =    reserved (see note)„		  bit 1 =    gate A20„		  bit 0 =    system reset„		Note:	bits 2 and 3 are the turbo speed switch or password„			  lock on Award/AMI/Phoenix BIOSes.  These bits make„			  use of nonstandard keyboard controller BIOS„			  functionality to manipulate„			    pin 23 (8041 port 22) as turbo switch for AWARD„			    pin 35 (8041 port 15) as turbo switch/pw lock for„				Phoenix„„0060	r/w	KB controller data port or keyboard input buffer (ISA, EISA)„		should only be read from after status port bit0 = 1„		should only be written to if status port bit1 = 0„		keyboard commands (data goes also to port 0060):„		 ED	dbl   set/reset mode indicators Caps Num Scrl„		 EE	sngl  diagnostic echo. returns EE.„		 EF-F2	sngl  NOP (No OPeration). reserved for future use„		 F3	dbl   set typematic rate/delay„		 F4	sngl  enable keyboard„		 F5	sngl  disable keyboard. set default parameters„		 F6	sngl  set default parameters„		 F7-FD	sngl  NOP„		 FE	sngl  resend last scancode„		 FF	sngl  perform internal power-on reset function„„„0060	r	KeyBoard or KB controller data output buffer (via PPI on XT)„„0061	w	KB controller port B (ISA, EISA)   (PS/2 port A is at 0092)„		system control port for compatibility with 8255„		 bit 7	(1= IRQ 0 reset )„		 bit 6-4    reserved„		 bit 3 = 1  channel check enable„		 bit 2 = 1  parity check enable„		 bit 1 = 1  speaker data enable„		 bit 0 = 1  timer 2 gate to speaker enable„„0061	r	KB controller port B control register (ISA, EISA)„		system control port for compatibility with 8255„		 bit 7	 parity check occurred„		 bit 6	 channel check occurred„		 bit 5	 mirrors timer 2 output condition„		 bit 4	 toggles with each refresh request„		 bit 3	 channel check status„		 bit 2	 parity check status„		 bit 1	 speaker data status„		 bit 0	 timer 2 gate to speaker status„„0061	w	PPI  Programmable Peripheral Interface 8255 (XT only)„		system control port„		 bit 7 = 1  clear keyboard„		 bit 6 = 0  hold keyboard clock low„		 bit 5 = 0  I/O check enable„		 bit 4 = 0  RAM parity check enable„		 bit 3 = 0  read low switches„		 bit 2	    reserved, often used as turbo switch„		 bit 1 = 1  speaker data enable„		 bit 0 = 1  timer 2 gate to speaker enable„„0062	r/w	PPI (XT only)„		 bit 7 = 1  RAM parity check„		 bit 6 = 1  I/O channel check„		 bit 5 = 1  timer 2 channel out„		 bit 4	    reserved „		 bit 3 = 1  system board RAM size type 1„		 bit 2 = 1  system board RAM size type 2„		 bit 1 = 1  coprocessor installed„		 bit 0 = 1  loop in POST„„0063	r/w	PPI (XT only) command mode register  (read dipswitches)„		 bit 7-6 = 00  1 diskette drive„			 = 01  2 diskette drives„			 = 10  3 diskette drives„			 = 11  4 diskette drives„		 bit 5-4 = 00  reserved„			 = 01  40*25 color (mono mode)„			 = 10  80*25 color (mono mode)„			 = 11  MDA 80*25„		 bit 3-2 = 00  256K (using 256K chips)„			 = 01  512K (using 256K chips)„			 = 10  576K (using 256K chips)„			 = 11  640K (using 256K chips)„		 bit 3-2 = 00  64K  (using 64K chips)„			 = 01  128K (using 64K chips)„			 = 10  192K (using 64K chips)„			 = 11  256K (using 64K chips)„		 bit 1-0       reserved„„0064	r	KB controller read status (ISA, EISA)„		 bit 7 = 1 parity error on transmission from keyboard„		 bit 6 = 1 receive timeout„		 bit 5 = 1 transmit timeout„		 bit 4 = 0 keyboard inhibit„		 bit 3 = 1 data in input register is command„			 0 data in input register is data„		 bit 2 = 0 system flag status 0=power up or reset 1=selftest OK„		 bit 1 = 1 input buffer full (input 60/64 has data for 8042)„		 bit 0 = 1 output buffer full (output 60 has data for system)„„0064	r	 KB controller read status by Compaq„		 bit 7 = 1 parity error detected (11-bit format only). If an„			   error is detected, a Resend command is sent to the„			   keyboard once only, as an attempt to recover.„		 bit 6 = 1 receive timeout. transmission didn't finish in 2mS.„		 bit 5 = 1 transmission timeout error„			    bit 5,6,7  cause„				1 0 0  No clock„				1 1 0  Clock OK, no response„				1 0 1  Clock OK, parity error„		 bit 4 = 0 security lock engaged„		 bit 3 = 1 data in OUTPUT register is command„			 0 data in OUTPUT register is data„		 bit 2 = 0 system flag status 0=power up or reset 1=soft reset„		 bit 1 = 1 input buffer full (output 60/64 has data)„		 bit 0 = 0 no new data in buffer (input 60 has data)„„0064	w	KB controller input buffer (ISA, EISA)„		KB controller commands (data goes to port 0060):„		 20	read  read byte zero of internal RAM, this is the„			      last KB command send to 8041„		      Compaq  Put current command byte on port 0060„				command structure:„				bit 7	reserved„				bit 6 = 1 convert KB codes to 8086 scan codes„				bit 5 = 0 use 11-bit codes, 1=use 8086 codes„				bit 4 = 0 enable keyboard, 1=disable keyboard„				bit 3 = 1 ignore security lock state„				bit 2	  this bit goes into bit2 status reg.„				bit 1 = 0 reserved„				bit 0 = 1 generate int. when output buffer full„		 21-3F	read  reads the byte specified in the lower 5 bits of„			      the command in the 8041's internal RAM„		 60-7F	dbl   writes the data byte to the address specified in„			      the 5 lower bits of the command.„„			      Alternate description KB IO command 60 summary:„			       bit7 = 0 reserved„			       bit6 =	IBM PC compatibility mode„			       bit5 =	IBM PC mode„			       bit4 =	disable kb„			       bit3 =	inhibit override„			       bit2 =	system flag„			       bit1 = 0 reserved„			       bit0 =	enableoutput buffer full interrupt„„		 60   Compaq  Load new command (60 to [64], command to [60])„		 A1   Compaq  unknown speedfunction ??„		 A2   Compaq  unknown speedfunction ??„		 A3   Compaq  Enable system speed control„		 A4   Compaq  Toggle speed„		 A5   Compaq  Special reed. the 8042 places the real values„			      of port 2 except for bits 4 and 5 wich are given„			      a new definition in the output buffer. No output„			      buffer full is generated.„				if bit 5 = 0, a 9-bit keyboard is in use„				if bit 5 = 1, an 11-bit keyboard is in use„				if bit 4 = 0, outp-buff-full interrupt disabled„				if bit 4 = 1, output-buffer-full int. enabled„		 A6   Compaq  unknown speedfunction ??„		 AA	sngl  initiate self-test. will return 55 to data port„		      Compaq  Initializes ports 1 and 2, disables the keyboard„			      and clears the buffer pointers. It then places„			      55 in the output buffer.„		 AB	sngl  initiate interface test. result values:„			       0 = no error„			       1 = keyboard clock line stuck low„			       2 = keyboard clock line stuck high„			       3 = keyboard data line is stuck low„			       4 = keyboard data line stuck high„		      Compaq   5 = Compaq diagnostic feature„		 AC	read  diagnostic dump. the contents of the 8041 RAM,„			      output port, input port, status word are send.„		 AD	sngl  disable keyboard (sets bit 4 of commmand byte)„		 AE	sngl  enable keyboard  (resets bit 4 of commmand byte)„		 AF	AWARD Enhanced Command: read keyboard version„		 C0	read  read input port„		      Compaq  Places status of input port in output buffer. use„			      this command only when the output buffer is empty„		 C1	AWARD Enhanced Command: poll input port Low nibble„		 C2	AWARD Enhanced Command: poll input port High nibble„		 D0	read  read output port„		      Compaq  Places byte in output port in output buffer. use„			      this command only when the output buffer is empty„		 D1	dbl   write output port. next byte written  to 0060„			      will be written to the 8041 output port„		      Compaq  The system speed bits are not set by this command„			      use commands A1-A6 (!) for speed functions.„		 D2	AWARD Enhanced Command: write keyboard output buffer„		 D3	AWARD Enhanced Command: write pointing device out.buf.„		 D4	AWARD Enhanced Command: write to auxiliary device„		 DD	sngl  disable address line A20. default in Real Mode„		 DF	sngl  enable address line A20„		 E0	read  read test inputs. bit0 = T0 and bit1 = T1„		 Exx	AWARD Enhanced Command: active output port„		 ED   Compaq  This is a two part command to control the state„			      of the NumLock CpasLock and ScrollLock LEDs„			      The second byte contains the state to set LEDs.„				bit 7-3	   reserved. should be set to 0.„				bit 2 = 0  Caps Lock LED off„				bit 1 = 0  Num Lock LED off„				bit 0 = 0  Scroll Lock LED off„		 F0-FF	sngl  pulse output port low for 6 microseconds.„			      bits 0-3 contain the mask for the bits to be„			      pulsed. a bit is pulsed if its mask bit is zero.„			      bit0=system reset. Don't set to zero. Pulse only!„„general note:	 Keyboard controllers are widely different from each other.„		 You cannot generally exchange them between different machines.„note on Award:	 Derived from Award's Enhanced KB controller advertising sheet.„note on Compaq:	 Derived from the Compaq Deskpro 386 Tech. Ref. Guide.„„0065	r	communications port (Olivetti M24)„„0068	w	HP-Vectra  control buffer (HP commands)„0069	r	HP-Vectra  SVC (keyboard request SerViCe port)„006A	w	HP-Vectra  clear processing, done„„006C-006F	HP-HIL	(Human Interface Link = async. serial inputs 0-7)„„-------------------------------------------------------------------------------„0070-007F ----	CMOS RAM/RTC (Real Time Clock  MC146818)„„0070	w	CMOS RAM index register port (ISA, EISA)„		 bit 7	 = 1  NMI disabled„			 = 0  NMI enabled„		 bit 6-0      CMOS RAM index (64 bytes, sometimes 128 bytes)„„		any write to 0070 should be followed by an action to 0071„		or the RTC wil be left in an unknown state.„„0071	r/w	CMOS RAM data port (ISA, EISA)„		RTC registers:„		00    current second in BCD„		01    alarm second   in BCD„		02    current minute in BCD„		03    alarm minute   in BCD„		04    current hour in BCD„		05    alarm hour   in BCD„		06    day of week  in BCD„		07    day of month in BCD„		08    month in BCD„		09    year  in BCD (00-99)„		0A    status register A„		       bit 7 = 1  update in progress„		       bit 6-4 divider that identifies the time-based„				frequency„		       bit 3-0 rate selection output  frequency and int. rate„		0B    status register B„		       bit 7 = 0  run„			     = 1  halt„		       bit 6 = 1  enable periodic interrupt„		       bit 5 = 1  enable alarm interrupt„		       bit 4 = 1  enable update-ended interrupt„		       bit 3 = 1  enable square wave interrupt„		       bit 2 = 1  calendar is in binary format„			     = 0  calendar is in BCD format„		       bit 1 = 1  24-hour mode„			     = 0  12-hour mode„		       bit 0 = 1  enable daylight savings time. only in USA.„				  useless in Europe. Some DOS versions clear„				  this bit when you use the DAT/TIME command.„		0C    status register C„		       bit 7 =	  interrupt request flag„		       bit 6 =	  peridoc interrupt flag„		       bit 5 =	  alarm interrupt flag„		       bit 4 =	  update interrupt flag„		       bit 3-0	  reserved„		0D    status register D„		       bit 7 = 1  Real-Time Clock has power„		       bit 6-0	  reserved„		0E    diagnostics status byte„		       bit 7 = 0  RTC lost power„		       bit 6 = 1  CMOS RAM checksum bad„		       bit 5 = 1  invalid configuration information at POST„		       bit 4 = 1  memory size error at POST„		       bit 3 = 1  fixed disk/adapter failed initialization„		       bit 2 = 1  CMOS RAM time found invalid„		       bit 1 = 1  adapters do not match configuration (EISA)„		       bit 0 = 1  time out reading an adapter ID (EISA)„		0F    shutdown status byte„		       00 = normal execution of POST„		       01 = chip set initialization for real mode reentry„		       04 = jump to bootstrap code„		       05 = issue an EOI an JMP to Dword ptr at 40:67„		       06 = JMP to Dword ptrv at 40:67 without EOI„		       07 = return to INT15/87 (block move)„		       08 = return to POST memory test„		       09 = return to INT15/87 (block move)„		       0A = JMP to Dword ptr at 40:67 without EOI„		       0B = return IRETS through 40:67„		10    diskette drive type for A: and B:„		       bit 7-4	drive type of drive 0„		       bit 3-0	drive type of drive 1„			       = 0000	   no drive„			       = 0001	   360K„			       = 0010	   1M2„			       = 0011	   720K„			       = 0100	   1M44„			       = 0101-1111 reserved„		11    reserved / AMI Extended CMOS setup (AMI Hi-Flex BIOS)„		       bit 7   = 1     Typematic Rate Programming„		       bit 6-5 = 00    Typematic Rate Delay 250 mSec„		       bit 4-0 = 00011 Typematic Rate 21.8 Chars/Sec„		12    fixed disk drive type for drive 0 and drive 1„		       bit 7-4	drive type of drive 0„		       bit 3-0	drive type of drive 1„				if either of the nibbles equals 0F, then bytes„				19 an 1A are valid„		13    reserved / AMI Extended CMOS setup (AMI Hi-Flex BIOS)„		       bit 7 = 1  Mouse Support Option„		       bit 6 = 1  Above 1 MB Memory Test disable„		       bit 5 = 1  Memory Test Tick Sound disable„		       bit 4 = 1  Memory Parity Error Check enable„		       bit 3 = 1  Hit <ESC> Message Display disabled„		       bit 2 = 1  Hard Disk Type 47 Data Area at address 0:300„		       bit 1 = 1  Wait For <F1> If Any Error enabled„		       bit 0 = 1  System Boot Up Num Lock is On„		14    equipment byte„		       bit 7-6	 diskette drives installed„			       = 00  1 drive installed„			       = 01  2 drives installed„			       = 10  reserved„			       = 11  reserved„		       bit 5-4	 primary display„			       = 00  adapter card with option ROM „			       = 01  40*25 color„			       = 10  80*25 color„			       = 11  monochrome„		       bit 3-2	 reserved„		       bit 1   = 1  coprocessor installed (non-Weitek)„		       bit 0	    diskette drive avaliable for boot„		15    LSB of systemn base memory in Kb„		16    MSB of systemn base memory in Kb„		17    LSB of total extended memory in Kb„		18    MSB of total extended memory in Kb„		19    drive C extension byte„		1A    drive D extension byte„		1B-27 reserved„		1B/1C word to 82335 RC1 roll compare register at [24]„			(Phoenix)„		1D/1E word to 82335 RC2 roll compare register at [26]„			(Phoenix)„		28    HP-Vectra checksum over 29-2D„		29-2D reserved„		29/2A word to Intel 82335 CC0 compare register at„			[28](Phoenix)„		2B/2C word send to 82335 CC1 compare register at [2A]„			(Phoenix)„		2D    AMI Extended CMOS setup (AMI Hi-Flex BIOS)„		      (Phoenix BIOS checks for the values AA or CC)„		       bit 7 = 1  Weitek Processor Absent„		       bit 6 = 1  Floppy Drive Seek At Boot disabled„		       bit 5 = 1  System Boot Up Sequence  C:, A:„		       bit 4 = 1  System Boot Up Speed is high„		       bit 3 = 1  Cache Memory enabled„		       bit 2 = 1  Internal Cache Memory	 <1>„		       bit 1-0	  reserved„		2E    CMOS MSB checksum over 10-2D„		2F    CMOS LSB checksum over 10-2D„		30    LSB of extended memory found above 1Mb at POST„		31    MSB of extended memory found above 1Mb at POST„		32    date century in BCD„		33    information flags„		       bit4 = bit4 from CPU register CR0   (Phoenix)„			      this bit is only known as INTEL RESERVED„		34-3F reserved	„		34     bit4 bit5 (Phoenix BIOS)„		3D/3E word to 82335 MCR memory config register at„			[22](Phoenix)„		3D     bit3	 base memsize 512/640  (Phoenix)„		3E     bit7 = 1	 relocate enable       (Phoenix)„		       bit1 = 1	 shadow video enable   (Phoenix)„		       bit0 = 1	 shadow BIOS enable    (Phoenix)„„„		User Definable Drive Parameters are also stored in CMOS RAM:„„		AMI (386sx BIOS 1989) first user definable drive (type 47)„		 1B  L cylinders„		 1C  H cylinders„		 1D  heads„		 1E  L Write Precompensation Cylinder„		 1F  H Write Precompensation Cylinder„		 20  ??„		 21  L cylinders parking zone„		 22  H cylinders parking zone„		 23  sectors„„		AMI (386sx BIOS 1989) second user definable drive (type 48)„		 24  L cylinders„		 25  H cylinders„		 26  heads„		 27  L Write Precompensation Cylinder„		 28  H Write Precompensation Cylinder„		 29  ??„		 2A  L cylinders parking zone„		 2B  H cylinders parking zone„		 2C  sectors„„		Phoenix (386BIOS v1.10.03 1988) 1st user definable drv (type48)„		 20  L cylinders„		 21  H cylinders„		 22  heads„		 23  L Write Precompensation Cylinder„		 24  H Write Precompensation Cylinder„		 25  L cylinders parking zone„		 26  H cylinders parking zone„		 27  sectors„„		Phoenix (386BIOS v1.10.03 1988) 2nd user definable drv (type49)„		(when PS/2-style password option is not used)„		 35  L cylinders„		 36  H cylinders„		 37  heads„		 38  L Write Precompensation Cylinder„		 39  H Write Precompensation Cylinder„		 3A  L cylinders parking zone„		 3B  H cylinders parking zone„		 3C  sectors„„0078		HP-Vectra  Hard Reset: NMI enable/disable„		 bit 7 = 0  disable & clear hard reset from HP-HIL controller„		       = 1  enable hard reset from HP-HIL controller chip„		 bit 6-0    reserved„„-------------------------------------------------------------------------------„0078-007F ----	PC radio by CoZet Info Systems„		The I/O address range is dipswitch selectable from:„		   038-03F and 0B0-0BF„		   078-07F and 0F9-0FF„		   138-13F and 1B0-1BF„		   178-17F and 1F9-1FF„		   238-23F and 2B0-2BF„		   278-27F and 2F0-2FF„		   338-33F and 3B0-3BF„		   378-37F and 3F0-3FF„		All of these addresses show a readout of FF in initial state.„		Once started, all of the addresses show	 FB, whatever might„		happen.„„-------------------------------------------------------------------------------„007C-007D ----	HP-Vectra  PIC 3   (Programmable Interrupt Controller 8259)„		cascaded to first controller.„		used for keyboard and input device interface.„007C	r/w	HP-Vectra  PIC 3  see at 0020  PIC 1„007D	r/w	HP-Vectra  PIC 3  see at 0021  PIC 1„„-------------------------------------------------------------------------------„0080	w	Manufacturing Diagnostics port„„-------------------------------------------------------------------------------„0080-008F ----	DMA page registers   (74612)„„0080	r/w	extra page register (temporary storage)„0081	r/w	DMA channel 2 address byte 2„0082	r/w	DMA channel 3 address byte 2„0083	r/w	DMA channel 1 address byte 2„0084	r/w	extra page register„0085	r/w	extra page register„0086	r/w	extra page register„0087	r/w	DMA channel 0 address byte 2„0088	r/w	extra page register„0089	r/w	DMA channel 6 address byte 2„0089	r/w	DMA channel 7 address byte 2„0089	r/w	DMA channel 5 address byte 2„008C	r/w	extra page register„008D	r/w	extra page register„008E	r/w	extra page register„008F	r/w	DMA refresh page register„„-------------------------------------------------------------------------------„0090-009F ----	PS/2 POS (Programmable Option Select)„„0090		Central arbitration control port„0091		Card selection feedback„„0092	r/w	PS/2 system control port A  (port B is at 0061)„		 bit 7-6   any bit set to 1 turns activity light on„		 bit 5	   reserved„		 bit 4 = 1 watchdog timout occurred „		 bit 3 = 0 RTC/CMOS security lock (on password area) unlocked„		       = 1 CMOS locked (done by POST)„		 bit 2	   reserved„		 bit 1 = 1 indicates A20 active„		 bit 0 = 0 system reset or write„			 1 pulse alternate reset pin (alternate CPU reset)„„0094	w	system board enable/setup register„		 bit 7 = 1  enable functions„		       = 0  setup functions„		 bit 5 = 1  enables VGA„		       = 0  setup VGA„„0095		reserved„„0096	w	adapter enable /setup register„		 bit 3 = 1  setup adapters„		       = 0  enable registers„„0097		reserved„„-------------------------------------------------------------------------------„00A0-00AF ----	PIC 2	(Programmable Interrupt Controller 8259)„„00A0	r/w	NMI mask register (XT)„„00A0	r/w	PIC 2  same as 0020 for PIC 1„00A1	r/w	PIC 2  same as 0021 for PIC 1 except for OCW1:„		 bit 7 = 0  reserved„		 bit 6 = 0  enable fixed disk interrupt„		 bit 5 = 0  enable coprocessor exception interrupt„		 bit 4 = 0  enable mouse interrupt„		 bit 3 = 0  reserved„		 bit 2 = 0  reserved„		 bit 1 = 0  enable redirect cascade„		 bit 0 = 0  enable real-time clock interrupt„„-------------------------------------------------------------------------------„00B0-00BF ----	PC radio by CoZet Info Systems„		The I/O address range is dipswitch selectable from:„		   038-03F and 0B0-0BF„		   078-07F and 0F9-0FF„		   138-13F and 1B0-1BF„		   178-17F and 1F9-1FF„		   238-23F and 2B0-2BF„		   278-27F and 2F0-2FF„		   338-33F and 3B0-3BF„		   378-37F and 3F0-3FF„		All of these addresses show a readout of FF in initial state.„		Once started, all of the addresses show	 FB, whatever might„		happen.„„-------------------------------------------------------------------------------„00C0	  ----	TI  SN746496 programmable tone/noise generator	PCjr„„-------------------------------------------------------------------------------„00C0-00DF ----	DMA 2	(second Direct Memory Access controller 8237)„„00C0	r/w	DMA channel 4 memory address bytes 1 and 0 (low) (ISA, EISA)„00C2	r/w	DMA channel 4 transfer count bytes 1 and 0 (low) (ISA, EISA)„00C4	r/w	DMA channel 5 memory address bytes 1 and 0 (low) (ISA, EISA)„00C6	r/w	DMA channel 5 transfer count bytes 1 and 0 (low) (ISA, EISA)„00C8	r/w	DMA channel 6 memory address bytes 1 and 0 (low) (ISA, EISA)„00CA	r/w	DMA channel 6 transfer count bytes 1 and 0 (low) (ISA, EISA)„00CC	r/w	DMA channel 7 memory address byte 0 (low), then 1 (ISA, EISA)„00CE	r/w	DMA channel 7 transfer count byte 0 (low), then 1 (ISA, EISA)„„00D0	r	DMA channel 4-7 status register (ISA, EISA)„		 bit 7 = 1  channel 7 request„		 bit 6 = 1  channel 6 request„		 bit 5 = 1  channel 5 request„		 bit 4 = 1  channel 4 request„		 bit 3 = 1  terminal count on channel 7„		 bit 2 = 1  terminal count on channel 6„		 bit 1 = 1  terminal count on channel 5„		 bit 0 = 1  terminal count on channel 4„„00D0	w	DMA channel 4-7 command register (ISA, EISA)„		 bit 7 = 1  DACK sense active high„		       = 0  DACK sense active low„		 bit 6 = 1  DREQ sense active high„		       = 0  DREQ sense active low„		 bit 5 = 1  extended write selection„		       = 0  late write selection„		 bit 4 = 1  rotating priority„		       = 0  fixed priority„		 bit 3 = 1  compressed timing„		       = 0  normal timing„		 bit 2 = 0  enable controller„		 bit 1 = 1  enable memory-to-memory transfer„		 bit 0	    .....„„00D2	w	DMA channel 4-7 write request register (ISA, EISA)„„00D4	w	DMA channel 4-7 write single mask register (ISA, EISA)„		 bit 7-3      reserved„		 bit 2	 = 0  clear mask bit„			 = 1  set mask bit„		 bit 1-0 = 00 channel 4 select„			 = 01 channel 5 select„			 = 10 channel 6 select„			 = 11 channel 7 select„„00D6	w	DMA channel 4-7 mode register (ISA, EISA)„		 bit 7-6 = 00  demand mode„			 = 01  single mode„			 = 10  block mode„			 = 11  cascade mode„		 bit 5	 = 0   address increment select„			 = 1   address decrement select„		 bit 4	 = 0   autoinitialisation disable„			 = 1   autoinitialisation enable„		 bit 3-2 = 00  verify operation„			 = 01  write to memory„			 = 10  read from memory„			 = 11  reserved„		 bit 1-0 = 00  channel 4 select„			 = 01  channel 5 select„			 = 10  channel 6 select„			 = 11  channel 7 select„„00D8	w	DMA channel 4-7 clear byte pointer flip-flop (ISA, EISA)„00DA	r	DMA channel 4-7 read temporary register (ISA, EISA)„00DA	w	DMA channel 4-7 master clear (ISA, EISA)„00DC	w	DMA channel 4-7 clear mask register (ISA, EISA)„00DE	w	DMA channel 4-7 write mask register (ISA, EISA)„„00E0		split address register, memory encoding registers PS/2m80 only„„-------------------------------------------------------------------------------„00F0-00F5 ----	PCjr Disk Controller„„00F0		disk controller„00F2		disk controller control port„00F4		disk controller status register„00F5		disk controller data port„„-------------------------------------------------------------------------------„00F0-00FF ----	coprocessor (8087..80387)„„00F0		math coprocessor clear busy latch„00F1		math coprocessor reset„00F8-00FF	math coprocessor„„-------------------------------------------------------------------------------„00F9-00FF ----	PC radio by CoZet Info Systems„		The I/O address range is dipswitch selectable from:„		   038-03F and 0B0-0BF„		   078-07F and 0F9-0FF„		   138-13F and 1B0-1BF„		   178-17F and 1F9-1FF„		   238-23F and 2B0-2BF„		   278-27F and 2F0-2FF„		   338-33F and 3B0-3BF„		   378-37F and 3F0-3FF„		All of these addresses show a readout of FF in initial state.„		Once started, all of the addresses show	 FB, whatever might„		happen.„„-------------------------------------------------------------------------------„0100-010F ----	CompaQ Tape drive adapter. alternate address at 0300„„-------------------------------------------------------------------------------„0100-0107 ----	PS/2 POS (Programmable Option Select)„„0100	r	POS register 0	Low adapter ID byte„0101	r	POS register 1	High adapter ID byte„„0102	r/w	POS register 2	option select data byte 1„		 bit 0 is card enable (CDEN)„„0103	r/w	POS register 3	option select data byte 2„0104	r/w	POS register 4	option select data byte 3„0105	r/w	POS register 5	option select data byte 4„		 bit 7	channel active (-CHCK)„		 bit 6	channel status„„0106	r/w	POS register 6	Low subaddress extension„0107	r/w	POS register 7	High subaddress extension„„-------------------------------------------------------------------------------„0108-010F ----	8 digit LED info panel on IBM PS/2„„010F	w	leftmost character on display„010E	w	second character„....	w„0108	w	eighth character„„-------------------------------------------------------------------------------„0130-013F ----	CompaQ SCSI adapter. alternate address at 0330„„-------------------------------------------------------------------------------„0130-0133 ----	Adaptec 154xB/154xC SCSI adapter.„		alternate address at 0134, 0230, 0234 ,0330 and 0334„„-------------------------------------------------------------------------------„0134-0137 ----	Adaptec 154xB/154xC SCSI adapter.„		alternate address at 0130, 0230, 0234 ,0330 and 0334„„-------------------------------------------------------------------------------„0138-013F ----	PC radio by CoZet Info Systems„		The I/O address range is dipswitch selectable from:„		   038-03F and 0B0-0BF„		   078-07F and 0F9-0FF„		   138-13F and 1B0-1BF„		   178-17F and 1F9-1FF„		   238-23F and 2B0-2BF„		   278-27F and 2F0-2FF„		   338-33F and 3B0-3BF„		   378-37F and 3F0-3FF„		All of these addresses show a readout of FF in initial state.„		Once started, all of the addresses show	 FB, whatever might„		happen.„„-------------------------------------------------------------------------------„0140-014F ----	SCSI (alternate Small Computer System Interface) adapter„		(1st at 0340-034F)„„-------------------------------------------------------------------------------„0140-0157 ----	RTC (alternate Real Time Clock for XT)	 (1st at 0340-0357)„„-------------------------------------------------------------------------------„0170-0177 ----	HDC 2	(2nd Fixed Disk Controller)   same as 01Fx (ISA, EISA)„„-------------------------------------------------------------------------------„0178-017F ----	PC radio by CoZet Info Systems„		The I/O address range is dipswitch selectable from:„		   038-03F and 0B0-0BF„		   078-07F and 0F9-0FF„		   138-13F and 1B0-1BF„		   178-17F and 1F9-1FF„		   238-23F and 2B0-2BF„		   278-27F and 2F0-2FF„		   338-33F and 3B0-3BF„		   378-37F and 3F0-3FF„		All of these addresses show a readout of FF in initial state.„		Once started, all of the addresses show	 FB, whatever might„		happen.„„-------------------------------------------------------------------------------„01E8-01EF ----	System Control. Laptop chipset: Headland HL21 & Acer M5105„„01ED	r/w	select internal register. Data to/from 01EF„01EE	r„01EF	r/w	reg.„		5  = 1000xxxx  for low CPU clock speed (4MHz on Morse/Mitac)„		   = 0xxxxxxx  for high CPU clock speed (16MHz on Morse/Mitac)„„-------------------------------------------------------------------------------„01F0-01F7 ----	HDC 1	(1st Fixed Disk Controller)   same as 017x (ISA, EISA)„„01F0	r/w	data register„„01F1	r	error register„		diagnostic mode errors:„		 bit 7-3	reserved„		 bit 2-1 = 001	no error detected„			 = 010	formatter device error„			 = 011	sector buffer error„			 = 100	ECC circuitry error„			 = 101	controlling microprocessor error„		 operation mode:„		  bit 7	 = 1  bad block detected„			 = 0  block OK„		  bit 6	 = 1  uncorrectable ECC error„			 = 0  no error„		  bit 5	      reserved„		  bit 4	 = 1  ID found„			 = 0  ID not found„		  bit 3	      reserved„		  bit 2	 = 1  command completed„			 = 0  command aborted„		  bit 1	 = 1  track 000 not found„			 = 0  track 000 found„		  bit 0	 = 1  DAM not found„			 = 0  DAM found (CP-3022 always 0)„„01F1	w	WPC/4  (Write Precompensation Cylinder divided by 4)„„01F2	r/w	sector count„01F3	r/w	sector number„01F4	r/w	cylinder low„01F5	r/w	cylinder high„„01F6	r/w	drive/head„		 bit 7	 = 1„		 bit 6	 = 0„		 bit 5	 = 1„		 bit 4	 = 0  drive 0 select„			 = 1  drive 1 select„		 bit 3-0      head select bits„„01F7	r	status register„		 bit 7 = 1  controller is executing a command„		 bit 6 = 1  drive is ready„		 bit 5 = 1  write fault„		 bit 4 = 1  seek complete„		 bit 3 = 1  sector buffer requires servicing„		 bit 2 = 1  disk data read successfully corrected„		 bit 1 = 1  index - set to 1 each disk revolution„		 bit 0 = 1  previous command ended in an error„„01F7	w	command register„		commands:„		 98 E5	 check power mode	(IDE)„		 90	 execute drive diagnostics„		 50	 format track„		 EC	 identify drive		(IDE)„		 97 E3	 idle			(IDE)„		 95 E1	 idle immediatete	(IDE)„		 91	 initialize drive parameters„		 1x	 recalibrate„		 E4	 read buffer		(IDE)„		 C8	 read DMA with retry	(IDE)„		 C9	 read DMA without retry (IDE)„		 C4	 read multiplec		(IDE)„		 20	 read sectors with retry„		 21	 read sectors without retry„		 22	 read long with retry„		 23	 read long without retry„		 40	 read verify sectors with retry„		 41	 read verify sectors without retry„		 7x	 seek„		 EF	 set features		(IDE)„		 C6	 set multiple mode	(IDE)„		 99 E6	 set sleep mode		(IDE)„		 96 E2	 standby		(IDE)„		 94 E0	 standby immediate	(IDE)„		 E8	 write buffer		(IDE)„		 CA	 write DMA with retry	(IDE)„		 CB	 write DMA with retry	(IDE)„		 C5	 write multiple		(IDE)„		 E9	 write same		(IDE)„		 30	 write sectors with retry„		 31	 write sectors without retry„		 32	 write long with retry„		 33	 write long without retry„		 3C	 write verify		(IDE)„		 9A	 vendor unique		(IDE)„		 C0-C3	 vendor unique		(IDE)„		 8x	 vendor unique		(IDE)„		 F0-F4	 EATA standard		(IDE)„		 F5-FF	 vendor unique		(IDE)„„-------------------------------------------------------------------------------„01F9-01FF ----	PC radio by CoZet Info Systems„		The I/O address range is dipswitch selectable from:„		   038-03F and 0B0-0BF„		   078-07F and 0F9-0FF„		   138-13F and 1B0-1BF„		   178-17F and 1F9-1FF„		   238-23F and 2B0-2BF„		   278-27F and 2F0-2FF„		   338-33F and 3B0-3BF„		   378-37F and 3F0-3FF„		All of these addresses show a readout of FF in initial state.„		Once started, all of the addresses show	 FB, whatever might„		happen.„„-------------------------------------------------------------------------------„0200-020F ----	Game port reserved I/O address space  „0200-0207 ----	Game port, eight identical addresses on some boards„„0201	r	read joystick position and status„		 bit 7	status B joystick button 2 / D paddle button„		 bit 6	status B joystick button 1 / C paddle button„		 bit 5	status A joystick button 2 / B paddle button„		 bit 4	status A joystick button 1 / A paddle button„		 bit 3	B joystick Y coordinate	   / D paddle coordinate„		 bit 2	B joystick X coordinate	   / C paddle coordinate„		 bit 1	A joystick Y coordinate	   / B paddle coordinate„		 bit 0	A joystick X coordinate	   / A paddle coordinate„„	w	fire joysticks four one-shots„„-------------------------------------------------------------------------------„0210-0217 ----	Expansion unit (XT)„„0210	w	latch expansion bus data„	r	verify expansion bus data„0211	w	clear wait, test latch„	r	High byte data address„0212	r	Low byte data address„0213	w	0=enable,  1=disable expansion unit„0214	w	latch data  (receiver card port)„	r	read data   (receiver card port)„0215	r	High byte of address, then Low byte   (receiver card port)„„-------------------------------------------------------------------------------„0220-0227 ----	Soundblaster PRO and SSB 16 ASP„„-------------------------------------------------------------------------------„0220-022F ----	Soundblaster PRO 2.0„„-------------------------------------------------------------------------------„0220-022F ----	Soundblaster PRO 4.0„0220	r	left FM status port„0220	w	left FM music register address port (index)„0221	r/w	left FM music data port„0222	r	right FM status port„0222	w	right FM music register address port (index)„0223	r/w	right FM music data port„0224	w	mixer register address port (index)„0225	r/w	mixer data port„0226	w	DSP reset„0228	r	FM music status port„0228	w	FM music register address port (index)„0229	w	FM music data port„022A	r	DSP read data (voice I/O and Midi)„022C	w	DSP write data / write command„022C	r	DSP write buffer status (bit 7)„022E	r	DSP data available status (bit 7)„„		The FM music is accessible on 0388/0389 for compatibility.„„-------------------------------------------------------------------------------„0230-0233 ----	Adaptec 154xB/154xC SCSI adapter.„		alternate address at 0130, 0134, 0230, 0330 and 0334„„-------------------------------------------------------------------------------„0234-0237 ----	Adaptec 154xB/154xC SCSI adapter.„		alternate address at 0130, 0134, 0230 ,0330 and 0334„„-------------------------------------------------------------------------------„0240-0257 ----	RTC (alternate Real Time Clock for XT)	 (1st at 0340-0357)„		(used by TIMER.COM v1.2 which is the 'standard' timer program)„„-------------------------------------------------------------------------------„0258-025F ----	Intel Above Board„„-------------------------------------------------------------------------------„0278-027E ----	parallel printer port, same as 0378 and 03BC„„0278	w	data port„0279	r/w	status port„027A	r/w	control port„„-------------------------------------------------------------------------------„02A2-02A3 ----	MSM58321RS clock„„-------------------------------------------------------------------------------„02B0-02BF ----	Trantor SCSI adapter„„-------------------------------------------------------------------------------„02B0-02DF ----	alternate EGA,	primary EGA at 03C0„„-------------------------------------------------------------------------------„02C0-02Cx ----	AST-clock„„-------------------------------------------------------------------------------„02E0-02EF ----	GPIB (General Purpose Interface Bus, IEEE 488 interface)„		(GAB 0 on XT)„02E1		GPIB (adapter 0)„02E2„02E3„„-------------------------------------------------------------------------------„02E0-02EF ----	data aquisition	 (AT)„„02E2		data aquisition (adapter 0)„02E3		data aquisition (adapter 0)„„-------------------------------------------------------------------------------„02E8-02EF ----	serial port, same as 02F8, 03E8, and 03F8„„-------------------------------------------------------------------------------„02F8-02FF ----	serial port, same as 02E8, 02F8, and 03F8„„02F8	w	transmitter holding register„02F8	r	receiver buffer register„	r/w	divisor latch, low byte	  when DLAB=1„02F9	r/w	divisor latch, high byte  when DLAB=1„	r/w	interrupt enable register when DLAB=0„02FA	r	interrupt identification register„02FB	r/w	line control register„02FC	r/w	modem control register„02FD	r	line status register„02FF	r/w	scratch register„„-------------------------------------------------------------------------------„0300-0301 ---- Soundblaster 16 ASP MPU-Midi„„-------------------------------------------------------------------------------„0300-031F ----	prototype cards„		Periscope hardware debugger„„-------------------------------------------------------------------------------„0300-030F ----	Philips CD-ROM player CM50„0310-031F ----	Philips CD-ROM player CM50„„-------------------------------------------------------------------------------„0320-0323 ----	XT HDC 1   (Hard Disk Controller)„„0320	r/w	data register„„0321	w	reset controller„	r	read controller hardware status„		 bit 7-6 = 0„		 bit 5	      logical unit number„		 bit 4-2 = 0„		 bit 1	 = 0  no error„		 bit 0	 = 0 „„0322	r	read DIPswitch setting on XT controller card„	w	generate controller-select pulse„0323	w	write pattern to DMA and INT mask register„„0324-0327 ----	XT HDC 2   (Hard Disk Controller)„0328-032B ----	XT HDC 3   (Hard Disk Controller)„032C-032F ----	XT HDC 4   (Hard Disk Controller)„„-------------------------------------------------------------------------------„0330-0331 ----	MIDI interface„„-------------------------------------------------------------------------------„0330-0333 ----	Adaptec 154xB/154xC SCSI adapter. default address.„		alternate address at 0130, 0134, 0230, 0234 and 0334„„-------------------------------------------------------------------------------„0330-033F ----	CompaQ SCSI adapter. alternate address at 0130„„-------------------------------------------------------------------------------„0330-033F ----	Philips CD-ROM player CM50„„-------------------------------------------------------------------------------„0334-0337 ----	Adaptec 154xB/154xC SCSI adapter.„		alternate address at 0130, 0134, 0230 ,0234 and 0330„„-------------------------------------------------------------------------------„0338	  ----	AdLib soundblaster card„„-------------------------------------------------------------------------------„0340-034F ----	Philips CD-ROM player CM50„„-------------------------------------------------------------------------------„0340-034F ----	SCSI (1st Small Computer System Interface) adapter„		(alternate at 0140-014F)„„-------------------------------------------------------------------------------„0340-0357 ----	RTC (1st Real Time Clock for XT), (alternate at 0240-0257)„		(used by TIMER.COM v1.2 which is the 'standard' timer program)„„0340	r/w	0.01 seconds  0-99„0341	r/w	0.1 seconds   0-99„0342	r/w	seconds	      0-59„0343	r/w	minutes	      0-59„0343	r/w	hours	      0-23„0345	r/w	day of week   1-7„0346	r/w	day of month  1-31„0347	r/w	month	      1-12„0348„0349	r/w	year	      0-99„034A„034B„034C„034D„034E„034F„0350	r	status?„0351	„0352„0353„0354	r	status?„0355„0356„0357„„-------------------------------------------------------------------------------„0348-0357 ----	DCA 3278„„-------------------------------------------------------------------------------„0360-036F ----	PC network (AT)„0360-0367 ----	PC network (XT only)„„-------------------------------------------------------------------------------„0370-0377 ----	FDC 2  (2nd Floppy Disk Controller 8272)  same as 03F0„„0372	w	diskette controller DOR (Digital Output Register)„0374	r	diskette controller status register„0375	r/w	diskette controller data register„0376	r/w	FIXED disk controller data register„0377	r	diskette controller DIR (Digital Input Register)„0377	w	select register for diskette data transfer rate„„-------------------------------------------------------------------------------„0378-037A ----	parallel printer port, same as 0278 and 03BC„„0378	w	data port„0379	r/w	status port„037A	r/w	control port„„-------------------------------------------------------------------------------„0380-038F ----	2nd Binary Synchronous Data Link Control adapter (see 03A0)„„0380	r/w	 on board 8255 port A, internal/external sense„0381	r/w	 on board 8255 port B, external modem interface„0382	r/w	 on board 8255 port C, internal control and gating„0383	r/w	 on board 8255 mode register„0384	r/w	 on board 8253 channel square wave generator„0385	r/w	 on board 8253 channel 1 inactivity time-out„0386	r/w	 on board 8253 channel 2 inactivity time-out„0387	r/w	 on board 8253 mode register„0388	r/w	 on board 8273 read: status  write: command„0389	r/w	 on board 8273 read: response  write: parameter„038A	r/w	 on board 8273 transmit interrupt status„038B	r/w	 on board 8273 receiver interrupt status„038C	r/w	 on board 8273 data„„-------------------------------------------------------------------------------„0388-0389 ---- Soundblaster PRO FM-Chip„0388-038B ---- Soundblaster 16 ASP FM-Chip„„-------------------------------------------------------------------------------„0390-039F ----	Cluster adapter (AT)„„0390-0393	(adapter 0)	(XT)„„-------------------------------------------------------------------------------„03A0-03AF ----	1st SDLC (Binary Synchronous Data Link Control adapter)„„0380	r/w	 on board 8255 port A, internal/external sense„0381	r/w	 on board 8255 port B, external modem interface„0382	r/w	 on board 8255 port C, internal control and gating„0383	r/w	 on board 8255 mode register„0384	r/w	 on board 8253 counter 0 unused„0385	r/w	 on board 8253 channel 1 inactivity time-out„0386	r/w	 on board 8253 channel 2 inactivity time-out„0387	r/w	 on board 8253 mode register„0388	r/w	 on board 8251 data„0389	r/w	 on board 8251 command/mode/status register„„-------------------------------------------------------------------------------„03B0-03BF ----	MDA  (Monochrome Display Adapter based on 6845)„„03B0		same as 03B4„03B1		same as 03B5„03B2		same as 03B4„03B3		same as 03B5„03B4	w	MDA CRT index register	 (EGA/VGA)„		selects which register (0-11h) is to be accessed through 3B5„03B5	r/w	MDA CRT data register	 (EGA/VGA)„		selected by port 3B4. registers C-F may be read„		 00  horizontal total„		 01  horizontal displayed„		 02  horizontal sync position„		 03  horizontal sync pulse width„		 04  vertical total„		 05  vertical displayed„		 06  vertical sync position„		 07  vertical sunc pulse width„		 08  interlace mode„		 09  maximum scan lines„		 0A  cursor start„		 0B  cursor end„		 0C  start address high„		 0D  start address low„		 0E  cursor location high„		 0F  cursor location low„		 10  light pen high„		 11  light pen low„03B6		same as 03B4„03B7		same as 03B5„03B8	r/w	MDA mode control register„		 bit 7 not used„		 bit 6 not used„		 bit 5 enable blink„		 bit 4 not used„		 bit 3 video enable„		 bit 2 not used„		 bit 1 not used„		 bit 0 high resolution mode„„03B9		reserved for color select register on color adapter„„03BA	r	CRT status register	 EGA/VGA: input status 1 register„		 bit 7-4 reserved„		 bit 3	 black/white video„		 bit 2-1 reserved„		 bit 0	 horizontal drive„„		 bit 7	 (MSD says) if this bit changes within 8000h reads then„		  bit 6-4 = 000 = adapter is Hercules or compatible„			    001 = adapter is Hercules+„			    101 = adapter is Hercules InColor„				  else: adapter is unknown„„03BA	w	EGA/VGA feature control register„„03BB		reserved for light pen strobe reset„„-------------------------------------------------------------------------------„03BC-03BF ----	parallel printer port, same as 0278 and 0378„„03BC	w	data port„03BD	r/w	status port„		 bit 7 = 0  busy„		 bit 6 = 0  acknowledge„		 bit 5 = 1  out of paper„		 bit 4 = 1  printer is selected„		 bit 3 = 0  error„		 bit 2 = 0  IRQ has occurred„		 bit 1-0    reserved„„03BE	r/w	control port„		 bit 7-5    reserved„		 bit 4 = 1  enable IRQ„		 bit 3 = 1  select printer„		 bit 2 = 0  initialize printer„		 bit 1 = 1  automatic line feed„		 bit 0 = 1  strobe„„-------------------------------------------------------------------------------„03BF	r/w	Hercules configuration switch register„		 bit 7-2„		 bit 1 = 0  disables upper 32K of graphics mode buffer„			 1  enables upper 32K of graphics mode buffer„		 bit 0 = 0  prevents graphics mode„			 1  allows graphics mode„„-------------------------------------------------------------------------------„03C0-03CF ----	EGA  (1st Enhanced Graphics Adapter)	alternate at 02C0„„03C0	(r)/w	EGA VGA ATC index/data register„03C1	r	VGA	other attribute register„03C2	r	EGA VGA input status 0 register„	w	VGA	miscellaneous output register„03C3	r/w	VGA	video subsystem enable„03C4	w	EGA	TS index register„	r/w	VGA	sequencer index register„03C5	w	EGA	TS data register„	r/w	VGA	other sequencer register„03C6	r/w	VGA	PEL mask register„03C7	r/w	VGA	PEL address read mode„	r	VGA	DAC state register„03C8	r/w	VGA	PEL address write mode„03C9	r/w	VGA	PEL data register„03CA	w	EGA	graphics 2 position register„	r	VGA	feature control register„03CC	w	EGA	graphics 1 position register„	r	VGA	miscellaneous output register„03CE	w	EGA	GDC index register„	r/w	VGA	graphics address register„03CF	w	EGA	GDC data register„	r/w	VGA	other graphics register„„-------------------------------------------------------------------------------„03D0-03DF ----	CGA   (Color Graphics Adapter)„„03D0		same as 03D4„03D1		same as 03D5„03D2		same as 03D4„03D3		same as 03D5„03D4	w	CRT (6845) index register   (EGA/VGA)„		selects which register (0-11h) is to be accessed through 3B5„03D5	w	CRT (6845) data register    (EGA/VGA)„		selected by port 3B4. registers C-F may be read„		 (for registers see at 3B5)„03D6		same as 03D4„03D7		same as 03D5„03D8	r/w	CGA mode control register  (except PCjr)„		 bit 7-6      not used„		 bit 5	 = 1  blink enabled„		 bit 4	 = 1  640*200 graphics mode„		 bit 3	 = 1  video enabled„		 bit 2	 = 1  monochrome signal„		 bit 1	 = 0  text mode„			 = 1  320*200 graphics mode„		 bit 0	 = 0  40*25 text mode„			 = 1  80*25 text mode„„03D9	r/w	CGA palette register„		 bit 7-6      not used„		 bit 5	 = 0 active color set: red, green brown„			 = 1 active color set: cyan, magenta, white„		 bit 4	     intense colors in graphics, background colors text„		 bit 3	     intense border in 40*25, intense background in„			     320*200, intense foreground in 640*200„		 bit 2	     red border in 40*25, red background in 320*200,„			     red foreground in 640*200„		 bit 1	     green border in 40*25, green background in„			     320*200, green foreground in 640*200„		 bit 0	     blue border in 40*25, blue background in 320*200,„			     blue foreground in 640*200„„03DA	r	CGA status register	EGA/VGA: input status 1 register„		 bit 7-4     not used„		 bit 3 = 1   in vertical retrace„		 bit 2 = 1   light pen switch is off„		 bit 1 = 1   positive edge from light pen has set trigger„		 bit 0 = 0   do not use memory„		       = 1   memory access without interfering with display„„03DA	w	EGA/VGA feature control register„„03DB	w	clear light pen latch„03DC	r/w	preset licht pen latch„„03DF		CRT/CPU page register  PCjr only„„-------------------------------------------------------------------------------„03E8-03EF ----	serial port, same as 02E8, 02F8, and 03F8„„-------------------------------------------------------------------------------„03F0-03F7 ----	FDC 1  (1st Floppy Disk Controller 8272)  same as 0370„„03F0		diskette controller status A (PS/2)„		 bit 7	 interrupt pending„		 bit 6	 second drive installed„		 bit 5	 step„		 bit 4	 track 0„		 bit 3	 head 1 select„		 bit 2	 index„		 bit 1	 write protect„		 bit 0	 direction„„03F1	r	diskette controller status B (PS/2)„		 bit 7-6  reserved„		 bit 5	  drive select (0=A:, 1=B:)„		 bit 4	  write data„		 bit 3	  read data„		 bit 2	  write enable„		 bit 1	  motor enable 1„		 bit 0	  motor enable 0„„03F2	w	diskette controller DOR (Digital Output Register)„		 bit 7-6    reserved PS/2„		 bit 7 = 1  drive 3 motor enable„		 bit 6 = 1  drive 2 motor enable„		 bit 5 = 1  drive 1 motor enable„		 bit 4 = 1  drive 0 motor enable„		 bit 3 = 1  diskette DMA enable (reserved PS/2)„		 bit 2 = 1  FDC enable	(controller reset)„		       = 0  hold FDC at reset„		 bit 1-0    drive select (0=A 1=B ..)„„03F4	r	diskette controller status register„		 bit 7 = 1  data register is ready„		 bit 6 = 1  transfer is from controller to system„			 0  transfer is from system to controller„		 bit 5 = 1  non-DMA mode„		 bit 4 = 1  diskette controller busy„		 bit 3 = 1  drive 3 busy (reserved on PS/2)„		 bit 2 = 1  drive 2 busy (reserved on PS/2)„		 bit 1 = 1  drive 1 busy„		 bit 0 = 1  drive 0 busy„„03F5	r	diskette command status register 0„		 bit 7-6      last command status„			 = 00  command terminated successfully„			 = 01  command terminated abnormally„			 = 10  invalid command„			 = 11  terminated abnormally by change in ready signal„		 bit 5	 = 1   seek completed„		 bit 4	 = 1  equipment check occurred after error„		 bit 3	 = 1  not ready„		 bit 2	 = 1  head number at interrupt„		 bit 1-0 = 1  unit select (0=A 1=B .. )„			      (on PS/2	01=A  10=B)„„		status register 1„		 bit 7	    end of cylinder; sector# greater then sectors/track„		 bit 6 = 0„		 bit 5 = 1  CRC error in ID or data field„		 bit 4 = 1  overrun„		 bit 3 = 0„		 bit 2 = 1  sector ID not found„		 bit 1 = 1  write protect detected during write„		 bit 0 = 1  ID address mark not found„„		status register 2„		 bit 7 = 0„		 bit 6 = 1  deleted Data Eddress Mark detected„		 bit 5 = 1  CRC error in data„		 bit 4 = 1  wrong cylinder detected„		 bit 3 = 1  scan command equal condition satisfied„		 bit 2 = 1  scan command failed, sector not found„		 bit 1 = 1  bad cylinder, ID not found„		 bit 0 = 1  missing Data Address Mark „„		status register 3„		 bit 7	    fault status signal„		 bit 6	    write protect status„		 bit 5	    ready status„		 bit 4	    track zero status„		 bit 3	    two sided status signal„		 bit 2	    side select (head select)„		 bit 1-0    unit select (0=A 1=B .. )„„03F6	r/w	FIXED disk controller data register„		 bit 7-4    reserved„		 bit 3 = 0  reduce write current„			 1  head select 3 enable„		 bit 2 = 1  disk reset enable„			 0  disk reset disable„		 bit 1 = 0  disk initialization enable„			 1  disk initialization disable„		 bit 0	    reserved„„03F7	r	diskette controller DIR (Digital Input Register)„		 bit 7 = 1 diskette change„„		 bit 6	   FIXED DISK write gate„		 bit 5	   FIXED DISK head select 3 / reduced write current„		 bit 4	   FIXED DISK head select 2„		 bit 3	   FIXED DISK head select 1„		 bit 2	   FIXED DISK head select 0„		 bit 1	   FIXED DISK drive 1 select„		 bit 0	   FIXED DISK drive 0 select   conflicts with:„„		 bit 0	   diskette high density select„„03F7	w	select register for diskette data transfer rate„		 bit 7-2       reserved„		 bit 1-0 = 00  500 Kb/S mode„			 = 01  300 Kb/S mode„			 = 10  250 Kb/S mode„			 = 11  reserved„„-------------------------------------------------------------------------------„03F8-03FF ----	serial port (8250,8251,16450,16550), same as 02E8,02F8,and 03F8„„03F8	w	serial port, transmitter holding register, which contains the„		character to be sent. Bit 0 is sent first.„		 bit 7-0   data bits when DLAB=0 (Divisor Latch Access Bit)„	r	receiver buffer register, which contains the received character„		Bit 0 is received first„		 bit 7-0   data bits when DLAB=0 (Divisor Latch Access Bit)„	r/w	divisor latch low byte when DLAB=1„„03F9	r/w	divisor latch high byte when DLAB=1„	r/w	interrupt enable register when DLAB=0„		 bits 7-4   reserved„		 bit 3 = 1  modem-status interrupt enable„		 bit 2 = 1  receiver-line-status interrupt enable„		 bit 1 = 1  transmitter-holding-register empty interrupt enable„		 bit 0 = 1  received-data-avail.int. enable (and 16550 timeout)„„	      - 16550 will interrupt if data exists in the FIFO and isn't read„		within the time it takes to receive four bytes or if no data is„		received within the time it takes to receive four bytes„„03FA	r	interrupt identification register. Information about a pending„		interrupt is stored here. When the ID register is addressed,„		the highest priority interrupt is held, and no other interrupts„		are acknowledged until the CPU services that interrupt.„		 bit 7-6 = 00  reserved on 8250, 8251, 16450„			 = 11  if FIFO queues are enabled (16550 only)„		 bit 5-4 = 0 reserved„		 bit 3	 = 0 reserved  8250, 16450„			 = 1 16550  timeout int. pending„		 bit 2-1 identify pending interrupt with the highest priority„		  = 11	receiver line status interrupt. priority=highest„		  = 10	received data available register interrupt. pr.=second„		  = 01	transmitter holding register empty interrupt. pr.=third„		  = 00	modem status interrupt. priority=fourth„		 bit 0 = 0  interrupt pending. contents of register can be used„			    as a pointer to the appropriate int.service routine„			 1  no interrupt pending„„	      - interrupt pending flag uses reverse logic, 0=pending, 1=none„	      - interrupt will occur if any of the line status bits are set„	      - THRE bit is set when THRE register is emptied into the TSR„„„03FA	w	16650 FCR  (FIFO Control Register)„		 bit 7-6 = 00  1 byte„			 = 01  4 bytes„			 = 10  8 bytes„			 = 11 14 bytes„		 bit 5-4 = 00 reserved„		 bit 3	 = 1  change RXRDY  TXRDY pins from mode 0 to mode 1„		 bit 2	 = 1  clear XMIT FIFO„		 bit 1	 = 1  clear RCVR FIFO„		 bit 0	 = 1  enable clear XMIT and RCVR FIFO queues„„	      - bit 0 must be set in order to write to other FCR bits„	      - bit 1 when set	the RCVR FIFO is cleared and this bit is reset„		 the receiver shift register is not cleared„	      - bit 2 when set	the XMIT FIFO is cleared and this bit is reset„		 the transmit shift register is not cleared„„03FB	r/w	line control register„		 bit 7 = 1  divisor latch access bit (DLAB)„			 0  receiver buffer, transmitter holding, or interrupt„			    enable register access„		 bit 6 = 1  set break enable. serial ouput is forced to spacing„			    state and remains there.„		 bit 5 =    stick parity„		 bit 4 = 1  even parity select„		 bit 3 =    parity enable„			 1  even number of ones are sent and checked in the „			    data word bits and parity bit„			 0  odd number of ones are sent and checked„		 bit 2 = 0  one stop bit„			 1  zero stop bit„		 bit 1-0 00 word length is 5 bits„			 01 word length is 6 bits„			 10 word length is 7 bits„			 11 word length is 8 bits„„03FC	r/w	modem control register„		 bit 7-5 = 0  reserved„		 bit 4 = 1  loopback mode for diagnostic testing of serial port„			    output of transmitter shift register is looped back„			    to receiver shift register input. In this mode„			    transmitted data is received immediately so that„			    the CPU can verify the transmit data/receive data„			    serial port paths.„		 bit 3 = 1  auxiliary user-designated output 2„		 bit 2 = 1  auxiliary user-designated output 1„		 bit 1 = 1  force request-to-send active„		 bit 0 = 1  force data-terminal-ready active„„03FD	r	line status register„		 bit 7 = 0  reserved„		 bit 6 = 1  transmitter shift and holding registers empty„		 bit 5 = 1  transmitter holding register empty. Controller is„			    ready toaccept a new character to send.„		 bit 4 = 1  break interrupt. the received data input is held in„			    in the zero bit state longer than the time of start„			    bit + data bits + parity bit + stop bits.„		 bit 3 = 1  framing error. the stop bit that follows the last„			    parity or data bit is a zero bit.„		 bit 2 = 1  parity error. Character has wrong parity„		 bit 1 = 1  overrun error. a character was sent to the receiver„			    buffer before the previous character in the buffer„			    could be read. This destroys the previous„			    character.„		 bit 0 = 1  data ready. a complete incoming character has been„			    received and sent to the receiver buffer register.„„03FE	r	modem status register„		 bit 7 = 1  data carrier detect„		 bit 6 = 1  ring indicator„		 bit 5 = 1  data set ready„		 bit 4 = 1  clear to send„		 bit 3 = 1  delta data carrier detect„		 bit 2 = 1  trailing edge ring indicator„		 bit 1 = 1  delta data set ready„		 bit 0 = 1  delta clear to send„„	      - bits 0-3 are reset when the CPU reads the MSR„	      - bit 4 is the Modem Control Register RTS during loopback test„	      - bit 5 is the Modem Control Register DTR during loopback test„	      - bit 6 is the Modem Control Register OUT1 during loopback test„	      - bit 7 is the Modem Control Register OUT2 during loopback test„„03FF	r/w	scratch register„„-------------------------------------------------------------------------------„„		Adresses above 03FF apply to EISA machines only !„„			 1000-1FFF	slot 1 EISA„			 2000-2FFF	slot 2 EISA„			 3000-3FFF	slot 3 EISA„			 4000-4FFF	slot 4 EISA„			 5000-5FFF	slot 5 EISA„			 6000-6FFF	slot 6 EISA„			 7000-7FFF	slot 7 EISA„„-------------------------------------------------------------------------------„0401-04D6 ----	used by EISA systems only„„0401	r/w	DMA channel 0 word count byte 2 (high)„0403	r/w	DMA channel 1 word count byte 2 (high)„0405	r/w	DMA channel 2 word count byte 2 (high)„0407	r/w	DMA channel 3 word count byte 2 (high)„„040A	w	extended DMA chaining mode register, channels 0-3„		 bit 7-5      reserved„		 bit 4	 = 0  generates IRQ13„			 = 1  generates terminal count„		 bit 3	 = 0  do not start chaining„			 = 1  programming complete„		 bit 2	 = 0  disable buffer chaining mode (default)„			 = 1  enable buffer chaining mode„		 bit 1-0      DMA channel select„„040A	r	channel interrupt (IRQ13) status register„		 bit 7-5  interrupt on channels 7-5„		 bit 4	  reserved„		 bit 3-0  interrupt on channels 3-0„„040B	w	DMA extended mode register for channels 3-0.„		bit settings same as 04D6„		 bit 7	 = 0  enable stop register„		 bit 6	 = 0  terminal count is an output for this channel„(default)„		 bit 5-4      DMA cycle timing„			 = 00 ISA-compatible (default)„			 = 01 type A timing mode„			 = 10 type B timing mode„			 = 11 burst DMA mode„		 bit 3-2      Address mode„			 = 00 8-bit I/O, count by bytes (default)„			 = 01 16-bit I/O, count by words, address shifted„			 = 10 32-bit I/O, count by bytes„			 = 11 16-bit I/O, count by bytes„		 bit 1-0      DMA channel select„„-------------------------------------------------------------------------------„0461	r/w	Extended NMI status/control register„		 bit 7 = 1  NMI pending from fail-safe timer (read only)„		 bit 6 = 1  NMI pending from bus timeout NMI status (read„only)„		 bit 5 = 1  NMI pending (read only)„		 bit 4	    reserved„		 bit 3 = 1  bus timeout NMI enable (read/write)„		 bit 2 = 1  fail-safe NMI enable (read/write)„		 bit 1 = 1  NMI I/O port enable (read/write)„		 bit 0	    RSTDRV. bus reset (read/write)„		       = 0  normal bus reset operation„		       = 1  reset bus asserted„„0462	w	Software NMI register. writing to this register causes an NMI„		if NMI's are enabled„		 bit 7 = 1  generates an NMI„„0464	r	bus master status latch register (slots 1-8). identifies the„		last bus master that had control of the bus„		 bit 7 = 0  slot 8 had control last„		 bit 6 = 0  slot 7 had control last„		 bit 5 = 0  slot 6 had control last„		 bit 4 = 0  slot 5 had control last„		 bit 3 = 0  slot 4 had control last„		 bit 2 = 0  slot 3 had control last„		 bit 1 = 0  slot 2 had control last„		 bit 0 = 0  slot 1 had control last„„0465	r	bus master status latch register (slots 9-16)„		 bit 7 = 0  slot 16 had control last„		 bit 6 = 0  slot 15 had control last„		 bit 5 = 0  slot 14 had control last„		 bit 4 = 0  slot 13 had control last„		 bit 3 = 0  slot 12 had control last„		 bit 2 = 0  slot 11 had control last„		 bit 1 = 0  slot 10 had control last„		 bit 0 = 0  slot 9  had control last„„-------------------------------------------------------------------------------„0481	r/w	DMA channel 2 address byte 3 (high)„0482	r/w	DMA channel 3 address byte 3 (high)„0483	r/w	DMA channel 1 address byte 3 (high)„0487	r/w	DMA channel 0 address byte 3 (high)„0489	r/w	DMA channel 6 address byte 3 (high)„048A	r/w	DMA channel 7 address byte 3 (high)„048B	r/w	DMA channel 5 address byte 3 (high)„„04C6	r/w	DMA channel 5 word count byte 2 (high)„04CA	r/w	DMA channel 6 word count byte 2 (high)„04CE	r/w	DMA channel 7 word count byte 2 (high)„„-------------------------------------------------------------------------------„04D0	w	IRQ 0-7 interrupt edge/level registers„		 bit 7 = 1  IRQ 7 is level sensitive„		 bit 6 = 1  IRQ 6 is level sensitive„		 bit 5 = 1  IRQ 5 is level sensitive„		 bit 4 = 1  IRQ 4 is level sensitive„		 bit 3 = 1  IRQ 3 is level sensitive„		 bit 2-0    reserved„„04D1	w	IRQ 8-15 interrupt edge/level registers„		 bit 7 = 1  IRQ 15 is level sensitive„		 bit 6 = 1  IRQ 14 is level sensitive„		 bit 5 = 1  reserved„		 bit 4 = 1  IRQ 12 is level sensitive„		 bit 3 = 1  IRQ 11 is level sensitive„		 bit 2 = 1  IRQ 10 is level sensitive„		 bit 1 = 1  IRQ 9  is level sensitive„		 bit 0	    reserved„„04D4	w	extended DMA chaining mode register, channels 4-7„		 bit 7-5 = 0  reserved„		 bit 4	 = 0  generates IRQ 13„			 = 1  generates terminal count„		 bit 3	 = 0  do not start chaining„			 = 1  programming complete„		 bit 2	 = 0  disable buffer chaining mode (default)„			 = 1  enable buffer chaining mode„		 bit 1-0      DMA channel select„„04D6	w	DMA extended mode register for channels 4-7„		bit settings same as 04B„		 bit 7	 = 0  enable stop register„		 bit 6	 = 0  terminal count is an output for this channel„(default)„		 bit 5-4      DMA cycle timing„			 = 00 ISA-compatible (default)„			 = 01 type A timing mode„			 = 10 type B timing mode„			 = 11 burst DMA mode„		 bit 3-2      Address mode„			 = 00 8-bit I/O, count by bytes (default)„			 = 01 16-bit I/O, count by words, address shifted„			 = 10 32-bit I/O, count by bytes„			 = 11 16-bit I/O, count by bytes„		 bit 1-0      DMA channel select„„-------------------------------------------------------------------------------„0601	w	System control. Laptop chipset: Headland HL21 & Acer M5105„		 bit 7 = 1  power led on„		 bit 6 = 1  LCD backlight off„		 bit 5„		 bit 4„		 bit 3„		 bit 2 = 1  video chips disabled, screen blanked.„		 bit 1„		 bit 0 = 1  will lock up your machine!„„	r	 =04	    (always reads back this value)„„-------------------------------------------------------------------------------„0620-0627 ----	PC network (adapter 1)„0628-062F ----	PC network (adapter 2)„„-------------------------------------------------------------------------------„06E2-06E3 ----	data aquisition (adapter 1)„„-------------------------------------------------------------------------------„0790-0793 ----	cluster (adapter 1)„„-------------------------------------------------------------------------------„0800-08FF ----	I/O port access registers for extended CMOS RAM or SRAM„		(256 bytes at a time)„		Sometimes plain text can be seen here.„„-------------------------------------------------------------------------------„0A20-0A23 ----	Token Ring (adapter 1)„0A24-0A27 ----	Token Ring (adapter 2)„„-------------------------------------------------------------------------------„0AE2-0AE3 ----	cluster (adapter 2)„0B90-0B93 ----	cluster (adapter 2)„„-------------------------------------------------------------------------------„0C00	r/w	page register to write to SRAM or I/O„„-------------------------------------------------------------------------------„0C80-0C83 ----	system board ID registers„„-------------------------------------------------------------------------------„1390-1393 ----	cluster (adapter 3)„„-------------------------------------------------------------------------------„2100-210F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„2110-211F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„2120-212F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„2130-213F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„2140-214F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„2150-215F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„2160-216F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„2170-217F ----	IBM XGA (eXtended Graphics Adapter  8514/A)„„-------------------------------------------------------------------------------„2390-2393 ----	cluster (adapter 4)„„-------------------------------------------------------------------------------„3220-3227 ----	serial port 3, description same as 03F8„3228-322F ----	serial port 4, description same as 03F8„„-------------------------------------------------------------------------------„3540-354F ----	IBM SCSI (Small Computer System Interface) adapter„3550-355F ----	IBM SCSI (Small Computer System Interface) adapter„3560-356F ----	IBM SCSI (Small Computer System Interface) adapter„3570-357F ----	IBM SCSI (Small Computer System Interface) adapter„„-------------------------------------------------------------------------------„4220-4227 ----	serial port, description same as 03F8„4228-422F ----	serial port, description same as 03F8„„-------------------------------------------------------------------------------„42E0-42EF ----	GPIB (General Purpose Interface Bus, IEEE 488 interface)„„42E1	r/w	GPIB (adapter 2)„„-------------------------------------------------------------------------------„5220-5227 ----	serial port, description same as 03F8„5228-522F ----	serial port, description same as 03F8„„-------------------------------------------------------------------------------„62E0-62EF ----	GPIB (General Purpose Interface Bus, IEEE 488 interface)„„62E1	r/w	GPIB (adapter 3)„„-------------------------------------------------------------------------------„82E0-82EF ----	GPIB (General Purpose Interface Bus, IEEE 488 interface)„„82E1	r/w	GPIB (adapter 4)„„-------------------------------------------------------------------------------„82F8-82FF ----	serial port, description same as 03F8„83F8-83FF ----	serial port, description same as 03F8„„-------------------------------------------------------------------------------„A220	  ????	soundblaster support in AMI Hi-Flex BIOS  ????„„-------------------------------------------------------------------------------„A2E0-A2EF ----	GPIB (General Purpose Interface Bus, IEEE 488 interface)„„A2E1	r/w	GPIB (adapter 5)„„-------------------------------------------------------------------------------„AFFF	r/w	plane 0-3 system latch (video register)„„-------------------------------------------------------------------------------„B220-B227 ----	serial port, description same as 03F8„B228-B22F ----	serial port, description same as 03F8„„-------------------------------------------------------------------------------„C220-C227 ----	serial port, description same as 03F8„C228-C22F ----	serial port, description same as 03F8„„-------------------------------------------------------------------------------„D220-D227 ----	serial port, description same as 03F8„D228-D22F ----	serial port, description same as 03F8„„-------------------------------------------------------------------------------„C2E0-C2EF ----	GPIB (General Purpose Interface Bus, IEEE 488 interface)„„C2E1	r/w	GPIB (adapter 6)„„-------------------------------------------------------------------------------„E2E0-E2EF ----	GPIB (General Purpose Interface Bus, IEEE 488 interface)„„E2E1	r/w	GPIB (adapter 7)„„„-------------------------------------------------------------------------------„„MEMORY-MAPPED ADDRESSES„„-------------------------------------------------------------------------------„80C00000  Compaq Deskpro 386 system memory board register„„80C00000 w	RAM relocation register„		bit 7-2	   Reserved, always write 1's.„		bit 1 = 0  Write-protect 128-Kbyte RAM at FE0000.„		      = 1  Do not write-protect RAM at FE0000.„		bit 0 = 0  Relocate 128-Kbyte block at FE0000 to address 0E0000„		      = 1  128-Kbyte RAM is addressed only at FE0000.„„80C00000 r	Diagnostics register„		bit 7	= 0  memory expansion board is installed„		bit 6	= 0  second 1 MB of system memory board is installed„		bit 5-4 = 00 base memory set to 640 KB„			  01 invalid„			  10 base memory set to 512 KB„			  11 base memory set to 256 KB„		bit 3	= 0  parity error in byte 3„		bit 2	= 0  parity error in byte 2„		bit 1	= 0  parity error in byte 1„		bit 0	= 0  parity error in byte 0 (in 32-bit double word)„„-------------------------------------------------------------------------------„Earl L. Montgomery             HEXADECIMAL AND BINARY NOTATIONQBTIPS_J.DOC                   03-27-93 (19:40)       Text                   109  3584     HEX-BIN.DOC While refreshing my memory on Hexadecimal and Binary notations„(and the use of the logical operators <AND> <OR>, I found that„it helped to take notes. This is a compilation of those notes.„Some phrasing is entirely my own. So if you find any mistakes„(other than grammar, sentence structure, or spelling! <smile>)„please inform me so I can correct my document file. This„document should prove useful to the new programmers.„ „                     A little info on Hexadecimal notation.„ „Hexadecimal is a numbering system based on 16 elements.„Digits are numbered 0 through F as follows:„ „0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F„ „Representing the digits 0 through 15.„ „Hexadecimal system uses powers of 16. For example:„&H19 (hexadecimal) represents 25 decimal. Let's see why.„Starting from the right the power is 1. Therefore 9 X 1 = 9„Moving left the next is power is 16. Therefore 1 X 16 = 16„And 9 + 16 = 25.„ „Let's try another. This time &HFF (hexadecimal)„Again starting from the right (F=15) 15 X 1= 15„Moving left 15 X 16 = 240.„And 240 + 15 = 255„ „So far we have looked at single byte hex values. Let's look at„a 16 bit hex value. Remember 8 bits to the byte? Now we look at„two adjoining bytes, or sixteen bits.„ „&H1902 (hexadecimal) represents 6402 decimal.„ „Again starting from the right 2 X 1= 2„Moving left 0 X 16 = 0„Moving left again <16 X 16 =256> 9 X 256 = 2304„Moving left again <16 X 256 = 4096> 1 X 4096 = 4096„And 2 + 0 + 2304 + 4096 = 6402„ „In basic hex values are preceeded by &H. For example &HFF or &H1902„In basic hex values can be determined by the command PRINT &HFF„or PRINT &H1902.„ „Decimal to hex is accomplished by PRINT HEX$(255)„or PRINT HEX$(1902).„ „Now let's look at the individual bits within a byte.„ „Remember there are 8 bits to the byte and reading from Right„to Left they increase in power by the power of 2.„ „Binary notation reflects set bits with a 1. Non set bits with a 0.„Let's look at one.„ „1 0 0 0 1 0 0 1 (This byte represents 137)„As with hex we start at the right.„ „1 X 1= 1„Moving left 2 X 0 = 0„Moving left again 4 X 0 = 0„Moving left again 8 X 1 = 8„Moving left again 16 X 0 = 0„Moving left again 32 X 0 = 0„Moving left again 64 X 0 = 0„Moving left again 128 X 1 = 128„ „And 1 + 0 + 0 + 8 + 0 + 0 + 0 + 128 = 137„ „                     Logical Operators <AND> <OR>„ „When you AND two numbers the results are in a new third number.„For example:„a = 137„b = 105„c = a AND b„ „1 0 0 0 1 0 0 1  This represents A <137>„0 1 1 0 1 0 0 1  This represents B <105>„ „0 0 0 0 1 0 0 1  This represents C <9>„ „What occurs when you AND two numbers is that the computer compares„the bits within the first number against the bits in the second number.„If the bits are the same then they will remain the same in the third„number.„If they are not the same then the equivalent bits will be 0 in the„third number.„ „ „                               "Logical OR„ „What occurs when you OR two numbers is that the computer compares„the bits within the first number against the bits in the second number.„If the bits are the same they will remain the same in the third number.„If they are not the same then the bits will be 1 in the third number.„ „For example:„A=122„B=15„C=A OR B„ „0 1 1 1 1 0 1 0   This represents A <122>„0 0 0 0 1 1 1 1   This represents B <15>„ „0 1 1 1 1 1 1 1   This represents C <127>„ „This quick little reference document composed by Earl Montgomery„I hope it proves to be of some use to you.„John McTaggart                 QWK LAYOUT                     charlie@charlie.seanet.com     12-15-94 (23:57)       QB, QBasic, PDS        230  10308    QWKPCKT.BAS '>Say I have had no luck so far in tracking down <this person> to obtain the most„'>recent version of QWKLAYxx.zip.  Currently I have QWKLAY13.zip but the info„'>is about 2 years old.. can anyone provide me with BBS or Internet FTP site„'>location of a more updated file for the QWK layout?  Long distance is not a„'>factor, I will call anywhere for the information..  and BTW any SYSOPS out„'>there utilizing the QWKE format for their mail?„'„'   Here it is, pretty well broken down. I hacked this out a year ago„'   or more. I made a lttle utility to extract useless messages from„'   Messages.Dat files. It could use a couple of well placed functions„'   but will shread a 1 meg dat file surprisingly fast! I don't think„'   it's all here, but the main parts are. I also have the routines for„'   the Control.Dat file hanging around here collecting dust. If you„'   can make some improvements on this twisted little mess, I enjoy„'   seeing them. I hope this helps some.„'„  'Here are a couple of type structures and actual useful stuff that may„  'prompt some of you to write mail readers, and/or utilities...„„  'For the novice, this is an example of data driven programming where„  'the program will accomodate different files more or less on the„  'fly. The trick is to produce algorythms that will be reused on„  'files whose actual format is already known and doesn't change...„  'The examples are in pure Basic, but can be improved upon greatly„  'with some of the existing toolboxes that are on the market including„  'those from Crescent and MicroHelp...„„  'This is the actual Messages.Dat header type and consists of 128bytes„„   TYPE QWKheader„    Status AS STRING * 1          'Message Status„    MessageNum AS STRING * 7      'Actual message #„    MessageDate AS STRING * 8     'Message date„    MessageTime AS STRING * 5     'Message time„    MessageTo AS STRING * 25      'Who's it to„    MessageFrom AS STRING * 25    'Who's it from„    Subject AS STRING * 25        'What are we talking about„    Password AS STRING * 12       'Password, never actually seen it used„    Reference AS STRING * 8       'Convoluted way to reference a message„    NumBlocks AS STRING * 6       'How many 128byte blocks in message„    KillFlag AS STRING * 1        'Self explanatory„    Conference AS INTEGER         'Conference #„    NotUsed AS STRING * 2         '„    NetWorkTag AS STRING * 1      'Net tag flag„   END TYPE„    DIM QwkInfo AS QWKheader„„  'Each record in the Messages.Dat file is referenced by a record #„  'held in an NDX file. In other words an NDX file named 001.NDX will„  'hold record pointers to all the messages in conference #1. The format„  'used is in MKS$ format and in my opinion should be converted to long„  'integer in one file instead of scattered across multiple ones.„  'All the high level languages including C, Pascal, and Basic would„  'benefit from not having to convert these pointers back and forth. By„  'using one file it would save considerable hard drive space when„  'taking cluster size into consideration, and would save the program„  'from having to open several files to get the pointer information.„  'Simply put, it would be much faster...„„  'The NDX files type structure...„„   TYPE NDXInfo„    Pointer AS STRING * 4          'Record pointer„    Conf AS STRING * 1             'Conference #„   END TYPE„    DIM NDX AS NDXInfo„„   'Here are the neccesary conversions...„   'If retreiving them from an NDX file try this...„   'You're path will probably be different so adjust accordingly...„   'Try the biggest NDX file you can...„   '----------------------------------------------------------------------„   OPEN "C:\Temp\Work\006.NDX" FOR BINARY AS #1„   HowMany& = LOF(1) \ 5„   '--How many records are we getting?„   FOR X = 1 TO HowMany&„   '--Each NDX is 5 bytes long, and the NDX file is always divisable by 5„    GET #1, , NDX„   '--Get them to LOF(1) \ 5„    RecPtr = CVSMBF(NDX.Pointer)„   '--Convert them„    PRINT ASC(NDX.Conf); RecPtr;„   '--Print it to prove it worked, print conference and message pointer„   NEXT„   CLOSE„„   'These pointers actually point to the message in the messages.dat file„   'in order to find the location to seek to in Messages.Dat simply„   'multiply by 128...„„   'Notice we get them in 5 byte chunks, via the NDXInfo type struc...„   'As a note, notice that the conference in the QWKheader is in integer„   'format and the NDX struct uses a string. Hey, I didn't invent it!„   'Since the pointer is a MKS$ 4 byte string you need to use a string„   'length of 1 for the conference. If we used an integer it would be„   '6 bytes instead of 5...„   'If outputting to the NDX file you need to know the LOC of the record„   'and divide it by 128. Using binary IO works very nicely...„„   'Doing the first record outside the DO/LOOP allows you not to have„   'to worry about checking for the first record with IFs...„„   'Simply by adding another DO/LOOP to check for the actual conferences„   'in the Messages.Dat file first you can actually ignore the NDX files„   'altogether. The advantage to this approach would be mail doors that„   'allow the user to not include the NDX files in the actual QWK packet.„   'OLX is a good example of this. If the NDX files don't exist it will„   'rebuild them when you open the packet. The benefit is less time when„   'downloading and smaller QWK packets...„„   OPEN "Messages.Dat" FOR BINARY AS #1„   '--Open the messages file„   OPEN "NDX.NDX" FOR BINARY AS #2„   'Our new index file for whole thing, not each conference„   'This will build a single NDX file for the entire Messages.Dat„   'file. After trying it, it really made it simple...Why have 10„   'different file. Anyone know why this is? Am I missing something...„„     SEEK #1, 129„      '--Seek past the mail door header„     GET #1, , QwkInfo„      '--Get the record header„     W$ = MKSMBF$(2)„      '--Record #2 is always first record„     CON$ = CHR$(QwkInfo.Conference)„      '--Convert Integer to String„     PUT #2, , W$„     PUT #2, , CON$„      '--Put to NDX file„     SEEK #1, 129„      '--Seek back to beginning of messages, redundant but works...„„    DO„     GET #1, , QwkInfo„      '--Get the whole header with get, then pull out what we need„     Length& = VAL(QwkInfo.NumBlocks)„      '--This is the number of 128 byte blocks in the message„     CON$ = CHR$(QwkInfo.Conference)„      '--Convert the QwkInfo.Conference Integer„     IF Length& = 0 THEN EXIT DO„      '--If the Value of QwkInfo.NumBlocks is 0 then we're done.„      '--A message can't have a length of 0„     WhereAmI& = LOC(1)„      '--Store our current file offset for later„     OnTheFly& = Length& * 128 - 128„      '--This is the actual message length <minus> the header info„      '--If you want to display the message you would assign a„      '--string with OnTheFly& length...„      'Mess$ = SPACE$(OnTheFly&)„      'GET #1, , Mess$„      '--All the other info is still in QwkInfo„     SEEK #1, WhereAmI& + OnTheFly& + 1„      '--Chew our way through the file, incrementing as we go„     Where$ = MKSMBF$(LOC(1) \ 128 + 1)„      '--Convert our offset to the proper format for the NDX file„     PUT #2, , Where$„     PUT #2, , CON$„      '--Put them to a file„    LOOP WHILE NOT EOF(1)„      '--Loop until the whole files been read.„     CLOSE„„ '     You now will have a file named NDX.NDX that holds the conference„ '     number and record pointer for all the messages in the Messages.Dat„ '     file...„„ '  John, Here is some stuff to help handle the Control.Dat file...„ '  It's not terribly efficient, but it does work.„ „   'Since Control.Dat is basically a text file„   'the first thing we need to do is find the # of lines it has...„„   OPEN "C:\Temp\Work\Control.Dat" FOR INPUT AS #1 'Open Control.Dat„   LineCount% = 0                    'Set the linecounter to 0„„   DO                                'Start a loop„    LINE INPUT #1, Line$             'And line input each„    LineCount% = LineCount% + 1      'Add it to the counter„   LOOP UNTIL EOF(1)                 'Until the end of the file„„   'LineCount% should now hold our total # of lines in the„   'Control.Dat file. Knowing this information will allow us to„   'dimension an array to hold the info...„„   REDIM ControlDat$(1 TO LineCount%)„„   'Dimension a string array for that many lines.„   'Start at the beginning of the file„„   SEEK #1, 1                 'Start at beginning„„   FOR Y = 1 TO LineCount%    'Loop through the Control file and„    LINE INPUT #1, Ours$      'Input the lines, one at a time„    ControlDat$(Y) = Ours$    'Load our array with the contents of the file„   NEXT Y                     'We're done with the file so close it...„    CLOSE„„    'Now lets see if it worked!„„    CLS„    PRINT "Board Name.........."; ControlDat$(1)„    NumConferences = VAL(ControlDat$(11)) + 1„    PRINT "Total Conferences..."; LTRIM$(STR$(NumConferences))„„    'ControlDat$(11) is the total # of conferences - 1„    'If anybody knows why its not the actual # I'd be curious as to why„„     Steps = 10 + NumConferences * 2„„    'The above (Steps) is pretty important for finding the total„    'conferences and there proper numbers. Of course again its only„    'one way. There may be a better way but the above works. Print„    'the total conferences„„     FOR C = 12 TO Steps STEP 2„      PRINT ControlDat$(C + 1); " "; ControlDat$(C)„     NEXT„„    'Notice the print statement actually extracts the name first„    'and then the number from the array. Ideally you would„    'seperate the conferences and conference numbers and put them„    'in a scrollable picklist.„„    'I hope this might help someone. I found most of this by fiddling„    'around and looking at a couple of FAQs on QWK files. Some of„    'them didn't go into to much detail and some were just wrong.„    'if anybody happens to find some better methods that are in„    'pure Basic form, I'd love to see them. Of course some well„    'placed assembly goes along way with these routines, but for„    'this I took a purest approach. Thanks...„Don Schullian                  VARIOUS INKEY METHODS          comp.lang.basic.misc           05-11-96 (11:55)       Text                   231  9703     KEYS.BAS      Back in days of old, when Commodore's were bold and "no one needed„more than 640k" I was shown a simple idea that has remained with me„through several languages and countless version changes. As the„concept is so important I would like to share my experience with those„of you who wish to continue reading. As these ideas were "handed down"„to me from fellow programmers and/or from this news group I feel it„only right that I pass it back to others just BASICally getting„started.„„  On the Commodores and in GW-BASIC it looked something like this:„„100 G$ = INKEY$ : IF G$<>"" THEN RETURN ELSE GOTO 100„„One might ask; "if it's a one-liner then why not just type it in the„code each time you need it?" and that would be a valid question. On„the Commodore we had all of 32k for the program so we counted bytes„and bits. Things were a bit better on the super PCs of the time, we„had 64k but even 64k fills up real quick. GOSUB 100 was cheaper than„all that code. It is also easier to type, takes less text space, etc.„„  A couple years later my trusty old XT and I got QuickBASIC and„TurboBASIC (TB won out). One of the first functions I wrote was:„„FUNCTION GetKey$()„  LOCAL G$„„  DO : G$ = INKEY$ : LOOP UNTIL G$<> ""„  GetKey$ = G$„„END FUNCTION„„Not much had changed, just the "shape", did the same thing, wasn't„much smarter, but I slowly realized that NOW with all the other„goodies that the modern BASICs offered that GetKey$ was far superior„to the old GW version.„„GetKey$ stayed virtually unchanged for many years until a month ago„when version 1,342.02g was built, accepted, and integrated throughout„my libraries.„„FUNCTION fGetKey% ()„  LOCAL G$„„  DO„    G$ = INKEY$„  LOOP UNTIL LEN(G$) > 0„  G$ = G$ + CHR$(0)„  fGetKey% = CVI( G$ )„„END FUNCTION„„As you can see, still not much has changed but the 2 little changes do„make a world of difference. First of all LEN(G$) is faster and cheaper„than G$ = "" and passing/using INTEGERs instead of STRINGs is just„good business!„„Before you can fully understand fGetKey% there are few things you must„know:„„CVI (n$) converts the FIRST 2 BYTES of a string into an INTEGER„STR$(n%) converts an INTEGER into a STRING„CHR$(n%) converts the FIRST BYTE of an INTEGER into a STRING„INKEY$   returns 0, 1 or 2 byte strings only„„An INTEGER is stored LOWBYTE:HIBYTE in memory.„  eg: INTEGER = HIBYTE*256 + LOWBYTE„  <SPACE> = CHR$(32)         : CVI( CHR$(32)+CHR$(00) ) =    32„  <F10>   = CHR$(0)+CHR$(68) : CVI( CHR$(00)+CHR$(68) ) = 17408„„An EQUATE (name may change from BASIC to BASIC) is a number, in the„range of an INTEGER that can be assigned only ONCE in a program and is„like a command to the compiler to replace the "text" with the value„assigned to it. These little rascals are EXTREMELY useful and their„full use should be explored at your earliest convenience.„„  So, now that we've got everyone up to scratch, let's get back into„fGetKey%. Using fGetKey% makes many, many, seemingly difficult tasks„so easy it almost feels like cheating to use them (..NOT..). fGetKey%„creates one place in the program were you KNOW the user's key-presses„are going to be available. EVERY KEY-PRESS, think about that!!!„„ 1) Trap ANY key you want without generating thousands of bytes of„    extra code with ON KEY.„ 2) On-screen clocks can be run from here without creating a flock of„    extra code.„ 3) Instant Pop-up goodies no matter where the user is.„ 4) Automatic screen blanking after x seconds with no user input„ 5) Make keys "illegal" and disallow there use program wide.„ 6) Run the whole main menu with hot-keys trapped by fGetKey%„ 7) Run demos from stored key-presses & elapsed times.„ 8) Translate incoming key-presses into UCASE$, LCASE$, or even„    other languages.„ 9) and on, and on, and on, and on.......„„ So, how do you make this work for you? Well, let's get into that now.„First of all there are a group of key-presses that are pretty constant„in every program. Thinks like <ESC>, <ENTER>, <F1>, <F10>, <UP>,„<DOWN>, etc. so you'll want to create an include file of EQUATES and„keep it handy. I have translated all mine into HEX so the numbers are„all the same length and display a cleaner list but that's a personal„thing. Here are some of the more common ones:„„%HOME_key   = &h4700 : %UP_key     = &h4800 : %PGUP_key   = &h4900„%LEFT_key   = &h4B00 :                      : %RIGHT_key  = &h4D00„%END_key    = &h4F00 : %DOWN_key   = &h5000 : %PGDN_key   = &h5100„%ENTER_key  = &h000D : %CTRL_Enter = &h000A„%ESC_key    = &h001B : %F01_key    = &h3B00 : %F10_key    = &h4400„„These represent the values that fGetKey% will be returning when these„keys are pressed. They also make the task of writing a menu much„easier as you only have to remember the key name and, of course the„code is self explanatory. It all looks like this:„„DO„  G% = fGekKey%„  SELECT CASE G%„    CASE %HOME_key„    CASE %UP_key„    CASE %PGUP_key„    CASE %LEFT_key„    CASE %RIGHT_key„    CASE %END_key„    CASE %DOWN_key„    CASE %PGND_key„    CASE %ENTER_key„  END SELECT„LOOP UNTIL G% = %ESC_key„„_THAT_, my friends, is legible code. It also happens to be faster than„its cousin which uses STRINGs and CHR$(0)+CHR$(70). I'll grant that it„takes a bit of work to create your list of key-presses but it's worth„the one time effort, believe me!„„  Conversely, there are values that the keyboard can't produce, like„-1 CHR$(255)+CHR$(255), and these can be just as important as the„legal ones when sending signals to routines. Like %BailOut = -1. Think„about it!„„If you're going to do some key and/or time trapping your function is„going to have to get a bit bigger. So, let's play with this idea that„does just about everything:„„ON TIMER (60) GOSUB CLOCK   „„$EVENT ON    ' Turn on event trapping (it was off)„„FUNCTION fGetKey% ()„  LOCAL G%, G$, T!„„  TIMER ON„  DO „   T! = TIMER + 180  ' 3 minutes from now„    DO„      G$ = INKEY$„      IF TIMER > T! THEN„        CALL BlankScreen„        G% = 0„        EXIT LOOP„      END IF„    LOOP UNTIL LEN( G$ ) > 0„    G$ = G$ + CHR$(0)„    G% = CVI( G$ )„    SELECT CASE G%„      CASE %F01_key  : CALL PopHelp   ' trap F1 for help„      CASE %ALT_x    : GOTO ByeBye    ' trap <ALT>X to end program„      CASE 124       : G% = 0         ' trap "|" so it can't be used„      CASE 97 TO 122 : G% = G% - 32   ' English UCASE„    END SELECT„  LOOP UNTIL G% <> 0„„  TIMER STOP„  fGetKey% = G%„„END FUNCTION„„$EVENT OFF     ' no more event trapping needed!„„As I said, MOST everything is here. The on screen clock is running, a„3 minute screen blanker is in force, the pipe character has been„removed from the user, instant pop-up help is activated for the whole„program, an instant bail-out key is standing by, the English alphabet„will ALWAYS return the UCASEd version of the character, thousands of„bytes of code have been saved because we haven't used ON KEY, and ON„TIMER only affects a few lines of code. The best part is that if„anything needs changing or maybe something needs to be added like„%ALT_F1 for more help then it all happens in one place for the whole„program. You won't have to search every routine in every file, debug,„or worry that you missed one.„„  If you were observant then you noticed one other important aspect of„programming; consistency. The variable "G" has followed me for over a„decade now and has ALWAYS meant the same thing. "The incoming (gotten)„key." It has changed from G$ of old to the G% of today but it is still„a "G" and anyone who reads ANY of my code will soon become familiar„with its value. The "G", itself, isn't important ("K" works pretty„well too and I've even seen OTHER variables!) but the consistency IS„important.„„  Another trick showed up a few years back that made things easier„too. Notice that the name changed from GetKey to fGetKey? Well, back„in the old days the only functions we had were DEF fnGetKey type„things and "fn" is still a reserved word in most BASICs. When you used„a function that started with "fn" you could see at a glance what was„happening but today, with the more open format allowed one can not„tell a function from a variable: eg: G% = GetKey%. GetKey%, here,„could be a function or a variable so how do you tell?  Well, what a„couple of friends of mine and I came up with were a few simple rules„to alleviate the confusion. Here's my list of "rules".„„   MySub        - subs start with a capital letter„  fMyFunction   - functions start with a small "f"„  sSharedVar    - shared variables start with a small "s"„  pPublicVar    - public variables start with a small "p"„  cCommonVar    - common variables start with a small "c"„  tTYPEvar      - DIMed type variables start with a small "t"„   AllOtherVars - all other variables start with a capital letter„                  !!ALL variables are signed!!„„  Well, thanks for hanging in there! I hope this information helps„some of you. To those of you who feel like I've wasted your time„and/or band width I apologize but I've noticed that quite a few people„keep asking questions about ON KEY, INKEY$, etc. and I would think„this little idea will help those people quite a bit. Like I said at„the top, I've been helped by others known and unknown and, in the„spirit of things, feel like I can now repay those debts.„„  A parting shot here. I don't mind this tutorial being reproduced„EXCEPT where it is done for a profit. That is meant to include "how„to" books but exclude web pages and collections like ABC packets, etc.„„Any questions?„Ian Musgrave                   ASSEMBLY LANGUAGE INTO BASIC   comp.lang.basic.misc           04-17-96 (08:18)       Text                   88   3848     ASMINQB.TXT > Hi all,„>  I am looking for a QBasic routine (not QuickBasic, please) that will „>  let you use Assembly language code in QBasic programs.„>  I have seen these all over the place.  I even had a few, but I either „>  misplaced or deleted them.„„Well, there is no routine as such to convert ASM code to the assembly language „hex code QBASIC and QB4.x requires for CALL ABSOLUTE.  Mark K Kim's„assembly language in BASIC tutorial  at the following„FTP site, ftp://users.aol.com/markkkim/asm_tutorial/„gives good step by step instructions for using DEBUG to convert ASM code to „hex code. This won't work on MASM or TASM code though (but you should be able „to convert this to DEBUG acceptable code with only minor difficulties if you „know what you are doing).„„You can semi automate the system Mark mentions though. Here's a modification „of one of his examples, the code to turn the mouse on.„„Create a file called mouseon.dbg (or cut and paste the example below)„with the following DEBUG code (best read Marks examples first so this makes „sense„„;==========Mouseon.dbg, cut here„a„mov ax,0000    ;Copy 0000h to AX„int 33h        ;Interrupt 33h„cmp ax,0000    ;Compare, is AX=0000h„jz 010f        ;If equal, Jump to last statement„mov ax,0001    ;Else move 0001h to AX„int 33         ;Interrupt 33h„retf           ;Return„„u 100 10f      „q              „;=============cut here.„„now type „DEBUG < mouseon.dbg > mouseon.asm„„This will send the contents of the debug session to a file called mouseon.asm „which looks like this.„„;========mouseon.asm„-a„1289:0100 mov ax,0000    ;Copy 0000h to AX„1289:0103 int 33h        ;Interrupt 33h„1289:0105 cmp ax,0000    ;Compare, is AX=0000h„1289:0108 jz 010f        ;If equal, Jump to last statement„1289:010A mov ax,0002    ;Else move 0001h to AX„1289:010D int 33         ;Interrupt 33h„1289:010F retf           ;Return„1289:0110 „-u 100 10f      „1289:0100 B80000        MOV	AX,0000                            „1289:0103 CD33          INT	33                                 „1289:0105 3D0000        CMP	AX,0000                            „1289:0108 7405          JZ	010F                               „1289:010A B80100        MOV	AX,0001                            „1289:010D CD33          INT	33                                 „1289:010F CB            RETF	                                   „-q              „;===========end„„you want the lines between -u and -q, now you have to select the hex codes and „split them up (eg, ignore the 1289:0103, you just want CD33, which has to be „split up into CD and 33 and then converted into a string format CALL ABSOULTE „can use. So CD33 becomes CHR$(&HCD)+CHR$(&H33) (&H means hex)„„Thus you get„'==========================================================================„asm$ = ""„„asm$ = asm$ + CHR$(&HB8) + CHR$(&H0) + CHR$(&H0)      'MOV     AX,0000„asm$ = asm$ + CHR$(&HCD) + CHR$(&H33)                 'INT     33        Call the interupt„asm$ = asm$ + CHR$(&H3D) + CHR$(&H0) + CHR$(&H0)      'CMP     AX,0000   If AX is 0 then no mouse„asm$ = asm$ + CHR$(&H74) + CHR$(&H5)                  'JZ      010F      so jump to the end„asm$ = asm$ + CHR$(&HB8) + CHR$(&H1) + CHR$(&H0)      'MOV     AX,0001   otherwise load AX with 1„asm$ = asm$ + CHR$(&HCD) + CHR$(&H33)                 'INT     33        and do the interrupt„asm$ = asm$ + CHR$(&HCB)                              'RETF              Return to the system„   „„DEF SEG = VARSEG(asm$)  'calculate segment„offset% = SADD(asm$)    'calculate offset„CALL ABSOLUTE(offset%)  'execute„'=============================================================================„„It should be easy to write a parser that will take the mouseon.asm file and „convert it to BASIC code, I might even do it when I get some time.„Bill White                     TIMER FAQ                      FidoNet QUIK_BAS Echo          03-11-95 (00:00)       Text                   64   2218     TIMER.FAQ   '> I am writing a program and I am wanting the opening screen„'> to pause for maybe 3 seconds (I can work on revising the„'> amount of time if I can ever get the screen to pause)„'> before continuing on to the rest of the program.  I have„'> tried TIMER (3) variations, but haven't been able to get„'> anything to work.  It keeps going straight into the„'> program.  Does anybody have a routine to pause a program„'> for a certain amount of time before continuing?  Thankyou.„„'     TIMER.FAQ                                  3/11/95„„'     A Frequently Asked Question (FAQ) is "how do I„'introduce a delay into my program, independent of the„'CPU speed?"  In the past there has been extensive„'discussion in this echo of this subject, which brought„'out some problems.  A summary of this discussion„'follows:„„'     The old BASIC statement we used for years:„„ FOR i=1 to 1000: NEXT i„„'is not independent of the CPU speed.„„'     You could use SLEEP 2.  This, however, has„'problems: integer numbers only, user can hit _ANY_ key„'to jump out of it, and that key will be held in the„'buffer waiting to bite the next INPUT command unless„'dumped with DO: LOOP UNTIL INKEY$ = ""„„'     TIMER can be used - it ticks off 1/18.2 of a„'second:„„ delay = 2„ finish = TIMER + delay„ DO„ LOOP UNTIL TIMER => delay„„'     This works, but has a fatal midnight flaw: the„'timer is reset to 0 at midnight and it is therefore„'possible that "finish" will never be reached.  It's„'easy to test for midnight (there are 86,400 seconds in„'a day).„„'     However, it is easy not to depend on TIMER to do„'the counting - count it yourself.  Something like:„„ delay = whatever„ t! = INT(TIMER)„ DO„     IF t! <> INT(TIMER) THEN„         t! = INT(TIMER)„         count = count + 1„         PRINT count„     END IF„ LOOP UNTIL count = delay„„'     This routine doesn't care what the reading of„'TIMER is, only that it has changed.  A roll-over at„'midnight is just as valid a change as an increase of„'one second.  If you want 1/10's of a second, you'll„'need to alter accordingly.  Since TIMER ticks at 18.2„'times a second, the smallest interval will be„'0.0549450549 sec.„Beau Schwabe                   MODIFY THE BITS IN A BYTE      comp.lang.basic.misc           06-06-96 (23:36)       QB, QBasic, PDS        33   1274     BITS.BAS    '>        Does anyone know an easy way of modifying the bits in a byte? I„'>mean as in is it possible to assign a variable to each bit of a byte o„'>r„'>must you modify them by usind AND/OR/XOR?„„'Here is a short program to "modify the bits in a byte"....„„DEFINT A-Z                      'Define ALL numbers A thru Z as INTEGERs„                                'so processing SPEED is faster...„„„BYTE = 88                       'Define a value for BYTE„„'************************* CONVERT BYTE to BITS ************************„A = (BYTE AND 1) \ 1            'Bit 0„B = (BYTE AND 2) \ 2            'Bit 1„C = (BYTE AND 4) \ 4            'Bit 2„D = (BYTE AND 8) \ 8            'Bit 3„E = (BYTE AND 16) \ 16          'Bit 4„F = (BYTE AND 32) \ 32          'Bit 5„G = (BYTE AND 64) \ 64          'Bit 6„H = (BYTE AND 128) \ 128        'Bit 7„„'**************************** MODIFY BITS HERE *************************„'example„A = (NOT A) + 2                 'Toggles BIT "A" (0 or 1)„G = (NOT G) + 2                 'Toggles BIT "G" (0 or 1)„„'********************** CONSTITUTE BITS into a BYTE *******************„BYTE = A + B * 2 + C * 4 + D * 8 + E * 16 + F * 32 + G * 64 + H * 128„„„PRINT BYTE                      'Display NEW byte value„Scott Turchin                  GET BACK TO ROOT DIRECTORY     nitehawk@tscnet.com            07-24-96 (11:26)       QB, QBasic, PDS        15   476      GETBACK.BAS I once needed a simple but effective way to return to my programs root „directory each time I returned from a shell, rather than type it out „each and every time (there are 4 shells in my program) I made this happy „little subroutine...However, Somewhere in the beginning of the program „this must be performed:„Here$=Curdir„Drive$=LEFT$(CURDIR,1)„„„SUB GETBACK( HERE$, DRIVE$ ) PUBLIC„  CHDRIVE DRIVE$„  CHDIR HERE$„END SUB„„Very Very simple, but effective...„George Phillips                FORMAT OF GRASP ANIMATION FILE phillips@cs.ubc.ca             03-15-91 (04:16)       Text                   816  29501    GLFORMAT.TXTNote that some of this information is incomplete.  Check the Grasp„manual for clarification on e.g. the script-file commands.  If „anybody would like to merge all relevant documents together, that„would be nice.„„These documents were passed to me by Martin Fong, fong@erg.sri.com„„Eli Brandt   eli@smectos.gang.umass.edu  32@4351 WWIV„========================================================================„„The formats of GRASP animation files.„By George Phillips <phillips@cs.ubc.ca>„Distribute this freely, but give credit where credit is due, eh?„Version: Jan. 19,1991„„GRASP is an animation system particular to the IBM PC world.  It consists„of a program to create animations and a run-time environment for„displaying them.  The most common form these animations take is ".GL"„archives which may be displayed on an IBM-PC with a program called„GRASPRT.EXE.  This document describes what I have been able to„decipher about the format of ".GL" archives and the files contained„within.  It should be useful to those attempting to write ".GL"„animation players on other platforms.„„A ".GL" file is simply an archive file which contains images, fonts„and a command file which tells GRASPRT what to do.  These various„files have standard extensions to denote their contents:„„.txt - A command file; usually there is only one of these per archive.„.pic - An image.„.clp - An image but without a colour map.„.set or .fnt - A font containing character glyphs.„„It should be noted that the GL archive is of no particular importance;„all the archived files could exist as ordinary files and the animation„should still work.  Any GL player should be able to operate both from„an archive or from ordinary files.„„„File Formats„„Most of the data in GL files can be adequately described as a stream„of bytes which is practically universally understood.  Some fields„contain 2-byte and 4-byte integers.  I'll refer to these as "words"„and "long words" and they are all stored in little-endian format.„So if we have 4 consecutive bytes, b1, b2, b3 and b4, the word„at b1 is (b1 + b2 * 256) and the long word at b1 is„(b1 + b2 * 256 + b3 * 256 * 256 + b4 * 256 * 256 * 256).„„Since this information was gathered by example, the purpose of some„header fields and commands may not be known.  I've marked unknown„fields with question marks and have tried to put question marks and„other warnings about descriptions which are guesses.„„„GL Archives (.gl)„„A GL archive begins with a directory listing the files in the archive„which is followed by the data for each file.„„+-- Directory Header„| dir length	(word)		number of bytes in the directory header„| +-- File Entry (17 bytes per, (dir length) / 17 of them)„| | offset	(long word)	Position of file data as an offset from„| |				the beginning of the archive„| | name	(13 bytes)	File name, null padded.„| +--„+--- File data area„| +-- File Data„| | length	(long word)	Size of the file„| | data	(bytes)		the file's data (surprise!)„| +--„+---„„Font Files (.fnt or .set)„„These are very simple; first a short header describing the size of the„characters in the font and what byte values correspond to each glyph„followed by the glyph data.„„+-- Font Header„| length	(word)		length of the entire font file„| size		(byte)		number of glyphs in the font file„| first		(byte)		byte value represented by the first glyph„| width		(byte)		width of each glyph in pixels„| height	(byte)		height of each glyph in pixels„| glyphsize	(byte)		number of bytes to encode each glyph„+-- Glyph Data„| glyph first„| glyph first + 1„| ...„| glyph first + size - 2„| glyph first + size - 1„+--„„Each glyph is stored almost exactly as you would expect a raw PBM file to„contain it except that a '0' bit means black and a '1' bit means white.„In other words, row major order, each line padded to end on a byte„boundary, most significant bit is leftmost.„„„Image Formats (.pic and .clp)„„These consist of a header containing the usual image information followed„by blocked, run-length encoded image data.„„+-- Image Header (17 or 19 bytes)„| magic?	(byte)		magic number?  Always is 0x34 or 0x12„| width		(word)		width of image in pixels„| height	(word)		heigh of image in pixels„| ????		(4 bytes)	unknown„| bpp		(byte)		bits per pixel (only seen 1 or 8)„| type		(byte)		image type, either 'L' or 'C'„| flags		(byte)		if (flags & 4) then image has colourmap„| ?		(byte)		unknown„| extend	(byte)		extended header byte (if != 0, header„|				has 2 more bytes) 1/2?„| ?		(byte)		unknown„| ??		(2 bytes)	header extension if extend != 0„+-- Colour Map ((1 << bpp) * 3 bytes, only if flags & 4 == 4)„| +-- Colour Map entries (as many as indicated by bpp)„| | R		(byte)		red intensity, 0 - 63   \„| | G		(byte)		green intensity, 0 - 63  + entry 0„| | B		(byte)		blue intensity, 0 - 63  /„| +--„| ...„+-- Image Data„| blocks	(word)		number of blocks of data„| +-- Data Block (blocks of them)„| | length	(word)		length of data block, including header„| | bufsize	(word)		buffer size needed to hold all the„| |				uncompressed data in this block„| | esc		(byte)		the escape code in this block„| | data	(length - 5 byte)	run-length encoded data„| +--„+--„„The run-length encoding is byte oriented and follows these rules:„„- characters other than "esc" (see data block header) are literal„- esc n c means repeat c n times (1 <= n <= 255)„- esc 0 len(word) c means repeat c len times„„If bpp=1, then the resulting data stream is interpreted as it is„with font glyphs (i.e., msb is left, pad to bytes, row first, etc).„If bpp=8, then each byte in the data stream is an index into the„colour map.  If no colour map is available, the map to use can„only be discovered by running through the command file.„„I've only seen images with bpp=1 and bpp=8 and they it always works„out that either bpp=1 and type=C or bpp=8 and type=L.  The type=C„corresponds to CGA graphics which are mostly monochrome and 640 x 200„(so the aspect ratio is funny).  Type=L is colour graphics, prob. VGA„and usually 320 x 200.  Notice that the colour maps have only 6„bits, the same as VGA's digital to analog converters.  ".pic" files„always have colour maps, ".clp" files never do.  It seems that„you can be lazy with your run-length decoding code; I've never seen„a full sequence appear across a data-block boundary (encoders should„probably not let that happen).  The amount of uncompressed data„in a block never seems to exceed 8192 bytes.„„Much of the header information is mysterious.  Note that the header„extension field is a guess and that there are other consistent„possibilities (e.g., the extension field is a length byte or even„part of a length word).  Only type=C images seem to have the„extension.  Maybe the extra information is supposed to be used„in video mode operating system calls on the PC?„„What made this part easier was the existence of a PC-based program which„converts ".pic" files into GIF files.  Its called "cvt2gif" and can„be found on wuarchive.wustl.edu:/mirrors/msdos/gif/cvt2gif.zip.  Those„wishing to enhance the format descriptions would do well to get a„copy.  I did notice that bpp=1 images are not necessarily black and white„but could be black and some other colour as selected from the CGA„pallette.  I doubt the distinction will make much difference to the„animation, but if you really want to do it right...„„„Command File (.txt)„„The command file looks like a typical script file with the lines delimited„by carriage returns, line feeds or both.  Any text following ';' on a line„is a comment.  Text followed by a colon is used to indicate a label„(much like most assemblers).  Commands consist of a keyword followed by a„list of comma separated arguments.  The input is case-insensitive except„for arguments containing text to display (which are in double quotes).„„The basis of the command language seems to be what I call picture and„clip registers, of which there are 16 of each.  A few commands will„load a picture (or clip) from a file into a register.  Other commands„then reference the register numbers to display the pictures or get„colour maps from them.  It seems that the colour map from a picture„(.pic) is installed into the hardware and this is where the„colour maps for the clips (.clp) come from.  I assume that I am missing„a lot of commands, but most notably I believe there should be„more primitive drawing commands.„„Many of the commands seem to have a delay argument associated with„them.  This seems reasonable as control over time in an animation„is important.  I may have been over-zealous in looking for delays.„The actual time units of the delays is unknown.  They are typically„numbers < 100, so milliseconds are a likely candidate.  Hundredths„of a second are possible as well.„„Here is a list of commands.  Optional arguments are enclosed in [].„Ranges are possible in arguments (I've only seem them in fly) and„take the form "n,-,m", (e.g., fly 0,0,10,10,1,1,1,-,16).„„* box x1,y1,x2,y2,colour?„Draw a box with corners (x1, y1) and (x2, y2) in the colour given by„the colourmap entry number.„„* cfade x,y,delay,img,[,?,?]„Display a clip image img at (x, y) and wait for delay time units before„proceeding.„„* cfree n„Free up any memory associated with clip register n.„„* clearscr„Clear the display (to the currently selected colour or black?).„„* cload name,num[,?]„Load a clip image "name" into clip register num.  If name does not„have a .clp extension, it will be automatically appended.„„* color n„Set the current colour to n.  This at least seems to affect the„text displaying commands.„„* exit„Terminate the command file.„„* fload name„Load the named font which becomes the font to be used when displaying„text.  ".fnt" is appended to name if necessary.„„* float x1,y1,x2,y2,step?,delay?,num„Move the clip image (num) by displaying it at (x1,y1) and erasing it„and displaying it every step pixels until (x2,y2).  Delay delay time„units in between steps.  Or maybe something completely different,„but the x1,y1,x2,y2 and num arguments are probably coordinates and„a clip number.„„* fly x1,y1,x2,y2,step?,delay?,clip list„Successively display the clip images from (x1,y1) to (x2,y2) with delay„time units in-between.  The clip list is just a bunch of clip numbers„separated by commas (i.e., fly is varags).  A range is likely to„appear in the clip list.  Often (x1,y1) == (x2,y2).„„* fstyle ?[,?]„Presumably set up some parameters on how a font is displayed.„„* goto label„Force flow of control to the given label.„„* loop„Denotes the end of a mark loop.  Continues the loop at the most recent„mark if the loop hasn't finished.  „„* mark n„This pairs with the loop command and begins a for loop from 1 to n.„One assumes that the interaction of mark, loop and goto is the same„as for, next and goto in BASIC.  That is, loops are dynamically„scoped and you can jump in and out of them.  Mark simply pushes„a loop start onto the stack and loop examines whatever is on„the top of the loop stack.„„* mode ?„Modify the current video mode in some way.  I haven't seen this often.„„* note freq,delay?,duration„„Play a musical note of the given frequency and duration and delay for„delay time units afterward.„„* pallette n„Make the colour map from picture register n be the one to use.  This probably„installs it into the hardware so that when a clip is loaded there is„no colour map to change.„„* pfade effect,pict[,delay?[,?,?]]„Display the picture numbered pict on the screen.  The effect number„indicates what sort of special effect is used to display it.  What„the numbers mean I have no idea, but I know some of the effects.„Each pixel loaded randomly, every even line then every odd line„and so on.  The delay parameter seems to make sense, but not always.„The extra parameters could be those needed for some effects.  Often„they are large numbers.„„* pfree n„Free up any memory associated with picture register n.„„* pload name,n„Load picture "name" into picture register n.  ".pic" is appended to„name if necessary.„„* putup x,y,n„Display clip register n at (x,y).„„* set retrace [on|off]„Set is probably a general internal control variable changing command.„What retrace is I have no idea, but it was set off then on around„a fly statement.„„* spread ?,?„Who knows, but the numbers used are probably picture register numbers.„Maybe some kind of colourmap changing?„„* text x,y,"text",[delay?]„Display the given text (enclosed in double quotes) at (x,y).  The„extra parameter is probably a display, but it could be the display„colour or the background colour.  Probably the display colour is„that given by the color statement.„„* tran [on 0|off]„No idea.  Was used around some cload and float statements.„„* video mode„Set the display mode to 'C' or 'L' (remember the image format types?).„Usually the first statement in a command file.  C almost certainly„refers to CGA which is 640 x 200 monochrome and L almost certainly„to VGA which (in their case) is 320 x 200 x 256.„„* waitkey [[delay[,label]]„Wait up to delay units for the user to press a key (or forever if no„delay time is given).  If the user presses a key and the label„argument is present, transfer control to that label.„„* window x1,y1,x2,y2,?„Some kind of display control.  Probably a clipping window with appropriate„coordinate translation (i.e., (0,0) becomes (x1,y1)).„„„„This document was created by looking hard at a number of GL files,„using cvt2gif to help decipher the image file format and looking„at 1 or 2 animations on an RS-6000 running a PC emulator and using„grasprt.  cvt2gif was very useful; grasprt under the PC emulator„was painfully slow at times and didn't help my understanding„much.  I've never even gotten close to a copy of the program for„creating and editing GL files.„„If you find out more about GL files, send me the changes so I can„extend this document.  Feel free to include this as supplementary „documentation if you write a GL player.  Finally, here are some„projects which could help find out more about GL files:„„- Get cvt2gif and feed it small variations on .pic files to decipher„the meaning of the missing header fields.  I may do this.„„- Alter control files on some animations and see what effects they„have.  Something easy would be to change the effect number on„pfade statements (if that's what it is).  I don't have the hardware„to do this.„„- Look at the GRASP animation package and intuit what the commands„mean by what control you have over generating animations.  This is„probably the easiest way to get information.  I don't have GRASP,„I don't know where to get it and I don't has a PC good enough to„run it on.„„========================================================================„„GRASP/Pictor Font format description                                  09/06/87„------------------------------------                                  --------„„For convenience, we have chosen to adopt the IBM ROM font format for data, but„to keep things manageable, we have added a 7 byte header which describes the„font.„„The seven byte header is defined as follows:„„WORD	number of bytes in character data, plus this 7 byte header.„BYTE	number of characters in set. 1-255 or 0 if 256.„BYTE	ascii value of first character.„BYTE	x size of character in pixels.„BYTE	y size of character in pixels.„BYTE	number of bytes in a single character.„„As you can see from this header data, these limits apply:„„1) Maximum number of characters in set is 256.„2) Maximum character size is limited as: xsize/8 * ysize <256.„3) All character data plus 7 byte header must be <64K in size„„„We use the following structure when writing programs that use fonts. Note the„additional words at the end of the structure which allow you to keep the actual„character data in a far segment.„„struct chs {		/* character set structure */„	unsigned int numchbyts;„	unsigned char numchars;„	unsigned char ascoff;„	unsigned char chxsize;„	unsigned char chysize;„	unsigned char chbytes;„	unsigned int chsseg;	/* segment of character data */„	unsigned int chsofs;	/* offset in segment of character data */„};„„„So....A 256 character 8x16 font's header would look like:„„numchbyts   = 4103         256 chars X 16 bytes/char + 7 bytes for header„numchars    =    0         0 to represent 256„ascoff      =    0         start with 0 character„chxsize     =    8         8 dots wide„chysize     =   16         16 dots high„chbytes     =   16         1 byte wide x 16 dots high„„„and a 96 character 11 X 18 font whose first character is SPACE's header would„look like:„„numchbyts   = 3456         96 chars X 36 bytes/char + 7 bytes for header„numchars    =    0         0 to represent 256„ascoff      =   32         start with 'SPACE' character„chxsize     =   11         8 dots wide (this takes 2 bytes!)„chysize     =   18         16 dots high„chbytes     =   36         2 byte wide x 18 dots high„„========================================================================„„„„                   PCPAINT/Pictor Page Format Description„„                          Format by John Bridges.„„                   Document by Microtex Industries, Inc.„„„„„„Revision Date: 2/9/88„„„„Global Notes:„------------„„PCPAINT 1.0 - Revision 1.0 was developed for Mosue Systems in 1984 supported„only BSAVE files in CGA 4 color mode. In the space between the scan buffers„was a string that read PCPAINT 1.0 followed by 2 bytes which were the pallete„and border information for that picture.„„PCPAINT 1.5 - Revision 1.5 was the same as 1.0 except that it contained larger„than screen images and also had a primative packing format. This was sold for„so short a time that it won't be covered here.„„PCPAINT 2.0 thru Pictor 3.1 - This document describes these formats. The file„description is identical for all revisions in this range. However, in„PCPAINT 2.0, the bit-planes were packed together so that the pictures„resembled a PCjr picture, or 4 bits per pixel, 1 bit plane. Starting with„Pictor 3.0, the files were saved with the bitplanes separated. This takes a„little more memory in some cases, but the speed in loading and saving was a„desireable consideration.„„NOTE TO PROGRAMMERS: A good PCPAINT/Pictor file decoder will use the variables„                     in the header to decode the image and thus be compatible„                     with all formats since the October, 1985 release of„                     PCPAINT 2.0.„„Also please note that PCPAINT/Pictor are stored from the bottom up. This is„opposite that of most of the screen adapters it supports. This really causes„no problem, but be aware that you should use a Y table to look up scan lines.„In all PCPAINT/Pictor pictures, the scan lines are continuous. If a picture „is to be displayed on a particular adapter, the programmer is responsible for„using a y-table to properly interleave the lines if necessary.„„Also note that Pictor was designed for speed, so no inter-mode loading is„possible. If you are writing applications that create Pictor images that you„want to load into Pictor, you must remain mode dependent. „„Header - A full description of the file header information.„„offset	type	name	description„-------	-------	-------	----------------------------------------------------- „  0	word	marker	marker that is always 01234h„„  2	word	xsize	x size of page in pixels „„  4	word	ysize	y size of page in pixels„„  6	word	xoff	x offset into page where lower left hand corner of„			viewport is located (default of 0 is ok)„„  8	word	yoff	y offset into page where lower left hand corner of„			viewport is located (default of 0 is ok)„„ 10	byte	bitsinf	bits 0-3 is the number of bits per pixel per bit„			plane and bits 4-7 is the number of bit planes (so„			4 color cga mode would be 02h and 16 color ega would„			be 31h and plantronics 16 color would be 12h)„„ 11	byte	emark	marker that is always a 0ffh„„ 12	byte	evideo	single uppercase letter indicating which video mode„			this picture was created in, can default to 0.„„			0 - 40 col text„			1 - 80 col text„			2 - mono text„			3 - 43 line text„„			A=320x200x4 cga„			B=320x200x16 pcjr, stbplus, tandy 1000„			C=640x200x2 cga„			D=640x200x16 ega„			E=640x350x2 ega„			F=640x350x4 ega„			G=640x350x16 ega„			H=720x348x2 hercules„			I=320x200x16 plantronics„			J=320x200x16 ega„			K=640x400x2 AT&T or Toshiba 3100„			L=320x200x256 vga„			M=640x480x16 ega plus(video 7, tseng, paradise), vga„			N=720x348x16 Hercules InColor„			O=640x480x2 vga„„ 13	word	edesc	extra information descriptor defines what is in„			the extra information that follows this header,„			0=nothing„			1=pallet (single byte) border (single byte)[CGA]„			2=pcjr or non ECD 16 color registers (0-15), 1 byte each„			3=EGA with ECD 16 color registers (0-63) 1 byte each„			4=VGA 256 color info - 256 colors, 1 byte each rgb gun.  „„ 15	word	esize	size of extra information in bytes„„ 17	byte	edata[]	the actual extra data the size which is defined„			by esize (at offset 15).„ 17+„ esize	word	numblks	the number of packed blocks in this file. if this is„			a zero, then data is unpacked. „„„Structures - These C structures describe the header information.„„struct head {„	unsigned int mark=0x1234;	/* marks begining of a page file */„	unsigned int xsize;		/* x size of page */„	unsigned int ysize;		/* y size of page */„	unsigned int xoff;		/* current x offset into picture of viewport */„	unsigned int yoff;		/* current y offset into picture of viewport */„	unsigned char bitsinf;„}„„struct extra {„	unsigned char emark=0xff;„	unsigned char evideo;„	unsigned int edesc;„	unsigned int esize;„}„„int edata[esize];„unsigned int numblks;„„If the file is packed then what follows is a multi block packed file,„otherwise (if the file is not packed, numblks=0) the actual data follows.„„Bit planes follow each other in the file and when packed each bit plane„must start in a new packed block.„„„Packed Block Description„„„Packed block header„„PBSIZE	dw		;Packed block size. The size of this block„BSIZE	dw		;Unpacked block size„MBYTE	db		;Unique marker byte. This is a byte that does not„			; exist in the current unpacked block. If no unique„			; byte exists, then pick one that is used rarely„			; to avoid too much redundancy.„„Packed block data - variable size depending on whether 16 bit run is needed.„„MARKER	db		;mark a run (this is where MBYTE goes) „LENGTH	db		;length of run. if 0, then look at BIGLEN„„BIGLEN	dw		;16 bit run count (only exists if LENGTH==0)„DATA	db		;byte to fill run with„„„Example 1 - a 320x200, 4 color, packed page file, of a white screen. „„	dw	0x1234		;marker„	dw	320		;x size„	dw	200		;y size„	dw	0		;x offset„	dw	0		;y offset„	db	02h		;2 bits per pixel and 1 bit plane„„	db	0xff		;extra info flag„	db	'A'		;vidmode„	dw	1		;extra area descriptor (pal and bord)„	dw	2		;bytes in extra area„	db	2,0		;pallet and border (extra information)„„	dw	2		;number of packed blocks„„;first block„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0xff		;byte to fill run with„;second block„	dw	5+5		;packed block size„	dw	7808		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	7808		;16 bit run count„	db	0xff		;byte to fill run with„„„„„Example 2 - a 640x350, 16 color, packed page file, of a red screen (color 4).„„	dw	0x1234		;marker„	dw	640		;x size„	dw	350		;y size„	dw	0		;x offset„	dw	0		;y offset„	db	31h		;bits per pixel and 1 bit plane„„	db	0xff		;new extra info flag„	db	'G'		;vidmode„	dw	3		;extra area descriptor (pal and bord)„	dw	16		;bytes in extra area„	db	0,1,2,3,4,5,14h,7„	db	38h,39h,3ah,3bh,3ch,3dh,3eh,3fh„„	dw	16		;number of packed blocks„;block 1 of first bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 2 of first bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 3 of first bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 4 of first bit plane„	dw	5+5		;packed block size„	dw	3424		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	3424		;16 bit run count„	db	0		;byte to fill run with„;block 1 of second bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 2 of second bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 3 of second bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 4 of second bit plane„	dw	5+5		;packed block size„	dw	3424		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	3424		;16 bit run count„	db	0		;byte to fill run with„;block 1 of third bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0xff		;byte to fill run with„;block 2 of third bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0xff		;byte to fill run with„;block 3 of third bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0xff		;byte to fill run with„;block 4 of third bit plane„	dw	5+5		;packed block size„	dw	3424		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	3424		;16 bit run count„	db	0xff		;byte to fill run with„;block 1 of fourth bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 2 of fourth bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 3 of fourth bit plane„	dw	5+5		;packed block size„	dw	8192		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	8192		;16 bit run count„	db	0		;byte to fill run with„;block 4 of fourth bit plane„	dw	5+5		;packed block size„	dw	3424		;unpacked block size„	db	0		;marker byte„	db	0		;mark a run„	db	0		;a 16 bit run count follows„	dw	3424		;16 bit run count„	db	0		;byte to fill run with„„„„Example 3 - For more detail lets consider a block that isn't all the same.„Say the data consists of 30 2's, and 8, a 4, and 300 1's.„„; the block would look like this „„	dw	5+10		;packed block size„	dw	332		;30 + 1 + 1 + 300 bytes as above„	db	ff		;what to mark a run with,„                                ; because there are no ff's in our example.„„	db	ff		;mark a run „	db	30		;8 bit run count„	db	2		;byte to fill run with - 2„„	db	8		;not a run marker, so must be data„„	db	4		;not a run marker, so must be data„„	db	ff		;mark a run„	db	0		;means 16 bit run count follows„	dw	300		;run count	„	db	1		;byte to fill run with - 1„„„The actual unpacked data that resides in memory consists 2 seperate„sections.„„1. The control structure: contains x size, y size, x offset, y offset,„   segment of bit mapped data, number of bits per pixel and number of„   additional bit planes. this information is kept in pcpaint's data segment.„„2. The actual bit mapped data: contains the actual page image, mapped from„   bottom left (so bottom scan line is first). The data is contiguous within„   each bit plane, so scan line 1 follows scan line 0 directly. the page„   can and does cross segment boundires (a bit plane can be larger than„   64k). each bit plane follows the previous but starts on a paragraph„   boundary, the printer driver will be passed the offset in paragraphs„   between bit planes and the number of additional planes.„   The bit planes start with bit 0, each additional plane is the next bit.„„„Kurt Kuzba                     SUBROUTINE & FUNCTION USAGE    FidoNet QUIK_BAS Echo          10-06-96 (22:08)       QB, QBasic, PDS        92   4523     SUBTUTOR.BAS'>   What is the difference between SUBs and FUNCTIONS?„'>.........„'_|_|_|   SUBTUTOR.BAS„'_|_|_|   A short tutorial on SUB and FUNCTION usage.„'_|_|_|   No warrantee or guarantee is given or implied.„'_|_|_|   Released   PUBLIC DOMAIN   by Kurt Kuzba.  (10/6/96)„COLOR 15, 1: CLS„PRINT " This is a short tutorial on use of SUB and FUNCTION in QBasic"„PRINT " and Quick Basic. It explores some of the relationships of"„PRINT " variables between modules. By studying the code and following"„PRINT " with the text, one may grasp module concepts."„PRINT " Variables in a SUB or FUNCTION, unless declared as STATIC,"„PRINT " are AUTOMATIC variables. BASIC initializes them every time"„PRINT " the module containing them is called. They may have the same"„PRINT " name as variables in other modules without confusion."„PRINT " SHARED and PASSED variables will be examined. Ready?"„DO: LOOP WHILE INKEY$ = "": CLS„PRINT " We will begin with the SUB. Variables may be passed by SEG or"„PRINT " or by VAL. Variables enclosed in parentheses are passed by VALue."„PRINT " FUNCTION variables must be enclosed in a group parentheses, and"„PRINT " we may also use VAL parentheses. First, we will pass by VALue."„PRINT : MyStr$ = "This won't be changed.": MySub (MyStr$)„PRINT " MyStr$ = "; MyStr$: PRINT„PRINT " As you can see, MyStr$ is unchanged"„DO: LOOP WHILE INKEY$ = "": CLS„PRINT " Now we will pass by SEGment.": PRINT„MyStr$ = "This will be changed."„MySub MyStr$: PRINT " MyStr$ = "; MyStr$: PRINT„PRINT " Since the ADDRESS of MyStr$ was passed, the SUB was"„PRINT " able to change the contents of the variable."„DO: LOOP WHILE INKEY$ = "": CLS„PRINT " Now we will use a FUNCTION and pass by VALue.": PRINT„MyStr$ = "This won't be changed.": FuncStr$ = MyFunc((MyStr$)):„PRINT " MyFunc$ = "; FuncStr$: PRINT " MyStr$ = "; MyStr$: PRINT„PRINT " As a result, MyStr$ is unchanged, and a new string is created."„DO: LOOP WHILE INKEY$ = "": CLS„PRINT " Now we will pass MyStr$ by SEGment.": PRINT„MyStr$ = "This will be changed.": FuncStr$ = MyFunc(MyStr$):„PRINT " MyFunc$ = "; FuncStr$: PRINT " MyStr$ = "; MyStr$: PRINT„PRINT " We still got the new string, but now MyStr$ has changed!"„DO: LOOP WHILE INKEY$ = "": CLS„PRINT " Unlike subroutines using GOSUB, variables found in the"„PRINT " MAIN module are unknown in the SUB or FUNCTION routines."„PRINT " This is known as the SCOPE of a variable. In order for a"„PRINT " variable to be VISIBLE to a SUB or FUNCTION, it must be"„PRINT " declared as being SHARED, or be passed as an argument."„DO: LOOP WHILE INKEY$ = "": PRINT„MyStr$ = "This is MyStr$.": MyShare: PRINT " MyStr$ = "; MyStr$: PRINT„PRINT " This way, variables are available to your SUB or FUNCTION."„DO: LOOP WHILE INKEY$ = "": CLS„PRINT " In addition, we may declare variables SHARED in the main"„PRINT " module by use of the DIM statement.": PRINT„DIM OurStr AS STRING * 32: OurStr = "This is a shared string."„MySub OurStr: PRINT " OurStr = "; OurStr: PRINT„PRINT " So here we see that this string is shared in the SUB."„DO: LOOP WHILE INKEY$ = "": PRINT„PRINT " If we were to pass a fixed length string as an argument,"„PRINT " then the contents of the string would be passed and not the"„PRINT " string itself, although, if that string were passed by SEGment,"„PRINT " then whatever changes were made to the passed string would be"„PRINT " stored in the fixed string when we exit the SUB or FUNCTION."„DIM FixedStr AS STRING * 10: FixedStr = "A string"„PRINT " FixedStr = "; FixedStr: Fixed FixedStr„PRINT " FixedStr = "; FixedStr: PRINT„PRINT " The SUB string is a temporary dynamic string created by the SUB"„PRINT " and truncated to fit into the fixed length string."„DO: LOOP WHILE INKEY$ = "": PRINT„PRINT " I hope this answers most of your questions concerning"„PRINT " the use of SUBs and FUNCTIONs in QBasic and Quick Basic."„DO: LOOP WHILE INKEY$ = "": COLOR 2, 0: CLS„'_|_|_|   end   SUBTUTOR.BAS„„SUB Fixed (p$)„   PRINT " (passed string)p$ = "; p$„   p$ = "This string is way too big for FixedStr."„   PRINT " (passed string)p$ = "; p$„END SUB„„FUNCTION MyFunc$ (p$)„   PRINT " (passed variable)p$ = "; p$: p$ = "changed"„   MyFunc$ = "This is an entirely new string!"„END FUNCTION„„SUB MyShare„   SHARED MyStr$: PRINT " SHARED variable MyStr$ = "; MyStr$„   MyStr$ = "This variable, being SHARED, may be changed."„END SUB„„SUB MySub (p$)„   PRINT " (passed variable)p$ = "; p$: p$ = "changed"„END SUB„„Andrew L. Ayers                GET/PUT INFO. FOR VGA MODE 13H andrewa@indirect.com           09-09-96 (00:00)       Text                   342  15018    GETPUT13.TXT-----------------------------------------------------------------------------„        Mode 13 VGA (320x200x256) GET/PUT Information and Techniques„„                  By Andrew L. Ayers - September 9th, 1996„„-----------------------------------------------------------------------------„„The following is what I have found out through trial and error (as well as„a bit of logical guesswork). While I have found it to work on every machine„I have tried it with, do not assume it is so for your machine. Instead, pro-„ceed with caution. While none of this should cause major problems (ie. I do„not believe it will trash your machine or anything), a wrong step could cause„your machine to lock up, forcing you to reboot. Anyway, this is intended for„informational purposes only. I cannot be held responsible for the use/abuse„of the information contained herein, nor can I be held responsible for any„damage done to the person or the machine on which the examples contained in„this document are run upon. Just the standard disclaimer to CMA!„„If you find this information useful, and choose to include the techniques in„your own code, please be kind and mention my name. You don't have to do this„(hell, if I mentioned everyone's name I have learned from, that list would be„a mile long!), but it would be nice.„„I wish to thank Jason Grooms - for guiding my first steps into the wonderful„world of assembler (back then, 6809), and to Brent Dill, for showing me how„to do strange and crazy stuff with GET/PUT, and a host of other tips. Brent,„if your read this, contact me. I'm on the 'Net. I know you are worth your„salt to find me. L8r!„„=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=„„Calculating the buffer size for GET/PUT in mode 13:„„1. Take the width of the area you are getting (in pixels) and multiply it„   by the height (in lines). This will give you the total number of bytes„   in the area for the buffer.„„2. Find the total number of WORDs to use by dividing the number of bytes by„   two. We need the total number of WORDs because the smallest variable type„   we can use is an integer, which is WORD size (2 bytes).„„3. We now have the amount of space needed to store the area we want to GET.„   But BASIC needs a couple of more pieces of information in order for GET„   and PUT to operate correctly. These two pieces of information are the„   width and the height of the image! It needs these two items in order for„   the PUT routine to know when to stop drawing. So, the width and the„   height of the image area must be stored with the image data itself. These„   two values are placed into their own WORDs at the start of the buffer. We„   must add on two WORDs to accomodate this.„„4. We now have the total number of WORDs needed to DIMension an integer array„   to hold our image data. Because the base of the array starts at zero, we„   will subtract one from our total number of WORDs to DIMension our array:„„	DIM buffer%(# of WORDs)„„5. Our buffer data layout looks like so:„„	WORD	DESCRIPTION„	----	--------------------------------------------------„	   0	Width, contained in the high byte of the WORD.„		This value is in bits (!), and so must be divided„		by 8 to find out the number of pixels (bytes).„	   1    Height, contained in the high byte of the WORD.„		Value in number of lines.„	   2	Start of data...„	   .„	   .„	   .„	  XX	End of data...„„Example:„„1. We have a 16x16 sprite. So we need 256 bytes in order to hold an area this„   big.„„2. We need the number of WORDs, so we divide by 2, giving us 128 WORDs.„„3. We add two words to accomodate the width and height values needed by PUT,„   giving us a total of 130 WORDs.„„4. We subtract 1, and dimension our array:„„	DIM buffer%(129)„„5. Our buffer data layout looks like so:„„	WORD	DESCRIPTION„	----	--------------------------------------------------„	   0	Width, contained in the high byte of the WORD.„		This value is in bits (!), and so must be divided„		by 8 to find out the number of pixels (bytes).„	   1    Height, contained in the high byte of the WORD.„		Value in number of lines.„	   2	Start of data...„	   .„	   .„	   .„	 129	End of data...„„=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=„„Multiple Image Buffers for GET/PUT:„„What was shown above was an example for a simple buffer to hold a single„image to be used in GET/PUT. Using the above simple example, we would just do the„following„„		GET(0,0)-(15,15),buffer%„		PUT(100,100),buffer%,PSET„„in order to GET/PUT a single simple image. But what if we needed 30 sprites„(say for a game)? We could do this„„		DIM buffer1%(129), buffer2%(129),...,buffer30%(129)„„then use GET/PUT to move everything around, but this is wasteful, and not„very easy to work with. What if we wanted animation? What then?„„Fortunately, there is an easy way out, using what is called offsetting. We„have a buffer of a set size we are GETing and PUTing with. What isn't being„shown is what is called the offset. An offset is a number added to a fixed„value to obtain a new start value. When we dimension an array, the start of„that array is obtained and kept by BASIC (we can use VARSEG and VARPTR to„find it if we wanted to). If we say DIM a%(20), then say a%(2)=15, we have„used an offset of 2 from the start of the array and placed 15 at that pos-„ition in memory. A similar thing is done by GET/PUT. Note the following:„„		DIM buffer%(129)„		GET(0,0)-(15,15),buffer%„„is the same as:„„		DIM buffer%(129)„		GET(0,0)-(15,15),buffer%(0)„„We just didn't use the offset of zero in the first example! What would happen„if we did the following?:„„		DIM buffer%(129)„		GET(0,0)-(15,15),buffer%(10)„„We would get an error. This is because we need 130 WORDs of space for the„area we are trying to GET, and we only have a total of 130 WORDs to play„with. By trying to put an offset of 10 into the mix, we overrun the end of„the array by 10 WORDs! The following would work:„„		DIM buffer%(139)„		GET(0,0)-(15,15),buffer%(10)„„Now WORD number 10 would hold our width and WORD number 11 our height, and„12 through 139 would hold our data. We could then PUT(100,100),buffer%(10),PSET„and everything would work fine. Now what would happen if we PUT(100,100),„buffer%(0),PSET? We would either get an error or garbage, because PUT wouldn't„have the correct width and height info in the first two WORDs! So, we need„to keep track of the size so we know what offsets we can use when GETing and„PUTing our images.„„Our example is a 16x16 sprite. We would like to have 30 of these for our„ultra cool game we are writing. We need 130 WORDs for each of these sprites„(2 for width/height, 128 for data), and we want 30 sprites, so we need a„buffer that is 3900 WORDs long (130 WORDs x 30 sprites). We know that every„130 WORDs is a new sprite, so that will be our offset. If we set our offset„to 0, then we are on the first sprite, 130 is the second, 260 is the third,„and so on. The following shows how:„„		DIM sprite%(3899)„		spritenum%=2„		GET(0,0)-(15,15),sprite%(spritenum%*130)„		spritenum%=5„		PUT(100,100),sprite%(spritenum%*130),PSET„„Before you can put a sprite, you obviously need to GET it, so that PUT has„the width/height info to work with. So lines 4 and 5 wouldn't work in our„example unless we changed line 2 to "spritenum%=5".„„We now have an easy way to GET/PUT a whole mess of sprites on the screen„using a single buffer that is easily accessible. We could do simple animation„with this system. Say our first five sprites were already in the buffer and„they were an animation of some type. To flip through them, we would do the„following:„„		FOR spritenum%=0 TO 4„		  PUT(100,100),sprite%(spritenum%*130),PSET„		NEXT spritenum%„„It is that easy.„„Our buffer layout now looks like this, for those interested:„„	WORD	DESCRIPTION„	----	--------------------------------------------------„	   0	Width, contained in the high byte of the WORD.„		This value is in bits (!), and so must be divided„		by 8 to find out the number of pixels (bytes).„	   1    Height, contained in the high byte of the WORD.„		Value in number of lines.„	   2	Start of sprite0 data...„	   .„	   .„	   .„	 129	End of sprite0 data...„„	 130	Width, contained in the high byte of the WORD.„		This value is in bits (!), and so must be divided„		by 8 to find out the number of pixels (bytes).„	 131    Height, contained in the high byte of the WORD.„		Value in number of lines.„	 132	Start of sprite1 data...„	   .„	   .„	   .„	 259	End of sprite1 data...„„	 260	Width, contained in the high byte of the WORD.„		This value is in bits (!), and so must be divided„		by 8 to find out the number of pixels (bytes).„	 261    Height, contained in the high byte of the WORD.„		Value in number of lines.„	 262	Start of sprite2 data...„	   .„	   .„	   .„	 389	End of sprite2 data...„„And so on...„„The only other thing you need to keep in mind is buffer size versus sprite„size. As noted before, a 16x16 sprite needs 130 WORDs in order to store it„completely in an array. When you have multiple sprites in an array, there„is a limit to the size of your array you can have. This limit is 64K - 65536„bytes, or 32768 WORDs. To find out how many sprites you can store in a single„array, divide 32768 by the number of WORDs required for each sprite. Drop any„values after the decimal (that is, take the integer, drop the remainder), and„this is the maximum number of sprites you can store. For our example of a„16x16 sprite (130 WORDs), this works out to be 252 sprites. Take that number„and multiple by the number of WORDs per sprite, subtracting 1, to use for„DIMensioning the array: DIM buffer%(32759).„„The following table breaks down common sprite sizes and array dimensions:„„	Sprite Size  Number  Array Size (in WORDs)„	-----------  ------  ---------------------------------„	   8 x 8       963   34 for sprite, 32741 for array„	  16 x 16      252   130 for sprite, 32759 for array„	  32 x 32       63   514 for sprite, 32381 for array„	  64 x 64       15   2050 for sprite, 30749 for array„„If you need more sprites, you can split them over two arrays. Animation and„such becomes more difficult to handle, but it can be done. „„Also remember, the larger the sprite, the more data the computer has to shove„around. Stay away from the 64 x 64 sprites, except for maybe big bosses or„such. These things are memory HOGS. The only other limit to be aware of is„QBASIC's 160K limit on program AND code size. One buffer of sprites (252„sprites) will eat almost 64K, leaving you with less than 100K to put the„rest of your code in! QuickBASIC and PowerBASIC users shouldn't have any„problem though. Some of these problems may be overcome by using EMS routines„to shove the sprite data into extended memory, though.„„=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=„„GETing and PUTing without The BOX:„„If you have ever used GET and PUT, you know that when you PUT, a "box" is„left around your image obliterating anything under and around your sprite.„This looks very ugly and unprofessional in a game. The following shows the„best way to get rid of this problem, using a method called sprite masking.„„1. First, for each and every sprite you create, create a "mask" for it. This„   mask is the same size and shape as the original sprite, only it consists„   of only two colors, 0 and 255 (or &H0 and &HFF for you hex folks). Color„   all visible portions of the sprite (those portions you want to obscure„   the background) with color 0. Color all invisible portions of the sprite„   (those protions you want the background to show through) with color 255.„   Remember, you need one mask for each sprite, and this will knock your„   sprite count down by half, so keep it in mind when designing your game.„„2. To display your sprite, simply PUT the mask image down using the AND op-„   erator, then place the sprite image down using the OR operator. The AND„   and OR operators are called bitwise boolean operators, and have the„   following truth tables:„„	        AND			OR„	-------------------	-------------------„	IN1	IN2	OUT	IN1	IN2	OUT„	-------------------	-------------------„	0	0	0	0	0	0„	1	0	0	1	0	1„	0	1	0	0	1	1„	1	1	1	1	1	1„„   These tables basically mean the following. If you take two bits and AND„   or OR them together, the result equals a 1 or a 0 depending on the inputs„   and the relationship between them in the truth tables for the operator in„   question. If you understand this - read on. If you understand this and„   are 10 - 14 years old, you don't need college (just kidding ;).„„   Now, for what we are doing, we have a background of different byte values„   (which consist of a series of bits). Our mask only has two values in it,„   the byte 0 (00000000 in binary) and the byte 255 (11111111 in binary).„   Let me show you how the magic works:„„   A.	Our Background Image	AND	Mask	=	Result„„	11110110		      11111111		11110110„	11110110		      11000011		11000010„	11110110		      11000011		11000010„	11110110		      11000011		11000010„	11110110		      11111111		11110110„„  B.	Our Result	       OR      Sprite	=	Result„„	11110110		      00000000		11110110„	11000010		      00111100		11222210„	11000010		      00111100		11222210„	11000010		      00111100		11222210„	11110110		      00000000		11110110„„  If you notice, I have used 2s in place of 1s on the final result to show„  the example better. Those 2s should really be 1s, so don't let that throw„  you. Suffice to say, if you look carefully, we have placed our 8 x 5„  sprite on the background, without the border showing.„„=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=„„GETing and PUTing without The BOX, method 2:„„The next best way to GET and PUT without the box showing, is to simply not„draw those pixels in the first place. The only way to do that (short of mod-„ifying BASIC itself) is to write your own PUT routine, to skip over any pixel„of a defined color (0 in our case). This would have two advantages: Number„one, your sprite could be drawn faster because you only set the pixels you„need, and number two, you wouldn't double your buffer requirements for „sprites because you would only need the sprites, and could eliminate the„masks! All sounds good until you try to write the thing in BASIC...it is„horribly slow (ok, on a fast system, it runs at an acceptable pace). The only„way to get around this is to code it in a lower level language (or at least„one that can compile down to a faster version). I have done this, and you„can find the results of my labor in the ABC Packets. It is called the Blast!„library. It allows you to do the above, and much more. Check it out!„„