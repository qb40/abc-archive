Alexander Podkolzin            PB TEXT MODE SCREEN SAVER      APP@nw.sbank.e-burg.su         11-05-96 (11:12)       PB                     169  4027     TXTSAVER.BAS'-------------------------------------------------------------------------„'„' Simple text mode screen saver (PowerBasic 3.2).„' Author - Alexander Podkolzin <APP@nw.sbank.e-burg.su>„' Public domain.„' Test it before using!„'„'-------------------------------------------------------------------------„' Not PowerBasic users! Exclude subs SaveScreen and RestoreScreen...„'-------------------------------------------------------------------------„'„  DEFINT a-z„'„„  ScreenSaver„„'„  SUB ScreenSaver„'„'   It works fine on my 100DX4 ...„'„     %MaxStars = 50               ' Number of "stars" on the screen„     DIM Star(2000)               ' Array of "stars"„'„     SaveScreen w$,1,1,80,25,0„'„     CLS                          ' Initial settings...„     RANDOMIZE TIMER„'„     FOR i=1 TO %MaxStars„        Star(INT(RND*1999)+1) = 1„     NEXT„'„     s$=CHR$(250)„     FOR k=1 TO 2000„        IF Star(k)<>0 THEN„           GOSUB CalcYX„           GOSUB ShowStar„        END IF„     NEXT„'„     DO                           ' Main loop„        s$=INKEY$„        IF s$<>"" THEN EXIT LOOP„'„        k = INT(RND*1999)+1„'„        IF Star(k)=1 THEN„           s$=CHR$(250)„        ELSEIF Star(k)=2 THEN„           s$=CHR$(249)„        ELSEIF Star(k)=3 THEN„           s$=CHR$(7)„        ELSEIF Star(k)>4 THEN„           s$=" "„        END IF„'„        IF k<2001 THEN„           IF Star(k)<>0 THEN„              GOSUB CalcYX„              GOSUB ShowStar„              INCR Star(k)„              IF Star(k)>4 THEN„                 GOSUB KillStar„                 n=0„                 FOR i=1 TO 2000„                    IF Star(i)<>0 THEN INCR n„                 NEXT„                 d = %MaxStars - n„                 IF d>0 THEN„                    FOR i=1 TO d„                       GOSUB AddStar„                    NEXT„                 END IF„              END IF„           END IF„        END IF„        COLOR 8,0„        LOCATE 1,72               ' Printing time at upper right corner„        PRINT TIME$;              ' of the screen.„     LOOP„'„     RestoreScreen w$,1,1„'„     EXIT SUB„'„„CalcYX:„     y = k \ 80 +1„     x = (k MOD 80)+1„     RETURN„'„„KillStar:„     Star(k)=0„     LOCATE y,x„     PRINT " ";„     RETURN„'„'„„ShowStar:„     LOCATE y,x„     c = INT(RND*15)+1            ' Random color (1 - 15)„     COLOR c,0„     PRINT s$;„     RETURN„'„'„„AddStar:„     DO„        k = INT(RND*2000)+1„        IF k<2001 AND Star(k)=0 THEN„           Star(k)=1„           EXIT LOOP„        END IF„     LOOP„     RETURN„'„  END SUB„'„'-------------------------------------------------------------------------„  SUB SaveScreen(w$,xb%,yb%,xe%,ye%,sh%) PUBLIC„     DIM temp AS BYTE PTR„     DIM WinPtr AS BYTE PTR„     DIM TextPtr AS BYTE PTR„     lx% = (xe% - xb% + 1) * 2„     ly% = ye% - yb% + 1„     IF sh% THEN„        INCR lx%,2„        INCR ly%„     END IF„     l$ = RIGHT$(" " + STR$(lx%), 3 )„     w$ = l$ + SPACE$( lx% * ly% )„     WinPtr = PBVSCRNBUFF + (yb%-1)*160 + (xb%-1)*2„     TextPtr = STRPTR32(w$) + 3„     FOR i%=1 TO ly%„        temp = WinPtr„        FOR k%=1 TO lx%„           @TextPtr = @temp„           INCR TextPtr„           INCR temp„        NEXT„        INCR WinPtr,160„     NEXT„  END SUB„'-------------------------------------------------------------------------„  SUB RestoreScreen(w$,xb%,yb%) PUBLIC„     DIM temp AS BYTE PTR„     DIM WinPtr AS BYTE PTR„     DIM TextPtr AS BYTE PTR„     l$ = LEFT$(w$,3)„     w$ = LTRIM$(w$,l$)„     lx% = VAL(l$)„     ly% = LEN(w$) \ lx%„     TextPtr = STRPTR32(w$)„     WinPtr = PBVSCRNBUFF + (yb%-1)*160 + (xb%-1)*2„     FOR i%=1 TO ly%„        temp = WinPtr„        FOR k%=1 TO lx%„           @temp = @TextPtr„           INCR TextPtr„           INCR temp„        NEXT„        INCR WinPtr,160„     NEXT„  END SUB„'-------------------------------------------------------------------------„Daniel Garlans                 TEXT 2 SELF EXTRACTING .BAS    thegarlans@geocities.com       11-08-96 (15:35)       QB, QBasic, PDS        105  3694     TXT2BAS.BAS 'TxtoBas 1.2„'Changes: neater and more commented :)„'Takes a text file and creates a "self extracting" .BAS file that creates„'the origional text like it was.„'This program was tested with WORMHOLE.BAS by..err..someone, and was inspired„'by complaints that line-lengths were a problem for most browsers„'---Constants„CONST maxwid = 70 '70 character maximum length in output file„'---Code„PRINT "TxtoBas 1.2 by Daniel Garlans" 'header„INPUT "File to convert:", a$„IF a$ = "" THEN END„inputted$ = a$„INPUT "File to write to:", out$„IF out$ = "" THEN END„OPEN a$ FOR INPUT AS #1„PRINT "File exists." 'if we're here, the file opened :)„PRINT "Starting...";„v$ = ENVIRON$("TEMP") 'get tempfile directory„IF LEN(v$) = 0 THEN v$ = "c:" 'if there's no "TEMP" set, make the temp dir=c:„tfile$ = v$ + "\@t2btemp.034" 'one temp file„tfile2$ = v$ + "\@t2btemp.043" 'two temp files„OPEN tfile$ FOR OUTPUT AS #2 'temp file: First step„tot = 0 'line count...„DO WHILE NOT EOF(1) 'keep it comin'„LINE INPUT #1, a$ 'get a line„fin$ = "" 'to write=nothing yet„FOR b = 1 TO LEN(a$) 'letter by letter„c$ = MID$(a$, b, 1) 'get a letter„'requirements..„IF ASC(c$) < 127 THEN 'below 127„ IF c$ <> CHR$(94) THEN 'not an exponent symbol (this is used for CR/LF's„  IF c$ = CHR$(34) THEN„   fin$ = fin$ + CHR$(125) 'fix the quotation mark bug (change to curleybrace)„  ELSE„   fin$ = fin$ + c$ 'we are only here if the character is accepted„  END IF„ END IF„END IF„NEXT b„fin$ = fin$ + CHR$(94) 'add a line-end character, because it has to be :)„tot = tot + 1 'line count..prolly not needed„PRINT #2, fin$; 'NO CR/LF's! (a CR/LF is converted to the exp symbol„LOOP„CLOSE 'close files„PRINT "..."; 'let you know you're still alive„OPEN tfile$ FOR BINARY AS #1 'temp file with chr(94) for cr/lf's :)„OPEN tfile2$ FOR OUTPUT AS #2 'temp file with DATA's„tot2 = 0 'linecount 2„DO WHILE NOT EOF(1)  'keep it comin'„v$ = STRING$(maxwid, " ") 'an area to get„GET #1, , v$ 'get a run of letters„PRINT #2, "DATA " + CHR$(34) + v$ + CHR$(34) 'assemble a DATA command„tot2 = tot2 + 1 'increase linecount„LOOP„'PRINT #2, CHR$(34)„CLOSE„PRINT "..."; 'still alive :)„OPEN tfile2$ FOR INPUT AS #1 'DATA command tempfile„OPEN out$ FOR OUTPUT AS #2 'final file with extractor info„t = 0„DO WHILE NOT EOF(1) 'another line count...„LINE INPUT #1, a$„t = t + 1„LOOP„SEEK #1, 1 'go to first spot„'write extractor code„PRINT #2, "' Text 2 Bas Extractor Code..."„PRINT #2, "lines="; t„PRINT #2, "outlines="; tot„PRINT #2, "ON ERROR GOTO 20"„PRINT #2, "FOR a = 1 TO lines: READ b$: NEXT a"„PRINT #2, "RESTORE"„PRINT #2, "INPUT "; CHR$(34); "Output File"; CHR$(34); "; a$"„PRINT #2, "OPEN a$ FOR OUTPUT AS #1"„PRINT #2, "FOR b = 1 TO lines"„PRINT #2, "READ c$"„PRINT #2, "FOR d = 1 TO LEN(c$)"„PRINT #2, "e$ = MID$(c$, d, 1)"„PRINT #2, "IF e$ = CHR$(94) THEN"„PRINT #2, "PRINT #1, "; CHR$(34); CHR$(34)„PRINT #2, "ELSEIF e$ = CHR$(125) THEN"„PRINT #2, "PRINT #1, CHR$(34);"„PRINT #2, "ELSE"„PRINT #2, "PRINT #1, e$;"„PRINT #2, "END IF"„PRINT #2, "NEXT d"„PRINT #2, "NEXT b"„PRINT #2, "PRINT "; CHR$(34); " Extraction Complete."; CHR$(34)„PRINT #2, "CLOSE : END"„PRINT #2, "20 PRINT "; CHR$(34); "Text 2 Bas Data Corrupted!"; CHR$(34); ": END"„'the plus CHR$(34) is 'cause you can't do: PRINT " print "Hello World!"" :)„PRINT #2, "' Text 2 Bas Extractor Data..." 'remark for clarity„FOR a = 1 TO t 'copy in the data commands in the temp file 2„LINE INPUT #1, d$„PRINT #2, d$„NEXT a„PRINT #2, "' End of Text 2 Bas Extractor Data" 'clarity„CLOSE 'finish up„„PRINT "Tx2bas Complete!" 'info„KILL tfile$ 'temp file erase„KILL tfile2$ 'again„END„„Ray Carson                     SCROLL SCREEN LEFT/RIGHT       QBTIPS_T.DOC                   12-08-93 (09:13)       QB, QBasic, PDS        75   2859     SCROLL.BAS  '> I know how to scroll the screen UP and DOWN by using„'> interrupts, but I can't find a way do make it scroll left„'> and right like in Lotus 1-2-3, etc...„'> If you know if it's possible, or how to do it, leave me a message„ „'The following code is slow in the IDE but is reasonably fast when„'compiled to an .EXE. You will lose characters that are scrolled off„'of the screen unless you put them into an array or if you are working„'with known data (arrays/fields) then just reprint. I Hope long lines„'don't get wrapped!„ „DEFINT A-Z      'SCROLL.BAS ~ Ray Carson ~ 1993„DECLARE SUB Scroll (UpperRow, LowerRow, Columns, Direction)„COLOR 15, 1: CLS„LOCATE 4, 2: PRINT CHR$(218); STRING$(76, CHR$(196)); CHR$(191);„LOCATE 8, 2: PRINT CHR$(192); STRING$(76, CHR$(196)); CHR$(217);„FOR X = 5 TO 7„    LOCATE X, 2: PRINT CHR$(179);„    LOCATE X, 79: PRINT CHR$(179);„NEXT„COLOR 14, 1„LOCATE 5, 32: PRINT "RC Software";„LOCATE 6, 32: PRINT "1113 Hillcrest";„LOCATE 7, 32: PRINT "Conroe, Texas 77301";„COLOR 2, 1„LOCATE 6, 10: PRINT "(409)756-6860";„LOCATE 6, 60: PRINT "(409)441-5096";„COLOR 20, 1: LOCATE 10, 35: PRINT "Press Key";„DO: LOOP UNTIL LEN(INKEY$)„CALL Scroll(5, 6, 10, 0)  ' Direction 0 = right„DO: LOOP UNTIL LEN(INKEY$)„CALL Scroll(5, 6, 10, -1) ' Direction -1 = left„COLOR 15, 1: LOCATE 10, 35: PRINT "  Done   ";„ „SUB Scroll (UpperRow, LowerRow, Columns, Direction)„ „    DEF SEG = 0„    Address = PEEK(1040) AND 48„    IF Address = 48 THEN„        DEF SEG = &HB000    'mono„    ELSE„        DEF SEG = &HB800    'color„    END IF„    FOR X = 1 TO Columns„        IF Direction = 0 THEN               'Right„            FOR Column = 79 TO 1 STEP -1    'move everything„                FOR Row = UpperRow TO LowerRow„                    Offset = ((Row - 1) * 80 + (Column - 1)) * 2„                    NewColumn = Column + 1„                    NewOffset = ((Row - 1) * 80 + (NewColumn - 1)) * 2„                    Char = PEEK(Offset)„                    Attr = PEEK(Offset + 1)„                    POKE NewOffset, Char„                    POKE NewOffset + 1, Attr„                    POKE Offset, 32„                NEXT„            NEXT„        END IF„        IF Direction = -1 THEN              'Left„            FOR Column = 2 TO 80            'move everything„                FOR Row = UpperRow TO LowerRow„                    Offset = ((Row - 1) * 80 + (Column - 1)) * 2„                    NewColumn = Column - 1„                    NewOffset = ((Row - 1) * 80 + (NewColumn - 1)) * 2„                    Char = PEEK(Offset)„                    Attr = PEEK(Offset + 1)„                    POKE NewOffset, Char„                    POKE NewOffset + 1, Attr„                    POKE Offset, 32„                NEXT„            NEXT„        END IF„    NEXT„ „END SUB„Martijn van de Streek          DOCUMENT CODER/DECODER         FidoNet QUIK_BAS Echo          11-25-96 (13:37)       QB, QBasic, PDS        152  5103     DOCCOD.BAS  'I've finished translating and editing the coding program. There was a little „'bug in the program after I had altered the coding mechanism, so it took a bit „'longer than it had to. „'Here's the code: „ „'=============== Begin of program „DECLARE SUB LOOKFILE (ARG$) „DECLARE FUNCTION DECode$ (Variabele$) „DECLARE FUNCTION Code$ (Variabele$) „ON ERROR GOTO Errhand „ „' === Program Header === „PRINT „COLOR 15, 0: PRINT DECode$("epD"); : COLOR 7, 0: PRINT DECode$("xqgnu") „COLOR 15, 0: PRINT DECode$("hrE! "); : COLOR 7, 0: „PRINT DECode$("=:=*wwpywiy" + CHR$(34) + "se"); „PRINT „ „'== Reading parameters... == „CoMMa$ = LTRIM$(RTRIM$(COMMAND$)) + " " „FOR Temp = 1 TO LEN(CoMMa$) „  IF MID$(CoMMa$, Temp, 1) = " " THEN Cmds% = Cmds% + 1 „NEXT Temp „'More or less than 3 parameters? „IF Cmds% < 3 THEN GOTO UserHelp „IF Cmds% > 3 THEN GOTO UserHelp „IF MID$(CoMMa$, 1, 1) = "C" THEN Add% = 1 'If first parameter is C, then „                                          'Code the file. „ „IF MID$(CoMMa$, 1, 1) = "D" THEN Re% = 1  'If first parameter is D, then „                                          'Decode the file. „IF Add% + Re% = 0 THEN GOTO UserHelp      'If first parameter <> C OR D then „                                          'display some help „'find begin of first filename „FOR Temp = 3 TO LEN(CoMMa$) „  IF MID$(CoMMa$, Temp, 1) = " " THEN EXIT FOR „NEXT Temp „FOR B1% = Temp + 1 TO LEN(CoMMa$) „  IF MID$(CoMMa$, B1%, 1) = " " THEN EXIT FOR „NEXT B1% „File1$ = MID$(CoMMa$, 3, Temp - 3) „File2$ = MID$(CoMMa$, Temp + 1, B1% - Temp - 1) „IF Add% = 1 THEN GOTO Add „IF Re% = 1 THEN GOTO ReWrite „GOTO UserHelp „ „Add: „'=== Code-a-file === „IF NOT File1$ <> File2$ THEN PRINT "Can't read from "; File1$; " and write to"; PRINT "Secure with pasword? (Y/N)" „passWord$ = "" „PasYN$ = INPUT$(1) „IF UCASE$(PasYN$) = "Y" THEN „  PRINT "Typ het paswoord in:"; : COLOR 0, 0 „  INPUT "", passWord$: COLOR 7, 0 „  IF passWord$ = "" THEN PRINT "ERROR: Invalid pasword": END „  PRINT "Retype password:"; : COLOR 0, 0 „  INPUT "", PasswordControl$: COLOR 7, 0 „  IF PasswordControl$ <> passWord$ THEN „     PRINT "ERROR: Pasword check failed": END „  END IF „END IF „PassWrd$ = passWord$ + SPACE$(80 - LEN(passWord$)) „OPEN File1$ FOR INPUT AS #1        'This file comes the information from „OPEN File2$ FOR OUTPUT AS #2       'and this file is where the information „                                   'goes to... „  PRINT #2, Code$("Coded file by DOCOD.")' give file initialisation code for „                                         ' decoding... „  PRINT #2, Code$(PassWrd$) „regnr% = 0 „PRINT „Rownr% = CSRLIN - 1 „DO WHILE NOT EOF(1) „  LINE INPUT #1, Rec$              'Read, „  PRINT #2, Code$(Rec$)            'Code and write „  regnr% = regnr% + 1 „  LOCATE Rownr%, 1: „  PRINT "Coding line:"; regnr% „LOOP „CLOSE #1 „CLOSE #2 „PRINT "Done." „END „ „ReWrite: „'=== DECode-a-file === „IF NOT File1$ <> File2$ THEN PRINT "Can't read file "; File1$; " and write to file."„OPEN File1$ FOR INPUT AS #1        'This is where the info comes from . . .„LINE INPUT #1, Rec$                'Read and check for right file format... „IF Rec$ <> Code$("Coded file by DOCOD.") THEN PRINT "ERROR: Not a DOCOD File.":  „LINE INPUT #1, Rec$                'Read a line . . . „IF Rec$ <> "" THEN „  PRINT "Password:"; : COLOR 0, 0 „  INPUT "", passWord$: COLOR 7, 0 „  IF passWord$ <> LTRIM$(RTRIM$(DECode$(Rec$))) THEN PRINT "ERROR: Wrong password„END IF„OPEN File2$ FOR OUTPUT AS #2       'And this is where it goes „regnr% = 0 „Rownr% = CSRLIN „PRINT „Rownr% = Rownr% - 1 „DO WHILE NOT EOF(1) „  LINE INPUT #1, Rec$              'Reading... „  PRINT #2, DECode$(Rec$)          'DECoding, and rewriting... „  regnr% = regnr% + 1 „  LOCATE Rownr%, 1: „  PRINT "Uncoding line:"; regnr%    'show the line number... „LOOP „CLOSE #1 „CLOSE #2 „PRINT "Done." „END „ „UserHelp: „PRINT "Usage:   CODOC.EXE c source.ext target.ext       -> Codes text files." „PRINT "         CODOC.EXE d source.ext target.ext       -> Decodes text files."„PRINT : PRINT "Only use CoDoc on TEXT-files, not binary ones !! (it corrupts the file)"„END„ „Errhand: „IF ERR = 53 THEN PRINT "ERROR: File not found": END „IF ERR = 64 THEN PRINT "ERROR: Invalid filename": END „CLS „PRINT "Error:"; ERR „END „ „ „FUNCTION Code$ (Variabele$) „FOR Temp = 1 TO LEN(Variabele$)„„  NewCh$ = CHR$((ASC(MID$(Variabele$, Temp, 1)) + Temp) - 1) „  Newvar$ = Newvar$ + NewCh$ „NEXT Temp „FOR Temp = LEN(Newvar$) TO 1 STEP -1 „  NewCh$ = MID$(Newvar$, Temp, 1) „  NewVar2$ = NewVar2$ + NewCh$ „NEXT Temp „ „Code$ = NewVar2$ „END FUNCTION „ „FUNCTION DECode$ (Variabele$) „FOR Temp = LEN(Variabele$) TO 1 STEP -1 „  NewCh$ = MID$(Variabele$, Temp, 1) „  NewVar2$ = NewVar2$ + NewCh$ „NEXT Temp „FOR Temp = 1 TO LEN(NewVar2$) „  NewCh$ = CHR$(1 + (ASC(MID$(NewVar2$, Temp, 1)) - Temp)) „  Newvar$ = Newvar$ + NewCh$ „NEXT Temp „DECode$ = Newvar$ „END FUNCTION „'================ End of program „Aaron Clausen                  INPUT FIELD ROUTINE            aaronc@freenet.alberni.net     12-13-96 (21:00)       QB, QBasic, PDS        124  3588     INPUT.BAS   ' Here is a quick and dirty input routine that I originally developed for„' entering phone numbers.„„DECLARE FUNCTION PInput$ (Picture$)„„DEFINT A-Z„' # number„' ! alpha„' % alpha-numeric„' & uppercase alpha„' * lowercase alpha„'„' All other characters will be seen as literals and will be displayed.„'„' Eg. Phone$ = PInput$("(###) ###-####")„'„FUNCTION PInput$ (Picture$)„„  tString$ = ""„  Length = LEN(Picture$)„  StartRow = CSRLIN„  StartCol = POS(0)„„  FOR CharCount = 1 TO Length„    IF INSTR("#!%&*", MID$(Picture$, CharCount, 1)) THEN„      tString$ = tString$ + " "„      PRINT " ";„    ELSE„      tString$ = tString$ + MID$(Picture$, CharCount, 1)„      PRINT MID$(Picture$, CharCount, 1);„    END IF„  NEXT CharCount„„  LOCATE StartRow, StartCol, 1„„  ExitFlag = 0„  GetKeyFlag = -1„  CharCount = 0„„  DO„    IF GetKeyFlag THEN„      DO„        HitKey$ = INKEY$„      LOOP UNTIL HitKey$ <> ""„    ELSE„      GetKeyFlag = -1„    END IF„„    KeyVal = ASC(HitKey$)„    SELECT CASE KeyVal„      CASE 8„        IF CharCount >= 0 AND CharCount <= (Length + 1) THEN„          IF CharCount > 0 THEN„            SELECT CASE MID$(Picture$, CharCount, 1)„              CASE "#", "!", "%", "&", "*"„                LOCATE CSRLIN, POS(0) - 1„                PRINT " ";„                LOCATE CSRLIN, POS(0) - 1„                MID$(tString$, CharCount, 1) = " "„                CharCount = CharCount - 1„              CASE ELSE„                LOCATE CSRLIN, POS(0) - 1„                GetKeyFlag = 0„                CharCount = CharCount - 1„            END SELECT„          END IF„        ELSE„„        END IF„      CASE 13„        ExitFlag = -1„      CASE 32 TO 127„        CharCount = CharCount + 1„        IF CharCount <= Length THEN„          SELECT CASE MID$(Picture$, CharCount, 1)„            CASE "#"„              IF (KeyVal = 45 OR KeyVal = 46) OR (KeyVal >= 48 AND KeyVal <= 57) THEN„                MID$(tString$, CharCount, 1) = HitKey$„                PRINT HitKey$;„              ELSE„                CharCount = CharCount - 1„              END IF„            CASE "!"„              IF (KeyVal >= 65 AND KeyVal <= 90) OR (KeyVal >= 97 AND KeyVal <= 122) THEN„                MID$(tString$, CharCount, 1) = HitKey$„                PRINT HitKey$;„              ELSE„                CharCount = CharCount - 1„              END IF„            CASE "%"„              MID$(tString$, CharCount, 1) = HitKey$„              PRINT HitKey$;„            CASE "&"„              IF (KeyVal >= 65 AND KeyVal <= 90) OR (KeyVal >= 97 AND KeyVal <= 122) THEN„                HitKey$ = UCASE$(HitKey$)„                MID$(tString$, CharCount, 1) = HitKey$„                PRINT HitKey$;„              ELSE„                CharCount = CharCount - 1„              END IF„            CASE "*"„              IF (KeyVal >= 65 AND KeyVal <= 90) OR (KeyVal >= 97 AND KeyVal <= 122) THEN„                HitKey$ = LCASE$(HitKey$)„                MID$(tString$, CharCount, 1) = HitKey$„                PRINT HitKey$;„              ELSE„                CharCount = CharCount - 1„              END IF„            CASE ELSE„              GetKeyFlag = 0„              MID$(tString$, CharCount, 1) = MID$(Picture$, CharCount, 1)„              PRINT MID$(Picture$, CharCount, 1);„          END SELECT„        ELSE„          IF CharCount > Length THEN CharCount = Length„        END IF„    END SELECT„  LOOP UNTIL ExitFlag„„  LOCATE , , 0„  PRINT„  PInput$ = tString$„„END FUNCTION„Kurt Kuzba                     SEARCH AND REPLACE STRING      FidoNet QUIK_BAS Echo          12-24-96 (14:46)       QB, QBasic, PDS        39   1502     SANDR.BAS   '>   I already submitted a short program to search and replace„'>   instances of any combination of characters.  (The person„'>   asking was asking for code to s/r %? codes.)  (I didn't„'>   keep a copy of it.. darnit.... oh well.)„'>   I was basically saying that INSTR only tells you where„'>   the text starts at, as I interpreted the message as„'>   referring to INSTR searching and replacing...„'>.....„'   Right. You have to find the end of the word yourself.„'Since you already know the length of it, though, that is easy.„„'_|_|_|   SANDR.BAS„'_|_|_|   A simple search and replace for QBasic strings.„'_|_|_|   No warrantee or guarantee is given or implied.„'_|_|_|   Released   PUBLIC DOMAIN   by Kurt Kuzba.  (12/24/96)„DECLARE SUB SandR (text$, OldT$, NewT$)„PRINT CHR$(13); "Begin Search and Replace test."„text$ = "Ellie's groovy boot reserves flavors"„PRINT text$„OldWord$ = "boot": NewWord$ = "boy": rl% = LEN(OldWord$)„SandR text$, "ellie's", "Every"„PRINT text$„SandR text$, "groovy", "Good"„PRINT text$„SandR text$, "boot", "Boy"„PRINT text$„SandR text$, "reserves", "Deserves"„PRINT text$„SandR text$, "flavors", "Favor"„PRINT text$„SUB SandR (text$, OldT$, NewT$)„   rl% = LEN(OldT$): found% = INSTR(UCASE$(text$), UCASE$(OldT$))„   IF found% THEN„      part1$ = "": IF found% > 1 THEN part1$ = LEFT$(text$, found% - 1)„      part2$ = MID$(text$, found% + rl%)„      text$ = part1$ + NewT$ + part2$„   END IF„END SUB„'_|_|_|   end   SANDR.BAS„Denis Boyles                   PRINT BIG TEXT LETTERS         FidoNet QUIK_BAS Echo          01-05-97 (19:11)       QB, QBasic, PDS        44   1095     BIGHIYA.BAS '==========================================================================„'PROGRAM: BIGHIYA.BAS„' AUTHOR: Denis Boyles„„'RELEASE: Public Domain (pd) Jan 5, 1997„'VERSION: 1.10„„'COMPILE: Microsoft qBASIC v1.1„'     OS: MS-DOS (v6.20)„„'PURPOSE: use BIOS's CGA ROM font to print out BIG text letters :)„'  NOTES: based on my assembly version, based on my C version :)„'==========================================================================„„DECLARE SUB PrintBigText (text$)„„CLS„PrintBigText "Hi,World!"„„DEFINT A-Z„SUB PrintBigText (text$)„  DEF SEG = &HF000„  bits$ = CHR$(128) + CHR$(64) + CHR$(32) + CHR$(16) + CHR$(8) + CHR$(4) + CHR$(2) + CHR$(1)„  IF LEN(text$) > 9 THEN„    slen = 9„  ELSE„    slen = LEN(text$)„  END IF„„  FOR y = 0 TO 7„    a$ = ""„    FOR ct = 1 TO slen„      byte = PEEK(&HFA6E + ASC(MID$(text$, ct, 1)) * 8 + y)„      FOR x = 1 TO 8„        IF byte AND ASC(MID$(bits$, x, 1)) THEN„          a$ = a$ + CHR$(219)„        ELSE„          a$ = a$ + CHR$(32)„        END IF„      NEXT„    NEXT„    PRINT a$„  NEXT„END SUB„Brian Bacon                    MULTI-LINE EDIT                FidoNet QUIK_BAS Echo          01-01-97 (22:23)       QB, QBasic, PDS        175  6373     MLEDIT.BAS  'Multi-line edit„DECLARE SUB MLedit (Text$(), Row, Col, Ln, Hg, Fg, Bg, KeyCode)„' Row, Col - Row/Col of upper left corner„' Ln - Max length of each line„' Hg - Total number of lines to edit„' Fg, Bg - foreground/background color of edit box„' KeyCode - Key used to exit (27=esc, 13=ctrl-enter or max lines„'                            reached)„'„' This routine exits if you hit ENTER on the last edit-able line„DIM SHARED TypeOver„TypeOver = 1  ' On„TypeOver = -2 ' Off„„CLS„DIM T$(20)„T$(1) = "Press ESC to abort"„T$(2) = "Press CTRL-ENTER to end editing"„T$(3) = "Press HOME or END to go to the Beginning/End of the line"„T$(4) = "Press CTRL-HOMEor CTRL-END to go to the Beginning/End of "„T$(4) = T$(4) + "the input"„T$(5) = "Use the cursor keys to move around."„T$(6) = "Unfortunatly MLedit doesnt support word wrapping."„T$(7) = "You can use INS and DEL though.. and BACKSPACE will work"„T$(7) = T$(7) + " ANYWHERE"„MLedit T$(), 1, 1, 80, 20, 15, 1, KC„„'Multi-Line Edit by Brian Bacon„SUB MLedit (Text$(), Row, Col, Ln, Hg, Fg, Bg, KeyCode)„    COLOR Fg, Bg„    FOR I = 0 TO Hg - 1„        LOCATE Row + I, Col„        PRINT SPACE$(Ln)„    NEXT I„    LOCATE Row, Col„    FOR I = 1 TO UBOUND(Text$)„        PRINT Text$(I)„    NEXT I„    FOR I = 1 TO UBOUND(Text$)„        IF Text$(I) <> "" THEN f = I„    NEXT I„    c = Col + LEN(Text$(f))„    r = Row + f - 1„    EdN = f„    DIM EdText$(UBOUND(Text$))„    FOR I = 1 TO UBOUND(Text$)„        EdText$(I) = Text$(I)„    NEXT I„    DEF SEG = 0„    IF PEEK(&H463) = &HB4 THEN„       CsrSize = 12„    ELSE„       CsrSize = 7„    END IF„    DEF SEG„    DO„      IF TypeOver = 1 THEN„         TopLine = CsrSize \ 2„      ELSE„         TopLine = CsrSize - 1„      END IF„      LOCATE r, c, 1, TopLine, CsrSize„      DO„        A$ = INKEY$„      LOOP UNTIL LEN(A$)„      SELECT CASE A$„             CASE CHR$(27): KeyCode = 27: EXIT SUB„             CASE CHR$(10) 'Ctrl-Enter„                     KeyCode = 13„                     FOR I = 1 TO UBOUND(Text$)„                         EdText$(I) = Text$(I)„                     NEXT I„                     EXIT SUB„             CASE CHR$(13)„                  IF EdN = UBOUND(Text$) THEN„                     KeyCode = 13„                     FOR I = 1 TO UBOUND(Text$)„                         EdText$(I) = Text$(I)„                     NEXT I„                     EXIT SUB„                  ELSE„                     EdN = EdN + 1„                     r = r + 1„                     c = Col„                  END IF„             CASE CHR$(0) + CHR$(&H4D) 'right„                  IF c = Col + Ln - 1 AND r = Row + Hg - 1 THEN„                     BEEP„                  ELSEIF c = Col + Ln - 1 AND r < Row + Hg - 1 THEN„                     r = r + 1„                     c = Col„                     EdN = EdN + 1„                  ELSE„                     c = c + 1„                  END IF„             CASE CHR$(0) + CHR$(&H4B) 'left„                  IF c = Col AND r = Row THEN„                     BEEP„                  ELSEIF c = Col AND r > Row THEN„                     r = r - 1„                     c = Col + Ln - 1„                     EdN = EdN - 1„                  ELSE„                     c = c - 1„                  END IF„             CASE CHR$(0) + CHR$(&H48) 'up„                  IF r = Row THEN BEEP ELSE r = r - 1: EdN = EdN - 1„             CASE CHR$(0) + CHR$(&H50) 'down„                  IF r = Row + Hg - 1 THEN„                     BEEP„                  ELSE r = r + 1„                     EdN = EdN + 1„                  END IF„             CASE CHR$(0) + CHR$(&H4F) 'end„                  c = Col + Ln - 1„             CASE CHR$(0) + CHR$(&H47) 'home„                  c = Col„             CASE CHR$(0) + CHR$(&H53) 'del„                  IF LEN(EdText$(EdN)) > 0 THEN„                     EdText$(EdN) = LEFT$(EdText$(EdN), c - Col) + MID$(EdText$(EdN), c - Col + 2)„                     LOCATE Row + EdN - 1, Col„                     PRINT SPACE$(Ln)„                     LOCATE Row + EdN - 1, Col„                     PRINT EdText$(EdN)„                  END IF„             CASE CHR$(0) + CHR$(&H52) 'ins„                  TypeOver = NOT TypeOver„             CASE CHR$(0) + CHR$(119) 'ctrl-home„                  r = Row: c = Col: EdN = 1„             CASE CHR$(0) + CHR$(117) 'ctrl-end„                  r = Row + Hg - 1: c = Col + Ln - 1„                  EdN = UBOUND(Text$)„             CASE CHR$(8)„                  IF LEN(EdText$(EdN)) > 0 AND c > 1 THEN„                     EdText$(EdN) = LEFT$(EdText$(EdN), c - 1 - Col) + MID$(EdText$(EdN), c - Col + 1)„                     LOCATE Row + EdN - 1, Col„                     PRINT SPACE$(Ln)„                     LOCATE Row + EdN - 1, Col„                     PRINT EdText$(EdN)„                     c = c - 1„                  ELSEIF EdN > 1 THEN„                     EdN = EdN - 1„                     c = LEN(EdText$(EdN)) + Col„                     IF c = 81 THEN c = 80„                     r = r - 1„                  END IF„             CASE CHR$(32) TO CHR$(254)„                  IF TypeOver = 1 THEN„                     IF c - Col + 1 > LEN(EdText$(EdN)) THEN„                        EdText$(EdN) = EdText$(EdN)„                     END IF„                     MID$(EdText$(EdN), c - Col + 1) = A$„                  ELSE„                     EdText$(EdN) = EdText$(EdN) + SPACE$(Ln - LEN(EdText$(EdN)))„                     EdText$(EdN) = LEFT$(EdText$(EdN), c - Col) + A$ + MID$(EdText$(EdN), c - Col + 1)„                     EdText$(EdN) = RTRIM$(EdText$(EdN))„                     IF LEN(EdText$(EdN)) > Ln THEN EdText$(EdN) = LEFT$(EdText$(EdN), Ln)„                  END IF„                  LOCATE r, Col„                  PRINT SPACE$(Ln)„                  LOCATE r, Col„                  PRINT EdText$(EdN)„                  c = c + 1„                  IF c - Col + 1 > Ln THEN„                     r = r + 1„                     c = Col„                     IF r - Row + 1 > Hg THEN„                        r = r - 1„                        c = Col + Ln - 1„                     END IF„                     EdN = r - Row + 1„                  END IF„     END SELECT„   LOOP„END SUB„Nick Kochakian                 TEXT SCROLLER V2.0             NickK@worldnet.att.net         01-20-97 (16:40)       QB, QBasic, PDS        109  2893     TEXTSCR2.BASDECLARE SUB TEXTSCRL (TEXT$, WAY%, DELY%, X%, Y%, CHARS%)„'----------------------------------------------------------------------------„'Program name:  Text scroll„'Verison:  verison 2.0„'„'Date made:  1/20/97, 1997„'„'Author: - Nick Kochakian -„'„'Changes:„'- Some scrolling text dosen't have an 78 character maximum.„'  The unlimited text also never stops unless you press a key„'„'This program will scroll a text string up to 78 characters MAXIMUM!„'If you have any questions or comments on this program or any others„'please E-mail me at:„'„'nickK@worldnet.att.net„'„'You can use this program in your program but PLEASE give me credit where„'it is deserved the most!„'Thanks! :)„'----------------------------------------------------------------------------„„CLS„„TEXT$ = "Text scroller verison 2.0 by: - Nick Kochakian -  1997  "„'Leave 2 spaces at the end if you are using scrolling off the screen to the„'left„„'To add color to the scrolling text just use the regular COLOR command„'BEFORE you call TEXTSCRL„„CALL TEXTSCRL(TEXT$, 1, 9999, 1, 1, 0)„SLEEP 1„CALL TEXTSCRL(TEXT$, 3, 9999, 1, 1, 0)„SLEEP 1„CALL TEXTSCRL(TEXT$, 2, 9999, 1, 1, 0)„SLEEP 1„TEXT$ = "Text scroller verison 2.0 by: - Nick Kochakian - 1997      If you have any comments or questions please e-mail me at:  nickK@worldnet.att.net        Thanks! :)                            "„CALL TEXTSCRL(TEXT$, 4, 9999, 1, 1, 80)„„'TEXT$ - Is the text string„'WAY% - Is the way to scroll it:„'       1 = Typing effect (left to right)„'       2 = Scrolls the text on from the left side of the screen„'       3 = Scrolls the text off the screen. (Moves it to the left)„'       4 = The everlasting scroll. Only ends when you press a key.„'DELY% - Is the delay I use 9999 as the delay for my Pentium 60.„'        If the delay dosen't slow it down enough then add your own or„'        copy / paste the original delay 1 or 2 times!„'X% - Is the X position of the text on the screen„'Y% - Is the Y position of the text on the screen„'„'„'CHARS% - Is the number of characters to display at one time when using„'         WAY 4. Otherwise, set to zero or whatever.„„SUB TEXTSCRL (TEXT$, WAY%, DELY%, X%, Y%, CHARS%)„„IF WAY% = 1 THEN„MAXCHR = LEN(TEXT$)„FOR I = 1 TO MAXCHR„LOCATE X%, Y%: PRINT LEFT$(TEXT$, I)„„FOR A = 1 TO DELY%„NEXT A„„NEXT I„END IF„„IF WAY% = 2 THEN„MAXCHR = LEN(TEXT$)„FOR I = 1 TO MAXCHR„LOCATE X%, Y%: PRINT RIGHT$(TEXT$, I)„„FOR A = 1 TO DELY%„NEXT A„„NEXT I„END IF„„IF WAY% = 3 THEN„MAXCHR = LEN(TEXT$)„FOR I = 1 TO MAXCHR„LOCATE X%, Y%: PRINT MID$(TEXT$, I)„„FOR A = 1 TO DELY%„NEXT A„„NEXT I„„END IF„„IF WAY% = 4 THEN„I = 1„MAXCHR = LEN(TEXT$)„DO„LOCATE X%, Y%: PRINT MID$(TEXT$ + TEXT$, I, CHARS%)„I = I + 1„IF I > MAXCHR THEN I = 1„FOR A = 1 TO DELY%„NEXT A„LOOP UNTIL INKEY$ <> ""„„END IF„„END SUB„„Byron Smith                    BLINK OFF                      unol@sat.net                   01-25-97 (16:41)       QB, QBasic, PDS        8    204      BLINKOFF.BASSCREEN 0: WIDTH 80, 25: CLS„REDIM ML&(1)„ML&(0) = &HB31003B8„ML&(1) = &HCB10CD00„DEF SEG = VARSEG(ML&(0))„CALL ABSOLUTE(VARPTR(ML&(0)))„ERASE ML&„COLOR 1 + 16, 6: PRINT "Unol@sat.net": COLOR 7, 0„Christopher S. Wyatt           TEXT RITE (EDITOR)             alt.lang.basic                 01-31-97 (09:45)       QB, QBasic, PDS        1471 43995    TEXTRITE.BAS'>Can someone please send me a simple text editor in plain Basic (QBasic or„'>QB45) code. It must have the ability to print on paper, on screen; load„'>files; save files; edit files;; all in a simple code. I am trying to learn„'>this language, but I need some good examples.„'>I will probably use this txt editor for my own purposes and not for any„'>distribution of any sort.„„'I never finished this program -- I was adding a cut, copy paste„'feature -- but it is functional. I stopped programming when DOS„'started to ship with a REAL editor, not EDLIN. I used Text Rite for„'years, installing it on every machine I used.„„'It runs under QBASIC, QuickBasic, and PowerBASIC. Note: For PB,„'you have to change calls to PCOPY... but that's easy, it's well„'documented in the manual. I've tested it, and it does work.„„'If anyone would like to continue the Text Rite challenge (a„'good BASIC editor) let me know. I'd love to see this done, if„'just to prove BASIC isn't a toy.„„'Again, I was going to add: CUT/COPY/PASTE, and MOUSE calls.„'I realized AFTER I wrote the code that the menu routines were„'sloppy; I have since re-written them to be more logical. My„'newer (two or three years old!) menu routines are a lot easier„'to read and modify. I switched to TYPEd variables to enable a help„'string for each menu item.„„'It's old and ugly, but here goes nothing:„„' Text Rite Version 2.24.00B  (15 Jul 1992)„' (c) 1984-1992 Student Oriented Software„' by C. S. Wyatt„„' =====>  Variable Types  <=====„	DEFINT A-Z„	DECLARE SUB DelFile ()„	DECLARE SUB DelLine (row)„	DECLARE SUB DelText ()„	DECLARE SUB FileDir ()„	DECLARE SUB FindRepl (itemnum)„	DECLARE SUB InputBox (inprompt$, answerlen, col, row, hide, answer$)„	DECLARE SUB InputText (answer$, answerlen, col, row, hide)„	DECLARE SUB InsLine (row)„	DECLARE SUB ItemBox (box$(), col, row, itemnum)„	DECLARE SUB LoadMode ()„	DECLARE SUB MakeMenu ()„	DECLARE SUB MenuCall ()„	DECLARE SUB MenuBox ()„	DECLARE SUB MainScreen ()„	DECLARE SUB NewFile ()„	DECLARE SUB NewText (edline)„	DECLARE SUB PosText (itemnum)„	DECLARE SUB PrintMode (itemnum)„    DECLARE SUB PrintSetup (pglines, topmar, btmar, leftmar, startnum, nummode)„	DECLARE SUB SaveLine ()„	DECLARE SUB SaveMode ()„	DECLARE SUB TextWrap ()„„' =====>  Screen Color Variables      <=====„    bcolor = 0:                              ' Background color (0-7)„    fcolor = 7:                              ' Foreground color (Text) (0-7)„    mcolor = 7:                              ' Menu bar color (0-7)„' =====>  Generic & Editor Variables  <=====„	a = 0:                                   ' Generic numeric value„	a$ = "":                                 ' Generic string„	linelen = 60:                            ' Line length„	newscrn = 0:                             ' Update text on ccreen„	insmode = 1:                             ' Insert Mode On„	scrnline = 3:                            ' Screen line marker„	scrncol = 1:                             ' Screen row marker„	edline = 1:                              ' Line being edited„' =====>  Editing Variables           <=====„	blockbeg = -1:                           ' Edit block (start)„	blockbch = -1:                           ' Edit block (start char)„	blockend = -1:                           ' Edit block (end)„	blockech = -1:                           ' Edit block (end char)„	blockmode = 0:                           ' Block mode toggle„	pasteallow = 0:                          ' Paste active toggle„	blockflag = 0:                           ' Block mode flag„' =====>  MakeMenu Variables          <=====„	CONST maxmenu = 10:                      ' Last declared menu (-1)„	CONST maxitem = 12:                      ' Maximum menu items (+2)„	menubar$ = "  ":                         ' Begin building menus„' =====>  I/O and Printer Variables   <=====„	filespec$ = "<NONE>":                    ' File selected„' =====>  Arrays and Such             <=====„	DIM SHARED menu$(maxmenu, maxitem):      ' Define menu array (11x10)„	'$DYNAMIC„	DIM SHARED ibox$(1):                     ' Array for item menus„	DIM SHARED scandir(1) AS STRING * 12:    ' Set # of files„	DIM SHARED doctxt(600) AS STRING:        ' Document Text„ „	CALL MakeMenu„„IF COMMAND$ <> "" THEN„	 ON ERROR GOTO ErrorTrap„	 filespec$ = COMMAND$„	 scrncol = -1„	 CALL LoadMode„	 END IF„„ProgramStart:„	ON ERROR GOTO ErrorTrap„	CALL MainScreen„	edline = 1„	CALL NewText(1)„„MainLoop:„	DO WHILE 1„		 a$ = "": exkey = 0„		 COLOR bcolor + (8 * insmode), mcolor + (8 * insmode)„		 LOCATE scrnline, scrncol„		 PRINT CHR$(SCREEN(scrnline, scrncol));„		 VIEW PRINT„		 LOCATE 1, 65„		 PRINT USING "###:##"; edline; scrncol;„		 LOCATE 1, 75„		 IF blockmode = 1 THEN„				PRINT "BLK";„				ELSE„				IF insmode = 1 THEN PRINT "INS";  ELSE PRINT "   ";„				END IF„		 VIEW PRINT 3 TO 23„		 WHILE a$ = ""„			 a$ = INKEY$„			 COLOR mcolor + 8, bcolor„			 LOCATE 25, 45, 0: PRINT "Date: "; DATE$;„			 LOCATE 25, 65: PRINT "Time: "; TIME$;„			 COLOR fcolor, bcolor„			 IF blockmode = 1 THEN COLOR bcolor, fcolor„			 WEND„		 IF blockmode = 1 THEN„				blockend = edline:    ' Edit block (end)„				blockech = scrncol:   ' Edit block (end char)„				CALL NewText(edline + 3 - scrnline)„				END IF„		 LOCATE scrnline, scrncol„		 PRINT CHR$(SCREEN(scrnline, scrncol));„		 IF scrnline = 23 THEN„				CALL SaveLine„				CALL NewText(edline)„				scrnline = 3„				END IF„		 IF a$ = CHR$(27) THEN a$ = CHR$(27) + CHR$(33): ' ESC = ALT-F„		 IF LEN(a$) > 1 THEN„				exkey = ASC(RIGHT$(a$, 1))„			 IF exkey <> 75 AND exkey <> 77 AND exkey <> 82 THEN CALL SaveLine„				IF exkey = 18 THEN exkey = 60: ' ALT - E„				IF exkey = 33 THEN exkey = 65: ' ALT - F„				IF exkey = 24 THEN exkey = 64: ' ALT - O„				IF exkey = 25 THEN exkey = 61: ' ALT - P„				IF exkey = 20 THEN exkey = 63: ' ALT - T„				IF exkey > 58 AND exkey < 69 THEN„					 IF menu$(exkey - 59, 0) <> "" THEN„							menucalled = exkey - 59„							newscrn = 0„							blockflag = blockmode„							CALL MenuCall„							IF blockflag = 0 AND blockmode = 1 THEN„								 blockbeg = edline:    ' Edit block (start)„								 blockbch = scrncol:   ' Edit block (start char)„								 END IF„							IF newscrn = 1 THEN„								 CALL MainScreen„								 CALL NewText(edline)„								 END IF„							END IF„					 END IF„				IF exkey = 71 THEN„					 IF scrnline = 3 AND scrncol = 1 THEN„							edline = 1: scrnline = 3„							CALL NewText(edline)„							END IF„					 IF scrncol = 1 AND scrnline > 3 THEN„							a = scrnline - 3„							edline = edline - a„							IF edline < 1 THEN edline = 1„							scrnline = 3: scrncol = 1: ' Home„							CALL NewText(edline)„							END IF„					 IF scrncol > 1 THEN scrncol = 1„					 END IF„				IF exkey = 72 THEN„					 IF scrnline > 3 AND edline > 1 THEN„							scrnline = scrnline - 1„							edline = edline - 1„							ELSE„							IF edline > 1 THEN„								 edline = edline - 1„								 scrnline = 3„								 CALL NewText(edline)„								 END IF„							END IF„					 IF LEN(doctxt(edline)) < scrncol THEN exkey = 79„					 IF blockmode = 1 THEN„							blockend = edline:    ' Edit block (end)„							blockech = scrncol:   ' Edit block (end char)„							CALL NewText(edline + 3 - scrnline)„							END IF„					 END IF: ' Up„				IF exkey = 73 THEN„					 edline = edline - 19„					 scrnline = 3: scrncol = 1„					 IF edline < 1 THEN edline = 1„					 CALL NewText(edline)„					 END IF: ' PgUp„			 IF exkey = 75 AND scrncol > 1 THEN scrncol = scrncol - 1:  ' Left„				IF exkey = 77 AND scrncol < 78 THEN„				 IF SCREEN(scrnline, scrncol) <> 255 THEN scrncol = scrncol + 1„					 IF blockmode = 1 THEN„							blockend = edline:    ' Edit block (end)„							blockech = scrncol:   ' Edit block (end char)„							CALL NewText(edline + 3 - scrnline)„							END IF„					 END IF: ' Right„				IF exkey = 80 AND scrnline < 23 THEN„					 scrnline = scrnline + 1: edline = edline + 1: ' Down„					 IF blockmode = 1 THEN„							blockend = edline:    ' Edit block (end)„							blockech = scrncol:   ' Edit block (end char)„							CALL NewText(edline + 3 - scrnline)„							END IF„					 IF LEN(doctxt(edline)) < scrncol THEN exkey = 79„					 END IF„				IF exkey = 79 AND scrncol < 79 THEN„					 scrncol = LEN(RTRIM$(doctxt(edline))) + 1„					 IF scrncol > 1 THEN„					   IF SCREEN(scrnline, scrncol - 1) = 255 THEN scrncol = scrncol - 1„							END IF„					 END IF: ' End„				IF exkey = 81 THEN„					 scrnline = 3: scrncol = 1„					 edline = edline + 19„				 IF edline > UBOUND(doctxt, 1) THEN edline = UBOUND(doctxt, 1)„					 CALL NewText(edline)„					 END IF: ' PgDn„				IF exkey = 82 THEN insmode = (insmode XOR 1): ' Ins„				a$ = ""„				END IF„		 IF a$ <> "" THEN a = ASC(a$) ELSE a = 0„		 IF (a$ <> "" AND insmode = 1) OR exkey = 83 THEN„				b$ = ""„				FOR t = scrncol TO 80„						b$ = b$ + CHR$(SCREEN(scrnline, t))„						NEXT t„				b$ = RTRIM$(b$)„				IF b$ = "" THEN b$ = " "„				END IF„		 IF exkey = 83 THEN„				exkey = 0: ' Delete pressed„				CALL SaveLine„				IF LEN(RTRIM$(doctxt(edline))) = 0 AND scrncol = 1 THEN„					 CALL DelLine(1)„					 IF scrnline < 23 AND scrnline > 3 THEN„							FOR t = (scrnline - 1) TO 23„									LOCATE t, 1„									PRINT SPACE$(79);„									LOCATE t, 1„									b = edline + t - scrnline„									PRINT doctxt(b);„									NEXT t„							ELSE„							CALL NewText(edline)„							END IF„					 ELSE„					 IF scrncol < linelen THEN CALL DelText„					 END IF„				END IF„		 IF a = 8 THEN„				scrncol = scrncol + (scrncol > 1): ' Backspace„				LOCATE scrnline, scrncol„				PRINT b$; " ";„				a = 0: a$ = ""„				END IF„		 IF a = 9 THEN a$ = SPACE$(5 - (scrncol MOD 5)): ' Tab„		 IF scrncol > linelen THEN„				IF a$ = " " OR a$ = CHR$(13) THEN„					 a$ = CHR$(13)„					 LOCATE scrnline, scrncol„					 PRINT " ";„					 ELSE„					 CALL TextWrap„					 LOCATE scrnline, 1„					 PRINT a$;„					 CALL SaveLine„					 a$ = ""„					 END IF„				END IF„		 IF a = 13 THEN„				LOCATE scrnline, scrncol: ' Enter„				PRINT CHR$(255); SPACE$(78 - scrncol);„				scrncol = scrncol + 1„				CALL SaveLine„				IF insmode = 1 THEN„					 CALL InsLine(1)„					 IF scrnline < 21 AND scrnline > 3 THEN„							FOR t = (scrnline - 1) TO 23„									LOCATE t, 1„									PRINT SPACE$(79);„									LOCATE t, 1„									b = edline + t - scrnline„									PRINT doctxt(b);„									NEXT t„							ELSE„							CALL NewText(edline)„							END IF„					 END IF„				END IF„		 IF a$ <> "" THEN„				LOCATE scrnline, scrncol: PRINT a$;„				IF CSRLIN > scrnline THEN„					 CALL SaveLine„					 edline = edline + 1„					 END IF„				scrnline = CSRLIN„				scrncol = POS(0)„				IF insmode = 1 THEN PRINT b$; " ";„				END IF„		LOOP„	END„„ErrorTrap:„	CLS„	COLOR fcolor + 16, bcolor„	PRINT TAB(34); "E R R O R !!"„	BEEP: BEEP: BEEP„	COLOR fcolor + 8„	a$ = "#" + STR$(ERR)„	IF ERR = 7 THEN a$ = "Out of Memory."„	IF ERR > 49 THEN a$ = "Check Diskette."„	IF ERR = 53 THEN a$ = "File not Found."„	IF ERR = 61 THEN a$ = "Disk is Full."„	IF ERR = 64 THEN a$ = "Illegal File Name."„	IF ERR > 70 THEN a$ = "Disk not Ready."„	IF ERR = 73 THEN a$ = "Feature Unavailable."„	PRINT : PRINT TAB(40 - LEN(a$) / 2); a$„	COLOR fcolor„	LOCATE 7, 30: PRINT "Hit any key, please."„	a$ = INPUT$(1)„	scrncol = 1„	RESUME ProgramStart„„REM $STATIC„SUB DelFile„	SHARED filespec$„„	b$ = filespec$„	CALL FileDir„	a$ = "N"„    CALL InputBox("Deleting " + filespec$ + "!  Are you sure??", 1, 35, 8, 0, a$)„	a$ = UCASE$(a$)„	IF a$ <> "Y" THEN„		 filespec$ = b$„		 EXIT SUB„		 END IF„	KILL filespec$„END SUB„„SUB DelLine (row)„	SHARED doctxt() AS STRING, edline„„	FOR t = (edline + row - 1) TO (UBOUND(doctxt, 1) - 1)„			SWAP doctxt(t), doctxt(t + 1)„			NEXT t„	FOR t = (UBOUND(doctxt, 1) - row + 1) TO UBOUND(doctxt, 1)„			doctxt(t) = ""„			NEXT t„END SUB„„SUB DelText„SHARED doctxt() AS STRING, edline, b$, scrnline, scrncol, linelen„„		IF LEN(b$) = 1 THEN b$ = " "„		IF LEN(b$) > 1 THEN b$ = RIGHT$(b$, LEN(b$) - 1)„		IF b$ = " " AND scrnline < 23 THEN„			 b = INSTR(linelen - (scrncol + 1), doctxt(edline + 1), " ")„			 IF b = 0 AND LEN(doctxt(edline + 1)) > 0 THEN„					b = LEN(doctxt(edline + 1))„					doctxt(edline + 1) = doctxt(edline + 1) + " "„					END IF„			 c$ = LEFT$(doctxt(edline + 1), b)„			 b$ = b$ + c$„		   doctxt(edline + 1) = RIGHT$(doctxt(edline + 1), LEN(doctxt(edline + 1)) - b)„			 LOCATE scrnline + 1, 1„			 PRINT SPACE$(79);„			 LOCATE scrnline + 1, 1„			 PRINT doctxt(edline + 1);„			 END IF„		LOCATE scrnline, scrncol„		PRINT b$; " ";„END SUB„„SUB FileDir„	SHARED ibox$(), filespec$„„ReadDir:„	LOCATE 1, 1, 0„	SHELL "dir > scanfile.dir"„	OPEN "scanfile.dir" FOR INPUT AS #1„		fcounter = 0„		WHILE NOT EOF(1)„			LINE INPUT #1, a$„			fcounter = fcounter + 1„			WEND„		CLOSE #1„	REDIM scandir(fcounter + 3) AS STRING * 12„	OPEN "scanfile.dir" FOR INPUT AS #1„		fcounter = 1„		WHILE NOT EOF(1)„			LINE INPUT #1, a$„		  IF LEFT$(a$, 1) <> " " AND LEN(a$) > 1 AND LEFT$(a$, 8) <> "SCANFILE" THEN„				IF MID$(a$, 14, 1) = "<" THEN a$ = LEFT$(a$, 9) + "<D>"„				a$ = MID$(a$, 1, 8) + "." + MID$(a$, 10, 3)„				scandir(fcounter) = a$„				fcounter = fcounter + 1„				END IF„			WEND„		limit = fcounter - 1„		DO„			 swaps = 0„			 FOR item = 0 TO (limit - 1)„					 IF scandir(item) > scandir(item + 1) THEN„							SWAP scandir(item), scandir(item + 1)„							swaps = item„							END IF„					 NEXT item„			 limit = swaps„			 LOOP WHILE swaps„		scandir(fcounter) = "    [A:]    "„		scandir(fcounter + 1) = "    [B:]    "„		scandir(fcounter + 2) = "    [C:]    "„		fcounter = fcounter + 2„		CLOSE #1„	REDIM ibox$(fcounter + 2)„	KILL "scanfile.dir"„	IF fcounter = 0 THEN EXIT SUB„ „	ibox$(0) = "Directory:"„	ibox$(1) = STR$(fcounter + 3)„	ibox$(2) = "12"„	FOR dircntr = 1 TO (fcounter)„		ibox$(dircntr + 2) = LEFT$(scandir(dircntr) + "            ", 12)„		NEXT dircntr„	item = 0„	CALL ItemBox(ibox$(), 27, 8, item)„	IF item > 0 THEN„		 IF RIGHT$(ibox$(item + 2), 3) = "<D>" THEN„				CHDIR RTRIM$(LEFT$(ibox$(item + 2), 8))„				GOTO ReadDir„				ELSE„				IF INSTR(ibox$(item + 2), ":]") = 7 THEN„					 LOCATE 1, 1„					 SHELL MID$(ibox$(item + 2), 6, 2)„					 GOTO ReadDir„					 END IF„				filespec$ = ibox$(item + 2)„				END IF„		 END IF„END SUB„„SUB FindRepl (itemnum) STATIC„SHARED doctxt() AS STRING, edline, fcolor, bcolor, scrncol„„	CALL InputBox("Search For?", 40, 20, 6, 0, ftext$)„	ftext$ = RTRIM$(ftext$)„	IF ftext$ = CHR$(27) THEN EXIT SUB„	IF itemnum = 1 THEN„		 CALL InputBox("Replace With?", 40, 22, 10, 0, rtext$)„		 rtext$ = RTRIM$(rtext$)„		 IF rtext$ = CHR$(27) THEN EXIT SUB„		 CALL InputBox("Confirm? (Y/N)", 1, 24, 14, 0, conftxt$)„		 conftxt$ = UCASE$(conftxt$)„		 IF conftext$ = CHR$(27) THEN EXIT SUB„		 END IF„	IF itemnum = 0 THEN„		 FOR counter = edline TO UBOUND(doctxt, 1)„				 a = INSTR(doctxt(counter), ftext$)„				 IF a > 0 AND (a <> scrncol AND counter <> edline) THEN„						edline = counter„						scrncol = a: BEEP„						EXIT FOR„						END IF„				 NEXT counter„		 IF scrncol = a THEN EXIT SUB„		 FOR counter = 1 TO edline - 1„				 a = INSTR(doctxt(counter), ftext$)„				 IF a > 0 THEN„						edline = counter„						scrncol = a: BEEP„						EXIT FOR„						END IF„				 NEXT counter„		 EXIT SUB„		 END IF„' =====>  Replace  <=====„	FOR counter = 1 TO UBOUND(doctxt, 1)„			a = INSTR(doctxt(counter), ftext$)„			IF a > 0 THEN„				 ans$ = "Y"„				 IF conftxt$ = "Y" THEN„						COLOR fcolor, bcolor„						CALL NewText(counter)„						LOCATE 3, a„						COLOR bcolor, fcolor„						PRINT ftext$;„						CALL InputBox("Replace? (Y/N)", 1, 24, 14, 0, ans$)„						ans$ = UCASE$(ans$)„						IF ans$ = CHR$(27) THEN EXIT SUB„						END IF„				 IF ans$ = "Y" THEN„						c$ = LEFT$(doctxt(counter), a - 1) + rtext$„				    b$ = RIGHT$(doctxt(counter), LEN(doctxt(counter)) + 1 - (a + LEN(ftext$)))„						doctxt(counter) = c$ + b$„						END IF„				 END IF„			NEXT counter„END SUB„„SUB InputBox (inprompt$, answerlen, col, row, hide%, answer$)„	COLOR 0, 7, 0„	menuwidth = answerlen + 2„	IF LEN(inprompt$) > answerlen THEN menuwidth = LEN(inprompt$) + 2„	LOCATE row, col„	PRINT CHR$(218); STRING$(menuwidth, 196); CHR$(191);„	LOCATE row + 1, col„    PRINT CHR$(179); " "; LEFT$(inprompt$ + STRING$(80, 32), menuwidth - 1); CHR$(179);„	COLOR 8, 0, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	COLOR 0, 7, 0„	LOCATE row + 2, col„	PRINT CHR$(195); STRING$(menuwidth, 196); CHR$(180);„	COLOR 8, 0, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	COLOR 0, 7, 0„	LOCATE row + 3, col„	PRINT CHR$(179); STRING$(menuwidth, 32); CHR$(179);„	COLOR 8, 0, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	COLOR 0, 7, 0„	LOCATE row + 4, col„	PRINT CHR$(192); STRING$(menuwidth, 196); CHR$(217);„	COLOR 8, 0, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	LOCATE row + 5, col + 1„	FOR border = 1 TO menuwidth + 2„		PRINT CHR$(SCREEN(CSRLIN, POS(0)));„		NEXT border„	COLOR 4, 7„	row = row + 3„	col = col + 2„	answer$ = RTRIM$(answer$)„	CALL InputText(answer$, answerlen, col, row, hide%)„END SUB„„SUB InputText (answer$, answerlen, col, row, hide%)„	LOCATE row, col, 1„	PRINT answer$;„	FOR letter = 1 TO answerlen„		 a$ = ""„		 WHILE a$ = ""„				a$ = INKEY$„				IF LEN(a$) > 1 THEN„					 IF RIGHT$(a$, 1) = CHR$(75) THEN a$ = CHR$(8)„					 END IF„				IF LEN(a$) > 1 THEN a$ = ""„				WEND„		 IF a$ = CHR$(9) THEN a$ = CHR$(13)„		 IF a$ = CHR$(27) THEN„				answer$ = CHR$(27)„				EXIT FOR„				END IF„		 IF a$ = CHR$(13) THEN EXIT FOR„		 IF letter = 1 THEN„				LOCATE row, col„				PRINT STRING$(answerlen, 32);„				answer$ = ""„				LOCATE row, col„				END IF„		 IF a$ <> CHR$(8) THEN„				IF hide% = 1 THEN„					 PRINT "*";„					 ELSE„					 PRINT a$;„					 END IF„				END IF„		 IF a$ <> CHR$(8) THEN answer$ = answer$ + a$„		 IF a$ = CHR$(8) AND letter > 1 THEN„				LOCATE CSRLIN, POS(0) - 1: PRINT " ";„				letter = letter - 2„				answer$ = LEFT$(answer$, letter)„				LOCATE row, col, 1„			 IF hide% = 0 THEN PRINT answer$;  ELSE PRINT STRING$(letter, "*");„				END IF„		 NEXT letter„	answer$ = LEFT$(answer$ + STRING$(answerlen, 32), answerlen)„END SUB„„SUB InsLine (row)„	SHARED doctxt() AS STRING, edline, scrncol„„	a$ = LEFT$(doctxt(edline), scrncol - 1)„	FOR t = UBOUND(doctxt, 1) TO (edline + row) STEP -1„			SWAP doctxt(t), doctxt(t - row)„			NEXT t„	FOR t = (edline) TO (edline + row)„			doctxt(t) = ""„			NEXT t„	doctxt(edline) = a$„END SUB„„SUB ItemBox (box$(), col, row, itemnum)„	SHARED bcolor, mcolor„„	'=====>  Item list for choice box      <=====„	' box$(0)     --->  Menu Name„	' box$(1)     --->  Last Item's *REAL* Number (item + 2)„	' box$(2)     --->  Menu Width (Same as LEN of longest item)„	' col          Horizontal location of box„	' row          vertical location of box„	' item         selected item in array„„	lastitem = VAL(box$(1)) - 3„	IF itemnum > lastitem OR itemnum = 0 THEN itemnum = 1„	IF lastitem < 1 THEN EXIT SUB„	menuwidth = VAL(box$(2)) + 2„„	COLOR bcolor + 8, mcolor, 0„	LOCATE row, col, 0„	PRINT CHR$(201); STRING$(menuwidth, 205); CHR$(187);„	LOCATE row + 1, col„    PRINT CHR$(186); LEFT$(" " + box$(0) + STRING$(menuwidth, 32), menuwidth); CHR$(186);„	COLOR 8, 0, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	COLOR bcolor + 8, mcolor, 0„	LOCATE row + 2, col„	PRINT CHR$(199); STRING$(menuwidth, 196); CHR$(182);„	COLOR 8, 0, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	COLOR bcolor + 8, mcolor, 0„	menu = itemnum„' =====>  List Files in Box  <=====„	FOR border = 1 TO 10„		LOCATE row + 2 + border, col, 0„		PRINT CHR$(186);„		IF menu > lastitem THEN„			 PRINT STRING$(menuwidth, 32);„			 ELSE„		   PRINT LEFT$(" " + box$(menu + 2) + STRING$(menuwidth, 32), menuwidth);„			 menu = menu + 1„			 END IF„		PRINT CHR$(186);„		COLOR 8, 0, 0„		PRINT CHR$(SCREEN(CSRLIN, POS(0)))„		COLOR bcolor + 8, mcolor, 0„		NEXT border„	LOCATE CSRLIN, col, 0„	PRINT CHR$(200); STRING$(menuwidth, 205); CHR$(188);„	COLOR 0, 8, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	LOCATE CSRLIN, col + 1„	FOR border = 1 TO menuwidth + 2„		PRINT CHR$(SCREEN(CSRLIN, POS(0)));„		NEXT border„	COLOR bcolor + 8, mcolor, 0„	menu = 1: item = itemnum„	LOCATE row + 3, col + 1„	COLOR 7, 0„    PRINT LEFT$(" " + box$(item + 2) + STRING$(menuwidth, 32), menuwidth);„	COLOR bcolor + 8, mcolor, 0„' =====>  Select Item  <=====„	a$ = "": a = 0„	WHILE (a$ <> CHR$(13))„		a$ = ""„		b = VAL(RIGHT$(TIME$, 4))„		IF b > 7 THEN b = 0„		WHILE a$ = ""„			COLOR mcolor, bcolor„			LOCATE 25, 45, 0: PRINT "Date: "; DATE$;„			LOCATE 25, 65: PRINT "Time: "; TIME$;„			a$ = INKEY$„			WEND„		IF a$ = CHR$(27) THEN„			 itemnum = 0„			 col = 27„			 EXIT SUB„			 END IF„		IF a$ = CHR$(13) THEN„			 col = 13„			 itemnum = item„			 EXIT SUB„			 END IF„		IF LEN(a$) > 1 THEN„			 a = ASC(RIGHT$(a$, 1))„			 IF a = 73 THEN menu = menu - 9: item = menu„			 IF a = 81 THEN menu = menu + 9: item = menu„			 IF a = 71 THEN menu = 1: item = 1„			 IF a = 72 THEN„					IF item = menu THEN menu = menu - 9„					item = item - 1„					END IF„			 IF a = 80 THEN„					IF item = menu + 9 THEN menu = menu + 9„					item = item + 1„					END IF„			 IF a = 79 THEN menu = lastitem + 1„			 END IF„		IF LEN(a$) = 1 THEN„			 a$ = UCASE$(a$)„			 a = item„			 FOR border = 3 TO (lastitem + 2)„					 IF a$ = LEFT$(box$(border), 1) THEN„							item = border - 2: menu = border - 2„							EXIT FOR„							END IF„					 NEXT border„			 END IF„		IF menu > lastitem THEN„			 menu = lastitem - 9„			 item = lastitem„			 END IF„		IF menu < 1 THEN menu = 1„		IF item < 1 THEN item = 1„		IF item > lastitem THEN item = lastitem„		COLOR bcolor + 8, mcolor, 0„		box = menu„		FOR border = 1 TO 10„				LOCATE row + 2 + border, col + 1, 0„				IF box > lastitem THEN„					 PRINT STRING$(menuwidth, 32);„					 ELSE„					 IF box = item THEN COLOR 7, 0, 0„					 PRINT " "; box$(box + 2); " ";„					 COLOR bcolor + 8, mcolor, 0„					 box = box + 1„					 END IF„				NEXT border„		WEND„		itemnum = item„END SUB„„SUB LoadMode„	SHARED doctxt() AS STRING, filespec$, bcolor, fcolor, linelen„	SHARED scrncol, scrnline, edline„„	FOR edline = 1 TO UBOUND(doctxt, 1)„			doctxt(edline) = ""„			NEXT edline„	IF scrncol = -1 THEN„		 scrncol = 1„		 GOTO LoadFile„		 END IF„	CALL FileDir„	a$ = "Y"„	CALL InputBox("Load " + filespec$ + "?", 1, 35, 8, 0, a$)„	IF a$ = CHR$(27) OR UCASE$(a$) = "N" THEN„		 edline = 1„		 EXIT SUB„		 END IF„LoadFile:„	OPEN "I", 1, filespec$„		edline = 1„		WHILE NOT EOF(1) AND edline < UBOUND(doctxt, 1)„				a$ = INPUT$(1, #1)„				IF a$ = CHR$(13) THEN a$ = " "„				IF a$ <> CHR$(10) THEN doctxt(edline) = doctxt(edline) + a$„				IF a$ = " " AND LEN(doctxt(edline)) > linelen THEN„					 doctxt(edline) = doctxt(edline) + a$„					 el = LEN(doctxt(edline))„					 IF el > linelen THEN el = linelen„					 b = 0„					 FOR t = el TO 1 STEP -1„							 IF MID$(doctxt(edline), t, 1) = " " THEN„									b = t„									EXIT FOR„									END IF„							 NEXT t„					 IF b <> 0 THEN„					   b$ = LTRIM$(RIGHT$(doctxt(edline), LEN(doctxt(edline)) - (b)))„							doctxt(edline) = LEFT$(doctxt(edline), b)„							edline = edline + 1„							doctxt(edline) = RTRIM$(b$) + " "„							ELSE„							edline = edline + 1„							END IF„					 END IF„				IF a$ = CHR$(10) THEN„					 doctxt(edline) = RTRIM$(doctxt(edline)) + CHR$(255)„					 edline = edline + 1„					 COLOR bcolor, fcolor„					 LOCATE 1, 65„					 PRINT USING "###"; edline;„					 END IF„				WEND„		CLOSE #1„	scrnline = 3: scrncol = 1: edline = 1„END SUB„„SUB MainScreen„	SHARED fcolor, bcolor, mcolor, menubar$„	SHARED filespec$, linelen„„	SCREEN 0, 0, 0, 0„	VIEW PRINT„	COLOR fcolor, bcolor„	WIDTH 80„	CLS„BoxDraw:„	COLOR bcolor + 8, mcolor„	LOCATE 1, 1: PRINT menubar$;„	COLOR mcolor, bcolor„	LOCATE 2, 1„	FOR t = 1 TO 80„		a$ = "-"„		IF t / 5 = INT(t / 5) THEN a$ = "|"„		IF t / 10 = INT(t / 10) THEN a$ = RIGHT$(STR$(t / 10), 1)„		IF t = INT(linelen / 2) THEN a$ = CHR$(23)„		PRINT a$;„		NEXT t„	COLOR bcolor, mcolor„	LOCATE 2, linelen: PRINT "]";„	LOCATE 24, 1:„	PRINT "  "; RIGHT$(SPACE$(12) + RTRIM$(filespec$), 12); TAB(30);„	PRINT "Text Rite 2.24(c) 1992, Student Oriented Software  ";„	COLOR mcolor + 8, bcolor„	LOCATE 25, 45, 0: PRINT "Date: "; DATE$;„	LOCATE 25, 65: PRINT "Time: "; TIME$;„	LOCATE 25, 3: COLOR bcolor, mcolor„	PRINT "ESC";„	COLOR mcolor, bcolor„	PRINT " - (Escape) to Exit any Menu";„	VIEW PRINT 3 TO 23„END SUB„„SUB MakeMenu„	SHARED menu$(), menubar$„„' CALLed by:  Menuz.bas„„	'=====> Menu, options (10 Max)      <=====„	' menu$(x,0)   --->  Menu Name„	' menu$(x,1)   --->  Last Item's *REAL* Number (item + 2)„	' menu$(x,2)   --->  Menu Width (Same as LEN of longest item)„ „	' menu$(0, 0) = "F1-Help"„	' menu$(0, 3) = "Index"„„	menu$(1, 0) = "F2-Edit"„	menu$(1, 3) = "Block Define"„	menu$(1, 4) = STRING$(13, 196)„	menu$(1, 5) = "Copy Block"„	menu$(1, 6) = "Paste Block"„	menu$(1, 7) = "Delete Block"„	menu$(1, 8) = STRING$(13, 196)„	menu$(1, 9) = "Find"„	menu$(1, 10) = "Replace"„	„„	menu$(5, 0) = "F6-Print"„	menu$(5, 3) = "Print"„	menu$(5, 4) = "Setup"„„	menu$(4, 0) = "F5-Format"„	menu$(4, 3) = "Center"„	menu$(4, 4) = "Left"„	menu$(4, 5) = "Right"„ „	menu$(2, 0) = "F3-Options"„	menu$(2, 3) = "Line Length"„	menu$(2, 4) = STRING$(16, 196)„	menu$(2, 5) = "Text Color"„	menu$(2, 6) = "Background Color"„	menu$(2, 7) = "Menu Color"„	menu$(2, 8) = STRING$(16, 196)„	menu$(2, 9) = "Defaults"„ „	menu$(6, 0) = "F7-File"„	menu$(6, 3) = "New"„	menu$(6, 4) = "Load"„	menu$(6, 5) = "Save"„	menu$(6, 6) = STRING$(6, 196)„	menu$(6, 7) = "Delete"„	menu$(6, 8) = STRING$(6, 196)„	menu$(6, 9) = "X Exit"„ „	menu$(10, 0) = "Colors"„	menu$(10, 3) = "0 Black"„	menu$(10, 4) = "1 Blue"„	menu$(10, 5) = "2 Green"„	menu$(10, 6) = "3 Cyan"„	menu$(10, 7) = "4 Red"„	menu$(10, 8) = "5 Purple"„	menu$(10, 9) = "6 Orange"„	menu$(10, 10) = "7 White"„ „	FOR menu = 0 TO maxmenu„		IF menu < 10 THEN menubar$ = menubar$ + menu$(menu, 0) + "  "„		menu$(menu, 2) = "0"„		FOR item = 3 TO maxitem„			IF menu$(menu, item) <> "" THEN„				 menu$(menu, 1) = STR$(item)„				 IF LEN(menu$(menu, item)) > VAL(menu$(menu, 2)) THEN„						menu$(menu, 2) = STR$(LEN(menu$(menu, item)))„						END IF„				 END IF„			NEXT item„		NEXT menu„	menubar$ = LEFT$(menubar$ + STRING$(70, 32), 80)„END SUB„„SUB MenuBox : 'Draws Pull-Down menus using MENU$()„	SHARED menu$(), menucalled, col„„	IF col = 0 AND menucalled = 0 THEN EXIT SUB„	COLOR 0, 7, 0„	FOR menu = 3 TO VAL(menu$(menucalled, 1))„		LOCATE menu - 1, col, 0„	   b$ = LEFT$(menu$(menucalled, menu) + STRING$(VAL(menu$(menucalled, 2)) + 1, 32), VAL(menu$(menucalled, 2)) + 1)„		PRINT CHR$(179); " ";„		IF LEFT$(b$, 1) <> CHR$(196) THEN COLOR 15, 0, 0„		PRINT LEFT$(b$, 1);„		COLOR 0, 7, 0„		PRINT RIGHT$(b$, LEN(b$) - 1); CHR$(179);„		COLOR 8, 0, 0„		PRINT CHR$(SCREEN(CSRLIN, POS(0)))„		COLOR 0, 7, 0„		NEXT menu„	LOCATE VAL(menu$(menucalled, 1)), col„	PRINT CHR$(192); STRING$(VAL(menu$(menucalled, 2)) + 2, 196); CHR$(217);„	COLOR 8, 0, 0„	PRINT CHR$(SCREEN(CSRLIN, POS(0)))„	LOCATE VAL(menu$(menucalled, 1)) + 1, col + 1„	FOR menu = 1 TO (VAL(menu$(menucalled, 2)) + 4)„		PRINT CHR$(SCREEN(CSRLIN, POS(0)));„		NEXT menu„END SUB„„SUB MenuCall STATIC„	SHARED menubar$, menu$(), menucalled, item, col„	SHARED fcolor, bcolor, mcolor, linelen, newscrn„	SHARED scandir() AS STRING * 12„	SHARED ibox$(), filespec$, scrncol„	SHARED blockmode, pasteallow„„	DO„		 IF menucalled < 10 THEN„			 PCOPY 0, 1:                        ' Copy non-menu screen into RAM„				col = INSTR(1, menubar$, menu$(menucalled, 0)) - 1„				END IF„	    SCREEN 0, 0, 1, 1:                    ' Menu's use Screen 1 to save„	    COLOR 7, 0, 0:                        '  original display (Screen 0)„		 item = 2„	    xitmenu = 0:                          ' Remain in menus until Exit„		 CALL MenuBox„		 IF menucalled = 0 AND col = 0 THEN„				SCREEN 0, 0, 0, 0„				COLOR fcolor, bcolor„				EXIT SUB„				END IF„„SelectItem:„		 a = 0:                                  ' No key pressed yet„	    DO UNTIL (a = 13 OR a = 27 OR (LEN(a$) > 1 AND (a = 77 OR a = 75)))„				a$ = "": a = 0„				WHILE a$ = ""„					a$ = UCASE$(INKEY$)„					COLOR mcolor + 8, bcolor„					LOCATE 25, 45, 0: PRINT "Date: "; DATE$;„					LOCATE 25, 65: PRINT "Time: "; TIME$;„					WEND„				a = ASC(RIGHT$(a$, 1))„				IF LEN(a$) > 1 THEN„' =====>  Special Key Pressed <=====„					 IF a = 77 OR a = 75 THEN„							DO„								 IF a = 77 THEN„								menucalled = menucalled + 1 + ((menucalled > 8) * 10)„										ELSE„								menucalled = menucalled - 1 - ((menucalled < 1) * 10)„										END IF„								 LOOP WHILE menu$(menucalled, 0) = ""„							xitmenu = 0„							END IF„					 IF a = 80 OR a = 72 THEN„							item = item - (a = 80) + (a = 72)„							IF item < 3 THEN item = VAL(menu$(menucalled, 1))„							IF item > VAL(menu$(menucalled, 1)) THEN item = 3„							IF LEFT$(menu$(menucalled, item), 1) = CHR$(196) THEN„								 item = item - (a = 80) + (a = 72)„								 END IF„							CALL MenuBox„							LOCATE item - 1, col + 1, 0„					   b$ = LEFT$(" " + menu$(menucalled, item) + STRING$(VAL(menu$(menucalled, 2)) + 1, 32), VAL(menu$(menucalled, 2)) + 2)„					   IF menucalled <> 10 OR (menucalled = 10 AND (item = 10 OR item = 3)) THEN„								 COLOR 7, 0: PRINT b$; : COLOR 0, 7„								 ELSE„						   COLOR 0, VAL(menu$(menucalled, item)): PRINT b$: COLOR 0, 7„								 END IF„							END IF„					 END IF„		 ' =====>  Letter Pressed  <=====„		 IF (a <> 27 AND a <> 13) AND (LEN(a$) = 1) THEN„				a = item„				FOR menu = (item + 1) TO maxitem„					IF a$ = LEFT$(menu$(menucalled, menu), 1) THEN„						 item = menu„						 EXIT FOR„						 END IF„					NEXT menu„				IF a = item THEN„					 FOR menu = 3 TO item„						 IF a$ = LEFT$(menu$(menucalled, menu), 1) THEN„								item = menu„								EXIT FOR„								END IF„						 NEXT menu„					 END IF„				CALL MenuBox„				IF item > 2 THEN„					 LOCATE item - 1, col + 1, 0„				 b$ = LEFT$(" " + menu$(menucalled, item) + STRING$(VAL(menu$(menucalled, 2)) + 1, 32), VAL(menu$(menucalled, 2)) + 2)„				 IF menucalled <> 10 OR (menucalled = 10 AND (item = 10 OR item = 3)) THEN„							COLOR 7, 0: PRINT b$; : COLOR 0, 7„							ELSE„					   COLOR 0, VAL(menu$(menucalled, item)): PRINT b$: COLOR 0, 7„							END IF„					 END IF„				END IF„		 LOOP„' =====>  Item Selected  <=====„	    IF a = 27 THEN xitmenu = 1: ' ESC menu item selected, so menus will be left„		 IF a = 13 THEN„				xitmenu = 1„				IF item > 2 THEN choice$ = menu$(menucalled, item)„				IF menucalled = 10 THEN„					 IF choice$ = "0 Black" THEN a = 0„					 IF choice$ = "1 Blue" THEN a = 1„					 IF choice$ = "2 Green" THEN a = 2„					 IF choice$ = "3 Cyan" THEN a = 3„					 IF choice$ = "4 Red" THEN a = 4„					 IF choice$ = "5 Purple" THEN a = 5„					 IF choice$ = "6 Orange" THEN a = 6„					 IF choice$ = "7 White" THEN a = 7„					 IF rcolor = 1 AND (a <> bcolor) THEN fcolor = a„					 IF rcolor = 2 AND (a <> fcolor) THEN bcolor = a„					 IF rcolor = 4 AND (a <> bcolor) THEN mcolor = a„					 COLOR fcolor, bcolor„					 EXIT SUB„					 END IF„				IF menucalled = 1 THEN„					 IF choice$ = "Block Define" THEN„							blockmode = 1„							menu$(1, 3) = "Block End   "„							END IF„					 IF choice$ = "Block End   " THEN„							blockmode = 0„							menu$(1, 3) = "Block Define"„							END IF„					 IF choice$ = "Copy Block" THEN„							' Set the value docbuffer(0) = lines in buffer„							' then copy into docbuffer (1+) BlockBegin -> BlockEnd„							' (copy into buffer in case of delete)„							END IF„					 IF choice$ = "Delete Block" THEN„							' Use the DelLine sub to delete lines„							' from BlockBegin to BlockEnd,„							' storing text in docbuffer() same as Copy Block„							END IF„					 IF choice$ = "Paste Block" THEN„							' Use InsLine(0) to insert # lines in docbuffer(0)„							' copy text from docbuffer(1+) in blank lines„							END IF„					 IF choice$ = "Find" THEN„							CALL FindRepl(0)„							newscrn = 1„							END IF„					 IF choice$ = "Replace" THEN„							CALL FindRepl(1)„							newscrn = 1„							END IF„					 END IF„				IF menucalled = 5 THEN„					 IF choice$ = "Print" THEN CALL PrintMode(0)„					 IF choice$ = "Setup" THEN CALL PrintMode(1)„					 END IF„				IF menucalled = 4 THEN„					 IF choice$ = "Center" THEN CALL PosText(1)„					 IF choice$ = "Left" THEN CALL PosText(0)„					 IF choice$ = "Right" THEN CALL PosText(2)„					 END IF„				IF menucalled = 2 THEN„					 newscrn = 1„					 IF choice$ = "Line Length" THEN„							a$ = "60"„							CALL SaveMode„							CALL InputBox("New Line Length:", 3, 35, 8, 0, a$)„							linelen = VAL(a$)„							IF linelen < 15 OR linelen > 79 THEN linelen = 60„							IF RTRIM$(filespec$) <> "<NONE>" THEN„								 scrncol = -1„								 CALL LoadMode„								 END IF„							END IF„					 IF choice$ = "Defaults" THEN„							fcolor = 3: bcolor = 0: mcolor = 7„							linelen = 60„							END IF„					 IF INSTR(choice$, "Color") > 0 THEN„							IF INSTR(choice$, "Back") > 0 THEN rcolor = 2„							IF INSTR(choice$, "Text") > 0 THEN rcolor = 1„							IF INSTR(choice$, "Menu") > 0 THEN rcolor = 4„							menucalled = 10: 'Color Menu„					   col = INSTR(1, menubar$, menu$(2, 0)) + VAL(menu$(2, 2)) + 2„							CALL MenuBox„							xitmenu = 0: ' ====>  Remain in Menuing system <=====„							END IF„					 END IF„				IF menucalled = 6 THEN„					 IF choice$ = "New" THEN„							CALL NewFile„							newscrn = 1„							END IF„					 IF choice$ = "Load" THEN„							CALL LoadMode„							newscrn = 1„							END IF„					 IF choice$ = "Save" THEN„							CALL SaveMode„							END IF„					 IF choice$ = "Delete" THEN„							CALL DelFile„							END IF„					 IF choice$ = "X Exit" THEN„							VIEW PRINT: CLS„							END„							END IF„					 END IF„				END IF„' Exit Menus„		 SCREEN 0, 0, 0, 0„		 COLOR fcolor, bcolor„		 a$ = ""„	LOOP WHILE xitmenu = 0„END SUB„„SUB NewFile„	SHARED doctxt() AS STRING, scrnline, scrncol, filespec$, edline„„	filespec$ = "<New File>"„	FOR edline = 1 TO UBOUND(doctxt, 1)„			doctxt(edline) = ""„			NEXT edline„	edline = 1: scrnline = 3: scrncol = 1„END SUB„„SUB NewText (edline)„	SHARED doctxt() AS STRING, fcolor, bcolor, mcolor„	SHARED blockbeg, blockbch, blockend, blockech„	SHARED blockmode„„	COLOR fcolor, bcolor, mcolor„	CLS 2„	FOR t = edline TO edline + 20„		LOCATE t - edline + 3, 1„		IF t < UBOUND(doctxt, 1) THEN„			 COLOR fcolor, bcolor, mcolor„			 IF blockmode <> 0 THEN„					IF t = blockbeg OR t = blockend THEN„						 FOR a = 1 TO LEN(doctxt(t))„						 COLOR fcolor, bcolor„					IF (t = blockbeg AND t = blockend) AND (a >= blockbch AND a <= blockech) THEN„								COLOR bcolor, fcolor„								END IF„					IF (t = blockbeg AND a >= blockbch) AND t <> blockend THEN„								COLOR bcolor, fcolor„								END IF„					IF (t = blockend AND a <= blockech) AND t <> blockbeg THEN„								COLOR bcolor, fcolor„								END IF„						 PRINT MID$(doctxt(t), a, 1);„						 NEXT a„						 END IF„					IF t <> blockbeg AND t <> blockend THEN„					IF t > blockbeg AND t < blockend THEN COLOR bcolor, fcolor„						 PRINT doctxt(t);„						 END IF„					ELSE„					COLOR fcolor, bcolor„					PRINT doctxt(t);„					END IF„			 END IF„		NEXT t„END SUB„„SUB PosText (itemnum)„	SHARED doctxt() AS STRING, edline, linelen, bcolor, fcolor, scrnline„„	SCREEN 0, 0, 0, 0„	LOCATE scrnline, 1„	CALL SaveLine„	doctxt(edline) = LTRIM$(doctxt(edline))„	doctxt(edline) = RTRIM$(doctxt(edline))„	IF RIGHT$(doctxt(edline), 1) = CHR$(255) THEN„		 doctxt(edline) = LEFT$(doctxt(edline), LEN(doctxt(edline)) - 1)„		 END IF„	IF itemnum = 1 THEN„		 a$ = SPACE$((linelen / 2) - (LEN(doctxt(edline)) / 2) - 1)„		 doctxt(edline) = a$ + doctxt(edline)„		 END IF„	IF itemnum = 2 THEN„		 a$ = SPACE$(linelen - LEN(doctxt(edline)))„		 doctxt(edline) = a$ + doctxt(edline)„		 END IF„	doctxt(edline) = doctxt(edline) + CHR$(255)„	COLOR fcolor, bcolor„	LOCATE scrnline, 1„	PRINT SPACE$(79);„	LOCATE scrnline, 1„	PRINT doctxt(edline);„END SUB„„SUB PrintMode (itemnum) STATIC„	SHARED doctxt() AS STRING, linelen, fcolor, bcolor„ „	IF pglines = 0 THEN pglines = 60„	IF topmar = 0 THEN topmar = 3„	IF btmar = 0 THEN btmar = 9„	IF startnum = 0 THEN startnum = 1„	IF leftmar = 0 THEN leftmar = 40 - (linelen / 2)„ „	IF itemnum = 1 THEN„	    CALL PrintSetup(pglines, topmar, btmar, leftmar, startnum, nummode)„		 EXIT SUB„		 END IF„„	prnout = pglines - (topmar + btmar)„	pgnum = startnum - 1„	FOR edline = 1 TO UBOUND(doctxt, 1)„			IF RTRIM$(doctxt(edline)) <> "" THEN b = edline„			NEXT edline„	FOR counter = 1 TO topmar„			IF counter = 1 AND nummode > 1 AND nummode < 4 THEN„				 pgnum = pgnum + 1„				 IF nummode = 1 THEN LPRINT SPACE$(linelen); pgnum„				 IF nummode = 2 THEN LPRINT SPACE$(39); pgnum„				 IF nummode = 3 THEN LPRINT SPACE$(leftmar); pgnum„				 ELSE„				 LPRINT„				 END IF„			NEXT counter„	FOR edline = 1 TO b„			COLOR bcolor, fcolor„			LOCATE 1, 65„			PRINT USING "###"; edline;„		  LPRINT SPACE$(leftmar); LEFT$(doctxt(edline), LEN(doctxt(edline)) - 1)„			IF (edline / prnout) = INT(edline / prnout) THEN„				 IF btmar > 2 AND nummode > 3 THEN„						pgnum = pgnum + 1„						LPRINT„						IF nummode = 4 THEN LPRINT SPACE$(linelen); pgnum„						IF nummode = 5 THEN LPRINT SPACE$(39); pgnum„						END IF„				 LPRINT CHR$(12);„				 FOR counter = 1 TO topmar„						 IF counter = 1 AND nummode > 1 AND nummode < 4 THEN„								pgnum = pgnum + 1„								IF nummode = 1 THEN LPRINT SPACE$(linelen); pgnum„								IF nummode = 2 THEN LPRINT SPACE$(39); pgnum„								IF nummode = 3 THEN LPRINT SPACE$(leftmar); pgnum„								ELSE„								LPRINT„								END IF„						 NEXT counter„				 END IF„			NEXT edline„	IF nummode > 3 AND (edline / prnout <> INT(edline / prnout)) THEN„		 edline = edline - 1„		 WHILE (edline / prnout) <> INT(edline / prnout)„				 LPRINT„				 edline = edline + 1„				 WEND„		 IF btmar > 2 THEN„				pgnum = pgnum + 1„				LPRINT„				IF nummode = 4 THEN LPRINT SPACE$(linelen); pgnum„				IF nummode = 5 THEN LPRINT SPACE$(39); pgnum„				END IF„		 END IF„	LPRINT CHR$(12);„END SUB„„SUB PrintSetup (pglines, topmar, btmar, leftmar, startnum, nummode)„SHARED ibox$()„„		 REDIM ibox$(9)„		 ibox$(0) = "Printer Options"„		 ibox$(1) = "8"„		 ibox$(2) = "15"„		 ibox$(3) = "Lines Per Page "„		 ibox$(4) = "Top Margin     "„		 ibox$(5) = "Bottom Margin  "„		 ibox$(6) = "Left Margin    "„		 ibox$(7) = "Page Numbering "„		 item = 1„		 CALL ItemBox(ibox$(), 21, 2, item)„		 IF item = 0 THEN EXIT SUB„		 IF item = 1 THEN„				ibox$(0) = "Lines Per Page"„				ibox$(1) = "9"„				ibox$(2) = "31"„				ibox$(3) = "66  - Letter Regular/Portrait  "„				ibox$(4) = "88  - Letter Condensed/Portrait"„				ibox$(5) = "84  - Legal Regular/Portrait   "„				ibox$(6) = "112 - Legal Condensed/Portrait "„				ibox$(7) = "51  - Landscape Regular        "„				ibox$(8) = "68  - Landscape Condensed      "„				item = 1„				CALL ItemBox(ibox$(), 39, 4, item)„				IF item = 0 THEN EXIT SUB„				pglines = VAL(ibox$(item + 2))„				EXIT SUB„				END IF„		 IF item = 2 THEN„				ibox$(0) = "Top Margin"„				ibox$(1) = "10"„				ibox$(2) = "27"„				ibox$(3) = "0  - No Top Margin         "„				ibox$(4) = "2  - 1/3-inch  or  1/4-inch"„				ibox$(5) = "4  - 2/3-inch  or  1/2-inch"„				ibox$(6) = "6  -   1-inch  or  3/4-inch"„				ibox$(7) = "8  - 1.3-inch  or    1-inch"„				ibox$(8) = "10 - 1.6-inch  or 1.25-inch"„				ibox$(9) = "12 -   2-inch  or  1.5-inch"„				item = 1„				CALL ItemBox(ibox$(), 39, 4, item)„				IF item = 0 THEN EXIT SUB„				topmar = VAL(ibox$(item + 2))„				EXIT SUB„				END IF„		 IF item = 3 THEN„				ibox$(0) = "Bottom Margin"„				ibox$(1) = "10"„				ibox$(2) = "27"„				ibox$(3) = "0  - No Bottom Margin      "„				ibox$(4) = "2  - 1/3-inch  or  1/4-inch"„				ibox$(5) = "4  - 2/3-inch  or  1/2-inch"„				ibox$(6) = "6  -   1-inch  or  3/4-inch"„				ibox$(7) = "8  - 1.3-inch  or    1-inch"„				ibox$(8) = "10 - 1.6-inch  or 1.25-inch"„				ibox$(9) = "12 -   2-inch  or  1.5-inch"„				item = 1„				CALL ItemBox(ibox$(), 39, 4, item)„				IF item = 0 THEN EXIT SUB„				btmar = VAL(ibox$(item + 2))„				EXIT SUB„				END IF„		 IF item = 4 THEN„				mar$ = STR$(leftmar / 10)„				CALL InputBox("Left Margin?", 5, 24, 14, 0, mar$)„				IF INSTR(mar$, CHR$(27)) > 0 THEN EXIT SUB„				leftmar = VAL(mar$) * 10„				EXIT SUB„				END IF„		 IF item = 5 THEN„				ibox$(0) = "Page Numbering"„				ibox$(1) = "10"„				ibox$(2) = "27"„				ibox$(3) = "0  - No Page Numbering     "„				ibox$(4) = "1  - Top Right Corner      "„				ibox$(5) = "2  - Top Center            "„				ibox$(6) = "3  - Top Left Corner       "„				ibox$(7) = "4  - Bottom Right Corner   "„				ibox$(8) = "5  - Bottom Center         "„				ibox$(9) = "New Starting Page Number   "„				item = 1„				CALL ItemBox(ibox$(), 39, 4, item)„				IF item = 0 THEN EXIT SUB„				IF item = 7 THEN„					 ans$ = STR$(startnum)„					 CALL InputBox("Starting Page Number?", 5, 24, 14, 0, ans$)„					 IF INSTR(ans$, CHR$(27)) > 0 THEN EXIT SUB„					 startnum = VAL(ans$)„					 EXIT SUB„					 END IF„				nummode = VAL(ibox$(item + 2))„				EXIT SUB„				END IF„END SUB„„SUB SaveLine„	SHARED scrnline, edline, doctxt() AS STRING„ „	IF edline = UBOUND(doctxt, 1) THEN BEEP: EXIT SUB„	doctxt(edline) = ""„	FOR t = 1 TO 80„			doctxt(edline) = doctxt(edline) + CHR$(SCREEN(scrnline, t))„			NEXT t„	doctxt(edline) = RTRIM$(doctxt(edline))„END SUB„„SUB SaveMode„	SHARED doctxt() AS STRING, filespec$, bcolor, fcolor„ „	b$ = filespec$„	CALL InputBox("File Name?", 60, 10, 8, 0, filespec$)„	IF filespec$ = CHR$(27) OR RTRIM$(filespec$) = "<NONE>" THEN„		 filespec$ = b$„		 EXIT SUB„		 END IF„	FOR edline = 1 TO UBOUND(doctxt, 1)„			IF RTRIM$(doctxt(edline)) <> "" THEN b = edline„			NEXT edline„	OPEN filespec$ FOR OUTPUT AS #1„	FOR edline = 1 TO b„			COLOR bcolor, fcolor„			LOCATE 1, 65„			PRINT USING "###"; edline;„			b$ = RTRIM$(doctxt(edline))„			IF RIGHT$(b$, 1) = CHR$(255) THEN„				 b$ = LEFT$(b$, LEN(b$) - 1) + CHR$(13) + CHR$(10)„				 ELSE„				 b$ = b$ + " "„				 END IF„			PRINT #1, b$;„			NEXT edline„	CLOSE #1„	SCREEN 0, 0, 0, 1„	LOCATE 24, 3„	PRINT LEFT$(filespec$ + SPACE$(12), 12);„	SCREEN 0, 0, 1, 1„END SUB„„SUB TextWrap„	SHARED a$, linelen, scrnline, scrncol, edline, doctxt() AS STRING„„	c$ = a$: ' Store last character typed in holder„	a$ = ""„	x = 1„„    WHILE SCREEN(scrnline, linelen - x) <> 32 AND SCREEN(scrnline, linelen - x) <> 45„		x = x + 1„		 IF x > linelen THEN„				BEEP: BEEP„				scrncol = scrncol - 1„				EXIT SUB„				END IF„		WEND„	el = linelen - x: ' Line Length„	b$ = ""„	FOR t = 1 TO el„			IF CHR$(SCREEN(scrnline, t)) <> CHR$(255) THEN„				 b$ = b$ + CHR$(SCREEN(scrnline, t))„				 END IF„			NEXT t„	FOR t = el + 1 TO 80„			IF CHR$(SCREEN(scrnline, t)) <> CHR$(255) THEN„				 a$ = a$ + CHR$(SCREEN(scrnline, t))„				 END IF„			NEXT t„	a$ = RTRIM$(a$)„	a$ = a$ + c$„	LOCATE CSRLIN, 1: PRINT SPACE$(79)„	LOCATE CSRLIN - 1, 1: PRINT b$; SPACE$(80 - el)„	CALL SaveLine„	IF edline < UBOUND(doctxt, 1) THEN„		 scrncol = LEN(a$) + 1„		 edline = edline + 1„		 a$ = a$ + " " + doctxt(edline)„		 END IF„	scrnline = scrnline + 1„	IF scrnline > 23 THEN scrnline = 23„END SUB„Craig Wright                   TEXT FILE VIEWER               e-mail anonymous               01-30-97 (14:40)       QB, QBasic, PDS        477  15100    VIEWER.BAS  'Description„'  QBasic simple plain ASCii text file viewer for _BIG_ files„'  Theoretical max file size (using QBasic) is about 16000 x 64kb„'  or 1 gb, using typical real-world files reduces this to 512 mb„„'  It was coded in response to a request from a beginner to show how„'  to view big files in QBasic and is _ONLY_ a shell <250 lines,„'  you can add whatever you want ; left/right scroll, mouse etc.„„'  This is not claimed to be the ideal solution just another method.„'  I may have gone a bit overboard on the comments :)„„'Pro's and Cons„'  Note that 16383 and 65535 have been rounded down.„„'  It's slow when scrolling from each 64kb chunk although this can„'  be reduced in size to make loading quicker. Lots of wasteage due to„'  file white space/overlap, even worse if long lines >80 need to be„'  viewed.„'  Using Pointer&(1000) and Text(64000 \ 80) requires 68kb and„'  allows about 800 000 lines.„'  The memory overhead can be reduced - Pointer&(2000) and„'  Text(32000 \ 80) requires 40kb and allows 800 000 lines !„„'  This is a best case, typical text files will not fill all of Text(),„'  assuming 50% wasteage in file white space and overlap still allows„'  400 000 lines.„„'  For small files a file pointer array and SEEK to beginning of each„'  line may be more appropriate but you MUST be using a cached drive„'  and a hard disk, using this method with uncached drives or floppy,„'  ZiP drives etc. will be very slow.„'  Using Pointer1&(16000) and Pointer2&(16000) requires 128kb and„'  allows 32 000 lines.„'  16000 &longs = 64kb = max QBasic array size„„'Notes„'  Instead of allocating an extra buffer (and associated code)„'  when scrolling down from one 64kb chunk of file to another, the„'  last bit of the previous 64kb chunk is used - overlap.„'  Code broken up to avoid word wrapping when >80 characters„„'Limits„'  Only handles 80 character line lengths„'  May be a noticeable delay for large files when loading in file„'  chunks unless a disk cache such as SMARTDRV is used„„'Bugs„'  Page Up/Dn needs sorting„'  Problem with displaying last file chunk if file>64kb, it'll„'  display but will also move up more than 1 line„'***************************************************************„„'$DYNAMIC„DEFINT A-Z„„DECLARE SUB BuildTable ()„DECLARE SUB CheckLimits ()„DECLARE SUB FindString (SearchFor$)„DECLARE SUB GetFileChunk ()„DECLARE SUB GetFileToView ()„DECLARE FUNCTION GetKey$ ()„DECLARE SUB ResetScreen ()„DECLARE SUB ViewFile ()„„„    'top and bottom rows of text mode view limits„CONST TopRow = 2„CONST BottomRow = 24„    'back and foreground colours valid values are 1-15„CONST BackColour = 1„CONST ForeColour = 7„„    'transition buffer size/overlap (in lines) when loading„    'from one 64kb chunk of file to another„CONST TransitionLines = BottomRow - TopRow + 1„„    'Allocate 64kb to hold all or part of file, if using in your„    'own code then set it to your preferred value and use REDIM„    'to de-allocate memory. Note that reducing its size will also„    'reduce delay between loading in each file chunk.„    '64kb = maximum size in Qbasic.„    'QuickBasic/PDS/VB for DOS users can increase this size„DIM SHARED Text(64000 \ 80) AS STRING * 80„„    'file position where 64kb chunks read from, max file size„    'using 1000 is about 1000 x 64kb, increase 1000 to view„    'larger files„DIM SHARED Pointer(1000) AS LONG„   „    'points to current 64kb chunk=Text() of file being viewed„DIM SHARED CurrentFilePosition AS INTEGER„    'total number of 64kb chunks in file„DIM SHARED TotalChunks AS INTEGER, FileName$, FileHandle AS INTEGER„DIM SHARED MaxLines AS INTEGER, LinesInText AS LONG, CurrentLine„„„KEY OFF„VIEW PRINT„„      'Kludge - increase typematic/scroll rate, only works if„      'MS DOS v6.xx MODE.COM available in the path and CMOS not„      'disabled it, different syntax required for other DOS's„      'Makes big difference to scroll rate if typematic rate is slow„      'Win v3.xx automatically increases typematic rate in DOS boxes„      'For QB/PDS/VB use a call interrupt„    SHELL "mode con rate=32 delay=1"„„    CLS„       „        'get total lines in array buffer„    LinesInText = UBOUND(Text)„„        'set to 1st 64kb chunk in file„    CurrentFilePosition = 1„„    GetFileToView„   „    BuildTable„   „        'load in first 64kb chunk„    GetFileChunk„     „    ViewFile„„    ResetScreen„    END„„„    '************* error handlers„BadPath:„ResetScreen„PRINT "Error ! unable to access your selected file -"„PRINT "  "; FileName$„PRINT„PRINT "An invalid path, drive or file name may have been used": END„„BadErase:„ResetScreen„PRINT "Error ! unable to access disk": END„„InitializeError:„ResetScreen„PRINT "Error ! unknown problem occurred when loading in file": END„„ProgramError:„ResetScreen„PRINT "Error ! internal program error occurred": END„„REM $STATIC„SUB BuildTable„  „    'builds the pointer table for byte position in file„    'where each 64kb chunk is to be loaded from„„    ON ERROR GOTO InitializeError„    PRINT„     „      'check if valid text file by getting line length of first„      'line, should really check all lines but this may be too„      'slow for big files„    LINE INPUT #FileHandle, a$„„    IF LEN(a$) > 80 THEN„        PRINT "Warning ! file contains lines that exceed 80 characters"„        PRINT "in length, it may not be a valid plain ASCii text file"„        PRINT„        PRINT "Press a key to continue or Q to quit"„        PRINT„        z$ = UCASE$(INPUT$(1))„        IF z$ = "Q" THEN END„    END IF„   „    PRINT : PRINT "Please wait - loading in file"„   „    SEEK #FileHandle, 1„„        'first 64kb chunk of file = 1„    TotalChunks = 1„        'first chunk in file always starts at byte 1„    Pointer(TotalChunks) = 1„„    DO WHILE NOT EOF(FileHandle)„        LINE INPUT #FileHandle, a$„        i = i + 1„       „        IF i > LinesInText - TransitionLines THEN„                'finished counting this 64kb chunk„            TotalChunks = TotalChunks + 1„            Pointer(TotalChunks) = SEEK(FileHandle)„               „                'check exceeds table array size„            IF TotalChunks = UBOUND(Pointer) THEN EXIT DO„           „                'show table being built, only needed for„                'large files and slow systems„            PRINT "±";„            i = 0„        END IF„  „    LOOP„   „    CLS„„END SUB„„SUB CheckLimits„       „        'moving up through file„        IF CurrentLine < 1 THEN„            CurrentLine = 1„            „                'if file is >64kb then load in previous 64 kb chunk„            IF TotalChunks > 1 THEN„                IF CurrentFilePosition > 1 THEN„                      'not at file beginning so load in previous„                      '64 kb chunk of file„                    CurrentFilePosition = CurrentFilePosition - 1„                    GetFileChunk„                    CurrentLine = MaxLines - TransitionLines + 1„                END IF„            END IF„        END IF„     „        'moving down through file„        IF CurrentLine > MaxLines - TransitionLines + 1 THEN„            CurrentLine = MaxLines - TransitionLines + 1„      „            IF TotalChunks > 1 THEN„                IF CurrentFilePosition < TotalChunks THEN„                        'not at file end„                    CurrentFilePosition = CurrentFilePosition + 1„                    GetFileChunk„                    CurrentLine = 1„                END IF„            END IF„        END IF„     „        IF CurrentLine < 1 THEN CurrentLine = 1„        IF CurrentLine > MaxLines THEN CurrentLine = MaxLines„„END SUB„„SUB FindString (SearchFor$)„„        'gotta have something to search for„    IF LEN(SearchFor$) < 1 THEN EXIT SUB„   „        'get original line and file position„    LastLine = CurrentLine„    LastPosition = CurrentFilePosition„       „        'make it case insensitive„    SearchFor$ = LCASE$(SearchFor$)„       „    LOCATE 1, 2, 0: PRINT "Searching "„   „    DO„            'show search in progress„        LOCATE 1, 13: PRINT USING "####"; CurrentLine„       „        CurrentLine = CurrentLine + 1„           „            'check if need to load in next bit of file„        IF CurrentFilePosition < TotalChunks THEN CheckLimits„       „        IF INSTR(1, LCASE$(Text(CurrentLine)), SearchFor$) > 0 THEN EXIT SUB„           „            'quit if last file chunk and last line in file„        IF CurrentLine >= MaxLines THEN EXIT DO„    LOOP„„   „        'nothing found so reset to original position in file„    CurrentLine = LastLine„    CurrentFilePosition = LastPosition„    GetFileChunk„    CheckLimits„    LOCATE 1, 2: PRINT "No matches found !"„    BEEP„    z$ = GetKey„„END SUB„„SUB GetFileChunk„    „    'loads in a 64kb chunk of the file at a time„   „        'make sure buffer is blank in case at end of file„    FOR i = 1 TO LinesInText„        Text(i) = ""„    NEXT„„        'go to file position where 64kb chunk to be loaded from„    SEEK #FileHandle, Pointer(CurrentFilePosition)„„    MaxLines = 0„„        'FOR loop not used as there may not be enough lines„        'to fill the buffer„    DO WHILE NOT EOF(FileHandle)„        LINE INPUT #FileHandle, a$„        „        MaxLines = MaxLines + 1„„            'Strip out form feeds - needs more checking„        DO„            i = INSTR(a$, CHR$(12))„            IF i > 0 THEN MID$(a$, i, 1) = " "„        LOOP UNTIL i = 0„       „            'strip out TABs„        DO„            i = INSTR(a$, CHR$(9))„            IF i > 0 THEN MID$(a$, i, 1) = " "„        LOOP UNTIL i = 0„„        Text(MaxLines) = a$„           „            'finished loading in this chunk„        IF MaxLines = LinesInText THEN EXIT DO„    LOOP„„END SUB„„SUB GetFileToView„   „        'get file to view and check it exists„   „    PRINT : INPUT "Enter file to view : ", FileName$„   „    IF LEN(FileName$) < 1 THEN„        PRINT : PRINT "Error ! no file selected": END„    END IF„„        'check file exists - trap invalid path, drive and file names„    ON ERROR GOTO BadPath„    FileHandle = FREEFILE„    OPEN FileName$ FOR BINARY AS #FileHandle„          „        'Open in binary mode will create a new file if none„        'exists, this is 0 bytes long - existing files are„        'usually >0 bytes long„    IF LOF(FileHandle) = 0 THEN„        CLOSE FileHandle„        PRINT "Error ! your selected file does not exist !"„        PRINT„            'clean up by erasing the new, zero length file„        ON ERROR GOTO BadErase„        KILL FileName$„        END„    END IF„„    CLOSE FileHandle„„        'file actually exists so open it in text mode„    FileHandle = FREEFILE„    OPEN FileName$ FOR INPUT AS #FileHandle„„END SUB„„FUNCTION GetKey$„   „        'returns a key press„    DO„        z$ = INKEY$„        LOCATE 1, 72: PRINT TIME$„    LOOP UNTIL z$ > ""„   „    GetKey$ = UCASE$(z$)„„END FUNCTION„„SUB ResetScreen„    'close all open files, reset colours, clear screen before„    'exit and switch on cursor„    CLOSE : COLOR 7, 0: CLS : LOCATE , , 0: PRINT„END SUB„„SUB ViewFile„„        'initial start position in array buffer„    CurrentLine = 1„        'total lines displayed on the screen„    LinesDisplayed = BottomRow - TopRow„„        'draw border & useful info„    COLOR 0, 7„    LOCATE 1, 1: PRINT SPACE$(80);„    LOCATE 25, 1: PRINT SPACE$(80);„    LOCATE 1, 35: PRINT "Press H for Help - ESCape quits";„    LOCATE 25, 2: PRINT "File : "; LEFT$(FileName$, 50);„    LOCATE 25, 60: PRINT "Size : "; LOF(FileHandle) \ 1000; "kb";„„        'main view loop„    ON ERROR GOTO ProgramError„„    DO„            'show info about buffer„        COLOR 0, 7„        LOCATE 1, 2, 0: PRINT "Chunk No/Line :";„        PRINT CurrentFilePosition; "/"; CurrentLine; "   "„        COLOR ForeColour, BackColour„        „          'display the file - as Text() is fixed length string„          'it will erase previously displayed lines - no erase„          'line routine or padding out to end of line required„        FOR i = 0 TO LinesDisplayed„            LOCATE TopRow + i, 1: PRINT Text(CurrentLine + i);„        NEXT„„        SELECT CASE GetKey„            CASE CHR$(0) + CHR$(72)         'Up„                CurrentLine = CurrentLine - 1„           „            CASE CHR$(0) + CHR$(80)         'Down„                CurrentLine = CurrentLine + 1„           „            CASE CHR$(0) + CHR$(73)         'Page Up„                CurrentLine = CurrentLine - LinesDisplayed„           „            CASE CHR$(0) + CHR$(81)         'Page Down„                CurrentLine = CurrentLine + LinesDisplayed„           „            CASE CHR$(0) + CHR$(71)         'Home„                CurrentLine = 0             'force update„                IF TotalChunks > 1 THEN CurrentFilePosition = 2„                CheckLimits„                CurrentLine = 1„           „            CASE CHR$(0) + CHR$(79)         'Endkey„                CurrentLine = MaxLines - TransitionLines + 2„                CurrentFilePosition = TotalChunks - 1„                CheckLimits„                CurrentLine = MaxLines - TransitionLines + 1„           „            CASE CHR$(13), CHR$(27)„                    'Return or ESCape key exits main loop„                EXIT DO„           „            CASE "F"„                COLOR 0, 7: LOCATE 1, 1: PRINT SPACE$(80);„                COLOR 7, 0„                LOCATE 1, 2, 1:„                INPUT "Enter text to search for : ", SearchFor$„                COLOR 0, 7: LOCATE 1, 1: PRINT SPACE$(80);„                FindString (SearchFor$)„                COLOR 0, 7: LOCATE 1, 1: PRINT SPACE$(80);„           „            CASE "R"„                    'repeat last find„                FindString (SearchFor$)„                COLOR 0, 7: LOCATE 1, 1: PRINT SPACE$(80);„           „            CASE "H"„                COLOR 7, 0„                FOR i = 7 TO 18     'clear partial screen„                    LOCATE i, 9: PRINT SPACE$(60)„                NEXT„                LOCATE 8, 11: PRINT "Help"„                LOCATE 9, 13: PRINT "Up/Down    - move"„                LOCATE 10, 13: PRINT "PageUp/Dn  - Page Up and Page Down"„                LOCATE 11, 13: PRINT "Home       - go to file beginning"„                LOCATE 12, 13: PRINT "End        - go to file end"„                LOCATE 13, 13: PRINT "CR/ESCape  - quit"„                LOCATE 14, 13: PRINT "F          - find text string, case insensitive"„                LOCATE 15, 13: PRINT "R          - repeat last find"„                LOCATE 16, 13: PRINT "H          - help !"„                z$ = GetKey„„        END SELECT„      „        'bit inefficient this - calls it twice„       CheckLimits„    LOOP„„END SUB„Dave Navarro, Jr.              TELEVISION SCREEN WIPE         dave@powerbasic.com            02-06-97 (14:04)       PB                     31   787      TELEWIPE.BAS'Television style wipe.  Clears from bottom and top at the same time to„'the middle, then clears the middle beginning with the sides.„'converted to PowerBASIC from Pascal code by Dave Navarro, Jr.„„DEFINT A-Z„„DIM DYNAMIC ScreenMem(0:1999) AT &HB800  'color video segment„„FOR L = 1 TO 12„  FOR Y = 12 TO 0 STEP -1„    FOR X = 0 TO 79„      Z = ScreenMem(X+(80*Y))„      ScreenMem(X+(80*Y)+80) = Z„      ScreenMem(X+(80*Y))    = 1792„    NEXT„    FOR X = 0 TO 79„      Z = ScreenMem(X+(80*(24-Y)))„      ScreenMem(X+(80*(24-Y))-80) = Z„      ScreenMem(X+(80*(24-Y)))    = 1792„    NEXT„  NEXT„  IF L < 12 THEN„    FOR z = 1 TO 8000 : NEXT„  END IF„NEXT„„FOR X = 0 TO 39„  ScreenMem(X+960)  = 1792„  Screenmem(1039-X) = 1792„  FOR z = 1 TO 13000: NEXT„NEXT„Dave Navarro, Jr.              MELT CHARACTERS OFF SCREEN     dave@powerbasic.com            02-06-97 (14:09)       PB                     32   1115     MELT.BAS    'Melt all the charactors off of the screen.„'by Dave Navarro, Jr.„'requires PowerBASIC 3.0 or later„„DEFINT A-Z„„Cells = pbvScrnRows * pbvScrnCols - 1„Range = Cells„„IF BIT(pbvScrnCard, 1) THEN„  DIM DYNAMIC ScreenMem(0:1999) AT &HB800  'color screen address„ELSE„  DIM DYNAMIC ScreenMem(0:1999) AT &HB000  'mono screen address„END IF„„DO„  Cells = Range                 'restore value„  FOR x = 0 TO Range„    cell = ScreenMem(x)         'get char & attribute from screen„    Char = ch AND &HFF          'isolate char„    IF Char = 32 THEN           'is it a space?„      Cell = &H0720             'yes, make sure it's white on black„      DECR Cells                'one less non-space on screen„    ELSEIF Char < 32 THEN       'is it a control char?„      INCR Cell                 'add one to move it closer to a space„    ELSE                        'it's above a space„      DECR Cell                 'so subtract one to move it close to a„space„    END IF„    ScreenMem(x) = Char         'put it back„  NEXT„LOOP WHILE Cells >= 0           'keep looping until their all spaces„Angelo Ken Pesce               TEXTMODE FIRE EFFECT           ken@uniserv.uniplan.it         02-10-97 (19:02)       QB, QBasic, PDS        75   1350     APS.BAS     'QBASIC TEXTMODE FIREEFFECT„'BY ANGELO KEN PESCE 1997„„SCREEN 0: WIDTH 80, 50„DEFINT A-Z„DIM scrbuf(80, 50)„„DO„GOSUB lastline„GOSUB randput„GOSUB fire„GOSUB updscr„LOOP„„END„REM ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBS„updscr:„LOCATE 1, 1„FOR y = 1 TO 49„FOR x = 1 TO 80„SELECT CASE scrbuf(x, y)„CASE 0 TO 9„COLOR 0, 0: PRINT " ";„CASE 10 TO 19„COLOR 4, 0: PRINT "∞";„CASE 20 TO 29„COLOR 4, 0: PRINT "±";„CASE 30 TO 39„COLOR 4, 0: PRINT "≤";„CASE 40 TO 44„COLOR 14, 4: PRINT " ";„CASE 45 TO 50„COLOR 14, 4: PRINT "∞";„CASE 51 TO 69„COLOR 14, 4: PRINT "±";„CASE 70 TO 89„COLOR 14, 4: PRINT "≤";„CASE 90 TO 124„COLOR 14, 4: PRINT "€";„CASE 125 TO 160„COLOR 15, 0: PRINT "€";„END SELECT„NEXT„NEXT„RETURN„„lastline:„FOR x = 1 TO 80„A = CINT(RND)„IF A = 1 THEN scrbuf(x, 50) = 0„IF A = 0 THEN scrbuf(x, 50) = 160„NEXT„RETURN„„randput:„FOR I = 1 TO 5„x = INT(79 * RND + 1)„y = INT(49 * RND + 1)„scrbuf(x, y) = 160„scrbuf(x, y + 1) = 160„scrbuf(x + 1, y + 1) = 160„NEXT„RETURN„„fire:„FOR x = 1 TO 79„FOR y = 1 TO 49„colr = scrbuf(x, y) + scrbuf(x + 1, y) + scrbuf(x, y + 1) + scrbuf(x - 1, y) + scrbuf(x, y - 1)„colr = INT(colr / 5.3 - INT(11 * RND - 5))„IF colr > 160 THEN colr = 160„IF colr < 0 THEN colr = 0„scrbuf(x, y - 1) = colr„NEXT„NEXT„RETURN„Wayne Robinson                 FIELD EDITOR                   harryst@castel.nl              03-02-88 (00:00)       QB, QBasic, PDS        277  7371     FLDEDIT.BAS „'  FldEdit()„'  by Wayne Robinson, Under the Sun Software„'  Data (201) 666-0519, The Covered Bridge, Phoenix 807/10„'„'  Field Editor for taking keyboard input from a specific„'  screen location of maximum length. Returns one string (FTemp$)„'  and one integer value (FRKey%).„'  Display this code with a TAB stop of 3 spaces for best result.„'  Version 2.0, 3/2/88„'„'  In order to trap function keys the variable FRKey% must be initialized„'  with a non-zero value for the call. This will enable the page, cursor,„'  function keys, and others to be trapped. If FRKey% is 0 coming into„'  FldEdit then only Escape and Carriage Return are trapped. In order to„'  parse for the occurance of one of these keys I suggest a test of FRKey%„'  at the return from FldEdit via a select case such as this one. FldEdit„'  will strip the leading 0's from extended keys and return only the second„'  value in FRKey%„'„'     SELECT CASE FRKey%„'        CASE 13  'CR note FldEdit v1.0 returned 0„'        CASE 27  'ESC„'        CASE 9   'TAB„'        CASE 59  'F1„'        CASE 60  'F2„'        .„'        .„'        .„'        .„'        CASE 71  'HOME„'        CASE 79  'END„'        CASE ELSE„'     END SELECT„'„'  The keys trapped with FRKey% are:„'           F1 - F10             0, 59 to 0, 68„'           Carriage Return      13„'           Escape               27„'           Tab                  9„'           Home                 0, 71„'           End                  0, 79„'           PgUp                 0, 73„'           PgDn                 0, 81„'           Cursor Up            0, 72„'           Cursor Down          0, 80„'„'  Parameters:„'  FRow% = ROW of first character of field„'  FCol% = Column of first character of field„'  FLength% = maximum length of field„'  FFore% = foreground color of text in field„'  FBack% = background color of text in field„'  FRKey% if 0 in then function keys are not parsed„'         if > 0 in then function keys are parsed and value returned„'  FTemp$ = String to edit. If not "" then this string will be placed„'           in the field by FldEdit with the correct attribute.„'           The edited string is returned in this variable.„„	SUB FldEdit (FRow%, FCol%, FLength%, FFore%, FBack%, FRKey%, FTemp$) STATIC„„'  Set boolean values„		CONST TRUE = -1„		CONST FALSE = 0„„'  Set color, ephasize field, insert string, and set cursor„		FSet% = FCol% - 1„		COLOR FFore%, FBack%„		LOCATE FRow%, FCol%, 0„		PRINT FTemp$; SPACE$(FLength% - LEN(FTemp$));„		LOCATE FRow%, FCol%, 1„„'  Check FRKey% and set page key functions„		IF FRKey% THEN„			PageSet% = TRUE„		ELSE„			PageSet% = FALSE„		END IF„„'  Initialize return key code, stop, reset insert mode„		FRKey% = FALSE„		FStop% = FALSE„		FInsert% = FALSE„„'  Set Editor Output string to new Input string„		FOut$ = FTemp$„„'  Start Parsing„		DO UNTIL FStop%„„'  Sound alarm if called for„			IF Alarm% THEN„				SOUND 1000, 1„				SOUND 1500, 2„				SOUND 500, 1„				Alarm% = FALSE„			END IF„„'  Get a key to parse„			FIn$ = ""„			DO„			FIn$ = INKEY$„			LOOP WHILE FIn$ = ""„„'  Start by parsing length of key string„			SELECT CASE LEN(FIn$)„„'  Check for extended key, strip leading zero„				CASE 2„				FIn$ = RIGHT$(FIn$, 1)„„'  Use ASCII value to select„					SELECT CASE ASC(FIn$)„„'  Cursor Right„						CASE 77„							IF POS(0) < FSet% + (LEN(FOut$) + 1) THEN„								LOCATE , POS(0) + 1„							ELSE„								Alarm% = TRUE„							END IF„„'  Cursor Left„						CASE 75„							IF POS(0) > FSet% + 1 THEN„								LOCATE , POS(0) - 1„							ELSE„								Alarm% = TRUE„							END IF„„'  Delete„						CASE 83„							IF POS(0) - FSet% <= LEN(FOut$) THEN„								Shift$ = MID$(FOut$, (POS(0) - FSet%) + 1)„								FOut$ = LEFT$(FOut$, ((POS(0) - FSet%) - 1)) + Shift$„								FTempPos% = POS(0)„								LOCATE , , 0„								PRINT MID$(FOut$, POS(0) - FSet%); CHR$(32);„								LOCATE , FTempPos%, 1„							ELSE„								Alarm% = TRUE„							END IF„„'  Insert„						CASE 82„							IF FInsert% = FALSE THEN„								FInsert% = TRUE„								LOCATE , , , 0, 7„							ELSEIF FInsert% = TRUE THEN„								FInsert% = FALSE„								LOCATE , , , 7, 7„							END IF„„'  Up, Down, PgUp, PgDn, Home, End„						CASE 59 to 68, 71, 72, 73, 79, 80, 81„							IF PageSet% THEN„								FRKey% = ASC(FIn$)„								FStop% = TRUE„							ELSE„								Alarm% = TRUE„							END IF„„'  Any other key is illegal so set alarm and loop„						CASE ELSE„							Alarm% = TRUE„„					END SELECT„„'  Check for non-extended keys„				CASE 1„„'  Use ASCII value to select„					SELECT CASE ASC(FIn$)„„'  Backspace„						CASE 8„							IF POS(0) - FSet% > 1 THEN„								IF POS(0) - FSet% > LEN(FOut$) THEN„									FOut$ = LEFT$(FOut$, LEN(FOut$) - 1)„									FTempPos% = POS(0)„									LOCATE , POS(0) - 1, 0„									PRINT CHR$(32);„									LOCATE , FTempPos% - 1, 1„								ELSEIF POS(0) - FSet% <= LEN(FOut$) THEN„									Shift$ = MID$(FOut$, POS(0) - FSet%)„									FOut$ = LEFT$(FOut$, ((POS(0) - FSet%) - 2)) + Shift$„									FTempPos% = POS(0)„									LOCATE , POS(0) - 1, 0„									PRINT MID$(FOut$, POS(0) - FSet%); CHR$(32);„									LOCATE , FTempPos% - 1, 1„								END IF„							ELSE„								Alarm% = TRUE„							END IF„„'  Tab„						CASE 9„							IF PageSet% THEN„								FRKey% = ASC(FIn$)„								FStop% = TRUE„							ELSE„								Alarm% = TRUE„							END IF„„'  Carriage Return„						CASE 13„							FRKey% = ASC(FIn$)„							FStop% = TRUE„„'  Escape„						CASE 27„							FRKey% = ASC(FIn$)„							FStop% = TRUE„„'  Check for additional uprintable input„						CASE IS < 32, IS > 125„							Alarm% = TRUE„„'  Found printable key„						CASE 32 TO 125„„'  If not past end of maximum length take input.„							IF POS(0) <= FSet% + FLength% THEN„„'  If position is less than current string length then check for insert„'  mode on and overwrite character if insert off or insert character if on.„								IF POS(0) - FSet% <= LEN(FOut$) THEN„„'  Insert mode off?„									IF FInsert% = FALSE THEN„										MID$(FOut$, POS(0) - FSet%, 1) = FIn$„										PRINT FIn$;„„'  Insert mode on?„									ELSEIF FInsert% = TRUE THEN„„'  Check length of string plus input and take input if less than max lenth.„										IF LEN(FOut$) < FLength% THEN„											Shift$ = MID$(FOut$, POS(0) - FSet%)„											FOut$ = LEFT$(FOut$, (POS(0) - FSet%) - 1) + FIn$ + Shift$„											FTempPos% = POS(0)„											LOCATE , , 0„											PRINT MID$(FOut$, POS(0) - FSet%);„											LOCATE , FTempPos% + 1, 1„„'  If string plus input too long sound alarm and return.„										ELSE„											Alarm% = TRUE„										END IF„									END IF„„'  If string position greater than current string length then add character.„								ELSEIF POS(0) - FSet% > LEN(FOut$) THEN„									FOut$ = FOut$ + FIn$„									PRINT FIn$;„								END IF„„'  Cursor past end of field so input is illegal„							ELSE„								Alarm% = TRUE„							END IF„„'  Any other key is illegal so set alarm and loop„						CASE ELSE„							Alarm% = TRUE„„					END SELECT„„			END SELECT„„		LOOP„„'  Exit, reset cursor, assign passed variable„		LOCATE , , 0, 7, 7„		FTemp$ = FOut$„„	END SUB„Paul N. Lawrence               POKE CHARACTER                 harryst@castel.nl              11-16-87 (00:00)       QB, QBasic, PDS        330  11001    POKECHAR.BAS' saved as:  pokechar.bas  11/16/87  by  Paul N. Lawrence (MicroHelp BUG BBS)„„DEFINT A-Z„DIM Char$(5)„over:„COLOR 15, 4„CLS„PRINT " What string to convert?"„PRINT„LINE INPUT i$: IF i$ = "" OR i$ = "end" OR i$ = "END" THEN END„User$ = i$„„GOSUB showchar:„„COLOR 14, 4„LOCATE 10, 1„FOR i = 1 TO 5„  PRINT LEFT$(Char$(i), 79)„NEXT„DO: LOOP UNTIL INKEY$ <> ""„GOTO over:„END„„showchar:„' User$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ?!.,;: abcdefghijklmnopqrstuvwxyz|?|!|.|,|;|:"„'          ^ UserPtr                                  NOTE: CHR$(124) ^„'             12345   WidthPtr, CharWidth„' Char$(1) = "....."  CharHeight„' Char$(2) = "....."„' Char$(3) = "....."„' Char$(4) = "....."„' Char$(5) = "....."  CharHeight, MaxHeight„„MaxHeight = 5„CharWidth = 6'                         | maximum width expected in DATA„FOR i = 1 TO MaxHeight'                | initialize array with spaces„  Char$(i) = SPACE$(LEN(User$) * CharWidth)'| leave room for maximum width„NEXT„„UserPtr = 1'                           | point to first character in input„CharPtr = 1'                           | point to first place in output array„„DO'                                    | go around until all input is used„„Char = ASC(MID$(User$, UserPtr, 1))„IF Char < 97 THEN HeightOffset = 0 ELSE HeightOffset = 2' | lower or upper„IF Char = 124 THEN '                   | lower case punctuation follows„  UserPtr = UserPtr + 1„  Char = ASC(MID$(User$, UserPtr, 1)) + 256„END IF„„' Large character data format:  DATA char.width, char.code, char.code,...„'   lower case punctuation has 256 added to ASCII value, and„'       must be preceded by a CHR$(124)„„SELECT CASE Char„CASE 97: RESTORE CHAR97:„CHAR97:„DATA 3,210,183,32,214,182,32,211,208,32„CASE 98: RESTORE CHAR98:„CHAR98:„DATA 3,183,32,32,199,183,32,211,208,32„CASE 99: RESTORE CHAR99:„CHAR99:„DATA 3,210,183,32,186,32,32,211,208,32„CASE 100: RESTORE CHAR100:„CHAR100:„DATA 3,32,183,32,214,182,32,211,208,32„CASE 101: RESTORE CHAR101:„CHAR101:„DATA 3,210,183,32,199,189,32,211,208,32„CASE 102: RESTORE CHAR102:„CHAR102:„DATA 3,210,183,32,199,196,32,211,32,32„CASE 103: RESTORE CHAR103:„CHAR103:„DATA 3,210,183,32,211,182,32,211,208,32„CASE 104: RESTORE CHAR104:„CHAR104:„DATA 3,183,32,32,199,183,32,211,211,32„CASE 105: RESTORE CHAR105:„CHAR105:„DATA 2,211,32,186,32,211,32„CASE 106: RESTORE CHAR106:„CHAR106:„DATA 3,32,211,32,32,186,32,211,208,32„CASE 107: RESTORE CHAR107:„CHAR107:„DATA 4,183,32,32,32,199,210,189,32,189,211,189,32„CASE 108: RESTORE CHAR108:„CHAR108:„DATA 2,183,32,186,32,211,32„CASE 109: RESTORE CHAR109:„CHAR109:„DATA 4,210,210,183,32,186,186,186,32,211,211,211,32„CASE 110: RESTORE CHAR110:„CHAR110:„DATA 3,210,183,32,186,186,32,211,211,32„CASE 111: RESTORE CHAR111:„CHAR111:„DATA 3,210,183,32,186,186,32,211,208,32„CASE 112: RESTORE CHAR112:„CHAR112:„DATA 3,210,183,32,199,189,32,211,32,32„CASE 113: RESTORE CHAR113:„CHAR113:„DATA 3,210,183,32,211,182,32,32,211,32„CASE 114: RESTORE CHAR114:„CHAR114:„DATA 3,210,183,32,186,32,32,211,32,32„CASE 115: RESTORE CHAR115:„CHAR115:„DATA 3,210,183,32,211,183,32,211,208,32„CASE 116: RESTORE CHAR116:„CHAR116:„DATA 4,32,183,32,32,196,182,196,32,32,211,208,32„CASE 117: RESTORE CHAR117:„CHAR117:„DATA 4,183,32,214,32,186,32,186,32,211,196,208,32„CASE 118: RESTORE CHAR118:„CHAR118:„DATA 3,183,214,32,186,186,32,211,208,32„CASE 119: RESTORE CHAR119:„CHAR119:„DATA 4,183,32,214,32,186,186,186,32,211,208,208,32„CASE 120: RESTORE CHAR120:„CHAR120:„DATA 3,183,214,32,215,215,32,189,211,32„CASE 121: RESTORE CHAR121:„CHAR121:„DATA 4,183,32,214,32,211,210,189,32,32,208,32,32„CASE 122: RESTORE CHAR122:„CHAR122:„DATA 3,196,183,32,210,208,32,211,196,32„CASE 305: RESTORE CHAR305:„CHAR305:„DATA 2,183,32,186,32,208,32„CASE 306: RESTORE CHAR306:„CHAR306:„DATA 3,218,183,32,214,189,32,211,217,32„CASE 307: RESTORE CHAR307:„CHAR307:„DATA 3,218,183,32,32,182,32,192,189,32„CASE 308: RESTORE CHAR308:„CHAR308:„DATA 3,191,183,32,192,182,32,32,208,32„CASE 309: RESTORE CHAR309:„CHAR309:„DATA 3,214,191,32,211,183,32,192,189,32„CASE 310: RESTORE CHAR310:„CHAR310:„DATA 3,214,191,32,199,183,32,211,189,32„CASE 311: RESTORE CHAR311:„CHAR311:„DATA 3,218,183,32,32,186,32,32,208,32„CASE 312: RESTORE CHAR312:„CHAR312:„DATA 3,214,183,32,199,182,32,211,189,32„CASE 313: RESTORE CHAR313:„CHAR313:„DATA 3,214,183,32,211,182,32,192,189,32„CASE 304: RESTORE CHAR304:„CHAR304:„DATA 3,214,183,32,186,186,32,211,189,32„CASE 319: RESTORE CHAR319:„CHAR319:„DATA 4,214,196,220,32,32,219,32,32,32,254,32,32„CASE 289: RESTORE CHAR289:„CHAR289:„DATA 2,220,32,219,32,254,32„CASE 300: RESTORE CHAR300:„CHAR300:„DATA 2,32,32,32,32,191,32„CASE 302: RESTORE CHAR302:„CHAR302:„DATA 2,32,32,32,32,254,32„CASE 314: RESTORE CHAR314:„CHAR314:„DATA 2,32,32,254,32,254,32„CASE 315: RESTORE CHAR315:„CHAR315:„DATA 2,32,32,254,32,191,32„CASE 65: RESTORE CHAR65:„CHAR65:„DATA 5,186,223,223,186,32,186,32,32,186,32,199,196,196,182,32,186,32,32,186,32,186,32,32,186,32„CASE 66: RESTORE CHAR66:„CHAR66:„DATA 6,186,223,223,186,32,32,186,32,32,186,32,32,199,196,196,208,183,32,186,32,32,32,186,32,186,220,220,220,186,32„CASE 67: RESTORE CHAR67:„CHAR67:„DATA 5,186,223,223,186,32,186,32,32,32,32,186,32,32,32,32,186,32,32,32,32,186,220,220,186,32„CASE 68: RESTORE CHAR68:„CHAR68:„DATA 5,186,223,223,183,32,186,32,32,186,32,186,32,32,186,32,186,32,32,186,32,186,220,220,189,32„CASE 69: RESTORE CHAR69:„CHAR69:„DATA 5,186,223,223,32,32,186,32,32,32,32,199,196,180,32,32,186,32,32,32,32,186,220,220,186,32„CASE 70: RESTORE CHAR70:„CHAR70:„DATA 5,186,223,223,186,32,186,32,32,32,32,199,196,180,32,32,186,32,32,32,32,186,32,32,32,32„CASE 71: RESTORE CHAR71:„CHAR71:„DATA 5,186,223,223,186,32,186,32,32,32,32,186,32,195,183,32,186,32,32,186,32,186,220,220,186,32„CASE 72: RESTORE CHAR72:„CHAR72:„DATA 5,186,32,32,186,32,186,32,32,186,32,199,219,219,182,32,186,32,32,186,32,186,32,32,186,32„CASE 73: RESTORE CHAR73:„CHAR73:„DATA 6,223,223,186,223,223,32,32,32,186,32,32,32,32,32,186,32,32,32,32,32,186,32,32,32,220,220,186,220,220,32„CASE 74: RESTORE CHAR74:„CHAR74:„DATA 5,32,32,32,186,32,32,32,32,186,32,214,180,32,186,32,186,32,32,186,32,186,220,220,186,32„CASE 75: RESTORE CHAR75:„CHAR75:„DATA 5,186,32,32,186,32,186,32,32,186,32,186,220,220,189,32,186,32,211,183,32,186,32,32,186,32„CASE 76: RESTORE CHAR76:„CHAR76:„DATA 5,186,32,32,32,32,186,32,32,32,32,186,32,32,32,32,186,32,32,32,32,186,220,220,186,32„CASE 77: RESTORE CHAR77:„CHAR77:„DATA 6,186,223,210,223,186,32,186,32,186,32,186,32,186,32,208,32,186,32,186,32,32,32,186,32,186,32,32,32,186,32„CASE 78: RESTORE CHAR78:„CHAR78:„DATA 6,186,223,183,32,186,32,186,32,186,32,186,32,186,32,186,32,186,32,186,32,186,32,186,32,186,32,211,220,186,32„CASE 79: RESTORE CHAR79:„CHAR79:„DATA 5,186,223,223,186,32,186,32,32,186,32,186,32,32,186,32,186,32,32,186,32,186,220,220,186,32„CASE 80: RESTORE CHAR80:„CHAR80:„DATA 5,186,223,223,186,32,186,32,32,186,32,186,220,220,186,32,186,32,32,32,32,186,32,32,32,32„CASE 81: RESTORE CHAR81:„CHAR81:„DATA 6,186,223,223,186,32,32,186,32,32,186,32,32,186,32,32,186,32,32,186,32,32,186,32,32,186,219,219,199,183,32„CASE 82: RESTORE CHAR82:„CHAR82:„DATA 5,186,223,223,186,32,186,32,32,186,32,186,220,220,189,32,186,32,211,183,32,186,32,32,186,32„CASE 83: RESTORE CHAR83:„CHAR83:„DATA 5,186,223,223,186,32,186,32,32,32,32,211,196,196,183,32,32,32,32,186,32,186,220,220,186,32„CASE 84: RESTORE CHAR84:„CHAR84:„DATA 6,223,223,186,223,223,32,32,32,186,32,32,32,32,32,186,32,32,32,32,32,186,32,32,32,32,32,186,32,32,32„CASE 85: RESTORE CHAR85:„CHAR85:„DATA 6,186,32,32,186,32,32,186,32,32,186,32,32,186,32,32,186,32,32,186,32,32,186,32,32,186,220,220,199,183,32„CASE 86: RESTORE CHAR86:„CHAR86:„DATA 5,186,32,32,186,32,186,32,32,186,32,186,32,32,186,32,186,32,32,186,32,211,220,220,189,32„CASE 87: RESTORE CHAR87:„CHAR87:„DATA 6,186,32,32,32,186,32,186,32,32,32,186,32,186,32,210,32,186,32,186,32,186,32,186,32,186,220,208,220,186,32„CASE 88: RESTORE CHAR88:„CHAR88:„DATA 6,186,32,32,32,186,32,211,191,32,214,189,32,32,214,219,189,32,32,214,189,32,192,183,32,186,32,32,32,186,32„CASE 89: RESTORE CHAR89:„CHAR89:„DATA 6,186,32,32,32,186,32,186,32,32,32,186,32,211,220,32,220,189,32,32,32,186,32,32,32,32,32,186,32,32,32„CASE 90: RESTORE CHAR90:„CHAR90:„DATA 5,223,223,223,186,32,32,32,214,189,32,32,214,189,32,32,214,189,32,32,32,186,220,220,220,32„CASE 49: RESTORE CHAR49:„CHAR49:„DATA 4,223,186,32,32,32,186,32,32,32,186,32,32,32,186,32,32,220,186,220,32„CASE 50: RESTORE CHAR50:„CHAR50:„DATA 5,186,223,223,186,32,32,32,32,186,32,214,196,196,189,32,186,32,32,32,32,186,220,220,186,32„CASE 51: RESTORE CHAR51:„CHAR51:„DATA 5,186,223,223,186,32,32,32,32,186,32,32,32,196,182,32,32,32,32,186,32,186,220,220,186,32„CASE 52: RESTORE CHAR52:„CHAR52:„DATA 5,186,32,32,186,32,186,32,32,186,32,186,220,220,186,32,32,32,32,186,32,32,32,32,186,32„CASE 53: RESTORE CHAR53:„CHAR53:„DATA 5,186,223,223,223,32,186,32,32,32,32,211,196,196,183,32,32,32,32,186,32,220,220,220,186,32„CASE 54: RESTORE CHAR54:„CHAR54:„DATA 5,186,223,223,32,32,186,32,32,32,32,199,196,196,183,32,186,32,32,186,32,186,220,220,186,32„CASE 55: RESTORE CHAR55:„CHAR55:„DATA 5,223,223,223,186,32,32,32,32,186,32,32,32,32,186,32,32,32,32,186,32,32,32,32,186,32„CASE 56: RESTORE CHAR56:„CHAR56:„DATA 5,186,223,223,186,32,186,32,32,186,32,199,196,196,182,32,186,32,32,186,32,186,220,220,186,32„CASE 57: RESTORE CHAR57:„CHAR57:„DATA 5,186,223,223,186,32,186,32,32,186,32,211,196,196,182,32,32,32,32,186,32,32,32,32,186,32„CASE 48: RESTORE CHAR48:„CHAR48:„DATA 5,186,223,223,186,32,186,32,218,182,32,186,218,217,186,32,199,217,32,186,32,186,220,220,186,32„CASE 63: RESTORE CHAR63:„CHAR63:„DATA 5,186,223,223,186,32,32,32,214,189,32,32,214,189,32,32,32,186,32,32,32,32,220,32,32,32„CASE 33: RESTORE CHAR33:„CHAR33:„DATA 4,186,219,186,32,186,219,186,32,186,219,186,32,211,210,189,32,32,220,32,32„CASE 44: RESTORE CHAR44:„CHAR44:„DATA 2,32,32,32,32,32,32,32,32,191,32„CASE 46: RESTORE CHAR46:„CHAR46:„DATA 2,32,32,32,32,32,32,32,32,220,32„CASE 58: RESTORE CHAR58:„CHAR58:„DATA 2,32,32,32,32,223,32,220,32,32,32„CASE 59: RESTORE CHAR59:„CHAR59:„DATA 2,32,32,32,32,223,32,220,32,223,32„CASE ELSE: RESTORE CHAR999„CHAR999:„DATA 2,32,32,32,32,32,32,32,32,32,32„END SELECT„„READ CharWidth„FOR CharHeight = (1 + HeightOffset) TO MaxHeight' puts lower in bottom 3/5„  FOR WidthPtr = CharPtr TO (CharPtr + CharWidth - 1)„    READ CharData„    MID$(Char$(CharHeight), WidthPtr, 1) = CHR$(CharData)„  NEXT„NEXT„CharPtr = CharPtr + CharWidth'         | adjust for next output„UserPtr = UserPtr + 1'                 | look at next input„„LOOP UNTIL UserPtr > LEN(User$)'       | do until no more input„„FOR i = 1 TO MaxHeight'                | truncate to actual size„  Char$(i) = LEFT$(Char$(i), (CharPtr - 1))„NEXT„„RETURN„Marc van den Dikkenberg        ROT-13 ENCODER/DECODER         excel@xs4all.nl                02-27-97 (01:13)       QB, QBasic, PDS, PB    24   557      ROT13.BAS   ' ROT-13 encoder/decoder„' Created 26-02-1997„' By Marc van den Dikkenberg (pb@excelsior.xs4all.nl)„' „' http://pitel-lnx.ibk.fnt.hvu.nl/~excel/pb.html „'„test$="This is a test"„„print "Original - "test$„call rot13(test$)„print "ROT-13   - "test$„„SUB ROT13(test$)„  for tt=1 to len(test$)„    y%=0„    x%=asc(mid$(test$,tt,1))„    if (x%>64 and x%<91) or (x%>96 and x%<123) then„      y%=13„      x%=x%-y%„      if x%<97 and x%>83 then x%=x%+26 else if x%<65 then x%=x%+26„    end if„    mid$(test$,tt,1)=chr$(x%)„  next tt„END SUB„Nick Kochakian                 TEXT LIGHT                     NickK@worldnet.att.net         03-02-97 (06:56)       QB, QBasic, PDS        99   1663     TXTLIGHT.BASDECLARE SUB txtlight (x!, y!, delay!, txt$)„'Text light„'„'3/2/97„'1997 By: - Nick Kochakian -„'„'This program should look something like that thing on the top of the screen„'of the advanced ABC reader.„'„'My e-mail: nickK@worldnet.att.net„'„'If you decide to use this program in one of yours please give me credit!„'„'Have fun! :)„„CLS„txt$ = " Text Light 1997 By: - Nick Kochakian  :) " 'Your message should be„                                                    'no longer that 80„                                                    'characters„x = 1„y = 1„delay = 7000„„CALL txtlight(x, y, delay, txt$)„„SUB txtlight (x, y, delay, txt$)„y1 = y 'Rear„y2 = y + 1 'Middle„y3 = y + 2 'Front„„y4 = y + 3„y5 = y + 4„„y6 = y1 - 1„y7 = y5 + 1„„dirs = 1„„txtlen = LEN(txt$)„„DO„'LOCATE x, y„„LOCATE x, y1„COLOR 8„PRINT MID$(txt$, y1, 1);„„LOCATE x, y2„COLOR 7„PRINT MID$(txt$, y2, 1);„„LOCATE x, y3„COLOR 15„PRINT MID$(txt$, y3, 1);„„LOCATE x, y4„COLOR 7„PRINT MID$(txt$, y4, 1);„„LOCATE x, y5„COLOR 8„PRINT MID$(txt$, y5, 1);„„IF dirs = 1 THEN„y5 = y5 + 1„y = y + 1„y4 = y4 + 1„y3 = y3 + 1„y2 = y2 + 1„y1 = y1 + 1„END IF„„IF dirs = 2 THEN„y1 = y1 - 1„y = y - 1„y5 = y5 - 1„y4 = y4 - 1„y3 = y3 - 1„y2 = y2 - 1„END IF„„IF y5 > txtlen THEN dirs = 2„IF y1 < x + 1 THEN dirs = 1„„FOR i = 1 TO delay„NEXT i„FOR i = 1 TO delay„NEXT i„„IF dirs = 1 THEN y6 = y1 - 1„IF dirs = 1 THEN IF y6 < 1 THEN y6 = y - 1 ELSE LOCATE x, y6: PRINT " "„„IF dirs = 2 THEN y7 = y5 + 1„IF dirs = 2 THEN IF y7 > 80 THEN y7 = y5 + 1 ELSE LOCATE x, y7: PRINT " "„LOOP UNTIL INKEY$ <> ""„„„END SUB„„The ABC Programmer             TURN SCREEN ON AND OFF         SCREEN.SWG                     03-04-97 (18:20)       QB, QBasic, PDS        35   910      SCRONOFF.BAS'>I use alot of line draws and some text on the screen....the lines come out„'>first and then the text a second or two later....is there a way so that the„'>whole output comes at once.  I tried Setvisualpage and setactivepage but the„'>the whole output screen is off.„„' I'm not completely sure how it works, but it looks like the original„' coder is switching bitplanes to create the effect.„„DEFINT A-Z„DECLARE SUB ScreenOn ()„DECLARE SUB ScreenOff ()„„  PRINT "Turning Screen Off..."„  A$ = INPUT$(1)„  ScreenOff„  PRINT "Can you see this??"„  PRINT "Can you see this??"„  PRINT "Can you see this??"„  PRINT "Can you see this??"„  PRINT "Can you see this??"„  PRINT "Can you see this??"„  PRINT "Can you see this??"„  A$ = INPUT$(1)„  ScreenOn„END„„SUB ScreenOff„  OUT &H3C4, 1„  OUT &H3C5, (INP(&H3C5) OR &H20)„END SUB„„SUB ScreenOn„  OUT &H3C4, 1„  OUT &H3C5, 0„END SUB„The ABC Programmer             SHINE FX TEXT                  Convert from Pascal code       03-04-97 (18:20)       QB, QBasic, PDS        107  3609     SHINEFX.BAS '/--------------------------------------------------------------\„'| SHINE FX TEXT  Converted from Pascal code by William Yu       |„'|                Released to the Public Domain (03-01-97)       |„'|                                                               |„'| Cheap plugs: Do you remember TheDraw's (v4.6+) shiny intro?   |„'|              How about TouchStone(tm) Pictures shiny ending?  |„'\--------------------------------------------------------------/„„DECLARE SUB Init.XTable ()„DECLARE SUB Shine (sx%, sy%, ex%, ey%, C%)„DECLARE SUB ShowImage ()„DEFINT A-Z„„' Shine FX (Pascal version) - by Christopher J. C.„' inspired by lotsa product out there that use this kind of FX„„' This code is public domain.  Do whatever you want with it.„„' A credit line for me would be nice  ;^p„„CONST MaxRow = 25„CONST MaxColumn = 80„„DIM SHARED XTable(1 TO MaxRow) AS INTEGER„„DEF SEG = &HB800„„ Init.XTable„ ShowImage„ DO„   Shine 1, 1, 31, 12, 15„ LOOP UNTIL INKEY$ <> ""„„END„„SUB Init.XTable„  FOR cnt = 0 TO MaxRow - 1„    XTable(cnt + 1) = -cnt„  NEXT cnt„END SUB„„SUB Shine (sx, sy, ex, ey, C)„„DIM Buffer(1 TO MaxRow) AS INTEGER     ' Add or remove the number„DIM Buffer2(1 TO MaxRow) AS INTEGER    ' of light sequences as desired, and„DIM Buffer3(1 TO MaxRow) AS INTEGER    ' delete necessary code from below„„ cnt = 0„ FOR x = sx TO ex + ey - sy„   FOR y = sy TO ey„     IF (XTable(y - sy + 1) + x > sx - 1) AND (XTable(y - sy + 1) + x < ex + 1) THEN„       num = (y - 1) * 160 + (XTable(y - sy + 1) + (x - 1)) * 2 + 1„       Buffer(y) = PEEK(num)                    'save background attr.„       Buffer2(y) = PEEK(num + 2)               '2nd save„       Buffer3(y) = PEEK(num + 4)               '3rd save„       POKE num, C + (Buffer(y) AND 240)        'highlight the spot„                                                'Just change the attribute„       POKE num + 2, C + (Buffer2(y) AND 240)   '2nd highlight„       POKE num + 4, C + (Buffer3(y) AND 240)   '3rd highlight„     END IF„   NEXT y„„   WAIT &H3DA, 8     ' Wait for retrace, else chaos erupts!„  „   FOR y = sy TO ey„     IF (XTable(y - sy + 1) + x > sx - 1) AND (XTable(y - sy + 1) + x < ex + 1) THEN„       'restore background attr.„       ' 1st, 2nd, then 3rd„       POKE ((y - 1) * 160 + (XTable(y - sy + 1) + (x - 1)) * 2 + 1), Buffer(y)„       POKE ((y - 1) * 160 + (XTable(y - sy + 1) + (x - 1)) * 2 + 1) + 2, Buffer2(y)„       POKE ((y - 1) * 160 + (XTable(y - sy + 1) + (x - 1)) * 2 + 1) + 4, Buffer3(y)„     END IF„   NEXT y„ NEXT x„END SUB„„SUB ShowImage„„ FOR cnt = 1 TO 7„   LOCATE cnt + 1, 1: COLOR 11: PRINT "€"„   LOCATE cnt + 4, 31: COLOR 9: PRINT "€"„ NEXT cnt„ COLOR , 3„ FOR cnt = 2 TO 11„   LOCATE cnt, 2: PRINT SPACE$(29)„ NEXT cnt„ „ COLOR 11, 0„LOCATE 1, 1: PRINT "‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹";„COLOR 3: PRINT "‹"„LOCATE 12, 1: PRINT "ﬂ";„COLOR 9: PRINT "ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ"„COLOR , 3: LOCATE 9, 1: COLOR 11: PRINT "≤"„LOCATE 10, 1: PRINT "±": LOCATE 11, 1: PRINT "∞"„LOCATE 4, 31: COLOR 9: PRINT "≤"„LOCATE 3, 31: PRINT "±": LOCATE 2, 31: PRINT "∞"„COLOR 11: LOCATE 3, 10: PRINT "Shine FX Text"„COLOR 8: LOCATE 4, 7: PRINT "ƒÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕƒ"„COLOR 12: LOCATE 5, 9: PRINT "Pascal Code by"„COLOR 1: LOCATE 6, 8: PRINT "Christopher J. C."„COLOR 12: LOCATE 7, 9: PRINT "BASIC Code by"„COLOR 1: LOCATE 8, 11: PRINT "William Yu"„COLOR 8: LOCATE 9, 7: PRINT "ƒÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕƒ"„COLOR 11: LOCATE 10, 4: PRINT "Add a little shine to the"„LOCATE 11, 5: PRINT "usually boring screen"„„END SUB„Mark Glenn                     TEXT TO EXECUTABLE BASIC CODE  fglenns@ix.netcom.com          03-19-97 (19:16)       QB, QBasic, PDS        453  29890    CATGEN30.BASDEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"CATGEN30.ZIP",4^6:Z&=22164:?STRING$(50,177);„U"%up()%9%%%R-%Eb8AG,94-bZ)%%%;1%%%1%%%%fs%xnWh%fySgRfx&%<X>T[C5M„U"\o6xZo^DjcNjouH.<FI?9XGY5Uq[ENv)ObN<Y79mdGY#o)Vcvf$kRmnok>q<_<t„U"bp\4;^F#8I8CZwT]uV+u9THHOD:ZU97Xqf?_9DwDe?N:p.zn_ZV<vJ;6_i9^OM.„U"$3iLEV[4h+B0k?y1dF7w[ck9#t&[;HDc&_F,P1U\^8lf,q9c1^&0g=shs9#ks4_„U"CbFW<d9_9,%IRC;dX'qu3[3Cu6aVq4-UM*YuDDWh0,UYFdHNfUd<U4x-A+'+e0Y„U".t6R18r/7#[^(2N83p:FJfZ?hdG$5GezRVW%MexD8t2H8L:,%+C$:yFZv+r8Qlb„U"Zzc:^rV1h&a-(^]%XDt]-o3&%%[a$JWuuB#pj?sj^n_n)T%eu:6uk=a0C=]H6M\„U"Oz%A3C)0_s)CBQLLKdeHOT2,$q#<s]ZR*E9CR]Rh'R?/$a#yI0O)Nj62E:aS#%g„U".8,9.u7&s&Jm<:Xd3.2eLa=P>Q36_#ySBu=;^DS&Eeg&?:jJPkXiNIp^rGOoG2/„U"vP8nmO0a'a\+z=BND=0+%i%0C%G%F'b)_?cuC%\=v]M?VO9>RqhC9\RnX&TEE,j„U"'*4lUJ1uqohp4[DJ_fYN:m'NbiM/+^8Bad7PX+wY4:<m+CStG^W^(8;#=J5,THv„U"H_#;SGyjJ8*O*cq_(Sja=b#+Ng$f>cVB_coJ'O^dH9>^lPmJ<$UJAr?s+Izcqsq„U"xm]SALqaCXH28j+pDNbJkSAnLrTa4k-Nt$J5DqZg]HMruncL<'\<\%5,?Y0+CP5„U"l_gaoJWJz)^203'+Pb#fvc$nxM=O?(N[K1)?=dSj96&:c1b-NDhuN#&wHFw%lX&„U"Op%5,E%UVv-3<.*LI3qQ8*g])Ff#:17%.N1eX9*WTosjF(ca+5?&q$?3O)J+Hi=„U"RBq#;lv1Ms&boq^]#9D5/)\boOg7\SGF6qU#CD+uhi9T^Bpzq.9X<Vo<j&%tWx0„U"&ug7kP2k[_]J6fIy*hcly-dS',E%y9$S:',+s5d.ky\y?ZAp=c571NBJgYP2ue#„U"8W*.2C$d87Bga3H(6=M/Uk(<m=pmB5UxaQ4gb)PIUrKfYCu8_WgVJkJx,J6Z:IX„U"gHm+xdff^1>Q8#,Ftob/(Ej%%XM3Iyw4Xkp;fnLTvlwQ0*^bg$NJWy-y>vOE,Y(„U";5>\?qsW0cZR^sF%s+^nwcsJb>dP0<6[tbW'?,<s7gT]Bj?jHqK2o$iLgheLYJ8„U"XC:jC0'>;B2>yrr,<-(1a\r4Z>I#V/'PD1js$.fFKVR*p+P>em)(g.zB9gJnl7e„U"xw6C0t\Y.7;?h]wqM_m'^cSm0GZEGvx^FKV9WQjmu>Wpio5VX98uCxmR)3&mmVj„U"rHQn-/cu&m;)xWWYM>)YoW9);w&:F_Ghs:9O#CWh;gLf83)RUEtiV>%KE5X936d„U"mA0Bg0XRMtaAu_;.)\EpypE6G(maRlTIt&=CZCTPbnLfYKK_nf'grF6i%\up(%)„U"9%%#%-%z_bAG4J/k;1[5%%=%N%%/%%%%h%fylj%sSitLht)<G>Tmauw79w>V;Y%„U"#l]j$VlGkQu<FB+UA:PeUae5hEUfhZ8;n6KfRAEL?+g#T<'-3n(o#W(/k+biM3D„U"DD'6czRlqj6%iu6,9uLT:iN(NHh?]N1,\vDd72VFM0SfKPTOX/OTP,tlylmpejE„U"$%z^9i^Lj<JV4op$bc;qN>>dpDNwsC<(]lXRh$fX4\^C(cbLT(vD3+i?PQ+$+jo„U"^0YRwQ?,4qE$Pd(4_U.T9Y%q$7[VB8J/%b8uQ;%EI;,6)[2hu&mC(XRm5C^DZSW„U"$GZh;^^liK3uQiIudw06[dsA8rw8W^#n%d$2XkaO,#Pl%6nuTsU6nfUs5D0>p67„U"U*lo/e;XckoO;?T[OcddFZKP6Yaqq<F4'zdLg)hvT?qhg;E\=Gkyk7E?qk5,YNP„U"td]>zv+kzB7rJ?d(O:Na%sYDs&GOTDgw+w&u:GMX6B^v9y#kz(bJ7ZQgKZu2eD%„U")cD3qVOsLM_z6b$PHlgRjwR[GD4k,ZO&dl3Lm;3J'sM*Rk8Z..PB]>9^+q>(>8z„U"Jb*1_]ck7,0bD_2'+ervqs7<>0LDI?pGa#r4BdG:a?_V#C9EQ%X8bac/9^0HteV„U"bg\4nQ<Q5H#zp)joGNC1'gII8tNYti4..-LiodTb'BQd^#Q,/w'cIHSw9D2Etkl„U":*sjIMvwzZ3SJ*i%.tvh2Fd=af7^j5D.]S=RKU8QWjK/KKR*^<3u4zac2q0rQ\%„U"LJfaX;Y6*FBzAW%uqW3AfDPzCFl'>Cwp6OW<n/Pz,9<q<IV?s.VF/X3s9uOY0?&„U"DQbb5H[dm$JV'BYFAufY]>R&m$[7.Vx(h*L#a<4(#gw?Ao%+dNq)4\Y6:G%h^R]„U"Jf(qP(Q6&b<o\ekP6ag=W<4kw[Trk>#B8v4ePd&&GZ[>O)TX6^q#,4J=[o_.7iT„U"kDU&:CvWoLOR;s8cNQ>qJQJicr'T4O$g,?.+.,&*pKuIj8vbXCEjgjzE_:Ut-/I„U"4y_Fw3o#$^uC>=HAzl9IgtQ?m%wuE6[l>,.1HtBGpUT0YkC/]WXE*n39m3H_1%g„U"(Te$kktH);(i$YX7,R([=TiG[MK6mG%u\'IJ#^6=$^ag/kDX?8fY_^*qvp.:6Bh„U">Us&UY9K&_9rBLT9;2wkd,(f+ZCxY*rPtke>rP4&s+Rr0eA4kh(YQ%tc<VJpm6$„U"HUDUY_d7J?_\NZTXehQREoSlq6[[CjOSuob[B$hI6\R,6UP#GCqtC_)Kc]KN%co„U"q\JV_BP4RDw4rtQvrZt]w5]jWtwpGC-JaZ%-l$sD'*n&5pgXG2-Hy;uOM]A.>YO„U"O;La9;jApg>Yq'DFBsu1ABa'j6^6Go_bcc:>G-ua\h2M,%GH;Zpy)QaLg&y*UXh„U"uA4cg_lC4?M?1gdrn>xi/F,nu[^CI>w&.H%aBS#iLW;>BmZFNe8+^r>KxFX6A+O„U"sxj%&+6V*;8b<cW:7/g/mF6;0mZ[/q6)mJ/sW3ZAnR<bi^/Xt45V1a5l;dR;KWX„U"dXq7(.WwS0wOr-EtpzefBe?A5/9Y't'oLKd9)v7$aI<^PMQoi9-ltqtPT[f+'^h„U"tF(&lLL2[cW%a#QH>ku>6/[-2esRCP*wadx>TMbi6WNs.NV;AIg+a<D\dxj7Y7)„U"K.T:M,VCcBfEDe:>.x)KBvU,MPrAxf_qd8Q#MX;rrQS-*I[:m(0K44oH(lw+mMf„U">dg9ebTu4L:kro]1j,x0[pahwI#6\Qoe'7ARl]YaWC,DZ^*K'P*G8y4?pIMx0S)„U"\dMg4'/rz0AtYNr<cb19D+nH#*:^[;QF0.CxsI=H(azpkAV2'e3&PME1uU=PZ=4„U"4oL_j]4ybmfT+yMolph&qIdwGzKbs#0[vn9UO[J]H_Ad.C43A.d3,=?BGYC^%1'„U"ec6o+h'6iBTfL7?2)0%zKilM9ZGU+d;EdVcNwwQov%BOv#VvUNiV(jMM1G#=+4#„U"]LodW>yKd/7cUmL98>-4<XR<X#]c-(M0zY\REB'h12oo-c$1C&V8hM'17>v/6X*„U"n]*#\zNUXXNm>zp(<py=u7_cwZgJbAeibaYUi9_+83YM62oX]'[JI[tspAVX9F)„U"2rh/S/5xpl?l$Dut;LlIvkXY%W\xvpFu[COiqcg<JZBX70Ck*dL]%uohP;Z7y;>„U"0OQn^SdjvTKNOx=[a74M$WY1-3'W_JHVH%XNXr?PBhg.,JhfrR:bjt,'?0mx6se„U"fs?s<4d<ecp<)=<Tc<tO(3eT#WUm(KGWDde<8),jBW+:D)#1m/sfV40rR4fZN2I„U"W4qG&0M\n13Xm?KtpUADm=?*P[-hD=hb?rqZ.1Y:Ie.\zrZ1ZBrvH*$/k=PqK%(„U"M6[FZ#\dBCvQ^e5CnULOZ*Ug#\BC_;&6;R0xe3?leCXto[5hKzn:0R+z94'i&rJ„U"N<P]i-H[gqc:fG[S$Ao6Y[5Y*wJM]]<4bq8Kdr/6VH8h:YnZdXCQNUSvbwFdI?M„U"eu:Fmlun+tmfc/Xglrbfd*bAg1oqDEZk[piE^GVv]K9thSuCvPJ?%R]GGaIxukG„U"PRt$B4Hd\?ANidN8kpWYEmHLW*]SBYW7S8vqmXoB^xKnWWb:uPBFFTu08LTX0[V„U"K0lvaaIrgX_Dk/(lI;t/IySF*KTIk+ZKmC;+E,#p.frut8<g:6'*Jw5GW;*kI/>„U"sD#+]%rIQ8W/'2dnx2A%>JBLGXE*wW8]>am,o,K?R8VHp-TYSEOaDN-R;azfNX*„U"\2HBAfYZkY%GGt^(6dgOZ1Gc=^T=S6D*acRCG9Y6bk.<X4D^K%[A3tu<5dsQwX-„U"l_lrrx4BSFM'A$.>)P678p&#vde5_j5$)kD<>zLgg08T8wjf=N/OHwbwZaIG.2C„U"eX+#).v5QhM__d_I.bK/-i=5.d2CD)(y-P+LW)#zMbD+X9no_BnhxJusV-FmiHH„U"h=n3F$^KquWcaAwR^/rp6I4u4,am,dLRMY^+)J^C:[8P/35eSs[Uedbhyxo[F+f„U"%0AHUeG(n*0xRI?F_?S[=lcmjmbdq:J;,(f=g_i0o9I#O(CmILN&C>hMK?JBF'p„U"H'eI1bp0jK\F+',7Jip+FF]XksgvK>I#r8i&czv.o0.hgvX^SI[vi<d?nc3rC\\„U"Jg*fe[46e)=>IC<AAd6y_dAr'J2f+t6MKLNeokBh\[6,<ks]?^oAOpG9GS$J:NA„U"D=zObay9BTn=L,)[X_%S&#IrIP'LPO)d1$c1U:Kvl*oHTo*1W&-b\BZn,=#AbmS„U"51AE^Q6fOBW:C*qPE2HP(ShS[nMp5S,uumchEne/?X>92d\;S[Bl5IW3#BeiqlD„U"S,\_H#-m<c5sleu<pHZ1jn;VV<XsA&?PF)PN#YlpYSck^>uGb9'\_Jc$5/jEAka„U"xxuRVn*:xV5:d[omG*KBQ22bFMCNQ96zfRi^nS9jieLH,MesT^^_4w<cQ8gLis[„U"u/w:1D6+N2DFOv_UG,\?RBg&q'f_a(]2?#10](74M-#iEUe/xhKn-+SAo8H^PE/„U"$p;FzNJTlgZWe4SLwoGcH97'7Q0n1J&Ju5h,,61(vdoG2xBKWkA7_>g_D?p,X'5„U"(W[=PMcjOl4N3kGVO5eUAiyRsN_eght4SLK#hd/O-YoP4V==8UJpuopY03F&Qgx„U"xQ?)u5,VZI^a$Ccc__bYAw;_LNY$OknIDYTi;KAbcnWj(CyO?Dcbfdw/l&B4C/W„U"v+cS^i2ld.h>4/>43,JK:PY%E)8oDl=RqX\]9[OkBxQ%_k4mH>oR#&YqQ0rlLU;„U"/pF1;3NI:rHhkKzDa[ja?r''+rE:lG^t*sU#u,7AJf$XgUZXHh^N4bYVg-x-NY<„U"UI?u0<'K8Vrcy*+yH\/0ZPrka3AVC%XoLEXRN3cOZX-m%7RGqc:mbgp;]'VD%C7„U"clBccqc2WPIzfbHBRSQ=A5f99qcT3$I[sdt8%in\Rou=P.]vf'u/a3iEFKa)gso„U"^xYloZLIDcSf(DI2]j-wil%28tSr5yudE3c^i?.Y+[&Bf0(3-AU+Qc-Lc>n2=&9„U"<_9MO&-a?lM74mknuP>VAC8S?dBv)EwRdPo[HBA0VVf$cc-$16'N^A>oQ<t7LaD„U"/f11t16/4E\hUtcPZbGYfE'H=([_kq#&rV'Mu''1pDbH]=3K6k8hEr'aD7k,<_i„U"ln3&WY1smI\:R-rr.L=GD+U#\>z_BQBkt_DUvdk]#zfIU*tfJj'jtaASU3P(?p,„U">(Ju/%\.2tkVZrWChx)+M4iUJhc13&]URM3D*KW]J=C)$*4fJB)EC49cZM4gbn7„U",$]b[Nfe-zRUH*?P%s&#;w0a/:gg8vNA4:On#up:LbG/1/RDNPLE06[Xv)(B<+p„U"U2EV$:lrpIJ17C_ma<Ap9r>kKUK_)V2n9l:G68PQlU-ALk^ZLd+OE<(YT1,*Tl4„U"[jc>\<3>C;N1GJ90l^D0sb*Pj;3GB'xBb\#N3d/iC[&&8'ns'eYD=e8R*\xDjY<„U"6B]jv&K]EsX)8V3wmU'GFB<GTdP:+pPlnXOB;sH^6R]SNC;t%]=(ucT6hf8nZSd„U")(kY5j]/#%t5BPFT.;n3\TID)1,OO)(<Lk(iI90?N1$Qv$)Vi0hKDd;>clF6:$x„U">&_pT^4eYB-$gg[IpFU;'lC^hli+GdIj>Pq-NY9h2BazTv?iTGT-3,Deo:'+bu>„U"3aIQ6;]E&B'Sp*8H3ZZfxePFMZz]E&35i%2_N-uPj]$NY1I--bdWz?r#z9V3O5A„U"2o?LQ(J]:axKg4/'3aF\*\#TWC2ey0545RK6?.J5t-h;Rr.=kY$cc\r[7r)4Lj.„U"LTW?]L%8MQ]Gu?><>GFkEy1K_#tV;p2%Fo#BME)q7rg+46mSjWLWvDW.lg&u.Ef„U"l<MbOLCU?5)AUiyol_86nXSTWCbE:Jr?Xb_M?8fg#6w&95vo\mtEVEEH=7lJ+zS„U"6gXij]FRJ3afjNAPMS?#(vC3M3RjTSn:OA*b8jNNh5H%exbBW,WyG6X0]QYYIAt„U"BPu9ho*#3m_JtI<I&Uisk298dFXXC[edL3Qm;Y>TfX&YghVKDVIjblE9XM'A*3'„U";(LNi>OtHn0o&AP<?9fY?+]s5fG(;e>7I6:oUz>;w%S?$1[DB:dh>NGla24]a3l„U"%y$LNijdYo=7[LUjx4;n&jJ9h60Zt,rKM6+_eaoWJuBq.N5w'JLqN\,Ak1)iMcl„U"BXsdMZu2X4WP[T8k)H,Qt#tw<fX8UGeO+L=i%#c_/EX=X^jL9WXaJ6kCUo>,8/B„U"YQV.*=xNc):iXs%<\=,7TX3w*&[fhCoj>qIC6,1ku$eyos3ql-6?aL*$QMI.MIr„U"l50T72[SK6u,_&r+I,=s83>hsZgj_lV#F<=\:R4q=q1E5hF$oaq'[=-xx%u%p()„U"9%%%%-I%abAaG>cV(b76%(%Jk%%%.%%%%hfy%XUSi7fyFa<d=[obb8f[#BoMh*9„U"UIegg=Br^iWnIU5/:hLX(\c_Don%7V[#[sLBJJ9p3tKTt5XB6&/zT,E0TqZ_eE3„U"N&X8&M&&&&N0zzz-CLaSO:H\=D>/gJ]$do>pw#dC&**)K$Z9c#93s8b1[oJbrag„U"6Za%E,[Vb-I5D'juxP5Y+_&_ztg(P+*9<b9]*Jn\:OK8\j(Rr=wgR)IM8Xs'HGr„U"Vt^GaA[h>hIqSgoi[>T0ent<Sp4V;XW<rkOzI#El%iQ1$BPG_ir(yjE2>bm;H0a„U"RpWzs/ppokJhE6XCMm:B(hsi0FLJ#ex;YpduD9q//udVGG(3YBCdDaV9ZKpgL;:„U"p0>LfT1CXa#l:(5S#.SaHXEi<B>3\)5\]LyPaTeP<Q6\'_)Z83+HIBM#sW'^tDw„U"dQsu7K$]6e14d$<rQpf2\jZU6iIAa,bPKVU>hfW0i2vuWQi&O;')&qgM.4,,muD„U"BlqUsI4,QBJjj]$Bs9B3e$tVMYcQkCIq:dnq4?OR'Bqu*mU9Ilm3n#A=$68$mp8„U"I_/nPm;\Y^+1gw\3^_Me,R9ik7H9Ii0Q?]7*Z13=-d%+>bIkh?]U5>[>UKp6_la„U"%?8/)aLHBgJ(ck4L3YbJ$C-XDc8Y*d.eobPWB9YS[7V*UJF&LI/;e9+q[%'$R.I„U".g$9p?9=Sk(+]aha1(*'U(^6e6Nd;22U(WL.J$&ERLEC9xdpDRt5G.4$\xp3u^s„U"dNqM,,6Z(RFDP:<,B0/h3HTttJQ%53P]L5JD=OMTk$Xvq>cEAD'Lg80hLneo**C„U"j0#,A0Z[R+h57hQ.BeV;^)j]i+?X(do[VFgeY5Rt3C&Aq&=-Tp4-/8i_PJJ[B_8„U"+X*GbJ'tgI(9ngB$?1&e0'u.VgH:5E^ozTV[:dm/S5G0m'0+iEu6-eEOcUdR28\„U"Q6oxxb)uT/H4w(%p->*VVhV2RoAEzOE;V2)\/#Q/3lZqgkmd[S-fHrcQiirPfFl„U"_]9a4T98Xkd0uHWk>uiW[OfqUma8#yA=nUrY;Sj-Vd\4%Gn\bViFKOri7VC4?%w„U"9#'%h=W5>,\#&qE6oQSpbR+/h$]Tmki6p+,FJ-*l=,D6L=e2Y0/X;+Te3B*)6YS„U"DWl.UO6#i79I2-d]7RTo<An6UlUW&_;&oL,suIAco%:Gc[SKo#z9LFJuqt<D*xL„U"I;C[h;xwaq6PPjI;0s^96H[D([HIcWK[okqWu2kP,:oV*t]S9,KLwGJXz7xO]2h„U"g'?:[h[+sp>*xq<cK/L&vLmZ.wgmue\j-Bn0oF[52k;.9mS-d=Ju<9tj4>W\3'W„U"t_Vr]WNO%^s$G1u>tu;'r,(u5h,STG^Wjn\=lY7UGIbK'j3iqD%'#=b.cVYN&vg„U"+e6:6$YO;dbrWys3Y_R=nq3oqdQG?AL6^dP>?=/'g^^VO,4isqPoJ4dOl%^rtsY„U"3%35NgGm;0jq(Ie&T,:<^np2V\=IW521)/<]L?BZ-9$qPg9:m&?Hl_UCSZ*qc+>„U"6wI0TbfgT%pc%pog08(leb&$d^DnL?t:uZP)YG7-05^XQF:6I#zpj=1DeYHa]'f„U"r+hr9k/?9d?#RQg+Kg]cBB1IcXG0iS9o>p#%6=p(o_n*nVlBYQTK]dK/P8:BH,r„U"g7_ET44FcU[:SUbgsSf1d.i636,OioVl/S8elo&U#U<?P8w:'Bu9vf-8BU1#+;y„U"_]i9n6])ieI622YIRs#[W#nBw'VV[OZ#nc*(]T)+FYc]huu=i#3w=,LKKa$KIBi„U";T,4O3Lou&Gf^*#(TqB0[F]<lP;9kH?mD(Aw]Ms*MZsYa1D[:ckCjj$A5^v8CY4„U"sFZR#[qiy(gtAV#$Nl/8%_:c&gZDz9=iDH%*#nE[[C?CY7jnV)2oml*Jg#Z=]'L„U"+q[,BIM*=='e79p.$J;kqheY.wn>AO9<q;?WBUt8;mFfWpLv\*<Hst6lP(n2Uf)„U"cHD<\wLaNF#JJ=Px]JGnDTuqAruVnYdruuPDBuajxAuhrl2rXTjdK.D>V2_Qbxx„U"&=ZWl'X9r+tXahtBAi(QT=%8^Y[5wB2666p4R$a6(8yrX=MLEOs8L'Mc^J:lfuj„U"jqp#4[*^wLsO0^6eg]sG0J'+uIM;nl.8NL74bqu+,;bfTb*gQ=z0/9\(pQ$Ts$+„U">QpY1nAwcV:D2s#BVFJ&y5IUNrk(fRp_.kiM4d2iEaD2GsnzcKsz&*7CsG/dnQs„U"MZ(3YaVD.]BX3f%Df^MqugP(vuugBbBqpl.)2=>zn4J,Vqak3oug_1$_,79IP$B„U"&Lh&(#kCt<2+]Syo7eqYWMN>w&C<k9gDDaR.q8r6ybnp5UDLu66##l#VJ[=rfIK„U"Z:gM*WehoQU)bX&8eto3Rs3cJuKoAVV2N-\;f<upl,xzfZGIcC;g*.&\%M3Y*av„U"q^1oMu2/y^E0L8r>C=qa-L[+E1Vj0ep:RA2U_tRn/blZBITQ-95OqDsF?e^C0gW„U"jZr2=(YW(6#lh47F%T*nZtA(p^M&j[4</,TR16)?6:=AEDY?cix(5.r8,os.+Uk„U"43EZ&Mt'l2K/OQe/DIP7/:EYI\63_UiM/\EoaF))C31F#>6\m\&^T%N_sc#M2oL„U"$tFC=kp*A%36nkb7=miw1>^okNijpi^%IC#KY=C[7Br_&_Ck3p?\0MAr1phoalu„U"Ta^C,1hcl%schV9ZMluh$f)FZoG^N:To0P_(C$7&IN6^1EL1bp[d>p;k*4Jpo=B„U"OkMHiGm#b.<#CfZt0r]pGxh0,q\Kp5b6(r$4*7o$rGo[7)F9./\vCfhVcRtVCz=„U"r+[Dc^7(_s8^GH5.avvMR8t1df+/1G>7%r3G?CH,](*6K\f&Mei\[Q?EI2anLEL„U"(>/H\=*Vr:UnNO&8:HBHLXmdJm)Xg%mYv4]Ps^RVN='Dku-U9hVYT:p,\*<I].f„U"L[-p:OL_\PNPKRs5#t1]_T+Wsdkj0DW;l/9R=y_R5z-Oy:yMUx$2ieZFwf>i+v(„U"]b8<<#QLAO#Hc$b[hsZ^Osr-&sMA,,bi?'P2d/-?;Rg-M5;lF9,O44W-1H?NY>E„U"eUr&]$w+fuu_1>)11G+>o\0&[]54:420>&BhPO4.)tLQE$Q=%5x+;h7q'Sn2myV„U"Fm]it&Pq)>'lv(fBR&sRg/(0pI36wZr3vv68t&a=YLdk^v&KO7w6^A1*QHA>[<*„U"g3D4WOd/;=WA#g'R#NfN:Abfyy7qv\YZm3;Or<Qsts?l<0UI=B#$_(]h,&HtW8L„U"(,\CUH(B(\GK+d+hd1Dx#V0a8=E4V;6/mR9-Th]hy-TDjvOS-fGX+cR;]o)GKbW„U"cNYd#VZQ,WK1KwY;5M84uf,B)DN<?dPWI5Y%wR>wK&K+fpd)?rJ:%2\L=NlZTb4„U"B1Qbre>E$UwMBc?=1c5,56/$G<HYMhmdZKMewtQW_6BEYM7Y>T(NiDSWVBxL7E)„U"TO,hBljg=]%<W?iX.,?%q.,wT9CU(/PbTzt/V$bN+nIcBI\+e;ASBKTtL%6tKs<„U"or<d^9YR$TNDI=mZ=aY89o2w%ZXLW)#2a=W+SYbF=c?H+hNZg^cRpjb8PYN^gk2„U"<JB:g^aXf],QR+RJf+f.?<i3_ANdPD1x:KDJeSSAaZiO_t4L$6b/8BSxK-qht+W„U"cewnh)8kbw7OO#;=RYB8l?1,:j2L^]l2$=9T44;]LayeYcEffjCs$u;Eq;/R=WK„U"1oo/C<(9*hA3mYNna5?;JYqVq)FMqFt17f+iMl7%8)h_7;8pL;pxs6/4I^ih]vc„U"W9uI^/g8>pa<uI_a01(OH,\#UpH'W2kEaK_R-1b3IUzU'-YpRYf:,:'LA39a;.=„U"j9J.?KL0:Sb>7)/41szOn4*rkkeTa]xNrN/Emen*\[HCYm/2I%pr#&kE2h?BJ*R„U"Hzt:A:)R(#[E?%G$2W^Y%8:2hB\DJe*(\MPLE/iOjWNp?bqjbM;9hDa#%+j9vX:„U"B_$^:3sPi3(N)09J__^&Ydn>%CC99M--EzQV=xA,8]90E0-8ILibbu*H1#WIrY-„U"DESR?Hzu=\,gmXprch7*XT^C/cgKC2#D4jDnh$WZ?Z:kr&IQ5JyBB]-w&VSx:co„U"0S_(bpc\bf:$]t,fY#2K05ZXQbiIcu:j_kEYgTW/'VxY,itTG<Ky$8PHpPAGQK7„U"^%_rj[oCMM_J$x\X,<FesVyv*k_b3c5Jcqz$(Kr1P+SCnxD(<C71XpyL,xq]OkI„U")?<7oNtgiZk-Jr'wYl?Suf/0TJEPU&Y0cn<]%:bPm(B<&-Kaa*/(ABFb^ruCIlU„U"I2gD7B*OK8k)>mk2%]3J9SC=72f?8[uiRL*AFUdj>#GNgM=.1x_v)Lskydl%OFG„U";psg:qU=XrRI2>_KTgm^vBZ4KbvPSJ;9B&dI)UL8_^9xIBko\*vh4ItN,hX87]$„U"pGyVc3m;]643,h<'*V7tJLpCdWNkkMs+RA(u5]Q.\Ry>k0FaN87D(mX)r[:1bx$„U"xow7us1(z[FWq3b'#x'rmghyt;lhwy<4k?6f(a:eg3Z9G3TtrM'D5S/Jd9ydRYW„U"-R*1r_x45Y[2'gpfcr#-ogtVIcI?*C[5K'ITB7^7_Ixg&dj6%f:8*m0vml'V,M4„U"*C;#8%t\W?4O;nv=]-P:0ZwYTl.3I;QKmT+Cp,SgH7$Rd\?2x4,LGS47j0>SLvr„U"gUS[nmdaY?k,os;/Uht1P$#0N#T'D-dzh_1iNE=fWeft1.BLXZ(H,W,Gq&3*zMY„U"x*8u=\$U3;e]nAn/W*$1]FeT)B\($o#\v,M-][^HQ=\;61oXd1J=Wctupe^n_M)„U"#Y#YXo9Bqd]oDZskI0x(r*%(Jf8VJ7/6]1R?Kt99Sr14950[MM>6\5-55PHild'„U"-Go?id1rc[ffB4-O-<*uon2Wn56.X.uW/DC<g(kK]WbF.8b'NZ8hl.6^CHRGP3[„U"P:[+Z1=UIEs>hNuO1+TITww4zCO#PZnhB;M,/tOXRoR/VYmC]Kn5A*v%uyPZ,D:„U"30l?K)CF56p2IkmR%ig??]f5mgFm1H^Uh(RemHh%Xh2r%:n/8cma:T^cb^nn?k-„U"RF]%b33uOhX;\#4LV$I^LlcdF>P4C$Rczp?HXZc]L*IAeZh^_4*KyW#Af?67AP<„U"<fm2>IFpvfNo<H-GsLm05=gXo0ML^67$6>mjX3^sVlqC$#,2Nj9(r\[x'2sGv5.„U"Nl0hKxm[VEs1Y,1>H<\rqw&b0cyufnm;U6eYVxG#>vkOHt=v1qxYFt3J:(Fk+.0„U"Lria/>,t/LB<3pLTvHBC2SXt=tvJr#S1c&f/m2pyB5YS\=xacN5MJ2\jH>^KH$n„U"\4^=]jrl2%k1$7al#%vV,/2uz17*oxqEd\zC#ij\x4.v:eZc,,8I&Po(l7uO+c.„U"t:zwpSVBieig]iYjG?=8Z'=9jC,Lmn>t;9MbUW\C>TPFu/44D38ca>Pa-s4+qCy„U"o*bK9''v;0QU*)*j0\8ROIb_C4p2wqX9*CkGOYF.<$pDUl=R9lide-59DTgGR2q„U"e.z$T=5k4i1.<YANkC&g^Z[gqC[OY^m5\1_24g%g6LK%5a,FD(OZj*ZPN/7rsAb„U"ct(UW-<AUc/%MpO=?m&hiQe_<D9Sbk3HH_xay.wA[,zZ,gFu-$Ls&\WE[1r31Ex„U"(2(wBha:_d/7?'h2fla(ue/?G'y4_]9#(I:_WMbr9tH^*xOAGPn00BQP'_3GL^i„U"esr8'x0up%()9%%%%-%1=cAGN4'ZD&FH%%*KO%%%/%%%%hfyi%thSgRfxFL\NxH„U"0Z+aXu>YhIjff+K\s*TY^al+^H>gj[#e28;+iZ%yo\\bWEJ2aA5N?O>t9oX648#„U"dP^OtVa5FY81j6,RLsF;?wzWN9.)HV&C#M5DJRsV-XuuP_?_H?o*.\U1kJnA[TU„END SUB„SUB V2„U"a],_v$od*Vfdf6UI#3/K9#'O09T)n?)Ey*U$h(iNPrA]enp%31l]Z>(V:O8>&-<„U"ZF]qP;+LM\BCnLOdGY<Xj'R%$ob7eY:D=xuZakhq1iMp.[5C]jvTU=6#]'WXd$(„U"uSa$'FZc0-e#xCLjK-'3NFL+m$d47qbxerc']j'4>OkX2>$z=Wsm9uSy%/N>Kl_„U"2]+BCh61#/6ZiT9mkvT+;V]Oa?&^,Z-Dr&>c;fPdlV6K3kIXda'1foT&5^9lTpa„U"U^EeP:ZK72lE3)uF^7OlLOJ$WxB9]GJ4VuA^wdL?[H3>JRRerg'7\ls0Yh<2x0'„U"U$3(7(%rMU[n\*cP6/ItFVmS/\CS%Gr]kwcYUg=2aZ1]8r)n=(b.^T%_BL\C?0a„U"rvbOYB_AH-TNhn#nnlKI2oX96S8IC[zxq11m(r/f(j,fl?a]3s2seE=,k9)+PF/„U"rs:UbYeE;16[>SjR110Q\NQPru;\,$<5U\(&k2l45)*\D['5=8=yeLGOo-ItR*n„U"WB37*bG;:Y*6Y]iQIW*pjD<aRg5H0x'):?+m._3pX-51=3Zm)pM^^tVgK:]'Y2$„U"E<T/3'wd(7R:J9i3WYUs3*Gr'n9aGRdiFQ[rw=;7lBWGY14Z)OTF]q;UL$AAdi_„U"<C4I<Ti'F4A?JCicqI4=BLcc,)WV(.)T^ROsh10qcMoaj2GW^(]g82M<fxeU$Td„U"Qg*,(IFOz:dJDJVJ\Z1];D7A4JZI.BCf&qHA./nfC<N(%GC*>/4%M&EWDaxgUR9„U"[Ln&U=\T&n2]0'^QODn7LHib:d/0FEGY7n.?1fvnuQN;ZZZdl)R%:/=cT0Q;Q_H„U">6ERk,[P-<oL9j*,p=(h>N)M<.)XVBg4w(%\s\'%JAGMM;&^S[\H3<P?J.HZ/La„U"SrrWF\CdfN;L7$?X=wq;0tD9jzUC97<iZav8b^/Z:#&S+d[yQxF\PQnT'OrYwn3„U"F6anSN/pB6-t01)]19IjlYlWQP<<+9uRJMo^h)i3jM[+Ik,:^9,0t3]6UX]i3rA„U"IL67(q$BMsq/6U>M85d&gi>yS.bcp8>FpNpVUXUm-Q?dirA<j2h-?qY+lR;EGGN„U"hX#];fP(-Z]1xsIj&&)%s57zc32V3U>\&ZoF2ewmiy.#_<7COlNL%v%-ocDpdMM„U"xfmlNXYI/n\ljhrstv8xrbKld>Rd4xX?GirtQnTJ(MB^Wd57ENDHLF4p3ub<?ix„U"J(l;g?A1r]4FnW$N8HWl5TK0GZ&8)biSU)uZOXWL6M4rjxrs.bZP\K?)1tKrb*f„U"gjwhiN4MWvlPY_wQg&6G(\Tv5Rn48NoUx,tu*sJ=A-I&tj=*:QfDe5bjV8vc]+=„U"b>K^bBso3Ut60)SZVIL7u7^9Yo/(SZVRX-2XuW9c:3%K$H0l2XuEk3dMPBXX]Z+„U"i<X=rn6/GQq6vh5n:(I#ADd%6,dM4VXYNU-sfNfKDMp;3P(8T*tmG$SZxDV;e\e„U"/gW'0CRyo/mUvedsdKL<>UWx5rOtnRVXtn\LijJ&ur'2:G;vI0HVM&>ft=\qq=u„U"u/3Aq$]BH$E4,lg<WHAql$/mZvN7N)RJG9hVXtZ3Sx698\)?mk&%tZulmI[aC3c„U"NFRrsoB&Omj+\zZ9RZr.#nz(zBW=DrkrEGDX,3hUG/#;+?=:oa$ww0_[QEpgSfx„U"YPcqRCnI_-C67dU)XL(*U;l/m/_;I3.-h/gAx&P*60JE08r85hXhUH87?%bYv)R„U"b&t29b+EfjQLOR(6hIF_RxBRFC82Zf*6z'W%.'J5&OTZg=^-=Myu3MT\xvg<_iU„U"C?1Y7#]jE,O3M/iHGEasBaut?cBU3A?j'pP^&/31q&7pn3iQ7m$_/*?oP6/i?kP„U",Ku_,zb7c7+kYfsx>b[U(Y#JS<#1S9TeXZd2Jy/k>r*n23eU5'fB=;,)m^Vze,t„U"sz(PBprO2vl]Gfl,AgmTdA*2?$e7>]a>Roa1J0RV,iPo%->(.xK5ZHplS7\4J$V„U"O=.nDV?<g1bjZ'9$#SctkC,A9l?lqMmWfX+Kb+$+jC3m'R3F]EaF,IH'VKMQ'r6„U"':UckbdZ\bqR^\px?vI&D=2;M:A+>6=lxgjYePrhqdaV^aKXFSI].B$Do6H,3P3„U"H$a?L#B+kaRWKVE\o66HTP491DPb\8%u7#fL97*<ShCURj:XZu>Qrw?6Llw=cqA„U"KQXi&fZ1F+GTz3%?:,kX]J::'FGU];vS[+Vc-AV]awG&VxAQ2L.KXhC,%YQHrr7„U"]:ypMoU5V23rm1N*h<d55-Jo+<77vMc3wl2*-b+Mbfh0gH1,zP09KAR^nSCrc(a„U"SSNL78J3jYSlXCU$Ueg-KPBn*YH0*NxEi)[7-mTT&:G(h\zJ+KAS$/Dl\&OTLCb„U"RJB$4vJ_s=Z]ngU5^LsecjmX2lgI*_P*M,qvFi9['YBk)BI;tn$d\:bk/&)(LK>„U"&t.CF:col?QAY:hCT#'6:efSn?;vI,q'm2VE5u^&wVYNV6L1w[,bPvjoIb00TB\„U"F:\KcOs'&TW8g/c52T'Q,>\^.h\L0DfydC>C-F7&U3pTC54wD0;2&#(Ryx)CF2V„U"#6-thH$+,Umea9AUo\O[Oit7VQCY?37U0Pe9j5>-Xjh67d$Rdjt=b[I.'+K>+*o„U"R07.=gia,oI]KWW1Qn5dOsT=+%DJLfORbpW9WL5F'X[h5$*[hfFp5pRI_AyhMi#„U"-7h[0VEmluPl9\TuCw'*3$=;&B(,>EKy0?NLGYXX/,T;4M$[u#r=S.[,KPj1#0?„U"F#T<Z?Nqr.RZDpPfuqlE)Rr*_JH/;v2puN;;#mH;\?rko3\Vfb%fq7u/(4]#k/P„U"$(/AIni?mgof5h5%_.M)M-Y],oiFrhcH>;g8K4Dt3;<%A,LIX7fjJk:):v;5XKt„U"NnLHA_p[x1\4c0e+7\Vkn?[ee*[mBHBIW=Y':t>jU2Zog(9Q9*7/fJc/bG*YuEp„U"cse9rak4NSAIV]=(>kLelf>mnwpQZa1B$M)jT;];MC_[IrJ.$2g??.vIr2kRq2(„U"mD\AS[lOG&FQmxIRll-X43U^so.U7L;]6FE[Aj&.EMCM7-&,b)>TGln),<e6L;=„U"1cRNS$+.ANehEpC,Jv-EU0DmNV>;*QxjiBY:O>Ef0bSdvBftSOJ:Cx;e<0[nk_A„U"89YT]0U-n;4nBe[;o<Du7i1So^[9<(E<?89nK%AK>Re[yLkIKQB-^:pf_fD=8;i„U"RZTS=-OEkT;auHA42kTl=)t0o?FGUE_[cK#e<M1lVTclx<fpNV'/SS#l4\ZDp9)„U"[QaBpA.+pZoFV\Os]H9;m/$=BiS_.5&psHUTV%mO_YQ%Ye6%Q:&nQ[:<PJ'?83-„U"(p_K$7WPDLqo9z:jhekbag9SpBSjfC^z7ISkkbeR(ClS;FqNG6YGA?,pI_Pikut„U"R.z_HRCbHJui^Z6&k/3[f/nkViI0'vG./KIFR$eFg8YX)L3[z7LR+jthhxi7;Mg„U"%iBO;2BX^Y31g=)vK3mu0OZtMr)XEc0d6FE(#CYEA<JAJzpuOjH3i(&MqL2$^Vi„U"J3yZ#]p0+U-2,<6+0YmB?8QAED,G-pC=Em26#2%,Fn1Z$4L(\u0Mx8Hnob<oEKQ„U"gQ(D<dWB=j/4bnTsci1^;,8.sJQDW%0x>AUiIbrpU5\p):ous[dg+TvxyUgUS&8„U"OYd?7]jYej1bed%ZGrk+NB%<IMD=Sj,Hq5$fpo?h\$oIB3ghX/Oi8/.Pg't.Y]t„U",UnvLC]vVfh%=rANS4A<1Ea]&C83mC[[Zo/(XC;g8/JqlU+,$]on>.xDEck406Q„U"fuogX+O6Yzd-(nd7U<D3zpHM9Uk5H>k(N0%f^q%SJFIaBx%120Zi[K#7ewJDl+/„U"$7r)=*n[UdiSv[b#2,gJ.:;wq0[iSos7du^qKQ:>?fsw[7NtUNVw(SmOKBdg7Hj„U")yg<w$1h7Hre<#'U*L;Xkq>hc]XY6mc\pYI]Y610=9qY$s0uY2pe#)eeX\M$R]n„U"R4FV\IRjn.HXRi7mLnsa6D$od)F^fh).I9Ab];s)\1>77GL:3[8&XO:t,Ivl(;8„U"8QVr(<<Vncl$nrO5l8+=9iuK9OR#Va?mEC'&Ltue:1-+\Okd#<cc#abotJhH#G5„U">Lz_:D*a.:zK]*h\Ri#n4Nk:rP,n3='R=t64WO^]xG>5usM:7_\ffjg;8v1yR2j„U"ao3Vs;]vt.qCvWJ*IqG&S=.Y%m:SShE&PM_<96nXF2%OaC+>jRo0]?ZMVSCzn=z„U"Z?6cpVDaw#SnN<y1R>UeOXR1OT(,]m'R2Wd3[bbegfBk%;[Vr<lG3#2latfTZ=f„U"6*^X/Ay=Meh3n[Q+OM_JOez*7YmhDcKwq;0k%gY[gKE#*n6$3l''WDJLo/t;4zf„U"emw+eB/mkm6J[5W#?RAq3G)oXx)hFkaU-%1$2Y1&+:Zs<t>I/RwnxG1iGyb:YDC„U"Ta%dlifEDj$-wbp*yOYm%aRDdIbJa;L^8YI.L;:B/Gk%'IMd\_ofSWmAN6u&l;<„U"[B8FN9<s<iF:&;5,WOa0XnBF#0S5JKtOo2?VCX=LAo1V3K2Yo#B(Z[KMt;ty_6X„U"2\/iFzMGv;Lc^vw?#&r-'V#U16O9CH:M.'c2AI&Pse[1V8^+f/^#JEwWf:0S#=5„U"SKwc2J[r1JATPNP\wtZ)s:5whonTBp55_?jNIqB0#C'5J*g45#HkNjLkcAk\\w;„U"E:je^H$PnWaDx;B4YzW\m,0tPYW]bavp1=Z7)FZ+-f+Hc/Ro_aZDW<&0We\Kues„U"Fzap)BMubxNt\)c+qED3cR\%>(+&V2^-<or3Ef<NSB3A+y$gAH9lAA392R\g0;E„U"NV_1nu-Rtp$96>EO6gRsPE-TX>c>c'Q8E<viUY>dfbM^^4;(]97;1myTZ(ryEjx„U"IHr;3PQ#cuuEYu,B'I59SI)oLW;,dAOY/[*ssIdXk=qiB&PHBIIns$*4kM7#=td„U"R[00%S*iz#7Csv1Ibk%^q]p5FpbJ7Etw5<II2,^?r0JBIGrq?(>Ynaj8Q)W7ZXJ„U"7_8wrKNOo+\i-xSoKC-*w8lI^mF=qIiJ5P<UT=,sXNHb5O(=->c7&<B13Q%z/?T„U"1LYQZxoH/WF3$oElM[eEnYe&6ZJR5I#fCnAx'YkGw0;/u[9nob:SDMWr9l/qB8m„U"o79M_/If,P2i$)IDp)Io]vEW/cJpLb6]:L2F'ok:qT'OkS6=q#aztU;Jhr2hSAd„U"+v16ojs#L#N^gm]78L/6y$6g*7%R\n)2iCR/21e,2AM5W$+,IE3VY-$s023Jmw2„U"VBJ*T/<_r,dqvM4L/rH8-owV2&hc5/4lSUe4f34E]C)1ama71ir2Jue7l]%iw/t„U"5:kAfM0-i'b.;F]7[.zkTK>2T=^T=yaX]D3RpOkkrhs/DxgZM4jE0yU)js;8Y7S„U"G&(1(+=J.B+#5PZ-.CG6twv4M>X#oLB6iGOSnmQTI5m6fq<:r'Lo-J/xsi,S3+0„U"Fr'WS)YWe0ei7N2?\YW?5A8ei3o=Hi>]29>bAkSBV*Zm#JV9gqCNhxU+YjxF4uj„U"z^R0hr<o2m-_]63IBcv%E6(eKMi))rE>.V<f>K7\?DsZ5CsoI&>k.A[(K\z;t+,„U"Yi+QsB>bB'VGi&CI%'nCsff7=SHU11A%p,[C4j^I/5ijlZfSZ4D-Ft4.<CQZl9h„U"hCh)N)I+cmS#o'9e1]_ZP.CZ6FY>UI-gQg\Y<xXS:#vFoCVyPtT$dudec-#;M3=„U"N\?FAOEj[y*lNHQiw:(huOxR16X1kG,+A8__$5nINvT(YD^/+3,h<.tF$W#bkgv„U"CHH_.,)3aw=nSr8\,u.Kq5q5EP\GaNG[]x3,XE&1A&>[H';z^[nN*xS;uw.Wet*„U",$KuVZcmIvY>B&142-lB&]HF]LSk335<E[7<U*DOGBHkAuC&*H$x$n^0)b7;MSK„U"Gm-t5FcwMtuM)I>;./nMZAq]6ICgE_]w-\=g6/(M^CCbmi[>9$]PPpaAK^I3g^D„U"-5.7fFSIx'Dj6_J/_QTRFh,^0E4D.piLG^7<QE*H_FTfIRIU4wZHi[NMN2PJy+2„U"UZN[-Tan-=U&LGlZ;&1u]bs;#awwd>jlQ%(WWB[Q1Wx[OXBw*cH&a:YEd8e_LzK„U"YM],h1$D<T(sq%=h_n5q:#:K1dJoP*ifo/C<91[?katXLGxvtYbTISI)DnW&t-\„U"LOA]Qqeo0)eDNlUSw2679-SiyshhE-DHI=($.ZKt:;]btn)%r$Kr6PGN?_57:f1„U"W&tDOM4_1:_sug#_UeTZ-5nA[3r?&[qZeK;1y]$q+PmxRv&f?K7-:Q0/e=y[]nP„U"g_vr'?,VeEZtxIQ&&vgfjpA:?,T1bS]BvFB5PobajV+kMOep'.c/-UTW%X]^0AI„U"G6\'=o3'Jy(nvAPSM#E:PC8oRW5Kowvo/R_u-DXM;AZf9]&cmrBe90nXp[*\2H>„U"1UBn/(7Z/^o04cI*x$Tb(l=28eu[<]I5v6,/[E+S.;aWmG.FMTb$]j-.OHUQ>(-„U"mN<2?bs9hN:U[3&)eCV?HlmcGXl'=Q,?$^9wCObH-n%dq($eWjQLI#p?VC;W?Sl„U"aZR]^_m2)^lD%'8]W]?q/tvd18*)AfmWfZ5qZYG:+q,E9?b3cjBbTTSbp0KQkM$„U"T<Wb,CEtO01$\,ur*.B^/%aRQh_;_<48^m3_#afI8ZV[2BW+1JgsmbeE'kmWxBO„U"tlbEm;d\EN;s5T'4ori6Yx^9,]SRL*u[[;OTa/8WFA)'N5U&D%ogmP,aCOUyY'w„U"gmA#D?iCl=ZU9$ZSOd=JHX'aM4Ij%'s:;2Nr8[Lf0K>5*UXPLZ[,rwg-]j6-Yqv„U"AlTSC)v(N*i7LLtoHZEoD3J-JboQPox]<dH9CktBvBasol^WZpMZ.6Y)t+U,hW#„U"hy<hLYr[O&qlhT'5oj/78$Qx(fGRe-c5Fi)z8r7S>3(]f^l+S\*]h]d)PuPH]jj„U"KIuvr%GcuxU)EU^f)G1fT2Ov^8RwkD(tKSx+G+D<S6M,6<Vp]CT1pKV'K8Z]^?X„U"OE3'[Xha2JsOeIOkdI?$^Yx'vU79*$.d6j::vsCvE7dWdX*IfeOeM(]lj8-JlDu„U"#1DUVXg7GQUfDnqFpoqUUs>n$EE[V[uVFM:N(w*$]nd0qKUA6pm=\A_%zV,YGbj„U"2&6UC#;XCR]\7MV.17B'WjQJ[3>Zhjj#<pejNUJ(gYt-o?g2kTrdqeqt6kR\RsD„U"-EjuSA&A)_?>Fv^[^$0q>x#Ft\oa[^).zN5MBW3urNdEtSo4lD%zKMuOX[HDUTd„U"^jsjvNW:n#lPs]_90d7uBUHw0AsEMam:%NgxG<$1N[[#.]-:T=fEpw;rt8Ob2Ym„U"mMysLm.oR8)n%\[e;-hw^IL0aheARIJ_//^s2)S>JY$[V5.QR[oGahpDx5JbE7C„U"kxk_sa]EW'XpHt>,BA7K%CBLak_HxZ4A$UHA07CwIVv#9s]#RZ<-[k(g(Pd(#qk„U"Qxcb-8ocN^Prk.mRqPomR>1yV3OBKR%Nqo4_&cCZJ7ITq.rFJLPEB7$B^4,8XtD„U"DBh-Xh+2#[.lZQ<s8d)#SVurAm?RK>S]2h+0qAxaT[WqCV=JnG]an-o\EiDTD]3„U"ri:JHnBD<D'kmjaXCnwl:aAbnaJLfu;6xf[tt.d+2hpq1FnR?Wh=ERnd9x8lu.b„U"G:lr\zWYivzl<Au%bMP*FOwSU.?ei=GT0$e[STsBdNG=v6s(&ke+'g?DkE'Mp\+„U"jml'LJD5bTi/oii'u3=hd*V01[#oo/k1g=vnO]=1<0E]=m*:k-nm3dN':b28qPy„U"),[:8$SqYZbba=tE$FR'm__=,?IeW'pj_=iR5^usd5.'&C=G^2vR5r37eN]9QMb„U"_PsQbG$+Wj_J;?ci/.8NnN#'X(d0#?;<vaB;;GcnLDO]ntEbnL6.\cH7Fk,/=G*„U"Cr>lw.J:<-W?^2d<V-W?KZDqHQJ:=-W?_2d=I9xn49FXPWJK+iD0PXK+;iDPYp9„U"rrq;>.PuGWpp+fTuWqKHT#LYR=U7p:rw0*g#Ml?fv4<d_9rw%G\$9GrwG&da9rw„U"(WFb9jnAf3Elp-FV$+vdK4DY?)Np$EJYY/e>ceKN<tm60nq5p#^TBL=mpYp$TW2„U"j[gyNehhx<^MjCttfN31R.>jspSRKrF3N5JvpOh]B];$$UJh(NvVbh3X)XW+s%e„U"61lo]A'Q<:#zapYRg'ao?#%0alXC(]0lP=>Dca#KE%mzfZzNkdjDHA)S#(_Zr-^„U"SJKBf:QFNRdGY\]G2r(>UU?.bYg?;LSbqS4$-67*)0l8,1q&xQ,khJOF.<+Gj(E„U"oG&uI03\/&?O?N6PUQ.wEcZsB<m&;PK%/EAL.hnuSVRL,:?u*f&bi<um6k[6T9=„U"?W//s^e]Lwmo46:?HOFP7vlqOZsk>F_?\'r,9#kkn4$rK&ByOhDQk5M6T4PNr$P„U"\sWm%M[]gJng5;tYW>c7eyiVDy'g_t8*5niYg\Kw\nffsm]pBWstXYlVHFw03%g„U"w&n[hteDr4dO4_AM,.I29YC=htqbXiNdfi-6MOi8r&[5cA(.Ag\j3\cC6UB_i$n„U"0A.V[2uWL32OvJFI-CdCPG?R>-fWMf.bq'4>oTFl-fZJoc$-YrhcjA^7*wdsZ3]„U"zf8+[\&hV+^'rE'h)LNZquPUS'mfVBKO]A?(B0dv+np<RMHGMhwXf_[%e[heFmS„U"3*EQI\fx;KW._vlu&hG0LUd.x*.sv2nizNKRQ[njR.QN+pwQS'txTX*sclj_NG2„U"(O[HcbNFhGZdopao3Iofmm'OwImS,.\BM:_o%=4XDZ%/Eh+F*M<\[y[K4h0*.+&„U"r'0RIZ+x1-.?[#i#OUV$*\wkN#ar%cTRw4[mj:5&J+ra&K*t(Q6al4;xeNZd^Q9„U"7MNoxdgo.#Z&*=.jlD8+0lxf:xsgWoRcd?<r(7*\\>_HjB-<k3yD(]:xY:+\YMY„U"\jFGAPZdj>pkSr(x==CoY?v,pPz+dAcg8u8>uAIRn)A_aG_4ZwSlb'6>ATj+#J:„U"Nj)?H0B\53U=F_)'hlYf+y+p$Q,v3c-IGaVLp7>m8iJ-$R$y+\J&H.,h,.]FDJt„U"J+&KVT'-'2u<6FuMDNSvr0ixI;fi=W-$sUN+P$b%XZoCTF\\A>=#g>zAs'j?&CN„U"QP*ItKk0Co95(I-&=PwfV-m%64-sY(xEyJlV_l7Q53a)M<.NdmN;txVn?Q&[1C1„U"#LT1A2:bbjoW$>G2Ow;p5gU&h;?DI7RNL4Nz:P$W=Ka[JGU,>p^qx6uoTY+mY]\„U"B4UQx?sCdtJ5dhK-9q;z;Q]'G\i(/T7:/ninXY=BAm/nDH4J0L9zDljSERIp6G[„U";nOh='735$:WwNitRhGp<pBGr%bJS.7L1pit9c[>-sfa:GddO.jbN>$o&\4xMuD„U"i+Xm72001Rxh+sr\-)s,F2WLnRy6$8QDeNwE]M0DBR];C'g#)6JU3H:4uo??Pq#„U"h5).7HL]2mY*oQC^$b]YVcZJs_*TU,wah$-EjzZ%2_+rlep[ffwt44%Pry-)R>;„U"#8/:54enG<KA8NUU<PprCTHO..76,fY.sOLd%9h#SGrAs(_9t)C)Fx27Xx$;VE#„U"GC(5(<kq5R.Lm&+:qICMvYMpMrqL98feeMoaftZ7D3$G'&(.)(nX8l_CaldrH#M„U"rYJVYF7[Fa.\m/yC8fx?7r_D/M<YOL;AgLr,c-KM37KkU+l4KA1%Tqdr+77,N,e„U"EwN>_1(u95O%^d-Z]&ZI4Z)YCRpp:Z82.Fh]'</q-8mkL>05c?a6QDqZ[A);_9U„U"_rk,LK'fZ<NX/?9/b9d?l+mHkc''u,4B$zPr;7qedS>-'c7]S8x#Eq/d>zSkp(0„U"c7\B:$sosP>7\NQoo;KKZfn]:\64lRHIN5X1^W#Yp2.SszmTlk\^tQ7]kesi?>8„U"i?=,TRa3ny6TOX1]1IGai^ZN_vfqS8Zk7D[0J^,IKqwJj,xhOUNb%&K79Hk'10^„U"McLtAmKcj't79DSckf/T)4EPz_c;NX-<T?Afa]_W9cZG8AoBe>-gR>ZDU-;=Cuy„U"HD/%jk;=zm&q\AYNjEooi+;f:,f$G-?s=2wBDMq+yTQK7cwi$)6sDyv$(MRk;ps„U"o>s&:\e7nTRE^-&_DtxVEd?nS2k,hG9vxueD;6rWq^,3pY-Ix;j;xd(g5??B^bC„U"%Z0HrkVL%0:iIDzTV9>s+h-5h,jZSy:=;_R0F=ClZS:S*5dfZx8_Zu&mT;tn3;m„U"kCjHinB%_LU5))T6t>XYn.+l?XcS<v)GkN:.kb8h'39gSU6)0Xi\Z/]f0t.9zD+„U";q7ohqY$28:zf1.JcGxB(5[Io$Ldm:\;6GaY?utEd6(\kjD)B,L\w1A\/Jcvcuj„U"LQ:?;J[tu7VafLuDud>DVo?3c1yW9:&=DI'NL2p4xPX>L$KS0AP_HSfpA9^v-w'„U"e?Yc6LI67eLHD*?J%w%uTw;)69DhyI1GHS3hl8[R^ZnaFT7%P<(=KzSV-,3l=+Y„U"BtcUQ8n4Y$E#2<C-fhF.BkhQPG:Tu8']iZbjPQ8^w]waGCdc0uEn^U?m/];V+&P„U"b.('x&rWr&bEOEq^.13s9kN8:I^u*+z's._eGqZ,>M*,KhH^f8q/7KVFQk+Z5nz„U"Z6gr<o;KBoD/3&vVeZqiF_cR)n.>qW6YkI1Y*s^4mC%Wr,J+jc/qQL:/rz,K7Zn„U"'j1wUIEPJWjYFXa;uNx4E&XZG&;IW$cx+ftO>St[fp#L_Fn8[HS4+z.vxY&]I0*„U"%w:)VXnSgFvU5d2>3#Al5AgF^)$0go%&D?kFOhEV#z.wdwVm+(M^>b$BJ2^'];]„U"%JTFcD^Q*8jiBFsJWboHIH;L3,^V5Xu3l&wT[1&Nm-Cbnj&Pwz*DPo94(7yE;]m„U"qYaktjo8.56)<+8spv>p$\gAn8>)#D#Wq:htjF7N^Sb[[hijNMs5ydYmscYzbYQ„U"a9N8U)][uv;qG-U?c=M?AusJ>n[I?F1#K(O\x]qkq1N=0Ow.p.8S,X9.NkSZeHq„U"Ym-Mta*VE'g\LD\ur7qQ<]G\vDj_1)Tng20B\9U_0s_ojsj5Z8E0Fwu)M;(N,*o„U"<Pn5]SWa'YJoaHXK]9O'mrmkQ(#SIOx>?krUg3(>yC+K%$$x_:U#Y-d[\wHj8<y„U"MB[U?-DZahKt^,*T.7*9/_^7DvEDbUWY>)9jjAjLqlVV,rVEcG_I9tx[CnloxMR„U"^Yp$H$e(I;>EBf[VgU#8h\3<9Sx1AHM$ph8M<4N(Rh>$m%$7eHrfZCVH>x$7+oV„U"l'?k(kG]iCfLFBcKC?2/i-MgG*Tw8NIH;xB81+ZO>[i+I0#fVN^ciA*k*3]egB+„U")O]H$r5FFrdo$RI0Xrda0NC=I]j'Bhsz-NC&DXyFEU1)J,+A,xm[(5:K(lBE9Ie„U"i#aJkh1\\*smDkT:wWv&rmY_)c9#Yh88/[Mr8tdJ$xP3aPBfb(QP/9miLnef]tN„U"x%Dup(%)9%%%%-%P&owGeR1MI:#%%%H%%%%0%%%%k#nqj.%niSi(n)x%^'*5)(x„U"?sQ8#tFx7MXOXFu)&Z*jAN]?$$]<LNSs%ecMc]%P]J;\6K(>HkCwZnYXll$mOOu„U"ckD:C%XpW9AYx8Z/aXC9GAlpZ(xD97flwO+#5uucMh&qvNYw_*h)+qY9[(M,%%u„U"p(%)9%%%%-%j_cAG7*nCp([/%%w%#%%/%%%%h%fylj%sSgfOx6'<,BT[7cwg>v>„U"V&ckV1rCeIBL\J.sleNJjxhAXicS+6(LPn4m[gII9%[zTt<p^.40OThad+'EPes„U"UrM1jelg,ZPoGDs-[3_Bq]qXGkti_iZE-N1n$jK/(1$A/q$hHfqR++(JZcxd&Vn„U"Tp&9=#'71&FkR4^B/kBX<.v+'W;n*m?nij7vtwnH0Q).'-vE[>9g6ZI6.#K(,X8„U"8^mW(,xQyoUG(__2</(uFFh>JI%GzKOMrY4eCre-T(7*aMALMCumqqQ&.w;J1Wp„U"qD-*eMqdWOQpmOhmac>d<#OlG.cJ^.,a.9'(Q4;IL\>l<fa:-0_3o(E5jj'1C#E„U"Lh0Fu,bA6Zkud,?8/v0&&9)PAGiF1u*_)B:DwH6h*>G+&+n?P+kWNW=X+*q<L,5„U"J'FNLo-N9R=1,a>O+]2wy8>Y=([z=n7+Q#rG[*r<OLgTVuAAKF2t#+Qm=eZ&0+2„U":FLI>*e>#$ALkRkWV'4E%ZR*xa4YWP]d_+UW]6SaLpTAsbMAJ<Mp#g4jcd1Qv'C„U"(=SyNt&)/[p1-E%e:$40%sNv1qx5m7:[PvJ0+oeI*BTyYD(E2-doCTK0r(md,zw„U"aq51wo^?9mcyVW1658+OHhL+$YlXh*Os_4Xo+VsKFxdIW02uab'O<8W]z:N<NFL„U";Yqx$'vIXe.n8k5O%)aj$U:;h\N4(o#i'-Xb/)D>65rZ:PSu:B)_qG?;[b^.j>]„U"f'KYj\O:AYAHfj+v^:'LJ7(k4zVU,-)[sIsf/.^K)8qZ\N_3aKx,y#(wH2<nRa0„U"*xH0EqQ'o?XPvJ#]Bp2J.cHEF[E[1_$whfCFV.u$m0ci^FdSFRZ4?blKaxYbd(D„U"5?^]K^=-U8()nc+gNt:a\UO*[%0,_=/$nSR:)[sl\am&VAOkQ^E>&s\UWmtr<Ij„U"sU8rI?>eldRgfx3RG2['eKU^T'.83h79G.m%.MV,vvHqrrZNo(EN:pSu/N32>An„U"wQd.4:dmxkQ<8-\qOY6e9vYW(5'INp*YV=9/043dOY=;WaxEF,SC\p*ng:Pc;bH„U"G\\VrBA5,L'?*#2E#p:1I?eVSm:s]Nte>1rbuffI8C_S07T0F5#?v3D^c1wzdVo„U"3<a?JY[i^h'^5E2O8R%URI+VUoOi8B3Yss'0RM7C2<f$xA=-:Z[JAj]QAm0vlK>„END SUB„SUB V3„U"bz7cB+?I(8&Vd2RcvVo#.V=FXoH4ZU?7TQ1CVrg^jIFLTAqPAZ4v38EA),%*uVT„U"i5t]]2sdnwd\_G2xRj(oPk^lmmsdb+f(=0bBF9'7$?]Do1dZ$i\\L\#FTh\nmx>„U"Rtgu$b8T*Tx=_rG0YCE[pRrTs$DSn(YkgEL.fE6EpxsM\JDrThC8%9W^kjadP*w„U"F1YR:BJwK4vbDIY'agg)TLjyZNK6sbWWUv-D;o<.3XkLBCs+XoYT1WxqEv,NNWN„U"cD).c]:[c%YOBA7S7eah9;kD$K)PHPkRZ]-H?Q(LdAku<iSn^#<Tc[[aM-%PXze„U"?N#ms^V+<hh'8HwKVaS0C%.3;JJ$C>oh+vi?o'&Z>ul)y#^Nzcp8v#vqz0QW.&^„U"<B8gWKH80_O(:(O=0ont^R/MaV&eYLmh6SG.3&Ie3v>7DI43;(fA3o/CXj$em7\„U"?Y59*tQnO/C^Mi0<#foi3q=6Szh&5SSbIR,*p^^j$LLCAY[aMkHKR/2Y<w,/'.]„U"(-eq9Jc])FO3J0/KCKRYi7q(P]C(o>zGUb3rSRR&,3c:-tc/nc>68J:wDJ)wZ0H„U"U2jmS,C^B84LY1<v;eeo]%k:&SLw<&;u9\1ZPNX^=#F/N/Nl>F>\IVkH0VM,d-d„U"C],U]kuX8xq(G^TrMmcmo0\Iw$0IcPSq\?-F</x2EwbY*%4+rCip#4CQ?cmf<K)„U",S6#&'AY6TjA*Il]D>#t]X$k%rhiTgvG8NR&LJ7+yDLUh]U\p0bnev?.n*Y*$J0„U"N8Ku#i6:1:vsb+jGUyaW,0AOm<^AFO?H4I/bR&ycYoZDdmCZo#8I=luxlFTiDvz„U"\TJ)W-/MyN=AGH]iZFv&]rN'w:ejqo&jXMfRi3\0f$TsbVAr^5Sc<I#.%3_59*p„U"k:7%$m+p+OD]ePRYV'2vXSIH#,G.R;>Ft<a2X$';nkJH^[AyHVG^MfVx]=#59Q'„U"P$#)N-d*sNovF$1uk^i1^oq:3E:xQGN72<6j\wj.ku7a%KAE>)jZV?V$jR5;6RU„U"T0Kqk4Isa=FO7*A03CoVT?k\lAniO\7cP)JOV].ROEmfC>N$W?v]m6Cps-3/kN>„U"]0+v&ZKoUY#v'9\AYUWRaM7f;zvq))qdGYpwKc<K1^Y:I=bre6lYsQfg6iLh:XQ„U"h;PVdmHRO.x5__5']gxaC\ytng3ttQ\tUgAE+Oct^O1_f-Cj-$\*vl*)SnKC6>=„U"ZkBOa&q\;e*7I.<n[:IyJsxP;0uYfpLUWW*qlPGi3V6b5UYb'EgsDlp;(T4=)31„U".WaD[3Dv($>\&rjIzmIM;CNkggIJ*8n%S8eD5p&Xi^R4Og5f*7qU^<Q#)yL)&.j„U"NfZ:2kCM>75ob'Ls.c8()HFz_oDAF7Y,Qa9'b$Qw&kCY:&d6IohY004d4M<'s3S„U"XCc#r*d5?)7H7QZ'+Yh^R>U8i=88x.f5*y=Si4cA4N-z/s,xrkXf.h5rDlHZo>J„U"#ubr<RE4A(rIuLIvJVEJ00nA9[($ICj1ET=GJ9Y%lo7>M?Wj,4SFfh^xNdp7]H3„U"^Ypl(=OLADoGY49dI2OK'J6H'EIHAog<S,hFY);*OQ-.nXWw.;bOi;CL>vi$y6$„U"+s5N6K_ksW>%3tGKBNVW<^a,yuXt9TiD]wEJU17%&siwHFWPlHY2'h8+A5BMahe„U"C\b\Ca#S:NLz[,49h_Hw5Cm&aHa[0W?<nQX5A&q?iNTVX;2'1T;06CtUbN>n3:N„U"5iGu2g=+x#a,rtlJ2i;9U46.GC42d1\D.l^t2Zrp%bbmWGgQ&J[2cAXbMV)L,ln„U"NQ2qNm;nNJ=L/:u&E+5s#(C:Kw(IHiF+p[ATOmDMgU)%Y_Hu9C?oV>XRRYV'>R(„U"Fm=$Vhc(oxVwSV$K^]:F?(zpCmV5=]/;.u<=U2Tg4V6%\Tl]i$kk6JK+.&i+zA^„U"K2niyogCN*Ix>:39Y'3THHGs.#Oj*P*VcvyKUB;*/f\\0O-4J9S-nER6Z.J3NoO„U"IIp1-'h5dC*1u4T/vm?J+hAq.z#JuF#k*AARS\*raNm1UqO^-5hxq9Idv9<ZRWC„U"gB;%FK4X4Ej:=kO^nQ1aaP[7^hX^+_;,(5<SAnd%up&'%9%9%%%%-%3EbAG],9-„U"b&Z)%%%;1%%%1%%%%%%%%%&%E%%%%%%%%%fs%xnWh%fySg%fxup%&'9%%9%%%I-„U"%zbSAG4/1k;157%%=N%%%/%%%%%%%%%&%%E%%%'.)%%%hfyl%jsSi%thup%&'9%„U"%9%%%#-%ab8AG>c0Vb76.%%Jk%%%.%%%%%%%%%&%%E%%%%d:%%%hfyX%USif%yu„U"p&%'9%9%%%%-I%=cAOG4'Z)DFH%4%KO%%%/%%%%%%%%%&%E[%%%G%K%%h%fyit%„U"hSgf%xup&%'9%9%%%%-.%Pow%Ge1M*I:%%(%H%%%%0%%%%%%%%%&%E#%%%<%o%%„U"k#nqj.%niSi(n)up%&'9%%9%%%#-%jcnAG7n&Cp(/7%%w#%%%/%%%%%%%%%&%%E„U"%%%%&p%%%hfyl%jsSg%fxup%*+%%%%%+%%+%w&%%%Qz%%%%%„END SUB„V2„V3„CLOSE:IF S=132AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„The ABC Programmer             WORD WRAPPER (FOR TEXT FILES)  voxel@freenet.edmonton.ab.ca   04-08-97 (10:10)       QB, QBasic, PDS        51   1917     WORDWRAP.BAS'========================================================================„' Simple word wrapper for text files.  (Code: William Yu  Date: 04-08-97)„' 100% PUBLIC DOMAIN, please use freely.„'„' Purpose: Wraps a line exceeding the specified wrap limit (WrapLimit).„'          Made especially for Windows documents saved as plain text.„'========================================================================„„DEFINT A-Z„„CONST False = 0„CONST True = NOT False„„WrapLimit = 78                      ' Start wrapping at which column?„„FileName$ = "OLDDOC.TXT"            ' Location of input file.„OutFile$ = "NEWDOC.TXT"             ' Name of output file.„„FileNum = FREEFILE„OPEN FileName$ FOR INPUT AS FileNum     ' No file checking done.„„OutFileNum = FREEFILE„OPEN OutFile$ FOR OUTPUT AS OutFileNum  ' No file exist checking done.„„DO„  LINE INPUT #FileNum, Text$            ' Read in text.„  IF LEN(Text$) <= WrapLimit THEN       ' If line does not exceed wrap limit„    PRINT #OutFileNum, Text$            ' then no need to parse line.„  ELSE„    CantWrap = False      ' Used as a dummy error (ie. WrapLimit = 1..etc)„    WHILE (LEN(Text$) > WrapLimit) AND (CantWrap = False)„      CantWrap = True„      FOR I = WrapLimit TO 1 STEP -1      ' Parse backwards.„        IF MID$(Text$, I, 1) = " " THEN   ' For first occurence of a space.„          NewText$ = LEFT$(Text$, I - 1)  ' Get new text.„          CantWrap = False                ' Set back to false.„          EXIT FOR                        ' No more parsing needed.„        END IF„      NEXT I„      IF CantWrap = False THEN„        Text$ = MID$(Text$, I + 1, LEN(Text$))„        PRINT #OutFileNum, NewText$„      END IF„    WEND„    PRINT #OutFileNum, Text$              ' Dump remaining text to file.„  END IF„LOOP UNTIL EOF(FileNum)                   ' parse entire file„„CLOSE FileNum, OutFileNum„„END„Richard Peacock                SUPER LIMITED INPUT            rjp1@bayou.com                 05-11-97 (16:39)       QB, QBasic, PDS        170  5108     SLI.BAS     DECLARE FUNCTION InputLine$ (text$, ViewWidth%, keycode%)„DECLARE FUNCTION Lesser% (Var1%, Var2%)„„' Super Limited Input!!„„„' Hello all!„' This is a cool little thing to let you have an input line, that can scroll„' back anf forth with the left & right keys!  You also type.  (Just run it)„' Do with this what you will, just give me small credit.„„' I am Richard Peacock, Of Peacock Programming.  My page is at:„' www.bayou.com/~rjp1/        Go there and follow the link to my„' game page.  Thanx all....and bye!„'      ./„'     /|„'     / \„„        'These are the ascii codes of the keys.„„CONST false = 0, true = NOT false„CONST ESC = 27, ENTER = 13, BkSpc = 8, TabKey = 9„CONST InsertKey = -82, DeleteKey = -83„CONST HomeKey = -71, CtrlHome = -119„CONST EndKey = -79, CtrlEnd = -117„CONST PgUpKey = -73, PgDnKey = -81„CONST UpArrow = -72, DnArrow = -80, LArrow = -75, RArrow = -77„DIM SHARED CursSize%„„CursSize% = 7„„„CLS„„„        '  Ok, All I'm really doing here is making a pretty little dialog box.„        '  (The one you see when you run the program).„„„„„„LOCATE 4, 1„PRINT "Features:  You can scroll left and right.  Press INSERT to use INS and OVS mode."„PRINT "You can use HOME and END.  You can use Ascii symbols."„„„LOCATE 10, 23„COLOR 0, 7: PRINT "File Name:"„COLOR 15, 2„LOCATE 10, 32„„        ' I will explain this next line:„        ' The first thing in quotes is the starting line.  It can be blank.„        ' The second is how many spaces across to allow.„        ' The last statement is the letter you type.„„a$ = InputLine$("It can scroll when you type!", 29, keycode%)„LOCATE 1, 1: COLOR 7, 0„IF keycode% = ESC THEN LOCATE 1, 1: PRINT "You hit ESC"„IF keycode% = ENTER THEN LOCATE 1, 1: PRINT "You hit ENTER"„PRINT a$„„FUNCTION InputLine$ (text$, ViewWidth%, keycode%)„„MaxLnLen% = 128„LCol% = POS(0): RCol% = LCol% + ViewWidth% - 1„View$ = SPACE$(ViewWidth%)„Work$ = LEFT$(text$, MaxLnLen%)„LnLen% = LEN(Work$)„CCol% = Lesser(LCol% + LnLen%, RCol%)„AChar% = LnLen% + 1„„'LOCATE , , 0, CursSize% - 1, CursSize%„Insert% = true„DO„  LOCATE , LCol%„  LSET View$ = MID$(Work$, AChar% - (CCol% - LCol%), ViewWidth%)„  PRINT View$;„  LOCATE , CCol%, 1„  LnLen% = LEN(Work$)„  DO„    DO: Ky$ = INKEY$: LOOP UNTIL LEN(Ky$)„    keycode% = ASC(Ky$): IF keycode% = 0 THEN keycode% = -ASC(MID$(Ky$, 2))„  LOOP UNTIL keycode% <> BadKey%: BadKey% = 0„  LOCATE , , 0„  SELECT CASE keycode%„    CASE BkSpc„         IF AChar% = 1 THEN„           BEEP: BadKey% = keycode%„         ELSE„           IF AChar% <= LnLen% + 1 THEN„                Work$ = LEFT$(Work$, AChar% - 2) + MID$(Work$, AChar%)„           END IF„           AChar% = AChar% - 1„           IF CCol% <> LCol% THEN CCol% = CCol% - 1„         END IF„    CASE ENTER„         text$ = Work$„         EXIT DO„    CASE ESC„         EXIT DO„    CASE 32 TO 255      ' letter keys„         IF AChar% > MaxLnLen% THEN„           BEEP: BadKey% = keycode%„         ELSE„           IF AChar% <= LnLen% THEN„                IF Insert% THEN„                  IF LnLen% = MaxLnLen% THEN„                    BEEP: BadKey% = keycode%„                  ELSE„                    Work$ = LEFT$(Work$, AChar% - 1) + Ky$ + MID$(Work$, AChar%)„                    AChar% = AChar% + 1„                    IF CCol% <> RCol% THEN CCol% = CCol% + 1„                  END IF„                ELSE 'IF NOT Insert% THEN (in overstrike mode)„                  MID$(Work$, AChar%, 1) = Ky$„                  AChar% = AChar% + 1„                  IF CCol% <> RCol% THEN CCol% = CCol% + 1„                END IF„           ELSE 'IF AChar% > LnLen% THEN„                Work$ = Work$ + SPACE$(AChar% - LnLen% - 1) + Ky$„                AChar% = AChar% + 1„                IF CCol% <> RCol% THEN CCol% = CCol% + 1„           END IF„         END IF„    CASE LArrow„         IF AChar% = 1 THEN„           BEEP: BadKey% = keycode%„         ELSE 'IF AChar% > 1 THEN„           AChar% = AChar% - 1„           IF CCol% <> LCol% THEN CCol% = CCol% - 1„         END IF„    CASE RArrow„         IF AChar% > MaxLnLen% THEN„           BEEP: BadKey% = keycode%„         ELSE„           AChar% = AChar% + 1„           IF CCol% <> RCol% THEN CCol% = CCol% + 1„         END IF„    CASE HomeKey„         AChar% = 1„         CCol% = LCol%„    CASE EndKey„         AChar% = LnLen% + 1„         CCol% = Lesser(LCol% + LnLen%, RCol%)„    CASE InsertKey„         Insert% = NOT Insert%„         IF Insert% THEN„         LOCATE , , , CursSize% - 1, CursSize%„         ELSE„         LOCATE , , , CursSize% / 2, CursSize%„         END IF„    CASE DeleteKey„         IF AChar% <= LnLen% THEN„           Work$ = LEFT$(Work$, AChar% - 1) + MID$(Work$, AChar% + 1)„         END IF„    CASE ELSE„         BEEP: BadKey% = keycode%„  END SELECT„ LOOP„ LOCATE , , , CursSize% - 1, CursSize%„„InputLine$ = text$„„END FUNCTION„„ FUNCTION Lesser% (Var1%, Var2%) STATIC„ Lesser% = Var1%: IF Var2% < Var1% THEN Lesser% = Var2%„END FUNCTION„Brian Bacon                    ADJUSTABLE WORD WRAPPER        kyberteknik@geocities.com      06-02-97 (22:31)       QB, QBasic, PDS        85   2341     WORDWRAP.BAS'WordWrap by KyberTeknik„'yeah, I know this is a really slow demo, but I didn't want to take„'time make it fast.„'„' I got the idea from a word wrapping routine I found somewhere that„' was about 150 lines long. It was fancier, however, but this is a„' smaller version I wrote from scratch the works just as good.„'„' Permission is granted to use this code in your programs if you„' check out my web page... (if you can.. otherwise just use it„' anyways) --->  www.geocities.com/SiliconValley/Lakes/2213„'                kyberteknik@geocities.com„'„DECLARE SUB WordWrap (text$, x1, x2, y1)„a$ = "hello this is some sample text. hahaha"„a$ = a$ + " I made a wordwraper! really, I dont mean any of "„a$ = a$ + "this, this is just sample text...  but this does seem "„a$ = a$ + "to be a fast and SMALL way to word wrap text..."„a$ = a$ + "but dont take the text down to small... or it will screw up."„a$ = a$ + " Press 6 to increase the line length, 4 to decrease it. 'q'"„a$ = a$ + " to end"„„I = 30„DO„  CLS„  WordWrap a$, 1, I, 1„  DO: b$ = INKEY$: LOOP UNTIL b$ <> ""„  IF b$ = "6" THEN„     I = I + 1„     IF I > 80 THEN I = 80„  END IF„  IF b$ = "4" THEN„     I = I - 1„     IF I < 25 THEN I = 25„  END IF„  IF b$ = "q" OR b$ = "Q" THEN END„LOOP„„SUB WordWrap (text$, x1, x2, y1)„    savetext$ = text$„    s = x2 - x1„    y = y1„    LOCATE y, x1„    IF LEN(text$) > s THEN„       DO„         IF LEN(text$) = 0 THEN EXIT DO„         text$ = LTRIM$(text$)„         IF LEN(text$) >= s THEN„            tmp$ = LEFT$(text$, s)„         ELSE„            tmp$ = text$„         END IF„         stmp$ = tmp$„         GOSUB ReverseTmp„         IF MID$(text$, s + 1, 1) = " " THEN„            PRINT stmp$„            text$ = MID$(text$, s + 1)„         ELSE„         a = INSTR(tmp$, " ")„         IF a = 0 THEN„            PRINT stmp$„            text$ = MID$(text$, s + 1)„         ELSE„            PRINT LEFT$(text$, s - a)„            text$ = MID$(text$, s - a + 1)„         END IF„         END IF„         y = y + 1„         LOCATE y, x1„       LOOP„    ELSE„       PRINT s„    END IF„    text$ = savetext$„    EXIT SUB„„ReverseTmp:„    t$ = ""„    FOR I = LEN(tmp$) TO 1 STEP -1„        t$ = t$ + MID$(tmp$, I, 1)„    NEXT I„    tmp$ = t$„    RETURN„END SUB„„Jason Lashua                   ICE WRITE                      allthat@ix.netcom.com          05-31-97 (03:52)       QB, QBasic, PDS        63   1897     ICEWRITE.BAS'„' IceWrite! Ver 0.26a By Jason Lashua -- yet another useless program..„'„' Uhm, ok.. heres deh deal.  you just type„' IceWrite " This is my text f00", y„' where Y is which line on the screen to write the line.„' and it makes the text fade like ice or something, and gives it a moving„' effect.. lot smoother than some other QB sources i've seen„' easy 'nuff eh? herez a l'il example„'„' By the way,  if somebody could make a textmode GET/PUT routine that WORKS,„' Please do =] i just dont like all these type mismatch errors..kinda.. make„' me.. dizzy.. wwoooo„' aight, 'less talk, more program„'„DECLARE SUB IceWrite (writing$, y)„'„'„CLS„' notice the leading space, thats just so it shows all the letters, instead of„' cutting off the first one..„„IceWrite "This looks like Ice fading, or something!! woohoo", 4„IceWrite "hey! waddaya know?? it actually works!! something that REALLY WORKS!=]", 10„„' puts the text "This looks like Ice fading, or something!! woohoo on line 4„' press F-5 and try it!„'„'„' Oh yea, if you use this source in your program, please give me credit where„' it is due„„SUB IceWrite (writing$, y)„'the iceing„'keeps repeating until a key is pressed„DO WHILE INKEY$ = ""„  FOR i = 1 TO LEN(writing$)„    LOCATE y, i„    COLOR 0„    PRINT MID$(writing$, i, 1);„    COLOR 7„    PRINT MID$(writing$, i + 1, 1);„    COLOR 15„    PRINT MID$(writing$, i + 2, 1);„    COLOR 11„    PRINT MID$(writing$, i + 3, 1);„    COLOR 9„    PRINT MID$(writing$, i + 4, 1);„    COLOR (1)„    PRINT MID$(writing$, i + 5, 1);„    COLOR (9)„    PRINT MID$(writing$, i + 6, 1);„    COLOR (11)„    PRINT MID$(writing$, i + 7, 1);„    COLOR (0)„    PRINT MID$(writing$, i + 8, length)„    ' this right here is the delay between each letter„    ' adjust to taste„    FOR x = 1 TO 8000: NEXT x„    LOCATE y, i„  NEXT i„  LOOP„END SUB„Jason Lashua                   FALLING TEXT                   allthat@ix.netcom.com          05-31-97 (03:52)       QB, QBasic, PDS        42   979      FALLTEXT.BASDECLARE SUB FallText (text$, x!, y!, desty!)„DECLARE SUB gotoxy (x!, y!)„' FallText! V1.0 by Jason Lashua„'„' whut this dumb thing does, is just makes a text string 'fall' 1 letter at a„' time to a user defined line on the screen.„'„' if u use this source in your programs, please give me credit where it is„' due„'„' Syntax: falltext "Text message" X,Y,DestY„' where X,Y are the cooridinates of the screen to place the string„' DestY is the destination line on the screen to make the text fall to„'„' Lets try it..„'„FallText "Falling Text!!! WOOOOHOOOO! lalalalalalalaal blah", 1, 1, 23„„„„„SUB FallText (text$, x, y, desty)„gotoxy x, y„PRINT text$„FOR i = 1 TO LEN(text$)„FOR y = 1 TO desty„fall$ = MID$(text$, i, 1)„gotoxy i, y„PRINT " ";„gotoxy i, y + 1„PRINT fall$;„FOR delay = 1 TO 300: NEXT delay'edit to taste„NEXT y„NEXT i„END SUB„„SUB gotoxy (x, y)„' ok, i hate LOCATE .. y? its BACKWARDS!!!„' 'nuff sed.„LOCATE y, x„END SUB„„Ethan Eade                     CHARACTER COUNT OF TEXT FILES  ethaneade@toad.net             06-15-97 (22:23)       QB, QBasic, PDS        190  14733    CHARCNT.BAS DECLARE SUB printnumberofchars (chars() AS INTEGER, title AS STRING)„DECLARE FUNCTION maxvalue (chars() AS INTEGER)„DECLARE SUB calculate (chars() AS INTEGER)„DECLARE SUB printer (multifilecount() AS INTEGER, allfiles() AS STRING)„DIM multifilecount(1 TO 26) AS INTEGER„DIM chars(1 TO 26)  AS INTEGER„DIM multifile(1 TO 10) AS STRING„DIM allfiles(1 TO 10) AS STRING„1 :„DO„IF NOT nofileflag THEN filenumber = filenumber + 1„nofileflag = 0„SCREEN 0„CLS„IF NOT filenumber = 1 THEN„COLOR 14, 4: PRINT " Files processed:": COLOR 14, 0„FOR index = 1 TO 10„IF NOT allfiles(index) = "" THEN PRINT "                   "; allfiles(index)„NEXT index„PRINT„END IF„COLOR 14, 4: PRINT " Filename ("; CHR$(34); : COLOR 30: PRINT "quit"; : COLOR 14: PRINT CHR$(34); " to exit,"; CHR$(34); : COLOR 30: PRINT "print"; : COLOR 14: PRINT CHR$(34); " to print current values):";„COLOR , 0: INPUT " ", filename$„IF UCASE$(filename$) = "QUIT" THEN END„IF UCASE$(filename$) = "PRINT" THEN CALL printer(multifilecount(), allfiles()): nofileflag = 1: GOTO 1„IF NOT MID$(filename$, 2, 2) = ":\" THEN filename$ = "c:\" + filename$„IF NOT nofileflag THEN allfiles(filenumber) = filename$„IF NOT filenumber = 1 AND NOT filenumber = 10 THEN„multifile(filenumber) = ", " + filename$„ELSEIF filenumber = 1 THEN multifile(filenumber) = filename$„ELSEIF filenumber = 10 THEN multifile(filenumber) = ", and " + filename$ + "."„END IF„OPEN filename$ FOR INPUT AS #1„SCREEN 12„CALL calculate(chars())„FOR index = 1 TO 26„multifilecount(index) = multifilecount(index) + chars(index)„NEXT index„CALL printnumberofchars(chars(), "Results of file " + filename$)„multifilenames$ = ""„FOR index = 1 TO 10„'IF NOT nextline AND LEN(multifilenames$) > 15 THEN multifilenames$ = multifilenames$ + CHR$(13) + CHR$(10): nextline = 1„multifilenames$ = multifilenames$ + multifile(index)„NEXT index„IF NOT filenumber = 1 THEN CALL printnumberofchars(multifilecount(), "Results of Multifile Count of files " + multifilenames$)„CLOSE (1)„LOOP„„SUB calculate (chars() AS INTEGER)„DIM hloc, lasthloc, module AS DOUBLE„CLS„hloc = 2„LINE (1, 20)-(639, 40), , B„module = (1 / 638) * LOF(1)„LOCATE 1, 1: COLOR 4: PRINT "Reading and Calculating...": COLOR 15„FOR index = 1 TO LOF(1)„IF NOT INT((index / LOF(1)) * 100) = Percent THEN LOCATE 1, 36: PRINT INT((index / LOF(1)) * 100); "%": Percent = INT((index / LOF(1)) * 100)„IF NOT index = LOF(1) AND index > (hloc - 1) * module THEN„   LINE (2, 21)-(hloc, 39), 1, BF: hloc = hloc + (1 / module)„END IF„IF index = LOF(1) THEN LINE (2, 21)-(638, 39), 1, BF„char$ = INPUT$(1, 1)„SELECT CASE UCASE$(char$)„   CASE "A": chars(1) = chars(1) + 1„   CASE "B": chars(2) = chars(2) + 1„   CASE "C": chars(3) = chars(3) + 1„   CASE "D": chars(4) = chars(4) + 1„   CASE "E": chars(5) = chars(5) + 1„   CASE "F": chars(6) = chars(6) + 1„   CASE "G": chars(7) = chars(7) + 1„   CASE "H": chars(8) = chars(8) + 1„   CASE "I": chars(9) = chars(9) + 1„   CASE "J": chars(10) = chars(10) + 1„   CASE "K": chars(11) = chars(11) + 1„   CASE "L": chars(12) = chars(12) + 1„   CASE "M": chars(13) = chars(13) + 1„   CASE "N": chars(14) = chars(14) + 1„   CASE "O": chars(15) = chars(15) + 1„   CASE "P": chars(16) = chars(16) + 1„   CASE "Q": chars(17) = chars(17) + 1„   CASE "R": chars(18) = chars(18) + 1„   CASE "S": chars(19) = chars(19) + 1„   CASE "T": chars(20) = chars(20) + 1„   CASE "U": chars(21) = chars(21) + 1„   CASE "V": chars(22) = chars(22) + 1„   CASE "W": chars(23) = chars(23) + 1„   CASE "X": chars(24) = chars(24) + 1„   CASE "Y": chars(25) = chars(25) + 1„   CASE "Z": chars(26) = chars(26) + 1„END SELECT„NEXT„END SUB„„FUNCTION maxvalue (chars() AS INTEGER)„FOR index = 1 TO 26„IF chars(index) > MAX THEN MAX = chars(index)„NEXT index„maxvalue = MAX„END FUNCTION„„SUB printer (multifilecount() AS INTEGER, allfiles() AS STRING)„LOCATE 15, 33: COLOR 30, 4: PRINT "Printing...": COLOR , 0„FOR index = 1 TO 26„total = total + multifilecount(index)„NEXT index„LPRINT "   Total Character Count of the Following Files:"„FOR index = 1 TO 10„IF NOT allfiles(index) = "" THEN LPRINT "         " + allfiles(index)„NEXT index„LPRINT STRING$(75, "_")„FOR index = 1 TO 26„LPRINT "   Occurrences of character "; CHR$(index + 64); ": " + STR$(multifilecount(index)) + "    Percentage of total characters: " + LEFT$(STR$(multifilecount(index) / total * 100), 5)„NEXT index„FOR index = 1 TO 32„LPRINT„NEXT index„END SUB„„SUB printnumberofchars (chars() AS INTEGER, title AS STRING)„CLS„module = 350 / maxvalue(chars())„FOR index = 1 TO 26„total = total + chars(index)„LOCATE 29, index * 2 + 2: PRINT CHR$(index + 64);„IF NOT chars(index) = 0 THEN LINE (index * 16 + 4, 445)-(index * 16 + 18, 445 - (module * chars(index))), 1, BF„NEXT index„LOCATE 1, 1: COLOR 4: PRINT title: COLOR 15„SELECT CASE UCASE$(INPUT$(1))„   CASE "A": LOCATE 3, 25: PRINT CHR$(65); ":"; STR$(chars(1)): PRINT "Percent of all characters: " + STR$(chars(1) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "B": LOCATE 3, 25: PRINT CHR$(66); ":"; STR$(chars(2)): PRINT "Percent of all characters: " + STR$(chars(2) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "C": LOCATE 3, 25: PRINT CHR$(67); ":"; STR$(chars(3)): PRINT "Percent of all characters: " + STR$(chars(3) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "D": LOCATE 3, 25: PRINT CHR$(68); ":"; STR$(chars(4)): PRINT "Percent of all characters: " + STR$(chars(4) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "E": LOCATE 3, 25: PRINT CHR$(69); ":"; STR$(chars(5)): PRINT "Percent of all characters: " + STR$(chars(5) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "F": LOCATE 3, 25: PRINT CHR$(70); ":"; STR$(chars(6)): PRINT "Percent of all characters: " + STR$(chars(6) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "G": LOCATE 3, 25: PRINT CHR$(71); ":"; STR$(chars(7)): PRINT "Percent of all characters: " + STR$(chars(7) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "H": LOCATE 3, 25: PRINT CHR$(72); ":"; STR$(chars(8)): PRINT "Percent of all characters: " + STR$(chars(8) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "I": LOCATE 3, 25: PRINT CHR$(73); ":"; STR$(chars(9)): PRINT "Percent of all characters: " + STR$(chars(9) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "J": LOCATE 3, 25: PRINT CHR$(74); ":"; STR$(chars(10)): PRINT "Percent of all characters: " + STR$(chars(10) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "K": LOCATE 3, 25: PRINT CHR$(75); ":"; STR$(chars(11)): PRINT "Percent of all characters: " + STR$(chars(11) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "L": LOCATE 3, 25: PRINT CHR$(76); ":"; STR$(chars(12)): PRINT "Percent of all characters: " + STR$(chars(12) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "M": LOCATE 3, 25: PRINT CHR$(77); ":"; STR$(chars(13)): PRINT "Percent of all characters: " + STR$(chars(13) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "N": LOCATE 3, 25: PRINT CHR$(78); ":"; STR$(chars(14)): PRINT "Percent of all characters: " + STR$(chars(14) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "O": LOCATE 3, 25: PRINT CHR$(79); ":"; STR$(chars(15)): PRINT "Percent of all characters: " + STR$(chars(15) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "P": LOCATE 3, 25: PRINT CHR$(80); ":"; STR$(chars(16)): PRINT "Percent of all characters: " + STR$(chars(16) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "Q": LOCATE 3, 25: PRINT CHR$(81); ":"; STR$(chars(17)): PRINT "Percent of all characters: " + STR$(chars(17) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "R": LOCATE 3, 25: PRINT CHR$(82); ":"; STR$(chars(18)): PRINT "Percent of all characters: " + STR$(chars(18) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "S": LOCATE 3, 25: PRINT CHR$(83); ":"; STR$(chars(19)): PRINT "Percent of all characters: " + STR$(chars(19) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "T": LOCATE 3, 25: PRINT CHR$(84); ":"; STR$(chars(20)): PRINT "Percent of all characters: " + STR$(chars(20) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "U": LOCATE 3, 25: PRINT CHR$(85); ":"; STR$(chars(21)): PRINT "Percent of all characters: " + STR$(chars(21) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "V": LOCATE 3, 25: PRINT CHR$(86); ":"; STR$(chars(22)): PRINT "Percent of all characters: " + STR$(chars(22) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "W": LOCATE 3, 25: PRINT CHR$(87); ":"; STR$(chars(23)): PRINT "Percent of all characters: " + STR$(chars(23) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "X": LOCATE 3, 25: PRINT CHR$(88); ":"; STR$(chars(24)): PRINT "Percent of all characters: " + STR$(chars(24) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "Y": LOCATE 3, 25: PRINT CHR$(89); ":"; STR$(chars(25)): PRINT "Percent of all characters: " + STR$(chars(25) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE "Z": LOCATE 3, 25: PRINT CHR$(90); ":"; STR$(chars(26)): PRINT "Percent of all characters: " + STR$(chars(26) / total * 100) + "%" + SPACE$(50 - POS(1)): LOCATE 3, 1: PRINT "Occurrences of character";„   CASE CHR$(27): EXIT SUB„   CASE " ": EXIT SUB„END SELECT„DO„SELECT CASE UCASE$(INPUT$(1))„   CASE "A": LOCATE 3, 25: PRINT CHR$(65); ":"; STR$(chars(1)): PRINT "Percent of all characters: " + STR$(chars(1) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "B": LOCATE 3, 25: PRINT CHR$(66); ":"; STR$(chars(2)): PRINT "Percent of all characters: " + STR$(chars(2) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "C": LOCATE 3, 25: PRINT CHR$(67); ":"; STR$(chars(3)): PRINT "Percent of all characters: " + STR$(chars(3) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "D": LOCATE 3, 25: PRINT CHR$(68); ":"; STR$(chars(4)): PRINT "Percent of all characters: " + STR$(chars(4) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "E": LOCATE 3, 25: PRINT CHR$(69); ":"; STR$(chars(5)): PRINT "Percent of all characters: " + STR$(chars(5) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "F": LOCATE 3, 25: PRINT CHR$(70); ":"; STR$(chars(6)): PRINT "Percent of all characters: " + STR$(chars(6) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "G": LOCATE 3, 25: PRINT CHR$(71); ":"; STR$(chars(7)): PRINT "Percent of all characters: " + STR$(chars(7) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "H": LOCATE 3, 25: PRINT CHR$(72); ":"; STR$(chars(8)): PRINT "Percent of all characters: " + STR$(chars(8) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "I": LOCATE 3, 25: PRINT CHR$(73); ":"; STR$(chars(9)): PRINT "Percent of all characters: " + STR$(chars(9) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "J": LOCATE 3, 25: PRINT CHR$(74); ":"; STR$(chars(10)): PRINT "Percent of all characters: " + STR$(chars(10) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "K": LOCATE 3, 25: PRINT CHR$(75); ":"; STR$(chars(11)): PRINT "Percent of all characters: " + STR$(chars(11) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "L": LOCATE 3, 25: PRINT CHR$(76); ":"; STR$(chars(12)): PRINT "Percent of all characters: " + STR$(chars(12) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "M": LOCATE 3, 25: PRINT CHR$(77); ":"; STR$(chars(13)): PRINT "Percent of all characters: " + STR$(chars(13) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "N": LOCATE 3, 25: PRINT CHR$(78); ":"; STR$(chars(14)): PRINT "Percent of all characters: " + STR$(chars(14) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "O": LOCATE 3, 25: PRINT CHR$(79); ":"; STR$(chars(15)): PRINT "Percent of all characters: " + STR$(chars(15) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "P": LOCATE 3, 25: PRINT CHR$(80); ":"; STR$(chars(16)): PRINT "Percent of all characters: " + STR$(chars(16) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "Q": LOCATE 3, 25: PRINT CHR$(81); ":"; STR$(chars(17)): PRINT "Percent of all characters: " + STR$(chars(17) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "R": LOCATE 3, 25: PRINT CHR$(82); ":"; STR$(chars(18)): PRINT "Percent of all characters: " + STR$(chars(18) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "S": LOCATE 3, 25: PRINT CHR$(83); ":"; STR$(chars(19)): PRINT "Percent of all characters: " + STR$(chars(19) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "T": LOCATE 3, 25: PRINT CHR$(84); ":"; STR$(chars(20)): PRINT "Percent of all characters: " + STR$(chars(20) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "U": LOCATE 3, 25: PRINT CHR$(85); ":"; STR$(chars(21)): PRINT "Percent of all characters: " + STR$(chars(21) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "V": LOCATE 3, 25: PRINT CHR$(86); ":"; STR$(chars(22)): PRINT "Percent of all characters: " + STR$(chars(22) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "W": LOCATE 3, 25: PRINT CHR$(87); ":"; STR$(chars(23)): PRINT "Percent of all characters: " + STR$(chars(23) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "X": LOCATE 3, 25: PRINT CHR$(88); ":"; STR$(chars(24)): PRINT "Percent of all characters: " + STR$(chars(24) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "Y": LOCATE 3, 25: PRINT CHR$(89); ":"; STR$(chars(25)): PRINT "Percent of all characters: " + STR$(chars(25) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE "Z": LOCATE 3, 25: PRINT CHR$(90); ":"; STR$(chars(26)): PRINT "Percent of all characters: " + STR$(chars(26) / total * 100) + "%" + SPACE$(50 - POS(1))„   CASE CHR$(27): EXIT SUB„   CASE " ": EXIT SUB„END SELECT„LOOP„END SUB„Kurt Kuzba                     CALCULATOR-STYLE INPUT         FidoNet QUIK_BAS Echo          06-20-97 (06:20)       QB, QBasic, PDS        54   1933     CALCGET.BAS '>   I am working on a calculator program, but the biggest„'>   problem is how do I enter the numbers from right to left,„'>   instead of the normal left to right?„'   You could try something like the code below.„'   As you can see, the actual calculator code is not functional.„'   The input routine works pretty well, though! :)„'_|_|_|   CALCGET$.BAS„'_|_|_|   Example of a method to get calculator-style input.„'_|_|_|   No warrantee or guarantee is given or implied.„'_|_|_|   PUBLIC DOMAIN   by Kurt Kuzba.     (6/19/1997)„DIM CalcWin AS STRING * 16, Nm AS STRING„DIM dec AS INTEGER, clr AS INTEGER„DIM Memory AS DOUBLE, Result AS DOUBLE, Entry AS DOUBLE„clr = 1: Entry = 0: Result = 0: Memory = 0„DO„   CalcWin = RIGHT$(SPACE$(15) + STR$(Entry), 16)„   LOCATE 5, 35: PRINT CalcWin„   DO: K$ = UCASE$(INKEY$)„      K% = INSTR(" 0123456789.+-*/^%=~MRACE" + CHR$(27), K$)„   LOOP WHILE K% < 2: K% = K% - 2„   IF clr > 0 THEN„      Entry = 0: clr = 0„      CalcWin = RIGHT$(SPACE$(15) + STR$(Entry), 16)„      LOCATE 5, 35: PRINT CalcWin„   END IF„   SELECT CASE K%„      CASE IS < 10„         Nm = LTRIM$(CalcWin)„         IF dec > 0 THEN„            IF INSTR(Nm, ".") = 0 THEN Nm = Nm + "."„         END IF„         Nm = Nm + K$: Nm = RIGHT$(Nm, 16): Entry = VAL(Nm)„      CASE 10: dec = 1„      CASE 11   'add„         Result = Result + Entry: Entry = Result: clr = 1„      CASE 12: 'subtract„         Result = Result - Entry: Entry = Result: clr = 1„      CASE 13: 'multiply„      CASE 14: 'divide„      CASE 15: 'square„      CASE 16: 'percent„      CASE 17: 'equal„      CASE 18: 'square root„      CASE 19: 'to memory„      CASE 20: 'recall memory„      CASE 21: 'add to memory„      CASE 22   'Clear„         Entry = 0: Result = 0: dec = 0„      CASE 23   'Clear Entry„         Entry = 0: dec = 0„      CASE 24: EXIT DO„   END SELECT„LOOP„'_|_|_|   end   CALCGET$.BAS„Daniel Kalna                   VIEW BOX SUBROUTINE            drk@Xswbell.net                06-23-97 (18:42)       QB, QBasic, PDS        116  4206     VIEWBOX.BAS '  View Box v1.0:  By Daniel Kalna„'  http://www.geocities.com/SiliconValley/Lakes/4616/„'  Written with QuickBasic 4.5  Should work in Qbasic, haven't tried it.„„'  Displays plain ASCII text files in a View Box window.„'  Use /AH option if text file contains more than 6000 lines.„'  Uses dynamic array to save memory workspace.„'  Able to view a text file over 2 megabytes big with 16000 lines.„'  Scroll up/down thru file.  PgUp/PgDn/Home/End keys work too.„'  Esc key exits the subroutine.„'  Allows left/right scrolling for files wider than the viewbox window„'  Cut and paste the subroutine into your own program.„„DECLARE SUB ViewBox (FileName$, ULR%, ULC%, LRR%, LRC%)„„DEFINT A-Z„„COLOR 1, 11„CLS„„PRINT "                         View Box Subroutine Demo"„PRINT„PRINT "         This demo displays the source code for this demo program"„PRINT "         in a viewbox window."„„FileName$ = "viewbox.bas"„„ULR = 8: ULC = 10       'upper left row / upper left column„LRR = 23: LRC = 70     'lower right row / lower right column„„COLOR 11, 1„„ViewBox FileName$, ULR, ULC, LRR, LRC„„CLOSE„END„„SUB ViewBox (FileName$, ULR, ULC, LRR, LRC)„„ DisplayedX = LRR - ULR - 1   ' Number of rows displayed at one time„ ClipLength = LRC - ULC - 1   'number of columns displayed at one time„ OffsetY = 1„ TempWipe$ = "±" + STRING$(ClipLength, 32) + "±"„„ '-- analyze text file, count the number of lines in the file„ FileNumber = FREEFILE„ OPEN FileName$ FOR INPUT AS #FileNumber„ WHILE NOT EOF(FileNumber)„   LINE INPUT #FileNumber, Record$„   LineCount = LineCount + 1„ WEND„ CLOSE #FileNumber„„ 'Build listbox frame„  FOR i = ULR TO LRR: LOCATE i, ULC: PRINT TempWipe$; : NEXT i„  LOCATE LRR, ULC: PRINT STRING$(ClipLength + 2, 177);„  LOCATE ULR, ULC: PRINT STRING$(ClipLength + 2, 177);„„ 'build index, record byte location and line length of each line„ Pointer = 1„ REDIM TempIndex(LineCount + 1, 2) AS LONG„ OPEN FileName$ FOR INPUT AS #FileNumber„ TempIndex(Pointer, 1) = 1               'first record location is one„ WHILE NOT EOF(FileNumber)„   LINE INPUT #FileNumber, Record$       'get record„   TempIndex(Pointer, 2) = LEN(Record$)  'record length„   IF TempIndex(Pointer, 2) > MaxLength THEN MaxLength = TempIndex(Pointer, 2)„   Pointer = Pointer + 1„   TempIndex(Pointer, 1) = TempIndex(Pointer - 1, 1) + LEN(Record$) + 2„ WEND„ CLOSE #FileNumber„„„ '-- display file„ OPEN FileName$ FOR BINARY AS #FileNumber„„ ExitFlag = 0„ Pointer = 1„„ WHILE ExitFlag = 0„   'display screen of text„   LOCATE ULR + 1, ULC + 1„   Xloc = ULR„   IF Pointer < 1 THEN Pointer = 1„   FOR i = Pointer TO Pointer + (DisplayedX - 1)   'rows (ULR+1 to LRR-1)„     IF i <= LineCount THEN„       SEEK #FileNumber, TempIndex(i, 1)„       Record$ = INPUT$(TempIndex(i, 2), #FileNumber)„       Xloc = Xloc + 1„       LOCATE Xloc, ULC: PRINT TempWipe$;„       LOCATE Xloc, ULC + 1„       PRINT MID$(Record$, OffsetY, ClipLength);„     END IF„   NEXT i„„   '-- process keyboard input„   KeyCode$ = "": WHILE KeyCode$ = "": KeyCode$ = INKEY$: WEND„   IF KeyCode$ = CHR$(27) THEN CLOSE FileNumer: EXIT SUB„   IF KeyCode$ = CHR$(0) + CHR$(72) THEN Pointer = Pointer - 1: IF Pointer < 1 THEN Pointer = 1„   IF KeyCode$ = CHR$(0) + CHR$(80) THEN Pointer = Pointer + 1: IF Pointer + (DisplayedX - 1) > LineCount THEN Pointer = LineCount - (DisplayedX - 1)„   IF KeyCode$ = CHR$(0) + CHR$(75) THEN OffsetY = OffsetY - 5: IF OffsetY < 1 THEN OffsetY = 1„   IF KeyCode$ = CHR$(0) + CHR$(77) THEN„      OffsetY = OffsetY + 5„      IF OffsetY > (MaxLength - ClipLength + 1) THEN OffsetY = (MaxLength - ClipLength + 1)„      IF OffsetY < 1 THEN OffsetY = 1„   END IF„   IF KeyCode$ = CHR$(0) + CHR$(73) THEN Pointer = Pointer - (DisplayedX - 1): IF Pointer < 1 THEN Pointer = 1„   IF KeyCode$ = CHR$(0) + CHR$(81) THEN Pointer = Pointer + (DisplayedX - 1): IF Pointer + (DisplayedX - 1) > LineCount THEN Pointer = LineCount - (DisplayedX - 1)„   IF KeyCode$ = CHR$(0) + CHR$(71) THEN Pointer = 1„   IF KeyCode$ = CHR$(0) + CHR$(79) THEN Pointer = LineCount - (DisplayedX - 1)„ WEND„„ CLOSE FileNumber„ ERASE TempIndex„„END SUB„Brian Mahocker                 (TALKER) TEXT MANIPULATIONS    Kain121182@aol.com             07-03-97 (12:01)       QB, QBasic, PDS        172  7082     TALKER.BAS  DECLARE SUB RandomIn (x, y, text$, pause, col)„DECLARE SUB BackwardsTalker (x, y, text$, col)„DECLARE SUB CoolPause (x, y, speed)„DECLARE SUB CaseColorTalker (x, y, text$, firstcase)„DECLARE SUB ColorTalker (x, y, text$)„DECLARE SUB CaseTalker (x, y, c, text$, firstcase)„„'Go into the sub for information on it„„CLS„COLOR 15: LOCATE 1, 1: PRINT "Case Talker"„CaseTalker 2, 10, 9, "Brian's da bomb", 1„COLOR 15: LOCATE 4, 1: PRINT "Color Talker"„ColorTalker 5, 10, "Who da man?"„COLOR 15: LOCATE 7, 1: PRINT "Case & Color Talker"„CaseColorTalker 8, 10, "do i rule? i think so", 1„COLOR 15: LOCATE 10, 1: PRINT "Backwards Talker"„BackwardsTalker 11, 10, "This iz cool!", 10„COLOR 15: LOCATE 13, 1: PRINT "Random In"„RandomIn 14, 10, "Real Programmers Use Q-Basic!!!!", 500, 9„COLOR 15: LOCATE 16, 1: PRINT "Cool Pause"„CoolPause 17, 10, 200„„SUB BackwardsTalker (x, y, text$, col)„„'Backwards Talker By: Brian Mahocker - Contact me at "Kain121182@AOL.COM„'What this does is print text$ in backwards„'Variables - X = Xpos on the screen, Y = Ypos on the screen„'            text$ = The text to be Backwarded, Col = The color of the text„COLOR col„FOR BW = LEN(text$) TO 1 STEP -1„   LET BWT$ = BWT$ + MID$(text$, BW, 1)„NEXT BW„LOCATE x, y: PRINT BWT$„END SUB„„SUB CaseColorTalker (x, y, text$, firstcase)„„'Case & Color Talker By: Brian Mahocker - Contact me at "Kain121182@AOL.COM„'What this does is print text$ in case like this, "BrIaN Is dA BoMb" and„'                                                     in different colors„'Variables - X = Xpos on the screen, Y = Ypos on the screen„'            text$ = The text to be CaseColorTalked„'            firstcase = if it is 1, the first letter will be lower case„'            firstcase = if it is 2, the first letter will be upper case„„IF firstcase = 1 THEN LET cas = 1„IF firstcase = 2 THEN LET cas = 2„FOR CCT = 1 TO LEN(text$)„   LET c = INT(RND * 15) + 1„   IF cas = 1 THEN„      COLOR c: LOCATE x, y: PRINT LCASE$(MID$(text$, CCT, 1)): LET y = y + 1„   END IF„   IF cas = 2 THEN„      COLOR c: LOCATE x, y: PRINT UCASE$(MID$(text$, CCT, 1)): LET y = y + 1„   END IF„   IF cas = 2 THEN LET cas = 1: GOTO NextcCT„   IF cas = 1 THEN LET cas = 2: GOTO NextcCT„NextcCT:„NEXT CCT„„„END SUB„„SUB CaseTalker (x, y, c, text$, firstcase)„„'Case Talker By: Brian Mahocker - Contact me at "Kain121182@AOL.COM"„'Simply what this does is print text$ in case like this, "BrIaN Is dA BoMb"„'Variables - X = Xpos on the screen, Y = Ypos on the screen„'            c = Color of text, text$ = The text to be CaseTalked„'            firstcase = if it is 1, the first letter will be lower case„'            firstcase = if it is 2, the first letter will be upper case„„IF firstcase = 1 THEN LET cas = 1„IF firstcase = 2 THEN LET cas = 2„FOR CT = 1 TO LEN(text$)„   IF cas = 1 THEN„      COLOR c: LOCATE x, y: PRINT LCASE$(MID$(text$, CT, 1)): LET y = y + 1„   END IF„   IF cas = 2 THEN„      COLOR c: LOCATE x, y: PRINT UCASE$(MID$(text$, CT, 1)): LET y = y + 1„   END IF„   IF cas = 2 THEN LET cas = 1: GOTO NextCT„   IF cas = 1 THEN LET cas = 2: GOTO NextCT„NextCT:„NEXT CT„END SUB„„SUB ColorTalker (x, y, text$)„„'Color Talker By: Brian Mahocker - Contact me at "Kain121182@AOL.COM"„'Simply what this does is print text$ in random colors, 1 letter at a time„'Variables - X = Xpos on the screen, Y = Ypos on the screen„'            text$ = the text to be printed„„RANDOMIZE TIMER„FOR CT = 1 TO LEN(text$)„   LET c = INT(RND * 15) + 1„   COLOR c: LOCATE x, y: PRINT MID$(text$, CT, 1): LET y = y + 1„NEXT CT„END SUB„„SUB CoolPause (x, y, speed)„ „'Cool Pause By: Brian Mahocker - Contact me at 'Kain121182@AOL.COM'„'This is a really cool pause sub„'Variables - X = Xpos on the screen, Y = Ypos on the screen„'            speed = how long the pasue is in between the movements of the ><'s„'            300 is a good setting for speed„DO„LET CoolPauseW$ = INKEY$„LOCATE x, y„COLOR 7: PRINT "..."; : COLOR 8: PRINT "["; : COLOR 7: PRINT "-"; : COLOR 15: PRINT "Press a key!"; : COLOR 7: PRINT "-"; : COLOR 8: PRINT "]"; : COLOR 7: PRINT "..."„LET t = 0: DO: LET CoolPauseW$ = INKEY$„IF CoolPauseW$ <> "" THEN : EXIT SUB„LET t = t + 1: LOOP UNTIL t = speed„LOCATE x, y„COLOR 15: PRINT ">"; : COLOR 7: PRINT ".."; : COLOR 8: PRINT "["; : COLOR 7: PRINT "-"; : COLOR 15: PRINT "Press a key!"; : COLOR 7: PRINT "-"; : COLOR 8: PRINT "]"; : COLOR 7: PRINT ".."; : COLOR 15: PRINT "<"„LET t = 0: DO: LET CoolPauseW$ = INKEY$„IF CoolPauseW$ <> "" THEN : EXIT SUB„LET t = t + 1: LOOP UNTIL t = speed„LOCATE x, y„COLOR 7: PRINT ">"; : COLOR 15: PRINT ">"; : COLOR 7: PRINT "."; : COLOR 8: PRINT "["; : COLOR 7: PRINT "-"; : COLOR 15: PRINT "Press a key!"; : COLOR 7: PRINT "-"; : COLOR 8: PRINT "]"; : COLOR 7: PRINT "."; : COLOR 15: PRINT "<"; : COLOR 7: PRINT  _„"<"„LET t = 0: DO: LET CoolPauseW$ = INKEY$„IF CoolPauseW$ <> "" THEN : EXIT SUB„LET t = t + 1: LOOP UNTIL t = speed„LOCATE x, y„COLOR 8: PRINT ">"; : COLOR 7: PRINT ">"; : COLOR 15: PRINT ">"; : COLOR 8: PRINT "["; : COLOR 7: PRINT "-"; : COLOR 15: PRINT "Press a key!"; : COLOR 7: PRINT "-"; : COLOR 8: PRINT "]"; : COLOR 15: PRINT "<"; : COLOR 7: PRINT "<"; : COLOR 8: PRINT  _„"<"„LET t = 0: DO: LET CoolPauseW$ = INKEY$„IF CoolPauseW$ <> "" THEN : EXIT SUB„LET t = t + 1: LOOP UNTIL t = speed„LOCATE x, y„COLOR 7: PRINT "."; : COLOR 8: PRINT ">"; : COLOR 7: PRINT ">"; : COLOR 8: PRINT "["; : COLOR 7: PRINT "-"; : COLOR 15: PRINT "Press a key!"; : COLOR 7: PRINT "-"; : COLOR 8: PRINT "]"; : COLOR 7: PRINT "<"; : COLOR 8: PRINT "<"; : COLOR 7: PRINT  _„"."„LET t = 0: DO: LET CoolPauseW$ = INKEY$„IF CoolPauseW$ <> "" THEN : EXIT SUB„LET t = t + 1: LOOP UNTIL t = speed„LOCATE x, y„COLOR 7: PRINT ".."; : COLOR 8: PRINT ">"; : COLOR 8: PRINT "["; : COLOR 7: PRINT "-"; : COLOR 15: PRINT "Press a key!"; : COLOR 7: PRINT "-"; : COLOR 8: PRINT "]"; : COLOR 8: PRINT "<"; : COLOR 7: PRINT ".."„LET t = 0: DO: LET CoolPauseW$ = INKEY$„IF CoolPauseW$ <> "" THEN : EXIT SUB„LET t = t + 1: LOOP UNTIL t = speed„LOCATE x, y„COLOR 7: PRINT "..."; : COLOR 8: PRINT "["; : COLOR 7: PRINT "-"; : COLOR 15: PRINT "Press a key!"; : COLOR 7: PRINT "-"; : COLOR 8: PRINT "]"; : COLOR 7: PRINT "..."„LOOP„AfterCoolPause:„END SUB„„SUB RandomIn (x, y, text$, pause, col)„„'RandonIn Talker By: Brian Mahocker - Contact me at "Kain121182@AOL.COM„'What this does is print text$ by printing 1 random letter at a time„'Variables - X = Xpos on the screen, Y = Ypos on the screen„'            text$ = The text to be RandomedIn, Pause = the pause between„'            Col = The color of the text                      each letter.„           „RANDOMIZE TIMER„COLOR col„DIM RI(LEN(text$))„FOR PRI = 1 TO LEN(text$)„GetLet:„   LET WL = INT(RND * LEN(text$)) + 1„   IF RI(WL) = 1 THEN GOTO GetLet„   LET RI(WL) = 1„   LET CurLet$ = MID$(text$, WL, 1)„   LOCATE x, y + WL - 1„   PRINT CurLet$„   FOR delay = 1 TO pause: NEXT delay„NEXT PRI„END SUB„Andrew Below                   SCREEN COMPRESS/DECOMPRESS     bel@obninsk.ru                 07-11-97 (20:20)       QB, QBasic, PDS        53   1192     SCROLL!.BAS 'Screen compress/decompress and horizontal scrool demo.  7/11/97„'---------------------------------------------------------------„'Hi.„'Here is a little screen compress/decompress demo program. I found„'OUT register number, that decreases or increases text scan line flag.„'Just look - it's COOL!„'„'But on my machine, then screen comes up, in the bottom part prints„'strange garbage. If anybody can remove it, please e-mail me how.„'And, If you can tell me, why when screen scrolls horizontally,„'it going up to 1 line, please e-mail me too.„'„'Thanx,„'Andrew.„'E-mail: bel@obninsk.ru„'„DEF SEG = &HB800„„SCREEN 0„CLS„FOR a% = 1 TO 23„ LOCATE a%„ COLOR a% MOD 15 + 1„ PRINT STRING$(80, CHR$(a% + 64))„NEXT a%„„FOR i = 15 TO 0 STEP -1„  OUT &H3D4, 9„  OUT &H3D5, i„  WAIT &H3DA, 10„  FOR t = 1 TO 4000: NEXT t„NEXT i„FOR i = 0 TO 15„  OUT &H3D4, 9„  OUT &H3D5, i„  WAIT &H3DA, 10„  FOR t = 1 TO 4000: NEXT t„NEXT i„FOR i = 80 TO 0 STEP -1„  OUT &H3D4, 13„  OUT &H3D5, i„  WAIT &H3DA, 13„  FOR t = 1 TO 4000: NEXT t„NEXT i„FOR i = 0 TO 80„  OUT &H3D4, 13„  OUT &H3D5, i„  WAIT &H3DA, 13„  FOR t = 1 TO 4000: NEXT t„NEXT i„„DEF SEG„COLOR 15„Tika Carr                      TEXT VIEWER W/ZIP SUPPORT      t.carr@pobox.com               07-20-97 (13:40)       QB, QBasic, PDS        1059 36935    UV2.BAS     ' The Ultimate TEXT Viewer Programmed by William Yu (1994)„' Use within a commercial product is strictly prohibited„' Modify as you wish, includes a file directory listing„'„'ZIP view support added by Tika Carr 7/20/1997. Program assumes PKUNZIP.EXE„'is in the PATH or same directory. Also performs cleanup when opening a new„'file or exiting (deletes the ZIPLST.$$$ file)„„DECLARE SUB HELP1 ()„DECLARE SUB HELP2 ()„DECLARE SUB HELP3 ()„„'$DYNAMIC„DEFINT A-Z„„CONST FALSE = 0„CONST TRUE = NOT FALSE„FPC = FALSE„YC = 1„„CLS : LOCATE , , 0„SHELL "DIR /AD/O > Drive.LST"„„OPEN "Drive.LST" FOR INPUT AS #1„DO„  LINE INPUT #1, CurrentDrive$„LOOP UNTIL INSTR(1, CurrentDrive$, ":\")„„CLOSE 1„KILL "DRIVE.LST"„„Y = LEN(CurrentDrive$)„CurDir$ = MID$(CurrentDrive$, 15, Y)„CurDrive$ = MID$(CurrentDrive$, 15, 2)„DefaultDir$ = MID$(CurrentDrive$, 15, Y)„„Escape = FALSE„File$ = COMMAND$              'For QB/PDS„„START:„CAP = FALSE: YC = 1„ON ERROR GOTO ERRORHANDLE„„IF RIGHT$(File$, 3) = "ZIP" THEN„  SHELL "PKUNZIP -vb " + File$ + " > ZIPLST.$$$"„  File$ = "ZIPLST.$$$"„END IF„„OPEN File$ FOR INPUT AS #1„REDIM Seeks&(1 TO 16000)       'Use 32767 /ah for QB and to compile (BC)„„CurSeek& = 1„Numlines = 0„COLOR 0, 1„FOR J = 1 TO 25„LOCATE J, 1: PRINT STRING$(80, 0)„NEXT J„COLOR 15, 4: LOCATE 25, 1: PRINT "  The Ultimate Text Viewer Version 0.02  FREEWARE"; : COLOR 7, 4: PRINT "  <"; : COLOR 11: PRINT "1"; : COLOR 10: PRINT "2"; : COLOR 3: PRINT "3"; : COLOR 12: PRINT "4"; : COLOR 13: PRINT "5"; : COLOR 14: PRINT "6"; _„ : COLOR 7: PRINT "7"; : COLOR 15: PRINT "8"; : COLOR 9: PRINT "9"; : COLOR 7: PRINT ">"; : COLOR 10: PRINT "  Color Change    "„COLOR 0, 1: LOCATE 24, 1: PRINT STRING$(80, 0)„LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "; : COLOR 15: PRINT "C"; : COLOR 0: PRINT "APTURE     "; : COLOR 15: PRINT "H"; : COLOR 0: PRINT "ELP!                                                   "„„DO UNTIL EOF(1)„  LINE INPUT #1, Text$„  Numlines = Numlines + 1„  Seeks&(Numlines) = CurSeek&          ' Save starting position„  CurSeek& = CurSeek& + LEN(Text$) + 2 ' Next position - 2 is„  LOCATE 1, 60: COLOR 14, 3: PRINT Numlines„  V$ = INKEY$„  IF V$ = CHR$(27) THEN EXIT DO„LOOP                                     ' for C/R & LF„„LOCATE 1, 1„„CurCol = 1                               ' Current Column„SeekEl = 1                               ' Current line„Escape = FALSE„„COLOR 7, 1: X = 7„„DO„  GOSUB LoadAndDisplay„  GOSUB KeyProcess„LOOP UNTIL Escape„„CLOSE„LOCATE 25, 1: COLOR 7, 0: PRINT STRING$(80, 0): LOCATE 24, 1: COLOR 7, 0: PRINT "Thanks for Using The Ultimate Text Viewer Version 0.02  FREEWARE Copy!  (c) 1994": GOTO QUIT„„LoadAndDisplay:„  SEEK #1, Seeks&(SeekEl)„„  FOR I = 2 TO 24„    IF NOT EOF(1) THEN LINE INPUT #1, Text$ ELSE Text$ = ""„    COLOR X, YC„    Strg$ = SPACE$(80)„    IF LEN(Text$) < CurCol THEN Text$ = Text$ + SPACE$(CurCol - LEN(Text$))„    LSET Strg$ = MID$(Text$, CurCol)„    IF NOT EOF(1) AND INSTR(1, Strg$, "") THEN LINE INPUT #1, Text$: Strg$ = SPACE$(80): LSET Strg$ = MID$(Text$, CurCol)„    IF CAP = TRUE AND I = 2 THEN LOCATE I, 1, 0: COLOR 15, 4: PRINT Strg$: COLOR 7, 0: GOTO CF„    LOCATE I, 1, 0: PRINT Strg$;„CF:„IF CAP = TRUE THEN LOCATE 1, 45: COLOR 1, 3: PRINT PS; : COLOR 0, 3: PRINT CHR$(26); : COLOR 1, 3: PRINT SeekEl„  LOCATE 1, 60: COLOR 14, 3: PRINT Numlines; : COLOR 10: PRINT ":"; : COLOR 4: PRINT SeekEl; : COLOR 10: PRINT ":"; : COLOR 15: PRINT CurCol„    COLOR X, YC„  NEXT I„RETURN„„„KeyProcess:„„  DO„    Ky$ = INKEY$„  LOOP UNTIL LEN(Ky$)                'Wait for a keypress„„  IF LEN(Ky$) = 1 THEN               'Create a key code„    KeyCode = ASC(Ky$)               'Regular character key„  ELSE                               'Extended key„    KeyCode = -ASC(RIGHT$(Ky$, 1))„  END IF„„  SELECT CASE KeyCode„    CASE 27„      Escape = TRUE        ' ESC„„    CASE -72             ' Up Arrow„      SeekEl = SeekEl - 1„      IF SeekEl < 1 THEN SeekEl = 1: GOTO KeyProcess„„    CASE -80             ' Dn Arrow„      SeekEl = SeekEl + 1„      IF SeekEl > Numlines THEN SeekEl = SeekEl - 1: GOTO KeyProcess„„    CASE -77             ' Right Arrow„      CurCol = CurCol + 1„„    CASE -75             ' Left Arrow„      CurCol = CurCol - 1„      IF CurCol < 1 THEN CurCol = 1: GOTO KeyProcess„„    CASE -73           ' Page Up„      SeekEl = SeekEl - 23„      IF SeekEl < 1 THEN SeekEl = 1„„    CASE -81, 13, 32           ' Page Dn„      SeekEl = SeekEl + 23„      IF SeekEl > Numlines THEN„        SeekEl = Numlines - 23: GOTO KeyProcess„      END IF„„    CASE -71                       ' Home„    LOCATE 1, 70: COLOR 15, 3: PRINT "          "„      SeekEl = 1„„    CASE -79                       ' End„      SeekEl = Numlines - 23„      IF SeekEl < 1 THEN SeekEl = 1: GOTO KeyProcess„„    CASE 49„      X = 11„    CASE 50„      X = 10„    CASE 51„      X = 3„    CASE 52„      X = 12„    CASE 53„      X = 13„    CASE 54„      X = 14„    CASE 55„      X = 7„    CASE 56„      X = 15„    CASE 57„      X = 9„    CASE 70„      GOSUB FKEY„    CASE 102„      GOSUB FKEY„„    CASE 67„      GOSUB CAPTURE„    CASE 99„      GOSUB CAPTURE„„    CASE 72„      GOSUB HELP„    CASE 104„      GOSUB HELP„„    CASE -59„       CALL HELP2„    CASE -60„    TextFile$ = "TXT"„       GOTO LISTFILES„    CASE -61„    TextFile$ = "*"„       GOTO LISTFILES„    CASE -62„       FPC = TRUE: PCOPY 0, 1: GOTO PRINTER„    CASE -63„       PCOPY 0, 1: GOSUB CAPON„    CASE -64„       PCOPY 0, 1: GOSUB CAPOFF„    CASE -65„       PCOPY 0, 1: GOSUB SAVECAP„    CASE -66„       PCOPY 0, 1: GOSUB DOSSHELL„„    CASE ELSE„      GOTO KeyProcess„„    END SELECT„„RETURN„„FKEY:„FPC = FALSE„PCOPY 0, 1„FOR R = 3 TO 11„LOCATE R, 4: COLOR 0, 0: PRINT STRING$(21, 0)„NEXT R„LOCATE 1, 3: COLOR 15, 4: PRINT " F"; : COLOR 10, 4: PRINT "ILE "„LOCATE 2, 2: COLOR 0, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 3, 2: PRINT CHR$(179); : COLOR 15, 0: PRINT " O"; : COLOR 7, 0: PRINT "pen Text File... "; : COLOR 0, 3: PRINT CHR$(179)„LOCATE 4, 2: PRINT CHR$(179); : COLOR 15, 3: PRINT " L"; : COLOR 0: PRINT "ist All Files    "; CHR$(179)„LOCATE 5, 2: PRINT CHR$(195); STRING$(19, 196); CHR$(180)„LOCATE 6, 2: PRINT CHR$(179); : COLOR 15, 3: PRINT " P"; : COLOR 0: PRINT "rint Entire File "; CHR$(179)„LOCATE 7, 2: PRINT CHR$(179); : COLOR 15, 3: PRINT " D"; : COLOR 0: PRINT "OS Shell...      "; CHR$(179)„LOCATE 8, 2: PRINT CHR$(195); STRING$(19, 196); CHR$(180)„LOCATE 9, 2: PRINT CHR$(179); : COLOR 0, 3: PRINT " E"; : COLOR 15, 3: PRINT "x"; : COLOR 0, 3: PRINT "it              "; CHR$(179)„LOCATE 10, 2: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„ROW = 3„FKEYSEL:„V$ = INKEY$„IF UCASE$(V$) = "X" THEN LOCATE 25, 1: COLOR 7, 0: PRINT STRING$(80, 0): LOCATE 24, 1: COLOR 7, 0: PRINT "Thanks for Using The Ultimate Text Viewer Version 0.02  FREEWARE Copy!  (c) 1994": GOTO QUIT„IF UCASE$(V$) = "P" THEN GOTO PRINTER„IF UCASE$(V$) = "O" THEN TextFile$ = "TXT": GOTO LISTFILES„IF UCASE$(V$) = "L" THEN TextFile$ = "*": GOTO LISTFILES„IF UCASE$(V$) = "D" THEN GOTO DOSSHELL„IF V$ = CHR$(0) + "P" THEN ROW = ROW + 1: GOSUB DOWN„IF V$ = CHR$(0) + "H" THEN ROW = ROW - 1: GOSUB UP„IF V$ = CHR$(0) + "M" THEN PCOPY 1, 0: GOTO CAPTURE„IF V$ = CHR$(0) + "K" THEN PCOPY 1, 0: GOTO HELP„IF V$ = CHR$(13) THEN GOTO ENTER„IF V$ = CHR$(0) + ";" THEN CALL HELP2     'F1„IF V$ = CHR$(0) + "<" THEN TextFile$ = "TXT": GOTO LISTFILES 'F2„IF V$ = CHR$(0) + "=" THEN TextFile$ = "*": GOTO LISTFILES'F3„IF V$ = CHR$(0) + ">" THEN GOSUB PRINTER   'F4„IF V$ = CHR$(0) + "?" THEN GOTO CAPON     'F5„IF V$ = CHR$(0) + "@" THEN GOTO CAPOFF    'F6„IF V$ = CHR$(0) + "A" THEN GOTO SAVECAP   'F7„IF V$ = CHR$(0) + "B" THEN GOTO DOSSHELL  'F8„IF V$ = CHR$(27) THEN PCOPY 1, 0: RETURN„GOTO FKEYSEL„DOWN:„IF ROW = 8 THEN ROW = 3„IF ROW = 3 THEN LOCATE ROW, 3: COLOR 15, 0: PRINT " O"; : COLOR 7, 0: PRINT "pen Text File... ": LOCATE 9, 3: COLOR 0, 3: PRINT " E"; : COLOR 15, 3: PRINT "x"; : COLOR 0, 3: PRINT "it              "„IF ROW = 4 THEN LOCATE ROW, 3: COLOR 15, 0: PRINT " L"; : COLOR 7, 0: PRINT "ist All Files    ": LOCATE 3, 3: COLOR 15, 3: PRINT " O"; : COLOR 0, 3: PRINT "pen Text File... "„IF ROW = 5 THEN LOCATE 6, 3: COLOR 15, 0: PRINT " P"; : COLOR 7, 0: PRINT "rint Entire File ": LOCATE 4, 3: COLOR 15, 3: PRINT " L"; : COLOR 0, 3: PRINT "ist All Files    "„IF ROW = 6 THEN LOCATE 7, 3: COLOR 15, 0: PRINT " D"; : COLOR 7, 0: PRINT "OS Shell...      ": LOCATE 6, 3: COLOR 15, 3: PRINT " P"; : COLOR 0, 3: PRINT "rint Entire File "„IF ROW = 7 THEN LOCATE 9, 3: COLOR 7, 0: PRINT " E"; : COLOR 15, 0: PRINT "x"; : COLOR 7, 0: PRINT "it              ": LOCATE 7, 3: COLOR 15, 3: PRINT " D"; : COLOR 0, 3: PRINT "OS Shell...      "„RETURN„UP:„IF ROW = 2 THEN ROW = 7„IF ROW = 7 THEN LOCATE 3, 3: COLOR 15, 3: PRINT " O"; : COLOR 0, 3: PRINT "pen Text File... ": LOCATE 9, 3: COLOR 7, 0: PRINT " E"; : COLOR 15, 0: PRINT "x"; : COLOR 7, 0: PRINT "it              "„IF ROW = 3 THEN LOCATE 4, 3: COLOR 15, 3: PRINT " L"; : COLOR 0, 3: PRINT "ist All Files    ": LOCATE 3, 3: COLOR 15, 0: PRINT " O"; : COLOR 7, 0: PRINT "pen Text File... "„IF ROW = 4 THEN LOCATE 6, 3: COLOR 15, 3: PRINT " P"; : COLOR 0, 3: PRINT "rint Entire File ": LOCATE 4, 3: COLOR 15, 0: PRINT " L"; : COLOR 7, 0: PRINT "ist All Files    "„IF ROW = 5 THEN LOCATE 7, 3: COLOR 15, 3: PRINT " D"; : COLOR 0, 3: PRINT "OS Shell...      ": LOCATE 6, 3: COLOR 15, 0: PRINT " P"; : COLOR 7, 0: PRINT "rint Entire File "„IF ROW = 6 THEN LOCATE 9, 3: COLOR 0, 3: PRINT " E"; : COLOR 15, 3: PRINT "x"; : COLOR 0, 3: PRINT "it              ": LOCATE 7, 3: COLOR 15, 0: PRINT " D"; : COLOR 7, 0: PRINT "OS Shell...      "„RETURN„ENTER:„IF ROW = 7 THEN LOCATE 25, 1: COLOR 7, 0: PRINT STRING$(80, 0): LOCATE 24, 1: COLOR 7, 0: PRINT "Thanks for Using The Ultimate Text Viewer Version 0.02  FREEWARE Copy!  (c) 1994": GOTO QUIT„IF ROW = 6 THEN GOTO DOSSHELL„IF ROW = 5 THEN GOTO PRINTER„IF ROW = 4 THEN TextFile$ = "*": GOTO LISTFILES„IF ROW = 3 THEN TextFile$ = "TXT": GOTO LISTFILES„„LISTFILES:„PCOPY 1, 0„SHELL "DIR /AD/O > Drive.LST"„„„'=============================„'    Current Drive / Path„'=============================„„DosCmd$ = "DIR *." + TextFile$ + " /B /ON > DIR.LST"„SHELL DosCmd$„LOCATE 2, 4: COLOR 12, 0: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„LOCATE 3, 4: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„LOCATE 4, 4: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„LOCATE 3, 6: COLOR 10: PRINT CurDir$ + "\*."; TextFile$„„LOCATE 6, 10: COLOR 11: PRINT CHR$(218); STRING$(20, 196); CHR$(191)„FOR J = 7 TO 16„  LOCATE J, 10: PRINT CHR$(179); STRING$(20, 0); CHR$(179)„NEXT J„LOCATE 17, 10: PRINT CHR$(192); STRING$(20, 196); CHR$(217)„FOR J = 7 TO 18„LOCATE J, 32: COLOR 7, 8: PRINT STRING$(2, 176)„IF J = 18 THEN LOCATE J, 12: PRINT STRING$(20, 176)„NEXT J„„LOCATE 6, 36: COLOR 11: PRINT CHR$(218); STRING$(12, 196); CHR$(191)„FOR J = 7 TO 16„  LOCATE J, 36: PRINT CHR$(179); STRING$(12, 0); CHR$(179)„NEXT J„LOCATE 17, 36: PRINT CHR$(192); STRING$(12, 196); CHR$(217)„FOR J = 7 TO 18„LOCATE J, 50: COLOR 7, 8: PRINT STRING$(2, 176)„IF J = 18 THEN LOCATE J, 38: PRINT STRING$(12, 176)„NEXT J„„LOCATE 6, 54: COLOR 11: PRINT CHR$(218); STRING$(9, 196); CHR$(191)„FOR J = 7 TO 14„  LOCATE J, 54: PRINT CHR$(179); STRING$(9, 0); CHR$(179)„NEXT J„LOCATE 15, 54: PRINT CHR$(192); STRING$(9, 196); CHR$(217)„FOR J = 7 TO 16„LOCATE J, 65: COLOR 7, 8: PRINT STRING$(2, 176)„IF J = 16 THEN LOCATE J, 56: PRINT STRING$(9, 176)„NEXT J„„LOCATE 7, 57: COLOR 7: PRINT "[-A-]"„LOCATE 8, 57: PRINT "[-B-]"„LOCATE 9, 57: PRINT "[-C-]"„LOCATE 10, 57: PRINT "[-D-]"„LOCATE 11, 57: PRINT "[-E-]"„LOCATE 12, 57: PRINT "[-F-]"„LOCATE 13, 57: PRINT "[-G-]"„LOCATE 14, 57: PRINT "[-H-]"„„TEXTPICK:„CLOSE 1„  REDIM DirNames$(100)„  I = 0„OPEN "DRIVE.LST" FOR INPUT AS #1„„  DO„     INPUT #1, X$„     IF INSTR(1, X$, "<DIR>") THEN„        I = I + 1„        DirNames$(I) = LEFT$(X$, 8)„     END IF„  LOOP WHILE NOT (EOF(1))„GR = I„I = 1„J = 7„DO„     LOCATE J, 38: COLOR 7, 0: PRINT DirNames$(I)„     IF I = GR THEN EXIT DO„     I = I + 1„     J = J + 1„LOOP UNTIL J = 17„„CLOSE„FOR J = 7 TO 16„COLOR 15, 0„LOCATE J, 12: PRINT STRING$(17, 0)„NEXT J„„FileNum = 0„File = 7„I = 7„N = 1„„OPEN "DIR.LST" FOR INPUT AS #1„„DO WHILE NOT EOF(1)„  LINE INPUT #1, FileName$„  FileNum = FileNum + 1„LOOP„„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„DO WHILE NOT EOF(1)„     LINE INPUT #1, FileName$„     COLOR 7„     LOCATE File, 14: PRINT FileName$„     File = File + 1„     IF File = 17 THEN EXIT DO„LOOP„„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„'=============================================„'          Select Text to View„'=============================================„„IF EOF(1) THEN LOCATE 7, 13: COLOR 14, 0: PRINT "No File(s) Found": GOTO DIRECTORY„LINE INPUT #1, FileName$„I = 7„LOCATE I, 12: COLOR 15, 1: PRINT "  " + FileName$ + "  "„„SELECTFILE:„V$ = INKEY$„IF V$ = CHR$(0) + "P" THEN GOSUB SELDOWN„IF V$ = CHR$(0) + "H" THEN GOSUB SELUP„IF V$ = CHR$(0) + "M" THEN COLOR 7, 0: LOCATE I, 12: PRINT "  " + FileName$ + "  ": GOTO DIRECTORY„IF V$ = CHR$(13) THEN„  IF File$ = "ZIPLST.$$$" THEN KILL "ZIPLST.$$$"„  GOTO SELENTER„END IF„IF V$ = CHR$(27) THEN„  IF File$ = "ZIPLST.$$$" THEN KILL "ZIPLST.$$$"„  File$ = "": CLOSE : KILL "DRIVE.LST": KILL "DIR.LST": GOTO START„END IF„GOTO SELECTFILE„„SELDOWN:„IF EOF(1) THEN RETURN„COLOR 7, 0: GOSUB SELMAIN„LINE INPUT #1, FileName$„N = N + 1„I = I + 1„COLOR 15, 1„GOSUB SELMAIN„RETURN„„SELUP:„IF N = 1 THEN RETURN„COLOR 7, 0: GOSUB SELMAIN„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„NU = 1„DO„     LINE INPUT #1, FileName$„     NU = NU + 1„LOOP UNTIL NU = N„N = N - 1: I = I - 1„COLOR 15, 1„GOSUB SELMAIN„RETURN„„SELMAIN:„IF I = 17 THEN I = 16: GOSUB DISPLAYDOWN„IF I = 6 THEN I = 7: GOSUB DISPLAYUP: RETURN„IF I = 7 THEN LOCATE I, 12: PRINT "                ": LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 8 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 9 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 10 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 11 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 12 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 13 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 14 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 15 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 16 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„RETURN„„DISPLAYDOWN:„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„NL = 10„DO„LINE INPUT #1, FileName$„NL = NL + 1„LOOP UNTIL NL = N„„FOR J = 7 TO 16„  LINE INPUT #1, FileName$„    COLOR 7, 0„  LOCATE J, 14: PRINT "            "„  LOCATE J, 14: PRINT FileName$„NEXT J„„COLOR 15, 1„RETURN„„DISPLAYUP:„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„FOR H = 1 TO N„     LINE INPUT #1, FileName$„NEXT H„„LOCATE 7, 14: PRINT "              "„COLOR 15, 1„GOSUB SELMAIN„„FOR J = 8 TO 16„  LINE INPUT #1, FileName$„    COLOR 7, 0„  LOCATE J, 14: PRINT "            "„  LOCATE J, 14: PRINT FileName$„NEXT J„„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„FOR H = 1 TO N„     LINE INPUT #1, FileName$„NEXT H„„RETURN„„„SELENTER:„PCOPY 1, 0„CLOSE„KILL "DRIVE.LST"„KILL "DIR.LST"„File$ = FileName$„GOTO START„„'===============================================„'             Select Directories„'===============================================„„DIRECTORY:„„CLOSE 1„  REDIM DirNames$(75)„  I = 0„OPEN "DRIVE.LST" FOR INPUT AS #1„„  DO„     INPUT #1, X$„     IF INSTR(1, X$, "<DIR>") THEN„        I = I + 1„        DirNames$(I) = LEFT$(X$, 8)„     END IF„  LOOP WHILE NOT (EOF(1))„GR = I„I = 1„J = 7„DO„     LOCATE J, 38: COLOR 7, 0: PRINT DirNames$(I)„     IF I = GR THEN EXIT DO„     I = I + 1„     J = J + 1„LOOP UNTIL J = 17„I = 1: C = 7„LOCATE C, 38: COLOR 15, 4: PRINT DirNames$(1)„„DIRSEL:„V$ = INKEY$„IF V$ = CHR$(0) + "P" THEN GOSUB DIRDOWN„IF V$ = CHR$(0) + "H" THEN GOSUB DIRUP„IF V$ = CHR$(0) + "K" THEN GOTO TEXTPICK„IF V$ = CHR$(0) + "M" THEN GOTO DRIVE„IF V$ = CHR$(13) THEN GOTO DIRENTER„IF V$ = CHR$(27) THEN File$ = "": CLOSE : KILL "DRIVE.LST": KILL "DIR.LST": GOTO START„GOTO DIRSEL„„DIRDOWN:„IF GR = I THEN RETURN„COLOR 7, 0„GOSUB DIRMAIN„C = C + 1: I = I + 1„COLOR 15, 4„GOSUB DIRMAIN„RETURN„„DIRUP:„IF I = 1 THEN RETURN„COLOR 7, 0„GOSUB DIRMAIN„C = C - 1: I = I - 1„COLOR 15, 4„GOSUB DIRMAIN„RETURN„„DIRMAIN:„IF C = 17 THEN C = 16: GOSUB DIRDISDOWN„IF C = 6 THEN C = 7: GOSUB DIRDISUP„LOCATE C, 38: PRINT DirNames$(I)„RETURN„„DIRDISDOWN:„I = I - 10„FOR J = 7 TO 16„I = I + 1„COLOR 7, 0„LOCATE J, 38: PRINT DirNames$(I)„NEXT J„COLOR 15, 4„RETURN„„DIRDISUP:„I = I - 1„FOR J = 7 TO 16„I = I + 1„COLOR 7, 0„LOCATE J, 38: PRINT DirNames$(I)„NEXT J„I = I - 9„COLOR 15, 4„RETURN„„DIRENTER:„CLOSE„KILL "DRIVE.LST"„KILL "DIR.LST"„IF LEFT$(DirNames$(I), 2) = ". " THEN DirNames$(I) = MID$(CurrentDrive$, 15, 3)„DosCmd$ = "CD " + DirNames$(I)„SHELL DosCmd$„DIRENTER2:„SHELL "DIR /AD /O> DRIVE.LST"„DosCmd$ = "DIR *." + TextFile$ + " /B /ON > DIR.LST"„SHELL DosCmd$„OPEN "Drive.LST" FOR INPUT AS #1„DO„  LINE INPUT #1, CurrentDrive$„LOOP UNTIL INSTR(1, CurrentDrive$, ":\")„CLOSE 1„„Y = LEN(CurrentDrive$)„CurDir$ = MID$(CurrentDrive$, 15, Y)„LOCATE 3, 6: COLOR 15, 0: PRINT STRING$(71, 0)„IF RIGHT$(CurDir$, 1) = "\" THEN„LOCATE 3, 6: COLOR 10, 0: PRINT CurDir$ + "*." + TextFile$„ELSE„LOCATE 3, 6: COLOR 10, 0: PRINT CurDir$ + "\*." + TextFile$„END IF„„FOR J = 7 TO 16„COLOR 15, 0„LOCATE J, 37: PRINT STRING$(11, 0)„NEXT J„„FOR J = 7 TO 16„COLOR 15, 0„LOCATE J, 12: PRINT STRING$(17, 0)„NEXT J„„GOTO TEXTPICK„„'==================================„'        Drive Switching„'==================================„„DRIVE:„CLOSE 1„  REDIM DirNames$(75)„  I = 0„OPEN "DRIVE.LST" FOR INPUT AS #1„„  DO„     INPUT #1, X$„     IF INSTR(1, X$, "<DIR>") THEN„        I = I + 1„        DirNames$(I) = LEFT$(X$, 8)„     END IF„  LOOP WHILE NOT (EOF(1))„GR = I„I = 1„J = 7„DO„     LOCATE J, 38: COLOR 7, 0: PRINT DirNames$(I)„     IF I = GR THEN EXIT DO„     I = I + 1„     J = J + 1„LOOP UNTIL J = 17„„CLOSE„I = 7„LOCATE I, 56: COLOR 15, 5: PRINT " [-A-] "„„DRIVESEL:„V$ = INKEY$„IF V$ = CHR$(0) + "K" THEN COLOR 7, 0: GOSUB DRIVEMAIN: GOTO DIRECTORY„IF V$ = CHR$(27) THEN File$ = "": CLOSE : KILL "DRIVE.LST": KILL "DIR.LST": GOTO START„IF V$ = CHR$(0) + "P" THEN GOSUB DRIVEDOWN„IF V$ = CHR$(0) + "H" THEN GOSUB DRIVEUP„IF V$ = CHR$(13) THEN GOTO DRIVEENTER„GOTO DRIVESEL„„DRIVEDOWN:„COLOR 7, 0„GOSUB DRIVEMAIN„I = I + 1„COLOR 15, 5„GOSUB DRIVEMAIN„RETURN„„DRIVEUP:„COLOR 7, 0„GOSUB DRIVEMAIN„I = I - 1„COLOR 15, 5„GOSUB DRIVEMAIN„RETURN„„DRIVEMAIN:„IF I = 15 THEN I = 7„IF I = 6 THEN I = 14„IF I = 7 THEN LOCATE I, 56: PRINT " [-A-] "„IF I = 8 THEN LOCATE I, 56: PRINT " [-B-] "„IF I = 9 THEN LOCATE I, 56: PRINT " [-C-] "„IF I = 10 THEN LOCATE I, 56: PRINT " [-D-] "„IF I = 11 THEN LOCATE I, 56: PRINT " [-E-] "„IF I = 12 THEN LOCATE I, 56: PRINT " [-F-] "„IF I = 13 THEN LOCATE I, 56: PRINT " [-G-] "„IF I = 14 THEN LOCATE I, 56: PRINT " [-H-] "„RETURN„„DRIVEENTER:„COLOR 7, 0: GOSUB DRIVEMAIN„KILL "DRIVE.LST"„KILL "DIR.LST"„IF I = 7 THEN SHELL "A:"„IF I = 8 THEN SHELL "B:"„IF I = 9 THEN SHELL "C:"„IF I = 10 THEN SHELL "D:"„IF I = 11 THEN SHELL "E:"„IF I = 12 THEN SHELL "F:"„IF I = 13 THEN SHELL "G:"„IF I = 14 THEN SHELL "H:"„GOTO DIRENTER2„„'==================================================„'           Restore Current Drive/Path„'==================================================„„QUIT:„COLOR 7, 0„SHELL CurDrive$„DosCmd$ = "CD " + DefaultDir$„SHELL DosCmd$„END„„„DOSSHELL:„PCOPY 1, 0: COLOR 7, 0: CLS : SHELL "ECHO Type 'EXIT' to Return to The Ultimate Text Viewer": SHELL: PCOPY 1, 0: LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "; : COLOR 15: PRINT "C"; : COLOR 0: PRINT "APTURE     "; : COLOR 15: _„                                                                            PRINT "H"; : COLOR 0: PRINT "ELP!     ": GOTO FKEY„„PRINTER:„OPEN "LPT1:BIN" FOR OUTPUT AS #2„PP = SeekEl„CLOSE #1„OPEN File$ FOR INPUT AS #1„     FOR Y = 10 TO 12„     LOCATE Y, 30: COLOR 0, 0: PRINT STRING$(31, 0)„     NEXT Y„     LOCATE 9, 28: COLOR 14, 4: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„     LOCATE 10, 28:  PRINT CHR$(179); : COLOR 15: PRINT "    Press <ESC> to Abort!    "; : COLOR 14: PRINT CHR$(179)„     LOCATE 11, 28: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„DO UNTIL EOF(1)„V$ = INKEY$„IF V$ = CHR$(27) THEN EXIT DO„LINE INPUT #1, Text$„LPRINT Text$„LOOP„CLOSE„OPEN File$ FOR INPUT AS #1„DO„LINE INPUT #1, Text$„LOOP UNTIL PP = SeekEl„PNEXT:„IF FPC = TRUE THEN RETURN ELSE GOTO FKEY„„CAPTURE:„PCOPY 0, 1„LOCATE 1, 12: COLOR 15, 4: PRINT " C"; : COLOR 10: PRINT "APTURE "„FOR R = 3 TO 8„LOCATE R, 13: COLOR 0, 0: PRINT STRING$(15, 0)„NEXT R„LOCATE 2, 11: COLOR 0, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 3, 11: PRINT CHR$(179); : COLOR 7, 0: PRINT " T"; : COLOR 7, 0: PRINT "urn  "; : COLOR 15, 0: PRINT "O"; : COLOR 7, 0: PRINT "n... "; : COLOR 0, 3: PRINT CHR$(179)„LOCATE 4, 11: PRINT CHR$(179); : COLOR 0: PRINT " Turn  O"; : COLOR 15, 3: PRINT "f"; : COLOR 0: PRINT "f   "; CHR$(179)„LOCATE 5, 11: PRINT CHR$(195); STRING$(13, 196); CHR$(180)„LOCATE 6, 11: PRINT CHR$(179); : COLOR 15, 3: PRINT " S"; : COLOR 0: PRINT "ave As...  "; CHR$(179)„LOCATE 7, 11: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„ROW = 3„CAPTUREKEY:„V$ = INKEY$„IF V$ = CHR$(27) THEN PCOPY 1, 0: RETURN„IF V$ = CHR$(13) THEN GOTO CAPENTER„IF UCASE$(V$) = "O" THEN GOTO CAPON„IF UCASE$(V$) = "F" THEN GOTO CAPOFF„IF UCASE$(V$) = "S" THEN GOTO SAVECAP„IF V$ = CHR$(0) + "P" THEN ROW = ROW + 1: GOSUB CAPDOWN„IF V$ = CHR$(0) + "H" THEN ROW = ROW - 1: GOSUB CAPUP„IF V$ = CHR$(0) + "K" THEN PCOPY 1, 0: GOTO FKEY„IF V$ = CHR$(0) + "M" THEN PCOPY 1, 0: GOTO HELP„IF V$ = CHR$(0) + ";" THEN CALL HELP2     'F1„IF V$ = CHR$(0) + "<" THEN TextFile$ = "TXT": GOTO LISTFILES'F2„IF V$ = CHR$(0) + "=" THEN TextFile$ = "*": GOTO LISTFILES'F3„IF V$ = CHR$(0) + ">" THEN GOTO PRINTER   'F4„IF V$ = CHR$(0) + "?" THEN GOTO CAPON     'F5„IF V$ = CHR$(0) + "@" THEN GOTO CAPOFF    'F6„IF V$ = CHR$(0) + "A" THEN GOTO SAVECAP   'F7„IF V$ = CHR$(0) + "B" THEN GOTO DOSSHELL  'F8„GOTO CAPTUREKEY„„CAPDOWN:„IF ROW = 6 THEN ROW = 3„IF ROW = 3 THEN LOCATE 3, 12: COLOR 7, 0: PRINT " Turn  "; : COLOR 15, 0: PRINT "O"; : COLOR 7, 0: PRINT "n... ": LOCATE 6, 12: COLOR 15, 3: PRINT " S"; : COLOR 0, 3: PRINT "ave As...  "„IF ROW = 4 THEN LOCATE 4, 12: COLOR 7, 0: PRINT " Turn  O"; : COLOR 15, 0: PRINT "f"; : COLOR 7, 0: PRINT "f   ": LOCATE 3, 12: COLOR 0, 3: PRINT " Turn  "; : COLOR 15, 3: PRINT "O"; : COLOR 0: PRINT "n... "„IF ROW = 5 THEN LOCATE 6, 12: COLOR 15, 0: PRINT " S"; : COLOR 7, 0: PRINT "ave As...  ": LOCATE 4, 12: COLOR 0, 3: PRINT " Turn  O"; : COLOR 15, 3: PRINT "f"; : COLOR 0, 3: PRINT "f   "„RETURN„CAPUP:„IF ROW = 2 THEN ROW = 5„IF ROW = 3 THEN LOCATE 3, 12: COLOR 7, 0: PRINT " Turn  "; : COLOR 15, 0: PRINT "O"; : COLOR 7, 0: PRINT "n... ": LOCATE 4, 12: COLOR 0, 3: PRINT " Turn  O"; : COLOR 15, 3: PRINT "f"; : COLOR 0, 3: PRINT "f   "„IF ROW = 4 THEN LOCATE 4, 12: COLOR 7, 0: PRINT " Turn  O"; : COLOR 15, 0: PRINT "f"; : COLOR 7, 0: PRINT "f   ": LOCATE 6, 12: COLOR 15, 3: PRINT " S"; : COLOR 0, 3: PRINT "ave As...  "„IF ROW = 5 THEN LOCATE 6, 12: COLOR 15, 0: PRINT " S"; : COLOR 7, 0: PRINT "ave As...  ": LOCATE 3, 12: COLOR 0, 3: PRINT " Turn  "; : COLOR 15, 3: PRINT "O"; : COLOR 0, 3: PRINT "n... "„RETURN„„CAPENTER:„IF ROW = 3 THEN GOTO CAPON„IF ROW = 4 THEN GOTO CAPOFF„IF ROW = 5 THEN GOTO SAVECAP„„CAPON:„PS = SeekEl„PCOPY 1, 0„LOCATE 1, 36: COLOR 10, 3: PRINT "Capture:"; : COLOR 1: PRINT PS; : COLOR 0, 3: PRINT CHR$(26); SeekEl„CAP = TRUE„RETURN„„CAPOFF:„PCOPY 1, 0„LOCATE 1, 36: COLOR 3, 3: PRINT "                        "„CAP = FALSE„RETURN„„SAVECAP:„IF CAP = FALSE THEN PCOPY 1, 0: RETURN„IF PS > SeekEl THEN PCOPY 1, 0: RETURN„CLOSE #1„OPEN File$ FOR INPUT AS #1„PS2 = PS„DO„IF PS = 1 THEN EXIT DO„LINE INPUT #1, SAVEDTEXT$„PS = PS - 1„LOOP UNTIL PS = 1„FOR V = 11 TO 13„LOCATE V, 4: COLOR 0, 0: PRINT STRING$(76, 0)„NEXT V„COLOR 10, 2„LOCATE 10, 2: PRINT "⁄"; STRING$(74, 196); "ø"„LOCATE 11, 2: PRINT CHR$(179); STRING$(74, 0); CHR$(179)„LOCATE 12, 2: PRINT "¿"; STRING$(74, 196); "Ÿ"„LOCATE 11, 4: COLOR 14, 2: PRINT "Save As: "; : COLOR 15, 2: LINE INPUT ""; FILNAM$„IF FILNAM$ = "" THEN PCOPY 1, 0: PS = PS2: RETURN„OPEN FILNAM$ FOR APPEND AS #2„PS2 = PS2 - 1„     FOR Y = 10 TO 12„     LOCATE Y, 30: COLOR 7, 8: PRINT STRING$(31, 176)„     NEXT Y„     LOCATE 9, 28: COLOR 14, 4: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„     LOCATE 10, 28:  PRINT CHR$(179); : COLOR 15: PRINT "     Press <ESC> to STOP!    "; : COLOR 14: PRINT CHR$(179)„     LOCATE 11, 28: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„DO„IF EOF(1) THEN EXIT DO„V$ = INKEY$„IF V$ = CHR$(27) THEN EXIT DO„LINE INPUT #1, SAVEDTEXT$„PRINT #2, SAVEDTEXT$„PS2 = PS2 + 1„LOOP UNTIL PS2 = SeekEl„PS = PS2„CLOSE #2„PCOPY 1, 0„RETURN„„HELP:„PCOPY 0, 1„LOCATE 1, 24: COLOR 15, 4: PRINT " H"; : COLOR 10: PRINT "ELP! "„FOR V = 3 TO 8„LOCATE V, 25: COLOR 0, 0: PRINT STRING$(18, 0)„NEXT V„LOCATE 2, 23: COLOR 0, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 3, 23: PRINT CHR$(179); : COLOR 15, 0: PRINT " G"; : COLOR 7, 0: PRINT "eneral Help   "; : COLOR 0, 3: PRINT CHR$(179)„LOCATE 4, 23: PRINT CHR$(179); : COLOR 15, 3: PRINT " C"; : COLOR 0: PRINT "ommand Keys   "; CHR$(179)„LOCATE 5, 23: PRINT CHR$(195); STRING$(16, 196); CHR$(180)„LOCATE 6, 23: PRINT CHR$(179); : COLOR 0, 3: PRINT " Capturing "; : COLOR 15, 3: PRINT "T"; : COLOR 0, 3: PRINT "ext "; CHR$(179)„LOCATE 7, 23: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„ROW = 3„HELPKEY:„V$ = INKEY$„IF V$ = CHR$(27) THEN PCOPY 1, 0: RETURN„IF V$ = CHR$(0) + "P" THEN ROW = ROW + 1: GOSUB HELPDOWN„IF V$ = CHR$(0) + "H" THEN ROW = ROW - 1: GOSUB HELPUP„IF V$ = CHR$(0) + "M" THEN PCOPY 1, 0: GOTO FKEY„IF V$ = CHR$(0) + "K" THEN PCOPY 1, 0: GOTO CAPTURE„IF UCASE$(V$) = "G" THEN CALL HELP1„IF UCASE$(V$) = "C" THEN CALL HELP2„IF UCASE$(V$) = "T" THEN CALL HELP3„IF V$ = CHR$(13) THEN GOSUB HELPENTER„IF V$ = CHR$(0) + ";" THEN CALL HELP2     'F1„IF V$ = CHR$(0) + "<" THEN TextFile$ = "TXT": GOTO LISTFILES'F2„IF V$ = CHR$(0) + "=" THEN TextFile$ = "*": GOTO LISTFILES'F3„IF V$ = CHR$(0) + ">" THEN GOTO PRINTER   'F4„IF V$ = CHR$(0) + "?" THEN GOTO CAPON     'F5„IF V$ = CHR$(0) + "@" THEN GOTO CAPOFF    'F6„IF V$ = CHR$(0) + "A" THEN GOTO SAVECAP   'F7„IF V$ = CHR$(0) + "B" THEN GOTO DOSSHELL  'F8„GOTO HELPKEY„„HELPDOWN:„IF ROW = 6 THEN ROW = 3„IF ROW = 3 THEN LOCATE 3, 24: COLOR 15, 0: PRINT " G"; : COLOR 7, 0: PRINT "eneral Help   ": LOCATE 6, 24: COLOR 0, 3: PRINT " Capturing "; : COLOR 15, 3: PRINT "T"; : COLOR 0, 3: PRINT "ext "„IF ROW = 4 THEN LOCATE 4, 24: COLOR 15, 0: PRINT " C"; : COLOR 7, 0: PRINT "ommand Keys   ": LOCATE 3, 24: COLOR 15, 3: PRINT " G"; : COLOR 0, 3: PRINT "eneral Help   "„IF ROW = 5 THEN LOCATE 6, 24: COLOR 7, 0: PRINT " Capturing "; : COLOR 15, 0: PRINT "T"; : COLOR 7, 0: PRINT "ext ": LOCATE 4, 24: COLOR 15, 3: PRINT " C"; : COLOR 0, 3: PRINT "ommand Keys   "„RETURN„HELPUP:„IF ROW = 2 THEN ROW = 5„IF ROW = 3 THEN LOCATE 3, 24: COLOR 15, 0: PRINT " G"; : COLOR 7, 0: PRINT "eneral Help   ": LOCATE 4, 24: COLOR 15, 3: PRINT " C"; : COLOR 0, 3: PRINT "ommand Keys   "„IF ROW = 4 THEN LOCATE 4, 24: COLOR 15, 0: PRINT " C"; : COLOR 7, 0: PRINT "ommand Keys   ": LOCATE 6, 24: COLOR 0, 3: PRINT " Capturing "; : COLOR 15, 3: PRINT "T"; : COLOR 0, 3: PRINT "ext "„IF ROW = 5 THEN LOCATE 6, 24: COLOR 7, 0: PRINT " Capturing "; : COLOR 15, 0: PRINT "T"; : COLOR 7, 0: PRINT "ext ": LOCATE 3, 24: COLOR 15, 3: PRINT " G"; : COLOR 0, 3: PRINT "eneral Help   "„RETURN„„HELPENTER:„IF ROW = 3 THEN CALL HELP1„IF ROW = 4 THEN CALL HELP2„IF ROW = 5 THEN CALL HELP3„RETURN„„ERRORHANDLE:„     IF ERR = 53 OR ERR = 52 THEN„COLOR 0, 1„FOR O = 1 TO 25„LOCATE O, 1: PRINT STRING$(80, 0)„NEXT O„COLOR 15, 4: LOCATE 25, 1: PRINT "  The Ultimate Text Viewer Version 0.02  FREEWARE"; : COLOR 7, 4: PRINT "  <"; : COLOR 11: PRINT "1"; : COLOR 10: PRINT "2"; : COLOR 3: PRINT "3"; : COLOR 12: PRINT "4"; : COLOR 13: PRINT "5"; : COLOR 14: PRINT "6"; _„ : COLOR 7: PRINT "7"; : COLOR 15: PRINT "8"; : COLOR 9: PRINT "9"; : COLOR 7: PRINT ">"; : COLOR 10: PRINT "  Color Change    "„COLOR 0, 1: LOCATE 24, 1: PRINT STRING$(80, 0)„LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "; : COLOR 15: PRINT "C"; : COLOR 0: PRINT "APTURE     "; : COLOR 15: PRINT "H"; : COLOR 0: PRINT "ELP!                                                   "„LOCATE 4, 1: COLOR 7, 1„PRINT "      ±€€  ±€€ ±€€      ±€€€€€€€€ ±€€ ±€€€€€€€ ±€€€€€€€ ±€€€€€€€€ ±€€€€€€€"„PRINT "      ±€€  ±€€ ±€€         ±€€    ±€€ ±€€±€±€€ ±€€  ±€€    ±€€    ±€€"„PRINT "      ±€€  ±€€ ±€€         ±€€    ±€€ ±€€  ±€€ ±€€€€€€€    ±€€    ±€€€€€€"„PRINT "      ±€€  ±€€ ±€€         ±€€    ±€€ ±€€  ±€€ ±€€  ±€€    ±€€    ±€€"„PRINT "      ±€€€€€€€ ±€€€€€€€    ±€€    ±€€ ±€€  ±€€ ±€€  ±€€    ±€€    ±€€€€€€€"„PRINT "                                           "„PRINT "                     ±€€€€€€€€ ±€€€€€€€ ±€€  ±€€ ±€€€€€€€€"„PRINT "                        ±€€    ±€€      ±€€  ±€€    ±€€"„PRINT "                        ±€€    ±€€€€€€    ±€€€      ±€€"„PRINT "                        ±€€    ±€€      ±€€  ±€€    ±€€"„PRINT "                        ±€€    ±€€€€€€€ ±€€  ±€€    ±€€"„PRINT„PRINT "                ±€€  ±€€ ±€€ ±€€€€€€€ ±€€  ±€€ ±€€€€€€€ ±€€€€€€€"„PRINT "                ±€€  ±€€ ±€€ ±€€      ±€€  ±€€ ±€€      ±€€  ±€€"„PRINT "                ±€€  ±€€ ±€€ ±€€€€€€  ±€€  ±€€ ±€€€€€€  ±€€€€€€€"„PRINT "                ±€€  ±€€ ±€€ ±€€      ±€€±€±€€ ±€€      ±€€ ±€€"„PRINT "                 ±€€€€€  ±€€ ±€€€€€€€ ±€€€€€€€ ±€€€€€€€ ±€€ ±€€€"„PRINT„PRINT "              Programmed by William Yu  (c) 1994   UTV Version 0.02"„RESUME FKEY„END IF„     IF ERR = 25 THEN„     LOCATE 10, 20„     FOR Y = 10 TO 13„     LOCATE Y, 30: COLOR 0, 0: PRINT STRING$(31, 0)„     NEXT Y„     LOCATE 9, 28: COLOR 14, 4: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„     LOCATE 10, 28:  PRINT CHR$(179); : COLOR 15: PRINT "  No Printer Port Detected!  "; : COLOR 14: PRINT CHR$(179)„     LOCATE 11, 28: PRINT CHR$(179); : COLOR 15: PRINT " PLEASE TURN YOUR PRINTER ON "; : COLOR 14: PRINT CHR$(179)„     LOCATE 12, 28: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„     WHILE INKEY$ = "": WEND: PCOPY 1, 0„     LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "„     RESUME PNEXT„     END IF„PCOPY 1, 0„RESUME FKEY„„REM $STATIC„SUB HELP1„PCOPY 0, 2„LOCATE 3, 3: COLOR 10, 2: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„FOR O = 4 TO 21„LOCATE O, 3: COLOR 10, 2: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„NEXT O„LOCATE 22, 3: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„COLOR 7, 8: LOCATE 23, 5: PRINT STRING$(74, 176)„FOR O = 4 TO 22„LOCATE O, 77: PRINT STRING$(2, 176)„NEXT O„LOCATE 3, 34: COLOR 15, 2: PRINT "GENERAL HELP"„LOCATE 4, 5: COLOR 0, 2: PRINT "Starting up The Ultimate Text Viewer with command line:"„LOCATE 5, 8: COLOR 15, 2: PRINT "UTV <[Drive:Path]FileName.Ext>  Example:  "; : COLOR 14: PRINT "UTV UTV.TXT"„LOCATE 6, 5: COLOR 0: PRINT "Starting up The Ultimate Text Viewer Without the Command Line:"„LOCATE 7, 8: COLOR 15: PRINT "If you happen to run the program without a command line you will be"„LOCATE 8, 8: PRINT "able to select a file using the FILE command and selecting"„LOCATE 9, 10: COLOR 14: PRINT "Open a Text File  "; : COLOR 10: PRINT "(*.TXT will be displayed)"„LOCATE 10, 10: COLOR 14: PRINT "List all Files    "; : COLOR 10: PRINT "(*.* in current directory will be displayed)"„LOCATE 11, 5: COLOR 0: PRINT "Error Control:"„LOCATE 12, 8: COLOR 15: PRINT "When selecting a file, there are many  different drives from which"„LOCATE 13, 8: PRINT "you can choose from, please don't select a drive you know does not"„LOCATE 14, 8: PRINT "function or don't have."„LOCATE 21, 28: COLOR 11: PRINT "Press any key to continue..."„WHILE INKEY$ = "": WEND„PCOPY 2, 0„END SUB„„SUB HELP2„PCOPY 0, 2„LOCATE 3, 3: COLOR 10, 2: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„FOR O = 4 TO 21„LOCATE O, 3: COLOR 10, 2: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„NEXT O„LOCATE 22, 3: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„COLOR 7, 8: LOCATE 23, 5: PRINT STRING$(74, 176)„FOR O = 4 TO 22„LOCATE O, 77: PRINT STRING$(2, 176)„NEXT O„LOCATE 3, 27: COLOR 15, 2: PRINT "COMMAND KEYS/SHORT CUT KEYS"„LOCATE 4, 5: COLOR 0: PRINT "Scrolling Text & Menu Commands:"„LOCATE 5, 8: COLOR 15: PRINT CHR$(24); CHR$(25); : COLOR 14: PRINT " Up/Down "; : COLOR 15: PRINT CHR$(27); CHR$(26); : COLOR 14: PRINT " Left/Right "; : COLOR 15: PRINT " PGDN/PGDN "; : COLOR 14: PRINT "Up a Page/Down a Page"; : COLOR 15: PRINT  _„" ESC"; : COLOR 14: PRINT " Exits"„LOCATE 6, 8: COLOR 15: PRINT "F"; : COLOR 14: PRINT " - FILE COMMAND"; : COLOR 11: PRINT " Open New Text File for Viewing/Printing/DOS Shell"„LOCATE 7, 8: COLOR 15: PRINT "C"; : COLOR 14: PRINT " - CAPTURE TEXT"; : COLOR 11: PRINT " Capture Certain Lines of text and saving it as..."„LOCATE 8, 8: COLOR 15: PRINT "H"; : COLOR 14: PRINT " - HELP ON UTV "; : COLOR 11: PRINT " This screen right here"„LOCATE 9, 8: COLOR 15: PRINT "1 to 9 produces a color change to the current TEXT"„LOCATE 10, 8: COLOR 11: PRINT "1 = Light Cyan  2 = Green  3 = Cyan  4 = Red  5 = Magenta 6 = Yellow"„LOCATE 11, 8: PRINT "7 = Grey (Default Color)  8 = White  9 = Blue"„LOCATE 12, 5: COLOR 0: PRINT "Short Cut Keys:"„LOCATE 13, 8: COLOR 15: PRINT "F1 "; : COLOR 14: PRINT "= Displays all the Command Keys (This Help Screen)"„LOCATE 14, 8: COLOR 15: PRINT "F2 "; : COLOR 14: PRINT "= Open a Text File"„LOCATE 15, 8: COLOR 15: PRINT "F3 "; : COLOR 14: PRINT "= List All Files"„LOCATE 16, 8: COLOR 15: PRINT "F4 "; : COLOR 14: PRINT "= Print Entire Text"„LOCATE 17, 8: COLOR 15: PRINT "F5 "; : COLOR 14: PRINT "= Turn Capture ON"„LOCATE 18, 8: COLOR 15: PRINT "F6 "; : COLOR 14: PRINT "= Turn Capture OFF"„LOCATE 19, 8: COLOR 15: PRINT "F7 "; : COLOR 14: PRINT "= Save Captured Text As..."„LOCATE 20, 8: COLOR 15: PRINT "F8 "; : COLOR 14: PRINT "= DOS Shell"„LOCATE 21, 27: COLOR 4, 2: PRINT "Press any key to continue..."„WHILE INKEY$ = "": WEND„PCOPY 2, 0„END SUB„„SUB HELP3„PCOPY 0, 2„LOCATE 3, 3: COLOR 10, 2: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„FOR O = 4 TO 21„LOCATE O, 3: COLOR 10, 2: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„NEXT O„LOCATE 22, 3: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„COLOR 7, 8: LOCATE 23, 5: PRINT STRING$(74, 176)„FOR O = 4 TO 22„LOCATE O, 77: PRINT STRING$(2, 176)„NEXT O„LOCATE 3, 32: COLOR 15, 2: PRINT "CAPTURING TEXT"„LOCATE 4, 5: COLOR 0: PRINT "Commands for Capturing Text:"„LOCATE 5, 8: COLOR 15: PRINT "Capturing Text is quite simple, F5 to turn capture ON or you could"„LOCATE 6, 8: PRINT "type 'C' and select Turn On"„LOCATE 7, 8: PRINT "After you have turned Capture ON, a red line should appear below the"„LOCATE 8, 8: PRINT "menu commands.  That is the first line that will be captured."„LOCATE 9, 8: PRINT "You will see a"; : COLOR 14: PRINT " Capturing 10 "; CHR$(26); " 10"; : COLOR 15: PRINT " on the top line.  (Example only)"„LOCATE 10, 8: COLOR 11: PRINT "First line to be captured"; : COLOR 12: PRINT CHR$(24); CHR$(24); "   "; CHR$(24); CHR$(24); : COLOR 11: PRINT "this is the last line to be captured"„LOCATE 11, 8: COLOR 15: PRINT "Scroll down to capture the desired amount of lines."„LOCATE 12, 8: COLOR 14: PRINT "*** Each time a line is scrolled past the red line, it is captured."„LOCATE 13, 8: COLOR 15: PRINT "You may turn Capture off anytime by pressing F6 or selecting it from"„LOCATE 14, 8: PRINT "the CAPTURE Commands.  You should SAVE your Captured Text before you"„LOCATE 15, 8: PRINT "do that by pressing F7 or selecting SAVE AS from the CAPTURE Command"„LOCATE 16, 5: COLOR 0: PRINT "Error Control:"„LOCATE 17, 8: COLOR 15: PRINT "Capture 100 "; CHR$(26); " 20 will NOT save, the first number has to be lower."„LOCATE 18, 8: PRINT "When you save the captured text as a filename that already exists,"„LOCATE 19, 8: PRINT "it will APPEND (Add the captured text) 'til end of file."„LOCATE 21, 27: COLOR 11: PRINT "Press any key to continue..."„WHILE INKEY$ = "": WEND„PCOPY 2, 0„END SUB„Jason Lashua                   COLOUR CODED WRITER            irox@gte.net                   08-09-97 (01:38)       QB, QBasic, PDS        37   996      CWRITE.BAS  DECLARE SUB cwrite (text$)„' Cwrite v1.o by jason lashua„'   nice color code.„' just type cwrite "`15blah`07 heh" or something„' the colors are:„' dark          bright       name„'  00              08          black„'  01              09          blue„'  02              10         green„'  03              11         cyan„'  04              12         red„'  05              13         magenta„'  06              14         yellow„'  07              15         white„'„'  All color codes are preceeded by an `„'„CLS„LOCATE 10, 27„cwrite "`15w`13el`05come `15t`13o `15c`13wr`05ite`03!"„LOCATE 11, 19„cwrite "`07D`15oesn`09'`15t text look beter `15l`07i`08ke `15t`07h`08is`09?"„LOCATE 12, 25„cwrite "`11a`03n`08d `11i`03t`08's `11s`03o `11e`03a`08sy `11t`03o`08o!"„„SUB cwrite (text$)„FOR i = 1 TO LEN(text$)„a$ = MID$(text$, i, 1)„IF a$ <> "`" THEN PRINT a$;„IF a$ = "`" THEN„b$ = MID$(text$, i + 1, 2)„col = VAL(b$)„COLOR col„i = i + 2„END IF„NEXT i„END SUB„Jason Lashua                   EASY MCI CODES                 irox@gte.net                   08-09-97 (01:38)       QB, QBasic, PDS        59   1742     MCI.BAS     ' easy MCi codes.. v1.o„'„'   well, i never understood how to make mci codes..„'  and then just realized its sooo easy, and you can learn too„'  if you plan to write a bbs or a door or something :P„'„'  just type mci "text .. %mci code.."„'„'  mci codes are preceeded with the percent sign„'  and only have 2 letters. the current codes are..„'„'  ti   display time„'  dt   display date„'  pa   wait for keypress„'  cr   go to start of next line„'  te   print the text all over again from the mci procedure„'  cl   clear screen„'„DECLARE SUB mci (text$)„CLS„'„' the codes %ti and %dt print the time and the date..„'„mci "the time is %ti and the date is %dt"„'„'you can even make up your own codes..„'and what they do, just edit the sub "mci"...„'„LOCATE 10, 1„mci "and this is what i typed.. again.. %cr %te"„mci "%cr%crnow lets go to a new demo. %cr%cr%pa'"„' the %cr code goes down to the next line..„'„' heres a %pa code.. which waits for enter to be pressed..„'„mci "%clheres a recap of all the mci codes..%cr%cr%ti%crtime%cr%dt%crdate%cr%cr%te%cr%crretype the whole input line again..%cr%crand finally, the pause%cr%pa"„„SUB mci (text$)„FOR i = 1 TO LEN(text$)„a$ = MID$(text$, i, 1)„IF a$ <> "%" THEN PRINT a$;„IF a$ = "%" THEN„b$ = MID$(text$, i + 1, 2)„'just some samples of what you can make an mci code do„'„'you can add new mci codes too.. like„'if b$="te" then print text$;„'and that'll re print the parms passed to this procedure..„'„IF b$ = "ti" THEN PRINT TIME$;„IF b$ = "dt" THEN PRINT DATE$;„IF b$ = "te" THEN PRINT text$;„IF b$ = "cr" THEN PRINT ""„IF b$ = "pa" THEN INPUT "Press enter to continue", asoeooeeeee„IF b$ = "cl" THEN CLS„i = i + 2„END IF„NEXT i„END SUB„Nick Kochakian                 PRINT2 (ANOTHER WAY TO PRINT)  NickK@worldnet.att.net         09-05-97 (19:00)       QB, QBasic, PDS        180  3120     PRINT2.BAS  DECLARE SUB print2 (x!, y!, txt$, way!, col!)„'Print2 --- Just another way to print text„'„'9/5/97 By: - Nick Kochakian -„'„'If you use the sub print2 in your program please give me some credit!„'„'If you have any questions or comments please contact me at either e-mail„'address.„'„'web address: http://www.geocities.com/siliconvalley/heights/5914/„'e-mail 1:    nickk@worldnet.att.net„'e-mail 2:    dnukem3@geocities.com„„CLS„„CALL print2(1, 1, "print2 rocks!!!", 1, 7)„CALL print2(0, 0, "Print2 by: - Nick Kochakian -", 2, 7)„CALL print2(0, 0, "GreY ScalE...................", 3, 7)„CALL print2(0, 0, "You can even have text printed backwards!!!", 4, 7)„CALL print2(0, 0, "--- Hello! --- ... --- .,'`',.o.-< --- Like my snake?", 5, 7)„CALL print2(0, 0, "hihihihihihihihihihihi --- hihihihi --- hihihihi", 6, 7)„CALL print2(0, 0, "print2 - way = 7", 7, 7)„„'print2(x,y,txt$,way,col)„'x - x location if x is equal to 0 then print on the current line„'y - y location if y is equal to 0 then print on the current line„'txt$ - your text„'way - the way to print it (way chart below)„'col - the color of the text„„'way = 1 - Upper / Lower case mixed text„'way = 2 - Multi color text„'way = 3 - Grey scale text„'way = 4 - Print text reversed„'way = 5 - ASCII -> Txt$„'way = 6 - Txt$ mix„'way = 7 - All uppercase„„SUB print2 (x, y, txt$, way, col)„RANDOMIZE TIMER„„IF x = 0 OR y = 0 THEN GOTO part2:„LOCATE x, y„„part2:„IF col = -1 THEN GOTO part3:„COLOR col„„part3:„IF way = 1 THEN„txtlen = LEN(txt$)„flag = 0„FOR i = 1 TO txtlen„m$ = MID$(txt$, i, 1)„IF flag = 0 THEN m$ = UCASE$(m$)„IF flag = 2 THEN flag = 1„„PRINT m$;„„„IF flag = 0 THEN flag = 2„IF flag = 1 THEN flag = 0„NEXT i„PRINT ""„END IF„„IF way = 2 THEN„„txtlen = LEN(txt$)„„col = 0„flag = 0„„FOR i = 1 TO txtlen„m$ = MID$(txt$, i, 1)„„IF flag = 0 THEN col = col + 1„IF flag = 2 THEN col = col - 1„„COLOR col„PRINT m$;„„IF col = 15 THEN flag = 2„IF col = 1 THEN flag = 1„„IF flag = 1 THEN flag = 0„NEXT i„„PRINT ""„COLOR 7„„END IF„„IF way = 3 THEN„„txtlen = LEN(txt$)„„col = 7„colf = 0„flag = 0„„FOR i = 1 TO txtlen„m$ = MID$(txt$, i, 1)„„IF flag = 0 THEN colf = colf + 1„IF flag = 2 THEN colf = colf - 1„„IF colf = 1 THEN col = 8„IF colf = 2 THEN col = 7„IF colf = 3 THEN col = 15„„COLOR col„PRINT m$;„„IF colf = 3 THEN flag = 2„IF colf = 1 THEN flag = 1„„IF flag = 1 THEN flag = 0„NEXT i„„PRINT ""„COLOR 7„„END IF„„IF way = 4 THEN„„txtlen = LEN(txt$)„„a = txtlen„„FOR i = 1 TO txtlen„PRINT MID$(txt$, a, 1);„a = a - 1„NEXT i„„PRINT ""„END IF„„IF way = 5 THEN„„txtlen = LEN(txt$)„„FOR i = 1 TO txtlen„x = INT(RND * 254) + 1„IF x < 33 THEN x = 128„„PRINT CHR$(x);„FOR d = 1 TO 999„NEXT d„NEXT i„„LOCATE , CSRLIN„FOR i = 1 TO txtlen„PRINT MID$(txt$, i, 1);„„FOR d = 1 TO 999„NEXT d„„NEXT i„„PRINT ""„END IF„„IF way = 6 THEN„„txtlen = LEN(txt$)„„FOR i = 1 TO txtlen„x = INT(RND * txtlen) + 1„„PRINT MID$(txt$, x, 1);„NEXT i„„PRINT ""„END IF„„IF way = 7 THEN PRINT UCASE$(txt$)„END SUB„Nick Kochakian                 LETTER DROP                    NickK@worldnet.att.net         09-05-97 (19:00)       QB, QBasic, PDS        59   1175     LET-DROP.BASDECLARE SUB letdrop (x!, y!, txt$, dly!, bottomy!)„'LetTer DRoP„'„'9/4/97 By: - Nick Kochakian -„'„'Don't forget to check out my web page... I don't have ALL of my code„'for QB and C there yet... But there are alot of cool things to do there...„'„'If you have any questions or comments please contact me at either e-mail„'address.„'„'web address: http://www.geocities.com/siliconvalley/heights/5914/„'e-mail 1:    nickk@worldnet.att.net„'e-mail 2:    dnukem3@geocities.com„„txt$ = "LetTer DRoP --- 1997 --- Nick Kochakian"„„CLS„CALL letdrop(1, 1, txt$, 999, 23)„„'This produces a kinda neat effect if bottomy is equal to 24 or 25...„„'letdrop(x,y,txt$,dly,bottomy)„'„'x - x location of where to start the message„'y - y almost the same thing as x„'txt$ - The string of text„'dly - delay„'bottomy - Where the text should stop„„SUB letdrop (x, y, txt$, dly, bottomy)„„LOCATE x, y„„letmax = LEN(txt$)„„FOR i = 1 TO letmax„„FOR a = x TO bottomy„a2 = a„„IF a = 1 THEN a2 = 1 ELSE a2 = a2 - 1„„LOCATE a2, y„PRINT " "„LOCATE a, y„PRINT MID$(txt$, i, 1)„„FOR e = 1 TO dly„NEXT e„„NEXT a„y = y + 1„„'SLEEP 1„„NEXT i„„END SUB„Kurt Kuzba                     EDITABLE FIELDS                FidoNet QUIK_BAS Echo          09-04-97 (05:17)       QB, QBasic, PDS        182  8230     INVNTORY.BAS'>   an editable field that is more than one line long.„'   Here is something to play with. :)„'_|_|_|   INVNTORY.BAS   PUBLIC DOMAIN   by Kurt Kuzba.  (9/4/1997)„TYPE InventoryControlDat„   PartName AS STRING * 60: PartNumb AS STRING * 20„   PartDesc AS STRING * 160: PartsPrc AS LONG: PartsCst AS LONG„   PartsAvl AS LONG: PartsOrd AS LONG: END TYPE„DECLARE SUB EditInventory (i AS InventoryControlDat)„DECLARE SUB ShowInventory (i AS InventoryControlDat)„DECLARE SUB ShowItem (x%, s$, H%)„DECLARE SUB ShowLine (x%, hilite%, i AS InventoryControlDat)„DECLARE SUB DoEdit (item%, i AS InventoryControlDat)„DECLARE SUB ShowTime ()„DECLARE SUB EditName (PartName$)„DECLARE SUB EditNumb (PartNumb$)„DECLARE SUB EditDesc (PartDesc$)„DECLARE SUB EditAvl (Avl&)„DECLARE SUB EditOrd (Ord&)„DECLARE SUB EditPrc (Prc&)„DECLARE SUB EditCst (Cst&)„DECLARE FUNCTION Currency$ (V&)„DECLARE FUNCTION Caption$ (C%)„DECLARE FUNCTION GetDate$ ()„DECLARE FUNCTION GetString$ (d$, x%, y%, l%, k%)„ON ERROR GOTO BooBoo„DIM Inv AS InventoryControlDat„Inv.PartName = "": Inv.PartNumb = "": Inv.PartDesc = ""„Inv.PartsAvl = 0: Inv.PartsOrd = 0„Inv.PartsPrc = 0: Inv.PartsCst = 0„EditInventory Inv: SYSTEM„BooBoo: FError$ = STR$(ERR): RESUME NEXT„FUNCTION Caption$ (C%)„   SELECT CASE C%„      CASE 0: s$ = " " + CHR$(213) + CHR$(209) + STRING$(62, 205)„         Caption$ = s$ + CHR$(209) + CHR$(184) + " "„      CASE 1: Caption$ = "  <==  Part I.D. Number"„      CASE 2: Caption$ = "==>       "„      CASE 3: Caption$ = "Parts On Hand  :"„      CASE 4: Caption$ = "Parts On Order :"„      CASE 5: Caption$ = "Price Per Part : $"„      CASE 6: Caption$ = "Cost Per Part  : $"„      CASE 7: s$ = " " + CHR$(212) + CHR$(207) + STRING$(62, 205)„         Caption$ = s$ + CHR$(207) + CHR$(190) + " "„      CASE 8: Caption$ = "========  Part Description or Comments"„   END SELECT: END FUNCTION„FUNCTION Currency$ (V&) : d$ = MID$(STR$(V& \ 100), 2) + "."„   C$ = RIGHT$("00" + MID$(STR$(V& MOD 100), 2), 2)„   Currency$ = d$ + C$: END FUNCTION„SUB DoEdit (item%, i AS InventoryControlDat)„   SELECT CASE item%„      CASE 0: EditName i.PartName„      CASE 1: EditNumb i.PartNumb„      CASE 2: EditDesc i.PartDesc„      CASE 3: EditAvl i.PartsAvl„      CASE 4: EditOrd i.PartsOrd„      CASE 5: EditPrc i.PartsPrc„      CASE 6: EditCst i.PartsCst„   END SELECT: COLOR 10, 2: LOCATE 2, 1, 0„   PRINT STRING$(80, 177); : END SUB„SUB EditAvl (Avl&) : LOCATE 2, 7: COLOR 10, 0„   PRINT " Enter number of parts to add. "„   NumberAvl$ = GetString$("     ", 14, 41, 6, 0)„   Avl& = Avl& + VAL(NumberAvl$): END SUB„SUB EditCst (Cst&) : LOCATE 2, 7: COLOR 10, 0„   PRINT " Enter new cost per piece. "„   Cst$ = GetString$("", 17, 41, 10, 0)„   IF VAL(Cst$) > 0 THEN Cst& = VAL(Cst$) * 100„END SUB„SUB EditDesc (PartDesc$) : LOCATE 2, 7: COLOR 10, 0: cLine% = 0„   PRINT " Enter Description or comments. ": DIM Desc$(3)„   Desc$(0) = MID$(PartDesc$, 1, 40)„   Desc$(1) = MID$(PartDesc$, 41, 40)„   Desc$(2) = MID$(PartDesc$, 81, 40)„   Desc$(3) = MID$(PartDesc$, 121, 40)„   DO: x% = cLine% + 10„      Desc$(cLine%) = GetString$(Desc$(cLine%), x%, 21, 40, k%)„      LOCATE x%, 21: COLOR 15, 1„      PRINT LEFT$(Desc$(cLine%) + SPACE$(40), 40);„      IF k% = -72 THEN cLine% = (cLine% + 3) MOD 4„      IF (k% = 13) OR (k% = -80) THEN cLine% = (cLine% + 1) MOD 4„   LOOP WHILE k% <> 27„   MID$(PartDesc$, 1, 40) = Desc$(0)„   MID$(PartDesc$, 41, 40) = Desc$(1)„   MID$(PartDesc$, 81, 40) = Desc$(2)„   MID$(PartDesc$, 121, 40) = Desc$(3): END SUB„SUB EditName (PartName$) : LOCATE 2, 7: COLOR 10, 0„   PRINT " Enter full part name. "„   PartName$ = GetString$(PartName$, 7, 11, 60, 0): END SUB„SUB EditNumb (PartNumb$) : LOCATE 2, 7: COLOR 10, 0„   PRINT " Enter part number. "„   PartNumb$ = GetString$(PartNumb$, 8, 11, 20, 0): END SUB„SUB EditInventory (i AS InventoryControlDat)„   ShowInventory i: item% = 1: k% = -72: Finished% = 0„   DO„      SELECT CASE k%„         CASE -72, ASC("8"), ASC("1"): ShowLine item%, 0, i„            item% = (item% + 6) MOD 7: ShowLine item%, 1, i„         CASE -80, ASC("2"), ASC("3"): ShowLine item%, 0, i„            item% = (item% + 1) MOD 7: ShowLine item%, 1, i„         CASE 13: ShowLine item%, 0, i„            DoEdit item%, i: ShowLine item%, 1, i„         CASE 27, -45, ASC("+"): Finished% = -1„      END SELECT: k% = 0: k$ = INKEY$„      IF k$ > "" THEN„         k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))„      END IF: ShowTime: LOOP WHILE NOT (Finished%): END SUB„SUB EditOrd (Ord&) : LOCATE 2, 7: COLOR 10, 0„   PRINT " Enter number of parts to add. "„   NumberOrd$ = GetString$("     ", 15, 41, 6, 0)„   Ord& = Ord& + VAL(NumberOrd$): END SUB„SUB EditPrc (Prc&) : LOCATE 2, 7: COLOR 10, 0„   PRINT " Enter new price per piece. "„   Prc$ = GetString$("", 16, 41, 10, 0)„   IF VAL(Prc$) > 0 THEN Prc& = VAL(Prc$) * 100„END SUB„FUNCTION GetDate$„   d$ = DATE$: m% = VAL(d$): d$ = MID$(d$, INSTR(d$, "-"))„   MID$(d$, 1) = " ": mon$ = "  JanFebMarAprMayJunJulAugSepOctNovDec"„   GetDate$ = MID$(mon$, m% * 3, 3) + d$: END FUNCTION„FUNCTION GetString$ (d$, x%, y%, l%, k%)„   s$ = LEFT$(d$ + SPACE$(l%), l%): done% = 0: ins% = 1: GOSUB insert„   C% = LEN(RTRIM$(s$)) - 1„   IF C% < l% THEN C% = C% + 1„   DO: LOCATE x%, y%, 0: COLOR 0, 3: PRINT s$;„      DO: k% = 0: ShowTime: LOCATE x%, y% + C%: COLOR 4 * ins%, 7„         PRINT MID$(s$, C% + 1, 1); : k$ = INKEY$„         IF k$ > "" THEN„            k% = ASC(k$): IF k% = 0 THEN k% = -ASC(MID$(k$, 2))„         END IF: LOOP WHILE k% = 0„      SELECT CASE k%„         CASE 32 TO 126„            IF ins% > 0 THEN„               s$ = LEFT$(LEFT$(s$, C% + 1) + MID$(s$, C% + 1), l%)„            END IF„            MID$(s$, C% + 1) = CHR$(k%): C% = C% - (C% < l%)„         CASE 8„            IF C% > 0 THEN„               C% = C% - 1: s$ = LEFT$(s$, C%) + MID$(s$, C% + 2) + " "„            END IF„         CASE 13, -72, -80: GetString$ = s$: done% = -1„         CASE 27: GetString$ = d$: done% = -1„         CASE -82: ins% = ABS(ins% - 1): SOUND 999, .5: GOSUB insert„         CASE -75: C% = (C% + l% - 1) MOD l%„         CASE -77: C% = (C% + 1) MOD l%„         CASE -71: C% = 0„         CASE -79: C% = LEN(RTRIM$(s$)) - 1: IF C% < l% THEN C% = C% + 1„         CASE -83: s$ = LEFT$(s$, C%) + MID$(s$, C% + 2) + " "„      END SELECT: LOOP WHILE NOT (done%): ins% = 0: GOSUB insert„EXIT FUNCTION„insert: : LOCATE 6, 38: COLOR 9, 1„   IF ins% > 0 THEN PRINT " INS "; :  ELSE PRINT STRING$(5, 205);„   RETURN„END FUNCTION„SUB ShowInventory (i AS InventoryControlDat) : COLOR 10, 2: CLS„   FOR t% = 1 TO 25: LOCATE t%, 1, 0: PRINT STRING$(80, 177); : NEXT„   LOCATE 6, 7, 0: COLOR 9, 1: PRINT Caption$(0);„   FOR t% = 1 TO 7: ShowLine t%, 0, i: NEXT„   COLOR 9, 1: LOCATE 18, 7: PRINT Caption$(7): END SUB„SUB ShowItem (x%, s$, H%) : border$ = " " + STRING$(2, 179) + " "„   LOCATE x%, 7, 0: COLOR 9, 1: PRINT border$;„   IF H% > 0 THEN COLOR 4, 7:  ELSE COLOR 15, 1„   PRINT LEFT$(s$ + SPACE$(60), 60); : COLOR 9, 1„   PRINT border$: END SUB„SUB ShowLine (x%, hi%, i AS InventoryControlDat)„   SELECT CASE x%„      CASE 0: ShowItem 7, i.PartName, hi%„      CASE 1: ShowItem 8, i.PartNumb + Caption$(1), hi%„      CASE 2: ShowItem 9, Caption$(8), hi%„         ShowItem 10, Caption$(2) + MID$(i.PartDesc, 1, 40), hi%„         ShowItem 11, Caption$(2) + MID$(i.PartDesc, 41, 40), hi%„         ShowItem 12, Caption$(2) + MID$(i.PartDesc, 81, 40), hi%„         ShowItem 13, Caption$(2) + MID$(i.PartDesc, 121, 40), hi%„      CASE 3: ShowItem 14, Caption$(3) + STR$(i.PartsAvl), hi%„      CASE 4: ShowItem 15, Caption$(4) + STR$(i.PartsOrd), hi%„      CASE 5: ShowItem 16, Caption$(5) + Currency$(i.PartsPrc), hi%„      CASE 6: ShowItem 17, Caption$(6) + Currency$(i.PartsCst), hi%„   END SELECT: END SUB„SUB ShowTime : LOCATE 4, 7, 0: COLOR 10, 0: tm$ = TIME$„   t% = VAL(tm$): tm$ = MID$(tm$, INSTR(tm$, ":")): am$ = "am"„   IF t% = 0 THEN t% = 12 ELSE IF t% > 12 THEN t% = t% - 12: am$ = "pm"„   tm$ = RIGHT$(STR$(t%), 2) + tm$„   PRINT "  " + GetDate$ + "  " + tm$ + " " + am$ + "  ": END SUB„Tommi Utriainen                SCROLLING TEXT                 tomppa@pcuf.fi                 09-14-97 (21:42)       QB, QBasic, PDS        40   952      DEMO.BAS    '„' simple scrolling text..„„CLS„SCREEN 9„„LOCATE 10, 10„„a$ =  _„"                        Joo, laitetaan nytten sitten yhteen ja samaan muuttujaan eikÑ ollenkaan kÑytetÑ dataa, niin on paljon helpompi juttu tehdÑ.. SillÑ voihan yx muuttuja olla vissiin ihan tarpeeksi pitkÑ meidÑn scrolli tekstille, vai eikî tÑmÑ riitÑ??? Hé???" _„„a$ = a$ + " Seli seli, sitten pitÑÑ vaan jatkaa muuttujaa tÑhÑn tyyliin, ettÑs tiedÑt.. Tosi hillittîmÑsti tekstiÑ vai?? No joo, mutta ihan riittÑvÑsti kuitenkin, pari riviÑ voipi laittaa ihan hyvin.. "„'a$ = UCASE$(a$)„„COLOR 12„RESTORE pale:„„FOR t = 1 TO LEN(a$)„„„a = a + 1„IF a = 1 THEN„READ pal: IF pal = 99 THEN RESTORE: READ pal„PALETTE 12, pal„a = 0„END IF„„„„                alku = TIMER„                DO WHILE TIMER - alku < .045„                LOOP„„LOCATE 10, 3„PRINT MID$(a$, t, 75);„„NEXT„„pale:„DATA 0,8,1,9,25,11,31,31,31,31,31,31,31,31,31,31,11,25,9,1,8,99„Ryan Shaw                      TEXT HILIGHTING CODE           kathleen@iafrica.com.na        10-10-97 (20:02)       QB, QBasic, PDS        104  3882     BOUNCE.BAS  ' BOUNCE (.BAS...?!!!)„' Atr.:  Ryan Shaw„' Mail.:  kathleen@iafrica.com.na (no I don't have a problem figuring out who„'                                     I am...)„'„' Descript:„' Displays a, er, thing running from left to right, but unfortunately it„' doesn't pull the brakes in time and smacks into the right hand side of the„' screen, bounces left, tries to avoid collosion for the second time,„' doesn't, and gets hit again...  This seems to go on for a long time„' depending on how evil you plan to be...„'„' Text hilight thing like in XREAD (except that it has *3* hi-intens. spots„' while the one in XREAD has *4*).  Comes with THREE fades for you too test.„' If you can...„'„' Disclaimer:„' If anything appears on your screen, it's your problem...„' If nothing happens, it's still your problem...„' If a strange looking thing gets hurt on your screen and sues you, it's„' a bug somewhere in the program, squash it.  And don't return it to me.„'„' Use it if you want, and give credit to me (read as you) if you want to„' congratulate yourself on finding such a useless/ful program, I don't„' really care what you do with it since I spent ten seconds longer„' commenting it than writing it...„'„DECLARE SUB HiLightText (Focus%)„DIM SHARED FadeTable(10) AS INTEGER„„CLS„DelayPause& = 35000               ' Need a long because it's too quick„                                  ' to read otherwise....„„FOR LoadFade% = 0 TO 8„  READ FadeTable(LoadFade%)       ' Load our fade table„NEXT„„COLOR 3„PRINT "…"; STRING$(78, "Õ"); "ª"„PRINT "∫"; SPC(78); "∫"„PRINT "»"; STRING$(78, "Õ"); "º"„COLOR 0                           ' Hide the text„LOCATE 2, 2                       ' And print it...„PRINT STRING$(39, ">"); STRING$(39, "<")„COLOR 12„„Killer% = 1„DO„  SELECT CASE Bounce%             ' So that the text bounces around„    CASE IS = 0                   ' Bounce right„      Focus% = Focus% + 1         '„      IF Focus% = 79 THEN„        Bounce% = 1               ' Bounce left at end of line„        LOCATE 4, 1„        PRINT SPC(72); "Dooof!!!"„        Killer% = Killer% + 1„      END IF„    CASE IS = 1                   ' Bounce left„      Focus% = Focus% - 1         '„      IF Focus% = 1 THEN„        Bounce% = 0               ' Bounce right at start of line„        LOCATE 4, 1„        PRINT "Arrrg!!!"; SPC(72);„        Killer% = Killer% + 1„      END IF„    END SELECT„  HiLightText Focus%              ' HiLight text„  'FOR Delay& = 0 TO DelayPause&   ' Pause too read... (remove for TOO MUCH„  'NEXT Delay&                     ' SPEED!!! - looks like a high speed wave„                                  ' on my comp...)„                                  ' Couple weeks later:  actually it looks„                                  ' pretty cool... try it...„LOOP WHILE INKEY$ = ""„„COLOR 15„PRINT "You have beaten up thing"; Killer%; "times.  Was that fun or something?"„„' The first/last pieces of data should be 0 (to leave the text hidden),„' or whatever your background colour is.„' The next number describes the colour used for low brightness, then„' the next for medium brightness, and the third for high intensity.„' Fade from black to bright white...„DATA 0, 8, 7, 15, 15, 15, 7, 8, 0„' Ice fade...„DATA 0, 3, 11, 15, 15, 15, 11, 3, 0„' Red spot light...„DATA 0, 4, 12, 4, 4, 4, 12, 4, 0„„SUB HiLightText (Focus%)„DEF SEG = &HB800                          ' Text memory„  FOR ChngChar% = Focus% - 4 TO Focus% + 4    ' 4 chars that way and 5 there„    SELECT CASE ChngChar%„      CASE IS = 79„        EXIT FOR„      CASE IS > 0„        POKE (160 + (ChngChar% * 2) + 1), FadeTable(CurChar%)   ' Write their clr„        CurChar% = CurChar% + 1   ' Change table position„      CASE ELSE„        CurChar% = CurChar% + 1„    END SELECT„  NEXT„DEF SEG„END SUB„Sami Kyostila                  TEXTMODE WINDOZE ENGINE        hiteck@mail.freenet.hut.fi     10-13-97 (18:48)       QB, QBasic, PDS        4209 125244   TWIN.BAS    '----[TWIN.BAS (C) Sami KyîstilÑ 1997]----------------------------------------„'            ⁄ƒƒƒƒƒƒø⁄ƒƒø⁄ƒƒƒƒƒø⁄ƒƒƒƒø  ⁄ƒƒƒø ⁄ƒƒƒƒø⁄ƒƒƒƒø„'            ≥€∞  €∞≥≥€∞≥≥€∞ €∞≥≥€€€∞¿ø⁄Ÿ€€∞¿ø≥€€€∞≥≥€€€∞≥„'            ≥€∞  €∞≥√ƒƒ¥≥€∞ €∞≥≥€∞ €∞≥≥€∞ €∞≥≥  €∞≥≥€∞  ≥„'     ˙ ˙˙ƒ˙ƒ¥€∞  €∞√¥€∞√¥€€∞€∞√¥€∞ €∞√¥€∞ €∞√¥ €∞ √¥€€∞ √ƒ˙ƒ˙˙ ˙„'            ≥€∞€∞€∞≥≥€∞≥≥€∞€€∞≥≥€∞ €∞≥≥€∞ €∞≥≥€∞  ≥≥€∞  ≥„'            ≥€€∞€€∞≥≥€∞≥≥€∞ €∞≥≥€€€∞⁄Ÿ¿ø€€∞⁄Ÿ≥€€€∞≥≥€€€∞≥„'            ¿ƒƒƒƒƒƒŸ¿ƒƒŸ¿ƒƒƒƒƒŸ¿ƒƒƒƒŸ  ¿ƒƒƒŸ ¿ƒƒƒƒŸ¿ƒƒƒƒŸ„'„'                            E˙N˙G˙I˙N˙E„'„'                            ::[V1.00]::„'„'                [T˙E˙X˙T˙M˙O˙D˙E]-[V˙E˙R˙S˙I˙O˙N]„'„'                  ⁄ƒƒƒø ⁄ƒƒƒƒƒƒƒø ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„'         ˙ ˙˙ƒ˙ƒƒƒ¥(C)√ƒ¥S˙A˙M˙i√ƒ¥K˙Y˙ô˙S˙T˙i˙L˙é√ƒƒ˙ƒ˙˙ ˙„'                  ¿ƒƒƒŸ ¿ƒƒƒƒƒƒƒŸ ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„'„'                       ˙ ˙˙ƒ˙ƒ1ƒ9ƒ9ƒ7ƒ˙ƒ˙˙ ˙„'„'----------------------------------------------------------------------------„'„' If you have any comments, questions, bug reports, etc. please send them to:„'„'   hiteck@freenet.hut.fi„'„' or:„'„'   kemple.oy@mbnet.fi„'„' or contact hiteck in IRC„'„'----------------------------------------------------------------------------„„'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„'*                                                                         *„'* You are granted a permission (and encouraged) to use this code to       *„'* build your own applications, as long as I am credited for the           *„'* engine, after all, it's not that easy to write 4000+ lines of source ;) *„'* Also include the above box somewhere in your program's source           *„'*                                                                         *„'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„„„'----------------------------------------------------------------------------„'„' Required files:          TWIN.BAS - Main source„'„' Programming language: Microsoft QuickBasic v4.5„'                       (Should also run under QB v1.1 and PDS)„'„'----------------------------------------------------------------------------„„„'----------------------------------------------------------------------------„'„'  This program has been completely written by me, Sami KyîstilÑ, except„'  for the following routines, which I have modified from other peoples'„'  programs:„'„'     - DMA Wav player modified from Mike Huff's DMAPLAY.BAS„'           (added 32k+ file support)„'     - Mouse routines modified from Mikrobitti Magazine's article„'     - Original idea from William Yu's ABC Express Reader„'     - High intensity backround colors from Byron Smith's program„'     - Directory routines from QDIR.BAS (sorry, don't know who made it)„'„'  Almost every SUB in this program is commented to help you master this„'  engine. If a SUB's description says "SYSTEM", that means that„'  you don't have to worry about that one, it is handled by the engine.„'„'  Here is a list of some of the SUBS:„'  (???? is a wildcard)„'„'          Main - The engine's inmost core, handles all objects„'     DefScreen - Defines screen parameters, like colors, screen lines etc.„'    Initscreen - Place your object creation calls in here„'    Create???? - These subs create objects, read the description to„'                 find out their parameters etc.„'    KillWindow - This sub removes a window and it's contents„'                 You can remove a single object by setting it's ????.Active„'                 Flag to 0, for example for a Label, Label(Num).Active = 0„'                 Redraw the screen after this„'    WAVPlayDMA - Plays WAV/VOC files in the backround„'         Exist - Checks if a file exists„'    ????Volume - Sound Blaster volume settings„'  Hiiripiiloon - Hides the mouse cursor, so the screen won't mess up when„'                 drawing (see sub MouseInside)„'    Hiiriesiin - Shows the mouse cursor„'        Dialog - Displays a message box, or prompt the user for information„'         Query - Queries user for a text string (Name, Filename, etc.)„'       FDialog - Initializes the built-in file browser (Save)„'       FSelect - Initializes the built-in file browser (Load)„'    SampleByte - Samples a byte from the Sound Blaster Mic port„'                 (Doesn't work under Win95, at least not on my machine)„'„'  There are lots of more useful SUBS/FUNCTIONS, so please browse through the„'  SUB/FUNCTION list (press F2 to view it).„'„'----------------------------------------------------------------------------„„„„„„'----------------------------------------------------------------------------„'                               Features„'----------------------------------------------------------------------------„'„' - A complete text user interface with movable windows and objects„' - Built-in filesystem browser„' - Intuitive interface, which resembles many commercial applications,„'   like MS QuickBasic v4.5„' - DMA backround Wav player, which supports unlimited file lenghts„' - User definable screen parameters„' - Customisable memory usage (See CONST-statements below)„'„' ...and the list goes on„'„'----------------------------------------------------------------------------„„„„„„'----------------------------------------------------------------------------„'                      What is this thing anyway?„'----------------------------------------------------------------------------„'„' This program is a GUI (Graphical user interface) that you can use to write„' programs without having to make a new user interface for every program.„' It has may useful objects, for example a button, a checkbox, an text input„' field etc. The objects are similar to ones in Microsoft Windows 95, so„' users won't have trouble adjusting to them. It's great for installation„' programs (see SUB BackroundCopy).„'„'----------------------------------------------------------------------------„„„„„'----------------------------------------------------------------------------„'                      Your first Windoze program.„'----------------------------------------------------------------------------„'„' To write a Windoze program, you need to do a couple of things first:„'   First you must delete every executable statement from SUB Initscreen,„' so the objects of this demo are deleted and you get a clean table to start„' from. Then delete all user event handlers between the lines "Start of user„' code" and "End user code" in the main module. SUB Initscreen is called at„' the start of the program, so place all your object creation commands there.„' But before that, you need to make a window where you can place your„' objects, since they can't be placed on a plain desktop. So insert the„' following line to SUB Initscreen:„'„'      CreateWindow 1, 1, 1,  60, 15, 15, 7 "Test window"„'                   ^  ^  ^  ^    ^    ^  ^  ^„'               index  coords         color  topic            „'                                                        „'„' This line calls SUB Createwindow, which creates and draws a window at„' (1,1) - (60, 15). The window's index number is 1 and it's topic is„' "Test window", and it is filled, with color 7 (gray) with a color 15 (white)„' border. To change any of these properties, refer to SUB CreateWindow„' for parameter descriptions. The index number is the handle of the window.„' It will be used to refer to the window when creating objects into it.„'   Now you should add an object to the window. Lets start with the button.„' Add this line to SUB Initscreen:„'„'      CreateButton 1, 1, 4, 2, 8, 3, "Exit",  15,  3„'                   ^  ^  ^  ^  ^  ^   ^         ^  ^„'  host window handle  |  |  |  |  |   Caption   Color„'                  index  coords (x,y,xlen, ylen)„'„' This line call SUB Createbutton, which creates and draws a button in window„' 1, with an handle (index) number of 1, placed at  4x,  2y, 8 chars wide,„' 3 chars high, and with the text "Exit" printed on it, white over cyan„'   Now, try to run your program. It should display a light gray window in„' the upper left corner of the screen, with an "Exit" button in it. When„' you click the button, nothing happens, so lets fix it. When a button is„' clicked, the variable Clickedbutton is assigned the value of the clicked„' button's index number, in this case 1. So lets make an event handler for„' the button, so when it is clicked, the program is ended. Add these lines„' after the line "Start user code" in the main module:„'„' IF ClickedButton = 1 THEN     'Test if button 1 is clicked„'   END                         'End program„' END IF„'„'                   C O N G R A T U L A T i O N S !„'„' You've just completed your first Windoze program! It's just a small„' demonstration of Windoze's cababilities. And it's also quite boring.„' You can add more complex objects into you program, and multiple windows„' Check out SUBS Create?????? to learn how to make objects like radiobuttons,„' checkboxes, scrollbars and menus. See SUB ColPrint, to find out how to„' print colored text on objects that support it.„'„'----------------------------------------------------------------------------„„„„'----------------------------------------------------------------------------„'                        Useful variables„'----------------------------------------------------------------------------„'„'                   AWin - Which window is active„'                  AText - Active textfield„'  .-   MenuSelected.Win - Window, where selected menu resides„'  |-   MenuSelected.Num - Number of the menu where the selected item is„'  |-  MenuSelected.Item - Number of selected item„'  |„'  Use in conjuction to find out what menu item was selected„'„'                   Key$ - Pressed keyboard key (INKEY$)„'              MouseMove - If 1, then mouse was moved„'          Clickedbutton - The index of the button which was clicked„'                  Click - If 1, then mouse was clicked„'               DBLClick - If 1, then mouse was double-clicked„'                   Drag - If 1, then a window is being moved„'                 Hx, Hy - Mouse coordinates„'                     Hv - Mouse left button (if -1, then being held down)„'                     Hk - Mouse center button (if -1, then being held down)„'                     Ho - Mouse right button (if -1, then being held down)„'            PlayingWAV& - If True, then the system is playing a wav file„'          Version.Major - Major version (1 char string)„'          Version.Minor - Minor version (2 char string)„'           SelectedLBox - Selected list box                 '\„'     SelectedName$(Num) - Name of selected ListBox item     '- use to find out what„'           SelectedItem - Number of selected ListBox item   '/ item the user selected„'                                                               from a list box„'              EnterText - Number of the textfield where the„'                          user pressed enter„'„' Most objects have variables which you can read the objects value from„' (or set it). See SUB Create???? to find out the variables for an object.„'„'----------------------------------------------------------------------------„„„'----------------------------------------------------------------------------„'                              Known bugs„'----------------------------------------------------------------------------„'„' - Objects (Labels for example) cannot be updated from other windows than„'   they are in. This is actually not a bug, I've disabled it, because it„'   causes screen redraw errors. I have no idea how to go about this problem.„'   It would require lots of calculation to find out where to draw and where„'   not to draw.„' - The file browser sometimes behaves strangely, I have no idea why.„'   If you have any suggestions, please email me.„' - You cannot initialize the file selector, if a sound is playing in the„'   backround. I've removed that ability, because if you do it, then„'   you'll get garbage instead of filenames. Again, please email me if you„'   can help.„'----------------------------------------------------------------------------„„„„'$DYNAMIC„DEFINT A-Z„„DECLARE SUB DmaState (StopGo%)„DECLARE SUB MasterVolume (right%, Left%, Getvol%)„DECLARE SUB DrawShadow (x%, y%, x2%, y2%)„DECLARE SUB DrawMenuItems (WindowNum%, Num%)„DECLARE SUB DrawMenuBox (WindowNum%, Num%)„DECLARE SUB CreateMenu (WindowNum%, Num%, Caption$)„DECLARE SUB AddMenuItem (WindowNum%, Num%, Caption$)„DECLARE SUB DrawMenu (WindowNum%)„DECLARE FUNCTION FDialog$ (Text$, StartDir$, StartFile$)„DECLARE SUB ReadDir2 (Dir$)„DECLARE FUNCTION GetFileAttr% (Filename$)„DECLARE FUNCTION QDir$ (FileSpec$, Dirs)„DECLARE FUNCTION MouseInside% (x%, y%, x2%, y2%)„DECLARE FUNCTION RealLen% (Text$)„DECLARE SUB ColPrint (Text$)„DECLARE FUNCTION FSelect$ (Text$, StartDir$, FileSpec$)„DECLARE SUB DrawTaskBar ()„DECLARE SUB DrawPBar (Num%)„DECLARE SUB CreatePBar (WindowNum%, Num%, x%, y%, XLen%, UsedCol%, FreeCol%, Max&, Value&)„DECLARE FUNCTION DMADone% ()„DECLARE SUB ReadDir (Dir$, FileSpec$)„DECLARE FUNCTION Query$ (Topic$, Text$, TextField$, MaxLen, Password%)„DECLARE FUNCTION SeekBufferLine% (Num%, LineNum%)„DECLARE FUNCTION FSelect$ (Text$, Dir$, FileSpec$)„DECLARE SUB Dir.init (path$, attrib%)„DECLARE SUB WAVPlayDMA (File$, Freq&)„DECLARE FUNCTION DMADone% ()„DECLARE SUB DMAPlay (Segment&, Offset&, Length&, Freq&)„DECLARE SUB writedsp (Byte%)„DECLARE FUNCTION DSPVersion! ()„DECLARE SUB GetBLASTER (DMA%, BasePort%, IRQ%)„DECLARE FUNCTION ReadDAC% ()„DECLARE FUNCTION ReadDSP% ()„DECLARE FUNCTION ResetDSP% ()„DECLARE SUB ResetSB ()„DECLARE FUNCTION Samplebyte% ()„DECLARE SUB SpeakerState (OnOff%)„DECLARE FUNCTION SpeakerStatus% ()„DECLARE SUB CreateTextField (WindowNum%, Num%, x%, y%, MaxLen%, FCol%, BCol%, Text$, Password)„DECLARE SUB DrawTextField (Num%)„DECLARE FUNCTION InputField$ (Text$, Key$, MaxLen%, TPos%)„DECLARE FUNCTION Dialog% (Topic$, Text$, Button1$, Button2$, Button3$)„DECLARE SUB KillWindow (Num%)„DECLARE SUB SeekLine (FileNum%, LineNum%)„DECLARE SUB CreateListBox (WindowNum%, Num%, x%, y%, XLen%, YLen%, Filename$, Offset%, FCol%, BCol%, ViewBox, Col)„DECLARE SUB DrawListBox (Num%)„DECLARE FUNCTION CountLines% (File$)„DECLARE FUNCTION Exist% (File$)„DECLARE SUB CreateLabel (WindowNum%, Num%, x%, y%, XLen%, YLen%, Style%, FCol%, BCol%, Caption$)„DECLARE SUB PrintLine (Text$, XLen%)„DECLARE FUNCTION Wrap$ (InputText$, Wrappos%)„DECLARE SUB DrawLabel (Num%)„DECLARE SUB CreateRadioButton (WindowNum%, Num%, x%, y%, State%, Group%, Caption$)„DECLARE SUB DrawRadio (Num%)„DECLARE SUB Switch (Var%, Value1%, Value2%)„DECLARE SUB CreateCheckBox (WindowNum%, Num%, x%, y%, State%, Caption$)„DECLARE SUB DrawCheckBox (Num%)„DECLARE SUB CreateFrame (WindowNum%, Num%, x%, y%, XLen%, YLen%, Caption$, Style%, FCol%, BCol%)„DECLARE SUB Box3D (x%, y%, x2%, y2%, Style%, FCol%, BCol%, Back%)„DECLARE SUB DrawFrame (Num)„DECLARE SUB CreateButton (WindowNum%, Num%, x%, y%, XLen%, YLen%, Caption$, FCol, BCol)„DECLARE SUB DrawButton (Num, Pressed)„DECLARE SUB ReDrawWindow (Num%)„DECLARE SUB Hiirirajat (x1%, y1%, x2%, y2%)„DECLARE SUB DrawDesk (x%, y%, x2%, y2%)„DECLARE SUB EraseBox ()„DECLARE SUB DrawBox (x%, y%, x2%, y2%)„DECLARE SUB Initscreen ()„DECLARE SUB DefScreen ()„DECLARE SUB ReDrawScreen ()„DECLARE SUB CreateWindow (Num%, x%, y%, x2%, y2%, FCol%, BCol%, Topic$)„DECLARE SUB BlinkOff ()„DECLARE SUB Hiirilue (vasen%, oikea%, keski%, x%, y%)„DECLARE SUB Main ()„DECLARE SUB UpdateMouse ()„DECLARE SUB Hiiriesiin ()„DECLARE SUB Hiiripiiloon ()„DECLARE SUB Hiiriajuri (ax%, bx%, cx%, dx%)„DECLARE FUNCTION Hiiritarkista% ()„DECLARE SUB DrawWindow (Num)„OPTION BASE 1„„„'WAV-playback„'------------„DIM SHARED WavBuffer(0 TO 0) AS STRING * 8000„DIM SHARED WavFreq&„DIM SHARED WavFileHandle&„DIM SHARED WavOffset&„DIM SHARED WavLength&„DIM SHARED PlayingWAV&„DIM SHARED BasePort%„DIM SHARED LenPort%„DIM SHARED Channel%„DIM SHARED IRQ%„DIM SHARED EnterText AS INTEGER„„„GetBLASTER Channel%, BasePort%, IRQ%       'Read Sound Blaster parameters„„TYPE Registers„   ax    AS INTEGER„   bx    AS INTEGER„   cx    AS INTEGER„   dx    AS INTEGER„   bp    AS INTEGER„   si    AS INTEGER„   di    AS INTEGER„   ds    AS INTEGER„   es    AS INTEGER„   Flags AS INTEGER„END TYPE„„TYPE VersionType„  Major AS STRING * 1„  Minor AS STRING * 2„END TYPE„„TYPE PBarType„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  x2 AS INTEGER„  UsedCol AS INTEGER„  FreeCol AS INTEGER„  Max AS LONG„  Value AS LONG„  OldValue AS LONG„  Active AS INTEGER„END TYPE„„TYPE TextFieldType„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  MaxLen AS INTEGER„  FCol AS INTEGER„  BCol AS INTEGER„  TPos AS INTEGER„  Password AS INTEGER„  Active AS INTEGER„END TYPE„„TYPE ListBoxType„  FCol AS INTEGER„  BCol AS INTEGER„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  x2 AS INTEGER„  y2 AS INTEGER„  Offset AS INTEGER„  Total AS INTEGER„  Selected AS INTEGER„  Block AS INTEGER„  UseBuffer AS INTEGER„  ViewBox AS INTEGER„  Active AS INTEGER„  Col AS INTEGER„END TYPE„„„TYPE CheckBoxType„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  State AS INTEGER„  Active AS INTEGER„END TYPE„„„TYPE RadioType„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  State AS INTEGER„  Group AS INTEGER„  Active AS INTEGER„END TYPE„„TYPE ButtonType„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  x2 AS INTEGER„  y2 AS INTEGER„  FCol AS INTEGER„  BCol AS INTEGER„  Active AS INTEGER„END TYPE„„TYPE WindowType„  x AS INTEGER„  y AS INTEGER„  x2 AS INTEGER„  y2 AS INTEGER„  FCol AS INTEGER„  BCol AS INTEGER„END TYPE„„TYPE BoxType„  Col AS INTEGER„  Char AS STRING * 1„END TYPE„„TYPE FrameType„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  x2 AS INTEGER„  y2 AS INTEGER„  Style AS INTEGER„  FCol AS INTEGER„  BCol AS INTEGER„  Active AS INTEGER„END TYPE„„TYPE LabelType„  Win AS INTEGER„  x AS INTEGER„  y AS INTEGER„  x2 AS INTEGER„  y2 AS INTEGER„  Style AS INTEGER„  FCol AS INTEGER„  BCol AS INTEGER„  Active AS INTEGER„END TYPE„„„TYPE Menutype„  Caption AS STRING * 10„  Items AS INTEGER„  Longest AS INTEGER„END TYPE„„TYPE MenuSelectedType„  Win AS INTEGER„  Num AS INTEGER„  Item AS INTEGER„END TYPE„„CONST Float = 0„CONST SingleNormal = 1„CONST DoubleNormal = 2„CONST SingleIN = 3„CONST SingleOUT = 4„CONST DoubleIN = 5„CONST DoubleOUT = 6„CONST Filled = 7„„CONST MaxTextFields = 10               'Adjust for lower memory usage„CONST MaxListBoxes = 10„CONST MaxLabels = 10„CONST MaxCheckBoxes = 10„CONST MaxRadioButtons = 10„CONST MaxWindows = 10„CONST MaxButtons = 20„CONST MaxFrames = 10„CONST MaxPBars = 3„„„CONST BufferSize = 2000                'Listbox Buffer size„„CONST True = 0„CONST False = NOT True„„„„DIM SHARED MenuBar(MaxWindows + 1, 8) AS Menutype„DIM SHARED Menu$(MaxWindows + 1, 8, 0 TO 14)„DIM SHARED MenuSelected AS MenuSelectedType„DIM SHARED AMenu AS INTEGER„DIM SHARED MenuItem AS INTEGER„„DIM SHARED PBar(MaxPBars) AS PBarType„DIM SHARED Version AS VersionType„DIM SHARED OldTimer&„DIM SHARED TaskBarLine AS INTEGER„DIM SHARED TaskBar AS INTEGER„„'----------------------------------------------------------------------------„'You get an "Out of memory" error here,„'decrease the constant BufferSize (above)„'or the maximum number of listboxes (also„'above)„DIM SHARED Buf(1 TO MaxListBoxes + 2, 0 TO BufferSize) AS INTEGER„'----------------------------------------------------------------------------„„„DIM SHARED BufferPos AS INTEGER„DIM SHARED ReadByte AS STRING * 1„DIM SHARED AText AS INTEGER„DIM SHARED CursorX AS INTEGER„DIM SHARED CursorY AS INTEGER„DIM SHARED TextF(MaxTextFields + 1) AS TextFieldType„DIM SHARED TextFText$(MaxTextFields + 1)„DIM SHARED GTime AS LONG„DIM SHARED SelectedItem AS INTEGER„DIM SHARED Key$„DIM SHARED LBoxFilename$(MaxListBoxes + 2)„DIM SHARED LBox(MaxListBoxes + 2) AS ListBoxType„DIM SHARED Label(MaxLabels + 1) AS LabelType„DIM SHARED LabelCaption$(MaxLabels + 1)„DIM SHARED LockWindows AS INTEGER„DIM SHARED CBoxCaption$(MaxCheckBoxes)„DIM SHARED CBox(MaxCheckBoxes) AS CheckBoxType„DIM SHARED RadioCaption$(MaxRadioButtons)„DIM SHARED Radio(MaxRadioButtons) AS RadioType„DIM SHARED Frame(MaxFrames + 2) AS FrameType„DIM SHARED FrameCaption$(MaxFrames + 2)„DIM SHARED Lines AS INTEGER„DIM SHARED ClickedButton AS INTEGER„DIM SHARED HoldButton AS INTEGER„DIM SHARED But(MaxButtons + 3) AS ButtonType„DIM SHARED ButCaption$(MaxButtons + 3)„DIM SHARED Box(1 TO 260) AS BoxType„DIM SHARED BoxX„DIM SHARED BoxX2„DIM SHARED BoxY„DIM SHARED BoxY2„DIM SHARED DragWin AS INTEGER„DIM SHARED AWin AS INTEGER„DIM SHARED WinTopic$(MaxWindows + 1)„DIM SHARED Win(MaxWindows + 1) AS WindowType„DIM SHARED Hx AS INTEGER„DIM SHARED Hy AS INTEGER„DIM SHARED Hv AS INTEGER„DIM SHARED Hk AS INTEGER„DIM SHARED Ho AS INTEGER„DIM SHARED OldHiiriX AS INTEGER„DIM SHARED OldHiiriY AS INTEGER„DIM SHARED Click AS INTEGER„DIM SHARED ActiveTopicF, ActiveTopicB„DIM SHARED DeActiveTopicF, DeActiveTopicB„DIM SHARED Drag AS INTEGER„DIM SHARED DragOfs AS INTEGER„DIM SHARED DragXLen AS INTEGER„DIM SHARED DragYLen AS INTEGER„DIM SHARED MouseMove AS INTEGER„DIM SHARED DesktopFCol AS INTEGER„DIM SHARED DesktopBCol AS INTEGER„DIM SHARED DesktopChar$„DIM SHARED SelectedLBox AS INTEGER„DIM SHARED Ku$„DIM SHARED Kr$„DIM SHARED Kl$„DIM SHARED Kd$„DIM SHARED SelectedName$(MaxListBoxes + 2)„DIM SHARED Windows AS INTEGER„DIM SHARED ClickCount AS LONG„DIM SHARED DBLClick AS INTEGER„„DIM SHARED Regs AS Registers„DIM SHARED Code(0 TO 55)„DIM SHARED DTA AS STRING * 44„DIM SHARED TheString AS STRING * 80„„RESTORE DirCode„Chk& = 0„FOR i = 0 TO 55„  READ Temp&„  Chk& = Chk& + Temp&„  Code(i) = Temp&„NEXT„IF Chk& <> -228741 THEN                  'Checksum„  BEEP„  PRINT " ˛ Interrupt code array error"„  END„END IF„„'Define keys„Ku$ = CHR$(0) + CHR$(72)„Kr$ = CHR$(0) + CHR$(77)„Kd$ = CHR$(0) + CHR$(80)„Kl$ = CHR$(0) + CHR$(75)„„„„DefScreen„SCREEN 0: CLS„WIDTH 80, Lines„VIEW PRINT 1 TO Lines„„BlinkOff„„Version.Major = "1"„Version.Minor = "00"„„„„„„PRINT " ˛ Initializing mouse..."„„RESTORE MouseData„DIM SHARED hiiri$               'Konekielinen ajuri„hiiri$ = SPACE$(57)             'Varataan tilaa„FOR i% = 1 TO 57„  READ a$                       'Luetaan data ja„  h$ = CHR$(VAL("&H" + a$))     'muutetaan tekstimuotoisesta„  MID$(hiiri$, i%, 1) = h$      'hexaluvusta tavuksi„NEXT i%„„napit% = Hiiritarkista%        'Alustetaan hiiri„IF (napit% = 0) THEN„  PRINT "Mouse not found!"„  END„END IF„„Hiirirajat 0, 0, 80 * 8 - 8, Lines * 8 - 8„„SCREEN , , 3, 0„DrawDesk 1, 1, 80, Lines + 1„PCOPY 3, 0„SCREEN , , 0, 0„„LockWindows = False„SelectedLBox = 1„SelectedItem = 0„AWin = 1„AText = 1„EnterText = 0„BufferPos = 0„PlayingWAV& = False„Hiiriesiin„LOCATE Lines \ 2, 36„Box3D 30, Lines \ 2 - 2, 50, Lines \ 2 + 2, SingleNormal, 15, 4, 3„DrawShadow 30, Lines \ 2 - 2, 49, Lines \ 2 + 3„LOCATE Lines \ 2, 32„COLOR 15, 4„PRINT "Initializing..."„SCREEN , , 1, 0„„Hiiripiiloon„Initscreen„ReDrawScreen„PCOPY 1, 0„SCREEN , , 0, 0„ClickCount = TIMER„Hiiriesiin„Hiiriesiin„„MasterVolume 15, 15, True„MasterVol = 15„„DO„  UpdateMouse„  Main„„'----------------------------------------------------------------------------„' Start user code„'----------------------------------------------------------------------------„„„  'Play-Button„  IF ClickedButton = 1 THEN„    IF TextFText$(1) <> "" THEN„      IF Radio(1).State = True THEN Rate& = 8000: Speed! = .5„      IF Radio(2).State = True THEN Rate& = 11025: Speed! = 1„      IF Radio(3).State = True THEN Rate& = 16000: Speed! = 1.5„      IF Radio(4).State = True THEN Rate& = 22050: Speed! = 2„      IF Radio(5).State = True THEN Rate& = 32000: Speed! = 2.5„      IF Radio(6).State = True THEN Rate& = 38000: Speed! = 3„      IF Radio(7).State = True THEN Rate& = 44100: Speed! = 3.5„      WAVPlayDMA TextFText$(1), Rate&„      IF PlayingWAV& = True THEN PBar(1).Max = LOF(WavFileHandle&)„    END IF„  END IF„„  'Volume buttons„  IF ClickedButton = 5 THEN„    MasterVol = MasterVol + 1„    IF MasterVol > 15 THEN MasterVol = 15„    CreateLabel 2, 1, 16, 10, 4, 3, Float, 16, 6, LTRIM$(RTRIM$(STR$(MasterVol)))„    MasterVolume MasterVol, MasterVol, True„  END IF„„  IF ClickedButton = 6 THEN„    MasterVol = MasterVol - 1„    IF MasterVol < 0 THEN MasterVol = 0„    CreateLabel 2, 1, 16, 10, 4, 3, Float, 16, 6, LTRIM$(RTRIM$(STR$(MasterVol)))„    MasterVolume MasterVol, MasterVol, True„  END IF„„„  'Update percent bar„  IF PlayingWAV& = True THEN„      PBar(1).Value = WavOffset& + 8000„  END IF„„„  'Browse-button„  IF ClickedButton = 2 THEN„    IF PlayingWAV& = False THEN TextFText$(1) = FSelect$("Choose a WAV file to play and then press the OK-button.", "c:\", "*.WAV")„    DrawTextField 1„  END IF„„„  '"File"-menu in text viewer window, "Load"-item„  IF MenuSelected.Win = 4 AND MenuSelected.Num = 1 AND MenuSelected.Item = 1 THEN„    Filename$ = FSelect("Select a text file to view", "C:\", "*.TXT")„    IF Filename$ <> "" THEN CreateListBox 4, 2, 0, 1, 77, 5, Filename$, 0, 7, 1, True, False„    SelectedLBox = 1„  END IF„„  '"File"-menu in text viewer window, "Save"-item„  IF MenuSelected.Win = 4 AND MenuSelected.Num = 1 AND MenuSelected.Item = 2 THEN„    Filename$ = FDialog("Choose a filename where to save you work. (Demo Only)", "C:\", "FOO.TXT")„  END IF„„„  'User selected an item in the list box„  IF SelectedLBox = 1 AND SelectedItem <> 0 AND AWin = 3 THEN„    Dummy = Dialog("Info", "You selected item" + STR$(SelectedItem), "OK", "", "")„  END IF„„  'Percent bars showing mouse movement„  'Also checks if checkbox 1 is set„  IF CBox(1).State = True THEN„    PBar(2).Value = Hx„    PBar(3).Value = Hy„  END IF„„  '"Menu"-menu in demowindow, 1st item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 1 AND MenuSelected.Item = 1 THEN„    SOUND 100, 1„    SOUND 150, 1„    SOUND 200, 1„  END IF„„  '"Menu"-menu in demowindow, 2nd item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 1 AND MenuSelected.Item = 2 THEN„    SOUND 500, 1„    SOUND 550, 1„    SOUND 600, 1„  END IF„ „  '"Menu"-menu in demowindow, 3rd item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 1 AND MenuSelected.Item = 3 THEN„    SOUND 1000, 1„    SOUND 1050, 1„    SOUND 1100, 1„  END IF„„  '"Menu"-menu in demowindow, 4th item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 1 AND MenuSelected.Item = 4 THEN„    SOUND 1500, 1„    SOUND 1550, 1„    SOUND 1600, 1„  END IF„„  '"Menu"-menu in demowindow, "Quit"-Item„  'NOTE: the separator line in the menu„  '      is also counted as an item, so„  '      the number of the "Quit"-item is„  '      6 instead of 5„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 1 AND MenuSelected.Item = 6 THEN„    END„  END IF„„  '"Help-menu in demowindow, "About"-Item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 2 AND MenuSelected.Item = 1 THEN„    Dummy = Dialog("About Windoze v" + Version.Major + "." + Version.Minor, "Windoze v" + Version.Major + "." + Version.Minor + " by Sami KyîstilÑ 1997. You may use this program freely as long as you give me credit for it", "OK", "", "")„  END IF„„  '"Help-menu in demowindow, "About Taskbar"-Item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 2 AND MenuSelected.Item = 2 THEN„    Dummy = Dialog("About Taskbar", "The taskbar at the bottom of the screen can be removed if you find it disturbing from the SUB DefScreen", "OK", "", "")„  END IF„„  '"Help-menu in demowindow, "Contact the Author"-Item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 2 AND MenuSelected.Item = 3 THEN„    Dummy = Dialog("Contacting the Author", "If you have any questions, comments, etc, feel free to send them to Sami KyîstilÑ (hiteck@freenet.hut.fi or kemple.oy@mbnet.fi)", "OK", "", "")„  END IF„„  '"Help-menu in demowindow, "Free memory"-Item„  IF MenuSelected.Win = 3 AND MenuSelected.Num = 2 AND MenuSelected.Item = 5 THEN„    Dummy = Dialog("Free memory", "String:" + STR$(FRE(1)) + CHR$(255) + "Stack:" + STR$(FRE(0)) + "        " + "Array:" + STR$(FRE(-1)), "OK", "", "")„  END IF„„  'Question-Button„  IF ClickedButton = 3 THEN„    Name$ = Query$("Query", "What is your name?", "", 15, False)„    IF Name$ = "" THEN Name$ = "Mr. Anonymous"„    Dummy = Dialog("Hi there", "Hi there, " + Name$ + "!", "Hi!", "", "")„  END IF„„'----------------------------------------------------------------------------„' End user code„'----------------------------------------------------------------------------„LOOP„„„DirCode:                                         'Don't mess with this!„                                                 'I've included a checksum„                                                 'count to prevent possible„                                                 'data loss if someone messes„                                                 'with this.„DATA -29867,22252,7767,5638,-29921,2142„DATA 8075,13502,11776,7304,30347,-1018,20653„DATA -29779,-21032,-14197,-29779,-21040„DATA -6005,20653,-29779,-21000,-21168,-16242„DATA 24095,-12968,-25600,22278,-29867,5868„DATA -29945,5758,-21508,-15477,-29781,-21567„DATA -15733,22699,-29781,-21562,-21672,-10100„DATA 22699,22699,1963,24351,23902,1226„DATA 0,0,0,0,0,0,0,0„„MouseData:                                       'Don't mess with this either„DATA 55, 89, E5, 8B, 5E, 0C, 8B, 07, 50, 8B, 5E, 0A, 8B, 07, 50, 8B„DATA 5E, 08, 8B, 0F, 8B, 5E, 06, 8B, 17, 5B, 58, 1E, 07, CD, 33, 53„DATA 8B, 5E, 0C, 89, 07, 58, 8B, 5E, 0A, 89, 07, 8B, 5E, 08, 89, 0F„DATA 8B, 5E, 06, 89, 17, 5D, CA, 08, 00„„REM $STATIC„SUB AddMenuItem (WindowNum, Num, Caption$)„'----------------------------------------------------------------------------„'              Adds a menu item into a menu„'----------------------------------------------------------------------------„'„' WindowNum - Host window of the menu„'       Num - The number of the menu in the window,„'             counting from left to right (1: First, 2: Second etc.)„'  Caption$ - Caption of the menu item. (Blank for a separator)„'„'----------------------------------------------------------------------------„„MenuBar(WindowNum, Num).Items = MenuBar(WindowNum, Num).Items + 1„„IF MenuBar(WindowNum, Num).Items > Win(WindowNum).y2 - Win(WindowNum).y - 4 THEN MenuBar(WindowNum, Num).Items = Win(WindowNum).y2 - Win(WindowNum).y - 4„„Menu$(WindowNum, Num, MenuBar(WindowNum, Num).Items) = Caption$„IF LEN(Caption$) > MenuBar(WindowNum, Num).Longest THEN MenuBar(WindowNum, Num).Longest = LEN(Caption$)„„DrawMenu WindowNum„END SUB„„DEFSNG A-Z„SUB BlinkOff„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„REDIM ML&(0 TO 1)„ML&(0) = &HB31003B8„ML&(1) = &HCB10CD00„DEF SEG = VARSEG(ML&(0))„CALL absolute(VARPTR(ML&(0)))„ERASE ML&„„END SUB„„DEFINT A-Z„SUB Box3D (x, y, x2, y2, Style, FCol, BCol, Back)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF x2 > 80 THEN x2 = 80„IF y2 > Lines THEN y2 = Lines„„Hiiripiiloon„„'Styles:„'-------„' Float = 0„' SingleNormal = 1„' DoubleNormal = 2„' SingleIN = 3„' SingleOUT = 4„' DoubleIN = 5„' DoubleOUT = 6„' Filled = 7„„SELECT CASE Style„CASE IS = 0„  FOR i = y TO y2 - 1„    COLOR FCol, BCol„    LOCATE i, x, 0„    PRINT STRING$(x2 - x, " ");„    COLOR 0, Back„    IF i = y THEN PRINT "‹";  ELSE PRINT "€";„  NEXT„  LOCATE y2, x + 1, 0„  PRINT STRING$(x2 - x, "ﬂ");„CASE IS = 1„  FOR i = y TO y2 - 1„    COLOR FCol, BCol„    LOCATE i, x, 0„    IF i = y THEN„      PRINT CHR$(218) + STRING$(x2 - x - 2, "ƒ") + CHR$(191);„    ELSE„      PRINT CHR$(179) + STRING$(x2 - x - 2, " ") + CHR$(179);„    END IF„  NEXT„  LOCATE y2, x, 0„  PRINT CHR$(192) + STRING$(x2 - x - 2, "ƒ") + CHR$(217);„CASE IS = 2„  FOR i = y TO y2 - 1„    COLOR FCol, BCol„    LOCATE i, x, 0„    IF i = y THEN„      PRINT CHR$(201) + STRING$(x2 - x - 2, "Õ") + CHR$(187);„    ELSE„      PRINT CHR$(186) + STRING$(x2 - x - 2, " ") + CHR$(186);„    END IF„  NEXT„  LOCATE y2, x, 0„  PRINT CHR$(200) + STRING$(x2 - x - 2, "Õ") + CHR$(188);„CASE IS = 3„  FOR i = y TO y2 - 1„    COLOR 15, BCol„    LOCATE i, x, 0„    IF i = y THEN„      PRINT CHR$(218) + STRING$(x2 - x - 2, "ƒ");„      COLOR 8„      PRINT CHR$(191);„    ELSE„      COLOR 15„      PRINT CHR$(179) + STRING$(x2 - x - 2, " ");„      COLOR 8„      PRINT CHR$(179);„    END IF„  NEXT„  LOCATE y2, x, 0„  COLOR 8„  PRINT CHR$(192) + STRING$(x2 - x - 2, "ƒ") + CHR$(217);„„CASE IS = 4„  FOR i = y TO y2 - 1„    COLOR 8, BCol„    LOCATE i, x, 0„    IF i = y THEN„      PRINT CHR$(218) + STRING$(x2 - x - 2, "ƒ");„      COLOR 15„      PRINT CHR$(191);„    ELSE„      COLOR 8„      PRINT CHR$(179) + STRING$(x2 - x - 2, " ");„      COLOR 15„      PRINT CHR$(179);„    END IF„  NEXT„  LOCATE y2, x, 0„  COLOR 15„  PRINT CHR$(192) + STRING$(x2 - x - 2, "ƒ") + CHR$(217);„„CASE IS = 5„  FOR i = y TO y2 - 1„    COLOR 15, BCol„    LOCATE i, x„    IF i = y THEN„      PRINT CHR$(201) + STRING$(x2 - x - 2, "Õ");„      COLOR 8„      PRINT CHR$(187);„    ELSE„      COLOR 15„      PRINT CHR$(186);„      COLOR 8„      PRINT STRING$(x2 - x - 2, " ") + CHR$(186);„    END IF„  NEXT„  COLOR 8„  LOCATE y2, x„  PRINT CHR$(200) + STRING$(x2 - x - 2, "Õ") + CHR$(188);„„CASE IS = 6„  FOR i = y TO y2 - 1„    COLOR 8, BCol„    LOCATE i, x„    IF i = y THEN„      PRINT CHR$(201) + STRING$(x2 - x - 2, "Õ");„      COLOR 15„      PRINT CHR$(187);„    ELSE„      COLOR 8„      PRINT CHR$(186);„      COLOR 15„      PRINT STRING$(x2 - x - 2, " ") + CHR$(186);„    END IF„  NEXT„  COLOR 15„  LOCATE y2, x„  PRINT CHR$(200) + STRING$(x2 - x - 2, "Õ") + CHR$(188);„„CASE IS = 7„  FOR i = y TO y2 - 1„    COLOR FCol, BCol„    LOCATE i, x„    PRINT STRING$(x2 - x, " ");„  NEXT„„END SELECT„„Hiiriesiin„„END SUB„„SUB CDVolume (right%, Left%, Getvol%)„'----------------------------------------------------------------------------„' Sets the CD-volume on the Sound Blaster card„'----------------------------------------------------------------------------„'„'  Right% - Right volume„'   Left% - Left volume„' Getvol% - If true, then volume will be read, not set„'„'----------------------------------------------------------------------------„„„OUT BasePort% + 4, &H28„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (right% + Left% * 16) AND &HFF„END IF„END SUB„„SUB ColPrint (Text$)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„'----------------------------------------------------------------------------„' Prints color-coded text„'----------------------------------------------------------------------------„' Color codes:„'„'   & followed by a color value between 0-15 (in hex)„'„' Example:„'„'   This text is &Cred„'----------------------------------------------------------------------------„„FOR i = 1 TO LEN(Text$)„  Done = 0„  DO„    IF MID$(Text$, i, 1) = "&" AND INSTR("0123456789ABCDEF", MID$(Text$, i + 1, 1)) AND i < LEN(Text$) THEN„      COLOR VAL("&H" + MID$(Text$, i + 1, 1))„      i = i + 2„    ELSE„      Done = 1„    END IF„  LOOP UNTIL Done„  PRINT MID$(Text$, i, 1);„NEXT„END SUB„„FUNCTION CountLines% (File$)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„Lin% = 0„„CountFile = FREEFILE„OPEN File$ FOR INPUT AS #CountFile„„DO„  IF EOF(CountFile) THEN EXIT DO„  LINE INPUT #CountFile, Dummy$„  Lin% = Lin% + 1„LOOP„CountLines% = Lin%„CLOSE CountFile„„„„END FUNCTION„„SUB CreateButton (WindowNum, Num, x, y, XLen, YLen, Caption$, FCol, BCol)„'----------------------------------------------------------------------------„' Creates a button„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Button index number„'       x, y - Coords„' XLen, YLen - X lenght, Y lenght„'   Caption$ - Caption, color codes can be used„' FCol, BCol - Button color„'----------------------------------------------------------------------------„„But(Num).Win = WindowNum„But(Num).x = x„But(Num).y = y„But(Num).x2 = x + XLen„But(Num).y2 = y + YLen„But(Num).FCol = FCol„But(Num).BCol = BCol„But(Num).Active = 1„„ButCaption$(Num) = Caption$„DrawButton Num, False„END SUB„„SUB CreateCheckBox (WindowNum, Num, x, y, State, Caption$)„'----------------------------------------------------------------------------„' Creates a checkbox„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Index number„'       x, y - Coords„'      State - True/False„'   Caption$ - Caption, color codes can be used„'----------------------------------------------------------------------------„„„CBox(Num).Win = WindowNum„CBox(Num).x = x„CBox(Num).y = y„CBox(Num).State = State„CBoxCaption$(Num) = Caption$„CBox(Num).Active = 1„„DrawCheckBox Num„„END SUB„„SUB CreateFrame (WindowNum, Num, x, y, XLen, YLen, Caption$, Style, FCol, BCol)„'----------------------------------------------------------------------------„' Creates a frame„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Index number„'       x, y - Coords„' XLen, YLen - X lenght, Y lenght„'   Caption$ - Caption, color codes can be used„'      Style - Border style:„'              + Float„'              + SingleIN/OUT/Normal„'              + DoubleIN/OUT/Normal„'              + Filled„' FCol, BCol - Color„'----------------------------------------------------------------------------„„„Frame(Num).Win = WindowNum„Frame(Num).x = x„Frame(Num).y = y„Frame(Num).x2 = x + XLen„Frame(Num).y2 = y + YLen„FrameCaption$(Num) = Caption$„Frame(Num).Style = Style„Frame(Num).FCol = FCol„Frame(Num).BCol = BCol„Frame(Num).Active = 1„„DrawFrame Num„„END SUB„„SUB CreateLabel (WindowNum, Num, x, y, XLen, YLen, Style, FCol, BCol, Caption$)„'----------------------------------------------------------------------------„' Creates a label„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Index number„'       x, y - Coords„' XLen, YLen - X lenght, Y lenght„'      Style - Border style:„'              + Float„'              + SingleIN/OUT/Normal„'              + DoubleIN/OUT/Normal„'              + Filled„' FCol, BCol - Color„'   Caption$ - Caption, color codes can't be used„'----------------------------------------------------------------------------„„„Label(Num).Win = WindowNum„Label(Num).x = x„Label(Num).y = y„Label(Num).x2 = x + XLen„Label(Num).y2 = y + YLen„Label(Num).Style = Style„Label(Num).FCol = FCol„Label(Num).BCol = BCol„LabelCaption$(Num) = Caption$„Label(Num).Active = 1„„„DrawLabel Num„„END SUB„„SUB CreateListBox (WindowNum, Num, x, y, XLen, YLen, Filename$, Offset, FCol, BCol, ViewBox, Col)„'----------------------------------------------------------------------------„' Creates a listbox„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Index number„'       x, y - Coords„' XLen, YLen - X lenght, Y lenght„'  Filename$ - Filename to read list from„'     Offset - Startup offset„' FCol, BCol - Color„'    ViewBox - If True, then listbox will be a file viewing box instead„'        Col - If True, then color codes will be used when printing the text„'----------------------------------------------------------------------------„„„IF Exist(Filename$) = False THEN„  LBox(Num).Total = 0„  EXIT SUB„END IF„„LBox(Num).Total = CountLines(Filename$)„„TempFile = FREEFILE„OPEN Filename$ FOR BINARY AS #TempFile„Ln& = LOF(TempFile)„IF Ln& <= BufferSize THEN„  FOR i& = 1 TO Ln&„    GET #1, , ReadByte„    Buf(Num, i& - 1) = ASC(ReadByte)„  NEXT„  LBox(Num).UseBuffer = 1„ELSE„  LBox(Num).UseBuffer = 0„END IF„„CLOSE #TempFile„„LBox(Num).Win = WindowNum„LBox(Num).x = x„LBox(Num).y = y„IF XLen - x >= Win(WindowNum).x2 - Win(WindowNum).x - 1 THEN XLen = Win(WindowNum).x2 - Win(WindowNum).x - x - 1„IF YLen - y >= Win(WindowNum).y2 - Win(WindowNum).y - 2 THEN YLen = Win(WindowNum).y2 - Win(WindowNum).y„LBox(Num).x2 = x + XLen„LBox(Num).y2 = y + YLen„LBoxFilename$(Num) = Filename$„LBox(Num).Offset = Offset„LBox(Num).Selected = Offset„LBox(Num).FCol = FCol„LBox(Num).BCol = BCol„LBox(Num).ViewBox = ViewBox„LBox(Num).Col = Col„IF Offset > LBox(Num).Total THEN LBox(Num).Offset = LBox(Num).Total: LBox(Num).Selected = LBox(Num).Total„„LBox(Num).Active = 1„„DrawListBox Num„„END SUB„„SUB CreateMenu (WindowNum, Num, Caption$)„'----------------------------------------------------------------------------„' Creates a menu into a window„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Number of menu, counting from the left (1...2...3...etc.)„'   Caption$ - Caption„'----------------------------------------------------------------------------„„MenuBar(WindowNum, Num).Caption = Caption$„MenuBar(WindowNum, Num).Items = 0„„END SUB„„SUB CreatePBar (WindowNum, Num, x, y, XLen, UsedCol, FreeCol, Max&, Value&)„'----------------------------------------------------------------------------„' Creates a percent bar„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Index number„'       x, y - Coords„'       XLen - X lenght„'    UsedCol - Used color„'    FreeCol - Free color„'       Max& - Max value„'     Value& - Startup value„'----------------------------------------------------------------------------„„PBar(Num).Win = WindowNum„PBar(Num).x = x„PBar(Num).y = y„PBar(Num).x2 = x + XLen„PBar(Num).UsedCol = UsedCol„PBar(Num).FreeCol = FreeCol„PBar(Num).Max = Max&„PBar(Num).Value = Value&„PBar(Num).OldValue = Value„PBar(Num).Active = 1„„DrawPBar Num„„END SUB„„SUB CreateRadioButton (WindowNum, Num, x, y, State, Group, Caption$)„'----------------------------------------------------------------------------„' Creates a radio box„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Index number„'       x, y - Coords„' XLen, YLen - X lenght, Y lenght„'      State - True/False„'      Group - Number of group the radio box belongs to„'   Caption$ - Caption, color codes can be used„'----------------------------------------------------------------------------„Radio(Num).Win = WindowNum„Radio(Num).x = x„Radio(Num).y = y„Radio(Num).State = State„Radio(Num).Group = Group„RadioCaption$(Num) = Caption$„Radio(Num).Active = 1„„DrawRadio Num„„END SUB„„SUB CreateTextField (WindowNum, Num, x, y, MaxLen, FCol, BCol, Text$, Password)„'----------------------------------------------------------------------------„' Creates a text field„'----------------------------------------------------------------------------„'  WindowNum - Host window number„'        Num - Index number„'       x, y - Coords„'     MaxLen - Max lenght„' FCol, BCol - Color„'      Text$ - Startup text„'   Password - If true, then stars (*) will be displayed instead of chars„'----------------------------------------------------------------------------„' TextFText$(Num) contains the textfield's text„'----------------------------------------------------------------------------„„TextF(Num).Win = WindowNum„TextF(Num).x = x„TextF(Num).y = y„TextF(Num).MaxLen = MaxLen„TextF(Num).FCol = FCol„TextF(Num).BCol = BCol„Text$ = LEFT$(Text$, MaxLen)„TextF(Num).TPos = LEN(Text$)„TextFText$(Num) = Text$„TextF(Num).Password = Password„TextF(Num).Active = 1„„DrawTextField Num„„END SUB„„SUB CreateWindow (Num, x, y, x2, y2, FCol, BCol, Topic$)„'----------------------------------------------------------------------------„' Creates a window where other objects can be placed„'----------------------------------------------------------------------------„'        Num - Index number„'  x,y,x2,y2 - Coords„' FCol, BCol - Color„'     Topic$ - Topic, color codes can't be used„'----------------------------------------------------------------------------„„„Win(Num).x = x„Win(Num).y = y„Win(Num).x2 = x2„Win(Num).y2 = y2„Win(Num).FCol = FCol„Win(Num).BCol = BCol„WinTopic$(Num) = Topic$„„DrawWindow Num„„END SUB„„SUB DefScreen„'----------------------------------------------------------------------------„' Defines screen parameters„'----------------------------------------------------------------------------„„ActiveTopicF = 15          'Active topic color„ActiveTopicB = 4„DeActiveTopicF = 7         'DeActive topic color„DeActiveTopicB = 0„DesktopFCol = 3            'Desktop color„DesktopBCol = 1„DesktopChar$ = "∞"         'Desktop character„„TaskBar = True             'Use taskbar? (True/False)„„Lines = 50                 'Screen vertical lines:„                           '----------------------„                           '25„                           '43„                           '50„„END SUB„„FUNCTION Dialog (Topic$, Text$, Button1$, Button2$, Button3$)„'----------------------------------------------------------------------------„'                      Creates a dialogwindow„'----------------------------------------------------------------------------„'„'  Topic$ - Window topic„'   Text$ - Displayed text„'Button1$ - Button 1 text„'Button2$ - Button 2 text (if blank, then button won't be created)„'Button3$ - Button 3 text (if blank, then button won't be created)„'„'----------------------------------------------------------------------------„'       When a dialog is active, all other objects are disabled„'----------------------------------------------------------------------------„' Returns the number of the pressed button (1, 2, or 3)„'----------------------------------------------------------------------------„„IF Button1$ = "" THEN EXIT FUNCTION„x = 20„y = Lines \ 2 - 5„x2 = 60„y2 = Lines \ 2 + 5„„CreateWindow MaxWindows + 1, x, y, x2, y2, 15, 7, Topic$„CreateLabel MaxWindows + 1, MaxLabels + 1, 0, 0, (x2 - x) - 1, (y2 - y) - 3, Filled, 0, 7, Text$„„LockWindows = True„AWin = MaxWindows + 1„„IF Button2$ = "" AND Button3$ = "" AND Button1$ <> "" THEN„  CreateButton MaxWindows + 1, MaxButtons + 1, (x2 - x) \ 2 - 5, (y2 - y) - 4, 8, 1, Button1$, 15, 3„END IF„„IF Button2$ <> "" AND Button3$ = "" AND Button1$ <> "" THEN„  CreateButton MaxWindows + 1, MaxButtons + 1, 5, (y2 - y) - 4, 8, 1, Button1$, 15, 3„  CreateButton MaxWindows + 1, MaxButtons + 2, (x2 - x) - 8 - 8, (y2 - y) - 4, 8, 1, Button2$, 15, 3„END IF„„IF Button2$ <> "" AND Button3$ <> "" AND Button1$ <> "" THEN„  CreateButton MaxWindows + 1, MaxButtons + 1, 3, (y2 - y) - 4, 8, 1, Button1$, 15, 3„  CreateButton MaxWindows + 1, MaxButtons + 2, (x2 - x) \ 2 - 5, (y2 - y) - 4, 8, 1, Button2$, 15, 3„  CreateButton MaxWindows + 1, MaxButtons + 3, (x2 - x) - 5 - 8, (y2 - y) - 4, 8, 1, Button3$, 15, 3„END IF„„ReDrawScreen„„DO„  UpdateMouse„  IF Button1$ <> "" AND Button2$ = "" AND Button3$ = "" THEN„    IF Key$ = CHR$(13) THEN ClickedButton = MaxButtons + 1: EXIT DO„  END IF„„  IF Button1$ <> "" AND Button2$ <> "" AND Button3$ = "" THEN„    IF Key$ = CHR$(13) THEN ClickedButton = MaxButtons + 1: EXIT DO„    IF Key$ = CHR$(27) THEN ClickedButton = MaxButtons + 2: EXIT DO„  END IF„„  Main„„LOOP UNTIL ClickedButton > MaxButtons„„Dialog = ClickedButton - MaxButtons„KillWindow MaxWindows + 1„LockWindows = False„„„END FUNCTION„„FUNCTION DMADone%„'----------------------------------------------------------------------------„'                Use to see if a DMA transfer has been completed„'----------------------------------------------------------------------------„„Count% = INP(LenPort%)„Count2% = INP(LenPort%)„Count& = CLNG(Count% + 1) * CLNG(Count2% + 1)„IF (Count& - 1) >= &HFFFF& THEN junk% = INP(DSPDataAvail%): DMADone% = -1„END FUNCTION„„SUB DMAPlay (Segment&, Offset&, Length&, Freq&)„' Transfers and plays the contents of the buffer.„Length& = Length& - 1„Page% = 0„MemLoc& = Segment& * 16 + Offset&„SELECT CASE Channel%„    CASE 0„       PgPort% = &H87„       AddPort% = &H0„       LenPort% = &H1„       ModeReg% = &H48„    CASE 1„       PgPort% = &H83„       AddPort% = &H2„       LenPort% = &H3„       ModeReg% = &H49„    CASE 2„       PgPort% = &H81„       AddPort% = &H4„       LenPort% = &H5„       ModeReg% = &H4A„    CASE 3„       PgPort% = &H82„       AddPort% = &H6„       LenPort% = &H7„       ModeReg% = &H4B„    CASE ELSE„       PRINT "DMA channels 0-3 only are supported."„       EXIT SUB„END SELECT„„OUT &HA, &H4 + Channel%„OUT &HC, &H0„OUT &HB, ModeReg%„OUT AddPort%, MemLoc& AND &HFF„OUT AddPort%, (MemLoc& AND &HFFFF&) \ &H100„IF (MemLoc& AND 65536) THEN Page% = Page% + 1„IF (MemLoc& AND 131072) THEN Page% = Page% + 2„IF (MemLoc& AND 262144) THEN Page% = Page% + 4„IF (MemLoc& AND 524288) THEN Page% = Page% + 8„OUT PgPort%, Page%„OUT LenPort%, Length& AND &HFF„OUT LenPort%, (Length& AND &HFFFF&) \ &H100„OUT &HA, Channel%„„IF Freq& < 23000 THEN„   TimeConst% = 256 - 1000000 \ Freq&„   writedsp &H40„   writedsp TimeConst%„   writedsp &H14„   writedsp (Length& AND &HFF)„   writedsp ((Length& AND &HFFFF&) \ &H100)„ELSE„   IF DSPVersion! >= 3 THEN„      TimeConst% = ((65536 - 256000000 \ Freq&) AND &HFFFF&) \ &H100„      writedsp &H40„      writedsp TimeConst%„      writedsp (Length& AND &HFF)„      writedsp ((Length& AND &HFFFF&) \ &H100)„      writedsp &H91„   ELSE„      PRINT "You need a Sound Blaster with a DSP v3.x+ to play at high speed."„      EXIT SUB„   END IF„END IF„END SUB„„SUB DmaState (StopGo%)„' Stops or continues DMA play.„IF StopGo% THEN writedsp &HD4 ELSE writedsp &HD0„„END SUB„„SUB DrawBox (x, y, x2, y2)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„Hiiripiiloon„Offset& = 1„COLOR Win(AWin).FCol, 0„„FOR i& = x + 1 TO x2 - 1„  Box(Offset&).Char = CHR$(SCREEN(y, i&, 0))„  Box(Offset&).Col = (SCREEN(y, i&, 1))„  Offset& = Offset& + 1„  IF Blink = 1 THEN COLOR Col + 16„  LOCATE y, i&„  PRINT CHR$(SCREEN(y, i&));„NEXT„„FOR i& = x + 1 TO x2 - 1„  Box(Offset&).Char = CHR$(SCREEN(y2 - 1, i&, 0))„  Box(Offset&).Col = (SCREEN(y2 - 1, i&, 1))„  Offset& = Offset& + 1„  LOCATE y2 - 1, i&„  PRINT CHR$(SCREEN(y2 - 1, i&));„NEXT„„FOR i& = y TO y2 - 1„  Box(Offset&).Char = CHR$(SCREEN(i&, x, 0))„  Box(Offset&).Col = (SCREEN(i&, x, 1))„  Offset& = Offset& + 1„  LOCATE i&, x„  PRINT CHR$(SCREEN(i&, x));„NEXT„„FOR i& = y TO y2 - 1„  Box(Offset&).Char = CHR$(SCREEN(i&, x2, 0))„  Box(Offset&).Col = (SCREEN(i&, x2, 1))„  Offset& = Offset& + 1„  LOCATE i&, x2„  PRINT CHR$(SCREEN(i&, x2));„NEXT„„BoxX = x„BoxY = y„BoxX2 = x2„BoxY2 = y2„„„Hiiriesiin„END SUB„„SUB DrawButton (Num, Pressed)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF But(Num).Active = 0 THEN EXIT SUB„„Hiiripiiloon„„x = But(Num).x + Win(But(Num).Win).x + 1„y = But(Num).y + Win(But(Num).Win).y + 1„x2 = But(Num).x2 + Win(But(Num).Win).x + 1„y2 = But(Num).y2 + Win(But(Num).Win).y + 1„„IF Pressed = False THEN„  FOR i = y TO y2 - 1„    COLOR But(Num).FCol, But(Num).BCol„    LOCATE i, x„    PRINT STRING$(x2 - x, " ");„    COLOR 0, Win(But(Num).Win).BCol„    IF i = y THEN PRINT "‹";  ELSE PRINT "€";„  NEXT„  COLOR 0, Win(But(Num).Win).BCol„  LOCATE y2, x + 1„  PRINT STRING$(x2 - x, "ﬂ");„„  COLOR But(Num).FCol, But(Num).BCol„  LOCATE y + ((y2 - y) \ 2), x + ((x2 - x) \ 2) - RealLen(ButCaption$(Num)) \ 2„  ColPrint ButCaption$(Num)„ELSE„  FOR i = y TO y2 - 1„    LOCATE i, x„    COLOR 0, Win(But(Num).Win).BCol„    PRINT " ";„    COLOR But(Num).FCol, But(Num).BCol„    PRINT STRING$(x2 - x, " ");„  NEXT„  COLOR 0, Win(But(Num).Win).BCol„  LOCATE y2, x + 1„  PRINT STRING$(x2 - x, " ");„„„  COLOR But(Num).FCol, But(Num).BCol„  LOCATE y + ((y2 - y) \ 2), x + ((x2 - x) \ 2) - RealLen(ButCaption$(Num)) \ 2 + 1„  ColPrint ButCaption$(Num)„END IF„„IF TaskBar = True THEN DrawTaskBar„Hiiriesiin„END SUB„„SUB DrawCheckBox (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF CBox(Num).Active = 0 THEN EXIT SUB„„Hiiripiiloon„„x = CBox(Num).x + Win(CBox(Num).Win).x + 1„y = CBox(Num).y + Win(CBox(Num).Win).y + 1„„COLOR Win(CBox(Num).Win).FCol, Win(CBox(Num).Win).BCol„LOCATE y, x„IF CBox(Num).State = True THEN„  ColPrint "[˛] " + CBoxCaption$(Num)„ELSE„  ColPrint "[ ] " + CBoxCaption$(Num)„END IF„„IF TaskBar = True THEN DrawTaskBar„Hiiriesiin„END SUB„„SUB DrawDesk (x, y, x2, y2)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF x2 > 80 THEN x2 = 80„IF y2 > Lines + 1 THEN y2 = Lines + 1„COLOR DesktopFCol, DesktopBCol„FOR i& = y TO y2 - 1„  LOCATE i&, x„  PRINT STRING$(x2 - x + 1, DesktopChar$);„NEXT„END SUB„„SUB DrawFrame (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF Frame(Num).Active = 0 THEN EXIT SUB„„Hiiripiiloon„„x = Frame(Num).x + Win(Frame(Num).Win).x + 1„y = Frame(Num).y + Win(Frame(Num).Win).y + 1„x2 = Frame(Num).x2 + Win(Frame(Num).Win).x + 1„y2 = Frame(Num).y2 + Win(Frame(Num).Win).y + 1„„Box3D x, y, x2, y2, Frame(Num).Style, Frame(Num).FCol, Frame(Num).BCol, Win(Frame(Num).Win).BCol„COLOR Frame(Num).FCol, Frame(Num).BCol„LOCATE y, x + 2„ColPrint FrameCaption$(Num)„„IF TaskBar = True THEN DrawTaskBar„Hiiriesiin„END SUB„„SUB DrawLabel (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF Label(Num).Active = 0 THEN EXIT SUB„„Hiiripiiloon„„x = Label(Num).x + Win(Label(Num).Win).x + 1„y = Label(Num).y + Win(Label(Num).Win).y + 1„x2 = Label(Num).x2 + Win(Label(Num).Win).x + 1„y2 = Label(Num).y2 + Win(Label(Num).Win).y + 1„„Box3D x, y, x2, y2, Label(Num).Style, Label(Num).FCol, Label(Num).BCol, Win(Label(Num).Win).BCol„COLOR Label(Num).FCol, Label(Num).BCol„LOCATE y + 1, x + 1„PrintLine LabelCaption$(Num), (x2 - x) - 3„„IF TaskBar = True THEN DrawTaskBar„Hiiriesiin„„END SUB„„SUB DrawListBox (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF LBox(Num).Active = 0 THEN EXIT SUB„„x = LBox(Num).x + Win(LBox(Num).Win).x + 1„y = LBox(Num).y + Win(LBox(Num).Win).y + 1„x2 = LBox(Num).x2 + Win(LBox(Num).Win).x + 1„y2 = LBox(Num).y2 + Win(LBox(Num).Win).y + 1„„„Hiiripiiloon„„IF Win(LBox(Num).Win).x2 - Win(LBox(Num).Win).x <= 0 THEN Hiiriesiin: EXIT SUB„„IF LBox(Num).Total < 1 THEN„  Box3D x, y, x2, y2, Filled, LBox(Num).FCol, LBox(Num).BCol, 0„  Hiiriesiin„  EXIT SUB„END IF„„IF LBox(Num).Total = 0 THEN EXIT SUB„„„IF LBox(SelectedLBox).Selected > LBox(SelectedLBox).Total - 1 THEN LBox(SelectedLBox).Selected = LBox(SelectedLBox).Total - 1„IF LBox(SelectedLBox).Selected < 0 THEN LBox(SelectedLBox).Selected = 0„„„IF LBox(Num).Selected < LBox(Num).Offset THEN LBox(Num).Offset = LBox(Num).Offset - 1„IF LBox(Num).Offset < 0 THEN LBox(Num).Offset = 0: LBox(Num).Selected = 0„„IF LBox(Num).Selected > LBox(Num).Offset + (y2 - y - 1) THEN LBox(Num).Offset = LBox(Num).Offset + 1„IF LBox(Num).Offset > LBox(Num).Total THEN LBox(Num).Offset = LBox(Num).Total„„IF LBox(Num).ViewBox = True THEN„  LBox(Num).Offset = LBox(Num).Selected„  IF LBox(Num).Offset > LBox(Num).Total - (y2 - y) THEN LBox(Num).Offset = LBox(Num).Total - (y2 - y): LBox(Num).Selected = LBox(Num).Total - (y2 - y)„END IF„„VLine = LBox(Num).Offset„„IF LBox(Num).ViewBox = True THEN„  IF LBox(Num).Total > y2 - y THEN Block = y + 1 + ((LBox(Num).Selected / (LBox(Num).Total - (y2 - y)))) * (y2 - y - 3)„ELSE„  IF LBox(Num).Total > y2 - y THEN Block = y + 1 + ((LBox(Num).Selected / (LBox(Num).Total))) * (y2 - y - 3)„END IF„LBox(Num).Block = Block„„„IF LBox(Num).UseBuffer = 0 THEN„  IF Exist(LBoxFilename$(Num)) = False THEN EXIT SUB„  TempFile = FREEFILE„  OPEN LBoxFilename$(Num) FOR INPUT AS #TempFile„  SeekLine TempFile, LBox(Num).Offset„„  FOR i = y TO y2 - 1„    IF i > Lines THEN EXIT FOR„    IF NOT EOF(TempFile) THEN„      DO„        LINE INPUT #TempFile, TempLine$„      LOOP UNTIL TempLine$ <> "" OR EOF(TempFile)„      FOR ii = 1 TO LEN(TempLine$)„        IF MID$(TempLine$, ii, 1) = CHR$(9) THEN MID$(TempLine$, ii, 1) = " "„      NEXT„    ELSE„      TempLine$ = STRING$(x2 - x, " ")„    END IF„    IF VLine = LBox(Num).Selected AND LBox(Num).ViewBox = False THEN„      COLOR ActiveTopicF, ActiveTopicB„      SelectedName$(Num) = TempLine$„    ELSE„      COLOR LBox(Num).FCol, LBox(Num).BCol„    END IF„    LOCATE i, x, 0„    IF LBox(Num).Col = True THEN„      ColPrint LEFT$(TempLine$, x2 - x) + STRING$(x2 - x - RealLen(LEFT$(TempLine$, x2 - x)), " ")„    ELSE„      PRINT LEFT$(TempLine$, x2 - x) + STRING$(x2 - x - LEN(LEFT$(TempLine$, x2 - x)), " ");„    END IF„    COLOR 0, 7„    LOCATE i, x2, 0„    IF i > y AND i < y2 - 1 AND i <> Block AND (y2 - y) < LBox(Num).Total THEN„      PRINT "∞";„    END IF„    VLine = VLine + 1„    Dummy$ = INKEY$„  NEXT„  CLOSE #TempFile„ELSEIF LBox(Num).UseBuffer = 1 THEN„  BufPos = SeekBufferLine(Num, LBox(Num).Offset)„  FOR i = y TO y2 - 1„    IF i > Lines THEN EXIT FOR„    TempLine$ = ""„  „    IF VLine < LBox(Num).Total THEN„      DO„        IF BufPos > BufferSize THEN EXIT DO„        Char$ = CHR$(Buf(Num, BufPos))„        BufPos = BufPos + 1„        IF Char$ = CHR$(13) THEN EXIT DO„        TempLine$ = TempLine$ + Char$„      LOOP„      FOR ii = 1 TO LEN(TempLine$)„        IF MID$(TempLine$, ii, 1) = CHR$(9) THEN MID$(TempLine$, ii, 1) = " "„      NEXT„    ELSE„      TempLine$ = STRING$(x2 - x, " ")„    END IF„    BufPos = BufPos + 1„„    IF VLine = LBox(Num).Selected AND LBox(Num).ViewBox = False THEN„      COLOR ActiveTopicF, ActiveTopicB„      SelectedName$(Num) = RTRIM$(TempLine$)„    ELSE„      COLOR LBox(Num).FCol, LBox(Num).BCol„    END IF„    LOCATE i, x, 0„    IF LBox(Num).Col = True THEN„      ColPrint LEFT$(TempLine$, x2 - x) + STRING$(x2 - x - RealLen(LEFT$(TempLine$, x2 - x)), " ")„    ELSE„      PRINT LEFT$(TempLine$, x2 - x) + STRING$(x2 - x - LEN(LEFT$(TempLine$, x2 - x)), " ");„    END IF„    COLOR 0, 7„    LOCATE i, x2, 0„    IF i > y AND i < y2 - 1 AND i <> Block AND (y2 - y) < LBox(Num).Total THEN„      PRINT "∞";„    END IF„    VLine = VLine + 1„    Dummy$ = INKEY$„  NEXT„END IF„„  COLOR 0, 7„  LOCATE y, x2„  PRINT CHR$(24);„  LOCATE y2 - 1, x2„  PRINT CHR$(25);„„IF (y2 - y) < LBox(Num).Total THEN„  LOCATE Block, x2„  PRINT "€";„END IF„„Hiiriesiin„IF TaskBar = True THEN DrawTaskBar„„END SUB„„SUB DrawMenu (WindowNum)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„„Hiiripiiloon„x = Win(WindowNum).x + 1„y = Win(WindowNum).y + 1„x2 = Win(WindowNum).x2„LOCATE y, x - 1„COLOR 0, 7„PRINT STRING$(x2 - x + 2, " ")„LOCATE y, x, 0„„FOR i = 1 TO 8„  IF i = AMenu THEN COLOR 7, 0 ELSE COLOR 0, 7„  IF MenuBar(WindowNum, i).Items > 0 THEN„    PRINT MenuBar(WindowNum, i).Caption;„  END IF„NEXT„„Hiiriesiin„Hiiriesiin„„END SUB„„SUB DrawMenuBox (WindowNum, Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF MenuBar(WindowNum, Num).Items = 0 THEN EXIT SUB„„Hiiripiiloon„„x = Win(WindowNum).x + ((Num - 1) * 10) + 1„y = Win(WindowNum).y + 2„„Longest = MenuBar(WindowNum, Num).Longest„IF Longest < 10 THEN Longest = 10: MenuBar(WindowNum, Num).Longest = 10„„Box3D x, y, x + Longest + 2 + 2, y + MenuBar(WindowNum, Num).Items + 1, SingleNormal, 0, 7, 0„„FOR i = 1 TO MenuBar(WindowNum, Num).Items„  IF y + i > Lines THEN EXIT FOR„  IF MenuItem = i THEN COLOR 7, 0 ELSE COLOR 0, 7„  LOCATE y + i, x + 1, 0„  IF Menu$(WindowNum, Num, i) <> "" THEN„    PRINT " "; Menu$(WindowNum, Num, i);„    PRINT STRING$(Longest + 1 - LEN(Menu$(WindowNum, Num, i)), " ");„  ELSE„    LOCATE y + i, x, 0„    PRINT "√" + STRING$(Longest + 2, "ƒ") + "¥";„  END IF„NEXT„DrawShadow x, y, x + Longest + 3, y + MenuBar(WindowNum, Num).Items + 2„„„Hiiriesiin„END SUB„„SUB DrawMenuItems (WindowNum, Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„x = Win(WindowNum).x + ((Num - 1) * 10) + 1„y = Win(WindowNum).y + 2„„Longest = MenuBar(WindowNum, Num).Longest„IF Longest < 10 THEN Longest = 10„„„FOR i = 1 TO MenuBar(WindowNum, Num).Items„  IF y + i > Lines THEN EXIT FOR„  IF MenuItem = i THEN COLOR 7, 0 ELSE COLOR 0, 7„  LOCATE y + i, x + 1, 0„  IF Menu$(WindowNum, Num, i) <> "" THEN„    PRINT " "; Menu$(WindowNum, Num, i);„    PRINT STRING$(Longest + 1 - LEN(Menu$(WindowNum, Num, i)), " ");„  ELSE„    LOCATE y + i, x, 0„    PRINT "√" + STRING$(Longest + 2, "ƒ") + "¥";„  END IF„NEXT„„„END SUB„„SUB DrawPBar (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF PBar(Num).Active = 0 THEN EXIT SUB„„„x = PBar(Num).x + Win(PBar(Num).Win).x + 1„y = PBar(Num).y + Win(PBar(Num).Win).y + 1„x2 = PBar(Num).x2 + Win(PBar(Num).Win).x + 1„PBar(Num).OldValue = PBar(Num).Value„„IF Hx >= x AND Hx <= x2 AND Hy = y THEN Hiiripiiloon„„LOCATE y, x, 0„„XLen = (PBar(Num).Value / PBar(Num).Max) * 100 * ((x2 - x) / 100)„IF XLen > x2 - x THEN XLen = x2 - x„IF XLen < 0 THEN XLen = 0„„COLOR PBar(Num).UsedCol, 0„PRINT STRING$(XLen, "€");„COLOR 0, PBar(Num).FreeCol„PRINT STRING$((x2 - x) - XLen, "∞");„„Hiiriesiin„„END SUB„„SUB DrawRadio (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF Radio(Num).Active = 0 THEN EXIT SUB„„Hiiripiiloon„„x = Radio(Num).x + Win(Radio(Num).Win).x + 1„y = Radio(Num).y + Win(Radio(Num).Win).y + 1„„COLOR Win(Radio(Num).Win).FCol, Win(Radio(Num).Win).BCol„LOCATE y, x„IF Radio(Num).State = True THEN„  ColPrint "(" + CHR$(4) + ") " + RadioCaption$(Num)„ELSE„  ColPrint "( ) " + RadioCaption$(Num)„END IF„„IF TaskBar = True THEN DrawTaskBar„Hiiriesiin„„END SUB„„SUB DrawShadow (x, y, x2, y2)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„YLen = y2 - y„XLen = x2 - x + 1„„IF x2 < 80 THEN„FOR i& = y + 1 TO YLen + y„  IF i& = Lines + 1 THEN EXIT FOR„  Char$ = CHR$(SCREEN(i&, x + XLen, 0))„  Col = (SCREEN(i&, x + XLen, 1))„  IF Col < 128 THEN„    Col = Col MOD 16„    Blink = 0„  ELSE„    Col = Col MOD 16„    Blink = 1„  END IF„„  IF Blink = 1 THEN COLOR 16, 0 ELSE COLOR 8, 0„„  LOCATE i&, x + XLen„  PRINT Char$;„„  IF x + XLen + 1 < 81 THEN„  Char$ = CHR$(SCREEN(i&, x + XLen + 1, 0))„  Col = (SCREEN(i&, x + XLen + 1, 1))„  IF Col < 128 THEN„    Col = Col MOD 16„    Blink = 0„  ELSE„    Col = Col MOD 16„    Blink = 1„  END IF„„  IF Blink = 1 THEN COLOR 16, 0 ELSE COLOR 8, 0„  PRINT Char$;„  END IF„NEXT„END IF„„IF y2 < Lines + 1 THEN„FOR i& = x + 2 TO XLen + x - 1„  LOCATE y + YLen, i&„  Char$ = CHR$(SCREEN(y + YLen, i&, 0))„  Col = (SCREEN(y + YLen, i&, 1))„  IF Col < 128 THEN„    Col = Col MOD 16„    Blink = 0„  ELSE„    Col = Col MOD 16„    Blink = 1„  END IF„„  IF Blink = 1 THEN COLOR 16, 0 ELSE COLOR 8, 0„„  LOCATE y + YLen, i&„  PRINT Char$;„NEXT„END IF„„„END SUB„„SUB DrawTaskBar„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„Hiiripiiloon„„Windows = 0„FOR i = 1 TO MaxWindows„  IF Win(i).x > 0 AND Win(i).x2 - Win(i).x > 0 THEN„    Windows = Windows + 1„  END IF„NEXT„„x = 12„y = Lines„LOCATE y, 1„COLOR 0, 0„PRINT STRING$(10, ".");„COLOR 0, 7„PRINT STRING$(70, " ");„„FOR xx = 11 TO 71 STEP 10„  LOCATE y, xx„  PRINT "≥";„NEXT„„FOR i = 1 TO Windows„  LOCATE y, x„  IF AWin = i THEN„    COLOR 15, 1„  ELSE„    COLOR 0, 7„  END IF„  PRINT LEFT$(WinTopic$(i), 9) + STRING$(9 - LEN(LEFT$(WinTopic$(i), 9)), " ");„  x = x + 10„  IF x = 72 THEN„    x = 12„    y = y - 1„    LOCATE y, 1„    COLOR 0, 0„    PRINT STRING$(10, ".");„    COLOR 0, 7„    PRINT STRING$(70, " ");„    COLOR 0, 7„    FOR xx = 11 TO 71 STEP 10„      LOCATE y, xx„      PRINT "≥";„    NEXT„  END IF„NEXT„TaskBarLine = y„„COLOR 4, 0„LOCATE Lines, 1„PRINT "˛";„COLOR 1„PRINT "W";„COLOR 1„PRINT "I";„COLOR 9„PRINT "N";„COLOR 3„PRINT "D";„COLOR 11„PRINT "O";„COLOR 15„PRINT "Z";„COLOR 15„PRINT "E";„COLOR 4„PRINT "˛ ";„COLOR 0, 7„PRINT " ";„„LOCATE Lines, 73, 0„COLOR 4, 7„PRINT TIME$;„„Hiiriesiin„„END SUB„„SUB DrawTextField (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF TextF(Num).Active = 0 THEN EXIT SUB„„IF Win(TextF(Num).Win).x2 - Win(TextF(Num).Win).x <= 0 THEN EXIT SUB„„Hiiripiiloon„„x = TextF(Num).x + Win(TextF(Num).Win).x + 1„y = TextF(Num).y + Win(TextF(Num).Win).y + 1„„COLOR TextF(Num).FCol, TextF(Num).BCol„LOCATE y, x„IF TextF(Num).Password = False THEN„  PRINT TextFText$(Num) + STRING$(TextF(Num).MaxLen - LEN(TextFText$(Num)), " ")„ELSE„  PRINT STRING$(LEN(TextFText$(Num)), "*") + STRING$(TextF(Num).MaxLen - LEN(TextFText$(Num)), " ")„END IF„„IF TextF(Num).TPos > LEN(TextFText$(Num)) THEN TextF(Num).TPos = LEN(TextFText$(Num))„„IF TaskBar = True THEN DrawTaskBar„Hiiriesiin„„END SUB„„SUB DrawWindow (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„Hiiripiiloon„„x = Win(Num).x„y = Win(Num).y„x2 = Win(Num).x2„y2 = Win(Num).y2„FCol = Win(Num).FCol„BCol = Win(Num).BCol„Topic$ = WinTopic$(Num)„„IF x2 < x THEN SWAP x2, x„IF y2 < y THEN SWAP y2, y„IF x2 > 80 THEN x2 = 80„IF y2 > Lines + 1 THEN y2 = Lines + 1„IF x < 1 THEN x = 1„IF y < 1 THEN y = 1„„XLen = x2 - x + 1„YLen = y2 - y„UpLine$ = STRING$(XLen, CHR$(32))„IF LEN(Topic$) > XLen THEN Topic$ = LEFT$(Topic$, XLen)„MID$(UpLine$, (XLen \ 2) - LEN(Topic$) \ 2 + 1) = Topic$„„LOCATE y, x„IF AWin = Num THEN COLOR ActiveTopicF, ActiveTopicB ELSE COLOR DeActiveTopicF, DeActiveTopicB„PRINT UpLine$;„COLOR FCol, BCol„„FOR i& = 1 TO YLen - 2„  LOCATE y + i&, x„  PRINT CHR$(179) + STRING$(XLen - 2, " ") + CHR$(179);„NEXT„„LOCATE y + i&, x„PRINT CHR$(192) + STRING$(XLen - 2, CHR$(196)) + CHR$(217);„„DrawShadow x, y, x2, y2„„FOR i = 1 TO 8„  IF MenuBar(Num, i).Items > 0 THEN DrawMenu Num:  EXIT SUB„NEXT„„Hiiriesiin„END SUB„„FUNCTION DSPVersion!„' Gets the DSP version.„writedsp &HE1„Temp% = ReadDSP%„Temp2% = ReadDSP%„DSPVersion! = VAL(STR$(Temp%) + "." + STR$(Temp2%))„END FUNCTION„„SUB EraseBox„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„Hiiripiiloon„Offset& = 1„x = BoxX„y = BoxY„x2 = BoxX2„y2 = BoxY2„„FOR i& = x + 1 TO x2 - 1„  Char$ = Box(Offset&).Char„  Col = Box(Offset&).Col„  Offset& = Offset& + 1„„  IF Col < 128 THEN„    FCol = Col MOD 16„    BCol = Col \ 16„    Blink = 0„  ELSE„    FCol = (Col MOD 16) + 16„    BCol = Col \ 16„    Blink = 1„  END IF„  COLOR FCol, BCol„„  LOCATE y, i&„  PRINT Char$;„NEXT„„FOR i& = x + 1 TO x2 - 1„  Char$ = Box(Offset&).Char„  Col = Box(Offset&).Col„  Offset& = Offset& + 1„„  IF Col < 128 THEN„    FCol = Col MOD 16„    BCol = Col \ 16„    Blink = 0„  ELSE„    FCol = (Col MOD 16) + 16„    BCol = Col \ 16„    Blink = 1„  END IF„  COLOR FCol, BCol„  LOCATE y2 - 1, i&„  PRINT Char$;„NEXT„„FOR i& = y TO y2 - 1„  Char$ = Box(Offset&).Char„  Col = Box(Offset&).Col„  Offset& = Offset& + 1„„  IF Col < 128 THEN„    FCol = Col MOD 16„    BCol = Col \ 16„    Blink = 0„  ELSE„    FCol = (Col MOD 16) + 16„    BCol = Col \ 16„    Blink = 1„  END IF„  COLOR FCol, BCol„  LOCATE i&, x„  PRINT Char$;„NEXT„„FOR i& = y TO y2 - 1„  Char$ = Box(Offset&).Char„  Col = Box(Offset&).Col„  Offset& = Offset& + 1„„  IF Col < 128 THEN„    FCol = Col MOD 16„    BCol = Col \ 16„    Blink = 0„  ELSE„    FCol = (Col MOD 16) + 16„    BCol = Col \ 16„    Blink = 1„  END IF„  COLOR FCol, BCol„  LOCATE i&, x2„  PRINT Char$;„NEXT„„Hiiriesiin„„END SUB„„FUNCTION Exist% (File$)„'----------------------------------------------------------------------------„'                       Checks if a file exists„'----------------------------------------------------------------------------„'„'    File$ - File to check„'„'----------------------------------------------------------------------------„'  Returns True if file exists, else False„'----------------------------------------------------------------------------„„„IF File$ = "" THEN Exist = False: EXIT FUNCTION„Checkfile = FREEFILE„OPEN File$ FOR BINARY AS #Checkfile„IF LOF(Checkfile) = 0 THEN„  Exist = False„  CLOSE #Checkfile„  KILL File$„ELSE„  Exist = True„  CLOSE #Checkfile„END IF„„END FUNCTION„„FUNCTION FDialog$ (Text$, StartDir$, StartFile$)„'----------------------------------------------------------------------------„' Initializes a FileSaveDialog„'----------------------------------------------------------------------------„'     Text$ - Prompt text„' StartDir$ - Startup directory„'StartFile$ - Default filename„'----------------------------------------------------------------------------„' Returns blank, if user selected "Cancel"„'----------------------------------------------------------------------------„„IF PlayingWAV& = True THEN EXIT FUNCTION„„Dir$ = UCASE$(StartDir$)„IF Dir$ = "" THEN Dir$ = "c:\"„IF RIGHT$(Dir$, 1) <> "\" THEN Dir$ = Dir$ + "\"„CreateWindow MaxWindows + 1, 15, 4, 65, 23, 15, 7, Dir$„CreateButton MaxWindows + 1, MaxButtons + 1, 38, 2, 8, 3, "OK", 15, 4„CreateButton MaxWindows + 1, MaxButtons + 2, 38, 7, 8, 3, "Cancel", 15, 4„CreateFrame MaxWindows + 1, MaxFrames + 1, 1, 1, 16, 4, "Filename", SingleNormal, 0, 7„CreateFrame MaxWindows + 1, MaxFrames + 2, 19, 1, 15, 11, "Dirs/Drives", SingleNormal, 0, 7„CreateLabel MaxWindows + 1, MaxLabels + 1, 0, 13, 49, 3, SingleNormal, 0, 7, Text$„CreateTextField MaxWindows + 1, MaxTextFields + 1, 3, 3, 12, 16, 7, StartFile$, False„„IF FileSpec$ = "" THEN FileSpec$ = "*.*"„ReadDir2 Dir$„„AText = MaxTextFields + 1„OldAWin = AWin„AWin = MaxWindows + 1„LockWindows = True„ReDrawScreen„„DO„  UpdateMouse„  Main„„  IF SelectedLBox = MaxListBoxes + 2 AND SelectedItem <> 0 THEN„    IF INSTR(SelectedName$(MaxListBoxes + 2), ":") > 0 THEN„      Dir$ = SelectedName$(MaxListBoxes + 2)„    ELSEIF INSTR(SelectedName$(MaxListBoxes + 2), ".") > 0 THEN„      FOR i = LEN(Dir$) - 1 TO 1 STEP -1„        IF MID$(Dir$, i, 1) = "\" THEN EXIT FOR„      NEXT„      Dir$ = LEFT$(Dir$, i)„    ELSE„      Dir$ = Dir$ + SelectedName$(MaxListBoxes + 2) + "\"„    END IF„    ReadDir2 Dir$„    WinTopic$(MaxWindows + 1) = Dir$„    ReDrawScreen„  END IF„  Hiiriesiin„„  IF EnterText = MaxTextFields + 1 THEN EXIT DO„„LOOP UNTIL ClickedButton > MaxButtons„„IF ClickedButton = MaxButtons + 1 THEN„  IF TextFText$(MaxTextFields + 1) <> "" THEN FDialog$ = UCASE$(Dir$ + TextFText$(MaxTextFields + 1))„ELSEIF ClickedButton = MaxButtons + 2 THEN„  FDialog$ = ""„END IF„„KillWindow MaxWindows + 1„LockWindows = False„AWin = OldAWin„ReDrawScreen„„END FUNCTION„„SUB FMVolume (right%, Left%, Getvol%)„'----------------------------------------------------------------------------„' Sets the FM-volume on the Sound Blaster card„'----------------------------------------------------------------------------„'„'  Right% - Right volume„'   Left% - Left volume„' Getvol% - If true, then volume will be read, not set„'„'----------------------------------------------------------------------------„„OUT BasePort% + 4, &H26„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (right% + Left% * 16) AND &HFF„END IF„END SUB„„FUNCTION FSelect$ (Text$, StartDir$, FileSpec$)„'----------------------------------------------------------------------------„' Initializes a FileBrowseDialog„'----------------------------------------------------------------------------„'     Text$ - Prompt text„' StartDir$ - Startup directory„' FileSpec$ - Filespec (ie "*.TXT", "*.*" for all files)„'----------------------------------------------------------------------------„' Returns blank, if user selected "Cancel"„'----------------------------------------------------------------------------„„IF PlayingWAV& = True THEN EXIT FUNCTION„„Dir$ = UCASE$(StartDir$)„IF Dir$ = "" THEN Dir$ = "c:\"„IF RIGHT$(Dir$, 1) <> "\" THEN Dir$ = Dir$ + "\"„CreateWindow MaxWindows + 1, 15, 4, 65, 23, 15, 7, Dir$ + FileSpec$„CreateButton MaxWindows + 1, MaxButtons + 1, 38, 2, 8, 3, "OK", 15, 4„CreateButton MaxWindows + 1, MaxButtons + 2, 38, 7, 8, 3, "Cancel", 15, 4„CreateFrame MaxWindows + 1, MaxFrames + 1, 1, 1, 15, 11, "Files", SingleNormal, 0, 7„CreateFrame MaxWindows + 1, MaxFrames + 2, 19, 1, 15, 11, "Dirs/Drives", SingleNormal, 0, 7„CreateLabel MaxWindows + 1, MaxLabels + 1, 0, 13, 49, 3, SingleNormal, 0, 7, Text$„„IF FileSpec$ = "" THEN FileSpec$ = "*.*"„ReadDir Dir$, FileSpec$„„OldAWin = AWin„AWin = MaxWindows + 1„LockWindows = True„ReDrawScreen„„DO„  UpdateMouse„  Main„„  IF SelectedLBox = MaxListBoxes + 2 AND SelectedItem <> 0 THEN„    IF INSTR(SelectedName$(MaxListBoxes + 2), ":") > 0 THEN„      Dir$ = SelectedName$(MaxListBoxes + 2)„    ELSEIF INSTR(SelectedName$(MaxListBoxes + 2), ".") > 0 THEN„      FOR i = LEN(Dir$) - 1 TO 1 STEP -1„        IF MID$(Dir$, i, 1) = "\" THEN EXIT FOR„      NEXT„      Dir$ = LEFT$(Dir$, i)„    ELSE„      Dir$ = Dir$ + SelectedName$(MaxListBoxes + 2) + "\"„    END IF„    ReadDir Dir$, FileSpec$„    WinTopic$(MaxWindows + 1) = Dir$ + FileSpec$„    ReDrawScreen„  END IF„  Hiiriesiin„„  IF SelectedLBox = MaxListBoxes + 1 AND SelectedItem <> 0 THEN„    FSelect$ = Dir$ + SelectedName$(MaxListBoxes + 1)„    EXIT DO„  END IF„  „LOOP UNTIL ClickedButton > MaxButtons„„IF ClickedButton = MaxButtons + 1 THEN„  IF SelectedName$(MaxListBoxes + 1) <> "" THEN FSelect$ = Dir$ + SelectedName$(MaxListBoxes + 1)„ELSEIF ClickedButton = MaxButtons + 2 THEN„  FSelect$ = ""„END IF„„KillWindow MaxWindows + 1„LockWindows = False„AWin = OldAWin„ReDrawScreen„„END FUNCTION„„SUB GetBLASTER (DMA%, BasePort%, IRQ%)„'----------------------------------------------------------------------------„' This subroutine parses the BLASTER environment string and returns settings.„'----------------------------------------------------------------------------„„IF LEN(ENVIRON$("BLASTER")) = 0 THEN PRINT "BLASTER environment variable not set.": EXIT SUB„FOR Length% = 1 TO LEN(ENVIRON$("BLASTER"))„   SELECT CASE MID$(ENVIRON$("BLASTER"), Length%, 1)„      CASE "A"„        BasePort% = VAL("&H" + MID$(ENVIRON$("BLASTER"), Length% + 1, 3))„      CASE "I"„        IRQ% = VAL(MID$(ENVIRON$("BLASTER"), Length% + 1, 1))„      CASE "D"„        DMA% = VAL(MID$(ENVIRON$("BLASTER"), Length% + 1, 1))„   END SELECT„NEXT„„END SUB„„FUNCTION GetFileAttr% (Filename$)„'=======================================================================„'Name:          GetFileAttr%„'Purpose:       This routine returns the attribute of a specified file„'=======================================================================„    DEF SEG = VARSEG(Code(0))                   ' point to QINT code„    Regs.ax = &H4300                            ' specify get attribute„    TheString$ = Filename$ + CHR$(0)            ' add a NUL byte for DOS„    Regs.dx = VARPTR(TheString$)                ' DX points to the string„    Regs.ds = VARSEG(TheString$)                ' DS point to segment„    CALL absolute(&H21, Regs, 0)                ' get attribute in CX reg„    GetFileAttr% = Regs.cx AND &HFF             ' get file attribute„    IF Regs.Flags AND 1 THEN GetAttr% = -1      ' if carry set, then cough„    DEF SEG                                     ' return from hyper-space„„END FUNCTION„„DEFSNG A-Z„SUB Hiiriajuri (ax%, bx%, cx%, dx%)„  DEF SEG = VARSEG(hiiri$)                  'Segmentti talteen„  hiiri% = SADD(hiiri$)                     'Offsetti talteen„  CALL absolute(ax%, bx%, cx%, dx%, hiiri%) 'Kutsu„END SUB„„SUB Hiiriesiin„  ax% = 1                   'Funktio 1„  Hiiriajuri ax%, 0, 0, 0   'Kutsutaan hiiriajuria„END SUB„„SUB Hiirilue (vasen%, oikea%, keski%, x%, y%)„  ax% = 3                         'Funktio 3„  Hiiriajuri ax%, bx%, cx%, dx%   'Kutsutaan hiiriajuria„  vasen% = ((bx% AND 1) <> 0)      'Luetaan nappien asennot„  oikea% = ((bx% AND 2) <> 0)      'bx:stÑ„  keski% = ((bx% AND 4) <> 0)„  x% = cx%                        'ja hiiren koordinaatit„  y% = dx%                        'cx:stÑ ja dx:stÑ„END SUB„„SUB Hiiripiiloon„  ax% = 2                   'Funktio 2„  Hiiriajuri ax%, 0, 0, 0   'Kutsutaan hiiriajuria„END SUB„„SUB Hiirirajat (x1%, y1%, x2%, y2%)„  ax% = 7                         'Funktio 7„  cx% = x1%                       'Rajat cx:ÑÑn ja dx:ÑÑn„  dx% = x2%„  Hiiriajuri ax%, 0, cx%, dx%     'Kutsutaan hiiriajuria„  ax% = 8                         'Funktio 8„  cx% = y1%                       'Rajat cx:ÑÑn ja dx:ÑÑn„  dx% = y2%„  Hiiriajuri ax%, 0, cx%, dx%     'Kutsutaan hiiriajuria„END SUB„„FUNCTION Hiiritarkista%„  ax% = 0                        'Funktio 0„  Hiiriajuri ax%, bx%, 0, 0      'Kutsutaan hiiriajuria„  IF (ax% = 0) THEN              'Onko ajuri kÑytîssÑ?„    Hiiritarkista% = 0           'jos ei, palautetaan 0„  ELSEIF (bx% = 3) THEN          'Kolminappinen hiiri?„    Hiiritarkista% = 3„  ELSEIF (bx% = 0) THEN          'EpÑstandardi hiiri?„    Hiiritarkista% = 1„  ELSE„    Hiiritarkista% = 2           'Tavallinen kaksinappinen hiiri?„  END IF„END FUNCTION„„DEFINT A-Z„SUB Initscreen„'----------------------------------------------------------------------------„' Initializes the application„'----------------------------------------------------------------------------„' Place all your create???? statements here„'----------------------------------------------------------------------------„CreateWindow 1, 10, 20, 60, 34, 15, 7, "Player"„CreateWindow 2, 40, 30, 73, 47, 15, 3, "Config"„„'If using QBasic v1.1, change the COMMAND$ below to ""„CreateTextField 1, 1, 4, 3, 40, 16, 7, COMMAND$, False„„CreateFrame 1, 1, 2, 1, 45, 10, "Filename", SingleNormal, 0, 7„CreateFrame 1, 2, 4, 3, 40, 1, "", Float, 7, 0„„CreateButton 1, 1, 18, 7, 10, 3, "Play " + CHR$(16), 15, 2„CreateButton 1, 2, 34, 5, 10, 1, "Browse...", 15, 3„„CreateFrame 2, 4, 1, 1, 30, 7, "Playback rate", SingleNormal, 0, 3„CreateFrame 2, 5, 1, 9, 30, 5, "Volume", SingleNormal, 0, 3„„CreateRadioButton 2, 1, 3, 3, False, 1, "8000"„CreateRadioButton 2, 2, 3, 4, False, 1, "11025"„CreateRadioButton 2, 3, 3, 5, False, 1, "16000"„CreateRadioButton 2, 4, 3, 6, True, 1, "22050"„„CreateRadioButton 2, 5, 15, 3, False, 1, "32000"„CreateRadioButton 2, 6, 15, 4, False, 1, "38000"„CreateRadioButton 2, 7, 15, 5, False, 1, "44100"„„CreatePBar 1, 1, 4, 5, 28, 10, 7, 1000000, 0„„CreateButton 2, 5, 3, 11, 3, 1, "+", 14, 4„CreateButton 2, 6, 8, 11, 3, 1, "-", 14, 4„„MasterVolume 15, 15, False„CreateLabel 2, 1, 16, 10, 4, 3, Float, 16, 6, "15"„„CreateWindow 3, 1, 1, 50, 19, 7, 1, "Textmode Windoze"„CreateMenu 3, 1, "Menu"„CreateMenu 3, 2, "Help"„AddMenuItem 3, 1, "Sample Item"„AddMenuItem 3, 1, "Another Sample Item"„AddMenuItem 3, 1, "Yet Another Sample Item"„AddMenuItem 3, 1, "Return of the Sample Item"„AddMenuItem 3, 1, ""„AddMenuItem 3, 1, "Quit"„„AddMenuItem 3, 2, "About"„AddMenuItem 3, 2, "About Taskbar"„AddMenuItem 3, 2, "Contacting the Author"„AddMenuItem 3, 2, ""„AddMenuItem 3, 2, "Free memory"„„CreateButton 3, 7, 2, 2, 17, 1, "Sample Button", 15, 3„                 „CreateButton 3, 8, 2, 5, 16, 3, "&4C&Co&El&Fo&Ar&2s", 15, 7„„CreateFrame 3, 6, 0, 9, 48, 6, "TextFields", SingleNormal, 7, 1„CreateTextField 3, 2, 2, 11, 40, 16, 7, "Textfield", False„CreateTextField 3, 3, 2, 13, 20, 16, 7, "Password", True„„OPEN "TEMP.TMP" FOR OUTPUT AS #1„„PRINT #1, "Item 1"„PRINT #1, "Item 2"„PRINT #1, "Item 3"„PRINT #1, "Item 4"„PRINT #1, "&1C&9o&3l&Bo&Frs"„PRINT #1, "&9Blue"„PRINT #1, "&AGreen"„PRINT #1, "&BCyan"„PRINT #1, "&CRed"„PRINT #1, "&DPink"„PRINT #1, "&EYellow"„PRINT #1, "&FWhite"„CLOSE #1„„CreateListBox 3, 1, 24, 2, 16, 6, "TEMP.TMP", 0, 7, 0, False, True„„CreateWindow 4, 1, 40, 80, 48, 7, 1, "Mini text viewer"„CreateMenu 4, 1, "File"„AddMenuItem 4, 1, "Open..."„AddMenuItem 4, 1, "Save...(Demo)"„„CreateWindow 5, 57, 1, 80, 9, 14, 2, "Windoze"„„CreatePBar 5, 2, 1, 1, 20, 14, 7, 80, 40„CreatePBar 5, 3, 1, 3, 20, 14, 7, INT(Lines), Lines \ 2„CreateCheckBox 5, 1, 1, 5, True, "Active"„„CreateButton 3, 3, 26, 13, 14, 1, "Question", 15, 4„END SUB„„FUNCTION InputField$ (Text$, Key$, MaxLen, TPos)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF Key$ = "" THEN InputField$ = Text$: EXIT FUNCTION„„SELECT CASE Key$„CASE IS = CHR$(8)„  IF LEN(Text$) > 0 THEN„    Text$ = LEFT$(Text$, TPos - 1) + MID$(Text$, TPos + 1, 255)„    TPos = TPos - 1„    IF TPos = -1 THEN TPos = 0„    Key$ = ""„  ELSE„    Key$ = ""„  END IF„CASE IS = CHR$(0) + CHR$(75)„  IF TPos > 0 THEN TPos = TPos - 1„  Key$ = ""„CASE IS = CHR$(0) + CHR$(77)„  TPos = TPos + 1„  IF TPos > MaxLen THEN TPos = MaxLen„  IF TPos > LEN(Text$) THEN TPos = LEN(Text$)„  Key$ = ""„CASE IS = CHR$(0) + "S"„  Text$ = LEFT$(Text$, TPos) + MID$(Text$, TPos + 2, 255)„  Key$ = ""„CASE IS = CHR$(9)„  Key$ = ""„END SELECT„„IF LEFT$(Key$, 1) = CHR$(0) THEN Key$ = ""„„IF Key$ <> "" THEN„  Text$ = LEFT$(Text$, TPos) + Key$ + MID$(Text$, TPos + 1, 255)„  IF LEN(Text$) > MaxLen THEN Text$ = LEFT$(Text$, MaxLen)„  TPos = TPos + 1„  IF TPos > MaxLen THEN TPos = MaxLen„END IF„„InputField$ = Text$„„END FUNCTION„„SUB KillWindow (Num)„'----------------------------------------------------------------------------„' Removes a window with the index number of Num„'----------------------------------------------------------------------------„„Win(Num).x = -1024„Win(Num).y = -1024„Win(Num).x2 = Win(Num).x„IF TextF(AText).Win = Num THEN CursorX = 0: CursorY = 0„„FOR i = 1 TO MaxFrames + 2„  IF Frame(i).Win = Num THEN„    Frame(i).Active = 0„  END IF„NEXT„„FOR i = 1 TO MaxCheckBoxes„  IF CBox(i).Win = Num THEN„    CBox(i).Active = 0„  END IF„NEXT„„„FOR i = 1 TO MaxRadioButtons„  IF Radio(i).Win = Num THEN„    Radio(i).Active = 0„  END IF„NEXT„„FOR i = 1 TO MaxLabels + 1„  IF Label(i).Win = Num THEN„    Label(i).Active = 0„  END IF„NEXT„„FOR i = 1 TO MaxListBoxes + 2„  IF LBox(i).Win = Num THEN„    LBox(i).Active = 0„  END IF„NEXT„„FOR i = 1 TO MaxTextFields + 1„  IF TextF(i).Win = Num THEN„    TextF(i).Active = 0„  END IF„NEXT„„FOR i = 1 TO MaxButtons + 3„  IF But(i).Win = Num THEN„    But(i).Active = 0„  END IF„NEXT„„FOR i = 1 TO MaxPBars„  IF PBar(i).Win = Num THEN„    PBar(i).Active = 0„  END IF„NEXT„„„ReDrawScreen„„END SUB„„SUB LineVolume (right%, Left%, Getvol%)„'----------------------------------------------------------------------------„' Sets the Line in-volume on the Sound Blaster card„'----------------------------------------------------------------------------„'„'  Right% - Right volume„'   Left% - Left volume„' Getvol% - If true, then volume will be read, not set„'„'----------------------------------------------------------------------------„„OUT BasePort% + 4, &H2E„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (right% + Left% * 16) AND &HFF„END IF„END SUB„„DEFSNG A-Z„SUB Main„'----[TWIN.BAS (C) Sami KyîstilÑ 1997]----------------------------------------„'            ⁄ƒƒƒƒƒƒø⁄ƒƒø⁄ƒƒƒƒƒø⁄ƒƒƒƒø  ⁄ƒƒƒø ⁄ƒƒƒƒø⁄ƒƒƒƒø„'            ≥€∞  €∞≥≥€∞≥≥€∞ €∞≥≥€€€∞¿ø⁄Ÿ€€∞¿ø≥€€€∞≥≥€€€∞≥„'            ≥€∞  €∞≥√ƒƒ¥≥€∞ €∞≥≥€∞ €∞≥≥€∞ €∞≥≥  €∞≥≥€∞  ≥„'     ˙ ˙˙ƒ˙ƒ¥€∞  €∞√¥€∞√¥€€∞€∞√¥€∞ €∞√¥€∞ €∞√¥ €∞ √¥€€∞ √ƒ˙ƒ˙˙ ˙„'            ≥€∞€∞€∞≥≥€∞≥≥€∞€€∞≥≥€∞ €∞≥≥€∞ €∞≥≥€∞  ≥≥€∞  ≥„'            ≥€€∞€€∞≥≥€∞≥≥€∞ €∞≥≥€€€∞⁄Ÿ¿ø€€∞⁄Ÿ≥€€€∞≥≥€€€∞≥„'            ¿ƒƒƒƒƒƒŸ¿ƒƒŸ¿ƒƒƒƒƒŸ¿ƒƒƒƒŸ  ¿ƒƒƒŸ ¿ƒƒƒƒŸ¿ƒƒƒƒŸ„'„'                            E˙N˙G˙I˙N˙E„'„'                            ::[V1.00]::„'„'                [T˙E˙X˙T˙M˙O˙D˙E]-[V˙E˙R˙S˙I˙O˙N]„'„'                  ⁄ƒƒƒø ⁄ƒƒƒƒƒƒƒø ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„'         ˙ ˙˙ƒ˙ƒƒƒ¥(C)√ƒ¥S˙A˙M˙i√ƒ¥K˙Y˙ô˙S˙T˙i˙L˙é√ƒƒ˙ƒ˙˙ ˙„'                  ¿ƒƒƒŸ ¿ƒƒƒƒƒƒƒŸ ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ„'„'                       ˙ ˙˙ƒ˙ƒ1ƒ9ƒ9ƒ7ƒ˙ƒ˙˙ ˙„'„'----------------------------------------------------------------------------„'„' This is the core of the engine, which handles all object events.„'„' If you wish to make your own objects, add the handler code here.„'„'----------------------------------------------------------------------------„„IF CursorY > 0 AND CursorX > 0 AND TextF(AText).Win = AWin AND DragWin = 0 THEN„  LOCATE CursorY, CursorX, 1„  PRINT "";„ELSE„  LOCATE CSRLIN, POS(0), 0„END IF„„IF TaskBar = True AND Click = 1 AND LockWindows = False THEN„  IF Hy >= TaskBarLine AND Hy <= Lines AND Hx > 11 AND Hx < 71 THEN„    NewAWin = (Hx - 11) \ 10 + ((Lines - Hy) * 6) + 1„    IF NOT NewAWin > Windows THEN„      Click = 0„      OldAWin = AWin„      AWin = -1„      SCREEN , , 1, 0„      PCOPY 0, 1„      ReDrawWindow INT(OldAWin)„      AWin = NewAWin„      ReDrawWindow AWin„      DrawTaskBar„      PCOPY 1, 0„      SCREEN , , 0, 0„    END IF„  END IF„END IF„„IF TaskBar = True AND Click = 1 AND LockWindows = False AND AMenu = 0 THEN„  IF Hy = Lines AND Hx < 10 THEN„    Dummy = Dialog("About Windoze v" + Version.Major + "." + Version.Minor, "Windoze v" + Version.Major + "." + Version.Minor + " by Sami KyîstilÑ 1997. You may use this program freely as long as you give me credit for it", "OK", "", "")„  END IF„END IF„„IF Hv = -1 AND DragWin = 0 AND Drag = 0 AND AMenu = 0 THEN„  FOR i = 1 TO MaxWindows + 1„    IF Hx >= Win(i).x AND Hx <= Win(i).x2 AND Hy = Win(i).y AND Win(i).x2 - Win(i).x <> 0 AND i = AWin THEN„      DragWin = i„      DrawBox Win(i).x, Win(i).y, Win(i).x2, Win(i).y2„      DragOfs = Hx - Win(i).x„      DragXLen = Win(i).x2 - Win(i).x„      DragYLen = Win(i).y2 - Win(i).y„      Hiiripiiloon„      Hiirirajat DragOfs * 8, 0, 632 - ((Win(i).x2 - Win(i).x) - DragOfs) * 8, (Lines * 8) - (Win(i).y2 - Win(i).y) * 8„      Hiiriesiin„    END IF„  NEXT„END IF„„IF Hv = -1 AND DragWin > 0 AND MouseMove = 1 THEN„  EraseBox„  Win(DragWin).x = Hx - DragOfs„  Win(DragWin).y = Hy„  Win(DragWin).x2 = Hx - DragOfs + DragXLen„  Win(DragWin).y2 = Hy + DragYLen„  IF Win(DragWin).x < 1 THEN Win(DragWin).x = 1„  IF Win(DragWin).y < 1 THEN Win(DragWin).y = 1„  IF Win(DragWin).x2 - DragXLen < 1 THEN Win(DragWin).x2 = 1 + DragXLen„  IF Win(DragWin).y2 - DragYLen < 1 THEN Win(DragWin).y2 = 1 + DragYLen„„  IF Win(DragWin).x + DragXLen > 80 THEN Win(DragWin).x = 80 - DragXLen„  IF Win(DragWin).y + DragYLen > Lines + 1 THEN Win(DragWin).y = Lines - DragYLen + 1„  IF Win(DragWin).x2 > 80 THEN Win(DragWin).x2 = 80„  IF Win(DragWin).y2 > Lines + 1 THEN Win(DragWin).y2 = Lines + 1„„  DrawBox Win(DragWin).x, Win(DragWin).y, Win(DragWin).x2, Win(DragWin).y2„END IF„„IF Hv = 0 AND DragWin > 0 THEN„  ReDrawScreen„  DragWin = 0„  Hiiripiiloon„  Hiirirajat 0, 0, 79 * 8, Lines * 8 - 8„  Hiiriesiin„END IF„„„IF DragWin = 0 THEN„IF Key$ = CHR$(27) AND MenuBar(AWin, 1).Items > 0 AND MenuItem = 0 AND AMenu = 0 THEN„  Key$ = ""„  MenuItem = 0„  AMenu = 1„  Hiiripiiloon„  SCREEN , , 1, 0„  PCOPY 0, 1„  ReDrawWindow AWin„  DrawTaskBar„  PCOPY 1, 0„  SCREEN , , 0, 0„  DrawMenu AWin„  Hiiriesiin„END IF„„IF Key$ = CHR$(27) AND AMenu <> 0 THEN„  Key$ = ""„  MenuItem = 0„  AMenu = 0„  Hiiripiiloon„  SCREEN , , 1, 0„  PCOPY 0, 1„  ReDrawWindow AWin„  DrawTaskBar„  PCOPY 1, 0„  SCREEN , , 0, 0„  Hiiriesiin„END IF„„„IF AMenu <> 0 AND Key$ = Kd$ AND MenuItem <> 0 THEN„  DO„    MenuItem = MenuItem + 1„    IF MenuItem = 14 THEN MenuItem = 1„  LOOP UNTIL Menu$(AWin, AMenu, MenuItem) <> ""„  Hiiripiiloon„  DrawMenuItems AWin, AMenu„  Hiiriesiin„END IF„„IF AMenu <> 0 AND Key$ = Ku$ AND MenuItem <> 0 THEN„  DO„    MenuItem = MenuItem - 1„    IF MenuItem < 1 THEN MenuItem = 14„  LOOP UNTIL Menu$(AWin, AMenu, MenuItem) <> ""„  Hiiripiiloon„  DrawMenuItems AWin, AMenu„  Hiiriesiin„END IF„„IF AMenu <> 0 AND Key$ = Kd$ AND MenuItem = 0 THEN„  Hiiripiiloon„  MenuItem = 1„  SCREEN , , 1, 0„  PCOPY 0, 1„  ReDrawWindow AWin„  DrawMenuBox AWin, AMenu„  DrawTaskBar„  PCOPY 1, 0„  SCREEN , , 0, 0„  Hiiriesiin„  DrawMenu AWin„END IF„„„„„IF AMenu <> 0 AND Key$ = Kl$ THEN„  OldAMenu = AMenu„  IF MenuItem <> 0 THEN MenuItem = 1„  DO„    AMenu = AMenu - 1„    IF AMenu = 0 THEN AMenu = 8:„    IF AMenu = OldAMenu THEN EXIT DO„  LOOP UNTIL MenuBar(AWin, AMenu).Items > 0„  Hiiripiiloon„  SCREEN , , 1, 0„  PCOPY 0, 1„  ReDrawWindow AWin„  IF MenuItem > 0 THEN DrawMenuBox AWin, AMenu„  DrawTaskBar„  PCOPY 1, 0„  SCREEN , , 0, 0„  Hiiriesiin„  DrawMenu AWin„END IF„„IF AMenu <> 0 AND Key$ = Kr$ THEN„  OldAMenu = AMenu„  IF MenuItem <> 0 THEN MenuItem = 1„  DO„    AMenu = AMenu + 1„    IF AMenu = 8 THEN AMenu = 1„  LOOP UNTIL MenuBar(AWin, AMenu).Items > 0„  Hiiripiiloon„  SCREEN , , 1, 0„  PCOPY 0, 1„  ReDrawWindow AWin„  IF MenuItem > 0 THEN DrawMenuBox AWin, AMenu„  DrawTaskBar„  PCOPY 1, 0„  SCREEN , , 0, 0„  Hiiriesiin„  DrawMenu AWin„END IF„„IF Hv = -1 AND Hy = Win(AWin).y + 1 THEN„  NewAMenu = (Hx - Win(AWin).x - 1) \ 10 + 1„  IF NewAMenu = 0 THEN NewAMenu = 1„  IF NewAMenu <> AMenu AND MenuBar(AWin, NewAMenu).Items > 0 THEN„    AMenu = NewAMenu„    MenuItem = 1„    Hiiripiiloon„    SCREEN , , 1, 0„    PCOPY 0, 1„    ReDrawWindow AWin„    DrawMenuBox AWin, AMenu„    DrawTaskBar„    PCOPY 1, 0„    SCREEN , , 0, 0„    Hiiriesiin„    DrawMenu AWin„  END IF„END IF„„„IF Hy <> Win(AWin).y + 1 AND AMenu <> 0 THEN„  IF Hv = -1 AND Hx >= Win(AWin).x + ((AMenu - 1) * 10) + 1 AND Hx <= Win(AWin).x + ((AMenu - 1) * 10) + 1 + MenuBar(AWin, AMenu).Longest AND Hy >= Win(AWin).y + 2 AND Hy <= Win(AWin).y + 2 + MenuBar(AWin, AMenu).Items THEN„    NewItem = Hy - Win(AWin).y - 2„    IF Menu$(AWin, AMenu, NewItem) <> "" THEN„      Hiiripiiloon„      MenuItem = NewItem„      DrawMenuItems AWin, AMenu„      Hiiriesiin„    END IF„  END IF„END IF„  „„IF Hy <> Win(AWin).y + 1 AND AMenu <> 0 THEN„  IF Click = 1 AND NOT (Hx >= Win(AWin).x + ((AMenu - 1) * 10) + 1 AND Hx <= Win(AWin).x + ((AMenu - 1) * 10) + 1 + MenuBar(AWin, AMenu).Longest AND Hy >= Win(AWin).y + 2 AND Hy <= Win(AWin).y + 2 + MenuBar(AWin, AMenu).Items) THEN„    MenuItem = 0„    AMenu = 0„    SCREEN , , 1, 0„    PCOPY 0, 1„    ReDrawWindow AWin„    DrawTaskBar„    PCOPY 1, 0„    SCREEN , , 0, 0„  END IF„END IF„„„„IF Click = 1 AND Hy <> Win(AWin).y + 1 AND AMenu <> 0 THEN„  IF Hx >= Win(AWin).x + ((AMenu - 1) * 10) + 1 AND Hx <= Win(AWin).x + ((AMenu - 1) * 10) + 1 + MenuBar(AWin, AMenu).Longest AND Hy > Win(AWin).y + 2 AND Hy <= Win(AWin).y + 2 + MenuBar(AWin, AMenu).Items THEN„    NewItem = Hy - Win(AWin).y - 2„    IF Menu$(AWin, AMenu, NewItem) <> "" THEN„      Hiiripiiloon„      MenuItem = NewItem„      DrawMenuItems AWin, AMenu„      Hiiriesiin„    END IF„  END IF„  MenuSelected.Win = AWin„  MenuSelected.Num = AMenu„  MenuSelected.Item = MenuItem„  MenuItem = 0„  AMenu = 0„  Hiiripiiloon„  SCREEN , , 1, 0„  PCOPY 0, 1„  ReDrawWindow AWin„  DrawTaskBar„  PCOPY 1, 0„  SCREEN , , 0, 0„  Hiiriesiin„END IF„„„IF Key$ = CHR$(13) AND AMenu <> 0 THEN„  MenuSelected.Win = AWin„  MenuSelected.Num = AMenu„  MenuSelected.Item = MenuItem„  Key$ = ""„  MenuItem = 0„  AMenu = 0„  Hiiripiiloon„  SCREEN , , 1, 0„  PCOPY 0, 1„  ReDrawWindow AWin„  DrawTaskBar„  PCOPY 1, 0„  SCREEN , , 0, 0„  Hiiriesiin„END IF„„END IF„„„„IF DragWin = 0 AND AMenu = 0 THEN„IF Click = 1 AND LockWindows = False THEN„  IF Hx < Win(AWin).x OR Hx > Win(AWin).x2 OR Hy < Win(AWin).y OR Hy > Win(AWin).y2 THEN„    FOR i = 1 TO MaxWindows + 1„      IF Hx >= Win(i).x AND Hx <= Win(i).x2 AND Hy >= Win(i).y AND Hy < Win(i).y2 AND Win(i).x2 > 1 THEN„        OldAWin = AWin„        AWin = -1„        SCREEN , , 1, 0„        PCOPY 0, 1„        ReDrawWindow INT(OldAWin)„        AWin = i„        ReDrawWindow AWin„        IF TaskBar = True THEN DrawTaskBar„        PCOPY 1, 0„        SCREEN , , 0, 0„      END IF„    NEXT„  END IF„END IF„„IF Hv = -1 AND HoldButton = 0 THEN„  FOR i = 1 TO MaxButtons + 3„    IF But(i).Win = AWin AND But(i).Active = 1 THEN„      IF Hx >= But(i).x + Win(But(i).Win).x + 1 AND Hx < But(i).x2 + Win(But(i).Win).x + 1 AND Hy >= But(i).y + Win(But(i).Win).y + 1 AND Hy <= But(i).y2 + Win(But(i).Win).y + 1 THEN„        HoldButton = i„        DrawButton INT(i), True„      END IF„    END IF„  NEXT„END IF„„IF Hv = 0 AND HoldButton <> 0 THEN„  i = HoldButton„  IF Hx < But(i).x + Win(But(i).Win).x + 1 OR Hx >= But(i).x2 + Win(But(i).Win).x + 1 OR Hy < But(i).y + Win(But(i).Win).y + 1 OR Hy > But(i).y2 + Win(But(i).Win).y + 1 THEN„    DrawButton HoldButton, False„    HoldButton = 0„  ELSE„    DrawButton HoldButton, False„    ClickedButton = HoldButton„    HoldButton = 0„  END IF„END IF„„IF HoldButton <> 0 THEN„  i = HoldButton„  IF Hx < But(i).x + Win(But(i).Win).x + 1 OR Hx >= But(i).x2 + Win(But(i).Win).x + 1 OR Hy < But(i).y + Win(But(i).Win).y + 1 OR Hy > But(i).y2 + Win(But(i).Win).y + 1 THEN„    DrawButton HoldButton, False„    HoldButton = 0„  END IF„END IF„„IF Click = 1 THEN„  FOR i = 1 TO MaxCheckBoxes„    IF CBox(i).Win = AWin AND CBox(i).Active = 1 THEN„      IF Hx >= CBox(i).x + Win(CBox(i).Win).x + 1 AND Hx <= CBox(i).x + Win(CBox(i).Win).x + 1 + RealLen(CBoxCaption$(i)) + 3 AND Hy = CBox(i).y + Win(CBox(i).Win).y + 1 THEN„        Switch CBox(i).State, True, False„        DrawCheckBox INT(i)„      END IF„    END IF„  NEXT„END IF„„IF Click = 1 THEN„  FOR i = 1 TO MaxRadioButtons„    IF Radio(i).Win = AWin AND Radio(i).Active = 1 THEN„      IF Hx >= Radio(i).x + Win(Radio(i).Win).x + 1 AND Hx <= Radio(i).x + Win(Radio(i).Win).x + 1 + RealLen(RadioCaption$(i)) + 3 AND Hy = Radio(i).y + Win(Radio(i).Win).y + 1 THEN„        Radio(i).State = True„        FOR ii = 1 TO MaxRadioButtons„          IF ii <> i AND Radio(ii).Win = AWin AND Radio(ii).Group = Radio(i).Group THEN„            Radio(ii).State = False„            DrawRadio INT(ii)„          END IF„        NEXT„        DrawRadio INT(i)„      END IF„    END IF„  NEXT„END IF„„IF Hv = -1 AND GTime MOD 40 = 0 THEN„  FOR i = 1 TO MaxListBoxes + 2„    IF LBox(i).Win = AWin AND LBox(i).Total > 0 AND LBox(i).Active = 1 THEN„      IF Hx >= LBox(i).x + Win(LBox(i).Win).x + 1 AND Hx < LBox(i).x2 + Win(LBox(i).Win).x + 1 AND Hy >= LBox(i).y + Win(LBox(i).Win).y + 1 AND Hy < LBox(i).y2 + Win(LBox(i).Win).y + 1 THEN„        SelectedLBox = i„        IF LBox(i).ViewBox = False THEN„          LBox(i).Selected = LBox(i).Offset + Hy - (LBox(i).y + Win(LBox(i).Win).y) - 1„          IF LBox(i).Selected >= LBox(i).Total - 1 THEN LBox(i).Selected = LBox(i).Total - 1„        END IF„        DrawListBox INT(i)„      END IF„      IF Hx = LBox(i).x2 + Win(LBox(i).Win).x + 1 AND Hy = LBox(i).y + Win(LBox(i).Win).y + 1 THEN„        SelectedLBox = i„        LBox(i).Selected = LBox(i).Selected - 1„        DrawListBox INT(i)„      END IF„      IF Hx = LBox(i).x2 + Win(LBox(i).Win).x + 1 AND Hy = LBox(i).y2 - 1 + Win(LBox(i).Win).y + 1 THEN„        SelectedLBox = i„        LBox(i).Selected = LBox(i).Selected + 1„        DrawListBox INT(i)„      END IF„    END IF„  NEXT„END IF„„IF Click = 1 THEN„  FOR i = 1 TO MaxListBoxes + 2„    IF LBox(i).Win = AWin AND LBox(i).Total > 0 AND LBox(i).Active = 1 THEN„      IF Hx >= LBox(i).x + Win(LBox(i).Win).x + 1 AND Hx < LBox(i).x2 + Win(LBox(i).Win).x + 1 AND Hy >= LBox(i).y + Win(LBox(i).Win).y + 1 AND Hy < LBox(i).y2 + Win(LBox(i).Win).y + 1 AND LBox(i).ViewBox = False THEN„        SelectedLBox = i„        LBox(i).Selected = LBox(i).Offset + Hy - (LBox(i).y + Win(LBox(i).Win).y) - 1„        IF LBox(i).Selected >= LBox(i).Total - 1 THEN LBox(i).Selected = LBox(i).Total - 1„        DrawListBox INT(i)„        IF DBLClick = 1 THEN„          SelectedItem = LBox(SelectedLBox).Selected + 1„        END IF„      END IF„      IF Hx = LBox(i).x2 + Win(LBox(i).Win).x + 1 AND Hy < LBox(i).y2 - 1 + Win(LBox(i).Win).y + 1 AND Hy > LBox(i).y + Win(LBox(i).Win).y + 1 THEN„        IF Hy < LBox(i).Block THEN„          SelectedLBox = i„          LBox(SelectedLBox).Selected = LBox(SelectedLBox).Selected - (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„          LBox(SelectedLBox).Offset = LBox(SelectedLBox).Offset - (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„          IF LBox(SelectedLBox).Selected < 0 THEN LBox(SelectedLBox).Selected = 0„          IF LBox(SelectedLBox).Offset < 0 THEN LBox(SelectedLBox).Offset = 0„          DrawListBox INT(SelectedLBox)„        ELSEIF Hy > LBox(i).Block THEN„          SelectedLBox = i„          LBox(SelectedLBox).Selected = LBox(SelectedLBox).Selected + (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„          LBox(SelectedLBox).Offset = LBox(SelectedLBox).Offset + (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„          IF LBox(SelectedLBox).Selected >= LBox(SelectedLBox).Total - 1 THEN LBox(SelectedLBox).Selected = LBox(SelectedLBox).Total - 1„          IF LBox(SelectedLBox).Offset >= LBox(SelectedLBox).Total - 1 THEN LBox(SelectedLBox).Offset = LBox(SelectedLBox).Total - 1 - (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„          DrawListBox INT(SelectedLBox)„        END IF„      END IF„    END IF„  NEXT„END IF„„„IF Key$ <> "" AND LBox(SelectedLBox).Win = AWin AND LBox(SelectedLBox).Total > 0 THEN„  IF Key$ = Ku$ THEN„    LBox(SelectedLBox).Selected = LBox(SelectedLBox).Selected - 1„    DrawListBox INT(SelectedLBox)„  END IF„  IF Key$ = Kd$ THEN„    LBox(SelectedLBox).Selected = LBox(SelectedLBox).Selected + 1„    DrawListBox INT(SelectedLBox)„  END IF„  IF Key$ = CHR$(13) THEN„    SelectedItem = LBox(SelectedLBox).Selected + 1„  END IF„  IF Key$ = CHR$(0) + "Q" THEN„    LBox(SelectedLBox).Selected = LBox(SelectedLBox).Selected + (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„    LBox(SelectedLBox).Offset = LBox(SelectedLBox).Offset + (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„    IF LBox(SelectedLBox).Selected >= LBox(SelectedLBox).Total - 1 THEN LBox(SelectedLBox).Selected = LBox(SelectedLBox).Total - 1„    IF LBox(SelectedLBox).Offset >= LBox(SelectedLBox).Total - 1 THEN LBox(SelectedLBox).Offset = LBox(SelectedLBox).Total - 1 - (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„    DrawListBox INT(SelectedLBox)„  END IF„  IF Key$ = CHR$(0) + "I" THEN„    LBox(SelectedLBox).Selected = LBox(SelectedLBox).Selected - (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„    LBox(SelectedLBox).Offset = LBox(SelectedLBox).Offset - (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„    IF LBox(SelectedLBox).Selected < 0 THEN LBox(SelectedLBox).Selected = 0„    IF LBox(SelectedLBox).Offset < 0 THEN LBox(SelectedLBox).Offset = 0„    DrawListBox INT(SelectedLBox)„  END IF„  IF Key$ = CHR$(0) + "O" THEN„    LBox(SelectedLBox).Selected = LBox(SelectedLBox).Total - 1„    LBox(SelectedLBox).Offset = LBox(SelectedLBox).Total - 1 - (LBox(SelectedLBox).y2 - LBox(SelectedLBox).y)„    DrawListBox INT(SelectedLBox)„  END IF„  IF Key$ = CHR$(0) + "G" THEN„    LBox(SelectedLBox).Selected = 0„    LBox(SelectedLBox).Offset = 0„    DrawListBox INT(SelectedLBox)„  END IF„END IF„„IF Click = 1 THEN„  FOR i = 1 TO MaxTextFields + 1„    IF TextF(i).Win = AWin AND TextF(i).Active = 1 THEN„      IF Hy = TextF(i).y + Win(TextF(i).Win).y + 1 AND Hx >= TextF(i).x + Win(TextF(i).Win).x + 1 AND Hx < TextF(i).x + TextF(i).MaxLen + Win(TextF(i).Win).x + 1 THEN„        AText = i„        TextF(i).TPos = Hx - TextF(i).x - Win(TextF(i).Win).x - 1„        IF TextF(i).TPos > LEN(TextFText$(i)) THEN TextF(i).TPos = LEN(TextFText$(i))„        CursorX = TextF(i).x + Win(TextF(i).Win).x + 1 + TextF(i).TPos„        CursorY = Hy„      END IF„    END IF„  NEXT„END IF„„„IF Key$ <> "" THEN„    IF Key$ = CHR$(0) + CHR$(15) THEN„      TextSearch = AText„      DO„        TextSearch = TextSearch - 1„        IF TextSearch < 1 THEN TextSearch = MaxTextFields + 1„        IF TextSearch = AText THEN EXIT DO„        IF TextF(TextSearch).Win = AWin AND TextSearch <> AText THEN„          AText = TextSearch„          EXIT DO„        END IF„      LOOP„      Key$ = ""„    END IF„„    IF Key$ = CHR$(9) THEN„      TextSearch = AText„      DO„        TextSearch = TextSearch + 1„        IF TextSearch > MaxTextFields + 1 THEN TextSearch = 1„        IF TextSearch = AText THEN EXIT DO„        IF TextF(TextSearch).Win = AWin AND TextSearch <> AText THEN„          AText = TextSearch„          EXIT DO„        END IF„      LOOP„      Key$ = ""„    END IF„„END IF„„FOR i = 1 TO MaxPBars„  IF PBar(i).Value <> PBar(i).OldValue AND PBar(i).Win = AWin THEN DrawPBar INT(i)„NEXT„„IF Key$ <> "" AND TextF(AText).Win = AWin THEN„  IF Key$ = CHR$(13) THEN EnterText = AText: Key$ = ""„  TextFText$(AText) = InputField(TextFText$(AText), Key$, TextF(AText).MaxLen, TextF(AText).TPos)„  DrawTextField AText„END IF„„„IF TextF(AText).MaxLen > 0 AND TextF(AText).Active = 1 THEN„  CursorX = TextF(AText).x + Win(TextF(AText).Win).x + 1 + TextF(AText).TPos„  CursorY = TextF(AText).y + Win(TextF(AText).Win).y + 1„END IF„„END IF„„  „  IF PlayingWAV& = True AND DMADone% = -1 THEN„    WavOffset& = WavOffset& + 8000„    IF WavLength& - WavOffset& < 8000 THEN PlayLength& = WavLength& - WavOffset& ELSE PlayLength& = 8000„    IF PlayLength& <= 0 THEN„      CLOSE #WavFileHandle&„      PlayingWAV& = False„      WavLength& = 0„      WavOffset& = 0„      WavFreq& = 0„    ELSE„      GET #WavFileHandle&, , WavBuffer(0)„      DMAPlay VARSEG(WavBuffer(0)), VARPTR(WavBuffer(0)), PlayLength& - 1, WavFreq&„    END IF„  END IF„„„OldHiiriX = Hx„OldHiiriY = Hy„„IF GTime MOD 100 = 0 THEN BlinkOff„„IF TaskBar = True AND TIMER >= OldTimer& + 1 THEN„  IF Hy > Lines - 1 AND Hx > 72 THEN Hiiripiiloon„  LOCATE Lines, 73, 0„  COLOR 4, 7„  PRINT TIME$;„  IF Hy > Lines - 1 AND Hx > 72 THEN Hiiriesiin„  OldTimer& = TIMER„END IF„„END SUB„„DEFINT A-Z„SUB MasterVolume (right%, Left%, Getvol%)„'----------------------------------------------------------------------------„' Sets the master volume on the Sound Blaster card„'----------------------------------------------------------------------------„'„'  Right% - Right volume„'   Left% - Left volume„' Getvol% - If true, then volume will be read, not set„'„'----------------------------------------------------------------------------„„OUT BasePort% + 4, &H22„'PRINT BasePort%„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (right% + Left% * 16) AND &HFF„END IF„END SUB„„SUB MicVolume (Volume%, Getvol%)„'----------------------------------------------------------------------------„' Sets the mic gain on the Sound Blaster card„'----------------------------------------------------------------------------„'„' Volume% - Volume„' Getvol% - If true, then volume will be read, not set„'„'----------------------------------------------------------------------------„„OUT BasePort% + 4, &HA„IF Getvol% THEN„   Volume% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, Volume% AND &HF„END IF„END SUB„„FUNCTION MouseInside (x, y, x2, y2)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„IF Hx >= x AND Hx <= x2 AND Hy >= y AND Hy <= y2 THEN MouseInside = True ELSE MouseInside = False„END FUNCTION„„SUB PrintLine (Text$, XLen)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„„Hiiripiiloon„Wrapped$ = RTRIM$(Wrap$(Text$, XLen))„Text$ = LEFT$(Text$, LEN(Text$) - 1)„„„StartPos = POS(0)„„FOR i = 1 TO LEN(Wrapped$)„  IF MID$(Wrapped$, i, 1) <> CHR$(255) THEN„    PRINT MID$(Wrapped$, i, 1);„  ELSE„    PRINT„    LOCATE , StartPos„  END IF„NEXT„„Hiiriesiin„END SUB„„FUNCTION QDir$ (FileSpec$, Dirs)„'=======================================================================„'Name:          QDir$„'Purpose:       Return next file that matches the original file spec„'=======================================================================„    QDir$ = ""„    DEF SEG = VARSEG(Code(0))                   ' point to QINT code„„    ' Set up the DTA to our special work area„„    Regs.ax = &H1A00                            ' specify DTA address„    Regs.ds = VARSEG(DTA)                       ' DS reg has seg part„    Regs.dx = VARPTR(DTA)                       ' DX reg has offset„    CALL absolute(&H21, Regs, 0)                ' do the business...„„    ' Now see if we need a FIND FIRST or FIND NEXT CALL„„    IF LEN(FileSpec$) THEN                      ' got a file spec so...„  Regs.ax = &H4E00                              ' specify FIND FIRST„  IF Dirs = True THEN„    Regs.cx = &HFF„  ELSE„    Regs.cx = 39                                ' no directories or vol labels„  END IF„  TheString$ = FileSpec$ + CHR$(0)        ' add a NUL byte for DOS„  Regs.dx = VARPTR(TheString$)            ' DX points to the string„  Regs.ds = VARSEG(TheString$)            ' DS point to segment„    ELSE                                        ' no file spec so...„  Regs.ax = &H4F00                        ' specify FIND NEXT„    END IF„„    CALL absolute(&H21, Regs, 0)                ' do the business...„„    ' If the carry flag is clear, then we've got a file spec !„„    IF (Regs.Flags AND 1) = 0 THEN              ' carry clear = ok„  Filename$ = MID$(DTA, 31, 13)           ' extract the file from the DTA„  QDir$ = LEFT$(Filename$, INSTR(Filename$, CHR$(0)) - 1)„    END IF„„    DEF SEG                                     ' return from hyper-space„END FUNCTION„„FUNCTION Query$ (Topic$, Text$, TextField$, MaxLen, Password)„'----------------------------------------------------------------------------„' Prompts the user to enter information into a textfield„'----------------------------------------------------------------------------„'     Topic$ - Window Topic„'      Text$ - Prompt text„' TextField$ - Initial text„'     MaxLen - Max lenght„'   Password - If True, then a password dialog will be created„'----------------------------------------------------------------------------„„x = 20„y = Lines \ 2 - 6„x2 = 60„y2 = Lines \ 2 + 6„„CreateWindow MaxWindows + 1, x, y, x2, y2, 15, 7, Topic$„CreateLabel MaxWindows + 1, MaxLabels + 1, 0, 0, (x2 - x) - 1, 3, Filled, 0, 7, Text$„„LockWindows = True„AWin = MaxWindows + 1„„CreateButton MaxWindows + 1, MaxButtons + 1, 5, (y2 - y) - 4, 8, 1, "OK", 15, 3„CreateButton MaxWindows + 1, MaxButtons + 2, (x2 - x) - 8 - 8, (y2 - y) - 4, 8, 1, "Cancel", 15, 3„„CreateFrame MaxWindows + 1, MaxFrames + 1, (x2 - x) \ 2 - (MaxLen \ 2) - 2, 5, MaxLen + 2, 1, "", Float, 0, 7„CreateTextField MaxWindows + 1, MaxTextFields + 1, (x2 - x) \ 2 - (MaxLen \ 2) - 2, 5, MaxLen + 2, 16, 7, TextField$, Password„„AText = MaxTextFields + 1„ReDrawScreen„„DO„  UpdateMouse„  Main„„  IF EnterText = MaxTextFields + 1 THEN ClickedButton = MaxButtons + 1: EXIT DO„  IF Key$ = CHR$(27) THEN ClickedButton = MaxButtons + 2: EXIT DO„„LOOP UNTIL ClickedButton > MaxButtons„„IF ClickedButton = MaxButtons + 1 THEN„  Query$ = TextFText$(MaxTextFields + 1)„ELSE„  Query$ = ""„END IF„„KillWindow MaxWindows + 1„LockWindows = False„CursorX = -1024„CursorY = -1024„„END FUNCTION„„FUNCTION ReadDAC%„' Reads a byte from the DAC.„writedsp &H20„ReadDAC% = ReadDSP%„„END FUNCTION„„SUB ReadDir (Dir$, FileSpec$)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„„TempFile = FREEFILE„OPEN "FSELECT.TMP" FOR OUTPUT AS #TempFile„„NFileSpec$ = Dir$ + FileSpec$„„DO„  Filename$ = RTRIM$(LTRIM$(QDir$(NFileSpec$, False)))„  NFileSpec$ = ""„  IF Filename$ <> "" THEN„    PRINT #TempFile, RTRIM$(Filename$)„  ELSE„    EXIT DO„  END IF„LOOP„CLOSE #TempFile„„„OPEN "FSELECT2.TMP" FOR OUTPUT AS #TempFile„NFileSpec$ = Dir$ + "*.*"„„DO„  Filename$ = QDir$(NFileSpec$, True)„  NFileSpec$ = ""„  IF (LTRIM$(RTRIM$(Filename$))) <> "" THEN„    IF GetFileAttr(Dir$ + Filename$) AND 16 THEN„      IF Filename$ <> "." THEN PRINT #TempFile, RTRIM$(Filename$)„    END IF„  ELSE„    EXIT DO„  END IF„LOOP„PRINT #TempFile, "A:\"„PRINT #TempFile, "C:\"„PRINT #TempFile, "D:\"„PRINT #TempFile, "E:\"„PRINT #TempFile, "F:\"„PRINT #TempFile, "G:\"„PRINT #TempFile, "H:\"„PRINT #TempFile, "I:\"„PRINT #TempFile, "J:\"„PRINT #TempFile, "K:\"„PRINT #TempFile, "L:\"„PRINT #TempFile, "M:\"„PRINT #TempFile, "N:\"„PRINT #TempFile, "O:\"„PRINT #TempFile, "P:\"„PRINT #TempFile, "Q:\"„PRINT #TempFile, "R:\"„PRINT #TempFile, "S:\"„PRINT #TempFile, "T:\"„PRINT #TempFile, "U:\"„PRINT #TempFile, "V:\"„PRINT #TempFile, "W:\"„PRINT #TempFile, "X:\"„PRINT #TempFile, "Y:\"„PRINT #TempFile, "Z:\"„CLOSE #TempFile„„CreateListBox MaxWindows + 1, MaxListBoxes + 1, 2, 2, 12, 10, "FSELECT.TMP", 0, 0, 3, False, False„CreateListBox MaxWindows + 1, MaxListBoxes + 2, 20, 2, 12, 10, "FSELECT2.TMP", 0, 0, 3, False, False„„„END SUB„„SUB ReadDir2 (Dir$)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„TempFile = FREEFILE„„OPEN "FSELECT2.TMP" FOR OUTPUT AS #TempFile„NFileSpec$ = Dir$ + "*.*"„„DO„  Filename$ = QDir$(NFileSpec$, True)„  NFileSpec$ = ""„  IF (LTRIM$(RTRIM$(Filename$))) <> "" THEN„    IF GetFileAttr(Dir$ + Filename$) AND 16 THEN„      IF Filename$ <> "." THEN PRINT #TempFile, RTRIM$(Filename$)„    END IF„  ELSE„    EXIT DO„  END IF„LOOP„PRINT #TempFile, "A:\"„PRINT #TempFile, "C:\"„PRINT #TempFile, "D:\"„PRINT #TempFile, "E:\"„PRINT #TempFile, "F:\"„PRINT #TempFile, "G:\"„PRINT #TempFile, "H:\"„PRINT #TempFile, "I:\"„PRINT #TempFile, "J:\"„PRINT #TempFile, "K:\"„PRINT #TempFile, "L:\"„PRINT #TempFile, "M:\"„PRINT #TempFile, "N:\"„PRINT #TempFile, "O:\"„PRINT #TempFile, "P:\"„PRINT #TempFile, "Q:\"„PRINT #TempFile, "R:\"„PRINT #TempFile, "S:\"„PRINT #TempFile, "T:\"„PRINT #TempFile, "U:\"„PRINT #TempFile, "V:\"„PRINT #TempFile, "W:\"„PRINT #TempFile, "X:\"„PRINT #TempFile, "Y:\"„PRINT #TempFile, "Z:\"„CLOSE #TempFile„„CreateListBox MaxWindows + 1, MaxListBoxes + 2, 20, 2, 12, 10, "FSELECT2.TMP", 0, 0, 3, False, False„„END SUB„„FUNCTION ReadDSP%„' Reads a byte from the DSP„DO„LOOP UNTIL INP(BasePort% + 14) AND &H80„ReadDSP% = INP(BasePort% + 10)„END FUNCTION„„FUNCTION RealLen (Text$)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„Ln& = LEN(Text$)„FOR i = 1 TO LEN(Text$)„  Done = 0„  IF MID$(Text$, i, 1) = "&" AND INSTR("0123456789ABCDEF", MID$(Text$, i + 1, 1)) AND i < LEN(Text$) THEN„    Ln& = Ln& - 2„  END IF„NEXT„RealLen = Ln&„END FUNCTION„„SUB ReDrawScreen„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„Hiiripiiloon„LOCATE CSRLIN, POS(0), 0„SCREEN , , 1, 0„PCOPY 3, 1„„FOR i = 1 TO MaxWindows + 1„  IF Win(i).x2 - Win(i).x <> 0 AND AWin <> i THEN„    ReDrawWindow i„  END IF„NEXT„„ReDrawWindow AWin„„IF TaskBar = True THEN DrawTaskBar„„PCOPY 1, 0„SCREEN , , 0, 0„Hiiriesiin„„END SUB„„SUB ReDrawWindow (Num)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„„IF Win(Num).x2 - Win(Num).x = 0 THEN EXIT SUB„DrawWindow Num„„FOR i = 1 TO MaxFrames + 2„  IF Frame(i).Win = Num THEN„    DrawFrame i„  END IF„NEXT„„FOR i = 1 TO MaxCheckBoxes„  IF CBox(i).Win = Num THEN„    DrawCheckBox i„  END IF„NEXT„„„FOR i = 1 TO MaxRadioButtons„  IF Radio(i).Win = Num THEN„    DrawRadio i„  END IF„NEXT„„FOR i = 1 TO MaxLabels + 1„  IF Label(i).Win = Num THEN„    DrawLabel i„  END IF„NEXT„„FOR i = 1 TO MaxListBoxes + 2„  IF LBox(i).Win = Num THEN„    DrawListBox i„  END IF„NEXT„„FOR i = 1 TO MaxTextFields + 1„  IF TextF(i).Win = Num THEN„    DrawTextField i„  END IF„NEXT„„FOR i = 1 TO MaxPBars„  IF PBar(i).Win = Num THEN„    DrawPBar i„  END IF„NEXT„„FOR i = 1 TO MaxButtons + 3„  IF But(i).Win = Num THEN„    DrawButton i, False„  END IF„NEXT„„„„END SUB„„FUNCTION ResetDSP%„' Resets the DSP„OUT BasePort% + 6, 1„FOR Count% = 1 TO 4„   junk% = INP(BasePort% + 6)„NEXT„OUT BasePort% + 6, 0„IF INP(BasePort% + 14) AND &H80 = &H80 AND INP(BasePort% + 10) = &HAA THEN„   ResetDSP% = -1„ELSE„   ResetDSP% = 0„END IF„END FUNCTION„„SUB ResetSB„'----------------------------------------------------------------------------„'                 Resets the Sound Blaster„'----------------------------------------------------------------------------„„OUT &H226, 1: OUT &H226, 0„DO„  x% = INP(&H22E)„  IF x% AND 128 THEN„    x% = INP(&H22A)„    IF x% = &HAA THEN„„    EXIT DO„  END IF„END IF„LOOP„„„DO„x% = INP(&H22C)„LOOP WHILE x% AND 128„„„OUT &H22, &HD1„„„„„END SUB„„FUNCTION Samplebyte%„'----------------------------------------------------------------------------„'           Samples a byte from the Sound Blaster Microfone„'----------------------------------------------------------------------------„„bp% = BasePort%„„CALL writedsp(&H20) 'Command to sample one byte„datavail% = bp% + 14„dly:„        IF INP(datavail%) AND &H80 = 0 THEN GOTO dly„datread% = bp% + 10„bt% = INP(datread%)„Samplebyte% = bt%„„END FUNCTION„„FUNCTION SeekBufferLine (Num, LineNum)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„„Ln% = 1„FOR i& = 0 TO BufferSize„  IF Buf(Num, i&) = 13 THEN Ln% = Ln% + 1„  IF Ln% > LineNum THEN EXIT FOR„NEXT„IF LineNum > 0 THEN SeekBufferLine = i& + 2 ELSE SeekBufferLine = 0„„END FUNCTION„„SUB SeekLine (FileNum, LineNum)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„„SEEK #FileNum, 1„„FOR i = 0 TO LineNum - 1„  IF EOF(FileNum) THEN EXIT FOR„  LINE INPUT #FileNum, Dummy$„NEXT„„END SUB„„SUB SetStereo (OnOff%)„'----------------------------------------------------------------------------„'                     Sets stereo on/off„'----------------------------------------------------------------------------„„OUT BasePort% + 4, &HE„IF OnOff% THEN OUT BasePort% + 5, 2 ELSE OUT BasePort% + 5, 0„END SUB„„SUB SpeakerState (OnOff%)„' Turns speaker on or off.„IF OnOff% THEN writedsp &HD1 ELSE writedsp &HD3„END SUB„„FUNCTION SpeakerStatus%„OUT BasePort% + 4, &HD8„IF INP(BasePort% + 5) = &HFF THEN SpeakerStatus% = -1 ELSE SpeakerStatus% = 0„END FUNCTION„„SUB Switch (Var, Value1, Value2)„'----------------------------------------------------------------------------„'                           Switches values„'----------------------------------------------------------------------------„'„'     Var - Variable to be changed„'  Value1 - Value 1„'  Value2 - Value 2„'„'----------------------------------------------------------------------------„'„' if Var = Value1 then Value2 will be assigned to Var„'„' if Var = Value2 then Value1 will be assigned to Var„'„' This SUB is used with Checkboxes and Radiobuttons„'„'----------------------------------------------------------------------------„„„IF Var = Value1 THEN Var = Value2: EXIT SUB„IF Var = Value2 THEN Var = Value1„„END SUB„„SUB UpdateMouse„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„'                    Reads mouse position and status„'----------------------------------------------------------------------------„  DialogClickedButton = 0„  InputDialogClickedButton = 0„  ClickedButton = 0„  Key$ = INKEY$„  MouseMove = 0„  SelectedItem = 0„  MovedBar = 0„  ClickedRadioButton = 0„  ClickedCheckBox = 0„  EnterText = 0„  Hiirilue Hiiriv%, Hiirio%, Hiirik%, HiiriX%, HiiriY%„  Hx = HiiriX% \ 8 + 1„  Hy = HiiriY% \ 8 + 1„  Hv = Hiiriv%„  Ho = Hiirio%„  Hk = Hiirik%„„  IF Hv = 0 AND Click = -1 THEN Click = 1 ELSE IF Hv = 0 THEN Click = 0„  IF Hv = 0 THEN Drag = 0„  IF Hv = 0 THEN MovingBar = 0„  IF Hv = -1 AND Click = 0 THEN Click = -1„„  IF Hx <> OldHiiriX THEN MouseMove = 1„  IF Hy <> OldHiiriY THEN MouseMove = 1„  IF Hx <> OldHiiriX AND Hv = -1 THEN Drag = 1„  IF Hy <> OldHiiriY AND Hv = -1 THEN Drag = 1„  DBLClick = 0„„  IF Click = 1 THEN„    IF MouseMove = 0 AND TIMER <= ClickCount + 1 THEN„      ClickCount = 0„      DBLClick = 1„    ELSE„      ClickCount = TIMER„    END IF„  END IF„  IF MouseMove = 1 THEN ClickCount = 0„„  GTime = GTime + 1„  GTime = GTime MOD 64000„„  MenuSelected.Win = 0„  MenuSelected.Num = 0„  MenuSelected.Item = 0„„END SUB„„SUB VocVolume (right%, Left%, Getvol%)„'----------------------------------------------------------------------------„' Sets the VOC-volume on the Sound Blaster card„'----------------------------------------------------------------------------„'„'  Right% - Right volume„'   Left% - Left volume„' Getvol% - If true, then volume will be read, not set„'„'----------------------------------------------------------------------------„„OUT BasePort% + 4, &H4„IF Getvol% THEN„   Left% = INP(BasePort% + 5) \ 16„   right% = INP(BasePort% + 5) AND &HF„   EXIT SUB„ELSE„   OUT BasePort% + 5, (right% + Left% * 16) AND &HFF„END IF„END SUB„„SUB WAVPlayDMA (File$, Freq&)„'----------------------------------------------------------------------------„'  Plays a WAV, VOC, SND sound file in the backround„'----------------------------------------------------------------------------„'„'                 File$ - File to be played„'                 Freq& - Playback frequency„'„'----------------------------------------------------------------------------„'                   Set volume levels with *Volume subs„'----------------------------------------------------------------------------„„„IF PlayingWAV& = True THEN CLOSE #WavFileHandle&: PlayingWAV& = False„„WavFile = FREEFILE„IF Exist(File$) = False THEN EXIT SUB„„OPEN File$ FOR BINARY AS #WavFile„„„IF RIGHT$(UCASE$(File$), 3) = "WAV" THEN„  GET #WavFile, 44, WavBuffer(0)„  Length& = LOF(1) - 44„ELSE„  GET #WavFile, , WavBuffer(0)„  Length& = LOF(1)„END IF„„„IF Length& > 8000 THEN„  WavLength& = Length&„  WavFileHandle& = WavFile„  WavOffset& = 0„  WavFreq& = Freq&„  Length& = 8000„  PlayingWAV& = True„  DMAPlay VARSEG(WavBuffer(0)), VARPTR(WavBuffer(0)), Length&, Freq&„ELSE„  DMAPlay VARSEG(WavBuffer(0)), VARPTR(WavBuffer(0)), Length&, Freq&„  CLOSE #WavFile„END IF„„„END SUB„„FUNCTION Wrap$ (InputText$, Wrappos)„'----------------------------------------------------------------------------„'                           S˙Y˙S˙T˙E˙M„'----------------------------------------------------------------------------„„„IF INSTR(InputText$, " ") = 0 THEN InputText$ = InputText$ + " ": Wrap$ = InputText$: EXIT FUNCTION„InputText$ = InputText$ + " "„„IF LEN(InputText$) <= Wrappos THEN Wrap$ = InputText$: EXIT FUNCTION„TPos = 1„OrgText$ = InputText$„OrgLen = LEN(InputText$)„TPos2 = 1„TPos = 0„„DO„  TPos = TPos + 1„  TPos2 = TPos2 + 1„  IF TPos2 > Wrappos + 1 THEN„    TPos2 = 0„    FOR VPos = TPos TO TPos - Wrappos STEP -1„      IF MID$(InputText$, VPos, 1) = " " THEN EXIT FOR„    NEXT„    InputText$ = LEFT$(InputText$, VPos - 1) + CHR$(255) + MID$(InputText$, VPos + 1, 255)„    TLen = TLen + 1„  END IF„LOOP UNTIL TLen >= OrgLen„„Wrap$ = LEFT$(InputText$, OrgLen)„InputText$ = OrgText$„„END FUNCTION„„SUB writedsp (Byte%)„' Writes a byte to the DSP„DO„LOOP WHILE INP(BasePort% + 12) AND &H80„OUT BasePort% + 12, Byte%„„END SUB„Alexander Meyer                SEARCH FOR OCCURENCES IN A FILEMeyer.Karl@t-online.de         10-19-97 (09:09)       QB, QBasic, PDS        41   1102     TEXTCHAR.BAS'                             ////„'                           0(o o)0„'-------------------------ooO (_) Ooo---------------------„' TEXTCHAR.BAS -- Written in QuickBasic 4.5„'„' Name: Search for character in textfile„' Author: Alexander Meyer„' Date: 10-18-1997„' Description: This program searches how often a„'              character (e.g. A) occurs in a textfile.„'„'For questions or comments mail to: Meyer.Karl@t-online.de„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-„„CLS„SHELL "dir *.txt"„PRINT„INPUT "Textfile"; Datei$„Search:„INPUT "Character to search for (example: A): ", Search$„IF LEN(Search$) <> 1 THEN„  PRINT "Only one character!!"„  GOTO Search„END IF„„Search$ = LCASE$(Search$)„Print$ = UCASE$(Search$)„CLS„OPEN Datei$ FOR INPUT AS #1„DO WHILE NOT EOF(1)„  LINE INPUT #1, Inline$„FOR i = 1 TO LEN(Inline$)„  Midi$ = MID$(Inline$, i, 1)„  IF LCASE$(Midi$) = Search$ THEN„    Zeichen = Zeichen + 1„    LOCATE 1: PRINT Zeichen; Print$; "'s found!!": PRINT„  END IF„NEXT i„LOOP„CLOSE #1„COLOR 14: PRINT Zeichen; Print$; "'s found!!"„Alexander Meyer                SHINING/SPOTLIGHT ON TEXT      Meyer.Karl@t-online.de         10-19-97 (09:09)       QB, QBasic, PDS        74   1965     SHINETXT.BAS'                             ////„'                           0(o o)0„'-------------------------ooO (_) Ooo---------------------„' SHINETXT.BAS -- Written in QuickBasic 4.5„'„' Name: Shining text„' Author: Alexander Meyer„' Date: 10-18-1997„' Description: This effect is known from the ABC Express„'              Reader„'„'For questions or comments mail to: Meyer.Karl@t-online.de„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-„DECLARE SUB ShiningText (Text$, x, Delay)„„SCREEN 0: WIDTH 80      '--> Textmode, 80 x 25„CLS                     '--> Clear screen„„'**Call routine**„CALL ShiningText("Shining text by Alexander Meyer  :-)", 5, 500)„„SUB ShiningText (Text$, x, Delay)„„'**Shining text routine**„„DO„„IF y > LEN(Text$) - 2 THEN„y = LEN(Text$) + 6„FOR i = LEN(Text$) TO 1 STEP -1„  IF INKEY$ <> "" THEN EXIT SUB„  Midi$ = MID$(Text$, i, 5)„  Save5$ = MID$(Midi$, 1, 1)„  Save4$ = MID$(Midi$, 2, 1)„  Save3$ = MID$(Midi$, 3, 1)„  Save2$ = MID$(Midi$, 4, 1)„  Save1$ = MID$(Midi$, 5, 1)„  y = y - 1„    LOCATE x, y - 4: COLOR 8: PRINT Save5$„    LOCATE x, y - 3: COLOR 7: PRINT Save4$„    LOCATE x, y - 2: COLOR 15: PRINT Save3$„    LOCATE x, y - 1: COLOR 7: PRINT Save2$„    LOCATE x, y: COLOR 8: PRINT Save1$„    LOCATE x, y + 1: PRINT " "„    FOR z = 1 TO Delay: NEXT z„ „  NEXT i„„  ELSE„„y = 1„FOR i = 1 TO LEN(Text$)„  IF INKEY$ <> "" THEN EXIT SUB„  Midi$ = MID$(Text$, i, 5)„  Save1$ = MID$(Midi$, 1, 1)„  Save2$ = MID$(Midi$, 2, 1)„  Save3$ = MID$(Midi$, 3, 1)„  Save4$ = MID$(Midi$, 4, 1)„  Save5$ = MID$(Midi$, 5, 1)„    y = y + 1„    LOCATE x, y: COLOR 8: PRINT Save1$„    LOCATE x, y + 1: COLOR 7: PRINT Save2$„    LOCATE x, y + 2: COLOR 15: PRINT Save3$„    LOCATE x, y + 3: COLOR 7: PRINT Save4$„    LOCATE x, y + 4: COLOR 8: PRINT Save5$„    LOCATE x, y - 1: PRINT " "„    FOR z = 1 TO Delay: NEXT z„    NEXT i„ „  END IF„„LOOP WHILE INKEY$ = ""„„END SUB„Alexander Meyer                BOUNCING TEXT                  Meyer.Karl@t-online.de         10-19-97 (09:09)       QB, QBasic, PDS        69   1350     BOUNCTXT.BAS'                             ////„'                           0(o o)0„'-------------------------ooO (_) Ooo---------------------„' BOUNCTXT.BAS -- Written in QuickBasic 4.5„'„' Name: Bouncing text„' Author: Alexander Meyer„' Date: 10-18-1997„' Description: This is a little nice program that shows„'              a bouncing text  ;-)„'„'For questions or comments mail to: Meyer.Karl@t-online.de„'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-„„DECLARE SUB BouncingText (Text$, x, y, Breit, Hoch, Delay)„„SCREEN 0: WIDTH 80         '--> Textmode 80 x 25„„'Call routine„CALL BouncingText("Hello!!", 1, 1, 50, 20, 300)„„END„„SUB BouncingText (Text$, x, y, Breit, Hoch, Delay)„„'**Bouncing text routine**„„xRand = x„yRand = y„Breit = Breit + y„Hoch = Hoch + x„„DO„„LOCATE x, y: PRINT Text$       '--> Print text„„FOR i = 1 TO Delay: NEXT i     '--> Delay„„CLS                            '--> Clear screen„„IF GoX = 0 THEN„  x = x + 1„  IF x >= Hoch THEN„    GoX = 1„    IF x = Hoch THEN„      x = x + 1„      GoX = 1„    END IF„  END IF„END IF„„IF GoX = 1 THEN„  x = x - 1„  IF x <= xRand THEN GoX = 0„END IF„„IF GoY = 0 THEN„  y = y + 1„  IF y >= Breit THEN GoY = 1„END IF„„IF GoY = 1 THEN„  y = y - 1„  IF y <= yRand THEN GoY = 0„END IF„„LOOP UNTIL INKEY$ <> ""„„END SUB„The ABC Programmer             DRAW 3D-LIKE TEXT BOXES        voxel@freenet.edmonton.ab.ca   10-26-97 (10:55)       QB, QBasic, PDS        55   1401     3DBOX.BAS   ' 3D-Like Text Boxes programmed by William Yu (10-26-97)„' Just like the ones used in The ABC Express Reader„' 100% Public Domain„„' Usage Notes:„'   X,Y,XX,YY are self explanatory„'   C  = Bright Colour„'   C2 = Dark Colour„'   BC = Background Colour„'   Solid = fill in box?  0 = No, anything else is Yes„'   Indent = create an indent effect? 0 = No, anything else is yes„„DEFINT A-Z„DECLARE SUB Draw.3DBox (X%, Y%, XX%, YY%, C%, C2%, BC%, Solid%, Indent)„„CONST False = 0„CONST True = NOT False„„CLS„Draw.3DBox 8, 9, 72, 21, 15, 0, 1, True, False„Draw.3DBox 10, 10, 70, 20, 15, 0, 1, False, True„„SUB Draw.3DBox (X%, Y%, XX%, YY%, C%, C2%, BC%, Solid%, Indent)„„Char1$ = "⁄"„CharHoz$ = "ƒ"„Char2$ = "ø"„CharVert$ = "≥"„Char3$ = "¿"„Char4$ = "Ÿ"„„COLOR C%, BC%„A = (XX% - X%) - 1„IF Indent THEN„  COLOR C2%„  LOCATE Y%, X%: PRINT Char1$; STRING$(A, CharHoz$);„  COLOR C%: PRINT Char2$„ELSE„  LOCATE Y%, X%: PRINT Char1$; STRING$(A, CharHoz$);„  COLOR C2%: PRINT Char2$„END IF„FOR I = Y% + 1 TO YY% - 1„  IF Indent THEN COLOR C2% ELSE COLOR C%„  LOCATE I, X%: PRINT CharVert$;„  IF Solid% THEN PRINT SPACE$(A);„  IF Indent THEN COLOR C% ELSE COLOR C2%„  LOCATE I, XX%: PRINT CharVert$;„NEXT I„LOCATE YY%, X%„IF Indent THEN COLOR C2% ELSE COLOR C%„PRINT Char3$;„IF Indent THEN COLOR C% ELSE COLOR C2%„PRINT STRING$(A, CharHoz$); Char4$;„„END SUB„