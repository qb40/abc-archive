Kurt Kuzba                     DELAY TIMERS                   FidoNet QUIK_BAS Echo          11-06-95 (15:00)       QB, QBasic, PDS        76   3129     QBDELAY.BAS 'Someone wrote:„„'>   Does anybody have a routine to pause a program for a„'>   certain amount of time before continuing?  Thankyou.„'>......................................................„„'Kurt Kuzba Replied:„„'   Generally, SLEEP is sufficient, but sometimes you need a„'finer resolution or the ability to ignore keypresses.„'   You may use the DOS internal clock, which allows a minimum„'delay of 0.054931641 seconds. The DOS clock increments at a„'rate of 18.20444444 times per second.„'   You may also use the vertical retrace, though I have been told„'that it is not recommended. This allows a more precise control.„'This allows increments of 0.0014285714 seconds. The Video Retrace„'usually occurs at a rate of 70 times per second, but may change„'due to use of different hardware on various systems.„'   You may also use the Programmable Interrupt Timer at hardware„'port (&H40), or 64 decimal, allowing an adjustable delay, which„'depends on the speed of your processor. The PIT calibration„'FUNCTION attempts to read the PIT based on the DOS clock and set„'the delay interval accordingly. It has not been tested and may„'lose accuracy at greater speeds with better processors, so it„'should only be used in personal use software on known systems,„'or require configuration to individual setups. I haven't the range„'of hardware to test for other processors and conditions.„„'_|_|_|   QBDELAY.BAS„'_|_|_|   This program utilizes three different delay timers.„'_|_|_|   Each uses the same method but employs a different„'_|_|_|   measure. DOSDelay uses the internal DOS clock.„'_|_|_|   VRTDelay uses the VIDEO hardware interrupt retrace.„'_|_|_|   PITDelay uses the hardware interrupt Programmable„'_|_|_|   Interrupt Timer. Each will generate a 10 second delay.„'_|_|_|   Released to the   Public Domain   by Kurt Kuzba„DECLARE FUNCTION PITcal& ()„DECLARE SUB PITDelay (seconds!)„DECLARE SUB DOSDelay (seconds!)„DECLARE SUB VRTDelay (seconds!)„COLOR 2, 0: CLS : DIM SHARED PIT(1) AS LONG„PRINT "DOSDelay : "; TIME$: DOSDelay 10„PRINT "           "; TIME$: COLOR 9„PRINT "VRTDelay : "; TIME$: VRTDelay 10„PRINT "           "; TIME$: COLOR 15„PIT(0) = PITcal: COLOR 12„PRINT "PIT calibrated at"; PIT(0); "increments per second."„COLOR 14„PRINT "PITDelay : "; TIME$: PITDelay 10„PRINT "           "; TIME$„SUB DOSDelay (seconds!)„   DEF SEG = 0„   d& = FIX(seconds! * 18.20444444#)„   FOR t& = t& TO d&„     d% = PEEK(&H46C) AND 255„     WHILE d% = (PEEK(&H46C) AND 255): WEND„   NEXT„END SUB„FUNCTION PITcal&„   p& = 0: DEF SEG = 0: x% = (PEEK(&H46C) + 1) AND 255„   WHILE x% <> (PEEK(&H46C) AND 255): WEND„   WHILE x% = (PEEK(&H46C) AND 255)„      p& = p& + 33„      FOR t% = 1 TO 19: WAIT (64), 128, 128: WAIT (64), 128: NEXT„   WEND„   PITcal& = p& * 11.02„END FUNCTION„SUB PITDelay (seconds!)„   d& = FIX(seconds! * PIT(0))„   FOR t& = 0 TO d&: WAIT 64, 128: WAIT 64, 128, 128: NEXT„END SUB„SUB VRTDelay (seconds!)„   d& = FIX(seconds! * 70)„   FOR t& = 0 TO d&: WAIT (&H3DA), 8: WAIT (&H3DA), 8, 8: NEXT„END SUB„'_|_|_|   end QBDELAY.BAS„Jack Hudgions                  TIME SLICING                   FidoNet QUIK_BAS Echo          10-29-95 (10:52)       QB, PDS                65   1970     TIMSLICE.BAS'These routines assume the declarations for the interrupt structures are„'present (QB.BI or QBX.BI), and that the QB.QLB or QBX.QLB quick library„'is loaded.„„'For Windows, it's first necessary to retrieve the DOS version:„„' Get DOS version„InReg.AX = &H3306„CALL Interrupt(&H21, InReg, OutReg)„DOSver = ((OutReg.BX AND 255) * 100) + (OutReg.BX \ 256)„IF DOSver = 0 THEN„  InReg.AX = &H3000„  CALL Interrupt(&H21, InReg, OutReg)„  DOSver = ((OutReg.AX AND 255) * 100) + (OutReg.AX \ 256)„END IF„„'This returns the version as an integer for simplicity (300 = DOS 3.00,„'620 = DOS 6.20, etc.).„„'Next, call the following function to detect Windows (If you attempt to„'execute this code under DOS 2.x, it will lock up):„„' Check for Windows„IF DOSver >= 300 THEN„  InReg.AX = &H160A„  CALL Interrupt(&H2F, InReg, OutReg)„  IF OutReg.AX <> 0 THEN„    WinMode = 0„  ELSE„    WinMode = OutReg.CX„  END IF„END IF„„'The variable WinMode will be set as follows:„„'  0 = Windows not detected„'  1 = Real mode detected (Win 3.0 and earlier only)„'  2 = Standard mode detected.„'  3 = 386 enhanced mode detected.„„'For OS/2, check the DOS version, and if it's 20 or higher, your program„'is running under OS/2 2.0 or later:„„' Check for OS/2 by checking if DOS ver >= 20.„IsOS2 = DOSver >= 2000„„'The variable IsOS2 will be zero (false) if OS/2 is not detected, or -1„'(true) if OS/2 is detected.  You can also use the DOS version to„'determine the OS/2 version.  I believe these are correct:„„'  OS/2 version   DOS version returned„'     2.0               20.0„'     2.1               20.1„'     2.11              20.2„'     3.0               20.3„„'Once you have this information, giving up timeslices is a snap.  Simply„'insert this code wherever your program awaits input:„„' Give up timeslices under Windows or OS/2„IF WinMode = 3 OR IsOS2 THEN„  InReg.AX = &H1680„  CALL Interrupt(&H2F, InReg, OutReg)„END IF„„Kurt Kuzba                     VERTICAL RETRACE DELAY         FidoNet QUIK_BAS Echo          07-21-95 (16:50)       QB, QBasic, PDS        42   1876     SCANTIMR.BAS'Does anybody know how stable this routine might be?„'Would it be necessary to test the scan intervals in a second„'in order to achieve accuracy, or would assumption of 70 scans„'per second be correct in all cases. With a resolution of 70:sec„'we get accuracy to .014285714 seconds, which is quite a bit„'better than the DOS clock at &H46C, with a resolution of 18:sec„'and an accuracy to .054931641 seconds. It would only take two„'seconds to run a test of the number of scans per second.„'Even with a slower video system, with a resolution of 60:sec„'we get accuracy to .016666667 seconds, or .02 with 50:sec.„'I'd like to avoid the routine to read the scans per second, which is„'   scans% = 0„'   begin& = timer„'   WHILE begin& = timer: WEND„'   begin& = timer„'   WHILE begin& = timer„'      WHILE (INP(&H3DA) AND 8): WEND„'      WHILE (INP(&H3DA) AND 8) = 0: WEND„'      scans% = scans% + 1„'   WEND„'but I fear it would be necessary unless the program specified VGA only.„'And does anybody know what is at I/O port 65, and what it is for?„„' [=-=]  SCANTIMR.BAS     [=-=] [=-=] [=-=] [=-=] [=-=] [=-=] [=-=]„' [=-=]  This program demonstrates a method for using the     [=-=]„' [=-=]  vertical retrace as a program timer.                 [=-=]„' [=-=]  Released to the Public Domain      by    Kurt Kuzba  [=-=]„' [=-=] [=-=] [=-=] [=-=] [=-=] [=-=] [=-=] [=-=] [=-=] [=-=] [=-=]„COLOR 9, 0: CLS„INPUT "Seconds to pause"; s!„PRINT "Pausing for"; INT(s! * 70); "scan intervals."„'PRINT "begin "; TIME$„PRINT "begin "; TIMER         '<-- Added by Carl!„FOR t% = 0 TO INT(s! * 70)„   WHILE (INP(&H3DA) AND 8): WEND„   WHILE (INP(&H3DA) AND 8) = 0: WEND„NEXT„'PRINT "end   "; TIME$„PRINT "end   "; TIMER         '<-- Added by Carl!„'BEEP„WHILE INKEY$ = "": WEND„' [=-=]  SCANTIMR.BAS     [=-=] [=-=] [=-=] [=-=] [=-=] [=-=] [=-=]„Douglas Lusher                 CLOCK SET                      FidoNet QUIK_BAS Echo          11-01-94 (00:00)       QB, QBasic, PDS        234  7102     CLOCKSET.BAS'Well, here we are at daylight saving time again. Thought I„'would repost this bit of code to set the time and date in„'a computer by calling the NIST (National Institute of„'Standards and Technology) and obtaining the correct values„'from their atomic clock. Just a note for those of you who„'may have gotten this code from when I have posted it in„'the past: this is an updated version, there were a couple„'of subtle bugs in the previously posted versions.„„ DEFINT A-Z„ CONST False = 0, True = NOT False„ CONST Modem = 1„„ TimeOut$ = "*** Time limit exceeded, program aborted"„ Abort$ = "*** Program aborted from keyboard"„„ PhoneNumber$ = "1-303-494-4774"„ 'this is the phone number for the National Institute for Standards„ 'and Technology in Colorado. It's the number I use for setting„ 'my computer's clock, so the rest of the program is written to use„ 'it. Listed below are some other numbers that you can call by„ 'modem for the same purpose, but I don't know anything about the„ 'service and info they provide.„„ 'PhoneNumber$ = "1-202-653-0351"„ 'the United States Naval Observatory in Anapolis, Maryland„„ 'PhoneNumber$ = "07-2217033"         ' Brisbane, Australia„ 'PhoneNumber$ = "03-6001641"         ' Melbourne, Australia„„ ComSpec$ = "COM1:1200,N,8,1,BIN,CS0,DS0"„ 'Change this ComSpec$ if your modem is on a different serial port.„ '1200 baud and 300 baud are the only speeds available at NIST„„ ON ERROR GOTO HandleError„ WIDTH 80„ PRINT„ PRINT "CLOCKSET.BAS"„ PRINT "A program to set the clock/calendar of an IBM compatible"„ PRINT "computer after obtaining the correct date and time via modem."„ PRINT "Written by Douglas H. Lusher, 11-01-1994"„ PRINT„ PRINT "Time Zone? <E>astern, <C>entral, <M>ountain, <P>acific: ";„ DO„   LOCATE , , 1: Ky$ = INPUT$(1): LOCATE , , 0„   IF Ky$ = CHR$(27) THEN PRINT : PRINT Abort$: END„   Ky$ = UCASE$(Ky$)„   TZ% = INSTR("ECMP", Ky$)„   IF TZ% THEN PRINT Ky$: TZ% = TZ% + 4: EXIT DO„   BEEP„ LOOP„ 'If you require other time zones, the above code will have„ 'to be altered. For Alaska, TZ% must be set equal to 9.„ 'For Hawaii, set TZ% equal to 11.„„ PRINT "Daylight Savings Time? <Y>es, <N>o: ";„ DO„   LOCATE , , 1: Ky$ = INPUT$(1): LOCATE , , 0„   IF Ky$ = CHR$(27) THEN PRINT : PRINT Abort$: END„   Ky$ = UCASE$(Ky$)„   IF Ky$ = "Y" OR Ky$ = "N" THEN PRINT Ky$: EXIT DO„   BEEP„ LOOP„ IF Ky$ = "Y" THEN TZ% = TZ% - 1„„ Abort% = False„ OPEN ComSpec$ FOR RANDOM AS #Modem„ PRINT #Modem, "ATZ"„ Start! = TIMER„ DO„   IF LineReceived(ModemInput$) THEN„     IF INSTR(ModemInput$, "OK") THEN EXIT DO„   ELSEIF INKEY$ = CHR$(27) THEN„     PRINT : PRINT Abort$: Abort% = True: EXIT DO„   ELSEIF TimeSince!(Start!) > 20 THEN„     PRINT : PRINT TimeOut$: Abort% = True: EXIT DO„   END IF„ LOOP„„ IF Abort% THEN GOTO ProgramEnd„„ SLEEP (3)„ PRINT #Modem, "ATDT"; PhoneNumber$„ Start! = TIMER„ DO„   IF LineReceived(ModemInput$) THEN„     IF INSTR(ModemInput$, "CONNECT") THEN„       EXIT DO„     ELSEIF INSTR(ModemInput$, "BUSY") THEN„       Abort% = True: EXIT DO„     ELSEIF INSTR(ModemInput$, "NO CARRIER") THEN„       Abort% = True: EXIT DO„     ELSEIF INSTR(ModemInput$, "ERROR") THEN„       Abort% = True: EXIT DO„     END IF„   ELSEIF INKEY$ = CHR$(27) THEN„     PRINT : PRINT Abort$: Abort% = True: EXIT DO„   ELSEIF TimeSince!(Start!) > 30 THEN„     PRINT : PRINT TimeOut$: Abort% = True: EXIT DO„   END IF„ LOOP„„ IF Abort% THEN GOTO ProgramEnd„„ Start! = TIMER„ LineCount% = 0„ DO„   IF LineReceived(ModemInput$) THEN„     'discard the first few lines to allow the connection„     '  to stabilize„     LineCount% = LineCount% + 1„     IF LineCount% > 10 THEN„       GOSUB SetClock„       IF ClockSet% THEN EXIT DO„     ELSEIF INSTR(ModemInput$, "NO CARRIER") THEN„       EXIT DO„     ELSEIF INSTR(ModemInput$, "ERROR") THEN„       EXIT DO„     END IF„   ELSEIF INKEY$ = CHR$(27) THEN„     PRINT : PRINT Abort$: EXIT DO„   ELSEIF TimeSince!(Start!) > 30 THEN„     PRINT : PRINT TimeOut$: EXIT DO„   END IF„ LOOP„„ ProgramEnd:„ PRINT #Modem, "+++";„ Start! = TIMER„ DO UNTIL TimeSince!(Start!) > 2: LOOP„ PRINT #Modem, "ATH0"„ Start! = TIMER„ DO„   IF LineReceived(ModemInput$) THEN„     IF INSTR(ModemInput$, "OK") THEN EXIT DO„   ELSEIF TimeSince!(Start!) > 20 THEN„     EXIT DO„   END IF„ LOOP„ CLOSE #Modem„ END„„ SetClock:„ 'lines containing the date and time info are„ '50 characters long and end with a "*" or "#"„ IF LEN(ModemInput$) <> 50 THEN„   ClockSet% = False: RETURN„ END IF„ IF MID$(ModemInput$, 50) <> "*" AND MID$(ModemInput$, 50) <> "#" THEN„   ClockSet% = False: RETURN„ END IF„ 'get the date info from the line„ D$ = MID$(ModemInput$, 10, 5) + "-19" + MID$(ModemInput$, 7, 2)„ IF VAL(MID$(ModemInput$, 7, 2)) < 94 THEN MID$(D$, 7, 2) = "20"„ 'get the time info„ T$ = MID$(ModemInput$, 16, 8)„ 'alter the time for the desired time zone„ Hour% = VAL(T$) - TZ%„ IF Hour% < 0 THEN„   'some adjustments will be necessary„   Hour% = Hour% + 24„   Day% = VAL(MID$(D$, 4, 2)) - 1„   IF Day% = 0 THEN„     Month% = VAL(MID$(D$, 1, 2)) - 1„     SELECT CASE Month%„       CASE 0„         Day% = 31„         Month% = 12„         Year% = VAL(MID$(D$, 7, 4)) - 1„         MID$(D$, 7, 4) = RIGHT$(STR$(Year%), 4)„       CASE 1, 3, 5, 7, 8, 10„         Day% = 31„       CASE 4, 6, 9, 11„         Day% = 30„       CASE 2„         Day% = 28„         Year% = VAL(MID$(D$, 7, 4))„         IF LeapYear(Year%) THEN Day% = 29„     END SELECT„     MID$(D$, 1, 2) = RIGHT$(STR$(Month% + 100), 2)„   END IF„   MID$(D$, 4, 2) = RIGHT$(STR$(Day% + 100), 2)„ END IF„ MID$(T$, 1, 2) = RIGHT$(STR$(Hour% + 100), 2)„ PRINT STRING$(58, "*")„ PRINT "  Current settings: Date: "; DATE$, "Time: "; TIME$„ DATE$ = D$: TIME$ = T$„ PRINT "      Corrected to: Date: "; DATE$, "Time: "; TIME$„ PRINT STRING$(58, "*"): PRINT„ ClockSet% = True„ RETURN„„ HandleError:„ ErrCode% = ERR„ IF ErrCode% = 57 THEN„   Err57% = Err57% + 1„   IF Err57% <= 5 THEN„     RESUME„   ELSE„     PRINT "Program terminated; too many I/O errors."„     RESUME ProgramEnd„   END IF„ ELSE„   PRINT "ERROR:"; ErrCode%; "- Program terminated."„   RESUME ProgramEnd„ END IF„„ FUNCTION LeapYear% (Year%) STATIC„ 'returns True (-1) if the specified year is a leap year„   LY% = (Year% MOD 4 = 0) AND (Year% MOD 100 <> 0)„   LY% = LY% OR (Year% MOD 400 = 0)„   LeapYear% = LY%„ END FUNCTION„„ FUNCTION LineReceived (Received$) STATIC„   CRLF$ = CHR$(13) + CHR$(10)„   LineReceived = False„   IF LOC(Modem) THEN„     NewChars$ = INPUT$(LOC(Modem), #Modem)„     PRINT NewChars$;„     Buffer$ = Buffer$ + NewChars$„     LineEnd% = INSTR(Buffer$, CRLF$)„     IF LineEnd% THEN„       Received$ = LEFT$(Buffer$, LineEnd% - 1)„       Buffer$ = MID$(Buffer$, LineEnd% + 2)„       LineReceived = True„     END IF„   END IF„ END FUNCTION„„ FUNCTION TimeSince! (Mark!)„   TimeNow! = TIMER„   TimeSince! = (TimeNow! - ((TimeNow! < Mark!) * 86400)) - Mark!„ END FUNCTION„Steve M. Wiegand               CALCULATE DAY OF WEEK          stevewie@ksc9.th.com           04-21-96 (16:23)       QB, QBasic, PDS        729  28534    DAYOWEEK.BAS'This program will calculate a day of the week for any year from 1753 to 2030„„DEFINT A-Z„DECLARE SUB TRANSLATE ()„DECLARE SUB LETTERS ()„DECLARE SUB LAYER1 ()„DECLARE SUB NORMAL1 ()„DECLARE SUB NORMAL0 ()„DECLARE SUB Initialize ()„DECLARE SUB FancyCls (dots%, Background%)„DECLARE SUB Center (Row%, text$)„DECLARE SUB OPENINTRO ()„DECLARE SUB Box (Row1%, Col1%, Row2%, Col2%)„DECLARE SUB PAUSE ()„DECLARE SUB DAYERROR ()„DECLARE SUB inputerror ()„DECLARE FUNCTION GetNum# (Row%, Col%)„CONST TRUE = -1„CONST FLASE = NOT TRUE„CONST BYEAR = 1753„COMMON SHARED P$(), P$, SIZE$„COMMON SHARED C1$, C2$, C3$„COMMON SHARED C4$, BGC, DOT$„COMMON SHARED SPACING$, Word$„COMMON SHARED PFT, PFL„COMMON SHARED m, d, y, nt%„DIM P$(122)„DIM SHARED Colorpref„DIM SHARED Colors(0 TO 20, 1 TO 4)„DIM SHARED year%(278)„DIM SHARED M1%(12), M2%(12), M3%(12), M4%(12), M5%(12), M6%(12), M7%(12)„DIM SHARED M8%(12), M9%(12), M10%(12), M11%(12), M12%(12), M13%(12), M14%(12)„DIM SHARED d1%(31), d2%(31), d3%(31), d4%(31), d5%(31), d6%(31), d7%(31)„DIM SHARED dn$(7)„DIM SHARED mn$(12): DIM SHARED mnu%(12)„CALL LETTERS                                'CALL LETTERSET„'„' Begin Mainline Code„'„Initialize„OPENINTRO„BEGIN:„Colorpref = 1„FancyCls Colors(2, Colorpref), Colors(1, Colorpref)„Box 9, 19, 15, 61„COLOR 7, 0„Center 11, "Enter the Century and Year (CCYY)"„nt% = 1„y = GetNum#(13, 38)„FancyCls Colors(2, Colorpref), Colors(1, Colorpref)„Box 9, 19, 15, 61„COLOR 7, 0„Center 11, "Enter the Month of the Year (01-12)"„nt% = 2„m = GetNum#(13, 39)„FancyCls Colors(2, Colorpref), Colors(1, Colorpref)„Box 9, 19, 15, 61„COLOR 7, 0„Center 11, "Enter the Day of the Month (01-31)"„nt% = 3„d = GetNum#(13, 39)„DATEEDIT:„IF m = 2 THEN„   z% = y MOD 4„   IF z% = 0 THEN„       mnu%(2) = 29„   END IF„END IF„IF d > mnu%(m) THEN„    CALL DAYERROR„    CALL PAUSE„    GOTO doagain„END IF„INDEX1 = (y - BYEAR) + 1„INDEX2 = year%(INDEX1)„SELECT CASE INDEX2„    CASE IS = 1„        index3 = M1%(m)„    CASE IS = 2„        index3 = M2%(m)„    CASE IS = 3„        index3 = M3%(m)„    CASE IS = 4„        index3 = M4%(m)„    CASE IS = 5„        index3 = M5%(m)„    CASE IS = 6„        index3 = M6%(m)„    CASE IS = 7„        index3 = M7%(m)„    CASE IS = 8„        index3 = M8%(m)„    CASE IS = 9„        index3 = M9%(m)„    CASE IS = 10„        index3 = M10%(m)„    CASE IS = 11„        index3 = M11%(m)„    CASE IS = 12„        index3 = M12%(m)„    CASE IS = 13„        index3 = M13%(m)„    CASE IS = 14„        index3 = M14%(m)„END SELECT„SELECT CASE index3„    CASE IS = 1„        bd% = d1%(d)„    CASE IS = 2„        bd% = d2%(d)„    CASE IS = 3„        bd% = d3%(d)„    CASE IS = 4„        bd% = d4%(d)„    CASE IS = 5„        bd% = d5%(d)„    CASE IS = 6„        bd% = d6%(d)„    CASE IS = 7„        bd% = d7%(d)„END SELECT„FancyCls Colors(2, Colorpref), Colors(1, Colorpref)„Box 9, 19, 15, 61„COLOR 7, 0„IF bd% > 7 OR bd% < 0 THEN„   LOCATE 10, 20, 0„   PRINT "Calculation Error - bd%"„   LOCATE 11, 41, 0„   PRINT bd%„   GOTO finish„END IF„z1$ = mn$(m): z2$ = STR$(d): z3$ = STR$(y): z4$ = z1$ + " " + z2$ + z3$„A$ = "The date entered is a " + dn$(bd%)„Center 10, z4$„Center 12, A$„A$ = ""„PAUSE„doagain:„FancyCls Colors(2, Colorpref), Colors(1, Colorpref)„Box 9, 19, 15, 61„COLOR 7, 0„Center 12, "Do another date ? [Y/N]"„LOCATE 14, 40, 1„WHILE INKEY$ <> "": WEND„DO„   kbd$ = UCASE$(INKEY$)„LOOP UNTIL kbd$ = "Y" OR kbd$ = "N"„IF kbd$ = "Y" THEN„   mnu%(2) = 28„   GOTO BEGIN„END IF„CLS„SYSTEM„finish:„END„„'The following data defines the color schemes available via the main menu.„'„'    scrn  dots  bar  back   title  shdow  choice  curs   cursbk  shdow„DATA 0,    7,    15,  7,     0,     7,     0,      15,    0,      0„DATA 1,    9,    12,  3,     0,     1,     15,     0,     7,      0„DATA 3,    15,   13,  1,     14,    3,     15,     0,     7,      0„DATA 7,    12,   15,  4,     14,    0,     15,     15,    1,      0„„'Box:„'  Draw a box on the screen between the given coordinates.„SUB Box (Row1, Col1, Row2, Col2) STATIC„    COLOR 14, 0„    BoxWidth = Col2 - Col1 + 1„„    LOCATE Row1, Col1„    PRINT "⁄"; STRING$(BoxWidth - 2, "ƒ"); "ø";„„    FOR A = Row1 + 1 TO Row2 - 1„        LOCATE A, Col1„        PRINT "≥"; SPACE$(BoxWidth - 2); "≥";„    NEXT A„„    LOCATE Row2, Col1„    PRINT "¿"; STRING$(BoxWidth - 2, "ƒ"); "Ÿ";„„END SUB„„DEFSNG A-Z„'Center:„'  Center text on the given row.„SUB Center (Row%, text$)„DEFINT A-Z„    LOCATE Row, 41 - LEN(text$) / 2„    PRINT text$;„END SUB„„SUB DAYERROR„z1$ = STR$(m)„z2$ = STR$(d)„z3$ = STR$(y)„LINE (158, 235)-(390, 249), 7, B„LINE (159, 236)-(389, 248), 15, BF„Word$ = "              " + z1$ + "/" + z2$ + "/" + z3$„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 245: PFL = 163: CALL NORMAL1„LINE (158, 262)-(390, 274), 7, B„LINE (159, 263)-(389, 273), 15, BF„Word$ = "The day of the month is invalid"„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 272: PFL = 163: CALL NORMAL1„LINE (158, 279)-(415, 291), 7, B„LINE (159, 280)-(414, 290), 15, BF„x$ = STR$(mnu%(m))„Word$ = "The month you selected has " + x$ + " days"„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 289: PFL = 163: CALL NORMAL1„LEAPYRERROR:„IF m < 2 OR m > 2 THEN„        GOTO exitsub„END IF„IF d > 29 THEN„        GOTO exitsub„END IF„LINE (158, 296)-(415, 308), 7, B„LINE (159, 297)-(414, 307), 15, BF„Word$ = "The year is not a leap year"„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 306: PFL = 163: CALL NORMAL1„„exitsub:„END SUB„„DEFSNG A-Z„'FancyCls:„'  Clears screen in the right color, and draws nice dots.„SUB FancyCls (dots%, Background%)„DEFINT A-Z„    VIEW PRINT 7 TO 25„    COLOR dots, Background„    CLS 2„„    FOR A = 560 TO 1820 STEP 45„        Row = A / 80 + 1„        Col = A MOD 80 + 1„        LOCATE Row, Col„        PRINT CHR$(250);„    NEXT A„END SUB„„'GetNum:„'  Gets valid numeric input from user„'Parameters:„'  Row, Col - location to echo input„FUNCTION GetNum# (Row, Col)„  result$ = ""„  Done = FALSE„  WHILE INKEY$ <> "": WEND   'Clear keyboard buffer„„  DO WHILE NOT Done„„    LOCATE Row, Col„    PRINT result$; CHR$(95); "    ";„    „    kbd$ = INKEY$„    SELECT CASE kbd$„      CASE "0" TO "9"„        result$ = result$ + kbd$„      CASE "."„        IF INSTR(result$, ".") = 0 THEN„          result$ = result$ + kbd$„        END IF„      CASE CHR$(13)„        IF (VAL(result$) > 2030 OR VAL(result$) < 1753) AND nt% = 1 THEN„          result$ = ""„            CALL inputerror„        ELSE„        IF (VAL(result$) > 12 OR VAL(result$) < 1) AND nt% = 2 THEN„          result$ = ""„          CALL inputerror„        ELSE„        IF (VAL(result$) > 31 OR VAL(result$) < 1) AND nt% = 3 THEN„          result$ = ""„          CALL inputerror„        ELSE„          Done = TRUE„        END IF„         END IF„          END IF„       „      CASE CHR$(8)„        IF LEN(result$) > 0 THEN„          result$ = LEFT$(result$, LEN(result$) - 1)„        END IF„      CASE ELSE„        IF LEN(kbd$) > 0 THEN„          BEEP„        END IF„      END SELECT„  LOOP„„  LOCATE Row, Col„  PRINT result$; " ";„„  GetNum# = VAL(result$)„'„END FUNCTION„„'Initialize:„'  Read colors in and set up assembly routines„SUB Initialize„year%(1) = 1: year%(2) = 2: year%(3) = 3: year%(4) = 11: year%(5) = 6: year%(6) = 7„year%(7) = 1: year%(8) = 9: year%(9) = 4: year%(10) = 5: year%(11) = 6: year%(12) = 14„year%(13) = 2: year%(14) = 3: year%(15) = 4: year%(16) = 12: year%(17) = 7: year%(18) = 1„year%(19) = 2: year%(20) = 10: year%(21) = 5: year%(22) = 6: year%(23) = 7: year%(24) = 8„year%(25) = 3: year%(26) = 4: year%(27) = 5: year%(28) = 13: year%(29) = 1: year%(30) = 2„year%(31) = 3: year%(32) = 11: year%(33) = 6: year%(34) = 7: year%(35) = 1: year%(36) = 9„year%(37) = 4: year%(38) = 5: year%(39) = 6: year%(40) = 14: year%(41) = 2: year%(42) = 3„year%(43) = 4: year%(44) = 12: year%(45) = 7: year%(46) = 1: year%(47) = 2: year%(48) = 3„year%(49) = 4: year%(50) = 5: year%(51) = 6: year%(52) = 14: year%(53) = 2: year%(54) = 3„year%(55) = 4: year%(56) = 12: year%(57) = 7: year%(58) = 1: year%(59) = 2: year%(60) = 10„year%(61) = 5: year%(62) = 6: year%(63) = 7: year%(64) = 8: year%(65) = 3: year%(66) = 4„year%(67) = 5: year%(68) = 13: year%(69) = 1: year%(70) = 2: year%(71) = 3: year%(72) = 11„year%(73) = 6: year%(74) = 7: year%(75) = 1: year%(76) = 9: year%(77) = 4: year%(78) = 5„year%(79) = 6: year%(80) = 14: year%(81) = 2: year%(82) = 3: year%(83) = 4: year%(84) = 12„year%(85) = 7: year%(86) = 1: year%(87) = 2: year%(88) = 10: year%(89) = 5: year%(90) = 6„year%(91) = 7: year%(92) = 8: year%(93) = 3: year%(94) = 4: year%(95) = 5: year%(96) = 13„year%(97) = 1: year%(98) = 2: year%(99) = 3: year%(100) = 11: year%(101) = 6: year%(102) = 7„year%(103) = 1: year%(104) = 9: year%(105) = 4: year%(106) = 5: year%(107) = 6: year%(108) = 14„year%(109) = 2: year%(110) = 3: year%(111) = 4: year%(112) = 12: year%(113) = 7: year%(114) = 1„year%(115) = 2: year%(116) = 10: year%(117) = 5: year%(118) = 6: year%(119) = 7: year%(120) = 8„year%(121) = 3: year%(122) = 4: year%(123) = 5: year%(124) = 13: year%(125) = 1: year%(126) = 2„year%(127) = 3: year%(128) = 11: year%(129) = 6: year%(130) = 7: year%(131) = 1: year%(132) = 9„year%(133) = 4: year%(134) = 5: year%(135) = 6: year%(136) = 14: year%(137) = 2: year%(138) = 3„year%(139) = 4: year%(140) = 12: year%(141) = 7: year%(142) = 1: year%(143) = 2: year%(144) = 10„year%(145) = 5: year%(146) = 6: year%(147) = 7: year%(148) = 1: year%(149) = 2: year%(150) = 3„year%(151) = 4: year%(152) = 12: year%(153) = 7: year%(154) = 1: year%(155) = 2: year%(156) = 10„year%(157) = 5: year%(158) = 6: year%(159) = 7: year%(160) = 8: year%(161) = 3: year%(162) = 4„year%(163) = 5: year%(164) = 13: year%(165) = 1: year%(166) = 2: year%(167) = 3: year%(168) = 11„year%(169) = 6: year%(170) = 7: year%(171) = 1: year%(172) = 9: year%(173) = 4: year%(174) = 5„year%(175) = 6: year%(176) = 14: year%(177) = 2: year%(178) = 3: year%(179) = 4: year%(180) = 12„year%(181) = 7: year%(182) = 1: year%(183) = 2: year%(184) = 10: year%(185) = 5: year%(186) = 6„year%(187) = 7: year%(188) = 8: year%(189) = 3: year%(190) = 4: year%(191) = 5: year%(192) = 13„year%(193) = 1: year%(194) = 2: year%(195) = 3: year%(196) = 11: year%(197) = 6: year%(198) = 7„year%(199) = 1: year%(200) = 9: year%(201) = 4: year%(202) = 5: year%(203) = 6: year%(204) = 14„year%(205) = 2: year%(206) = 3: year%(207) = 4: year%(208) = 12: year%(209) = 7: year%(210) = 1„year%(211) = 2: year%(212) = 10: year%(213) = 5: year%(214) = 6: year%(215) = 7: year%(216) = 8„year%(217) = 3: year%(218) = 4: year%(219) = 5: year%(220) = 13: year%(221) = 1: year%(222) = 2„year%(223) = 3: year%(224) = 11: year%(225) = 6: year%(226) = 7: year%(227) = 1: year%(228) = 9„year%(229) = 4: year%(230) = 5: year%(231) = 6: year%(232) = 14: year%(233) = 2: year%(234) = 3„year%(235) = 4: year%(236) = 12: year%(237) = 7: year%(238) = 1: year%(239) = 2: year%(240) = 10„year%(241) = 5: year%(242) = 6: year%(243) = 7: year%(244) = 8: year%(245) = 3: year%(246) = 4„year%(247) = 5: year%(248) = 13: year%(249) = 1: year%(250) = 2: year%(251) = 3: year%(252) = 11„year%(253) = 6: year%(254) = 7: year%(255) = 1: year%(256) = 9: year%(257) = 4: year%(258) = 5„year%(259) = 6: year%(260) = 14: year%(261) = 2: year%(262) = 3: year%(263) = 4: year%(264) = 12„year%(265) = 7: year%(266) = 1: year%(267) = 2: year%(268) = 10: year%(269) = 5: year%(270) = 6„year%(271) = 7: year%(272) = 8: year%(273) = 3: year%(274) = 4: year%(275) = 5: year%(276) = 13„year%(277) = 1: year%(278) = 2„M1%(1) = 1: M1%(2) = 4: M1%(3) = 4: M1%(4) = 7: M1%(5) = 2: M1%(6) = 5„M1%(7) = 7: M1%(8) = 3: M1%(9) = 6: M1%(10) = 1: M1%(11) = 4: M1%(12) = 6„M2%(1) = 2: M2%(2) = 5: M2%(3) = 5: M2%(4) = 1: M2%(5) = 3: M2%(6) = 6„M2%(7) = 1: M2%(8) = 4: M2%(9) = 7: M2%(10) = 2: M2%(11) = 5: M2%(12) = 7„M3%(1) = 3: M3%(2) = 6: M3%(3) = 6: M3%(4) = 2: M3%(5) = 4: M3%(6) = 7„M3%(7) = 2: M3%(8) = 5: M3%(9) = 1: M3%(10) = 3: M3%(11) = 6: M3%(12) = 1„M4%(1) = 4: M4%(2) = 7: M4%(3) = 7: M4%(4) = 3: M4%(5) = 5: M4%(6) = 1„M4%(7) = 3: M4%(8) = 6: M4%(9) = 2: M4%(10) = 4: M4%(11) = 7: M4%(12) = 2„M5%(1) = 5: M5%(2) = 1: M5%(3) = 1: M5%(4) = 4: M5%(5) = 6: M5%(6) = 2„M5%(7) = 4: M5%(8) = 7: M5%(9) = 3: M5%(10) = 5: M5%(11) = 1: M5%(12) = 3„M6%(1) = 6: M6%(2) = 2: M6%(3) = 2: M6%(4) = 5: M6%(5) = 7: M6%(6) = 3„M6%(7) = 5: M6%(8) = 1: M6%(9) = 4: M6%(10) = 6: M6%(11) = 2: M6%(12) = 4„M7%(1) = 7: M7%(2) = 3: M7%(3) = 3: M7%(4) = 6: M7%(5) = 1: M7%(6) = 4„M7%(7) = 6: M7%(8) = 2: M7%(9) = 5: M7%(10) = 7: M7%(11) = 3: M7%(12) = 5„M8%(1) = 1: M8%(2) = 4: M8%(3) = 5: M8%(4) = 1: M8%(5) = 3: M8%(6) = 6„M8%(7) = 1: M8%(8) = 4: M8%(9) = 7: M8%(10) = 2: M8%(11) = 5: M8%(12) = 7„M9%(1) = 2: M9%(2) = 5: M9%(3) = 6: M9%(4) = 2: M9%(5) = 4: M9%(6) = 7„M9%(7) = 2: M9%(8) = 5: M9%(9) = 1: M9%(10) = 3: M9%(11) = 6: M9%(12) = 1„M10%(1) = 3: M10%(2) = 6: M10%(3) = 7: M10%(4) = 3: M10%(5) = 5: M10%(6) = 1„M10%(7) = 3: M10%(8) = 6: M10%(9) = 2: M10%(10) = 4: M10%(11) = 7: M10%(12) = 2„M11%(1) = 4: M11%(2) = 7: M11%(3) = 1: M11%(4) = 4: M11%(5) = 6: M11%(6) = 2„M11%(7) = 4: M11%(8) = 7: M11%(9) = 3: M11%(10) = 5: M11%(11) = 1: M11%(12) = 3„M12%(1) = 5: M12%(2) = 1: M12%(3) = 2: M12%(4) = 5: M12%(5) = 7: M12%(6) = 3„M12%(7) = 5: M12%(8) = 1: M12%(9) = 4: M12%(10) = 6: M12%(11) = 2: M12%(12) = 4„M13%(1) = 6: M13%(2) = 2: M13%(3) = 3: M13%(4) = 6: M13%(5) = 1: M13%(6) = 4„M13%(7) = 6: M13%(8) = 2: M13%(9) = 5: M13%(10) = 7: M13%(11) = 3: M13%(12) = 5„M14%(1) = 7: M14%(2) = 3: M14%(3) = 4: M14%(4) = 7: M14%(5) = 2: M14%(6) = 5„M14%(7) = 7: M14%(8) = 3: M14%(9) = 6: M14%(10) = 1: M14%(11) = 4: M14%(12) = 6„dn$(1) = "MONDAY   ": dn$(2) = "TUESDAY  ": dn$(3) = "WEDNESDAY": dn$(4) = "THURSDAY ": dn$(5) = "FRIDAY   ": dn$(6) = "SATURDAY ": dn$(7) = "SUNDAY"„d1%(1) = 1: d1%(2) = 2: d1%(3) = 3: d1%(4) = 4: d1%(5) = 5: d1%(6) = 6:„d1%(7) = 7: d1%(8) = 1: d1%(9) = 2: d1%(10) = 3„d1%(11) = 4: d1%(12) = 5: d1%(13) = 6: d1%(14) = 7: d1%(15) = 1: d1%(16) = 2: d1%(17) = 3: d1%(18) = 4: d1%(19) = 5: d1%(20) = 6„d1%(21) = 7: d1%(22) = 1: d1%(23) = 2: d1%(24) = 3: d1%(25) = 4: d1%(26) = 5: d1%(27) = 6: d1%(28) = 7: d1%(29) = 1: d1%(30) = 2„d1%(31) = 3„d2%(1) = 2: d2%(2) = 3: d2%(3) = 4: d2%(4) = 5: d2%(5) = 6: d2%(6) = 7: d2%(7) = 1: d2%(8) = 2: d2%(9) = 3: d2%(10) = 4„d2%(11) = 5: d2%(12) = 6: d2%(13) = 7: d2%(14) = 1: d2%(15) = 2: d2%(16) = 3: d2%(17) = 4: d2%(18) = 5: d2%(19) = 6: d2%(20) = 7„d2%(21) = 1: d2%(22) = 2: d2%(23) = 3: d2%(24) = 4: d2%(25) = 5: d2%(26) = 6: d2%(27) = 7: d2%(28) = 1: d2%(29) = 2: d2%(30) = 3„d2%(31) = 4„d3%(1) = 3: d3%(2) = 4: d3%(3) = 5: d3%(4) = 6: d3%(5) = 7: d3%(6) = 1: d3%(7) = 2: d3%(8) = 3: d3%(9) = 4: d3%(10) = 5„d3%(11) = 6: d3%(12) = 7: d3%(13) = 1: d3%(14) = 2: d3%(15) = 3: d3%(16) = 4: d3%(17) = 5: d3%(18) = 6: d3%(19) = 7: d3%(20) = 1„d3%(21) = 2: d3%(22) = 3: d3%(23) = 4: d3%(24) = 5: d3%(25) = 6: d3%(26) = 7: d3%(27) = 1: d3%(28) = 2: d3%(29) = 3: d3%(30) = 4„d3%(31) = 5„d4%(1) = 4: d4%(2) = 5: d4%(3) = 6: d4%(4) = 7: d4%(5) = 1: d4%(6) = 2: d4%(7) = 3: d4%(8) = 4: d4%(9) = 5: d4%(10) = 6„d4%(11) = 7: d4%(12) = 1: d4%(13) = 2: d4%(14) = 3: d4%(15) = 4: d4%(16) = 5: d4%(17) = 6: d4%(18) = 7: d4%(19) = 1: d4%(20) = 2„d4%(21) = 3: d4%(22) = 4: d4%(23) = 5: d4%(24) = 6: d4%(25) = 7: d4%(26) = 1: d4%(27) = 2: d4%(28) = 3: d4%(29) = 4: d4%(30) = 5„d4%(31) = 6„d5%(1) = 5: d5%(2) = 6: d5%(3) = 7: d5%(4) = 1: d5%(5) = 2: d5%(6) = 3: d5%(7) = 4: d5%(8) = 5: d5%(9) = 6: d5%(10) = 7„d5%(11) = 1: d5%(12) = 2: d5%(13) = 3: d5%(14) = 4: d5%(15) = 5: d5%(16) = 6: d5%(17) = 7: d5%(18) = 1: d5%(19) = 2: d5%(20) = 3„d5%(21) = 4: d5%(22) = 5: d5%(23) = 6: d5%(24) = 7: d5%(25) = 1: d5%(26) = 2: d5%(27) = 3: d5%(28) = 4: d5%(29) = 5: d5%(30) = 2„d5%(31) = 7„d6%(1) = 6: d6%(2) = 7: d6%(3) = 1: d6%(4) = 2: d6%(5) = 3: d6%(6) = 4: d6%(7) = 5: d6%(8) = 6: d6%(9) = 7: d6%(10) = 1„d6%(11) = 2: d6%(12) = 3: d6%(13) = 4: d6%(14) = 5: d6%(15) = 6: d6%(16) = 7: d6%(17) = 1: d6%(18) = 2: d6%(19) = 3: d6%(20) = 4„d6%(21) = 5: d6%(22) = 6: d6%(23) = 7: d6%(24) = 1: d6%(25) = 2: d6%(26) = 3: d6%(27) = 4: d6%(28) = 5: d6%(29) = 6: d6%(30) = 7„d6%(31) = 1„d7%(1) = 7: d7%(2) = 1: d7%(3) = 2: d7%(4) = 3: d7%(5) = 4: d7%(6) = 5: d7%(7) = 6: d7%(8) = 7: d7%(9) = 1: d7%(10) = 2„d7%(11) = 3: d7%(12) = 4: d7%(13) = 5: d7%(14) = 6: d7%(15) = 7: d7%(16) = 1: d7%(17) = 2: d7%(18) = 3: d7%(19) = 4: d7%(20) = 5„d7%(21) = 6: d7%(22) = 7: d7%(23) = 1: d7%(24) = 2: d7%(25) = 3: d7%(26) = 4: d7%(27) = 5: d7%(28) = 6: d7%(29) = 7: d7%(30) = 1„d7%(31) = 2„mn$(1) = "January": mn$(2) = "February": mn$(3) = "March": mn$(4) = "April": mn$(5) = "May": mn$(6) = "June"„mn$(7) = "July": mn$(8) = "August": mn$(9) = "September": mn$(10) = "October": mn$(11) = "November": mn$(12) = "December"„mnu%(1) = 31: mnu%(2) = 28: mnu%(3) = 31: mnu%(4) = 30: mnu%(5) = 31: mnu%(6) = 30: mnu%(7) = 31: mnu%(8) = 31: mnu%(9) = 30: mnu%(10) = 31: mnu%(11) = 30: mnu%(12) = 31„„FOR ColorSet = 1 TO 4„     FOR x = 1 TO 10„            READ Colors(x, ColorSet)„     NEXT x„NEXT ColorSet„„END SUB„„SUB inputerror„LINE (158, 235)-(390, 249), 7, B„LINE (159, 236)-(389, 248), 15, BF„Word$ = "Input Error"„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 245: PFL = 163: CALL NORMAL1„LINE (158, 262)-(390, 274), 7, B„LINE (159, 263)-(389, 273), 15, BF„IF nt% = 1 THEN„   Word$ = "The Year entered is invalid"„ELSEIF nt% = 2 THEN„   Word$ = "The Month entered is invalid"„ELSEIF nt% = 3 THEN„   Word$ = "The Day entered is invalid"„END IF„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 272: PFL = 163: CALL NORMAL1„LINE (158, 279)-(415, 291), 7, B„LINE (159, 280)-(414, 290), 15, BF„IF nt% = 1 THEN„    Word$ = "Valid range is 1753 - 2030"„ELSEIF nt% = 2 THEN„    Word$ = "Valid range is 1 - 12"„ELSEIF nt% = 3 THEN„    Word$ = "Valid range is 1 -31"„END IF„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 289: PFL = 163: CALL NORMAL1„LINE (158, 296)-(415, 308), 7, B„LINE (159, 297)-(414, 307), 15, BF„Word$ = "Please re-enter"„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 4"„C2$ = "C12"„PFT = 306: PFL = 163: CALL NORMAL1„„END SUB„„SUB LAYER1„  PSET (PFL + 2, PFT + 5), BGC: DRAW C3$ + P$„  PSET (PFL + 0, PFT + 5), BGC: DRAW C3$ + P$„  PSET (PFL + 1, PFT + 5), BGC: DRAW C3$ + P$„  PSET (PFL + 0, PFT + 4), BGC: DRAW C3$ + P$„  PSET (PFL + 1, PFT + 2), BGC: DRAW C2$ + P$„  PSET (PFL + 2, PFT + 4), BGC: DRAW C1$ + P$„  PSET (PFL + 3, PFT + 3), BGC: DRAW C4$ + P$„  PSET (PFL + 3, PFT + 2), BGC: DRAW C2$ + P$„  PSET (PFL + 4, PFT + 4), BGC: DRAW C2$ + P$„  PSET (PFL + 5, PFT + 2), BGC: DRAW C3$ + P$„  PSET (PFL + 5, PFT + 3), BGC: DRAW C2$ + P$„  PSET (PFL + 4, PFT + 3), BGC: DRAW C1$ + P$„END SUB„„SUB LETTERS„   P$(32) = "BR4"                                                  'SPACE„   P$(33) = "BR1BD1U1BU2U5BD7BR3"                                  '!„   P$(34) = "BR0BU7D2BR2U2BD7BR3"                                  '"„   P$(35) = "BD1BR1U8D2L1R5L1U2D8U2L4R5BR2BD1"                     '#„   P$(36) = "BD1BR3U8D8BL3BU5U1E1R3F1BD1BL5F1R3F1D1G1L3H1BR7BD1"   '$„   P$(37) = "BD1U1E6U1BL5BD2U1R1D1L1BD4BR4R1D1L1U1BD1BR5"          '%„   P$(38) = "BR1BU2BL1E3U1H1L1G1D1F6BU1BL5BU3G2D1F1R3E3BD2BR2"     '&„   P$(39) = "BR2BU7D1G1BD5BR4"                                     ''„   P$(40) = "BR1BD1BU2U4E2G2D4F2BU1BR4"                            '(„   P$(41) = "BR2BD1BU2U4H2F2D4G2BU1BR5"                            ')„   P$(42) = "BR2BU2U6D3L2R4BL4BD2E4BL4F4BD3BR4"                    '*„   P$(43) = "BR2BD1U7D3L2R5BD3BR3"                                 '+„   P$(44) = "BD1U1R1D2G1BU3BR4"                                    ',„   P$(45) = "BR1BU3R3L3BD3BR5"                                     '-„   P$(46) = "BD1BR1L1BU1BR4"                                       '.„   P$(47) = "BR1E5G5BR7"                                           '/„   P$(48) = "BD1BU1U6E1R2F1D6G1L2H1BR6"                            '0„   P$(49) = "BD1BR2U7BL1E1D1BD6BR3"                                '1„   P$(50) = "BR1BU6E1R2F1D2G4D1R4BU1BR3"                           '2„   P$(51) = "BU6E1R2F1D2G1L2R2F1D2G1L2H1BR7"                       '3„   P$(52) = "BU3E4D8U4L4R5BD3BR3"                                  '4„   P$(53) = "BR1BU3U4R4L4D4E1R2F1D3G1L2H1BR7"                      '5„   P$(54) = "BR1BD1BU4U3E1R2F1H1L2G1D6F1R2E1U3H1L2G1BD3BR6"        '6„   P$(55) = "BR1BU7R4D3G4D1BU1BR7"                                 '7„   P$(56) = "BR1BU6E1R2F1D2G1L2R2F1D2G1L2H1U2E1H1U2BD6BR7"         '8„   P$(57) = "BR1BU4U2E1R2F1D6G1L2H1BU4F1R3BD3BR3"                  '9„   P$(58) = "BR1U1BU2U1BD4BR3"                                     ':„   P$(59) = "BD1BR1BU1U1BU2U1BD4G1BU1BR6"                          ';„   P$(60) = "BU3E3G3F3BR3"                                         '<„   P$(61) = "BU3R4BD2L4BR7BD1"                                     '=„   P$(62) = "BU6BR1F3G3BR5"                                        '>„   P$(63) = "BR1BU5U1E1R2F1D2G1D1BD2D1BU1BR3"                      '?„   P$(64) = "BD1BU1U6E1R3F1D5L2H1U2E1R1D3BD3L3H1F1R3E1BR3"         '@„   P$(65) = "BD1U7E1R3F1D3L5R5D4BR4BU1"                            'A„   P$(66) = "BD1U8R4F1D2G1L4R4F1D2G1L4BU1BR9"                      'B„   P$(67) = "BD1BU1U6E1R3F1BD6G1L3H1F1R3BR4BU1"                    'C„   P$(68) = "BD1U8R4F1D6G1L4BR9BU1 "                               'D„   P$(69) = "BD1U8R4L4D4R3L3D4R4BU1BR4"                            'E„   P$(70) = "BD1U8R5L5D4R4L4D4BR8BU1"                              'F„   P$(71) = "BD1BU1U6E1R3F1BD6G1L3H1F1R3E1U3L2R2D3BR4"             'G„   P$(72) = "BD1U8D4R4U4D8BR4BU1"                                  'H„   P$(73) = "BD1BR3U8L1R2L1D8L1R2BR4BU1"                           'I„   P$(74) = "BD1BU1F1R2E1U7L1R2L1D7BR5"                            'J„   P$(75) = "BD1BU8D8U4R1E4G4F4BR4BU1"                             'K„   P$(76) = "BD1BU8D8R4BU1BR4"                                     'L„   P$(77) = "BD1U7E1R2F1D7U7E1R2F1D7BU1BR4"                        'M„   P$(78) = "BD1U8F7D1U8D8BR4BU1"                                  'N„   P$(79) = "BD1BU1U6E1R3F1BD6G1L3H1BR5U6D6BR4"                    'O„   P$(80) = "BD1U8R4F1D2G1L4D4BR9BU1"                              'P„   P$(81) = "BD1BU1U6E1R3F1BD6G1L3H1BR5U6BL3BD5F3BG3BR7BU5"        'Q„   P$(82) = "BD1U8R4F1D2G1L4R1F4BR4BU1"                            'R„   P$(83) = "BD1BU5U2E1R3F1BD2BL5F1R3F1D2G1L3H1BR9"                'S„   P$(84) = "BR3BD1BU8L4R6L3D8BR6BU1"                              'T„   P$(85) = "BD1BU1U7D7F1R3E1U7D7BR4"                              'U„   P$(86) = "BD1BU8D5F2D1U1E2U5D5BR5BD2"                           'V„   P$(87) = "BD1BU1U7D7F1R2E1U7D7F1R2E1U7D7BD1BR4BU1"              'W„   P$(88) = "BD1BU8D1F3E3U1D1G6D1U1E3F3D1BU1BR5"                   'X„   P$(89) = "BL1BU5U2D2F3E3U2D2G3D3BU1BR7"                         'Y„   P$(90) = "BU7R5D2G5D1R5BR4BU1"                                  'Z„   P$(91) = "BR1BD1BR3L3U8R3BR3BD7"                                '[„   P$(92) = "BU5F5BR3"                                             '\„   P$(93) = "BD1R3U8L3BR2BD7BR4"                                   ']„   P$(94) = "BR1BU5E2F2BD5BR2"                                     '^„   P$(95) = "BD1R4BU1BL2BR5"                                       '_„   P$(96) = "BR2BU7D1F1BD5BR2"                                     '`„   P$(97) = "U2E1R3U1H1L2G1E1R2F1D4G1L2H1F1BR2E1U2D3BR4BU1"        'a„   P$(98) = "BD1U8D8R3E1U4H1L2G1D4BR8"                             'b„   P$(99) = "BR0U4E1R2F1BD4G1L2H1F1R2E1BR4"                        'c„   P$(100) = "U4E1R2F1H1L2G1D4F1R2E1U7D7D1BU1BR4"                  'd„   P$(101) = "U4E1R2F1D2L4D2F1R2E1BR4"                             'e„   P$(102) = "BR1BD1U7E1R2F1H1L2G1D3L1R3BD3BR5"                    'f„   P$(103) = "U4E1R2F1D4G1L2H1BD3F1R2E1U3BR4"                      'g„   P$(104) = "BU7D8U5E1R2F1D5BU1BR4"                               'h„   P$(105) = "BR3BD1U6BU2BD7BR4"                                   'i„   P$(106) = "BR1BD1U6BU2BD7D3G1L2BU4BR8"                          'j„   P$(107) = "BD1BU8D8U3E3G3F3BU1BR3"                              'k„   P$(108) = "BR1BD1U8L1R1D8L1R2BR4BU1"                            'l„   P$(109) = "BD1U6D1E1R1F1D5U5E1R1F1D5BU1BR4"                     'm„   P$(110) = "BD1U6D1E1R2F1D5U4BD3BR4"                             'n„   P$(111) = "U4E1R2F1D4G1L2H1BR8"                                 'o„   P$(112) = "U4E1R2F1D4G1L2H1D4U4BR8"                             'p„   P$(113) = "U4E1R2F1D4G1L2H1BR4D4L1R2L1U4BR5"                    'q„   P$(114) = "BD1U6D1E1R2F1H1L2G1U1D6BU1BR7"                       'r„   P$(115) = "BU3U1E1R2F1H1L2G1D1F1R2F1D1G1L2H1BR8"                's„   P$(116) = "BR1BU7D2L2R4L2D5F1R1E1BR4"                           't„   P$(117) = "U5D5F1R2E1U5D5BR4"                                   'u„   P$(118) = "BD1BU6D3F2D1U1E2U3D3BD2BR4"                          'v„   P$(119) = "BD1BU6D5F1R1E1U4D4F1R1E1U5D5BR4"                     'w„   P$(120) = "BD1BU6D1F2E2U1D1G4D1U1E2F2D1BU1BR4"                  'x„   P$(121) = "BU5D5F1R2E1U5D8G1L2H1BU3BR8"                         'y„   P$(122) = "BU5R4D1G4D1R4BU1BR4"                                 'z„END SUB„„SUB NORMAL0„PSET (PFL + 0, PFT + 0), BGC: DRAW C1$ + P$„END SUB„„SUB NORMAL1„    PSET (PFL + 0, PFT + 1), BGC: DRAW C2$ + P$„    PSET (PFL + 1, PFT + 0), BGC: DRAW C1$ + P$„    PSET (PFL + 2, PFT + 0), BGC: DRAW C1$ + P$„END SUB„„SUB OPENINTRO„COLOR 7, 0„SCREEN 9                                    'SET SCREEN MODE TO 9„CLS„LINE (1, 1)-(590, 72), 13, B„LINE (3, 3)-(588, 70), 7, BF„Word$ = "What Day Was It ?"„SPACING$ = "L1"„SIZE$ = "20"„DOT$ = "N"„BGC = 7„CALL TRANSLATE„C1$ = "C 5": C2$ = "C 8": C3$ = "C 8": C4$ = "C 8"„PFT = 52: PFL = 16: CALL LAYER1„PFT = 52: PFL = 14: CALL LAYER1„PFT = 52: PFL = 12: CALL LAYER1„C1$ = "C 5": C2$ = "C 0": C3$ = "C 0": C4$ = "C15"„PFT = 50: PFL = 18: CALL LAYER1„PFT = 50: PFL = 17: CALL LAYER1„Colorpref = 1„FancyCls Colors(2, Colorpref), Colors(1, Colorpref)„„LINE (158, 100)-(390, 116), 7, B„LINE (159, 101)-(389, 115), 15, BF„Word$ = "Display Any Day of the Week for"„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 1"„C2$ = "C 9"„PFT = 110: PFL = 163: CALL NORMAL1„LINE (158, 122)-(390, 138), 7, B„LINE (159, 123)-(389, 137), 15, BF„Word$ = "   Any Date Between 1753 - 2030"„SPACING$ = "R0"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 1"„C2$ = "C 9"„PFT = 132: PFL = 163: CALL NORMAL1„„HITENTER:„LINE (228, 337)-(340, 350), 7, BF„Word$ = "Press any Key"„SPACING$ = "R1"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 0"„C2$ = "C 8"„PFT = 346: PFL = 231: CALL NORMAL1„INKEY1:„C1$ = "C 0"„C2$ = "C 8"„PFT = 346: PFL = 231: CALL NORMAL1„SLEEP 1„C1$ = "C 4"„C2$ = "C 8"„PFT = 346: PFL = 231: CALL NORMAL1„SLEEP 1„A$ = INKEY$: IF A$ = "" THEN GOTO INKEY1„END SUB„„SUB PAUSE„LINE (248, 337)-(360, 350), 7, BF„Word$ = "Press any Key"„SPACING$ = "R1"„SIZE$ = " 4"„DOT$ = "N"„BGC = 15„CALL TRANSLATE„C1$ = "C 0"„C2$ = "C 8"„PFT = 346: PFL = 251: CALL NORMAL1„INKEY2:„C1$ = "C 0"„C2$ = "C 8"„PFT = 346: PFL = 251: CALL NORMAL1„SLEEP 1„C1$ = "C 4"„C2$ = "C 8"„PFT = 346: PFL = 251: CALL NORMAL1„SLEEP 1„A$ = INKEY$: IF A$ = "" THEN GOTO INKEY2„END SUB„„SUB TRANSLATE„  SPACING$ = "B" + UCASE$(SPACING$)„     SIZE$ = "S" + UCASE$(SIZE$)„  P$(105) = "BR0BD1U6BU2BD7BR4"                     'i„  P$(106) = "BR1BD1U6BU2BD7D3G1L2BU4BR8"            'j„  IF DOT$ = "Y" THEN P$(105) = "BR0BD1U6BU1U1BD7BR4"            'DOT OVER i„  IF DOT$ = "Y" THEN P$(106) = "BR1BD1U6BU1U1BD7D3G1L2BU4BR8"   'DOT OVER j„  P$ = SIZE$„  FOR J = 1 TO LEN(Word$)„  P$ = P$ + P$(ASC(MID$(Word$, J, 1))) + SPACING$„  NEXT J„END SUB„Egbert Zijlema                 SEVERAL DATE & TIME ROUTINES   E.Zijlema@uni4nn.iaf.nl        06-14-96 (13:33)       PB                     494  15137    TIMEDATE.BAS$LIB ALL OFF„$ERROR ALL OFF„$OPTIMIZE SIZE„$COMPILE EXE      ' compile it to let the daylight saving part run„„' TIMEDATE.BAS    - Routines for date and time processing„„' Author          : Egbert Zijlema <E.Zijlema@uni4nn.iaf.nl>„' Date            : June 14, 1996„' Copyright status: Public Domain„„' TIMEDATE.BAS contains several routines to manipulate date and time„' It includes a test for Daylight Saving:„' On first use it stores the actual half year ("SUMMER" or "WINTER") at„' the end of the file. Therefore the DLS-part of this demo does not work„' in the IDE, in order to make sure PB.EXE itself will not become affected.„„' If you include TIMEDATE.EXE in your AUTOEXEC.BAT file, it will check„' for Daylight Saving on every startup. In that case leave the demo's„' out and rewrite the main module before compiling, as follows:„„'                          CLS„'                          DayLightSaving„'                          END„„' Credit: The routine to detect the file's own path (FUNCTION MySelf)„'         comes from Thomas Gohel, the maintainer of the PBSound WebSite„'         in Germany. Thank you, Thomas!„„DEFINT A - Z„„daydata:„  DATA Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday„monthdata:„  DATA January, February, March, April, May, June, July, August„  DATA September, October, November, December„daysinmonthdata:„  DATA 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31„„' Trim all spaces from both ends of a string„FUNCTION TRIM(BYVAL text AS STRING) AS STRING„  FUNCTION = LTRIM$(RTRIM$(text))„END FUNCTION„„' Right align a string„FUNCTION rgtALIGN(BYVAL text AS STRING, BYVAL length) AS STRING„  FUNCTION = RIGHT$(SPACE$(length) + text, length)„END FUNCTION„„FUNCTION MySelf AS STRING„„  ' from Thomas Gohel, Germany„  ' detects the full pathname of the running executable„„  ! mov ax, &H6200„  ! int &H21„  ! mov es, bx„  ! mov ax, WORD PTR es:[&H2C]„  ! mov pbvDefSeg, ax           ; undocumented in PowerBASIC 3.0„„  count = 0„  DO„    INCR count„  LOOP UNTIL PEEK$(count, 4) = CHR$(0, 0, 1, 0)„„  DO WHILE PEEK(count + 4) <> 0„    temp$ = temp$ + CHR$(PEEK(count + 4))„    INCR count„  LOOP„„  DEF SEG„„  FUNCTION = temp$„END FUNCTION„„FUNCTION Julian& (InDate$)„„  ' converts a date into it's Julian number„  IF LEN(InDate$) < 10 THEN EXIT FUNCTION    ' format "mm-dd-[-]yyyy"„  Y& = VAL( MID$(InDate$, 7) )               ' year (maybe negative = b.C.)„  M& = VAL( LEFT$(InDate$, 2) )              ' month„  D& = VAL( MID$(InDate$, 4, 2) )            ' day„  temp& = (M& - 14) \ 12„  JulPart& = D& - 32075 + (1461 * (Y& + 4800 + temp&) \ 4)„  JulPart& = JulPart& + (367 * (M& - 2 - temp& * 12) \ 12)„„  FUNCTION = JulPart& - (3 * ((Y& + 4900 + temp&) \ 100) \ 4)„END FUNCTION„„SUB JulToDate (JN&, ResultDate$)„„  ' converts the Julian number of a date into it's„  ' date form ("mm-dd-[-]yyyy")„  JulNumber& = JN& + 68569„  help& = 4 * JulNumber& \ 146097„  JulNumber& = JulNumber& - (146097 * help& + 3) \ 4„  TempYear& = 4000 * (JulNumber& + 1) \ 1461001„  JulNumber& = JulNumber& - (1461 * TempYear& \ 4) + 31„  TempMonth& = 80 * JulNumber& \ 2447„  day = CINT(JulNumber& - (2447 * TempMonth& \ 80))„  month = CINT(TempMonth& + 2 - (12 * (TempMonth& \ 11)))„  year = CINT(100 * (help& - 49) + TempYear& + (TempMonth& \ 11))„  month$ = rgtALIGN(STR$(month), 2) + "-"„  day$ = rgtALIGN(STR$(day), 2) + "-"„  year$ = rgtALIGN(STR$(ABS(year)), 4)               ' maybe negative„  REPLACE CHR$(32) WITH "0" IN year$„  IF year < 0 THEN year$ = "-" + year$„  ResultDate$  = month$ + day$ + year$„  REPLACE CHR$(32) WITH "0" IN ResultDate$„END SUB„„FUNCTION LeapYear (TestYear$)„„  ' tests if a given year is a leap year„  JulNumber& = Julian&("02-28-" + TestYear$)„  INCR JulNumber&                                ' the next day we need!„  JulToDate JulNumber&, Result$                  ' convert to stringformat„„  IF LEFT$(Result$, 5) = "02-29" THEN„    FUNCTION = 1„  ELSE„    FUNCTION = 0„  END IF„END FUNCTION„„FUNCTION DayWeek (InDate$)„    ' returns a number for each day of the week„    ' range 1...7 = Monday up to Sunday„„  month = VAL( LEFT$(InDate$, 2) )„  day   = VAL( MID$(InDate$, 4, 2) )„  year  = VAL( MID$(InDate$, 7) )„„  DECR month, 2„  IF month < 1 OR month > 10 THEN„    INCR month, 12 : DECR year„  END IF„  century = year \ 100„  year = year MOD 100„  temp = INT(2.6 * month - .19) + day + year + (year \ 4)„  result = (temp + (century \ 4) - (century * 2)) MOD 7„  IF result = 0 THEN result = 7                       ' Sunday = 7„„  FUNCTION = result„END FUNCTION„„SUB LastSunday(month$, sunday&)„  day = 32„  DO„    DECR day„    InDate$ = month$ + TRIM(STR$(day)) + MID$(DATE$, 6)„    number = DayWeek(InDate$)„  LOOP UNTIL number = 7„  sunday& = Julian&(InDate$)„END SUB„„FUNCTION DayLightBegin&„  ' returns last Sunday of March as Julian„„  LastSunday "03-", temp&„  FUNCTION = temp&„END FUNCTION„„FUNCTION DayLightEnd&„  ' returns last Sunday of October as Julian„„  LastSunday "10-", temp&„  FUNCTION = temp&„END FUNCTION„„SUB DayLightSaving„  TestDate& = Julian&(DATE$)„  SELECT CASE TestDate&„    CASE < DayLightBegin&, > DayLightEnd&„      clock = -1„    CASE DayLightBegin&„      IF VAL( LEFT$(TIME$, 2) ) < 2 THEN clock = -1 ELSE clock = 1„    CASE DayLightEnd&„      IF VAL( LEFT$(TIME$, 2) ) > 2 THEN clock = -1 ELSE clock = 1„    CASE ELSE„      clock = 1„  END SELECT„  IF clock = 1 THEN dlsFlag$ = "SUMMER" ELSE dlsFlag$ = "WINTER"„  handle = FREEFILE„  OPEN "B", #handle, MySelf„  SEEK #handle, LOF(1) - 6„  GET$ #handle, 6, setting$„„  ' if newly installed:„  IF setting$ <> "SUMMER" AND setting$ <> "WINTER" THEN„    CLOSE #handle„    InstallActualSetting dlsFlag$„    EXIT SUB„  END IF„„  IF setting$ <> dlsFlag$ THEN„    SEEK #handle, LOF(handle) - 6„    PUT$ #handle, dlsFlag$„    AdjustTime clock„  END IF„  CLOSE #handle„END SUB„„SUB InstallActualSetting(flag$)„  handle = FREEFILE„  OPEN "B", #handle, MySelf„  SEEK #handle, LOF(handle)„  PUT$ #handle, flag$„  CLOSE #handle„END SUB„„SUB AdjustTime(clock)„„  ' change the clock by 1 hour + or -„  ' adjust date, if necessary„  hour = VAL( LEFT$(TIME$, 2) )„  INCR hour, clock                          ' clock = -1 or +1„  IF hour > 23 THEN„    DECR hour, 24„    JulToDate Julian&(DATE$) + 1, ResultDate$„    DATE$ = ResultDate$„  ELSEIF hour < 0 THEN„    INCR hour, 24„    JulToDate Julian&(DATE$) - 1, ResultDate$„    DATE$ = ResultDate$„  END IF„  hour$ = TRIM(STR$(hour))„  IF hour < 10 THEN hour$  = "0" + hour$„  TIME$ = hour$ + MID$(TIME$, 3)„END SUB„„FUNCTION MonthName(InDate$) AS STRING„  RESTORE monthdata„  number = VAL( LEFT$(InDate$, 2) )„  FOR count = 1 TO number„    READ temp$„  NEXT„  FUNCTION = temp$ + CHR$(32)„END FUNCTION„„FUNCTION DayName(InDate$) AS STRING„  RESTORE daydata„  number = DayWeek(InDate$)„  FOR count = 1 TO number„    READ temp$„  NEXT„  FUNCTION = temp$ + CHR$(32)„END FUNCTION„„FUNCTION DaysInMonth(InDate$) AS INTEGER„  RESTORE daysinmonthdata„  number = VAL(LEFT$(InDate$, 2))„  FOR count = 1 TO number„    read total„  NEXT„  IF number = 2 THEN total = total + LeapYear(MID$(InDate$, 7))„  FUNCTION = total„END FUNCTION„„FUNCTION DateText(InDate$) AS STRING„  day$ = MID$(InDate$, 4, 2) + CHR$(32)„  IF ASC(day$) = 48 THEN day$ = MID$(day$, 2)      ' skip leading zero„  year = VAL(MID$(InDate$, 7))                     ' perhaps < 1„  IF year < 1 THEN„    DECR year„    year$ = rgtALIGN(STR$(ABS(year)), 4)„    REPLACE CHR$(32) WITH "" IN year$„    year$ = year$ + " b.C."„  ELSE„    year$ = MID$(InDate$, 7)„  END IF„  FUNCTION = DayName(InDate$) + day$ + MonthName(InDate$) + year$„END FUNCTION„„FUNCTION DateNumeric(InDate$) AS STRING„  year = VAL(MID$(InDate$, 7))                     ' perhaps < 1„  IF year < 1 THEN„    DECR year„    year$ = rgtALIGN(STR$(ABS(year)), 4)„    REPLACE CHR$(32) WITH "0" IN year$„    year$ = "-" + year$„  ELSE„    year$ = MID$(InDate$, 7)„  END IF„  ' uses slash for "-" to avoid "--" in negative year„  FUNCTION = LEFT$(InDate$, 2) + "/" + MID$(InDate$, 4, 2) + "/" + year$„END FUNCTION„„' ******************************************************************„' the following routines only serve this demo„' let them out if you intend tot implement the above in your library„' ******************************************************************„„SUB JulianText„  CLS„  PRINT "The Julian& (to define as a LONG INTEGER) is a unique number"„  PRINT "for each day, starting November 25, 4714 before Christ; which"„  PRINT "date is Julian (or daynumber) 1."„  PRINT "Keep always in mind that this scientific method to cumpute"„  PRINT "days and dates, is based upon our modern (so called Gregorian)"„  PRINT "calendar. Due to the fact that this calendar is rather young,"„  PRINT "the results may not always mirror historical reality, simply"„  PRINT "because ";CHR$(34);"they";CHR$(34);" used a different ";„  PRINT "calendar in those days."„  PRINT "Additionally, the same must be said of Zeller's method to find the"„  PRINT "name of the day for a given date (FUNCTION DayWeek)."„  PRINT„  PRINT "For computing reasons the Julian method includes the year 0 (zero)"„  PRINT "which was non-existing, they say. That's why the FUNCTIONs DateText"„  PRINT "and DateNumeric have been added in order to correct the result of"„  PRINT "SUB JulToDate by 1 year, if necessary."„  PRINT "If you intend to let the user input dates, your input routine must"„  PRINT "in fact do the opposite. Take care that the routine does not accept"„  PRINT "year zero and no dates older than 11/25/-4714. Before starting"„  PRINT "computational routines your program must INCREASE every input"„  PRINT "older than annum 1 by one year."„  PRINT„  PRINT "more"„  DO„  LOOP UNTIL LEN(INKEY$)„  PRINT„  PRINT "E.g. if the user types ";CHR$(34);"01/01/-0001";CHR$(34);„  PRINT " (January 1st, 1 b.C.) your"„  PRINT "program must modify this into ";CHR$(34);"01/01/0000";CHR$(34);„  PRINT " before passing it"„  PRINT "through any of the above mentioned routines. Afterwards"„  PRINT "FUNCTION DateText or FUNCTION DateNumeric will re-convert it"„  PRINT "to 1 b.C. This sounds rather complicated, but the alternative"„  PRINT "is worse: leave the conversion out and learn your customer/user"„  PRINT "to input zero if he/she means 1 b.C. (etcetera)"„  DO„  LOOP UNTIL LEN(INKEY$)„END SUB„„SUB MenuText„  CLS„  PRINT "Date and time manipulations you'll ever need"„  PRINT "Donated to the Public Domain by Egbert Zijlema"„  PRINT„  PRINT "F1  = Info on Julian and Zeller's method"„  PRINT "F2  = Demo leap year"„  PRINT "F3  = Demo Julian"„  PRINT "F4  = Demo ";CHR$(34);"date before Christ";CHR$(34)„  PRINT "F5  = Daylight Saving demo"„  PRINT "Esc = Stop this demonstration"„  PRINT„  PRINT "Re-enter this menu by pressing any key"„END SUB„„SUB LeapYearDemo„  CLS„  TestDate$ = "02-01-1996"„  PRINT "1996 is a leap year, so "; MonthName(TestDate$);„  PRINT "counted ";TRIM(STR$(DaysInMonth(TestDate$)));" days"„„  TestDate$ = "02-01-1995"„  PRINT "1995 was not, so "; MonthName(TestDate$);"of that year had ";„  PRINT TRIM(STR$(DaysInMonth(TestDate$)));" days"„„  DO„  LOOP UNTIL LEN(INKEY$)„END SUB„„SUB JulianDemo„  CLS„  PRINT "Today's Julian number is"; Julian&(DATE$)„  PRINT„„  TermToPay& = 14„  JulToDate Julian&(DATE$) + TermToPay&, payday$„  PRINT "Pay your bill before "; DateText(payday$)„  PRINT„„  JulToDate Julian&(DATE$) - 1, result$„  PRINT "Yesterday was "; DayName(result$); DateNumeric(result$)„  PRINT„„  JulToDate 1, oldest$„  PRINT "The oldest date Julian can find is "; DateText(oldest$)„  PRINT "which has been";Julian&(DATE$) - 1; "days ago!"„  PRINT„„  PRINT "Dates beyond "; DateText("12-31-9999"); " need computers with the"„  PRINT "capability to store 5-digit years"„  PRINT "Engineers still have plenty of time to invent them:";„  PRINT Julian&("12-31-9999") - Julian&(DATE$); "days"„  DO„  LOOP UNTIL LEN(INKEY$)„END SUB„„SUB BeforeChristDemo„  CLS„  TestDate$ = "01-01--0001"                  ' = the year 2 before Christ„  JulToDate Julian&(TestDate$), result$„„  PRINT "The year zero did not exist. Probably."„  PRINT "However, for correct computations with Julians you do need it!"„  PRINT "Therefore the FUNCTIONs DateText(InDate$) / DateNumeric(InDate$)"„  PRINT "decrease an annum under 1 (= before Christ) by 1 year."„  PRINT "DateText adds the extension ";CHR$(34);"b.C.";CHR$(34);" as well."„  PRINT„  PRINT "This is the computational date:  "; result$„  PRINT "And here are 3 ways to write it: "; DateText(result$)„  PRINT "                                 "; DayName(result$);„  PRINT DateNumeric(result$)„  PRINT "                                 ";DateNumeric(result$)„  PRINT„  PRINT "BTW: 2 before Christ was ";„  IF NOT LeapYear("0001") THEN PRINT "not";„  PRINT " a leap year"„  DO„  LOOP UNTIL LEN(INKEY$)„END SUB„„SUB DayLightDemo„  CLS„  IF BIT(pbvHost, 5) <> 0 THEN„    PRINT "Don't try this in the IDE! It will affect PB.EXE"„    PRINT "Compile this program to an EXE first"„  ELSE„    PRINT "Now we do the daylight saving test"„    PRINT„„    JulToDate DayLightBegin&, start$„    JulToDate DayLightEnd&, finish$„    PRINT "The daylight saving half year started "; DateText(start$); " and"„    PRINT "wil end "; DateText(finish$)„    PRINT„    DayLightSaving                            ' install setting on first use„„    OldDate$ = DATE$                          ' save actual date„    PRINT "Today: "; DateText(OldDate$);„    PRINT " ("; TIME$; ")"„    PRINT„„    JulToDate DayLightBegin& - 1, result$     ' try the day before„    DATE$ = result$„    DayLightSaving„    PRINT "No daylight saving: ";„    PRINT DateText(DATE$); " ("; TIME$; ")"„    PRINT„„    JulToDate DayLightBegin& + 1, result$     ' 2 days later„    DATE$ = result$„    DayLightSaving„    PRINT "Daylight saving: ";„    PRINT DateText(DATE$); " ("; TIME$; ")"„    PRINT„„    DATE$ = OldDate$                          ' finally restore actual date„    DayLightSaving„    PRINT "Date restored: ";„    PRINT DateText(DATE$); " ("; TIME$; ")"„  END IF„  DO„  LOOP UNTIL LEN(INKEY$)„END SUB„„FUNCTION GetKey„  DO„    KeyIn$ = INKEY$„  LOOP UNTIL LEN(KeyIn$)„  FUNCTION = CVI(KeyIn$ + CHR$(0) )„END FUNCTION„„SUB MainMenu„  DO„    KeyIn = GetKey„    SELECT CASE KeyIn„      CASE 59 * 256       ' F1„        JulianText„        MenuText„      CASE 27             ' Escape„        CLS : SYSTEM„      CASE 60 * 256       ' F2„        LeapYearDemo„        MenuText„      CASE 61 * 256       ' F3„        JulianDemo„        MenuText„      CASE 62 * 256       ' F4„        BeforeChristDemo„        MenuText„      CASE 63 * 256       ' F5„        DayLightDemo„        MenuText„    END SELECT„  LOOP„END SUB„„CLS„  MenuText„  MainMenu„END„James McMurrin                 RAINBOW CLOCK                  FidoNet QUIK_BAS Echo          06-13-96 (19:09)       QB, QBasic, PDS        152  3979     RBCLOCK.BAS DIM PAL(512) AS LONG, CO(7, 3), SC(2, 60), MC(2, 60), HQ(2, 60), HC(2, 12)„SCREEN 13„RANDOMIZE TIMER„PAL(0) = 0„'PAL(L) = A * 65536 + B * 256 + C„B = 29.4: R = 52.333333#„PAL(1) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = 2„FOR L = 1 TO 13„B = B - 2.1: R = R - 2 / 3„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„NEXT L„B = 0: R = 43„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„FOR L = 1 TO 29„G = G + 1 / 3: R = R + 2 / 3„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„NEXT L„G = 10: R = 63„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„FOR L = 1 TO 29„G = G + 53 / 30„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„NEXT L„G = 63„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„FOR L = 1 TO 29„R = R - 2.1„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„NEXT L„R = 0„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„FOR L = 1 TO 29„B = B + 2.1: G = G - 2.1„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„NEXT L„B = 63: G = 0„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„FOR L = 1 TO 29„R = R + 2.1„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„NEXT L„R = 63„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„FOR L = 1 TO 15„B = B - 2.1: R = R - 2 / 3„PAL(PC) = CINT(B) * 65536 + CINT(G) * 256 + CINT(R)„PC = PC + 1„NEXT L„PALETTE USING PAL(0)„T$ = "RAINBOW                            CLOCK"„B$ = "BY:˙JAMES                       MCMURRIN"„FOR L = 1 TO 40„LOCATE 1, L„COLOR (L MOD 6) * 30 + 15„PRINT MID$(T$, L, 1);„LOCATE 24, L„PRINT MID$(B$, L, 1);„NEXT L„CIRCLE (160, 99), 119, 1„PAINT (160, 99), 1, 1„FOR L = 0 TO 359 STEP 6„IF (L / 30) = INT(L / 30) THEN„ FOR Q = -.5 TO .5 STEP .1„ ROW = 99 + COS((L + Q) * 3.14159 / 180) * 100„ COL = 160 + SIN((L + Q) * 3.14159 / 180) * 119„ LINE (160, 100)-(COL, ROW), 0„ NEXT Q„ 'ROW = 99 + COS(L * 3.14159 / 180) * 95„ 'COL = 160 + SIN(L * 3.14159 / 180) * 110„ 'PAINT (COL, ROW), 0, 0„ELSE„ ROW = 99 + COS(L * 3.14159 / 180) * 100„ COL = 160 + SIN(L * 3.14159 / 180) * 119„ BROW = 99 + COS(L * 3.14159 / 180) * 41„ BCOL = 160 + SIN(L * 3.14159 / 180) * 49„ LINE (BCOL, BROW)-(COL, ROW), 0„END IF„NEXT L„LINE (159, 99)-(159, 101), 0„CIRCLE (160, 99), 119, 0„CIRCLE (160, 99), 98, 0„CIRCLE (160, 99), 69, 0„CIRCLE (160, 99), 49, 0„FOR L = 3 TO 360 STEP 6„ROW = 99 - COS(L * 3.14159 / 180) * 95„SC(1, (L - 3) / 6 + 1) = ROW„ROW = 99 - COS((L) * 3.14159 / 180) * 77„MC(1, (L - 3) / 6 + 1) = ROW„ROW = 99 - COS((L) * 3.14159 / 180) * 55„HQ(1, (L - 3) / 6 + 1) = ROW„COL = 160 + SIN(L * 3.14159 / 180) * 114„SC(2, (L - 3) / 6 + 1) = COL„COL = 160 + SIN((L) * 3.14159 / 180) * 95„MC(2, (L - 3) / 6 + 1) = COL„COL = 160 + SIN(L * 3.14159 / 180) * 65„HQ(2, (L - 3) / 6 + 1) = COL„IF (L - 3) / 30 = INT((L - 3) / 30) THEN„ ROW = 99 - COS((L + 15) * 3.14159 / 180) * 25„ COL = 160 - SIN((L + 15) * 3.14159 / 180) * 25„ HC(1, (L - 3) / 30 + 1) = ROW„ HC(2, (L - 3) / 30 + 1) = COL„ CIRCLE (COL, ROW), 1, 8„END IF„NEXT L„OOFM = -1: OOHQ = -1: OOFH = -1„DO„OT$ = TIME$„OFS = VAL(MID$(OT$, 7, 2))„OFM = VAL(MID$(OT$, 4, 2))„OFH = VAL(MID$(OT$, 1, 2))„OHQ = INT(OFM / 12)„FOR L = 1 TO 60„PC = ((60 - OFS) + L - 1) MOD 60 + 1„PAINT (SC(2, L), SC(1, L)), PC, 0„NEXT L„IF OFH <> OOFH THEN„ OOFH = OFH: OFS = OFH MOD 12„ FOR L = 0 TO 11„ PC = (11 - ((OFS + L) MOD 12)) * 5 + 121„ PAINT (HC(2, L + 1), HC(1, L + 1)), PC, 0„ NEXT L„END IF„IF OFM <> OOFM THEN„ OOFM = OFM„ FOR L = 1 TO 60„ PC = ((60 - OFM) + L - 1) MOD 60 + 61„ PAINT (MC(2, L), MC(1, L)), PC, 0„ NEXT L„END IF„IF OHQ <> OOHQ THEN„ OOHQ = OHQ„ OS = (OFH MOD 12) * 5 + OHQ + 1„ FOR L = 1 TO 60„ PC = ((60 - OS) + L) MOD 60 + 121„ PAINT (HQ(2, L), HQ(1, L)), PC, 0„ NEXT L„END IF„DO: LOOP WHILE TIME$ = OT$„LOOP WHILE INKEY$ = ""„Edward Di Geronimo Jr.         CHANGE FREQ OF SYSTEM TIMER    FidoNet QUIK_BAS Echo          07-07-96 (00:00)       QB, QBasic, PDS        68   2347     INTCLOCK.BAS'Here's some almost working code to get more precise timing in„'QuickBasic. It works by changing the internal timer to generate an„'interrupt more often than 18.2 times per second. To use this code, call„'the ChangeTimer function, and to get the desired frequency use this„'formula:„„'    1.19318mhz„'-----------------„'desired freuqency„„'18.2 comes about by dividing by 65535 (highest 16bit number).„„'If you look at the code, you'll notice there are COUNTER0, 1, and 2„'constants. Counter 0 is the frequency of the system timer (which we„'change), counter 1 is the ram refresh rate (don't change!), and counter„'2 is related to the pc speaker (I doubt you should touch it).„„'I know this works in C, but I don't know how well it will work in QB.„'It should effect the TIMER value. It would be great for games if we„'could write our own ISR's to accompany this, but QB doesn't have„'pointers, let alone sub/function pointers, so we can't. Oh well. But ON„'TIMER should be effected by this, so I guess we don't need one. I'll„'leave it to you guys to figure it out.„„'Code to change the frequency of the 8253 clock chip's interrupt„'generation. Public domain (C) by Edward Di Geronimo Jr. 7/7/96„„DEFINT A-Z„„DECLARE SUB ChangeTimer (NewCount%)„„CONST CONTROL8253 = &H43  ' the 8253's control register„CONST CONTROLWORD = &H3C  ' the control word to set mode 2„                          '    binary least/most„CONST COUNTER0 = &H40     ' counter 0„CONST COUNTER1 = &H41     ' counter 1„CONST COUNTER2 = &H42     ' counter 2„„CONST TIMER60HZ = &H4DAE   ' 60 hz„CONST TIMER50HZ = &H5D37   ' 50 hz„CONST TIMER40HZ = &H7486   ' 40 hz„CONST TIMER30HZ = &H965C   ' 30 hz„CONST TIMER20HZ = &HE90B   ' 20 hz„CONST TIMER18HZ = &HFFFF   ' 18.2 hz (the standard count and the slowest possible)„ChangeTimer TIMER60HZ„„DO WHILE INKEY$ = ""„    A# = TIMER„    PRINT A#,„    WHILE A# = TIMER: WEND„LOOP„„ChangeTimer TIMER18HZ„„SUB ChangeTimer (NewCount)„' send the control word, mode 2, binary, least/most load sequence„„OUT CONTROL8253, CONTROLWORD„„' now write the least significant byte to the counter register„„OUT COUNTER0, NewCount AND &HFF            ' LOWBYTE(newcount)„„' and now the the most significant byte„„OUT COUNTER0, (NewCount AND &HFF00) / 256  ' HIGHBYTE(newcount)„„END SUB„Kevin J. Krumwiede             LINEAR DATE                    FidoNet QUIK_BAS Echo          07-12-96 (01:22)       QB, QBasic, PDS        64   1834     LIN_DATE.BAS' Hello everybody!  This program reports the current linear date, „' expressed as the number of seconds since 00:00 on 01-01-1970. „' This could be used the same way you might use TIMER to create „' delays, but without the complications of midnight rollover. „' This seems to be pretty fast, though I'm sure there's room for „' optimization.  I think I corected properly for all the special  „' cases (leap years, etc.), but if you spot any errors, please „' let me know!  Here it is: „ „' ********************************************************************* „' lin_date.bas „' Written and released to the PUBLIC DOMAIN by Kevin J Krumwiede „' Calculates the linear date from 01-01-1970 as per the Unix convention „' ********************************************************************* „ „DECLARE FUNCTION linearDate& () „DECLARE FUNCTION leapDays% (year%) „ „CLS „PRINT "Current Linear Date:"; „PRINT linearDate& „ „END „ „FUNCTION leapDays% (year%) „ „IF (year% MOD 100 = 0) AND (year% MOD 4 <> 0) THEN „        leapDays% = 0 „ELSEIF (year% MOD 4 = 0) THEN „        leapDays% = 1 „ELSE „        leapDays% = 0 „END IF „ „END FUNCTION „ „FUNCTION linearDate& „ „dt$ = DATE$ „m% = VAL(LEFT$(dt$, 2)) „d% = VAL(MID$(dt$, 4, 2)) „y% = VAL(RIGHT$(dt$, 4)) „ „DIM days(1 TO 12) AS INTEGER „days(1) = 31: days(2) = 28: days(3) = 31: days(4) = 30 „days(5) = 31: days(6) = 30: days(7) = 31: days(8) = 31 „days(9) = 30: days(10) = 31: days(11) = 30: days(12) = 31 „ „lin& = 0 „FOR i% = 1970 TO y% - 1 „        lin& = lin& + 86400 * (365 + leapDays(y%)) „NEXT i% „ „FOR i% = 1 TO m% - 1 „        lin& = lin& + 86400 * days(m%) „NEXT „IF m% > 2 THEN lin& = lin& + 86400 * leapDays(y%) „ „lin& = lin& + 86400 * (d% - 1) „lin& = lin& + TIMER „ „linearDate& = lin& „ „END FUNCTION „Egbert Zijlema                 CONTINUALLY DISPLAY ACTUAL TIMEE.Zijlema@uni4nn.iaf.nl        07-21-96 (22:02)       PB                     225  7164     SHOWTIME.BAS' SHOWTIME.BAS ---- continuatedly displays the actual time„' Author          : Egbert Zijlema (E.Zijlema@uni4nn.iaf.nl)„' Date            : July 21, 1996„' Language        : Power Basic 3.2„' Copyright status: Public Domain„„' Info:„' Most of the time a program is just waiting for user activity„' (e.g. keyboard input). These "pauses" are the most excellent„' moments to display the actual time. For instance at the menu bar.„' There is only 1 restriction: the Basic commands LOCATE and/or PRINT„' should ALWAYS serve the user, so your program must write (POKE) the„' time information directly to video memory.„„' In this demo a sample menu lets you toggle between different formats:„' hh:mm:ss (the default TIME$)„' hh:mm (including a blinking colon)„' 12/24 hrs system, adding AM or PM for 12 hrs„„' For computers with vga card there is an extra font to display„' the time in 'digital' form. These font (earlier released as„' "LOADFONT.BAS") includes the characters 0 - 9, A, P and M. They„' will temporaryly replace the characters 224 throug 238 of the„' default ASCII set. It is to be restored while quitting.„' ---------------------------------------------------------------------„„DEFINT A - Z„„%NO = 0 : %YES = NOT %NO           ' equates true/false (0/-1)„„%AX = 1 : %BX = 2 : %CX = 3        ' equates for ...„%DX = 4 : %BP = 7 : %ES = 9        ' ... registers„„TYPE CLOCKFLAGS„  twelve AS INTEGER                ' 12 hrs clock„  secs AS INTEGER                  ' show seconds„  font AS INTEGER                  ' use special font„END TYPE„„TYPE FLAGS„  mono AS INTEGER                  ' monochrome screen„  vga AS INTEGER                   ' ega/vga card present„END TYPE„„DIM clok AS SHARED CLOCKFLAGS„DIM flg AS SHARED FLAGS„DIM VideoAddress AS SHARED INTEGER„„IF (pbvScrnCard AND 1) = 0 THEN    ' test card type„  VideoAddress = &HB800            ' color card„ELSE„  VideoAddress = &HB000            ' monochrome„  flg.mono = %YES„END IF„„IF BIT(pbvScrnCard, 4) THEN        ' is it a vga-card as well?„  LoadFont                         ' load special chars„  flg.vga = %YES                   ' vga modifications done!„END IF„„SUB LoadFont„  cred$ = CHR$(126, 129, 189, 165, 161, 165, 189, 129, 126)„  phon$ = CHR$(  0,   0,   0, 126, 255, 153,  60, 126, 126)„  zero$ = CHR$( 56, 198, 198, 198,   0, 198, 198, 198,  56)„  one$  = CHR$( 24,  24,  24,  24,   0,  24,  24,  24,  24)„  two$  = CHR$( 56, 198,   6,   6,  56, 192, 192, 192,  62)„  thre$ = CHR$( 56, 198,   6,   6,  56,   6,   6, 198,  56)„  four$ = CHR$(198, 198, 198, 198,  56,   6,   6,   6,   6)„  five$ = CHR$( 62, 192, 192, 192,  56,   6,   6, 198,  56)„  six$  = CHR$(192, 192, 192, 192,  56, 198, 198, 198,  56)„  sevn$ = CHR$(248,   6,   6,   6,   0,   6,   6,   6,   6)„  eigt$ = CHR$( 56, 198, 198, 198,  56, 198, 198, 198,  56)„  nine$ = CHR$( 56, 198, 198, 198,  56,   6,   6, 198,  56)„  a$    = CHR$( 56, 198, 198, 198,  56, 198, 198, 198, 198)„  p$    = CHR$( 56, 198, 198, 198,  56, 192, 192, 192, 192)„  m$    = CHR$(126, 219, 219, 219,   0, 219, 219, 195, 195)„„  start$    = STRING$(3, 0)    ' align top„  tail$     = STRING$(4, 0)    ' align tail„  between$  = STRING$(7, 0)    ' align prev. and next char„„  ' NOTE: if the characters don't bottom align versus default„  '       font characters (e.g. the colon) then unmark the next line:„„  ' SWAP start$, tail$„„  pattern$  = start$ + cred$ + between$ + phon$ + between$ + zero$ + _„              between$ + one$ + between$ + two$ + between$ + thre$ + _„              between$ + four$ + between$ + five$ + between$ + six$ + _„              between$ + sevn$ + between$ + eigt$ + between$ + nine$ + _„              between$ + a$ + between$ + p$ + between$ + m$ + tail$„„  REG %AX, &H1100               ' function„  REG %BX, 16 * 256             ' 16 bytes per char in BH„  REG %CX, 15                   ' number of characters„  REG %DX, 224                  ' first char in ASCII-set to modify„  REG %ES, STRSEG(pattern$)„  REG %BP, STRPTR(pattern$)„  CALL INTERRUPT &H10„  REG %AX, &H1103               ' function„  REG %BX, 0„  CALL INTERRUPT &H10„END SUB„„' Trim all spaces from both ends of a string„FUNCTION TRIM(BYVAL text AS STRING) AS STRING„  FUNCTION = LTRIM$(RTRIM$(text))„END FUNCTION„„FUNCTION TimeToDisplay AS STRING„  temp$ = TIME$„  IF NOT clok.secs THEN temp$ = LEFT$(temp$, 5)    ' skip seconds„  hour = VAL(LEFT$(temp$, 2))„  extension$ = SPACE$(3)„„  IF clok.twelve THEN„    SELECT CASE hour„      CASE => 12„        IF hour > 12 THEN DECR hour, 12„        extension$ = " PM"„      CASE ELSE„        IF hour = 0 THEN hour = 12„        extension$ = " AM"„    END SELECT„  END IF„„  temp$ = TRIM(STR$(hour)) + MID$(temp$, 3) + extension$„  temp$ = temp$ + SPACE$(11 - LEN(temp$) )  ' fixed length = 11 chars„„  IF clok.font THEN„    FOR count = 48 TO 57„      REPLACE CHR$(count) WITH CHR$(count + 178) IN temp$„    NEXT„    REPLACE CHR$(65) WITH CHR$(236) IN temp$„    REPLACE CHR$(80) WITH CHR$(237) IN temp$„    REPLACE CHR$(77) WITH CHR$(238) IN temp$„  END IF„„  FUNCTION = temp$„END FUNCTION„„SUB TimeInfo„  STATIC colon„  IF flg.mono THEN„    attri = 112                               ' black on white„  ELSE„    attri = 121                               ' blue on white„  END IF„„  Info$ = TimeToDisplay„  IF colon = %NO AND clok.secs = %NO THEN„    REPLACE ":" WITH CHR$(32) IN Info$„    colon = %YES„  ELSE„    colon = %NO„  END IF„„  NextChar = 1„„  DEF SEG = VideoAddress„  FOR offset = 102 TO 122 STEP 2               ' 11 characters + 11 colors„    character = ASC(MID$(Info$, NextChar, 1))„    POKE offset, character„    POKE offset + 1, attri„    INCR NextChar„  NEXT„  DEF SEG„END SUB„„FUNCTION GetKey„  STATIC lastTime$„„  DO„„    IF TIME$ <> lastTime$ THEN                 ' every second„      lastTime$ = TIME$„      TimeInfo„    END IF„„  LOOP UNTIL INSTAT„„  FUNCTION = CVI( INKEY$ + CHR$(0) )„END FUNCTION„„SUB DemoMenu„„  ' menu text„  COLOR 7, 0„  IF flg.vga THEN„    LOCATE 3, 4„    PRINT "F1  = toggle fonts"„  END IF„  LOCATE 4, 4 : PRINT "F2  = toggle seconds"„  LOCATE 5, 4 : PRINT "F3  = toggle 12/24 hrs"„  LOCATE 6, 4 : PRINT "Esc = end of this demo"„„  DO„    KeyIn = GetKey„    SELECT CASE KeyIn„      CASE 27„        IF flg.vga THEN SCREEN 0, 0, 0, 0   ' restore default font„        CLS„        SYSTEM„      CASE 59 * 256                         ' F1„        IF NOT flg.vga THEN EXIT SELECT„        IF clok.font THEN clok.font = %NO ELSE clok.font = %YES„      CASE 60 * 256                         ' F2„        IF clok.secs THEN clok.secs = %NO ELSE clok.secs = %YES„      CASE 61 * 256                         ' F3„        IF clok.twelve THEN clok.twelve = %NO ELSE clok.twelve = %YES„    END SELECT„  LOOP„END SUB„„„' demo main„„CLS„  COLOR 0, 7„  LOCATE 1, 1 : PRINT SPACE$(80);         ' dummy menu bar„  LOCATE 1, 4 : PRINT "Sample Menu Bar"„„  clok.secs = %YES                        ' start with default TIME$„  CALL DemoMenu„END„Egbert Zijlema                 TRAP KEYBOARD INACTIVITY       E.Zijlema@uni4nn.iaf.nl        08-19-96 (19:53)       PB                     99   2673     NOKEY.BAS   ' NOKEY.BAS  - how to trap keyboard inactivity„' Author     : Egbert Zijlema (E.Zijlema@uni4nn.iaf.nl)„' (up)Date   : August 19, 1996„' Language   : Power Basic 3.2„' Copyright  : Public Domain„„' This routine does not demonstrate a sophisticated screen saver.„' Its main purpose is to show the most simple method to trap keyboard„' inactivity for a certain period of time.„' As a sample screen saver it turns the screen black, just to proof„' that it really works.„„' Most programmers use the TIMER FUNCTION to calculate the number of„' seconds before screen saver launch. This works. I used it myself„' until an hour ago. There is 1 small problem however: as soon as„' the computer's clock passes midnight, TIMER is (re)set to zero„' which will cause an infinite loop - unless you correct it by„' adding 86400 seconds every round, e.g.:„„' start# = TIMER„' DO„'    now# = TIMER„'    IF now# < start# THEN INCR now#, 86400  [ adjust for midnight]„'    IF now# - start# =>  .... THEN„'      (command to start screen saver)„'    END IF„'„'    (code for keyboard trapping)„' LOOP UNTIL ........„„' ---------------------------- begin code ---------------------------„„DEFINT A - Z„FUNCTION GetKey AS INTEGER„  STATIC t$                     ' alias for TIME$„  DO„„    IF seconds = 30 THEN        ' half a minute for this demo„      CALL BlackScreen          ' start screen saver„      EXIT FUNCTION„    END IF„„    IF t$ <> TIME$ THEN         ' TIME$ changes every second„      t$ = TIME$„      LOCATE 1, 72 : PRINT t$   ' you may leave this out„      INCR seconds              ' add 1„    END IF„„    KeyIn$ = INKEY$„  LOOP UNTIL LEN(KeyIn$)        ' until keypress„„  FUNCTION = CVI( KeyIn$ + CHR$(0) )„END FUNCTION„„SUB BlackScreen„  DEF SEG = &HB800              ' color card - use &HB000 for monochrome„  OldScreen$ = PEEK$(0, 4000)„  COLOR 7, 0„  LOCATE , , 0                  ' hide cursor„  CLS„  DO„  LOOP UNTIL LEN(INKEY$)„  POKE$ 0, OldScreen$„  DEF SEG„END SUB„„SUB MainMenu„  DO„    KeyIn = GetKey„    SELECT CASE KeyIn„      CASE 27„        CLS„        SYSTEM„      CASE ELSE„        ' other keys not supported here„    END SELECT„  LOOP„END SUB„„' main„„CLS„  COLOR 15, 0„  LOCATE 2, 4„  PRINT "NOKEY.BAS       - traps keyboard inactivity"„  LOCATE 3, 4„  PRINT "Author          : Egbert Zijlema"„  LOCATE 4, 4„  PRINT "Copyright status: Public Domain"„  LOCATE 10, 4„  PRINT "This screen will turn black after 30 seconds"„  LOCATE 11, 4„  PRINT "Press any key to restore it"„  COLOR 7„  LOCATE 14, 4„  PRINT "(or press Esc to finish this demo)"„„  MainMenu„END„Andrew K. Dart                 CONVERT UNIX TIME STAMP        FidoNet QUIK_BAS Echo          10-14-96 (17:32)       QB, QBasic, PDS        70   2436     UNIXTIME.BAS'Note:  My real name is Andrew K. Dart.  (Required by the rules!)„„'I'm sure by now you've been flooded with replies to your question about„'UNIX time stamps, where the date and time is represented by a long„'integer indicating the number of seconds past midnight, 1/1/1970.„'I would have replied sooner, but there was ideal kite-flying weather„'yesterday!  Here's what I've pieced together for you:„„REM Program converts UNIX-style date code into day and time.„REM The date code is expressed in the number of seconds since„REM midnight, January 1, 1970.„„REM Written 10/14/96 by Andrew K. Dart         PUBLIC DOMAIN„REM Provided as a public service, with no guarantees.„REM If you're still using UNIX after 12/31/99,„REM you'll need to make a few modifications.„„DIM LastDay(69 TO 99)„LastDay(69) = 0„FOR x = 70 TO 99„   LastDay(x) = 365 + LastDay(x - 1)„   IF x MOD 4 = 0 THEN LastDay(x) = LastDay(x) + 1„NEXT x„„DIM mo(12)„FOR x = 1 TO 12„   READ mo(x)„NEXT x„DATA 0,31,59,90,120,151,181,212,243,273,304,334„„INPUT "What is the date code"; Code&„REM maximum allowable date code is LastDay(99) * 86400„REM which is 946,684,800 seconds after 00:00 on 1/1/70.„„Days = Code& \ 86400„FOR x = 70 TO 99„   IF Days <= LastDay(x) THEN EXIT FOR„NEXT x„'PRINT USING "Apparently this was sometime in 19##."; x„„FOR y = 1 TO 11„   IF Days < (LastDay(x - 1) + mo(y + 1)) THEN„      PRINT "The date was "; STR$(y); "/";„      PRINT RIGHT$(STR$(100 + Days - LastDay(x - 1) - mo(y) + 1), 2);„      PRINT "/"; RIGHT$(STR$(100 + x), 2)„      EXIT FOR„   END IF„NEXT y„„REM Now let's figure out what the time of day was:„RawSeconds = Code& MOD 86400„Hour = RawSeconds \ 3600„Minute = (RawSeconds - (Hour * 3600)) \ 60„Second = RawSeconds MOD 60„PRINT "The time was ";„PRINT USING "##:"; Hour;„PRINT RIGHT$(STR$(100 + Minute), 2); ":";„PRINT RIGHT$(STR$(100 + Second), 2)„END„„'==============   END   ===============„„'I presume that you do not want to account for Leap Seconds,„'because the computer clock (on the system running UNIX) probably does„'not count them.  However if you wanted to use a program like this to„'figure the exact number of seconds between two times, on two different„'dates, you would need to find out whether one or more leap seconds had„'occurred between the two dates.   For details on leap seconds,„'E-Mail me at„'               andrew.dart@chrysalis.org„