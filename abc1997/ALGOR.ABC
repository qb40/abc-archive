Tyler Barnes                   UPDATE OF BASE CONVERSION      comp.lang.basic.misc           11-14-96 (16:16)       QB, QBasic, PDS        32   1381     BASE.BAS    'Here's an update to my base conversion thing. This version is smaller,„'faster, and neater. (I simplified a part at the end and removed some of„'the exponent stuff I was doing.)„„DECLARE SUB Base2Base (Number1$, Digits1$, Number2$, Digits2$)„CONST Bin = "01", Oct = "01234567", Dec = "0123456789", Hex = "0123456789ABCDEF„„SUB Base2Base (Number1$, Digits1$, Number2$, Digits2$)„Number1$ = UCASE$(Number1$): Digits1$ = UCASE$(Digits1$)„Digits2$ = UCASE$(Digits2$): Number2$ = ""„IF Digits1$ <> "0123456789" THEN„FOR I% = LEN(Number1$) TO 1 STEP -1„IF Digits1$ = "01234567" THEN FinalNum& = VAL("&O" + Number1$): EXIT FOR„IF Digits1$="0123456789ABCDEF" THEN FinalNum&=VAL("&H"+Number1$):EXIT FOR„CD$ = MID$(Number1$, I%, 1)„CV% = INSTR(Digits1$, CD$) - 1„FinalNum& = FinalNum& + (CV% * (LEN(Digits1$) ^ ABS(I% - LEN(Number1$))))„NEXT I%„ELSE„FinalNum& = VAL(Number1$)„END IF„IF FinalNum& < 0 THEN FinalNum& = FinalNum& + 65536„IF Digits2$ = "0123456789" THEN Number2$ = LTRIM$(STR$(FinalNum&)): EXIT SUB„IF Digits2$ = "0123456789ABCDEF" THEN Number2$ = HEX$(FinalNum&): EXIT SUB„IF Digits2$ = "01234567" THEN Number2$ = OCT$(FinalNum&): EXIT SUB„DestBase% = LEN(Digits2$)„DO„Remainder% = FinalNum& MOD DestBase%„FinalNum& = (FinalNum& - Remainder%) / DestBase%„Number2$ = MID$(Digits2$, Remainder% + 1, 1) + Number2$„LOOP UNTIL FinalNum& = 0„END SUB„Toshihiro Horie                GRAPH INTEGRALS                www.ocf.berkeley.edu/~horie    11-13-95 (00:00)       QB, QBasic, PDS        133  4476     NINT.BAS    DEFDBL A-Z„'#####################################################################„'//GRAPH (ALMOST) ANY INTEGRAL WITHOUT KNOWING ITS ANALYTIC SOLUTION„'//PROGRAMMED FOR CALCULUS STUDENTS„'//BY TOSHIHIRO HORIE  11/13/95„'//BASED ON SIMPSON.BAS BY T. Horie„'#####################################################################„DECLARE SUB GRID (XC%, YC%, XS%, YS%, XN%, YN%)„ON ERROR GOTO er„CONST FALSE = 0, TRUE = NOT FALSE„CONST e = 2.7182818#„VARS:„      OPTION BASE 1„      DIM SHARED ISECT(3)„      DIM XOLD(2), YOLD(2), YP(2)„„      iformat$ = "X=+##.# Integral=+#######.###"„      XS% = 640: YS% = 480:   'dimensions of screen 12„      XC% = XS% \ 2: YC% = YS% \ 2„      XM% = 10: YM% = 5: 'X AND Y DIMENSIONS OF GRID„      XN% = XS% \ XM%: YN% = INT(XS% \ YM% * 1.33333)„      XI = .2: 'coarseness of the plotted line„„MAIN:„      GRID XC%, YC%, XS%, YS%, XN%, YN%„      'GOSUB EQUATION: 'get endpoints a and b„      'LINE (a * XN% + XC%, 0)-(a * XN% + XC%, YS%), 7, , &HAAAA„      'LINE (b * XN% + XC%, 0)-(b * XN% + XC%, YS%), 7, , &HBBBB„      x = -XC% / XN% - 1: GOSUB EQUATION„„DO„x = x + XI„      FOR N = 1 TO 2„'TRANSLATE TO SCREEN COORDINATES....„                GOSUB EQUATION„                IF y(N) > YM% THEN y(N) = YM%„                IF y(N) < -YM% THEN y(N) = -YM%„„                XP% = x * XN% + XC%„                YP%(N) = -y(N) * YN% + YC%„                LINE (XOLD%(N), YOLD%(N))-(XP%, YP%(N)), N + 9„                XOLD%(N) = XP%: YOLD%(N) = YP%(N)„      NEXT N„LOOP WHILE x < (XC% / XN%)„„a = -XC% / XN%: PSET (-XC% * XN - 1, YC%)„'A=0:PSET (xc%, yc%):'to start at origin„LOCATE 5, 1: COLOR 7: PRINT "Calculating...": COLOR 15„„CONST b = 0                           'from definition of integral?„DO: '------------------------------------------------------------------„astart = a„N% = 10                               '50 subdivisions (N% must be even!)„h = (b - a) / N%                      'dx for each subdivision„integral = 0                          'init integral to 0„s = 0                                 'init sum„x = a + h: GOSUB EQUATION: s = s + y(1) * 4„x = a + h + h                         'init x position to start„FOR lp% = 1 TO N% - 2„        GOSUB EQUATION„        IF ((lp% - 1) MOD 2) = 0 THEN„                s = s + y(1) * 2„        ELSE„                s = s + y(1) * 4„        END IF„        x = x + h„NEXT lp%„x = a: GOSUB EQUATION: s = s + y(1)„x = b: GOSUB EQUATION: s = s + y(1)„„  integral = -h / 3 * s„  xpi% = INT(astart * XN% + XC%)„  ypi% = INT((-integral) * YN% + YC%)„  LINE -(xpi%, ypi%), 14„  LOCATE 60, 1„  PRINT USING iformat$; astart; integral;„  PALETTE 7, RND * 64: 'flash the Calculating prompt„„a = a + XI„IF INKEY$ <> "" THEN STOP„LOOP WHILE a < (XC% / XN%): '---------------------------------------------„END„„er:„y(1) = 0„RESUME NEXT„„EQUATION:„'WARNING: you MUST set b=1 by definition, to get correct graph for LOGs.„y(1) = 1 / (1 + x ^ 2)          ' take the integral of this function (for x>0)„y(2) = ATN(x)                   ' analytic solution+C (0 if don't know)„                                '  If we're lucky, this is zero, and„                                '  the yellow and blue lines will overlap.„'y(1) = 2 * x / (1 + x ^ 4)„'y(2) = ATN(x ^ 2)„RETURN„„DEFINT A-Z„SUB GRID (XC%, YC%, XS%, YS%, XN%, YN%) STATIC„SCREEN 12: CLS : COLOR 15„WIDTH 80, 60: LOCATE 1, 1„PRINT "Basic Integral Grapher v1.0"„PRINT "uses Simpson's Rule for fast calc"„PRINT "by Toshihiro Horie 11/13/95"„PRINT "Internal revision: 11/25/95"„LOCATE 1, 58: PRINT "Today's date:"; DATE$„LOCATE 24, 4: PRINT "Scale: 1 unit= 1"„„LINE (XC, 0)-(XC, YS), 15: LINE (0, YC)-(XS, YC), 15:          REM Center„CN = -1„FOR X1 = XC TO XS STEP XN„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (X1, YC)-(X1, YC + 3), CL„        LINE (X1 + 1, YC)-(X1 + 1, YC + 3), CL„NEXT X1„CN = -1„FOR X1 = XC TO 0 STEP -XN„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (X1, YC)-(X1, YC + 3), CL„        LINE (X1 + 1, YC)-(X1 + 1, YC + 3), CL„NEXT X1„CN = -1„FOR Y1 = YC TO YS STEP YN„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (XC, Y1)-(XC + 4, Y1), CL„NEXT Y1„CN = -1„FOR Y1 = YC TO 0 STEP -YN„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (XC, Y1)-(XC + 4, Y1), CL„NEXT Y1„END SUB„„Toshihiro Horie                FUNCTION GRAPHER               www.ocf.berkley.edu/~horie/    11-24-96 (00:00)       QB, QBasic, PDS        355  10174    FGRAPH.BAS  ' Improved Function Grapher                     '„' Log, scaling, incr, and root bugs fixed.      '„' Copyright (c) 1996 Toshihiro Horie            '„„CONST version = 6.72„DEFSNG A-Z„DECLARE FUNCTION atan! (x!)„DECLARE FUNCTION asin! (x!)„DECLARE FUNCTION acos! (x!)„DECLARE FUNCTION csc! (x!)„DECLARE FUNCTION sec! (x!)„DECLARE FUNCTION cot! (x!)„DECLARE FUNCTION log10 (x) : DECLARE FUNCTION ln (x)„DECLARE FUNCTION sinh (x) : DECLARE FUNCTION csch (x)„DECLARE FUNCTION cosh (x) : DECLARE FUNCTION sech (x)„DECLARE FUNCTION tanh (x) : DECLARE FUNCTION coth (x)„DECLARE FUNCTION acosh! (x!) : DECLARE FUNCTION asech! (x!)„DECLARE FUNCTION asinh! (x!) : DECLARE FUNCTION acsch! (x!)„DECLARE FUNCTION acoth! (x!) : DECLARE FUNCTION atanh! (x!)„DECLARE SUB grid (x1!, y1!, XS!, ys!, XC!, YC!, XN!, yn!, xm!, ym!)„DECLARE SUB radianmarks (XC, YC, XS, ys, XN)„„CLEAR , , 32767: 'allocate more stack to error handler„ON ERROR GOTO 60„„'ln(x) divided by LOG(10)/LOG(e) gives common log„'Common LOG is defined in function LOG10„'LN natural log is defined in func LN„CONST l = 2.3025851#„CONST e = 2.7182818#„CONST pi = 3.14159265357989#„CONST DX = 1 / 1048576„„'##########################################################„  XS = 640: ys = 480:        'dimensions of the screen„  xm = 10: ym = 16:          'X AND Y DIMENSIONS OF GRID„'##########################################################„„„SCREEN 12: CLS : COLOR 15: LOCATE 1, 1„PRINT "FUNCTION GRAPHER Version "; version„PRINT "by Toshihiro Horie Rev 04/06/96"„COLOR 7: LOCATE 24, 4: PRINT "Scale: 1 green unit= 1"„GOSUB VARS„XC = XS \ 2: YC = ys \ 2„XN = XS / xm: yn = INT(XS / ym * 4 / 3)„incr = xm / XC * 4: M1 = 0„CALL grid(x1, y1, XS, ys, XC, YC, XN, yn, xm, ym)„REM =======================START GRAPHING!!!=================================„xi = incr„DEF SEG = 0: ' if scroll lock is on, then double the speed„IF (PEEK(&H417) AND &H10) THEN incr = incr * 2: DEF SEG„„'DRAW FIRST POINT.......................„x = -XC / XN - 1„GOSUB equation„XP = x * XN + XC„YP = -Y * yn + YC„PSET (XP, YP), 15„„DO„LOCATE 1, 67:  PRINT TIME$„'....................................................KEY CHECK....„in$ = INKEY$: xmode = 1„  IF in$ = "*" THEN xmode = 16„  IF in$ = "+" THEN xmode = 4„  IF in$ = "-" THEN xmode = 1 / 4„  IF in$ = "." THEN xmode = 8„  IF in$ = " " THEN xmode = -4: 'reverse„  IF in$ = "," THEN xmode = 1 / 8„xi = incr * xmode„„IF UCASE$(in$) = "Q" THEN GOSUB ASK„IF in$ = CHR$(27) THEN END„'INCREMENT THE X, FIND SLOPE............„'if flat curve then speed up„'IF ABS(M1) < .1 THEN xmode = 1.5„x = x + xi„GOSUB equation„M1 = (Y - yold) / (x - xold)„'.................................................BOUNDARY CHECK..1„IF Y > (YC / yn) + 16 OR Y < (-YC / yn) - 16 THEN„   Errflag2 = 1„   xi = incr * 2„   GOTO SKIP„ ELSE„   xi = incr„END IF„'TRANSLATE TO SCREEN COORDINATES..................................1.5„XP = x * XN + XC„YP = -Y * yn + YC„IF Errflag2 = 1 THEN PSET (XP, YP), 15: Errflag2 = 0„IF Errflag = 1 THEN PSET (XP, YP), 15: Errflag = 0„'DRAW LINE F(X)...................................SLOPE CHECK.....2„IF ABS(M1) > 64 THEN xi = incr / 8„IF ABS(M1) > 256 THEN„        ' vert asymptote - probably„        'LINE (XP, 0)-(XP, 479), 7, , &HCCCC„        xi = incr / 16„        PSET (XP, YP), 15„ELSE„        xi = incr„        LINE -(XP, YP), 15„END IF„'CIRCLE (XP, YP), 3, 12„'PSET (XP - 1, YP), 14: PSET (XP + 1, YP), 14: PSET (XP, YP), 14„'FIND CRITICAL POINTS.............................................3„IF MOLD * M1 < 0 THEN '(Mean Value Theorem)„      CIRCLE (xold * XN + XC, -yold * yn + YC), 4, 11„      COLOR 11„      LOCATE 28, 4: PRINT USING "(+###.###"; xold;„      PRINT USING ",+#####.###) "; yold„      COLOR 15„      PSET (XP, YP), 15„END IF„SKIP:„'SHOW SLOPE AND X,Y COORDINATE....................................4„LOCATE 25, 4: PRINT USING "(+###.##"; x;„PRINT USING ",+#####.##) "; Y„IF SGN(Y) * SGN(yold) <= 0 THEN '...............x-roots (misses mins)„      LOCATE 27, 4: PRINT USING "RootX=###.##"; xold„END IF„MOLD = (Y - yold) / (x - xold)„xold = x: yold = Y„IF x <> 0 THEN LOCATE 26, 4: PRINT USING "slope=+####.##   "; MOLD„„skip2:„LOOP WHILE x < (XC / XN)„END„'======================================================================„„ASK:„xold = x„LOCATE 1, 1: PRINT STRING$(80, 255);„LOCATE 1, 1: INPUT "X COORDINATE"; x: GOSUB equation: y0 = Y„x = x + DX: GOSUB equation: der1 = (Y - y0) / (DX)„LOCATE 1, 38: PRINT USING "Y COORDINATE IS +######.###"; y0„LOCATE 2, 35: PRINT USING "1st DERIVATIVE  IS +######.####"; der1„Y = 0: y0 = 0: der1 = 0: x = xold„RETURN„„60 :„xi = .05„XPE = x * XN + XC: CIRCLE (XPE, YC), 8, 8„LOCATE 25, 5: PRINT USING "Error: ####.##   "; x„Errflag = 1„RESUME skip2„„VARS:„'fill in the polynomial's coefficients here„'Don't forget to take out the apostrophe„'before the Y=C4*X^4+C3*X^3... equation„'note:CA/X, CB/X^2, etc. causes overflows near x=0„C4 = .2„C3 = 0„C2 = -1„C1 = 0„C0 = 2„CA = 0„CB = 0„CC = 0„RETURN„„equation:„'=================================================================================================„'Use LOG10(X) instead of LOG(X) for common logs!!!!„Y = e ^ x„'  y = C4 * X ^ 4 + C3 * X ^ 3 + C2 * X ^ 2 + C1 * X + C0 + CA / X + CB / X ^ 2 + CC / X ^ 3„'          4th         3rd         2nd         1st       0th      -1th        -2nd       -3rd„'=================================================================================================„RETURN„„FUNCTION acos (x)„'0<=y<=pi„IF x < 0 THEN„      acos = ATN(SQR(1 - x * x) / x) + pi„ELSEIF x = 0 THEN„      acos = pi / 2„ELSE„      acos = ATN(SQR(1 - x * x) / x) '(normal)„END IF„END FUNCTION„„FUNCTION acosh (x)„'x >= 1„acosh = ln(x + SQR(x ^ 2 - 1))„END FUNCTION„„FUNCTION acoth (x)„'≥x≥ > 1„acoth = .5 * ln((x + 1) / (x - 1))„END FUNCTION„„FUNCTION acsch (x)„'x <> 0„acsch = ln(1 / x + SQR(1 + x ^ 2) / ABS(x))„END FUNCTION„„FUNCTION asech (x)„'0 < x Û 1„asech = ln((1 + SQR(1 - x ^ 2)) / x)„IF x > 1 THEN END„END FUNCTION„„FUNCTION asin (x)„asin = ATN(x / SQR(1 - x * x))„END FUNCTION„„FUNCTION asinh (x)„asinh = ln(x + SQR(x ^ 2 + 1))„END FUNCTION„„FUNCTION atan (x)„atan = ATN(x)„END FUNCTION„„FUNCTION atanh (x)„'≥x≥ < 1„IF x >= 1 THEN END„atanh = .5 * ln((1 + x) / (1 - x))„END FUNCTION„„FUNCTION cosh (x)„cosh = (e ^ x + e ^ -x) / 2„END FUNCTION„„FUNCTION cot (x)„cot = 1 / TAN(x)„END FUNCTION„„FUNCTION coth (x)„'undefined at x=0„coth = 1 / tanh(x)„END FUNCTION„„FUNCTION csc (x)„csc = 1 / SIN(x)„END FUNCTION„„FUNCTION csch (x)„'undefined at x=0„csch = 1 / sinh(x)„END FUNCTION„„SUB eqs„'  y = (PI / 2 - X) * TAN(X)„'  y = sinh(x)„'  Y = atanh(x)„'  Y = tanh(X)„'  Y = (2 * x) / (SQR(x ^ 2 + x + 1))              'AP CALC AB 1995 #1B„'  Y = (X + 2) / (X ^ 2 + X + 1) ^ 1.5             '1st der #1B„'  Y = e ^ (-X ^ 2)                                      'Bell curve„'  Y = -2 * X * e ^ (-X ^ 2)                             '1st der„'  Y = 2 * X * e ^ (-X ^ 2) * (2 * X ^ 2 - 1)            '2nd der„'  Y = X * ln(X)„' --above are test questions from ch7„'  Y = (1 / X ^ 2) ^ X„'  Y = (2 ^ (COS(X) - 2)) / X„'  Y = (3 ^ (SIN(X) - 1)) / X„'  Y = X ^ (X + 1)„'  Y = X ^ ln(X)„'  Y = X ^ (-SQR(3))„'  Y = X ^ (SQR(2))„'  Y = (1 + 1 / X) ^ X        'e AS X->infinity„'  Y = X ^ (1 / X)„'  Y = X ^ (1 / ln(X))„'  Y = (ln(X)) ^ (-2)„'  Y = 1 / x - 1 / SQR(x)               '\________„'  Y = X * (1 - COS(X)) / (X - SIN(X))  '\/~~~^~~~\/„'  Y = (ln(X)) ^ 2„'  Y = e ^ x - x + 3 * SIN(5 * x) - 2„'  Y = 1 - 2 * COS(x) ^ 3„„END SUB„„SUB grid (x1, y1, XS, ys, XC, YC, XN, yn, xm, ym)„„FOR x1 = XC TO XS STEP XN: LINE (x1, 0)-(x1, ys), 10, , &HAAAA: NEXT x1: REM Vertical down„FOR x1 = XC TO 0 STEP -XN: LINE (x1, 0)-(x1, ys), 10, , &HAAAA: NEXT x1: REM Vertical up„FOR y1 = YC TO ys STEP yn: LINE (0, y1)-(XS, y1), 2, , &HAAAA: NEXT y1:  REM Horizontal right„FOR y1 = YC TO 0 STEP -yn: LINE (0, y1)-(XS, y1), 2, , &HAAAA: NEXT y1:  REM Horizontal left„„CN = -1„FOR x1 = XC TO XS STEP XN„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (x1, YC)-(x1, YC + 3), CL„        LINE (x1 + 1, YC)-(x1 + 1, YC + 3), CL„NEXT x1„CN = -1„FOR x1 = XC TO 0 STEP -XN„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (x1, YC)-(x1, YC + 3), CL„        LINE (x1 + 1, YC)-(x1 + 1, YC + 3), CL„NEXT x1„CN = -1„FOR y1 = YC TO ys STEP yn„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (XC, y1)-(XC + 4, y1), CL„NEXT y1„CN = -1„FOR y1 = YC TO 0 STEP -yn„        CN = CN + 1: IF CN MOD 5 = 0 THEN CL = 12 ELSE CL = 14„        LINE (XC, y1)-(XC + 4, y1), CL„NEXT y1„COLOR 15: LOCATE 30, 1„'PRINT "± KEYBOARD GUIDE:  [*] for WARP, [+] for FAST, [-] FOR SLOW, [Escape] to stop. ±";„LOCATE 29, 60: PRINT "[" + LTRIM$(STR$(-xm \ 2)) + "," + LTRIM$(STR$(-ym \ 2)) + "]";„PRINT "x[" + LTRIM$(STR$(xm \ 2)) + "," + LTRIM$(STR$(ym \ 2)) + "]";„„LINE (XC, 0)-(XC, ys), 15: LINE (0, YC)-(XS, YC), 15:          REM Center„„radianmarks XC, YC, XS, ys, XN„„END SUB„„FUNCTION ln (x)„'the LOG function in QBASIC returns natural log for some odd reason...„ln = LOG(x)„END FUNCTION„„FUNCTION log10 (x)„log10 = LOG(x) / l„END FUNCTION„„SUB radianmarks (XC, YC, XS, ys, XN)„CL1 = 9: CL2 = 4„CN = -1: FOR x1 = XC TO XS STEP (XN * pi / 2)„        CN = CN + 1: IF CN MOD 2 = 0 THEN CL = CL1 ELSE CL = CL2„        LINE (x1, YC)-(x1, YC - 3), CL„        DRAW "D2R1L2R1"„        'LINE (X1 + 1, YC)-(X1 + 1, YC - 3), CL„NEXT x1„CN = -1: FOR x1 = XC TO 0 STEP (-XN * pi / 2)„        CN = CN + 1: IF CN MOD 2 = 0 THEN CL = CL1 ELSE CL = CL2„        LINE (x1, YC)-(x1, YC - 3), CL„        DRAW "D2R1L2R1"„        'LINE (X1 - 1, YC)-(X1 + 1, YC - 3), CL„NEXT x1„END SUB„„FUNCTION sec (x)„sec = 1 / COS(x)„END FUNCTION„„FUNCTION sech (x)„sech = 1 / cosh(x)„END FUNCTION„„FUNCTION sinh (x)„sinh = (e ^ x - e ^ -x) / 2„END FUNCTION„„FUNCTION tanh (x)„tanh = sinh(x) / cosh(x)„END FUNCTION„Marek Piotrowski               CALCULATE # OF COMBINATIONS    ao487@freenet.toronto.on.ca    01-05-97 (17:00)       QB, QBasic, PDS        117  3544     ODDS.BAS    ' Did you ever try to compare what are your odds in different lotteries?„'„' This algorithm simplifies the task.„'„'„'    This is the formula for number of k-element combinations out of„'    n elements:„'„'                n!„'     X  = -----------------„'            (n - k)! * k!„'„'„'      Where n - total number of elements„'            k - number of elements in one combination„'            n! = 1 * 2 * , , * n      factorial of n„'            k! = 1 * 2 * , , * k      factorial of k„'            X - number of possible k-element combinations„'„„DEFINT D, K, N, R„DEFDBL X„DEFLNG Y„„' I am going to comment this algorithm assuming number of elements n=49„' and 6-element combinations k=6.„„„INPUT "Enter total number of elements            :"; n„INPUT "Enter number of elements in a combination :"; k„PRINT„„' After entering n=49 and k=6 our formula looks like that:„„'                49!             43! * 44 * 45 * 46 * 47 * 48 * 49„'     X  = ----------------- = --------------------------------------„'            (49 - 6)! * 6!        (43)! * 1 * 2 * 3 * 4 * 5 * 6„'„' Since n and k are already known I create two integer arrays: Numerator„' and Denominator. These arrays will hold all the factors of the fraction.„' Both arrays are k=6 element arrays.„„DIM Numerator(k) AS INTEGER„DIM Denominator(k) AS INTEGER„„' Let fill the arrays with proper values.„' Numerator array holds numbers 44 to 49. Denominator array holds numbers„' 1 to 6„„Bracket = n - k„„FOR i = 1 TO k„  Numerator(i) = Bracket + i„  Denominator(i) = i„NEXT i„„' Now our fraction looks as follows„'„'            44 * 45 * 46 * 47 * 48 * 49„'     X =    ----------------------------„'               1 * 2 * 3 * 4 * 5 * 6„'„' and obviously can be simplified.                44                      22        45                     15„' For instance ----- can be reduced to ----- ,   ---- can be reduced to -----„'                2                       1         3                      1„'„' and so on. Following lines take care of most possible cases like„'„'  6     3          3     1          51     3„' --- = ---    or  --- = ---    or  ---- = ---„'  4     2          9     3          34     2„„FOR i = 1 TO k„  FOR j = 1 TO k„      IF Denominator(i) > 1 AND Numerator(j) > 1 THEN„        IF Numerator(j) MOD Denominator(i) = 0 THEN„          Numerator(j) = Numerator(j) \ Denominator(i)„          Denominator(i) = Denominator(i) \ Denominator(i)„        END IF„        IF Denominator(i) MOD Numerator(j) = 0 THEN„          Denominator(i) = Denominator(i) \ Numerator(j)„          Numerator(j) = Numerator(j) \ Numerator(j)„        END IF„        FOR z = 2 TO 7„          IF Denominator(i) MOD z = 0 AND Numerator(j) MOD z = 0 THEN„            Denominator(i) = Denominator(i) \ z„            Numerator(j) = Numerator(j) \ z„          END IF„        NEXT z„„      END IF„„„  NEXT j„NEXT i„„' By now most of Denominator array elements should be equal 1.„' Our fraction looks like that:„'„'            22 *  3 * 46 * 47 *  2 * 49„'     X =    ----------------------------„'               1 * 1 * 1 * 1 * 1 * 1„'„' Final result is a quotient of products.„'„X = 1„Y = 1„„FOR i = 1 TO k„  X = X * Numerator(i)      'Calculating numerator product„  Y = Y * Denominator(i)    'Calculating denominator product„NEXT i„„X = X / Y                   'Dividing numerator by denominator„„PRINT "Number of"; k; "element combinations out of"; n; "numbers is"; X„„or by denominator„„PRINT "Number of"; k; "element combinations out of"; n; "numbers is"; X„„Hans Lunsing                   COMPUTE NATURAL LOG TABLE      FidoNet QUIK_BAS Echo          01-03-97 (09:16)       QB, QBasic, PDS        128  4455     LN.BAS      ' > Well, I declared each variable as DOUBLE separately, and now I„' > get correct values for ln 2, 2.5, 3, 3.5 and 4. All the rest are„' > off. Try it and see. Any suggestions? How do I find out what„' > algorithm QuickBASIC is using, short of disassembling their„' > libraries?„„'This is what I got:„„'2.00  .6931471805599453  .6931471805599453„'2.10  .7419373447293773  .7419373447293773„'2.20  .7884573603642703  .7884573603642703„'2.30  .8329091229351041  .8329091229351041„'2.40  .8754687373539001  .8754687373539001„'2.50  .9162907318741552  .9162907318741552„'2.60  .9555114450274366  .9555114450274366„'2.70  .9932517730102836  .9932517730102837„'2.80  1.029619417181159  1.029619417181159„'2.90  1.064710736992429  1.064710736992429„'3.00  1.09861228866811  1.09861228866811„'3.10  1.131402111491101  1.131402111491101„'3.20  1.163150809805681  1.163150809805681„'3.30  1.193922468472435  1.193922468472435„'3.40  1.223775431622116  1.223775431622116„'3.50  1.252762968495368  1.252762968495368„'3.60  1.280933845462065  1.280933845462065„'3.70  1.308332819650179  1.308332819650179„'3.80  1.33500106673234  1.33500106673234„'3.90  1.360976553135601  1.360976553135601„'4.00  1.386294361119891  1.386294361119891„„'The approximation function does a really good job, isn't it? If you get„'other results you must have done something wrong. This is the source I„'used to ptoduce this table:„„DEFINT A-Z„DECLARE FUNCTION Dln# (x#)„DECLARE FUNCTION Expo% (x#)„„' Approx tries out an approximation routine for ln (x).„„CONST TRUE = -1„CONST FALSE = 0„„DIM SHARED Aerr                         ' Code for approximation error.„„' Main code:„„        CLS„        FOR x# = 2# TO 4.1# STEP .1#„          y# = Dln#(x#)„          z# = LOG(x#)„          PRINT USING "#.## "; x#;„          PRINT y#; z#„        NEXT x#„END„„FUNCTION Dln# (x#)„' Dln finds the natural log of the passed parameter:„„CONST a0 = -64.12494342374558# - 1.147E-15„CONST a1 = 16.38394356302153# + 4.222E-15„CONST a2 = -.7895611288749125# - 7.267E-17„„CONST b0 = -769.4993210849487# - 9.777E-14„CONST b1 = 312.0322209192453# + 2.844E-14„CONST b2 = -35.66797773903464# - 6.171E-15„„CONST c0 = .7071067811865475# + 2.44E-17„CONST c1 = .693359375#„CONST c2 = -2.121944400546906D-04„„DIM F AS DOUBLE                         ' Fractional part.„DIM aw AS DOUBLE, bw AS DOUBLE          ' Temporary variables.„DIM rz AS DOUBLE, rz2 AS DOUBLE         ' Temporary variables.„DIM w AS DOUBLE, z AS DOUBLE            ' Temporary variables.„DIM Znum AS DOUBLE, Zden AS DOUBLE      ' Z numerator and denominator.„DIM N AS INTEGER                        ' Exponent of 2 in passed parameter.„„' Main code:„„        IF x# <= 0# THEN„                Aerr = TRUE             ' Signal an error.„                Dln# = 0#               ' Pass back zero.„                EXIT FUNCTION           ' Quit early.„        END IF„„        N = Expo(x#) + 1                ' Use DEC-style exponents.„        Power# = 1#                     ' This will hold 2 ^ N.„„        FOR I% = 1 TO N„                Power# = Power# * 2#    ' "Integer exponentiation."„        NEXT I%„„        F = x# / Power#                 ' Find DEC-style mantissa.„„        IF F > c0 THEN„                Znum = F - 1#„                Zden = .5# * F + .5#„        ELSE„                N = N - 1„                Znum = F - .5#„                Zden = .5# * Znum + .5#„        END IF„„        z = Znum / Zden                 ' By definition.„        w = z * z„        aw = a0 + w * (a1 + w * a2)             ' Numerator polynomial in w.„        bw = b0 + w * (b1 + w * (b2 + w))       ' Denominator polynomial in w.„„        rz2 = w * (aw / bw)„        rz = z * (1# + rz2)„        Dln# = (c2 * N + rz) + c1 * N„END FUNCTION ' Dln#„„FUNCTION Expo% (x#)„' Expo returns the exponent of 2 from a double-precision number.„        DEF SEG = VARSEG(x#)            ' Find data area.„        Start% = VARPTR(x#)             ' Find x's place therein.„„        a& = PEEK(Start% + 7)           ' Most significant byte.„        b& = PEEK(Start% + 6)           ' Next most significant.„„        Word& = 256 * a& + b&„        IF Word& > 32767 THEN Word& = Word& - 32768     ' Erase sign bit.„„        Word& = Word& \ 16              ' Erase mantissa bits.„        Expo = Word& - 1023             ' Remove bias.„END FUNCTION ' Expo„Erika Schulze & Gunther Ilzig  TRANSCENDENTAL FUNCTIONS FOR PB100775.2275@CompuServe.Com     01-17-97 (17:33)       PB                     156  10326    TRANS387.BAS' Run/load under PowerBASIC to extract TRANS387.ZIP„DEFINT A-Z:SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"TRANS387.ZIP",4^6:Z&=7442:?STRING$(50,177);„U"%up()%9%%%[-%f0.VG.e6E7S+%%%I1%%%/%%%%wj%firj%SVxyD,%n>]\];7j#I„U"0'hLIV?B-(]yCQd]dT:%f;Fzgn;%HsKZJB=Oe2n<]N'Kronqk.XX:Ht=z(fpIxS„U"+C8\)K'VRi-0I1gD[u#t6vu8]<.:GS%oT?qmD+Gn0spPqRz4d<u?seQqTv9AthA„U"eVD]k^VpRb,HsC9+Bf0K<pnT9^<E;BM?4%N7h2]F?/+1uWk5Gt,kpkyKuGK?4ht„U"&4OZr5LBO]3;62nB0yKL\d#Q+L#KojlTJ?FwHj?NmB_C47g8GZcjH$508+lM,ml„U"Gkaj&1PYrMXyCGd4l\+,^QtporZk%DR_=bd0&Y2Q.^tSb%Z2bG0?A[kGMV=,faO„U"DJ:JMja#Lg&(Avy:Jr&[%8]i1'I\x3qVuB\>fria'?VFRZ7CT>o=jp.]_*'wp+=„U"^+nC-FcoETW&5?,Bg6dH,Xww_6'cd1Q9*i2wW%/BlMa(WFtG9/tu2p'0QFJP*)d„U"OfQ-Jl?%,:CRpkRPu3<J]*jP%5\\DDi<3fcu+K1]-p$h\P3KHOvPU1Z>d%X1gQr„U"H)J\eb%Ir,R\,TLtkNGn3%0T?:OG3XGz(2I#MBtw/*_,zj9m#d2l&f\L7$(]Nrd„U"N8ksqhun][p)F'K]H6MAEqnDN<k<15co%uFdk9a/5*1A(2x/$%dZ9_<o(\0\#&y„U"di,K#O8Hp;CYLB-5l1J*U)=Hf.*eTz<j3L;J2_Q6,QGdi&8a/E_QTXO++S?-C>)„U"J(lTo9jSv-F]v],%Ho#7ZXu3d&JJKmtSTZ7Q-Tu#8rSWA=Clf=4<j-f9QSt1ghq„U"[+e:S.Qg+p/MoWpUM)(OV[%6&>0;*HeQub&TalOv7>_hKi_GfsfbJLX/po6Swa4„U"x>0;s&c?,KT8o0+3)3d4UYI63=BTS(&470DpuT2G-J]CpcG+%=;eFn#yJ?3AJ]Y„U"8]:[QB8Y]9^.$_faPCfu$AO'7MZuoT1/o*c3:tdmRvKVG%SYQm'VM)9^vjo5+G_„U"hd#f2#H\%USap.JrXBW>WI$_dqV93Pa\dY$7eE-NoC-*&]SL-Q(T[RzSSb,;VdD„U"K7/2%\7#.X3cwg&$D../OIO&B[uyTCe#w4S)A.TtLQSgXHN9Ah?u]l-NAMH4?rk„U"D[mJC;q&1Ngj0)(2%r0MKGHpf2.(.w0.8VopUMi?jpofs&/XFPY]dI'a#l/?sFj„U"WdLe_^bdb5.[Now3B4O6IQzBZXE)+E_'7NgVs[Y:=Ej62reoT.rqqVwg(xJU'oW„U";9CNH?6a>'fqzXC>IB*ejtA7=^Eo.3_eHC<(#7\KJM<6i,Ig][M:*gIcG4o?[Gm„U"Dq)6dq(fpY>iLsIRDY%ms^F9_g71i4pb5CS_)RYKjT+;EKB#?5vxTO-wI62]_en„U"dRZ)*:$;8([Q]eGu<('b#\gIBJgN6_Jq\hR9-?30&:4k,p5r,<BxIUCJwk,8vxK„U"j%(#^a^T&aT&U:dxGimzf3&[23TFy*-)I&06t)K+vLASn\WL%UE0KuDOeZy$v7o„U"g/;Bt?ByqsZTpb%3j\]tR*t&rnsH0?v3dUsfH6&vYnL[nN^qc.O7C>F3is7S(q-„U"lL=zEZ-[FYIv;upj$$48P+Z,hIaJ%i^ycci0>/T9#wlsN]1:)uj)P;bBhY*?$jm„U"X5u77?%rfD[;KZ6M=Y]oK%M3M2+X1dvXme'o[4FCdS&Ag?1#dZHpZ#wB6$UA38V„U"kl=J-KIGP$:AYZiNFq#?9w0etFCOA2P=Ze>;5$*G1J;[W<Je#3%5lvk,Gov>r\<„U"TDVLqK_??9(pz.\8e*i[&6WGX+FdI0mh=)t]HmF>gNd-*-gN.te8N7T$+0[sVcF„U"/3Y6GcDTb9?d\45/:Va\vlRe\X0&-*A\1Sl^0]WI+;;N.OaDB'r9Ejic2R4.ttg„U"%_KG6<ZAIZtvC;45ag:M).(vtgdvN^lQWdi8XpT^mrSbt]<LAkme%p+cnw*mY^(„U"usupxFW/wJD6EN.>i<.JA^fA&CtLZ1R=S$DkK213Z6;G);g^FA>-9pE/=_euh),„U"#*'+H4lk0WX/0ZcS#$]e]pQUXGx%*&f,)V<%W1O9^O*qMfT:ci'7)%P9le]Pj(W„U"Khh87W7Y;6AssHbi<YoXd]bBBnJp?$[r0+.F92YxSfR+rtY6Gji;DMr0%up()%9„U"%%%[-%f0.VGT&0s]k.#%%$.%%%1%%%%yw%fsxX%]\SfRxrf*<VASmO;7]z0u3L<„U"$iO,AD=aV0Jy=>+o^O#jC+JK*Cn+Js(+zkm2)D20<8%_&BoGt$qvhL&RDIae8)g„U"+F3dBPeuFrsmTX^X8c.s,NlBw-xu=-iJ3,6fD5U$r<*(.B3+lhuV\0MP0skGUL(„U"Vi]C\q\=b;itHRM\i]\8k.8j+bFK_0/2;xfFgb26&,1GIgHu\9u;KB];Sy,Tr4C„U"MD7mCe?;0i4oi2w<f7.<\YN]CZt:q9ei<AuA[l20-kiu&0r<N<VP5+t7XBgGs4\„U"aD,033h[GpWa79#FC<t5UhQXHixrY6V<]DQY96cl25DuwWwW/9:VX-#9;gGe_r#„U"N[MNU;6]0ei5'ooH[np$W>LO0#TxBUjYDAgB)F)H.J*HJL&(V#r$2DM.6_H\JQ>„U"bO#./-nf&<ofBv[Al(C6&Ad$Izqsw,,.V8%j__594nM;<ar)l8^Ypdzq&Eh5:n2„U"4%L[%:sQBJ53)fac8tiAC+3Q^N%$<ftL&$i#fvh6HPuhM007fX?rl7bHd]mMFg?„U".#,C/z$qR-fWME$Cj.p8e?wmk0.g(s>_UV.EMAJ9Xd_rWoJMsb?'E=:za.S::aI„U"JwT^f3coAk^*'mw=fUJp]PE1.l4]%X2+I%/BfxmrGl,Rl.-ds/S6dSfTIja5[2[„U"jdN<TqKi>+c80_Dt+HJRMDqHqdZh=QJDQ'<+X$;*&4RGM-/;f=lt&7SY?b<wq\L„U"MwOZa\Di>X<SdKj:Kb60rF+WhV_-217Mn)+8KijQ1]%w4fzYn?wfZn8Csgt7rLI„U"a?O8&qEWFB[*?x8\sH#P+.(o3CW?EJ'uBZ]+>+.J?iHv+80J?j8P#rmzy_Znoxx„U"*dc,OuSOg8,>lMbJ4F_p2+IXp'SJxobr.JB9.=:4F3SbfQLF;TsP6RbfsqO*mSa„U"gLCfj'\M5]X^?b+.kxneC6V$k>eSfJ+ah0XMZvI[zA?Pyw\t2397P'wRYkgj*So„U"Zx\X%h=l3e27S,?CXZ$[9_)lW=>S>zo+>it2AG]?H'_V6%7F[4&pp]dG(wxS(+z„U"=__.jxa#$/^&%5yfn:(z3mGru3zU8=bNRWye0*a1QgO(d6B1g0PX&+u*0/=Z:3J„U"RVpGf6<oQV?Qq,^h+m(0Gl\0pgY3>6eRtgKH;xD>ZNM*1:gsw];bFMq4&+K4#vG„U"Cn0y)C.ssdz=j(mAKTZE-ECflqu;GN\oP()luKjdjDqfICkP\K)*aDo8'.:8&ni„U"e3r,NZGlhRp<q^rgLJGyR-<.NU0?Yx6u\HIMjO:;VV;F0+_G)lWKa'hcl83HhTi„U"JO_#S128S%Z&A;+q$)k0i]iKCiXaD]r]>.>;80C\jVE*Hs:d+c6q^63U)x\t#9l„U"KLTF[KK\bViVE;iLI0?x,+niAVVGYZh)eB+9SH0QH9)hww1M^q?_j<]o&H=iUt3„U",$v>t5*UtNj1GRZX\F</YhxMhU.kw*U2VaSGS6OQ(u]Q2WrVEn>A+.NG&:Z]IKt„U"?oi)3;seSKC0SHjel7#^\)H&+39>lE$\?<XaXoJO)XZqo&)MTWY,PuTcp0_)&Yj„U")F.qq<7Q220MO-6ODTgsu%i>E?Da[8RhAO_ter(>[v:H(*iwoFXKNGSJbV%8y::„U"lL,<#Mqq-B&5#jj7:G&9U:fR8ps+U*&wmUSoDwciPosE3I?Pr,B&4:JO[2jyuIf„U"'-G:Y<FYYVfBGSs3vj,]PKp(d#i1o]_d=gHF2cIG^;?S0Jy/t)iT1TaqjqV;RI(„U"+3CIF^f0ptX^t0\'[jtt[IPY8jQ#Ot5T$(qwZSk2mzLq,07rAtE).qhsJorDegF„U"0?O_0kuxwIaZ/vd-Xx+f)[,NET)$%Rb<XE_yFpti#gby7fL>-w,JQ/W9thFrbI*„U"g*xkY[)'>JNMx)#Q]](O$D;\=qtKR=;?+T*/$SZfC3\HuP84k-jxD2GH&x&,CV1„U"7bqf1P$eAyb+l6Fh4ykH#6:x4pj]q=+5DnVf-1AA^jU;6&J:5iW/r3k?i>J)0kb„U"R?d;iZRb0_+5i3<n8V5a<QS7O+Z%1VVhUgQ1[RDRbBWr)/\Q/\O#6Kl<Ldlq)q]„U"=7D_+V;8rh[C4N?rsF;ogOggc*p0$:34C]0,YnX51X4ye^buOL,)E,^okVTSo:-„U"dn*1&TEraaUJ')<d_P-PT.GgJ%?GAf#gDOvGDrE/7#?#*tA20O70^iAEmGVB;$O„U"ULd)C6+H7;C71:wgeh9mLx^rdLEC,;]BN0*RDuYrpj,MFHw^Q)g;Z[tr;c90jWD„U"g)7N)%S^>Bs4HWkfW/JCFdAD14&Sdb\#a_0SpzOqj:Z93D],o__2*0ag-YvQq2R„U"^QNQuSn0-5^'9m8+V#['DqGHL^JL4k4J?fGZdBJ#=U7\-7Jq.11<F7TEz;RYq9j„U"]r?w?(Llp6^,aZsUI-#3&ZPk8y+BM4X^4i(u5>f8kH_/8zZA6.V>zB<Dx)67MVh„U"#%M&VZ31a%P9x*Tca6,)x1BzoX2E<cfNPYxC[J+R%bmAF>;</GuF#U</?h3\SEq„U"q0-n[SW+-t[R8ZR$RUmN]YXm4;,]Uj<?J'RZ_Xke%WR$?d#p=J1ab<q82[_rtWf„U"=s'/qbq3Xc-frXvrmWcfn,\gTV$I,,RGHBw?4qj)Jhid<_5=TTh+/K'UiB6z+Of„U"M'p&.)6=N'r%)MeV(,/gvHk'-hh;4P.nCbMIJJHo*m(+XGgLy53d%.Gu*thPdnP„U"'3*h<P*Xr+Z%%hM6alHS0yeD:5tEp]Rgf'bS(0/gT\%d,=v-(6>-W85s<kw:+[N„U"UIL8/f?/GXb\u\?^c(>'RhC=PARGFT3o-ZvgpRSSUR(Z*<Sjt,']Q/nHu+#ThX9„U"f^;K:KvGXLIc4E1:[ihd<<3.7:=#:H>15>Ht*N)'J('NOMq.LwHq.ZNI(P(Q4Ot„U"W7ySqgsVPV.Go6#;lJFF^oeXnXv<+$]Xy3JK.7tS(fyMnc-V$Om%2_HYTR.Fp%n„U"6u?wDUArN%'27w(foHHRDUVE(//&B]Kka[c..cq.C+VetKdWTc,<Z?-q2^)xl(f„U"CTv$rB]r^FNSiAWvA0R/gLkOl2_ViKDpRMdv*YJsCYF%:w#+33Xfi<Ud]hjt5r7„U"bX;s78+NX\22L.\s[TZfc;?Id+ReRtJ&N(up%()9%%%%-%,00VG3<[O1&*-%%&.„U"I%%%1%%%%ywfs%xX]\%SgfxNN)*>H[A7M7KwwhFN4wa*JSJ5a'B/bg%#5R'ZKEX„U"O$$0sr?=9;rQkgoOIR.NtySq;3>+UiPzfVXu*47sYydO<lHrV0^#vL$5,Z\*5jV„U"6+W694.pMf+.&9D3#JSX/A;InBa<ih$o:Jg+b.<km%jZZO8h,8AP6['13V[KPsK„U"$7;F(>4*]l[Mxv/H5r%u&gF_Z/<>LGudbB_PUZcsuA_Z[gsaX?*YR8pxG/NF)3Z„U"KS_(_)FU]o#D#h)y4oB6he\Ywo2*?RxLT)GDHNkQM+.t2g0sO;iGFhXNjWP6[s:„U"'hg:oJCLV#y7iSGgW6acrS'i)OUlo0bOu(20t>lmFXhluFFZ6%Uy\Qsp?l1PdYD„U"-lrw6[3=#I#?SSs'D:f7_5eUxM2q&KHB>4mu>DvJ93t.KlshpLSy[S?oIE-\B,J„U"?vLLW&HN4P7<Ct#qnGy\%N(vcN;'E>KKf#Jc94)#n=eT=m(4EqW0*gia0nRna[l„U"CsYF5RUU.>bg2'g+e6saXCfC$7^UmC:4E4[MsZ2E^ZR7X8G%_5Zm5AP8EggN[\p„U"V:eS[84f_[b>[kBq*c?qfjxUk16oxKSW,?Ywu5nc892\FjuZ:N>G)aTYQVH[FZ)„U"nPIop.C2Fgr[bEBSyD,xO\&(TQ7-.]6vd7[$N&l-4NJ0mVF^C;F3^:-a-sUHF3R„U"Ukzj.j(s,<SGmS$:^n*N'#5AVYx9=y[ni_&M=r8OWjf*;ADqpH%=iYf]\d=.Svt„U"IyqEplqK1QoK*ZQ\?W:[F0Ciq0ydmSae<OQ8.ubE2^pvAQ'-bq;K?;I[hSN1Knf„U"Hbp-3S5r+BAZFe#nMiy=XX.rp;GR*AV'0J:[cty1r$rLVgmlX,<'n>8xw?;&xTp„U"wgp1./kWv0mocNS)r,g7<h4y;,#$m6lU0jCNN1_zQq\=(JUsbNaqBP.H^/?7KUM„U">mI8lCM_OtfVM[7F+95Y])7BE.\vK/$]3BStRr3Pw>;,A*[/iT+fcJKVIgC*.\Z„U"8Hd1=s^Wl3_+Nu&&NsVv(O5s8%Gf_e(3%,/On'%rk;a^)d,uI1)mi)oft(+KUt?„U"6U&o&AK0?AB4Ix;vRi-#B9m99kil2oy1neL3r0UrHzZWZc+:wD#)]Gt(g#IeC'B„U"Pl/6$E#mTWEf1q40/Bt7o#0v#fS\)XufnylXOt*1;hwoa-oOB9=FnLqM4RQ04Ii„U"t;,_\I+)Cuv?;Ol/OKOX0$IQ-v>*4SgUl>YUTEge6a#(vAVIDR[kG7Q>4lEFyFy„U"G_<bw0,Fk)Hw?0'1Z+pgpXd.o]&Zl:RcAKk<*TGlpB);Z=*dYg)R_$ka_%dn$=_„U"mO>f0N&t,GiCGVOH;UVB9_8ULV[NrtOwAp>Ti;O1;Lfo?0qi?CoH9E;Sh^kq'Y7„U"<c*+0j5sLSEN5QQl;X?K^7dswn-,,3jWZRkf<pS.5BR:o^j4#eG\#jBggm7S#U5„U"ST+I)5IW7%PSg2<PJ<qkC91_bD/yAW$Y2A9'y5RJfptK:^_<NWQbMi./:zMSd/>„U"+uwog32KFjTVe=DpZ?F+PcbZgIrEd>9/+DJSt=Oi;G3GG.,ql<S+LrNq(G[P,1\„U"3$YYN:-bVc#pvILhkHs(b\U?%)hhW-VakYm5YnSq+OoL?bNN0r-]0Hmh=-'WF$3„U"Id?s\6pQGZuSn_L)R#;B>:j?>o'5.4c*WzJby\r6JPF$Iu,(PIAC]0KmGrm58jq„U"/E>TcEVhJCD*2cSf0hf2\9([t7>8Qo6Mez7pmZQcT=R'k<.[G'OiDl_I4l9bXg3„U"Z6RU\Fk'H)BTAaHai)JP8DJNNoJw2Uj.Vb+$n*^tfM1A];R_LRZ3Q=#0<>f#y>K„U"063G<keyb[UnoYGv=Y.boVzYe[joLi;%E7-\Ngs$d1_>&/7SjR(M,,S)LSb+2(a„U"'h/9qGPIQYh6PgV6i1h[Xj-e)v8U;^G5wf#x.:OGk*xjLO+KSilv5Fdc_c_^6B<„U"=iJ*T8:xc*_fVRq+#js'gRg>\V<9C,Hhr'x\MA7V+IXjHGY.RisGoG;ipjd+j9&„U"a2neb?DsAr8%u;lh>?FYqE%2aJd,jgK*'QFxY+]W=[QbQq0T5v<GqZUdU%+BP?6„U"cN58f7W*ZgvQqZR>T0DUPrvou4vjhNWqP7S^tfIB)h4i=Dumm?5:',&lwS[Y(jW„U"B*pJOgP81B..F1U31yq%#,QfZ-Gu\P\%8&)AKo(W0/mIfm??ni=Ic9m^lw[V6bW„U"s58)k;M1PZtRsAbMN^)-ad/?12Vb$/oB-oI$J'<;P'1eMAR/;38whcPW./QNKnZ„U"SWh_>4DtqRlEW0hGuH,C_]p8oswIf^<Y<UGd\y1xY=pe%gpb=1jS$/$5Gl^6)z4„U"5PWw+p*)O5,POZE<;qbev<hemosF2sstt_672XSW^>hZT1ri'C&A=<i5^r0PBqR„U"HiqyDPsGW[/?on1A1d:OyrP/\NpM;'+4F$u-scf??to7rU:eoo\[xcS-7XYGICG„U"'2qU?y.t^s%,;eNdn&PX7kv9T]EmylIe0a,gWJ5wPe9;e+;lH7D$0LB1mltR48e„U"BIb$p8uh5+FQH3=U9[_1u_'_gT-D].qPMf.QKwX#:xzUo(xxs;gFpb?YS$=S/>)„U"OM:FdNfSnI1*L'+3vY_clt;c8k=%6Ba7O37&%AoI\S.pQ+6_Jok'TRwR6JeGn6j„U"\msIb-Y&N_umkMvR7e^[\opjrvR?qodJr6)>T'sajF2X1>#,\x,u%p()9%%%%-7„U"%p0V(Gg,<-;w%%(%T)%%%1%%%%ywf%sxX]%\Sns4h&bf,:;U9c#H;s%BCOy:fEj„U"UIT$C,2T9\ha$Qnago)R^gji;lc\HuP2(es,GL#<M68xn,<jmg\-'\J#hn;v,3#„U"VW)b?LMTNfdi#aBP>?U6(oj>Yd$jT8:bd[14EpF9Gt_$,aOcIJ11NX8;u\7)n-K„U"1U.<>d3+ri%b>PoF&rL5Ma#Sk&&E=wIR<?00\W=I5bMiM%xQMoUhw5o1b,s2fnJ„U"iJZ-CwA>J$jk4187JlahI%;f5KSu6cMO[[4+*Na7*.-0fy$mxtJNmxL%0bI^PxE„U"'d8tr6_xV'44RB;m]_g;CFKg-*^KJ&Q&OQgupot,MGDu%p()9%%%%-7%p0VXG+T„U"B*Lb&%(%s'%%%1%%%%ywf%sxX]%\StgUo:Y2'YNNo]EP[/+UPpQ?GNfuM///_%.„U"NRo3C&?Q7SsFr'CnRw%u-pRsOGEH7xUJXbkRF;ZYi+v%Lo6j)6A,X4uQ6?%8(h+„U"kW2?C[Y6+W\_El8h/oYq45PW51;6N<$Pg>eR1C_[jqE[0bvjU)H?4]UO]+OW%hE„U".+.+;%k*w8A18;Sgf$wp&V$,'=Q'wXjtNY0//;3Dl2com(3fhF[dfeD1Fc9)/:I„U"2;5/911\_1_VsWaUmF1-:L>=Y1ZU/B8O+U\K]\=LTOP0^+[#YOD7\PRfC?De\-G„U"?c9i(?:2#mx)2/]YSP#A4Y#ln#2&135YVluG%>>y$&'=A;IVs+/uFAA9s5Sv_mm„U"ATfr#90nY>wdM1?JY*Fjadu<Iv4\o)-WtnWNq[$_6y:\jTe;&nVzCr1#[_DZJ4>„U"Hw;TH.7n)S4ae7>$T$_'iT^>dtwVO6Zrj_PqjNg57)Os%pyMi_cX4\\c[^fcI^u„U"[JGDhIudoYF7[*Nil-JF\mYQL3O)xx)%%up&'%9%9%%%%-%+f0VGn.eE7&S+%%%„U"I1%%%/%%%%%%%%%&%E%%%%%%%%%wj%firj%SVxy%up&'%9%9%%%%-%+f0VG8T&s„U"]&k.%%($.%%%1%%%%%%%%%&%E%7%%%+%%%yw%fsxX%]\Sf%xrup%&'9%%9%%%d-„U"%00RVG<[/O1*-.%%.I%%%1%%%%%%%%%&%%E%%%&A5%%%ywfs%xX]\%Sgfx%up&'„U"%9%9%%%%-%+p0VG\g,<;'w%%%&T)%%%1%%%%%%%%%&%E%7%%p=%%%yw%fsxX%]\„U"Sn%shup%&'9%%9%%%[-%p0mVG+T5BLb&.%%s'%%%1%%%%%%%%%%%%E%%%%D?%%%„U"ywfs%xX]\%Stgo%up*+%%%%%%*%*%%E&%%'U#%%%%%„END SUB„CLOSE:IF S=247AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Erika Schulze & Gunther Ilzig  TRANSCENDENTAL FUNCTIONS FOR QB100775.2275@CompuServe.Com     01-19-97 (16:30)       QB, QBasic, PDS        862  41263    TRANS.BAS   DECLARE SUB Reading (x%, y%)„DECLARE SUB Basex (p1!, p2!, p3!)„DECLARE SUB Waiting ()„DECLARE FUNCTION CalcRad! (p!)„DECLARE FUNCTION CalcDeg! (p!)„'***************************************************************************„'Program:       TRANS.BAS                                                  *„'Task:          Demonstration for the transcendental functions.            *„'Interpreter:   QBASIC mixed with assembly language                        *„'Written:       January 1997                                               *„'Authors:       Gunther Ilzig and Erika Schulze                            *„'               CIS: 10775,2275                                            *„'               Internet: 100775.2275@compuserve.com                       *„'               PUBLIC DOMAIN                                              *„'***************************************************************************„„'The  software  is  provided  with  the  standard  disclaimers: no„'warranties   or  guaranties,  either  explicit  or  implied.  The„'material is free for use (PUBLIC DOMAIN).„„'There  is  no documentation, but in the source code, every sub or„'function   has  a  header  that  contains  not  only  the  passed„'parameters (INPUT and OUTPUT), but also the used algorithms.„„'Hardware requirements: 80386/80387 (or better).„„'The program works under  DOS,  WINDOWS  3.x,  WIN95 and OS/2.„„'Motivation:„'===========„„'QBASIC doesn't  support FPU instructions. That makes the programs„'sometimes a bit slow and that's not necessary, if a FPU is avail-„'able.„„'The demonstration program contains several procedures for„'calculating transcendental functions: sin x, cos x, tan x, cot x,„'arcsin  x,  arccos  x,  arctan x, arccot x, y^x, log x (ln x) and„'log10  x  (lg  x).  The  calculation procedures are completely in„'assembly  language  with the new 80387 instructions and therefore„'very  fast.„„'Note about terminology:„'There are differences in the expressions of the logarithms between„'the USA/Canada on the one hand and Europe on the other hand.„'USA/ Canada                     Europe„'===========                     ======„„'LOG X                           LN X„'LOG10 X                         LG X„'LOG2 X                          LD X„„'It follows the explanation. The different terminology is a long„'tradition from the European renaissance and later from the Enlightenment.„'The famous English mathematician Henry Briggs (1561 - 1630) made the„'first table of logarithms and the G in LG X stands for Briggs. The other„'expressions come from the Latin: LN = Logarithmus Naturalis and„'LD = Logarithmus Dualis.„'We've mostly used both expressions (one in brackets) and therefore„'the programmers in both worlds shouldn't have difficulties.„„'The library is, of course, PUBLIC DOMAIN and everybody may use it„'free  and  change  it, if, for example, another precision is„'needed.  It  isn't  complete  and doesn't include procedures for:„'sinh  x,  cosh  x,  tanh  x, coth x; but it is the first release.„'Please feel free to make suggestions for improvement.„„'Another,  possibly  better, approach to calculate such functions,„'is  the  use  of  the  so  called  Chebyshev  approximation  (for„'background  information  see  points  5  and  6 of the literature„'list).„„'Literature List:„„'1. Ross P. Nelson: 80386/80486 Programming Guide. Microsoft Press„'2. Stephen  P.  Morse  et.  al. The  80386/387 Architecture. John„'Wiley & Sons„'3. IEEE Standard  Boards. IEEE Standard for Binary Floating-Point„'Arithmetic. ANSI/IEEE Std. 754 - 1985„'4. Intel,  387  DX  User's Manual (Programmer's Reference), Order„'Number 231917 - 002„'5. G. G. Lorentz:  Approximation of Functions. Holt, Rinehart and„'Winston.„'6. Lyusternik,  Chervonenkis,  Yanpolski:  Handbook for Computing„'Elementary Functions. Pergamon Press (translation from Russian).„'7. K. - D. Thies: PC XT/AT Numerik-Buch. TeWi-Verlag (in German)„'8.   Jorke,  Lampe,  Wengel:  Arithmetische  Algorithmen.  Verlag„'Technik (in German).„„'For further informations or questions send us a message.„„'Erika Schulze and Gunther Ilzig„'CIS: 100775,2275„'Internet: 100775.2275@compuserve.com„„'===========================================================================„'used arrays, variables and constants for the demonstration                =„'===========================================================================„„DIM FMSin%(15)                  'array for the sine procedure„FMSinseg% = VARSEG(FMSin%(0))   'start address sine procedure„FMSinoff% = VARPTR(FMSin%(0))„„DIM FMCos%(15)                  'array for the cosine procedure„FMCosseg% = VARSEG(FMCos%(0))   'start address cosine procedure„FMSinoff% = VARPTR(FMCos%(0))„„DIM FMTan%(16)                  'array for the tangent procedure„FMTanseg% = VARSEG(FMTan%(0))   'start address tangent procedure„FMTanoff% = VARPTR(FMTan%(0))„„DIM FMCot%(16)                  'array for the cotangent procedure„FMCotseg% = VARSEG(FMCot%(0))   'start address cotangent procedure„FMCotoff% = VARPTR(FMCot%(0))„„DIM FMAtn%(16)                  'array for the arctangent procedure„FMAtnseg% = VARSEG(FMAtn%(0))   'start address arctangent procedure„FMAtnoff% = VARPTR(FMAtn%(0))„„DIM FMAct%(16)                  'array for the arccotangent procedure„FMActseg% = VARSEG(FMAct%(0))   'start address arccotangent procedure„FMActoff% = VARPTR(FMAct%(0))„„DIM FMAsn%(20)                  'array for the arcsine procedure„FMAsnseg% = VARSEG(FMAsn%(0))   'start address arcsine procedure„FMAsnoff% = VARPTR(FMAsn%(0))„„DIM FMAcs%(20)                  'array for the arccosine procedure„FMAcsseg% = VARSEG(FMAcs%(0))   'start address arccosine procedure„FMAcsoff% = VARPTR(FMAcs%(0))„„DIM FMPow%(26)                  'array for the power routine„FMPowseg% = VARSEG(FMPow%(0))   'start address power routine„FMPowoff% = VARPTR(FMPow%(0))„„DIM FMexp%(26)                  'array for the expo procedure„FMExpseg% = VARSEG(FMexp%(0))   'start address expo procedure„FMExpoff% = VARPTR(FMexp%(0))„„DIM FMLn%(16)                   'array for the naturalis procedure„FMLnseg% = VARSEG(FMLn%(0))     'start address naturalis procedure„FMLnoff% = VARPTR(FMLn%(0))„„DIM FMLg%(16)                   'array for the brigg procedure„FMLgseg% = VARSEG(FMLg%(0))     'start address brigg procedure„FMLgoff% = VARPTR(FMLg%(0))„„angalphadeg = 30                'angle alpha in degree„angalpharad = 0                 'result for the angle alpha in radian„angbetadeg = 0                  'result for the angle beta in degree„sinbeta = .8660253              'the sine of 60 degree„cosbeta = .5000002               'the cosine of 60 degree„tanbeta = 1.73205               'the tangent of 60 degree„cotbeta = .5773506              'the cotangent of 60 degree„result = 0                      'the result for the trigonometrical„				'functions„a = 3                           'the values for the expression:„b = 4                           'c=a^b„c = 0„x = 5                           'value for e^x, log x, log10 x„„'===========================================================================„'Demonstration starts here                                                 =„'===========================================================================„„CLS                             'clear the screen„„RESTORE sine                    'read code for sine procedure„CALL Reading(FMSinseg%, FMSinoff%)„„RESTORE cosine                  'read the code for cosine procedure„CALL Reading(FMCosseg%, FMCosoff%)„„RESTORE tangent                 'read the code for tangent procedure„CALL Reading(FMTanseg%, FMTanoff%)„„RESTORE cotangent               'read the code for cotangent procedure„CALL Reading(FMCotseg%, FMCotoff%)„„RESTORE arctangent              'read the code for arctangent procedure„CALL Reading(FMAtnseg%, FMAtnoff%)„„RESTORE arccotangent            'read the code for arccotangent procedure„CALL Reading(FMActseg%, FMActoff%)„„RESTORE arcsine                 'read the code for arcsine procedure„CALL Reading(FMAsnseg%, FMAsnoff%)„„RESTORE arccosine               'read the code for arccosine procedure„CALL Reading(FMAcsseg%, FMAcsoff%)„„RESTORE power                   'read the code for the power routine„CALL Reading(FMPowseg%, FMPowoff%)„„RESTORE expo                    'read the code for the expo routine„CALL Reading(FMExpseg%, FMExpoff%)„„RESTORE naturalis               'read the code for the naturalis routine„CALL Reading(FMLnseg%, FMLnoff%)„„RESTORE brigg                   'read the code for the brigg procedure„CALL Reading(FMLgseg%, FMLgoff%)„„angalpharad = CalcRad(angalphadeg)„				'convert the angle into radian„DEF SEG = FMSinseg%             'calculate the sine„  CALL ABSOLUTE(angalpharad, result, FMSinoff%)„DEF SEG„PRINT "The sine from 30 Degree is           :"; result„				'print the sine„„DEF SEG = FMCosseg%             'calculate the cosine„  CALL ABSOLUTE(angalpharad, result, FMCosoff%)„DEF SEG„PRINT "The cosine from 30 Degree is         :"; result„				'print the cosine„„DEF SEG = FMTanseg%             'calculate the tangent„  CALL ABSOLUTE(angalpharad, result, FMTanoff%)„DEF SEG„PRINT "The tangent from 30 Degree is        :"; result„„DEF SEG = FMCotseg%             'calculate the cotangent„  CALL ABSOLUTE(angalpharad, result, FMCotoff%)„DEF SEG„PRINT "The cotangent from 30 Degree is      :"; result„„DEF SEG = FMAtnseg%             'calculate the inverse tangent„  CALL ABSOLUTE(tanbeta, result, FMAtnoff%)„DEF SEG„angbetadeg = CalcDeg(result)„PRINT "The angle from the tangent value is  :"; angbetadeg; "Degree"„„DEF SEG = FMActseg%             'calculate the inverse cotangent„  CALL ABSOLUTE(cotbeta, result, FMActoff%)„DEF SEG„angbetadeg = CalcDeg(result)„PRINT "The angle from the cotangent value is:"; angbetadeg; "Degree"„„DEF SEG = FMAsnseg%             'calculate the inverse sine„  CALL ABSOLUTE(sinbeta, result, FMAsnoff%)„DEF SEG„angbetadeg = CalcDeg(result)„PRINT "The angle from the sine value is     :"; angbetadeg; "Degree"„„DEF SEG = FMAcsseg%             'calculate the inverse cosine„  CALL ABSOLUTE(cosbeta, result, FMAcsoff%)„DEF SEG„angbetadeg = CalcDeg(result)„PRINT "The angle from the cosine value is   :"; angbetadeg; "Degree"„„DEF SEG = FMPowseg%             'calculate c=a^b„  CALL ABSOLUTE(a, b, c, FMPowoff%)„DEF SEG„PRINT "The result of 3^4 is                 :"; c„„DEF SEG = FMExpseg%             'calculate e^x„  CALL ABSOLUTE(x, result, FMExpoff%)„DEF SEG„PRINT "The result of e^5 is                 :"; result„„DEF SEG = FMLnseg%              'calculate ln x„  CALL ABSOLUTE(x, result, FMLnoff%)„DEF SEG„PRINT "The result of ln 5 is                :"; result„„DEF SEG = FMLgseg%              'calculate ln x„  CALL ABSOLUTE(x, result, FMLgoff%)„DEF SEG„PRINT "The result of lg 5 is                :"; result„PRINT„PRINT„PRINT "It follows a speed demonstration of c=a^b with"„PRINT "10 000 loop cycles. First with QBASIC."„PRINT„PRINT "Please press any key to continue ..."„CALL Waiting                    'wait for a key„CLS                             'clear the screen„„PRINT "I'm calculating..."„t = TIMER„FOR i% = 1 TO 10000„  CALL Basex(a, b, c)„NEXT i%„t = ABS(t - TIMER)„PRINT„PRINT "Result of 3^4 ="; c„PRINT "Elapsed Time  ="; t; "Seconds"„PRINT„PRINT "Now with the assembly language procedure:"„PRINT„PRINT "Please press any key to continue ..."„CALL Waiting                    'wait for a key„CLS                             'clear the screen„„PRINT "I'm calculating..."„t = TIMER„FOR i% = 1 TO 10000„  DEF SEG = FMPowseg%           'calculate c=a^b„    CALL ABSOLUTE(a, b, c, FMPowoff%)„  DEF SEG„NEXT i%„t = ABS(t - TIMER)„PRINT„PRINT "Result of 3^4 ="; c„PRINT "Elapsed Time  ="; t; "Seconds"„PRINT„PRINT "Please press any key to end the demonstration."„CALL Waiting                    'wait for a key„CLS                             'clear the screen„„END„sine:„'***************************************************************************„'PROCEDURE sine                                                            *„'Task:          Calculates the sine.                                       *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address angle                                     *„'Output:        sine                                                       *„'Uses:          no subroutines                                             *„'Note:          The domain for the angle is with 80387 instructions:       *„'               -2^63 < angle < 2^63                                       *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di              ;don't want to be like MicroSoft„DATA 56:        'push   si              ;save registers„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=angle„DATA d9,fe:     'fsin                   ;st(0):=SIN(angle)„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„cosine:„'***************************************************************************„'PROCEDURE cosine                                                          *„'Task:          Calculates the cosine.                                     *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address angle                                     *„'Output:        sine                                                       *„'Uses:          no subroutines                                             *„'Note:          The domain for the angle is with 80387 instructions:       *„'               -2^63 < angle < 2^63                                       *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=angle„DATA d9,ff:     'fcos                   ;st(0):=COS(angle)„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„tangent:„'***************************************************************************„'PROCEDURE tangent                                                         *„'Task:          Calculates the tangent.                                    *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address angle                                     *„'Output:        tangent                                                    *„'Uses:          no subroutines                                             *„'Note:          The domain for the angle is with 80387 instructions:       *„'               -2^63 < angle < 2^63                                       *„'               For the calculation of the tangent function we use the     *„'               FPU instruction FPTAN (partial tangent). This instruction  *„'               moves automatic the constant 1 at the FPU stack. Therefore *„'               we must remove this value after the calculation is done.   *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=angle„DATA d9,f2:     'fptan                  ;st(0):=1„		'                       ;st(1):=TAN(angle)„DATA dd,d8:     'fstp   st(0)           ;remove the 1„		'                       ;st(0):=TAN(angle)„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„cotangent:„'***************************************************************************„'PROCEDURE cotangent                                                       *„'Task:          Calculates the cotangent.                                  *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address angle                                     *„'Output:        cotangent                                                  *„'Uses:          no subroutines                                             *„'Note:          The domain for the angle with 80387 instructions is:       *„'               -2^63 < angle < 2^63                                       *„'               It is:                                                     *„'                                  1                                       *„'                      cot(x) = --------                                   *„'                                tan(x)                                    *„'                                                                          *„'               Therefore, we can use the '1' from FPTAN to calculate the  *„'               cotangent.                                                 *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=angle„DATA d9,f2:     'fptan                  ;st(0):=1„		'                       ;st(1):=TAN(angle)„DATA de,f1:     'fdivrp                 ;st(0):=st(0)/st(1)„		'                       ;and the FPU stack is cleared„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„arctangent:„'***************************************************************************„'PROCEDURE arctangent                                                      *„'Task:          Calculates the inverse tangent.                            *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address tangent value                             *„'Output:        angle in radian                                            *„'Uses:          no subroutines                                             *„'Note:          The domain for the angle (main value) is:                  *„'               -PI/2 < arctan y < PI/2                                    *„'               The FPU instruction FPATAN(st(1),st) is defined as:        *„'                                                                          *„'                                  ⁄ arctan x for st(1)=x and st(0)=1      *„'               FPATAN(st(1),st) =ƒ¥                                       *„'                                  ¿ arccot x for st(1)=1 and st(0)=x      *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=tangent value„DATA d9,e8:     'fld1                   ;load '1'„		'                       ;st(0):=1„		'                       ;st(1):=tangent value„DATA d9,f3:     'fpatan                 ;st(0):=angle„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„arccotangent:„'***************************************************************************„'PROCEDURE arccotangent                                                    *„'Task:          Calculates the inverse cotangent.                          *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address cotangent value                           *„'Output:        angle in radian                                            *„'Uses:          no subroutines                                             *„'Note:          see FMAtn                                                  *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,e8:     'fld1                   ;load '1'„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=cotangent value„		'                       ;st(1):=1„DATA d9,f3:     'fpatan                 ;st(0):=angle„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„arcsine:„'***************************************************************************„'PROCEDURE arcsine                                                         *„'Task:          Calculates the inverse sine.                               *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address sine value                                *„'Output:        angle in radian                                            *„'Uses:          no subroutines                                             *„'Note:          It is:                                                     *„'                                                                          *„'                                               x                          *„'                     arcsin x = arctan    ------------                    *„'                                           ⁄ƒƒƒƒƒƒƒƒƒƒ                    *„'                                        \  ≥      2                       *„'                                          \≥ 1 - x                        *„'                                                                          *„'               It follows:                                                *„'                                                                          *„'                     arcsin x = FPATAN(x,SQR(1-x^2))                      *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=sine value=x„DATA d9,c0:     'fld    st              ;st(0):=x„		'                       ;st(1):=x„DATA d8,c8:     'fmul   st,st           ;st(0):=x^2„		'                       ;st(1):=x„DATA d9,e8:     'fld1                   ;st(0):=1„		'                       ;st(1):=x^2„		'                       ;st(2):=x„DATA de,e1:     'fsubrp                 ;st(0):=1-x^2„		'                       ;st(0):=x„DATA d9,fa:     'fsqrt                  ;st(0):=SQR(1-x^2)„		'                       ;st(1):=x„DATA d9,f3:     'fpatan                 ;st(0):=arcsin x=angle„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„arccosine:„'***************************************************************************„'PROCEDURE arccosine                                                       *„'Task:          Calculates the inverse cosine.                             *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address cosine value                              *„'Output:        angle in radian                                            *„'Uses:          no subroutines                                             *„'Note:          It is:                                                     *„'                                                                          *„'                                          x                               *„'                    arccos x = arccot ----------                          *„'                                       ⁄ƒƒƒƒƒƒƒ                           *„'                                    \  ≥     2                            *„'                                      \≥1 - x                             *„'                                                                          *„'               It follows:                                                *„'                                                                          *„'                    arccos x = FPATAN(SQR(1-x^2),x)                       *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;ds:si -> angle„DATA 8b,7e,06:  'mov    di,[bp+6]       ;ds:di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=sine value=x„DATA d9,c0:     'fld    st              ;st(0):=x„		'                       ;st(1):=x„DATA d8,c8:     'fmul   st,st           ;st(0):=x^2„		'                       ;st(1):=x„DATA d9,e8:     'fld1                   ;st(0):=1„		'                       ;st(1):=x^2„		'                       ;st(2):=x„DATA de,e1:     'fsubrp                 ;st(0):=1-x^2„		'                       ;st(0):=x„DATA d9,fa:     'fsqrt                  ;st(0):=SQR(1-x^2)„		'                       ;st(1):=x„DATA d9,c9:     'fxch                   ;exchange st(0) and st(1)„DATA d9,f3:     'fpatan                 ;st(0):=arcsin x=angle„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d         'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„power:„'***************************************************************************„'PROCEDURE power                             b                             *„'Task:          Calculates the expression c=a                              *„'Input:         [bp+6]  = address c                                        *„'               [bp+8]  = address b                                        *„'               [bp+10] = address a                                        *„'Output:        c=a^b                                                      *„'Note:          It is:                                                     *„'                     b    b*ld x                                          *„'                    a  = 2                                                *„'                                                                          *„'               The expression b*ld x we can compute with the instruction  *„'               FYL2X.                            x                        *„'               The instruction F2XM1 calculates 2  - 1                    *„'                                         y                                *„'               With FSCALE we compute x*2                                 *„'               Unfortunately, FSCALE accepts only integer exponents and   *„'               F2XM needs the argument in -0.5 < x < 0.5. Therefore we    *„'               round with FRNDINT.                                        *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 53:        'push   bx„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,5e,0a:  'mov    bx,[bp+10]      ;bx -> a„DATA 8b,76,08:  'mov    si,[bp+8]       ;si -> b„DATA 8b,7e,06:  'mov    di,[bp+6]       ;di -> c„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=b„DATA d9,07:     'fld    dword ptr [bx]  ;st(0):=a„		'                       ;st(1):=b„DATA d9,f1:     'fyl2x                  ;st(0):=b*log2 a=z„DATA d9,c0:     'fld    st              ;copy the result„		'                       ;st(0):=z„		'                       ;st(1):=z„DATA d9,fc:     'frndint                ;round st(0) to integer„DATA dc,e9:     'fsub   st(1),st(0)     ;st(1):=z-round(z)„DATA d9,c9:     'fxch                   ;st(0):=z-round(z)„		'                       ;st(1):=round(z)„DATA d9,f0:     'f2xm1                  ;st(0):=2^(z-round(z))-1„		'                       ;st(1):=round(z)„DATA d9,e8:     'fld1                   ;st(0):=1„		'                       ;st(1):=2^(z-round(z))-1„		'                       ;st(2):=round(z)„DATA de,c1:     'faddp                  ;st(0):=2^(z-round(z))„		'                       ;st(1):=round(z)„DATA d9,fd:     'fscale                 ;st(0):=2^(z-round(z))*2^round(z)„		'                       ;=2^z=result„DATA dd,d9:     'fstp   st(1)           ;clear FPU stack„DATA d9,1d:     'fstp   dword ptr [di]  ;c:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 5b:        'pop    bx„DATA 8b,e5:     'mov    sp,bp„DATA 5d:        'pop    bp„DATA ca,06,00:  'ret    6„DATA *:         'end character„„expo:„'***************************************************************************„'PROCEDURE expo                                                            *„'Task:          Calculates e^x.                                            *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address x                                         *„'Output:        e^x                                                        *„'Uses:          no subroutines                                             *„'Note:          See also FMPow. The only difference is that we moreover    *„'               need the constant log2 e.                                  *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;si -> x„DATA 8b,7e,06:  'mov    di,[bp+6]       ;di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=x„DATA d9,ea:     'fldl2e                 ;st(0):=log2 e=ld e„		'                       ;st(1):=x„DATA de,c9:     'fmulp                  ;st(0):=x*ld e=z„DATA d9,c0:     'fld    st              ;copy the result„		'                       ;st(0):=z„		'                       ;st(1):=z„DATA d9,fc:     'frndint                ;round st(0) to integer„DATA dc,e9:     'fsub   st(1),st(0)     ;st(1):=z-round(z)„DATA d9,c9:     'fxch                   ;st(0):=z-round(z)„		'                       ;st(1):=round(z)„DATA d9,f0:     'f2xm1                  ;st(0):=2^(z-round(z))-1„		'                       ;st(1):=round(z)„DATA d9,e8:     'fld1                   ;st(0):=1„		'                       ;st(1):=2^(z-round(z))-1„		'                       ;st(2):=round(z)„DATA de,c1:     'faddp                  ;st(0):=2^(z-round(z))„		'                       ;st(1):=round(z)„DATA d9,fd:     'fscale                 ;st(0):=2^(z-round(z))*2^round(z)„		'                       ;=2^z=result„DATA dd,d9:     'fstp   st(1)           ;clear FPU stack„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d:        'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„naturalis:„'***************************************************************************„'PROCEDURE naturalis                                                       *„'Task:          Calculates log x (ln x, logarithmus naturalis).            *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address x                                         *„'Output:        logx (ln x)                                                *„'Uses:          no subroutines                                             *„'Note:          It is:                                                     *„'                      log x = log 2*log2 x                                *„'                         a       a                                        *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;si -> x„DATA 8b,7e,06:  'mov    di,[bp+6]       ;di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,ed:     'fldln2                 ;st(0):=ln 2„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=x„		'                       ;st(1):=ln 2„DATA d9,f1:     'fyl2x                  ;st(0):=ln 2*ld x=result„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d:        'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„brigg:„'***************************************************************************„'PROCEDURE brigg                                                           *„'Task:          Calculates log10 x (lg x, Brigg's logarithms).             *„'Input:         [bp+6] = address result                                    *„'               [bp+8] = address x                                         *„'Output:        logx (ln x)                                                *„'Uses:          no subroutines                                             *„'Note:          It is:                                                     *„'                      log x = log 2*log2 x                                *„'                         a       a                                        *„'***************************************************************************„DATA 55:        'push   bp„DATA 8b,ec:     'mov    bp,sp„DATA 57:        'push   di„DATA 56:        'push   si„DATA 8b,76,08:  'mov    si,[bp+8]       ;si -> x„DATA 8b,7e,06:  'mov    di,[bp+6]       ;di -> result„DATA db,e3:     'fninit                 ;initialize FPU„DATA d9,ec:     'fldlg2                 ;st(0):=lg 2„DATA d9,04:     'fld    dword ptr [si]  ;st(0):=x„		'                       ;st(1):=lg 2„DATA d9,f1:     'fyl2x                  ;st(0):=lg 2*ld x=result„DATA d9,1d:     'fstp   dword ptr [di]  ;result:=st(0)„DATA 9b:        'fwait„DATA 5e:        'pop    si„DATA 5f:        'pop    di„DATA 8b,e5:     'mov    sp,bp„DATA 5d:        'pop    bp„DATA ca,04,00:  'ret    4„DATA *:         'end character„„SUB Basex (p1!, p2!, p3!)„  p3! = p1! ^ p2!„END SUB„„'***************************************************************************„'FUNCTION CalcDeg                                                          *„'Task:          Converts radian in degree.                                 *„'Input:         p = angle in radian                                        *„'Output:        angle in degree                                            *„'Uses:          no subroutines                                             *„'Note:          It is (see also CalcRad):                                  *„'                                                                          *„'                                 x      *180                              *„'                                  radian                                  *„'                       x       = ------------                             *„'                        degree       Pi                                   *„'***************************************************************************„FUNCTION CalcDeg! (p!)„  pi = 3.141592         'pi as extended variable„  factor = 180„  CalcDeg = p * factor / pi„END FUNCTION„„'***************************************************************************„'FUNCTION CalcRad                                                          *„'Task:          Converts degree in radian.                                 *„'Input:         p# = angle in degree                                       *„'Output:        angle in radian                                            *„'Uses:          no subroutines                                             *„'Note:          It is:                                                     *„'                       x            360                                   *„'                        degree                                            *„'                       --------- =  -----                                 *„'                       x            2*Pi                                  *„'                        radian                                            *„'                                                                          *„'                                    x      *Pi                            *„'               It follows:           degree                               *„'                        x        = ------------                           *„'                         radian      180                                  *„'***************************************************************************„FUNCTION CalcRad! (p!)„  pi = 3.141592              'pi„  divisor = 180„  CalcRad = p * pi / divisor„END FUNCTION„„'***************************************************************************„'SUB Reading                                                               *„'Task:          Reads machine code in an array.                            *„'Input:         x% = segment address first array element                   *„'               y% = offset address first array element                    *„'Output:        machine code in the array                                  *„'Uses:          no subroutines                                             *„'***************************************************************************„SUB Reading (x%, y%)„  DEF SEG = x%                  'set the segment„  FOR i% = 0 TO 199             'reading loop„    READ byte$                  'read 1 byte„    IF byte$ = "*" THEN EXIT FOR„				'end character„    POKE (y% + i%), VAL("&H" + byte$)„				'write 1 byte„  NEXT i%„  DEF SEG                       'reset the segment„END SUB„„'***************************************************************************„'SUB Waiting                                                               *„'Task:          Waits until the user has pressed a key.                    *„'Input:         Nothing                                                    *„'Output:        Waiting                                                    *„'Uses:          No Subroutines                                             *„'***************************************************************************„SUB Waiting„  WHILE LEN(INKEY$) = 0„  WEND„END SUB„Brian Mahocker                 THEORY OF PROBABILITY          Kain121182@aol.com             01-25-97 (13:54)       QB, QBasic, PDS        32   1345     PROBILTY.BAS'This is an experiment intended to document the theory of probobility.„'Use how u want. But if you do use this stuff in your other programs,„'please at least give me credit!!„„CLS : INPUT "What do you want the delay to be? : "; delay: COLOR 7„CLS : RANDOMIZE TIMER„DO„LOCATE 1, 1: PRINT "Number 1 :"; : COLOR 15: PRINT num1: COLOR 7„LOCATE 2, 1: PRINT "Number 2 :"; : COLOR 15: PRINT num2: COLOR 7„LOCATE 4, 1: PRINT "Times Equal :"; : COLOR 15: PRINT equal: COLOR 7„LOCATE 6, 1: PRINT "Numbers are currently"; : COLOR 15: PRINT apart; : COLOR 7: PRINT "apart with"; : COLOR 15: PRINT higher; : COLOR 7: PRINT "being the higher number"„LOCATE 8, 1: PRINT "Highest amount ever being apart is"; : COLOR 15: PRINT highapart„LOCATE 10, 1: COLOR 7: PRINT "Press "; : COLOR 15: PRINT "Pause/Break"; : COLOR 7: PRINT " at any time to pause count"„LET pick = INT(RND * 2) + 1„IF pick = 1 THEN LET num1 = num1 + 1„IF pick = 2 THEN LET num2 = num2 + 1„IF pick = 3 THEN LET num1 = num1 + 1„LET time = 0: DO: LET time = time + 1: LOOP UNTIL time = delay„IF num1 = num2 THEN„   LET equal = equal + 1„   LET higher = 0„END IF„IF num1 > num2 THEN„   LET apart = (num1 - num2)„   LET higher = 1„END IF„IF num2 > num1 THEN„   LET apart = (num2 - num1)„   LET higher = 2„END IF„IF apart > highapart THEN LET highapart = apart„LOOP„The ABC Programmer             RPN POSTFIX NOTATION EVAULATOR voxel@freenet.edmonton.ab.ca   01-28-97 (14:30)       QB, QBasic, PDS        225  6711     RPNEVAL.BAS '=========================================================================„' Reverse Polish Notation (RPN) Evaluator Programmed by William Yu (01/97)„'„'            Infix Notation : 4 + (3 - 2) * 9 ^ 2„'   Equivalent Postfix (RPN): 4 3 2 - 9 2 ^ * +„'„' Please check ALGOR.ABC for the useful INFIX TO POSTFIX (RPN) CONVERTER.„' Both demonstrate the fundamentals and uses of stacks.„'=========================================================================„„DECLARE FUNCTION EmptyStack% (Stack AS INTEGER)„DECLARE SUB POP (Stack AS INTEGER, Element AS DOUBLE)„DECLARE SUB GetNextToken (RPNExp AS STRING, Position AS INTEGER, Token AS ANY, TokenItem AS STRING)„DECLARE SUB PUSH (Stack AS INTEGER, Element AS DOUBLE)„DECLARE FUNCTION Evaluate# (RPNExp AS STRING)„DEFINT A-Z„„CONST FALSE = 0„CONST TRUE = NOT FALSE„„' Token item„CONST Operand = 1         ' TIP: Use descriptive identifiers };-)„CONST Operator = 2        ' So you don't have to waste time documenting.„CONST Bad = 3„CONST Finished = 4„„'Error codes„CONST None = 0„CONST FewOperands = 1„CONST FewOperator = 2„CONST Invalid = 3„CONST NoResult = 4„„CONST Max = 100      ' # of items (operands only) to fill stack until full„„DIM RPNExp AS STRING„DIM SHARED Element(1 TO Max) AS DOUBLE„DIM SHARED ErrorCode„„' One heck of an expression :)„' Needs„'WIDTH 80, 43„' to view all the steps„' End the expression with ; (semi-colon)„„RPNExp = "+4.546 2.6734^ 5656 -438.390 /* 6234  -234 99*564- 23 432 457 234 *+/*-+;"„„' Other examples to uncomment.  Create one!„'RPNExp = "4 6 +;"„'RPNExp = "-34.3 345 / 345 -345* 45 +-;"„'RPNExp = "45.345 -.345*;"„'RPNExp = "34 8 ^ 85 10 + *;"„„CLS„PRINT "Expression is: "; RPNExp„„Number# = Evaluate(RPNExp)„IF ErrorCode = None THEN„  PRINT "Expression Value is:"; Number#„ELSE„  PRINT : PRINT "*** BAD EXPRESSION : ";„  SELECT CASE ErrorCode„    CASE FewOperands„      PRINT "Too few operands. ***"„    CASE FewOperator„      PRINT "Too few operators. ***"„    CASE Invalid„      PRINT "Invalid input (bad character) ***"„    CASE NoResult„      PRINT "Nothing to evaluate! ***"„  END SELECT„END IF„„FUNCTION EmptyStack (Stack AS INTEGER)„'----------------------------------------------„'  Simply checks if stack is empty„'----------------------------------------------„„  EmptyStack = FALSE„  IF Stack = 0 THEN EmptyStack = TRUE„„END FUNCTION„„FUNCTION Evaluate# (RPNExp AS STRING)„'----------------------------------------------„'  Evaluate the RPN Expression„'----------------------------------------------„„DIM TokenItem AS STRING„DIM Number AS DOUBLE, Number2 AS DOUBLE„„   Position = 1      ' Parse string from position 1„   Stack = 0         ' Initialize Stack, ie. make it empty„   ErrorCode = None„„   DO„     GetNextToken RPNExp, Position, Token, TokenItem„     PRINT "TOKEN = "; TokenItem;„     SELECT CASE Token„       CASE Operand„         Number = VAL(TokenItem)„         PRINT "  PUSH = "; Number„         PUSH Stack, Number„       CASE Operator„         POP Stack, Number„         IF EmptyStack(Stack) THEN ErrorCode = FewOperands: EXIT DO„         POP Stack, Number2„         PRINT "  POP ="; Number; " POP ="; Number2„         SELECT CASE TokenItem„           CASE "+"„             Number = Number + Number2„           CASE "-"„             Number = Number2 - Number„           CASE "*"„             Number = Number * Number2„           CASE "/"„             Number = Number2 / Number„           CASE "^"„             Number = Number2 ^ Number„         END SELECT„         PUSH Stack, Number„         PRINT " PUSH ="; Number„       CASE Finished„         IF EmptyStack(Stack) THEN„           ErrorCode = NoResult„         ELSE„           POP Stack, Number„           PRINT " POP ="; Number„         END IF„       CASE Bad„         ErrorCode = Invalid„         EXIT DO„     END SELECT„   LOOP UNTIL Token = Finished„   IF NOT EmptyStack(Stack) THEN ErrorCode = FewOperator„„   Evaluate# = Number„„END FUNCTION„„SUB GetNextToken (RPNExp AS STRING, Position AS INTEGER, Token AS INTEGER, TokenItem AS STRING)„'------------------------------------------------------------------------„'  Parse Expression until a token (Operand/Operator/EndOfExpr) is found.„'------------------------------------------------------------------------„„  Start = Position„  Done = FALSE„  Token = Finished„  Numbers$ = "0123456789."„  Signs$ = " +-*/^"„„  DO„    Char$ = MID$(RPNExp, Position, 1)„    SELECT CASE Char$„      CASE "0" TO "9", "."„        Token = Operand„        Check$ = MID$(RPNExp, Position + 1, 1)„        Check = FALSE„        FOR I = 1 TO LEN(Signs$)„          IF Check$ = MID$(Signs$, I, 1) THEN Check = TRUE„        NEXT I„        IF Check THEN Done = TRUE„      CASE " "„        Start = Start + 1„      CASE "+", "-"„        Check$ = MID$(RPNExp, Position + 1, 1)„        Check = FALSE„        FOR I = 1 TO LEN(Numbers$)„          IF Check$ = MID$(Numbers$, I, 1) THEN Check = TRUE„        NEXT I„        IF Check THEN                   ' Check for strings like 123+123„          IF Token = Operand THEN       ' which is not valid.„            Token = Bad                 ' (Where + can be any operator)„            Done = TRUE„          ELSE                          ' Although you can have -123„            Token = Operand             ' so we continue to parse...„          END IF„        ELSE                            ' Else it's 123+ or just +„          Token = Operator              ' So we perform the operation.„          Done = TRUE                   ' (Again, + can be any operator)„        END IF„      CASE "*", "/", "^"„        Token = Operator„        Done = TRUE„      CASE ";"„        Done = TRUE„        Token = Finished„      CASE ELSE„        Token = Bad„        Done = TRUE„    END SELECT„    Position = Position + 1„  LOOP UNTIL Done OR Position > LEN(RPNExp)„ „  TokenItem = MID$(RPNExp, Start, Position - Start)„„END SUB„„SUB POP (Stack AS INTEGER, Element AS DOUBLE)„'----------------------------------------------„'  Return the top element on the stack.„'----------------------------------------------„„IF Stack = 0 THEN„  PRINT " *** Attempt to pop from an empty stack ***"„ELSE„  Element = Element(Stack)„  Stack = Stack - 1„END IF„„END SUB„„SUB PUSH (Stack AS INTEGER, Element AS DOUBLE)„'----------------------------------------------„'  Fill stack with Element„'----------------------------------------------„„Stack = Stack + 1„IF Stack > Max THEN„  PRINT " *** Attempt to push on a full stack ***"„ELSE„  Element(Stack) = Element„END IF„„END SUB„The ABC Programmer             CONVERT INFIX TO POSTFIX (RPN) voxel@freenet.edmonton.ab.ca   02-15-97 (10:00)       QB, QBasic, PDS        216  7017     CONV2RPN.BAS'***************************************************************************„' INFIX TO POSTFIX EXPRESSION CONVERTER programmed by William Yu (02/97)„'„'       Converts Infix:  ((A + 5) / B - 2) * C„'     To Postfix (RPN):  A 5 + B / 2 - C *„'„' Also available in ALGOR.ABC is the RPN (Postfix) evaluator.„' For the stack in this case, only the operators "()+-*/^" are stored„' instead of the operands for the RPN Evaluator.„'„' This program was converted to BASIC by William Yu using a Pascal template„' Referenced from:„'            Larry Nyhoff & Sanford Leestma„'            Data Structures and Program Design in Pascal (2nd Edition)„'            Pages 204-209.„'„' With some ingenuity, you could simply make this to an Infix evaluator.„'***************************************************************************„DEFINT A-Z„DECLARE SUB ProcessOperator (Operator AS STRING, Stack%)„DECLARE FUNCTION Priority% (Operator AS STRING)„DECLARE SUB Pop (Stack AS INTEGER, Element AS STRING)„DECLARE SUB ProcessRightParen (Stack%, ErrorCode%)„DECLARE SUB ConvertToRPN (Expression AS STRING)„DECLARE SUB Push (Stack AS INTEGER, Element AS STRING)„„CONST FALSE = 0„CONST TRUE = NOT FALSE„CONST Max = 25            ' Maximum number of operators to be stored„                          ' in the stack at one time.  eg. if you have„                          ' a lot of ((((((((( brackets in your expression„                          ' the stack size should be adjusted.„„DIM SHARED Element(1 TO Max) AS STRING * 1„DIM Expression AS STRING„„CLS„„' NOTE:  2(4 + 5) will not parse properly (include the '*' sign)„'  USE:  2*(4 + 5) instead.„„Expression = "(A-B)*(C-(D+E)^F)"    ' Start with the Infix notation„„'Expression = "((A+B)"              '<- Here's an error in expression„'Expression = "WowWee*(How+Does^Programming)-This*Work"„'Expression = "((123 + 39^3 * (43 - 89) / 10 - ((90 - 34) * 3)))"„„PRINT "  The infix: "; Expression„PRINT "Now Postfix: ";„ConvertToRPN Expression              ' Then get the Postfix (RPN) expression„„END„„SUB ConvertToRPN (Expression AS STRING)„'********************************************************„'   Input:  Infix expression„' Purpose:  Convert Expression to RPN„'  Output:  To screen, the Postfix (RPN) Expression„'    Note:  Uses procedures Priority, ProcessRightParen„'           ProcessOperator, and stack-processing„'********************************************************„„DIM Token AS STRING * 1„„  Stack = 0               ' Initialize an empty stack„  ErrorCode = FALSE„  Signs$ = " ()+-*/^"„„  I = 1„  Token = LEFT$(Expression, 1)„„  WHILE (NOT ErrorCode) AND (I <= LEN(Expression))„    Valid = FALSE„    FOR X = 1 TO LEN(Signs$)„      IF Token = MID$(Signs$, X, 1) THEN Valid = TRUE: EXIT FOR„    NEXT X„    IF Valid THEN„      PRINT " ";„      SELECT CASE Token„        CASE " "                       '{* Skip Blanks and do nothing *}„        CASE "("                       '{* Left parenthesis           *}„          Push Stack, Token„          LOCATE , POS(CSRLIN) - 1     '{* Just to make it look nice  *}„        CASE ")"                       '{* Right parenthesis          *}„          ProcessRightParen Stack, ErrorCode„        CASE "+", "-", "*", "/", "^"   '{* Arithmetic operator        *}„          ProcessOperator Token, Stack„      END SELECT„    ELSE                               '{* Operand *}„      PRINT Token;„    END IF„    I = I + 1                          '{* Get next token and process it *}„    Token = MID$(Expression, I, 1)„  WEND„„  '{* Pop and display operators on the stack *}„  WHILE Stack <> 0 AND NOT ErrorCode„    Pop Stack, Token„    IF Token <> "(" THEN„      PRINT Token;„    ELSE„      ErrorCode = TRUE„    END IF„  WEND„„  IF ErrorCode THEN„    PRINT "<<< Error in infix expression >>>"„  END IF„„END SUB„„SUB Pop (Stack AS INTEGER, Element AS STRING)„'----------------------------------------------„'  Return the top element on the stack.„'----------------------------------------------„„IF Stack = 0 THEN„  PRINT " *** Attempt to pop from an empty stack ***"„ELSE„  Element = Element(Stack)„  Stack = Stack - 1„END IF„„END SUB  '{* Pop *}„„FUNCTION Priority% (Operator AS STRING)„'**********************************************************„'   Input:  The Character Operator„' Purpose:  Find the priority of Operator, and arithmetic„'           operator of (.„'  Output:  Returns priority (0 - 2) of Operator.„'**********************************************************„ „  SELECT CASE Operator„    CASE "("            ' Not so great„      Priority = 0„    CASE "+", "-"„      Priority = 1„    CASE "*", "/"„      Priority = 2„    CASE "^"            ' Greatest priority (Exponential)„      Priority = 3„  END SELECT„„END FUNCTION„„SUB ProcessOperator (Operator AS STRING, Stack)„'*********************************************************************„'   Input:  A Character denoting an arithmetic Operator, and a„'           stack of operators.„' Purpose:  Process an arithmetic operator.  Operators are popped„'           from the stack until the stack becomes empty or an„'           operator appears on the top of the stack whose priority„'           is less than or equal to that of the Operator.  Operator„'           is then pushed onto the stack.„'  Output:  Modified stack position.„'*********************************************************************„„DIM TopOperator AS STRING * 1„„  DonePopping = FALSE„„  DO„    IF Stack = 0 THEN„      DonePopping = TRUE„    ELSE„      Pop Stack, TopOperator„      IF Priority(Operator) <= Priority(TopOperator) THEN„        PRINT TopOperator;„      ELSE„        Push Stack, TopOperator„        DonePopping = TRUE„      END IF„    END IF„  LOOP UNTIL DonePopping„  Push Stack, Operator„„END SUB„„SUB ProcessRightParen (Stack, ErrorCode)„'******************************************************************„'   Input:  The stack position„' Purpose:  Pop and display operators from Stack until a left„'           parenthesis is on top of the stack; it too is popped,„'           but not displayed.„'  Output:  Modified stack position, and ErrorCode, which is true„'           if the stack becomes empty with no left parenthesis„'           being found.„'******************************************************************„„DIM TopToken AS STRING * 1„„  DO„     IF Stack = 0 THEN„       ErrorCode = TRUE„     ELSE„       Pop Stack, TopToken„       IF TopToken <> "(" THEN PRINT TopToken;„     END IF„  LOOP UNTIL TopToken = "(" OR ErrorCode„„END SUB„„SUB Push (Stack AS INTEGER, Element AS STRING)„'----------------------------------------------„'  Fill stack with Element„'----------------------------------------------„„Stack = Stack + 1„IF Stack > Max THEN„  PRINT " *** Attempt to push on a full stack ***"„ELSE„  Element(Stack) = Element„END IF„„END SUB '{* Push *}„Tom Nelson (Chien-Lung Su)     UNLIMITED DIGIT INTEGERS       cs85107@cc.chpi.edu.tw         10-27-96 (00:00)       QB, QBasic, PDS        156  4486     UNLIMMUL.BAS' Program name   : "Unlimited-digit integers addition & multiplication"„' Author         : Tom Nelson (Chien-Lung Su)„' Date           : 1996/10/27„' Copyright      : Feel free to use it in your programs.„'                  Or you can send a copy of your product to me ! :)„' Notice         : No error-checking on the given strings for operations !„'                  i.e. You should develop error-preventing code yourself !„' E-mail address : tomnelson.bbs@tnbbs.tnmgeb.edu.tw„'                  cs85107@cc.chpi.edu.tw„'                  cs85107@cssun1.cs.chpi.edu.tw„' Home page      : http://web.chpi.edu.tw/~cs85107/    \„'                  http://web.cs.chpi.edu.tw/~cs85107/ |-> Coming soon !„'                  http://Lung.dorm.chpi.edu.tw/       /„' P.S.           : This program has Turbo Pascal version. If you would„'                  like to take a view of it, please contact me !„„DECLARE FUNCTION UnlimitedMul$ (NumString1$, NumString2$)„' The great function of the program ! :)„DECLARE FUNCTION StrMul$ (NumString1$, NumString2$)„' A function performs a 1-digit integer to multi-digit integer multiplication.„DECLARE FUNCTION StrAdd$ (NumString1$, NumString2$)„' A function performs integer addition.„' Called by the two functions above.„„CLS„PRINT "Unlimited-digit integers addition & multiplication."„PRINT "Written By Tom Nelson 1996."„PRINT„INPUT "Enter the 1st number : ", Num1$„INPUT "Enter the 2nd number : ", Num2$„Num1$ = LTRIM$(RTRIM$(Num1$))„Num2$ = LTRIM$(RTRIM$(Num2$))„PRINT„„IF LEN(Num1$) > LEN(Num2$) THEN„   Max1% = LEN(Num1$)„ELSE„   Max1% = LEN(Num2$)„END IF„„Max2% = LEN(Num1$) + LEN(Num2$) - 1„PRINT SPACE$(Max2% - LEN(Num1$) + 3) + Num1$„PRINT "x) " + SPACE$(Max2% - LEN(Num2$)) + Num2$„PRINT STRING$(Max2% + 3, "-")„PRINT SPACE$(Max2% - LEN(UnlimitedMul$(Num1$, Num2$)) + 3) + UnlimitedMul$(Num1$, Num2$)„PRINT„PRINT SPACE$(Max1% - LEN(Num1$) + 3) + Num1$„PRINT "+) " + SPACE$(Max1% - LEN(Num2$)) + Num2$„PRINT STRING$(Max1% + 3, "-")„PRINT SPACE$(Max1% - LEN(StrAdd$(Num1$, Num2$)) + 3) + StrAdd$(Num1$, Num2$)„END„„„„FUNCTION StrAdd$ (NumString1$, NumString2$)„IF NumString1$ = "" OR NumString2$ = "" THEN EXIT FUNCTION„DIM Array1%(1024)„DIM Array2%(1024)„DIM Array3%(1024)„„Add1$ = LTRIM$(RTRIM$(NumString1$))„Add2$ = LTRIM$(RTRIM$(NumString2$))„Len1% = LEN(Add1$)„Len2% = LEN(Add2$)„„FOR Temp% = 1 TO Len1%„    Array1%(Temp%) = VAL(MID$(Add1$, Len1% + 1 - Temp%, 1))„NEXT Temp%„„FOR Temp% = 1 TO Len2%„    Array2%(Temp%) = VAL(MID$(Add2$, Len2% + 1 - Temp%, 1))„NEXT Temp%„„IF Len1% > Len2% THEN Max% = Len1% ELSE Max% = Len2%„„FOR Temp% = 1 TO Max% + 1„Sum% = Array1%(Temp%) + Array2%(Temp%) + CarryFlag%„IF Sum% >= 10 THEN„   CarryFlag% = 1„   Array3%(Temp%) = Sum% - 10„ELSE„   CarryFlag% = 0„   Array3%(Temp%) = Sum%„END IF„NEXT Temp%„„FOR Temp% = Max% + 1 TO 1 STEP -1„Result$ = Result$ + LTRIM$(STR$(Array3%(Temp%)))„NEXT Temp%„„FOR Temp% = 1 TO LEN(Result$)„IF MID$(Result$, Temp%, 1) <> "0" THEN„   Okay$ = MID$(Result$, Temp%, LEN(Result$) + 1 - Temp%)„   EXIT FOR„END IF„NEXT Temp%„„ERASE Array1%„ERASE Array2%„ERASE Array3%„StrAdd$ = Okay$„END FUNCTION„„„„FUNCTION StrMul$ (NumString1$, NumString2$)„IF NumString1$ = "" OR NumString2$ = "" THEN EXIT FUNCTION„„Len1% = LEN(LTRIM$(RTRIM$(NumString1$)))„Len2% = LEN(LTRIM$(RTRIM$(NumString2$)))„„DIM Array1$(1024)„„IF Len1% >= 1 AND Len2% = 1 THEN„   Begin% = Len1%„   Mul1$ = LTRIM$(RTRIM$(NumString1$))„   Mul2$ = LTRIM$(RTRIM$(NumString2$))„ELSEIF Len1% = 1 AND Len2% >= 1 THEN„   Begin% = Len2%„   Mul1$ = LTRIM$(RTRIM$(NumString2$))„   Mul2$ = LTRIM$(RTRIM$(NumString1$))„ELSE„   EXIT FUNCTION„END IF„„FOR Times% = Begin% TO 1 STEP -1„Temp% = VAL(MID$(Mul1$, Times%, 1)) * VAL(Mul2$)„Array1$(Begin% - Times% + 1) = LTRIM$(STR$(Temp%)) + STRING$(Begin% - Times%, "0")„NEXT Times%„„FOR Times% = 2 TO Begin%„Array1$(1) = StrAdd$(Array1$(1), Array1$(Times%))„NEXT Times%„StrMul$ = Array1$(1)„ERASE Array1$„END FUNCTION„„„„FUNCTION UnlimitedMul$ (NumString1$, NumString2$)„Length2% = LEN(LTRIM$(RTRIM$(NumString2$)))„DIM Sum$(Length2%)„„FOR I% = Length2% TO 1 STEP -1„Sum$(Length2% - I% + 1) = StrMul$(NumString1$, MID$(NumString2$, I%, 1)) + STRING$(Length2% - I%, "0")„NEXT I%„„Temp$ = Sum$(1)„FOR Times% = 2 TO Length2%„Temp$ = StrAdd$(Temp$, Sum$(Times%))„NEXT Times%„„UnlimitedMul$ = Temp$„ERASE Sum$„Temp$ = ""„END FUNCTION„Van Anderson                   BASE CONVERSION                vanisaac@cport.com             03-06-97 (20:24)       QB, QBasic, PDS        43   1405     CONVBASE.BAS' This program changes a given number into its equivalent in any base.„' It is really simple, but it is a good algorithm.  I used the convention„' created by Hex in assigning the value of a given letter (values 10-36).„' In looking at this program, you may notice that in order to solve the„' problem, I had to chang the numbers to strings in order to print them out.„' Van Anderson 2.10.1996„CLS„INPUT "Enter the number you want converted: ", num1$„num1$ = UCASE$(num1$)„INPUT "Enter the number's base: ", base1„INPUT "Enter the base you want it converted to: ", base2„„N1 = 0„N2 = LEN(num1$)„DO UNTIL N1 = N2„        digit$ = RIGHT$(num1$, 1)„        digitascii = ASC(digit$)„        IF digitascii < 58 THEN„                dig = digitascii - 48„        ELSE„                dig = digitascii - 55„        END IF„        tempnum = tempnum + dig * base1 ^ N1„        N1 = N1 + 1„        num1$ = LEFT$(num1$, N2 - N1)„LOOP„num1 = tempnum„tempnum = 0„PRINT num1$; "In base"; base1; "Equals this number in base"; base2; ":"„DO UNTIL num1 = 0„        tempdig = num1 MOD base2„        IF tempdig > 9 THEN„                tempdig = tempdig + 55„                ELSE„                tempdig = tempdig + 48„                END IF„        tempchar$ = CHR$(tempdig)„        tempnum$ = tempchar$ + tempnum$„        num1 = num1 \ base2„LOOP„PRINT tempnum$„tempnum$ = ""„END„Jason Stratos Papadopoulos     CALCULATE PI                   comp.lang.basic.misc           01-05-97 (07:59)       QB, QBasic, PDS        155  4720     PI.BAS      DECLARE SUB PrintOut (sum%(), words%)„DECLARE SUB Multiply (term%(), words%, mult&, firstword%)„DECLARE SUB Divide (term%(), words%, denom&, firstword%)„DECLARE SUB Add (sum%(), term%(), words%, sign%, firstword%)„DECLARE SUB FastDivide (term%(), words%, denom&)„„'Program to calculate pi, version 2.0„'The algorithm used is Gregory's series with Euler acceleration.„'This program uses the optimal Euler 2/3 rule: rather than use Euler's„'series for all the terms, compute instead 1/3 of the terms using„'Gregory's series and the rest using Euler's. It can be shown that„'each term in this compound series cuts the error by a factor of 3,„'while using only Euler's series has each term cut the error by a„'factor of 2. This is a major timesaver: it reduces the number of terms„'to be added up by over 35%, and of the terms that remain 1/3 can„'be crunched out faster than normal! The code also includes some tricks„'to speed things up (like reducing the size of the arrays Euler's series„'works on).„'„'Converging faster also means more digits can be computed. Some tests„'show the program is capable of computing about 51,000 digits of pi,„'and is quite fast if compiled (5000 digits in about 90 seconds on„'a 486 66MHz computer). I'd be grateful if someone can help me code„'the Divide and FastDivide SUBs in assembly, which can probably make„'the program twice as fast. Comments or questions to jasonp@wam.umd.edu„„DEFINT A-Z„CLS„INPUT "how many digits"; digits&„„words = digits& \ 4 + 4„terms& = CLNG(digits& / .477) \ 3 + 1„IF terms& MOD 2 > 0 THEN terms& = terms& + 1„DIM sum(words), term(words)„„                                          'Gregory's Series-------„PRINT TIME$: sum(1) = 1: denom& = 3: sign = -1„„FOR x& = 1 TO terms& - 1„  „   CALL FastDivide(term(), words, denom&)„   CALL Add(sum(), term(), words, sign, 2)„   denom& = denom& + 2: sign = -sign„„NEXT x&„                                          'Euler's Acceleration---„firstword = 2: x& = 1„CALL FastDivide(term(), words, 2 * denom&)„„DO UNTIL firstword = words„„   denom& = denom& + 2„   CALL Add(sum(), term(), words, sign, firstword)„   CALL Divide(term(), words, denom&, firstword)„   CALL Multiply(term(), words, x&, firstword)„  „   IF term(firstword) = 0 THEN firstword = firstword + 1„   x& = x& + 1„„LOOP„                                          'Finish up--------------„CALL Add(sum(), term(), words, sign, firstword)„CALL Multiply(sum(), words, 4, 1)„CALL PrintOut(sum(), words)„END„„'--------------------------------------------------------------------„SUB Add (sum(), term(), words, sign, firstword)„„IF sign = 1 THEN„  „   'add it on„   FOR x = words TO firstword STEP -1„      sum(x) = sum(x) + term(x)„      IF sum(x) >= 10000 THEN„         sum(x - 1) = sum(x - 1) + 1„         sum(x) = sum(x) - 10000„      END IF„   NEXT x„„ELSE„„    'subtract it off„    FOR x = words TO firstword STEP -1„       sum(x) = sum(x) - term(x)„       IF sum(x) < 0 THEN„          sum(x - 1) = sum(x - 1) - 1„          sum(x) = sum(x) + 10000„       END IF„    NEXT x„„END IF„END SUB„„'-------------------------------------------------------------------„SUB Divide (term(), words, denom&, firstword)„„FOR x = firstword TO words„   dividend& = remainder& * 10000 + term(x)„   quotient = dividend& \ denom&„   term(x) = quotient„   remainder& = dividend& - quotient * denom&„NEXT x„„END SUB„„'------------------------------------------------------------------------„SUB FastDivide (term(), words, denom&)„'not really a fast divide, but there are fewer operations„'since dividend& below doesn't have term(x) added on (always 0)„„remainder& = 1„FOR x = 2 TO words„   dividend& = remainder& * 10000„   quotient = dividend& \ denom&„   term(x) = quotient„   remainder& = dividend& - quotient * denom&„NEXT x„„END SUB„„'---------------------------------------------------------------------„SUB Multiply (term(), words, mult&, firstword)„„FOR x = words TO firstword STEP -1„   product& = mult& * term(x) + carry&„   term(x) = product& MOD 10000„   carry& = (product& - term(x)) \ 10000„NEXT x„„END SUB„„'------------------------------------------------------------------„SUB PrintOut (sum(), words)„„PRINT : PRINT "pi=3."„i = 2„DO UNTIL i = words - 1„   j = sum(i)„   IF j > 999 THEN„       PRINT " " + RIGHT$(STR$(j), 4);„   ELSEIF j > 99 THEN„       PRINT " 0" + RIGHT$(STR$(j), 3);„   ELSEIF j > 9 THEN„       PRINT " 00" + RIGHT$(STR$(j), 2);„   ELSE„       PRINT " 000" + RIGHT$(STR$(j), 1);„   END IF„  „   IF (i - 1) MOD 15 = 0 THEN PRINT„   i = i + 1„LOOP„PRINT : PRINT : PRINT TIME$„„END SUB„Don Schullian                  HUFFMAN (DE)COMPRESSION FOR PB d83@ath.forthnet.gr            06-11-97 (15:59)       PB                     148  9802     HUF4PB32.BAS'Run/Load under PowerBASIC to extract HUF4PB32.ZIP„DEFINT A-Z:SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"HUF4PB32.ZIP",4^6:Z&=7049:?STRING$(50,177);„U"%up()%9%'%#-%M$BCG]h2'x[(%%%n+%%%0%%%%mz%kkrf#sSy'^y,yT,=U[5JL<„U"oNAg%N1^(Zje7jTbxPb?<,FY*6v-H:mAW&g^4#fwPwb.XXM8I#mnF7>^BmSh7-4„U"(6=#kqHrF2C3jM=3m#YC1m(,X>2grmdKBR'?eNs9>+BYK=i^#temgfZLv(CNS<>„U"8<]b-r7L7a=%x6hh;YmCMZmqwX(saOkc0ILT>^m4]SbiX;\odL06IF=hp\>WUG=„U"bTJ#%9=<'-a0C#V7Lp]6b&X\U7Pik#ckf9BiH[5;T5z#GYqpOTae:h$$;p^&SuN„U"^.xGdii(0/Y^hwuj&Xh3\xu4RNeA;jPL[-7JXxq2>YqkeVzOTZIf[V&hTgYV,^^„U">]n<MlBnUb>Yte/R6Ww]Y&&]#QyKSjAxXbNej[4B;2BIbr(cE//aAr6]iaN=gck„U"8TK30tE5hNlwmD#6]Nb:<ChQR])a(H0t*^-]RvSHDS(?HY,vTJ<H%:mP6w?AtAN„U"*\Ni&Sf's(hE>'SQhCu/IE)o4F:/iS+C:L1v]aKrtawN$GKR3E,GjfdkUq)aybA„U",f'$0CDaiEq6=5*>#_M/Fkk8pQbIg5PKL:V5rTk(iSChV^F]:F8)bhzO6x<O9H,„U"Br>RIF\:idp>bVTQ9'<yNbP0jD,r=TEF9kaA=F[9=9VUwB0EJI8mXg4j_Iw'-r-„U"r2L-N\=.%Jl#e7dzC&2qjh/F67k8]7E_R5Y?hQuM^<YR-d7^:xNa_wl:=G09T\]„U"-/(uRaSI63%p^4kn:LNY5DRhEXqoOdx?E>7>HFAdo:/<1fVADud2.^s*V8kBMpO„U";QHWdZGu,TyJ'>n^LaQ%1XuaZ&[:e($2Auhbg$&<]oI[/%nr](,LaT9.;qRA6De„U"ujPDdg]v^8+>]]a*s[b^Cri<&<meucMEQ<iQ'Q\1zH+ME6Ak9og2%<uigp4b/cj„U"DK-6h/Kq_JnL1JT8-4='QC7mW(I+O44Ue;v6frNO9P%9TC./qS72algmXgWKcT)„U"ED+2R&#_f'bkN9g]DK<\Qk19dHu=lO5C;QmKlF.>smV=E4i^-nIjS-P7K;lArg7„U"60mHIYfP(_>,bqV<B2WV2OEIVR+'c&yB*?8=K5$.fus)_p*=W$Z((8cvw,c7lsU„U"HrA+2VkT(#RQaTJ/sdn\]bkNuF4t4.=K3fq[OfCEnGCPpliep<w%*up(%)9%'[%„U"-%\b'DGi>fcHz[0%%^%S%%/%%%%m#zkk.%uSzsayF?Tb=TkombewZFE.7y5d6a7„U"PvToEJy04B%Hx)n:ZE*eLfZrg/Wi9NpOfv&LQEPqat4*o[N40mP88s^:$FGuIHj„U"A+,/b,xPB'B=2B5U,fB9ipfh&MwutD?$sD)Zjc+0Mh/E'v,\>CD.m.LE_\>Jg8U„U"83Lqluv>,DON?3)1-D%Qw.(zf88U6,;jctb-V9Ils_j(-BA,QjY-nJWXVFvGV&K„U"eQC2LOnPX-:<f+Q=*lKa=-ua&AG\V5MUOd5Mt.7xsZ*kuQ^VN7UnUsPh3q&irY]„U"5g_5?d6Ng)bjND;ei84(wcD[>rM2B&nOn;n0PlkA4b#9AR5nAeUr5=-ixA9Fu-i„U"%V9>9#\-;zEd(WP(]jlntImtduod#xkK5Z$P6C<zX8o\F-xW&oi\3IxQWvJ^q]M„U"44FdE3Mc44d%/6WT;khuPv66fU:1X^++6kv$tR,_<p%%2+9a[kg$?;r:+m-aTg6„U"D*$pc)Gk:l14UH&/b\AqEL4lB;%0kXXPgz;CL4$1crkSC_-jVj7_D;olr)*$dS_„U"%=\3im^j/UNA8==SGlW0GuUwsbXxwTFfUX7Jk..ZaD,FZT^87ZTLti+nFli?p%*„U"9Il>qde2YQ\P[>*Xg2a$72Mj?$zb0MlbzK7i0]S_:Q6EY5VyuNxx\K^6G2]X#*o„U"IX_\HGc;IjUTA-+^K(/LUQvN07nU*\cuGjiL1kCOQ#U7](3O;//)ee0LYP;)#39„U">+aHB3>_cV1>[zvWJ)H/_fGSX.dh>V2Xi>aN)'v6Ix#mXeHGm^pG)ZA)Mhl3z-(„U"eH1v+?x&Pf&s12niqid8CZLYO%)VPg2-f*_QCZ8Ik^xRKOPcq#aOu+AVA:z.aRd„U"4_;1O+<O[BoulxgXu:QfJ^Ik7ptIJ].Gt14o#8%pS=+uA_5Vcr]5y=U_m1l6GO5„U"5#Fcam-9n#htE3oHM]O<I^1s%d1NB'XkSuq5\TSLqcm&8WC.8i%40*%%huedYk6„U"dg(%,-j'3L7UhLg4Ua4VL'zLKrUGK%S:13&)p<;oD7UMtt34Ie'rm^sg?rF3(fg„U"62Ab8Y2]+A0>qEsjKCG&mE\q>kD>Qc0,I2NE0N/_O,,7G8#P:pM6YiTTi7)ReIL„U",aCa<Fbm:8zf%3qc[A3;/1=XTZp2G+M;n]N:-U#dwT*gXpl\q*A\YY>?6I\?Bb7„U"THIKe2?GCT_hOf\63_R8YP2h1:Cqr>=[L^#froA]pQPfE*C#CPO]&f]DT+*i4&;„U"N]1U[AQ+XhH,qSj9t(W=,F59)RCz4rJKv<5v&f>$(KnUyWM$coF;DPl$<b->p0=„U"iEq&+5Of0\W2AUQUK;VQbu6dFf^RC4rSZ_J$Zm4oA1?h[+K,Ml+YUkS4<9E,h6r„U"?=8j+SC<*DV>BA1aTMP>*V+tc:jr<BT^Ua)#k;574;MmdN/6b62B?AsVyD8]DBR„U"n9(U3:'[r+[syn[4Hca:c79<LAppA>3BCp'Uhq$#A2Q]Y'$9P+/Pidn<XJ52C<$„U"R.U?)#Up_oEg)L'Wc<]KCh0ir8'IE=VPTReZ&HGlvBEk,'5.335LR*OLIj<liLM„U"&f39u$/e/K.<VHe1bn7R#SmCdYD)bf;i'eL>a0rZ7]:KQ2lp\5W'3nyv\f%w1Fn„U"JbGX5*B.69I^gO5)Bc;Y0_aybnHHl2S3qj+)]*r-FgT8Y)2v.:]Zy]F7M16fLNe„U"Os+-<Q#KIcM)9;m4y3,G2wIH&H(Azu//m^qs+_iDjJL4*1k&;MoA,xknNWIEtGa„U"[ebAKK?8E1>Y&xgljKmb_#I\1+e&H*rEgAZ)JY((A&qELIHav#OnDt487yNOd5)„U"R%^g)kuX'Q]nev8ETk'[3t(]Bn8ym+y3?S/32N5aj4Wa0Gf*3tnF%;;P8*)fP-;„U"%SH\l,6l#\[TmEnx_SFNj=\mRL-v.sML>65eGE]b?u['dwTPPy-:)+Y6aL\v8)n„U"]miAMr':?MVwwOe5yRfsRmx,sb&MH=Ow8Ex\nu+<Ad%JM'=H2jr$f/TcPD%_,Ng„U"1gril,lA_+hzdwBwD_inzwc_PnC3cRw+Pm%;I*oXu%oao*]92w\k41CGvpgTk]$„U"ntqVSy<'W9:tPGGU1e<R.:L.;de8y+2H:z(jxzeF_[o92,)m?DhTrf2R(sz;Ze*„U"5CqbYU,(o;R#0vn(s9aM=1KD28SZ2q_.y#9*:7)i:qN>\p7hwOo/8NIp+<(:osL„U"h2(Ze.[XT&qc]EN;uMGsgy[qy/-FC=4^sL=3lM/whD+Nm&zpW_z?s$>gA/gzw-D„U"bzQ%T0=/c8D1>B4>L.Jl<79N\9>.JM;hMC]2Y0C*/D_t50aXdNPBU9>0A9Lfne_„U")KbSbpE:Wa.*[6q+]b-3QF\z:P'K7/%<*4H:Tn\M-2V4d[6Z5mUR?)Z$DA4gZxo„U"dO#:+7fXI*p5MoB#0F'OCOcD,tSd>7?LcLl<ku\__c[[)'90kQ)cO4'+cmeHmsm„U"j/Vw&^LqN##Uz?N(QtE<fnx&URfe+9=)MJOZ[ukt=Y3D*IPd78sS>?aj4/vl*-n„U"TaN45UoMpK6Xb7YH5'iTMper)iTSltd7k))+=;9Rg6&b/t]\>5EAO(lVpyB9Zbo„U"B;Q<HRk3g8\&]3N_<&hkRZ'nwFWIwrYY=%N5UrQG3D(Yh[A:6ZVs=QwMDLS6%jP„U"(bhhpLFNjMpLZt-&S6.7%MAy+M\JNeHuIT)P;';[R(IYWR)<\Alw]v.^_N>E\7)„U"cqO+cJ)P&Zp#nrj_%.P[.RzB(+pMtXBE#JknMF,uO4c7KW)i%*EDQ:KG#Q<:z94„U"Oo3&8'i1ei'fUY>.uThYZ'FX\9=d1V+<-Wkgo6PuuSR<Vsru9b2jJG1c_)np9BH„U"R+9_C8+.e'?2Tgh/ViIBbz=5WKpvMZAA9om.d6)z3KlNa4xajdeK6X+XCRpdBSI„U"*>mH\Go6.PEF52;iGs9Z,5p(,3dWjplg_?K2Nz8zmbIt]\H=d^syfA51mLo#.jV„U"xa?B;la[uL_-j,ZP>'(h3?VaoG&.X2hA'VDUBrq#f4_sGKdmd^6e)SpTs&-V*;H„U"DH7I0<v/0MOPscdGmcgqTkkPXm\;6-j;>3cPGhbAVFyY6Y.M34Khwt[=tWCB/7A„U"?'t1\a;*h:Q&jiX;7tpqq>50JqURUUXJ*oP%J>pn>IS1uqto$W?jaW_8Qd>rC4R„U"t;h&\rwlVTm-;b130#0.i#N]t_uHod^_SP86kaho97NHqEKxDq+9/puRVaDYz')„U"nctYtk]hTwZ\/>psqs3wq4#Z,'Y^o3a>ajRePJ6K[9x5P)\y=fh&f;q,aK[0)uF„U"Ug7Kr58/1,UA/[T;JBr.B#^ghc]i,ab4&I-$wV=zt+lrVbk:ZWuqW=F7vS,NV,E„U")^P7/6v&+27fu3?)^*_XgPLIErlnWK_0ZK9ff8sEbSs^M-Nz/JIB.Q]Pczb)$Z<„U"UZV+&,BZ>UGV(vl0rXL:0e4h=3^6hg(7,\RQ5-;DwE9aBi6jgVMVrmgnDwk^YRU„U"(>tK#^;ejZRoD\lj:P-MDXhmx)WAp8MHPE(Si=TlNl<i&gC2GV&sFGhFv#jhgX,„U";cM((oDI_l;4q=)e'43W/:k#1^4)4=q=B+CnBi'FjW:YO4M:X2Czry&>(^wOJR]„U"Jj%Ozj?YDTv%+66kyhz8mFM\Ih[6OU=YYRNQFuJTEOrU5/_UBg&8RU#**Kj>U:$„U"g3]kp;[4]*nNup%()9%%'%-%:v*DG+$1vS%d*%%&m4%%%/%%%%mzkk&.ySgRfxF„U"%;<>Smj5w]=DNg?A%*Bf&QSW,j=kZ>Y8%ATWT4wsxDA/&.>[FrJY<sd>,6PTpBi„U"Jbx(LlJ)-eEaXZlEE]cTw?G2i\5(>/;OvoEEG;BI4\_b=v)ok#-X6%Bak>5KnR%„U"Og?%_=khJ%P/IT46E5cfEXhu'Bt&p/#Bl$=EF/-L/96HOZnr\D:FW5:UU>2T&7R„U"9P=Zi<YC'6'-Z1[G(ta9rQ7I<ldXI9)ZZj^*4-tvHC(l#Nq5'9eNmdN[k(E4nOc„U"9N5uL9a<cR*P);U'*hPnXeQ02cTxDnT.m(faA#sQM2eeCHStT$WR<tWW,9/EG#R„U">0#+<seY5TuYnEDz,#4;q7/70QHQ<O]?o)<UR(d].4N%MDq,Ib/NH:$=:heo\LV„U"k>1=d59Or.(1kZP[PQ;[vPUs?wog>lq$?]OL=5m8WL)9'f\>HE8]'X>fi[W_6FU„U"a7xlIdYMnPA_J1R8\Fs?#G66^=t-9B6DB,&.47D5D89SiC223uD=Dy)93Aq13Ad„U"=FU6&RIOrQ=^C/Y;Y]'^[Tql?nLOf,p*RXU_9&Wh1vT8JgGOoSyZLC7L\QtrdN?„U"lm-a<w4-8L2S0Y#W9;r7D&[zpTO+i.-o3_UX+>KuQg;rg*AW2Q;.0iYY%?/Wm[:„U"wA\cA-dw'i\XRhv?9lC-4+o)DePb<qkSqDkY/6l[#$V<[%:m^\MmksPA.aGlAt5„U"%)T:z\Z9]AP6.7'wN6%e+l<3QDkNsbioA=tch=<-)v;nN7/]B:F1f/j0,ZrMCP.„U"\,SSYUVn(-U'[,l/TNZ^fQOZj+KSp'$si)I<&hSDF'(IZbUt?3PU.C\M-oZ2)xC„U"2:T3kx2u3+iXR5kiI2[(a*Y8;B8R[Ullp<Yl3ps$6B[XR+/am+=wB<[<&#e<SAR„U"[3t+psM6Zoi^<ZgXUr$R1VsYa/:q,Bj?sN3SBS+(i.5Q$4:xwQ&x;F[0_^5A%PK„U"/35OKVYC:-v&28A_LV\x+9qX\k/ykwM$^Ujm%t]1whKb;)8Ro*iUPs0AA&A#z0>„U"NQvh&PAq+vgIIJxt=X;7(gzX-?i&o_ThZaS?B-Y]7:n3R=nelm91*n;(ht4H%qr„U"1DSlqd+l>g?csUU9>1R3VFwR)i(_&6*Ue(Wr0,1FjLOUZlT06>HK7V5Nf]Wv(,>„U"kbC=WIuq&=4<=2?O1l.4T/gAx%bj+fsE$K>.w;iiog7TZk;U)-;5Z\nbN9J:rIk„U"F9]v/\DIfBN8b_efJ*vpenQ1Nq9:l-DhCxeeMALu's=wf+t2NkGkhaWY_CIN^t-„U",\n:/m=*pm^cpmJp9mJp8,]ginObuCjtTpH=H_9d\lB:[NnJ<5PbFmidRfpAJV4„U"DlEYbNqTqjho57HV37,_7%Mf^z>]GWm%$qyW?53mFMvgO%z(Yi$2G6>p1+J0I.s„U"485t7Bx$P%Xz2pmY)f5Cr2T:R3RX%MuEekV\);&L93V%sd6t^d44Xkfl0Kjb+x0„U"7p8zosnjLfkLSbgSbQVRMygjn7JCL)mZ+][fn]R&L2ta><BE4zKm7hg]HGVbHEn„U"XhUJo)x1b=CcJHLb)zVhfnRE=2ik$n]EH^=ws^:r7cA#cBMI]ekAz]8D:hg0f37„U"XP2Z[,VRK_pCu:+2j'hpNY:.C^BOPFn[kT]3dZ-g/'fa::,Z7KiS$r&SdCpYT]4„U"3:vO'.W0[OxLogltfXZs+(c^(iDYG$UBAh2c*Z&>up(%)9%'[%-%sb'DG^derEJ„U"[*%%O%9%%/%%%%m#zkk.%zSzs4yF&p,>Tk5T7#iN1=s%Q+:-PNE*b=Dd#w)B/;M„U"aE2&xbpVo'Dg&Wq/9>d#ho'J'fsM<OmACM_xN:n]VL*2cNJGTVGzOhEl>Y57RlE„U"#5L]>o66*YCvvMcfs2O.QdLnaWD1fsC51.NX4ew)h.oe9X1LMsT8x%PFiJ\:t9d„U"2T9Dd(cvC1o?KrdQ2MEmh?$W6$G;$2DbYJ6x$W:DgYDSMz--o++</R9Z(lWGtW?„U"R:bsV9wQ?>i/IlrmDr-p#4P]dbj7azOAT=/EYvT^qoLrD0Osn8'ZRErA[Z(LX&d„U">4t.lq''4]qx+hYgp&0f;)%&Z&KCTE_Y6)aK8>h$*BQqF%tFdLCU.cl*>6UrdTK„U"#+lxXBt?qZ(4ZP*W#\:#TZuXRTW9SFBYt]/0/<0EpdP,X^inRtPp8ra\-7_QqBT„U"m52GE^gb&;WQ90<qUb]#oY=?Ph$2J&3dk%_p^u8QQl+Up?IZQ$3S<+)mZBP4e_R„U"?D(74,uMPns]A?42qt$b(e?M47nXtOBQ?'\z$+m\k&(l5W6vKwU<=5h&SC$VRH/„U"u3;/F-lh1F>[K6(%4)Q#I8FG>0Jr_,GsA1AA%J;bvb0m',H89wIQ*SNAq-VW]Y3„U"#>j<b:)u]QN6g63<*WL)8qY\jN8/'I*AP^/,^9s+PCHl+n_BYnZHt;1FsGE\<qU„U"+fqu+?.kZU)_)tIz$mtZxm,Zb*-J^(fI)L['40[-a9gmetRL'-a[m%nGKM4ab;g„U"/b3s.BJ+2,0*a$_rNkD)(T*%\Ag)7^J[f+*5GoWlOUiH7mg+n^suRA=m7E7.Wzy„U"F81l>+tWH?#WPM8RZ*T\d=:*dB=Ll$rcfk%E.5iE#'iia,M%fE(dJ?)Y8GbL&DN„U";^E/^.;<&rF/i>Xmf6omLL_:fvT'9gj90M_OS8-Ke=A9-3[q4;2lqWBzn%&?k-s„U"9$udm_P3=)eP2T)H+'e3Q1XyqaT)t_\H+z%]n-Hit#>WdJkQC[-\2hr$gv0Q3E*„U"+;5;[<LYYo$HTTZ5NroQ7GkjSb-WdHTXkq6P0:z5I_QW6f8X[&ZqK]L8=->rk8E„U"gA[R6SIZhjs$ZH'i-dtEnC8SePa&g_YP^mB)Lp][\<&+s,>eq#&+&9lgV=&H5*s„U"_.PrC3hsYRU[KJ6edYP<0pjN#IBOz3=[ndAO;o1c)E*fTv9axY2$dU&X1mOp#a9„U"NThTwKND95f,UWNa[P)]w]d9e/A550FPvXy:FIS#vX\GI2Q=ONfr-[uUUY0'aKv„U"BT#'%C-rWJAs[TX22G7+Ic3=D_jy6-DSKeRL$<W?f6pKbDXWa<0I$d,N;(y,Uc3„U"=2%mIikaKLgPi+#bP*:^d?Uwr>\kcFgrT0/xF0mSL:i$TT.(9g)gnIDvBH-Ja<T„U"-1Cr:yEJN;%.EtdNvGCN2J?'J\I3$DC'I<R-Vk0?(lxjgyl?N>R64_cw's^&Z4]„U"qAbkX;U=fGGWnkr(i4L9.BgCoXuQ\VDd8Wm:=P>]NCH&0dM.8,_O/9L:gVYL#$l„U"K=4WQECSHr7qgEtySd4uO[ph8#$wfFLxW:H%33I2u1wjfNRnY[i#'fh7Uem&o%?„U"2LLfM7CoKfbJn_-.u01'pLJ5KdRsnk-RJ.^M7OFcUtr9B3$z'[L94>bFHazk[D:„U",:NSrX#.uYF(Mw&h$4b#r\%R*ZOJt<tq0;<ioE'4;j39)34k;#(bQ;s0XZ([RI=„U"QMRS4_.#Fj59,Qu4cKHSXJn$X[a]dMC%IVdAg4?U:HA.e&+Cn]/=l^KAyVoAxJW„U"6=k/Ty2h8c?f&p=N*e*JU[iQ0-ZBG=UeGA9w[S2$jYIMuS+Lo%hA/4t?_0txXNa„U"zb.J>qy#4ADF1DO;3Cu$7&Ct&uH'qaye.+IheI9GVlGQ9ZGSN-c5I3E6h8'x%up„U"%&'9%%9%'%#-%M$BCG]h2'x[(%%%n+%%%0%%%%%%%%%&%%E%%%%%%%%%mzkk%rf„U"sS(y'yu%p&'9%%9%'[%-%\b'DGi>fcHz[0%%^%S%%/%%%%%%%%%&%%E%%+%.(%%„U"%mzk(k.uS%zsyu%p&'9%%9%'%%-%v,*DG$'1vSd#*%%m%4%%/%%%%%%%%%&%%E%„U"%%%W4%%%mzk(k.yS%gfxu%p&'9%%9%'[%-%sb'DG^derEJ[*%%O%9%%/%%%%%%%„U"%%&%%E%%(%h9%%%mzk(k.zS%zsyu%p*+%%%%%)[%)%Z#%%%a%?%%%%%„END SUB„CLOSE:IF S=127AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Nigel Traves                   TRIGONOMETRIC LIBRARY          FidoNet QUIK_BAS Echo          06-08-97 (05:01)       QB, PDS                96   6330     TRIGLIB.BAS DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"TRIGLIB.ZIP",4^6:Z&=4474:?STRING$(50,177);„U"%up()%9%'%#-%Qif;GM<&QdZ)%%%U<%%%0%%%%yw%nlkz%shSgOnN',,>[]9hL.„U"8xK9a,xqyuVF%i5+MPdoP8J8,<f:Giw%hV+Q.9:k/xqUN8/Kl.4FEKuD**8/Lc$„U"$MBXi1l\w5QXmZYMv>1<ZY?M'P],].,uQkRV2UO.m$.I,;g+9eElP67I/LlL?JT„U"PUmWQQ0$fJU?a<:v;/L3Or*<hU?d;Hk;PlZ(;dc,9?d/7f>Lev_HE5cV8iH#[cC„U"lyi:m_N/GT/$p=6?Y0WkO+U-H<U9UM4cB+<7.IJi,5keS3+iC]uQ))ad(8oU5j0„U"jx>e<-Q^on=,gVdTV_2iDAxYNeW;JfDDodlT5f'5.=H$=PQ[oeF-LIW]bASr8Yu„U"oO2Ejo4l#Y:8F<3YKMrZrr^5WU$RqO;c=)2]nIAgO_&g]\pI9-*mnOiU(.'wl([„U"&h;><a>P-P+9<qHEM&l[4Sgv))vOidnH5M$&eiR-EfWJ8[OY0#EQo1gG/t,/k-+„U"F.xNSo\gLga,D5Z0rfkrB(awU.77w;ItkaBj)xrrlm_e6Obb\x\;0sXEJkiERZt„U"+nIk+6ZTiBl>5C_Udo5d(\XtIVGP=v/:PXFL*-tFUoPqEFYnr3lgR8odaAGd(rn„U"qamWM>B6,sZt%T8?nTvfQp%&;Tss[Tr^84V_MzdaPD5-N'izXBW6a+C8(Iv&/QL„U"YW2lE3I>W&7CpugGa234]vd_5oSXE+57Os:c&b\)U&tf'L]]OD>bg-*H?2P0I5%„U"><P7LxX%'Ye4MRnMD]o.:?0T315g8rTjmgE&#m(oH0(FLl5X**IjoK[(nR%<PQ(„U"*UZIG<U843M=kY7gpLG%%uDJ>FJ?[Qz6tBTd<7l9Q<FqHTcLeB:Fno-UMF?HJQx„U"f5CWs.1:Ybb3wrEWH,0V?fbqyXD&oNgRF:z*ofIRqh\r#g0b<'T'cR<wv;edIbn„U"C_u=5nqz5S0B'S27zpCEJuPy3\u$P4d*<e9_+T]<s:cB5Z)\gD0Pn=Z[TQWLV,4„U"R\fpAp+L]i.u0\/b^b^8t#Isnh&?(QXcY:2&Ce2^Lu[*T-Keq9?(=z9fYOdq./M„U"GB2L1rB'^'Z[,a<DP2=,i,M4r/Tem#L7B:3<MX/1K9j98%]Ag;p?Zr*g2Zs$qMF„U"dYmNv9fNbD41jIf8--lZF^'z7QQ&u2\U:D%.u:0&$Dl]o6iN-oC0%_d#DdM]mrq„U"rdJ0euLSAGx+nK)-h9Lg#VBEK[fV'j'Ata4^b.5jpib^2NAf+3>a8NX^9y?,txt„U"Vyt:T)En,TGzvaKPp16J<XcYN465Zw,fS26b?l,gSPst#Ycs6W;r80QhhiFWGad„U"*In?J=?_lCLA:<4tEjB3qt]5pDssDM8UX$Vxpog#ncCBiK,2JVwvlxW\%RfHW^Q„U"f^wmHOVdL's,up%()9%%'%-%:^1<GE.ZAr&W+%%&)]%%%0%%%%ywnl%qngS[gfx„U"Fh)*>[Ik9M^8cd)t>6.&'[nnF&8Ix67d0sQ=Rg?59-taJ3IE6J4p$,khg$&J)T$„U"+73Bv7WBT_$0>BGU,nJL\h\qun?ggD?e?YjN\Bu15u5%^$b^Rb>4rZbiWTTdt,$„U"p\hH97t[Z$lae/1tOjuLVVxTddnRr=#gO.eL['XdLycitk_j:,79WWgjOn<))_Z„U"[?.8PxMb,TiNoCnXG=pXGrcXGtXfGv.cubbB6Tt6G:AG=7GBd%Crof[s3^.&UqC„U":aLN94*5&'Kr9KHY#&Kb,tN+(MLkxsT)m\fq*q$79w-]phIkL&DGS1=DA[J\)9a„U"9B$<Gmgk.IT-Y8eu8#.m^u(L4Lj8vM>7/LPUuu)ae?3Y9%35*Fk-#jh<X^)1hh0„U"PB1Qn0^F78OYsL<=(C]aFvqd6;NV_FI$-&3,<UfaW4gD;[9mtmY8UE-LX44*<7K„U"G(]e.e9=je4uT$Z;lmCm/JX4:)ZU&tI]y:6qOCe3))F8*L3h?72'<?ILz^Hn-k-„U"=vAs*(r]I.9<>]tHB]Gf4itVW'T1jg&_gq8D:_gCg9Z5)?c/eG[nILyEe1:8RF(„U"P3I=\3'N2#_=x)'nmU7:.5H3Cx%G8eOxYBUusA?g3&StP)+zGWZ6=gEG>_G+8ZB„U"JS=M<%D.zmj2w/Jk\'J$u\[C=/7Xe1YIO(S9.f$.n7.d\)1Zl<Z6LG.P'0c(H-Z„U".'xY$9H'LeKu89:c,mgOK=[2O\RI5Ta$AVO#mk5=;OCl%qwFOt=;9lhB_;=Mv3n„U"oP.C^7(c%x\KOLJ#xu]5,$TfQi9e$kXhsAvqxrsWYNQq0T[j\/%:,&c+4RuNE64„U"vc*b(9d-rTr7Q)RFKX^WflN:>LcQm4Xe7u>gr'ed)[#+UfrWsz7T5I_\<n#-a)D„U"pa&4+vJ)CO;7kg&?\f;SoUQh09H/Y#e7&hZs:^/6xJ(fFU>U_)Pa2jFVJ+9g;,g„U"4t^KI.(ukXuqz'C7tq[DX\D/p%1vB=a5V8>L1xfb49W(xs[Ou7Ro;dnI650H/&a„U"POZ>lHh9(uNgth^Dp=gOJ_&-+j$4i.a8U8'SiCB,]\eR4$Rv=CumpG.bXf#gc#?„U"CS3]4-D,*[6wkLJ1L%5I2lM^.)j*m,=Bo0,XdpN-Rw>]rF+ZgU4u-c.M:K*;=ge„U"JUD+<*^\M%WYE6KFRqbh$Wu1pEH/T$Dl1C[U0m\<DFaI\mdHpr5([j9^)bgEI^Y„U"eYiz:qUk5B%YMtCWye(*b\N9mG*Awg*\/uZ4iU^Qr^ZU7j8cvrM))2[O,klgjT?„U"h]\y-q.cu:F6pu?:)S8PV$HC^Yg2z?5[%yFcp*sO;f7-ewo:v#V77GgeNx<p*T;„U"&jci%0aHDbj,2%#zTM6.gdEkO3,A#FzsWj7=\C#sAlNB6<'v(y=-Go=4wxcj'1\„U"1Jzl$WJXrB>9W:q6A1NXjB5R.CX>z0jrb)L'ZM;#pzU<7DZyu9EQum:&EKZ?uP5„U"sLLCr,3flzaQmWA4QLo_GC7:]niO\XN\VU&Q>/sp;:),0v^959?S'1WE;&,^qbc„U"*F/-_,7LP*)b:Yd&nH1la+qB.q.mYZSpKrdnv8.-%9uas>YC;2mAxvN\db%Cq+V„U"H3/T,]e:PvK5KA%qhuwOu3W#/_Z>n+y/eA$ugN5%X_a&nbDpdtjOx\&]'Cn:Y2_„U".n3WGy/ibAAhL;yx%_WAUkIDZq?NP]/j4Y:PQqUoVwyP&Z=tjg%?BRwf/EHTC27„U"H*<u%6cInl&:ns6<,em9(f.Ff<n.AI'Q[zwDa7hl\cOG8jsS3U[uhZY(;x\:Rx2„U"3$d(R%NB3$34Nauh$'dFdS0Po[G>E&5M_QNh-)7o:J1(>i?nqKk+=e&]MGrPo^+„U"Wu\jA_KtdO(8L&MrWoY'5(wX7loiZhbsSxO2*s\C3yiju<W0+A8onfQDTy:6DWn„U"Cswa)'^#9'ga>Ig,UzyH0D>vBk[)x,oSwYajc*&I[GWg)M[42<9XSEhPnKC5fME„U"d4BK8T)NKPgtX07TGm0tgTI9B]#c8yac$W>)e%)Y2bbdmN5\4)Q>VY&A8x$T+Nv„U"Zs?lz>58/CT-'.#m+9tKI:]/=Lv&1Pqx*vCUa7^7k71t&fOj.&B'e22,n4G\R1R„U"heiA#Ik?_Fxu%p()9%%'%-g%$2<XGKv6)#J'%+%+/%%%1%%%%ywn%lyjx%ySgf1„U"xl%v)Biq9hL6Uxq?RbQgqrbM/)r<DEucyu#;AJb0_60j>5uQ3TKkxL2F0&;]<SI„U"5kWp+Gp^JhWNR<.)<o3wU+Z8e$grq?lsLo4dkw&:3?_>Z3H.Y#C)=V\<*eNg(GF„U"<fF'A'&2<m>g+iV-^#mg?tQutMxUXBaS3u7K.>6K+,Uq;kuhWfq6f.k]U9Tfx\S„U"*vV[]FfI&2.)q:).+I-5kHjm=06rY7_YA;-ZE*OJDeNJK&oE3W0[%T.sgN=L:A2„U"=f+sEcuC5V>##mAEO=o[h952-0khj4BG'CDgNAN;pBr.Q*v7)dEL/?Bg]</:R4n„U"uVK.2xr:Y)8Ln?b1RI\XwP_]W,O#hmZ\l1b0)CV7$pim<YeK1kIrvEN:2c=TB?l„U"4O'Wke:Qek?em6;698-KRnQ2WfEiB9V]IV)'cune0KAOYHUR)PcH]Vz]%CN_s9u„U"aZuC+hHYdVHVEAS<,hQ<=VLJPB*Q9Y)Poikc9JF.WP3ALQ8E/XGYxGtkNv;)i:W„U"Hf-)fr=&ApP9-HY,sM>OOR/Wmkf4-3Lmae+ONh2d/PKT<*+3;wPDjL+>,wl27d$„U"wk9B?hGG.64Z*5iFML7pI2?;/Au%rkfy#\HJ>$c86U6r1hdBr-:3B.bR(u%b&YX„U"vS]B2bY(8p_+,nKDb%]kOQ4BsQ5a,ACKolqM\#3dfRF4nptNmeYs.P6lSXSqH<U„U"pg+2-vb9V8+T(UaP7$XfajK1HdljGbqjVHnK5#HRzo#c#+<\nx^uVtQDj,a.]_w„U"8tB:wCF[>N2YZW1l5?WhiDneebEX\?$F[<m%s4%up()%9%'%R-%Q*'AGU,33[y'„U".%%3*%%%,%%%%wj%fiSr^jDyD,=TU595#i4Q]-fqe]8zohtxJ,\R9-Ia,K=a2hu„U"%7)*i9mrCyw7.hoMy#j*(quA^eelE'N)TOy*2gwPc8Avhl)3fl?B*RQ3gF>Vv?>„U"y-?C%=0nj_23uO2G)s8r=6LB/BEXb3^R^\Fh>y'3&<zqpnTKeIdSub3b3V#MnO_„U"<\n.%4(oHIsZj:OsQrAic+.e/FF^dTKpkYf_?.89I237Sc(8d[dX*gQV492o2rF„U"^e3L^HDw4ZI#i6.,t8I,iN6M$6.m#Mb(^%mXpI-\P.C%p#z5gCX4\XiY1MuR7n-„U")>c30D4oywaaNgw#7JxzgEzWNF(g#9YB&kK*XZa+5Q]-O%[f:u&&/R#1RQD>Vt1„U"p+VXr+\>R%LnKK.T5\&[9OLvx];(mg7gKL1SAmSB,8RB7o-#1CQ%gDeWF'bSSu'„U"52E0+?:&&Fap2WX+M$jQ3/mB\G(Gq4nJGsG6L.\_mz[bJwj<]mfhaQ+&&/zQO$M„U"'Xl->IgZlO<VCA0-W>\4G6ItJN5<oy1oqaSq[K3W4bt/w+SYs_\%i7_/]ViF#kS„U"eT3C=snc-GS(-e*CSH(BJoa9??^a-:F[sTo1*G--wgwBMZ0VNU2s7m9m0Gmg:#7„U"'J&kde9uD=-8>f>76Nmb-]q-&T:r9_q1[NRm+3fZei1X8=U7^x7X9GC[M?A<Es]„U"qBC(rP#f]V'55n,&3Gan]xp&d8cK9]zH'ey>niRmfv5VPN$R_Z9I5he-Tj,02TV„U"+FlHRZ,PHjTQ92DKBV=#;$CKUlHxm6:l7GZRDoE-ISL3X#L.q94tCm318;pN2\n„U"=>g'D)AtfNluAL)/Bj48>JKPwc<ImEtrTtNP_[E3SVIIx=Wv_/=,=w%u%p&'9%%„U"9%'%%-%QGi;GM*<QdZ%)%%U%<%%0%%%%%%%%%&%%E%%%%%%%%%ywn%lkzs%hSgn„U"%up&'%9%9%%'%-%:^1<GE.ZAr&W+%%&)]%%%0%%%%%%%%%&%E%.%%-)%%%yw%nl„U"qn%gSgf%xup&%'9%9%%'%-g%$2<XGKv6)#J'%+%+/%%%1%%%%%%%%%&%E%%%%4%„U"0%%y%wnly%jxyS%gfxu%p&'9%%9%'[%-%Q,*AGUO,3[y#'%%3%*%%,%%%%%%%%%„U"&%%E%%+%-2%%%wjf%iSrj%up*+%%%%%%)%)%'Z%%%&R5%%%%%„END SUB„CLOSE:IF S=174AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Brian Mahocker                 CALCULATE THEORY OF PROBABILTY Kain121182@aol.com             07-03-97 (12:01)       QB, QBasic, PDS        58   2184     PROBILTY.BAS'This is an experiment intended to document the theory of probobility.„'Use how u want. But if you do use this stuff in your other programs,„'please at least give me credit!!„CLS : INPUT "What do you want the delay to be? : ", delay: COLOR 7„CLS : RANDOMIZE TIMER„COLOR 7„LOCATE 1, 1: PRINT "Number 1 :"„LOCATE 2, 1: PRINT "Number 2 :"„LOCATE 3, 1: PRINT "Total Numbers drawn : "„LOCATE 5, 1: PRINT "Times Equal :"„LOCATE 8, 1: PRINT "The higher number is number :"„„DO„COLOR 7„LOCATE 7, 1: PRINT "Numbers are currently"; : COLOR 15: PRINT apart&; : COLOR 7: PRINT "apart and going "; : COLOR 15: PRINT CHR$(going) + " ": COLOR 7„LOCATE 10, 1: PRINT "Highest amount ever being apart is"; : COLOR 15: PRINT highapart&: COLOR 7„LOCATE 12, 1: PRINT "Number 1 has been highest"; : COLOR 15: PRINT number1high&; : COLOR 7: PRINT "times."„LOCATE 13, 1: PRINT "Number 2 has been highest"; : COLOR 15: PRINT number2high&; : COLOR 7: PRINT "times."„LOCATE 15, 1: COLOR 7: PRINT "Press "; : COLOR 15: PRINT "P"; : COLOR 7: PRINT " at any time to pause count then press again to continue"„COLOR 15„LOCATE 1, 11: PRINT num1&„LOCATE 2, 11: PRINT num2&„LOCATE 5, 14: PRINT equal&„LOCATE 8, 30: PRINT higher&„' LOCATE 3, 22: PRINT totaldrawn&„IF UCASE$(INKEY$) = "P" THEN„   DO„   LOOP UNTIL UCASE$(INKEY$) = "P"„END IF„LET pick = INT(RND * 2) + 1„IF pick = 1 THEN LET num1& = num1& + 1„IF pick = 2 THEN LET num2& = num2& + 1„IF delay = 0 THEN GOTO start„LET time = 0: DO: LET time = time + 1: LOOP UNTIL time = delay„start:„IF num1& = num2& THEN„   'SOUND 3000, .5„   LET equal& = equal& + 1„   LET higher& = 0„END IF„LET oldapart& = apart&„IF num1& > num2& THEN„   LET apart& = (num1& - num2&)„   LET higher& = 1„END IF„IF num2& > num1& THEN„   LET apart& = (num2& - num1&)„   LET higher& = 2„END IF„IF oldapart& > apart& THEN LET going = 25„IF oldapart& < apart& THEN LET going = 24„IF apart& > highapart& THEN LET highapart& = apart&„IF higher& = 1 THEN LET number1high& = number1high& + 1„IF higher& = 2 THEN LET number2high& = number2high& + 1„IF INKEY$ = CHR$(27) THEN GOTO totalexit„LET totaldrawn& = totaldrawn& + 1„LOOP„totalexit:„Ian Pitt                       EXPRESSION EVALUATOR           IanPitt@worldnet.att.net       07-09-97 (17:41)       VBDOS                  178  5672     EVALUATE.BASDECLARE SUB pusho (op() AS STRING * 1, operator$)„DECLARE FUNCTION popn! (ops!())„DECLARE FUNCTION popo$ (op() AS STRING * 1)„DECLARE FUNCTION peekat$ (op() AS STRING * 1)„DECLARE SUB pushn (ops!(), op!)„DECLARE SUB parse (expression$)„DECLARE FUNCTION evaluate! (expression$)„„'Programmer: Ian Pitt„'Date: 7/9/1997„'Email: IanPitt@bigfoot.com„'Program Name: The Evaluator„'Purpose: Gets a mathematical expression from the user and parse it then„'         evaluates it.„„'NOTE: If you need any explanation contact me at the above email address.„'      Or if you find the code particularly helpful in any way please let„'      me know as it encourages me to do more.„„DEFINT A-Z„CONST true = -1, false = NOT true„'Print welcoming message and instructions„CLS„PRINT "WELCOME TO THE EVALUATOR"„PRINT : PRINT„PRINT "The following are examples of legal expressions:-"„PRINT "   2 + 2                Result is 4"„PRINT "   2 - 2                Result is 0"„PRINT "   2 * 2                Result is 4"„PRINT "   2 / 2                Result is 1"„PRINT "   2 ^ 2                Result is 4  NOTE: ie 2 raised to the power 2"„PRINT "   3+(4*(-3+2*34)+2)^2  Result is 68647"„PRINT„PRINT "You may type 'QUIT' at any time to quit the program"„PRINT„„„DO WHILE UCASE$(expression$) <> "QUIT"„  INPUT "Enter expression to evaluate: ", expression$„  'expression$ = "3+(4*(-3+2*34)+2)^2"„  PRINT " Expression = "; expression$„  parse expression$„  PRINT expression$; " After parsing"„  value! = evaluate(expression$)„  PRINT value!„  'expression$ = "quit"„LOOP„END„„FUNCTION evaluate! (expression$)„  DIM operands!(20), operators(10) AS STRING * 1„„  lexpression = LEN(expression$)„  hierarchy$ = "^*/+-()"„„  operands!(0) = 0   'clears operands stack„  operators(0) = CHR$(0) 'clears operators stack„  'pushn operands!(), 0  'seeds stack with 0„„  symbolstart = 1„  DO„    symbolend = INSTR(symbolstart, expression$, " ")„    IF symbolend <= 0 THEN symbolend = lexpression + 1„    symbol$ = UCASE$(MID$(expression$, symbolstart, symbolend - symbolstart))„    symbolpos = INSTR(hierarchy$, symbol$)„    IF symbolpos > 0 THEN  'this is an operator„      symbolonstack$ = peekat$(operators())„      IF INSTR(hierarchy$, symbolonstack$) > symbolpos OR symbolonstack$ = "" OR symbol$ = "(" THEN„        pusho operators(), symbol$„      ELSEIF symbol$ = ")" THEN„        DO„          symbolonstack$ = popo$(operators())„          IF INSTR("^*/+-", symbolonstack$) > 0 THEN„            op2! = popn(operands!())„            op1! = popn(operands!())„          END IF„          SELECT CASE symbolonstack$„            CASE "^": pushn operands!(), op1! ^ op2!„            CASE "*": pushn operands!(), op1! * op2!„            CASE "/": pushn operands!(), op1! / op2!„            CASE "+": pushn operands!(), op1! + op2!„            CASE "-": pushn operands!(), op1! - op2!„          END SELECT„        LOOP WHILE symbolonstack$ <> "("„      ELSE„        symbolonstack$ = popo$(operators())„        IF INSTR("^*/+-", symbolonstack$) > 0 THEN„          op2! = popn(operands!())„          op1! = popn(operands!())„        END IF„        SELECT CASE symbolonstack$„          CASE "^": pushn operands!(), op1! ^ op2!„          CASE "*": pushn operands!(), op1! * op2!„          CASE "/": pushn operands!(), op1! / op2!„          CASE "+": pushn operands!(), op1! + op2!„          CASE "-": pushn operands!(), op1! - op2!„          CASE "(": pusho operators(), symbol$„        END SELECT„        pusho operators(), symbol$„      END IF„    ELSE„      pushn operands!(), VAL(symbol$)„    END IF„    symbolstart = symbolend + 1„  LOOP WHILE symbolend < lexpression„        DO WHILE ASC(operators(0))„          symbolonstack$ = popo$(operators())„          IF INSTR("^*/+-", symbolonstack$) > 0 THEN„            op2! = popn(operands!())„            op1! = popn(operands!())„          END IF„          SELECT CASE symbolonstack$„            CASE "^": pushn operands!(), op1! ^ op2!„            CASE "*": pushn operands!(), op1! * op2!„            CASE "/": pushn operands!(), op1! / op2!„            CASE "+": pushn operands!(), op1! + op2!„            CASE "-": pushn operands!(), op1! - op2!„          END SELECT„        LOOP„  evaluate! = popn(operands!())„END FUNCTION„„SUB parse (expression$)„  lexpression = LEN(expression$)„  WasOperator = true„  FOR ct = 1 TO lexpression„    ch$ = MID$(expression$, ct, 1)„    SELECT CASE ch$„      CASE " "„      CASE "("„        texpression$ = texpression$ + ch$ + " "„        WasOperator = true„      CASE ")"„        texpression$ = texpression$ + " " + ch$„        WasOperator = false„      CASE "+", "-", "*", "/", "^"„        IF NOT WasOperator THEN„          texpression$ = texpression$ + " " + ch$ + " "„        ELSE„          texpression$ = texpression$ + ch$„        END IF„        WasOperator = NOT WasOperator„      CASE ELSE„        texpression$ = texpression$ + ch$„        WasOperator = false„    END SELECT„  NEXT„  expression$ = texpression$„END SUB„„FUNCTION peekat$ (op() AS STRING * 1)„  ct = ASC(op(0))„  IF ct THEN peekat$ = op(ct) ELSE peekat$ = ""„END FUNCTION„„FUNCTION popn! (ops!())„  popn! = ops!(ops!(0))„  ops!(0) = ops!(0) - 1„END FUNCTION„„FUNCTION popo$ (op() AS STRING * 1)„  ct = ASC(op(0))„  popo$ = op(ct)„  ct = ct - 1„  op(0) = CHR$(ct)„END FUNCTION„„SUB pushn (ops!(), op!)„  ops!(0) = ops!(0) + 1„  ops!(ops!(0)) = op!„END SUB„„SUB pusho (op() AS STRING * 1, operator$)„  ct = ASC(op(0))„  ct = ct + 1„  op(0) = CHR$(ct)„  op(ct) = operator$„END SUB„Tika Carr                      CALCULATE MOON AGE             t.carr@pobox.com               07-15-97 (16:03)       QB, QBasic, PDS        68   2153     MOON_AGE.BAS' MOON_AGE.BAS„'„' Converted to QuickBasic by Tika Carr 7/14/1997„' Original MOON_AGE.C public domain by Michelangelo Jones, 1:1/124.„' Found in Bob Stout's C SNIPPETS collection„'„' Public Domain - No warranties or guarantees are expressed nor implied.„„' Returns 0 for new moon, 15 for full moon,„' 29 for the day before new, and so forth.„'„' This routine sometimes gets "off" by a few days,„' but is self-correcting.„„DECLARE FUNCTION MoonAge% (month%, day%, year%)„„DEFINT A-Z„„MoonData1:„DATA 18, 0, 11, 22, 3, 14, 25, 6, 17, 28, 9, 20, 1, 12, 23, 4, 15, 26, 7„DATA -1, 1, 0, 1, 2, 3, 4, 5, 7, 7, 9, 9„„MoonData2:„DATA "new"                  : ' totally dark„DATA "waxing crescent"      : ' increasing to full & quarter light„DATA "in its first quarter" : ' increasing to full & half light„DATA "waxing gibbous"       : ' increasing to full & > than half„DATA "full"                 : ' fully lighted„DATA "waning gibbous"       : ' decreasing from full & > than half„DATA "in its last quarter"  : ' decreasing from full & half light„DATA "waning crescent"      : ' decreasing from full & quarter light„„DATA "Jan", "Feb", "Mar", "Apr", "May", "Jun"„DATA "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"„„DIM description(8) AS STRING, months(12) AS STRING„„RESTORE MoonData2„FOR i = 0 TO 7: READ description(i): NEXT„FOR i = 0 TO 11: READ months(i): NEXT„„CLS„INPUT "Month (01 - 12): ", month„INPUT "Day: ", day„INPUT "year: ", year„„'For the next line, you may want to fix this to take the year 2000 into„'consideration ;)„„IF year < 100 THEN year = year + 1900„„phase = MoonAge(month, day, year)„PRINT "Moon Age for "; month; "/"; day; "/"; year; ": "; phase„PRINT "Moon phase on "; day; " "; months(month - 1); " "; year; " is ";„PRINT description(INT(((phase + 2) * 16& / 59&)))„„FUNCTION MoonAge (month, day, year) STATIC„„DIM ages(19), offsets(12)„RESTORE MoonData1„FOR i = 0 TO 18: READ ages(i): NEXT„FOR i = 0 TO 11: READ offsets(i): NEXT„„IF day = 31 THEN day = 1„„MoonAge = ((ages((year + 1) MOD 19) + ((day + offsets(month - 1)) MOD 30) + (year < 1900)) MOD 30)„„END FUNCTION„The ABC Programmer             (DE)COMPRESS QB FILES          voxel@freenet.edmonton.ab.ca   07-01-97 (00:00)       QB, QBasic, PDS        246  5642     COMPQB.BAS  '(De)compress QB/QBasic/PDS/VBDOS files  Programmed by William Yu (07-01-97)„„DECLARE SUB DeCompressQBFile (InFile$, OutFile$)„DECLARE SUB CompressQBFile (InFile$, OutFile$)„DEFINT A-Z„„CONST ID = 255        ' Identifier„„TYPE Reference„  Text AS STRING * 20„  Symbol AS INTEGER„END TYPE„„DIM SHARED RefData(1 TO 510) AS Reference  ' 510 is the maximum I allow.„DIM SHARED NumRef„„READ NumRef„FOR I = 1 TO NumRef„  READ RefData(I).Text„  READ RefData(I).Symbol„NEXT I„„ InFile$ = "COMPQB.BAS"„OutFile$ = "COMPQB.CQB"„„CLS„CompressQBFile InFile$, OutFile$„„ InFile$ = "COMPQB.CQB"„OutFile$ = "SAMPLE.BAS"„„DeCompressQBFile InFile$, OutFile$„„' Here's a short list of the many statements/functions in a typical QB program.„' For maximal compression, use them all! <g>„' Fully customizable table w/simple compression and decompression algorithms.„' After using COMPQB.BAS, PKZIP compresses the output a little better!„„' Try not to exceed 255, as anything over that will use up 3 bytes instead„' of only 2 bytes.„„' Data DOES NOT have to be in numerical order, but it helps to speed up the„' decompression process if it is.„„DATA 100„DATA DECLARE SUB,1„DATA DECLARE FUNCTION,2„DATA END SUB,3„DATA END FUNCTION,4„DATA FOR INPUT AS,5„DATA FOR OUTPUT AS,6„DATA FOR BINARY AS,7„DATA FOR APPEND AS,8„DATA SELECT CASE,9„DATA END SELECT,10„DATA END TYPE,11„DATA LOOP UNTIL,12„DATA END IF,13„DATA ELSE IF,14„DATA DIM SHARED,15„DATA PRINT USING,16„DATA COMMON SHARED,17„DATA RANDOMIZE TIMER,18„DATA AS INTEGER,19„DATA AS STRING,20„DATA AS DOUBLE,21„DATA AS SINGLE,22„DATA AS ANY,23„DATA AS LONG,24„DATA EXIT SUB,25„DATA DEFINT A-Z,26„DATA DEF SEG,27„DATA GOSUB,28„DATA COLOR,29„DATA LOCATE,30„DATA CIRCLE,31„DATA PRINT ",32„DATA ABS,33„DATA PAINT,34„DATA CASE,35„DATA CONST,36„DATA TYPE,37„DATA FUNCTION,38„DATA ELSE,39„DATA THEN,40„DATA RETURN,41„DATA GOTO,42„DATA DIM,43„DATA NEXT,44„DATA EXIT,45„DATA INKEY$,46„DATA WHILE,47„DATA OPEN,48„DATA CLOSE,49„DATA FREEFILE,50„DATA LINE INPUT,51„DATA PRINT,52„DATA WRITE,53„DATA XOR,54„DATA COMMAND$,55„DATA STEP,56„DATA READ,57„DATA POKE,58„DATA WEND,59„DATA "DATA",60„DATA FOR,61„DATA CLS,62„DATA LOF(,63„DATA EOF(,64„DATA PSET,65„DATA POINT,66„DATA SUB,67„DATA GET,68„DATA PUT,69„DATA LINE,70„DATA VARPTR$(,71„DATA VARPTR(,72„DATA VARSTR(,73„DATA PEEK,74„DATA SADD,75„DATA RTRIM$(,76„DATA LTRIM$(,77„DATA LEFT$(,78„DATA MID$(,79„DATA RIGHT$(,80„DATA LEN(,81„DATA CHR$(,82„DATA ASC(,83„DATA INSTR,84„DATA BLOAD,85„DATA BSAVE,86„DATA SCREEN,87„DATA ON ERROR,88„DATA ON KEY,89„DATA WIDTH,90„DATA PLAY,91„DATA SLEEP,92„DATA AND,93„DATA SPACE$(,94„DATA MOD,95„„' These demonstrate customizable compression„„DATA CompressQBFile,96„DATA Ref,97„DATA InFile,98„DATA OutFile,99„DATA Text,100„„SUB CompressQBFile (InFile$, OutFile$)„„PRINT " Compressing: "; InFile$„PRINT "Outputing to: "; OutFile$„„InFile = FREEFILE„OPEN InFile$ FOR INPUT AS InFile„OutFile = FREEFILE„OPEN OutFile$ FOR OUTPUT AS OutFile„„FileBytes& = LOF(InFile)„„DO„  LINE INPUT #InFile, Text$„  FOR I = 1 TO NumRef„    A = INSTR(Text$, RTRIM$(RefData(I).Text))„    WHILE A„      IF A THEN„        B = B + 1„        IF A > 1 THEN FText$ = LEFT$(Text$, A - 1) ELSE FText$ = ""„        IF RefData(I).Symbol > 255 THEN„          Symbol$ = CHR$(0) + CHR$(RefData(I).Symbol MOD 255)„                   '    ^^^ You can make this go up to 255 if you wish.„                   '  So you can keep up to 255*255 references!„        ELSE„          Symbol$ = CHR$(RefData(I).Symbol)„        END IF„        Text$ = FText$ + CHR$(ID) + Symbol$ + MID$(Text$, A + LEN(RTRIM$(RefData(I).Text)), LEN(Text$))„        OrigText& = OrigText& + LEN(RTRIM$(RefData(I).Text))„      END IF„      A = INSTR(Text$, RTRIM$(RefData(I).Text))„    WEND„  NEXT I„  PRINT #OutFile, Text$„  LOCATE 4, 1„  PRINT USING "Saved: ##,### bytes!"; OrigText& - (B * 2)„  PRINT USING "Compressed: ##.#% of file"; (OrigText& - (B * 2)) / FileBytes& * 100;„LOOP UNTIL EOF(InFile)„CLOSE InFile„CLOSE OutFile„„END SUB„„SUB DeCompressQBFile (InFile$, OutFile$)„„' Test on several different source codes, works about 99% of the time„' Seems to choke on badly written code though :)„„PRINT„PRINT„PRINT "Decompressing: "; InFile$„PRINT " Outputing to: "; OutFile$„„InFile = FREEFILE„OPEN InFile$ FOR BINARY AS InFile       ' Must watch for CHR$(13)„OutFile = FREEFILE„OPEN OutFile$ FOR OUTPUT AS OutFile„„FileBytes& = LOF(InFile)„„Pointer& = 1„CrLf$ = CHR$(13) + CHR$(10)„DO„  Text$ = SPACE$(256)                   ' Don't encode code with long lines„  GET #InFile, Pointer&, Text$„  Text$ = MID$(Text$, 1, INSTR(Text$, CrLf$) - 1)„  Pointer& = Pointer& + LEN(Text$) + 2„  FText$ = ""„  I = 1„  WHILE I < LEN(Text$)„    IF MID$(Text$, I, 1) = CHR$(ID) THEN„      Sym = ASC(MID$(Text$, I + 1, 1))„      IF Sym = 0 THEN Sym = 255 + ASC(MID$(Text$, I + 2, 1))„      X = Sym„      IF RefData(X).Symbol <> Sym THEN     ' In case you mess up the„        FOR X = 1 TO NumRef                ' reference chart.„          IF RefData(X).Symbol = Sym THEN EXIT FOR„        NEXT X„      END IF„      IF Sym > 255 THEN„        I = I + 2„      ELSE„        I = I + 1„      END IF„      FText$ = FText$ + RTRIM$(RefData(X).Text)„    ELSE„      FText$ = FText$ + MID$(Text$, I, 1)„    END IF„    I = I + 1„  WEND„  IF I = LEN(Text$) THEN FText$ = FText$ + MID$(Text$, I, 1)„  PRINT #OutFile, FText$„LOOP UNTIL Pointer& >= LOF(InFile)„CLOSE InFile„CLOSE OutFile„„END SUB„Denis Boyles                   4 FUNCTION CALCULATOR          FidoNet QUIK_BAS Echo          06-28-96 (02:33)       QB, QBasic, PDS        67   1660     CALCUL4.BAS ' > I am working on a calculator program, but the biggest problem is how„' > do I enter the numbers from right to left, instead of the normal left„' > to right?  I want to do this with INKEY$,„„' Here's my 00000011 bits worth. The following code I whipped up does that„' and serves as a simple 4 function calculator too. Perhaps it will give„' you some ideas.„„' Enter a number and it will move in left on the "display". Then pick a„' function and finally press = for your answer. You're not limited to single„' one time calculations either. You can keep going until you press = for„' the final result.„„' ie:„'  100 * 320 + 160 = 32160„„DECLARE FUNCTION GetNum$ (lcd$)„„CLS„PRINT "+---------+"„PRINT "|         |"„PRINT "+---------+"„„lcd$ = SPACE$(9)„op$ = GetNum(lcd$)„n& = VAL(LTRIM$(lcd$))„„DO„  SELECT CASE op$„    CASE "+"„      lcd$ = SPACE$(9)„      op$ = GetNum(lcd$)„      n& = n& + VAL(LTRIM$(lcd$))„„    CASE "-"„      lcd$ = SPACE$(9)„      op$ = GetNum(lcd$)„      n& = n& - VAL(LTRIM$(lcd$))„„    CASE "*"„      lcd$ = SPACE$(9)„      op$ = GetNum(lcd$)„      n& = n& * VAL(LTRIM$(lcd$))„„    CASE "/"„      lcd$ = SPACE$(9)„      op$ = GetNum(lcd$)„      n& = n& / VAL(LTRIM$(lcd$))„  END SELECT„LOOP UNTIL op$ = "="„„a$ = LTRIM$(STR$(n&))„lcd$ = SPACE$(9 - LEN(a$)) + a$„LOCATE 2, 2„PRINT lcd$„„FUNCTION GetNum$ (lcd$)„  DO„    key$ = INKEY$„    IF key$ >= "0" AND key$ <= "9" THEN„      lcd$ = MID$(lcd$, 2, 8) + key$„      LOCATE 2, 2„      PRINT lcd$„    END IF„  LOOP UNTIL key$ = "+" OR key$ = "-" OR key$ = "*" OR key$ = "/" OR key$ = "="„  GetNum$ = key$„END FUNCTION„Davey W. Taylor                ENIGMA CODER                   audio.squad@mailbox.swipnet.se 08-13-97 (08:25)       QB, QBasic, PDS        500  15687    ENIGMA.BAS  '⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ--ƒƒƒ--ƒ -˘  ˘„'≥                   ** ENIGMA CODER **„'≥                Created by Davey W Taylor„'≥„'≥ The ENIGMA machine was used by the germans during the„'≥ war to encrypt important messages so that the brittish„'≥ could not read them if they were intercepted. It uses„'≥ a very simple design and is simple to use and still„'≥ it is very hard to decrypt the messages after they„'≥ have been encrypted.. why? The ENIGMA machine uses a„'≥ very clever way of encrypting the message. Three„'≥ different rotors and reflector which all can be„'≥ changed. You would also have to know the start„'≥ positions of each rotor in order to decrypt the„'≥ message. On top of that there was a plugboard on the„'≥ front of the machine allowing the user to manually„'≥ switch any of the 26 characters. Anyway, what makes„'≥ it real hard to decrypt is that the rotors actually„'≥ change position. After every keypress the first„'≥ rotor changes position, when that one has passed through„'≥ one cycle(A to Z) the second one changes and the same„'≥ goes for the third one. This program uses the same way„'≥ of encrypting/decrypting messages and as far as I know„'≥ it should actually decrypt REAL ENIGMA messages if you„'≥ know how the needed rotors were constructed. This would„'≥ require some modification to the enigma: section though.„'≥ More information about the ENIGMA machine can be found„'≥ on the internet!„'≥„'≥ The above text might be a bit hard to understand since„'≥ my english spelling is not very good... sorry! :)„'≥ Anyway, I hopy you enjoy the program...„'¿ƒƒƒƒƒ--ƒƒ˘-  ˘   ˘„' ** If you have any comments / suggestions / questions, my email is: **„' ** audio.squad@mailbox.swipnet.se                                   **„„DECLARE SUB add (rot$, alpha$)„DECLARE SUB waitkey ()„DECLARE SUB XYWrite (x%, y%, char$)„„DIM rotora$(1 TO 24)                              'set variables„DIM names$(1 TO 24)„alpha$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ "„plugs$ = alpha$„rotor$ = "AAAA010101"„„RESTORE enigma                                    'read rotors„FOR n% = 1 TO 24„ READ rotora$(n%)„NEXT n%„„RESTORE greek                                     'read rotor names„FOR n% = 1 TO 24„ READ names$(n%)„NEXT n%„„ver$ = "1.9"„SCREEN 12„COLOR 7„„menu:                                             'main menu„CLS„PRINT "ENIGMA CODER " + ver$„PRINT„PRINT " L - Load File"„PRINT " S - Save File"„PRINT " P - Edit Plugboard"„PRINT " C - Change Rotors"„PRINT " I - Change Start Positions"„PRINT " F - Change Reflector"„PRINT " E - Encode"„PRINT " Q - Quit"„PRINT„PRINT " Plugbord Edited?         (     )"„PRINT " Current Rotors:          (         :         :         )"„PRINT " Current Start Positions: (    :    :    )"„PRINT " Current Reflector:       (         )"„„LOCATE 12, 29„IF plugs$ <> alpha$ THEN COLOR 12: PRINT "Yes": COLOR 7 ELSE PRINT "No"„LOCATE 13, 29„PRINT names$(INSTR(alpha$, MID$(rotor$, 1, 1)))„LOCATE 13, 39„PRINT names$(INSTR(alpha$, MID$(rotor$, 2, 1)))„LOCATE 13, 49„PRINT names$(INSTR(alpha$, MID$(rotor$, 3, 1)))„LOCATE 14, 29„PRINT LTRIM$(STR$(VAL(MID$(rotor$, 5, 2))))„LOCATE 14, 34„PRINT LTRIM$(STR$(VAL(MID$(rotor$, 7, 2))))„LOCATE 14, 39„PRINT LTRIM$(STR$(VAL(MID$(rotor$, 9, 2))))„LOCATE 15, 29„PRINT names$(INSTR(alpha$, MID$(rotor$, 4, 1)))„„DO„ SELECT CASE UCASE$(INKEY$)„  CASE "L"„   DO„    CLS„    PRINT "ENIGMA CODER " + ver$ + " LOAD FILE"„    PRINT„    LINE INPUT " Filename: ", file$„    IF file$ = "" THEN GOTO menu„    ok% = 1„    ON ERROR GOTO noload„    OPEN file$ FOR INPUT AS #1                    'open and check filesize,„    IF ok% = 1 THEN                               'letters etc...„     IF LOF(1) > 32000 THEN PRINT " File must not exceed 32 kbytes!": CLOSE #1„     file$ = INPUT$(LOF(1), #1)„     CLOSE #1„    END IF„    out$ = ""„    FOR n% = 1 TO LEN(file$)„     ch$ = UCASE$(MID$(file$, n%, 1))„     IF ch$ = CHR$(13) THEN ch$ = " "„     IF ch$ = CHR$(10) THEN ch$ = ""„     IF INSTR(alpha$ + extra$, ch$) = 0 THEN PRINT " File must only contain characters between A and Z!": waitkey: ERROR 0„     IF ok% = 0 THEN EXIT FOR„     out$ = out$ + ch$„    NEXT n%„    ON ERROR GOTO 0„   LOOP UNTIL ok%„   IF LEN(out$) = 0 THEN PRINT " File is empty!": waitkey: GOTO menu„   memory$ = out$„   GOTO menu„ „  CASE "S"„   DO„    CLS„    PRINT "ENIGMA CODER " + ver$ + " SAVE FILE"„    PRINT„    LINE INPUT " Filename: ", file$„    IF file$ = "" THEN GOTO menu„    ok% = 1„    ON ERROR GOTO nosave„    OPEN file$ FOR OUTPUT AS #1                   'save file„    IF ok% = 1 THEN„     PRINT #1, memory$;„     CLOSE #1„    END IF„    ON ERROR GOTO 0„   LOOP UNTIL ok%„   GOTO menu„ „  CASE "P"„   done% = 0„   DO„    CLS„    PRINT "ENIGMA CODER " + ver$ + " EDIT PLUGBOARD"„    PRINT„    PRINT " Use Letters To Swap. Ex: Pressing GA Would Swap G With A"„    PRINT " While In Swap, Press ESC To Abort"„    PRINT " Press ESC When Done Or Space To Reset"„   „    FOR n% = 1 TO 26                              'display plugboard„     p! = n% / 4.15„     CIRCLE (319 + COS(p!) * 100, 239 + SIN(p!) * 100), 5„     XYWrite 315 + COS(p!) * 120, 235 + SIN(p!) * 120, MID$(alpha$, n%, 1)„    NEXT n%„    FOR n% = 1 TO 26„     p! = n% / 4.15„     sx% = 319 + COS(p!) * 100„     sy% = 239 + SIN(p!) * 100„     p! = INSTR(alpha$, MID$(plugs$, n%, 1)) / 4.15„     ex% = 319 + COS(p!) * 100„     ey% = 239 + SIN(p!) * 100„     LINE (sx%, sy%)-(ex%, ey%), 12„    NEXT n%„   „    DO„     ok% = 1„     in$ = UCASE$(INKEY$)„     SELECT CASE in$„      CASE "A" TO "Z"„       sw$ = in$„       p! = INSTR(alpha$, sw$) / 4.15„       CIRCLE (319 + COS(p!) * 100, 239 + SIN(p!) * 100), 5, 12„       ok% = 0„       DO„        in$ = UCASE$(INKEY$)„        SELECT CASE in$„         CASE "A" TO "Z"„          swt$ = in$„          ok% = 1„         CASE CHR$(27): ok% = 2„        END SELECT„       LOOP UNTIL ok% > 0„      „       IF ok% = 1 THEN„        sp% = INSTR(alpha$, sw$)                  'calculate and swap letters„        ep% = INSTR(alpha$, swt$)„        nol% = 0„        IF MID$(plugs$, sp%, 1) <> MID$(alpha$, sp%, 1) THEN nol% = 1„        IF MID$(plugs$, ep%, 1) <> MID$(alpha$, ep%, 1) THEN nol% = 1„        IF MID$(plugs$, sp%, 1) = MID$(alpha$, ep%, 1) THEN nol% = 0„        IF nol% = 0 THEN„         s$ = MID$(plugs$, sp%, 1)„         MID$(plugs$, sp%, 1) = MID$(plugs$, ep%, 1)„         MID$(plugs$, ep%, 1) = s$„        ELSE„         BEEP                                     'beep if error„        END IF„       ELSE„        ok% = 1„       END IF„      CASE " ": plugs$ = alpha$„      CASE CHR$(27): done% = 1„      CASE ELSE: ok% = 0„     END SELECT„    LOOP UNTIL ok%„   LOOP UNTIL done%„   GOTO menu„ „  CASE "C"„   DO„    CLS„    PRINT "ENIGMA CODER " + ver$ + " CHANGE ROTORS"„    PRINT„    PRINT " Availavle Rotors:"„    PRINT "  ";„    FOR n% = 1 TO 24„     IF n% = 12 THEN PRINT CHR$(13); "  ";„     PRINT names$(n%);„     IF n% <> 24 THEN PRINT ", ";„    NEXT n%„    PRINT„    PRINT„    PRINT " Format: rotor: rotor: rotor"„    PRINT " Ex    : alfa: epsilon: pi"„    ok% = 1„    LINE INPUT " Rotors: ", rotr$„   „    IF rotr$ = "" THEN GOTO menu„    IF INSTR(rotr$, ":") = 0 THEN„     ok% = 0„    ELSE„     rot1$ = LTRIM$(RTRIM$(UCASE$(LEFT$(rotr$, INSTR(rotr$, ":") - 1))))„     rotr$ = MID$(rotr$, INSTR(rotr$, ":") + 1)„     IF INSTR(rotr$, ":") = 0 THEN„      ok% = 0„     ELSE„      rot2$ = LTRIM$(RTRIM$(UCASE$(LEFT$(rotr$, INSTR(rotr$, ":") - 1))))„      rotr$ = MID$(rotr$, INSTR(rotr$, ":") + 1)„      rot3$ = LTRIM$(RTRIM$(UCASE$(MID$(rotr$, INSTR(rotr$, ":") + 1))))„     END IF„    END IF„   LOOP UNTIL ok%„  „   o$ = ""                                        'find rotor names„   FOR n% = 1 TO 24„    IF UCASE$(names$(n%)) = rot1$ THEN o$ = o$ + MID$(alpha$, n%, 1): EXIT FOR„   NEXT n%„   IF n% = 25 THEN ok% = 0„   FOR n% = 1 TO 24„    IF UCASE$(names$(n%)) = rot2$ THEN o$ = o$ + MID$(alpha$, n%, 1): EXIT FOR„   NEXT n%„   IF n% = 25 THEN ok% = 0„   FOR n% = 1 TO 24„    IF UCASE$(names$(n%)) = rot3$ THEN o$ = o$ + MID$(alpha$, n%, 1): EXIT FOR„   NEXT n%„   IF n% = 25 THEN ok% = 0„   IF ok% = 0 THEN PRINT " Invalid rotor name!": waitkey: GOTO menu„   MID$(rotor$, 1, 3) = o$                        'change rotors„   GOTO menu„ „  CASE "I"„   DO„    CLS„    PRINT "ENIGMA CODER " + ver$ + " CHANGE START POSITIONS"„    PRINT„    PRINT " Format         : pos: pos: pos (1 to 26)"„    PRINT " Ex             : 1: 7: 5"„    ok% = 1„    LINE INPUT " Start Positions: ", rotr$„    IF rotr$ = "" THEN GOTO menu„    IF INSTR(rotr$, ":") = 0 THEN„     ok% = 0„    ELSE„     rot1% = VAL(LTRIM$(RTRIM$(UCASE$(LEFT$(rotr$, INSTR(rotr$, ":") - 1)))))„     rotr$ = MID$(rotr$, INSTR(rotr$, ":") + 1)„     IF INSTR(rotr$, ":") = 0 THEN„      ok% = 0„     ELSE„      rot2% = VAL(LTRIM$(RTRIM$(UCASE$(LEFT$(rotr$, INSTR(rotr$, ":") - 1)))))„      rotr$ = MID$(rotr$, INSTR(rotr$, ":") + 1)„      rot3% = VAL(LTRIM$(RTRIM$(UCASE$(MID$(rotr$, INSTR(rotr$, ":") + 1)))))„     END IF„    END IF„   LOOP UNTIL ok%„  „   IF rot1% < 1 OR rot1% > 26 THEN ok% = 0        'check positions„   IF rot2% < 1 OR rot2% > 26 THEN ok% = 0„   IF rot3% < 1 OR rot3% > 26 THEN ok% = 0„   IF ok% = 1 THEN„    IF rot1% < 10 THEN rot1$ = "0" ELSE rot1$ = ""„    IF rot2% < 10 THEN rot2$ = "0" ELSE rot2$ = ""„    IF rot3% < 10 THEN rot3$ = "0" ELSE rot3$ = ""„    rot1$ = rot1$ + LTRIM$(STR$(rot1%))„    rot2$ = rot2$ + LTRIM$(STR$(rot2%))„    rot3$ = rot3$ + LTRIM$(STR$(rot3%))„    o$ = rot1$ + rot2$ + rot3$„    MID$(rotor$, 5, 6) = o$                       'change positions„   ELSE„    PRINT " Invalid start positions!"„    waitkey„   END IF„   GOTO menu„ „  CASE "F"„   DO„    CLS„    PRINT "ENIGMA CODER " + ver$ + " CHANGE REFLECTOR"„    PRINT„    PRINT " Availavle Reflectors:"„    PRINT "  ";„    FOR n% = 1 TO 24„     IF n% = 12 THEN PRINT CHR$(13); "  ";„     PRINT names$(n%);„     IF n% <> 24 THEN PRINT ", ";„    NEXT n%„    PRINT„    PRINT„    ok% = 1„    LINE INPUT " Reflector: ", rotr$„    IF rotr$ = "" THEN GOTO menu„    refc$ = LTRIM$(RTRIM$(UCASE$(rotr$)))„    FOR n% = 1 TO 24                              'find reflector name„     IF UCASE$(names$(n%)) = refc$ THEN o$ = MID$(alpha$, n%, 1): EXIT FOR„    NEXT n%„    IF n% = 25 THEN ok% = 0„    IF ok% = 0 THEN PRINT " Invalid reflector name!": waitkey„   LOOP UNTIL ok%„  „   MID$(rotor$, 4, 1) = o$                        'change reflector„   GOTO menu„ „  CASE "E"„   CLS„   PRINT "ENIGMA CODER " + ver$ + " ENCODE"„   PRINT„   rot1% = VAL(MID$(rotor$, 5, 2))                'get the three rotors„   rot1$ = rotora$(INSTR(alpha$, MID$(rotor$, 1, 1))) 'and their positions„   rot2% = VAL(MID$(rotor$, 7, 2))„   rot2$ = rotora$(INSTR(alpha$, MID$(rotor$, 2, 1)))„   rot3% = VAL(MID$(rotor$, 9, 2))„   rot3$ = rotora$(INSTR(alpha$, MID$(rotor$, 3, 1)))„   refc$ = rotora$(INSTR(alpha$, MID$(rotor$, 4, 1)))„  „   FOR n% = 1 TO rot1% - 1                        'rotate all rotors to their„    n$ = LEFT$(rot1$, 1)                          'start positions„    rot1$ = MID$(rot1$, 2) + n$„    add rot1$, alpha$„   NEXT n%„   FOR n% = 1 TO rot2% - 1„    n$ = LEFT$(rot2$, 1)„    rot2$ = MID$(rot2$, 2) + n$„    add rot2$, alpha$„   NEXT n%„   FOR n% = 1 TO rot3% - 1„    n$ = LEFT$(rot3$, 1)„    rot3$ = MID$(rot3$, 2) + n$„    add rot3$, alpha$„   NEXT n%„  „   LOCATE 14, 2: PRINT STRING$(79, "-")„   ty% = 3: tx% = 2„   by% = 15: bx% = 2„  „   FOR n% = 1 TO LEN(memory$)„    VIEW PRINT 3 TO 12„    i$ = MID$(memory$, n%, 1)„    LOCATE ty%, tx%„    PRINT i$;„    ty% = CSRLIN: tx% = POS(0)„    IF tx% = 1 THEN tx% = 2„    VIEW PRINT 15 TO 24„    o$ = i$„   „    IF o$ <> " " THEN„     o$ = MID$(plugs$, INSTR(alpha$, o$), 1)      'this part is the actual„     o$ = MID$(rot1$, INSTR(alpha$, o$), 1)       'encoding. This is the„     o$ = MID$(rot2$, INSTR(alpha$, o$), 1)       'way the electricity would„     o$ = MID$(rot3$, INSTR(alpha$, o$), 1)       'flow through a real enigma„     o$ = MID$(refc$, INSTR(alpha$, o$), 1)       'machine: first through the„     o$ = MID$(rot3$, INSTR(alpha$, o$), 1)       'plugbord then through the„     o$ = MID$(rot2$, INSTR(alpha$, o$), 1)       'rotors, through the„     o$ = MID$(rot1$, INSTR(alpha$, o$), 1)       'reflector and back again!„     o$ = MID$(plugs$, INSTR(alpha$, o$), 1)„     MID$(memory$, n%, 1) = o$„    END IF„   „    FOR z% = 1 TO INSTR(alpha$, o$)„     LOCATE by%, bx%: PRINT MID$(alpha$, z%, 1);„    NEXT z%„„    by% = CSRLIN: bx% = POS(0)„    IF bx% = 1 THEN bx% = 2„    IF o$ <> " " THEN„     n$ = LEFT$(rot1$, 1)                         'rotate rotor 1„     rot1$ = MID$(rot1$, 2) + n$„     add rot1$, alpha$„     rot1% = rot1% + 1„     IF rot1% = 27 THEN„      rot1% = 1„      n$ = LEFT$(rot2$, 1)                        'rotate rotor 2„      rot2$ = MID$(rot2$, 2) + n$„      add rot2$, alpha$„      rot2% = rot2% + 1„      IF rot2% = 27 THEN„       rot2% = 1„       n$ = LEFT$(rot3$, 1)                       'rotate rotor 3„       rot3$ = MID$(rot3$, 2) + n$„       add rot3$, alpha$„       rot3% = rot3% + 1„       IF rot3% = 27 THEN rot3% = 1„      END IF„     END IF„    END IF„  „   NEXT n%„   VIEW PRINT„   LOCATE 25, 60„   PRINT "Press Any Key!"„   waitkey„   GOTO menu„ „  CASE "Q"„   WIDTH 80, 25„   PRINT "Thank you for using the ENIGMA CODER!"„   END„ END SELECT„LOOP„„noload:                                           'file load error handling„ok% = 0„PRINT " Can't load file!"„waitkey„RESUME NEXT„„nosave:                                           'file save error handling„ok% = 0„PRINT " Can't save file!"„waitkey„RESUME NEXT„„greek:                                            'the greek alphabet„                                                  '(used as rotor names)„DATA Alpha, Beta, Gamma, Delta, Epsilon, Zeta, Eta, Teta, Jota, Kappa, Lambda„DATA My, Ny, Ksi, Omikron, Pi, Ro, Sigma, Tau, Ypsilon, Fi, Chi, Psi, Omega„„enigma:                                           'information on the wiring„                                                  'of each rotor„DATA QXKSGVERLWCINMZYAHDUTFJBPO„DATA IXLOHQUEAMWCJTDSFYPNGZKBRV„DATA IMPGHVDEAUZQBTRCLOYNJFXWSK„DATA JXYRKUNVLAEIZGSWTDOQFHPBCM„DATA KGLHZQBDSTACNMURFPIJOYXWVE„DATA QMVIGLEJDHWFBSZXAUNYRCKPTO„DATA DQMAVTLKYRHGCONSBJPFWEUZIX„DATA GJUVZTARPBMQKSWILHNFCDOYXE„DATA ODTBKMIXGZEWFSAYRQNCVULHPJ„DATA IMRTKJNLAFEHBGSUWCODPZQYXV„DATA IRMNXYWVAZQOCDLSKBPUTHGEFJ„DATA DQOAVXSYULMJKTCZBWGNIERFHP„DATA MXNJQZVWYDRUACPOEKTSLGHBIF„DATA PDIBKRJQCGESZONAHFLXWYUTVM„DATA QHXLYTUBOMVDJZISAWPFGKRCEN„DATA CXATHNUEQWZYPFVMISRDGOJBLK„DATA EPNYAXITGRUSQCZBMJLHKWVFDO„DATA MYWSJVNIHELKAGZTXUDPRFCQBO„DATA XCBRYLITGMNFJKWQPDZHVUOAES„DATA FLSQOAZXKYIBPUEMDVCWNRTHJG„DATA OLRGJYDSNEVBWIATXCHPZKMQFU„DATA LSOEDKPYRQFAWZCGJIBXVUMTHN„DATA COALZWJMPGTDHUBIVSRKNQFYXE„DATA PZYUWTRVOSMXKQIANGJFDHELCB„„SUB add (rot$, alpha$)„ FOR n% = 1 TO LEN(rot$)„  i% = INSTR(alpha$, MID$(rot$, n%, 1)) - 1„  IF i% = 0 THEN i% = 26„  MID$(rot$, n%, 1) = MID$(alpha$, i%, 1)„ NEXT n%„END SUB„„SUB waitkey„ DO: LOOP WHILE INKEY$ = ""„END SUB„„SUB XYWrite (x%, y%, char$)„ DEF SEG = &HF000„ FOR py% = 0 TO 7„  r% = PEEK(&HFA63 + 11 + (ASC(char$) * 8) + py%)„  FOR px% = 0 TO 7„   IF r% AND (2 ^ px%) THEN PSET ((7 - px%) + x%, py% + y%)„  NEXT px%„ NEXT py%„ DEF SEG„END SUB„J. W. Dare                     INFIX EXPRESSION EVALUATOR     jwdare@novia.net               08-17-97 (02:58)       QB, QBasic, PDS        525  19632    MATH1.BAS   'Filename: MATH1.BAS„'QBasic/QB4.5„'jwdare@novia.net„'„'MATH1.BAS is a mathematical expression evaluator which converts an Infix„'(standard calculator) expression to a Postfix expression and then solves„'the equation.  The program is capable of handling the main arithmetic„'operations along with exponents, basic trig functions, the Pi constant,„'and one variable (X).  The input is case insensitive.„'Valid operators are:„'„'                +,  -,  * , /,  ^, SIN, COS, TAN, PI, and X for variable„'„'Negative numbers must be enclosed in parentheses, for example (-5) or„'(-(2+X)).  Commas are allowed in numeric expressions, for example„'987,654,321 is valid.  White space in input expression is ignored.„'„'The program uses MS Basic conventions such as disallowing raising any„'negative number to a non-integer power.   The program may be modified to„'alter these conventions.„'„'Math1.bas takes an input mathematical expression string, Math.in$.  The„'Subroutine Prep then "standardizes" the string.  The standardized Math.in$„'is then passed to the Subroutine Postfix which converts Math.in$ to the„'Postfix expression Math.fix$.  Math.fix$ is then passed to the Subroutine„'Calc which  evaluates the Postfix expression.„'„'Most of the following routines could be optimized by using the ASC function„'to convert ASCII characters to their numeric value and then doing integer„'comparisons.„'„'--------------- Program error codes„'„'     ERROR.CODE% =„'0 = NO DETECTED ERRORS„'1 = SYNTAX ERROR„'2 = PARENTHESES MISCOUNT„'3 = DIVISION BY 0 ERROR„'4 = RAISE NEG NUMBER TO NON-INTEGER POWER (SQR ROOT OF NEG NUMBER, ECT..)„'5 = DISALLOWED CHARACTER„'6 = DECIMAL POINT ERROR„'-----------------------------------------„'The main module variables are:„'        Math.in$ = The input expression„'        Math.fix$ = The Mathin$ expression converted to Postfix form„'        X = The user defined variable„'        Error.code% = 0 if no errors, otherwise contains error number„'        PFix.Stack$() = String array used in Sub Postfix„'        Val.Stack() =   Single precision array used in Sub Calc„'        Pi = 4 * ATN(1), the value of Pi„'        Deg.flg% = -1 if input angles are in degrees, 0 if in radians„'-----------------------------------------„„„DECLARE FUNCTION PrepString$ (Pstr$)„   'Used in SUB Prep„   'Converts lcase to ucase, removes spaces and commas„   'Converts negation to CHR$(22)„„DECLARE SUB Functnams (Math.In$, Math.test$, Fun$, Char$)„   'Used in SUB Prep„   'Replaces multiple character function names with„   'single representitive character and creates string for„   'illegal character detection.„„DECLARE FUNCTION Parenth.Cnt% (Cnt.str$)„   '0 if "(" and ")" count equal„„DECLARE FUNCTION Legal.Char% (Strin$)„   'Used in SUB prep to check for invalid characters.„„DECLARE FUNCTION String.Priority% (Test.Char$)„    'Used in SUB Postfix„    'Determines currently scanned character's priority value„    'Test.Char$ = Current Math.fix$ character„„DECLARE FUNCTION Stack.Priority% (Test.Char$)„    'Used in SUB Postfix„    'Determines the priority value of operators stored in the stack„    'Test.Char$ = Top stack character„„DECLARE FUNCTION Decim.Cnt% (Strin$)„    'Used in SUB Calc to test for correct number (1) of„    'decimal points in a numaric string (Val.tmp$).„„DECLARE SUB Prep (Strin$, Error.Code%)„DECLARE SUB Postfix (Math.In$, Math.Fix$, PFix.Stack$())„DECLARE SUB Calc (Math.Fix$, Val.Stack(), X, Final.val, Error.Code%, Deg.flg%, Pi)„„„DIM Val.Stack(50)    'picked 50 arbitrarily„DIM PFix.Stack$(50)„Pi = 4 * ATN(1)„Error.Code% = 0„„'--------- Test input„„Deg.flg% = -1     '-1 for degree calculations, 0 for radian calculations.„X = 5             'Set to any value for testing use of a variable.„„LINE INPUT "Enter an expression: "; Math.In$„„„'-------------- Main module„IF LEN(Math.In$) THEN„   CALL Prep(Math.In$, Error.Code%)„   IF Error.Code% = 0 THEN„      CALL Postfix(Math.In$, Math.Fix$, PFix.Stack$())„     „         'The Sub Calc may be placed in a loop to solve for„         'multiple values of X„      CALL Calc(Math.Fix$, Val.Stack(), X, Final.val, Error.Code%, Deg.flg%, Pi)„  „   END IF„ELSE„   Error.Code% = 5„END IF„„'-------------- Test output„PRINT„PRINT "Math.In$ = "; Math.In$„PRINT "Math.fix$ = "; Math.Fix$„PRINT„„   IF Error.Code% = 0 THEN„      PRINT "Final.val ="; Final.val„   ELSE„      PRINT "Error code #"; LTRIM$(STR$(Error.Code%))„   END IF„PRINT„„END„„'        The Calc subroutine is used to solve the Postfix expression„'Math.Fix$.  This is accomplished by scanning Math.Fix$ one character at a„'time, from left to right.  Operands and temporary results are store in the„'single precision array, Val.Stack(), which is a stack addressed by„'Valstk.pntr%.„'        Numeric string characters are stored in a temporary variable„'(Val.Temp$) until a comma is encountered.  The comma signals the program„'to increment the pointer,  convert the numeric string to a single„'precision numeric value, then store the numeric value in the top position„'of Val.Stack().  Likewise, constants and the value contained in the„'variable (X) are stored on the top of the stack when encountered.„'        If an operator that only requires one operand such as trig„'functions or negation, is scanned, the function/operation is applied to„'the top value in the stack.  If an operator requiring two operators such„'as addition, subtraction, multiplication, or division, is the current„'scanned character, the top value is pulled from the stack, the stack„'pointer is decremented by one, and that value is also pulled from the stack.„'The operation is performed on these two operands and then the results of„'the operation is stored in the current stack position.„'„SUB Calc (Math.Fix$, Val.Stack(), X, Final.val, Error.Code%, Deg.flg%, Pi)„   Valstk.pntr% = 0„   Val.tmp$ = ""„   Co.ef1 = 0„   Co.ef2 = 0„   Test.str1$ = "0123456789."       'numerics„   Test.str2$ = "SCT"               'functions„FOR i% = 1 TO LEN(Math.Fix$)„  „   Crnt.Char$ = MID$(Math.Fix$, i%, 1)„  „   IF INSTR(Test.str1$, Crnt.Char$) THEN„      Val.tmp$ = Val.tmp$ + Crnt.Char$„   ELSEIF INSTR(Test.str2$, Crnt.Char$) THEN„      IF Deg.flg% THEN              'Convert degree input to radian„         Val.Stack(Valstk.pntr%) = Val.Stack(Valstk.pntr%) * Pi / 180„      END IF„     „      IF Crnt.Char$ = "S" THEN„         Val.Stack(Valstk.pntr%) = SIN(Val.Stack(Valstk.pntr%))„      ELSEIF Crnt.Char$ = "C" THEN„         Val.Stack(Valstk.pntr%) = COS(Val.Stack(Valstk.pntr%))„      ELSEIF Crnt.Char$ = "T" THEN„         Val.Stack(Valstk.pntr%) = TAN(Val.Stack(Valstk.pntr%))„      END IF„   ELSE„      IF Crnt.Char$ = "," THEN„         Error.Code% = Decim.Cnt%(Val.tmp$)  'Test for multiple decimal points„         IF Error.Code% = 0 THEN„            Valstk.pntr% = Valstk.pntr% + 1„            Val.Stack(Valstk.pntr%) = VAL(Val.tmp$)   'Add number to stack„            Val.tmp$ = ""„         ELSE„            EXIT FOR„         END IF„      ELSEIF Crnt.Char$ = "P" THEN„         Valstk.pntr% = Valstk.pntr% + 1„         Val.Stack(Valstk.pntr%) = Pi„      ELSEIF Crnt.Char$ = "X" THEN„         Valstk.pntr% = Valstk.pntr% + 1„         Val.Stack(Valstk.pntr%) = X„      ELSEIF Crnt.Char$ = CHR$(22) THEN„         Val.Stack(Valstk.pntr%) = -Val.Stack(Valstk.pntr%)„      ELSEIF Crnt.Char$ = "*" THEN„         Co.ef2 = Val.Stack(Valstk.pntr%)„            Valstk.pntr% = Valstk.pntr% - 1„         Co.ef1 = Val.Stack(Valstk.pntr%)„         Val.Stack(Valstk.pntr%) = Co.ef1 * Co.ef2„      ELSEIF Crnt.Char$ = "/" THEN„         Co.ef2 = Val.Stack(Valstk.pntr%)„         IF Co.ef2 <> 0 THEN                       'Test for divide by 0„               Valstk.pntr% = Valstk.pntr% - 1„            Co.ef1 = Val.Stack(Valstk.pntr%)„            Val.Stack(Valstk.pntr%) = Co.ef1 / Co.ef2„         ELSE„            Error.Code% = 3„            EXIT FOR„         END IF„      ELSEIF Crnt.Char$ = "+" THEN„         Co.ef2 = Val.Stack(Valstk.pntr%)„            Valstk.pntr% = Valstk.pntr% - 1„         Co.ef1 = Val.Stack(Valstk.pntr%)„         Val.Stack(Valstk.pntr%) = Co.ef1 + Co.ef2„      ELSEIF Crnt.Char$ = "-" THEN„         Co.ef2 = Val.Stack(Valstk.pntr%)„            Valstk.pntr% = Valstk.pntr% - 1„         Co.ef1 = Val.Stack(Valstk.pntr%)„         Val.Stack(Valstk.pntr%) = Co.ef1 - Co.ef2„      ELSEIF Crnt.Char$ = "^" THEN„         Co.ef2 = Val.Stack(Valstk.pntr%)„            Valstk.pntr% = Valstk.pntr% - 1„         Co.ef1 = Val.Stack(Valstk.pntr%)„         Pwr.tmp = Co.ef2 - FIX(Co.ef2)       'test for non-integer value„         IF Co.ef1 < 0 AND Pwr.tmp <> 0 THEN„            Error.Code% = 4„            EXIT FOR„         ELSE„            Val.Stack(Valstk.pntr%) = Co.ef1 ^ Co.ef2„         END IF„      END IF„   END IF„NEXT i%„„IF Error.Code% = 0 THEN„   IF Valstk.pntr% = 1 THEN         'Program has reached bottom of stack„      Final.val = Val.Stack(Valstk.pntr%)„   ELSE„      Error.Code% = 1               'Probable input syntax error„   END IF„END IF„„END SUB„„'Makes sure there's only one decimal point in Strin$, returns error #6 if„'multiple decimal points exits in a numeric exprssion (input error checking.)„'„FUNCTION Decim.Cnt% (Strin$)„   flag% = 0„   Position% = 1„   Test% = 0„   Decim.Cnt% = 0„   DO„      Test% = INSTR(Position%, Strin$, ".")„      IF Test% THEN„         IF flag% THEN„            Decim.Cnt% = 6„            EXIT DO„         ELSE„            Position% = Test% + 1„            flag% = NOT flag%„         END IF„      END IF„   LOOP UNTIL Test% = 0„„END FUNCTION„„'Replaces Math.in$ function names with single representitive character.„'Math.test$ is a control used by the Legal.Char%() function to check for„'invalid characters later in Sub Prep„'„SUB Functnams (Math.In$, Math.test$, Fun$, Char$)„DO„   Place% = INSTR(Math.In$, Fun$)„   IF Place% THEN„     „      Str.1$ = LEFT$(Math.In$, (Place% - 1))„      Str.2$ = RIGHT$(Math.In$, (LEN(Math.In$) - (LEN(Str.1$) + LEN(Fun$))))„      Math.In$ = Str.1$ + Char$ + Str.2$„     „      'Used by function Legal.Char%() for input error testing„      Str.1test$ = LEFT$(Math.test$, (Place% - 1))„      Str.2test$ = RIGHT$(Math.test$, (LEN(Math.test$) - (LEN(Str.1$) + LEN(Fun$))))„      Math.test$ = Str.1test$ + SPACE$(1) + Str.2test$„   END IF„LOOP WHILE Place%„END SUB„„'Tests a control string for invalid characters (input error checking.)„'Returns error #5 if error detected.„'„FUNCTION Legal.Char% (Strin$)„   Test.str$ = "01234567890.X()+-*/^ " + CHR$(22)„   flag% = 0„   Cnt% = 0„   DO„      Cnt% = Cnt% + 1„      IF INSTR(Test.str$, MID$(Strin$, Cnt%, 1)) = 0 THEN flag% = 1„   LOOP UNTIL Cnt% = LEN(Strin$) OR flag%„   IF flag% THEN„      Legal.Char% = 5„   ELSE„      Legal.Char% = 0„   END IF„   „END FUNCTION„„'Counts parentheses, returns an error #2 if parentheses miscount occurs (input„'error checking.)„'„FUNCTION Parenth.Cnt% (Cnt.str$)„   Open.Parcnt% = 0„   Close.Parcnt% = 0„   FOR i% = 1 TO LEN(Cnt.str$)„      IF MID$(Cnt.str$, i%, 1) = "(" THEN„         Open.Parcnt% = Open.Parcnt% + 1„      ELSEIF MID$(Cnt.str$, i%, 1) = ")" THEN„         Close.Parcnt% = Close.Parcnt% + 1„      END IF„      IF Close.Parcnt% > Open.Parcnt% THEN EXIT FOR„   NEXT i%„   IF (Open.Parcnt% - Close.Parcnt%) THEN„      Parenth.Cnt% = 2„   ELSE„      Parenth.Cnt% = 0„   END IF„END FUNCTION„„'Sub for converting infix (Math.In$) to postfix (Matfix$)„'        The Postfix subroutine contains the code that scans the Infix„'expression, Math.In$, and creates the Postfix (polish notation) expression„'Math.Fix$.  Postfix expressions differ from standard Infix expressions in„'that the math operator follows the two operands instead of being placed„'between them, and also, parentheses are not needed.  The use of comma„'delimiters is my own embellishment.„'For example:„'„'    Infix:                  Postfix:„'    -----------             -------------„'    3+2                     3,2,+„'    (3+2)*(6-5)             3,2,+6,5,-*„'    2^8/256                 2,8,^256,/„'„'       This is done with the use of two functions, String.Priority%() and„'Stack.Priority%(), and the PFix.Stack$ array which serves as a stack to„'store mathematical operators.„'        The Math.In$ string is scanned, left to right.  Each scanned„'number is added directly to the right end of Math.Fix$, with a comma added„'to the end of each complete numeric expression.  Constants and variables are„'added directly to the right end of Math.Fix$ also, but no trailing comma is„'added.  The trailing comma after each numeric expression is used by the„'Calc subroutine as an "end of numeric string" flag.„'        The two functions are used to determine the "priority" of scanned„'operators or parentheses.  String.Priority%() assigns a priority value to„'the currently scanned Math.In$ operator.  Stack.Priority%() assigns a„'value to operators stored in the PFix.Stack$ array.  Their priority„'values are:„'„'    Operator                String.Priority%()      Stack.Priority%()„'    --------                ------------------      -----------------„'    (                       0                       6„'    Trig Function           1                       1„'    Negative  number        2                       2„'    ^                       3                       3„'    * or /                  4                       4„'    + or -                  5                       5„'„'        If the scanned character is an operator or opening parenthesis„'then the priority of the top operator on the stack is checked.  If the„'stack operator's Stack.Priority% is equal or less than the currently„'scanned operator's String.Priority% then the stack operator is added to„'the right end of Math.Fix$, the stack pointer (PfixStk.Pntr%) is decremented„'by one, and the next operator on the stack is compared to the currently„'scanned operator.  When the Stack.Priority% value of the top stack„'operator is greater than the String.Priority% of the currently scanned„'operator, then the stack pointer is incremented by one and the currently„'scanned operator is added to the stack.„'        If the scanned operator is a closing parenthesis, then each stack„'operator is pulled off the stack and added to the right of Math.Fix$ until„'an opening parenthesis is encountered in the stack.  After the last„'Math.In$ character is scanned and processed, any remaining operators in„'the stack are pulled one at a time and added to the right end of Math.Fix$.„'„'note, CHR$(22) denotes a negative number„'„SUB Postfix (Math.In$, Math.Fix$, PFix.Stack$())„   true% = -1„   false% = NOT true%„   Crnt.Char$ = ""„   Test.str1$ = "0123456789."„   Test.str2$ = "+-*/^SCT()XP" + CHR$(22)„   Begin.num% = true%„   PfixStk.Pntr% = 0„   Math.Fix$ = ""„„FOR i% = 1 TO LEN(Math.In$)„   Crnt.Char$ = MID$(Math.In$, i%, 1)„  „   IF INSTR(Test.str1$, Crnt.Char$) THEN           'Process numerics„      Math.Fix$ = Math.Fix$ + Crnt.Char$„      Begin.num% = false%„   ELSEIF INSTR(Test.str2$, Crnt.Char$) THEN„     „      IF NOT Begin.num% THEN„         Math.Fix$ = Math.Fix$ + ","„         Begin.num% = true%„      END IF„     „      IF Crnt.Char$ = "X" OR Crnt.Char$ = "P" THEN 'Process constants/variables„         Math.Fix$ = Math.Fix$ + Crnt.Char$„      ELSE                                         'Process operators„         repeat% = true%„         DO„            IF Crnt.Char$ = ")" THEN„               IF PFix.Stack$(PfixStk.Pntr%) = "(" THEN„                  repeat% = false%„               ELSE„                  Math.Fix$ = Math.Fix$ + PFix.Stack$(PfixStk.Pntr%)„               END IF„               PfixStk.Pntr% = PfixStk.Pntr% - 1„            ELSE„               IF Stack.Priority%(PFix.Stack$(PfixStk.Pntr%)) <= String.Priority%(Crnt.Char$) AND PfixStk.Pntr% > 0 THEN„                  Math.Fix$ = Math.Fix$ + PFix.Stack$(PfixStk.Pntr%)„                  PfixStk.Pntr% = PfixStk.Pntr% - 1„               ELSE„                  PfixStk.Pntr% = PfixStk.Pntr% + 1„                  PFix.Stack$(PfixStk.Pntr%) = Crnt.Char$„                  repeat% = false%„               END IF„            END IF„         LOOP WHILE repeat%„      END IF„  „   END IF„NEXT i%„  „IF NOT Begin.num% THEN Math.Fix$ = Math.Fix$ + ","„     „      'Add any remaining operators to Math.Fix$„DO UNTIL PfixStk.Pntr% = 0„   Math.Fix$ = Math.Fix$ + PFix.Stack$(PfixStk.Pntr%)„   PfixStk.Pntr% = PfixStk.Pntr% - 1„LOOP„„END SUB„„'        The Prep subroutine prepares the Math.In$ string for later„'evaluation by the Postfix subroutine.„'        First, Math.In$ is passed to the Prepstring$ function which„'removes spaces and commas, and assigns CHR$(22) to denote negative„'numbers.  It also converts all letters to upper case.  Math.In$ is then„'checked for proper parentheses count by the Parenth.Cnt% function.„'       Next, Math.In$ is passed to a series of the subroutine Functnams„'which replaces function names such a "SIN" with a single representative„'character, in this case "S".  The sub Functnams also creates a test string,„'Math.Test$, which is scanned by the Legal.Char% function for remaining„'invalid characters.„'„SUB Prep (Math.In$, Error.Code%)„   Math.In$ = PrepString$(Math.In$)„   Error.Code% = Parenth.Cnt%(Math.In$)„   IF Error.Code% = 0 THEN„      Math.test$ = Math.In$„      CALL Functnams(Math.In$, Math.test$, "SIN", "S")„      CALL Functnams(Math.In$, Math.test$, "COS", "C")„      CALL Functnams(Math.In$, Math.test$, "TAN", "T")„      CALL Functnams(Math.In$, Math.test$, "PI", "P")„      Error.Code% = Legal.Char%(Math.test$)„   END IF„END SUB„„'Removes spaces and commas from input string, converts negation to a CHR$(22),„'and converts all letters to upper case.„'„FUNCTION PrepString$ (Pstr$)„   Pstr.tmp$ = ""„   Prev.b$ = ""„   FOR i% = 1 TO LEN(Pstr$)„      b$ = MID$(Pstr$, i%, 1)„      IF b$ <> " " AND b$ <> "," THEN„         IF b$ = "-" AND Prev.b$ = "(" THEN b$ = CHR$(22)„         Pstr.tmp$ = Pstr.tmp$ + b$„      END IF„      Prev.b$ = b$„   NEXT i%„   PrepString$ = UCASE$(Pstr.tmp$)„END FUNCTION„„'Determines the priority value of the current operator from the stack.„'„FUNCTION Stack.Priority% (Test.Char$)„   IF Test.Char$ = "(" THEN„      Stack.Priority% = 6„   ELSEIF Test.Char$ = "S" OR Test.Char$ = "C" OR Test.Char$ = "T" THEN„      Stack.Priority% = 1„   ELSEIF Test.Char$ = CHR$(22) THEN„      Stack.Priority% = 2„   ELSEIF Test.Char$ = "^" THEN„      Stack.Priority% = 3„   ELSEIF Test.Char$ = "*" OR Test.Char$ = "/" THEN„      Stack.Priority% = 4„   ELSEIF Test.Char$ = "+" OR Test.Char$ = "-" THEN„      Stack.Priority% = 5„   END IF„END FUNCTION„„'Determines the priority of the current Math.Fix$ test character.„'„FUNCTION String.Priority% (Test.Char$)„   IF Test.Char$ = "(" THEN„      String.Priority% = 0„   ELSEIF Test.Char$ = "S" OR Test.Char$ = "C" OR Test.Char$ = "T" THEN„      String.Priority% = 1„   ELSEIF Test.Char$ = CHR$(22) THEN„      String.Priority% = 2„   ELSEIF Test.Char$ = "^" THEN„      String.Priority% = 3„   ELSEIF Test.Char$ = "*" OR Test.Char$ = "/" THEN„      String.Priority% = 4„   ELSEIF Test.Char$ = "+" OR Test.Char$ = "-" THEN„      String.Priority% = 5„   END IF„END FUNCTION„Michael S. Halpin              MATHEMATICAL FUNCTIONS         calvarygames@juno.com          08-27-97 (18:40)       QB, QBasic, PDS        415  16032    FUNCTION.BAS'Function.Bas„'       By Michael S. Halpin„'„'This program is released to public domain.  Anyone may incorporate any part„'or the entire program into theirs.  All I as in return is a little credit.„'Just put my name in the credits under special thanks to or a similar category.„'If you were not going to use credits well you are going to now.  And if you„'are one of those infringing gluttons that hog all the credit then you don't„'belong on the internet.  And don't use this program.  If you do and don't„'give me credit, and I do check, and I find out about it I will boycott you„'and you software and hunt you for the rest of your days.  All this can be„'avoided if you just give me credit.„'„'Copyright 1997-98„'       Michael S. Halpin„'               All Rights Reserved.„'„'If you have any questions, comments, or concerns you can contact me at CalvaryGames@Juno.Com.„'You can check us out on the web at http://members.aol.com/calvrygame„'„'! ! ! ! ! ! ! ! ! Attention all QB 4.5 Users ! ! ! ! ! ! ! ! ! ! !„'Some of the function like Hex2Dec and Oct2Dec may not work well with„'QB 4.5 due to it inability to properly calculate numbers.  You may get an„'over flow error.  This is NOT my fault I will try to find away around this„'for the future.  It should work fine in Power Basic.„'„'* * * * * * Built-In Mathematical Basic Functions * * * * * * *„'„'Declare Function Int(Number)        'Converts Decimals to lowest possible integers.„'Declare Function Hex$(Number)       'Converts Integers to hexidecimal.„'Declare Function Oct$(Number)       'Converts integers to octal.„'Declare Function Abs$(Number)       'Sets a number to absolute value. (1 = 1, -1 = 1)„'Declare Function Sqr(Number)        'Finds the square rood of a number.„'Declare Function Sgn(Number)        'Tells wether a number is positiver, negative, or zero.„'Declare Function Sin(Number)        'Returns the sine of a number.„'Declare Function Cos(Number)        'Returns the cosine of a number.„'Declare Function Log(Number)        'Returns the logarithm of a number (Base E).„'Declare Function Tan(Number)        'Returns the tangent of a number„'Declare Function Val(String)        'Returns the value of a string. (thus "2443" = 2443)„'Declare Funtion CInt(Number)        'Rounds a decimal to an integer using the first number after the decimal.  (eg. 1.5 = 2 but 1.45 = 1)„'„'* * * * * * Extended Mathematical Basic Functions * * * * * * *„DECLARE FUNCTION XRoot (X, Number)              'Finds the X root of the Number.  (Ex. XRoot(4, 81) = 4 | (4*4*4*4)=81)„DECLARE FUNCTION XLog (X, Number)               'Finds the log of the Number using the Base X.„DECLARE FUNCTION Distance (X1, Y1, X2, Y2)      'Calculates using the distance formula.„DECLARE FUNCTION Hex2Dec# (HexNumber$)          'Converts Hex Numbers to Decimal (Supports up to number FFFFFFFF).„DECLARE FUNCTION Oct2Dec (OctNumber$)           'Converts octal numbert to decimal (Supports up to number 77777777).„DECLARE FUNCTION Bin$ (Number)                  'Converts decimal to binary in sting format up to 255.„DECLARE FUNCTION CBin (Number)                  'Converts decimal to binary in integer format up to 255.„DECLARE FUNCTION Bin2Dec (Number)               'Converts Binary to Decimal up to 11111111.„DECLARE FUNCTION Round (Number)                 'Rounds number to the highest integer better than CInt. (eg. 1.5 = 2 and 1.4444445 = 2)„DECLARE FUNCTION Reverse (Number)               'Makes a negitive positive and a positive negative.„DECLARE FUNCTION Format$ (Number#, NumberPlaces) 'Formats a number to read only a certain number of places after the decimal in string format. (ex Format$(45.2154654, 2) becomes 45.21)„DECLARE FUNCTION Pyt (A, B)                     'Calculates the length of the hypotenuse of a right triangle using the pythagorean theorem.„DECLARE SUB Quad (A, B, C)                      'Calculates using the quadratic formula.„„DIM SHARED Quad1, Quad2, Buffer AS STRING * 1„CONST PI = 3.141592654#„„FUNCTION Bin$ (Number)„„IF Number >= 128 THEN Value$ = "1": Number = Number - 128 ELSE Value$ = "0"„IF Number >= 64 THEN Value$ = Value$ + "1": Number = Number - 64 ELSE Value$ = Value$ + "0"„IF Number >= 32 THEN Value$ = Value$ + "1": Number = Number - 32 ELSE Value$ = Value$ + "0"„IF Number >= 16 THEN Value$ = Value$ + "1": Number = Number - 16 ELSE Value$ = Value$ + "0"„IF Number >= 8 THEN Value$ = Value$ + "1": Number = Number - 8 ELSE Value$ = Value$ + "0"„IF Number >= 4 THEN Value$ = Value$ + "1": Number = Number - 4 ELSE Value$ = Value$ + "0"„IF Number >= 2 THEN Value$ = Value$ + "1": Number = Number - 2 ELSE Value$ = Value$ + "0"„IF Number >= 1 THEN Value$ = Value$ + "1": Number = Number - 1 ELSE Value$ = Value$ + "0"„„Bin$ = Value$„„END FUNCTION„„FUNCTION Bin2Dec (Number)„„IF Number >= 10000000 THEN Number = Number - 10000000: Value = 128 ELSE Value = 0„IF Number >= 1000000 THEN Number = Number - 1000000: Value = Value + 64„IF Number >= 100000 THEN Number = Number - 100000: Value = Value + 32„IF Number >= 10000 THEN Number = Number - 10000: Value = Value + 16„IF Number >= 1000 THEN Number = Number - 1000: Value = Value + 8„IF Number >= 100 THEN Number = Number - 100: Value = Value + 4„IF Number >= 10 THEN Number = Number - 10: Value = Value + 2„IF Number >= 1 THEN Number = Number - 1: Value = Value + 1„„Bin2Dec = Value„„END FUNCTION„„FUNCTION CBin (Number)„IF Number >= 128 THEN Value$ = "1": Number = Number - 128 ELSE Value$ = "0"„IF Number >= 64 THEN Value$ = Value$ + "1": Number = Number - 64 ELSE Value$ = Value$ + "0"„IF Number >= 32 THEN Value$ = Value$ + "1": Number = Number - 32 ELSE Value$ = Value$ + "0"„IF Number >= 16 THEN Value$ = Value$ + "1": Number = Number - 16 ELSE Value$ = Value$ + "0"„IF Number >= 8 THEN Value$ = Value$ + "1": Number = Number - 8 ELSE Value$ = Value$ + "0"„IF Number >= 4 THEN Value$ = Value$ + "1": Number = Number - 4 ELSE Value$ = Value$ + "0"„IF Number >= 2 THEN Value$ = Value$ + "1": Number = Number - 2 ELSE Value$ = Value$ + "0"„IF Number >= 1 THEN Value$ = Value$ + "1": Number = Number - 1 ELSE Value$ = Value$ + "0"„„CBin = VAL(Value$)„„END FUNCTION„„FUNCTION Distance (X1, Y1, X2, Y2)„„Distance = SQR((X1 - X2) ^ 2 + (Y1 - Y2) ^ 2)„„END FUNCTION„„FUNCTION Format$ (Number#, NumberPlaces)„„„Num$ = LTRIM$(RTRIM$(STR$(Number#)))„Value$ = LEFT$(Num$, (INSTR(Num$, ".") + NumberPlaces))„Format$ = Value$„„„END FUNCTION„„FUNCTION Hex2Dec# (HexNumber$)„„Number$ = LTRIM$(RTRIM$(UCASE$(HexNumber$)))„Buffer$ = ""„Value# = 0„„IF LEN(Number$) = 8 THEN„        Buffer = LEFT$(Number$, 1)„        Number$ = RIGHT$(Number$, 7)„END IF„„IF Buffer = "1" THEN Value# = Value# + (268435456 * 1)„IF Buffer = "2" THEN Value# = Value# + (268435456 * 2)„IF Buffer = "3" THEN Value# = Value# + (268435456 * 3)„IF Buffer = "4" THEN Value# = Value# + (268435456 * 4)„IF Buffer = "5" THEN Value# = Value# + (268435456 * 5)„IF Buffer = "6" THEN Value# = Value# + (268435456 * 6)„IF Buffer = "7" THEN Value# = Value# + (268435456 * 7)„IF Buffer = "8" THEN Value# = Value# + (268435456 * 8)„IF Buffer = "9" THEN Value# = Value# + (268435456 * 9)„IF Buffer = "A" THEN Value# = Value# + (268435456 * 10)„IF Buffer = "B" THEN Value# = Value# + (268435456 * 11)„IF Buffer = "C" THEN Value# = Value# + (268435456 * 12)„IF Buffer = "D" THEN Value# = Value# + (268435456 * 13)„IF Buffer = "E" THEN Value# = Value# + (268435456 * 14)„IF Buffer = "F" THEN Value# = Value# + (268435456 * 15)„Buffer = ""„„IF LEN(Number$) = 7 THEN„        Buffer = LEFT$(Number$, 1)„        Number$ = RIGHT$(Number$, 6)„END IF„„IF Buffer = "1" THEN Value# = Value# + (16777216 * 1)„IF Buffer = "2" THEN Value# = Value# + (16777216 * 2)„IF Buffer = "3" THEN Value# = Value# + (16777216 * 3)„IF Buffer = "4" THEN Value# = Value# + (16777216 * 4)„IF Buffer = "5" THEN Value# = Value# + (16777216 * 5)„IF Buffer = "6" THEN Value# = Value# + (16777216 * 6)„IF Buffer = "7" THEN Value# = Value# + (16777216 * 7)„IF Buffer = "8" THEN Value# = Value# + (16777216 * 8)„IF Buffer = "9" THEN Value# = Value# + (16777216 * 9)„IF Buffer = "A" THEN Value# = Value# + (16777216 * 10)„IF Buffer = "B" THEN Value# = Value# + (16777216 * 11)„IF Buffer = "C" THEN Value# = Value# + (16777216 * 12)„IF Buffer = "D" THEN Value# = Value# + (16777216 * 13)„IF Buffer = "E" THEN Value# = Value# + (16777216 * 14)„IF Buffer = "F" THEN Value# = Value# + (16777216 * 15)„Buffer = ""„„IF LEN(Number$) = 6 THEN„        Buffer = LEFT$(Number$, 1)„        Number$ = RIGHT$(Number$, 5)„END IF„„IF Buffer = "1" THEN Value# = Value# + (1048576 * 1)„IF Buffer = "2" THEN Value# = Value# + (1048576 * 2)„IF Buffer = "3" THEN Value# = Value# + (1048576 * 3)„IF Buffer = "4" THEN Value# = Value# + (1048576 * 4)„IF Buffer = "5" THEN Value# = Value# + (1048576 * 5)„IF Buffer = "6" THEN Value# = Value# + (1048576 * 6)„IF Buffer = "7" THEN Value# = Value# + (1048576 * 7)„IF Buffer = "8" THEN Value# = Value# + (1048576 * 8)„IF Buffer = "9" THEN Value# = Value# + (1048576 * 9)„IF Buffer = "A" THEN Value# = Value# + (1048576 * 10)„IF Buffer = "B" THEN Value# = Value# + (1048576 * 11)„IF Buffer = "C" THEN Value# = Value# + (1048576 * 12)„IF Buffer = "D" THEN Value# = Value# + (1048576 * 13)„IF Buffer = "E" THEN Value# = Value# + (1048576 * 14)„IF Buffer = "F" THEN Value# = Value# + (1048576 * 15)„Buffer = ""„„IF LEN(Number$) = 5 THEN„        Buffer = LEFT$(Number$, 1)„        Number$ = RIGHT$(Number$, 4)„END IF„„IF Buffer = "1" THEN Value# = Value# + (65536 * 1)„IF Buffer = "2" THEN Value# = Value# + (65536 * 2)„IF Buffer = "3" THEN Value# = Value# + (65536 * 3)„IF Buffer = "4" THEN Value# = Value# + (65536 * 4)„IF Buffer = "5" THEN Value# = Value# + (65536 * 5)„IF Buffer = "6" THEN Value# = Value# + (65536 * 6)„IF Buffer = "7" THEN Value# = Value# + (65536 * 7)„IF Buffer = "8" THEN Value# = Value# + (65536 * 8)„IF Buffer = "9" THEN Value# = Value# + (65536 * 9)„IF Buffer = "A" THEN Value# = Value# + (65536 * 10)„IF Buffer = "B" THEN Value# = Value# + (65536 * 11)„IF Buffer = "C" THEN Value# = Value# + (65536 * 12)„IF Buffer = "D" THEN Value# = Value# + (65536 * 13)„IF Buffer = "E" THEN Value# = Value# + (65536 * 14)„IF Buffer = "F" THEN Value# = Value# + (65536 * 15)„Buffer = ""„„IF LEN(Number$) = 4 THEN„        Buffer = LEFT$(Number$, 1)„        Number$ = RIGHT$(Number$, 3)„END IF„„IF Buffer = "1" THEN Value# = Value# + (4096 * 1)„IF Buffer = "2" THEN Value# = Value# + (4096 * 2)„IF Buffer = "3" THEN Value# = Value# + (4096 * 3)„IF Buffer = "4" THEN Value# = Value# + (4096 * 4)„IF Buffer = "5" THEN Value# = Value# + (4096 * 5)„IF Buffer = "6" THEN Value# = Value# + (4096 * 6)„IF Buffer = "7" THEN Value# = Value# + (4096 * 7)„IF Buffer = "8" THEN Value# = Value# + (4096 * 8)„IF Buffer = "9" THEN Value# = Value# + (4096 * 9)„IF Buffer = "A" THEN Value# = Value# + (4096 * 10)„IF Buffer = "B" THEN Value# = Value# + (4096 * 11)„IF Buffer = "C" THEN Value# = Value# + (4096 * 12)„IF Buffer = "D" THEN Value# = Value# + (4096 * 13)„IF Buffer = "E" THEN Value# = Value# + (4096 * 14)„IF Buffer = "F" THEN Value# = Value# + (4096 * 15)„Buffer = ""„„IF LEN(Number$) = 3 THEN„        Buffer = LEFT$(Number$, 1)„        Number$ = RIGHT$(Number$, 2)„END IF„„IF Buffer = "1" THEN Value# = Value# + (256 * 1)„IF Buffer = "2" THEN Value# = Value# + (256 * 2)„IF Buffer = "3" THEN Value# = Value# + (256 * 3)„IF Buffer = "4" THEN Value# = Value# + (256 * 4)„IF Buffer = "5" THEN Value# = Value# + (256 * 5)„IF Buffer = "6" THEN Value# = Value# + (256 * 6)„IF Buffer = "7" THEN Value# = Value# + (256 * 7)„IF Buffer = "8" THEN Value# = Value# + (256 * 8)„IF Buffer = "9" THEN Value# = Value# + (256 * 9)„IF Buffer = "A" THEN Value# = Value# + (256 * 10)„IF Buffer = "B" THEN Value# = Value# + (256 * 11)„IF Buffer = "C" THEN Value# = Value# + (256 * 12)„IF Buffer = "D" THEN Value# = Value# + (256 * 13)„IF Buffer = "E" THEN Value# = Value# + (256 * 14)„IF Buffer = "F" THEN Value# = Value# + (256 * 15)„Buffer = ""„„IF LEN(Number$) = 2 THEN„        Buffer = LEFT$(Number$, 1)„        Number$ = RIGHT$(Number$, 1)„END IF„„IF Buffer = "1" THEN Value# = Value# + (16 * 1)„IF Buffer = "2" THEN Value# = Value# + (16 * 2)„IF Buffer = "3" THEN Value# = Value# + (16 * 3)„IF Buffer = "4" THEN Value# = Value# + (16 * 4)„IF Buffer = "5" THEN Value# = Value# + (16 * 5)„IF Buffer = "6" THEN Value# = Value# + (16 * 6)„IF Buffer = "7" THEN Value# = Value# + (16 * 7)„IF Buffer = "8" THEN Value# = Value# + (16 * 8)„IF Buffer = "9" THEN Value# = Value# + (16 * 9)„IF Buffer = "A" THEN Value# = Value# + (16 * 10)„IF Buffer = "B" THEN Value# = Value# + (16 * 11)„IF Buffer = "C" THEN Value# = Value# + (16 * 12)„IF Buffer = "D" THEN Value# = Value# + (16 * 13)„IF Buffer = "E" THEN Value# = Value# + (16 * 14)„IF Buffer = "F" THEN Value# = Value# + (16 * 15)„Buffer = ""„„IF LEN(Number$) = 1 THEN„        Buffer = LEFT$(Number$, 1)„END IF„„IF Buffer = "1" THEN Value# = Value# + (1 * 1)„IF Buffer = "2" THEN Value# = Value# + (1 * 2)„IF Buffer = "3" THEN Value# = Value# + (1 * 3)„IF Buffer = "4" THEN Value# = Value# + (1 * 4)„IF Buffer = "5" THEN Value# = Value# + (1 * 5)„IF Buffer = "6" THEN Value# = Value# + (1 * 6)„IF Buffer = "7" THEN Value# = Value# + (1 * 7)„IF Buffer = "8" THEN Value# = Value# + (1 * 8)„IF Buffer = "9" THEN Value# = Value# + (1 * 9)„IF Buffer = "A" THEN Value# = Value# + (1 * 10)„IF Buffer = "B" THEN Value# = Value# + (1 * 11)„IF Buffer = "C" THEN Value# = Value# + (1 * 12)„IF Buffer = "D" THEN Value# = Value# + (1 * 13)„IF Buffer = "E" THEN Value# = Value# + (1 * 14)„IF Buffer = "F" THEN Value# = Value# + (1 * 15)„Buffer = ""„„Hex2Dec = Value#„EXIT FUNCTION„„„END FUNCTION„„FUNCTION Oct2Dec (OctNumber$)„„IF LEN(LTRIM$(RTRIM$(OctNumber$))) > 8 THEN Value = 0: EXIT FUNCTION„IF INSTR(OctNumber$, "8") > 0 THEN Value = 0: EXIT FUNCTION„IF INSTR(OctNumber$, "9") > 0 THEN Value = 0: EXIT FUNCTION„„Number = VAL(OctNumber$)„„DO UNTIL Number <= 7777777„        Number = Number - 10000000„        Value = Value + 2097152„LOOP„„DO UNTIL Number <= 777777„        Number = Number - 1000000„        Value = Value + 262144„LOOP„„DO UNTIL Number <= 77777„        Number = Number - 100000„        Value = Value + 32768„LOOP„„DO UNTIL Number <= 7777„        Number = Number - 10000„        Value = Value + 4096„LOOP„„DO UNTIL Number <= 777„        Number = Number - 1000„        Value = Value + 512„LOOP„„DO UNTIL Number <= 77„        Number = Number - 100„        Value = Value + 64„LOOP„„DO UNTIL Number <= 7„        Number = Number - 10„        Value = Value + 8„LOOP„„DO UNTIL Number <= 0„        Number = Number - 1„        Value = Value + 1„LOOP„„Oct2Dec = Value„„END FUNCTION„„FUNCTION Pyt (A, B)„„IF C = 0 THEN Pyt = SQR((A ^ 2) + (B ^ 2))„„END FUNCTION„„SUB Quad (A, B, C)„„D = (B ^ 2) - (4 * A * C)„„IF D < 0 THEN„        PRINT "There are no real roots.  Using the following default: "; : EXIT SUB„ELSE„        Quad1 = (-B + SQR(D)) / (2 * A)„        Quad2 = (-B - SQR(D)) / (2 * A)„END IF„„END SUB„„FUNCTION Reverse (Number)„„Reverse = Number * -1„„END FUNCTION„„FUNCTION Round (Number)„„Value$ = LTRIM$(RTRIM$(STR$(Number)))„„Length = INSTR(Value$, ".")„„Integer$ = LEFT$(Value$, Length - 1)„Extra$ = RIGHT$(Value$, Length - 1)„„B = LEN(Extra$)„„DO„        IF VAL(LEFT$(Extra$, 1)) >= 5 THEN Round = VAL(Integer$) + 1: EXIT FUNCTION„        IF VAL(LEFT$(Extra$, 1)) <= 3 THEN Round = VAL(Integer$): EXIT FUNCTION„        IF A = B THEN Round = VAL(Integer$): EXIT FUNCTION„        Extra$ = RIGHT$(Extra$, LEN(Extra$) - 1)„        A = A + 1„LOOP„„END FUNCTION„„FUNCTION XLog (X, Number)„„XLog = LOG(Number) / LOG(X)„„END FUNCTION„„FUNCTION XRoot (X, Number)„„        XRoot = Number ^ (1 / X)„„END FUNCTION„Kinslayer Indst. (Cody Bunch)  ROUND NUMBERS                  jbunch@bellsouth.net           09-03-97 (20:59)       QB, QBasic, PDS        21   814      ROUNDED.BAS CLS„COLOR 5„PRINT " THIS PROGRAM WILL ROUND NUMBERS TO SPECIFIED DECIMAL PLACES "„PRINT " FEEL FREE TO USE THIS PROGRAM AT YOUR OWN FREE WILL AND PUT"„PRINT " IT ON YOUR OWN PAGE AT MY CONSENT THE E-MAIL ADRESS WILL BE"„PRINT " DISPLAYED AT THE END OF THE PROGRAM. IF YOU HAVE ANY INTERESTS IN"„PRINT " ANY OTHER MATH PROGRAMS LET ME KNOW AND I'LL SEE WHAT I CAN DO"„PRINT " NOTE: CAPS LOCK MUST BE ON TO ROUND MORE THAN 1 NUMBER"„MORE$ = "Y"„   WHILE MORE$ = "Y"„   INPUT "NUMBER TO BE ROUNDED"; A„   INPUT "NUMBER OF PLACES"; B„   X = INT(A * 10 ^ B + .5) / 10 ^ B„   PRINT A; "ROUNDED TO"; B; "PLACES_"; X„   PRINT„   INPUT "DO ANOTHER (Y/N)"; MORE$„WEND„COLOR 3„PRINT "THIS PROGRAM WAS MADE BY KINSLAYER INDST."„PRINT "PLEASE E-MAIL ANY COMMENTS TO JBUNCH@BELLSOUTH.NET"„PRINT "THANK YOU"„Sami Kyostila                  HEX ENCODER/DECODER            hiteck@mail.freenet.hut.fi     09-05-97 (19:51)       QB, QBasic, PDS        208  4670     HEX.BAS     CONST ColLimit = 60        'Chars per line„„'-------------------------„'       Hex Encoder„'-------------------------„'FREEWARE by Sami Kyostila„'-------------------------„'  hiteck@freenet.hut.fi„'-------------------------„„'  This prog converts binary files into emailable ones„'I tried to keep the line lenght under 60 chars, so„'you can send this file via email.„'It also has a very simple checksum algorithm, but it„'is (almost) fully error proof.„'  To use, Encode the file you wish to send (NOTE:„'ZIP YOUR FILE FIRST!, so it will be a LOT smaller)„'and paste the file to an EMail message, and simply„'send it. To extract a file from an EMail message,„'save the message into a file and decode that file.„'NOTE: This program searches for an "Hex-" string that„'indicates the start of file data. However if your„'email message contains this string, then the extraction„'will fail, so make sure that there aren't any such„'strings in the file. Also make sure that the last 2„'bytes in the file are "XX", which indicate the end„'of the file data.„„TYPE Header                  'File header„  Verify AS STRING * 4„  Filename AS STRING * 12„END TYPE„„„DIM Byte AS STRING * 1       '1 byte„DIM Hex AS STRING * 2        '2 bytes„DIM Hdr AS Header            'Header„DIM SeekS AS STRING * 4      'Seek buffer„„CLS„COLOR 15, 4„PRINT "                    ";„PRINT "Hex Encoder/Decoder for QBasic - Sami Ky";„PRINT CHR$(148); "stil";„PRINT CHR$(132);„PRINT "              "„„VIEW PRINT 2 TO 25„PRINT„COLOR 10, 0„PRINT "          1 - Encode"„PRINT "          2 - Decode"„COLOR 2„PRINT„PRINT " Choose one: ";„k$ = INPUT$(1)„COLOR 9„„IF k$ = "1" THEN PRINT "Encode": GOTO Encode„IF k$ = "2" THEN PRINT "Decode": GOTO Decode„PRINT "Quit"„END„„„Encode:„COLOR 7, 0„PRINT„INPUT "  Input file: ", Inp$„IF Inp$ = "" THEN END„INPUT " Output file: ", Out$„IF Out$ = "" THEN END„„OPEN Inp$ FOR BINARY AS #1„OPEN Out$ FOR OUTPUT AS #2„„FOR i = LEN(Inp$) TO 1 STEP -1        'Remove path„  IF MID$(Inp$, i, 1) = "÷" THEN„    Inp$ = MID$(Inp$, i + 1, 255)„  END IF„NEXT„„Inp$ = UCASE$(Inp$)„Inp$ = LEFT$(Inp$, 12)„Inp$ = Inp$ + STRING$(12 - LEN(Inp$), "<")„„PRINT " Encoding..."„PRINT " - Writing header..."„Hdr.Verify = "Hex-"                  'Write header„Hdr.Filename = Inp$„„PRINT #2, Hdr.Verify;„PRINT #2, Hdr.Filename„„PRINT " - Encoding"; LOF(1); "bytes..."„Col = 0                              'Encode„Avg& = 0„lines& = 0„FOR i& = 1 TO LOF(1)„  GET #1, , Byte„  Avg& = Avg& + ASC(Byte)„  Hx$ = HEX$(ASC(Byte))„„  IF LEN(Hx$) = 1 THEN Hx$ = "0" + Hx$„  PRINT #2, Hx$;„  Col = Col + 2„  IF Col = ColLimit THEN„    Col = 0„    Chk$ = HEX$(Avg& MOD 255)„    IF LEN(Chk$) = 1 THEN Chk$ = "0" + Chk$„    PRINT #2, "::"; Chk$„    lines& = lines& + 1„    Avg& = 0„  END IF„NEXT„PRINT #2, "XX"„„„PRINT " - Output file size: "; LOF(2); "bytes -";„PRINT lines&; "lines"„„CLOSE #1„CLOSE #2„END„„„Decode:„COLOR 7, 0„PRINT„INPUT "  Input file: ", Inp$„IF Inp$ = "" THEN END„„PRINT " Decoding..."„PRINT " - Seeking..."„„OPEN Inp$ FOR BINARY AS #1„IF LOF(1) = 0 THEN                   'Check if file„  PRINT " File not found!"           'exists„  CLOSE„  KILL Inp$„  END„END IF„„Start& = -1„FOR i& = 1 TO LOF(1)                 'Seek start of„  GET #1, i&, SeekS                  'file data„  IF SeekS = "Hex-" THEN„    Start& = i&„    EXIT FOR„  END IF„NEXT„IF Start& = -1 THEN„  PRINT " - File data not found!"„  END„END IF„                                     'Read header„PRINT " - Reading header..."„SEEK #1, Start&„„GET #1, , Hdr„IF Hdr.Verify <> "Hex-" THEN„  PRINT " First 4 bytes must be 'Hex-'"„  CLOSE„  END„END IF„„Out$ = LEFT$(Hdr.Filename, INSTR(Hdr.Filename, "<") - 1)„OPEN Out$ FOR BINARY AS #2„PRINT " - Writing output file "; Out$; "..."„„IF LOF(2) > 0 THEN„  PRINT " Output file exists!"„  CLOSE„  END„END IF„„Col = 0                              'Decode„Avg& = 0„FOR i& = 1 TO LOF(1)„  DO„    GET #1, , Hex„    IF Hex = "XX" THEN EXIT FOR„    IF Hex = "::" THEN„      GET #1, , Hex„      IF VAL("&H" + Hex) <> Avg& MOD 255 THEN„        COLOR 12„        PRINT " Checksum error at"; SEEK(1)„        PRINT VAL("&H" + Hex); "<>"; Avg& MOD 255„        COLOR 7„        CLOSE„        END„      END IF„      Avg& = 0„      Hex = CHR$(13) + CHR$(0)„    END IF„  LOOP UNTIL INSTR(Hex, CHR$(13)) = 0„  Byte = CHR$(VAL("&H" + Hex))„  Avg& = Avg& + ASC(Byte)„  PUT #2, , Byte„NEXT„„„PRINT " - Input file size: ", LOF(1)„PRINT " - Output file size: ", LOF(2)„„CLOSE #1„CLOSE #2„„END„John Bull                      ADD/SUBTRACT USING STRINGS     flyhigh@prodigy.com            10-02-97 (12:04)       QB, QBasic, PDS        89   2588     ADD.BAS     SUB m (z$, what$, cash)„„' This is a sub to get by that pesky numeric limit of 32767 or -32767„' it uses a string to keep the numbers in and then splits them up into„' 2 variables to add/subtract them.  So you can have a number up to„' 999999 now.  This can be very useful. Have fun!„„math1:„IF LEN(z$) = 1 THEN z1 = VAL(RIGHT$(z$, 1)): z2 = 0„IF LEN(z$) = 2 THEN z1 = VAL(RIGHT$(z$, 2)): z2 = 0„IF LEN(z$) = 3 THEN z1 = VAL(RIGHT$(z$, 3)): z2 = 0„IF LEN(z$) = 4 THEN z1 = VAL(RIGHT$(z$, 3)): z2 = VAL(LEFT$(z$, 1))„IF LEN(z$) = 5 THEN z1 = VAL(RIGHT$(z$, 3)): z2 = VAL(LEFT$(z$, 2))„IF LEN(z$) = 6 THEN z1 = VAL(RIGHT$(z$, 3)): z2 = VAL(LEFT$(z$, 3))„„z$ = RIGHT$((STR$(cash)), LEN(STR$(cash)) - 1)„„IF LEN(z$) = 1 THEN z3 = VAL(RIGHT$(z$, 1)): z4 = 0„IF LEN(z$) = 2 THEN z3 = VAL(RIGHT$(z$, 2)): z4 = 0„IF LEN(z$) = 3 THEN z3 = VAL(RIGHT$(z$, 3)): z4 = 0„IF LEN(z$) = 4 THEN z3 = VAL(RIGHT$(z$, 3)): z4 = VAL(LEFT$(z$, 1))„IF LEN(z$) = 5 THEN z3 = VAL(RIGHT$(z$, 3)): z4 = VAL(LEFT$(z$, 2))„IF LEN(z$) = 6 THEN z3 = VAL(RIGHT$(z$, 3)): z4 = VAL(LEFT$(z$, 3))„„IF what$ = "+" THEN„„        z1 = z1 + z3„      „        DO„                IF z1 >= 1000 THEN„                        z1 = z1 - 999„                        z2 = z2 + 1„                        x$ = "*"„                END IF„        LOOP UNTIL z1 <= 1000„        IF x$ = "*" THEN z1 = z1 - 1„„        z2 = z2 + z4„„        IF z2 >= 999 THEN z2 = 999„„        z1$ = RIGHT$((STR$(z1)), LEN(STR$(z1)) - 1)„        z2$ = RIGHT$((STR$(z2)), LEN(STR$(z2)) - 1)„„        IF LEN(z1$) = 1 THEN z1$ = "00" + z1$„        IF LEN(z1$) = 2 THEN z1$ = "0" + z1$„        IF LEN(z2$) = 1 THEN z2$ = "00" + z2$„        IF LEN(z2$) = 2 THEN z2$ = "0" + z2$„„        z$ = z2$ + z1$„ „END IF„„„„„IF what$ = "-" THEN„    „        z1 = z1 - z3„„        IF z1 <= -1 OR z1 <= -1 THEN„                z1 = z1 + 1000„                z2 = z2 - 1„        END IF„„        z2 = z2 - z4„        IF z2 = -1 OR z2 <= -1 THEN„                IF z1 = 0 THEN„                        z2 = 0„                        z1 = 999„                ELSE„                        z1 = 0„                        z2 = 0„                END IF„        END IF„„        z1$ = RIGHT$((STR$(z1)), LEN(STR$(z1)) - 1)„        z2$ = RIGHT$((STR$(z2)), LEN(STR$(z2)) - 1)„„        IF LEN(z1$) = 1 THEN z1$ = "00" + z1$„        IF LEN(z1$) = 2 THEN z1$ = "0" + z1$„        IF LEN(z2$) = 1 THEN z2$ = "00" + z2$„        IF LEN(z2$) = 2 THEN z2$ = "0" + z2$„„        z$ = z2$ + z1$„ „END IF„„END SUB„Brian Wilkins                  QUADRATIC FORMULA              sonic@digital.net              10-16-97 (02:09)       QB, QBasic, PDS        10   418      QUAD.BAS    ' **** Quadratic Formula by Brian Wilkins„' **** This program will ask for A, B, & C, then using the quadratic formula„' **** It will give you a solution, or a N.R.S„„„CLS„INPUT "Enter A,B,C (seperate with commas) : ", A, B, C„D = (B ^ 2) - (4 * A) * C„IF D < 0 THEN PRINT "NO REAL SOLUTION" ELSE x = (-1 * B + D ^ (.5)) / (2 * A): x1 = (-1 * B - D ^ (.5)) / (2 * A): PRINT "The answer is:": PRINT x, x1„END„Timothy J. Mayo                SOLVING THE KNIGHT PROBLEM     tjmayo@spnt.com                10-18-97 (23:40)       QB, QBasic, PDS        278  7663     KNIGHT.BAS  DECLARE SUB newbreed ()„DECLARE SUB displaybest ()„''--------PROGRAM QBASIC--------''„''this product was made designed„''and programed by A.D. Ice„''14 years of age if you want„''to use my code please give„''me some credit for my code„''if you want to compile and sell„''my program (edited of course)„''"""""GO FOR IT""""""„''just give me SOME credit„''E-mail <tjmayo@spnt.com>„„''This program is desined as a way to solve the famous knight problem„''the knight problem is were the knight is placed on the chess board„''and the object of the rook is to move through each square on the board„'':------:------:------:------:------:------:------:------:„'':xxxxxx:      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„'':      :      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„'':      :      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„'':      :      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„'':      :      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„'':      :      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„'':      :      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„'':      :      :      :      :      :      :      :      :„'':------:------:------:------:------:------:------:------:„''useing the genetic alogarithem approach the knight LEARNS to go in the right way„''in practice useing this technique it could be possible to evolve a computer program„''the list of letters at the end of this program is the ANSWER to the program this is„''how you can decipher this program is as follows„''„''a: move up 2 left 1„''b: move up 2 right 1„''c: move up 1 left 2„''d: move up 1 right 2„''e: move down 2 right 1„''f: move down 2 left 1„''g: move down 1 right 2„''h: move down 1 left 2„''if you have question or just want to say hi you can e-mail me at„'' tjmayo <tjmayo@spnt.com> subject PROGRAMING A.D.„DECLARE SUB setup ()„DECLARE SUB move ()„SCREEN 12„RANDOMIZE TIMER„DIM SHARED board(8, 8, 201)„DIM SHARED x(201)„DIM SHARED y(201)„DIM SHARED genes$(201)„DIM SHARED value(201)„DIM SHARED count2„CALL setup„1 FOR count = 0 TO 201„FOR count2 = 1 TO 64„CALL move„num = num + 1„value(count) = num„IF ended = 1 THEN GOTO 11„IF ended = 0 THEN GOTO 30„NEXT„11 ended = 0„num = 0„NEXT„CALL newbreed„GOTO 1„30 CALL displaybest„„SUB displaybest„PRINT genes$(count)„x(count) = 0„y(count) = 0„FOR count = 0 TO 64„„IF MID$(genes$(count), count2, 1) = "A" THEN„ x(count) = x(count) - 1„ y(count) = y(count) - 2„END IF„IF MID$(genes$(count), count2, 1) = "B" THEN„ x(count) = x(count) + 1„ y(count) = y(count) - 2„END IF„„IF MID$(genes$(count), count2, 1) = "C" THEN„ x(count) = x(count) - 2„ y(count) = y(count) - 1„END IF„„IF MID$(genes$(count), count2, 1) = "D" THEN„ x(count) = x(count) + 2„ y(count) = y(count) - 1„END IF„„IF MID$(genes$(count), count2, 1) = "E" THEN„ x(count) = x(count) + 1„ y(count) = y(count) + 2„END IF„„IF MID$(genes$(count), count2, 1) = "F" THEN„ x(count) = x(count) - 1„ y(count) = y(count) + 2„END IF„„IF MID$(genes$(count), count2, 1) = "G" THEN„ x(count) = x(count) + 2„ y(count) = y(count) + 1„END IF„„IF MID$(genes$(count), count2, 1) = "H" THEN„ x(count) = x(count) - 2„ y(count) = y(count) + 1„END IF„NEXT„END SUB„„SUB move„IF MID$(genes$(count), count2, 1) = "A" THEN„ x(count) = x(count) - 1„ y(count) = y(count) - 2„  IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„IF MID$(genes$(count), count2, 1) = "B" THEN„ x(count) = x(count) + 1„ y(count) = y(count) - 2„  IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„IF MID$(genes$(count), count2, 1) = "C" THEN„ x(count) = x(count) - 2„ y(count) = y(count) - 1„  IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„IF MID$(genes$(count), count2, 1) = "D" THEN„ x(count) = x(count) + 2„ y(count) = y(count) - 1„  IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„IF MID$(genes$(count), count2, 1) = "E" THEN„ x(count) = x(count) + 1„ y(count) = y(count) + 2„  IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„IF MID$(genes$(count), count2, 1) = "F" THEN„ x(count) = x(count) - 1„ y(count) = y(count) + 2„  IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„IF MID$(genes$(count), count2, 1) = "G" THEN„ x(count) = x(count) + 2„ y(count) = y(count) + 1„ IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„IF MID$(genes$(count), count2, 1) = "H" THEN„ x(count) = x(count) - 2„ y(count) = y(count) + 1„ IF x(count) < 0 OR y(count) < 0 OR x(count) > 64 OR y(count) > 64 THEN„  ended = 1„  GOTO 10„  END IF„  board(x(count), y(count), count) = board(x(count), y(count), count) + 1„   IF board(x(count), y(count), count) >= 2 THEN„   ended = 1„   GOTO 10„   END IF„END IF„„10 END SUB„„SUB newbreed„best1 = 0„bestnum1 = 0„best2 = 0„bestnum2 = 0„FOR count3 = 0 TO 201„IF value(count3) > best1 THEN bestnum1 = count3„IF bestnum1 <> count3 AND value(count3) > best2 THEN bestnum1 = count3„NEXT count3„FOR count3 = 0 TO 201„IF bestnum1 <> count3 OR bestnum2 <> count3 THEN„value(count3) = 0„genes$(count3) = ""„x(count3) = 0„y(count3) = 0„END IF„NEXT count3„FOR count3 = 0 TO 8„FOR count4 = 0 TO 8„FOR count5 = 0 TO 201„board(count3, count4, count5) = 0„NEXT count5, count4, count3„FOR count3 = 0 TO 201„rand = INT(RND * 63) + 1„IF genes$(count3) = "" THEN genes$(count3) = LEFT$(genes$(bestnum1), rand) + RIGHT$(genes$(bestnum2), rand)„NEXT count3„END SUB„„SUB setup„PRINT„PRINT "PRESS ESC TO CONTINUE"„DO UNTIL INKEY$ = CHR$(27)„LOOP„CLS„FOR count1 = 0 TO 201„FOR count = 0 TO 64„genes$(count1) = genes$(count1) + CHR$(INT(RND * 7) + 65)„NEXT„board(0, 0, count1) = 1„NEXT„END SUB„Mark Junker                    FLEXIBLE FORMULA PARSER V2.5004mjs@prg.hannover.sgh-net.de    10-13-97 (17:51)       PB                     512  33785    FML.BAS     'Load/Run under PowerBASIC to extract FML25004.ZIP„DEFINT A-Z:SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"FML25004.ZIP",4^6:Z&=25056:?STRING$(50,177);„U"%up()%9%'%.-%B3#xH/)/bbF7%%%cs%%%0%I%%B2M0==4JAS10GBVa:b&Tm+lXp„U"kvC4\gQF2/<bERj.Z7FeQ2&B\I\LUbH3gs];0S<2+)_reV]uGvh0aCVwdA0(.m#„U"^$s[D4xz,;,,hO8Hh-DuknP8h;Wf$-#4g4KuMaX(=xiA1BmnC?0<Yw(/HBL+wde„U"jp?U[a<Lf4g/WXNOZj,uaEfxDSo4]inp\G[.Mn+Y>b5JJ9VE.L.*mZ]>\FKU&*3„U"anl8^Lfm2ulpYs86mLVKYh3c;#Yv&8YwY?#GX$cTH$VQ$HnXl/aE/'Z*,U_B*iK„U"+t;#VFuL]cqxS<M38c$=CJ9OuI\gx'?9S[i12/PO:f?Tt=$Vf'c1'*pC4$KM&sh„U"d*))Wy.:>\<esti/gZP^TE3e<:g.K._Y\WW/H4LKK.kq*gAS:6FuDLhEP?>KPa%„U"mLGy\B%WiK.9RXknqRmro*P=%avU>IqIb/4Em\sT^yELjR-iC^YgoF']fe4WE/q„U">/2*+PBnE.1]S3ZCMwjw(R?iKA0d49+<-Y=U01/UwDsbe6^h?xKInGtWovIN=1u„U"<$o;lYJQg?sUb)PM<8=*]Gs3kg/I_K/)]1NTV_2eR/)KMr>1'Q#Z0DVq4F_x(Y]„U"\xIhL\8'$XX6Xr0CU3-)$qXIR,bPcWce'>N+WEF?tf=AP<[XI&ICZ*qcLbUG5Xm„U"Vz2k0x^0CY3V97+Iegj8q;FW%\$<=JK7.>'5D8#>9/6ZsC;Au&F8-#9Rc#uXmCE„U"C_+M(=9Ij>$G;,%-N/+&-OQ,])'oLY7]PZPFXmCQE_mxS3/i=W=\R4ZfXi[77YC„U"rAH/EA(6ClA$BPdL9-T-7J6XMl^*xYcT\?JQ/BxO4&*_z.B+7qw8qW/HfOIUKO;„U"L&vn6<4[]v)fc0Q,\Hp?V$#c[b3&NuHbu+1?6ejCKx2AY[wk:Q$bQkX]?F,O3%'„U"#6fj.\P_%O.*z[_g%FOPAlT^$u=N*J((<6PaBIJMLJwcW]DuLJeaIwFldM?B[a-„U"h?#%<-9.8fT>Yw;&BLX[EeqX7g9\js-&^GpKwndIsrf<Fp]AV%7eTgL<KCzScw$„U"I2*KTT[CCJomc0_n#hM\/Upw+F/jt(iYl9'NFwqR(]$=WW1QH+5J#g0sRyzpWK-„U"$[f-KBD/N-3^M9*,RNg;M=K[jjgWRt99:dvu0D3ZC'%JjB)b8.)CzrM_)x(lY%-„U"u8FdjOT(X)'bqIv9CZ#kKX5gp_N5-QD[5BeiYe[hiqW.EMc:,O&Q%cqcu/k0alH„U"kkh_<&=mfE'NykNEk;o7\_^BG)_hxR$<$*jQWCE\)]/IYe0V\LF#41e^^k+o\DY„U"pis$;+u+*qGiHQv)?*)FZg3=j\s0hF.i+]<?gfD9;A5'(/;RwD)#_&M7qKv5G74„U"_Ls/2U/vHQm>_<9^-.5&9c9')/4I+F-U_[u;tZA//P5v5_'[I-j%D'[T<Q?/Rx3„U"Mdl&;*cXw)D(/qf]R(cn[?Fhm(V^f0a=*;Uc7URSkfMtxwU#?S;#%aP&N,'eJUu„U"6T?4q3tL<S,<=IUTY0Gq?EWMs35Og*8amLg,mj:8wpe;0wr*J+^LX'?4-M'#Mf7„U"e<Rk/^Y*Ffr?pctN9Ph13HgIjGQl[$M&Pi8t2;mFc-(gd1-qoi7w3R2.)DM=\[k„U"EE;LhGJG[oeXMUmGF*kiyMtLcEGu*:mB9pa5]()IWD&oH&A[/w,mHh5.V]$YNVm„U"/33-)9h6aK]2ky9Z1a'SE6^h_>VTDn>Oh3qhbpUQ2N4S4jx%G^MR5EYRnARC938„U"<*?yz(WGi4t9-0hz2AH5A'$=N8jOmt<JKd*h;&0'[<l:0'[bL4uWGo:XatG^]TC„U"+V<L_c-/ev,+='ji3SC2VSOKSQ7Z,T1R,Wkhm45opuTtx3,=jfu]LU>nZ0WBJE-„U"oJ<Kpd;Mn6lpaLst.5rDApQl=*^iM%8V,)0*-.o4u%Ac1Ae;hrBfC_?23cRFfeF„U"Gt9]V\UuIHa24wi57gd7<cdX];8b9L$V24B7F'(,WsqTFY.lYHP#+f:&AoN&Tb;„U"PZ65t.ifB>pM,cFV9N_X<[P)3pq8A^gEf9ksnu:Y?6ZlUDnfY]h]^_$.mZr2I5w„U"_O3-mB-EW/q05wMV(^eQUDBamz_/f,HqT4;F6_B5/1E5t%/c(x%KlD5t(K)#,t&„U"Yo](^Pa0Z9<I00;]lX%?_=lkq*Tj/8$Z2h#aB5L%;>lIz?7gPvE<h/BpRUcGF+w„U"BnTz<_Dj6HPu(A/pf$ZM'aSBt[Qm,A;/ARRBcLAmj2fHTNVlv.Zvv8mtLvU\):G„U",XPEQY*>,<Fe>93YbfjMh>>6j.Fh-lKXI7lv6am6\#s<fAencBZEYEm_dDf.EWs„U"XEp'O\e[*;,gLq1OPkUq#RUJtU0NoD)GpB,N4nWfX-4M:Mm*iV:%)sgr8Rd++Ts„U"CIWile&8oM:e?No;FYay8J??#8tp*OE^wE=1,Qg>'+HYRcRL,tALA?MkdWKpXJf„U"Fuk8c0';HD.$o>XrQ6CD27#ISgh=N](,j=u9m_]_zU<Ba-tu$2+3fFZE+36t13<„U";iJtQ=+%VQ-P(QzM-C-\lY7bw#5<:j\W.;BJ8M-4glku-dfi*Do6R]V\e:P:Gh/„U"vwJKqUOaG:EV'a3os8fisp$VAP>8XqdsmT7g3B*M(,7lj)OKRNmhi?>d/,gUjTF„U"%p])fZsYY(lN7?oC8Begm'2'h0EirGT1<>lf]..a1^E^2Q_zK?YwOs''KmEh?[F„U"]%M<$6H50;Sa])bR_uOP*-VnO5*XKFi^K1:gez,PtZnl<r$\fLx5CZbxpfSDHl:„U"W(WeroS5O3KQ;<_JqwJ0+(+mv&#i0tmpBsHfn]ewJm5f;2Mk#kA95%eZ%pk7oEE„U"dIa2hDz6tFefsWNa%i##eaRFBM&**B3m-$ap*Y^jSsp%5Y#+pA#HV.4]k8epr*3„U"p2;)1ce*OHB'#V5$E^9AU71=0DW0D#v3hBfecM94zf^^p2o=M,1z>Rdkc#1UHXG„U"F91ID*-vkK+F%[H3GBacm*$UWlAE+,52D#PI2B?:$JRoiJ0PgXCE_$(Xuxq9bxb„U")T2%18p10=oti68%&NOk=aE&Hkid*?&ee=n8o;$%+7s73JL9\(5\xw6NBiHBoRT„U"pGO\D:31KGge(KXixNfFj[.gGw+;_mdSM5r_I,m^t3WT;%FMZJ(?TB?Og#OYE=$„U"a+QH9bJP'q9bi7AHwuxJud$x^F_glePrxRzM\NnK6X_tYDf?bhi'mDqR5C2K(:.„U"(tFy:]]U5(5-3BB+'PUf0=/M5;b>ZiATA$)=3IqYo1#qXA(2ky;ra1d=E<&a-X=„U"on3Kfp&XX0ko5vcD_+s8ByeDZYcjEq3T\5<pPP^hVPi4moqcT$aCx;5ksfw8&Pk„U"yg+e)T-[12*K,I6j;9dOcq3TS7,x1wTC)OTE;rC1kU=s^;JVvA'jw>98=q1msd+„U"9BG]:9P#[aX1;ONOeGem4l4P,cKmDvo/9eKmrxsQa_7oj,c[#f$M^E*+P:(./x=„U"d>B;Bb4&[?r%G''lS,'pG1wcnm)i*6%CGB[)\MM,(atE:PLH+FYc%E+51CzOFo5„U"$%h(4g-siU/#-80M>MPEtW8;3nY_7b,.2A4,I3I7U<2<RPB/$OaKCO3tA(T98m6„U"32/QelXx90._8K4p;Ip'PNSrKfb\R/e]o\*uH1SjOuVpj_uVpa0q4h3.eG)BxDZ„U":jjaZcC6%w/(JT%RUoZji/.5pmNFZvACex?y(geL\jB.H>BfoUE]1Irdd-3/U'l„U"3Cdq(N*ooAP1C#&[kt.')<IDM$h_#e>in/3-j',b/t2'Qt%=*',&.:Nzh)O*)K?„U"pqbn?dxY(i0RZn$m0cldbT%pv>a4.p)-eAS<%H>piwkt3i1kx4ZeWK/LH2hG;nd„U"Tw?h5e5OuU=%n5=.cf(Fjo)'('vUX]GqLSqCm7eE'S3h)u+.gD1eVl1K%s,vI>%„U"KDtXrsI93s=AV;1Xt3%$[9uB]H3zJmnkUYB6z>'.8Z3Xi\nEbT;gc_PX#5+]/WQ„U"L;7-eB2U%4H#zwnWh4l0q^Byr%bhx)N;RBTR^vwCq)EPE8)?Yq.I)OQIJA'*/-l„U"V3_370&Ysc5Qulf<rXsc%xo<Z#lLu8vb)uv\H_tB4v5ulj$FZs5xL=OMOAI9WLj„U"iVQ:_Nm3c\*AqID?XKl]YJm(&tvXupi8.n6bHtdhoGT7v?gvpd3u73[^Z0v'4Km„U"45Ix4&k3APch1q]ITsa-$\VhnqON28/kUp]_<aWB[%SKsC2=B.rHZul1oH*X_,?„U"gM*,*[t*B&Bl8Q%C8R=;.vQYDR];V:*cbN79-Q0QbY;hYJlow<fEK8X;R>rc0hs„U"W;ATLfa.HZY'cy[<#PDh'KwM:i8k_dRFC*mtfQ%FvZJ\.*gH4q]8Z'vML.Rutde„U"=C*5lF)F'w]WhBBrkdIO6U05B8ktb'8APr2/^8ezd,ImWJp/ZObuaUkbSY^ftM)„U"+eWcxQ[C;/Jb8TST='t(aPl4CrHz?gC;=Rv%;p2di>c$b5O7&'kd,BQ_1Pn;4EC„U"JMTku/cXH&_$EgbA,f7'9bN7&Mc:h24AET7XP'v2rfumVBdjZGeEcflJQ/z-.[C„U"HK'/'LF'\MIiQ8IFEsBtT-,vYAA&^gH;=pH2RVNg;/o?avi.4=g+OmK]lc28A(A„U"(WA5EJgIxKD?9m=cdAhz;/5l-J6=)lshVn_;F'jA[4x_IPmVtirs.8iQ+;SVdZh„U"DW<JEW=8O=>V(6_6L4-O]zPrWtk(CJ(Fst7AG1aHGTW]&\<,Z:;5.jZZ']UASkV„U"GwYgE9ib^'7^RaII)XJ^ICDvuSFjN$.Hd=H):T_pdU,g]KR2vb8wuWdsM_solo0„U"F>74wh_3Lhv<PwG.iV?p&GcawfPJ$Y^'6]998nNa+OuXM..]dHIBI'lcU^SBivo„U"w%5jojIq^(WkkOowZJbNe9ML6lB*wl,wg#VkEvsVbGC-j[l%77g19PKPRyE..[<„U"-XP&f$/#Ac9Akj=%:Y/oiJ(yP$3iXiD&4UeYo6=UO0MPs\s<Y6QlsNT)MD7f[D+„U"0*Wn>*t>U&zDq\EGp3Y%U/VBFdOi84+x84i,U^.nRtZ<6?oVCHM]zd[/,SsC5)J„U"r%C8DmrKNpgzbi&J_*)Op1eH:[4]%l3nJ*'JfmX8s.CV[g,<g7_tJLWXNd7Gr#s„U"F)87>/Q*bAr'^(y^VCmXfwpYqrd:qtU'sa>#I0B(#C:-vYHZ)HHP&-+,+eKQ(XM„U"S2A$;OOd?tAKIc)_98f?/pjs^#ev%kUe3pHNb.5nm*W:QCnOHH-hto[-qHvd7r/„U"Pjo7spKJ8\PJYGW)mY,sAm9[g$gl3jnO/\-lQx.HzMtp7Hkm%E83j#(EP'_mVPL„U"M/Pq'*8V=yMb^.xE<p$m6N=7NOV9lW?Q/r2^U/*;,]Df6w1&:Oy'=:;TA7]csw-„U"L_j9Qr1C'S$R^[-)\>R?kJ6eQYVpWMspmoYg2nJiZ28X;j.(VrATbxruRpwlBeU„U"TMh0)h]Uof<+%s[TUQDpHSVtk;x31EkG6Rl)e]U;u49Qm$sNQr7MP0H'D<18kRS„U"6gCKT1ot-mEcpu1?Z6nKga2AMG##AqE#s_8;\D$2[s^tH3g'TmWCUpHck&x4wnL„U"<>.m%u3&as)n-N7s<5krCj/PM*]VC%(Zp56L]D/a+J&d70_q:fH7zCxUh_T94Q]„U"PcWMH::?edZ:hZgO06V'N]=L?B4IbBc(($3<lx(NY4*Tf1UShQ2,uMH\Yw<QJgF„U"ULHu#dlDJ'WD6$ipha$FIRtG7t2$G(DccQ><jaL?]=AbPodR0tpL2d5PBae5\oo„U"BWUww$HH40KKkx[5dW[g>rn]vw2F-0ZsEez&h&:?/jH(?dylDf4vC<tleG7%n0H„U"PmP%:CW1(-e%9w;^A(w+W20q=#KV+0L>FPoEq^XF+MB's,.U3kqI<0Id&a*4Fw\„U"A)3=:nZk*%JEN#FKYzF\f6OpqDa^l[Ja/u2x,K9dRC[CYdb-ky?=RClCmj008AN„U"<Kh[osMkYBxu*L+&M7;l^;4O2)>jP.)IsZG$vN%up()%9%'%I-%_BRhHM80]<^,„U"%%%,<%%%/%I%%5>MA<4;J?S18*f'vxF#B6M:c&rd%Yyw-,*%6c/n4fV#6+8,\Pi„U")o),ywnM\E6tF24Xyhh(SgWPv46GE.7ZXr'ucHCS'pugbbrZ3$d=uf9Wp_KmdTY„U"PLd^ih/o[T5q]-,i^7wG<azc<2O2U8%?MH?N:b$.%=Yg?KhFl]g:GDrX$[^XTm:„U"t=U0ipMx=t(RxQw<]xW\Le7KcKGFKiEa_TxK(jX1#nl/0S$[ZYw(b>du,x_b3;M„U"Yo4trWZZP*QR-$-^47<:lpENF[DO2e<u:Zbg8]kIt:396oP>hp;]t+JYYm+ZFX$„U"8rZX>57x>,;=5So>W.+s(M6f=7.oC)opLUVLgRj4V99r_5J)g.C,=^fAoxymMeT„U"s42Xee9=Ra2YH;Zwcm$wG^tlER_NjuXhAoj7[DCtv?+LkwC+,ElOY.+IrCl]YKW„U"Lt,(pG(:$%)9_NtB2nurRn(a2R7';=8uq-Bo\72I,y(oPnuzMdYkDE_M'7Mk5'l„U":i\rhWR(XOZfIwG0k0?NSE-ScpVtR('M9=Lq9V1>lli3<:hz?YcP<LJCq2Bp:py„U"8=hL-MK/-%f>p,*_3o,dAYxgW(4Es*#l,(75.\.9jIkaFcB4%p_CQttb$=Sn'Yg„U"jxAnW,Zc%1jS('of3jEo]0TQto*joT>7E+\aR+Es8xjMD>m+eRuv*=EP<AUr\jS„U"1HcG4U1uwM81(cr\\l\H65H[$;:Zh4ipI0l,Gb^(4qF_;t]<irpDkGF0DMif,/u„U"/df0[-Tle>-(PG'tl<s[,1m(F2A<,>G>;[OIXbvZaPn.=Ta#=YNmb,qn$c.F&ut„U"eW58:x[cf(Y0s?K(YaWTedZT(k<li=L0o0eA9/m3z[w3y_gW$68(0VAp6UL-VaS„U"(k\Yjwi5q::D,MnS;L\8vGT#qIWi&aUNBCQD.iNAWwVRm^J/D$[Ab'HisXktqqf„U"QI/w<q/=mM\WGGt8Y2=g0ZP^p_qEeSLPS)%Uc)sO]-;m:QJl6X;[B[_8*sYxe$l„U"C1?Ggc+M]4PDm/)Q2G[,YZ)&s$\Jh[h*kIO\;Q*tH-_z'tEQAMmgp<)fihP\[np„U"y48\=FB0'ERQ3OtYqXL+SRg%Pg%DimW%T#lh/&t(t3QodQMh<gz3G'H&FK'B><)„U"TWAB6o,?\oW;eea>G%5NfSbP6_3_sNb?qaD(O75AGIcQk+k[gSBs)S+nX[T[GGj„U")J*%8g)pUmeMYGo)\7(&cNQ>oQZdMUU1_dNLvK:YowZjhk1-TKw>kdEckad\<v.„U"(Qrh?[>o?l>6%Da+.WV6VYid#Fl3r'ArMqO%QR/l-&B4d#uxfn^n2cc(i=[[Z?Y„U"['_BJg.<lZA\6b4(vqR%FNhzvy\tjSfH[c;4h-i\_b$Mx/HJ2_GVd6.8uYM7^W^„U"p2UQ>GD5TscP'-Zv=NNbL6TePC#L:2o>t/0c<1xN4pmZGuo*e:Z;ei560xB)Kq$„U"gkYo0kNqAIhKVhvY^4us'cN-0xYIwe0#EMaq]c+CJ?ZY%W0)rz+3\j91?;P.?PV„U"(,:bsvZWd#7;(sB1,4rF[1R'+6fy?2eh^VUg,cmnV_Y4KJ2uRwxmN(Mju+YYqhp„U"T=;lN#;o'/gO,o8Rq6nAiB-6HEcx]CIQjM5%1_unf)I4Er]m&6o6/Sn4JP'3oP^„U"=,MQn;K^2q5OU6IqCF?Ly,41vmyD##O+]gc1$<2Ca&Al&_\(8KBcY=TP+P>&8D*„U"3k=69XoP[q,U?Z2[aa_^;Hd#SYklz&Tjk8RFqu9%0v9Zmlk==<e4>aAfY?I(izk„U"LqQPT*a2/l^R)KM<M/A_zLk0-%6.O1WlX#AgfY\;:uxMRVZVe\GtsQob-5FxM#Z„U"BnUNIaHkD:le.R#:29aB;:YQ?E:$4NcIMZ1QXwk9B%Q0miuInd9+Cbi\9[(pJV?„U"tmt59+vSndcR_]:Y2NP8T<*+TW2,?Grfxv=Wlrsz)GU^AdH'et3?uYDK7l89jVx„U"06M_&H-;\vekuv%ohsF9:btd^GJ_L^,/#\fD0RC1H.-Up'*Y;ap'*pt<d6/LPo_„U")F_Y/lM*)D9/0\8&5x/?aW%gE-)zLUf_cyt#m0wX4\j'Q#lu,JjSJrr)#mrCkSF„U"2Fs-HX8FU_KOIt0z'&,97dQz.-Lu^(jM*\?DLm]^^[\#$eu+&ELs%YX<_g0J[8u„U"<WGWpnMK'kj0X8Ziqh4k[s73DSo3H%ljglGg2n7J5?x4OEbo11dTFH3s2)VJ)j7„U"T&C&Ykf[md[j#b'aMkXkg=q#Ga)bXM0HgQN+3;<Hm2-rkk&lr1:8(Ghj-W?H%>*„U"vvSg2B/Q?\qngP#/;7QuSF4jsw6&$6v.Q^44zrlal'k1)^v\Z0]vSDY_>R0OgZo„U"..]06I_e[f8_PP6J:MjV2L.+qW4P$4,7rHsVf>3Mg25blD'9JfvYeY)K[[hKRp7„U"17Ip0/82\PqlTO.^QF-(PF-XT:kmOh9G\7Bi^Ls<dcvJ)\-=r4u%p()9%%'%-.%„U"97h1HT.^&3&(%%%s,%%%/%%L%B20M==4AgS18&jyh>SRU5v->xx<f&Nf:G-a-rE„U"CztPiLktq9nortamK<[ZWQhfc?kXhSR.*?gCYx+Ps8tW4?pge0?a5^]jc3OJ*m=„U"%w1lyW6p7xa#h'?$I^?<^x\C$BX2Dc+EfYp=JU^8-rA'3D^%+%U6X>kxnI($h_,„U"99#DZgr>R9)01TrmQ)0=loL2&B$4xSqZH7%h\t$C?L=2#rY7MFhj2<mZTb#[_VJ„U"#uNt)Tp4Jvw+lae\6eLo.CVFerE)9*$3BATC>8c>'RZIO3Y_&9gIAm*=#ri'\FR„U"Zc;?:n;Se\Zk>&tFJgK#5jwfAuJZ'B;U.U-t9hB;75rkCXT6Bg3o>t\[&IdszPW„U"X%c2a4S^o\ISXNw2%)INbW[ZNu3E.>,^;wB2L,i,:9)c^FTUO4Ge,z]]\6RiC)3„U"qae4G8,KYz[p_DL8U-ipK]j0GRlElo6k[)LL:#U=3RuLYm-WF/4RUB4<9b_v26T„U"V2MQF6_Cgkv-naroR'19[k\++[?m.5ZYYL_ghjAJ-e:*2g?C1saGJ/FP<=Eqe1r„U"OIKGqhDFw7_^3M:KU8g]=I?y*N;gQSg-=YNkN\ZvaDAVRtmtpC(f-]pp3&E'jaA„U"m$XO6l7k7Q0?mUwRle-o:Wj-K,lkJ%b0da-p[<nxB1bixUr.DFUSV0sm*p8Fg=T„U"2wPyLAn/4h)kvCq[9:;[tq]Yo3S'n9I_OD;Sj&&k_l&kHI(ocuYd5YdN/-<>?O/„U"Ch(mFNk/Zn$bD$^ClSF&AS&T6JzpoO'O+[GZzR8MZKEf:X>dW=FL)YYmn\Rh4F^„U">pr^S+\r?PmF;P?M\6[[d^_g,'bSR]%MW*&Qyax<G[$MF9AB<Xm^R68pA;ZYCTn„U"8ftWmE++ibRd#Nvo_q+N^4pSM.C99QD;JrJ]t/Y/e8RC':n;\pO]uTkOcV:k[Vm„U"b.NExCWK1hHDW=,]fP(N>OU/kV'xMGx:%>rb;TIAVeVt(L.)7_cs2%up()%9%'%„U"%-%r3#xHG1;FheMd%%J>%%%0%I%%5>MA<4;J?S10GBeb:bFT[+$XJsxL(qD]*>g„U"wj:^^?#ttdqJP7(2JRR\fV0t]c-,*%NwQ^<^MQQXM6%+4'IFJLnklWg,.*.4'=m„U"1+l?kOV36sTrro8jr/dQRT0V+n3MGW8Fcv7>tZVW/[pFp=2#wtQ\hcGVp;Mj=f/„U"#:4N#,XDumYlv6W(MG9D+Wuiv<qh-o$\MALPOaf6frl-El>M9^i3tM-sij$v[E4„U"gCM'#<.r:XGJDl5eJ(5.81ba[e4Yp(.=]4bo&[Rp;DWN$ktK2eAO>WYwnnH8+]0„U"h(mU,Sk*ZD_gTnEnua8Zga5#*bgkYts3T\DT%2-3hhVZinFC)Xp/mW.+>+mw?Gq„U"&4(=saTiKgT)r[CZ$nO0&tV4DVm6.gc,]>1$,o]'O[QH''$rrfuw-Bj8Ld\$;Zl„U"Xohp,Q>a(6+*8/(eGsP7Cah4;-*,46&RbJ+tvanV$YHOG1E4QU[cX1W=;vbb4xQ„U"5Pk$V0Gi^];cq+_Z,El[,lB%'iO]PS)<xH;3.<vnKnLLO#W_M9ee8W\qCG2\0(c„U">nWSjo).E,w-ORj50Tkn.(uS06Lmuf)l,ijV\'WL5IXqsD/<+K4lSfu]:>t0-4(„U"hiEFTnz7t2FfeL;]_l6+dz,8paHHds]bIis)Fls#A[X3A45HGto,n0\DE)REGe=„U"fWmIW#wQ)L5?mtX-W2rKm;e;3[?rLVBA+;a*uIM^R4m<^K[[gMpQSE;i8&#.7AT„U"i[uv8WvC1m-Dl(:f^sxb]i930v[[=eB3a?]k)U531ODNW6t_HWlEbv5o7Bun1IC„U"TDL>u=3oZy']FxdG#G7LS?C\DMQE_;v\Jd[HuQ51=jJ9+*FD*>7otp7LA5>N._O„U"(-Q)kRY'DtZYbT3qD:d#KVZ3P0CL0-FOX1[HV:1p+_\OA-r:mrqgT$R]\QMYbkH„U"D*-,ECHW\B2EbObs9-l5+OZbpECeneMToTc.WG,y2&&MAZ-:xRnN0<QS7%ehX($„U"koTHKlsSW-&h;.3&qMR%[MqKF\Xr*M8HVEk/IG%a/E.X,MQOWM\/mDeF*NW*E_t„U"u9tH5.69HhLUH]4Y'1BHhL)Y06u$./#rbGL40b*,xGUH?]rfW'^>VK'CQ6VSb-B„U"T8GZb?))jQ_1(Rr8nCL/1#(+8\J5lzS.[$2Wn'4NJaJ)Ci'05_kHsr&UV$p%8*5„U"QG:r4t>#&?UI$MN.,x)8ppXo>_xe+aI(wCi)K8WWUNW?8q.DI:g<DPUHmD>+IoA„U"K-E)_[,6[EY_'2?^Ch4%?H'vY'mvYf%/-vG-9dO&;m&0?piiVq[)T(JmJaXfOs?„U"JA,XB195,C*..Y=UwhsSvikT<Ok\nr[sAaD)WC3*=plV^H'+AbTag0Q+qA&A\<X„U"vE_aMNt<\ua2O+RxskzO2raqaCY_IL6F3%I.jQBD$ASOYLtFUF%3bKRZ=Ycg#A4„U"%kW<+YCE<W<1\8jpd9Kan<LFtUgiwo^McM>dO4uK-rwTiCT8;wA%pelF$6[F5CE„U"<k[1)g=-_]QlM&<H-<cq#Hhb99Tu=GCJrs(+=ru\ecLIhdQl[?VEquLl-9i(77>„U"ul(-=Ol^*ga)5K_ipMV&C8$)6_l;+JsW=CL*)2ck>]^JwXa/xHbSnp23AeK;V-S„U",A&zVG+eZusuM$E,StUYAmHpr73\6)OPguWj;r8^LK2b-u5]6lA%Xz=(H)c(es%„U"sX=Z>1X,K(EL2*SC)%fd%-a_KlU2Ic*95RIQ2v/-rD6<kwE2'4k^FpiGAis>3rf„U"\a]JV8<F^):c7t>r*AfWl0+NB1h7P2abUDmKaU8xYl)L8C3(*[,+,^_qbY%6?A-„U"w%b,XH?=u^+9_-I[rapUgAS*:W(n#>*uO1](mHDLifwJP$;GoDiG>c>(%SMdN>0„U"8Q&9SE;*Yl+]'qCLYOcma&1UQ?Di[WE=cQ?:qM.172*AZSnrB-3eQ5iMn'yK/8y„U")enOtbpf6&N1%HxLE'LAufR;7ev^5S%,bWA1^G+*=Gm)8q4h_cThYx[+am1[9(f„U"%Scdrm'o7)3%djN[OBUCv3o$,C*iv>mr1H&75nGQpvKAc0a3I>('c=hfHd#AoZA„U"s84[px./M$(WfxF/2S$yMP$a5L'&-A#bX6jID[S^./xi?kY0\:T_pc-*\;laD99„U"Da-Kq5'lkQX(;q_;YC8e.23*N%V&,GX*)<gaNEF9AMGse)i#d/_3=MPsL3T_=t:„U"KOY&2lid&Y<>OHG(u&OP,yl7<XWfo'1aH]_+XEM%$bohR4FCo8Vwu?=AvOTrfN'„U"529^chJ[&\8fH-DXh&2oV->Weu.^J\vLJxCta&t4N1YYjem/sS]FbkNDB^)uz.%„U"q.QU]2_s&UVt_fYrl]YZ#3h$Gn^2LUHK%J%Cfa35AZFB&\X[V_lH<t..w-qcD5-„U"dCO9&nIj.iZWxxb.[nUdL:Kt*4G$%ykar6Y2<OFL9P9J\W>BH%J,8m?AdJ\i(/B„U"3OYGB,5[_*awSH+RAjo_tg&4G*QgSCk+30\='K+13R.q/aM,6sCVhN\p2(&zkAs„U"B=/cMm.Aeb$7QG+b2ElJ[_-9bCYuMCFxi*gp.oPhn)(Oj7mVXoZbvK]bq,U$n0J„U"Bo]f\oeA?/+k01Quv#]8x:HpO:-&uPBjSfFj,K<fBDJ5-t-d>h3g4B*P&2K4;-Y„U"uQ>nlTqtljh#;U_%\(uT0Xw?\9Zd0nj4wjNJ9M0O\xAAn5Z8-njP&(ueOV\VLzr„U"J)&QD5cS#L$jBqHi+HuAt13F^Ks,mfuoeLukUt:e:g<V:IV>o<*$q>)xH6:D>-j„U"#-DY^irjQ0_7>mehnasRaJ,^_G[_[DsQE$6pbwpd0uwfQGk02<FH+>,7,_O%Z.i„U"(PoJE<'bplHml1NZgKp,PZ'-4XxwT9[9ebNuQdYs9E3(9-b5tFQVp9=UtaG;GK&„U"?xIB;<=?R9_wJf'ApGDA031KNz[EiskZXUQaE[3dAfE)^GF3Q#.^8y,stVptUM]„U".y;o#frC]]5K,+^ySIW,u<>_eLRyd$4$=(BhGiK\LD6e6&h2CivyM1r5.>k0OH%„U"(kYGLaQwcc,LUw%sX:JP=e$LwQq5ce<HU%3k9B5+Cct&-L8z$qGlk:0w.(BKM#=„U"Kwz%-19w+vtM9[hry-aXUT\E/$LqXZI.t.bgtpN&6C[sFN4qj(nDbSy6kLfRf'B„END SUB„SUB V2„U"LyHqEpLG]$WYf\Xp5S&ctS=MlW?c%z2Oh%ym>%>+q4];/r(c77])mK:4>=IX.eQ„U"2-uH:3AN^*X^jv\GV/+sr,U-W^m.Z7KbD%1U^rEgWS/IZhV\uBmQc]ig$Iy?Hx=„U"cO]M52^DUNnprmiF)jc.]&qg:>FYhkGIC=)%Aj^;QDHEo/N<Finm'RJ&*o\/KyE„U"#qX.N#C]IyMi&XZfHCbUpTxF5dIp90R3kT=M%sl&V[HH[lf*)Wr^_)&O1\q-PR)„U"fQ.d^1p97fI5CFV;U+7aJ\22P\7y(2r7ZXhJB'XrKAdtcI:9soh6TOI,]z;6BD*„U"-3??1W&ro4pY?A.Nfyp>1kIwx.v9jQi4ZBx&%o'BK]MMh8xXmN.kM7cCyM6/Lt7„U"g0XKM]C+a%Co3w%Wy:#W<b&*rYUu2BU#l>[pEkl=O3l:ZD'p+ox_ocTCN9xOUaK„U"uQ--$2gO.mI>X5DLy>AOoJJZ?7\D=*u>j//b=eI)O>9L/)'9wp$KW5WKY,99%zh„U"gZ(e1DJnUjq=aBLt+<^z+U/Ow*bcxRCExFiHXGphZPZ+aOK3MJ.Cfc\(f.i%C[W„U"B.a&SK.Q+JZ9L,6'OY:Laa7RuQCVYL]b,LcvD<o+I#k%zy)?>-#%1]c5Ja=a+X]„U"i4o)?mU.^[W_4BQ(8G[,hph1n%MF<UN>2o3PW\7MP(-sY3=eq]llT>%GK&nRM%y„U"vdNg8xKWSuX*:PnN.lq?CFRzrr/PfekZAXoR\Xr[jw\kgFh57bQLHv6^n\,.0Q$„U"n+VC&4y3xBP7jK[:L\*Raeb]h1rOSXfwi:m[tfW/Wei.4#Ue6$F6b>JL=(eW2;/„U"D:RKRW_s^Gu9kE%16*Fd/=*:mw1d8\ze4u,\C(&^x;OJAO$d)X\m6CFY]bYPif$„U"k&%myYLlG]LVf%1oco-++Q>3OmW/*.m[(OAHBaUG:,9o&A6f(,j&86D'TJD;QS1„U"Gv[-,_O09I/1ZkvcdW+Te)NCFP'X2K,,OX[F-1rx8tWjyA4pRo(G2PLtIZG';r=„U"=TtAva2f\]D?*:=YuhWzVVJ9q6E$QEQC*SXLu*]wO%b#9Y-LWN4vJzvb6+w/,.V„U"wC%&$5I$)3nk$v#[xn&J\N&rJ),BYa<IHqGpW*,:(Z2lq5ioCR2B#o;M_Q5\w?O„U"-2n,\OoAZ],JrI()d#2:&ia^d:Er)67<oUgx8pPMf/,J_\Cf9&n*Y.Kd#[^>\[+„U"cm96(A>7[kkbTV02%Ic[,G$&(h:)/HAOB)-%0j/p3_y>CK^$dmj*\Pa8d:XRT#(„U"AwEC,.8*Os[dR\^Mv[vOg]o^'a/i?VG$,+dN,Mv$Ne&A_tG(Yx2h*0cH(q7/OIH„U"GU_4yZpC'J,qY$G9P6A'IUSc4Cmt$Jl0f;4+nM3wmgh?6G><=+[qA-$Vn54iOO7„U"-qU98ShM#tEw1+uE>+78uroXXj7ANO>3gFcE8s;kOr8c3X4/2OXIAK(XYyXD%I(„U"Z:R[</%db/X:agdSWu*PBk%)We[,PUsjZfxe4-cP_13lUZ?&lnie^iIS]eW&RK9„U"0QL,OqCijY[8XqJ_liZD]u;o<WFmFiqkCrHRCm(1,Es2TolGL9LVsPx+#b1/-b0„U"Z/1<*(gfy;aODE<i5>C-L1gtwGKd==5e=Oy8m>j3lZ,hbUp<)T[ZthOjPA1E_YR„U")m[to:.I'N/ur2NFb77Bqx#.;J$*_3n&8uK;x1[D,eG'W1LgS.$H;StP+k]HYb'„U"?DstQGGF^$HFO]A_Abv6F',U*>DwjB8ziy[cBUc3Y04p>N?,3.:hU9#\,t%ho#?„U"dQ\wQDI%?1$I<?Um=Qv4p#/n8o'%d2Hc%x's.E.e6-EJXfEFbMO?I.Hs7)pYE'c„U"J#ytog\*+^PqkK[pj3='t&m$=tJ/6iLz1^j(1AiNp[1)ZXFY7Fr0DrbS,AVfT>I„U"<e6mRJ?VG0Qd?^B9.-etNASWe2AmxL%<5J$,iIg?6'QXrhZkD5HPX4Im(4wfK)#„U"Diqivskgu;G69v/P*:.,ZG<-wAA0.;plGQSR08ZqBJQ3uGzJx7W;V)7mtDEsZZ$„U".Uo._$blkj*M\<J4F>INW'At7m%Keb;UW]+6j#bhM*i91ZMf>hEKUX%zC>\04zt„U"8T8O?%<'ya*Wj[LO8EJ+FDf&9N:H>jrT%q]M(_jP_hf)xtr=x;+1:dXO9>_KSN'„U"oTE9[.Z\b>&]*d+hLRBk?BClN5EHrcJp5<2RUhL*C,vku6+6tvN6&sc(e)CgogG„U".$Y__k*f$QL9JVz[$HB&NJ;m=5C0n$%rVyN%AMj/;b-<wR:YrJ(prD_0nuw>76Z„U"-i6Agvj\E:#UYb^)2BIdgMnT\lj*Y;Wc+^/B?PdDctKck<#l.O#Nrw<:IQ&s5Ma„U"scl1\=_sb1Dc+Ite+p7W[fvkhotrdm[ELwSQX5;3fZ'/JJhOoTV)aEYiUicV=a/„U"%-GKZDEnUKq.=vX:)ih:$WDmDsIhoSr;y0%=(R.PE7'sfS)W:[ygEf*.\._7Qd=„U".:-cJ>-;W.^piNJbgXNukXl5GDZi:s*2YD(wlC:__N>DO+JPVP2Pl]BI-/*Q[OW„U":Z15#1_QV%,M01KI[eAl5)f(pW'yj5,,/p>[isW__D\m^)x:iHRtD9gR9U1lkF\„U"2u?nwY<WuD+Fq=BdQ<3*'A07Wne<7Z\W:)R861s&GUp-zdQ76&8h'L.C7%e1N7f„U"Iwo<F]b82j-#KbgR$Vr>/wpCc?w+H0KKK+c(W8,Gd4eCV>%oB;M*$]HH[]21Lj0„U"iE9D0g.$tjf*N/z=i9SdE<kEq5RpZ<g5UjLU?E=QLa-D/*MJ;8q5fsO%CBxT6Hc„U"DtJE4b(9C7.qP4]MAIi+<sDo3D<%oiH$LkCwfZ*rXotpbS$^pK$_-cpPB3L6^zj„U"BW#_ndEVQ'G:Rbde+TmO4>mw*71Z1_ro;VQYCvQnJyA/]1zZ-Vro7VQ>7NQd&vU„U"BB1Amb1M\NKN0Wg1c.rw)^RlkeSOc;j0,2)mT61R06#=[q/3=c$\uX>MeLwJ:,<„U"cmpJGR[rC6]9d15c(cxAm;1IS(_KS$jI**lnRUk]dM2:IvPSVQGocz\&Zs<d+(&„U"\#pp,oapU;W&nxcdP[p<x3u^YQ<K0nh'KnoK?0DpYS;\+2o4U?GH.K0-3Id[]dJ„U"a%A]__6xV23O_4b:sRXJ)bh/*.MCn,[Nj*Kwf'QeVI^EN]\kCRYQ&l(/RFQItVd„U"7oh%t1W(Qg^1W,j^jLVlUrG=Q96M57Pp.dlDfj1[P%X3DTuz<GNT#i4]V/7NGQN„U"<bs=n=CA)5slaPwaSV0F+V?Wg:VZuu1JA3N/7\B>YJ'gfHB;-K/JWxfpHD$sznh„U"2;kQLZ3b/$AGqrqrFXfAnquK3Y$oW[c__+1&Q/E63CTAC2%IU*NY$bE(QwlE#&j„U"qAM[Pl3lY7zrr,Rh]\;6'r2O3NN/H#,GcU)rTBw(w2[J;&7#D\rZ\<,,Yc,VFj8„U"51tmHoTRfjcMxW#(N4]77SlL2^qiK-N*\QtVclK*Oa$Z:)hg,4Yqg^,l.5BYawv„U"l1Ikk^JVTItL$8wLiHj/YdJkkgt$*UPxC8]eiE[le=u&pn1AffDYP<Olrc$A[3P„U"+s<L;n]_3o:\l+DGn01XLNN7#T8.Aa*bkv>wo5k8trPB'Bf7rFOhJld+'4t#eUh„U"y&y*TLVN[kgpADef<U*Xa1&mG;-9sgktj#Z9>Hm-x^TRPwKIH<ks?[<kf7YLmdr„U"i.CBrx%g\4<5+5?xQ/f'hB[VBVeOWI_r#FH=rd&RF'uszhA9o&I8akR4Qnn.j5:„U"rk_Z_ta/KTcIXE/,%vj0QCrqe#X]hm)%Dk,'c+PMop+<V9(TnD[E,k,;Wx9Q9Sv„U"U:+#Cn7sWs)kZ/C.ApV.E)j0cp.mo-l<(G:(S_?=8Fum:#9vvyFo3*4pJE?^YA9„U"%)/,J$xYOY0M\jh&%k(X:rR'8LAoa*[*)(%^\5r;gWD+xAhVx&-hE'fW2<Gj0yV„U"<&&Q1DzAsaSKr#$^z%f9l^%YY(qr;WW&hvA)vnsTW'>5J8mt(O'mbIHRqp>Qnfp„U"m?0gwu=bQ.(NVdv?n4.-IJTW>D:T8jY0Kc[9#TIuiB5#'PBJ*:p;fq3#<3mLy#0„U"w#<D:_:M_AH>b[j#\2Tj?[y#7-nNAr/6#S.Nf%<8pL[C40D8WW*%'<7i%QY.'t<„U"q)3G$K_BP=E_wEuCQQh.ay$KB:?wsdCN5/eItrMCAVz[%Vp08AubhL(m8mX-N'R„U"i.54*8_^7,,f/M3%VOX1'?u._\CF][Z2ekc28/NMIMT_ullSTc7iU_kF4V0F%(o„U"13Fw4qr4MZd#$oTG<qIh;Q$*Os]vfK5H;BaxNR1THIWQPSGYirTvpphqdh6B]pA„U"VIsnFrT]wOR22LkI;UGn]Yta*sCz=k^ZwI^Am2)I=RN^+3K]Ubf<b5B'e:^69NL„U"MIvodmjGMl#3]ra_CKB1MuWDTm.Dj\jKCUvnLJ8>oe$&a%BxO6owe&&pjKkEB&7„U"L9YXKH$.v3A*;f4FwhxQ(q-=6Mt67m%)VrL=C4Z4?Dl=ONgV,oIV^OaGcOziQ>+„U"IdH?]*y4Nj9HG-UX1V7]A#?=d?6-=4'L:8nf:p<J]k3Ag2tk6dTetH<\Ytbma6S„U">a:Atq7uX7^ZW5N2pIrd)A>dWV>=-D[k(3IT:Eo:K_h.RiuCPB#'vK/>Z6-[#8-„U"^=p]'h;.G5xVK(3m:<,v^U:vKjS<jb]L?,1VWCBG4S]cPvX+csVQ25Efae%-Y,m„U"4E4T36koSfgS7tG&iAb[d<p2E=Jd<^P0yG%Xz(fLb('?1Kk=\fv?XUSdUwrP^RR„U"Egi4<uMxLx[sHNELW:Rz4VDdJ>orisLg_o#],gyTFV8mEHQ4InPjSg](Xu/Ya-U„U")f:eSxL^7GA:iO$)'l4_CVpt+vOYfgaiLyH<RTe2GvO0MLt&/qm9G,lYk)dGbV/„U"Rn*>HfrvbmWWrQX_'i3VY*v(gn=zLp9BAxi/F4Fb<Umqo(u%nPaM4$EkbosKC^k„U"7LPe,EY9l+d)y$io',F^/YV-%fQvfZ=^YO+I]91HC4T4xy/1pR#?a48CBrrk8kJ„U"1K?#F1BM[_1r\J&zGmbIPUL#jx?^WNEOtpG.DcTj]aH=9ou^9a;GFBmLkmN<#_K„U"CNg4z\VeQPWOdl=:$R3^qPB4(VR3[*?CwZk_l;^cJ3Lr]f0AD58bvH.URADL?WF„U"Y?qyAdfuWJC04BpK\3$K_>1[C93'FDk,JA1MZjeTcV>gxe8g?LOob(<u?9wiq*P„U"<1_7[GUVY$9JA<*:iV6H2'ns8>p,lQ&flmMzr]<?f0U#e-$fougBn(ip_X:hoyf„U"?N*S8V.?2IT4oG7r#j2?>;KDe?]fDs]m35=0XjtlX<QP?+9wt',Cm_XN,$3]G,?„U"Zq<sl2oZN,bmSl=lm>f8A),(56VYB4[qM][[[,A;P_e8Z,TuDi\(VTw;,h-wrJ$„U"^#Vjv:R5l:$9/X,Nrub8tgDTAPvqabL&Z%=a[$RWQv)BmPL5b%SLq+L;[*nVQGo„U"$e_ES:^94oDSH;;?5lN'flcuwA-Qc]oPuA/b\4MTV(t*Hp+qw=,vrqwerl7wdf,„U"88zDHtRc-Z0c\D<wkH.4CwtChFL.GaEC8wm8+\.7E*[Zen5gvQDG(J$'EZbNH>.„U"IY^dk=s^6Vf,%4W&mTadVt=oh&Y-?hXPfJshN-WAphG)u<h[Ey<^MT/Y;P*bU3a„U"6/wj$#n,BW$Y<_H'0.;V6SsKL^<n,92HbR*imw2uw.uE>SYoAr32O__933FqQ>'„U"J\qxm^Kz8s?:.Ts12OEd5*^V5uxBW^B>_$keU=6H<aJrMWH<eLgrI2,14+9^OA-„U"k+cW+M#fPd*8iR>2DiIp_g?2+Vt8'Z/Uq&kgm)xr.$ZvIf,DVZlEoaTLY7l)U'?„U"0M<>h0_vO1G]mO/?pI-Fjg^lX2SLRj\4NiGfa?:>GkWPrpmnWU09OVe,.rh9,k9„U"G%-C<NM0Q5wRi[<5%a#Y'pzW+U8T]7.QQbmDt0Ag>Y(P[C^gWi6r'4U9+=%jN:*„U"6Vf1#Ca5-J(zUM+JCa9azvZd-8848M99W&Z>]In/(t\WL2oj.f?rst[M,IRUVYD„U"LAPg?Kf2*RA+,,iI3v3z/VbzQcSi\WkJ5yg2D7+=Z0T[y]w/LnM3'^J.s)Xx)5[„U"v_^zU^_EOK^2dPCIdlf%pO0/.u)Wc08c8I?ry_sS%G%'H_t;&\m*K[B\+8[H_./„U"]D5OMkqXYFWn2&mQ/-V$bt3()\:faT*;W_aU)T:ZYX-/]iaKP;ZIfFY=e\a.UZ%„U"=?\=R<\4&#GVUar2>x*h;K>xVO^%J%tVv'YQ9U9,2te#wqA,D7X#+KqslOk6]gl„U"=W.H^W<gYD]L7$XMI.pd<XwUy9xuGLt\hegB%rJP'DMC[4C;9Z,ihb.TM&%#Z6e„U";<jWCgpT5(SP8(ch/uw*^S-3[k&.+(ty2wi6j7it8<\iCBN^gGeifZhL?$w:0s[„U"^MA(7[wX\j8*&bZMmZJLqr7xMG%bPS;R:[^io/gpw#;&:.naC3vvM&//JRKco_G„U"mp+4rg1&l?v(v].:[Q59%9#IZ2hTe_KDRaSy1V,hpn[E:tGm5hQg,rF-,GWW%8i„U"0\MPC5MIhncE]ZoUd1cZPRoZpifZ4NNYo-JxNvOG]Y:n7%FM:&,;%Sm.-[]/B1y„U"9:X;7WB::F(c1P6L^XE=C/T/z:^jo8r&qlPqBnc0'JP;/9YViIoKaHWZ*fgCCbJ„U"OkQ-[b.6P_IZzYF[qW4cDW55\*P)^'>D*4W5'2K&-,Ql<*>D(A(B0>pdL&'M>9>„U"w[ppW>.?]%+$b.QM=QP_x)09'BDr?eW9Dr)qxLc+H&#Svvtp'Z59bQ2Z5Gx4+u)„U"'74m>GHn%V[H/(jvI&H8U6*PV<FHj?DuO0<^5M-p9#aONXO)vnM_5Cqo%]W0WC*„U",&1.KVH_lejs;1Km<=L\nqRSOEB#h66B^WM>3r7/]r./<l-$I1<Xh_dM_?x<&sE„U"jVE\-/>X,[)Je\MMdS3la6DOe$:;jqtm)9ipqyLCZi_4trJXLt-V8ui\)-U-4=Q„U"OSMLH;vZQ99SGZ4E+6N^04JI8SqLAw;c,dn1il/N45>>8$G7?M?d\M:1tid%H,E„U"oyoO5_b&PB<=bbEo$^B)pn#FHEluC*t\CE*T(XF#b]he:umffQkutOa1ie1=Ow3„U"oRAJpdDb+>y7wJHIv9g+%**ko]wX1IOr_?De;E4Fp.f)76DHnUyAO4t$<G7Xxp$„U"R(l0gsJ4noLqWb*2]Py.%(r4UDC*dMN>#,WMsC]$j7y?^.mY)F\?4m/<?P^Vk=n„U"j5Pq<_dml4t,t4+Q'7ldj9-Ms#Zj2or47*^9hLl'+;?.?^pxJKN=SJ<SIs0Od2'„U"I29H_mReJs%rky,BL?Tfh.YHbu?^HWTE_7YX7l.OY0OW^ZAl3NaR9E,h_h=,%rc„U"QDV=\FmmDw]'n5nRYnN^VkA3#HkK[-ZT9?&PWN3Tx&GyM2s.Nc9KVb97-FF-c9]„U"ZxKU'Tr$sQ.u;AX6%CP:7]/,bpo-CU23WvPII+h-*4'OB3%Kk.PKmU/$$\F3'Eb„U"G?4:JFl#Eg<d7LhF<*L?nbY.',A+ImEuXCYVEdKENO]S75R:fjH3;;(pX2FtqJK„U"9yCag>&mBbdyDf2;<Om&e4]UC_Q:4/>+WJ(kcV+PT7><r\=U_J^r:OfqpaD2y3i„U"enVhE)RnF%m2t>\n$*_wAFe_,l>'?DYcKKRUFO*por<vocmlJ:7VmJ.;nbXj)RG„U"S-R?r;UBqcnrWp=$)0hX&MfALk7?.6Gd([Z,BNWpLVAoVuxL(u($JCB<EGs;mW5„U"cDYs7cq/G#(LX+3gHm)F0)Fu:,YeYEoH^]fai1#uJ0$A2uI0'0&((QFbA)V7j=J„U"3;%V*068a+zD:D4y]ThoNFQP<9dX+17)Nq;h*g$D1;r:JIL.+hB9,)BbFcnaw<w„U"'mg&q7#XBbSfmCA&]Z:?\em7]JH3QolomLt(<92bm\sVx)iOcHu7)pqP$rMB-cX„U"AVO7'hzV2s#h(v[T*'Y<4)sVzYE:_wPunX;:j7$LRX6Q=VCcNrXsa/4RmwBhB-k„U"d7=&sJ>r9E$%C.C&1JGh>GO]_KD4rWs2)ppPXPPrbe1D^jz3&OUU6tDY#c.%R?7„U"=$=7c?w*pM$3U#_[h^qFKP#V?=Z,dn:W.+H]hR;h;aQbZP4BiKTkAH)5ganFSxq„U"7U6R1'Qlx<D?H-N*N;Oz2G2'kq&yadOPAi(32qpJ:de>lKT_xXwl1,Gu?f+A^)l„U"3R+P$h5*V2?H*&\fagGB?CTYzb3Am%W?^L+x9viZHp_EZfGf)V%#nJMB%;WD=a(„U"[D*#YZX%5mh&=tK>H#qBm%KMYP%#qBgP\kQjYlo5)UEKs(Na3n&9YR18f]TO]f_„U"yF,2VSvdBz%E$^]I&aURvqh#bp9PEMfJC?O.&?+VAPF=AHN'$*b7(B+8)kV6aOE„U">a$+IN3c&eq4z>KoGb^%f(V9GO#2b%V,F5BIS5_EYO-W2es66)PERkFn+6fr?;7„U"2D*'IIX?F:)o3UAL*[[F1hyX5X7L/)DIyeY>?Ur=\r1TUOJL<_oQE#r%OD4*k9T„U"Jr2WQ$k<F,[CJuh)PrPh%6GiT=y>Fh*O:CRy<lHvdw<[GgA:u(_L(RW*evB'sdF„U"Yv[VthfkGq*b\[)OHJW[>xTFJUtSKB^V:mGOjqTGXj/7O]Rp=X(*nW_>Q#e:(&_„U"KLtMrkQ.cS?;p'X^N<,YmfM,(<)93T)aX[2xeSMfA=?8TRXIVy)6ZacK7]toNSD„U"F4prsue\GX$_c6<I;I:qQK6tuibvTA.cC.2-L>kLU'.sfKSY(W^1,/j:iYT=j2o„U"pJGE,62ZS_TpJGO.k9:0m/:BFddPZ]1[B0fnE-l7jsw2$G<t8*i=CWdA^2Xt2FG„U"71'<E<(.M:B7MY9Mv9O^VV->kBAkG\oN/L'sfIls$5335hA</d?IiVaENhMfZA<„U")Z?S*Iuq;?Sy#IsR3vU)k%W%aBNkF=YC.Sp4t.yfTWC6xCb?xJNEuw?nF=CO=SU„U"euj-RBf%f1lKoZrutotduY(RSzSL;-cf.,F'Q'-zQZ9?4>_CzK$xdZP0A[9xzh7„U"]9id<iV7MiN\+W9fjNj:YYX(bMt)mnpYa%.yFjqY3cX:mBKj1gwfu,_xZ$86)n[„U",17O4xqO.nCh>9:W)z6lxl:X7p).\ta;2$oR($OICEY3tEXa]B#/9dP%BUsDcQY„U"M6>EXrgCa'sC5H[Nx<e]5ic\_)h&86+Is<#<;Bb+kE??'l94&2$Y)o#TFEjoDrf„U",SJOWH*G[o7$&Tu#i-XnEMuV9WD+hu.P4d?[d\kK0c+L;-0GmsRK#4$X8\uvt<Z„U"7x0IZjN5C%*L494)h6Vt(a3vwy)9=2URTN*csjsI>ZUSRvb,VaTKaPn1uQ,4/1i„U"v,BYVLE^7%hY2$/nAT^45c<#o+Et[la?^b$xatEh$l#XuVI:r,g/]?.yS)VVWev„U"231;'0PSOz*ll=#*tRtS)i\pnGrejtm6]rjIP(LMJutbckEcvXj33VH+u/oq[>0„U"v=vEOCRGnxHtHCZ4Ea^M5),:^?9%np[-S/h^jPi;^=[1s=_rsoK<w.b=_G.#m3E„U"$Q*HcKm,A6e5cX-(JBmL6fD-Llg^sfE.cX8u-nFiY(BXb\/,elTg5Pb-;tmSk\k„U"uBRnp;sDa8OtOuXG/;X6vyH:&\qSnp(G90*kcu3\WE/\$QG-l68\tsi;TIiP\SV„U"f^L\,c.A0FaQa_UU:CYtq#hDr(*_j$2X=jid7gDTYx%;W*gWeI_T$tQaf4R#CG)„U";WPno1nHMMPK9y4>rW$F$aGV.Vjpj&%ou\LS%%A$fF]vkCns2XlpNCC.8Ia,ia>„U"(d_nNXci'Ye_,WuQVY0mlCog3-.wHOsJ2Y^Bk=5L(F5pjE7n3vAHXsd/8:.J2[P„U"5%1d7B>JLhcwX&GTRP6CM_k)#Wt>)s&XfAlRQqw=/rk%'OZrLtN2($(OrKg'>Pd„U"UyC0/e[K/ePrTijR/#5hm373??x\S9z0/us[MPp:m,fj0BPDkK-[\S]bLeI&.;H„U"MA]i.uYOF/[i/mktCUd,X-Xf=\0P=;IlZ&gHd9w+_krXQ#.uikJ)OHjtDDj>d$p„U"'kj/aTjNj8DpLbdA)3aAaPzoS?j0%:f'8up(%)9%'[%-%K%3xHe5CU]s%&%%S%'„U"%%0#%%%5M8;4.D83S3M8IL_%tt(F=5>hIMKVfmcdS=6nGV&?ks0isg*'ES1J40B„U"qoN76c</Cm.EFS1ZlWuGrhmG'inS,]hpGRJn?G?j2pH)QsC.3tqN8nR94)RKPOG„U"h8pEN:g5^&%\rXbD6Wm(km%g+Vl^k>g$t,QH.(o4AH&6yFoLzorlF0Mnx1)j,1%„U"nP6%.]?Ek_us^i7p--VQp[e(\;8utdh>)[RYF1OmDY33;t$%X.C;#I#[^ovnF,;„U"ei^H%n>)F_XdYrBtrk7e:Te.?vO-1/L0bm1eB+K)1f&KaN5A4M:<5'Qwr3vlA8c„U"wvj7(Q6<6Adbe##K^0.b>e5Z(Q9XD9*<<[>IXcMS/l:6])#=jb^iq;X,G9FOBIb„U"iZ)<[bXqoI1;$3-U#);&M#h_kfAT)Rp=]=[:aT0WuBRFT:;AxMKGCuQ=1Nc#%up„U"()%9%'%.-%Y3dxH+>7)&$-%%%pA%%%/%I%%5>MA<4;LS10BN.(.>BT]7Np4_h9O„U"HU'Yt3P+V;30%#V;BB=/?r)IY8hbI;o4S;%GpOJc>GcU,68>w8ciBs6kIwjUR$l„U"nl<Z>QpShwC6$iop3uGl)[F<I^\(;iDd9,N*5e<RsSiVxPM[UvR(&K:o4.XA^3D„U"TW*_00m[m-c$:7?d]yF=Em_nWEC]XAGk(97IBqlwo?aR2qga:^.)a'EEe6I=D4>„U"L8gFf#Qq^hm7-D4VJ$\:C96i\4P$39&q,gx&nj6<iv3eLDA?6ZIZ4b1g5URAa4l„U"^($A6&&(4:+^P+vHR45'(58$i=p6:O>7(b'Hqs1Ot4-g#z9A3&0R)c4fA_$GfI0„U"^a3In0G^[6iYABEo$/xXVd+v5SpQ^5^+/6)?$7K7]s=#^cVInDHa6ILk,IEdk.Z„U"_Ki&>VX,pjRSch5.d#jclTAi95o)n_Ug4h_7bsa.B)Gi66l$),rc(L-rYFF/LM?„U"XRm4NrO$F:>pDDKj-m8u=HE(J8;05WEY0dU%Fd4bIK+8B-<ncQ&p]Wuh#h))RZ8„U"I4Nh#kn^_f&&)X8E+KHQh[b;>*P3C-<g6Z8/P*\0C>8DttKs\g9cA.kXV2wE6vn„U"]qWwr-qHu3k8-&+D<E)4J)0qteVJ12O]?Mu.rE<t5a$=8E&B#:4HQ-E%/UBpS(;„U")AA5=EHP]]VR#5B[pS+4johlEHaN&WG(a._YGRnl\#L%<u)>#%up=)S?:qzH;UM„U".3Ho]haYDah^G<CG':uKWh18X/s92:A(eGY6\VVpbE*dtd[*Z4-.J2:zX2p\H+6„U"e0FcGZ(bW;'(]4GKPzPS0kT.e1pXTMy<FZ:XUg<3W_Rd+J.i[Q<6e\l5Obs6EZG„U"D6dSgZxG;9W*,Az=$rO7a*tPBE,a3mZlTpn[TV(mkgk5G(x.)n\t)^d(OK6SZcX„U"5di,Kl=MQXv1Oy']).sJ#z86tcFc&Pb2LvZlRTBJ8jPt(z7/JbWjX/$TS,Kr<13„U"akmwi#BI<EWW?RuW9:v0c^m^dS,t2phB[moq\SKhC#Jt-^OE#-wiskE8\r-e'b:„U">f0B:qS2Y-<Wsa>aoO_sDp#]?#iWXBmZP90J[UUCYi$'YQshxthB\_bMM]Fx;qj„U"MmBj#77SL;er2YH<w70QD^?hEW/20C_eIpfnP:*52Z]cU*$+Y<Tn-]<pB%nW3NU„U"Ks#S[OvAGVe2WVV'+YxN.vJ$r_0FiVLqnSUU&a'=R*iLEk.,+<V2<P%Q6M6\(.V„U"C\rK9U]MDwr.gm:SfF6LwA:a9l]Pd'os);;00r0g\Rh<^ib%HPjbTA5X2Hnlqc2„U"jU%K0*bY?Z*/EV]9G6TJK1^c4j1g(qf)M?)+QYWhU<90Y<=HNgy0ice&^-vNL-?„U"YjFm+Hl>XpTh)-F-CL6L'aF2-u,qS(gm&%JA6KZ^DB\<8A,?_r?tH_ZIWR7Kw.q„U"eH[,ke=COEf3?/EW8^_?E_R.z/4g9m5Ly-IC5ouFk'w%)0)GVeu+vR(ahrC7Nrp„U"*,)h^Bg9mG8P/m6B)1CP)c0pHJXmWWFrk(XQHZ7RU8>(a'<(a)J4Pu-=J4]vmr*„U"aqUm,F58_H--=;n</VjbsXIJ4$HBi-M+[fe*]%34Y+DhI8T1auOp\bNEg9N9j\<„U"YSr2iX5%[2e0_l^Xq4=.VVqIu9JaL#oFDzDgm3;S4K1[l+G&UeNuG9$k+'MYd\q„U"c.=t('g$Nim,cU+6OG5Yw#nw]q(.Y.SX$7$8oSk5;a)L%6=;q'68#n1wc\(0fm+„U"ibnqS%WH=&E#6b/q2_p9u/EZkQpB1F?6gtgDAP+gTJ\3jU;]9/*)qn(2<;Fuah1„U"ex[pWDU/8o>g(Ahp9>U[YfmtLU73Vcr%B9?)j'aEC=QYg,#Awsq5_(I$+0h:\L5„U"+1IppaEFd>^(f*lO>?AHAG-]T%##V8op(CCB^W*nuYYrvd/2z,C03-(0q90)M?=„U"j4N/lQF,KajMCF;hg<c*R1u5oi,I']G]^__^+ADJ%%QWa-,XnD&G1^[e5GI\]QF„U"csrwdIX1S*_Dwz=GXK+)FW%TY%.4uUHK>YG/)a&QKEH?4^aGHx/E]DC>sUa:OZ?„U"X\Q?x6O2FLF$yDTd^45sH(bqNYeJO00Ss^VJ029HxaASy:sbe6uE(/oLwZ+<Fkh„END SUB„SUB V3„U"$b%wDTqPJ:1qe4FrI?1c_L[EbqlqvS<<&A*mcgdc7>IsWJyZ%g*#U6NX4ZERIb'„U"oq^uuK]HAIBnDm%jP7hkUb7j>TOb$-ks9:I4/4h7Sy5(]$T8R.4UQ%Lng*m.E>g„U"<O-cLI2>;U7Df=AHm#SE<PnGoDhR+eP&#;C*R[Mp4rPiCslIapNihZ28'DxqQW[„U"3S4\PVMlim6p_8qn:Rapz;GtmX2VY5)BM#[eC%IvPjF17')dHqM<:'qGP)NFdj=„U"f[\,lsCx;8%g=k:?fI0VCp)=#(FE^rG9$t8&e7Yf#+1XRTi8E.TABs\n56h(.yN„U"W4t[S>1i7=^QDa,)XyXf\=cgDaX67rF6dRqa/laP9)n8]EmN_Y^kcp;e_ToZnx3„U"<kjU'(XWl;[_rx%Uq)O/l[t8HlgU]r:^%W/D0OaiEM_cy%0<e?\Jt&ceiH0frLK„U"bOw'_(8Qf;4#[;d4Q<BB,\BYCPo_^g_V.[T9pY5:'d0hb552oZ4tTzJjdFUrTo4„U"rtEvb[_eiFJZ8>x?CEtA;lWf+cao%Sf-iK?_=nJL::MdQ.>O:HAfC>npHB8ZeHR„U")m-,C\$7a*dI]S:3cCYH#Tq5'ZhYtnB,km#-xG.)AhJ>'OPsQg'k7>.%fKc3#EP„U"QhkE_7fWV-UiS(putEKeFJ;/2mz+S3p%yAL6h3cle;R^[(SDocA<69u)=dA^ke\„U"]Nku+vmZw[gma[+k>R-TLwCVWVho7xqjYu1n:W$a_MgRB<Hhdg*^s#%jZ-:x&u%„U"p()9%%'%-+%K3x:HQBz'c>,%+%%8%%%/%%L%A4023<4ShCGC.h'<BSo?;wG=1xZ„U"q>uL=.#;+$#6;]tIK?\3;N\:buWfCS(*IQyIN&y,PrbVtT3hBEJ[)+abpqQ#oXo„U"4$4qnLGDXg-lBXCB4?I9niw+QGHftxA-EY7WomdDBlMt:4>alF<n6,AmJ0D\$.\„U"_eCN+U>LCb4>eT.<.-6_]VTlmV3K)&VYNCD:R^Gz[K<OlMzf<^1SdnlLw>jO69f„U"'ItXE/$1EF<6Mxu]pFdUuCu[J$Mp<UX2kn<>sbxP[o4y(L.DSpubg.??4+tiB2o„U"pt+%#ER2xan6[B,b*.zQ;so&1i$)]9V^(Z5Y]+ia^olkjSFsOPE*i_Lme3e5x]R„U"5pYfR+P-L0k-;YgQ36I<=69Kir2E4,DV;<a+Vyk[?.?=iJ/9fbqZ>m7JHTxe8Jc„U"(,ES9I.pAX9KVU=JjP_q?K&W<)wl*D3Q4iZi>XS[z[VH54hdBCq=dG8ka^=veV.„U"bE.x(9v/,0S$=o<:&Q;V[oXZFFieUXF%N/_r*W?9VAVtPQ%P'^n5jN+2dJM]5hA„U"[B,3=kpCUU,P9587A5V*WMmvk)4HnSmiJTisg2TQUiJY1jlHYIY\&A(Fw4n-se?„U"1,CIqs2^<OPX6^>soa/+E+x3Cxh=h>DQU4ptmuq-*NcckHSIjle#^#=LHT,MVGT„U"_4d[&aDD?eZ[EA,I^1w8VbpOnhi<$Tg/)R3[*Br+s(ZH1S;iFM^sMRxfcr8C79E„U"OiP+uYwOB?XVdBERdkYV7mPjL)6E9-)j=HwQnEIAh+skfuwP[A$bsL7i/2:*BJN„U"?.(<IX*cS3/0WDkJ%+[ifBGIcIZmRqCIT3#d_E[H)(ZZ9Y#)GN\Mb2$4]^YkQWp„U"S#XbPN:eolR23v'2X)[xU#+5qo;?JKN_D^t0UnT)b_lGrX[5;:_yF#ayhijzx_n„U"]:#1[-6x9iHf:#3RIHDq;^LT9kVOG$9\-&3J%49Otfq;2/G+2stUI2tS$$g0rNU„U"T;YAi'B\x\M>UZDwqQ,#lFPp1f/*l=-J3&athc%WC+W:1(sf*YU6aH$:1/qen_e„U"r0t-JYUu.;>v8s)*8-#Ipx;/M6O>+msX%5[E1>-c1+$MenYrgT$'DJxp7u1$64s„U"#=[^]I^H/=1;]6UQ&-CEM$wl0jd0[/]]QBxPMu*zevS]DW[/-[pKE(EAPG9ZKFC„U"1I[:XSTE&T0gjE9/Y78Q*5S+k_\2OWol;j4h6qAcVXUl8dZK7l0&(58zM=_5ogE„U"G4iR5CAD3Ynkxo,'niDGcMhEmri/=;7s)(5KWDoUG];1_Yaa/Q%b.-YfMUmuevp„U"$Ya%Tb081=o$_=tSo2<4$33&6JQ0lA=(ZHZ=j[aypSn+n>cH4<0#bC1>=cpC=uQ„U"Op3^f>#mnuf(jTt;8>Hi_2-36M*+uC/I,I+,[ZtlfRDg&+;.nEtwWGo,cOk8fPm„U"M8RigWVRb:nE<GV>M5Yds\qL^dv<W.9oev,qumh?>zQ#b_wZ'jmUY&L'Vgm\3&f„U"*x4r/W)HN3,74n+U08%pM34-C8y7,J66pL2bTnm(U_R\J8<^3t%&(&&J1IHpD*^„U":&.5niR>OOYS/AkpJpHNe&v9,l&DPCF=x;38qagsz[hhZoDO[TTF3z-O64\q\;T„U"YiC.wPq.pxg6R+)ZYCjTH1eJ_nhE.K.)MIlp-cId[iX(k)70AU?Xupe?%(6eb3S„U"jQ<;+'9&qhT\(TQ#(5OB'<BOQRpW?LbsJH_OSx6Ucqgbd?MGNJB^%X3&WfJ,[A#„U":Chvc62tU8%[oz06(kGBkXV%hZhvXhtTmA/h,92,rFDLo()GZ\e1Kb*I)xDY_m+„U"iNlB1EQpV(g0B3+[b<vmpC9nrRwo(er'sz03)<3jGI4QYzOrXS$rUO1UTrFEN/<„U"ulpTqINoHZ5,w>h=BPCrEyhoJtCr&J#<ejt-pe+0$2N>-KSwYA?>??>J<]ko=>W„U"1&\WwvI]kxfuO]Y_i+F#fuZ[$mewaz+iPu;6PEtpJtDN4Ri,)&Ffgo<8#ElW]\A„U"Yl5tFOs)ioVS/5[%k&Dj;GwD=b%O?h(4vD7yB.Xfe7NKLHC$1pFix_hhUN2^%&U„U"[sU#'3SQ_l[clxj<WF#Rh,V)qZ0:<>?H=FTRo]OBcpQA^0LnGL7Z:PL.di$V7-g„U"'Zo1Erg04%+fMOH[*3(Y#F,g3/IF4*,cc7qTv(xirbb3HiFq#xLLfYU$?]lJ8rt„U";9jWHg-t]CtjLvP-4Tm>#*)n[EUKfCYjNQijn,kcFxf2g(4/1[G_yrO%Q2.CRam„U"Xf;p-9fJXGxYxv7Nu^vO8tE&R^B2H3]dVwh6]$\^X&WW_y9=;w4%up()%9%'%%-„U"%,4#xH,_>RQb)%%%e8%%%0%I%%78MBC>AJHSCGPC.&<)>jm5rw=Bx)0Qs_UL]*#„U"bkqg(i6:jDKNzBxqayXP[U+S)5?4ZBh&%Nt<FQ*V.n/xAJ_G1'ME5mfI>%9^^4P„U"y*k'/*nt^;du>70/t/*KK;0*L'9qp_TX/VKKga420,A'emj[ea(#G6Uhx%T8KI5„U"YfQ8a8Wd5e*cJtXaS&9Q]sk+fau%iL4Z?j9o/)<0*ESc)KWHq)gVjYlVC:4md#F„U"N3#KvPXKgY2HChu39xt1go:vRdh'qN^;nXiqdO:^$mMqbrjb3>35'MAzCf<*fhb„U"Z:4?mDICn]s?vHJQA)Ft(OA:R%soUJE8nMWONJY;xwF^/=<+:<O&VZ*mr4thYoo„U"F[.0c&]-7:6=ux%SN?BRUlt,QY8cFQrtEdNO8plgbWAz4<NL[&u_3aoBlyMJA3O„U":i&WtaS.UGOo+47]YIJ.:;0Ce+UqTjA7kaWwksig.UBkzBH]18w0PIJLMCmRxBh„U"?5)$W$2S5n73aIgG*Zf/dSI7aG>KI#6yMC2F[?zQ6I:Gd1wX9avY+l(e6'x%y0i„U"3La\ucq+.X$Pm%N&IqA[QS>)LNgN%+q'J*vQj5imJBg'.&I3&v1Fle&fopw7,Y9„U"r%l0k.Cx=lh%jdK:Bg1EdhbBw]4oIGS;WcQ6.O1N?cyDHg/Im&O2xmYk_YeKL\Z„U"Is?#Q\Qv<MB1C6UZ2Mcala;6F,?l_VS>'H&MfP_9ch*4H5y*naEG/\ECw<E:aKu„U"]o4(1[gUXZx,V-DihL0XWv%Fk7;>Pkdf/SOAi#kLq,N[M56sqOPiFW^>R5;qAXQ„U"2stBY'8]Ip2f-ZQofv2<sBLem]>P?=TG.8VzYPw,SP&]RQ1.)m129XGw7W#(#7-„U"$eVkLca7BL1GR624s$?*J_o5sEoVeP2c5k44MM8>roK2AC7<Nqi8H9H6VLfuaD;„U"%&tMj5,*(#&?W8121mrv$UF<>Ic;XjQceTU)Qk%kY[j-v/Gy*,P6FbaOf>49V;k„U"I>:--?ekt#)93Y4_y;oUK0XlgWO/De3L9NwDQ#>5,aOFGrp7[j?:gMJeE)Mcrb)„U"aj;$Td.?A'(l7V[qmJMe?tY((O7J<Ar-5;-GC>SD5d-IDoQB*FrCjOO?IL)kY'N„U"dw0'/RS^:;',DEUe,wz&QjqHZ.'Qm?*,%OkEO]KVb'COle-?N]EyDsOS\=L=F'Q„U"b:RQP((7YG2qp:;&LDv0ebp<wRko$=UYlj^Q+R:Yrf)4j.PYUx/*ZbWwJx2mIaJ„U"2Zm6W9.g\_+l\G#6(cT?<E%BfqTD.sy?x2*7==%GszepQ8YxtPE;?ftioE4]&,H„U"1Pl+,Vbt)>\eauq_?VJr]GIYv=Z.E^G1I1qf$52\Y?nYeuBWLG*c$1mG6dtn-%>„U"YCR4edLL8bjYOAi\W:pRXpX-d09cBCHHl/xRjrVGO=G+M_XMTyvLi?Dk,sUFvP%„U"=CB>Z#Mv_VIRgvBHeL_I?AdN&1%H.N;kXO)8JEZn5fg8>]$N_;]yMH_^Q*D;Qb]„U"jt(ChWoWsW(\::$M#%)[?XMc3*GnaY?I:R.)7IB?^r.,v>hgJj_HSshy4Vf6&B:„U"6M9NWho0.gatg9#oHMlluJ,O6bZ?sY&T&'x&up%()9%%'%-%(yipHdHj*c%c'%%„U"&V)%%%,%%%M;824M=B4TjyD=T7U550BIdQAV9Y=N0IpR9CU_cOo/NST2i)(iOMK„U"'a>DmpB;aat'D)ni:7^X4XqzVvVlv4^pdY+tJ-B,b](NV^$/u8:9lf4&xlxn,X*„U"6-MrCg&V[HbEO&a]SmG+?jvmJ49\cFg&W0[c^n^9:LjNIw=:LlX*iB<CF2F&H[S„U"4]OD#K.5qmv#p[j#l\'_o$VMlhr6:UR;jXvvI+/9^JmB</um[FTVVf4>Tt4Pdta„U"&8Y_=QffVVZWhR<_YmQCn/2:wJA.c9O8Y)CpXT+z:C'TgKO2E:2?ts3)CR&O.IL„U"C2bb'aeU54LYTKkuOk?MMFuoO>14GK$NxMt5WR8H=UZ-%I'of_-B)l2KWg^q.UR„U"L,\yIKRNY:(RBvr?vRz_-NA,vWIk-#$NQA>_.l3Q)pu:X;9P(M'E;d?A58Jp$nG„U"KNzKRO'_I9&_'Wc91kuE1rT*0b>yp^Qi%rLLN8Ni\tdoGuhO22]x(0:JBd9[>3V„U"OUu>/egFcxeNTTX$)\2>A0S5lR<CR(GODT;Y%$d(eSB=e7U2fgoFvPd/R#C+R8=„U"k_hK*OeE^5y10c..HM7'?Jqk(,A&BbVs'46\g]ZNP.Iq_d1EZ+qOF^[d]r__9fB„U"B2Rf>Ber]+]vYnDJl4f379.e<kI+Mq:PrQ[kZ,1b[sOVO[B'#Os9FfaCX5,9Fs>„U"XC5Bos[Oc&S/9U8HzYe,5M#jO#+r;#w<]DWz<l)5=j%4up&%':09%%'%-(%B3xI„U"H/)b(bF7%%%cs%%%0%%%%%%%%%&%E4%/P%#%%%BM20==D4AS1)0Bup%&':0%9%'„U"%I-%_BRhHM80]<^,%%%,<%%%/%%%%%%%%%&%RE%/P&o7%%M5>A<24;?S)18up%&„U"':0%9%'%#-%97IhHT.(^3&(%%%s,%%%/%%%%%%%%%&%RE%/P&&?%%MB20=2=4AS„U")18up%&':0%9%'%%-%r3#xHG1;FheMd%%J>%%%0%%%%%%%%%&%RE%/P&OB%%M5>„U"A<24;?S210Bu%p&':%09%'[%-%K%3xHe5CU]s%&%%S%'%%0%%%%%%%%%&[%E%/)„U"Pdk%L%58;M4.83LS38I%up&'%:09%%'%-%&Y3xH,+>)&'$-%%%pA%%%/%%%%%%%„U"%%&%E%*/P1mI%%5>MA<4;LS10B%up&'%:09%%'%-%'K3xHbQBzc%>,%%'%8%%%/„U"%%%%%%%%%&%E%*/P#vI%%A4M03<4LSCGC%up&'%:09%%'%-%%,4xHg,_RQ'b)%%„U"%e8%%%0%%%%%%%%%&%E%N/P+'I%%78MBC>AJHSCG&Cup&%':09%%'%-.%yip#HH„U"j*'cc'%(%V)%%%,%%%%%%%%%&%EO%/P=A,%%;M824=)B4up%*+%%%%%.%7.%r&R„U"%%J.%%%%%„END SUB„V2„V3„CLOSE:IF S=250AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„William Deer                   MORSE CODE                     ag312350@student.uq.edu.au     10-26-97 (20:22)       QB, QBasic, PDS        329  13010    MORSE.BAS   DECLARE SUB Dot ()„DECLARE SUB GAP ()„DECLARE SUB Dash ()„DECLARE SUB WordSpace ()„DECLARE SUB CharacterSpace ()„DECLARE SUB Playchar (Key$)„DECLARE SUB UpdateMessages (Roman$, Morse$)„DECLARE SUB Box (X!, Y!, XX!, YY!, Fore!, Back%)„DECLARE SUB Option1 (Bracket%, Number!, Back%, Value!)„' ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø„' MORSE.BAS     by William DEER c/o Ag312350@student.uq.oz.au           ≥ „' 26/10/97                              version 1.00                    ≥„'                                                                       ≥„'„' Mouse.Bas was designed to help me understant morse code. This program„' reads from a text file, or displays a built in message, and plays the„' Morse code through the internal PC speaker. This program was designed„' to be a 'learning' aid for people interested in Morse Code. This„' version uses INTERNATIONAL MORSE, Not American Morse.„'„'  For those of you who are unfamiliar with Morse Code, here„' is a brief explanation;„'„' Morse Code is the arbitrary set of signals used on the Telegraph.„' It may also be used with a flash lamp for Signalling.„' The International (or continental) Morse Code is a simplified„' form generally used in radio telegraphy.„'„' The unit of the code is the DOT, representing a very brief depression„' of the telegraphy key.  The DASH represents a depression lasting„' three times as long as a dot. Between the depressions there is a pause„' equal in time to one dot, except in a few letters and signs, when there„' is a wait of two dots. The pause between letters in a word lasts as„' long as one dash, between words it lasts as long as two dashes.„'   (Source of information = New Illustrated Columbia Encylopedia.)„„SCREEN 0: KEY OFF: WIDTH 80, 25   ' Setup Screen for 80 * 25 Mode 0„CLS                               ' Clear Screen„„' Init Variables                „DEFINT A-E                       ' These are used for loops and so forth„CONST MaxMorseNo = 38            ' Number of characters in Morse data set„FileIn = 0                       ' Flag for text file input„DIM SHARED Frequency AS SINGLE:  Frequency = 1050       ' Pitch of beeps„DIM SHARED UnitLength AS SINGLE: UnitLength = 2.4       ' Speed of morse code.„        ' I guess I should mention that I have used the standard DOT as the„        ' minimum time element. Using the sound statement, there are 18.2„        ' dots per second, therefore the larger the Unitlength number, the„        ' slower the morse speed. I have found 2.4 is easy to follow.„DIM SHARED MorseKeyLen AS INTEGER ' Length of the morse code for a particular character„DIM MorseList AS STRING           ' Single string containing each character„DIM SHARED MorseString AS STRING  ' This is the morse string on screen„DIM SHARED RomanString AS STRING  ' The roman equiv. on screen„DIM SHARED Morse(2, MaxMorseNo) AS STRING ' Define Morse Code storage space„                                          ' Morse(1,*) = Character(A.Z,etc)„                                          ' Morse(2,*) = Morse Code„MorseList = ""          ' Set to 0 length to verify emptiness„„FOR A = 1 TO MaxMorseNo           ' For each character in the morse code set„ FOR B = 1 TO 2                   ' For both Roman and morse characters„  READ Morse(B, A)                ' Read in Data from below.„ NEXT B„ MorseList = MorseList + Morse(1, A) ' Update morsecode list with morse char.„NEXT A„„' Screen Setup„ GOSUB MenuOptions                ' Updates the screen„„A$ = "Welcome to Morse.BAS I hope you find it usefull." ' Welcoming message„Restart:„IF FileIn = 0 THEN                ' Blank the message list if not text file„RomanString = STRING$(80, " ")„MorseString = STRING$(80, " ")„END IF„OldMessage$ = A$                ' Keep a copy of the old list so repeat is able„MainLoop:„FOR A = 1 TO LEN(A$)            ' For every character in the message„ KeyBoard$ = INKEY$: IF KeyBoard$ <> "" THEN GOSUB KeyBoardHit„„ Char$ = UCASE$(MID$(A$, A, 1)) ' Get specific character from message„ ' Now to Check that the Character, CHAR$ is a valid morse letter„ ' If it is not a valid character, e.g. "!","@",etc,„ ' then it will be ommitted.„ InstVal = INSTR(MorseList, Char$)„ IF InstVal <> 0 THEN„        ' Character is a valid one.„        MorseKey$ = Morse(2, InstVal)   ' Morse equivalent of Char$„        CALL UpdateMessages(Char$, MorseKey$) ' Update list for screen„        COLOR 15, 0: LOCATE 7, 20: PRINT RomanString; : ' Update screen„        COLOR 10, 0: LOCATE 8, 20: PRINT MorseString;„        CALL Playchar(MorseKey$)        'Produce morse code for character„        CALL CharacterSpace             'Silent space between characters„        CALL UpdateMessages(" ", " ")   ' Put a space on screen as well„                                ELSE„        ' Character is invalid, therefore use a space.„        CALL WordSpace                  ' Assume character is a space„        CALL UpdateMessages(" ", " ≥ ") ' Put space and seperating line on screen„ END IF„NEXT A„ ' Message is now finished. Program will zero message or jump back to text file.„ IF FileIn = 1 THEN RETURN„A$ = "  "               ' Zero message„GOTO MainLoop           ' Display zeroed message until keyboard is hit„„KeyBoardHit:„        SELECT CASE KeyBoard$„         CASE "1"       'Input a message„          COLOR 7, 0: LOCATE 10, 4: INPUT "Message"; A$„          LOCATE 10, 2: PRINT STRING$(77, " ");„          GOTO Restart„          „         CASE "2"       'Load a text file„          LOCATE 10, 4: INPUT "FileName of Text file"; FileName$„          FileIn = 1„          GOSUB TxtIn„          FileIn = 0„        „         CASE "3"       'Play an internal message„          LOCATE 16, 50: PRINT "There are 6 internal messages";„          LOCATE 17, 50: INPUT "Which one do you want"; MessageNumber„          LOCATE 16, 50: PRINT "                            "„          LOCATE 17, 50: PRINT "                            "„          ON MessageNumber GOSUB M1, M2, M3, M4, M5, M6„          GOTO Restart„„         CASE "4"       'Pause/Continue Playback„          LOCATE 10, 30: COLOR 31, 0: PRINT "Hit any key to continue";„          WHILE INKEY$ = ""„           ' We wait„          WEND„          LOCATE 10, 30: PRINT "                         ";„         „         CASE "5"       'Exit Program„          GOSUB Closing„          RESET: END„        „         CASE "6"       'Replay existing message„          A$ = OldMessage$„          GOTO MainLoop„        „         CASE "7"       'Change speed„          LOCATE 16, 50: PRINT "Current speed = "; UnitLength„          LOCATE 17, 50: INPUT "New Speed = "; UnitLength„          LOCATE 16, 50: PRINT "                            "„          LOCATE 17, 50: PRINT "                            "„        „         CASE "8"       'Change pitch„          LOCATE 16, 50: PRINT "Current pitch = "; Frequency„          LOCATE 17, 50: INPUT "New Speed = "; Frequency„          LOCATE 16, 50: PRINT "                            "„          LOCATE 17, 50: PRINT "                            "„        END SELECT„ GOSUB MenuOptions„RETURN„„MenuOptions:„CLS„CALL Box(1, 1, 79, 24, 7, 0)„CALL Box(30, 2, 50, 4, 7, 0)„COLOR 15, 0: LOCATE 3, 31: PRINT "MORSE.BAS : Trainer";„LOCATE 12, 5: CALL Option1(10, 15, 0, 1): COLOR 7, 0: PRINT "Input a message"„LOCATE 14, 5: CALL Option1(10, 15, 0, 2): COLOR 7, 0: PRINT "Load a text file "„LOCATE 16, 5: CALL Option1(10, 15, 0, 3): COLOR 7, 0: PRINT "Play an internal message"„LOCATE 18, 5: CALL Option1(10, 15, 0, 4): COLOR 7, 0: PRINT "Pause/Continue Playback"„LOCATE 20, 5: CALL Option1(10, 15, 0, 5): COLOR 7, 0: PRINT "Exit Program"„LOCATE 22, 5: CALL Option1(10, 15, 0, 6): COLOR 7, 0: PRINT "Replay existing message"„LOCATE 12, 40: CALL Option1(10, 15, 0, 7): COLOR 7, 0: PRINT "Change speed ("; UnitLength; ")";„LOCATE 14, 40: CALL Option1(10, 15, 0, 8): COLOR 7, 0: PRINT "Change pitch ("; Frequency; " Hz)";„RETURN„„M1:     ' Message 1„A$ = "This is message 1. It is short and easy to follow. goodbye."„RETURN„M2:     ' Message 2„A$ = "This program was brought to you through the magical electrical ether by a crazed loon from Australia."„A$ = A$ + " He spent his entire Sunday trying to get his drug addled mind to think up nice things to do and"„A$ = A$ + " barely succeeded."„RETURN„M3:     ' Message 3„A$ = "This is recon group Sigma Alpha Delta, awaiting instructions for extraction. Our primary LUP is too hot"„A$ = A$ + " and request an immediate extract. Grid coordinates 462391 rep 462391 LUZ three. Authorization "„A$ = A$ + " Sigma Tango Unicorn Party Icon Delta. SAD over and out. "„RETURN„M4:     ' Message 4„A$ = "Hmmm it is really hard to think up witty and clean comments to leave on this program. I'm sure some of "„A$ = A$ + "you will play SOS through the computer and then patch into shipping channels. HA HA HA HA HA HA. Eat"„A$ = A$ + " your heart out Exon Valdez. Empowerment to the anarchists."„RETURN„M5:     ' Message 5„A$ = "I just want to say that the previous statement was typed in without the benefit of my daily medication."„A$ = A$ + "Im all right now, really I am. Look Out, shooter on the grassy knoll. I am not an animal. Bleep Bleep,"„A$ = A$ + " im coming to get you Pacman. Reedip reedip, Im a little spot of light on the wall. Oh no, darkness falls"„A$ = A$ + " across the land, the midnight hour is close at hand. Creatures roam in search of blood, and terrorize your"„A$ = A$ + " neighbourhood. thoust whoever shall be found without the soul for getting down, shall find themselves way"„A$ = A$ + " down in hell, and rot inside a corpsed shell."„„RETURN„M6:     ' Message 6„A$ = "Around the world,Around the world,Around the world,Around the world,Around the world."„A$ = A$ + " written by some daft punk. HA HA Were you expecting the lyrics to barbie girl."„RETURN„„TxtIn:  ' This part inputs a text file, and runs it through„OPEN FileName$ FOR INPUT AS #1„ WHILE NOT EOF(1)„   A$ = INPUT$(1, #1)„   GOSUB Restart„ WEND„CLOSE 1„RETURN„„„Closing:„CLS„CALL Box(1, 1, 79, 9, 7, 0)„LOCATE 3, 13: PRINT "Well, I hope that this program was somehow usefull to you."„LOCATE 4, 13: PRINT "Any suggestions or queries can be made to the E-mail address"„LOCATE 5, 13: PRINT "here   Ag312350@student.uq.oz.au  "„LOCATE 6, 13: PRINT "Thanks for taking the time to use this program."„LOCATE 7, 40: PRINT "W.DEER"„„„' INTERNATIONAL MORSE CODE„DATA "A","._"„DATA "B","_..."„DATA "C","_._."„DATA "D","_.."„DATA "E","."„DATA "F",".._."„DATA "G","__."„DATA "H","...."„DATA "I",".."„DATA "J",".___"„DATA "K","_._"„DATA "L","._.."„DATA "M","__"„DATA "N","_."„DATA "O","___"„DATA "P",".__."„DATA "Q","__._"„DATA "R","._."„DATA "S","..."„DATA "T","_"„DATA "U",".._"„DATA "V","..._"„DATA "W",".__"„DATA "X","_.._"„DATA "Y","_.__"„DATA "Z","__.."„DATA "1",".____"„DATA "2","..___"„DATA "3","...__"„DATA "4","...._"„DATA "5","....."„DATA "6","_...."„DATA "7","__..."„DATA "8","___.."„DATA "9","____."„DATA "0","_____"„DATA ".","._._._"„DATA ",","__..__"„„SUB Box (X, Y, XX, YY, Fore, Back)„ ' This subrountine draws a simple box of size (x,y)-(xx,yy) and coloured„ ' fore,back.„A = XX - X:                            B = YY - Y„Top$ = "’" + STRING$(A - 1, "Õ") + "∏"„Bot$ = "‘" + STRING$(A - 1, "Õ") + "æ"„COLOR Fore, Back„FOR c = Y TO YY„ LOCATE c, X: PRINT "≥"; :              LOCATE c, XX: PRINT "≥";„NEXT c„LOCATE Y, X: PRINT Top$; :              LOCATE YY, X: PRINT Bot$;„END SUB„„SUB CharacterSpace„ SOUND 0, 3 * UnitLength„ ' The Space between words is 1 Dash in length„END SUB„„SUB Dash„ SOUND Frequency, 3 * UnitLength„ ' Duration of Dash is three times that of the dot„END SUB„„SUB Dot„ SOUND Frequency, UnitLength„ ' Duration of the dot is one unit length„END SUB„„SUB GAP„ SOUND 0, UnitLength„ ' Duration of gap between dots and dashes within a word is„ ' 1 dot„END SUB„„SUB Option1 (Bracket, Number, Back, Value)„ COLOR Bracket, Back„  PRINT "<<";„ COLOR Number, Back„  PRINT INT(Value);„ COLOR Bracket, Back„  PRINT ">> ";„END SUB„„SUB Playchar (Key$)„ KeyLen = LEN(Key$)„ FOR A = 1 TO KeyLen            ' For every piece of the key„  Piece$ = MID$(Key$, A, 1)     ' Get the piece„  '  Now the piece$ can only be "_" or "."„  SELECT CASE Piece$„        CASE ".": CALL Dot               ' Dot„        CASE "_": CALL Dash              ' Dash„  END SELECT„  IF A <> KeyLen THEN CALL GAP„        ' Letter has not ended, therefore a GAP must be inserted„ NEXT A„END SUB„„SUB UpdateMessages (Roman$, Morse$)„ KeyLen = LEN(Morse$)„ MorseString = RIGHT$(MorseString + Morse$, 40)„ RomanString = RIGHT$(RomanString + Roman$ + STRING$(KeyLen - 1, " "), 40)„END SUB„„SUB WordSpace„ SOUND 0, 6 * UnitLength„ ' The Space between words is 2 Dashes in length„END SUB„