Tyler Barnes                   QBASIC INTERRUPT CALLS         FidoNet QUIK_BAS Echo          10-28-95 (22:32)       QBasic                 52   1541     INTCALL.BAS DEFINT A-Z„DECLARE FUNCTION ASMCode$ ()„TYPE RegTypeX„ax AS INTEGER„BX AS INTEGER„CX AS INTEGER„dx AS INTEGER„BP AS INTEGER„SI AS INTEGER„DI AS INTEGER„Flags AS INTEGER„DS AS INTEGER„ES AS INTEGER„END TYPE„DIM SHARED Regs AS RegTypeX„DECLARE SUB INTERRUPT (IntNum%, Regs AS RegTypeX)„„'** Simple demonstration on using INTERRUPT **„'** Requires a mouse driver **„CLS„Regs.ax = 0„INTERRUPT &H33, Regs„Regs.ax = &H20„INTERRUPT &H33, Regs„Regs.ax = 1„INTERRUPT &H33, Regs„„DEFSNG A-Z„FUNCTION ASMCode$„Buf$ = "UãÏÉÏVWUã^ãG=" + CHR$(255) + CHR$(255) + "uèGãG=" + CHR$(255) + CHR$(255) + "uèGãGâF¯ããOãWãw" + CHR$(10) + "ã" + CHR$(255) + "w" + CHR$(255) + "wèF˙" + CHR$(255) + "wãn¯[Õ!UãÏãnâ^¸ã^èF˛"„Buf$ = Buf$ + CHR$(255) + "v˙âãF¸âGâOâWXâGâw" + CHR$(10) + "âúèGèGãF˛âGZ_^ãÂ] " + CHR$(0)„ASMCode$ = Buf$„END FUNCTION„„DEFINT A-Z„SUB INTERRUPT (IntNum, Regs AS RegTypeX) STATIC„STATIC FileNum, IntOffset, Loaded„DIM Intcode AS STRING * 200„IF NOT Loaded THEN                        ' loaded will be 0 first time„Intcode = ASMCode        ' load routine and determine„IntOffset = INSTR(Intcode$, CHR$(&HCD) + CHR$(&H21)) + 1 ' int # offset„Loaded = -1„END IF„SELECT CASE IntNum„CASE &H25, &H26, IS > 255               ' ignore these interrupts„CASE ELSE„DEF SEG = VARSEG(Intcode)             ' poke interrupt number into„POKE VARPTR(Intcode) * 1& + IntOffset - 1, IntNum' code block„CALL Absolute(Regs, VARPTR(Intcode$)) ' call routine„END SELECT„END SUB„„Tyler Barnes                   TSR IN QUICKBASIC              FidoNet QUIK_BAS Echo          10-26-95 (18:29)       QB, QBasic, PDS        176  7555     TSRQUICK.BAS'Ok, here's the source code to a TSR that will make a small screen saver pop up„'every time you hit the printscreen key. You can make other types of tsr's with „'this also, all you have to do is hook the right interrupts.„'I don't really want to explain how to use this source, so for the most part, „'you'll have to figure it out for yourself. One thing you should know though...„„'In the program introduction (The part where I wrote A = 1000: B = 1000 etc.) „'you should put any variables that you plan on using. For example. if you are „'using A as a variable in your program, and the biggest possible number that „'will ever be in A is 1000, you'd type A = 1000. Same goes for string „'variables. If you are going to use A$, and the contents of A$ is never going „'to exceed 1000 characters, you'd put A$ = SPACE$(1000)„'On line 20000, there is a place on the line where there is a number. You can „'use the number that is there, or the number that is on the same line commented„'out... Using one number will cause the computer to continue what it was doing„„'after doing what the TSR told it to, the other one will do what the tsr told „'it to do, and abort any other processes. For example, in my screensaver „'thingy... one number will cause the screen saver to popup when you hit „'printscreen, and then return to DOS when you hit a key, the other number will „'cause the screensaver to popup, and return to dos, AND print the screen when „'you hit a key.„'Also, you will notice in the source that it creates a small .COM file, „'runs it with a shell command, and then kills it. This is unavoidable...„'Load QUickbasic with the /L switch.„'Do *NOT* run the TSR source from the environment„'Always compile into the Stand-Alone format.„'And last but not least: I wrote the screensaver, but I did not write the TSR „'source itself.„'Um, I guess that's it. Here it is. Not the best, but the closest I've seen to „'a QuickBasic TSR...„'--------------------------------------------------------------„'                       TSR_IN_BASIC„'                   QuickBasic version„'              start QB with"/lqb" switch„1    '  start introduction program here„'„A = 1000: B = 1000: C = 1000: D = 1000: I = 1000: COL = 1000: MP = 1000: Z = 1000„6999 '  end introduction program here„'„7000 '  set-up program„'„7010    DIM GMMCKAY%(600)„GMMCKAY%(600) = 0: GMMCKAY%(599) = 0: GMMCKAY% = 0: GMMCKAY$ = "00"„„GMMCKAY%(598) = VARPTR(GMMCKAY%(0))„DEF SEG = VARSEG(GMMCKAY%(0))„FOR GMMCKAY% = 0 TO 800„READ GMMCKAY$„POKE GMMCKAY%(598) + GMMCKAY%, VAL("&H" + GMMCKAY$)„NEXT GMMCKAY%„IF GMMCKAY$ <> "00" THEN PRINT "error loading program": STOP„„7500    GMMCKAY%(597) = 1'  *** first interrupt ***„7520    GMMCKAY%(598) = 5„7540    GOSUB 9000„„7600 '  GMMCKAY%(597)=2  '  *** second interrupt ***„7620 '  GMMCKAY%(598)=5„7640 '  GOSUB 9000„„7700 '  GMMCKAY%(597)=3  ' ** third interrupt ***„7720 '  GMMCKAY%(598)=5„7740 '  GOSUB 9000„„8140    DEF SEG = VARSEG(GMMCKAY%(0))„GMMCKAY% = VARPTR(GMMCKAY%(0))„„8160    CALL absolute(GMMCKAY%) ' call set-up„IF GMMCKAY%(599) = 1 THEN 10000„GMMCKAY%(599) = 1„LOCATE , , 1„Z = FREEFILE: OPEN "CS.COM" FOR OUTPUT AS Z„PRINT #Z, "å»ª" + CHR$(0) + CHR$(0) + "é€>£˛∏" + CHR$(0) + "LÕ!êêê";„CLOSE Z„SHELL "CS.COM"„KILL "CS.COM"„GMMCKAY% = VARPTR(GMMCKAY%(0)) + 763„DEF SEG = VARSEG(GMMCKAY%(0))„8340    CALL absolute(GMMCKAY%) ' terminate as TSR„GOTO 10000„9000    GMMCKAY% = VARPTR(GMMCKAY%(0)) + 643„DEF SEG = VARSEG(GMMCKAY%(0))„9040    CALL absolute(GMMCKAY%(598), GMMCKAY%(597), GMMCKAY%)' call interrupt  .......„9060    RETURN„'„10000 ' start TSR program here„„SCREEN 12„RANDOMIZE TIMER„DO„A = INT(RND * 640)„B = INT(RND * 480)„C = INT(RND * 640)„D = INT(RND * 480)„COL = INT(RND * 15)„FOR I = A TO INT(RND * (640 - A))„Z = INT(RND * 3) + 1„MP = INT(RND * 2)„SELECT CASE Z„CASE 1: C = C + 1„CASE 2: D = D + 1„CASE 3: B = B + 1„END SELECT„LINE (A, B)-(C, D), COL„NEXT I„LOOP WHILE INKEY$ = ""„SCREEN 0„CLS„„19999 ' end TSR program here„'„20000   GMMCKAY% = 437'**** or have GMMCKAY%=551„20020   GMMCKAY% = GMMCKAY% + VARPTR(GMMCKAY%(0))„DEF SEG = VARSEG(GMMCKAY%(0))„20060   CALL absolute(GMMCKAY%) ' return to original program„GOTO 10000„20100   END„„31000  '      GMMCKAY%() data statements„31001  DATA  9C,56,E8,00,00,5E,81,C6,7B,03,2E,8C,5C,08,0E„31002  DATA  1F,89,04,89,5C,02,89,4C,04,89,54,06,8C,54,0A„31003  DATA  8C,44,0C,58,89,44,0E,89,7C,10,89,6C,12,58,89„31004  DATA  44,16,B9,30,00,89,F0,05,60,00,05,18,00,07,89„31005  DATA  C7,29,CF,29,CF,8C,05,E2,F5,89,64,14,B8,00,00„31006  DATA  89,84,30,01,E9,A1,00,90,9C,56,E8,00,00,5E,81„31007  DATA  C6,28,03,2E,89,44,78,58,2E,89,44,7A,58,2E,89„31008  DATA  44,7C,2E,8B,84,30,01,3D,00,00,74,1C,2E,8B,84„31009  DATA  02,01,50,2E,8B,84,00,01,50,2E,8B,44,7C,50,2E„31010  DATA  8B,44,78,2E,8B,74,7A,9D,CB,90,B8,01,00,2E,89„31011  DATA  84,30,01,2E,8C,9C,88,00,0E,1F,90,90,8B,44,78„31012  DATA  89,84,80,00,8B,44,7C,89,84,96,00,8B,44,7A,89„31013  DATA  84,8E,00,89,9C,82,00,89,8C,84,00,89,94,86,00„31014  DATA  8C,94,8A,00,8C,84,8C,00,89,BC,90,00,89,AC,92„31015  DATA  00,B9,30,00,89,F0,05,60,00,05,98,00,07,89,C7„31016  DATA  29,CF,29,CF,8C,05,E2,F5,89,A4,94,00,8E,54,0A„31017  DATA  8B,64,14,B9,30,00,89,F0,05,16,00,89,C7,01,CF„31018  DATA  01,CF,8E,05,06,E2,F5,8B,6C,12,8B,7C,10,8E,44„31019  DATA  0C,8B,54,06,8B,4C,04,8B,5C,02,8B,44,16,50,8B„31020  DATA  44,0E,50,8B,04,8E,5C,08,5E,9D,FB,CB,90,90,9C„31021  DATA  56,E8,00,00,5E,81,C6,50,02,2E,89,44,78,58,2E„31022  DATA  89,44,7A,58,2E,89,44,7C,2E,8B,84,30,01,3D,00„31023  DATA  00,74,1C,2E,8B,84,06,01,50,2E,8B,84,04,01,50„31024  DATA  2E,8B,44,7C,50,2E,8B,44,78,2E,8B,74,7A,9D,CB„31025  DATA  90,B8,02,00,E9,25,FF,90,9C,56,E8,00,00,5E,81„31026  DATA  C6,0B,02,2E,89,44,78,58,2E,89,44,7A,58,2E,89„31027  DATA  44,7C,2E,8B,84,30,01,3D,00,00,74,1C,2E,8B,84„31028  DATA  0A,01,50,2E,8B,84,08,01,50,2E,8B,44,7C,50,2E„31029  DATA  8B,44,78,2E,8B,74,7A,9D,CB,90,B8,03,00,E9,E0„31030  DATA  FE,90,E8,00,00,5E,81,C6,C8,01,0E,1F,8E,94,8A„31031  DATA  00,8B,A4,94,00,B9,30,00,89,F0,05,96,00,89,C7„31032  DATA  01,CF,01,CF,8E,05,06,E2,F5,8B,AC,92,00,8B,BC„31033  DATA  90,00,8E,84,8C,00,8B,94,86,00,8B,8C,84,00,8B„31034  DATA  84,30,01,01,C0,01,C0,01,F0,BB,FE,00,01,C3,8B„31035  DATA  07,50,8B,47,FE,90,90,50,8B,9C,82,00,8B,84,96„31036  DATA  00,50,FA,B8,00,00,89,84,30,01,8B,84,80,00,8E„31037  DATA  9C,88,00,2E,8B,B4,8E,00,9D,CB,90,E8,00,00,5E„31038  DATA  81,C6,56,01,0E,1F,8E,94,8A,00,8B,A4,94,00,B9„31039  DATA  30,00,89,F0,05,96,00,89,C7,01,CF,01,CF,8E,05„31040  DATA  06,E2,F5,8B,AC,92,00,8B,BC,90,00,8E,84,8C,00„31041  DATA  8B,94,86,00,8B,8C,84,00,90,8B,9C,82,00,8B,84„31042  DATA  96,00,50,FA,B8,00,00,89,84,30,01,8B,84,80,00„31043  DATA  8E,9C,88,00,2E,8B,B4,8E,00,9D,FB,CF,90,E8,00„31044  DATA  00,5E,81,C6,FA,00,2E,8C,9C,A0,00,0E,1F,8C,84„31045  DATA  A2,00,89,AC,A4,00,89,BC,A6,00,89,E5,8B,7E,06„31046  DATA  8A,05,B4,35,CD,21,89,F2,8B,7E,04,8B,0D,83,F9„31047  DATA  01,75,0E,89,9C,00,01,8C,84,02,01,81,EA,2D,03„31048  DATA  EB,1F,83,F9,02,75,0E,89,9C,04,01,8C,84,06,01„31049  DATA  81,EA,55,02,EB,0C,89,9C,08,01,8C,84,0A,01,81„31050  DATA  EA,10,02,B4,25,CD,21,8B,AC,A4,00,8B,BC,A6,00„31051  DATA  8E,84,A2,00,8E,9C,A0,00,CA,04,00,90,90,B4,62„31052  DATA  CD,21,B8,00,00,8E,C0,26,A1,FE,03,29,D8,89,C2„31053  DATA  B8,00,31,CD,21,90,90,90,90,00,00,00,00,00,00„31054  DATA  00,00,00,00,00,00„31055  '         end GMMCKAY%() data statments„„Thomas Gohel                   FILE COPY                      comp.lang.basic.misc           10-28-95 (00:00)       PB                     152  3486     FILECOPY.BAS'> Here's a way to COPY in PowerBASIC.  It's very fast.„„'> close #1: open "trypb3.exe" for binary as #1„'> close #2: open "test.out" for binary as #2„'... but not with the date/time stamps <g>„„'*************************************************************************„'„'   FileCopy in PowerBASIC 3.0/3.2„'„'   public domain, von/by Thomas Gohel, GERMANY„'„'   http://www.snafu.de/~pbsound   -   author@pbsound.snafu.de„'„'*************************************************************************„„„DECLARE SUB FileCopy(Quelle$,Ziel$)„SHARED FileCopyError%„„PRINT„PRINT„PRINT "FileCopy mit/with PowerBASIC 3.0/3.2";TAB(53);"(c) 1994/95 von/by Thomas Gohel";„PRINT„„FileCopy "C:\DOS\COMMAND.COM", "C:\TEMP\KILL.ME"„IF FileCopyError% > 0 THEN„	PRINT "Es ist ein Fehler aufgetreten/error detected!"„END IF„END„„SUB FileCopy(Quelle$,Ziel$) public„		LOCAL QuellHandle%, ZielHandle%„		LOCAL DateiDatum%, DateiZeit%„„		LOCATE , 3: PRINT "Kopiere/Copying: ";Quelle$„		LOCATE , 3: PRINT "        nach/to: ";Ziel$„„		'*** Variablen Init ***„		Quelle$    = Quelle$ + CHR$(0)„		Ziel$      = Ziel$ + CHR$(0)„		QuelleSeg% = STRSEG(Quelle$)„		QuelleOff% = STRPTR(Quelle$)„		ZielSeg%   = STRSEG(Ziel$)„		ZielOff%   = STRPTR(Ziel$)„		Buffer%    = 32000„		Copy$      = STRING$(32000, 0)„		CopySeg%   = STRSEG(Copy$)„		CopyOff%   = STRPTR(Copy$)„„		'*** Quell-Datei ˆffnen / open source file ***„		! push ds„		! mov ax, &h3d90„		! mov dx, QuelleOff%„		! mov  ds, QuelleSeg%„		! int &h21„		! pop ds„		! jnc QuellFileOpenOk„		FileCopyError% = 1„		EXIT SUB„		QuellFileOpenOk:„		! mov QuellHandle%, ax„„		'*** Ziel-Datei ˆffnen / open destination file ***„		! push ds„		! mov ax, &h3c00„		! mov cx, &h0„		! mov dx, ZielOff%„		! mov ds, ZielSeg%„		! int &h21„		! pop ds„		! mov ZielHandle%, ax„		! jnc ZielFileOpenOk„		FileCopyError% = 1„		EXIT SUB„		ZielFileOpenOk:„„		'*** Quell-Datei einlesen / read source file ***„„		DO WHILE Buffer% = 32000„			! push ds„			! mov ax, &h3F00„			! mov bx, QuellHandle%„			! mov cx, Buffer%„			! mov dx, CopyOff%„			! mov ds, CopySeg%„			! int &h21„			! pop ds„			! mov Buffer%, ax„			! jnc ReadOk„			FileCopyError% = 1„			EXIT SUB„			ReadOk:„„			'*** Ziel-Datei schreiben / write destination file ***„			! push ds„			! mov ax, &h4000„			! mov bx, ZielHandle%„			! mov cx, Buffer%„			! mov dx, CopyOff%„			! mov ds, CopySeg%„			! int &h21„			! pop ds„			! mov Buffer%, ax„			! jnc WriteOk„			FileCopyError% = 1„			EXIT SUB„			WriteOk:„		LOOP„„		'*** Quell-Datei Datum lesen / read time/date ***„		! mov ax, &h5700„		! mov bx, QuellHandle%„		! int &h21„		! mov DateiZeit%, cx„		! mov DateiDatum%, dx„		! jnc LeseZeitOk„		FileCopyError% = 1„		EXIT SUB„		LeseZeitOk:„„		'*** Ziel-Datei Datum schreiben / write date/time ***„		! mov ax, &h5701„		! mov bx, ZielHandle%„		! mov cx, DateiZeit%„		! mov dx, DateiDatum%„		! int &h21„		! jnc SchreibeZeitOk„		FileCopyError% = 1„		EXIT SUB„		SchreibeZeitOk:„„		'*** Quell- & Ziel-Datei schlieﬂen / close files ***„		CloseAllFiles:„		! mov ax, &h3E00„		! mov bx, QuellHandle%„		! int &h21„		! jnc QuellFileCloseOk„		FileCopyError% = 1„		EXIT SUB„		QuellFileCloseOk:„„		! mov ax, &h3E00„		! mov bx, ZielHandle%„		! int &h21„		! jnc ZielFileCloseOk„		FileCopyError% = 1„		EXIT SUB„		ZielFileCloseOk:„„END SUB„'*************************************************************************„Douggie Green                  QBASIC ROUTINES                comp.lang.basic.misc           11-06-95 (03:31)       QBasic                 1124 28658    ROUTINES.BAS'>  I need some advise. I'm writing a small program with menus and one of „'> selection should display contents of the diskette or HD.„'> I know I can do it going to Shell, but I want to have them displayed in„'> a small box on the same screen with menus. I'd like to have a feature „'> of tagging these files and process them later.„„'Um, well, I was going to wait until I'd plugged in a few more snippets,„'but seeing as one of the things this does is read directories and display„'file info, here it is.„„'This is a beta posting of the new code snipets faq format. It currently„'runs in screen 0 only as the hi-liting routines only work in this mode.„'This will change (hopefully).„'This file will become the new code faq in a week or so. „„'There are no attributations(!) yet, or many comments. I think most of the„'code is fairly self-explanatory.„„'Comments, criticisms, suggestions to me at :-„'Douggie@blissinx.demon.co.uk„„'-----------------------------begin--cut here-------------------------------„DEFINT A-Z„DECLARE SUB Inverse (x%, y%, w$) 'Invert the word and it's backgound (toggle)„DECLARE SUB ShowBitMap (data$)   'Display a 16 colour bitmap„DECLARE SUB OpenHelpWindow ()    'Does what it says!„DECLARE SUB OpenAboutWindow ()   'More of the same„DECLARE SUB PageDown ()          'Show more files if there's more than a„DECLARE SUB PageUp ()            'screenful - PageUp does the reverse„DECLARE SUB OpenDropDown (x%, w%, d%)  'Open and close dropdown menus„DECLARE SUB CloseDropDown (x%, w%, d%)„DECLARE SUB ShowKeyboardStatus ()  'Status of Num lock, Insert, Alt, etc.„DECLARE SUB DoCommand (comm$)    'All commands are launched from here.„DECLARE SUB FileInfoWindow (filenumber%)„DECLARE SUB ShowFileDetails (filename$)„DECLARE SUB AlertWindow (message$)„„DECLARE FUNCTION IsDirectory% (entry$)„DECLARE FUNCTION DropDownMenu$ (menu%)„DECLARE FUNCTION GetWhichCommand% (menu$)„DECLARE FUNCTION BitClear% (Number%, bit%)„DECLARE FUNCTION BitSet% (Number%, bit%)„DECLARE FUNCTION BitTest% (Number%, bit%)„„DECLARE FUNCTION QueryWindow% (question$)„DECLARE SUB ShowFiles (first%, last%)„DECLARE SUB DrawBorder (x%, y%, w%, d%, bordertype%)„DECLARE SUB WriteWindow (x%, y%, w%, d%, windw() AS ANY)„DECLARE SUB ClearWindow (x%, y%, w%, d%)„DECLARE SUB ReadWindow (x%, y%, w%, d%, windw() AS ANY)„DECLARE SUB DrawScreen ()„DECLARE SUB Pause (message$)„DECLARE FUNCTION ScanWord$ (x%, y%, att%)„DECLARE FUNCTION Rstr$ (x%, LX%)„„DECLARE SUB Interrupt (IntNum%, Regs AS ANY) 'Interrupt interface„DECLARE SUB GetMousePos (xp%, yp%)        'All these routines use interrupts„DECLARE FUNCTION ButtonStatus% (button$)„DECLARE FUNCTION ButtonRelease% (button$)„DECLARE SUB SetMousePos (xmpos%, ympos%)„DECLARE FUNCTION InitMouse% ()„DECLARE SUB ShowMouse ()„DECLARE SUB HideMouse ()„„DECLARE FUNCTION ReadThisDir% ()„DECLARE FUNCTION GetBootDrive$ ()„DECLARE FUNCTION GetFreeSpace% (drive$)„DECLARE FUNCTION GetDosVer$ ()„DECLARE FUNCTION GetDefaultDrive$ ()„DECLARE FUNCTION GetCurrentDir$ ()„DECLARE FUNCTION Dir$ (DTA AS ANY, attr%)„DECLARE FUNCTION KeyBoardStatus% ()    'Last of the interrupt driven routines„„TYPE DataTransferArea„	Reserved1   AS STRING * 21„	attribute   AS STRING * 1„	FileTime    AS INTEGER„	filedate    AS INTEGER„	filesize    AS LONG„	filename    AS STRING * 13„END TYPE„„TYPE DirectoryRecord„	filename    AS STRING * 13„	filesize    AS LONG„	filedate    AS STRING * 12„	FileTime    AS STRING * 14„	fileattb    AS STRING * 2„END TYPE„„DIM SHARED FileDetails(200) AS DirectoryRecord„DIM SHARED TempFileDetails AS DirectoryRecord„„TYPE RegTypeX„		ax    AS INTEGER„		bx    AS INTEGER„		cx    AS INTEGER„		dx    AS INTEGER„		BP    AS INTEGER„		si    AS INTEGER„		DI    AS INTEGER„		flags AS INTEGER„		ds    AS INTEGER„		ES    AS INTEGER„END TYPE„„DIM SHARED Regs AS RegTypeX„„TYPE windowdetails„	character AS STRING * 1„	attribute AS STRING * 1„END TYPE„„CONST Rshift = 0, Lshift = 1, Ctrl = 2, Alt = 3, Scrollock = 4„CONST NumLock = 5, CapsLock = 6, Insert = 7„CONST kpageup = 73, kpagedown = 81„CONST ret = 13, maxfiles = 95, maxsize = 2000„„DIM SHARED windw(maxsize) AS windowdetails„DIM SHARED page, fst, lst, count AS INTEGER„„COMMON SHARED selection$„„'-------------------------start of main code-------------------------„SCREEN 0„CLS„mousebuttons = InitMouse  '' This will usually return 2, even with 3 button„																										'' mice <dg>„IF mousebuttons = 0 THEN„		PRINT "Mouse not present"„		END„END IF„„DrawScreen„„CALL SetMousePos(30, 10)              '' x,y format, based on 80x25 screen„	„ShowMouse„„count = ReadThisDir%    'How many files in this directory?„„ShowFiles 0, maxfiles   'List first page of files„„DO                      'Main control loop„„ ShowKeyboardStatus      'Alt, numlock status etc.„ „ IF ButtonRelease("l") THEN              'Deal with the mouse first„ „	GetMousePos mxp, myp„ „	word$ = ScanWord$(mxp, (myp), attr)„ „	IF word$ <> "" AND myp = 0 THEN        'Got a menubar command„	 maincomm = GetWhichCommand%(word$)    'Find which menu to open„	 menuselection$ = DropDownMenu$(maincomm) 'Get the actual command (Help etc)„	 DoCommand menuselection$                 'Do it„	END IF„ „	IF word$ <> "" AND IsDirectory(word$) THEN  'This is a directory (.. etc)„	 CHDIR MID$(word$, 2, LEN(word$) - 2)      'Trim the "<" and ">"„	 selection$ = "": word$ = ""         'Clear these to avoid problems„	 DrawScreen                               'Change directory, re-read and„	 count = ReadThisDir%                    'update the display„	 ShowFiles 0, maxfiles„	END IF„	„	IF word$ <> "" AND myp < 22 AND myp > 1 THEN  'It's a filename„	„	 IF attr = 7 THEN              'Not a hi-lited filename, so it's a new„		IF selection$ <> "" THEN     'selection„			Inverse selxpos, selypos, selection$  'un-hilite the old selection„			selection$ = ""                       'and clear it„		END IF„	 END IF„	„	 IF selection$ = word$ THEN    'clicked on the old selection„		 selection$ = ""          'so clear it„	 ELSE„		selection$ = word$        'new selection, so store co-ords for future„		selypos = myp„		selxpos = mxp„	 END IF„„	 Inverse mxp, myp, word$    'hilite the new selection or un-hilite the„															'current selection„	 LOCATE 25, 1: PRINT STRING$(26, 32);„	 LOCATE 25, 1: PRINT "Selection : "; selection$;„ „	END IF              'End of the filename handler„ „ END IF                       'End of mouse interface bits„ „ a$ = INKEY$                  'Now handle any key presses„ ctrlkey = 0                  'simple toggle„ „ IF a$ <> "" THEN„	IF LEN(a$) = 2 THEN keypress = ASC(RIGHT$(a$, 1)): ctrlkey = 1„	„	IF ctrlkey THEN            'handle control keys (pageup, pagedown etc)„	 IF keypress = kpageup THEN PageUp„	 IF keypress = kpagedown THEN PageDown„	END IF„ „ END IF„ „LOOP UNTIL a$ = " "          'End of main loop„„END„„„''hex data for interrupt routines„„DATA  &H55, &H8B, &HEC, &H83, &HEC, &H08, &H56, &H57, &H1E, &H55, &H8B, &H5E„DATA  &H06, &H8B, &H47, &H10, &H3D, &HFF, &HFF, &H75, &H04, &H1E, &H8F, &H47„DATA  &H10, &H8B, &H47, &H12, &H3D, &HFF, &HFF, &H75, &H04, &H1E, &H8F, &H47„DATA  &H12, &H8B, &H47, &H08, &H89, &H46, &HF8, &H8B, &H07, &H8B, &H4F, &H04„DATA  &H8B, &H57, &H06, &H8B, &H77, &H0A, &H8B, &H7F, &H0C, &HFF, &H77, &H12„DATA  &H07, &HFF, &H77, &H02, &H1E, &H8F, &H46, &HFA, &HFF, &H77, &H10, &H1F„DATA  &H8B, &H6E, &HF8, &H5B, &HCD, &H21, &H55, &H8B, &HEC, &H8B, &H6E, &H02„DATA  &H89, &H5E, &HFC, &H8B, &H5E, &H06, &H1E, &H8F, &H46, &HFE, &HFF, &H76„DATA  &HFA, &H1F, &H89, &H07, &H8B, &H46, &HFC, &H89, &H47, &H02, &H89, &H4F„DATA  &H04, &H89, &H57, &H06, &H58, &H89, &H47, &H08, &H89, &H77, &H0A, &H89„DATA  &H7F, &H0C, &H9C, &H8F, &H47, &H0E, &H06, &H8F, &H47, &H12, &H8B, &H46„DATA  &HFE, &H89, &H47, &H10, &H5A, &H1F, &H5F, &H5E, &H8B, &HE5, &H5D, &HCA„DATA  &H02, &H00          „„menubar:„DATA 3,"Disk","File","Help"„„menuitems:„DATA 2,7,3,"Format","Dir","Shell"„DATA 10,5,5,"List","Edit","Info","View","Exit"„DATA 72,6,2,"Help","About"„„„about:„DATA 4,"The new BASIC code FAQ","Version 0.1 - 2/NOV/95"„DATA "email Douggie@blissinx.demon.co.uk"„DATA "or basicfaq@blissinx.demon.co.uk"„„help:„DATA 3,"Use pageup and pagedown if the list"„DATA "of files is bigger than the screen"„DATA "Press the space bar to exit the program."„„SUB AlertWindow (m$)„ln = LEN(m$)„„x = 40 - ((ln + 2) / 2)„y = 10: w = ln + 4: d = 4„„ReadWindow x, y, w, d, windw()„ClearWindow x, y, w, d„DrawBorder x, y, w, d, 2„'nbeep„„LOCATE y + 1, x + ((w - ln) / 2)„PRINT m$;„LOCATE y + 2, x + ((w - 2) / 2)„PRINT "Ok";„„DO„		IF ButtonRelease("l") THEN„				GetMousePos tx, ty„				IF ty = y + 1 THEN„						ans$ = ScanWord$(tx, (ty), dum)„						IF ans$ = "Ok" THEN„								'flash tx, ty + 1, ans$„								'writewindow x, y, w, d, windw%()„						END IF„				END IF„		END IF„„key$ = INKEY$„IF key$ <> "" THEN ky = ASC(key$)„„LOOP UNTIL ans$ = "Ok" OR ky = ret„WriteWindow x, y, w, d, windw()„END SUB„„FUNCTION BitClear% (Number%, bit%)„				BitClear% = Number% AND (32767 - 2 ^ bit%)„END FUNCTION„„FUNCTION BitSet% (Number%, bit%)„				BitSet% = Number% OR 2 ^ bit%„END FUNCTION„„FUNCTION BitTest% (Number%, bit%)„				BitTest% = -SGN(Number% AND 2 ^ bit%)„END FUNCTION„„FUNCTION ButtonRelease (b$)„Regs.ax = &H6„	IF LEFT$(UCASE$(b$), 1) = "L" THEN Regs.bx = 0 ELSE Regs.bx = 1„Interrupt &H33, Regs„„ButtonRelease = Regs.bx  '' Count of releases, reset to 0 each call.„„END FUNCTION„„FUNCTION ButtonStatus (b$)„''  b$ should be either "l" or "r". When called once, will return the„''  number of times the specified button has been pressed since the last„''  call. When used in a loop, as in this demo prog, it works like INKEY$„''  Could be split into ButtonDown() and ButtonCount()  <dg>„„		Regs.ax = &H5„		IF LEFT$(UCASE$(b$), 1) = "L" THEN Regs.bx = 0 ELSE Regs.bx = 1„		Interrupt &H33, Regs„	„		ButtonStatus = Regs.bx  '' Count of presses, reset to 0 each call.„	„		IF Regs.ax > 0 THEN ButtonStatus = Regs.ax  '' Is a button down?„																																														''if so, return which button„END FUNCTION„„SUB ClearWindow (x, y, w, d)„„ty = y„COLOR 7, 0„FOR k = 1 TO d - 1„			LOCATE y + k, x„			PRINT STRING$(w, 32)„NEXT k„„END SUB„„SUB CloseDropDown (x, w, d)„y = 2„w = w + 2„d = d + 2„WriteWindow x, y, w, d, windw()„END SUB„„FUNCTION Dir$ (dt AS DirectoryRecord, attribute) STATIC„„DIM dtarec AS DataTransferArea„Null$ = CHR$(0)„„			'-----  Set up our own DTA so we don't destroy COMMAND$„Regs.ax = &H1A00                    'Set DTA function„Regs.dx = VARPTR(dtarec)               'DS:DX points to our DTA„Regs.ds = -1                        'Use current value for DS„CALL Interrupt(&H21, Regs)            'Do the interrupt„„IF ASC(dt.filename) > 32 THEN„	FileSpecZ$ = dt.filename + Null$„	Regs.ax = &H4E00„	Regs.cx = attribute„	Regs.dx = SADD(FileSpecZ$)„	Regs.ds = -1„ELSE„	Regs.ax = &H4F00„END IF„dtarec.filename = ""„CALL Interrupt(&H21, Regs)„„IF Regs.flags AND 1 THEN„	Dir$ = ""„ELSE„	Day = dtarec.filedate AND &H1F„	Month = (dtarec.filedate AND &H1E0) \ 32„	Year = (dtarec.filedate AND &HFE00) \ 512 + 1980„	dt.filedate = Rstr$(Month, 2) + "-" + Rstr$(Day, 2) + "-" + Rstr$(Year, 4)„	„	Seconds = (dtarec.FileTime AND &H1F) * 2„	Minutes = (dtarec.FileTime AND &H7E0) \ 32„	Hours = (dtarec.FileTime < 0) * (-16) + ((dtarec.FileTime AND &H7FFF) \ 2048)„	Abbr$ = " am"„	IF Hours = 12 THEN Abbr$ = " pm"„	IF Hours = 0 THEN Hours = 12„	IF Hours > 12 THEN   'Reset to 12 hour clock„		Hours = Hours MOD 12„		Abbr$ = " pm"„	END IF„	„	dt.FileTime = Rstr$(Hours, 2) + ":" + Rstr$(Minutes, 2) + ":" + Rstr$(Seconds, 2) + Abbr$„	dt.filename = dtarec.filename„	dt.filesize = dtarec.filesize„	dt.fileattb = STR$(ASC(dtarec.attribute))„'PRINT dt.fileattb„	Dir$ = dt.filename„END IF„„END FUNCTION„„SUB DoCommand (cm$)„„IF cm$ = "About" THEN„	OpenAboutWindow„	EXIT SUB„END IF„„IF cm$ = "Help" THEN„	OpenHelpWindow„	EXIT SUB„END IF„„IF cm$ = "Exit" THEN„ END„END IF„„IF cm$ = "Format" THEN„ AlertWindow ("Write your own code for this!")„ EXIT SUB„END IF„„IF cm$ = "Shell" THEN„	HideMouse„	CLS„	PRINT "Type EXIT to resume"„	SHELL ("")„	d = InitMouse„	DrawScreen„	ShowFiles 0, count„	ShowMouse„	EXIT SUB„END IF„„' handle actions on the selected file„„IF cm$ <> "" AND selection$ = "" THEN AlertWindow ("No file selected!"): EXIT SUB„„IF cm$ = "Info" THEN„ ShowFileDetails (selection$)„END IF„„IF cm$ = "Edit" THEN„ HideMouse„ SHELL ("edit " + selection$)„ d = InitMouse„ ShowMouse„END IF„„IF cm$ = "View" THEN„ ShowBitMap selection$„ DrawScreen„ ShowFiles 0, count„ ShowMouse„END IF„„IF cm$ = "List" THEN„ HideMouse„ CLS„ SHELL ("type " + selection$ + " | more ")„ Pause "Press a key to continue"„ DrawScreen„ ShowFiles 0, count„ ShowMouse„END IF„„END SUB„„SUB DrawBorder (x, y, w, d, b)„„		IF b = 1 THEN„				tlc% = 201: trc% = 187: blc% = 200: brc% = 188: vb% = 186: hb% = 205„						ELSEIF b > 1 THEN„				tlc% = 218: trc% = 191: blc% = 192: brc% = 217: vb% = 179: hb% = 196„				END IF„„IF b = 3 THEN tlc% = 194: trc% = 194„„		IF b <> 0 THEN„				LOCATE y, x: PRINT CHR$(tlc%);„				PRINT STRING$(w - 2, hb%); : PRINT CHR$(trc%)„						FOR k% = 1 TO d - 2„								LOCATE y + k%, x: PRINT CHR$(vb%)„								LOCATE y + k%, x + w - 1: PRINT CHR$(vb%)„						NEXT„				LOCATE y + d - 1, x: PRINT CHR$(blc%);„				PRINT STRING$(w - 2, hb%); : PRINT CHR$(brc%)„		END IF„„END SUB„„SUB DrawScreen„CLS„PRINT "Disk     File                      ";„PRINT "                                        Help "„PRINT STRING$(80, 196);„LOCATE 22, 1„PRINT STRING$(80, 196);„LOCATE 23, 1: PRINT "Last booted from "; GetBootDrive$;„LOCATE 23, 22: PRINT "Default drive "; GetDefaultDrive$;„LOCATE 23, 40: PRINT "DOS version "; GetDosVer$;„„LOCATE 23, 58: PRINT "Free space "; GetFreeSpace%(GetDefaultDrive$); " K";„LOCATE 24, 1: PRINT "Current directory "; GetCurrentDir$;„LOCATE 25, 1: PRINT STRING$(26, 32);„LOCATE 25, 1: PRINT "Selection : "; selection$;„„END SUB„„FUNCTION DropDownMenu$ (menu)„RESTORE menuitems„„FOR k = 0 TO menu - 1„	READ xpos, wide, numofitems„	FOR j = 1 TO numofitems„		READ item$„	NEXT„NEXT„„READ xpos, wide, numofitems„CALL OpenDropDown((xpos), (wide), (numofitems))„„FOR k = 1 TO numofitems„	READ item$„	LOCATE k + 2, xpos + 1„	PRINT item$;„NEXT„„DO„GetMousePos x, y„x = x + 1„„but = ButtonRelease("l")„a$ = INKEY$„LOOP UNTIL LEN(a$) OR but„„IF x > xpos AND x < xpos + wide AND y > 1 AND y < y + numofitems THEN„	com$ = ScanWord$(x - 1, y, d)   'Get the command as text„	comm = y - 2                    'Get the command as an numeric offset„END IF„„'LOCATE 25, 1: PRINT com$, comm;„„CloseDropDown xpos, wide, numofitems„„DropDownMenu$ = com$„„END FUNCTION„„SUB FileInfoWindow (k)„„x = 25: y = 10„w = 30: d = 6„„ReadWindow x, y, w, d, windw()„ClearWindow x, y, w, d„DrawBorder x, y, w, d, 2„„LOCATE y + 1, x + 2„PRINT "File name ; "; FileDetails(k).filename„LOCATE y + 2, x + 2„PRINT "File size ;"; FileDetails(k).filesize; " Bytes"„LOCATE y + 3, x + 2„PRINT "File date ; "; FileDetails(k).filedate„„LOCATE y + 4, x + 14„PRINT "Ok";„„DO„		IF ButtonRelease("l") THEN„				GetMousePos tx, ty„				IF ty = y + 3 THEN„						ans$ = ScanWord$(tx, (ty), dum)„						IF ans$ = "Ok" THEN„								'flash tx, ty + 1, ans$„„						END IF„				END IF„		END IF„„key$ = INKEY$„IF key$ <> "" THEN ky = ASC(key$)„„LOOP UNTIL ans$ = "Ok" OR ky = ret„WriteWindow x, y, w, d, windw()„„END SUB„„SUB flash (x, y, a$)„HideMouse„LOCATE y, x„COLOR 0, 7„PRINT a$;„FOR k = 1 TO 20000: NEXT„LOCATE y, x„COLOR 7, 0„PRINT a$;„FOR k = 1 TO 20000: NEXT„ShowMouse„END SUB„„FUNCTION GetBootDrive$„„'Returns the drive the system was last re-booted from as a letter plus„'a colon, eg, C: or A:„„Regs.ax = &H3305„CALL Interrupt(&H21, Regs)„GetBootDrive$ = CHR$((Regs.dx MOD 256) + 64) + ":"„END FUNCTION„„FUNCTION GetCurrentDir$„„'Returns the current working directory, this may or may NOT be the directory„'the program was started from„„DIM buf AS STRING * 80„Null$ = CHR$(0)„„Regs.ax = &H4700„Regs.dx = 0             'The default drive, 1=A, 2=B, 3=C, 4=D etc„																								'A null string ("") is returned if the root„																								'directory is found (ie, C:\ or A:\ )„„Regs.ds = -1            'Use current DS„Regs.si = VARPTR(buf)„CALL Interrupt(&H21, Regs)            'Do the interrupt„	„IF Regs.flags AND 1 THEN„	PRINT "An error has occured in Function GetCurrentDir$. Error no. is ";„	PRINT Regs.flags„	PRINT "This program is terminating."„	END„ELSE„	Null = INSTR(buf, Null$)„	GetCurrentDir$ = MID$(buf, 1, Null - 1)„END IF„„END FUNCTION„„FUNCTION GetDefaultDrive$„„Regs.ax = &H1900„CALL Interrupt(&H21, Regs)„GetDefaultDrive$ = CHR$((Regs.ax MOD 256) + 65) + ":"„END FUNCTION„„FUNCTION GetDosVer$„'Returns major and minor version as a string of the format "6.20)„„Regs.ax = &H3306„CALL Interrupt(&H21, Regs)            'Do the interrupt„GetDosVer$ = Rstr$(Regs.bx AND &HFF, 1) + "." + Rstr$(Regs.bx \ &HFF, 2)„END FUNCTION„„FUNCTION GetFreeSpace% (d$)„„'d$ can be either upper or lower case„'Returns disk free space rounded to the nearest kilobyte„'If the drive doesn't exist, GetFreeSpace% returns 0„'If there is no disk in the (floppy) drive, the system will lock up,„'requiring a soft reset (Ctrl+Alt+Del)„„Regs.ax = &H3600„Regs.dx = (ASC(d$) AND &HDF) - 64  'Turn drive letter into (1 - No. of drives)„CALL Interrupt(&H21, Regs)„GetFreeSpace% = Regs.bx * ((Regs.ax * Regs.cx) / 1024)„END FUNCTION„„SUB GetMousePos (xp, yp)„		Regs.ax = &H3„		Interrupt &H33, Regs„		xp = Regs.cx / 8   '' These values may need changing depending on„		yp = Regs.dx / 8   '' your screen mode <dg>„END SUB„„FUNCTION GetWhichCommand% (menu$)„RESTORE menubar„READ numofitems„FOR comm = 0 TO numofitems - 1„	READ menuitem$„	IF menuitem$ = menu$ THEN„		EXIT FOR„	END IF„NEXT„GetWhichCommand% = comm„„END FUNCTION„„SUB HideMouse„		Regs.ax = &H2„		Interrupt &H33, Regs„END SUB„„FUNCTION InitMouse„		Regs.ax = &H0„		Interrupt &H33, Regs„		IF Regs.ax <> 0 THEN InitMouse = Regs.bx ELSE InitMouse = 0„END FUNCTION„„SUB Interrupt (IntNum, Regs AS RegTypeX) STATIC„		STATIC filenum, IntOffset, Loaded„		„		' use fixed-length string to fix its position in memory„		' and so we don't mess up string pool before routine„		' gets its pointers from caller„		DIM IntCode AS STRING * 200„		IF NOT Loaded THEN                     ' loaded will be 0 first time„			„			FOR k = 1 TO 145„						READ h%„						MID$(IntCode, k, 1) = CHR$(h%)„			NEXT„„														''  determine address of interrupt no. offset in IntCode„			IntOffset = INSTR(IntCode$, CHR$(&HCD) + CHR$(&H21)) + 1„			Loaded = -1„		END IF„SELECT CASE IntNum„				CASE &H25, &H26, IS > 255               ' ignore these interrupts„				CASE ELSE„						DEF SEG = VARSEG(IntCode)             ' poke interrupt number into„						POKE VARPTR(IntCode) * 1& + IntOffset - 1, IntNum     ' code block„						CALL Absolute(Regs, VARPTR(IntCode$))               ' call routine„		END SELECT„END SUB„„SUB Inverse (x, y, w$)„HideMouse„att = SCREEN(y + 1, x, 1)„LOCATE y + 1, x„IF att = 112 THEN COLOR 7, 0 ELSE COLOR 0, 7„PRINT w$;„COLOR 7, 0„ShowMouse„END SUB„„FUNCTION IsDirectory% (entry$)„„FOR k = 1 TO count„	IF entry$ = LEFT$(FileDetails(k).filename, LEN(entry$)) AND FileDetails(k).fileattb = " 1" THEN„		IsDirectory% = k„		EXIT FOR„	END IF„NEXT„„END FUNCTION„„FUNCTION KeyBoardStatus%„Regs.ax = &H200„CALL Interrupt(&H16, Regs)„KeyBoardStatus% = Regs.ax„END FUNCTION„„SUB nbeep„SOUND 2500, 2„END SUB„„SUB OpenAboutWindow„„RESTORE about„READ numofitems„„x = 20: y = 10„w = 40: d = numofitems + 2„„ReadWindow x, y, w, d, windw()„ClearWindow x, y, w, d„DrawBorder x, y, w, d, 2„„FOR k = 1 TO numofitems„	LOCATE y + k, x + 2„	READ item$„	PRINT item$„NEXT„„DO„LOOP UNTIL LEN(INKEY$) OR ButtonRelease("l")„„WriteWindow x, y, w, d, windw()„END SUB„„SUB OpenDropDown (x, w, d)„y = 2„w = w + 2„d = d + 2„ReadWindow x, y, w, d, windw()„ClearWindow x, y, w, d„DrawBorder x, y, w, d, 3„„END SUB„„SUB OpenHelpWindow„„RESTORE help„READ numofitems„„x = 20: y = 10„w = 45: d = numofitems + 2„„ReadWindow x, y, w, d, windw()„ClearWindow x, y, w, d„DrawBorder x, y, w, d, 1„„FOR k = 1 TO numofitems„	LOCATE y + k, x + 2„	READ item$„	PRINT item$„NEXT„„DO„but = ButtonRelease("l")„a$ = INKEY$„LOOP UNTIL LEN(a$) OR but„„WriteWindow x, y, w, d, windw()„„END SUB„„SUB PageDown„„page = page + 1„fst = page * maxfiles„IF fst > count + 1 THEN„		BEEP„		page = page - 1„		EXIT SUB„END IF„lst = fst + maxfiles„'scrllbarps = scrllbarps + scrllinterval„ShowFiles fst, lst„END SUB„„SUB PageUp„page = page - 1„IF page < 0 THEN„		BEEP„		page = page + 1„		EXIT SUB„END IF„fst = page * maxfiles„lst = fst + maxfiles„ShowFiles fst, lst„„END SUB„„SUB Pause (m$)„IF m$ <> "" THEN PRINT m$;„WHILE a$ = ""„a$ = INKEY$„WEND„END SUB„„FUNCTION QueryWindow (m$)„„IF LEN(m$) < 10 THEN„		fill = (10 - LEN(m$)) / 2„		fill$ = STRING$(fill, 32)„		m$ = fill$ + m$ + fill$„END IF„„x = 40 - ((LEN(m$) + 2) / 2)„y = 10: w = LEN(m$) + 2: d = 5„„ReadWindow x, y, w, d, windw()„ClearWindow x, y, w, d„DrawBorder x, y, w, d, 2„„LOCATE y + 1, x + 1„PRINT m$„tx = x + ((w - 1) / 2) - 4„„LOCATE y + 3, tx„PRINT "Yes  No"„ty = y„b = -1„DO„		IF ButtonRelease("l") THEN„				GetMousePos tx, ty„				IF ty = y + 3 THEN„						ans$ = ScanWord$(tx, (ty), dum)„						'flash tx, ty, ans$„						b = INSTR("NY", LEFT$(ans$, 1)) - 1„						' querywindow = b„				END IF„				IF ty <> y + 3 THEN„						'nbeep„						WriteWindow x, y, w, d, windw()„						EXIT FUNCTION„				END IF„		END IF„„		c$ = ""„		c$ = INKEY$„		IF c$ <> "" THEN„				c$ = UCASE$(c$)„				b = INSTR("NY", c$) - 1„		END IF„„LOOP UNTIL ans$ <> "" OR b <> -1„WriteWindow x, y, w, d, windw()„QueryWindow = b„„END FUNCTION„„FUNCTION ReadThisDir%„„FOR k = 1 TO count„	TempFileDetails.filename = ""„	FileDetails(k).filename = ""„NEXT„„TempFileDetails.filename = "*.*"   'adjust this as appropriate„attr = 16„„found$ = Dir$(TempFileDetails, attr)     'check for the first file„count = 1„„DO WHILE LEN(found$)„	 „		IF TempFileDetails.fileattb = " 1" THEN„			TempFileDetails.filename = "<" + TempFileDetails.filename„			MID$(TempFileDetails.filename, INSTR(TempFileDetails.filename, CHR$(0))) = ">"„		END IF„„		FileDetails(count) = TempFileDetails„		count = count + 1„		TempFileDetails.filename = ""„		found$ = Dir$(TempFileDetails, attr) '' Notice the null filespec.„LOOP„ReadThisDir% = count„„END FUNCTION„„SUB ReadWindow (x, y, w, d, windw() AS windowdetails)„l = 0„ty = y + d„tx = x + w„HideMouse„FOR k = y TO ty„			FOR j = x TO tx„						LOCATE k, j„						windw(l).character = CHR$(SCREEN(k, j))„						windw(l).attribute = CHR$(SCREEN(k, j, 1) - 7)„						l = l + 1„			NEXT j„NEXT k„ShowMouse„END SUB„„FUNCTION Rstr$ (x%, LX%)„x$ = STR$(x%)„Rstr$ = RIGHT$("00000" + RIGHT$(x$, LEN(x$) - 1), LX%)„END FUNCTION„„FUNCTION ScanWord$ (x, y, att)„y = y + 1: x = x + 1 '' need to adjust because the mouse routines return„																					„HideMouse„„c = SCREEN(y, x)             ''Get the character under the mouse cursor„att = SCREEN(y, x, 1)        ''and it's atribute                                           „IF c > 39 AND c < 123 THEN   ''We're over a word so...„LOCATE y, x„„DO                       ''Find the start of the word„c = SCREEN(y, x)„x = x - 1„LOOP UNTIL c < 39 OR c > 123 OR x = 0„			„IF x > 0 THEN x = x + 2  ''We end up at the x position *before* the word„IF x = 0 THEN x = 1      ''SCREEN and LOCATE need this, just in case.„			„DO                       ''Read the word„c = SCREEN(y, x)„w$ = w$ + CHR$(c)„x = x + 1„LOOP UNTIL c < 39 OR c > 123 OR x = 0„„w$ = LEFT$(w$, LEN(w$) - 1)  ''We end up past the word, so trim it.„x = x - LEN(w$) - 1„END IF„„ScanWord$ = w$„ShowMouse„END FUNCTION„„SUB SetMousePos (xmpos, ympos)„		Regs.ax = &H4„		Regs.cx = xmpos * 8 '' These values may need changing depending on„		Regs.dx = ympos * 8 '' your screen mode <dg>„		Interrupt &H33, Regs„„END SUB„„' 2) --------------------------begin SHOWBMP2.BAS---------------------„''This is at least twice as fast as the previous routine.„'By Kim Christensen„'This routine will read in a Windows Bitmap file and display it.„'Only 16 color Bitmaps are supported. Even with SCREEN 13: I am„'only using that mode to "blow up" the picture a bit.„'Comments? Questions? Suggestions? : uv317@freenet.victoria.bc.ca„'No flames please! :)„SUB ShowBitMap (data$)„„'INPUT "Filename"; data$„IF LTRIM$(RTRIM$(data$)) = "" THEN END„OPEN data$ FOR BINARY AS #1„IF LOF(1) = 0 THEN AlertWindow ("File not found!"): CLOSE : KILL data$: END„„table$ = INPUT$(54, #1)  'Get the file header (54 bytes)„DIM table&(30)           'Create numerical array for header„DEF SEG = VARSEG(table&(1))„pointer% = VARPTR(table&(1))„„'Poke the data from string "table$" into numerical array "table&"„FOR x% = 0 TO 51„ POKE pointer% + x%, ASC(MID$(table$, x% + 3, 1))„NEXT„DEF SEG„„'Check for valid file type„IF MID$(table$, 1, 2) <> "BM" OR table&(4) <> 40 THEN„	 AlertWindow ("Not a valid *.BMP file!"): CLOSE : EXIT SUB„END IF„IF table&(8) <> 0 THEN„		AlertWindow ("This program will not diplay RLE encoded files"): CLOSE : EXIT SUB„END IF„IF ASC(MID$(table$, 29, 1)) <> 4 THEN„	 AlertWindow ("Only 16 color bitmaps are supported!"): CLOSE : EXIT SUB„END IF„„'Set the video mode for best picture fit„IF (table&(5) < 321) AND (table&(6) < 201) THEN„	 SCREEN 13„ELSE„	 SCREEN 12„END IF„LOCATE 2, 1„PRINT " Image is "; table&(5); " by "; table&(6)„„thecolors$ = INPUT$(table&(3) - 54, #1) 'Read in pallette info„DEF SEG = VARSEG(pal&)„pointer% = VARPTR(pal&)„'Poke the pallette info from the string "thecolors$"„'into pal& and reduce to 6 bits per byte.„FOR x% = 0 TO 63 STEP 4„ POKE pointer%, (ASC(MID$(thecolors$, x% + 3, 1))) \ 4„ POKE pointer% + 1, (ASC(MID$(thecolors$, x% + 2, 1))) \ 4„ POKE pointer% + 2, (ASC(MID$(thecolors$, x% + 1, 1))) \ 4„ POKE pointer% + 3, 0„PALETTE x% \ 4, pal&„NEXT„DEF SEG„„'Read in Bitmap data and set pixels accordingly„y% = table&(6) 'Put number of vertical pixels into y%„DO„	data$ = INPUT$((((table&(5) - 1) OR 7) + 1) \ 2, #1)„		IF (table&(5) \ 2) < LEN(data$) THEN„			 linelength% = table&(5) \ 2„		ELSE„			 linelength% = LEN(data$)„		END IF„		FOR x% = 1 TO linelength%„			pixel% = ASC(MID$(data$, x%, 1))„			PSET (x% * 2 + 1, y%), pixel% AND 15„			PSET (x% * 2, y%), pixel% \ 16„		NEXT„		y% = y% - 1„LOOP UNTIL EOF(1) OR INKEY$ <> ""„„Pause ""„SCREEN 0„END SUB„„SUB ShowFileDetails (filename$)„'first check it's in the list we made„„FOR k = 1 TO count„	IF filename$ = LEFT$(FileDetails(k).filename, LEN(filename$)) THEN„		FileInfoWindow (k)„		EXIT FOR„	END IF„NEXT„„END SUB„„SUB ShowFiles (first, last)„k = 3: l = first„HideMouse„DO„		l = l + 1„		y = k MOD 22: x = ((k \ 22)) * 16„		IF y < 3 THEN y = 3:  k = k + 3„		IF x = 0 THEN x = 1„		LOCATE y, x: PRINT FileDetails(l).filename;„		k = k + 1:„LOOP UNTIL l = last„ShowMouse„END SUB„„SUB ShowKeyboardStatus„k% = KeyBoardStatus%„LOCATE 25, 40„IF BitTest%(k%, Insert) THEN PRINT "Ins ";  ELSE PRINT "Over";„IF BitTest%(k%, Lshift) THEN PRINT "Lshift";  ELSE PRINT "      ";„IF BitTest%(k%, Rshift) THEN PRINT "Rshift";  ELSE PRINT "      ";„IF BitTest%(k%, Alt) THEN PRINT "Alt";  ELSE PRINT "   ";„IF BitTest%(k%, Ctrl) THEN PRINT "Ctrl";  ELSE PRINT "    ";„IF BitTest%(k%, NumLock) THEN PRINT "Num";  ELSE PRINT "   ";„IF BitTest%(k%, CapsLock) THEN PRINT "Caps";  ELSE PRINT "    ";„IF BitTest%(k%, Scrollock) THEN PRINT "Scroll";  ELSE PRINT "      ";„„END SUB„„SUB ShowMouse„		Regs.ax = &H1„		Interrupt &H33, Regs„END SUB„„SUB WriteWindow (x, y, w, d, windw() AS windowdetails)„l = 0„ty = y + d„tx = x + w„HideMouse„FOR k = y TO ty„			FOR j = x TO tx„						LOCATE k, j„						COLOR 7, 0„						IF ASC(windw(l).attribute) THEN COLOR 0, 7„						PRINT windw(l).character;„						l = l + 1„			NEXT j„NEXT k„ShowMouse„END SUB„Raymond Joh                    FILE PAGING DEMO               Dslayer@gnn.com                01-05-96 (00:00)       QB, QBasic, PDS        153  6155     PAGEDEMO.BAS'=============================FILE PAGING DEMO===============================„'RAYMOND JOH„'COMPUTERS SOLUTIONS„'PANAMA CITY,FLA.„'„'THIS PROGRAM IS DESIGNED TO BE AS FLEXIBLE AND USER FRIENDLY AS POSSIBLE.„'THE "USER VARIABLES" SECTION BELOW, ALLOWS YOU PLACE YOUR TEXT TO BE PAGED„'ANYWHERE ON THE SCREEN.BY REMOVING MY SCREEN.GRAPHICS SUB AND PLACING THE„'THE REST OF THIS DEMO IN YOUR PROGRAM,YOU CAN EASILY PAGE ANY FILE. THIS„'EXAMPLE PAGES YOUR C: DRIVE DIRECTORY.„'„'DONATED TO THE PUBLIC DOMAIN 1/05/95„'„DECLARE SUB SCREEN.GRAPHICS (CURPAGE%, TOTALPAGES%, FILESIZE%, DL%, LIN%, LP%, DLI%)„DECLARE SUB PAGE.1 (EXAMFILE$(), COUNT%, PAGE%, DL%, LIN%, LP%, DLI%)„DECLARE SUB PAGEUP (EXAMFILE$(), FILESIZE%, COUNT%, TOTALPAGES%, CURPAGE%, LASTKEY%, DL%, LIN%, LP%, DLI%)„DECLARE SUB PAGEDOWN (EXAMFILE$(), FILESIZE%, COUNT%, TOTALPAGES%, CURPAGE%, LASTKEY%, DL%, LIN%, LP%, DLI%)„DECLARE FUNCTION GETKEY% ()„CONST UPKEY = 72 * 256, DOWNKEY = 80 * 256, PGDN = 81 * 256, PGUP = 73 * 256„CONST ESCAPE = 27„SCREEN 12                       'SCREEN MODE OF CHOICE OF AUTHOR„'„'                      #####################„'                      ##  USER VARIBLES  ##„'                      #####################„LIN% = 22                    'NUMBER OF FILES FOR DISPLAY:CAN BE UP TO 26„DL% = 3                      'BEGINNING DISPLAY LINE,ADJUST ACCORDINGLY„LP% = 15                     'BEGINNING LINE POSITION,ADJUST ACCORDINGLY„„'                       ######################„'                       ## CREATE .DAT FILE ##„'                       ######################„'„SHELL "DIR C:/ON/B>C:\DOS\DATA.DAT"            'OR CREATE YOUR OWN„'                  ###############################„'                  ## READ .DAT FILE INTO ARRAY ##„'                  ###############################„DIM EXAMFILE$(1 TO 500)                        'DIM ARRAYS„OPEN "C:\DOS\DATA.DAT" FOR INPUT AS #1         'OPEN .DAT FILE„OPEN "C:\DOS\DOSDATA.DAT" FOR OUTPUT AS #2     'DETERMINE FILE SIZE„FILESIZE% = 1                                  'BY COPYING TO FILE #2„DO„  LINE INPUT #1, EXAMFILE$(FILESIZE%)„  PRINT #2, EXAMFILE$(FILESIZE%)„  FILESIZE% = FILESIZE% + 1„LOOP UNTIL EOF(1)„FILESIZE% = FILESIZE% - 1„CLOSE (1)„'                    ##########################„'                    ## CALL SCREEN GRAPHICS ##„'                    ##########################„DLI% = DL%                              'NOTE INITIAL LINE POSITION„TP = FILESIZE% / LIN%                   'COUNT TOTAL PAGES„CURPAGE% = 1                            'BEGINNING PAGE NUMBER„IF TP > INT(TP) THEN TOTALPAGES% = INT(TP) + 1„CALL SCREEN.GRAPHICS(CURPAGE%, TOTALPAGES%, FILESIZE%, DL%, LIN%, LP%, DLI%)„CALL PAGE.1(EXAMFILE$(), COUNT%, PAGE%, DL%, LIN%, LP%, DLI%)„„DO„  KEYIN% = GETKEY%                      'INITIATE INKEY% BY CALLING GETKEY%„  SELECT CASE KEYIN%                    '„    CASE DOWNKEY, PGDN                  'DOWN-ARROW OR PGDN PRESSED„      PAGEDOWN EXAMFILE$(), FILESIZE%, COUNT%, TOTALPAGES%, CURPAGE%, LASTKEY%, DL%, LIN%, LP%, DLI%„    CASE UPKEY, PGUP                    'UP-ARROW OR PGUP PRESSED„      PAGEUP EXAMFILE$(), FILESIZE%, COUNT%, TOTALPAGES%, CURPAGE%, LASTKEY%, DL%, LIN%, LP%, DLI%„    CASE ESCAPE                         'CASE ESCAPE--->>>GOODBYE„      CLOSE (2)„      KILL "C:\DOS\DATA.DAT"„      KILL "C:\DOS\DOSDATA.DAT"„      SYSTEM„  END SELECT„LOOP„„'                         #####################„'                         ## FUNCTION GETKEY ##„'                         #####################„'„FUNCTION GETKEY%„  DO„    KEYIN$ = INKEY$„  LOOP UNTIL LEN(KEYIN$)„  GETKEY% = CVI(KEYIN$ + CHR$(0))„END FUNCTION„„'                        ########################„'                        ## SUB-ROUTINE PAGE.1 ##„'                        ########################„'„SUB PAGE.1 (EXAMFILE$(), COUNT%, CURPAGE%, DL%, LIN%, LP%, DLI%)„FOR N% = 1 TO LIN%„  COLOR 12: LOCATE DL% + N%, LP%„  PRINT EXAMFILE$(N%)„  COUNT% = COUNT% + 1„  PAGE% = PAGE% + 1„NEXT N%„END SUB„„'                       ##########################„'                       ## SUB-ROUTINE PAGEDOWN ##„'                       ##########################„'„SUB PAGEDOWN (EXAMFILE$(), FILESIZE%, COUNT%, TOTALPAGES%, CURPAGE%, LASTKEY%, DL%, LIN%, LP%, DLI%)„IF CURPAGE% < TOTALPAGES% THEN„  IF LASTKEY% = 1 THEN COUNT% = COUNT% + LIN%„  CLS : COLOR 12„  CURPAGE% = CURPAGE% + 1„  FOR F% = 1 + COUNT% TO COUNT% + LIN%„    SCREEN.GRAPHICS CURPAGE%, TOTALPAGES%, FILESIZE%, DL%, LIN%, LP%, DLI%„    LOCATE DL% + (F% - COUNT%), LP%: PRINT EXAMFILE$(F%)„  NEXT F%„  LASTKEY% = 0„  COUNT% = COUNT% + LIN%„END IF„END SUB„„'                        ########################„'                        ## SUB-ROUTINE PAGEUP ##„'                        ########################„'„SUB PAGEUP (EXAMFILE$(), FILESIZE%, COUNT%, TOTALPAGES%, CURPAGE%, LASTKEY%, DL%, LIN%, LP%, DLI%)„IF CURPAGE% > 1 THEN„  CLS : COLOR 12„  CURPAGE% = CURPAGE% - 1„  IF LASTKEY% = 1 THEN COUNT% = COUNT% - LIN%„  IF LASTKEY% = 0 THEN COUNT% = COUNT% - (2 * LIN%): LASTKEY% = LASTKEY% + 1„  SCREEN.GRAPHICS CURPAGE%, TOTALPAGES%, FILESIZE%, DL%, LIN%, LP%, DLI%„  FOR F% = 1 + COUNT% TO COUNT% + LIN%„    LOCATE DL% + (F% - COUNT%), LP%: PRINT EXAMFILE$(F%)„  NEXT F%„END IF„END SUB„„'                    #################################„'                    ## SUB-ROUTINE SCREEN.GRAPHICS ##„'                    #################################„'„SUB SCREEN.GRAPHICS (CURPAGE%, TOTALPAGES%, FILESIZE%, DL%, LIN%, LP%, DLI%)„COLOR 3: LOCATE 2, 33: PRINT " PAGE "; CURPAGE%; "OF"; TOTALPAGES%„LINE (50, 36)-(580, 36), 12„LINE (50, 37)-(580, 37), 15„LINE (50, 38)-(580, 38), 7„LOCATE 27, 23: PRINT "<DOWN ARROW> OR <PGDN> TO PAGE DOWN"„LOCATE 28, 23: PRINT "  <UP ARROW> OR <PGUP> TO PAGE UP"„LINE (50, 406)-(580, 406), 12„LINE (50, 407)-(580, 407), 15„LINE (50, 408)-(580, 408), 7„COLOR 15:„LOCATE 12, 50: PRINT "TOTAL FILESIZE ="; FILESIZE%„LOCATE 13, 45: PRINT "TEXT STARTS ON LINE ="; DLI%„LOCATE 14, 47: PRINT "TEXT ENDS ON LINE ="; LIN% + DLI%„COLOR 12„END SUB„„Hauke Daempfling               FILE & DIRECTORY BOX           hcd@berlin.snafu.de            01/96 (00:00)          QB, QBasic, PDS        562  18977    DIRBOX.BAS  DECLARE FUNCTION DirBox$ (ArgD$, ArgF$)„'          DirBox 1.0b„'       By Hauke Daempfling„'Jan 1996„„' This program displays a file box in which the„' user can select a file (duh). It's just the 'beta „' version' right now. In other words, it works but still„' I don't have all the bugs out.„„' It works pretty simple: it SHELLS the DOS dir command„' so it puts the plain list of files or directories into„' a file. Then the file is taken and split up into an array„' wherever there is CHR$(13). Then the user can select a file„' from the array (list).„' NOTE: The program assumes that you are using screen page 0„' and it uses page 1. If you are using or not using these pages„' you can change the values in the first line of DirBox.„„'I would appreciate it that if you fix any bugs in the program„'that you could EMail the changes to hcd@berlin.snafu.de. Thanks :)„„'here a litttle demo:„SCREEN 0„CLS„FOR x = 1 TO 80       'random background„  FOR y = 1 TO 25„   LOCATE y, x„   PRINT CHR$(INT(RND * 26) + 65);„  NEXT y„NEXT x„a$ = DirBox$("C:\", "*.*") 'start DirBox„LOCATE 1, 1„COLOR 4, 7„IF a$ = "" THEN PRINT "You aborted." ELSE PRINT "You selected: "; a$„a$ = DirBox$("C:\", "*.EXE")„COLOR 4, 7„IF a$ = "" THEN PRINT "You aborted." ELSE PRINT "Starting: "; a$: SHELL a$„COLOR 4, 7„PRINT "-*-*- END OF DEMO -*-*-"„„DEFINT A-Z„FUNCTION DirBox$ (ArgD$, ArgF$)„OldS = 0                                        'OldS = your prog.'s page„AcS = 1                                         'AcS  = DirBox's page„PCOPY OldS, AcS: SCREEN 0, , AcS, AcS           'switch to page AcS„LOCATE , , 0                                    'hide the cursor„x = 10: y = 3                                   'X/Y coordinates of the box„CurFile = 0: CurDir = 0: CurDrive = 0„IF NOT RIGHT$(ArgD$, 1) = "\" THEN ArgD$ = ArgD$ + "\"„DIM Dir$(0)                                     'initalize the Dir$ and File$„DIM File$(0)                                    ' arrays„„GOSUB DrawBackGr                                'draw the box„LOCATE y, x + 19: COLOR 20, 9: PRINT "   Wait...   "; 'wait message„GOSUB GetDirs                                   'get the files and dirs.„GOSUB GetFiles„GOSUB DrawFileBox                               'draw the File+Dir boxes„GOSUB DrawDirBox„CurFile = 0: CurDir = -1: CurDrive = -1„GOSUB DrawDirBox„GOSUB DrawFileBox„GOSUB DCL                                       'DCL=DriveCurrentLocation„                                                '  (whatever)„COLOR 0, 7: LOCATE y, x + 18: PRINT "π"; : COLOR 15, 9„PRINT " Select Files "; : COLOR 0, 7: PRINT "Ã"; 'redraw the title„DO„ Cmd$ = UCASE$(INKEY$)                          'get the keys pressed„ IF Cmd$ = CHR$(0) + "P" THEN                   'up arrow„   IF CurFile > -1 THEN„     IF CurFile < Allfiles THEN CurFile = CurFile + 1„     CurDir = -1: CurDrive = -1„     GOSUB DrawFileBox„   END IF„   IF CurDir > -1 THEN„     IF CurDir < Alldirs THEN CurDir = CurDir + 1„     CurFile = -1: CurDrive = -1„     GOSUB DrawDirBox„   END IF„ ELSEIF Cmd$ = CHR$(0) + "H" THEN               'down arrow„   IF CurFile > -1 THEN„     IF CurFile > 0 THEN CurFile = CurFile - 1„     CurDir = -1: CurDrive = -1„     GOSUB DrawFileBox„   END IF„   IF CurDir > -1 THEN„     IF CurDir > 0 THEN CurDir = CurDir - 1„     CurFile = -1: CurDrive = -1„     GOSUB DrawDirBox„   END IF„ ELSEIF Cmd$ = CHR$(13) THEN                    'enter„   IF CurFile > -1 THEN„     BtnSel = 1„     GOSUB DrawBtns„     LOCATE y + 2, x + 40„     COLOR 7, 7„     PRINT " ";„     COLOR 15, 2„     PRINT "   OK   ";„     LOCATE y + 3, x + 41„     COLOR 7, 7„     PRINT "        "„     GOSUB Pause„     DirBox$ = ArgD$ + File$(CurFile)„     ERASE Dir$, File$„     SCREEN 0, , OldS, OldS„     EXIT FUNCTION„   END IF„   IF CurDir > -1 THEN                          'change directories„     LOCATE y, x + 19: COLOR 20, 9: PRINT "   Wait...   ";„     IF Dir$(CurDir) = ".." THEN„       ArgD$ = LEFT$(ArgD$, LEN(ArgD$) - 1)„       FOR a = LEN(ArgD$) TO 1 STEP -1„         IF RIGHT$(ArgD$, 1) <> "\" THEN        'this is all I could come„           ArgD$ = LEFT$(ArgD$, LEN(ArgD$) - 1) ' up with for going down„         ELSE                                   ' one directory... delete„           EXIT FOR                             ' all characters until the„         END IF                                 ' next "\"„       NEXT a„     ELSE„       ArgD$ = ArgD$ + Dir$(CurDir) + "\"„     END IF„     GOSUB GetDirs                              'get files+dirs from new„     GOSUB GetFiles                             ' directory„     CurFile = 0: CurDir = 0: CurDrive = 0„     DinView = 0„     FinView = 0„     GOSUB DrawBackGr                           'redraw everything„     GOSUB DrawFileBox„     GOSUB DrawDirBox„     CurFile = -1: CurDir = 0: CurDrive = -1„     GOSUB DrawFileBox„     GOSUB DrawDirBox„     COLOR 0, 7: LOCATE y, x + 18: PRINT "π"; : COLOR 15, 9„     PRINT " Select Files "; : COLOR 0, 7: PRINT "Ã";„     GOSUB DCL„   END IF„   IF CurDrive > -1 THEN                        'this is probably„     LOCATE y + 11, x + 3                       ' where you'll find„     COLOR 15, 9                                ' some bugs„     PRINT SPACE$(32)„     LOCATE y + 11, x + 3„     PRINT ""; : INPUT "", x$                   'input a new drive/directory„     LOCATE y, x + 19: COLOR 20, 9: PRINT "   Wait...   ";„     CDr$ = LEFT$(x$, INSTR(x$, "\"))„     IF LEN(x$) > 3 THEN CDi$ = RIGHT$(x$, INSTR(x$, "\"))„     IF INSTR(CDr$, ":\") = 0 THEN GOTO nodo    'if no drive is given„     ArgD$ = CDr$ + CDi$„     IF NOT RIGHT$(ArgD$, 1) = "\" THEN ArgD$ = ArgD$ + "\"„     GOSUB GetDirs„     GOSUB GetFiles„     CurFile = 0: CurDir = 0: CurDrive = 0„     DinView = 0„     FinView = 0„     GOSUB DrawBackGr„     GOSUB DrawFileBox„     GOSUB DrawDirBox„     CurFile = -1: CurDir = -1: CurDrive = 0„     GOSUB DrawFileBox„     GOSUB DrawDirBox„nodo:„     COLOR 0, 7: LOCATE y, x + 18: PRINT "π"; : COLOR 15, 9„     PRINT " Select Files "; : COLOR 0, 7: PRINT "Ã";„     GOSUB DCL„   END IF„ ELSEIF Cmd$ = CHR$(0) + "M" THEN               'right key: switch boxes„   IF CurFile > -1 THEN„       CurFile = -1: CurDir = DinView: CurDrive = -1„   ELSEIF CurDir > -1 THEN„       CurFile = -1: CurDir = -1: CurDrive = 0„   ELSEIF CurDrive > -1 THEN„       CurFile = FinView: CurDir = -1: CurDrive = -1„   END IF„   GOSUB DrawFileBox„   GOSUB DrawDirBox„   GOSUB DCL„ ELSEIF Cmd$ = CHR$(0) + "K" THEN               'left key: switch boxes„   IF CurFile > -1 THEN„       CurFile = -1: CurDir = -1: CurDrive = 0„   ELSEIF CurDir > -1 THEN„       CurFile = FinView: CurDir = -1: CurDrive = -1„   ELSEIF CurDrive > -1 THEN„       CurFile = -1: CurDir = DinView: CurDrive = -1„   END IF„   GOSUB DrawFileBox„   GOSUB DrawDirBox„   GOSUB DCL„ ELSEIF Cmd$ = CHR$(27) THEN                    'ESC pressed (abort)„   BtnSel = 2„   GOSUB DrawBtns„   LOCATE y + 4, x + 40„   COLOR 7, 7„   PRINT " ";„   COLOR 15, 2„   PRINT " Cancel ";„   LOCATE y + 5, x + 41„   COLOR 7, 7„   PRINT "        "„   GOSUB Pause„   DirBox$ = ""„   ERASE Dir$, File$„   SCREEN 0, , OldS, OldS„   EXIT FUNCTION„ ELSEIF Cmd$ = CHR$(9) THEN                     'TAB (switch to OK & Cancel)„  BtnSel = 1„  GOSUB DrawBtns„   DO„    xCmd$ = UCASE$(INKEY$)„    IF xCmd$ = CHR$(0) + "H" THEN BtnSel = 1: GOSUB DrawBtns„    IF xCmd$ = CHR$(0) + "P" THEN BtnSel = 2: GOSUB DrawBtns„    IF xCmd$ = CHR$(9) THEN EXIT DO„    IF xCmd$ = CHR$(27) THEN„      BtnSel = 2„      GOSUB DrawBtns„      LOCATE y + 4, x + 40„      COLOR 7, 7„      PRINT " ";„      COLOR 15, 2„      PRINT " Cancel ";„      LOCATE y + 5, x + 41„      COLOR 7, 7„      PRINT "        "„      GOSUB Pause„      DirBox$ = ""„      ERASE Dir$, File$„      SCREEN 0, , OldS, OldS„      EXIT FUNCTION„    END IF„    IF xCmd$ = CHR$(13) THEN„      IF BtnSel = 1 THEN„        LOCATE y + 2, x + 40„        COLOR 7, 7„        PRINT " ";„        COLOR 15, 2„        PRINT "   OK   ";„        LOCATE y + 3, x + 41„        COLOR 7, 7„        PRINT "        "„        GOSUB Pause„        DirBox$ = ArgD$ + File$(CurFile)„        ERASE Dir$, File$„        SCREEN 0, , OldS, OldS„        EXIT FUNCTION„      END IF„      IF BtnSel = 2 THEN„        LOCATE y + 4, x + 40„        COLOR 7, 7„        PRINT " ";„        COLOR 15, 2„        PRINT " Cancel ";„        LOCATE y + 5, x + 41„        COLOR 7, 7„        PRINT "        "„        GOSUB Pause„        DirBox$ = ""„        ERASE Dir$, File$„        SCREEN 0, , OldS, OldS„        EXIT FUNCTION„      END IF„    END IF„   LOOP„   BtnSel = 0„   GOSUB DrawBtns„ ELSE                                           'first letter of file/dir.„   IF CurFile > -1 THEN                         ' name„     f = 0„     FOR a = CurFile + 1 TO Allfiles„       IF UCASE$(LEFT$(File$(a), 1)) = Cmd$ THEN„         CurFile = a„         GOSUB DrawFileBox„         f = 1„         EXIT FOR„       END IF„     NEXT a„     IF f = 0 THEN„       FOR a = 0 TO Allfiles„         IF UCASE$(LEFT$(File$(a), 1)) = Cmd$ THEN„           CurFile = a„           GOSUB DrawFileBox„           f = 1„           EXIT FOR„         END IF„       NEXT a„     END IF„    END IF„   IF CurDir > -1 THEN„     f = 0„     FOR a = CurDir + 1 TO Alldirs„       IF UCASE$(LEFT$(Dir$(a), 1)) = Cmd$ THEN„         CurDir = a„         GOSUB DrawDirBox„         f = 1„         EXIT FOR„       END IF„     NEXT a„     IF f = 0 THEN„       FOR a = 0 TO Alldirs„         IF UCASE$(LEFT$(Dir$(a), 1)) = Cmd$ THEN„           CurDir = a„           GOSUB DrawDirBox„           f = 1„           EXIT FOR„         END IF„       NEXT a„     END IF„    END IF„ END IF„„LOOP„ERASE Dir$, File$„SCREEN 0, , OldS, OldS„EXIT FUNCTION„           '-------------------„DrawBackGr:                                     'draw the actual box„  COLOR 0, 7: LOCATE y, x: PRINT "…"; STRING$(52, "Õ"); "ª";„  FOR a = y + 1 TO y + 11„    LOCATE a, x„    PRINT "∫"; STRING$(52, " "); "∫";„  NEXT a„  LOCATE y + 12, x„  PRINT "»"; STRING$(52, "Õ"); "º";„  LOCATE y, x + 18: PRINT "π"; : COLOR 15, 9„  PRINT " Select Files "; : COLOR 0, 7: PRINT "Ã";„„  LOCATE y + 1, x + 6: COLOR 0, 7: PRINT " Files "; 'file box„  COLOR 15, 7: LOCATE y + 2, x + 2: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ";„  COLOR 0, 7: PRINT "ø";„  FOR a = y + 3 TO y + 9„    LOCATE a, x + 2„    COLOR 15, 7: PRINT "≥              "; : COLOR 0, 7: PRINT "≥";„  NEXT a„  LOCATE y + 10, x + 2„  COLOR 15, 7: PRINT "¿"; : COLOR 0, 7: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ";„ „  LOCATE y + 1, x + 21: COLOR 0, 7: PRINT " Directories "; 'directories box„  COLOR 15, 7: LOCATE y + 2, x + 20: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ";„  COLOR 0, 7: PRINT "ø";„  FOR a = y + 3 TO y + 9„    LOCATE a, x + 20„    COLOR 15, 7: PRINT "≥              "; : COLOR 0, 7: PRINT "≥";„  NEXT a„  LOCATE y + 10, x + 20„  COLOR 15, 7: PRINT "¿"; : COLOR 0, 7: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ";„  GOSUB DrawBtns„  LOCATE y + 7, x + 42: COLOR 15, 7: PRINT "DirBox"„  COLOR 8, 7„  LOCATE y + 9, x + 41: PRINT "By Hauke"„  LOCATE y + 10, x + 40: PRINT "Daempfling"„RETURN„„DrawBtns:„  LOCATE y + 2, x + 40„  IF BtnSel = 1 THEN COLOR 15, 2 ELSE COLOR 0, 2 'OK/Cancel buttons„  PRINT "   OK   ";„  COLOR 0, 7„  PRINT "‹";„  LOCATE y + 3, x + 41„  PRINT "ﬂﬂﬂﬂﬂﬂﬂﬂ";„„  LOCATE y + 4, x + 40„  IF BtnSel = 2 THEN COLOR 15, 2 ELSE COLOR 0, 2„  PRINT " Cancel ";„  COLOR 0, 7„  PRINT "‹";„  LOCATE y + 5, x + 41„  PRINT "ﬂﬂﬂﬂﬂﬂﬂﬂ";„RETURN„         '--------------------------„GetFiles:                                       'get the files„  LOCATE y + 13, 1: PRINT "";                   'in case of error messages„  DosCmd$ = "DIR " + ArgD$ + ArgF$ + " /B /A-D /ON > C:\DIR.TMP" 'DIR command„  SHELL DosCmd$                                 'shell to DOS„  OPEN "C:\DIR.TMP" FOR INPUT AS #1„  InFile$ = INPUT$(LOF(1), #1)                     'read the file„  CLOSE #1„  KILL "C:\DIR.TMP"„  Allfiles = -1                                 'number of files in list„  NewLine$ = CHR$(13)                           'the new line character„  FOR a = 1 TO LEN(InFile$)                     'read the number of lines„    IF MID$(InFile$, a, 1) = NewLine$ THEN Allfiles = Allfiles + 1„  NEXT a„  IF Allfiles = -1 THEN RETURN                  'if the file is empty„„  REDIM File$(Allfiles)                         'dimesion the file array„  Sloc = 1                                      'location pointer in InFile$„  File$(0) = LEFT$(InFile$, INSTR(InFile$, NewLine$) - 1) 'get first filename„  FOR a = 1 TO Allfiles                         'split the filenames„    Sloc = INSTR(Sloc + 2, InFile$, NewLine$)   'move the pointer„    IF Sloc = 0 OR INSTR(MID$(InFile$, Sloc + 2), NewLine$) = 0 THEN EXIT FOR„    File$(a) = LEFT$(MID$(InFile$, Sloc + 2), INSTR(MID$(InFile$, Sloc + 2), NewLine$) - 1)„  NEXT a„  FOR a = 0 TO Allfiles                         'check for empty strings„    IF File$(a) = "" THEN„      FOR b = a TO Allfiles - 1„       File$(b) = File$(b + 1)„      NEXT b„      Allfiles = Allfiles - 1„    END IF„  NEXT a„  InFile$ = ""„RETURN„             '---------------------------„DrawFileBox:                                    'draw the file box„  IF CurFile = -1 THEN COLOR 0, 7 ELSE COLOR 15, 9„  LOCATE y + 1, x + 6: PRINT " Files ";„  IF CurFile = -1 OR Allfiles = -1 THEN RETURN  'if the file box isn't active„  LOCATE y + 3, x + 17: COLOR 7, 9: PRINT "";  ' don't redraw it„  LOCATE y + 9, x + 17: COLOR 7, 9: PRINT "";„  COLOR 1, 7„  FOR a = y + 4 TO y + 8„    LOCATE a, x + 17: PRINT "∞";„  NEXT a„  IF Allfiles > 6 THEN„    CurSel = ((CurFile / Allfiles) * 100) \ 25  'location of scroll bar„    IF CurFile > FinView + 6 THEN FinView = CurFile - 6 'FinView is the first„    IF CurFile < FinView THEN FinView = CurFile         ' file in the box„    d = 0                                               ' (not CurFile)„    FOR a = FinView TO FinView + 6„      LOCATE y + 3 + d, x + 3„      IF a = CurFile THEN COLOR 15, 9 ELSE COLOR 0, 7   'if the file is sel.„      IF LEN(File$(a)) > 12 THEN                        'if the filename is„        PRINT " "; LEFT$(File$(a), 9); "..."            ' too long to be dis-„      ELSE                                              ' played fully„        PRINT " "; File$(a); SPACE$(12 - LEN(File$(a))); ' (Win95)„      END IF„      d = d + 1„    NEXT a„  ELSE„    CurSel = 0                                          'scroll bar„    FOR a = 0 TO Allfiles                               'same as above„      LOCATE y + 3 + a, x + 3„      IF a = CurFile THEN COLOR 15, 9 ELSE COLOR 0, 7„      IF LEN(File$(a)) > 12 THEN„        PRINT " "; LEFT$(File$(a), 9); "..."„      ELSE„        PRINT " "; File$(a); SPACE$(12 - LEN(File$(a)));„      END IF„    NEXT a„    COLOR 0, 7„    FOR a = Allfiles + 1 TO 6 - Allfiles                'print spaces where„      LOCATE y + 3 + a, x + 3                           ' there aren't any„      PRINT "            ";                             ' filenames„    NEXT a„  END IF„  LOCATE y + 4 + CurSel, x + 17: COLOR 7, 1: PRINT "∞"; ' scroll bar„RETURN„          '---------------------„GetDirs:                                                'practically the same„  LOCATE y + 13, 1: PRINT "";                           ' as GetFiles„  DosCmd$ = "DIR " + ArgD$ + "*.* /B /AD /ON > C:\DIR.TMP"„  SHELL DosCmd$„  OPEN "C:\DIR.TMP" FOR INPUT AS #1„  InFile$ = INPUT$(LOF(1), #1)„  CLOSE #1„  KILL "C:\DIR.TMP"„  NewLine$ = CHR$(13)„  Alldirs = -1„  FOR a = 1 TO LEN(InFile$)„    IF MID$(InFile$, a, 1) = NewLine$ THEN Alldirs = Alldirs + 1„  NEXT a„  IF Alldirs = -1 AND LEN(ArgD$) = 3 THEN RETURN„ „  REDIM Dir$(Alldirs + 1)„  IF Alldirs = -1 THEN GOTO SkipFill:„  Sloc = 1„  Dir$(0) = LEFT$(InFile$, INSTR(InFile$, NewLine$) - 1)„  FOR a = 1 TO Alldirs„    Sloc = INSTR(Sloc + 2, InFile$, NewLine$)„    IF Sloc = 0 OR INSTR(MID$(InFile$, Sloc + 2), NewLine$) = 0 THEN EXIT FOR„    Dir$(a) = LEFT$(MID$(InFile$, Sloc + 2), INSTR(MID$(InFile$, Sloc + 2), NewLine$) - 1)„  NEXT a„  FOR a = 0 TO Alldirs„    IF Dir$(a) = "" THEN„      FOR b = a TO Alldirs - 1„       Dir$(b) = Dir$(b + 1)„      NEXT b„      Alldirs = Alldirs - 1„    END IF„  NEXT a„SkipFill:„  IF LEN(ArgD$) > 3 THEN                                'add the .. directory„    Alldirs = Alldirs + 1                               ' if needed„    IF Alldirs > 0 THEN„      FOR a = Alldirs - 1 TO 0 STEP -1„        Dir$(a + 1) = Dir$(a)„      NEXT a„      Dir$(0) = ".."„    ELSE„      Dir$(0) = ".."„    END IF„  END IF„  InFile$ = ""„RETURN„             '---------------------------„DrawDirBox:                                             'again, the same as„  IF CurDir = -1 THEN COLOR 0, 7 ELSE COLOR 15, 9       ' DrawFileBox„  LOCATE y + 1, x + 21: PRINT " Directories ";„  IF CurDir = -1 OR Alldirs = -1 THEN RETURN„  LOCATE y + 3, x + 35: COLOR 7, 9: PRINT "";„  LOCATE y + 9, x + 35: COLOR 7, 9: PRINT "";„  COLOR 1, 7„  FOR a = y + 4 TO y + 8„    LOCATE a, x + 35: PRINT "∞";„  NEXT a„  IF Alldirs > 6 THEN„    CurSel = ((CurDir / Alldirs) * 100) \ 25„    IF CurDir > DinView + 6 THEN DinView = CurDir - 6„    IF CurDir < DinView THEN DinView = CurDir„    d = 0„    FOR a = DinView TO DinView + 6„      LOCATE y + 3 + d, x + 21„      IF a = CurDir THEN COLOR 15, 9 ELSE COLOR 0, 7„      IF LEN(Dir$(a)) > 12 THEN„        PRINT " "; LEFT$(Dir$(a), 9); "..."„      ELSE„        PRINT " "; Dir$(a); SPACE$(12 - LEN(Dir$(a)));„      END IF„      d = d + 1„    NEXT a„    IF CurDir + 6 > Alldirs THEN„      COLOR 0, 7„      FOR a = d TO 6„       LOCATE y + 3 + a, x + 21„       PRINT "              ";„      NEXT a„    END IF„  ELSE„    CurSel = 0„    FOR a = 0 TO Alldirs„      LOCATE y + 3 + a, x + 21„      IF a = CurDir THEN COLOR 15, 9 ELSE COLOR 0, 7„      IF LEN(Dir$(a)) > 12 THEN„        PRINT " "; LEFT$(Dir$(a), 9); "..."„      ELSE„        PRINT " "; Dir$(a); SPACE$(12 - LEN(Dir$(a)));„      END IF„    NEXT a„    COLOR 0, 7„    FOR a = Alldirs + 1 TO 6 - Alldirs„      LOCATE y + 3 + a, x + 21„      PRINT "            ";„    NEXT a„  END IF„  LOCATE y + 4 + CurSel, x + 35: COLOR 7, 1: PRINT "∞";„RETURN„          '---------------------„DCL:                                                    'draw the current dir„LOCATE y + 11, x + 3„IF CurDrive = -1 THEN COLOR 0, 7 ELSE COLOR 15, 9„IF LEN(ArgD$) > 32 THEN„  PRINT LEFT$(ArgD$, 32)„ELSE„  PRINT ArgD$; SPACE$(32 - LEN(ArgD$))„END IF„RETURN„          '---------------------------„Pause:                                                  'simple pause routine„ tim& = TIMER + .1„ DO: LOOP UNTIL TIMER >= tim&„RETURN„END FUNCTION„„Mark K. Kim                    GET DIRECTORY SCAN             MarkKKim@aol.com               02-07-96 (20:00)       QB, QBasic, PDS        378  16715    BDIR10A.BAS 'BASDir version 1.0a -- directory scan„'Copyright (c)1995-6 Mark K. Kim„'E-mail: MarkKKim@aol.com„'http://users.aol.com/markkkim/„'* Freely distributed.  May be used in other programs with proper notice of„'  credit.„'* This program is provided "as-is".„'* Not compatible with PowerBASIC.„'* In QuickBASIC 4.5, run QB.EXE with /L option. If including QB.BI, then„'  replace the ABSOLUTE SUB declaration statement in QB.BI with the ABSOLUTE„'  SUB declaration within this program. Make other proper revisions.„'* CREDIT: Ralf Brown's interrupt list was used to get interrupt for the„'  function.  Microsoft DOS's Debug was used to convert Assembly code to„'  machine code.  Microsoft is a Registered Trademark of Microsoft Corp.„'  Thanks to beta testers, rt911@aol.com and wildgamer@aol.com„'Read the header of each function to find out the usage of those functions.„'These functions are designed to work with most other routines as it does„'not interfere with any other routines. It is especially designed to work„'with other functions in this BASxx series.„„DECLARE SUB absolute (var1%, var2%, var3%, var4%, var5%, var6%, offset%)„'== BEGIN HEADER ==„TYPE FileStruct„  attrib AS INTEGER„  filedate AS STRING * 10„  filetime AS STRING * 8„  filesize AS DOUBLE„END TYPE„CONST F.NOR = &H200  'constant for "normal" files (*files* displayed with DIR)„CONST F.NON = &H100  'constant for files without any attribute„CONST F.ARC = &H20   'constant for archive file attribute„CONST F.DIR = &H10   'constant for directory file attribute„CONST F.VOL = &H8    'constant for volume file attribute„CONST F.SYS = &H4    'constant for system file attribute„CONST F.HID = &H2    'constant for hidden file attribute (may return directory)„CONST F.RDO = &H1    'constant for read-only file attribute„CONST F.ANY = &H0    'constant for any of the above„DECLARE SUB dir.init (path$, attrib%)         'call first to initialize„DECLARE FUNCTION dir.find$ ()                 'call next to get filenames„DECLARE SUB dir.fileinfo (file AS FileStruct) 'call to get file information„'== END HEADER ==„„'== START ==„CLS„INPUT "drive and/or directory to scan (ie - C:\DOS\): ", dir$„IF dir$ = "" THEN dir$ = "."„IF RIGHT$(dir$, 1) <> "\" THEN dir$ = dir$ + "\"„dir$ = dir$ + "*.*"„dir.init dir$, F.ANY„DIM info AS FileStruct„DO„  i% = i% + 1„  filename$ = dir.find$„  dir.fileinfo info„  IF filename$ <> "" THEN„    PRINT USING "\          \"; filename$;„    PRINT USING " #########"; info.filesize;„    PRINT "   " + info.filedate$ + " " + info.filetime$;„    PRINT " ";„  ELSE EXIT DO„  END IF„  IF info.attrib AND F.ARC THEN PRINT "A";„  IF info.attrib AND F.DIR THEN PRINT "D";„  IF info.attrib AND F.VOL THEN PRINT "V";„  IF info.attrib AND F.SYS THEN PRINT "S";„  IF info.attrib AND F.HID THEN PRINT "H";„  IF info.attrib AND F.RDO THEN PRINT "R";„  PRINT„LOOP„„'Finds the detailed information about the most recently obtained file by„'the <dir.find$> function.„'INPUT & RETURN:„'* file is a FileTruct TYPE to store the information in, where the following„'  are returned:„'  * file.attrib holds the attribute of the file, or the error code if any„'    error has occured during the last <dir.find$> FUNCTION operation, where„'    the error codes are:„'    * &h02 = file not found„'    * &h03 = path not found„'    * &h12 = no more files„'    Whether an error has occured or not can be determined by checking the„'    name of the file returned -- if the name has no length (""), then an„'    error has occured (or no more files were to be found.)„'  * file.filedate$ holds the date of the file creation/revision.„'  * file.filetime$ holds the time of the file creation/revision.„'  * file.filesize$ holds the size of the file.„'    Size of a file may be a negative number of the file is several hundred„'    megabytes long, but a chance of that happening is miniscuously small.„'EXAMPLE:„'  'Make a place to store detailed information about the file.„'  DIM fileinfo AS FileStruct„'  'initialize and set pattern for the file search„'  dir.init "C:\DOS\*.*", F.ANY„'  'get the file name and store information in <fileinfo> SUB„'  filename$ = dir.find$„'  'get the detailed information from <dir.fileinfo> SUB„'  dir.fileinfo fileinfo„'  'print the information to the screen„'  PRINT "File name: "; dir.find$„'  PRINT "File date: "; fileinfo.filedate$„'  PRINT "File time: "; fileinfo.filetime$„'  PRINT "File size: "; fileinfo.filesize„'  PRINT "File attributes:"„'  IF fileinfo.attrib AND F.DIR THEN PRINT "Directory"„'  IF fileinfo.attrib AND F.HID THEN PRINT "Hidden"„'  IF fileinfo.attrib AND F.VOL THEN PRINT "Volume Label"„'  IF fileinfo.attrib AND F.ARC THEN PRINT "Archive"„'  IF fileinfo.attrib AND F.SYS THEN PRINT "System"„'  IF fileinfo.attrib AND F.RDO THEN PRINT "Read-Only"„'  END„SUB dir.fileinfo (file AS FileStruct)„ „  '== SHARED VARIABLE ==„  SHARED dirfileinfo AS FileStruct„„  file = dirfileinfo„„END SUB„„'Scans for files in a directory„'RETURN:„'* Name of the file/directory is returned.„'* A string with nothing in it ("") will be returned upon error. Error codes„'  are obtainable through <dir.fileinfo> SUB's attribute.„'* Returned error codes (returned by <dir.fileinfo> SUB):„'  * &h02 = file not found„'  * &h03 = path not found„'  * &h12 = no more files„'COMMENT:„'* If dir.find$ is called again, the name of the next file is returned. The„'  user can look for files in a different directory or attributes can restart„'  the search by calling on <dir.init> function again.„'* Details of the found file can be obtained by calling on <dir.fileinfo> SUB„'  right after finding the file.„'EXAMPLE:„'* There is an example on top of <dir.fileinfo> in commented form.„FUNCTION dir.find$„ „  '== SHARED VARIABLES ==„  'general„  SHARED dirfileinfo AS FileStruct„  SHARED dircount AS INTEGER„  'control variables„  SHARED dir.attrib AS INTEGER„  SHARED dir.path AS STRING„  'machine language routines„  SHARED DTAseg AS INTEGER, DTAoff AS INTEGER„  SHARED findfirst$„  SHARED findnext$„„  IF dircount = -1 THEN„    pathseg% = VARSEG(dir.path)„    pathoff% = SADD(dir.path)„    asmseg% = VARSEG(findfirst$)„    asmoff% = SADD(findfirst$)„    DEF SEG = asmseg%„    CALL absolute(dummy%, dummy%, dummy%, pathseg%, pathoff%, &HFF, asmoff%)„    DEF SEG„    dircount = 0„  ELSEIF dircount = 0 THEN pathseg% = 1 'simulate error„  ELSE„    pathseg% = VARSEG(dir.path)„    pathoff% = SADD(dir.path)„    asmseg% = VARSEG(findnext$)„    asmoff% = SADD(findnext$)„    DEF SEG = asmseg%„    CALL absolute(dummy%, dummy%, dummy%, dummy%, pathseg%, pathoff%, asmoff%)„    DEF SEG„  END IF„  'check for errors„  IF pathseg% THEN  'error existance is returned through pathseg%„    dir.find$ = ""„    dirfileinfo.attrib = pathoff% 'error code is stored in pathoff%„    dirfileinfo.filedate = "00-00-0000"„    dirfileinfo.filetime = "00:00:00"„  ELSE„„    DO„      'get attribute of the file found„      DEF SEG = DTAseg„      attrib% = PEEK(DTAoff + &H15)„      DEF SEG„      'exit conditions:„      IF ((dir.attrib AND &H200) = &H200) AND ((attrib% AND &H21) = (attrib% AND &H3F)) THEN EXIT DO„      IF ((dir.attrib AND &H100) = &H100) AND ((attrib% AND &H3F) = 0) THEN EXIT DO„      IF (dir.attrib AND &H3F) AND (attrib% AND &H3F) THEN EXIT DO„      IF (dir.attrib AND &H3F) = 0 THEN EXIT DO„      'find next until right attributes are found„      pathseg% = VARSEG(dir.path)„      pathoff% = SADD(dir.path)„      asmseg% = VARSEG(findnext$)„      asmoff% = SADD(findnext$)„      DEF SEG = asmseg%„      CALL absolute(dummy%, dummy%, dummy%, dummy%, pathseg%, pathoff%, asmoff%)„      DEF SEG„      IF pathseg% THEN  'error existance is returned through pathseg%„        dir.find$ = ""„        dirfileinfo.attrib = pathoff% 'error code is stored in pathoff%„        dirfileinfo.filedate = "00-00-000"„        dirfileinfo.filetime = "00:00:00"„        EXIT FUNCTION„      END IF„    LOOP„„    'get name of the file found„    filename$ = SPACE$(13)„    FOR i% = 0 TO 12„      DEF SEG = DTAseg„      ch% = PEEK(DTAoff + &H1E + i%)„      DEF SEG = VARSEG(filename$)„      POKE SADD(filename$) + i%, ch%„      DEF SEG„    NEXT i%„    'find location of CHR$(0) and get only up to that point„    dir.find$ = LEFT$(filename$, INSTR(filename$, CHR$(0)))„„    'get attribute of the file found„    DEF SEG = DTAseg„    dirfileinfo.attrib = PEEK(DTAoff + &H15)„    DEF SEG„„    'get the file's date„    DEF SEG = DTAseg„    filedate& = (PEEK(DTAoff + &H19) AND &H7F) * &H100 + PEEK(DTAoff + &H18)„     IF (PEEK(DTAoff + &H19) AND &H80) THEN filedate& = filedate& OR &H8000„    fileyear$ = LTRIM$(STR$((filedate& AND &HFE00) / &H200 + 1980))„    filemonth$ = LTRIM$(STR$((filedate& AND &H1E0) / &H20))„     IF LEN(filemonth$) < 2 THEN filemonth$ = "0" + filemonth$  'align„    fileday$ = LTRIM$(STR$(filedate& AND &H1F))„     IF LEN(fileday$) < 2 THEN fileday$ = "0" + fileday$        'align„    DEF SEG„    dirfileinfo.filedate$ = filemonth$ + "-" + fileday$ + "-" + fileyear$„„    'get the file's time„    DEF SEG = DTAseg„    filetime& = (PEEK(DTAoff + &H17) AND &H7F) * &H100 + PEEK(DTAoff + &H16)„     IF (PEEK(DTAoff + &H17) AND &H80) THEN filetime& = filetime& OR &H8000„    filehour& = (filetime& AND &H7800) / &H800„     IF (filetime& AND &H8000) THEN filehour& = filehour& OR &H10„    filehour$ = LTRIM$(STR$(filehour&))„     IF LEN(filehour$) < 2 THEN filehour$ = "0" + filehour$     'align„    filemin$ = LTRIM$(STR$((filetime& AND &H7E0) / &H20))„     IF LEN(filemin$) < 2 THEN filemin$ = "0" + filemin$        'align„    filesec$ = LTRIM$(STR$((filetime& AND &H1F) * 2))„     IF LEN(filesec$) < 2 THEN filesec$ = "0" + filesec$        'align„    DEF SEG„    dirfileinfo.filetime$ = filehour$ + ":" + filemin$ + ":" + filesec$„„    'get filesize„    DEF SEG = DTAseg„    filesize& = (PEEK(DTAoff + &H1D) AND &H7F) * &H1000000„    filesize& = filesize& + PEEK(DTAoff + &H1C) * &H10000„    filesize& = filesize& + PEEK(DTAoff + &H1B) * &H100&„    filesize& = filesize& + PEEK(DTAoff + &H1A) * &H1„    IF (PEEK(DTAoff + &H1D) AND &H80) THEN filesize& = filesize& OR &H8000„    dirfileinfo.filesize = filesize&„    DEF SEG„  END IF„„  dircount = dircount + 1„END FUNCTION„„'Initializes the "dir" family functions (dir.init, dir.find$, dir.fileinfo)„'COMMENT:„'* This function is also used to "reset" the search "patterns" used by„'  <dir.find$>.„'INPUT:„'* path.o$ is the file parameter to scan for. Wildcards okay.„'* attrib.o% is the attribute to look for, where:„'  * &h200 is for "normal" files that are displayed from DOS by simple "DIR"„'    command. This call is handled through the function.„'  * &h100 is for files without any attributes. This call is also handled„'    through the function.„'  * &h20 is for archive files. This is handled by DOS (sort of).„'  * &h10 if for directories. This is also handled by DOS (once again, sort„'    of).„'  * &h8 is for file that stands for the volume label. This could be used on„'    the root directory of each drive to find out the name of the drive, but„'    the information may not always be accurate in that there is a second„'    copy of volume label in the boot sector which is the "real thing". The„'    file with the volume attribute is sort of like "shadow" of the real„'    thing. However, any major or proper program will modify both volume„'    labels.„'  * &h4 is for files with system attribute. Handled by DOS. System files„'    also appear to be hidden.„'  * &h2 is for files with hidden attribute. Handled by DOS.„'  * &h1 is for read-only files. Handled by DOS.„'  * &h0 is for any of the above files. Handled by the function.„'  Combination of these attributes can be made (ie - &h06 for hidden system„'    files.)„'  When a file name is returned through <dir.find$> function, file with ANY„'    of the above specs will be returned. For instance, if the user specifies„'    a hidden file, a file with hidden attribute AND any other ones will be„'    returned. (That's why I made the "normal" attribute)„'EXAMPLE:„'* There is an example on top of <dir.fileinfo> in commented form.„SUB dir.init (path.o$, attrib.o%)„„  '== SHARED VARIABLES ==„  'general„  SHARED dirfileinfo AS FileStruct„  SHARED dircount AS INTEGER„  'control variables„  SHARED dir.attrib AS INTEGER„  SHARED dir.path AS STRING„  'machine language routines„  SHARED DTAseg AS INTEGER, DTAoff AS INTEGER„  SHARED findfirst$„  SHARED findnext$„„  '== INITIALIZATION ==„  dircount = -1„  dir.attrib = attrib.o%„  dir.path = path.o$ + CHR$(0)„„  '== get DTA address ==„  'initialize machine language code to get DTA address„  asm$ = ""„  asm$ = asm$ + CHR$(&H55)                           'push bp          DTA„  asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)              'mov bp, sp       DTA„  asm$ = asm$ + CHR$(&HB4) + CHR$(&H2F)              'mov ah, 2f       DTA„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)              'int 21           DTA„  asm$ = asm$ + CHR$(&H89) + CHR$(&HD8)              'mov ax, bx       DTA„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx, [bp+08]  DTA„  asm$ = asm$ + CHR$(&H8C) + CHR$(&H7)               'mov [bx], es     DTA„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx, [bp+06]  DTA„  asm$ = asm$ + CHR$(&H89) + CHR$(&H7)               'mov [bx], ax     DTA„  asm$ = asm$ + CHR$(&H5D)                           'pop bp           DTA„  asm$ = asm$ + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)   'retf 0004        DTA„  'get segment and offsets„  asmseg% = VARSEG(asm$)„  asmoff% = SADD(asm$)„  'execute„  DEF SEG = asmseg%„  CALL absolute(dummy%, dummy%, dummy%, dummy%, DTAseg, DTAoff, asmoff%)„  DEF SEG„„  '== FIND FIRST ==„  'initialize machine language code„  findfirst$ = ""„  findfirst$ = findfirst$ + CHR$(&H55)                           'push bp          F1st„  findfirst$ = findfirst$ + CHR$(&H89) + CHR$(&HE5)              'mov bp, sp       F1st„  findfirst$ = findfirst$ + CHR$(&HB4) + CHR$(&H4E)              'mov ah, 4e       F1st„  findfirst$ = findfirst$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)  'mov bx, [bp+0a]  F1st„  findfirst$ = findfirst$ + CHR$(&H8E) + CHR$(&H1F)              'mov ds, [bx]     F1st„  findfirst$ = findfirst$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx, [bp+08]  F1st„  findfirst$ = findfirst$ + CHR$(&H8B) + CHR$(&H17)              'mov dx, [bx]     F1st„  findfirst$ = findfirst$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx, [bp+06]  F1st„  findfirst$ = findfirst$ + CHR$(&H8B) + CHR$(&HF)               'mov cx, [bx]     F1st„  findfirst$ = findfirst$ + CHR$(&HCD) + CHR$(&H21)              'int 21           F1st„  findfirst$ = findfirst$ + CHR$(&HB9) + CHR$(&H0) + CHR$(&H0)   'mov cx, 0000     F1st„  findfirst$ = findfirst$ + CHR$(&H80) + CHR$(&HD1) + CHR$(&H0)  'adc cl, 00       F1st„  findfirst$ = findfirst$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)  'mov bx, [bp+0a]  F1st„  findfirst$ = findfirst$ + CHR$(&H89) + CHR$(&HF)               'mov [bx], cx     F1st„  findfirst$ = findfirst$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx, [bp+08]  F1st„  findfirst$ = findfirst$ + CHR$(&H89) + CHR$(&H7)               'mov [bx], ax     F1st„  findfirst$ = findfirst$ + CHR$(&H5D)                           'pop bp           F1st„  findfirst$ = findfirst$ + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)   'retf 0006        F1st„„  '== FIND NEXT ==„  'initialize machine language code„  findnext$ = ""„  findnext$ = findnext$ + CHR$(&H55)                           'push bp          FNxt„  findnext$ = findnext$ + CHR$(&H89) + CHR$(&HE5)              'mov bp, sp       FNxt„  findnext$ = findnext$ + CHR$(&HB4) + CHR$(&H4F)              'mov ah, 4f       FNxt„  findnext$ = findnext$ + CHR$(&HCD) + CHR$(&H21)              'int 21           FNxt„  findnext$ = findnext$ + CHR$(&HB9) + CHR$(&H0) + CHR$(&H0)   'mov cx, 0000     FNxt„  findnext$ = findnext$ + CHR$(&H80) + CHR$(&HD1) + CHR$(&H0)  'adc cl, 00       FNxt„  findnext$ = findnext$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx, [bp+08]  FNxt„  findnext$ = findnext$ + CHR$(&H89) + CHR$(&HF)               'mov [bx], cx     FNxt„  findnext$ = findnext$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx, [bp+06]  FNxt„  findnext$ = findnext$ + CHR$(&H89) + CHR$(&H7)               'mov [bx], ax     FNxt„  findnext$ = findnext$ + CHR$(&H5D)                           'pop bp           FNxt„  findnext$ = findnext$ + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)   'retf 0004        FNxt„„END SUB„„Mark K. Kim                    FIND FREE & TOTAL HD SPACE     MarkKKim@aol.com               02-07-96 (20:00)       QB, QBasic, PDS        201  9338     BDSPC10A.BAS'BASDriveSpace version 1.0a -- Find free and total space on a drive„'Copyright (c)1995-6 Mark K. Kim„'E-mail: MarkKKim@aol.com„'http://users.aol.com/markkkim/„'* Freely distributed.  May be used in other programs with proper notice of„'  credit.„'* This program is provided "as-is".„'* Not compatible with PowerBASIC.„'* In QuickBASIC 4.5, run QB.EXE with /L option. If including QB.BI, then„'  replace the ABSOLUTE SUB declaration statement in QB.BI with the ABSOLUTE„'  SUB declaration within this program. Make other proper revisions.„'* CREDIT: Ralf Brown's interrupt list was used to get interrupt for the„'  function.  Microsoft DOS's Debug was used to convert Assembly code to„'  machine code.  Microsoft is a Registered Trademark of Microsoft Corp.„'  Thanks to beta testers, rt911@aol.com and wildgamer@aol.com„'Read the header of each function to find out the usage of those functions.„'These functions are designed to work with most other routines as it does„'not interfere with any other routines. It is especially designed to work„'with other functions in this BASxx series.„„DECLARE SUB absolute (var1%, var2%, var3%, var4%, var5%, var6%, offset%)„'== BEGIN HEADER ==„DECLARE FUNCTION drv.freespace# (drive$)„DECLARE FUNCTION drv.totalspace# (drive$)„'== END HEADER ==„„„'== START ==„„CLS„INPUT "Enter of the drive to find free and total spaces: ", drive$„freespace = drv.freespace(drive$)„IF freespace = -1 THEN„  PRINT "Error during free space calculation!"„  PRINT "Terminating program...."„  END„END IF„totalspace = drv.totalspace(drive$)„IF totalspace = -1 THEN„  PRINT "Error during total space calculation!"„  PRINT "Terminating program...."„  END„END IF„PRINT "The free space on "; LEFT$(drive$, 1); " is:";„ PRINT USING " ###############"; freespace;„ PRINT " bytes."„PRINT "The total space on "; LEFT$(drive$, 1); " is:";„ PRINT USING "###############"; totalspace;„ PRINT " bytes."„END„„'Finds out the available free space of a drive in bytes.„'INPUT:„'˛ Drive$ is the letter representation of the drive one wants to find out the„'  free space of.  If its length is zero, it is assumed to be the current„'  drive.  No space must come in front of the string (ie - " A:\" is not a„'  valid string)„'RETURN ON SUCCESS:„'˛ The free space of the drive„'RETURN ON ERROR:„'˛ -1 is returned on any type of error.  Such errors include non-alphabetic„'  drive letters and no such drive error„'COMMENT:„'˛ Lost clusters are assumed to be in use„FUNCTION drv.freespace# (drive$)„  'convert drive letter to corresponding letter„  driveseg% = VARSEG(drive$)  'get drive$'s segment„  driveoff% = SADD(drive$)    'get drive$'s offset„  DEF SEG = driveseg%         'define segment„  drive% = PEEK(driveoff%)    'get ASCII equivalent of first letter of drive$„  DEF SEG„  IF drive$ = "" THEN         'if length of drive$ is zero, use default drive„    drive% = 0  'default drive„  ELSEIF drive% >= ASC("A") AND drive% <= ASC("Z") THEN„    drive% = drive% - 64„  ELSEIF drive% >= ASC("a") AND drive% <= ASC("z") THEN„    drive% = drive% - 96„  ELSE                        'if nothing fits, exit with error code (-1)„    drv.freespace = -1„    EXIT FUNCTION„  END IF„„  'store machine code„  asm$ = ""„  asm$ = asm$ + CHR$(&H55)                              'push bp„  asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp, sp„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)                 'mov dx, [bx]„  asm$ = asm$ + CHR$(&HB4) + CHR$(&H36)                 'mov ah, 36h„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)                 'int 21h„  asm$ = asm$ + CHR$(&H53)                              'push bx„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)     'mov bx, [bp+0c]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx], ax„  asm$ = asm$ + CHR$(&H58)                              'pop ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx, [bp+0a]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx], ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx, [bp+08]„  asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx], cx„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H17)                 'mov [bx], dx„  asm$ = asm$ + CHR$(&H5D)                              'pop bp„  asm$ = asm$ + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)      'retf 0008h„„  'execute„  asmseg% = VARSEG(asm$)      'get segment of stored machine codes„  asmoff% = SADD(asm$)        'get offset of stored machine codes„  DEF SEG = asmseg%           'define segment„  dx% = drive%                'transfer data from drive% to dx%„  CALL absolute(var1%, var2%, ax%, bx%, cx%, dx%, asmoff%) 'execute„  DEF SEG„  'if invalid drive„  IF ax% = &HFFFF THEN drv.freespace = -1: EXIT FUNCTION„„  'convert integers to long integers (because of sign problems)„  ax& = ax% AND &H7FFF                            'ax = sectors per cluster„  IF (ax% AND &H8000) THEN ax& = (ax& OR &H8000&)„  bx& = bx% AND &H7FFF                            'bx = number of free clstrs„  IF (bx% AND &H8000) THEN bx& = (bx& OR &H8000&)„  cx& = cx% AND &H7FFF                            'cx = bytes per sector„  IF (cx% AND &H8000) THEN cx& = (cx& OR &H8000&)„  dx& = dx% AND &H7FFF                            'dx = total clusters„  IF (dx% AND &H8000) THEN dx& = (dx& OR &H8000&)„„  'calculate free space and return„  drv.freespace# = 1# * ax& * bx& * cx& '(1# is for typecasting just in case)„END FUNCTION„„'Finds out the total space of a drive in bytes.„'INPUT:„'˛ Drive$ is the letter representation of the drive one wants to find out the„'  total space of.  If its length is zero, it is assumed to be the current„'  drive.  No space must come in front of the string (ie - " A:\" is not a„'  valid string)„'RETURN ON SUCCESS:„'˛ The total space of the drive„'RETURN ON ERROR:„'˛ -1 is returned on any type of error.  Such errors include non-alphabetic„'  drive letters and no such drive error)„FUNCTION drv.totalspace# (drive$)„  'convert drive letter to corresponding letter„  driveseg% = VARSEG(drive$)  'get drive$'s segment„  driveoff% = SADD(drive$)    'get drive$'s offset„  DEF SEG = driveseg%         'define segment„  drive% = PEEK(driveoff%)    'get ASCII equivalent of first letter of drive$„  DEF SEG„  IF drive$ = "" THEN         'if length of drive$ is zero, use default drive„    drive% = 0  'default drive„  ELSEIF drive% >= ASC("A") AND drive% <= ASC("Z") THEN„    drive% = drive% - 64„  ELSEIF drive% >= ASC("a") AND drive% <= ASC("z") THEN„    drive% = drive% - 96„  ELSE                        'if nothing fits, exit with error code (-1)„    drv.totalspace = -1„    EXIT FUNCTION„  END IF„„  'store machine code„  asm$ = ""„  asm$ = asm$ + CHR$(&H55)                              'push bp„  asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp, sp„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)                 'mov dx, [bx]„  asm$ = asm$ + CHR$(&HB4) + CHR$(&H36)                 'mov ah, 36h„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)                 'int 21h„  asm$ = asm$ + CHR$(&H53)                              'push bx„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)     'mov bx, [bp+0c]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx], ax„  asm$ = asm$ + CHR$(&H58)                              'pop ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx, [bp+0a]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx], ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx, [bp+08]„  asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx], cx„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H17)                 'mov [bx], dx„  asm$ = asm$ + CHR$(&H5D)                              'pop bp„  asm$ = asm$ + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)      'retf 0008h„„  'execute„  asmseg% = VARSEG(asm$)      'get segment of stored machine codes„  asmoff% = SADD(asm$)        'get offset of stored machine codes„  DEF SEG = asmseg%           'define segment„  dx% = drive%                'transfer data from drive% to dx%„  CALL absolute(var1%, var2%, ax%, bx%, cx%, dx%, asmoff%) 'execute„  DEF SEG„  'if invalid drive„  IF ax% = &HFFFF THEN drv.totalspace = -1: EXIT FUNCTION„„  'convert integers to long integers (because of sign problems)„  ax& = ax% AND &H7FFF                            'ax = sectors per cluster„  IF (ax% AND &H8000) THEN ax& = (ax& OR &H8000&)„  bx& = bx% AND &H7FFF                            'bx = number of free clstrs„  IF (bx% AND &H8000) THEN bx& = (bx& OR &H8000&)„  cx& = cx% AND &H7FFF                            'cx = bytes per sector„  IF (cx% AND &H8000) THEN cx& = (cx& OR &H8000&)„  dx& = dx% AND &H7FFF                            'dx = total clusters„  IF (dx% AND &H8000) THEN dx& = (dx& OR &H8000&)„„  'calculate total space and return„  drv.totalspace# = 1# * ax& * cx& * dx& '(1# is for typecasting just in case)„END FUNCTION„„Mark K. Kim                    RETURNS DOS VERSION NUMBER     MarkKKim@aol.com               02-07-96 (20:00)       QB, QBasic, PDS        67   2933     BDVER10A.BAS'DOSVer version 1.0a -- Display DOS version number„'Copyright (c)1995-6 Mark K. Kim„'E-mail: MarkKKim@aol.com„'http://users.aol.com/markkkim/„'* Freely distributed.  May be used in other programs with proper notice of„'  credit.„'* This program is provided "as-is".„'* Not compatible with PowerBASIC.„'* In QuickBASIC 4.5, run QB.EXE with /L option. If including QB.BI, then„'  replace the ABSOLUTE SUB declaration statement in QB.BI with the ABSOLUTE„'  SUB declaration within this program. Make other proper revisions.„'* CREDIT: Ralf Brown's interrupt list was used to get interrupt for the„'  function.  Microsoft DOS's Debug was used to convert Assembly code to„'  machine code.  Microsoft is a Registered Trademark of Microsoft Corp.„'  Thanks to beta testers, rt911@aol.com and wildgamer@aol.com„'Read the header of each function to find out the usage of those functions.„'These functions are designed to work with most other routines as it does„'not interfere with any other routines. It is especially designed to work„'with other functions in this BASxx series.„„DECLARE SUB absolute (var1%, var2%, var3%, var4%, var5%, var6%, offset%)„'== BEGIN HEADER ==„DECLARE FUNCTION getdosver ()„'== END HEADER ==„„„'== START ==„„PRINT "DOS Version:"; getdosver„„'Returns DOS version as a single-precision number„'COMMENTS:„'* It has not been fully tested on low DOS versions. Plus some exceptions„'  apply (ie - IBM-DOS 6.1 reports itself as 6.0 because there never was„'  IBM-DOS 6.0; there was MS-DOS 6.0 instead). It reports 7.0 on DOS that„'  comes with Windows95.„'* DOS version may be faked with special programs„'RETURN:„'* DOS version as a single-precision number. (ie - 6.22)„FUNCTION getdosver„  'initialize machine language instructions„  asm$ = ""„  asm$ = asm$ + CHR$(&H55)                           'push bp„  asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)              'mov bp, sp„  asm$ = asm$ + CHR$(&HB8) + CHR$(&H0) + CHR$(&H30)  'mov ax, 3000„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)              'int 21„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H7)               'mov [bx], ax„  asm$ = asm$ + CHR$(&H5D)                           'pop bp„  asm$ = asm$ + CHR$(&HCA) + CHR$(&H2) + CHR$(&H0)   'retf 0002„  'execute machine language instructions„  DEF SEG = VARSEG(asm$)             'set segment„  offset% = SADD(asm$)               'find offset„  CALL absolute(var1%, var2%, var3%, var4%, var5%, ax%, offset%)   'execute„  DEF SEG„  IF ax% > 1 THEN                    'transfer ax integer to ax long integer„    ax& = ax%„  ELSEIF ax% < 0 THEN„    ax& = ABS(ax%) + &H8000„  ELSE„    ax& = &H100„  END IF„  majver% = ax& AND &HFF                'find major version„  minver% = (ax& AND &HFF00) / &H100    'find minor version„  getdosver = majver% + (minver% / 100) 'return values„END FUNCTION„„Mark K. Kim                    TEXT SCREEN SCROLL             MarkKKim@aol.com               02-07-96 (20:00)       QB, QBasic, PDS        178  8141     BSCRL10A.BAS'BASScroll version 1.0a -- scroll screen„'Copyright (c)1995-6 Mark K. Kim„'E-mail: MarkKKim@aol.com„'http://users.aol.com/markkkim/„'* Freely distributed.  May be used in other programs with proper notice of„'  credit.„'* This program is provided "as-is".„'* Not compatible with PowerBASIC.„'* In QuickBASIC 4.5, run QB.EXE with /L option. If including QB.BI, then„'  replace the ABSOLUTE SUB declaration statement in QB.BI with the ABSOLUTE„'  SUB declaration within this program. Make other proper revisions.„'* CREDIT: Ralf Brown's interrupt list was used to get interrupt for the„'  function.  Microsoft DOS's Debug was used to convert Assembly code to„'  machine code.  Microsoft is a Registered Trademark of Microsoft Corp.„'  Thanks to beta testers, rt911@aol.com and wildgamer@aol.com„'Read the header of each function to find out the usage of those functions.„'These functions are designed to work with most other routines as it does„'not interfere with any other routines. It is especially designed to work„'with other functions in this BASxx series.„„DECLARE SUB absolute (var1%, var2%, var3%, var4%, var5%, var6%, offset%)„'== BEGIN HEADER ==„DECLARE SUB scroll.up (lines%, x1%, y1%, x2%, y2%, attrib%)„DECLARE SUB scroll.down (lines%, x1%, y1%, x2%, y2%, attrib%)„'== END HEADER ==„„„'== START ==„„SHELL "dir /w c:\dos"„LOCATE 25, 1: PRINT "*** Press any key to continue ***";„„'slow scroll„LOCATE 24, 1: PRINT "*** SLOW SCROLL DEMONSTRATION ***";„DO„  FOR i% = 1 TO 10„    scroll.up 1, 5, 5, 75, 20, &H0„  NEXT i%„  FOR i% = 1 TO 10„    scroll.down 1, 5, 5, 75, 20, &H0„  NEXT i%„LOOP UNTIL INKEY$ <> ""„„'faster scroll„LOCATE 24, 1: PRINT "*** FASTER SCROLL DEMONSTRATION ***";„DO„  FOR i% = 1 TO 5„    scroll.up 2, 5, 5, 75, 20, &H0„  NEXT i%„  FOR i% = 1 TO 5„    scroll.down 2, 5, 5, 75, 20, &H0„  NEXT i%„LOOP UNTIL INKEY$ <> ""„„'even faster scroll„LOCATE 24, 1: PRINT "*** EVEN FASTER SCROLL DEMONSTRATION ***";„DO„  FOR i% = 1 TO 3„    scroll.up 3, 5, 5, 75, 20, &H0„  NEXT i%„  FOR i% = 1 TO 3„    scroll.down 3, 5, 5, 75, 20, &H0„  NEXT i%„LOOP UNTIL INKEY$ <> ""„„'fastest scroll„LOCATE 24, 1: PRINT "*** FASTEST SCROLL DEMONSTRATION ***    ";„DO„  FOR i% = 1 TO 2„    scroll.up 4, 5, 5, 75, 20, &H0„  NEXT i%„  FOR i% = 1 TO 2„    scroll.down 4, 5, 5, 75, 20, &H0„  NEXT i%„LOOP UNTIL INKEY$ <> ""„„'Scrolls down text on screen.„'INPUTS;„'* lines%   : Scroll this many lines down„'* x1%, y1% : Top-left coordinate„'* x2%, y2% : Bottom-right coordinate„'* (x1, y1)-(x2, y2) is the "box" area to be scrolled down.„'* attrib%  : Attributes of the text (color, blink, bold, etc.)„SUB scroll.down (lines%, x1%, y1%, x2%, y2%, attrib%)„  asm$ = ""„  asm$ = asm$ + CHR$(&H55)                            'push bp„  asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)               'mov bp, sp„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H10)  'mov bx, [bp+10]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)                'mov ax, [bx]„  asm$ = asm$ + CHR$(&HB4) + CHR$(&H7)                'mvo ah, 07„  asm$ = asm$ + CHR$(&H50)                            'push ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HE)   'mov bx, [bp+0e]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)                'mov ax, [bx]„  asm$ = asm$ + CHR$(&HB1) + CHR$(&H8)                'mov cl, 08„  asm$ = asm$ + CHR$(&HD3) + CHR$(&HE0)               'shl ax, cl„  asm$ = asm$ + CHR$(&H50)                            'push ax,„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)   'mov bx, [bp+0c]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&HF)                'mov cx, [bx]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)   'mov bx, [bp+0a]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)               'mov dx, [bx]„  asm$ = asm$ + CHR$(&H88) + CHR$(&HCC)               'mov ah, cl„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)   'mov bx, [bp+0a]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)               'mov dx, [bx]„  asm$ = asm$ + CHR$(&H88) + CHR$(&HCC)               'mov ah, cl„  asm$ = asm$ + CHR$(&H88) + CHR$(&HD0)               'mov al, dl„  asm$ = asm$ + CHR$(&H50)                            'push ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)   'mov bx, [bp+08]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&HF)                'mov cx, [bx]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)   'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)               'mov dx, [bx]„  asm$ = asm$ + CHR$(&H88) + CHR$(&HCC)               'mov ah, cl„  asm$ = asm$ + CHR$(&H88) + CHR$(&HD0)               'mov al, dl„  asm$ = asm$ + CHR$(&H50)                            'push ax„  asm$ = asm$ + CHR$(&H5A)                            'pop dx„  asm$ = asm$ + CHR$(&H59)                            'pop cx„  asm$ = asm$ + CHR$(&H5B)                            'pop bx„  asm$ = asm$ + CHR$(&H58)                            'pop ax„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H10)               'int 10„  asm$ = asm$ + CHR$(&H5D)                            'pop bp„  asm$ = asm$ + CHR$(&HCB)                            'retf„  asmseg% = VARSEG(asm$)„  asmoff% = SADD(asm$)„  DEF SEG = asmseg%„  CALL absolute(lines%, attrib%, y1% - 1, x1% - 1, y2% - 1, x2% - 1, asmoff%)„  DEF SEG„END SUB„„'Scrolls up text on screen.„'INPUTS;„'* lines%   : Scroll this many lines up„'* x1%, y1% : Top-left coordinate„'* x2%, y2% : Bottom-right coordinate„'* (x1, y1)-(x2, y2) is the "box" area to be scrolled up.„'* attrib%  : Attributes of the text (color, blink, bold, etc.)„SUB scroll.up (lines%, x1%, y1%, x2%, y2%, attrib%)„  asm$ = ""„  asm$ = asm$ + CHR$(&H55)                            'push bp„  asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)               'mov bp, sp„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H10)  'mov bx, [bp+10]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)                'mov ax, [bx]„  asm$ = asm$ + CHR$(&HB4) + CHR$(&H6)                'mvo ah, 06„  asm$ = asm$ + CHR$(&H50)                            'push ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HE)   'mov bx, [bp+0e]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)                'mov ax, [bx]„  asm$ = asm$ + CHR$(&HB1) + CHR$(&H8)                'mov cl, 08„  asm$ = asm$ + CHR$(&HD3) + CHR$(&HE0)               'shl ax, cl„  asm$ = asm$ + CHR$(&H50)                            'push ax,„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)   'mov bx, [bp+0c]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&HF)                'mov cx, [bx]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)   'mov bx, [bp+0a]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)               'mov dx, [bx]„  asm$ = asm$ + CHR$(&H88) + CHR$(&HCC)               'mov ah, cl„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)   'mov bx, [bp+0a]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)               'mov dx, [bx]„  asm$ = asm$ + CHR$(&H88) + CHR$(&HCC)               'mov ah, cl„  asm$ = asm$ + CHR$(&H88) + CHR$(&HD0)               'mov al, dl„  asm$ = asm$ + CHR$(&H50)                            'push ax„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)   'mov bx, [bp+08]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&HF)                'mov cx, [bx]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)   'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H17)               'mov dx, [bx]„  asm$ = asm$ + CHR$(&H88) + CHR$(&HCC)               'mov ah, cl„  asm$ = asm$ + CHR$(&H88) + CHR$(&HD0)               'mov al, dl„  asm$ = asm$ + CHR$(&H50)                            'push ax„  asm$ = asm$ + CHR$(&H5A)                            'pop dx„  asm$ = asm$ + CHR$(&H59)                            'pop cx„  asm$ = asm$ + CHR$(&H5B)                            'pop bx„  asm$ = asm$ + CHR$(&H58)                            'pop ax„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H10)               'int 10„  asm$ = asm$ + CHR$(&H5D)                            'pop bp„  asm$ = asm$ + CHR$(&HCB)                            'retf„  asmseg% = VARSEG(asm$)„  asmoff% = SADD(asm$)„  DEF SEG = asmseg%„  CALL absolute(lines%, attrib%, y1% - 1, x1% - 1, y2% - 1, x2% - 1, asmoff%)„  DEF SEG„END SUB„„Ronny Ong                      EXE FILE SPEC                  Rolf@ice.prima.ruhr.de         04-05-88 (00:00)       QB, PDS                79   2346     FILESPEC.BAS' FILESPEC.BAS by Ronny Ong, April 5, 1988 - 100% Public Domain„' Example of how to create FILESPEC.EXE:„'   BC FILESPEC/O;„'   LINK /E/NOE FILESPEC,,,QB.LIB;„„'$INCLUDE: 'QB.BI'„„DIM InRegs AS RegType, OutRegs AS RegType„DIM EnvBlkSeg AS INTEGER, EnvBlkPtr AS INTEGER, Char AS INTEGER„DIM Filespec AS STRING„„' The Program Segment Prefix is a 256-byte block which DOS„' creates below all normal transient programs loaded.  The PSP„' contains many important pieces of information about the„' transient program, including the location of its "environment„' block" in memory.„„LET InRegs.AX = &H6200 ' Int 21H, Function 62H is Get PSP.„CALL INTERRUPT(&H21, InRegs, OutRegs)„DEF SEG = OutRegs.BX ' Select the segment containing the PSP.„„' Get the segment of the environment block, stored at offset 2CH„' in the PSP.„„LET EnvBlkSeg = CVI(CHR$(PEEK(&H2C)) + CHR$(PEEK(&H2D)))„„' Now select the segment of the environment block itself.„' Environment blocks are always paragraph-aligned.  That is, they„' begin only on even 16-byte address boundaries.  Offset 0,„' therefore, is always the start of the block as long as the„' segment is set properly.„„DEF SEG = EnvBlkSeg„„' Initialize a pointer to search forward sequentially through„' memory, looking for the double zero bytes which mark the end of„' the environment strings.„„LET EnvBlkPtr = 0„„DO„  IF PEEK(EnvBlkPtr) = 0 THEN„    IF PEEK(EnvBlkPtr + 1) = 0 THEN„      EXIT DO„    END IF„  END IF„  IF EnvBlkPtr = &H7FFF THEN ' Environment blocks are max of 32K.„    PRINT "End of environment block not found!"„    STOP„  ELSE„    LET EnvBlkPtr = EnvBlkPtr + 1„  END IF„LOOP„„' Skip over the double zeroes and the 2-byte word count which„' precedes the filespec.„„LET EnvBlkPtr = EnvBlkPtr + 4„„LET Filespec = "" ' Initialize filespec.„„' Assemble Filespec, ensuring that it does not get too long.„„DO„  LET Char = PEEK(EnvBlkPtr)„  IF Char THEN„    LET Filespec = Filespec + CHR$(Char)„    LET EnvBlkPtr = EnvBlkPtr + 1„  END IF„LOOP WHILE Char > 0 AND LEN(Filespec) < 80„„' At this point, Filespec could be used in an OPEN statement to„' read/write the EXE file, but for this demonstration, it is„' simply displayed.„„PRINT "This program was loaded as "; Filespec„„DEF SEG ' Restore BASIC's default data segment.„END„Thomas Gohel                   DETECT COMPUTER PROCESSOR UNIT comp.lang.basic.misc           02-03-96 (00:00)       PB                     173  4957     PBCPU.BAS   '*************************************************************************„'„'  PBCPU.BAS:  Ermitteln des Prozessortyps in PowerBASIC 3.0/3.2„'              / CPU-Detection with PowerBASIC 3.0/3.2„'„'  entwickelt von Thomas Gohel  Fido:      2:2410/301.12„'  Version: 1.01                InterNet:  author@pbsound.snafu.de„'  Stand  : 02.03.1996          Homepage:  http://www.snafu.de/~pbsound/„'„'  unter Verwendung einiger Sourcen aus dem Jahre 1994 aus der ASM86.GER„'„' --------------------------------------------------------------------------„'„' Beschreibung: Das Programm f‰ngt beim Status Prozessor = 8086 an und„' ¸berpr¸ft, ob jeweils die Statusregister-Bits des n‰chst hˆheren„' Prozessors gesetzt werden kˆnnen.„' Bei Erkennung der Unterst¸tzung des CPUID-Befehls wird der Prozessortyp„' aus der 'Familykennung' ermittelt. Neuere CPU's sollten diesen Befehl„' unterst¸tzen, ebenso zuk¸nftige Prozessorgenerationen.„'„'     Bedeutung der Variable Prozessor?:„'     0   = 8086/8088„'     1   = 80186„'     2   = 80286„'     3   = 80386„'     4   = 80486„'     5   = 80586 (Pentium)„'     6   = 80686 (Pentium Pro)„'     7   = n‰chste CPU-Generationen :-))„'     255 = V20/V30„'„'***************************************************************************„„$COMPILE EXE„PRINT "ermittelter Prozessortyp: "; CPUTyp$„END„„FUNCTION CPUTyp$ public„        LOCAL Prozessor?„        DIM Vendor AS STRING * 12„„        ! pushf„        ! mov     ax, &h0000„        ! push    ax„        ! popf„        ! pushf„        ! pop     ax„        ! and     ax, &hF000„        ! cmp     ax, &hF000„        ! jnz     Teste286„„        ! mov     ax, &hFFFF„        ! mov     cl, &h21„        ! shl     ax, cl„        ! jnz     Setze186„        ! mov     Prozessor?, &h00„        ! popf„„        ! xor     ax, ax„        ! mov     al, &h40„        ! mul     al„        ! jz      SetzeNEC„        ! jmp     CPUEnde„„        Setze186:„        ! mov     Prozessor?, &h01„        ! popf„        ! jmp     CPUEnde„„        SetzeNEC:„        ! mov     Prozessor?, &hFF„        ! jmp     CPUEnde„„        Teste286:„        ! mov     ax, &h7000„        ! push    ax„        ! popf„        ! pushf„        ! pop     ax„        ! and     ax, &h7000„        ! jnz     Teste386„        ! mov     Prozessor?, &h02„        ! popf„        ! jmp     CPUEnde„„        Teste386:„        ! mov     bx, sp„        ! and     sp, &hFFFC„        ! db      &h66„        ! pushf„        ! db      &h66„        ! pop     ax„        ! db      &h66„        ! mov     cx, ax„        ! db      &h66„        ! xor     ax, &h0000„        ! dw      &h0004„        ! db      &h66„        ! push    ax„        ! db      &h66„        ! popf„        ! db      &h66„        ! pushf„        ! db      &h66„        ! pop     ax„        ! db      &h66„        ! xor     ax, cx„        ! mov     Prozessor?, &h03„        ! mov     sp, bx„        ! jz      CPUEnde„        ! and     sp, &hFFFC„        ! db      &h66„        ! push    cx„        ! db      &h66„        ! popf„        ! mov     sp, bx„„        Teste486:„        ! mov     Prozessor?, &h04„        ! db      &h66„        ! mov     ax, cx„        ! db      &h66„        ! xor     ax, &h0000„        ! dw      &h0020„        ! db      &h66„        ! push    ax„        ! db      &h66„        ! popf„        ! db      &h66„        ! pushf„        ! db      &h66„        ! pop     ax„        ! db      &h66„        ! xor     ax, cx„        ! je      CPUEnde„„        TesteCPUID:„        ! db      &h66„        ! xor     ax, ax„        ! inc     ax„        ! dw      &hA20F„        ! and     ah, &h0F„        ! mov     Prozessor?, ah„        ! xor     ax, ax„        ! dw      &hA20F„        ! db      &h66„        ! mov     Vendor$[00], bx„        ! db      &h66„        ! mov     Vendor$[04], dx„        ! db      &h66„        ! mov     Vendor$[08], cx„„        CPUEnde:„        SELECT CASE Vendor$„            CASE "GenuineIntel": Manufacturer$ = "Intel "„            CASE "AuthenticAMD": Manufacturer$ = "AMD "„            CASE "NexGenDevice": Manufacturer$ = "NexGen "„            'CASE "UMC UMC UMC ": Manufacturer$ = "??? "„            CASE ELSE          : Manufacturer$ = "Intel "„        END SELECT„        SELECT CASE Prozessor?„            CASE 0  : CPUTyp$ = "Intel 8088/8086"„            CASE 1  : CPUTyp$ = "Intel 80186"„            CASE 2  : CPUTyp$ = "Intel 80286"„            CASE 3  : CPUTyp$ = "Intel 80386"„            CASE 4  : CPUTyp$ = Manufacturer$ + "80486"„            CASE 5  : CPUTyp$ = Manufacturer$ + "Pentium"„            CASE 6  : CPUTyp$ = Manufacturer$ + "Pentium Pro"„            CASE 255: CPUTyp$ = "NEC V20/V30"„            CASE ELSE:„                      CPUTyp$ = "Intel 80" + CHR$(Prozessor? + 48) + "86"„        END SELECT„END FUNCTION„Jim Emptage                    PATH CHECK                     75504.2526@compuserve.com      03-10-96 (01:47)       QB, QBasic, PDS        190  4725     PATHCHK.BAS 'PATHCHK BY ROUGE VALLEY SOFTWARE 1996 75504.2526@COMPUSERVE.COM„'„'* Place program anywhere on the C: drive„'* It will show your path, and check that all directories exist„'* If some directories are no longer valid you will be asked if you„'* wish the PATH line in your autoexec.bat file changed to remove them„'* A back up of your original autoexec.bat file is [made autoexec.rvs]„'* Shareware, all rights reserved„'* Please ask permission if distributed in any package that is for sale.„'„'Jim Emptage, Rouge Valley Software„CLS„COLOR 7, 4„PRINT " ROUGE VALLEY SOFTWARE PATH CHECK (1996)   75504.2526@COMPUSERVE.COM            "„COLOR 7, 0„OPEN "rvsdrive.dat" FOR OUTPUT AS #2„CLOSE #2„SHELL "cd>rvsdrive.dat"„OPEN "rvsdrive.dat" FOR INPUT AS #2„DO UNTIL EOF(2)„  INPUT #2, CURDRIVE$„LOOP„CLOSE #2„PRINT "EXAMINE PATH STATEMENT : Changing to the root drive \"„PRINT "                       : Return to : "; CURDRIVE$; " when done."„CHDIR "\"„COLOR 7, 1„PRINT " MAKING DOS VERIFIED BACKUP OF AUTOEXEC.BAT > AUTOEXEC.RVS                      "„COLOR 7, 0„SHELL "COPY AUTOEXEC.BAT C:\AUTOEXEC.RVS/V/Y"„OPEN "rvstemp.dat" FOR OUTPUT AS #1„CLOSE #1„OPEN "rvstemp.dat" FOR APPEND AS #1„OPEN "autoexec.bat" FOR INPUT AS #2„cnt = 0„DO UNTIL EOF(2)„  LINE INPUT #2, x$„  cnt = cnt + 1„  IF UCASE$(MID$(x$, 1, 4)) = "PATH" THEN„    EXIT DO„  END IF„LOOP„CLOSE #2„COLOR 7, 4„PRINT " CURRENT PATH: ";„COLOR 7, 0„PRINT RTRIM$(x$)„PRINT "Line in AUTOEXEC.BAT: "; cnt;„PL = LEN(x$)„PRINT " PATH length: "; PL„PRINT "[ Note PATH line can only have 127 characters ]"„COLOR 7, 1„PRINT " COUNTING DIRECTORIES IN PATH:                                                  "„COLOR 7, 0„x$ = UCASE$(x$)„pcnt = 0„FIRST = INSTR(x$, "C:\")„FOR M = FIRST TO PL„  P$ = MID$(x$, M, 1)„  IF P$ <> ";" THEN„    PDIR$ = PDIR$ + P$„  ELSE„    IF RTRIM$(PDIR$) <> "" THEN„      PRINT " "; PDIR$; " ";„      PRINT #1, PDIR$„      PDIR$ = ""„      pcnt = pcnt + 1„    END IF„  END IF„NEXT„IF RTRIM$(PDIR$) <> "" THEN„  PRINT " "; PDIR$; " ";„  PRINT #1, PDIR$„  PDIR$ = ""„  pcnt = pcnt + 1„END IF„PRINT„PRINT pcnt; " DIRECTORIES IN PATH "„CLOSE„COLOR 7, 4„PRINT " CHECKING THAT ALL DIRECTORIES ARE VALID                                        "„COLOR 7, 0„REDIM iv(pcnt) AS STRING„ON ERROR GOTO DERR„OPEN "RVSTEMP.DAT" FOR INPUT AS #1„IVCNT = 0„DO UNTIL EOF(1)„  INPUT #1, dc$„  dc$ = RTRIM$(dc$)„  IF MID$(dc$, LEN(dc$), 1) = "\" THEN„    dc$ = MID$(dc$, 1, LEN(dc$) - 1)„  END IF„  CHDIR dc$„99„  IF ed = 1 AND block = 0 THEN„    COLOR 14, 4„    PRINT " INVALID DIRECTORIES FOUND ... [THEY DO NOT EXIST]                              "„    COLOR 7, 0„    block = 1„  END IF„  IF ed = 1 THEN„    PRINT " "; dc$; " ";„    IVCNT = IVCNT + 1„    iv(IVCNT) = dc$„    ed = 0„  END IF„LOOP„CLOSE„CHDIR "\"„IF block = 0 THEN„  COLOR 1, 7„  PRINT " NO INVALID DIRECTORIES FOUND ... ALL DIRECTORIES LISTED EXIST ... PASS         "„  COLOR 7, 0„END IF„IF IVCNT = 0 THEN GOTO 101„COLOR 7, 1„PRINT„PRINT " REMOVE INVALID DIRECTORIES FROM PATH (Y/N)                                     "„COLOR 7, 0„88„WHILE INKEY$ <> ""„WEND„CH$ = UCASE$(INPUT$(1))„SELECT CASE CH$„  CASE "Y"„    OPEN "rvstemp.dat" FOR INPUT AS #1„    np$ = "PATH "„    DO UNTIL EOF(1)„      LINE INPUT #1, x$„      nogo = 0„      FOR z = 1 TO IVCNT„        IF INSTR(UCASE$(x$), iv(z)) > 0 THEN nogo = 1„      NEXT„      IF nogo = 0 THEN„        np$ = np$ + UCASE$(x$) + ";"„      END IF„    LOOP„    CLOSE„    COLOR 7, 1„    PRINT " UPDATING PATH IN AUTOEXEC.BAT TO:                                  "„    COLOR 7, 0„    PRINT np$„    OPEN "rvstemp2.dat" FOR OUTPUT AS #1„    OPEN "autoexec.bat" FOR INPUT AS #2„    pblock = 0„    DO UNTIL EOF(2)„      LINE INPUT #2, x$„      IF UCASE$(MID$(x$, 1, 4)) = "PATH" AND pblock = 0 THEN„        pblock = 1„        PRINT #1, np$„      ELSE„        PRINT #1, x$„      END IF„    LOOP„    CLOSE„    KILL "AUTOEXEC.BAT"„    NAME "RVSTEMP2.DAT" AS "AUTOEXEC.BAT"„  CASE "N"„  CASE ELSE„    SOUND 40, 1„    GOTO 88„END SELECT„101„CLOSE„KILL "\rvstemp.dat"„CHDIR CURDRIVE$„LOCATE 25, 1„COLOR 14, 1„PRINT " FINISHED    -    PRESS ANY KEY TO EXIT PROGRAM                                 ";„COLOR 7, 0„WHILE INKEY$ <> ""„WEND„DO„LOOP WHILE INKEY$ = ""„CLS„END„DERR:„IF ed = 0 THEN ed = 1„SELECT CASE ERR„  CASE 76„    SOUND 40, 1„    RESUME 99„  CASE ELSE„    PRINT ERR, ERL„    PRINT "WARNING: UNDETERMINED ERROR"„    PRINT„    PRINT "DO NOT USE THE INFORMATION PROVIDED BY THIS PROGRAM"„    PRINT "CHECK YOUR AUTOEXEC.BAT FILE INCASE OF UNWANTED CHANGES"„END SELECT„RESUME 101„Robert Fortune                 DETECT IF SHARE IS LOADED      FidoNet QUIK_BAS Echo          04-11-96 (17:59)       QB, PDS                35   1811     SHARED.BAS  '>2. Is there anyone who has experience writing multi-node doors?  Now,„'>here I am referring both to the ability for the game to be playing„'>simultaneously on multiple nodes (which DFrame does automatically), and„'>ALSO to the ability for users on multiple nodes to be playing against„'>each other.„„'   I have experience writing BBS game doors that can be play simultaneously„'   on multiple nodes but they cannot play each other. I don't imagine it„'   would be very difficult to write a door that allows players to play„'   against each other while on different BBS nodes. I believe some people„'   write player's commands\incoming data to a file which the other nodes„'   can than read and act upon in real time. Does that help?„'     To determine if the BBS is multinode you can use the following„'   function to determine if DOS's TSR program SHARE is loaded and if it„'   is then your program will know that it has to lock and unlock its„'   data file(s). Some people just lock all their door's data files no„'   matter if the host BBS is multinode or not. That is up to you.„„DEFINT A-Z   ' untyped variables default to type integer„' $INCLUDE: 'QB.BI'„DECLARE FUNCTION IsShare% ()„DIM SHARED InReg AS RegType, OutReg AS RegType„PRINT "The DOS Utility SHARE is ";„IF IsShare% THEN„   PRINT "loaded. Lock/Unlock your file(s) as needed."„ELSE„   PRINT "is NOT loaded. No need to lock your file(s)."„END IF„FUNCTION IsShare% STATIC„  IsShare% = -1                           ' assume Share is loaded„  RegType.ax = &H1000                     ' service 10h„  CALL Interrupt(&H2F, InReg, OutReg)     ' check for presence of SHARE„  AL = RegType.ax AND 255                 ' isolate the result in AL„  IF AL <> &HFF THEN IsShare% = 0         ' SHARE not found„END FUNCTION„Geoffrey Liu                   ERRORLEVEL OF RETURNED SHELL   QBTIPS_?.DOC                   12-17-92 (21:25)       QB, QBasic, PDS        18   706      ERRLEVEL.BAS'> I have looked in several books for the QuickBasic equivalent of Batch„'>language's ERRORLEVEL command.  I couldn't get ERRORLEVEL to work in QB„'>and I am wondering if there is a command that does the same thing. I'm„'> trying to get QuickBasic to take Errorlevels from a program that I am„'> SHELLing out to run.„„DECLARE FUNCTION ErrorLevel% () 'Returns errorlevel of shelled program„„FUNCTION ErrorLevel%„„   'Purpose : To check the error level of a program returning from shell„   'Input   : none (well, helps if you did shell a program first)„   'Return  : The errorlevel returned from the last shelled program„„   DEF SEG = 0„   ErrorLevel% = PEEK(&H4FE)„   DEF SEG„END FUNCTION„Joey Shaw                      EXITING WITH ERRORLEVEL        Load with QB /LQB              08-04-92 (16:13)       QB, PDS                13   346      EXITERR.BAS '> Sure is! It's REAL simple. All you have to do is declare a sub...„„'Ohhh...„„'> DECLARE SUB ExitWithErrLvl ALIAS "_Exit" (BYVAL ErrorLevel%)„„'Ok....„„'> There thats it. Now to exit with an errorlevel just do this.„'> ExitWithErrLvl 5„'> That exits with errorlevel 5! See, pretty easy huh! See ya!„„'Yeah, tell me about it! Thanx„Tony Elliott                   CHECK IF IN A SHELL            QB TidBits                     09-06-92 (18:09)       QB, PDS                107  2993     INSHELL.BAS ' >Is it possible for a spawned program (via SHELL or more importantly via„' >QBSWAP) to know the name of the program which spawned it? (or even to know„' >that it is a shelled program and not a "top-level" program?)  How?„„'There is a way to determine if a program is a child process. However,„'I haven't been able to determine the name of the parent process. This„'EXE filename is normally store just above the apps copy of the„'environment. Apparently this info is destroyed when the parent app„'shells.„„'Here's some code to determine if the app is being executed from a„'shell:„„'$INCLUDE: 'QB.BI'„„DEFINT A-Z„DECLARE FUNCTION ImInAShell% ()„DECLARE FUNCTION BPeek% (Segment&, Offset%)„DECLARE FUNCTION WPeek% (Segment&, Offset%)„DECLARE FUNCTION ExeName$ (Psp%)„„IF ImInAShell% THEN„    PRINT "I'm in a shell!"„ELSE„    PRINT "I'm not in a shell."„END IF„ „„FUNCTION BPeek% (Segment&, Offset%)„„    'Peeks a byte (two bytes) and returns it as a result of the function„„    DEF SEG = Segment&                  'Point to data segment„    Temp% = PEEK(Offset%)               'Peek byte into temp variable„    DEF SEG                             'Point back to DGroup„    BPeek% = Temp%                      'Return it„„END FUNCTION„„FUNCTION ImInAShell%„„  DIM Reg AS RegTypeX„	„  IntNo = &H21                        'Get Current PSP„  Reg.ax = &H5100„  GOSUB DoDosCall„  CurrentPSP = Reg.bx„„  Reg.ax = &H5200                     'Get DOS "List of Lists"„  GOSUB DoDosCall„  Offset = Reg.bx„	„  'Get pointer to first memory control block (MCB) ES:BX-2„  MemBlock& = WPeek(CLNG(Reg.es), Offset - 2)„„  DO„    Id = BPeek(MemBlock&, 0)„    SELECT CASE Id„	  CASE &H4D                   'Part of MCB chain„	    OwnerPSP = WPeek(MemBlock&, 1)„	    BlockSize& = WPeek(MemBlock&, 3)„	    IF OwnerPSP <> 0 AND OwnerPSP <> 8 AND LastPSP <> OwnerPSP THEN„		  'Valid block„		  LastPSP = OwnerPSP„		  ParentPSP = WPeek(CLNG(OwnerPSP), &H16)„		  IF ParentPSP = OwnerPSP THEN„			IF FirstCommandCom = 0 THEN„			   FirstCommandCom = ParentPSP„			ELSE„			   ImInAShell = -1„			   EXIT DO„			END IF„		  END IF„	    ELSEIF OwnerPSP = CurrentPSP THEN„		  EXIT DO                         'Stop when we get to our„	    END IF                             'own PSP.„				 „	CASE &H5A                               'Last block in chain„	    EXIT DO„„	CASE ELSE                               'Error - MCB's Destroyed!!„	    EXIT DO„„	END SELECT„	MemBlock& = MemBlock& + BlockSize& + 1      'Next block in chain„ LOOP„ EXIT FUNCTION„„DoDosCall:„	CALL INTERRUPTX(IntNo, Reg, Reg)„RETURN„END FUNCTION„„FUNCTION WPeek% (Segment&, Offset%)„„    'Peeks a word (two bytes) and returns it as a result of the function„„    DEF SEG = Segment&„    TempL% = PEEK(Offset%)„    TempH% = PEEK(Offset% + 1)„    DEF SEG„    POKE VARPTR(Result%), TempL%„    POKE VARPTR(Result%) + 1, TempH%„    WPeek% = Result%„„END FUNCTION„„Thomas Gohel                   SET TIME & DATE ON FILES       alt.lang.basic                 05-02-95 (00:00)       PB                     97   2906     SETDATE.BAS '> I'm currently developing a program... I need to set the date on files. Right„'> now I'm using a utility to do that (runned via shell) but i wondered if„'> there were any faster, internal way? Please answere.. ;)„„'*************************************************************************„'„'   Setzen des Datum und der Uhrzeit in PowerBASIC 3.0/3.2„'   / Set date and time on files„'„'   entwickelt von / developed by   :  Thomas Gohel„'„'                           Fido    :  Thomas Gohel@2:2410/301.12„'                           InterNet:  author@pbsound.snafu.de„'                           Homepage:  http://www.snafu.de/~pbsound/„'„'**************************************************************************„„WriteDatum "noname.bak", "23.06.1995", "20:15:00"„END„„FUNCTION WriteDatum(Datei$, Datum$, Zeit$) public„        LOCAL DateiSeg??, DateiOff??, DateiHandle%„        LOCAL DateiDatum%, DateiZeit%„        LOCAL Tag%, Monat%, Jahr%„„        ' Tag%   = day„        ' Monat% = month„        ' Jahr%  = year„        ' DateiDatum% = date„        ' DateiZeit%  = time„„        Datei$     = Datei$ + CHR$(0)„        DateiSeg?? = STRSEG(Datei$)„        DateiOff?? = STRPTR(Datei$)„        Jahr%      = VAL(RIGHT$(Datum$, 4))„        Monat%     = VAL(MID$(Datum$, 4, 2))„        Tag%       = VAL(LEFT$(Datum$, 2))„        Stunde%    = VAL(LEFT$(Zeit$,2))„        Minute%    = VAL(MID$(Zeit$,4,2))„        Sekunde%   = VAL(RIGHT$(Zeit$,2))„        ! mov cl, 5„        ! mov ax, Minute%„        ! shl ax, cl„        ! mov Minute%, ax„        ! mov cl, 11„        ! mov ax, Stunde%„        ! shl ax, cl„        ! mov Stunde%, ax„        ! mov cl, 5„        ! mov ax, Monat%„        ! shl ax, cl„        ! mov Monat%, ax„        ! mov ax, Jahr%„        ! sub ax, 1980„        ! mov cl, 9„        ! shl ax, cl„        ! mov Jahr%, ax„        ! mov ax, DateiDatum%„        ! mov bx, Jahr%„        ! mov cx, Monat%„        ! mov dx, Tag%„        ! xor ax, ax„        ! or  ax, bx„        ! or  ax, cx„        ! or  ax, dx„        ! mov DateiDatum%, ax„        ! mov ax, DateiZeit%„        ! mov bx, Stunde%„        ! mov cx, Minute%„        ! mov dx, Sekunde%„        ! xor ax, ax„        ! or  ax, bx„        ! or  ax, cx„        ! or  ax, dx„        ! mov DateiZeit%, ax„„        ! push ds„        ! mov ax, &h3d90„        ! mov dx, DateiOff??„        ! mov ds, DateiSeg??„        ! int &h21„        ! pop ds„        ! mov DateiHandle%, ax„        ! jnc WriteFileOk„        EXIT FUNCTION„„        WriteFileOk:„        ! mov ax, &h5701„        ! mov bx, DateiHandle%„        ! mov cx, DateiZeit%„        ! mov dx, DateiDatum%„        ! int &h21„        ! mov ax, &h3e00„        ! mov bx, DateiHandle%„        ! int &h21„END FUNCTION„'**************************************************************************„Jason Laviska                  RETRIEVING ENVIRONMENT SETTINGSjason.laviska@outdoor.com      06-16-96 (16:56)       QB, QBasic, PDS        34   847      ENVIRO.BAS  'Retriving data from the environment settings by Jason Laviska.„'LaserArts' Library Function E-02-A„'--- Public Domain --- Use at your own risk ---„„'     A simple program used to check the environment settings and„'retrieve only the data found after the equal sign.  So if your„'environment settings included:„„'  PROMPT=$P$G„„'If you ran this Function by typing:„„'  PRINT Environment$ ("PROMPT")„„'You would get the following output:„„'  $P$G„„FUNCTION Environment$ (SearchFor$)„„SearchFor$ = UCASE$(SearchFor$)„SearchSize% = LEN(SearchFor$)„Temp% = 1„„DO WHILE ENVIRON$(Temp%) <> ""„  IF LEFT$(ENVIRON$(Temp%), SearchSize%) = SearchFor$ THEN„    Environment$ = RIGHT$(ENVIRON$(Temp%), LEN(ENVIRON$(Temp%)) - SearchSize% - 1)„    EXIT FUNCTION„  END IF„  Temp% = Temp% + 1„LOOP„Environment$ = ""„„END FUNCTION„Edward Blake                   BATCH PROCEDURES               eblake2@quebectel.com          07-04-96 (19:54)       QB, PDS                154  5053     BATCH.BAS   ' 1996 Edward Blake (still 14 years old) Quebec, Canada„' Routines called from a Batch (.BAT) file. can be used for making a simple„' Installation batch program or anything else.„' uses the StrTok routine from the quickbasic example program Token.bas„' for tokenizing the command$„' Can't be used with QBasic because QBasic doesnt support Command$„'„' $INCLUDE: 'QB.BI'„DECLARE SUB READER (FILE$)„DECLARE SUB BCKGND ()„DECLARE SUB WIN (X1!, Y1!, X2!, Y2!, A$)„DECLARE FUNCTION StrTok$ (Source$, Delimiters$)„DECLARE SUB EXITWITHERRLEVEL ALIAS "_EXIT" (N AS INTEGER)„DIM TOK$(10)„IF COMMAND$ <> "" THEN„P$ = COMMAND$„DELM$ = " ,;:()?" + CHR$(9) + CHR$(34)„TOKN$ = StrTok$(P$, DELM$)„WHILE TOKN$ <> ""„   TOK$(I) = TOKN$„   I = I + 1„   TOKN$ = StrTok$("", DELM$)„WEND„FOR I = 0 TO 10„TOK$(0) = UCASE$(LTRIM$(RTRIM$(TOK$(0))))„NEXT I„SELECT CASE TOK$(0)„CASE "BCKGND"„BCKGND„CASE "COLOR"„COLOR VAL(TOK$(1)), VAL(TOK$(2))„LOCATE 1, 1: PRINT„CASE "WIN"„WIN VAL(TOK$(1)), VAL(TOK$(2)), VAL(TOK$(3)), VAL(TOK$(4)), TOK$(5)„CASE "PROGRESS"„LOCATE VAL(TOK$(1)), VAL(TOK$(2)): PRINT STRING$(VAL(TOK$(3)) / 10, 219)„CASE "LOCATE"„LOCATE VAL(TOK$(1)), VAL(TOK$(2))„CASE "SELECTDRIVE"„WIN 20, 5, 40, 11, "Select Drive"„DO„I$ = INKEY$„IF I$ = CHR$(0) + CHR$(80) THEN Y% = Y% + 1„IF I$ = CHR$(0) + CHR$(72) THEN Y% = Y% - 1„IF I$ = CHR$(13) THEN EXIT DO„IF Y% = 0 THEN COLOR 15, 1 ELSE COLOR 7, 0„LOCATE 6, 21: PRINT "         A:        "„IF Y% = 1 THEN COLOR 15, 1 ELSE COLOR 7, 0„LOCATE 7, 21: PRINT "         B:        "„IF Y% = 2 THEN COLOR 15, 1 ELSE COLOR 7, 0„LOCATE 8, 21: PRINT "         C:        "„IF Y% = 3 THEN COLOR 15, 1 ELSE COLOR 7, 0„LOCATE 9, 21: PRINT "         D:        "„IF Y% = 4 THEN COLOR 15, 1 ELSE COLOR 7, 0„LOCATE 10, 21: PRINT "         E:        "„LOOP„EXITWITHERRLEVEL Y%„CASE "READER"„READER TOK$(1)„END SELECT„ELSE„PRINT "±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±";„PRINT "±±’ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ∏±±";„PRINT "±±≥ Batch Procedures - 1996 Edward Blake                                     ≥±±";„PRINT "±±√ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ[Commands]ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±";„PRINT "±±≥Win x1 y1 x2 y2 title (note: no parameters are optional except title)     ≥±±";„PRINT "±±≥bckgnd (note: all parameters are ignored)                                 ≥±±";„PRINT "±±≥color num1 [num2] (note: default is 0 for all parameters!!)               ≥±±";„PRINT "±±≥Progress x1 y1 value                                                      ≥±±";„PRINT "±±≥selectdrive (note: will return a errorlevel 0=A 1=B 2=C 3=D 4=E,only A-E) ≥±±";„PRINT "±±≥locate x1 y1 (use echo for displaying text)                               ≥±±";„PRINT "±±≥Reader filename (must have the extension)                                 ≥±±";„PRINT "±±‘ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕæ±±";„PRINT "±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±";„END IF„„SUB BCKGND„FOR I = 1 TO 24„LOCATE I, 1: PRINT STRING$(80, 177);„NEXT I„LOCATE 25, 1: PRINT STRING$(80, 177);„END SUB„„SUB READER (FILE$)„DIM FILEC$(500)„OPEN FILE$ FOR INPUT AS #1„DO UNTIL EOF(1)„INPUT #1, FILEC$(I)„I = I + 1„LOOP„CLOSE #1„COLOR 7, 1„Y = -1„DO„I$ = INKEY$„IF I$ = CHR$(0) + CHR$(80) THEN Y = Y + 1„IF I$ = CHR$(0) + CHR$(72) THEN Y = Y - 1„IF I$ = CHR$(27) THEN EXIT DO„IF Y < -1 THEN Y = -1„IF Y > 474 THEN Y = 474„FOR I = 1 TO 25„LOCATE I, 1, 0: PRINT FILEC$(I + Y) + STRING$(80 - (LEN(FILEC$(I + Y))), 32);„NEXT I„LOOP„COLOR 7, 0„CLS„END SUB„„FUNCTION StrTok$ (Srce$, Delim$)„STATIC Start%, SaveStr$„„   ' If first call, make a copy of the string.„   IF Srce$ <> "" THEN„      Start% = 1: SaveStr$ = Srce$„   END IF„„   BegPos% = Start%: Ln% = LEN(SaveStr$)„   ' Look for start of a token (character that isn't delimiter).„   WHILE BegPos% <= Ln% AND INSTR(Delim$, MID$(SaveStr$, BegPos%, 1)) <> 0„      BegPos% = BegPos% + 1„   WEND„   ' Test for token start found.„   IF BegPos% > Ln% THEN„      StrTok$ = "": EXIT FUNCTION„   END IF„   ' Find the end of the token.„   EndPos% = BegPos%„   WHILE EndPos% <= Ln% AND INSTR(Delim$, MID$(SaveStr$, EndPos%, 1)) = 0„      EndPos% = EndPos% + 1„   WEND„   StrTok$ = MID$(SaveStr$, BegPos%, EndPos% - BegPos%)„   ' Set starting point for search for next token.„   Start% = EndPos%„„END FUNCTION„„SUB WIN (X1, Y1, X2, Y2, A$)„FOR I = Y1 TO Y2„LOCATE I, X1: PRINT STRING$(X2 - X1, 32);„NEXT I„LOCATE Y1, X1 + 1: PRINT STRING$(X2 - X1 - 1, 196);„LOCATE Y2, X1 + 1: PRINT STRING$(X2 - X1 - 1, 196);„FOR I = Y1 + 1 TO Y2 - 1„LOCATE I, X1: PRINT CHR$(179);„LOCATE I, X2: PRINT CHR$(179);„NEXT I„LOCATE Y1, X1: PRINT CHR$(218);„LOCATE Y1, X2: PRINT CHR$(191);„LOCATE Y2, X1: PRINT CHR$(192);„LOCATE Y2, X2: PRINT CHR$(217);„IF A$ <> "" THEN„LOCATE Y1, ((X2 + X1) / 2) - ((LEN(A$) + 2) / 2): PRINT " " + A$ + " "„END IF„END SUB„Joe Negron                     FILE HANDLES                   FidoNet QUIK_BAS Echo          07-15-96 (21:44)       QB, PDS                56   1745     HANDLES.BAS '> In the CONFIG.SYS file, put the line FILES=20, or however„'> many you need and your version of DOS will tolerate.„„'No, it's not quite that simple.  The FILES directive in CONFIG.SYS„'specifies the maximum number of file handles the *system* (not program)„'will allow.  But, that does not mean that a particular program will be„'able to open that many files simultaneously.„„'The .EXE's PSP has a 20 byte file handle table (which leaves only 15 for„'your program since DOS uses 5 file handles).  The FUNCTION below,„'SetMaxFiles%(), calls a DOS interrupt which points the file handle table„'pointer to a larger area of memory.„„'SETMEM() is needed because, by default, BASIC grabs all available„'memory.  Passing SETMEM() a negative value tells BASIC to give up that„'much memory (in this case, 384 bytes is enough for at least 100 file„'handles).„„DEFINT A-Z„„'$INCLUDE: 'qb.bi'„„DECLARE FUNCTION SetMaxFiles% (NumFiles%)„„X% = SetMaxFiles% (100)„„FOR I% = 1 TO 100„   Num$ = MID$(STR$(I%), 2)„   OPEN STRING$(8 - LEN(Num$), "0") + Num$ + ".dat" FOR OUTPUT AS #I%„NEXT I%„„CLOSE„END„„'***********************************************************************„'* FUNCTION SetMaxFiles%„'*„'* PURPOSE„'*    Uses DOS ISR 21H, Function 67H (Set Maximum Handle Count) to set„'*    the maximum number of handles.„'***********************************************************************„FUNCTION SetMaxFiles% (NumFiles%) STATIC„   DIM Regs AS RegType„„   X& = SETMEM(-384)„   Regs.ax = &H6700„   Regs.bx = NumFiles%„„   Interrupt &H21, Regs, Regs„„   IF (Regs.flags AND 1) = 1 THEN„      SetMaxFiles% = Regs.ax                 'Error number„   ELSE„      SetMaxFiles% = 0„   END IF„END FUNCTION„Ronald Kas                     READING FILES FROM DIRECTORY   FidoNet QUIK_BAS Echo          08-16-96 (20:11)       QB, QBasic, PDS        76   2533     READFILE.BAS' > Does anyone know how to get the list(s) of files in a certian„' > driectory?? Without using the shell "dir" command?? can you use the„' > bois absolute disk read to read the fat table??  I know there are„' > simpler ways to do this, but I am wondering how the DIR command does„' > it... Such as to write my own, with out ANY shelling....„„' It is not so easy, but it can surely be done.„' You have to use an Interrupt to get the DTA of a file.„' Here is an exemple (I don't know if it works in QuickBasic, but I know„' it works in Qbasic. So if it doesn't work in QuickBasic, try it in„' Qbasic.)„„DECLARE SUB ReadFiles (pad$, masker$, Bestanden$(), BestLengte&(), BestAantal%)„DECLARE SUB ReadData ()„DECLARE FUNCTION Interr% (num%, AX%, BX%, CX%, DX%)„DIM Bestanden$(200), BestLengte&(200)„DIM SHARED MS%(30)„CLS„ReadData„ReadFiles "", "*.*", Bestanden$(), BestLengte&(), BestAantal%„PRINT„PRINT BestAantal%; "Bestandengevonden"„„FOR i = 1 TO BestAantal%„        PRINT Bestanden$(i), BestLengte&(i)„        PRINT ,„NEXT i„PRINT„„MS.Data:„        DATA 55,8b,ec,56,57„        DATA 8b,76,06,8b,14„        DATA 8b,76,08,8b,0c„        DATA 8b,76,0a,8b,1c„        DATA 8b,76,0c,8b,04„        DATA cd,21„        DATA 8b,76,0c,89,04„        DATA 5f,5e,5d„        DATA ca,08,00„        DATA #„„FUNCTION Interr% (num%, AX%, BX%, CX%, DX%)„        IF MS%(0) = 0 THEN PRINT "FOUT": END„        DEF SEG = VARSEG(MS%(0))„        POKE VARPTR(MS%(0)) + 26, num%„„        CALL ABSOLUTE(AX%, BX%, CX%, DX%, VARPTR(MS%(0)))„        Interr% = AX%„END FUNCTION„„SUB ReadData„        RESTORE MS.Data„        DEF SEG = VARSEG(MS%(0))„        FOR i = 0 TO 99„                READ byt$„                IF byt$ = "#" THEN EXIT FOR„                POKE VARPTR(MS%(0)) + i, VAL("&H" + byt$)„        NEXT i„END SUB„„SUB ReadFiles (pad$, masker$, Bestanden$(), BestLengte&(), BestAantal%)„        DTA$ = STRING$(80, " ")„        AX% = Interr%(&H21, &H1A00, 0, 0, SADD(DTA$))„        BestAantal% = 0„        FileName$ = pad$ + masker$ + CHR$(0)„        AX% = Interr%(&H21, &H4E00, 0, 32, SADD(FileName$))„„        WHILE AX% < 18„                f$ = MID$(DTA$, 31, 12)„                IF INSTR(f$, CHR$(0)) THEN f$ = LEFT$(f$, INSTR(f$, CHR$(0)) - 1)„                BestAantal% = BestAantal% + 1„                Bestanden$(BestAantal%) = f$„                BestLengte&(BestAantal%) = CVL(MID$(DTA$, 27, 4))„                AX% = Interr%(&H21, &H4F00, 0, 0, 0)„        WEND„END SUB„Alvin Williams                 DIRECTORY LISTER               jw32@gnn.com                   10-17-96 (16:56)       QB, PDS                883  26361    DIRLIST.BAS DECLARE SUB Help ()„' DirLister.. (C) WASC. 1994.  See legal-release below„' internet: LATEAGAIN@DELPHI.COM„„' DirLister is a Subroutine to display and navigate through directories in„' multiple columns and pages. I wrote it because i can't stand scrolling„' pick lists and it's similar to a commercial product i use a lot.„'„' You may change the....„'  ..number of columns, number of rows , starting screen row and„' starting screen column. See the line...„'***USER VARIABLES***„' ...in the ListDir sub.„'„' Since PDS's DIR$ function won't return a Directory (duh!)„' and QB dosn't have any DIR$ function, you will„' have to load a library with the Interrupt call's.„' ie:„'          qb listdir / l c:\qb45\qb.qlb„'     or   qbx listdir /l c:\bc7\libs\qbx.qlb    for PDS 7.1„' Since more people seem to have QB4.5 than PDS, i've re-coded this to„' run as QB4.5 compatable.„'„'  PDS users need to swap the lines...„'           'Regs.ds = SSEG(spec$)   'PDS 7.1„'           Regs.ds = VARSEG(spec$)  'QB4.5„' ..in FUNCTION qbdir$()„' ..or not, depending on farstring usage.„'„' ...also the qbcurdir$() function can be removed and replaced„' with the PDS func, CURDIR$.„'„' MONO and HERC users need to redo all the COLOR statements.„'„'  The source code to DirLister is made available to readers of the„' All Basic Code Packets of ABC only.„' Any other distribution of the source code is prohibited.„' You may use/include/sell the compiled or 'Binary' version in anyway you„'see fit.„„„„„DEFINT A-Z„DECLARE SUB DirLister (weAlreadyDidItYN%, thisfile%, mask$, dr$, tag%, dircnt%, numfiles%)„DECLARE SUB mainInput (prmpt$, cmdm2$, mode%, modet%)„DECLARE FUNCTION qbdir$ (mode%, spec$, a%)„DECLARE FUNCTION qbcurdir$ ()„„'„'$DYNAMIC„'if using qbx.bi or qb.bi, you shouldn't need this...„TYPE RegTypeX„ ax AS INTEGER„ bx AS INTEGER„ cx AS INTEGER„ dx AS INTEGER„ bp AS INTEGER„ si AS INTEGER„ di AS INTEGER„ flags AS INTEGER„ ds AS INTEGER„ es AS INTEGER„END TYPE„' Data transfer Area, we need this and it has to be shared„TYPE dta0„ DTAmisc AS STRING * 21„ Attr AS STRING * 1    ' this.....„ Time AS INTEGER„ Date AS INTEGER„ Size AS LONG„ filename  AS STRING * 13  '..and this, are all we really need„END TYPE„DECLARE SUB InterruptX (Intnum, InRegs AS RegTypeX, OutRegs AS RegTypeX)„„DIM SHARED regs AS RegTypeX„DIM SHARED buffer AS dta0„„DIM SHARED MaxDirEntry AS INTEGER„„'note: if you only want to return 1 file at a time, then this„' wouldn't need to be SHARED. You could REDIM it as necessary in the„' listdir() sub and erase it as needed. Rework the parameters to listdir()„' so that it returns the file name.„DIM SHARED filename$(1024)  'dir and file names„DIM SHARED fis%(1024)      'file-is%  root=1 dir=2 file=3 tagged file=6„„CALL Help„mask$ = ""„orgdir$ = qbcurdir$ ' QB.45„'orgdir$ = CURDIR$   'PDS 7.1„CLS„DO„  IF mask$ = "" THEN   ' if user reset mask$ we don't want to mess with it„    mask$ = "*.*"„  END IF„  CLS„  CALL DirLister(weAlreadyDidItYN%, thisfile%, mask$, cd$, tag%, dircnt%, numfiles%)„  IF thisfile% = 0 THEN  'user pressed <Esc>, quit program„    CLS„    exitLOOPflag% = 1„  ELSE„   'if the select file is a directory... change to it„   IF fis%(thisfile%) = 2 OR fis%(thisfile%) = 1 THEN„    'strip arrow and space..2 char„    IF fis%(thisfile%) = 2 THEN„      l% = LEN(filename$(thisfile%))„      IF LEN(cd$) = 3 THEN   'in root  'c:\'„	m$ = ""„      ELSE    'in a dir 'C:\THISDIR'  need a '\' on the end„	m$ = "\"„      END IF„	s$ = cd$ + m$ + RIGHT$(filename$(thisfile%), l% - 2)„    ELSE„       s$ = ".."„    END IF„	CHDIR s$„	weAlreadyDidItYN% = 0  'new dir„	numfiles% = 0„	dircnt% = 0„   ELSE„  „    PRINT "You selected: ";„   IF tag% = 0 THEN„    PRINT filename$(thisfile%)„   ELSE„     PRINT„     FOR i% = dircnt% TO numfiles%„      IF fis%(i%) = 6 THEN PRINT filename$(i%)„     NEXT i%„   END IF„    PRINT "<Space bar> to see Directory again. "„    PRINT "<Esc> or <Q> to quit."„   „    mainInput "", k$, 1, mt%„    IF mt% = 27 THEN k$ = "Q"„    SELECT CASE k$„    'put any routines to process files here„    ' RUN, SHELL, ZIP, DELETE, etc.„    CASE "Q"   'Quit„      exitLOOPflag% = 1„    END SELECT„   END IF„  END IF„LOOP UNTIL exitLOOPflag% = 1„„'clean up and exit„IF Xhere% <> 1 THEN ' exit where we started„ CHDIR orgdir$„END IF„CLS„CLOSE„END„„REM $STATIC„SUB DirLister (weAlreadyDidItYN%, thisfile%, mask$, dr$, tag%, dircnt%, numfiles%)„' DirLister.. (C) WASC. 1994.„' LATEAGAIN@DELPHI.COM„„STATIC filecnt%  '<--save this for next go around„DIM morep$(4)    '<--hold our Page Up , Page Down or both prompt„'set view window to 1-22..put commands and messages 23 to 25„theBIGloopEXIT% = 0„DO  '<---------theBIGloop„VIEW PRINT 1 TO 24„„    IF weAlreadyDidItYN% = 0 THEN   'if we havn't done this before„	  weAlreadyDidItYN% = 1     'well we're gonna do it„	  filecnt% = 0  ' zero this because it's static„	  ' now load sub-dir's„	     dr$ = qbcurdir$  ' QB.45„	     'dr$ = CURDIR$   'PDS 7.1„	     drive$ = LEFT$(dr$, 2)        'Get the current drive.„	     null$ = qbdir$(0, "", 24)„	     d$ = qbdir$(1, "*.*", 16)„		IF d$ <> "" THEN„		   ef% = 0„		   DO„		      GOSUB doname„		      d$ = qbdir$(2, "*.*", 16)„		      IF d$ = "" THEN ef% = 1„		    LOOP UNTIL ef% = 1„		END IF„	  'now sort dirs„	  filecnt% = dircnt%„	  sortStart% = 1: sortend% = filecnt%„	  GOSUB GSsortfname         'change to CALL QuickSort for speed„	  'z$ = DIR$(mask$)    'PDS 7.1„	  z$ = qbdir$(1, mask$, 32)„	  IF z$ <> "" THEN         ' if that worked try for more„	    ef0% = 0: nomore% = 0„„	    DO„	     IF filecnt% >= 1024 THEN nomore% = 1     'too many files„	     IF nomore% = 0 THEN                     'still going??„	       filecnt% = filecnt% + 1„	       fis%(filecnt%) = 3 'file„	       filename$(filecnt%) = z$„	       'z$ = DIR$  'PDS 7.1„	       z$ = qbdir$(2, mask$, 32)„	       IF z$ = "" THEN nomore% = 1    'last one„	     ELSE                             'no„	       ef0% = 1                       ' set loop exit„	     END IF„	    LOOP UNTIL ef0% = 1„„	  ELSE    'no files„	   IF filecnt% = 0 THEN 'no dirs either..must have problems„	    LOCATE 1, 1„	    PRINT "No files matching "; mask$; " where found."„	    'wait for a keypress„	    mainInput "", k$, 1, mt%„	    VIEW PRINT 1 TO 24„	    EXIT SUB„	   END IF„	  END IF„	  'sort files„	  sortStart% = dircnt% + 1: sortend% = filecnt%„	  GOSUB GSsortfname„ END IF  'end of wealreadygotitYN%„„ 'settings for pgdown page up status and display prompt„ morep$(0) = "No more files. "„ morep$(1) = "More Files.. Press <Page Down> to show. "„ morep$(2) = "More Files.. Press <Page Up> to show. "„ morep$(3) = "More Files.. Press <Page Up> or <Page Down> to show. "„ l3$ = "Use <Space bar> to tag files. <F2> to change mask(*.*) <F1>=Help <Esc>=Quit "„ l% = LEN(l3$): l3$ = l3$ + SPACE$(80 - l%)„„'show files in dir„ 'filename$() is 12 char wide„ divider$ = " " + CHR$(179) + " "        ' do string work once„ 'divider$ is 3 char wide..so.. fwidth% can't be less than 15.„ '***USER VARIABLES***   change as needed„ fwidth% = 15         'make sure this fits num cols„ StartRow% = 3:„ StartCol% = 2        '„ numRowsIncol% = 20  '***set this anywhere from 2 to 24„		     ' just make sure it fits the view print window„ numcols% = 5         'cant be more than 5 or less than 1„ '*****************„„ virtRow% = numRowsIncol% + (StartRow% - 1)„ wedidcnt% = 0„ hirow% = StartRow%: hicol% = StartCol% 'start out at first file„ oldhirow% = hirow%: oldhicol% = hicol%„ thisfile% = 1: oldthisfile% = 1        'set ptr to the first file„ index% = 0                             'for multiple pages ie?:page 2 index=132„ oldindex% = 0„ wedidcnt% = 0„ oldwedidcnt% = 0„ numOnScreen% = numcols% * numRowsIncol%      'ie: 110= (22 rows *  5 col )„ numFullpages% = filecnt% \ numOnScreen%   'use for <home> <end>„ numextra% = filecnt% MOD numOnScreen%„ dirpage% = 1„ IF LEN(dr$) = 3 THEN  'faster than  mid$(„  k$ = ""„ ELSE„  k$ = "\"„ END IF„„ numf$ = STR$(filecnt% - dircnt%) + "-Files " + STR$(dircnt%) + "-Director"„ IF dircnt% = 1 THEN„   numf$ = numf$ + "y"  'little grammer never hurts„ ELSE„  numf$ = numf$ + "ies"„ END IF„ „ l% = LEN(numf$)„ IF l% <= 80 THEN     'make the line fit the screen nicely„   numf$ = numf$ + SPACE$(80 - l%)„ ELSE„   numf$ = RIGHT$(numf$, 80)„ END IF„„ title$ = "Dir: " + dr$ + k$ + mask$„ l% = LEN(title$)„ IF l% <= 80 THEN„   title$ = title$ + SPACE$(80 - l%)„ ELSE„   title$ = RIGHT$(title$, 80)„ END IF„„exitLOOP2flag% = 0„DO„ LOCATE StartRow% - 1, 1:„ COLOR 0, 7„ LOCATE StartRow% - 1, 1: PRINT numf$;„ LOCATE StartRow% - 2, 1: PRINT title$;„ 'LOCATE StartRow% + numRowsInCol%, 1: PRINT SPACE$(80);„ COLOR 7, 0„„ pfLOOPexit% = 0„ column% = StartCol%          'start here 1,(0)„ rowcnt% = StartRow% - 1      ' we add 1 going in..set to (1 less) now„ oldindex% = index%„ oldthisfile% = thisfile%    ' if we are redrawing the page we need this„ wedidcnt% = oldwedidcnt%   'save to come back„„ DO   'ÕÕÕÕÕÕÕÕ  print filename LOOP   pfLOOPexit%„   wedidcnt% = wedidcnt% + 1„   rowcnt% = rowcnt% + 1          ' next row„   lastMaxRow% = rowcnt%          'save this„   maxcol% = column%              'save this for pgup, pgdown„   ' the last column may not have maxrow% 's„   LOCATE rowcnt%, column%:„   IF fis%(wedidcnt%) = 6 THEN  'if file is tagged, then print bold„     COLOR 15, 0„     PRINT filename$(wedidcnt%);„     COLOR 7, 0„   ELSE„     PRINT filename$(wedidcnt%);  'else just print„   END IF„   LOCATE rowcnt%, column% + fwidth% - 2: PRINT divider$;„   IF wedidcnt% = filecnt% THEN                     'we do em all??„     pfLOOPexit% = 1„   ELSE                        'no„    IF rowcnt% = (numRowsIncol% + StartRow% - 1) THEN  ' we fill up this col?„      column% = column% + fwidth%   ' move over 1 col (15 char)„      IF column% > (numcols% * fwidth%) THEN   'IF column% > 70 THEN we fill up screen  ?„	'yes , set up to do new screen„	pfLOOPexit% = 1„      ELSE                   'no ..just move over„	rowcnt% = StartRow% - 1„      END IF„„    END IF„  END IF„ LOOP UNTIL pfLOOPexit% = 1    'ÕÕÕÕÕÕÕÕprint filname LOOP  pfLOOPexit„'„„ 'figure out and  set more%, page up and page down flags„ IF wedidcnt% < filecnt% THEN„   IF wedidcnt% > numOnScreen% THEN  'if wedicnt% >110 but < filecnt%„    'we are in the middle„     more% = 3:   pgupok% = 1: pgdwnok% = 1   'next and previous pages exist„   ELSE„     more% = 1: pgupok% = 0: pgdwnok% = 1    ' just next pages exist„   END IF„ ELSE„   IF wedidcnt% > numOnScreen% THEN  'we are equal to file cnt,„   'but previous pages exist„     more% = 2: pgupok% = 1: pgdwnok% = 0  'so we show next pages exist but no previous„   ELSE         ' no previouspage, no next page..so„     more% = 0:  pgupok% = 0: pgdwnok% = 0    'no more files„   END IF„ END IF„„ COLOR 0, 7„ LOCATE StartRow% + numRowsIncol%, 1„ k$ = " Use arrow keys to move. " + morep$(more%)„ l% = LEN(k$): k$ = k$ + SPACE$(80 - l%)„ PRINT k$;„ LOCATE StartRow% + numRowsIncol% + 1, 1„ PRINT l3$;„ COLOR 7, 0„„ keyLOOPexit% = 0„ DO  'ÕÕÕÕÕÕÕÕKEY LOOP„      'do this to keep from scrolling into a blank spot„      ' in col one of the next page„     IF maxcol% = StartCol% THEN 'short 1 col page trap for right arrow„	IF hirow% > lastMaxRow% THEN„	  hirow% = lastMaxRow%: oldhirow% = hirow%„	  'reclac thsifile%, save oldThisFile%„	  GOSUB GScalcThisfile„	  oldthisfile% = thisfile%  'reset this„	END IF„     END IF„„       ' print old- location in plain color ie: un-highlite it„       LOCATE oldhirow%, oldhicol%:„	IF fis%(oldthisfile%) = 6 THEN 'its tagged„	  COLOR 15, 0„	  PRINT filename$(oldthisfile%);„	  COLOR 7, 0„	ELSE 'it aint tagged„	  PRINT filename$(oldthisfile%);„	END IF„       ' high-lite current one in different color„       LOCATE hirow%, hicol%:„       IF fis%(thisfile%) = 6 THEN 'its tagged„	 COLOR 15, 4„       ELSE  'no tag„	 COLOR 0, 4„       END IF„	 PRINT filename$(thisfile%);„       COLOR 7, 0      'reset to old colors„„       mainInput "", k$, 1, mt%          ' get one keypress„       ' mt% contains the keycode„	IF k$ = CHR$(13) THEN mt% = 13„	oldhirow% = hirow%: oldhicol% = hicol%„„	SELECT CASE mt%„	CASE 59 'F1=help„	   CALL Help„	   CLS„	     keyLOOPexit% = 1   'set for inner loop exit so we can„	     ' redraw the screen„	CASE 83   'delete„	 'confirm users choice„	 'kill file„	 'redo directory„	'CASE 1024  ' mouseMove„	'mouse routines deleted for space.„	'CASE 1025  'left mouse button click„	' fake <Enter>„	CASE 72  'up  arrow„	    IF hirow% = StartRow% THEN  'if first..start at bottom of previous col„		 hirow% = virtRow%„		 IF hicol% > StartRow% THEN    'move to prev column if not in first„		   hicol% = hicol% - fwidth%„		 ELSE                   ' move screen back if allowed„		  IF more% <> 0 AND more% <> 1 THEN„		   GOSUB GSdopageup„		  ELSE„		   hirow% = StartRow% 'stay put„		  END IF„		 END IF„	    ELSE„	       hirow% = hirow% - 1  'otherwise..go up one row„	    END IF„	CASE 80   'downarrrow%  '80„	    IF hirow% = virtRow% THEN  'if last, start at first row next column„	      IF hicol% < (numcols% - 1) * fwidth% THEN    'if not last col go to next„		 hirow% = StartRow%„		 hicol% = hicol% + fwidth%  '15„	      ELSE    'else last col move screen over if possible„		temp1% = hirow%  'save row„		GOSUB GSdopagedown„		IF wewentdown% = 0 THEN 'no good, save spot„		  hirow% = temp1%: oldhirow% = temp1%„		END IF„	      END IF„	    ELSE„	       hirow% = hirow% + 1    'otherwise go down one col„	    END IF„	CASE 75   'leftarrow%  '75     '„	    IF hicol% > StartCol% THEN„	      hicol% = hicol% - fwidth%    '15„	    ELSE  'see if another screen„	     IF more% <> 1 THEN 'keep from moving if on first page„	      'want to stay on same row for the new page..so...„	      'save old row%..because GSdopageup sets it to 22„	      temp1% = hirow%„	      GOSUB GSdopageup„	      'get our row back if it changed„		hirow% = temp1%: oldhirow% = temp1%„	     END IF„	    END IF„	CASE 77  'rightarrow„	    IF hicol% < (numcols% - 1) * fwidth% THEN„	       hicol% = hicol% + fwidth%„	    ELSE  'see if another screen„		'save old row%..because GSdopageup sets it to 1„		temp1% = hirow%„		GOSUB GSdopagedown„		'do this to keep from scrolling into a blank spot„		' in col one of the next page„		  hirow% = temp1%: oldhirow% = temp1%„	    END IF„	CASE 81   'page down„	   'if at top of page, set to bottom„	   IF (hicol% <> maxcol% AND hirow% <> lastMaxRow%) OR (hicol% = maxcol% AND hirow% <> lastMaxRow%) THEN„	     hicol% = maxcol%: hirow% = lastMaxRow%           ' |check for 1 col screen„	   ELSE  'set to next page„	      GOSUB GSdopagedown„	   END IF„	CASE 73    'page up„	   'if at bottom of page, set to top unless at top of page 1„	   ' in which case we stay put„	   IF NOT (hirow% = StartRow% AND hicol% = StartCol%) OR (hirow% = StartRow% AND hicol% = StartCol% AND (more% = 1 OR more% = 0)) THEN   'don't ask„	      hirow% = StartRow%: hicol% = StartCol%„	   ELSE  'do a new page„	    IF more% <> 1 THEN  'this is to keep hirow%=StartRow% ,hicol%=StartCol%„	    ' if we are at the first page„	      GOSUB GSdopageup„	    END IF„	   END IF„	CASE 71  '<Home>„	  ' just redraw the first page, set highlite„	  ' to the first file/directory„	  CLS : keyLOOPexit% = 1   'set to redraw„	  hicol% = StartCol%: hirow% = StartRow%„	  oldhicol% = hicol%: oldhirow% = hirow%„	  index% = 0: oldwedidcnt% = 0„	  thisfile% = 1: oldthisfile% = 1„	CASE 79 '<End>„	     CLS : keyLOOPexit% = 1   'set to redraw„	     IF numFullpages% >= 1 AND numextra% <> 0 THEN„	      ' cover's 1 page and half page„	       index% = numFullpages% * numOnScreen%„	     ELSE„	      IF numFullpages% <> 0 THEN„	       index% = filecnt% - (numFullpages% * numOnScreen%)„	      END IF„	     END IF„	       oldwedidcnt% = index%„	     IF numFullpages% = 0 THEN„	       temp2% = filecnt%„	     ELSE„	       temp2% = numextra%„	     END IF„	     thismanycol% = (temp2% \ numRowsIncol%)„	     IF (temp2% MOD numRowsIncol%) > 0 THEN„		thismanycol% = thismanycol% + 1„	     END IF„	     IF thismanycol% = 0 THEN„	       hicol% = StartCol%„	     ELSE„	       hicol% = ((thismanycol% * fwidth%) - fwidth%) + StartCol%„	     END IF„	     hirow% = ((numextra% MOD numRowsIncol%) - 1) + StartRow%„	     oldhirow% = hirow%: oldhicol% = hicol%„	CASE 27  '<Esc> exit and abort program„	    CLS„	    thisfile% = 0: tag% = 0          ' zero pointer to show no choice„	     EXIT SUB   '<----EXIT POINT„	CASE 13   '<Enter> 'when we exit, thisfile% is pointing to filename$(thisfile%)„	    numfiles% = filecnt%„	    CLS : keyLOOPexit% = 1: exitLOOP2flag% = 1„	    theBIGloopEXIT% = 1„	CASE 60  '<F2>  change mask$„	  'works better in a message box, but anyway...„	  LOCATE 23, 1: PRINT SPACE$(27);   'clean off screen line for input„	  LOCATE 23, 1: mainInput "Enter new mask ", mask$, 0, mt%„	  IF mask$ = "" THEN mask$ = "*.*"„	  CLS : keyLOOPexit% = 1: exitLOOP2flag% = 1„	  weAlreadyDidItYN% = 0: filecnt% = 0: dircnt% = 0„	CASE 320   'space bar..tag a file„	   'if fis%() is not a dir,„	    IF fis%(thisfile%) = 3 THEN„	      tag% = tag% + 1„	      fis%(thisfile%) = 6„	    ELSE„	      IF fis%(thisfile%) = 6 THEN„		tag% = tag% - 1„		fis%(thisfile%) = 3„	      END IF„	    END IF„	END SELECT„	„	' calculate new file pointer„	GOSUB GScalcThisfile„„  LOOP UNTIL keyLOOPexit% = 1   'ÕÕÕÕÕÕÕÕKEY LOOP„„LOOP UNTIL exitLOOP2flag% = 1„„LOOP UNTIL theBIGloopEXIT% = 1„„'clean up„VIEW PRINT 1 TO 24„EXIT SUB„„„„'SUB routines„„GSdopagedown:„       wewentdown% = 0           'set to default ..no„       IF pgdwnok% = 1 THEN      'if ok to go down„	     CLS :    wewentdown% = 1     'show we went down„	     oldwedidcnt% = wedidcnt%„	     oldindex% = index%„	     index% = wedidcnt%„	     hirow% = StartRow%: hicol% = StartCol%  'start out at first file on„					   ' screen  ie:LOCATE 1, 1„	     oldhirow% = hirow%: oldhicol% = hicol%  'preset old Locations„	     thisfile% = index% + 1:       ' set pointer„	     IF thisfile% > filecnt% THEN thisfile% = filecnt%„	     oldthisfile% = thisfile%               'hilight the first file„	     keyLOOPexit% = 1   'set for inner loop exit so we can„	     ' redraw the screen„      END IF„RETURN„GSdopageup:„  wewentup% = 0    'set to default„  IF pgupok% = 1 THEN„    wewentup% = 1   'show we went up„    CLS„    index% = index% - numOnScreen%     'bump the index back„    oldindex% = oldindex% - numOnScreen%„    oldwedidcnt% = oldwedidcnt% - numOnScreen%„   'start out at last position on page„   'since we are going up, the last position has to be ...„    hirow% = virtRow%: hicol% = ((numcols% * fwidth%) - fwidth%) + StartCol%„    oldhirow% = hirow%: oldhicol% = hicol%„    thisfile% = index% + numOnScreen%   '110„    oldthisfile% = thisfile%      'point to the first file„    keyLOOPexit% = 1            'set for inner loop exit„  END IF„„RETURN„„„GSsortfname:„' create a Quicksort SUB for speed„' be sure and set STACK for enough room„' for recursive calls on 1024 files„' mean while.... plain old shell sort„' courtesy of MicroSoft(C) examples„ 'nothing new here...just make sure to sort fis%() along with filename$()„noSwitch% = 0„Offset = (sortend% - sortStart%) \ 2„DO WHILE Offset > 0„Limit = sortend% - Offset„DO„Switch = noSwitch%„FOR temp1% = sortStart% TO Limit„IF filename$(temp1%) > filename$(temp1% + Offset) THEN„SWAP filename$(temp1%), filename$(temp1% + Offset)„SWAP fis%(temp1%), fis%(temp1% + Offset)  'swap file is„Switch = temp1%„END IF„NEXT temp1%„Limit = Switch - Offset„LOOP WHILE Switch„Offset = Offset \ 2„LOOP„„RETURN„„GScalcThisfile:„ ' save oldThisFile% to„  oldthisfile% = thisfile%                 ' save old file pointer„  thisfile% = index% + (((hicol% \ fwidth%) * 1) * numRowsIncol%) + (hirow% - (StartRow% - 1))„  'the above line is equal to„  ' SELECT CASE hicol%„  ' CASE StartCol% 'column is 1„  '    thisfile% = index% + (0 * numRowsInCol%) + (hirow% - (StartRow% - 1))„  ' CASE fwidth% + startCol% 'column 2„  '    thisfile% = index% + (1 * numRowsInCol%) + (hirow% - (StartRow% - 1))           'x1=0 + hilited row + 22„  '....etc„  ' if user tries to go to a blank area of the screen„  ' just stay where we were .. see trap for short 1 col page„  IF thisfile% > filecnt% THEN„     thisfile% = oldthisfile%„     hirow% = oldhirow%: hicol% = oldhicol%„  END IF„„RETURN„„doname:„   SELECT CASE d$„   CASE "."„      'do nothing„   CASE ".."„      dircnt% = dircnt% + 1„      filename$(dircnt%) = CHR$(24) + " " + d$'up arrow„      fis%(dircnt%) = 1   'root„   CASE ELSE„     dircnt% = dircnt% + 1„     filename$(dircnt%) = CHR$(25) + " " + d$'down„     fis%(dircnt%) = 2    'dir„   END SELECT„RETURN„„END SUB„„SUB Help„'„CLS„PRINT "**You can change this to use a window or something more upscale.**"„PRINT "**Just work it into your screen/window/setup**"„PRINT "Key usage...."„PRINT "<Enter> to change to directory or pick file."„PRINT "<F2> to change mask (*.*)"„PRINT "<Arrow Keys> to move from file to file or to next page."„PRINT "<Page Up> Go to top of current page or to previous page"„PRINT "<Page Down> Go to bottom of current page or to next page"„PRINT "<Home> Go to current root directory"„PRINT "<End> Go to last file on list"„PRINT "<Space Bar> Tags files in current directory"„PRINT "<Esc> Quit program"„PRINT "<F1> Help"„PRINT„mainInput "Press any key to continue...", k$, 1, mt%„„„END SUB„„DEFSNG A-Z„SUB mainInput (prmpt$, cmdm2$, mode%, modet%)„modet% = 0„STATIC OOldrow%, Ooldcol%, cmdo$, otc%, obc%„„„PRINT prmpt$;    'print prompt„StartPos% = POS(0)„STATIC cmdM$„SELECT CASE mode%„CASE 1                          'GET 1 CHARACTER AND RETURN„cmdM$ = "": inef% = 0„DO„ kk$ = INKEY$„ l% = LEN(kk$)„ IF l% > 0 THEN„  inef% = 1„  IF kk$ = CHR$(27) THEN„    modet% = 27„  ELSE„     IF l% > 1 THEN„	 c$ = RIGHT$(kk$, 1)„	 IF c$ <> "" THEN„	  scan% = ASC(c$)„	  modet% = scan%„„	 END IF„     END IF„  END IF„ END IF„LOOP UNTIL inef% = 1„cmdm2$ = UCASE$(kk$)„IF cmdm2$ = CHR$(32) THEN modet% = 320„CASE ELSE   'input a UCASE$(string$) and exit when CR,Esc or a Func key is hit„ LOCATE , , 1„ cmdM$ = "": inef% = 0„ GOSUB keyloop„ PRINT„ cmdm2$ = UCASE$(cmdM$)„ modet% = scan%„END SELECT„„EXIT SUB„„keyloop:„DO„ kk$ = INKEY$„ l% = LEN(kk$)„ IF l% > 0 THEN„  IF l% < 2 THEN„   a% = ASC(kk$)„   IF a% <> 13 THEN      'IF kk$ <> CHR$(13) THEN  <Enter>„     IF a% = 27 THEN     'IF kk$ = CHR$(27) THEN  <Esc>„       cmdm2$ = CHR$(27)„       modet% = 27„       EXIT SUB  '<---------exit point„     END IF„     IF a% = 8 THEN       'IF kk$ = CHR$(8) THEN  'BACK SPACE KEY„      l% = LEN(cmdM$)„      IF l% > 1 THEN 'no effect„	cmdM$ = MID$(cmdM$, 1, l% - 1)„      ELSE„	cmdM$ = ""„      END IF„      Currow% = CSRLIN: CurCol% = POS(0)„      IF CurCol% > StartPos% THEN  'locate cursor, go back one, print a space„       CurCol% = CurCol% - 1„       LOCATE Currow%, CurCol%„       PRINT " ";„       LOCATE Currow%, CurCol%„      END IF„     ELSE„      cmdM$ = cmdM$ + kk$„      PRINT kk$;„     END IF„   ELSE„     inef% = 1„     scan% = 13„   END IF„  ELSE 'its control characters or function key„	 c$ = RIGHT$(kk$, 1)„	 IF c$ <> "" THEN„	   scan% = ASC(c$)„	   inef% = 1„	 END IF„   END IF„  END IF„LOOP UNTIL inef% = 1„„„RETURN„END SUB„„DEFINT A-Z„FUNCTION qbcurdir$„' DirLister.. (C) WASC. 1994.„' LATEAGAIN@DELPHI.COM„  „   dbuffer$ = STRING$(65, CHR$(32))„   'see if drive is ready„  „   'get current drive„   regs.ax = &H1900„   CALL InterruptX(&H21, regs, regs)„   al% = regs.ax MOD 256„   c$ = CHR$(al% + 65) + ":\"    'A:=0 B:=1 C:=2 for prev INT„   'get directory„   drive% = al% + 1              'A:=1 B:=2 C:=3 for this INT„   regs.ax = &H4700„   regs.si = SADD(dbuffer$)„   regs.ds = VARSEG(dbuffer$)„   regs.dx = drive%„   CALL InterruptX(&H21, regs, regs)„   ecode% = regs.ax„  IF ecode% THEN„    zl% = INSTR(dbuffer$, CHR$(0))„    qbcurdir$ = c$ + LEFT$(dbuffer$, zl% - 1)„    dbuffer$ = ""„  ELSE„    qbcurdir$ = ""„    dbuffer$ = ""„  END IF„„  „END FUNCTION„„FUNCTION qbdir$ (mode%, spec$, a%)„ ' a%=32 for files  16 for directories„ ' a%=24 for normal files and dirs„ STATIC attrib%„ SELECT CASE mode%„ CASE 0„    'call with a%=24 for normanl files„    'Set DTA Buffer„    regs.ax = &H1A00„    regs.ds = VARSEG(buffer)„    regs.dx = VARPTR(buffer)„    CALL InterruptX(&H21, regs, regs)„    attrib = a%„ CASE 1„	   spec$ = spec$ + CHR$(0)„	   regs.ax = &H4E00„	   regs.cx = attrib%„	   'Regs.ds = SSEG(spec$)   'PDS 7.1„	   regs.ds = VARSEG(spec$)„	   regs.dx = SADD(spec$)„	   CALL InterruptX(&H21, regs, regs)„	   ecode% = regs.ax„       IF ecode THEN„	 qbdir$ = ""„       ELSE„	 IF ASC(buffer.Attr) = a% THEN„	   zl% = INSTR(buffer.filename, CHR$(0))„	   qbdir$ = LEFT$(buffer.filename, zl% - 1)„	 ELSE   'found a match to spec$ but not to attribute„	   'and we need to return something„	   'recursive call„	   f$ = qbdir$(2, spec$, a%)„	   qbdir$ = f$„	 END IF„       END IF„       EXIT FUNCTION„ CASE 2  'Find next file or dir„     DO„       regs.ax = &H4F00„       CALL InterruptX(&H21, regs, regs)„       ecode = regs.ax„       IF ecode THEN„	 qbdir$ = ""„	 EXIT FUNCTION„       ELSE„	IF ASC(buffer.Attr) = a% THEN„	  zl% = INSTR(buffer.filename, CHR$(0))„	  qbdir$ = LEFT$(buffer.filename, zl% - 1)„	  EXIT FUNCTION„	END IF„       END IF„     LOOP„ CASE 3  'Find next DIR only„     DO„       regs.ax = &H4F00„       CALL InterruptX(&H21, regs, regs)„       ecode = regs.ax„       IF ecode THEN„	   qbdir$ = ""„	   EXIT FUNCTION„       ELSE„	 IF ASC(buffer.Attr) = a% THEN„	   zl% = INSTR(buffer.filename, CHR$(0))„	   qbdir$ = LEFT$(buffer.filename, zl% - 1)„	   EXIT FUNCTION„	 END IF„       END IF„     LOOP„ END SELECT„EXIT FUNCTION„„„„END FUNCTION„Ben Kaashoek                   MISC. DETECTION ROUTINES       robertk@worldaccess.nl         10-28-96 (12:49)       QB, PDS                242  9576     DETECT.BAS  DEFINT A-Z                              'Use integers as default.„„REM $INCLUDE: 'qb.bi'                   'INTERRUPT include file in QB45„'REM $INCLUDE: 'qbx.bi'                  'INTERRUPT include file in QBX/PDS„„'The story:„' This little piece of code started out as a simple NDOS detection routine.„' Suddenly it became a "Why-Don't-I-Put-All-My-Detection-Routines-In-Here?"„' sort of program. Anyway. Hope you can use some of it.„' I will keep adding new detection routines to this file when I find others.„' So keep your eyes PEEKing:) for new detection stuff. There are loads„' more out there (and somewhere around here too).„' I tried to comment as much as possible. (Is there something like TOO much„' when you're commenting code?)„'„'                                                           BEN„'Resources:„' - Ralph Brown's Interrupt List. I think V43 (Get your hands on it)„'   A newer version will probably be released into the public domain.„' - Microsoft Windows V3.11 helpfile (Honest, it actually contained„'   something usefull. ;-) ).„' - NDOS helpfile.„„DECLARE SUB NDOSVersion (majVer%, minVer%)         'Works OK.„DECLARE SUB SMARTDRVInfo (Hits&, misses&, dirty&, majVer%, minVer%, HitRate%, oops%)„DECLARE SUB SMARTDRVSize (full%, current%, BytesPerElement!, windows%)„„DECLARE FUNCTION DetectANSI% ()„DECLARE FUNCTION DetectDOSKEY% ()„DECLARE FUNCTION DetectKSTACK% ()                  'Untested.„DECLARE FUNCTION DetectNDOS% ()                    'It detects my NDOS V7.0„DECLARE FUNCTION DetectNGUIDES% ()                 'Works OK.„DECLARE FUNCTION DetectNovellIPX% ()               'Untested.„DECLARE FUNCTION DetectSMARTDRV% ()                'Works OK.„DECLARE FUNCTION DetectXMS% ()                     'Works OK.„DECLARE FUNCTION PutKeysInKSTACK% (Keys$)          'Untested.„„DIM SHARED Inreg AS RegType, Outreg AS RegType„DIM SHARED InRegX AS RegTypeX, OutRegX AS RegTypeX„„'-------------------------- Begin demonstration ----------------------------„„CONST False = 0: True = NOT False       'Boolean constants.„„SCREEN 12: CLS : COLOR 7                'Test is independent of screenmode!„IF DetectNGUIDES THEN„ PRINT "Norton Guide is resident in memory"„ELSE„ PRINT "Norton Guide is not resident in memory"„END IF„„IF DetectNDOS THEN„ NDOSVersion Maj%, Min%„ PRINT "NDOS V"; LTRIM$(STR$(Maj%)); "."; LTRIM$(STR$(Min%)); " detected"„ELSE„ PRINT "NDOS not detected"„END IF„„IF DetectNovellIPX THEN„ PRINT "Novell Netware IPX driver detected"„ELSE„ PRINT "Novell Netware IPX driver not detected"„END IF„„IF DetectDOSKEY THEN„ PRINT "DOSKEY detected"„ELSE„ PRINT "DOSKEY not detected"„END IF„„IF DetectXMS THEN„ PRINT "V2.0+ XMS driver detected"„ELSE„ PRINT "V2.0+ XMS driver not detected"„END IF„„IF DetectKSTACK THEN„ PRINT "KSTACK.COM detected"„ELSE„ PRINT "KSTACK.COM not detected"„END IF„„IF DetectANSI THEN„ PRINT "ANSI.SYS detected"„ELSE„ PRINT "ANSI.SYS not detected"„END IF„„IF DetectSMARTDRV THEN„ SMARTDRVInfo Hits&, misses&, dirty&, majVer%, minVer%, HitRate%, oops%„ PRINT "SMARTDRV V"; LTRIM$(STR$(majVer)); "."; LTRIM$(STR$(minVer)); " detected"„ PRINT USING " √ƒ Cache hits   : #####"; Hits&„ PRINT USING " √ƒ Cache misses : #####"; misses&„ PRINT USING " √ƒ Dirty caches : #####"; dirty&„ PRINT USING " √ƒ Cache hitrate: ###%"; HitRate%„„ 'Notice how the hitrate only changes after disk activity.„ 'Why?, that's because the drive has become a SMART drive :-).„ 'Theoretically it should not exceed 100% (if it does you have a„ 'really smart one).„„ SMARTDRVSize full%, current%, BytesPerElement!, windows%„ DosSize& = current% * BytesPerElement!„ WinSize& = windows% * BytesPerElement!„ TotalSize& = full% * BytesPerElement!„ PRINT " ¿ƒ Cache sizes (bytes)"„ PRINT USING "     √ƒ DOS     = ########"; DosSize&„ PRINT USING "     √ƒ Windows = ########"; WinSize&„       PRINT "     ≥          ----------- +"„ PRINT USING "     ¿ƒ Total   = ########"; TotalSize&„ELSE„ PRINT "SMARTDRV not detected"„END IF„PRINT ""„COLOR 15„PRINT "Hope you can use this. Happy keyboard crunching !"„„DO: LOOP UNTIL INKEY$ <> ""             'Wait until a key is pressed.„COLOR 7                                 'Restore default MS-DOS colour.„SCREEN 0                                'Restore screen (else Win95 crashes HARD)„END                                     'Terminate program.„„'---------------------------- End demonstration ----------------------------„„FUNCTION DetectANSI„Inreg.AX = &H1A00                       'Function 1Ah, Subfunction 0h„CALL INTERRUPT(&H2F, Inreg, Outreg)     'Call DOS (Int 2Fh)„DetectANSI = 0                          'Assume it's not there„IF Outreg.AX \ 256 = &HFF THEN DetectANSI = -1„END FUNCTION„„FUNCTION DetectDOSKEY%„Inreg.AX = &H4800                       'Function 48h, Subfunction 0h„CALL INTERRUPT(&H2F, Inreg, Outreg)     'Call DOS (Int 2Fh)„DetectDOSKEY% = 0                       'Assume it's not there„IF Outreg.AX MOD 256 <> 0 THEN DetectDOSKEY% = -1„END FUNCTION„„FUNCTION DetectKSTACK„Inreg.AX = &HE44F                   'Function E4h, Subfunction 4Fh„Inreg.BX = 0„CALL INTERRUPT(&H2F, Inreg, Outreg) 'Call DOS (Int 2Fh)„DetectKSTACK = 0                    'Assume it's not there.„IF Outreg.AX = &H44EE THEN DetectKSTACK = -1„END FUNCTION„„FUNCTION DetectNDOS%„Inreg.AX = &HE44D                   'Function E4h, Subfunction 4Dh„CALL INTERRUPT(&H2F, Inreg, Outreg) 'Call DOS (Int 2Fh)„DetectNDOS = 0                      'Assume it's not there.„IF Outreg.AX = &H44EE THEN DetectNDOS = -1„END FUNCTION„„FUNCTION DetectNGUIDES%„Inreg.AX = &HF398                       'Function F3h, Subfunction 98h„CALL INTERRUPT(&H16, Inreg, Outreg)     'Call DOS (Int 16h)„DetectNGUIDES% = 0                      'Assume it's not there.„IF Outreg.AX = &H6A73 THEN DetectNGUIDES% = -1„END FUNCTION„„FUNCTION DetectNovellIPX%„'I haven't tested this routine because I don't have a network. Maybe in a few„'year's I can continue programming even when nature calls :-)„Inreg.AX = &H7A00                       'Function 7Ah, Subfunction 0h„CALL INTERRUPT(&H2F, Inreg, Outreg)     'Call DOS (Int 2Fh)„IF Outreg.AX MOD 256 = 0 THEN DetectNovellIPX% = 0„IF Outreg.AX MOD 256 = &HFF THEN DetectNovellIPX% = -1„END FUNCTION„„FUNCTION DetectSMARTDRV%„Inreg.AX = &H4A10                    'function 4Ah, Subfunction 10h„Inreg.BX = 0                         'Sorry, lost the info on this !„Inreg.CX = &HEBAB                    'Sorry, lost the info on this !„CALL INTERRUPT(&H2F, Inreg, Outreg)  'Call DOS (Int 2fh)„DetectSMARTDRV = 0                   'Assume it's not there.„IF Outreg.AX = &HBABE THEN DetectSMARTDRV = -1„END FUNCTION„„FUNCTION DetectXMS%„Inreg.AX = &H4300                       'Function 43h, Subfunction 0h„CALL INTERRUPT(&H2F, Inreg, Outreg)     'Call DOS (int 2Fh)„DetectXMS% = 0                          'Assume it's not there.„IF Outreg.AX MOD 256 = &H80 THEN DetectXMS% = -1„END FUNCTION„„SUB NDOSVersion (majVer%, minVer%)„Inreg.AX = &HE44D                       'Function E4h, Subfunction 4Dh„CALL INTERRUPT(&H2F, Inreg, Outreg)     'Call DOS (Int 2Fh)„majVer% = minVer% = 0                   'Return zeroes if NDOS not loaded.„IF Outreg.AX = &H44EE THEN              'Modify version if it's there.„ majVer% = Outreg.BX MOD 256            'Major version in register BL„ minVer% = Outreg.BX \ 256              'Minor version in register BH„END IF„END SUB„„FUNCTION PutKeysInKSTACK% (Keys$)„'If it doesn't work you may have to uncomment the line marked with "<---"„'and change the parameter of the VARSEG/SADD instruction.„'Many DOS functions require a Zero terminated string (ASCIIZ for short).„„'KeysZ$ = Keys$ + CHR$(0)              '<--- Uncomment this one„InRegX.AX = &HE44F                     'Function E4h, Sub-function 4Fh„InRegX.BX = 1„InRegX.CX = LEN(Keys$)                 'Number of keystrokes being passed.„InRegX.DS = VARSEG(Keys$)              'Segment of the keystroke string.„InRegX.DX = SADD(Keys$)                'Address of the keystroke string.„CALL INTERRUPTX(&H2F, InRegX, OutRegX) '| Int 2Fh„END FUNCTION„„SUB SMARTDRVInfo (Hits&, misses&, dirty&, majVer%, minVer%, HitRate%, oops%)„STATIC PrevHits&, PrevTotal&         'Keep data of previous call.„Inreg.AX = &H4A10                    'function 4Ah, subfunction 10h„Inreg.BX = 0„Inreg.CX = &HEBAB„CALL INTERRUPT(&H2F, Inreg, Outreg)  'Call DOS (int 2fh)„IF Outreg.AX = &HBABE THEN„ Hits& = Outreg.DX * &H100 + Outreg.BX„ misses& = Outreg.DI * &H100 + Outreg.SI„ dirty& = CLNG(Outreg.CX)„ majVer% = VAL(HEX$(Outreg.BP)) \ 100„ minVer% = VAL(HEX$(Outreg.BP)) - majVer * 100„ oops% = 0„ELSE„ oops% = -1„ EXIT SUB„END IF„„'Calculate the hitrate with the formula as found in Microsoft Windows help.„'Hit_rate = 100 * (CurrentHits - PreviousHits) / (CurrentTotal - PreviousTotal)„CurrTotal& = Hits& + misses& + dirty&„HitRate% = 100 * (Hits& - PrevHits&) / (CurrTotal& - PrevTotal&)„END SUB„„SUB SMARTDRVSize (full%, current%, BytesPerElement!, windows%)„Inreg.AX = &H4A10                     'function 4Ah, subfunction 10h„Inreg.BX = &H4„CALL INTERRUPT(&H2F, Inreg, Outreg)   'Call DOS (Int 2Fh)„full% = Outreg.AX                     'Size in elements of full sized cache„current% = Outreg.BX                  'Current size in elements„BytesPerElement! = Outreg.CX          'Size of one element in bytes„windows% = Outreg.DX                  'Number of elements under windows„END SUB„