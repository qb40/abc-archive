Victor Yiu                     SUPER HEX BROWSER              SUPER,HEX.BROWSER              07/95 (00:00)          ASM, QB, PDS           507  14233    BROWSER.BAS 'QB users must change all occurences of SSEG to VARSEG.„'„'Enjoy!  And I want to know if it feels SNAPPY on your machine!„„' ==================== Browser 1.0 =======================„' by Victor Yiu, July 1993.  Released into Public Domain.„'„'              *** LOAD WITH /AH SWITCH ***„' This program is a binary file viewer, in hex and ascii,„' made to look like Calvin French's HEXVIEW, PCTools' View,„' Norton's DiskEdit, and numerous others.  It uses my public-„' domain SuperHex library, written in optimized assembly -- so„' it is FAST!„'                      (to make EXE:)„'       BC BROWSER /O;„'       LINK /FARC /PACKC:64000 BROWSER+C:\QB\NOCOM,,,C:\QB\BCOM45+SUPERHEX;„'            ^ (include "/EX" if you won't use LZEXE or PKLITE)„'„' Compared to Clavin's HEXVIEW:„'   o  Mine can open files up to 128k„'   o  Mine is 5 million times faster (faster than PCTools or Norton)„'   o  Has a built-in text filter„'   o  Acceptable on an 4.77 MHz XT!„'   o  Compiles to only 25K with LZEXE or PKLITE!„'„' Next version will include search and editing features.„'„' Speed comparison (on a 10MHz XT)*:„'       Calvin French's HEXVIEW:   .55 K/sec„'             PCTool's 4.x Edit:     3 K/sec„'         Victor's SuperHEX (!):    20 K/sec   --->  WOW!„'„'  * I didn't do timing on my 486 because it was too darn fast!„'„' By the way -- try loading a file from the floppy -- it's fun!„' ============================================================„„DEFINT A-Z      ' $DYNAMIC„„CONST Block = 8192, PageSize = 16 * 21, LastDataLine = 23„CONST DataFG = 7, DataBG = 1, Attrib = DataFG + DataBG * 16„CONST False = 0, True = NOT False„„DECLARE SUB AdjustLastBytes (row%)„DECLARE SUB CheckPointer (Num&)„DECLARE SUB DrawInterface ()„DECLARE SUB DrawScreen ()„DECLARE SUB LoadFile (LOFile&)„DECLARE SUB PrintHex (Num&)„DECLARE SUB ShowHex (Posit&)„DECLARE FUNCTION GetAdapterSeg% ()„DECLARE FUNCTION Signed% (Num&)„„DECLARE SUB Scroll (BYVAL GoUp, BYVAL Attrib)„DECLARE SUB MemCopy (BYVAL SegFrom, BYVAL OffFrom, BYVAL SegTo, BYVAL OffTo, BYVAL Leng)„DECLARE SUB SuperHex (BYVAL VidSeg, BYVAL row, BYVAL OffsetHex, BYVAL OffsetASCii, BYVAL SEGMENT, BYVAL offset, BYVAL BackColor, BYVAL FilterOn)„' VidSeg     = Video segment of adapter (B800 for color, B000 for mono)„' Row        = Row to display data (1-25)„' OffsetHex  = Column to display the hex digits (1-)„' OffsetASCii= Column to display the characters themselves (1-)„' Segment    = Segment of source data„' Offset     = Offset of source data„' BackColor  = Background color in a packed byte:„'                (BackGround * 16) + ForeGround„„IF LEN(COMMAND$) = 0 THEN„    PRINT "Syntax:"„    PRINT "   BROWSER <filename>"„    END„END IF„„DIM SHARED VidSegment, Pointer&, LastBox, LOFile&, FilterOn„„OPEN COMMAND$ FOR BINARY AS #1„LOFile& = LOF(1)„IF (LOFile& + 3000 > FRE(-1)) OR (LOFile& > 131000) THEN PRINT "File too big.": END„IF LOFile& = 0 THEN CLOSE : PRINT COMMAND$; " does not exist.": KILL COMMAND$: END„„DIM SHARED Array&(LOFile& \ 4& + 4)„Pointer& = 0: LastBox = 4: Null$ = CHR$(0)„„CLS„VidSegment = GetAdapterSeg„DrawInterface„LOCATE 12, 33: COLOR 31, 3„PRINT " Loading file ... "; : COLOR 7„„LoadFile LOFile&„„IF LOFile& - 16 < PageSize THEN„    LOCATE 12, 33: COLOR , 1„    PRINT SPACE$(40);„END IF„„DrawScreen„DO„    DO: I$ = INKEY$„    LOOP UNTIL LEN(I$)„    IF LEN(I$) = 1 THEN I$ = UCASE$(I$)„„    SELECT CASE I$„        CASE Null$ + "Q", CHR$(13), " "   ' PageDown„            Pointer& = Pointer& + PageSize„            CheckPointer Pointer&„        CASE Null$ + "I"        ' PageUp„            Pointer& = Pointer& - PageSize„            CheckPointer Pointer&„        CASE Null$ + "P"        ' Down„            IF Pointer& + PageSize < LOFile& THEN„                Scroll 0, LastDataLine„                Pointer& = Pointer& + 16„                ShowHex Pointer&„„                Temp& = Pointer& + PageSize - 16„                LOCATE LastDataLine, 3: COLOR 14„                PrintHex Temp&„„                SuperHex VidSegment, LastDataLine, 10, 62, Signed(sseg(Array&(0)) + Temp& \ 16), VARPTR(Array&(0)), Attrib, FilterOn„                IF LOFile& - Temp& < 15 THEN AdjustLastBytes LastDataLine„            END IF„        CASE Null$ + "H"        ' Up„            IF Pointer& >= 16 THEN„                Scroll -1, LastDataLine„                Pointer& = Pointer& - 16„                ShowHex Pointer&„„                LOCATE 3, 3: COLOR 14„                PrintHex Pointer&„                SuperHex VidSegment, 3, 10, 62, Signed(sseg(Array&(0)) + Pointer& \ 16), VARPTR(Array&(0)), Attrib, FilterOn„            END IF„        CASE Null$ + "G"        ' Home„            Pointer& = 0„            DrawScreen„        CASE Null$ + "O"        ' End„            Pointer& = LOFile&„            CheckPointer Pointer&„        CASE "F"                ' toggle filter„            FilterOn = NOT FilterOn„            DrawScreen„„            LOCATE 25, 58: COLOR 4, 3„            IF FilterOn THEN PRINT CHR$(251);  ELSE PRINT " ";„        CASE ELSE„    END SELECT„LOOP UNTIL I$ = CHR$(27)„„COLOR 7, 0: CLS„PRINT "Thanks for trying Browser 1.0!"„PRINT„END„„REM $STATIC„SUB AdjustLastBytes (row)„„    Remov = 16 - (LOFile& AND 15)„    LOCATE row, 58 - Remov * 3„    PRINT SPACE$(Remov * 3 + 1);„    LOCATE , 78 - Remov„    PRINT SPACE$(Remov);„„END SUB„„SUB CheckPointer (Num&)„„IF Num& + PageSize - 15 > LOFile& THEN„    Num& = LOFile& + 15 - PageSize„END IF„„IF Num& < 0 THEN Num& = 0„DrawScreen„„END SUB„„SUB DrawInterface„„COLOR 14, 12„PRINT " Browser 1.0  ˛  by Victor Yiu, July 1993  ˛  Idea from" + " Calvin French's HEXVIEW "„COLOR 15, 1„PRINT CHR$(218); CHR$(196); CHR$(180);„COLOR 15, 3: PRINT " "; COMMAND$; " "; : COLOR 15, 1„PRINT CHR$(195); STRING$(80 - POS(0), 196); CHR$(191)„„FOR Lin = 3 TO LastDataLine„    LOCATE Lin, 1: PRINT CHR$(179); SPACE$(78);„„    IF Lin = 3 THEN„        PRINT CHR$(24);„    ELSEIF Lin = LastDataLine THEN„        PRINT CHR$(25);„    ELSE„        PRINT CHR$(176);„    END IF„NEXT„„LOCATE 4, 80, 0: PRINT CHR$(219);„LOCATE 24, 1: PRINT CHR$(192); CHR$(196); CHR$(180);„COLOR 13: PRINT "       (     )/"; LTRIM$(STR$(LOF(1)));„COLOR 15: PRINT " "; CHR$(195); STRING$(80 - POS(1), 196); CHR$(217);„„LOCATE 25, 1: COLOR 14, 3„PRINT " Adjust Viewport "; : COLOR 15„PRINT "[PgUp/PgDn] [Up/Down] [Home/End]         [F]=Filter" + " [Esc]=Quit ";„„END SUB„„SUB DrawScreen„STATIC NotOnePage, L    ' 1=True, 2=False, 0=first call„„IF NotOnePage = 0 THEN„    IF LOFile& - 16 < PageSize THEN„        NotOnePage = 1„        L = (LOFile& - 1) \ 16 + 3„    ELSE„        NotOnePage = 2„        L = LastDataLine„    END IF„END IF„„ShowHex Pointer&„COLOR 14„„Temp& = Pointer&„FOR row = 0 TO L - 3„    SuperHex VidSegment, row + 3, 10, 62, Signed(sseg(Array&(0)) + Temp& \ 16), VARPTR(Array&(0)), Attrib, FilterOn„„    LOCATE row + 3, 3, 0„    PrintHex Temp&„„    Temp& = Temp& + 16„NEXT„„IF Temp& > LOFile& THEN AdjustLastBytes L„„END SUB„„FUNCTION GetAdapterSeg„    DEF SEG = 0„    ColorM = (PEEK(&H410) AND 48) <> 48„    DEF SEG 'Monocrome--^                       ^„            'Color Graphics Adapter or better --|„„    IF ColorM THEN GetAdapterSeg = &HB800 ELSE GetAdapterSeg = &HB000„END FUNCTION„„SUB LoadFile (LOFile&)„„Dummy& = FRE("")„„TempStor$ = SPACE$(Block)„start& = sseg(Array&(0))„„FOR LoadUp = 1 TO LOFile& \ Block„    GET #1, , TempStor$„    MemCopy sseg(TempStor$), SADD(TempStor$), Signed(start&), VARPTR(Array&(0)), Block„    start& = start& + Block \ 16„    ShowHex LoadUp * 1& * Block„NEXT„„TempStor$ = SPACE$(LOFile& MOD Block)„GET #1, , TempStor$„MemCopy sseg(TempStor$), SADD(TempStor$), Signed(start&), 0, LEN(TempStor$)„    ' *** SSEG to sseg for QB/QBASIC users!„END SUB„„SUB PrintHex (Num&)„„    'PRINT MID$(HEX$(Num& + &H100000), 2);„    PRINT RIGHT$("0000" + HEX$(Num&), 5);„„END SUB„„SUB ShowHex (Posit&) STATIC„„COLOR 15, 1„LOCATE 24, 5„PRINT USING "######"; Posit&;„LOCATE , 12„PrintHex Posit&„„LOCATE LastBox, 80„PRINT CHR$(176);„LastBox = Posit& * 18 \ LOFile& + 4„LOCATE LastBox, 80„PRINT CHR$(219);„„END SUB„„FUNCTION Signed (Num&)„„    IF Num& > 32767 THEN„        Signed = Num& - 65536„    ELSE„        Signed = Num&„    END IF„„END FUNCTION„„„;---------8<-----[ Begin SUPERHEX.ASM ]----->8-----------„; All:„;„; This code is different from my original posting of SuperHex„; very slightly only.  I added a mem. copy and a scrolling„; procedure.„;              -- Victor„„; =========== SuperHEX 1.1 ===============„; by Victor Yiu, July 1993„;„; Ultra-fast ASCII to HEX conversion...„; designed for calling up from a file„; or memory viewer to display hex/ascii„; codes like Norton's DiskEdit, or PCTool's„; View... except much faster!„;„; This code is released into public domain.„; =========================================„„CODE SEGMENT PARA PUBLIC 'CODE'„    PUBLIC SuperHex, MemCopy, Scroll„    ASSUME CS:code, DS:nothing, ES:nothing, SS:nothing„„CharsPerLine    = 80        ; set-up hard coded constant„FilterReplaceChar EQU   '.' ; replace bad chars. with what?„„SuperHex PROC FAR„    PUSH BP             ; set up stack frame„    MOV BP, SP„    PUSH DS             ; save registers„    PUSH SI„    PUSH DI„; =============================================================„;VidSeg, Row, OffsetHex, OffsetASCii, Seg:Off memory (16 byte)„; BP+20  BP+18  BP+16       BP+14            BP+10 [DWORD]„„; BG Color    Filter„;   BP+8       BP+6„; =============================================================„„    LES AX, SS:[BP+18]  ; VidSeg --> ES„    DEC AX              ; Row --> AX  (adjust to 0-24 range)„    JZ NoMul            ; if 0, don't multiply to save time„    MOV BL, CharsPerLine; get # chars per line„    MUL BL              ; multiply„NoMul:„    SHL AX, 1           ; *2: vid.mem. alternates ASCii/color„    MOV DX, AX          ; save into DX„„    LDS SI, SS:[BP+10]  ; get source memory into DS:SI„    PUSH SI             ; save it for later„„; ====== Setup to write the 16 bytes of ASCii first„    MOV AH, SS:[BP+8]   ; get attribute into AH„    MOV DI, DX          ; move start of row offset into DI„    MOV BX, SS:[BP+14]  ; get offset of ASCii„    DEC BX„    SHL BX, 1           ; *2 because of vid. mem.„    ADD DI, BX          ; compute final offset„    CMP WORD PTR [BP+6], 0       ; filter on?„    JNE FilterOn„„REPT 16                 ; repeat 16 times„    LODSB               ; get byte„    STOSW               ; store byte + attribute„ENDM„    JMP SHORT Continue„EVEN„FilterOn:„    MOV CX, 16„    MOV BX, '~ '        ; preload constants„EVEN„FilterTop:„    LODSB„    CMP AL, BL          ; below 32?„    JL NoShow„    CMP AL, BH          ; more than 127„    JG NoShow„    STOSW„    LOOP FilterTop„    JMP SHORT Continue„EVEN„NoShow:„    MOV AL, FilterReplaceChar„    STOSW„    LOOP FilterTop„„„; ======= Set up for HEX conversion to screen„Continue:„    MOV BX, SS:[BP+16]  ; get offset of HEX„    DEC BX„    SHL BX, 1           ; *2 for vid. mem„    ADD DX, BX          ; add to original row offset„    MOV DI, DX          ; put it into the index register„    POP SI              ; get previous SI„    MOV CX, 16          ; do sixteen characters„„    MOV BL, AH          ; attribute into BL„„    MOV DX, (256*9) + ('A'-'9'-1)„    MOV BP, '00'        ; preload stuff to make it scream„„; BP = '00'„; BL = attribute„; BH = -- reserved for temporary digit„; DL = 'A'-'9'-1„; DH = 9„EVEN„LoopTop:„    MOV BH, 16          ; load divisor„    LODSB               ; get character„    MOV AH, 0           ; clear AH„    DIV BH              ; to get tens in AL, ones in AH.„    CMP AL, DH          ; > '9'?„    JLE NextDigit       ; no -- don't fix„EVEN„    ADD AL, DL          ; fix it„NextDigit:„    CMP AH, DH          ; > '9'?„    JLE WriteOut        ; no -- don't fix„    ADD AH, DL          ; fix it„WriteOut:„    ADD AX, BP          ; add '00' to digits to make them ASCii„    MOV BH, AH          ; save ones digit for next character„    MOV AH, BL          ; get attribute„    STOSW               ; write digit„    MOV AL, BH          ; get next„    STOSW               ; write„    MOV AL, ' '         ; write space„    STOSW„    CMP CX, 9           ; between the 8th and 9th HEX digits„    JE AddSpace„    LOOP LoopTop„    JMP SHORT OttaHere„EVEN„AddSpace: STOSW„    LOOP LoopTop„„OttaHere:„    POP DI              ; restore registers„    POP SI„    POP DS„    POP BP„    RET 16       ; shave off 16 bytes of passed in parameters„SuperHex ENDP„„MemCopy PROC FAR„    PUSH BP„    MOV BP, SP          ; set up stack frame„    PUSH DS„    PUSH SI„    PUSH DI„„    CLD„    MOV CX, [BP+6]      ; # to copy in CX„    LES DI, [BP+8]      ; get dest.„    LDS SI, [BP+12]     ; get source„„    SHR CX, 1           ; odd byte„    JNC CopyStart„    MOVSB„CopyStart: REP MOVSW    ; do copy„„    POP DI„    POP SI„    POP DS„    POP BP„    RET 10„MemCopy ENDP„„Scroll PROC FAR„    PUSH BP„    MOV BP, SP      ; set up stack frame„„; BP+8 = MoveUp?   BP+6 = attribute„„    MOV BH, [BP+6]  ; load up attribute„    MOV AX, 0601h   ; 1 line„    CMP BYTE PTR [BP+8], 0    ; zero?„    JE Down        ; yes; go up„    INC AH          ; go down (AX=0701)„Down:„    MOV CX, 0202h   ; (3,3) top left„    MOV DX, 0164Ch  ; (23,77) bottom right„    INT 010h        ; call vid. interrupt„    POP BP„    RET 4„„Scroll ENDP„    CODE ENDS„END„;---------8<-----[ End SUPERHEX.ASM ]----->8-----------„„' Compile SUPERHEX.ASM under TASM or MASM to make SUPERHEX.OBJ„'„' Then to make a LIB and QLB out of this file:„'„' LIB SUPERHEX +SUPERHEX;„' LINK /QUI SUPERHEX.LIB,,,c:\qb\bqlb45;„'                          qbxqlb        for PDS (I think)„'                          vbdosqlb      for VBDOS„' Load into QB:„'    QB BROWSER /L SUPERHEX /AH„'„' Instructions on how to make EXE file is in the BASIC source.„'„„Allan Zachary                  BINARY TO BASIC SCRIPT         BINARY,BASIC,SCRIPT            07/92 (00:00)          QB, QBasic, PDS        119  4170     BIN2QB.BAS  ' .------------------------------------------------------.„' |    BIN2QB.BAS  by Allan Zachary Public Domain 7/92   |„' |  Converts binary files to echo-compatible text files |„' |  version 3.3 - replaces a fallible checksum in v3.1  |„' | < Bar Charts progress, Manual or Batch style input > |„' |     BATCH SYNTAX: BIN2QB infile.ext outfile.ext      |„' `------------------------------------------------------'„DEFINT A-Z„DECLARE FUNCTION Bin2Txt$ (ThreeBytes$) ' 3 binary bytes in returns„DIM SHARED XCk&                      ' 4 printable Text bytes out„Q$ = CHR$(34): MaxFileSz& = 32760„Bin$ = RTRIM$(COMMAND$) ' (QBASIC users put 'REM' before this line.)„Split = INSTR(Bin$, " ")„IF Split = 0 THEN„  INPUT "Filename of file to convert:", InFile$„  INPUT "Output filename:", OutFile$„ELSE„  InFile$ = LEFT$(Bin$, Split - 1)„  OutFile$ = RIGHT$(Bin$, LEN(Bin$) - Split)„END IF„COLOR 12, 0: Bin$ = ""„IF LEN(InFile$) THEN„  OPEN InFile$ FOR BINARY AS #2„  Size& = LOF(2): FSiz& = Size&„ELSE„  InFile$ = "File"„END IF„IF Size& > MaxFileSz& THEN„  PRINT "Aborted- File too large for Bin2Qb!"„  BEEP: COLOR 7, 0: END„END IF„IF Size& THEN„  ON ERROR GOTO DoIt„  OPEN OutFile$ FOR INPUT AS #1„  CLOSE #1: COLOR 12, 0: PRINT OutFile$; " already exists!!"„  BEEP: COLOR 7, 0: END„DoIt:„  CLOSE #1: CLS„  COLOR 11, 0: PRINT "BIN2QB 3.3 by Allan Zachary Creating "; OutFile$„  OPEN OutFile$ FOR OUTPUT AS #1„  PRINT #1, "DEFINT A-Z  ' Created by BIN2QB 3.3 freeware 7/92"„  PRINT #1, "f$="; Q$; InFile$; Q$; ":LSBs=3"„  PRINT #1, "CLS : PRINT "; Q$; "Creating "; Q$; ";f$"„  PRINT #1, "OPEN f$ FOR BINARY AS #1 :FSize&="; FSiz&„  PRINT #1, "ON ERROR GOTO Done:LOCATE 2,1:PRINT STRING$(78,176)"„  PRINT #1, "DO"„  PRINT #1, "  READ Lyne$:LynLen=LEN(Lyne$)"„  PRINT #1, "  FOR i=1 TO LynLen "„  PRINT #1, "    Power=((i-1)MOD 4)*6"„  PRINT #1, "    B&=(ASC(MID$(Lyne$,i,1))-59)*2^Power:C&=C&+B&"„  PRINT #1, "    IF i MOD 4=0 THEN"„  PRINT #1, "      Stored&=Stored&+3:XCk&=XCk& XOR C&:LOCATE 2,1"„  PRINT #1, "      PRINT STRING$(CINT(Stored&/FSize&*78),219);"„  PRINT #1, "      IF Stored&>FSize& THEN LSBs=3+(FSize&-Stored&)"„  PRINT #1, "      Bin$=LEFT$(MKL$(C&),LSBs):PUT #1,,Bin$:C&=0"„  PRINT #1, "    ENDIF"„  PRINT #1, "  NEXT i:LOOP"„  Lyne$ = "DATA "„  BufSz& = FRE(Buf$) - 1024„  IF BufSz& > Size& THEN BufSz& = Size&„  Buf$ = SPACE$(BufSz&)„  LOCATE 2, 1: PRINT STRING$(78, 176); : COLOR 10, 0„  DO„    GET #2, , Buf$„    FOR i = 1 TO LEN(Buf$)„      Done& = Done& + 1„      Ascii = ASC(MID$(Buf$, i, 1))„      Bin$ = Bin$ + CHR$(Ascii)„      IF LEN(Bin$) = 3 THEN„        IF LEN(Lyne$) >= 69 THEN 'save it, and start a new line...„          PRINT #1, Lyne$„          LOCATE 2, 1: PRINT STRING$(CINT(Done& / Size& * 78), 219)„          Lyne$ = "DATA " + Bin2Txt$(Bin$)„        ELSE 'keep building this line...„          Lyne$ = Lyne$ + Bin2Txt$(Bin$)„        END IF„        Bin$ = ""„      END IF„    NEXT i„    Size& = Size& - BufSz&„    IF BufSz& > Size& THEN BufSz& = Size&„    Buf$ = SPACE$(BufSz&)„  LOOP WHILE LEN(Buf$)    'Until the last character has been read.„  Size& = LEN(Bin$)„  IF Size& THEN Bin$ = Bin2Txt$(Bin$)„  IF LEN(Lyne$) >= 69 THEN„    PRINT #1, Lyne$„    IF Size& THEN PRINT #1, "DATA " + Bin$„  ELSE„    PRINT #1, Lyne$ + Bin$„  END IF„  LOCATE 2, 1: PRINT STRING$(CINT(Done& / FSiz& * 78), 219)„  PRINT #1, "Done:CLOSE #1: PRINT"„  PRINT #1, "IF XCk&<>"; XCk&; " THEN "„  PRINT #1, "  PRINT "; Q$; "DATA corrupt!  File deleted."; Q$„  PRINT #1, "  KILL f$"„  PRINT #1, "ELSE"„  PRINT #1, "  PRINT f$;"; Q$; " created."; Q$„  PRINT #1, "END IF:END"„  CLOSE„  COLOR 11, 0: PRINT "done."„ELSE„ PRINT InFile$; " doesn't exist, or has no length!"„ CLOSE„END IF„COLOR 7, 0: END„„FUNCTION Bin2Txt$ (ThreeBytes$)„  L = LEN(ThreeBytes$)„  N& = CVL(ThreeBytes$ + STRING$(4 - L, 0))„  XCk& = XCk& XOR N&„  FourBytes$ = ""'             .---Offset into Character set„  FOR j = 1 TO 4 '             |„    Tmp$ = CHR$((N& AND 63) + 59)„    N& = N& \ 64„    FourBytes$ = FourBytes$ + Tmp$„  NEXT j„  Bin2Txt$ = FourBytes$„END FUNCTION„Chris Tracy                    DECIMAL 2 BINARY               DECIMAL,2,BINARY               03-12-93 (09:14)       QB, QBasic, PDS        41   1560     DEC2BIN.BAS '> i've got your attention, I need something VERY badly. It's a„'> relatively FAST decimal 2 binary function, as well as a binary 2„'> decimal function to go with it. The binary function needs to be„'> put in a string ($), so that I can deal with it. I'm not just„„'---- Cut Here /w Sharp Razorblades ----„DECLARE FUNCTION BinDec& (Binary$)„DECLARE FUNCTION DecBin$ (decimal&)„ „Bin$ = DecBin$(5050)    ' Convert 5050 to binary„PRINT Bin$              ' Print the result„PRINT BinDec&(Bin$)     ' Convert 0001001110111010 to the decimal equiv.„„FUNCTION BinDec& (Binary$) STATIC„        decimal& = 0: power% = 0„        Binary$ = UCASE$(Binary$)„        FOR i% = LEN(Binary$) TO 1 STEP -1„                digit% = ASC(MID$(Binary$, i%, 1)) - 48„                IF digit% < 0 OR digit% > 1 THEN decimal& = 0: EXIT FOR„                decimal& = decimal& + digit% * 2 ^ (power%)„                power% = power% + 1„        NEXT i%„        BinDec& = decimal&„END FUNCTION„„FUNCTION DecBin$ (decimal&) STATIC„        Bin$ = ""„        h$ = HEX$(decimal&)„        FOR i% = 1 TO LEN(h$)„                digit% = INSTR("0123456789ABCDEF", MID$(h$, i%, 1)) - 1„                IF digit% < 0 THEN Bin$ = "": EXIT FOR„                j% = 8: k% = 4„                DO„                        Bin$ = Bin$ + RIGHT$(STR$((digit% \ j%) MOD 2), 1)„                        j% = j% - (j% \ 2): k% = k% - 1„                        IF k% = 0 THEN EXIT DO„                LOOP WHILE j%„        NEXT i%„        DecBin$ = Bin$„END FUNCTION„„Rich Geldreich/Victor Yiu      POSTIT! 7.2 SCRIPT CODER       FidoNet QUIK_BAS Echo          08/93 (00:00)          QB, QBasic, PDS        1198 48477    POSTIT72.BASDEFINT A-Z„'--- PostIt! subroutines.„DECLARE SUB ParseCmdLine (cmd$, Params$(), Found%)„DECLARE SUB SepPath (a$, Drive$, path$, tName$)„DECLARE FUNCTION Decode% (oSwitch%, InSpec$, OutSpec$)„DECLARE FUNCTION Encode% (Op%, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InSpec$, OutSpec$)„DECLARE SUB ExpandLine (a$, Lines$(), LineLength%, NumLines%)„DECLARE FUNCTION FASC% (a$)„DECLARE FUNCTION GrabNum& (a$, Lower&, Upper&, Default&)„DECLARE FUNCTION UnTab$ (B$, TabStops%)„'--- ImportIt! subroutines.„DECLARE SUB ImportIt (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference%)„DECLARE SUB CreateRep (BBSID$, ArcCommand$)„DECLARE SUB AddToRep (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference%, ErrorCode$)„DECLARE SUB IIParse (cmd$, toname$, fromname$, conference%, BBSID$)„'„' --- beta test release --- released by Calvin French, August 1993 ---„'„' This SHOULD work perfectly. Please test it, tangle it, and report any„' bugs you find in it to Victor, Me, or (lastly only because he is very„' very busy), Rich.„'„' - Calvin -„'„' --------------------------------------------------------------------„'„' PostIt! v7.2 Script Encoder/Decoder-Public Domain-August 1993„' By Rich Geldreich & Victor Yiu. Many  contributions,   fixups,  and„' features by Mark H. Butler,  Quinn Tyler Jackson, and Scott Wunsch.„' QWK compatable .REP file support by Calvin French.„'„' PostIt! can  encode   any  binary   file  into  a  series  of self-„' extracting  script  files  that  can  be  reliably  distributed  on„' text-only  conferences  or  networks.   The  script  files  can  be„' extracted with  this  program,  or  with  any  Microsoft QuickBASIC„' language (DOS 5's QBASIC, QB4.5, PDS, VB-DOS) because  each  script„' contains its own small QuickBASIC decoder.„'„' PostIt!   can  also  format  QuickBASIC  source  code  suitable for„' distribution on conferences, and reconstruct source code  formatted„' by  this  program.   This  allows  QuickBASIC programmers to easily„' exchange BASIC source code without worrying about the annoying line„' length and message limitations of most networks.„'„' ImportIt!, a new part of PostIt!, can toss the output files created„' by PostIt! into a QWK compatable .REP file.„'„' New 7.2 Features:„'„' o  QWK  compatable  .REP file support  has been  included! No  more„'    importing tons of files into your reply packets via your offline„'    mail reader!„'„' New 7.1 Features:„'„' o  Totally rewritten source code!„' o  Much  more efficient  encoding algorithm (MOD 86 encoding)  with„'    a smaller and faster self extractor!„' o  Huge binary scripts now supported, up to 150k!„' o  The  script decoding & unfiltering functions  are now automated!„'    As  long  as a few  simple rules are followed (see the  notes on„'    the Decode command), no  user intervention  is needed to extract„'    multiple scripts from the same capture file.„' o  PostIt!  is  finally  a command line utility! Error codes can be„'    returned  to batch  files if  you're compiling   with  VBDOS  or„'    QBX.   Look  at the source to  find out  which error  code means„'    which.„' o  The format of PostIt!'s   message  headers has finally been well„'    thought out and (hopefully) finalized.  Although   compatibility„'    with  previous versions of PostIt!  has been sacrificed, scripts„'    created by  newer versions  of  PostIt!   should be decodable by„'    this version because of a common message header format.„'„' Explanation of Commands„'„' E = Encodes  any binary  file less than 150k into a self-extracting„'     text-only script.  If the -s  option is used with this command,„'     the entire script will be written to one output file; otherwise„'     the script will be split into multiple output files, where each„'     output file contains one message.   (Note:  Scripts created  by„'     this  command  cannot  be  extracted  by  previous  versions of„'     PostIt!.)„'„' F = Filters QuickBASIC source code for  posting  on  a  conference.„'     This  command  actually  performs  two filtering functions.  It„'     splits very long  lines  with  continuation characters (special„'     precautions are taken to ensure  quoted strings and remarks are„'     split correctly), and chops the source code into multiple files„'     so each file corresponds to one message  (unless the -s  option„'     is used).The filtered file can still be executed or compiled by„'     QuickBASIC, just as the original could.  (Note: DATA statements„'     split by filtering cannot be unsplit correctly by QB! This will„'     hopefully  be fixed  soon...   Files  filtered  by this command„'     cannot by unfiltered by previous versions of PostIt!.)„'„' D = Decodes binary/text scripts.  Multiple scripts can  be  decoded„'     from the same  input  file  with  this  function.  The decoding„'     algorithm  automatically  decides  which  method  was  used  to„'     encode the source file(binary script or source code filtering).„'„'     If  any  errors  are  encountered during decoding the script is„'     skipped  and the  partly decoded  file is deleted.„'„'     Binary and text scripts created by previous versions of PostIt!„'     cannot be decoded with this command, because of the new  header„'     format employed by this version of PostIt!.„'„'     (Notes:  Pages of a script MUST appear in increasing order.  In„'     other words, page 2 must follow page 1, page 3 must follow page„'     2, etc.  When posting  files  created  by  the E or F commands,„'     don't modify or remove the message headers because the decoding„'     algorithm expects these to indicate the beginning and ending of„'     each page.  (All message headers begin with a "'>>>" sequence.)„'     Finally, if an output file is specified on  the  command  line,„'     for  example "POSTIT D capture.txt c:\q\coolcode.zip", only the„'     specified output file  (COOLCODE.ZIP  in  the  example) will be„'     decoded if its script can be  located.   The  pathname  of  the„'     output  file  will  be  the  destination  path specified on the„'     command line.  In the  example,  the  file COOLCODE.ZIP will be„'     written to the C:\Q directory.)„'„' -Q  This  switch  will cause  PostIt!  to invoke  ImportIt!, a  new„'     feature available with version 7.2. ImportIt! will toss all the„'     files that PostIt! creates  into a QWK compatable reply  packet„'     (.REP file.) You  MUST specify  at least three  more paramaters„'     for this capability, however. They are:„'„'     [to:to_name] (optional)„'     This is the name that you would like in the "to" field (who you„'     are sending the message to.)  If it is not specified, ImportIt!„'     will substitute the name "ALL".„'„'     from:from_name„'     This is the name that you would like in the "from" field (which„'     is, more often than not, your own name)„'„'     NOTE: With  both names, if a  space is needed, use a period  in„'     the command  line (e.g.,  to:Victor.Yiu from:Calvin.French) and„'     ImportIt! will translate it to a space.„'„'     conf:conf_number„'     This is the number of the  FidoNet echomail conference that you„'     would like the  the messages to be  tossed into. This is really„'     the only very important  thing you need to remember in order to„'     use  ImportIt!  NOTE:  This  is NOT  the  NAME of the  echomail„'     conference (e.g., QUIK_BAS), but  rather the NUMBER (e.g., 32).„'     It should also  be mentioned that  sometimes this number is not„'     the same number as may appear  on your BBS's Message Base list.„'     It is suggested that  you check this  number carefully via your„'     offline  mail reader  as the  wrong  number will  toss  all the„'     messages into the wrong area.„'„'     bbsid:BBSID„'     This is  the BBS  identification  name of the  BBS you will  be„'     uploading  your  reply  packet  to.  According  to  the  naming„'     conventions outlined in the QWK format (version 1.6), this will„'     be the file name (not including the extention) of your .QWK and„'     .REP file  (QWK mail packet and reply  packet).  ImportIt! will„'     use this name to access the reply packet, so it is important to„'     get it right.„'„' Completely Stupid and Irrelevant Examples for the Average Fool„'„' postit e maim.zip -p95 -b20 c:\scripts\mc„' (Encodes a binary script of MAIM.ZIP. All output file(s) are written„'  to the C:\SCRIPTS directory and begin with the "MC" suffix. The„'  message length is 95 lines, and 20 blank lines are reserved on the„'  first message.)„' postit -a f x-ray.bas -o -s„' (Filters the file X-RAY.BAS for posting. All blank lines are padded„'  with a space, no prompting is done for file overwrites, and no„'  message splitting is performed.)„' postit d zebra.txt q\„' (Decodes all scripts from the file ZEBRA.TXT to the Q directory.)„' postit e graphics.zip -p95 -b0 -q to:You from:Me conf:32 bbsid:MYBBS„' (Encodes a binary script of GRAPHICS.ZIP. Output files are then„'  attached, or rather merged into MYBBS.REP. The messages will be from„'  YOU to ME in fidonet conference are #32. If to: was not specified,„'  it would be from YOU to ALL.) Tip: Since ImportIt! tosses files„'  directly into the .REP file, there is usually no need to reserve„'  blank lines on the first message.„'„TYPE MsgHeaderType„  Status          AS STRING * 1„  ConfNumASCII    AS STRING * 7„  MsgDate         AS STRING * 8„  MsgTime         AS STRING * 5„  ToField         AS STRING * 25„  FromField       AS STRING * 25„  SubjectField    AS STRING * 25„  PassWord        AS STRING * 12„  MsgRefNumber    AS STRING * 8„  NumBlocks       AS STRING * 6„  Flag            AS STRING * 1„  ConfNum         AS INTEGER          ' should be UNSIGNED INTEGER„  PacketMsgNumber AS STRING * 2„  NetworkTag      AS STRING * 1„END TYPE„' change the following to the name of the archiver you would like„' to use. Must be ZIP, ARJ or LHA„CONST PreferredArchiveMethod$ = "ZIP"„'CONST PreferredArchiveMethod$ = "ARJ"„'CONST PreferredArchiveMethod$ = "LHA"„DIM SHARED OutPutFile$(1 TO 256)„DEFINT A-Z„CONST true = -1, false = 0, Debug% = false„DIM SHARED GERR%: ON ERROR GOTO ErrHandler„LOCATE , , 1„PRINT "PostIt! v7.2 QuickBASIC Compatible Encoder/Decoder"„PRINT "Public Domain by Rich Geldreich and Victor Yiu"„PRINT„IF FRE(-1) < 65536 THEN ErrLvl% = 1: PRINT "Not enough memory": GOTO AllDone„DIM Params$(1 TO 10)„'The following line must be modified for DOS 5 QBASIC.„ParseCmdLine COMMAND$, Params$(), NumParams%„IF NumParams% = 0 THEN ErrLvl% = 2: GOTO ShowHelp„FOR I% = 1 TO NumParams%„  q$ = Params$(I%)„  IF LEFT$(q$, 1) <> "-" AND LEN(q$) = 1 THEN„    Command% = INSTR("EFD", q$)„    IF Command% <> 0 THEN„      Params$(I%) = "": EXIT FOR„    ELSE„      PRINT "Bad command: "; q$: PRINT : ErrLvl% = 3: GOTO ShowHelp„    END IF„  END IF„NEXT„IF Command% = 0 THEN PRINT "No command specified.": PRINT : ErrLvl% = 4: GOTO ShowHelp„IF Command% = 2 THEN DefaultLineLength% = 72 ELSE DefaultLineLength% = 65„sSwitch% = false: pSwitch% = 85: lSwitch% = DefaultLineLength%„tSwitch% = 4: oSwitch% = false: bSwitch% = 0: aSwitch% = false„iSwitch% = false: cSwitch% = false: qSwitch = 0„FOR I% = 1 TO NumParams%„  q$ = Params$(I%): Z$ = MID$(q$, 3)„  IF LEN(q$) THEN„    IF LEFT$(q$, 1) = "-" OR LEFT$(q$, 3) = "TO:" OR LEFT$(q$, 5) = "FROM:" OR LEFT$(q$, 5) = "CONF:" OR LEFT$(q$, 6) = "BBSID:" THEN„      IF LEFT$(q$, 3) <> "TO:" AND LEFT$(q$, 5) <> "FROM:" AND LEFT$(q$, 5) <> "CONF:" AND LEFT$(q$, 6) <> "BBSID:" THEN„        SELECT CASE MID$(q$, 2, 1)„          CASE "S": sSwitch% = true„          CASE "P": pSwitch% = GrabNum&(Z$, 45, 1000, 85)„          CASE "L": lSwitch% = GrabNum&(Z$, 60, 80, CLNG(DefaultLineLength%))„          CASE "T": tSwitch% = GrabNum&(Z$, 1, 8, 4)„          CASE "O": oSwitch% = true„          CASE "B": bSwitch% = GrabNum&(Z$, 0, 30, 0)„          CASE "A": aSwitch% = true„          CASE "I": iSwitch% = true„          CASE "C": cSwitch% = true„          CASE "Q"„            qSwitch% = true„            IIParse COMMAND$, toname$, fromname$, conference%, BBSID$„            qError$ = ""„            IF fromname$ = "" THEN„              qError$ = "From name not specified! "„            ELSEIF conference% = 0 THEN„              qError$ = qError$ + "Conference not specified! "„            ELSEIF BBSID$ = "" THEN„              qError$ = qError$ + "BBSID not specified! "„            END IF„            IF qError$ <> "" THEN„              PRINT LTRIM$(qError$)„              ErrLvl = 3„              qSwitch = false„              GOTO ShowHelp„            END IF„          CASE ELSE: PRINT "Bad switch: "; q$: PRINT : ErrLvl% = 3: GOTO ShowHelp„        END SELECT„      END IF„    ELSE„      SELECT CASE J%„      CASE 0: InputSpec$ = q$„      CASE 1: OutputSpec$ = q$„      CASE ELSE: PRINT "Too many filenames.": PRINT : ErrLvl% = 5: GOTO ShowHelp„      END SELECT: J% = J% + 1„    END IF„  END IF„NEXT„IF J% < 1 THEN PRINT "Must specify input file.": PRINT : ErrLvl% = 5: GOTO ShowHelp„SepPath InputSpec$, InputDrive$, InputPath$, InputName$„IF INSTR(InputName$, ".") = 0 THEN„  IF Command% = 1 THEN     'encoding  .ZIP„    InputSpec$ = InputSpec$ + ".ZIP"„  ELSEIF Command% = 2 THEN 'filtering .BAS„    InputSpec$ = InputSpec$ + ".BAS"„  ELSEIF Command% = 3 THEN 'decoding  .TXT„    InputSpec$ = InputSpec$ + ".TXT"„  END IF„ELSE„  IF Command% = 1 THEN„    SELECT CASE MID$(InputName$, INSTR(InputName$, ".") + 1, 3)„    CASE "ZIP", "LZH", "ARJ", "GIF", "SQZ", "ZOO", "ARC", "HAP", "JPG"„    CASE ELSE: PRINT "Warning: Uncompressed files should not be" + " encoded" + " into binary scripts!": PRINT„  END SELECT„  END IF„END IF„OPEN InputSpec$ FOR INPUT AS #1: CLOSE #1„IF GERR% THEN PRINT "Can't open "; InputSpec$: ErrLvl% = 6: GOTO AllDone„SepPath OutputSpec$, OutDrive$, OutPath$, OutName$„TestFile$ = OutDrive$ + OutPath$ + "pi742875.2yz"„OPEN TestFile$ FOR OUTPUT AS #1: CLOSE #1„IF GERR% THEN PRINT "Bad output specification.": ErrLvl% = 7: GOTO AllDone„KILL TestFile$„SELECT CASE Command%„CASE 1: Status% = Encode%(0, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InputSpec$, OutputSpec$)„CASE 2: Status% = Encode%(1, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InputSpec$, OutputSpec$)„CASE 3: Status% = Decode%(oSwitch%, InputSpec$, OutputSpec$)„END SELECT„IF Status% < 0 THEN ErrLvl% = 8 ELSE IF Status% > 0 THEN ErrLvl% = 9 ELSE ErrLvl% = 0„GOTO AllDone„ShowHelp:„PRINT "Usage: POSTIT [switch] command inputfile [outputfile] [-q" + " options]"„PRINT„PRINT "Commands:"„PRINT "e [E]ncode any file <150k into a self extracting binary script"„PRINT "f [F]ilter QB source into a text script"„PRINT "d [D]ecode captured text or binary script(s)"„PRINT„PRINT "Switches:"„PRINT "-s  Don't split output file into multiple messages"„PRINT "-o  Don't prompt for file overwrites"„PRINT "-b# Reserve # blank lines on first message (0-30, default=0)"„PRINT "-t# Set tab stops to # characters (1-8, default=4)"„PRINT "-l# Set line length to # characters (60-80, default=65 or 72)"„PRINT "-p# Set message length to # lines (45-1000, default=85)"„PRINT "-a  Padd blank lines with a space when filtering"„PRINT "-i  Ignore blank lines when filtering"„PRINT "-c  Crush space characters from start of lines when filtering"„PRINT„PRINT "ImportIt! (QWK compatable .REP file support):"„PRINT "-q [to:to_name] from:from_name conf:conf_num bbsid:BBSID"„AllDone:„IF qSwitch = true THEN„  IF GERR < 0 THEN„    IF Debug% THEN PRINT "Exiting with an errorlevel of"; ErrLvl%„    END„  END IF„  FOR n = 1 TO 256„    a$ = OutPutFile$(n)„    IF a$ = "" THEN EXIT FOR„  NEXT n„  NumFiles = n - 1„  DIM MsgFiles$(1 TO NumFiles)„  FOR n = 1 TO NumFiles„    MsgFiles$(n) = OutPutFile$(n)„  NEXT n„  FOR n = LEN(InputSpec$) TO 1 STEP -1„    IF MID$(InputSpec$, n, 1) = "\" THEN StartFname = n + 1„  NEXT n„  IF StartFname <> 0 THEN„    TitleFile$ = MID$(InputSpec$, StartFname, 1)„  ELSE„    TitleFile$ = InputSpec$„  END IF„  FOR n = 1 TO LEN(toname$)„    IF MID$(toname$, n, 1) = "." THEN MID$(toname$, n, 1) = " "„  NEXT n„  FOR n = 1 TO LEN(fromname$)„    IF MID$(fromname$, n, 1) = "." THEN MID$(fromname$, n, 1) = " "„  NEXT n„  ImportIt BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference%„END IF„IF Debug% THEN PRINT "Exiting with an errorlevel of"; ErrLvl%„END„ErrHandler: GERR% = ERR„  IF Debug% THEN IF GERR% <> 53 THEN PRINT "Global error #"; GERR%„RESUME NEXT„„SUB AddToRep (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference, ErrorCode$)„  DIM MsgHeader     AS MsgHeaderType„  DIM QWKRecBuff    AS STRING * 128„  DIM QWKByteBuff   AS STRING * 1„  DIM ArcHeader     AS STRING * 3„  ' test for file„  OPEN BBSID$ + ".REP" FOR BINARY AS #1„  IF LOF(1) = 0 THEN„    CLOSE #1„    KILL BBSID$ + ".REP"„    ErrorCode$ = "Reply packet (.REP file) not found!"„    EXIT SUB„  END IF„  ' test for messages„  NumMessages = UBOUND(MsgFiles$)„  IF NumMessages = 0 THEN„    CLOSE #1„    ErrorCode$ = "No files to add to reply (.REP) packet!"„    EXIT SUB„  END IF„  ' check ToName$„  IF toname$ = "" THEN„    toname$ = "ALL"„  END IF„  ' check FromName$„  IF fromname$ = "" THEN„    CLOSE #1„    ErrorCode$ = "No from field (name) specified!"„    EXIT SUB„  END IF„  CLOSE #1„  ' process mail packet„  PRINT„  PRINT "Unarchiving "; BBSID$ + ".REP";„  ' determine archive type„  OPEN BBSID$ + ".REP" FOR BINARY AS #1„  ' PKZIP file?„  SEEK 1, 1„  GET #1, , ArcHeader„  IF ArcHeader = "PK" + CHR$(3) THEN„    DeArcCommand$ = "PKUNZIP"„    ArcCommand$ = "PKZIP"„    ArcType$ = "ZIP"„  END IF„  ' LZH file?„  SEEK 1, 3„  GET #1, , ArcHeader„  IF ArcHeader = "-lh" THEN„    DeArcCommand$ = "LHA E"„    ArcCommand$ = "LHA A /M"„    ArcType$ = "LZH"„  END IF„  ' ARJ file?„  SEEK 1, 1„  GET #1, , ArcHeader„  IF LEFT$(ArcHeader, 2) = "'" + CHR$(234) THEN„    DeArcCommand$ = "ARJ E"„    ArcCommand$ = "ARJ A -Y"„    ArcType$ = "ARJ"„  END IF„  ' dearchive file„  PRINT " using "; ArcType$„  SHELL DeArcCommand$ + " " + BBSID$ + ".REP"„  CLOSE #1„  ' test for file„  OPEN BBSID$ + ".MSG" FOR BINARY AS #1„  IF LOF(1) = 0 THEN„    ErrorCode$ = "Error occured during DeArchiving. File " + BBSID$ + ".MSG not found in archive"„    CLOSE #1„    KILL BBSID$ + ".MSG"„    EXIT SUB„  END IF„  ' read messages„  PRINT„  PRINT "Reading Messages from "; BBSID$; ".MSG..."„  SEEK 1, 1„  GET #1, , QWKRecBuff„  DO„    GET #1, , MsgHeader„    NewHighest = VAL(MsgHeader.MsgRefNumber)„    IF NewHighest > Highest THEN Highest = NewHighest„    ' read until next message„    FOR n = 1 TO VAL(MsgHeader.NumBlocks) - 1„      GET #1, , QWKRecBuff„    NEXT n„  LOOP UNTIL SEEK(1) >= LOF(1)„  PRINT„  PRINT "Writing new messages..."„  PRINT„  PRINT "To:     "„  PRINT "From:   "„  PRINT "Subj:   "„  PRINT "Conf:   "„  PRINT "Date:   "„  PRINT "Time:   "„  PRINT "Number: "„  StartLin = CSRLIN - 7„  FOR msg = 1 TO NumMessages„    LOCATE StartLin, 1„    Subj$ = "[" + LTRIM$(STR$(msg)) + "/" + LTRIM$(STR$(NumMessages)) + "] " + TitleFile$„    conf$ = LTRIM$(STR$(conference))„    num$ = LTRIM$(STR$(msg + Highest - 1))„    dat$ = LEFT$(DATE$, 6) + RIGHT$(DATE$, 2)„    tim$ = LEFT$(TIME$, 5)„    PRINT "To:     "; toname$„    PRINT "From:   "; fromname$„    PRINT "Subj:   "; Subj$„    PRINT "Conf:   "; conf$„    PRINT "Date:   "; dat$„    PRINT "Time:   "; tim$„    PRINT "Number: "; num$„    PRINT "Writing File: "; MsgFiles$(msg);„    TotalLen& = 0„    OPEN MsgFiles$(msg) FOR INPUT AS #2„    OPEN "~IIBETA.TMP" FOR BINARY AS #3„    DO WHILE NOT EOF(2)„      LINE INPUT #2, text$„      text$ = text$ + CHR$(227)„      PUT #3, , text$„    LOOP„    TotalLen& = SEEK(3)„    TotalLen& = TotalLen& + 128       ' for tagline„    QWKRecBuff = CHR$(227) + " * ImportIt! v1.0b [BETA] * ImportIt!" + " [PD] by Calvin French, August 1993" + CHR$(227) + CHR$(227)„    PUT #3, , QWKRecBuff„    ExtraString$ = SPACE$(128 - (TotalLen& MOD 128))„    TotalLen& = TotalLen& + LEN(ExtraString$)„    PUT #3, , ExtraString$„    Blocks$ = LTRIM$(STR$((TotalLen& / 128) + 1))„    MsgHeader.Status = "-"            ' public, read„    MsgHeader.ConfNumASCII = conf$    ' conference (.REP only)„    MsgHeader.MsgDate = dat$          ' date„    MsgHeader.MsgTime = tim$          ' time„    MsgHeader.ToField = toname$       ' to„    MsgHeader.FromField = fromname$   ' from„    MsgHeader.SubjectField = Subj$    ' subject„    MsgHeader.PassWord = SPACE$(12)   ' password„    MsgHeader.MsgRefNumber = num$     ' message number„    MsgHeader.NumBlocks = Blocks$     ' blocks in message„    MsgHeader.Flag = CHR$(225)        ' active flag„    MsgHeader.ConfNum = conference    ' conference (.REP and .QWK)„    MsgHeader.PacketMsgNumber = " "   ' not sure what this is.„    MsgHeader.NetworkTag = " "        ' network tagline„    PUT #1, , MsgHeader„    SEEK 3, 1„    FOR n = 1 TO TotalLen& / 128„      GET #3, , QWKRecBuff„      PUT #1, , QWKRecBuff„    NEXT n„    CLOSE #3„    CLOSE #2„    KILL "~IIBETA.TMP"„  NEXT msg„  CLOSE #1„  PRINT„  PRINT„  PRINT "Rearchiving Packet..."„  SHELL ArcCommand$ + " " + BBSID$ + ".REP " + BBSID$ + ".MSG"„  PRINT„  PRINT "Deleting " + BBSID$ + ".MSG..."„  PRINT„  KILL BBSID$ + ".MSG"„  ErrorCode$ = "Packet Successfully Processed!"„END SUB„„SUB CreateRep (BBSID$, ArcCommand$)„„DIM QWKRecBuff AS STRING * 128„„PRINT„PRINT "Creating message data file (.MSG file)..."„PRINT„„OPEN BBSID$ + ".MSG" FOR BINARY AS #1„„QWKRecBuff = UCASE$(BBSID$)„„PUT #1, , QWKRecBuff„„CLOSE #1„„PRINT "Archiving file..."„„SHELL ArcCommand$ + " " + BBSID$ + ".REP " + BBSID$ + ".MSG"„„PRINT„PRINT "Deleting message data file (.MSG file)..."„„KILL BBSID$ + ".MSG"„„END SUB„„FUNCTION Decode% (oSwitch%, InSpec$, OutSpec$)„  DIM Lines$(1 TO 256), ValidChar%(255)„  FOR q% = 0 TO 85 'Valid encoding characters„    IF q% = 27 THEN„      ValidChar%(ASC("#")) = true„    ELSEIF q% = 59 THEN„      ValidChar%(ASC("$")) = true„    ELSE„      ValidChar%(q% + 37) = true„    END IF„  NEXT„  GERR% = 0: Z$ = "OPEN " + CHR$(34) + "O" + CHR$(34) + ",1," + CHR$(34)„  SepPath OutSpec$, OutDrive$, OutPath$, OutName$„  OutPath$ = OutDrive$ + OutPath$„  InputHandle% = FREEFILE„  OPEN InSpec$ FOR INPUT AS InputHandle% LEN = 8192„  OutputHandle% = FREEFILE„  DO„    IF FoundNewScript% = false THEN„      DO UNTIL EOF(InputHandle%)„        M% = M% + 1: IF M% = 16 THEN GOSUB AbortCheck„        LineNum& = LineNum& + 1„        LINE INPUT #1, a$: a$ = LTRIM$(RTRIM$(UCASE$(a$)))„        IF GERR% THEN PRINT "Error while reading from input file!": GOTO DecodeExit„        IF LEFT$(a$, 14) = "'>>> PAGE 1 OF" AND INSTR(a$, "BEGINS" + " HERE") > 0 AND INSTR(a$, "TYPE:") > 0 THEN EXIT DO„      LOOP„      IF EOF(InputHandle%) THEN EXIT DO„    END IF„    FoundNewScript% = false„    OutFile$ = LTRIM$(MID$(a$, 15))„    OutFile$ = RTRIM$(LEFT$(OutFile$, INSTR(OutFile$, "BEGINS") - 1))„    IF LEN(OutFile$) = 0 THEN GOTO FindNext„    IF LEN(OutName$) = 0 OR OutFile$ = OutName$ THEN„      FilesCRC% = -1: FilesLength& = -1: ScrDone% = false„      BadScript% = false: NumLines% = 0: K% = 0: s% = 0: B& = 0„      q% = INSTR(a$, "TYPE:") + 5„      SELECT CASE MID$(a$, q%, 3)„      CASE "BAS": ScriptType% = 0„      CASE "BIN"„        ScriptType% = 1„        EncodeVer% = FASC%(MID$(a$, q% + 3, 1)) - 65„        ExtractVer% = FASC%(MID$(a$, q% + 4, 1)) - 65„        IF ExtractVer% <> 0 THEN PRINT "Unsupported encoding algorithm" + "" + " for file "; OutFile$: PRINT : GOTO FindNext„      CASE ELSE: PRINT "Unsupported script type for file "; OutFile$: PRINT : GOTO FindNext„      END SELECT„      GOSUB CheckLine„      OPEN OutPath$ + OutFile$ FOR INPUT AS OutputHandle%: CLOSE OutputHandle%„      IF GERR% = 0 THEN„        IF oSwitch% = false THEN„          PRINT OutPath$ + OutFile$; " already exists. [O]verwrite, or" + "" + " [A]bort(o/a)? ";„          DO: DO: a$ = INKEY$: LOOP UNTIL LEN(a$): a$ = UCASE$(a$)„          LOOP UNTIL INSTR("OA" + CHR$(27), a$)„          LOCATE , 1: PRINT SPACE$(78); : LOCATE , 1„          SELECT CASE a$„          CASE "A", CHR$(27): GERR% = -1: PRINT "Aborted by user!": GOTO DecodeExit„          END SELECT„        END IF„      END IF„      GERR% = 0: OPEN OutPath$ + OutFile$ FOR OUTPUT AS OutputHandle%„      IF GERR% THEN PRINT "Error while opening "; OutPath$ + OutFile$; "!": GOTO DecodeExit„      OutSpecOpened% = true„      IF ScriptType% = 0 THEN PRINT "Unfiltering ";  ELSE PRINT "Decoding ";„      PRINT OutPath$ + OutFile$; "... ";„      LookingForNextPage% = false„      CurrentPage% = 1„      DO UNTIL EOF(InputHandle%)„        IF GERR% THEN PRINT "Error #"; STR$(GERR%); " while processing" + "" + " file!": GOTO DecodeExit„        M% = M% + 1: IF M% = 16 THEN GOSUB AbortCheck„        LineNum& = LineNum& + 1„        LINE INPUT #InputHandle%, a$: a$ = RTRIM$(a$)„        IF ScriptType% = 1 THEN a$ = LTRIM$(a$)„        IF LEFT$(a$, 4) = "'>>>" THEN„          GOSUB CheckLine„          IF UCASE$(LEFT$(a$, 10)) = "'>>> PAGE " THEN„            a$ = UCASE$(a$)„            IF LEFT$(a$, 15) = "'>>> PAGE 1 OF " AND INSTR(a$, "BEGINS" + "" + " HERE") > 0 THEN„              PRINT "Premature end of script on line"; LineNum&„              FoundNewScript% = true: BadScript% = true: EXIT DO„            END IF„            IF GrabNum&(MID$(a$, 11), 1, 256, -1) <> CurrentPage% THEN PRINT "Page out of sync on line"; LineNum&: BadScript% = true: EXIT DO„            IF INSTR(a$, "BEGINS HERE") THEN„              IF LookingForNextPage% = false THEN PRINT "Page"; CurrentPage%; " was encountered more than once on line"; LineNum&: BadScript% = true: EXIT DO„              LookingForNextPage% = false„            ELSEIF INSTR(a$, "ENDS HERE") THEN„              IF LookingForNextPage% = true THEN PRINT "Page"; CurrentPage%; "was terminated prematurely on line"; LineNum&: BadScript% = true: EXIT DO„              LookingForNextPage% = true„              CurrentPage% = CurrentPage% + 1„              IF INSTR(a$, "LAST PAGE") THEN ScrDone% = true: EXIT DO„            ELSE„              PRINT "Bad page header on line"; LineNum&: BadScript% = true: EXIT DO„            END IF„          END IF„        ELSE„          IF LookingForNextPage% = false THEN„            IF ScriptType% = 0 THEN„              GOSUB ShrinkLine„            ELSE„              IF LEFT$(a$, 1) = "U" AND LEFT$(LTRIM$(MID$(a$, 2)), 1) = CHR$(34) THEN GOSUB DecodeLine„            END IF„          END IF„        END IF„      LOOP„      IF BadScript% = false THEN„        IF ScrDone% = false THEN PRINT "Premature end of script on" + " line"; LineNum&: BadScript% = true: GOTO DecodeDone„        GoodScripts% = GoodScripts% + 1„        IF ScriptType% = 0 THEN„          IF NumLines% > 0 THEN a$ = "": GOSUB ShrinkLine„          PRINT "Ok"„        ELSE„          IF FilesLength& = -1 THEN„            PRINT "Warning: File's length could not be located!"„          ELSEIF FilesLength& <> B& THEN„            PRINT "Warning: Decoded file's length is incorrect."„          ELSEIF FilesCRC% = -1 THEN„            PRINT "Warning: File's checksum could not be located!"„          ELSEIF FilesCRC% <> s% THEN„            PRINT "Warning: Decoded file's checksum is incorrect."„          ELSE„            PRINT "Ok"„          END IF„        END IF„      END IF„DecodeDone:„      CLOSE OutputHandle%„      IF GERR% THEN PRINT "Error while writing to output file!": GOTO DecodeExit„      IF BadScript% THEN KILL OutPath$ + OutFile$„      OutSpecOpened% = false„      PRINT : IF OutFile$ = OutName$ THEN EXIT DO„    END IF„FindNext:„  LOOP UNTIL EOF(InputHandle%)„'----------------------------------------------------------„DecodeExit:„  q% = GERR%: CLOSE InputHandle%: CLOSE OutputHandle%„  IF q% = 0 THEN PRINT LTRIM$(STR$(GoodScripts%)); " script(s) decoded" + "" + " successfully."„  IF q% <> 0 AND OutSpecOpened% THEN KILL OutPath$ + OutFile$„  Decode% = q%„EXIT FUNCTION„'----------------------------------------------------------„ShrinkLine:„  FoundIt% = FASC(RIGHT$(a$, 1)) = 95„  IF FoundIt% THEN„    InQuote% = false„    FOR I% = 1 TO LEN(a$)„      IF MID$(a$, I%, 1) = CHR$(34) THEN InQuote% = NOT InQuote%„    NEXT„    'Don't combine lines that are part of binary scripts„    IF InQuote% THEN FoundIt% = false„  END IF„  IF FoundIt% OR NumLines% > 0 THEN„    IF NumLines% = 256 THEN„      PRINT "Too many line continuations!": BadScript% = true: GOTO DecodeDone„    END IF„    NumLines% = NumLines% + 1: Lines$(NumLines%) = a$„    IF FoundIt% = false THEN 'last line?„      a$ = ""„      FOR a% = 1 TO NumLines%„        B$ = Lines$(a%)„        'can we combine two quoted strings together?„        CombineQuote% = false„        IF RIGHT$(a$, 2) = "+_" AND LEN(a$) > 3 THEN„          IF RIGHT$(RTRIM$(LEFT$(a$, LEN(a$) - 2)), 1) = CHR$(34) THEN„            IF FASC(LTRIM$(B$)) = 34 THEN CombineQuote% = true„          END IF„        END IF„        IF CombineQuote% THEN„          a$ = RTRIM$(LEFT$(a$, LEN(a$) - 2))„          a$ = LEFT$(a$, LEN(a$) - 1) + MID$(LTRIM$(B$), 2)„        ELSE„          InQuote% = false„          'can we combine two remarks together?„          FOR I% = 1 TO LEN(a$)„            q$ = MID$(a$, I%, 1)„            IF q$ = CHR$(34) THEN„              InQuote% = NOT InQuote%„            ELSEIF InQuote% = false THEN„              IF q$ = "'" OR UCASE$(MID$(a$, I%, 4)) = "REM " THEN„                IF LEFT$(LTRIM$(B$), 1) = "'" THEN B$ = MID$(B$, 2)„                EXIT FOR„              END IF„            END IF„          NEXT„          'eradicate trailing "_" character„          IF LEN(a$) THEN a$ = LEFT$(a$, LEN(a$) - 1)„          a$ = a$ + B$„        END IF„      NEXT„      PRINT #OutputHandle%, a$: NumLines% = 0„    END IF„  ELSE„    PRINT #OutputHandle%, a$„  END IF„  IF GERR% THEN PRINT "Error while writing to output file!": GOTO DecodeExit„RETURN„'----------------------------------------------------------„DecodeLine: '**MOD 86 Decoder**„  a$ = MID$(LTRIM$(MID$(a$, 2)), 2)„  IF RIGHT$(a$, 1) = CHR$(34) THEN a$ = LEFT$(a$, LEN(a$) - 1)„  FOR a% = 1 TO LEN(a$)„    C% = ASC(MID$(a$, a%, 1))„    IF ValidChar%(C%) = false THEN PRINT "Illegal character found on" + " line"; LineNum&: BadScript% = true: GOTO DecodeDone„    C% = C% - 37: IF C% < 0 THEN C% = 91 + C% * 32„    IF K% < 4 THEN„      IF C% > 80 THEN PRINT "Decode out of sync/illegal character" + " found" + " on line"; LineNum&: BadScript% = true: GOTO DecodeDone„      K% = C% + 243„    ELSE„      T% = C% + (K% MOD 3) * 86: IF T% > 255 THEN PRINT "Illegal" + " character found on line"; LineNum&: BadScript% = true: GOTO DecodeDone„      PRINT #OutputHandle%, CHR$(T%);„      IF GERR% THEN PRINT "Error while writing to output file!": GOTO DecodeExit„      B& = B& + 1: K% = K% \ 3„    END IF„    s% = (s% + C%) AND 255„  NEXT„RETURN„'----------------------------------------------------------„CheckLine:„  q% = INSTR(a$, "TLEN:")„  IF q% THEN FilesLength& = GrabNum&(MID$(a$, q% + 5), 1, 153600, -1)„  q% = INSTR(a$, "TCHK:")„  IF q% THEN FilesCRC% = GrabNum&(MID$(a$, q% + 5), 0, 255, -1)„RETURN„'----------------------------------------------------------„AbortCheck: M% = 0: K$ = INKEY$„  IF K$ = CHR$(27) OR K$ = CHR$(0) + CHR$(0) THEN GERR% = -1: PRINT "Aborted by user!": GOTO DecodeExit„RETURN„END FUNCTION„„FUNCTION Encode% (Op%, iSwitch%, cSwitch%, aSwitch%, tSwitch%, sSwitch%, pSwitch%, lSwitch%, oSwitch%, bSwitch%, InSpec$, OutSpec$)„  ' following SHARED is for ImportIt!„  DIM Bucket%(1 TO 4), Lines$(64)„  GERR% = 0: q$ = CHR$(34)„'----------------------------------------------------------„  SepPath InSpec$, OutDrive$, OutPath$, InName$„  SepPath OutSpec$, OutDrive$, OutPath$, OutName$„  IF LEN(OutName$) = 0 THEN„    OutName$ = InName$„    IF INSTR(OutName$, ".") THEN OutName$ = LEFT$(OutName$, INSTR(OutName$, ".") - 1)„  END IF„  IF INSTR(OutName$, ".") THEN„    OutExt$ = MID$(OutName$, INSTR(OutName$, "."))„    OutName$ = LEFT$(OutName$, INSTR(OutName$, ".") - 1)„  END IF„  IF LEN(OutExt$) = 0 THEN IF Op% THEN OutExt$ = ".PST" ELSE OutExt$ = ".PI"„'----------------------------------------------------------„  InputHandle% = FREEFILE„  IF Op% THEN„    OPEN InSpec$ FOR INPUT AS InputHandle% LEN = 8192„  ELSE„    OPEN InSpec$ FOR BINARY AS InputHandle%„  END IF„  InputFileSize& = LOF(InputHandle%)„  IF Op% = 0 AND InputFileSize& > (150 * 1024&) THEN„    PRINT "Can't encode files larger than 150k."„    GERR% = -1: GOTO EncodeExit„  ELSEIF InputFileSize& = 0 THEN„    PRINT "Input file is null.": GERR% = -2: GOTO EncodeExit„  END IF„'----------------------------------------------------------„  IF Op% THEN PRINT "Filtering ";  ELSE PRINT "Encoding ";„  PRINT InSpec$; " ("; LTRIM$(STR$((InputFileSize& + 1023) \ 1024)); "k)"„  PRINT„'----------------------------------------------------------„  OutputHandle% = FREEFILE: LinesInPage% = 0„'----------------------------------------------------------„  IF Op% = 0 THEN„    Work$ = "U" + q$ + SPACE$(lSwitch% - 2): WorkPos% = 3„    CurrentSub% = 0: LinesInSub% = 0: FlagScaler% = 1„    GOSUB PrintDecodeHeader„    BytesLeft& = InputFileSize&: BufferSize% = 4096„    Buffer$ = SPACE$(BufferSize)„    DO„      IF GERR% THEN PRINT "- Error #"; STR$(GERR%); " while encoding" + " file!": GOTO EncodeExit„      IF BytesLeft& < BufferSize% THEN Buffer$ = SPACE$(BytesLeft&): BufferSize% = BytesLeft&„      GET InputHandle%, , Buffer$„      IF GERR% THEN PRINT "- Error while reading from input file!": GOTO EncodeExit„      GOSUB EncodeBlock„    LOOP WHILE BytesLeft&„    IF NumCodes% THEN GOSUB FlushCodeBuffer„    IF WorkPos% > 3 THEN Work$ = LEFT$(Work$, WorkPos% - 1): GOSUB PutSubLine„    IF LinesInSub% THEN L$ = "END SUB": GOSUB PutLine„    FOR a% = 2 TO CurrentSub%: L$ = "V" + HEX$(a%): GOSUB PutLine: NEXT„    GOSUB PrintDecodeTrailer„  ELSE„    BytesLeft& = InputFileSize&„    DO UNTIL EOF(InputHandle)„      IF GERR% THEN PRINT "- Error #"; STR$(GERR%); " while filtering" + "" + " file!": GOTO EncodeExit„      LINE INPUT #InputHandle, a$: a$ = RTRIM$(UnTab$(a$, tSwitch%))„      IF GERR% THEN PRINT "- Error while reading from input file!": GOTO EncodeExit„      IF cSwitch% THEN a$ = LTRIM$(a$)„      BytesLeft& = BytesLeft& - LEN(a$) - 2„      IF LEN(a$) > 0 OR iSwitch% = false THEN„        ExpandLine a$, Lines$(), lSwitch%, NumLines%„        'Don't let split lines cross page boundries, because QB won't„        'put them back together.„        IF sSwitch% = false AND (NumLines% > 1) AND (LinesInPage% + 1 + NumLines%) > pSwitch% THEN„          PRINT #OutputHandle%, "'>>> Page"; STR$(NumOutputFiles%); " of "; InName$; " ends here. Continued on next page."„          LinesInPage% = LinesInPage% + 1: GOSUB CloseOutputFile„        END IF„        FOR a% = 1 TO NumLines%„          L$ = Lines$(a%)„          'Don't let blank lines proceed the first page header.„          IF LinesInPage% <> 0 OR LEN(RTRIM$(L$)) > 0 THEN„            'The padding option is for those unfortunates that post„            'source online in RBBS's grubby line oriented text editor...„            IF aSwitch% THEN IF LEN(L$) = 0 THEN L$ = " "„            GOSUB PutLine„          END IF„        NEXT„      END IF„    LOOP„  END IF„'----------------------------------------------------------„  L$ = "'>>> Page" + STR$(NumOutputFiles%) + " of " + InName$ + " ends" + "" + " here. Last page."„  IF Op% = 0 THEN L$ = L$ + " TCHK:" + LTRIM$(STR$(CheckSum%))„  GOSUB PutLine: GOSUB CloseOutputFile: PRINT„  PRINT LTRIM$(STR$(TotalLines%)); " lines in"; STR$(NumOutputFiles%); " message(s) written."„'----------------------------------------------------------„EncodeExit:„  q% = GERR%„  CLOSE InputHandle%: CLOSE OutputHandle%„  IF q% <> 0 THEN FOR a% = 1 TO NumOutputFiles%: KILL OutPutFile$(a%): NEXT„  Encode% = q%„EXIT FUNCTION„'----------------------------------------------------------„EncodeBlock: '**MOD 86 Encoder**„  FOR I% = 1 TO BufferSize%„    Byte% = ASC(MID$(Buffer$, I%, 1)): BytesLeft& = BytesLeft& - 1„    CurrentFlag% = CurrentFlag% + (Byte% \ 86) * FlagScaler%„    FlagScaler% = FlagScaler% * 3: NumCodes% = NumCodes% + 1„    Bucket%(NumCodes%) = Byte% MOD 86„    IF NumCodes% = 4 THEN GOSUB FlushCodeBuffer„  NEXT„RETURN„'----------------------------------------------------------„FlushCodeBuffer:„  q% = CurrentFlag%: GOSUB PutByte„  FOR J% = 1 TO NumCodes%: q% = Bucket%(J%): GOSUB PutByte: NEXT„  NumCodes% = 0: CurrentFlag% = 0: FlagScaler% = 1„RETURN„'----------------------------------------------------------„PutByte:„  CheckSum% = (CheckSum% + q%) AND 255„  IF q% = 27 THEN„    MID$(Work$, WorkPos%) = "#"„  ELSEIF q% = 59 THEN„    MID$(Work$, WorkPos%) = "$"„  ELSE„    MID$(Work$, WorkPos%) = CHR$(q% + 37)„  END IF„  WorkPos% = WorkPos% + 1: IF WorkPos% > lSwitch% THEN GOSUB PutSubLine„RETURN„'----------------------------------------------------------„PutSubLine:„  IF LinesInSub% = 0 THEN„    CurrentSub% = CurrentSub% + 1„    IF CurrentSub% = 1 THEN„      L$ = "SUB V1:OPEN " + q$ + "O" + q$ + ",1," + q$ + InName$ + q$ + ",4^6:Z&=" + LTRIM$(STR$(LOF(1))) + ":?STRING$(50,177);"„    ELSE„      L$ = "SUB V" + HEX$(CurrentSub%)„    END IF„    GOSUB PutLine„  END IF„  L$ = Work$: GOSUB PutLine„  LinesInSub% = LinesInSub% + 1„  IF LinesInSub% = 200 THEN L$ = "END SUB": GOSUB PutLine: LinesInSub% = 0„  WorkPos% = 3„RETURN„'----------------------------------------------------------„PutLine:„  IF LinesInPage% = 0 THEN GOSUB OpenNewOutputFile„  PRINT #OutputHandle%, L$„  IF GERR% THEN PRINT "- Error writing to output file!": GOTO EncodeExit„  LinesInPage% = LinesInPage% + 1„  IF sSwitch% = false THEN„    'make sure last page has some meat on it„    IF LinesInPage% = (pSwitch% - 1) OR (BytesLeft& < 256 AND LinesInPage% > (pSwitch% - 10)) THEN„      PRINT #OutputHandle%, "'>>> Page"; STR$(NumOutputFiles%); " of "; InName$; " ends here. Continued on next page."„      LinesInPage% = LinesInPage% + 1: GOSUB CloseOutputFile„    END IF„  END IF„  'Check the blower for contol+c and escape every few lines...„  IF (LinesInPage% AND 7) = 1 THEN„    a$ = INKEY$: IF a$ = CHR$(27) OR a$ = CHR$(0) + CHR$(0) THEN GERR% = -3: PRINT "- Aborted by user!": GOTO EncodeExit„  END IF„RETURN„'----------------------------------------------------------„OpenNewOutputFile:„  IF NumOutputFiles% = 256 THEN GERR% = -4: PRINT "Too many output" + " files!": GOTO EncodeExit„  NumOutputFiles% = NumOutputFiles% + 1„  IF sSwitch% = true THEN„    J$ = OutName$„  ELSE„    J$ = LTRIM$(STR$(NumOutputFiles%))„    J$ = LEFT$(OutName$, 8 - LEN(J$)) + J$„  END IF„  OutFile$ = OutDrive$ + OutPath$ + J$ + OutExt$: GERR% = 0„  OPEN OutFile$ FOR INPUT AS OutputHandle%: CLOSE OutputHandle%„  IF GERR% = 0 THEN„    IF oSwitch% = false THEN„      PRINT OutFile$; " already exists. [O]verwrite, overwrite [R]est," + "" + " or [A]bort(o/r/a)? ";„      DO: DO: a$ = INKEY$: LOOP UNTIL LEN(a$): a$ = UCASE$(a$)„      LOOP UNTIL INSTR("ORA" + CHR$(27), a$)„      LOCATE , 1: PRINT SPACE$(78); : LOCATE , 1„      SELECT CASE a$„      CASE "A", CHR$(27): GERR% = -3: PRINT "Aborted by user!"„        NumOutputFiles% = NumOutputFiles% - 1: GOTO EncodeExit„      CASE "R": oSwitch% = true„      END SELECT„    END IF„  END IF„  PRINT "Now writing: "; OutFile$; " ";„  GERR% = 0: OPEN OutFile$ FOR OUTPUT AS OutputHandle% LEN = 4096„  OutPutFile$(NumOutputFiles%) = OutFile$„  IF GERR% THEN„    PRINT "- Error opening output file!"„    NumOutputFiles% = NumOutputFiles% - 1: GOTO EncodeExit„  END IF„  LinesInPage% = 1„  IF NumOutputFiles% = 1 THEN„    FOR I% = 1 TO bSwitch%„      IF aSwitch% THEN PRINT #OutputHandle, " " ELSE PRINT #OutputHandle,„    NEXT„    LinesInPage% = LinesInPage% + bSwitch%„  END IF„  PRINT #OutputHandle%, "'>>> Page"; STR$(NumOutputFiles%); " of "; InName$; " begins here.";„  IF NumOutputFiles% > 1 THEN„    PRINT #OutputHandle%,„  ELSE„    IF Op% = 0 THEN„      'The first letter after "BIN" is  which algorithm was used„      'to encode the file. The second letter is the minimum decoding„      'algorithm required to extract the file. Both range from A-Z.„      PRINT #OutputHandle%, " TYPE:BINAA";„      'TLEN stands for "total length".„      PRINT #OutputHandle%, " TLEN:"; LTRIM$(STR$(InputFileSize&))„      'In the future, other information may be put onto this line,„      'such as the file's date and time. (Actually, any line„      'starting will "'>>>" will be scanned for information by„      'the Decode function.)„    ELSE„      PRINT #OutputHandle%, " TYPE:BAS"„    END IF„  END IF„  GERR% = 0„RETURN„'----------------------------------------------------------„CloseOutputFile:„  CLOSE OutputHandle%„  IF GERR% THEN PRINT "- Error while writing to output file!": GOTO EncodeExit„  PRINT : TotalLines% = TotalLines% + LinesInPage%: LinesInPage% = 0„RETURN„'----------------------------------------------------------„PrintDecodeHeader:„  L$ = "DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1"„  GOSUB PutLine„RETURN„'----------------------------------------------------------„PrintDecodeTrailer:„  L$ = "CLOSE:IF S=" + LTRIM$(STR$(CheckSum%))„  L$ = L$ + "AND B&=Z&THEN?" + q$ + " :) Ok!" + q$ + "ELSE?" + q$ + " " + "" + ":( Bad!"„  GOSUB PutLine„  L$ = "SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN" + " C=91+C*32"„  GOSUB PutLine„  L$ = "IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1"„  GOSUB PutLine„  L$ = "S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB"„  GOSUB PutLine„RETURN„END FUNCTION„„'This self containted subroutine for splitting QB lines was made by„'Victor Yiu and a few other folks on the QUIK_BAS echo.„SUB ExpandLine (a$, Lines$(), LineLength%, NumLines%)„  NumLines% = 0„  'check to see if the line has already been split„  FOR I% = LEN(a$) TO 1 STEP -1„    SELECT CASE MID$(a$, I%, 1)„    CASE "_": NoSplit% = true„    CASE " "„    CASE ELSE: EXIT FOR„    END SELECT„  NEXT„  DO WHILE NoSplit% = false AND LEN(a$) > LineLength%„    'locate a place to split the line„    WrapPoint% = 0„    FOR I% = LineLength% TO LineLength% - 20 STEP -1„      SELECT CASE MID$(a$, I%, 1)„      CASE " ", ".", ",", ":", ";": WrapPoint% = I%: EXIT FOR„      END SELECT„    NEXT„    IF WrapPoint% = 0 THEN WrapPoint% = LineLength%„    'avoid wrapping on quote chars„    IF MID$(a$, WrapPoint% - 1, 1) = CHR$(34) THEN WrapPoint% = WrapPoint% - 1„    InQuote% = false: HasComment% = false„    'check to see if the line contains a remark„    FOR I% = 1 TO WrapPoint% - 1„      q$ = MID$(a$, I%, 1)„      IF q$ = CHR$(34) THEN„        InQuote% = NOT InQuote%„      ELSEIF InQuote% = false THEN„        IF q$ = "'" OR UCASE$(MID$(a$, I%, 4)) = "REM " THEN„          HasComment% = true: EXIT FOR„        END IF„      END IF„    NEXT„    NumLines% = NumLines% + 1„    IF InQuote% THEN„      Lines$(NumLines%) = LEFT$(a$, WrapPoint% - 1) + CHR$(34) + "+_"„    ELSE„      Lines$(NumLines%) = LEFT$(a$, WrapPoint% - 1) + "_"„    END IF„    a$ = MID$(a$, WrapPoint%)„    IF HasComment% THEN„      a$ = "'" + a$„    ELSEIF InQuote% THEN„      a$ = CHR$(34) + a$„    END IF„  LOOP„  NumLines% = NumLines% + 1: Lines$(NumLines%) = a$„END SUB„„FUNCTION FASC% (a$)„  IF LEN(a$) = 0 THEN FASC% = -1 ELSE FASC% = ASC(a$)„END FUNCTION„„FUNCTION GrabNum& (a$, Lower&, Upper&, Default&)„  FOR I% = 1 TO LEN(a$)„    q$ = MID$(a$, I%, 1): IF (q$ < "0" OR q$ > "9") THEN EXIT FOR„    J& = J& * 10& + ASC(q$) - 48„    IF J& > Upper& THEN GrabNum& = Default&: EXIT FUNCTION„  NEXT„  GrabNum& = J&: IF LEN(a$) = 0 OR J& < Lower& OR J& > Upper& THEN GrabNum& = Default&„END FUNCTION„„SUB IIParse (cmd$, toname$, fromname$, conference%, BBSID$)„  ' this short sub parses cmd$ and returns values for use with ImportIt!„  FOR n = 1 TO LEN(cmd$)„    IF MID$(cmd$, n, 4) = " -Q " THEN„      qLoc = n + 4„    END IF„  NEXT n„  FOR n = qLoc TO LEN(cmd$)„    IF MID$(cmd$, n, 3) = "TO:" THEN„      toname$ = LTRIM$(RTRIM$(MID$(cmd$, n + 3, INSTR(n, cmd$, "FROM:") - (n + 3))))„    ELSEIF MID$(cmd$, n, 5) = "FROM:" THEN„      fromname$ = LTRIM$(RTRIM$(MID$(cmd$, n + 5, INSTR(n, cmd$, "CONF" + ":") - (n + 5))))„    ELSEIF MID$(cmd$, n, 5) = "CONF:" THEN„      conference% = VAL(LTRIM$(RTRIM$(MID$(cmd$, n + 5, INSTR(n, cmd$, "BBSID:") - (n + 5)))))„    ELSEIF MID$(cmd$, n, 6) = "BBSID:" THEN„      BBSID$ = LTRIM$(RTRIM$(LTRIM$(RTRIM$(MID$(cmd$, n + 6)))))„    END IF„  NEXT n„END SUB„„SUB ImportIt (BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference)„  PRINT„  PRINT "ImportIt! v1.0"; CHR$(225); " QuickBASIC Compatable QWK format" + " file importer."„  PRINT "For use with PostIt! QuickBASIC Compatable Encoder/Decoder."„  PRINT "Public Domain by Calvin French, August 1993"„  PRINT„  PRINT "Adding encoded files to reply packet (.REP file)"„  AddToRep BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference, ErrorCode$„  PRINT„  PRINT "Status returned: "; ErrorCode$„  IF ErrorCode$ = "Reply packet (.REP file) not found!" THEN„    ArcMethod$ = PreferredArchiveMethod$„    SELECT CASE ArcMethod$„      CASE "ARJ"„        ArcCommand$ = "ARJ A"„      CASE "LHA"„        ArcCommand$ = "LHA A"„      CASE "ZIP"„        ArcCommand$ = "PKZIP"„    END SELECT„    CreateRep BBSID$, ArcCommand$„    AddToRep BBSID$, MsgFiles$(), toname$, fromname$, TitleFile$, conference, ErrorCode$„    PRINT "Status returned: "; ErrorCode$„    PRINT„  END IF„END SUB„„'This parsing sub does NOT mistake filenames like "F-14G.ZIP" as„'containing a switch. That's why it looks so big.„SUB ParseCmdLine (cmd$, Params$(), Found%)„  Found% = 0: Sep$ = "-/": Temp$ = LTRIM$(RTRIM$(cmd$)): InParam% = 0„  FOR p% = 1 TO LEN(Temp$)„    C$ = MID$(Temp$, p%, 1)„    IF InParam% = -1 THEN 'Inside of a switch?„      IF INSTR(Sep$, C$) THEN 'Found another switch?„        'Terminate current switch, then start parsing the next one.„        GOSUB MakeParam: MID$(Temp$, p%, 1) = LEFT$(Sep$, 1)„        ParamStart% = p%„      ELSEIF ASC(C$) = 32 OR ASC(C$) = 9 THEN„        GOSUB MakeParam: InParam% = 0 'Terminate current switch.„      END IF„    ELSEIF InParam% = -2 THEN 'Inside of a parameter?„      IF ASC(C$) = 32 OR ASC(C$) = 9 THEN 'Terminate parameter with„        GOSUB MakeParam: InParam% = 0     'space or TAB.„      END IF„    ELSE„      IF INSTR(Sep$, C$) THEN 'Found start of a switch?„        'Make sure all switches start with "-".„        MID$(Temp$, p%, 1) = LEFT$(Sep$, 1): InParam% = -1„        ParamStart% = p%„      ELSEIF ASC(C$) <> 32 AND ASC(C$) <> 9 THEN 'If char isn't a„        InParam% = -2: ParamStart% = p% 'space or TAB it's a parameter.„      END IF„    END IF„  NEXT„ IF InParam% THEN GOSUB MakeParam„  EXIT SUB„MakeParam:„  Found% = Found% + 1„  Params$(Found%) = MID$(Temp$, ParamStart%, p% - ParamStart%)„  IF Found% = UBOUND(Params$) THEN EXIT SUB„RETURN„END SUB„„SUB SepPath (a$, Drive$, path$, tName$)„  FOR I% = LEN(a$) TO 1 STEP -1„    IF INSTR("\:", MID$(a$, I%, 1)) THEN EXIT FOR„  NEXT„  IF I% > 0 THEN„    path$ = UCASE$(MID$(a$, 1, I%)): tName$ = UCASE$(MID$(a$, I% + 1))„  ELSE„    path$ = "": tName$ = UCASE$(a$)„  END IF„  Temp% = INSTR(path$, ":"): Drive$ = ""„  IF Temp% THEN Drive$ = LEFT$(path$, Temp%): path$ = MID$(path$, Temp% + 1)„END SUB„„FUNCTION UnTab$ (B$, TabStops%)„  a$ = B$: T% = INSTR(a$, CHR$(9))„  IF T% THEN„    DO: Temp% = (T% - 1) MOD TabStops%„    a$ = LEFT$(a$, T% - 1) + SPACE$(TabStops% - Temp%) + MID$(a$, T% + 1)„    T% = INSTR(T%, a$, CHR$(9)): LOOP WHILE T%„  END IF„  UnTab$ = a$„END FUNCTION '(last subroutine)„„