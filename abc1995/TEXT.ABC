Logan Ashby                    INDENT BASIC FILES             INDENT,BASIC,FILES             9/10/93 (00:00)        QB, PDS                447  13809    ID.BAS       ' --------------------------------------------------------------„ '| ID.BAS                                                ID.EXE |„ ' --------------------------------------------------------------|„ '|  This program is designed to indent a BASIC source code file |„ '|      properly. (Properly according to my definition. ;-)     |„ '| Written 9/10/93 by Logan Ashby                               |„ '|     Released to the public domain.                           |„ ' --------------------------------------------------------------„„ DEFINT A-Z„ ' Change to QBX.BI for PDS„ ' $INCLUDE: 'qb.bi'„„ DECLARE SUB BrkAtTok (Line1$, Line2$, Token$)„ DECLARE FUNCTION FileExists% (FileName$)„ DECLARE FUNCTION GetFWord$ (Line$)„ DECLARE FUNCTION GetInFName$ (CmdLine$, BaseName$)„ DECLARE FUNCTION IsLabel% (Label$, CrntLine$)„ DECLARE FUNCTION SrchKey% (FirstWord$, KeyIndex%)„ DECLARE SUB Usage ()„„ TYPE DOSFindT                       '| The DTA structure for the„	Reserved    AS STRING * 21      '|  DOS FindFirst/FindNext„	DFAttr      AS STRING * 1       '|  functions„	DosTime     AS INTEGER„	DosDate     AS INTEGER„	FileSize    AS LONG„	FileName    AS STRING * 13„ END TYPE„„ CONST CMNTLDRLEN = 40„ CONST TABSIZE = 4„ CONST TBLSIZE = 21„ CONST INDENT = 1„ CONST NOCHG = 0„ CONST OUTDENT = -1„ CONST OUTDENT1 = -2„„ CONST FALSE = 0„ CONST TRUE = -1„„ COMMON SHARED DblQut$, SngQut$, UndScr$„„ DIM SHARED KeyWTbl$(TBLSIZE)„„ DblQut$ = CHR$(34)„ SngQut$ = CHR$(39)„ UndScr$ = CHR$(95)„„ CmdLine$ = RTRIM$(COMMAND$)         '| Get the command line.„							  '| Ensure filespec is valid.„ InFName$ = GetInFName$(CmdLine$, BaseName$)„„ IF (LEN(InFName$)) THEN„	OutFName$ = BaseName$ + ".tid"„ ELSE„	END„ END IF„„ FOR i% = 1 TO TBLSIZE„	READ KeyWTbl$(i)„ NEXT i%„ InFile% = FREEFILE„ OPEN InFName$ FOR INPUT AS #InFile%„ OutFile% = FREEFILE„ OPEN OutFName$ FOR OUTPUT AS #OutFile%„„ IndLvl% = 0„ LnCtr% = 1„ iLblCtr = 0„ DO„	LINE INPUT #InFile%, InpLine$   '| Get a line from input file„	LOCATE , 1„	PRINT SPACE$(79);„	LOCATE , 1„	PRINT "Reading Line #"; LnCtr%; '| Update onscreen line cntr„„	IF (LEFT$(InpLine$, 1) = SngQut$) THEN„							  '| If the line is a comment„							  '|  that starts in column 1,„	    PRINT #OutFile%, InpLine$   '|  we'll pass it thru as is„	ELSE„							  '| Process comments, if any„	    CALL BrkAtTok(InpLine$, CmntLine$, "'")„	    IF (LEN(CmntLine$)) THEN„		   IF (LEFT$(CmntLine$, 1) = "|") THEN„			  CmntLine$ = "'" + CmntLine$„		   ELSE„			  CmntLine$ = "'| " + CmntLine$„		   END IF„	    END IF„	    IF (LEN(InpLine$) = 0) THEN '| If the line doesn't have„							  '|  any code...„		   IF (LEN(CmntLine$)) THEN„							  '| ... only comments....„			  CmntLine$ = SPACE$(CMNTLDRLEN) + CmntLine$„			  PRINT #OutFile%, CmntLine$„		   ELSE                    '| ... or a blank line.„			  PRINT #OutFile%, ""„		   END IF„	    ELSE„		   IF (IsLabel%(Label$, InpLine$)) THEN„			  IF (LEN(CmntLine$)) THEN„				 Label$ = Label$ + SPACE$(CMNTLDRLEN - LEN(Label$)) + CmntLine$„				 CmntLine$ = ""„			  END IF„			  PRINT #OutFile%, Label$„			  Label$ = ""„		   END IF„		   DO WHILE (LEN(InpLine$))„			  CrntLine$ = InpLine$„			  CALL BrkAtTok(CrntLine$, InpLine$, ":")„							  '| Get the first word on the„							  '|  line„			  FirstWord$ = GetFWord$(CrntLine$)„			  IF (LEN(FirstWord$)) THEN„				 '| If it's one of our keywords for indention,„				 '|  determine what we want to do. (indent,„				 '|  outdent, outdent just this line, or„				 '|  nothing.)„				 Action% = SrchKey%(FirstWord$, KeyIndex%)„			  ELSE„				 Action% = NOCHG„			  END IF„„			  SELECT CASE (Action%)„							  '| Don't change the line,„			  CASE NOCHG          '|  except for indentation„							  '|  to the current level„				 LdgSpcs$ = SPACE$(IndLvl% * TABSIZE)„„							  '| Print this line at the„			  CASE INDENT         '|  current indent level,„							  '|  and increment the level„				 LdgSpcs$ = SPACE$(IndLvl% * TABSIZE)„				 IF (KeyIndex% = 5) THEN„							  '| If it's a single line "IF"„							  '|  statement, don't change„							  '|  indent level.„					IF ((RIGHT$(CrntLine$, 4) = "THEN") OR (RIGHT$(CrntLine$, 1) = UndScr$)) THEN„					    IndLvl% = IndLvl% + 1„					ELSE„					    IF (LEN(InpLine$)) THEN„						   TmpInpLine$ = InpLine$„						   CALL BrkAtTok(CrntLine$, InpLine$, "THEN")„						   CrntLine$ = CrntLine$ + " THEN"„						   CALL BrkAtTok(InpLine$, ElseLine$, "ELSE")„						   IF (LEN(ElseLine$)) THEN„							  InpLine$ = InpLine$ + ": ELSE :" + ElseLine$„						   END IF„						   InpLine$ = InpLine$ + " : " + TmpInpLine$ + " : END IF"„						   IndLvl% = IndLvl% + 1„					    END IF„					END IF„				 ELSE„					IndLvl% = IndLvl% + 1„				 END IF„„			  CASE OUTDENT        '| Decrement the ind. level„							  '|  and print this line„				 IF (IndLvl%) THEN IndLvl% = IndLvl% - 1„				 LdgSpcs$ = SPACE$(IndLvl% * TABSIZE)„„							  '| Print this line at an„							  '|  indentation one level„							  '|  less than the current„			  CASE OUTDENT1       '|  one, but don't adjust„							  '|  the level.„				 LdgSpcs$ = SPACE$((IndLvl% - 1) * TABSIZE)„„			  END SELECT„							  '| Add the correct # of„							  '|  spaces to line and...„			  CrntLine$ = LdgSpcs$ + CrntLine$„							  '| ...print it.„			  IF (LEN(CmntLine$)) THEN„				 IF (LEN(CrntLine$) >= CMNTLDRLEN) THEN„					PRINT #OutFile%, SPACE$(CMNTLDRLEN); CmntLine$„				 ELSE„					CrntLine$ = CrntLine$ + SPACE$(CMNTLDRLEN - LEN(CrntLine$)) + CmntLine$„				 END IF„				 CmntLine$ = ""„			  END IF„			  PRINT #OutFile%, CrntLine$„		   LOOP„	    END IF„	END IF„	LnCtr% = LnCtr% + 1„„ LOOP UNTIL (EOF(InFile%))„„ CLOSE #InFile%                      '| Close the input and„ CLOSE #OutFile%                     '|  output files„„ OldFName$ = BaseName$ + ".bid"„ IF (FileExists%(OldFName$)) THEN KILL OldFName$„ NAME InFName$ AS OldFName$„ NAME OutFName$ AS InFName$„„ END„„ DATA BEGIN, DO, FOR, FUNCTION, IF, STATIC FUNCTION, STATIC SUB„ DATA SUB, WHILE, SELECT„ DATA CASE, CASE ELSE, ELSE, ELSEIF„ DATA END FUNCTION, END IF, END SUB, LOOP, NEXT, WEND, END SELECT„„ ' -------------------------- BrkAtTok --------------------------„ '|  This subroutine breaks the input line at the first          |„ '|      occurence of the given token that is not embedded in a  |„ '|      quoted string.                                          |„ ' --------------------------------------------------------------„ SUB BrkAtTok (Line1$, Line2$, Token$)„„	TokPtr% = INSTR(Line1$, Token$)„	IF (TokPtr%) THEN„	    QuotPtr% = INSTR(Line1$, DblQut$)„	    IF ((QuotPtr%) AND (QuotPtr% < TokPtr%)) THEN„		   Done% = FALSE„		   InQut% = TRUE„„		   DO„			  QuotPtr% = INSTR(QuotPtr% + 1, Line1$, DblQut$)„			  IF ((QuotPtr% > TokPtr%) AND (NOT InQut%)) THEN„				 QuotPtr% = 0„				 Done% = TRUE„			  ELSEIF (QuotPtr% > TokPtr%) THEN„				 TokPtr% = INSTR(QuotPtr% + 1, Line1$, Token$)„				 IF (TokPtr% = 0) THEN„					Done% = TRUE„					QuotPtr% = 0„				 END IF„			  END IF„			  IF (QuotPtr%) THEN„				 InQut% = NOT InQut%„			  ELSE„				 Done% = TRUE„			  END IF„		   LOOP UNTIL Done%„		   IF (InQut% OR (TokPtr% = 0)) THEN„			  Line1$ = LTRIM$(RTRIM$(Line1$))„			  Line2$ = ""„		   ELSE„			  Line2$ = LTRIM$(RTRIM$(MID$(Line1$, TokPtr% + LEN(Token$))))„			  Line1$ = LTRIM$(RTRIM$(LEFT$(Line1$, TokPtr% - 1)))„		   END IF„	    ELSE„		   Line2$ = LTRIM$(RTRIM$(MID$(Line1$, TokPtr% + LEN(Token$))))„		   Line1$ = LTRIM$(RTRIM$(LEFT$(Line1$, TokPtr% - 1)))„	    END IF„	ELSE                            '| No tokens on this line„	    Line1$ = LTRIM$(RTRIM$(Line1$))„	    Line2$ = ""„	END IF„„ END SUB„„ ' ------------------------ FileExists% -------------------------„ '|  This function checks to see if a file of the given name     |„ '|      exists. It returns TRUE (-1) if it does, FALSE (0) if   |„ '|      not.                                                    |„ ' --------------------------------------------------------------„ FUNCTION FileExists% (FileName$)„„	DIM RegsX AS RegTypeX„	DIM DTA AS DOSFindT„	DIM FindFileBuff AS STRING * 64 '| Buffer to hold file path„„„	Null$ = CHR$(0)„	RegsX.ax = &H2F00               '| Get the old DTA address„	CALL INTERRUPTX(&H21, RegsX, RegsX)„„	OldDTASeg% = RegsX.es           '| Save it to restore later„	OldDTAOff% = RegsX.bx„„	RegsX.ax = &H1A00               '| Set our DTA as the crnt„	RegsX.ds = VARSEG(DTA)          '|   one„	RegsX.dx = VARPTR(DTA)„	CALL INTERRUPTX(&H21, RegsX, RegsX)„„							  '| Load our current filename„							  '|  into the buffer„	FindFileBuff = FileName$ + Null$„	RegsX.ax = &H4E00„	RegsX.cx = 39                   '| Attribute for 'normal'„	RegsX.ds = VARSEG(FindFileBuff) '|  files„	RegsX.dx = VARPTR(FindFileBuff)„							  '| Call DOS findfirst func.„	CALL INTERRUPTX(&H21, RegsX, RegsX)„	IF (RegsX.flags AND 1) THEN„	    FileExists% = FALSE         '| It's not there„	ELSE„	    FileExists% = TRUE          '| ... or maybe it is.„	END IF„„	RegsX.ax = &H1A00               '| Restore the original DTA„	RegsX.ds = OldDTASeg%„	RegsX.dx = OldDTAOff%„	CALL INTERRUPTX(&H21, RegsX, RegsX)„„ END FUNCTION„„ ' ------------------------ GetFWord$ ---------------------------„ '|  This function gets the first word on the line.              |„ ' --------------------------------------------------------------„ FUNCTION GetFWord$ (Line$)„„	TestStr$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ._"„	TmpLine$ = UCASE$(Line$)„	StrLen% = LEN(TmpLine$)„„	Done% = FALSE„	CrntPtr% = 1„	DO„	    IF (INSTR(TestStr$, MID$(TmpLine$, CrntPtr%, 1)) = 0) THEN„		   Done% = TRUE„	    END IF„	    IF (NOT Done%) THEN CrntPtr% = CrntPtr% + 1„	LOOP UNTIL (Done% OR (CrntPtr% > StrLen%))„	Word1$ = LEFT$(TmpLine$, CrntPtr% - 1)„	IF ((Word1$ = "END") AND (LEN(TmpLine$) > 3)) THEN„	    TmpLine$ = LTRIM$(RTRIM$(MID$(TmpLine$, CrntPtr%)))„	    Word2$ = GetFWord$(TmpLine$)„	    IF ((Word2$ = "FUNCTION") OR (Word2$ = "IF") OR (Word2$ = "SUB") OR (Word2$ = "SELECT")) THEN„		   Word1$ = Word1$ + " " + Word2$„	    END IF„	ELSEIF ((Word1$ = "STATIC") AND (LEN(TmpLine$) > 6)) THEN„	    TmpLine$ = MID$(TmpLine$, CrntPtr%)„	    Word2$ = GetFWord$(TmpLine$)„	    IF ((Word2$ = "FUNCTION") OR (Word2$ = "SUB")) THEN„		   Word1$ = Word1$ + " " + Word2$„	    END IF„	END IF„	GetFWord$ = Word1$„„ END FUNCTION„„ ' ---------------------- GetInFName$ ---------------------------„ '|  This function validates the command line entry as a good    |„ '|      filename.                                               |„ ' --------------------------------------------------------------„ FUNCTION GetInFName$ (CmdLine$, BaseName$)„„	IF (LEN(CmdLine$) = 0) THEN„	    CALL Usage„	    GetInFName$ = ""„	ELSE„	    IF (LEN(CmdLine$) > 4) THEN„		   DotPos% = INSTR(LEN(CmdLine$) - 4, CmdLine$, ".")„	    ELSE„		   DotPos% = INSTR(CmdLine$, ".")„	    END IF„	    IF (DotPos%) THEN„		   BaseName$ = LEFT$(CmdLine$, DotPos% - 1)„	    ELSE„		   BaseName$ = CmdLine$„	    END IF„	    IF (FileExists%(CmdLine$)) THEN„		   GetInFName$ = CmdLine$„	    ELSE„		   TryFName$ = BaseName$ + ".bas"„		   IF (FileExists%(TryFName$)) THEN„			  GetInFName$ = TryFName$„		   ELSE„			  CALL Usage„			  GetInFName$ = ""„		   END IF„	    END IF„	END IF„„ END FUNCTION„„ ' ----------------------- IsLabel% -----------------------------„ '|  This function determines whether or not the current line is |„ '|      a label.                                                |„ ' --------------------------------------------------------------„ FUNCTION IsLabel% (Label$, CrntLine$)„„	ItIs% = FALSE„	TmpStr$ = UCASE$(CrntLine$)„	TestStr$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890._"„	FOR i% = 1 TO LEN(CrntLine$)„	    IF (INSTR(TestStr$, MID$(TmpStr$, i%, 1)) = 0) THEN„		   IF (MID$(TmpStr$, i%, 1) = ":") THEN„			  ItIs% = TRUE„			  Label$ = LEFT$(TmpStr$, i%)„			  IF (LEN(CrntLine$) > i%) THEN„				 CrntLine$ = LTRIM$(RTRIM$(MID$(CrntLine$, i% + 1)))„			  ELSE„				 CrntLine$ = ""„			  END IF„		   ELSE„			  ItIs% = FALSE„		   END IF„		   EXIT FOR„	    END IF„	NEXT i%„	IsLabel% = ItIs%„„ END FUNCTION„„ ' ----------------------- SrchKey% -----------------------------„ '|  This function searches the keyword table for a match.  If   |„ '|      it finds one, it determines what action it should take. |„ ' --------------------------------------------------------------„ FUNCTION SrchKey% (FirstWord$, KeyIndex%)„„	Done% = FALSE„	KeyIndex% = 0„	DO„	    KeyIndex% = KeyIndex% + 1„	    IF (KeyWTbl$(KeyIndex%) = FirstWord$) THEN„		   Done% = TRUE„		   IF (KeyIndex% < 11) THEN„			  SrchKey% = INDENT„		   ELSEIF (KeyIndex% < 15) THEN„			  SrchKey% = OUTDENT1„		   ELSE„			  SrchKey% = OUTDENT„		   END IF„	    END IF„	LOOP UNTIL ((Done%) OR (KeyIndex% >= TBLSIZE))„	IF (NOT Done%) THEN„	    SrchKey% = NOCHG„	    KeyIndex% = 0„	END IF„„ END FUNCTION„„ ' -------------------------- Usage -----------------------------„ '|  This subroutine prints a 'usage' screen if the user doesn't |„ '|      enter the correct parameters on the commandline         |„ ' --------------------------------------------------------------„ SUB Usage„„	CLS„	PRINT " -------------------------------------------- "„	PRINT "| Usage is: IND filename                     |"„	PRINT "|--------------------------------------------|"„	PRINT "|  Where filename is the name of the file    |"„	PRINT "|  on which you wish to perform indentation  |"„	PRINT "|  checking.                                 |"„	PRINT " -------------------------------------------- "„	BEEP„„ END SUB„„John Woodgate                  FAST TEXT VIEWER               FAST,TEXT,VIEWER               08/22/93 (00:00)       QB, PDS                577  13080    VIEWIT.BAS  DEFINT A-Z  „   „' $INCLUDE: 'QB.BI'„„DECLARE SUB CRTShutDown ()„DECLARE SUB DrawBox (TOPROW%, LFTCOL%, BOTROW%, RTCOL%, BORDER%)„DECLARE SUB CloseBox (TOPROW%, LFTCOL%, BOTROW%, RTCOL%)„DECLARE SUB PokeChar (row%, col1, col2, segmnt)„DECLARE SUB Initalize ()„DECLARE SUB Main ()„DECLARE FUNCTION Exist% (FIL$)„DECLARE FUNCTION CRT% ()„DECLARE SUB DrawScreen ()„DECLARE SUB CTRShutDown ()„DECLARE SUB ScrollScreen (Direction%, NumLines%, ULROW%, ULCOL%, LRROW%, LRCOL%)„„DIM SHARED inregs AS RegType, outregs AS RegType„DIM SHARED chars%(1 TO 3000), box%, lastchar%„DIM SHARED boxes%(1 TO 30), ends%(1 TO 30), colors%(1 TO 3000)„DIM SHARED boxstart%, FG%, BG%, fl$, buffer$(1 TO 22)„DIM SHARED seekpos&(1 TO 10000), SaverDelay!„„RANDOMIZE TIMER„CLS„PRINT "VIEWIT - Ver 2.0"„PRINT "Written by John Woodgate 1993..."„PRINT„„IF COMMAND$ <> "" THEN„ fl$ = COMMAND$„ELSE„ LINE INPUT "Enter file to view :", fl$„END IF„IF Exist%(fl$) = 0 THEN„ PRINT "File not found....."„ END„END IF„IF CRT% = 0 THEN     ' 0 = Monochrome  -1 = Color„ FG% = 15: BG% = 0   ' Monochrome Color Set„ELSE„ FG% = 15: BG% = 0„END IF„SaverDelay! = 120   ' Screen Saver Delay in Seconds„„CALL DrawScreen„CALL Main„„SUB CloseBox (TOPROW%, LFTCOL%, BOTROW%, RTCOL%)„„IF box% = 0 THEN EXIT SUB„z = boxes%(box%)„FOR a = TOPROW% TO BOTROW%„  row% = a: col1% = LFTCOL%: col2% = RTCOL%„  segmnt% = z„  CALL PokeChar(row%, col1%, col2%, segmnt%)„  z = z + (RTCOL% - LFTCOL% + 1)„NEXT a„„box% = box% - 1„IF box% = 0 THEN„  lastchar% = 0„  boxstart% = 0„ELSE„  boxstart% = boxes%(box%)„  lastchar% = ends%(box%)„END IF„„„END SUB„„FUNCTION CRT%„„DEF SEG = 0„IF PEEK(&H463) = &HB4 THEN„  CRT% = 0„ELSE„  CRT% = -1„END IF„END FUNCTION„„SUB CRTShutDown  „   „IF CRT% = 0 THEN„ DEF SEG = &HB000„ELSE„ DEF SEG = &HB800„END IF„BSAVE "VIEWIT.TMP", 0, 4000„COLOR 15, 0: CLS„„DO„ rw% = INT(RND * 24) + 1„ cl% = INT(RND * 42) + 1„ LOCATE rw%, cl%„ PRINT "ViewIt Screen Saver, Press any key to Restore.."„ FOR Delay& = 1 TO 20000: NEXT Delay&„ CLS„LOOP WHILE INKEY$ = ""„BLOAD "VIEWIT.TMP", 0„KILL "VIEWIT.TMP"„„END SUB„„SUB DrawBox (TOPROW%, LFTCOL%, BOTROW%, RTCOL%, BORDER%)„„z = lastchar%„IF z >= 3900 THEN„  EXIT SUB„END IF„„' Save the Screen„boxstart% = z + 1„box% = box% + 1„boxes%(box%) = lastchar% + 1„FOR a = TOPROW% TO BOTROW%„   FOR b = LFTCOL% TO RTCOL%„      z = z + 1„      chars%(z) = SCREEN(a, b, 0)„      colors%(z) = SCREEN(a, b, 1)„   NEXT b„NEXT a„lastchar% = z„ends%(box%) = z„„IF BORDER% = 0 THEN„  FOR a = TOPROW% TO BOTROW%„     LOCATE a, LFTCOL%„     PRINT SPACE$(RTCOL% - LFTCOL% + 1);„  NEXT a„  EXIT SUB„END IF„„IF BORDER% = 1 THEN„   LOCATE TOPROW%, LFTCOL%„   st$ = CHR$(218) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(196))  +CHR$(191)„   PRINT st$„   st$ = CHR$(179) + SPACE$(RTCOL% - LFTCOL% - 1) + CHR$(179)„   FOR a = TOPROW% + 1 TO BOTROW% - 1„      LOCATE a, LFTCOL%„      PRINT st$„   NEXT a„   LOCATE BOTROW%, LFTCOL%„   st$ = CHR$(192) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(196)) + CHR$(217)„   PRINT st$„   EXIT SUB„END IF„IF BORDER% = 2 THEN„  LOCATE TOPROW%, LFTCOL%„  st$ = CHR$(201) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(205)) + CHR$(187)„  PRINT st$„  st$ = CHR$(186) + SPACE$(RTCOL% - LFTCOL% - 1) + CHR$(186)„  FOR a = TOPROW% + 1 TO BOTROW% - 1„     LOCATE a, LFTCOL%„     PRINT st$„  NEXT a„  st$ = CHR$(200) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(205)) + CHR$(188)„  LOCATE BOTROW%, LFTCOL%„  PRINT st$„  EXIT SUB„END IF„IF BORDER% = 3 THEN„  st$ = CHR$(213) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(205)) + CHR$(184)„  LOCATE TOPROW%, LFTCOL%   „  PRINT st$„  st$ = CHR$(179) + SPACE$(RTCOL% - LFTCOL% - 1) + CHR$(179)„  FOR a = TOPROW% + 1 TO BOTROW% - 1„     LOCATE a, LFTCOL%„     PRINT st$„  NEXT a„  st$ = CHR$(212) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(205)) + CHR$(190)„  LOCATE BOTROW%, LFTCOL%„  PRINT st$„  EXIT SUB„END IF„IF BORDER% = 4 THEN„  st$ = CHR$(214) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(196)) + CHR$(183)„  LOCATE TOPROW%, LFTCOL%„  PRINT st$„  st$ = CHR$(186) + SPACE$(RTCOL% - LFTCOL% - 1) + CHR$(186)„  FOR a = TOPROW% + 1 TO BOTROW% - 1„     LOCATE a, LFTCOL%„     PRINT st$„  NEXT a„  st$ = CHR$(211) + STRING$(RTCOL% - LFTCOL% - 1, CHR$(196)) + CHR$(189)„  LOCATE BOTROW%, LFTCOL%„  PRINT st$„  EXIT SUB„END IF„„END SUB„„SUB DrawScreen„„LOCATE , , 0: COLOR FG%, BG%: CLS„LOCATE 1, 1„PRINT SPACE$(80);„LOCATE 2, 1„PRINT CHR$(213); STRING$(78, CHR$(205)); CHR$(184);„FOR a = 3 TO 24„  LOCATE a, 1„  PRINT CHR$(179); SPACE$(78); CHR$(176);„NEXT a„LOCATE 25, 1„PRINT CHR$(212); STRING$(78, CHR$(205)); CHR$(190);„LOCATE 25, 66„PRINT CHR$(181); SPACE$(11); CHR$(198);„LOCATE 25, 68„PRINT "F1 - Help";„END SUB„„FUNCTION Exist% (FIL$)„„IF FIL$ = "" THEN„ Exist% = 0„ EXIT FUNCTION„END IF„„OPEN FIL$ FOR BINARY AS #1„IF LOF(1) = 0 THEN„ Exist% = 0„ CLOSE #1„ KILL FIL$„ELSE„ CLOSE #1„ Exist% = -1„END IF„END FUNCTION„„SUB Main„„LOCATE 2, 39 - (LEN(fl$) + 2) \ 2„PRINT CHR$(181); " "; UCASE$(fl$); " "; CHR$(198);„OPEN fl$ FOR INPUT AS #1„COLOR FG%, BG%„CALL DrawBox(9, 20, 13, 60, 1)„„DO„ LINE INPUT #1, dummy$„ Maxlines& = Maxlines& + 1„ IF Maxlines& < 23 THEN buffer$(Maxlines&) = dummy$„ LOCATE 11, 29: PRINT "Reading Line # "; LTRIM$(STR$(Maxlines&))„ IF Maxlines& >= 10000 THEN„  LOCATE 11, 22„  PRINT "File Exceeds 10,000 Line Limit..          "„  LOCATE 13, 33  „  PRINT " Press any key ";   „  SLEEP 0„  CALL CloseBox(9, 20, 13, 60)„  COLOR 15, 0: CLS„  END„ END IF„ seekpos&(Maxlines&) = SEEK(1) - LEN(dummy$) - 2„LOOP UNTIL EOF(1)„CLOSE #1„„FOR a = 1 TO 22„ IF INSTR(buffer$(a), CHR$(12)) > 0 THEN MID$(buffer$(a),INSTR(buffer$(a), CHR$(12)), 1) = " "„NEXT a„OPEN fl$ FOR INPUT AS #1 LEN = 3072„CALL CloseBox(9, 20, 13, 60)„currline& = 1„FOR a = 3 TO 24„  LOCATE a, 2„  IF LEN(buffer$(currline&)) >= 77 THEN„   prnt$ = LEFT$(buffer$(currline&), 77)„  ELSE„   prnt$ = buffer$(currline&)„  END IF„  PRINT prnt$;„  currline& = currline& + 1„NEXT a„currline& = 1„curr% = 3 + (currline& / Maxlines&) * 21„LOCATE curr%, 80: PRINT CHR$(178);„„„   WHILE NOT finished„   GOSUB GetKbd„   SELECT CASE Kbd$„    CASE CHR$(0) + "G"„     GOSUB HomeKey„    CASE CHR$(0) + "O"„     GOSUB EndKey„    CASE CHR$(0) + "H"„     GOSUB ScrollUp„    CASE CHR$(0) + "P"„     GOSUB ScrollDown„    CASE CHR$(0) + "D"„     GOSUB ExitIt„    CASE CHR$(0) + ";"„     GOSUB PrintHelp„    CASE CHR$(0) + "Q"„     GOSUB PageDown„    CASE CHR$(0) + "I"„     GOSUB PageUp„    CASE CHR$(0) + "="„     GOSUB PrintIt„   END SELECT„   WEND„„EXIT SUB„„GetKbd:„Kbd$ = ""„start! = TIMER„GOSUB PrintBar„DO„ Kbd$ = INKEY$„ IF TIMER - start! >= SaverDelay! THEN„  CALL CRTShutDown„  start! = TIMER„ END IF„LOOP WHILE Kbd$ = ""„RETURN„„ScrollUp:„IF currline& > 1 THEN„ currline& = currline& - 1„ SEEK #1, seekpos&(currline&)„ LINE INPUT #1, buffer$(1)„ IF INSTR(buffer$(1), CHR$(12)) > 0 THEN MID$(buffer$(1),INSTR(buffer$(1), CHR$(12)), 1) = " "„ CALL ScrollScreen(1, 1, 3, 2, 24, 79)„ IF LEN(buffer$(1)) >= 78 THEN„  prnt$ = LEFT$(buffer$(1), 78)„ ELSE„  prnt$ = buffer$(1)  „  prnt$ = prnt$ + SPACE$(78 - LEN(prnt$))   „ END IF„ LOCATE 3, 2„ PRINT prnt$;„END IF„RETURN„„„ScrollDown:„IF currline& + 21 < Maxlines& THEN„ currline& = currline& + 1„ SEEK #1, seekpos&(currline& + 21)„ LINE INPUT #1, buffer$(1)„ IF INSTR(buffer$(1), CHR$(12)) > 0 THEN MID$(buffer$(1),INSTR(buffer$(1), CHR$(12)), 1) = " "„ CALL ScrollScreen(0, 1, 3, 2, 24, 79)„ IF LEN(buffer$(1)) >= 78 THEN„  prnt$ = LEFT$(buffer$(1), 78)„ ELSE„  prnt$ = buffer$(1)„  prnt$ = prnt$ + SPACE$(78 - LEN(prnt$))„ END IF„ LOCATE 24, 2„ PRINT prnt$;„END IF„RETURN„„PageUp:„IF currline& - 22 > 0 THEN„ SEEK #1, seekpos&(currline& - 22)„ currline& = currline& - 22: crln& = 1„ FOR a = 1 TO 22„   LINE INPUT #1, buffer$(a)„   IF INSTR(buffer$(a), CHR$(12)) > 0 THEN MID$(buffer$(a),INSTR(buffer$(a), CHR$(12)), 1) = " "„ NEXT a„ FOR a = 3 TO 24„   IF LEN(buffer$(crln&)) >= 78 THEN„    prnt$ = LEFT$(buffer$(crln&), 78)„   ELSE„    prnt$ = buffer$(crln&)„    prnt$ = prnt$ + SPACE$(78 - LEN(prnt$))„   END IF„   LOCATE a, 2„   PRINT prnt$;„   crln& = crln& + 1„ NEXT a„END IF„RETURN„„„PageDown:„IF (currline& + 21) + 21 < Maxlines& THEN„ SEEK #1, seekpos&(currline& + 22)„ currline& = currline& + 22: crln& = 1„ FOR a = 1 TO 22„   LINE INPUT #1, buffer$(a)„   IF INSTR(buffer$(a), CHR$(12)) > 0 THEN MID$(buffer$(a),INSTR(buffer$(a), CHR$(12)), 1) = " "„ NEXT a„ FOR a = 3 TO 24„   IF LEN(buffer$(crln&)) >= 78 THEN„    prnt$ = LEFT$(buffer$(crln&), 78)„   ELSE„    prnt$ = buffer$(crln&)„    prnt$ = prnt$ + SPACE$(78 - LEN(prnt$))„   END IF„   LOCATE a, 2„   PRINT prnt$;„   crln& = crln& + 1„ NEXT a„END IF„RETURN„„„ExitIt:„CALL DrawBox(9, 15, 13, 65, 3)„LOCATE 11, 18, 1„PRINT "(E)xit (S)hell or (R)eturn to Program :";„DO„ GOSUB GetKbd„LOOP UNTIL Kbd$ = "e" OR Kbd$ = "s" OR Kbd$ = "r"„LOCATE , , 0  „IF Kbd$ = "e" THEN   „ COLOR 15, 0„ CLS„ PRINT "If you have amy problems just contact me over"„ PRINT "FIDONet in the QuickBASIC programmers ECHO..."„ END„ELSEIF Kbd$ = "r" THEN„ CALL CloseBox(9, 15, 13, 65)„ RETURN„ELSE„ CALL CloseBox(9, 15, 13, 65)„ IF CRT% THEN„  DEF SEG = &HB800„ ELSE„  DEF SEG = &HB000„ END IF„ BSAVE "VIEWIT.TMP", 0, 4000„ COLOR 15, 0„ CLS„ PRINT "Type EXIT to Return to ViewIt..."„ SHELL„ BLOAD "VIEWIT.TMP", 0„ KILL "VIEWIT.TMP"„ RETURN„END IF„„PrintHelp:„CALL DrawBox(4, 10, 20, 70, 3)„LOCATE 4, 29„PRINT CHR$(181); " Keyboard Commands "; CHR$(198);„LOCATE 6, 12„PRINT "Arrow Keys:  Up --- Scroll up one line"„LOCATE 7, 12„PRINT "             Down - Scroll down one line"„LOCATE 8, 12„PRINT "             PgDn - Scroll down one page"„LOCATE 9, 12„PRINT "             PgUp - Scroll up one page"„LOCATE 10, 12„PRINT "             Home - Move to the top of the Document"„LOCATE 11, 12„PRINT "             End -- Move to the end of the Document"„LOCATE 14, 12„PRINT "Function Keys:  F3 --- Print file"„LOCATE 15, 12„PRINT "                F10 -- Exit ViewIt"„LOCATE 20, 31„PRINT " Press any key ";„SLEEP 0„CALL CloseBox(4, 10, 20, 70)„RETURN„„„PrintIt:„CALL DrawBox(9, 15, 14, 65, 1)„LOCATE 11, 25„PRINT "Printing, press ESC to Cancel"„curseek& = SEEK(1)„SEEK #1, 1„total& = LOF(1)„„DO„ LINE INPUT #1, X$„ printed& = printed& + LEN(X$) + 2„ LPRINT X$„ IF INKEY$ = CHR$(27) THEN„  CALL CloseBox(9, 15, 14, 65)„  LPRINT CHR$(27); "@";„  RETURN„ END IF„ FOR Delay% = 1 TO 5000: NEXT Delay%   ' Give the printer a chance to catch up„ Percent& = printed& / total& * 100„ LOCATE 13, 31„ PRINT USING "###% Complete..."; Percent&„LOOP UNTIL EOF(1)„LPRINT CHR$(12);„FOR Delay% = 1 TO 10000: NEXT Delay%„LPRINT CHR$(27); "@";„CALL CloseBox(9, 15, 14, 65)„RETURN„„PrintBar:  „IF 3 + (currline& / Maxlines&) * 21 <> curr% THEN   „ LOCATE curr%, 80„ PRINT CHR$(176);„ LOCATE 3 + (currline& / Maxlines&) * 21, 80„ PRINT CHR$(178);„ curr% = 3 + (currline& / Maxlines&) * 21„END IF„RETURN„„HomeKey:„IF currline& = 1 THEN RETURN„SEEK #1, seekpos&(1)„currline& = 1: crln& = 1„FOR a = 1 TO 22„ LINE INPUT #1, buffer$(a)„ IF INSTR(buffer$(a), CHR$(12)) > 0 THEN MID$(buffer$(a),INSTR(buffer$(a), CHR$(12)), 1) = " "„NEXT a„FOR a = 3 TO 24„   LOCATE a, 2: PRINT SPACE$(78);„   IF LEN(buffer$(crln&)) >= 78 THEN„    prnt$ = LEFT$(buffer$(crln&), 78)„   ELSE„    prnt$ = buffer$(crln&)„   END IF„   LOCATE a, 2„   PRINT prnt$;„   crln& = crln& + 1„NEXT a„RETURN„„„EndKey:„IF currline& = Maxlines& - 21 THEN RETURN„SEEK #1, seekpos&(Maxlines& - 21)„currline& = Maxlines& - 21: crln& = 1„FOR a = 1 TO 22„ LINE INPUT #1, buffer$(a)„ IF INSTR(buffer$(a), CHR$(12)) > 0 THEN MID$(buffer$(a),INSTR(buffer$(a), CHR$(12)), 1) = " "„NEXT a„FOR a = 3 TO 24„   LOCATE a, 2: PRINT SPACE$(78);„   IF LEN(buffer$(crln&)) >= 78 THEN„    prnt$ = LEFT$(buffer$(crln&), 78)„   ELSE„    prnt$ = buffer$(crln&)„   END IF„   LOCATE a, 2„   PRINT prnt$;„   crln& = crln& + 1„NEXT a„RETURN„END SUB„„SUB PokeChar (row%, col1%, col2%, segmnt%)„„DEF SEG = 0„segment = 0„IF PEEK(&H463) = &HB4 THEN„  DEF SEG = &HB000„ELSE„  DEF SEG = &HB800„END IF„segment = row% * 160 - 160„segment = segment + col1% * 2 - 2„colorseg% = segment + 1„FOR c = segmnt% TO segmnt% + (col2% - col1%)„  POKE segment, chars%(c)„  POKE colorseg, colors%(c)„  segment = segment + 2„  colorseg = colorseg + 2„NEXT c„DEF SEG„END SUB„„SUB ScrollScreen (Direction%, NumLines, ULROW, ULCOL, LRROW, LRCOL)„„' Uses the BIOS Video Interrupt„' to scroll the screen„'„IF Direction% = 0 THEN„ inregs.ax = NumLines + (6 * 256)  „ELSE   „ inregs.ax = NumLines + (7 * 256)„END IF„inregs.bx = BG% * 256„inregs.cx = (ULCOL - 1) + (256 * (ULROW - 1))„inregs.dx = (LRCOL - 1) + (256 * (LRROW - 1))„CALL INTERRUPT(&H10, inregs, outregs)„END SUB„Greg Estabrooks                PACK TEXT                      PACK,TEXT                      06/02/92 (19:42)       QB, QBasic, PDS        80   2138     PACKTEXT.BAS'    Here is a routine that I developed to compress small strings. It„'usually compresses the string (text only) to about 52% of the original„'size of the string.„„DEFINT A-Z„„DECLARE SUB PackTxt (Text$, Comp$, sw%)„„CLS„„Text$ = "This is a test, this is only a test."„„x = LEN(Text$)„PRINT "Text string     =  "; Text$„PRINT "Uncompress Len  = "; x„sw = 0„CALL PackTxt(Text$, Comp$, sw)„„xx = LEN(Comp$)„PRINT„PRINT "Compress Len    = "; xx„PRINT "Compress   %    ="; xx / x„PRINT "Compress string =  "; Comp$„„sw = 1„CALL PackTxt(Text$, Comp$, sw)„PRINT„PRINT "Returned Len    = "; LEN(Text$)„PRINT "Returned string =  "; Text$„„'„SUB PackTxt (Text$, Comp$, sw)„„   d1$ = "  e  as  tinthouerhet anreesr d onn or o i y wo tontyo. neisarte"„   d2$ = "ed,  ctiy  bat snd fal pensestvengitu talehaurllcousa  mf dfoof"„   d3$ = "siril  hmeg om Icehironsasiossbedepe rli Tetel nicho lilprcactut"„   d4$ = "Thpaeceachh wige ebuaisursulmawaotowtsmploI solyee Cunm rtieno S"„   d5$ = "diwhs.rafincademe.irplk  ury Pwoacos gams,duayavucColamowe Aoopu"„„   Dict$ = d1$ + d2$ + d3$ + d4$ + d5$„„   IF sw = 0 THEN„      Comp$ = ""„      DO„         cnt = cnt + 1„         char$ = MID$(Text$, cnt, 2)„         IF cnt = LEN(Text$) THEN„            Comp$ = temp$ + CHR$(ASC(MID$(Text$, cnt, 1)) - 32)„            EXIT SUB„         END IF„         xx = 1„ReDo:„         x = INSTR(xx, Dict$, char$)„         IF x > 0 THEN„            IF (x \ 2) = (x / 2) THEN„               xx = x + 1„               GOTO ReDo„            END IF„            temp$ = temp$ + CHR$((x \ 2) + 96)„            cnt = cnt + 1„         ELSE„            temp$ = temp$ + CHR$(ASC(MID$(Text$, cnt, 1)) - 32)„         END IF„      LOOP WHILE cnt < LEN(Text$)„      Comp$ = temp$„      EXIT SUB„   ELSE„      Text$ = ""„      FOR x = 1 TO LEN(Comp$)„         char = ASC(MID$(Comp$, x, 1))„         IF char > 95 THEN„            Text$ = Text$ + MID$(Dict$, (char - 96) * 2 + 1, 2)„         ELSE„            Text$ = Text$ + CHR$(ASC(MID$(Comp$, x, 1)) + 32)„         END IF„      NEXT„   END IF„„END SUB„„Scott Bailey                   PARSE IT                       Parse,it                       Unknown Date (00:00)   QB, QBasic, PDS        152  3872     PARSEIT.BAS 'PARSEIT by Scott Bailey„'Public Domain„'Extracts verb & noun from full„'sentence like in adventure games„'Probably could use some optimizing„DEFINT A-Z„DECLARE SUB parseit ()„'---------„'Main vars„'---------„'UserInput$=player's input„'V$=VERB returned„'N$=NOUN returned„'V=VERB num returned„'N=NOUN num returned„'Verb$()=VERB list„'Noun$()=NOUN list„'-------------------„'count the verbs & nouns so we know how„'big to make the arrays„DO„    ve = ve + 1„    READ in$„LOOP UNTIL in$ = "end"„DO„    no = no + 1„    READ in$„LOOP UNTIL in$ = "end"„RESTORE„'best to have them shared„DIM SHARED Verb$(ve), noun$(no), UserInput$, v$, n$, v, n„„'all data must be in lowercase„'---------„'Verb data„'---------„DATA kill,throw,shoot,climb,look,inventory,hit,punch,kick„DATA slap,make,save,restore,sing,fly,jump,roll,play,score„DATA time,drink,swallow,poke,stab,roll,push,pull,press,say„DATA run,yell,scream,hop,pour,feed,sit,lay,lie,sleep,nap„DATA take,get,eat,drop,examine,search,dig,read,quit,kiss„DATA list„'data _must_ finish with end„DATA end„'---------„'Noun data„'---------„DATA bottle,bear,cup,self,myself,rock,gun,spear,chair,pouch„DATA light,lamp,water,wine,beer,bird,pop,soda,food,hamburger„DATA mouse,pizza,steak,soup,stew,fork,watch,sandwich„DATA spoon,knife,sword,dagger,tree,bush,lake,pond„DATA wolf,kobold,ogre,lion,computer,time,fly,mosquito„DATA man,woman,girl,boy,baby,radio,car,truck,train,book,tape„DATA pen,key,note,paper,pig,cow,house,mirror,television,floor„DATA ground,stairs,room,piano,banana,phone,quarter,dime„DATA nickel,penny,dollar,money,disk,oven,stove,clock,glass„DATA verbs,nouns„'data _must_ finish with end„DATA end„„'get data„FOR count = 1 TO ve„    READ Verb$(count)„NEXT„FOR count = 1 TO no„    READ noun$(count)„NEXT„'----„'Main„'----„DO„LINE INPUT "What now> "; UserInput$„CLS„parseit„PRINT„PRINT "Verb:"; v$, "Noun:"; n$„PRINT "Verb#"; v, "Noun#"; n„PRINT„'some examples„IF v = 0 THEN PRINT "Please rephrase that."„IF v = 49 THEN END  'quit„IF v = 12 THEN PRINT "SAVE the "; n$; "?"„IF v = 13 THEN PRINT "There is nothing to restore!"„IF v = 6 THEN PRINT "You are not carrying anything yet!"„„IF v = 51 AND n = 83 THEN   'command: 'LIST VERBS'„    FOR k = 1 TO ve„        PRINT Verb$(k),„    NEXT„    PRINT„END IF„„IF v = 51 AND n = 84 THEN   'command: 'LIST NOUNS'„    FOR k = 1 TO no„        PRINT noun$(k),„    NEXT„    PRINT„END IF„„SELECT CASE v„    CASE 1, 2, 3, 7, 8, 9, 10, 24 'response to violence„    PRINT "You can not "; v$;„    IF n THEN„        PRINT " the "; n$; "!"„    ELSE„        PRINT " anything!"„    END IF„END SELECT„v$ = "": n$ = "": v = 0: n = 0„LOOP„„SUB parseit„UserInput$ = LCASE$(UserInput$) + " "„'--------------„'Parse sentence„'-----------------------------„'The first 3 letters of a verb„'and the first 4 letters of a„'noun is all that is needed.„'-----------------------------„DO WHILE LEN(UserInput$)„  FOR ve = 1 TO LEN(UserInput$)„    Char$ = MID$(UserInput$, ve, 1)„    IF Char$ = " " OR Char$ = "!" OR Char$ = "." OR Char$ = ","+_„"" THEN„        VrbHold$ = LEFT$(UserInput$, ve - 1)„        UserInput$ = MID$(UserInput$, ve + 1)„        Count1 = 1„        Count2 = 1„        DO  'get verb„        IF LEFT$(VrbHold$, 3) = LEFT$(Verb$(Count1), 3) THEN„            v$ = Verb$(Count1)„            v = Count1„            ve = 1„        END IF„        Count1 = Count1 + 1„        IF Verb$(Count1) = "end" THEN EXIT DO„        LOOP„„        DO  'get noun„            IF LEFT$(VrbHold$, 4) = LEFT$(noun$(Count2), 4) THEN„                n$ = noun$(Count2)„                n = Count2„                EXIT SUB„            END IF„            Count2 = Count2 + 1„            IF noun$(Count2) = "end" THEN EXIT DO„        LOOP„    END IF„  NEXT„LOOP„END SUB„Matt Hart                      COUNT NUMBER OF LINES          COUNT,NUMBER,LINES             04-16-92 (09:06)       QB, QBasic, PDS        48   1115     COUNTLNS.BAS' COUNTLNS.BAS  Matt Hart„'„' Counts the number of lines in a text file by„' counting occurrances of CR/LF.„' Modify the COMMAND$ for a Text File„„    DEFINT A-Z„    DECLARE FUNCTION CountLines& (File$)„„    F$ = LTRIM$(RTRIM$(COMMAND$))„„    PRINT F$ + " has"; CountLines&(F$); "lines"„    END„„FUNCTION CountLines& (File$)„    S$ = CHR$(13) + CHR$(10)„    F = FREEFILE„    OPEN "B", F, File$„    L& = LOF(F)„    SeekPos = 0&„    CL& = 0&„    DO UNTIL L& < 1&„        IF L& < 4096& THEN„            A$ = SPACE$(L&)„            SeekPos& = SeekPos& + L&„            L& = 0&„        ELSE„            A$ = SPACE$(4096)„            SeekPos& = SeekPos& + 4096&„            L& = L& - 4096&„        END IF„        GET F, , A$„        P = INSTR(A$, S$)„        DO UNTIL P = 0„            CL& = CL& + 1&„            P = P + 2„            P = INSTR(P, A$, S$)„        LOOP„        IF RIGHT$(S$, 1) = CHR$(13) THEN„            L& = L& + 1„            SeekPos& = SeekPos& - 1&„            SEEK #F, SeekPos&„        END IF„    LOOP„    CLOSE F„    CountLines& = CL&„END FUNCTION„„Tony Elliott                   FAR STRING ADDRESS             FAR,STRING,ADDRESS             09-24-92 (15:03)       ASM, QB, PDS           56   2169     FARSTRG.BAS 'From Basic„DECLARE SUB FarStringInfo (A$, Segment%, Offset%, Length%)„A$ = "Xyz123"„CALL FarStringInfo(A$, Segment%, Offset%, Length%)„PRINT "String's address: "; HEX$(Segment%); ":"; HEX$(Offset%)„PRINT "          Length:"; Length%„END„„; ------------- Asm code here....„„.Model Medium               ;I'll avoid the simplified ",BASIC" since„                            ; it's doubtful that A86 supports it.„„Extrn StringLength :Far     ;A PDS/VBDOS API function call„Extrn StringAddress:Far     ;Ditto„„.Code                       ;Code segment begins here„„Public FarStringInfo„FarStringInfo proc far„„    AString equ [bp+0ch]    ;We'll use equates to reference our parameters.„    Segm    equ [bp+0ah]    ;This just makes the code easier to read and„    Ofs     equ [bp+8]      ; maintain (should we add or remove parameters„    Leng    equ [bp+6]      ; in the future, we just need to change the„    Params  = 8             ; assignments here).„„    push BP„    mov     bp,sp           ;Set up a stack frame„„    push    ds              ;Save critical registers (even though in this„    push    si              ; example we don't change them).„    push di„„    mov     ax,AString      ;Pointer to near descriptor into ax„    push    ax              ;Push two copies; 1 for StringLength and„    push    ax              ; another to StringAddress„    call    StringLength    ;Returns length of A$ in AX„    mov     bx,Leng         ;Pointer to Length% into BX„    mov     [bx],ax         ;Plug string length into Length%„    call    StringAddress   ;Returns far address to string data in„dx: AX„    mov     bx,Segm         ;Pointer to Segment% into bx„    mov     [bx],dx         ;String segment into Segment%„    mov     bx,Ofs          ;Pointer to Offset% into bx„    mov     [bx],ax         ;String offset into Offset%„„    pop     di              ;Restore the registers we saved above„    pop si„    pop ds„    pop     bp              ;Restoring BP removes the "frame"„    ret     Params          ;Return to BASIC, popping parameters off of„                            ; the stack.„FarStringInfo endp„END„„Victor Yiu                     MESSAGE FILTER                 MESSAGE,FILTER                 07-28-93 (00:00)       QB, PDS, VBDOS         230  7160     MFILTER.BAS ; ============ MessageFilter v1.0 =============„;„; Strips all LF (ascii 10) and ascii 141s„;„; ======== by Victor Yiu, July 25, 1993 =======„;„; v1.0 -- First release using hybrid in-line code„;„; QB users:„;    DECLARE FUNCTION StripLF% (BYVAL Segm%, BYVAL Offst%, BYVAL Leng%)„;    Text$ = LEFT$(Text$, StripLF(VARSEG(Text$), VARPTR(Text$),  LEN(Text$))„;„; PDS (far string)/VB-DOS users:„;    DECLARE FUNCTION StripLF% (BYVAL FarAddr&, BYVAL Leng%)„;    Text$ = LEFT$(Text$, StripLF(SSEGADD(Text$), LEN(Text$)))„;„; Function returns new length of string, so you should truncate old„; string with a LEFT$(Text$, ResultingCode) after calling this func.„; The reason for different syntaxes is for speed.  BTW -- this routines„; automatically adjusts segment/offset overflows, so no need to adjust them„; in QB program.„;„; This routine is fast!  It minimizes jumps and uses partial in-line coding.„;„CODE SEGMENT PARA PUBLIC 'CODE'„    ASSUME CS:CODE, DS:nothing, ES:nothing, SS:nothing„    PUBLIC StripLF„„LineFeed        EQU     10„OtherBad        EQU     141„„StripLF PROC FAR„        PUSH BP„        MOV BP, SP          ; set up stack frame„        PUSH DS             ; save required variables„        PUSH SI„        PUSH DI„„        LES AX, DWORD PTR SS:[BP+8]     ; load starting and ending addresses„        CLD                             ; go forward„„        MOV DI, AX          ; save copy of offset in DI„        MOV CL, 4           ; divide offset by 16 to add to segment„        SHR AX, CL„        MOV DX, ES          ; add to segment„        ADD DX, AX„        AND DI, 15          ; adjust offset after operation„        MOV ES, DX„        MOV BX, DI          ; save offset in BX for later„        MOV DS, DX„        MOV SI, DI„„        MOV CX, WORD PTR SS:[BP+6]      ; get count„        MOV AX, CX              ; get remainder in AX„        SHR CX, 1               ; divide loop count by 8„        SHR CX, 1„        SHR CX, 1„        AND AX, 7               ; mask„        MOV DL, 10              ; prepare to x10 AL„        INC CX                  ; to take into account the extra loop„        MUL DL„        NEG AX„        ADD AX, OFFSET LoopCheck„        MOV DX, (LineFeed * 256) + OtherBad     ; preload for speed„              ;     DH                DL„        JMP AX„„EVEN            ; each byte processed is 10 bytes of code„StripTop:„        LODSB               ; load byte„        CMP AL, DH          ; LF?„        JE Byte2            ; yep -- skip„        CMP AL, DL          ; 141?„        JE Byte2            ; yep -- skip„        STOSB               ; just store then...„Byte2:  LODSB„        CMP AL, DH„        JE Byte3„        CMP AL, DL„        JE Byte3„        STOSB„Byte3:  LODSB„        CMP AL, DH„        JE Byte4„        CMP AL, DL„        JE Byte4„        STOSB„Byte4:  LODSB„        CMP AL, DH„        JE Byte5„        CMP AL, DL„        JE Byte5„        STOSB„Byte5:  LODSB„        CMP AL, DH„        JE Byte6„        CMP AL, DL„        JE Byte6„        STOSB„Byte6:  LODSB„        CMP AL, DH„        JE Byte7„        CMP AL, DL„        JE Byte7„        STOSB„Byte7:  LODSB„        CMP AL, DH„        JE Byte8„        CMP AL, DL„        JE Byte8„        STOSB„Byte8:  LODSB„        CMP AL, DH„        JE LoopCheck„        CMP AL, DL„        JE LoopCheck„        STOSB„LoopCheck:„        LOOP StripTop„„        MOV DX, DI      ; get new offset count„        SUB DI, BX      ; get length„        MOV AX, DI      ; return result„        POP DI„        POP SI          ; restore registers„        POP DS„        POP BP„        RET 6           ; shave off 6 bytes -- new length returned in AX„StripLF ENDP„End„„;============== end of asm. code.  Look at next message for BASIC„; program to test it.„„'Here's the BASIC source to utilitze the asm. routine? ---------„' ======== CFilter 1.0 =======„' asm. by Victor Yiu„'„' QB users:„'    DECLARE FUNCTION StripLF% (BYVAL Segm%, BYVAL Offst%, BYVAL Leng%)„'    Text$ = LEFT$(Text$, StripLF(VARSEG(Text$), VARPTR(Text$), LEN(Text$))„'„' PDS (far string)/VB-DOS users:„'    DECLARE FUNCTION StripLF% (BYVAL FarAddr&, BYVAL Leng%)„'    Text$ = LEFT$(Text$, StripLF(SSEGADD(Text$), LEN(Text$)))„'„' Function returns new length of string, so you should truncate old„' string with a LEFT$(Text$, ResultingCode) after calling this func.„' The reason for different syntaxes is for speed.  BTW -- this routines„' automatically adjusts segment/offset overflows, so no need to adjust them„' in QB program.„„DECLARE FUNCTION Filter$ (Text$, Array() AS STRING)      'one you call„DECLARE FUNCTION StripLF% (BYVAL FarAddr&, BYVAL Leng%)  'asm func.„DEFINT A-Z„„OPEN "Sample" FOR BINARY AS #1„Text$ = INPUT$(LOF(1), 1): PRINT "Size:"; LOF(1)„CLOSE : IF LEN(Text$) = 0 THEN KILL "sample": PRINT "File?": END„CLS„„DIM Array() AS STRING„„       ' Text$ is modified -- LFs and 141s are stripped„Address$ = Filter$(Text$, Array())„Text$ = ""„„OPEN "Output" FOR OUTPUT AS #1„FOR Num = 1 TO UBOUND(Array)„    PRINT #1, Array(Num);„NEXT„CLOSE„„PRINT Address$„„FUNCTION Filter$ (Text$, MsgText() AS STRING)„    REDIM MsgText(1 TO 200) AS STRING„    AP = 1: CR$ = CHR$(13)„„    ' ==== the FAST asm. procedure„    Text$ = LEFT$(Text$, StripLF(SSEGADD(Text$), LEN(Text$)))„„    Prev = INSTR(Text$, CR$ + CHR$(1) + "MSGID: ")„    IF Prev THEN SpaceAfter = INSTR(Prev + 8, Text$, " ")„    IF SpaceAfter THEN„        Address$ = MID$(Text$, Prev + 8, SpaceAfter - Prev - 7)„    END IF„    IF RIGHT$(Text$, 1) <> CR$ THEN Text$ = Text$ + CR$„„    Pntr = 1: Prev = 1: CurrentTop = 200„    DO„        Pntr = INSTR(Pntr, Text$, CR$)„        IF Pntr THEN                    ' dont include CR$ after each line„            MsgText(AP) = MID$(Text$, Prev, Pntr - Prev)„            Pntr = Pntr + 1: Prev = Pntr: AP = AP + 1„            IF AP > CurrentTop THEN„                CurrentTop = CurrentTop + 50„                REDIM PRESERVE MsgText(1 TO CurrentTop) AS STRING„            END IF„        END IF„    LOOP WHILE Pntr„    AP = AP - 1„    REDIM PRESERVE MsgText(1 TO AP) AS STRING„„    '„    'This portion of code looks for ^aMSGIDs and parses them.  If it doesn't„    'find a valid Fidonet address in the MSGID, it looks for the origin line„    'address (Inside brackets)„    '„    'This portion of code follows directly after the above code.„„    IF INSTR(Address$, ":") = 0 OR INSTR(Address$, "/") = 0 THEN„        FOR X = AP TO 1 STEP -1„            IF LEFT$(MsgText(X), 11) = " ! Origin: " THEN„                LG = LEN(MsgText(X))„                IF ASC(RIGHT$(MsgText(X), 1)) = 41 THEN ')„„                    FOR Y = LG TO 11 STEP -1„                        IF ASC(MID$(MsgText(X), Y)) = 40 THEN„                            EXIT FOR        '(„                        END IF„                    NEXT„                    Address$ = MID$(MsgText(X), Y + 1, LG - Y - 1)„                END IF„            END IF„        NEXT„    END IF„„    Filter$ = Address$„END FUNCTION„Walton Dell                    TINY LIMITED INPUT             TINY,LIMITED,INPUT             10/15/92 (00:00)       QB, QBasic, PDS        60   1802     TINYINPU.BAS'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„'Based on TINYINPU.BAS by Walton Dell - 10/15/92„'A small input routine that allows limited length input.„'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„„DEFINT A-Z„DECLARE FUNCTION TinyInput$ (Original$, Length, AutoCap, Allowed$)„„CLS„COLOR , 1„What$ = TinyInput$("Hello", 12, 0, "")„PRINT What$„„FUNCTION TinyInput$ (Original$, Length, AutoCap, Allowed$)„„Row = POS(0): CursorPos = CSRLIN„„LOCATE Row, CursorPos, 1„„PRINT Original$ + SPACE$(Length - LEN(Original$));„LOCATE , CursorPos + LEN(Original$): Total$ = Original$„„DO„DO„„  Ky$ = INKEY$„LOOP UNTIL Ky$ <> ""„  IF AutoCap THEN Ky$ = UCASE$(Ky$)„„  SELECT CASE ASC(Ky$)             'integer compares are faster than„                                   'string compares„     CASE 13                       '<Enter> time to go„„       TinyInput$ = Total$         'Function returns our string„       LOCATE , , 0: EXIT DO       'off cursor; exit loop to exit function„„     CASE 8                        'Backspace„       IF LEN(Total$) THEN Total$ = LEFT$(Total$, LEN(Total$) - 1)„       LOCATE , CursorPos: PRINT Total$ + " ";„       LOCATE , POS(0) - 1„„     CASE 27                       'Escape (doesn't exit??)„        Total$ = "":„        LOCATE , CursorPos„        PRINT SPACE$(Length); : LOCATE , CursorPos„„     CASE 1 TO 8, 11 TO 255       'all other keys (exc. tab & lf)„        IF AutoCap THEN Ky$ = UCASE$(Ky$)„        IF LEN(Allowed$) THEN„           IF INSTR(Allowed$, Ky$) = 0 THEN Ky$ = ""„        END IF„        IF LEN(Ky$) AND LEN(Total$) < Length THEN„            Total$ = Total$ + Ky$„            PRINT Ky$;„        END IF„    END SELECT„LOOP„„END FUNCTION„„Jeff Shantz                    ASCII CODE EXAMPLE             ASCII,CODE,EXAMPLE             Unknown Date (00:00)   QB, QBasic, PDS        55   2326     EX_ASC.BAS  'Ascii Code Utility By Jeff Shantz„'„'Programmer's Note„'„'This Utility Was Programmed In About 2 Minutes.  I Just Sat Down And Thought„'That It Would Be Nice To Make A Program That Shows User's Some Of The„'Commands In QuickBasic That Aren't Used Everyday.  This Program Uses„'3 Main Commands, STRING$, INKEY$ And ASC.  Many Programmers In QuickBasic„'Who Are Moderately Good Actually Do Not Know Those Three Commands.  They„'Are Quite Useful As INKEY$ And ASC Can Be Used To Make Programs With„'Hotkeys Etc. „'„CLS„N = 1                 'sets the variable used to determine the ascii code to 1„1 FOR I = 1 TO 999999 'start the loop„LOCATE 1, 1           'locates the coordinates 1,1 on the screen„X$ = STRING$(1, N)    'sets the ascii code currently being displayed to X$„„REM Titles And Instructions„COLOR 4: LOCATE 1, 26: PRINT "Ascii Code Utility"„LOCATE 5, 5„COLOR 15: PRINT ""; N; ": "; X$; " "  'prints the two columns„COLOR 7: LOCATE 5, 25: PRINT "Use `[' And `]' To Scroll.  Press Escape To Quit."„COLOR 14: LOCATE 10, 5: PRINT "The Left Column Indicates The Decimal Scan Code And The Right"„LOCATE 11, 5: PRINT "Column Indicates The Character That Accompagnies It."„LOCATE 13, 5: COLOR 4: PRINT "Written By Jeff Shantz"„„'The Following Will Set It So That The Program Acts Upon A Keypress„A$ = INKEY$: IF LEN(A$) = 0 THEN 2„CLS„'the statement below sets it so that if [ is pressed, N is lowered by 1„IF ASC(A$) = 91 THEN N = N - 1„'the statement below sets it so that if ] is pressed, N is raised by 1„IF ASC(A$) = 93 THEN N = N + 1 ELSE N = N 'stays same if other keys pressed„IF ASC(A$) = 27 THEN 3 'if escape is pressed, the program ends„IF N = -1 THEN N = N + 1: GOTO 1 'makes it so that you can't go below 0„IF N = 256 THEN N = N - 1: GOTO 1 'makes it so that you can't go above 255„2 NEXT I„3 SYSTEM 'exits to dos when run from DOS, otherwise just ends the program.„„'Written by Jeff Shantz„'„'A catalogue of other public domain programming examples and other types of„'public domain software written by Jeff Shantz can be obtained by sending„'$2.00 (for shipping & handling) to:„'„'Programming Examples„'c/o Jeff Shantz„'162 Ann Street„'Kitchener,Ontario„'N2B 1Y3, CANADA„'„'or by setting your modem to 8,N,1 and calling The Crypt at 1-(519)-576-3127„„„Jeff Shantz                    LENGTH EXAMPLE                 LENGTH,EXAMPLE                 Unknown Date (00:00)   QB, QBasic, PDS        41   1606     EX_LEN.BAS  'Length Example By Jeff Shantz„'„'Programmer's Note„'„'This Examples Demonstrates The Use Of The Length Of Characters In„'QuickBasic.  It Can Be Used For Any Sort Of Program And Is A Very Useful„'Command.  This Program Uses 2 Main Commands, LEN And STR$.  LEN Is The„'Length Of Whatever Variable Is In The Parentheses That Accompany It.„'STR$ Is Merely Changing The Variable That Is In Parentheses Beside It,„'To The Variable STR$.  These Commands Can Be Useful For Games, Utilities,„'And Many Other Programs. „'„'„'Titles And Instructions„0 CLS : LOCATE 1, 30: COLOR 4: PRINT "Length Example"„LOCATE 3, 20: COLOR 7: PRINT "Enter On Blank Line Or `0' To Quit"„LOCATE 7, 5: INPUT "Type A Number Ranging From 1-7 Digits : ", N„IF N < 1 THEN SYSTEM     'if the input is lower than 1, program exits„'in the statement below, if the input is higher than 7 digits, too high„„IF LEN(STR$(N)) > 8 THEN PRINT "Too High!": SLEEP 1: GOTO 0„ON LEN(STR$(N)) GOTO 1   'if it receives valid input, goes to label 1„'the statement below returns the number of digits that were inputted„1 LOCATE 9, 20: PRINT "You Typed A"; LEN(STR$(N)) - 1; "Digit Number":„PRINT : SLEEP 1: GOTO 0  'returns to 0„„'Written by Jeff Shantz„'„'A catalogue of other public domain programming examples and other types of„'public domain software written by Jeff Shantz can be obtained by sending„'$2.00 (for shipping & handling) to:„'„'Programming Examples„'c/o Jeff Shantz„'162 Ann Street„'Kitchener,Ontario„'N2B 1Y3, CANADA„'„'or by setting your modem to 8,N,1 and calling The Crypt at 1-(519)-576-3127„„„Jeff Shantz                    STRING$ BORDER EXAMPLE         STRING$,BORDER,EXAMPLE         Unknown Date (00:00)   QB, QBasic, PDS        43   1592     EX_STRIN.BAS'Border Example By Jeff Shantz„'„'Programmer's Note„'„'This Example Was Made So That Programmer's Could Learn Some New Techniques„'For Making Border's And Other Things In QuickBasic.  This Example Uses„'1 Main Command, STRING$.  Most People Do Not Know The Use Of STRING$ And„'It Is Actually A Very Useful Command.  I Find That Many Programmers Resort„'To Just Typing All The Characters Out In One Big Print Statement If They„'Want To Make A Border.  With STRING$, You Obviously Don't Have To Do That.„'Of Course, That Is Not The Only Use For STRING$, But With Some Experimenting,„'You'll Find New Uses For It.„'„'„„'Titles And Instructions„1 CLS : LOCATE 2, 25: COLOR 4: PRINT "Border Example"„COLOR 7: LOCATE 1, 63: PRINT "Enter 255 To Exit"„COLOR 15: LOCATE 5, 1: PRINT "Type An Ascii Code In Digital Format (e.g. 197) : "„LOCATE 5, 51: INPUT "", N   'gets the input„IF N = 255 THEN SYSTEM ELSE GOTO 2  'if the input is 255 then program exits„2„COLOR 14„X$ = STRING$(79, N)         'sets the border  „CLS„LOCATE 1, 1: PRINT X$:      'prints the upper border„LOCATE 23, 1: PRINT X$:     'prints the lower border„SLEEP 1: GOTO 1             'returns to label 1„„'Written by Jeff Shantz„'„'A catalogue of other public domain programming examples and other types of„'public domain software written by Jeff Shantz can be obtained by sending„'$2.00 (for shipping & handling) to:„'„'Programming Examples„'c/o Jeff Shantz„'162 Ann Street„'Kitchener,Ontario„'N2B 1Y3, CANADA„'„'or by setting your modem to 8,N,1 and calling The Crypt at 1-(519)-576-3127„„Jeff Shantz                    VIEW PRINT COMMAND             VIEW,PRINT,COMMAND             Unknown Date (00:00)   QB, QBasic, PDS        70   2636     EX_VP.BAS   'View Print Command Example By Jeff Shantz„'„'Programmer's Note„'„'This Utility Was Programmed In About 2 Minutes.  I Just Sat Down And Thought„'That It Would Be Nice To Make A Program That Shows User's Some Of The„'Commands In QuickBasic That Aren't Used Everyday.  This Program Uses„'1 Main Command, View Print.  Many Programmers In QuickBasic Who Are„'Moderately Good Actually Do Not Know This Command.  It Is Quite Useful As„'View Print Can Be Used To Make Programs With Windows In Certain Parts Of„'The Screen Without Affecting Any Other Parts Of The Screen.„'„0 CLS : SCREEN 0: LOCATE 1, 1:„X$ = STRING$(79, 196):     'sets the border to X$„PRINT X$:                  'prints the upper border„LOCATE 11, 1: PRINT X$     'prints the lower border„'Titles And Instructions„LOCATE 1, 19: PRINT "The View Print Command Example - Fake DOS"„LOCATE 15, 5: PRINT "To Clear, Type CLS":„LOCATE 15, 45: PRINT "To Type A File, Enter TYPE"„LOCATE 16, 5: PRINT "To List Directory, Type DIR"„LOCATE 16, 45: PRINT "To Quit, Type QUIT"„VIEW PRINT 2 TO 10         'sets the window to lines 2 and 10 only„CLS„1 INPUT "> ", A$           'simulated `command prompt'„IF A$ = "CLS" THEN CLS : GOTO 1„IF A$ = "cls" THEN CLS : GOTO 1„IF A$ = "TYPE" THEN 2„IF A$ = "type" THEN 2„IF A$ = "DIR" THEN 4„IF A$ = "dir" THEN 4„IF A$ = "QUIT" THEN SYSTEM„IF A$ = "quit" THEN SYSTEM ELSE PRINT : PRINT ">> "; A$; " : Command Not Found": PRINT : GOTO 1„2 INPUT "Which File? ", B$„  IF B$ = "READ.ME" THEN 3„  IF B$ = "read.me" THEN 3 ELSE PRINT ">> File Not Found": GOTO 1„3„CLS„PRINT "File: READ.ME": PRINT  'fake text file„PRINT X$„PRINT "This is a fake text file in a fake dos example written by Jeff Shantz."„PRINT "If you would like more examples by Jeff Shantz or to check out his"„PRINT "Press Any Key To Continue...": SLEEP„PRINT "public domain catalogue, check the end of the source code for details"„PRINT : PRINT "<END OF FILE>": PRINT„PRINT "Press Any Key To Continue...": SLEEP: CLS : GOTO 1„„4„„PRINT : PRINT "Directory Of C:\"„PRINT„PRINT "READ        .ME, 648 bytes, August 18th 1995, 4:35:51 am"„PRINT : PRINT "1 file(s)    648 bytes"„        PRINT "             0 bytes free"„PRINT : GOTO 1„„'Written by Jeff Shantz„'„'A catalogue of other public domain programming examples and other types of„'public domain software written by Jeff Shantz can be obtained by sending„'$2.00 (for shipping & handling) to:„'„'Programming Examples„'c/o Jeff Shantz„'162 Ann Street„'Kitchener,Ontario„'N2B 1Y3, CANADA„'„'or by setting your modem to 8,N,1 and calling The Crypt at 1-(519)-576-3127„„The ABC Programmer             FAST WORD SEARCH SOLVER        FAST,WORD,SEARCH,SOLVER        08-29-95 (00:00)       QB, QBasic, PDS        436  10186    WORDSRCH.BAS'===========================================================„' The Fast Word Search Solver by William Yu (c) 08-29-1995„'„'  Why waste hours doing those simple word search puzzles„'  Why not impress your family/friends by solving it without„' even making a single mark on the puzzle grid, and solving„' the puzzle in just 10 minutes or less! (Depending on your„' typing skills and how big the puzzle grid is).„'  All you have to do is type in the required data and wait„' only seconds for The Fast Word Search Solver to solve it„' for you!  You can disable search methods if your Word„' Search Puzzle does not require it for more speed!„'  Default Search Method (You can change the order):„'      Horizontal Find„'      Backward Horizontal Find„'      Vertical Find„'      Backward Vertical Find„'      Diagonal Right and Down Find„'      Diagonal Left and Down Find„'      Diagonal Right and Up Find„'      Diagonal Left and Up Find„' Timed Searches for (Within Basic environment):„' Out of 5 trials, fastest time recorded:„'        286/16MHz     64.22 seconds    20/20 Grid  82 Words„'        386/25MHz     16.31 seconds       "          "„'        486/33MHz     4.56  seconds       "          "„'        486DX2/66MHz  1.81  seconds       "          "„' All times are approximate, larger words take more„' time to find.  More words and larger grids take more„' time to search.„'  The times could be faster if you disable the letter„' spacing.  Try it and see how fast it can really go!„'===========================================================„„DEFINT A-Z„DECLARE SUB HorizontalFind (I, Max, Found, Find$)„DECLARE SUB HorizontalBackFind (I, Max, Found, Find$)„DECLARE SUB VerticalFind (I, Max, Found, Find$)„DECLARE SUB VerticalBackFind (I, Max, Found, Find$)„DECLARE SUB DiagonalFind (I, Max, Found, Find$, Direction)„DECLARE SUB DiagonalBackFind (I, Max, Found, Find$, Direction)„„SCREEN 0, 0, 0, 0„„REDIM SHARED Column$(50)   ' Maximum is 50, but change if neccessary„„CONST Max=20               ' How many Columns does your grid have„                           ' Rows would be the better word, but who cares„„OPEN "PUZZLE.DAT" FOR INPUT AS #1„  FOR I = 1 TO Max„    LINE INPUT #1, Column$(I)„    FOR X = 1 TO LEN(Column$(I))„      PRINT MID$(Column$(I), X, 1); " ";  ' You can disable the spacing„    NEXT X„    PRINT„  NEXT I„CLOSE #1„„'Uncomment this to manually type and find each word„'DO„'  LOCATE 2, 50„'  LINE INPUT "Find: "; Find$„'  Find$ = UCASE$(Find$)„'  IF Find$ = "" THEN END„'  GOSUB Find„'  COLOR , 0„'  LOCATE 2, 55: PRINT SPACE$(20)„'LOOP„„OPEN "PUZZLE.FND" FOR INPUT AS #1„  T! = TIMER„  DO„    LINE INPUT #1, Find$„    LOCATE 2, 50: PRINT "Find: "; Find$„    GOSUB Find„    COLOR , 0„    LOCATE 2, 55: PRINT SPACE$(25)„  LOOP UNTIL EOF(1)„  LOCATE 10, 47: PRINT "Seconds to Find all: "; : PRINT USING "###.##"; TIMER - T!„CLOSE #1„„SLEEP„END„„„' You can disable the spacing and for Horizontal Finds for more speed„' and take out the For/Next Loop„„Find:„HorizontalFind I, Max, Found, Find$„IF Found = 0 THEN HorizontalBackFind I, Max, Found, Find$„IF Found = 0 THEN„  VerticalFind I, Max, Found, Find$„ELSE„  LOCATE I, Found + Found - 1: COLOR , 1„  FOR X = 1 TO LEN(Find$)„    PRINT MID$(Find$, X, 1); : COLOR , 0: PRINT " "; : COLOR , 1„  NEXT X„  RETURN„END IF„IF Found = 0 THEN VerticalBackFind I, Max, Found, Find$„IF Found = 0 THEN„  DiagonalFind I, Max, Found, Find$, Direction„ELSE„  LOCATE Found, I + I - 1: COLOR , 1„  FOR X = 1 TO LEN(Find$)„    PRINT MID$(Find$, X, 1); : COLOR , 0: PRINT " "; : COLOR , 1„    PRINT„    LOCATE , I + I - 1„  NEXT X„  RETURN„END IF„IF Found = 0 THEN„  DiagonalBackFind I, Max, Found, Find$, Direction„ELSE„  LOCATE I, Found + Found - 1: COLOR , 1„  FOR X = 1 TO LEN(Find$)„    PRINT MID$(Find$, X, 1)„    IF Direction = 1 THEN LOCATE I + X, Found + Found + (X * 2) - 1 ELSE LOCATE I + X, ABS(Found + Found - (X * 2) - 1)„  NEXT X„  RETURN„END IF„IF Found = 0 THEN„  LOCATE 4, 50: PRINT SPACE$(30)„  LOCATE 4, 50: COLOR , 0: PRINT Find$; " not found."„ELSE„  LOCATE I, Found + Found - 1: COLOR , 1„  FOR X = 1 TO LEN(Find$)„    PRINT MID$(Find$, X, 1)„    IF Direction = 1 THEN LOCATE I + X, Found + Found + (X * 2) - 1 ELSE LOCATE I + X, ABS(Found + Found - (X * 2) - 1)„  NEXT X„END IF„„RETURN„„SUB DiagonalBackFind (I, Max, Found, Find$, Direction)„„BackUpFind$ = Find$„„FOR X = Max TO 1 STEP -1„ BackFind$ = BackFind$ + MID$(Find$, X, 1)„NEXT X„„Find$ = BackFind$„„FirstLetter$ = LEFT$(Find$, 1)„„I = 0„DO„  I = I + 1„  FindSecond$ = ""„  IF (Max - I) < LEN(Find$) - 1 THEN EXIT DO„  Where = INSTR(Column$(I), FirstLetter$)„  DO WHILE Where„  IF Where THEN„    '  \„    '    \     Searches left and up„    '      \„    IF LEN(Column$(I)) - Where >= LEN(Find$) - 1 THEN„      Y = I: Z = 1„      FOR X = Where + 1 TO Where + LEN(Find$) - 1„        Y = Y + 1: Z = Z + 1„        IF MID$(Column$(Y), X, 1) <> MID$(Find$, Z, 1) THEN EXIT FOR„        FindSecond$ = FindSecond$ + MID$(Column$(Y), X, 1)„      NEXT X„      FindSecond$ = FirstLetter$ + FindSecond$„      IF FindSecond$ = Find$ THEN Found = Where: Direction = 1: EXIT SUB„    END IF„    '      /„    '    /      Searches right and up„    '  /„    IF Where - LEN(Find$) >= 0 THEN„      FindSecond$ = ""„      Y = I: Z = 1„      FOR X = Where - 1 TO Where - LEN(Find$) + 1 STEP -1„        Y = Y + 1: Z = Z + 1„        IF MID$(Column$(Y), X, 1) <> MID$(Find$, Z, 1) THEN EXIT FOR„        FindSecond$ = FindSecond$ + MID$(Column$(Y), X, 1)„      NEXT X„      FindSecond$ = FirstLetter$ + FindSecond$„      IF FindSecond$ = Find$ THEN Found = Where: Direction = 2: EXIT SUB„    END IF„  END IF„  Where = INSTR(Where + 1, Column$(I), FirstLetter$)„  FindSecond$ = ""„  LOOP„LOOP„„Find$ = BackUpFind$„„END SUB„„SUB DiagonalFind (I, Max, Found, Find$, Direction)„„FirstLetter$ = LEFT$(Find$, 1)„„I = 0„DO„  I = I + 1„  FindSecond$ = ""„  IF (Max - I) < LEN(Find$) - 1 THEN EXIT DO„  Where = INSTR(Column$(I), FirstLetter$)„  DO WHILE Where„    IF Where THEN„      IF LEN(Column$(I)) - Where >= LEN(Find$) - 1 THEN„        ' \„        '   \     Searches right and down„        '     \„        Y = I: Z = 1„        FOR X = Where + 1 TO Where + LEN(Find$) - 1„          Y = Y + 1: Z = Z + 1„          IF MID$(Column$(Y), X, 1) <> MID$(Find$, Z, 1) THEN EXIT FOR„          FindSecond$ = FindSecond$ + MID$(Column$(Y), X, 1)„        NEXT X„        FindSecond$ = FirstLetter$ + FindSecond$„        IF FindSecond$ = Find$ THEN Found = Where: Direction = 1: EXIT SUB„      END IF„        '      /„        '    /     Searches left and down„        '  /„      IF Where - LEN(Find$) >= 0 THEN„        FindSecond$ = ""„        Y = I: Z = 1„        FOR X = Where - 1 TO Where - LEN(Find$) + 1 STEP -1„          Y = Y + 1: Z = Z + 1„          IF MID$(Column$(Y), X, 1) <> MID$(Find$, Z, 1) THEN EXIT FOR„          FindSecond$ = FindSecond$ + MID$(Column$(Y), X, 1)„        NEXT X„        FindSecond$ = FirstLetter$ + FindSecond$„        IF FindSecond$ = Find$ THEN Found = Where: Direction = 2: EXIT SUB„      END IF„    END IF„    Where = INSTR(Where + 1, Column$(I), FirstLetter$)„    FindSecond$ = ""„  LOOP„LOOP„„END SUB„„SUB HorizontalBackFind (I, Max, Found, Find$)„„'Reverse FIND$ Horizontal Back Find„„BackUpFind$ = Find$„„FOR X = Max TO 1 STEP -1„ BackFind$ = BackFind$ + MID$(Find$, X, 1)„NEXT X„„Find$ = BackFind$„„I = 0„DO„  I = I + 1„  Found = INSTR(Column$(I), Find$)„  IF Found THEN EXIT DO„LOOP UNTIL I = Max„„IF Found = 0 THEN Find$ = BackUpFind$„„END SUB„„SUB HorizontalFind (I, Max, Found, Find$)„„'Horizontal Find„„I = 0„DO„  I = I + 1„  Found = INSTR(Column$(I), Find$)„  IF Found THEN EXIT DO„LOOP UNTIL I = Max„„END SUB„„SUB VerticalBackFind (I, Max, Found, Find$)„„REDIM VerticalColumn$(50)„„BackUpFind$ = Find$„„FOR X = Max TO 1 STEP -1„ BackFind$ = BackFind$ + MID$(Find$, X, 1)„NEXT X„„Find$ = BackFind$„„FOR Y = 1 TO LEN(Column$(1))„  FOR X = 1 TO Max„    VerticalColumn$(Y) = VerticalColumn$(Y) + MID$(Column$(X), Y, 1)„  NEXT X„NEXT Y„„I = 0„DO„  I = I + 1„  Found = INSTR(VerticalColumn$(I), Find$)„  IF Found THEN EXIT DO„LOOP UNTIL I = LEN(VerticalColumn$(I))„„ERASE VerticalColumn$„IF Found = 0 THEN Find$ = BackUpFind$„„END SUB„„SUB VerticalFind (I, Max, Found, Find$)„„REDIM VerticalColumn$(50)„„FOR Y = 1 TO LEN(Column$(1))„  FOR X = 1 TO Max„    VerticalColumn$(Y) = VerticalColumn$(Y) + MID$(Column$(X), Y, 1)„  NEXT X„NEXT Y„„I = 0„DO„  I = I + 1„  Found = INSTR(VerticalColumn$(I), Find$)„  IF Found THEN EXIT DO„LOOP UNTIL I = LEN(VerticalColumn$(I))„„ERASE VerticalColumn$„„END SUB„„„'------------[ Begin PUZZLE.DAT ]---------------„LEGNASSSSSTSEUGSYOBP„SELORTELGSERRRATNASL„NEMKNEEVNEGSAIIMNRSA„PNIERPPTIINNEVOEEUUN„YRRRAAGAPWDEIIEHAROT„LAEHRLPRPFSTRKTLCIRM„PECSPESSARADKOCRTMIY„PLSEEOBTRNEIRESOASCT„AVNNLNHNWSDBFIMITPOU„CEOGIETSASEMMEBLTSUR„OSISRTBSURLLOEEBSYSK„UHTSEIDRACCOCTCLOOIE„NTANRIPGAACVONHEINNY„TMRCURDORTHENTUEDNSS„RROIIASOMSISTERSRPGL„YACSPTLDOGLOWACERSIS„SWEETSRWMGDBNMHEAGFG„ISDOOFIIMERAHSERHTTN„DADDYAGLYSEKACSTARSO„ERAFAMILYLNEHUSBANDS„'------------[ End PUZZLE.DAT ]---------------„„„'------------[ Begin PUZZLE.FND ]---------------„ANGEL„APPLY„AUNTS„BAKE„BIRDS„BROTHERS„BOYS„CAKES„CARD„CAROLS„CELEBRATIONS„CHAPELS„CHILDREN„CHOIRS„CHURCHES„CLAUS„COUNTRYSIDE„COUSINS„CRANBERRIES„CRIBS„DADDY„DECEMBER„DECORATIONS„ELVES„EMOTION„FAMILY„FARE„FEELINGS„FOODS„GENEROSITY„GIFTS„GIRLS„GLOW„GOODIES„GOODWILL„GRANDFATHERS„GRANDMOTHERS„GRIP„GUESTS„HUSBANDS„KEEN„KIDS„LEARN„LIGHTS„LOVES„MEALS„MERRY„MISTLETOE„MOMMY„NATIVITY„PAPER„PARENTS„PARTIES„PLANT„PRESENTS„RIBBONS„ROLES„SANTA„SHARE„SHOP„SISTERS„SONGS„SONS„SPARKLE„SPREE„STARS„STOCKINGS„SURPRISES„SWEETS„TEAMS„TINSEL„TOOLS„TRAVEL„TREATS„TREES„TRIPS„TURKEYS„TURNS„UNCLES„WARMTH„WIVES„WRAPPING„'------------[ End PUZZLE.FND ]---------------„The ABC Programmer             ULTIMATE TEXT VIEWER           ULTIMATE,TEXT,VIEWER           Year of 1994           QB, QBasic, PDS        1041 36593    UTV.BAS     '==========================================================„' The Ultimate TEXT Viewer Programmed by William Yu (1994)„' Use within a commercial product is strictly prohibited„' Modify as you wish, includes a file directory listing„'==========================================================„„DECLARE SUB HELP1 ()„DECLARE SUB HELP2 ()„DECLARE SUB HELP3 ()„„'$DYNAMIC„DEFINT A-Z„„CONST FALSE = 0„CONST TRUE = NOT FALSE„FPC = FALSE„YC = 1„„CLS : LOCATE , , 0„SHELL "DIR /AD/O > Drive.LST"„„OPEN "Drive.LST" FOR INPUT AS #1„DO„  LINE INPUT #1, CurrentDrive$„LOOP UNTIL INSTR(1, CurrentDrive$, ":\")„„CLOSE 1„KILL "DRIVE.LST"„„Y = LEN(CurrentDrive$)„CurDir$ = MID$(CurrentDrive$, 15, Y)„CurDrive$ = MID$(CurrentDrive$, 15, 2)„DefaultDir$ = MID$(CurrentDrive$, 15, Y)„„Escape = FALSE„'File$ = COMMAND$              'For QB/PDS„START:„CAP = FALSE: YC = 1„ON ERROR GOTO ERRORHANDLE„OPEN File$ FOR INPUT AS #1„REDIM Seeks&(1 TO 16000)       'Use 32767 /ah for QB and to compile (BC)„„CurSeek& = 1„Numlines = 0„COLOR 0, 1„FOR J = 1 TO 25„LOCATE J, 1: PRINT STRING$(80, 0)„NEXT J„COLOR 15, 4: LOCATE 25, 1: PRINT "  The Ultimate Text Viewer Version 0.02  FREEWARE"; : COLOR 7, 4: PRINT "  <"; : COLOR 11: PRINT "1"; : COLOR 10: PRINT "2"; : COLOR 3: PRINT "3"; : COLOR 12: PRINT "4"; : COLOR 13: PRINT "5"; : COLOR 14: PRINT "6"; : COLOR 7: PRINT "7"; : COLOR 15: PRINT "8"; : COLOR 9: PRINT "9"; : COLOR 7: PRINT ">"; : COLOR 10: PRINT "  Color Change    "„COLOR 0, 1: LOCATE 24, 1: PRINT STRING$(80, 0)„LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "; : COLOR 15: PRINT "C"; : COLOR 0: PRINT "APTURE     "; : COLOR 15: PRINT "H"; : COLOR 0: PRINT "ELP!                                                   "„„DO UNTIL EOF(1)„  LINE INPUT #1, Text$„  Numlines = Numlines + 1„  Seeks&(Numlines) = CurSeek&          ' Save starting position„  CurSeek& = CurSeek& + LEN(Text$) + 2 ' Next position - 2 is„  LOCATE 1, 60: COLOR 14, 3: PRINT Numlines„  V$ = INKEY$„  IF V$ = CHR$(27) THEN EXIT DO„LOOP                                     ' for C/R & LF„„LOCATE 1, 1„„CurCol = 1                               ' Current Column„SeekEl = 1                               ' Current line„Escape = FALSE„„COLOR 7, 1: X = 7„„DO„  GOSUB LoadAndDisplay„  GOSUB KeyProcess„LOOP UNTIL Escape„„CLOSE„LOCATE 25, 1: COLOR 7, 0: PRINT STRING$(80, 0): LOCATE 24, 1: COLOR 7, 0: PRINT "Thanks for Using The Ultimate Text Viewer Version 0.02  FREEWARE Copy!  (c) 1994": GOTO QUIT„„LoadAndDisplay:„  SEEK #1, Seeks&(SeekEl)„„  FOR I = 2 TO 24„    IF NOT EOF(1) THEN LINE INPUT #1, Text$ ELSE Text$ = ""„    COLOR X, YC„    Strg$ = SPACE$(80)„    IF LEN(Text$) < CurCol THEN Text$ = Text$ + SPACE$(CurCol - LEN(Text$))„    LSET Strg$ = MID$(Text$, CurCol)„    IF NOT EOF(1) AND INSTR(1, Strg$, "") THEN LINE INPUT #1, Text$: Strg$ = SPACE$(80): LSET Strg$ = MID$(Text$, CurCol)„    IF CAP = TRUE AND I = 2 THEN LOCATE I, 1, 0: COLOR 15, 4: PRINT Strg$: COLOR 7, 0: GOTO CF„    LOCATE I, 1, 0: PRINT Strg$;„CF:„IF CAP = TRUE THEN LOCATE 1, 45: COLOR 1, 3: PRINT PS; : COLOR 0, 3: PRINT CHR$(26); : COLOR 1, 3: PRINT SeekEl„  LOCATE 1, 60: COLOR 14, 3: PRINT Numlines; : COLOR 10: PRINT ":"; : COLOR 4: PRINT SeekEl; : COLOR 10: PRINT ":"; : COLOR 15: PRINT CurCol„    COLOR X, YC„  NEXT I„RETURN„„„KeyProcess:„„  DO„    Ky$ = INKEY$„  LOOP UNTIL LEN(Ky$)                'Wait for a keypress„„  IF LEN(Ky$) = 1 THEN               'Create a key code„    KeyCode = ASC(Ky$)               'Regular character key„  ELSE                               'Extended key„    KeyCode = -ASC(RIGHT$(Ky$, 1))„  END IF„„  SELECT CASE KeyCode„    CASE 27„      Escape = TRUE        ' ESC„„    CASE -72             ' Up Arrow„      SeekEl = SeekEl - 1„      IF SeekEl < 1 THEN SeekEl = 1: GOTO KeyProcess„„    CASE -80             ' Dn Arrow„      SeekEl = SeekEl + 1„      IF SeekEl > Numlines THEN SeekEl = SeekEl - 1: GOTO KeyProcess„„    CASE -77             ' Right Arrow„      CurCol = CurCol + 1„„    CASE -75             ' Left Arrow„      CurCol = CurCol - 1„      IF CurCol < 1 THEN CurCol = 1: GOTO KeyProcess„„    CASE -73           ' Page Up„      SeekEl = SeekEl - 23„      IF SeekEl < 1 THEN SeekEl = 1„„    CASE -81, 13, 32           ' Page Dn„      SeekEl = SeekEl + 23„      IF SeekEl > Numlines THEN„        SeekEl = Numlines - 23: GOTO KeyProcess„      END IF„„    CASE -71                       ' Home„    LOCATE 1, 70: COLOR 15, 3: PRINT "          "„      SeekEl = 1„„    CASE -79                       ' End„      SeekEl = Numlines - 23„      IF SeekEl < 1 THEN SeekEl = 1: GOTO KeyProcess„„    CASE 49„      X = 11„    CASE 50„      X = 10„    CASE 51„      X = 3„    CASE 52„      X = 12„    CASE 53„      X = 13„    CASE 54„      X = 14„    CASE 55„      X = 7„    CASE 56„      X = 15„    CASE 57„      X = 9„    CASE 70„      GOSUB FKEY„    CASE 102„      GOSUB FKEY„„    CASE 67„      GOSUB CAPTURE„    CASE 99„      GOSUB CAPTURE„„    CASE 72„      GOSUB HELP„    CASE 104„      GOSUB HELP„„    CASE -59„       CALL HELP2„    CASE -60„    TextFile$ = "TXT"„       GOTO LISTFILES„    CASE -61„    TextFile$ = "*"„       GOTO LISTFILES„    CASE -62„       FPC = TRUE: PCOPY 0, 1: GOTO PRINTER„    CASE -63„       PCOPY 0, 1: GOSUB CAPON„    CASE -64„       PCOPY 0, 1: GOSUB CAPOFF„    CASE -65„       PCOPY 0, 1: GOSUB SAVECAP„    CASE -66„       PCOPY 0, 1: GOSUB DOSSHELL„„    CASE ELSE„      GOTO KeyProcess„„    END SELECT„„RETURN„„FKEY:„FPC = FALSE„PCOPY 0, 1„FOR R = 3 TO 11„LOCATE R, 4: COLOR 0, 0: PRINT STRING$(21, 0)„NEXT R„LOCATE 1, 3: COLOR 15, 4: PRINT " F"; : COLOR 10, 4: PRINT "ILE "„LOCATE 2, 2: COLOR 0, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 3, 2: PRINT CHR$(179); : COLOR 15, 0: PRINT " O"; : COLOR 7, 0: PRINT "pen Text File... "; : COLOR 0, 3: PRINT CHR$(179)„LOCATE 4, 2: PRINT CHR$(179); : COLOR 15, 3: PRINT " L"; : COLOR 0: PRINT "ist All Files    "; CHR$(179)„LOCATE 5, 2: PRINT CHR$(195); STRING$(19, 196); CHR$(180)„LOCATE 6, 2: PRINT CHR$(179); : COLOR 15, 3: PRINT " P"; : COLOR 0: PRINT "rint Entire File "; CHR$(179)„LOCATE 7, 2: PRINT CHR$(179); : COLOR 15, 3: PRINT " D"; : COLOR 0: PRINT "OS Shell...      "; CHR$(179)„LOCATE 8, 2: PRINT CHR$(195); STRING$(19, 196); CHR$(180)„LOCATE 9, 2: PRINT CHR$(179); : COLOR 0, 3: PRINT " E"; : COLOR 15, 3: PRINT "x"; : COLOR 0, 3: PRINT "it              "; CHR$(179)„LOCATE 10, 2: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„ROW = 3„FKEYSEL:„V$ = INKEY$„IF UCASE$(V$) = "X" THEN LOCATE 25, 1: COLOR 7, 0: PRINT STRING$(80, 0): LOCATE 24, 1: COLOR 7, 0: PRINT "Thanks for Using The Ultimate Text Viewer Version 0.02  FREEWARE Copy!  (c) 1994": GOTO QUIT„IF UCASE$(V$) = "P" THEN GOTO PRINTER„IF UCASE$(V$) = "O" THEN TextFile$ = "TXT": GOTO LISTFILES„IF UCASE$(V$) = "L" THEN TextFile$ = "*": GOTO LISTFILES„IF UCASE$(V$) = "D" THEN GOTO DOSSHELL„IF V$ = CHR$(0) + "P" THEN ROW = ROW + 1: GOSUB DOWN„IF V$ = CHR$(0) + "H" THEN ROW = ROW - 1: GOSUB UP„IF V$ = CHR$(0) + "M" THEN PCOPY 1, 0: GOTO CAPTURE„IF V$ = CHR$(0) + "K" THEN PCOPY 1, 0: GOTO HELP„IF V$ = CHR$(13) THEN GOTO ENTER„IF V$ = CHR$(0) + ";" THEN CALL HELP2     'F1„IF V$ = CHR$(0) + "<" THEN TextFile$ = "TXT": GOTO LISTFILES 'F2„IF V$ = CHR$(0) + "=" THEN TextFile$ = "*": GOTO LISTFILES'F3„IF V$ = CHR$(0) + ">" THEN GOSUB PRINTER   'F4„IF V$ = CHR$(0) + "?" THEN GOTO CAPON     'F5„IF V$ = CHR$(0) + "@" THEN GOTO CAPOFF    'F6„IF V$ = CHR$(0) + "A" THEN GOTO SAVECAP   'F7„IF V$ = CHR$(0) + "B" THEN GOTO DOSSHELL  'F8„IF V$ = CHR$(27) THEN PCOPY 1, 0: RETURN„GOTO FKEYSEL„DOWN:„IF ROW = 8 THEN ROW = 3„IF ROW = 3 THEN LOCATE ROW, 3: COLOR 15, 0: PRINT " O"; : COLOR 7, 0: PRINT "pen Text File... ": LOCATE 9, 3: COLOR 0, 3: PRINT " E"; : COLOR 15, 3: PRINT "x"; : COLOR 0, 3: PRINT "it              "„IF ROW = 4 THEN LOCATE ROW, 3: COLOR 15, 0: PRINT " L"; : COLOR 7, 0: PRINT "ist All Files    ": LOCATE 3, 3: COLOR 15, 3: PRINT " O"; : COLOR 0, 3: PRINT "pen Text File... "„IF ROW = 5 THEN LOCATE 6, 3: COLOR 15, 0: PRINT " P"; : COLOR 7, 0: PRINT "rint Entire File ": LOCATE 4, 3: COLOR 15, 3: PRINT " L"; : COLOR 0, 3: PRINT "ist All Files    "„IF ROW = 6 THEN LOCATE 7, 3: COLOR 15, 0: PRINT " D"; : COLOR 7, 0: PRINT "OS Shell...      ": LOCATE 6, 3: COLOR 15, 3: PRINT " P"; : COLOR 0, 3: PRINT "rint Entire File "„IF ROW = 7 THEN LOCATE 9, 3: COLOR 7, 0: PRINT " E"; : COLOR 15, 0: PRINT "x"; : COLOR 7, 0: PRINT "it              ": LOCATE 7, 3: COLOR 15, 3: PRINT " D"; : COLOR 0, 3: PRINT "OS Shell...      "„RETURN„UP:„IF ROW = 2 THEN ROW = 7„IF ROW = 7 THEN LOCATE 3, 3: COLOR 15, 3: PRINT " O"; : COLOR 0, 3: PRINT "pen Text File... ": LOCATE 9, 3: COLOR 7, 0: PRINT " E"; : COLOR 15, 0: PRINT "x"; : COLOR 7, 0: PRINT "it              "„IF ROW = 3 THEN LOCATE 4, 3: COLOR 15, 3: PRINT " L"; : COLOR 0, 3: PRINT "ist All Files    ": LOCATE 3, 3: COLOR 15, 0: PRINT " O"; : COLOR 7, 0: PRINT "pen Text File... "„IF ROW = 4 THEN LOCATE 6, 3: COLOR 15, 3: PRINT " P"; : COLOR 0, 3: PRINT "rint Entire File ": LOCATE 4, 3: COLOR 15, 0: PRINT " L"; : COLOR 7, 0: PRINT "ist All Files    "„IF ROW = 5 THEN LOCATE 7, 3: COLOR 15, 3: PRINT " D"; : COLOR 0, 3: PRINT "OS Shell...      ": LOCATE 6, 3: COLOR 15, 0: PRINT " P"; : COLOR 7, 0: PRINT "rint Entire File "„IF ROW = 6 THEN LOCATE 9, 3: COLOR 0, 3: PRINT " E"; : COLOR 15, 3: PRINT "x"; : COLOR 0, 3: PRINT "it              ": LOCATE 7, 3: COLOR 15, 0: PRINT " D"; : COLOR 7, 0: PRINT "OS Shell...      "„RETURN„ENTER:„IF ROW = 7 THEN LOCATE 25, 1: COLOR 7, 0: PRINT STRING$(80, 0): LOCATE 24, 1: COLOR 7, 0: PRINT "Thanks for Using The Ultimate Text Viewer Version 0.02  FREEWARE Copy!  (c) 1994": GOTO QUIT„IF ROW = 6 THEN GOTO DOSSHELL„IF ROW = 5 THEN GOTO PRINTER„IF ROW = 4 THEN TextFile$ = "*": GOTO LISTFILES„IF ROW = 3 THEN TextFile$ = "TXT": GOTO LISTFILES„„LISTFILES:„PCOPY 1, 0„SHELL "DIR /AD/O > Drive.LST"„„„'=============================„'    Current Drive / Path„'=============================„„DosCmd$ = "DIR *." + TextFile$ + " /B /ON > DIR.LST"„SHELL DosCmd$„LOCATE 2, 4: COLOR 12, 0: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„LOCATE 3, 4: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„LOCATE 4, 4: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„LOCATE 3, 6: COLOR 10: PRINT CurDir$ + "\*."; TextFile$„„LOCATE 6, 10: COLOR 11: PRINT CHR$(218); STRING$(20, 196); CHR$(191)„FOR J = 7 TO 16„  LOCATE J, 10: PRINT CHR$(179); STRING$(20, 0); CHR$(179)„NEXT J„LOCATE 17, 10: PRINT CHR$(192); STRING$(20, 196); CHR$(217)„FOR J = 7 TO 18„LOCATE J, 32: COLOR 7, 8: PRINT STRING$(2, 176)„IF J = 18 THEN LOCATE J, 12: PRINT STRING$(20, 176)„NEXT J„„LOCATE 6, 36: COLOR 11: PRINT CHR$(218); STRING$(12, 196); CHR$(191)„FOR J = 7 TO 16„  LOCATE J, 36: PRINT CHR$(179); STRING$(12, 0); CHR$(179)„NEXT J„LOCATE 17, 36: PRINT CHR$(192); STRING$(12, 196); CHR$(217)„FOR J = 7 TO 18„LOCATE J, 50: COLOR 7, 8: PRINT STRING$(2, 176)„IF J = 18 THEN LOCATE J, 38: PRINT STRING$(12, 176)„NEXT J„„LOCATE 6, 54: COLOR 11: PRINT CHR$(218); STRING$(9, 196); CHR$(191)„FOR J = 7 TO 14„  LOCATE J, 54: PRINT CHR$(179); STRING$(9, 0); CHR$(179)„NEXT J„LOCATE 15, 54: PRINT CHR$(192); STRING$(9, 196); CHR$(217)„FOR J = 7 TO 16„LOCATE J, 65: COLOR 7, 8: PRINT STRING$(2, 176)„IF J = 16 THEN LOCATE J, 56: PRINT STRING$(9, 176)„NEXT J„„LOCATE 7, 57: COLOR 7: PRINT "[-A-]"„LOCATE 8, 57: PRINT "[-B-]"„LOCATE 9, 57: PRINT "[-C-]"„LOCATE 10, 57: PRINT "[-D-]"„LOCATE 11, 57: PRINT "[-E-]"„LOCATE 12, 57: PRINT "[-F-]"„LOCATE 13, 57: PRINT "[-G-]"„LOCATE 14, 57: PRINT "[-H-]"„„TEXTPICK:„CLOSE 1„  REDIM DirNames$(100)„  I = 0„OPEN "DRIVE.LST" FOR INPUT AS #1„„  DO„     INPUT #1, X$„     IF INSTR(1, X$, "<DIR>") THEN„        I = I + 1„        DirNames$(I) = LEFT$(X$, 8)„     END IF„  LOOP WHILE NOT (EOF(1))„GR = I„I = 1„J = 7„DO„     LOCATE J, 38: COLOR 7, 0: PRINT DirNames$(I)„     IF I = GR THEN EXIT DO„     I = I + 1„     J = J + 1„LOOP UNTIL J = 17„„CLOSE„FOR J = 7 TO 16„COLOR 15, 0„LOCATE J, 12: PRINT STRING$(17, 0)„NEXT J„„FileNum = 0„File = 7„I = 7„N = 1„„OPEN "DIR.LST" FOR INPUT AS #1„„DO WHILE NOT EOF(1)„  LINE INPUT #1, FileName$„  FileNum = FileNum + 1„LOOP„„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„DO WHILE NOT EOF(1)„     LINE INPUT #1, FileName$„     COLOR 7„     LOCATE File, 14: PRINT FileName$„     File = File + 1„     IF File = 17 THEN EXIT DO„LOOP„„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„'=============================================„'          Select Text to View„'=============================================„„IF EOF(1) THEN LOCATE 7, 13: COLOR 14, 0: PRINT "No File(s) Found": GOTO DIRECTORY„LINE INPUT #1, FileName$„I = 7„LOCATE I, 12: COLOR 15, 1: PRINT "  " + FileName$ + "  "„„SELECTFILE:„V$ = INKEY$„IF V$ = CHR$(0) + "P" THEN GOSUB SELDOWN„IF V$ = CHR$(0) + "H" THEN GOSUB SELUP„IF V$ = CHR$(0) + "M" THEN COLOR 7, 0: LOCATE I, 12: PRINT "  " + FileName$ + "  ": GOTO DIRECTORY„IF V$ = CHR$(13) THEN GOTO SELENTER„IF V$ = CHR$(27) THEN File$ = "": CLOSE : KILL "DRIVE.LST": KILL "DIR.LST": GOTO START„GOTO SELECTFILE„„SELDOWN:„IF EOF(1) THEN RETURN„COLOR 7, 0: GOSUB SELMAIN„LINE INPUT #1, FileName$„N = N + 1„I = I + 1„COLOR 15, 1„GOSUB SELMAIN„RETURN„„SELUP:„IF N = 1 THEN RETURN„COLOR 7, 0: GOSUB SELMAIN„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„NU = 1„DO„     LINE INPUT #1, FileName$„     NU = NU + 1„LOOP UNTIL NU = N„N = N - 1: I = I - 1„COLOR 15, 1„GOSUB SELMAIN„RETURN„„SELMAIN:„IF I = 17 THEN I = 16: GOSUB DISPLAYDOWN„IF I = 6 THEN I = 7: GOSUB DISPLAYUP: RETURN„IF I = 7 THEN LOCATE I, 12: PRINT "                ": LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 8 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 9 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 10 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 11 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 12 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 13 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 14 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 15 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„IF I = 16 THEN LOCATE I, 12: PRINT "  " + FileName$ + "  "„RETURN„„DISPLAYDOWN:„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„NL = 10„DO„LINE INPUT #1, FileName$„NL = NL + 1„LOOP UNTIL NL = N„„FOR J = 7 TO 16„  LINE INPUT #1, FileName$„    COLOR 7, 0„  LOCATE J, 14: PRINT "            "„  LOCATE J, 14: PRINT FileName$„NEXT J„„COLOR 15, 1„RETURN„„DISPLAYUP:„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„FOR H = 1 TO N„     LINE INPUT #1, FileName$„NEXT H„„LOCATE 7, 14: PRINT "              "„COLOR 15, 1„GOSUB SELMAIN„„FOR J = 8 TO 16„  LINE INPUT #1, FileName$„    COLOR 7, 0„  LOCATE J, 14: PRINT "            "„  LOCATE J, 14: PRINT FileName$„NEXT J„„CLOSE 1„OPEN "DIR.LST" FOR INPUT AS #1„„FOR H = 1 TO N„     LINE INPUT #1, FileName$„NEXT H„„RETURN„„„SELENTER:„PCOPY 1, 0„CLOSE„KILL "DRIVE.LST"„KILL "DIR.LST"„File$ = FileName$„GOTO START„„'===============================================„'             Select Directories„'===============================================„„DIRECTORY:„„CLOSE 1„  REDIM DirNames$(75)„  I = 0„OPEN "DRIVE.LST" FOR INPUT AS #1„„  DO„     INPUT #1, X$„     IF INSTR(1, X$, "<DIR>") THEN„        I = I + 1„        DirNames$(I) = LEFT$(X$, 8)„     END IF„  LOOP WHILE NOT (EOF(1))„GR = I„I = 1„J = 7„DO„     LOCATE J, 38: COLOR 7, 0: PRINT DirNames$(I)„     IF I = GR THEN EXIT DO„     I = I + 1„     J = J + 1„LOOP UNTIL J = 17„I = 1: C = 7„LOCATE C, 38: COLOR 15, 4: PRINT DirNames$(1)„„DIRSEL:„V$ = INKEY$„IF V$ = CHR$(0) + "P" THEN GOSUB DIRDOWN„IF V$ = CHR$(0) + "H" THEN GOSUB DIRUP„IF V$ = CHR$(0) + "K" THEN GOTO TEXTPICK„IF V$ = CHR$(0) + "M" THEN GOTO DRIVE„IF V$ = CHR$(13) THEN GOTO DIRENTER„IF V$ = CHR$(27) THEN File$ = "": CLOSE : KILL "DRIVE.LST": KILL "DIR.LST": GOTO START„GOTO DIRSEL„„DIRDOWN:„IF GR = I THEN RETURN„COLOR 7, 0„GOSUB DIRMAIN„C = C + 1: I = I + 1„COLOR 15, 4„GOSUB DIRMAIN„RETURN„„DIRUP:„IF I = 1 THEN RETURN„COLOR 7, 0„GOSUB DIRMAIN„C = C - 1: I = I - 1„COLOR 15, 4„GOSUB DIRMAIN„RETURN„„DIRMAIN:„IF C = 17 THEN C = 16: GOSUB DIRDISDOWN„IF C = 6 THEN C = 7: GOSUB DIRDISUP„LOCATE C, 38: PRINT DirNames$(I)„RETURN„„DIRDISDOWN:„I = I - 10„FOR J = 7 TO 16„I = I + 1„COLOR 7, 0„LOCATE J, 38: PRINT DirNames$(I)„NEXT J„COLOR 15, 4„RETURN„„DIRDISUP:„I = I - 1„FOR J = 7 TO 16„I = I + 1„COLOR 7, 0„LOCATE J, 38: PRINT DirNames$(I)„NEXT J„I = I - 9„COLOR 15, 4„RETURN„„DIRENTER:„CLOSE„KILL "DRIVE.LST"„KILL "DIR.LST"„IF LEFT$(DirNames$(I), 2) = ". " THEN DirNames$(I) = MID$(CurrentDrive$, 15, 3)„DosCmd$ = "CD " + DirNames$(I)„SHELL DosCmd$„DIRENTER2:„SHELL "DIR /AD /O> DRIVE.LST"„DosCmd$ = "DIR *." + TextFile$ + " /B /ON > DIR.LST"„SHELL DosCmd$„OPEN "Drive.LST" FOR INPUT AS #1„DO„  LINE INPUT #1, CurrentDrive$„LOOP UNTIL INSTR(1, CurrentDrive$, ":\")„CLOSE 1„„Y = LEN(CurrentDrive$)„CurDir$ = MID$(CurrentDrive$, 15, Y)„LOCATE 3, 6: COLOR 15, 0: PRINT STRING$(71, 0)„IF RIGHT$(CurDir$, 1) = "\" THEN„LOCATE 3, 6: COLOR 10, 0: PRINT CurDir$ + "*." + TextFile$„ELSE„LOCATE 3, 6: COLOR 10, 0: PRINT CurDir$ + "\*." + TextFile$„END IF„„FOR J = 7 TO 16„COLOR 15, 0„LOCATE J, 37: PRINT STRING$(11, 0)„NEXT J„„FOR J = 7 TO 16„COLOR 15, 0„LOCATE J, 12: PRINT STRING$(17, 0)„NEXT J„„GOTO TEXTPICK„„'==================================„'        Drive Switching„'==================================„„DRIVE:„CLOSE 1„  REDIM DirNames$(75)„  I = 0„OPEN "DRIVE.LST" FOR INPUT AS #1„„  DO„     INPUT #1, X$„     IF INSTR(1, X$, "<DIR>") THEN„        I = I + 1„        DirNames$(I) = LEFT$(X$, 8)„     END IF„  LOOP WHILE NOT (EOF(1))„GR = I„I = 1„J = 7„DO„     LOCATE J, 38: COLOR 7, 0: PRINT DirNames$(I)„     IF I = GR THEN EXIT DO„     I = I + 1„     J = J + 1„LOOP UNTIL J = 17„„CLOSE„I = 7„LOCATE I, 56: COLOR 15, 5: PRINT " [-A-] "„„DRIVESEL:„V$ = INKEY$„IF V$ = CHR$(0) + "K" THEN COLOR 7, 0: GOSUB DRIVEMAIN: GOTO DIRECTORY„IF V$ = CHR$(27) THEN File$ = "": CLOSE : KILL "DRIVE.LST": KILL "DIR.LST": GOTO START„IF V$ = CHR$(0) + "P" THEN GOSUB DRIVEDOWN„IF V$ = CHR$(0) + "H" THEN GOSUB DRIVEUP„IF V$ = CHR$(13) THEN GOTO DRIVEENTER„GOTO DRIVESEL„„DRIVEDOWN:„COLOR 7, 0„GOSUB DRIVEMAIN„I = I + 1„COLOR 15, 5„GOSUB DRIVEMAIN„RETURN„„DRIVEUP:„COLOR 7, 0„GOSUB DRIVEMAIN„I = I - 1„COLOR 15, 5„GOSUB DRIVEMAIN„RETURN„„DRIVEMAIN:„IF I = 15 THEN I = 7„IF I = 6 THEN I = 14„IF I = 7 THEN LOCATE I, 56: PRINT " [-A-] "„IF I = 8 THEN LOCATE I, 56: PRINT " [-B-] "„IF I = 9 THEN LOCATE I, 56: PRINT " [-C-] "„IF I = 10 THEN LOCATE I, 56: PRINT " [-D-] "„IF I = 11 THEN LOCATE I, 56: PRINT " [-E-] "„IF I = 12 THEN LOCATE I, 56: PRINT " [-F-] "„IF I = 13 THEN LOCATE I, 56: PRINT " [-G-] "„IF I = 14 THEN LOCATE I, 56: PRINT " [-H-] "„RETURN„„DRIVEENTER:„COLOR 7, 0: GOSUB DRIVEMAIN„KILL "DRIVE.LST"„KILL "DIR.LST"„IF I = 7 THEN SHELL "A:"„IF I = 8 THEN SHELL "B:"„IF I = 9 THEN SHELL "C:"„IF I = 10 THEN SHELL "D:"„IF I = 11 THEN SHELL "E:"„IF I = 12 THEN SHELL "F:"„IF I = 13 THEN SHELL "G:"„IF I = 14 THEN SHELL "H:"„GOTO DIRENTER2„„'==================================================„'           Restore Current Drive/Path„'==================================================„„QUIT:„COLOR 7, 0„SHELL CurDrive$„DosCmd$ = "CD " + DefaultDir$„SHELL DosCmd$„END„„„DOSSHELL:„PCOPY 1, 0: COLOR 7, 0: CLS : SHELL "ECHO Type 'EXIT' to Return to The Ultimate Text Viewer": SHELL: PCOPY 1, 0: LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "; : COLOR 15: PRINT "C"; : COLOR 0: PRINT "APTURE     "; : COLOR 15:                                                                          PRINT "H"; : COLOR 0: PRINT "ELP!     ": GOTO FKEY„„PRINTER:„OPEN "LPT1:BIN" FOR OUTPUT AS #2„PP = SeekEl„CLOSE #1„OPEN File$ FOR INPUT AS #1„     FOR Y = 10 TO 12„     LOCATE Y, 30: COLOR 0, 0: PRINT STRING$(31, 0)„     NEXT Y„     LOCATE 9, 28: COLOR 14, 4: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„     LOCATE 10, 28:  PRINT CHR$(179); : COLOR 15: PRINT "    Press <ESC> to Abort!    "; : COLOR 14: PRINT CHR$(179)„     LOCATE 11, 28: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„DO UNTIL EOF(1)„V$ = INKEY$„IF V$ = CHR$(27) THEN EXIT DO„LINE INPUT #1, Text$„LPRINT Text$„LOOP„CLOSE„OPEN File$ FOR INPUT AS #1„DO„LINE INPUT #1, Text$„LOOP UNTIL PP = SeekEl„PNEXT:„IF FPC = TRUE THEN RETURN ELSE GOTO FKEY„„CAPTURE:„PCOPY 0, 1„LOCATE 1, 12: COLOR 15, 4: PRINT " C"; : COLOR 10: PRINT "APTURE "„FOR R = 3 TO 8„LOCATE R, 13: COLOR 0, 0: PRINT STRING$(15, 0)„NEXT R„LOCATE 2, 11: COLOR 0, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 3, 11: PRINT CHR$(179); : COLOR 7, 0: PRINT " T"; : COLOR 7, 0: PRINT "urn  "; : COLOR 15, 0: PRINT "O"; : COLOR 7, 0: PRINT "n... "; : COLOR 0, 3: PRINT CHR$(179)„LOCATE 4, 11: PRINT CHR$(179); : COLOR 0: PRINT " Turn  O"; : COLOR 15, 3: PRINT "f"; : COLOR 0: PRINT "f   "; CHR$(179)„LOCATE 5, 11: PRINT CHR$(195); STRING$(13, 196); CHR$(180)„LOCATE 6, 11: PRINT CHR$(179); : COLOR 15, 3: PRINT " S"; : COLOR 0: PRINT "ave As...  "; CHR$(179)„LOCATE 7, 11: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„ROW = 3„CAPTUREKEY:„V$ = INKEY$„IF V$ = CHR$(27) THEN PCOPY 1, 0: RETURN„IF V$ = CHR$(13) THEN GOTO CAPENTER„IF UCASE$(V$) = "O" THEN GOTO CAPON„IF UCASE$(V$) = "F" THEN GOTO CAPOFF„IF UCASE$(V$) = "S" THEN GOTO SAVECAP„IF V$ = CHR$(0) + "P" THEN ROW = ROW + 1: GOSUB CAPDOWN„IF V$ = CHR$(0) + "H" THEN ROW = ROW - 1: GOSUB CAPUP„IF V$ = CHR$(0) + "K" THEN PCOPY 1, 0: GOTO FKEY„IF V$ = CHR$(0) + "M" THEN PCOPY 1, 0: GOTO HELP„IF V$ = CHR$(0) + ";" THEN CALL HELP2     'F1„IF V$ = CHR$(0) + "<" THEN TextFile$ = "TXT": GOTO LISTFILES'F2„IF V$ = CHR$(0) + "=" THEN TextFile$ = "*": GOTO LISTFILES'F3„IF V$ = CHR$(0) + ">" THEN GOTO PRINTER   'F4„IF V$ = CHR$(0) + "?" THEN GOTO CAPON     'F5„IF V$ = CHR$(0) + "@" THEN GOTO CAPOFF    'F6„IF V$ = CHR$(0) + "A" THEN GOTO SAVECAP   'F7„IF V$ = CHR$(0) + "B" THEN GOTO DOSSHELL  'F8„GOTO CAPTUREKEY„„CAPDOWN:„IF ROW = 6 THEN ROW = 3„IF ROW = 3 THEN LOCATE 3, 12: COLOR 7, 0: PRINT " Turn  "; : COLOR 15, 0: PRINT "O"; : COLOR 7, 0: PRINT "n... ": LOCATE 6, 12: COLOR 15, 3: PRINT " S"; : COLOR 0, 3: PRINT "ave As...  "„IF ROW = 4 THEN LOCATE 4, 12: COLOR 7, 0: PRINT " Turn  O"; : COLOR 15, 0: PRINT "f"; : COLOR 7, 0: PRINT "f   ": LOCATE 3, 12: COLOR 0, 3: PRINT " Turn  "; : COLOR 15, 3: PRINT "O"; : COLOR 0: PRINT "n... "„IF ROW = 5 THEN LOCATE 6, 12: COLOR 15, 0: PRINT " S"; : COLOR 7, 0: PRINT "ave As...  ": LOCATE 4, 12: COLOR 0, 3: PRINT " Turn  O"; : COLOR 15, 3: PRINT "f"; : COLOR 0, 3: PRINT "f   "„RETURN„CAPUP:„IF ROW = 2 THEN ROW = 5„IF ROW = 3 THEN LOCATE 3, 12: COLOR 7, 0: PRINT " Turn  "; : COLOR 15, 0: PRINT "O"; : COLOR 7, 0: PRINT "n... ": LOCATE 4, 12: COLOR 0, 3: PRINT " Turn  O"; : COLOR 15, 3: PRINT "f"; : COLOR 0, 3: PRINT "f   "„IF ROW = 4 THEN LOCATE 4, 12: COLOR 7, 0: PRINT " Turn  O"; : COLOR 15, 0: PRINT "f"; : COLOR 7, 0: PRINT "f   ": LOCATE 6, 12: COLOR 15, 3: PRINT " S"; : COLOR 0, 3: PRINT "ave As...  "„IF ROW = 5 THEN LOCATE 6, 12: COLOR 15, 0: PRINT " S"; : COLOR 7, 0: PRINT "ave As...  ": LOCATE 3, 12: COLOR 0, 3: PRINT " Turn  "; : COLOR 15, 3: PRINT "O"; : COLOR 0, 3: PRINT "n... "„RETURN„„CAPENTER:„IF ROW = 3 THEN GOTO CAPON„IF ROW = 4 THEN GOTO CAPOFF„IF ROW = 5 THEN GOTO SAVECAP„„CAPON:„PS = SeekEl„PCOPY 1, 0„LOCATE 1, 36: COLOR 10, 3: PRINT "Capture:"; : COLOR 1: PRINT PS; : COLOR 0, 3: PRINT CHR$(26); SeekEl„CAP = TRUE„RETURN„„CAPOFF:„PCOPY 1, 0„LOCATE 1, 36: COLOR 3, 3: PRINT "                        "„CAP = FALSE„RETURN„„SAVECAP:„IF CAP = FALSE THEN PCOPY 1, 0: RETURN„IF PS > SeekEl THEN PCOPY 1, 0: RETURN„CLOSE #1„OPEN File$ FOR INPUT AS #1„PS2 = PS„DO„IF PS = 1 THEN EXIT DO„LINE INPUT #1, SAVEDTEXT$„PS = PS - 1„LOOP UNTIL PS = 1„FOR V = 11 TO 13„LOCATE V, 4: COLOR 0, 0: PRINT STRING$(76, 0)„NEXT V„COLOR 10, 2„LOCATE 10, 2: PRINT "⁄"; STRING$(74, 196); "ø"„LOCATE 11, 2: PRINT CHR$(179); STRING$(74, 0); CHR$(179)„LOCATE 12, 2: PRINT "¿"; STRING$(74, 196); "Ÿ"„LOCATE 11, 4: COLOR 14, 2: PRINT "Save As: "; : COLOR 15, 2: LINE INPUT ""; FILNAM$„IF FILNAM$ = "" THEN PCOPY 1, 0: PS = PS2: RETURN„OPEN FILNAM$ FOR APPEND AS #2„PS2 = PS2 - 1„     FOR Y = 10 TO 12„     LOCATE Y, 30: COLOR 7, 8: PRINT STRING$(31, 176)„     NEXT Y„     LOCATE 9, 28: COLOR 14, 4: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„     LOCATE 10, 28:  PRINT CHR$(179); : COLOR 15: PRINT "     Press <ESC> to STOP!    "; : COLOR 14: PRINT CHR$(179)„     LOCATE 11, 28: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„DO„IF EOF(1) THEN EXIT DO„V$ = INKEY$„IF V$ = CHR$(27) THEN EXIT DO„LINE INPUT #1, SAVEDTEXT$„PRINT #2, SAVEDTEXT$„PS2 = PS2 + 1„LOOP UNTIL PS2 = SeekEl„PS = PS2„CLOSE #2„PCOPY 1, 0„RETURN„„HELP:„PCOPY 0, 1„LOCATE 1, 24: COLOR 15, 4: PRINT " H"; : COLOR 10: PRINT "ELP! "„FOR V = 3 TO 8„LOCATE V, 25: COLOR 0, 0: PRINT STRING$(18, 0)„NEXT V„LOCATE 2, 23: COLOR 0, 3: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„LOCATE 3, 23: PRINT CHR$(179); : COLOR 15, 0: PRINT " G"; : COLOR 7, 0: PRINT "eneral Help   "; : COLOR 0, 3: PRINT CHR$(179)„LOCATE 4, 23: PRINT CHR$(179); : COLOR 15, 3: PRINT " C"; : COLOR 0: PRINT "ommand Keys   "; CHR$(179)„LOCATE 5, 23: PRINT CHR$(195); STRING$(16, 196); CHR$(180)„LOCATE 6, 23: PRINT CHR$(179); : COLOR 0, 3: PRINT " Capturing "; : COLOR 15, 3: PRINT "T"; : COLOR 0, 3: PRINT "ext "; CHR$(179)„LOCATE 7, 23: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„ROW = 3„HELPKEY:„V$ = INKEY$„IF V$ = CHR$(27) THEN PCOPY 1, 0: RETURN„IF V$ = CHR$(0) + "P" THEN ROW = ROW + 1: GOSUB HELPDOWN„IF V$ = CHR$(0) + "H" THEN ROW = ROW - 1: GOSUB HELPUP„IF V$ = CHR$(0) + "M" THEN PCOPY 1, 0: GOTO FKEY„IF V$ = CHR$(0) + "K" THEN PCOPY 1, 0: GOTO CAPTURE„IF UCASE$(V$) = "G" THEN CALL HELP1„IF UCASE$(V$) = "C" THEN CALL HELP2„IF UCASE$(V$) = "T" THEN CALL HELP3„IF V$ = CHR$(13) THEN GOSUB HELPENTER„IF V$ = CHR$(0) + ";" THEN CALL HELP2     'F1„IF V$ = CHR$(0) + "<" THEN TextFile$ = "TXT": GOTO LISTFILES'F2„IF V$ = CHR$(0) + "=" THEN TextFile$ = "*": GOTO LISTFILES'F3„IF V$ = CHR$(0) + ">" THEN GOTO PRINTER   'F4„IF V$ = CHR$(0) + "?" THEN GOTO CAPON     'F5„IF V$ = CHR$(0) + "@" THEN GOTO CAPOFF    'F6„IF V$ = CHR$(0) + "A" THEN GOTO SAVECAP   'F7„IF V$ = CHR$(0) + "B" THEN GOTO DOSSHELL  'F8„GOTO HELPKEY„„HELPDOWN:„IF ROW = 6 THEN ROW = 3„IF ROW = 3 THEN LOCATE 3, 24: COLOR 15, 0: PRINT " G"; : COLOR 7, 0: PRINT "eneral Help   ": LOCATE 6, 24: COLOR 0, 3: PRINT " Capturing "; : COLOR 15, 3: PRINT "T"; : COLOR 0, 3: PRINT "ext "„IF ROW = 4 THEN LOCATE 4, 24: COLOR 15, 0: PRINT " C"; : COLOR 7, 0: PRINT "ommand Keys   ": LOCATE 3, 24: COLOR 15, 3: PRINT " G"; : COLOR 0, 3: PRINT "eneral Help   "„IF ROW = 5 THEN LOCATE 6, 24: COLOR 7, 0: PRINT " Capturing "; : COLOR 15, 0: PRINT "T"; : COLOR 7, 0: PRINT "ext ": LOCATE 4, 24: COLOR 15, 3: PRINT " C"; : COLOR 0, 3: PRINT "ommand Keys   "„RETURN„HELPUP:„IF ROW = 2 THEN ROW = 5„IF ROW = 3 THEN LOCATE 3, 24: COLOR 15, 0: PRINT " G"; : COLOR 7, 0: PRINT "eneral Help   ": LOCATE 4, 24: COLOR 15, 3: PRINT " C"; : COLOR 0, 3: PRINT "ommand Keys   "„IF ROW = 4 THEN LOCATE 4, 24: COLOR 15, 0: PRINT " C"; : COLOR 7, 0: PRINT "ommand Keys   ": LOCATE 6, 24: COLOR 0, 3: PRINT " Capturing "; : COLOR 15, 3: PRINT "T"; : COLOR 0, 3: PRINT "ext "„IF ROW = 5 THEN LOCATE 6, 24: COLOR 7, 0: PRINT " Capturing "; : COLOR 15, 0: PRINT "T"; : COLOR 7, 0: PRINT "ext ": LOCATE 3, 24: COLOR 15, 3: PRINT " G"; : COLOR 0, 3: PRINT "eneral Help   "„RETURN„„HELPENTER:„IF ROW = 3 THEN CALL HELP1„IF ROW = 4 THEN CALL HELP2„IF ROW = 5 THEN CALL HELP3„RETURN„„ERRORHANDLE:„     IF ERR = 53 OR ERR = 52 THEN„COLOR 0, 1„FOR O = 1 TO 25„LOCATE O, 1: PRINT STRING$(80, 0)„NEXT O„COLOR 15, 4: LOCATE 25, 1: PRINT "  The Ultimate Text Viewer Version 0.02  FREEWARE"; : COLOR 7, 4: PRINT "  <"; : COLOR 11: PRINT "1"; : COLOR 10: PRINT "2"; : COLOR 3: PRINT "3"; : COLOR 12: PRINT "4"; : COLOR 13: PRINT "5"; : COLOR 14: PRINT "6"; : COLOR 7: PRINT "7"; : COLOR 15: PRINT "8"; : COLOR 9: PRINT "9"; : COLOR 7: PRINT ">"; : COLOR 10: PRINT "  Color Change    "„COLOR 0, 1: LOCATE 24, 1: PRINT STRING$(80, 0)„LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "; : COLOR 15: PRINT "C"; : COLOR 0: PRINT "APTURE     "; : COLOR 15: PRINT "H"; : COLOR 0: PRINT "ELP!                                                   "„LOCATE 4, 1: COLOR 7, 1„PRINT "      ±€€  ±€€ ±€€      ±€€€€€€€€ ±€€ ±€€€€€€€ ±€€€€€€€ ±€€€€€€€€ ±€€€€€€€"„PRINT "      ±€€  ±€€ ±€€         ±€€    ±€€ ±€€±€±€€ ±€€  ±€€    ±€€    ±€€"„PRINT "      ±€€  ±€€ ±€€         ±€€    ±€€ ±€€  ±€€ ±€€€€€€€    ±€€    ±€€€€€€"„PRINT "      ±€€  ±€€ ±€€         ±€€    ±€€ ±€€  ±€€ ±€€  ±€€    ±€€    ±€€"„PRINT "      ±€€€€€€€ ±€€€€€€€    ±€€    ±€€ ±€€  ±€€ ±€€  ±€€    ±€€    ±€€€€€€€"„PRINT "                                           "„PRINT "                     ±€€€€€€€€ ±€€€€€€€ ±€€  ±€€ ±€€€€€€€€"„PRINT "                        ±€€    ±€€      ±€€  ±€€    ±€€"„PRINT "                        ±€€    ±€€€€€€    ±€€€      ±€€"„PRINT "                        ±€€    ±€€      ±€€  ±€€    ±€€"„PRINT "                        ±€€    ±€€€€€€€ ±€€  ±€€    ±€€"„PRINT„PRINT "                ±€€  ±€€ ±€€ ±€€€€€€€ ±€€  ±€€ ±€€€€€€€ ±€€€€€€€"„PRINT "                ±€€  ±€€ ±€€ ±€€      ±€€  ±€€ ±€€      ±€€  ±€€"„PRINT "                ±€€  ±€€ ±€€ ±€€€€€€  ±€€  ±€€ ±€€€€€€  ±€€€€€€€"„PRINT "                ±€€  ±€€ ±€€ ±€€      ±€€±€±€€ ±€€      ±€€ ±€€"„PRINT "                 ±€€€€€  ±€€ ±€€€€€€€ ±€€€€€€€ ±€€€€€€€ ±€€ ±€€€"„PRINT„PRINT "              Programmed by William Yu  (c) 1994   UTV Version 0.02"„RESUME FKEY„END IF„     IF ERR = 25 THEN„     LOCATE 10, 20„     FOR Y = 10 TO 13„     LOCATE Y, 30: COLOR 0, 0: PRINT STRING$(31, 0)„     NEXT Y„     LOCATE 9, 28: COLOR 14, 4: PRINT "⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"„     LOCATE 10, 28:  PRINT CHR$(179); : COLOR 15: PRINT "  No Printer Port Detected!  "; : COLOR 14: PRINT CHR$(179)„     LOCATE 11, 28: PRINT CHR$(179); : COLOR 15: PRINT " PLEASE TURN YOUR PRINTER ON "; : COLOR 14: PRINT CHR$(179)„     LOCATE 12, 28: PRINT "¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ"„     WHILE INKEY$ = "": WEND: PCOPY 1, 0„     LOCATE 1, 1: COLOR 15, 3: PRINT "   F"; : COLOR 0: PRINT "ILE     "„     RESUME PNEXT„     END IF„PCOPY 1, 0„RESUME FKEY„„REM $STATIC„SUB HELP1„PCOPY 0, 2„LOCATE 3, 3: COLOR 10, 2: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„FOR O = 4 TO 21„LOCATE O, 3: COLOR 10, 2: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„NEXT O„LOCATE 22, 3: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„COLOR 7, 8: LOCATE 23, 5: PRINT STRING$(74, 176)„FOR O = 4 TO 22„LOCATE O, 77: PRINT STRING$(2, 176)„NEXT O„LOCATE 3, 34: COLOR 15, 2: PRINT "GENERAL HELP"„LOCATE 4, 5: COLOR 0, 2: PRINT "Starting up The Ultimate Text Viewer with command line:"„LOCATE 5, 8: COLOR 15, 2: PRINT "UTV <[Drive:Path]FileName.Ext>  Example:  "; : COLOR 14: PRINT "UTV UTV.TXT"„LOCATE 6, 5: COLOR 0: PRINT "Starting up The Ultimate Text Viewer Without the Command Line:"„LOCATE 7, 8: COLOR 15: PRINT "If you happen to run the program without a command line you will be"„LOCATE 8, 8: PRINT "able to select a file using the FILE command and selecting"„LOCATE 9, 10: COLOR 14: PRINT "Open a Text File  "; : COLOR 10: PRINT "(*.TXT will be displayed)"„LOCATE 10, 10: COLOR 14: PRINT "List all Files    "; : COLOR 10: PRINT "(*.* in current directory will be displayed)"„LOCATE 11, 5: COLOR 0: PRINT "Error Control:"„LOCATE 12, 8: COLOR 15: PRINT "When selecting a file, there are many  different drives from which"„LOCATE 13, 8: PRINT "you can choose from, please don't select a drive you know does not"„LOCATE 14, 8: PRINT "function or don't have."„LOCATE 21, 28: COLOR 11: PRINT "Press any key to continue..."„WHILE INKEY$ = "": WEND„PCOPY 2, 0„END SUB„„SUB HELP2„PCOPY 0, 2„LOCATE 3, 3: COLOR 10, 2: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„FOR O = 4 TO 21„LOCATE O, 3: COLOR 10, 2: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„NEXT O„LOCATE 22, 3: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„COLOR 7, 8: LOCATE 23, 5: PRINT STRING$(74, 176)„FOR O = 4 TO 22„LOCATE O, 77: PRINT STRING$(2, 176)„NEXT O„LOCATE 3, 27: COLOR 15, 2: PRINT "COMMAND KEYS/SHORT CUT KEYS"„LOCATE 4, 5: COLOR 0: PRINT "Scrolling Text & Menu Commands:"„LOCATE 5, 8: COLOR 15: PRINT CHR$(24); CHR$(25); : COLOR 14: PRINT " Up/Down "; : COLOR 15: PRINT CHR$(27); CHR$(26); : COLOR 14: PRINT " Left/Right "; : COLOR 15: PRINT " PGDN/PGDN "; : COLOR 14: PRINT "Up a Page/Down a Page"; : COLOR 15: PRINT " ESC"; : COLOR 14: PRINT " Exits"„LOCATE 6, 8: COLOR 15: PRINT "F"; : COLOR 14: PRINT " - FILE COMMAND"; : COLOR 11: PRINT " Open New Text File for Viewing/Printing/DOS Shell"„LOCATE 7, 8: COLOR 15: PRINT "C"; : COLOR 14: PRINT " - CAPTURE TEXT"; : COLOR 11: PRINT " Capture Certain Lines of text and saving it as..."„LOCATE 8, 8: COLOR 15: PRINT "H"; : COLOR 14: PRINT " - HELP ON UTV "; : COLOR 11: PRINT " This screen right here"„LOCATE 9, 8: COLOR 15: PRINT "1 to 9 produces a color change to the current TEXT"„LOCATE 10, 8: COLOR 11: PRINT "1 = Light Cyan  2 = Green  3 = Cyan  4 = Red  5 = Magenta 6 = Yellow"„LOCATE 11, 8: PRINT "7 = Grey (Default Color)  8 = White  9 = Blue"„LOCATE 12, 5: COLOR 0: PRINT "Short Cut Keys:"„LOCATE 13, 8: COLOR 15: PRINT "F1 "; : COLOR 14: PRINT "= Displays all the Command Keys (This Help Screen)"„LOCATE 14, 8: COLOR 15: PRINT "F2 "; : COLOR 14: PRINT "= Open a Text File"„LOCATE 15, 8: COLOR 15: PRINT "F3 "; : COLOR 14: PRINT "= List All Files"„LOCATE 16, 8: COLOR 15: PRINT "F4 "; : COLOR 14: PRINT "= Print Entire Text"„LOCATE 17, 8: COLOR 15: PRINT "F5 "; : COLOR 14: PRINT "= Turn Capture ON"„LOCATE 18, 8: COLOR 15: PRINT "F6 "; : COLOR 14: PRINT "= Turn Capture OFF"„LOCATE 19, 8: COLOR 15: PRINT "F7 "; : COLOR 14: PRINT "= Save Captured Text As..."„LOCATE 20, 8: COLOR 15: PRINT "F8 "; : COLOR 14: PRINT "= DOS Shell"„LOCATE 21, 27: COLOR 4, 2: PRINT "Press any key to continue..."„WHILE INKEY$ = "": WEND„PCOPY 2, 0„END SUB„„SUB HELP3„PCOPY 0, 2„LOCATE 3, 3: COLOR 10, 2: PRINT CHR$(218); STRING$(72, 196); CHR$(191)„FOR O = 4 TO 21„LOCATE O, 3: COLOR 10, 2: PRINT CHR$(179); STRING$(72, 0); CHR$(179)„NEXT O„LOCATE 22, 3: PRINT CHR$(192); STRING$(72, 196); CHR$(217)„COLOR 7, 8: LOCATE 23, 5: PRINT STRING$(74, 176)„FOR O = 4 TO 22„LOCATE O, 77: PRINT STRING$(2, 176)„NEXT O„LOCATE 3, 32: COLOR 15, 2: PRINT "CAPTURING TEXT"„LOCATE 4, 5: COLOR 0: PRINT "Commands for Capturing Text:"„LOCATE 5, 8: COLOR 15: PRINT "Capturing Text is quite simple, F5 to turn capture ON or you could"„LOCATE 6, 8: PRINT "type 'C' and select Turn On"„LOCATE 7, 8: PRINT "After you have turned Capture ON, a red line should appear below the"„LOCATE 8, 8: PRINT "menu commands.  That is the first line that will be captured."„LOCATE 9, 8: PRINT "You will see a"; : COLOR 14: PRINT " Capturing 10 "; CHR$(26); " 10"; : COLOR 15: PRINT " on the top line.  (Example only)"„LOCATE 10, 8: COLOR 11: PRINT "First line to be captured"; : COLOR 12: PRINT CHR$(24); CHR$(24); "   "; CHR$(24); CHR$(24); : COLOR 11: PRINT "this is the last line to be captured"„LOCATE 11, 8: COLOR 15: PRINT "Scroll down to capture the desired amount of lines."„LOCATE 12, 8: COLOR 14: PRINT "*** Each time a line is scrolled past the red line, it is captured."„LOCATE 13, 8: COLOR 15: PRINT "You may turn Capture off anytime by pressing F6 or selecting it from"„LOCATE 14, 8: PRINT "the CAPTURE Commands.  You should SAVE your Captured Text before you"„LOCATE 15, 8: PRINT "do that by pressing F7 or selecting SAVE AS from the CAPTURE Command"„LOCATE 16, 5: COLOR 0: PRINT "Error Control:"„LOCATE 17, 8: COLOR 15: PRINT "Capture 100 "; CHR$(26); " 20 will NOT save, the first number has to be lower."„LOCATE 18, 8: PRINT "When you save the captured text as a filename that already exists,"„LOCATE 19, 8: PRINT "it will APPEND (Add the captured text) 'til end of file."„LOCATE 21, 27: COLOR 11: PRINT "Press any key to continue..."„WHILE INKEY$ = "": WEND„PCOPY 2, 0„END SUB„„The ABC Programmer             SIMPLE BANNER SCROLL           Used within the ABC Reader     09-05-95 (16:43)       QB, QBasic, PDS        61   1569     BANNER.BAS  ' Simple Banner Scroll by William Yu 09-05-1995„' Scrolls a line of text from right to left„„DEFINT A-Z„DECLARE SUB Delay (Seconds!)„DECLARE SUB BannerScroll (Text$, ForeColor, BackColor, BeginCol, EndCol, Row)„„CLS„„' Make sure you add a trailing space at the end of TEXT$„„Text$ = "Hello, my name is William Yu, and I'm The ABC Programmer. "„ForeColor = 15„BackColor = 0„BeginCol = 70„EndCol = 20„Row = 25„„BannerScroll Text$, ForeColor, BackColor, BeginCol, EndCol, Row„„SUB BannerScroll (Text$, ForeColor, BackColor, BeginCol, EndCol, Row)„„' Since this is a banner scroll, the starting point is always the highest„' If not then we exit the subroutine„„IF EndCol >= BeginCol THEN EXIT SUB„„DEF SEG = &HB800       ' You must have a Color Monitor to use POKE„„Y = 0„FOR X = BeginCol TO EndCol STEP -1„    Y = Y + 1„    LOCATE Row, X: COLOR ForeColor, BackColor: PRINT LEFT$(Text$, Y);„' If you like, you can have multiple colors„' To do this you POKE the color attribute to anything you want„' Here's an example, you'll have to modify it to suit your banner method„    POKE 3977, 7„    POKE 3979, 8„' Another way is to use random colors or define colors in an array.„    Delay .1„NEXT X„Y = 1„H = BeginCol - EndCol + 1„E = LEN(Text$)„DO„  Y = Y + 1„  LOCATE Row, EndCol: COLOR ForeColor, BackColor: PRINT MID$(Text$, Y, H);„  Delay .1„LOOP UNTIL Y = E„„END SUB„„DEFSNG A-Z„SUB Delay (Seconds)„  Time = TIMER„  XDELAY = Time + Seconds„  WHILE NOT (TIMER > XDELAY)„  WEND„  IF INKEY$ <> "" THEN END„END SUB„„The ABC Programmer             EMULATES TYPING BLUNDERS       EMULATE,TYPING,BLUNDERS        Year of 1994           QB, QBasic, PDS        50   1072     BLUNDERS.BAS'==================================================„'  BLUNDERS.BAS by William Yu  (1994)„'  Emulates a simple typing blunder and corrects„'  the spelling.„'  This works for single letters.„'==================================================„„DEFINT A-Z„„CONST False = 0„CONST True = NOT False„„CLS„Text$ = "^yYou ^nknow this is a ^nbad reput^eation for this ^Sschool don^;'t you^>?"„WholeWord$ = "|These This program |is was written for |bluder blunders."„LOCATE , , 1„I = 0: X = 1„Blunder = False„„DO„  I = I + 1„  IF Blunder THEN„    I = I - 1„    X = X - 1„    T! = TIMER„    DO WHILE TIMER - T! <= .1„    LOOP„    LOCATE , X: PRINT " ";„    LOCATE , X„    T! = TIMER„    DO WHILE TIMER - T! <= .1„    LOOP„    Blunder = False„    I = I + 2„  END IF„  LOCATE , X„  IF MID$(Text$, I, 1) = "^" THEN„    PRINT MID$(Text$, I + 1, 1);„    Blunder = True„    X = X + 1„  ELSE„    PRINT MID$(Text$, I, 1);„    Blunder = False„    X = X + 1„  END IF„  T! = TIMER„  DO WHILE TIMER - T! <= .07„  LOOP„LOOP UNTIL I = LEN(Text$)„„Kenneth W. Melvin              SCREEN DRAWING ROUTINES        kwmelvin@nr.infi.net           10-09-95 (00:00)       QB, QBasic, VB         81   2935     DEMOSCRN.BAS'Filename:  DEMOSCRN.BAS„'Date:      10-9-1995 kwm„'For:       QBasic, QuickBASIC, VBDOS„'Purpose:   Demonstration of drawing screens and passing parameters„'            to SUBprocedures. An example of structured programming.„„DECLARE SUB Shadows (UpRow%, LeftCol%, BotRow%, RtCol%)„DECLARE SUB DrawBorder (UpRow%, LeftCol%, BotRow%, RtCol%)„DECLARE SUB Background ()„DECLARE SUB ClearScrn (UpRow%, LeftCol%, BotRow%, RtCol%)„„DEFINT A-Z                              'defines variables of type integer„CLS                                     'clear the screen„„UpRow = 4                               'change any of these coordinates„LeftCol = 15                            'at this one location, and the„BotRow = 15                             'size of the window, the border,„RtCol = 65                              'and shadows change automatically.„„Background                                      'draws a background      „CALL ClearScrn(UpRow, LeftCol, BotRow, RtCol)   'clears a blank area„CALL DrawBorder(UpRow, LeftCol, BotRow, RtCol)  'draws a border in blank area„CALL Shadows(UpRow, LeftCol, BotRow, RtCol)     'draws shadows under window„„COLOR 0, 3                              'black FG, cyan BG„LOCATE UpRow + 3, LeftCol + 16          'position text in window„PRINT "This is DEMOSCRN.BAS"            'message„COLOR 0, 7                              'white FG, black BG„„END„„SUB Background„    COLOR 0, 7„    FOR i = 1 TO 80„        FOR j = 1 TO 25„            PRINT CHR$(176);„        NEXT„    NEXT„END SUB„„SUB ClearScrn (UpRow, LeftCol, BotRow, RtCol)„    COLOR 0, 7„    LOCATE UpRow, LeftCol„    FOR i = UpRow TO BotRow„        LOCATE i, LeftCol„        PRINT STRING$(RtCol - LeftCol + 1, CHR$(219))„    NEXT„END SUB„„SUB DrawBorder (UpRow, LeftCol, BotRow, RtCol)„   „    COLOR 0, 3      'change border color by changing FG [COLOR FG, BG] (0-15)„                    'change box color by changing BG (0-7 only)„                    '0=black 1=blue 2=green 3=cyan 4=red 5=magenta 6=brown„                    '7=white 8=gray 9=hiBlue 10=hiGreen 11=hiCyan 12=hiRed„                    '13=hiMagenta 14=Yellow 15=hiWhite„   „    LOCATE UpRow, LeftCol„    PRINT CHR$(213) + STRING$(((RtCol - LeftCol) - 1), CHR$(205)) + CHR$(184)„   „    FOR i = (UpRow + 1) TO (BotRow - 1)„      LOCATE i, LeftCol„      PRINT CHR$(179) + STRING$(((RtCol - LeftCol) - 1), CHR$(32)) + CHR$(179)„    NEXT„   „    LOCATE BotRow, LeftCol„    PRINT CHR$(212) + STRING$(((RtCol - LeftCol) - 1), CHR$(205)) + CHR$(190)„„END SUB„„SUB Shadows (UpRow, LeftCol, BotRow, RtCol)„    COLOR 8, 0              'color of shadow„    'horizontal shadow at bottom„    LOCATE BotRow + 1, LeftCol + 2„    PRINT STRING$((RtCol - LeftCol), CHR$(178))„    'vertical shadow at right side„    FOR i = UpRow + 1 TO BotRow„        LOCATE i, RtCol + 1: PRINT CHR$(178)„    NEXT„END SUB„„Jesu's Lozano                  CONCATENATES ASCII TEXT        comp.lang.basic.misc           Unknown Date           QB, QBasic, PDS        49   1383     JOINT.BAS   Delim$ = " ,;()?" + CHR$(9) + CHR$(34)„cade$ = LTRIM$(RTRIM$(COMMAND$))„IF MID$(cade$, 2, 1) = " " THEN„		SELECT CASE LEFT$(cade$, 1)„		CASE "S", "s": mete$ = CHR$(32)„		CASE "T", "t": mete$ = CHR$(9)„		CASE ELSE:  mete$ = LEFT$(cade$, 1)„		END SELECT„		cade$ = RIGHT$(cade$, LEN(cade$) - 2)„END IF„largo = LEN(cade$)„DIM token$(largo)„IF INSTR(cade$, ".") = 0 OR largo < 5 THEN„		PRINT "[ Concatenate ascii text or data files horizontally, line by line ]"„		PRINT "Price: 0 Registration: OFF Bugs: ON Author: lozano@etsiig.uniovi.es"„		PRINT "Usage: joint [S,T] file1 file2 [...file68] >out (Space;Tab;file>?.)"„ELSE„		FOR z = 1 TO largo„				char$ = MID$(cade$, z, 1)„				IF char$ = ">" OR char$ = "<" THEN EXIT FOR„				IF INSTR(Delim$, char$) <> 0 THEN„						flag = 0„				ELSE„						IF flag = 0 THEN i = i + 1„						flag = 1: token$(i) = token$(i) + char$„				END IF„		NEXT z„		FOR k = 1 TO i„				OPEN token$(k) FOR INPUT AS #k„		NEXT k„		DO„				linea$ = "": kount = 0„				FOR k = 1 TO i„						temp$ = ""„						IF LEN(token$(k)) > 1 THEN LINE INPUT #k, temp$„						linea$ = linea$ + mete$ + temp$„				NEXT k„				PRINT linea$„				FOR k = 1 TO i„						IF EOF(k) <> 0 THEN„								token$(k) = "": kount = kount + 1„						END IF„				NEXT k„		LOOP UNTIL kount >= i„END IF„FOR i = -2 TO 5„		SOUND 440 * (2 ^ (i - 10 / 12)), .6„NEXT i„END„Jesu's Lozano                  COMMATOR                       comp.lang.basic.misc           Unknown Date           QB, QBasic, PDS        115  3909     COMMATOR.BAS'    This is a another util (like JOINT.BAS) to solve 'little „'problems' reading sequential ascii data coming from/to non PC „'machines or from spreadsheets.„'    I.e. tipically a spreadsheet print ascii data in strange „'format, dificulting reading and proccesing. More than 255 chars „'per line were printed as„'        1111111111111111„'        2222222222222222„'        111„'        222„'    When you want 11111111111111„'              111„'              22222222222222„'              222„'    Well, just cut the full lines to many files, the rest to „'another and use the joint.bas code to concatenate by lines...„	„'    BUT what about the space formats which difficults reading „'plain text data as we like? „'    i.e. Gijon 5170968 Trabajo 5182188 (not correctly readed)„'    vs.  Gijon,5170968,Trabajo,5182188 (ok to read) „	 „'    Bla, bla... here is the PDS code  :-)„„„   F1$ = ";": F2$ = "<": F3$ = "=": F4$ = ">": F5$ = "?"„   F6$ = "@": F7$ = "A": F8$ = "B": F9$ = "C": F10$ = "D"„   CR$ = CHR$(13): BS$ = CHR$(8): ESC$ = CHR$(27)„   aleft$ = "K": ARIGHT$ = "M": ADOWN$ = "P": AUP$ = "H"„   AHOME$ = "G": AEND$ = "O": PGUP$ = "I": PGDN$ = "Q"„REM ----------------------------------------------------„PRINT "[ COMMATOR = Insert a lot of commas in your data files ,TA-CHAAN!,]"„PRINT "Limited to 10,000 lines. Plea, support bad programmers: Report bugs"„PRINT "Price: 0 Registration: OFF Bugs: ON Author: lozano@etsiig.uniovi.es"„INPUT "  My file is pathnamed as: ", infil$„INPUT "  and want to store commated file in: ", oufil$„OPEN LTRIM$(RTRIM$(infil$)) FOR INPUT AS #1„PRINT„PRINT "Well. Now we need to show a line to serve as pattern to put some commas."„PRINT "Press arrow keys to view lines and RETURN to accept the best one. %-)   "„DIM jumpi(1 TO 10000) AS LONG„		inilin = CSRLIN: n = 1„		DO„				IF EOF(1) THEN„						n = n - 1„						SOUND 800, .2„						SEEK #1, jumpi(n)„				END IF„				LINE INPUT #1, linea$„				lenlinea = LEN(linea$)„				jumpi(n) = SEEK(1) - lenlinea - 2„				LOCATE inilin, 1: COLOR 0, 7: PRINT LEFT$(linea$, 78);„				IF lenlinea < 78 THEN PRINT SPACE$(78 - lenlinea);„				GOSUB esperatecla„IF (scant$ = PGUP$ OR scant$ = AHOME$ OR scant$ = AUP$ OR sacnt$ = aleft$) THEN„				IF n > 1 THEN n = n - 1„				SEEK #1, jumpi(n)„ELSE„				n = n + 1„END IF„		LOOP UNTIL tecla$ = CR$„COLOR 7, 0: PRINT : PRINT„PRINT "Good. Now we have a petrified line. Let's overwrite over it some commas."„PRINT "Arrows, charts... Press SPACE to blank or RETURN to accept make the file"„		inilin = CSRLIN: i = 1„		DIM comma(lenlinea) AS INTEGER„		DO„				LOCATE inilin, 1: COLOR 7, 0: PRINT MID$(linea$, i, 79);„				IF lenlinea < 79 THEN PRINT SPACE$(79 - lenlinea);„				LOCATE inilin, 1: COLOR 0, 7: PRINT MID$(linea$, i, 1);„				GOSUB esperatecla„				SELECT CASE scant$„				CASE AHOME$: i = 1„				CASE aleft$: i = i - 1„				CASE ARIGHT$: i = i + 1„				CASE AEND$: i = lenlinea„				END SELECT„				IF i < 1 THEN i = 1„				IF i > lenlinea THEN i = lenlinea„				IF tecla$ = CR$ THEN EXIT DO„				IF LEN(tecla$) < 2 THEN„						comma(i) = ASC(tecla$)„						LOCATE inilin, 1: COLOR 7 + 16, 0: PRINT tecla$;„						SLEEP 1„				END IF„				IF tecla$ = " " THEN comma(i) = 0„		LOOP„SEEK #1, 1„OPEN LTRIM$(RTRIM$(oufil$)) FOR OUTPUT AS #2„PRINT "Working...";„DO„		LINE INPUT #1, linea$„		lenlinea = LEN(linea$)„		lineaout$ = ""„		FOR i = 1 TO lenlinea„				IF i <= UBOUND(comma, 1) THEN„				IF comma(i) <> 0 THEN lineaout$ = lineaout$ + CHR$(comma(i))„				END IF„				lineaout$ = lineaout$ + MID$(linea$, i, 1)„		NEXT i„		PRINT #2, lineaout$„LOOP UNTIL EOF(1)„FOR i = -2 TO 5„		SOUND 440 * (2 ^ (i - 10 / 12)), .6„NEXT i„COLOR 7, 0: PRINT : PRINT "All done! Confused? Me too..."„END„„esperatecla:„tecla$ = ""„WHILE tecla$ = ""„		tecla$ = UCASE$(INKEY$)„		scant$ = MID$(tecla$, 2, 1)„WEND„RETURN„Unknown Author(s)              FULL STRING EDIT               FidoNet QUIK_BAS Echo          Unknown Date           QB, QBasic, PDS        121  5031     FULLEDIT.BASDEFINT A-Z„SUB KeyIn (Ver$, Ln$, Mask$, Fg, Bg, p)„„'Ln$ = SPACE$(Number of Charecters to accept)„'Ver$ = "ALL"          All Characters„'Ver$ = "a-z"          Alpha Lower Case„'Ver$ = "A-Z"          Alpha Upper Case„'Ver$ = "a-Z"          Alpha Case off„'Ver$ = "#'s"          Numbers Only„'Mask$ = ""            i.e. To Enter DOB Mask$ would be "  /  /  "„'Fg/Bg                 ForeGround Color/Background Color„'p                     Screen Page Number„   DIM Chk(10)„   IF Mask$ <> "" THEN„      Ln$ = Mask$„      FOR Chk = 1 TO LEN(Mask$)„         IF MID$(Mask$, Chk, 1) <> " " THEN Temp$ = Temp$ + STR$(Chk)„      NEXT Chk„      Mask$ = Temp$„   END IF„   S = POS(0): L = LEN(Ln$): COLOR Fg, Bg: PRINT Ln$; : IF p = 0 THEN p = 1„   IF p > L THEN p = L + 1„   LOCATE , S + p - 1, 1, 7, 7: Temp$ = ""„   Alpha$ = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"„   Num$ = " 0123456789"„   IF UCASE$(LEFT$(Ver$, 4)) = "A-Z#" THEN Ver$ = Alpha$ + Num$ + MID$(Ver$, 5)„   SELECT CASE LEFT$(Ver$, 3)„      CASE "ALL": Caps = 0: Ver$ = Alpha$+Num$+"!@#$%^&*()-_+=\[]{};':,./<>? "„      CASE "A-Z": Caps = 1: Ver$ = Alpha$ + MID$(Ver$, 4)„      CASE "a-z": Caps = 2: Ver$ = Alpha$ + MID$(Ver$, 4)„      CASE "a-Z": Caps = 0: Ver$ = Alpha$ + MID$(Ver$, 4)„      CASE "#'s": Caps = 0: Ver$ = Num$ + MID$(Ver$, 4)„      CASE ELSE: Caps = 0„   END SELECT„„   a = 0: e = 0„   WHILE a <> 13 AND a <> 27 AND a <> 10„      DO„         IF Caps = 0 THEN a$ = INKEY$„         IF Caps = 1 THEN a$ = UCASE$(INKEY$)„         IF Caps = 2 THEN a$ = LCASE$(INKEY$)„      LOOP UNTIL a$ <> ""„      a = ASC(a$): IF a = 0 THEN a = ASC(RIGHT$(a$, 1)) * -1„      p = POS(0) - S + 1: R = POS(0)„      'SCREEN , , 0, 0: COLOR 7, 0: CLS : PRINT a: END„   SELECT CASE a„      CASE -32                                          ' ALT-D For Dos„Shell„         SCREEN , , 0, 0: CLS„         SHELL "Type EXIT [ENTER] To Return To Program"„         SHELL„      CASE -77: IF p < L + 1 THEN PRINT CHR$(28);  ELSE BEEP    ' Right arrow„      CASE -75: IF p <> 1 THEN PRINT CHR$(29);                  ' Left arrow„      CASE -71: LOCATE , S                                      ' <Home>„      CASE -119                                                 ' <Ctrl+Home>„         LOCATE , S: Ln$ = SPACE$(L): PRINT Ln$; : LOCATE , S„      CASE -79„         LOCATE , LEN(RTRIM$(Ln$)) + S                          ' <End>„      CASE -117                                                 ' <Ctrl+End>„         Ln$ = LEFT$(Ln$, p - 1) + SPACE$(L - p + 1)„         LOCATE , S, 0: PRINT Ln$; : LOCATE , R, 1„      CASE -116                                           ' <Ctrl+RightArrow>„         IF p <= L THEN„            Chk = INSTR(p, Ln$, " ")„            IF Chk <> 0 THEN„               Temp$ = LEFT$(LTRIM$(MID$(Ln$, Chk)), 1)„               IF Temp$ <> "" THEN LOCATE , S - 1 + INSTR(Chk, Ln$, Temp$), 1„            ELSE„               LOCATE , LEN(RTRIM$(Ln$)) + S„            END IF„         END IF„      CASE -115                                          ' <Ctrl+LeftArrow>„        Temp$ = RTRIM$(LEFT$(Ln$, p - 1))„        IF INSTR(Temp$, " ") THEN„           DO WHILE INSTR(Temp$, " ")„              Chk = INSTR(Temp$, " "): MID$(Temp$, Chk, 1) = "X"„           LOOP„           LOCATE , Chk + S, 1„        ELSE„           LOCATE , S„        END IF„      CASE 8                                              ' <Back Space>„         IF p <> 1 THEN„            Ln$ = LEFT$(Ln$, p - 2) + MID$(Ln$, p) + " "„            LOCATE , S, 0: PRINT Ln$; : LOCATE , R - 1, 1„         ELSE„            Ln$ = RIGHT$(Ln$, L - 1) + " ": LOCATE , S, 0: PRINT Ln$;„            LOCATE , p + S - 1, 1„         END IF„      CASE 127                                             ' <Ctrl+ BckSpc>„         IF p > L THEN p = L„         Ln$ = SPACE$(p) + MID$(Ln$, p + 1)„         LOCATE , S, 0: PRINT Ln$; : LOCATE , R, 1„      CASE -83                                                  '<Delete>„         IF p <= L THEN„            Ln$ = LEFT$(Ln$, p - 1) + MID$(Ln$, p + 1) + " "„            LOCATE , S, 0: PRINT Ln$; : LOCATE , R, 1„         END IF„      CASE -82                                                 '<Insert>„           IF insert = 0 THEN insert = 1 ELSE insert = 0„           IF insert = 0 THEN LOCATE , , 1, 7, 7„           IF insert = 1 THEN LOCATE , , 1, 4, 7„      CASE ELSE„         IF INSTR(Ver$, a$) AND p <= L THEN                 ' Print Character„            IF insert = 1 THEN„               Ln$ = LEFT$(Ln$, p - 1) + a$ + MID$(Ln$, p, L - p + 1)„               LOCATE , , 0: PRINT MID$(Ln$, p, L - p + 1); : LOCATE , R + 1, 1„            ELSE„               PRINT a$; : MID$(Ln$, p, 1) = a$„            END IF„            IF INSTR(Mask$, STR$(p + 1)) THEN PRINT MID$(Ln$, p + 1, 1);„         ELSE IF a <> 13 AND a <> 27 THEN BEEP„         END IF„      END SELECT„   WEND„   IF a = 27 THEN Ln$ = SPACE$(L)„„EndKeyIn:„Ln$ = RTRIM$(Ln$)„„END SUB„Jim Giordano                   DUMP FILE TO SCREEN            FidoNet QUIK_BAS Echo          06-26-93 (18:59)       QB, QBasic, PDS        337  9827     DUMP.BAS    'Dump by Jim Giordano.  Released for all non-comercial use.„'Note: add DEF SEG commented out below for use with Basic 7.1 PDS„„DEFINT A-Z„f$ = COMMAND$„IF f$ = "" THEN„   PRINT : PRINT : INPUT "Enter file name to dump - "; f$„END IF„f$ = LTRIM$(RTRIM$(f$))„IF f$ = "" THEN SYSTEM„„OPEN "B", 1, f$, 2048„FLength& = LOF(1)            'Number of bytes to process„IF FLength& = 0 THEN„  PRINT "Error opening filename "; f$; ".  Check for file name error."„  CLOSE #1„  KILL f$ 'eliminate file we just made„  SYSTEM„END IF„TabAmt& = FLength& \ 10      ' 10% tab amount„„DIM H$(255), D$(255), aa(255), nn$(255)„FOR i = 0 TO 255„    H$(i) = MID$(HEX$(&H100 + i), 2)„    D$(i) = MID$(STR$(1000 + i), 3)„    IF i < 32 AND (i = 7 OR (i > 8 AND i < 14) OR i > 27) THEN„      aa(i) = -1„    END IF„NEXT i„„CLS„ff$ = "Dump of file " + f$„LOCATE 1, (80 - LEN(ff$)) \ 2„PRINT ff$„'FOR I = 1 TO 8: PRINT "....+....|"; : NEXT I„GOSUB BottomStuff„„D& = 1 'start at first byte„AddOpt = -1  '-1 for decimal, 0 for hex„„LinesOfDump = 16„„DmpTyp$ = "Hex"„'DmpTyp$ = "Decimal"„GOSUB SetUp„„ssc$ = STRING$(17 * 80, " ")   'screen„„DO„   SEEK 1, D&„   a$ = INPUT$(BSize, 1)„'s! = TIMER: FOR xxx = 1 TO 80„   pp = 88„   sc$ = ssc$„   Padd& = D&„   IF Padd& > 1000000 THEN  'put millions part above„      TopAmt& = (Padd& \ 1000000) * 1000000„      Padd& = Padd& - TopAmt&„      MID$(sc$, 1) = "Address+" + STR$(TopAmt&)„   END IF„   FOR p = 1 TO LEN(a$) STEP Stp„      IF AddOpt THEN    'decimal„          aaa$ = MID$(STR$(Padd&), 2)„      ELSE„          aaa$ = HEX$(Padd&)„      END IF„      MID$(sc$, pp - LEN(aaa$)) = aaa$„      Padd& = Padd& + Stp„      ppc = pp + 2„      ss$ = MID$(a$, p, Stp)„      ssmax = LEN(ss$) - 1„      FOR i = 0 TO ssmax„         'DEF SEG = SSEG(ss$)    '*****note, add this line for qbx pds„         ppx& = SADD(ss$)„         aa = PEEK(ppx& + i)„         MID$(sc$, ppc) = nn$(aa)„         ppc = ppc + ppcamt„         IF aa(aa) THEN POKE ppx& + i, 32„      NEXT i„      MID$(sc$, pp + ppsamt + 1) = ss$   'ascii characters„      pp = pp + 80„   NEXT p„   LOCATE 3, 1, 0  'turn off cursor for print„   PRINT sc$;„'NEXT xxx: e! = TIMER: LOCATE 21, 1: PRINT "et="; e! - s!: SYSTEM„„   LOCATE 23, pcol: PRINT blnk$; : LOCATE 23, pcol, 1„   D$ = ""„   DOld& = D&   'wait for a change of position„   DO„      i$ = INKEY$„      i$ = UCASE$(i$)„      IF LEN(i$) = 2 AND LEFT$(i$, 1) = CHR$(0) THEN 'special key„         i$ = MID$(i$, 2)„         IF i$ = CHR$(73) THEN      'page up„            IF D& > BSize THEN D& = D& - BSize ELSE D& = 1„         ELSEIF i$ = CHR$(81) THEN  'page down„            IF FLength& - D& > BSize THEN D& = D& + BSize„         ELSEIF i$ = CHR$(72) THEN  'up„            IF D& > Stp THEN D& = D& - Stp ELSE D& = 1„         ELSEIF i$ = CHR$(80) THEN  'down„            IF FLength& - D& > Stp THEN D& = D& + Stp„         ELSEIF i$ = CHR$(77) THEN  'right„            IF D& < FLength& THEN D& = D& + 1„         ELSEIF i$ = CHR$(75) THEN  'left„            IF D& > 1 THEN D& = D& - 1„         ELSEIF i$ = CHR$(71) THEN  'home„            D& = 1„         ELSEIF i$ = CHR$(79) THEN  'end„            IF FLength& > BSize THEN D& = FLength& - BSize + 1 ELSE D& = 1„         ELSEIF i$ = CHR$(59) THEN  'f1, help„            GOSUB HelpScreen„            EXIT DO„         ELSEIF i$ = CHR$(67) THEN  'f9, search again„            GOSUB SearchAgain„         ELSEIF i$ = CHR$(92) THEN  'shift f9, search again„            GOSUB SearchBackwards„         ELSEIF i$ = CHR$(15) THEN  'shift tab, back 10%„            IF D& - TabAmt& > 0 THEN D& = D& - TabAmt&„         END IF„      ELSEIF i$ = "A" THEN       'change addressing„         AddOpt = NOT AddOpt„         EXIT DO                 'force exit since address didnt change„      ELSEIF i$ = "D" THEN      'wants decimal„         DmpTyp$ = "Decimal"„         GOSUB SetUp„         EXIT DO„      ELSEIF i$ = "H" THEN      'wants hex„         DmpTyp$ = "Hex"„         GOSUB SetUp„         EXIT DO„      ELSEIF i$ = "S" THEN„         s$ = "": GOSUB SearchAgain    'go get string to search for„      ELSEIF i$ = CHR$(9) THEN 'tab„         IF FLength& > D& + TabAmt& THEN D& = D& + TabAmt&„      ELSEIF i$ = CHR$(13) OR i$ = " " THEN„         IF LEN(D$) = 0 THEN„            IF FLength& - D& > BSize THEN D& = D& + BSize„         ELSE„            IF VAL(D$) <= FLength& THEN„               D& = VAL(D$)„            ELSE„               BEEP„            END IF„         END IF„      ELSEIF i$ = CHR$(27) THEN„         GOTO wrap„      ELSEIF i$ >= "0" AND i$ <= "9" THEN„         D$ = D$ + i$: PRINT i$;„      ELSEIF i$ = CHR$(8) THEN„         IF LEN(D$) > 0 THEN„            D$ = LEFT$(D$, LEN(D$) - 1)„            LOCATE , POS(0) - 1„            PRINT " ";„            LOCATE , POS(0) - 1„         END IF„      END IF„   LOOP WHILE D& = DOld& AND force = 0„   DO  'clear pending keys„   LOOP WHILE LEN(INKEY$)„LOOP WHILE D& > 0„wrap:„SYSTEM„„BottomStuff:„LOCATE 22, 1„PRINT FLength&; "characters available on file"„PRINT "Enter starting character number to dump - ";„pcol = POS(0)„blnk$ = SPACE$(80 - pcol)„PRINT : PRINT "Press F1 for commands";„RETURN„„HelpScreen:„LOCATE 3, 1„hlpblnk$ = SPACE$(60)„FOR hb = 1 TO 18„   LOCATE , 10: PRINT hlpblnk$„NEXT hb„LOCATE 4, 1„ts = 16„LOCATE , ts: PRINT "    Possible actions are as follows:"„PRINT„LOCATE , ts: PRINT "Escape key = quit program"„LOCATE , ts: PRINT "PgUp = up one page"„LOCATE , ts: PRINT "PgDn, space bar or Enter key = down one page"„LOCATE , ts: PRINT "Home = start of file,  End = end of file"„LOCATE , ts: PRINT "Up or Down = up or down one line"„LOCATE , ts: PRINT "Left or Right = up or down one byte"„LOCATE , ts: PRINT "S = enter string to search for"„LOCATE , ts: PRINT "F9 = search for string"„LOCATE , ts: PRINT "Shift-F9 = search backward for string"„LOCATE , ts: PRINT "Tab = move down file 10%,  Shift-Tab = Up 10%"„LOCATE , ts: PRINT "A = toggle address from Hex to Decimal"„LOCATE , ts: PRINT "D = dump in decimal,  H = dump in hex"„PRINT„LOCATE , 16: PRINT "    Press any key to continue - ";„SLEEP„RETURN„„Search:„   LOCATE 20, 1, 0„   FOR bb = 1 TO 4: PRINT SPACE$(80): NEXT bb„   LOCATE 20, 1„   PRINT "Enter string to search for, left arrow to backspace, press F9 when done"„   s$ = ""„   PRINT "ASCII   = "„   PRINT "Decimal = "„   PRINT "Hex     = "„   DO„      DO„         Sx$ = INKEY$„      LOOP WHILE Sx$ = ""„      IF LEN(Sx$) > 1 THEN  'possible function key„         IF ASC(MID$(Sx$, 2)) = 75 THEN 'left arrow key, backspace„             IF LEN(s$) > 0 THEN„                s$ = LEFT$(s$, LEN(s$) - 1)„                FOR bb = 21 TO 23„                    LOCATE bb, LEN(s$) * 4 + 13: PRINT "    "„                NEXT bb„             END IF„         ELSEIF ASC(MID$(Sx$, 2)) = 67 THEN 'f9, wrap up„             EXIT DO„         END IF„      ELSEIF LEN(s$) * 4 + 14 < 80 THEN„         LOCATE 21, LEN(s$) * 4 + 14„         aa = ASC(Sx$)„         IF aa < 32 AND (aa = 7 OR (aa > 8 AND aa < 14) OR aa > 27) THEN„              'dont PRINT„         ELSE„               PRINT Sx$„         END IF„         LOCATE 22, LEN(s$) * 4 + 13„         PRINT D$(aa)„         LOCATE 23, LEN(s$) * 4 + 13„         PRINT H$(aa)„         s$ = s$ + Sx$„      END IF„   LOOP„         „   LOCATE 20, 1, 0:„   FOR bb = 1 TO 4: PRINT SPACE$(80): NEXT bb„   GOSUB BottomStuff„   RETURN„„SearchAgain:„„   IF s$ = "" THEN„      GOSUB Search„      IF s$ = "" THEN RETURN  'no change„   END IF„   DO: LOOP WHILE LEN(INKEY$) > 0       'clear key board„   DOld& = D&„   DO„      Sx = INSTR(2, a$, s$)„      IF Sx > 0 THEN„         D& = D& + Sx - 1   'new start of page„         RETURN„      END IF„      IF FLength& - D& > BSize THEN„          D& = D& + BSize„          SEEK 1, D&„          a$ = INPUT$(BSize, 1)„      ELSE„          BEEP„          RETURN   'stay at last found d&„      END IF„      GOSUB SeeIfAbort„      IF AbortSearch THEN D& = DOld&: RETURN„   LOOP„„SearchBackwards:„„   IF s$ = "" THEN„      GOSUB Search„      IF s$ = "" THEN RETURN  'no change„   END IF„   DO: LOOP WHILE LEN(INKEY$) > 0       'clear key board„   DOld& = D&„   DO„      IF D& = 1 THEN„          BEEP„          RETURN  'at beginning of file„      END IF„      IF D& > BSize THEN D& = D& - BSize ELSE D& = 1„      SEEK 1, D&„      a$ = INPUT$(BSize, 1)„      Sx = INSTR(a$, s$) 'find first occurance this page„      IF Sx > 0 AND Sx < DOld& THEN 'found one„        DO„         nxsx = INSTR(Sx + 1, a$, s$)„         IF nxsx = 0 OR nxsx >= DOld& THEN„            D& = D& + Sx - 1   'new start of page„            RETURN„         END IF„         Sx = nxsx   'use later one„        LOOP„      END IF„      GOSUB SeeIfAbort„      IF AbortSearch THEN D& = DOld&: RETURN„   LOOP„STOP 'will never get here„„SeeIfAbort:„   AbortSearch = 0 'preset false„   IF INKEY$ <> "" THEN„      LOCATE 25, 1: PRINT "Abort Search ? <N>";„      DO„        qs$ = INKEY$„      LOOP WHILE qs$ = ""„      LOCATE 25, 1: PRINT "                   ";„      qs$ = UCASE$(qs$)„      IF qs$ = "Y" THEN AbortSearch = -1„   END IF„   RETURN„„„SetUp:„IF DmpTyp$ = "Decimal" THEN„  Stp = 14            'number of items per line„  BSize = Stp * LinesOfDump    'block size to read„  qq$ = STRING$(Stp * 4 + 2, " ")  'string to hold dump values„  ppsamt = 65 - 8„  ppcamt = 4„  nnamt = 1„  FOR i = 0 TO 255: nn$(i) = D$(i): NEXT i„ELSEIF DmpTyp$ = "Hex" THEN„  Stp = 16„  BSize = Stp * LinesOfDump„  qq$ = STRING$(Stp * 3 + 8, " ")„  ppsamt = 60 - 8„  ppcamt = 3„  nnamt = 2„  FOR i = 0 TO 255: nn$(i) = H$(i): NEXT i„END IF„RETURN„„Unknown Author(s)              PRINT HUGE CHARACTERS          FidoNet QUIK_BAS Echo          09/95                  QB, QBasic, PDS        90   2606     HUGECHAR.BASCONST MaxSlides = 65       '<<-- Enter Number of Slides Here (65)„CONST MaxPause = 90        '<<-- Enter Number of Seconds to Pause (90)„„DECLARE SUB GetVideoSeg ()„DECLARE SUB BigChar (CharCode%)„DECLARE SUB BigPrint (Text$)„DECLARE SUB CountTime ()„DIM SHARED VideoSeg&„SCREEN 0: WIDTH 80, 25: CLS„CALL GetVideoSeg„FOR a% = MaxSlides TO 1 STEP -1„   CLS„   LOCATE 1, 50: PRINT "  Press SPACE to PAUSE"„   LOCATE 3, 50: PRINT "Press ENTER for NEXT SLIDE"„   LOCATE 5, 50: PRINT "   Press ESC to EXIT"„   LOCATE 1, 1: CALL BigPrint(LTRIM$(STR$(a%)))„   CALL CountTime„   SOUND 200, 2: SOUND 32000, 1: SOUND 200, 2„NEXT a%„END„„SUB BigChar (CharCode%)„'--- Displays a BIG Character at current Cursor Location ---„Xpos% = POS(0): Ypos% = CSRLIN„DEF SEG = &HF000„FOR ScanLine% = 0 TO 7„   BitCode% = PEEK(&HFA6E + ScanLine% + CharCode% * 8)„   LOCATE Ypos% + ScanLine%, Xpos%„   FOR Bits% = 1 TO 8„      IF BitCode% < 128 THEN Show$ = "  " ELSE Show$ = CHR$(219) + CHR$(178)„      PRINT Show$;„      IF BitCode% > 127 THEN BitCode% = BitCode% - 128„      BitCode% = BitCode% * 2„   NEXT Bits%„NEXT ScanLine%„DEF SEG„LOCATE Ypos%, Xpos%„END SUB„„SUB BigPrint (Text$)„'--- Displays a BIG String at current Cursor Location ---„Xpos% = POS(0): Ypos% = CSRLIN„FOR a% = 1 TO LEN(Text$)„   Xtemp% = (a% - 1) * 16 + Xpos%„   LOCATE Ypos%, Xtemp%„   CALL BigChar(ASC(MID$(Text$, a%, 1)))„NEXT a%„LOCATE Ypos%, Xpos%„END SUB„„SUB CountTime„'---  Counts the time for Each Slide. Includes Pausing ---„FOR a% = MaxPause TO 1 STEP -1„   T! = TIMER„   LOCATE 10, 1: PRINT "You Have"; a%; "Seconds Left...   "„   IF a% = 10 THEN„      LOCATE 14, 25: PRINT "****  10 Second Warning!  ****"„      SOUND 130, 2„   END IF„   DO: I$ = INKEY$„   LOOP UNTIL (TIMER > T! + 1) OR (I$ <> "")    '<-- Pause for 1 Second„   IF I$ = " " THEN„      '--- Press SPACE to Pause ---„      LOCATE 15, 1: CALL BigPrint("Pause")„      I$ = INPUT$(1)„      CALL BigPrint("     ")„   ELSEIF I$ = CHR$(13) THEN„      '--- Press ENTER to Skip to Next Slide ---„      EXIT SUB„   ELSEIF I$ = CHR$(27) THEN„      '--- Press ESC to Exit Program ---„      CLS : LOCATE 8, 12„      CALL BigPrint("Bye!")„      END„   END IF„NEXT a%„END SUB„„SUB GetVideoSeg„'---  Just Does some Setting Up Stuff... ---„   VideoSeg& = 0„   DEF SEG = &H40: VideoMode% = PEEK(&H49)„   IF VideoMode% = 7 THEN VideoSeg& = &HB000„   IF VideoMode% < 4 THEN VideoSeg& = &HB800„   IF VideoSeg& = 0 THEN„      LOCATE 12, 25: PRINT "ERROR: Unfamiliar video mode!"„      END„   END IF„END SUB„„Erik Olson                     EDIT STRING IN BOX             EDIT,STRING,IN,BOX             Unknown Date           PB                     93   2488     EDITBOX.BAS $IF 0„„'   THIS FILE: EDITBOX$.BAS for PowerBASIC„'      AUTHOR: Erik Olson„' DESCRIPTION: Function to edit a string in a box„„$ENDIF„„' this subroutine already contains SINBOX.BAS, which draws a box around„' the input line.  You can, of course, use your own box routine, or„' not use one at all.„„' EDITBOX$ is a function which returns whatever was typed into the field.„' DEFAULT$ is the argument, which should be padded with spaces to equal the„' total size of the edit field.„„„' Example:„„A$=EditBox$("This is the Default     ")„CLS„IF A$="" THEN PRINT "You aborted" ELSE PRINT "You entered: ";A$„„„„„FUNCTION EditBox$(Default$)„„COLOR 0,7„CALL SingleBox(19, 38-(LEN(Default$)\2), 21, 42+(LEN(Default$)\2))„y = 40 - (LEN(Default$) \ 2) : YY=0„DO„„„   LOCATE 20,Y,0:PRINT Default$  ' if you want to put the box somewhere„   LOCATE  20,Y+yy,1             ' else, change these locate statements„„„   DO:A$=INKEY$:LOOP WHILE LEN(A$)=0„   IF LEN(A$) THEN„      SELECT CASE(A$)„      CASE CHR$(27), CHR$(13)„         EXIT SELECT„      CASE CHR$(8)„         IF YY THEN„            YY=YY-1„            IF YY THEN„               Default$=LEFT$(Default$,yy)+MID$(Default$,yy+2) + " "„            ELSE„               Default$=MID$(Default$,yy+2) + " "„            END IF„         END IF„      CASE CHR$(0)+CHR$(83)„         IF YY THEN„            Default$=LEFT$(Default$,yy)+MID$(Default$,yy+2) + " "„         ELSE„            Default$=MID$(Default$,yy+2) + " "„         END IF„      CASE CHR$(0)+CHR$(&H4D)„         IF YY < LEN(Default$) THEN YY=YY+1„      CASE CHR$(0)+CHR$(&H4B)„         IF YY THEN YY=YY-1„      CASE CHR$(0)+CHR$(79) 'end„         yy=LEN(RTRIM$(default$))„      CASE CHR$(0)+CHR$(71)„         yy=0„„      CASE ELSE„         IF LEN(A$)=1 and YY=0 THEN Default$=SPACE$(LEN(default$))„         IF LEN(A$)=1 and YY < LEN(Default$) THEN_„         MID$(Default$,YY+1,1) = A$ : YY=YY+1„„      END SELECT„      IF A$=CHR$(27) THEN EditBox$="":EXIT LOOP„      IF A$=CHR$(13) THEN EditBox$=RTRIM$(Default$):EXIT LOOP„„   END IF„LOOP„END FUNCTION„„„„„SUB SingleBox (Wa%, Wb%, Wc%, Wd%)„   LOCATE Wa%, Wb%: PRINT CHR$(213) + STRING$((Wd% - Wb%) - 1, 205) + CHR$(184)„   LOCATE Wc%, Wb%: PRINT CHR$(212) + STRING$((Wd% - Wb%) - 1, 205) + CHR$(190)„„   FOR zxy% = 1 TO Wc% - Wa% - 1„      LOCATE Wa% + zxy%, Wb%„      PRINT CHR$(179) + SPACE$((Wd% - Wb%) - 1) + CHR$(179)„   NEXT zxy%„„END SUB„John Sneeringer                COPY A FILE                    QBFAQ                          03-02-92 (19:11)       QB, QBasic, PDS        21   678      DOS.BAS            ' ===========================================================„       '  Copy File From Command Line -> Named to whatever F2$ is.„       ' ===========================================================„„       F1$ = COMMAND$    ' Target filename from command line„„       INPUT "New Name?"; F2$      ' name of file you want to copy to„„       OPEN "B", 1, F1$„       OPEN "B", 2, F2$„       A$ = SPACE$(1024)„       FOR i = 1 TO LOF(1) \ 1024„          GET 1, , A$„          PUT 2, , A$„       NEXT i„       IF LOF(1) MOD 1024 > 0 THEN„           A$ = SPACE$(LOF(1) MOD 1024)„           GET 1, , A$„           PUT 2, , A$„       END IF„       CLOSE 1, 2„John White/Dan Bridges         LINE WRAPPING                  FidoNet QUIK_BAS Echo          09-20-92 (19:57)       QB, QBasic, PDS        165  4661     WRAPLINE.BAS' WRAPLINE.BAS, Public Domain, John White 1:3636/2, 09-09-92„' With additions by Dan Bridges 3:640/820.2 @Fidonet, 20-Sep-92„' StrLen =  Maximum length of each line„' StrIn$ = The string to parse„' Work$  = Temp variable for parsing„' WorkPlus$ = Used to ensure that words aren't split„' ParsedLines$() = Array holding the parsed strings„' NumOfLines = Maximum number of parsed strings in ParsedLines$()„' GoNoLower = Ensures that line length is bigger than biggest word„'======================================================================„„DEFINT A-Z„DECLARE FUNCTION MaxWordLen (StrIn$)„DECLARE SUB WrapLine (StrLen, StrIn$, ParsedLines$(), NumOfLines)„DECLARE SUB DisplayArray (ParsedLines$(), NumOfLines, StrLen)„DECLARE SUB VaryLineLength (GoNoLower, StrLen, StrIn$, ParsedLines$(), NumOfLines)„„StrLen = 40„„DIM ParsedLines$(255)„„CONST False = 0, True = NOT False„„StrIn$ = "This is a very, very, very, long line and I think it will never end. Then again: it eventually must."„„GoNoLower = MaxWordLen(StrIn$)„„CLS„„CALL WrapLine(StrLen, StrIn$, ParsedLines$(), NumOfLines)„CALL DisplayArray(ParsedLines$(), NumOfLines, StrLen)„CALL VaryLineLength(GoNoLower, StrLen, StrIn$, ParsedLines$(), NumOfLines)„„END„„SUB DisplayArray (ParsedLines$(), NumOfLines, StrLen)„„CLS„„IF NumOfLines = 0 THEN„  PRINT "No Data in StrIn$"„  END„END IF„„COLOR 15, 0„PRINT LEFT$("....x....1....x....2....x....3....x....4....x....5....x....6....x....7....x....8", StrLen)„' Replace "x"s above with Alt-254 characters (small block).„' High ASCII characters replaced for Fidonet transmission.„COLOR 7, 0„„FOR LineNum = 1 TO NumOfLines„  PRINT ParsedLines$(LineNum)„NEXT LineNum„„NumOfLines = 0„„END SUB„„FUNCTION MaxWordLen (StrIn$)„„  StrIn$ = LTRIM$(RTRIM$(StrIn$))„„  IF INSTR(StrIn$, " ") = 0 THEN„    MaxWordLen = LEN(StrIn$)„    EXIT FUNCTION„  END IF„„  Space1 = INSTR(StrIn$, " ")„„  DO„    Space2 = INSTR(Space1 + 1, StrIn$, " ")„„    IF Space2 = 0 THEN„      WordLen = LEN(StrIn$) - Space1„    ELSE„      WordLen = Space2 - Space1 - 1„    END IF„„    IF WordLen > TempMaxLen THEN TempMaxLen = WordLen„    Space1 = Space2„  LOOP WHILE Space2„„    MaxWordLen = TempMaxLen„„END FUNCTION„„SUB VaryLineLength (GoNoLower, StrLen, StrIn$, ParsedLines$(), NumOfLines)„„DO„  SELECT CASE INKEY$„„  CASE CHR$(45)  'Action if Grey Minus Key is pressed„    IF StrLen = GoNoLower THEN„      LOCATE 24, 9: BEEP„      PRINT "Requested Right Margin is less than the length of the longest word."„      LOCATE 25, 9„      PRINT "Margin reduction command ignored! Press any key to clear this message...";„      DO: LOOP WHILE INKEY$ = ""„      CLS„    ELSE„      StrLen = StrLen - 1„    END IF„    CALL WrapLine(StrLen, StrIn$, ParsedLines$(), NumOfLines)„    CALL DisplayArray(ParsedLines$(), NumOfLines, StrLen)„„  CASE CHR$(43)  'Action if Grey Plus Key is pressed„    IF StrLen = 80 THEN„      LOCATE 24, 9: BEEP„      PRINT "Requested Right Margin is greater than 80 characters.";„      LOCATE 25, 9„      PRINT "Margin expansion command ignored! Press any key to clear this message...";„      DO: LOOP WHILE INKEY$ = ""„      CLS„    ELSE„      StrLen = StrLen + 1„    END IF„    CALL WrapLine(StrLen, StrIn$, ParsedLines$(), NumOfLines)„    CALL DisplayArray(ParsedLines$(), NumOfLines, StrLen)„„  CASE CHR$(27)  'Action if Esc Key is pressed„    EXIT DO„„  END SELECT„LOOP„„END SUB„„SUB WrapLine (StrLen, StrIn$, ParsedLines$(), NumOfLines)„„  IF StrIn$ = "" THEN„    NumOfLines = 0„    EXIT SUB„  END IF„  'If string to split is nothing, exit.„„  Work$ = StrIn$                     'Keep original value in StrIn$„  Done = False                       'reset flag„„  DO„    IF LEN(Work$) > StrLen THEN„      NumOfLines = NumOfLines + 1    'Increment index to array„      WorkPlus$ = LEFT$(Work$, StrLen + 1)„      'WorkPlus$ is used to see if there is a space immediately„      'after the requested split point so we do not split a word.„„      FOR SearchStartPos = StrLen TO 1 STEP -1„        LastSpacePos = INSTR(SearchStartPos, WorkPlus$, " ")„        IF LastSpacePos THEN„          ParsedLines$(NumOfLines) = LTRIM$(RTRIM$(LEFT$(Work$, LastSpacePos)))  'Put left (StrLen) chars in array„          Work$ = MID$(Work$, SearchStartPos + 1)„          'Remove parsed segment from Work$„          EXIT FOR„        END IF„      NEXT SearchStartPos„„    ELSE„      Done = True„    END IF„  LOOP UNTIL Done„„  NumOfLines = NumOfLines + 1   'Save remainder of StrIn$„  ParsedLines$(NumOfLines) = LTRIM$(Work$)„„END SUB„„Bert Christensen               INPUT ROUTINES                 PC Resources                   10/93 (00:00)          QB, QBasic, PDS        524  24442    ROSEQBAS.BAS'„' ROSEWOOD QUICKBASIC STUFF v 1 consists of two programs which can be„' incorporated into programs written in QuickBasic 4.xx or QBasic which„' is supplied with MS DOS 5 and 6. Libraries or commands such as„' CALL INTERRUPT not used in QBasic are not needed with this code.„'„' There are two distinct parts of the program:„'„'   The first is an input editor which will replace the commands "INPUT",„' "LINE INPUT", etc. with an input routine written with INKEY$ as the input.„' INKEY$ allows much nicer inputting, especially if you have several inputs„' to process in succession. This editor can be set up to accept various types„' of input and to block other types. This will greatly reduce the amount of„' error checking which is associated with the usual input functions.„'   Some parts of this program may look ancient with its IF..ENDs and GOTOs.„' However, I like to have the ability to cascade through the editor. See„' how scan% = 8 becomes scan% = 83 in the backspace command area. The program„' could be written using only DO..LOOP, SELECT CASE etc. but I doubt that it„' would make the program work better. It would be prettier though.„' The editor is very loosely based on a program from the magazine,„' PC RESOURCES, October 1987, pg. 61„'„'   The second part of the code is a simple window program. Windows of any„' size or colour, with or without a border, can be placed anywhere on the„' screen with text justified left, centre and right, and then wiped off so„' that the original screen below is restored. The speed in drawing and„' erasing these windows is not as great as windows using registers and„' CALL ABSOLUTE, but it is adequate for most purposes.„„' This code is written by:      Bert Christensen„'                               Rosewood Software„'                               135-10 Livonia Place„'                               Scarborough, Ontario, Canada M1E 4W6„'                               (416) 284-6119, CompuServe 70461,2507„'                               Internet bert.christensen@canrem.com„'„'                               Copyright (c) 1993 by Bert Christensen„'„' Anyone is granted full permission to use all or part of this program„' without charge. However, if you should feel moved to send a donation,„' it will not be refused.„'„' Any comments would be appreciated.„'„'„'           ROSEWOOD QUICKBASIC STUFF v 1„'„'           Programmed in MicroSoft QuickBasic 4.5 and VisualBasic for DOS 1.00„'           October 1993„'„'„'        ******DECLARATIONS*****„„DECLARE SUB Fulledit (row%(), column%(), numentry%, inperr%(), item$(), itemlen%(), itemflag%())„DECLARE SUB WindowSub (wintop%, winbot%, winleft%, winright%, winforecolour%, winbackcolour%, wintext$(), winborder%)„DECLARE FUNCTION Justify$ (text$, just%, winleft%, winright%)„DECLARE SUB Frame (toprow%, bottomrow%, leftcol%, rightcol%)„COMMON SHARED /colours/ sfg%, sbg%, rfg%, rbg%, ffg%, fbg%„sfg% = 0        'standard foreground„sbg% = 7        'standard background„rfg% = 7        'reverse foreground„rbg% = 1        'reverse background„REM ffg% = frame foreground„REM fbg% = frame background„„„REM ******************EDITOR SECTION**********************„„LOCATE 1, 1     'goto top left so whole screen will be "coloured"„COLOR sfg%, sbg%„CLS„COLOR rfg%, rbg%„' place prompts on the screen„LOCATE 1, 12: PRINT "`Rosewood QB Stuff' Input Editor for QuickBasic & QBasic"„COLOR sfg%, sbg%„LOCATE 3, 5: PRINT "This field accepts 0 to 9 & space only"; : LOCATE 5, 5: PRINT "This field accepts all alphanumeric entries";„LOCATE 7, 5: PRINT "This field accepts `0' to `9',`-', `.' and `space' only"; : LOCATE 9, 5: PRINT "The Esc key is disabled in this field";„LOCATE 11, 5: PRINT "Edit pre-existing data"; : LOCATE 13, 5: PRINT "Field length of 1"; :   LOCATE 15, 5: PRINT "Field length of 45";„LOCATE 17, 27: PRINT "Fields can be placed anywhere on screen"„LOCATE 19, 1: PRINT STRING$(80, "*");„LOCATE 20, 5: PRINT "Use arrow keys, Home, End, PgUp, PgDn, Del, Bksp, Ins to edit";„LOCATE 21, 5: PRINT "Ctrl F3 to delete input; Ctrl F4 to copy text; Ctrl F5 to paste";„LOCATE 22, 5: PRINT "Ctrl End & Ctrl Home to move to ends of field; Ctrl F10 to quit editing";„LOCATE 23, 5: PRINT "Ctrl F6 to centre text";„entryload$ = "Bert Christensen, Rosewood Software"      'see item$(5) below„numentry% = 8   'number of input items. can be 1 to ??„„REDIM item$(numentry%), itemlen%(numentry%), inperr%(numentry%), row%(numentry%), column%(numentry%), itemflag%(numentry%)„„'item$() = the input item. if there is data to be edited, see below at item$(5).„'if there is no data to be edited then item$() = " ".„'itemlen%() = the length of the item$().„'inperr%() is a flag to manipulate data in the sub, Fulledit„'column%() is the horizontal column position to start the editing of the particular item$()„'row%() is the vertical row to start editing the item$()„'itemflag%() is like inperr%() above (in case you should need 2)„'below is the filling of the arrray„„        item$(1) = " ": itemlen%(1) = 5: inperr%(1) = 0: column%(1) = 44: row%(1) = 3: itemflag%(1) = 1„        item$(2) = " ": itemlen%(2) = 25: inperr%(2) = 0: column%(2) = 50: row%(2) = 5: itemflag%(2) = 0„        item$(3) = " ": itemlen%(3) = 10: inperr%(3) = 0: column%(3) = 64: row%(3) = 7: itemflag%(3) = 2„        item$(4) = " ": itemlen%(4) = 6: inperr%(4) = 1: column%(4) = 45: row%(4) = 9: itemflag%(4) = 0      'inperr% = 1„        item$(5) = entryload$: itemlen%(5) = 40: inperr%(5) = 0: column%(5) = 30: row%(5) = 11: itemflag%(5) = 0„        item$(6) = " ": itemlen%(6) = 1: inperr%(6) = 0: column%(6) = 25: row%(6) = 13: itemflag%(6) = 0„        item$(7) = " ": itemlen%(7) = 45: inperr%(7) = 0: column%(7) = 24: row%(7) = 15: itemflag%(7) = 0„        item$(8) = " ": itemlen%(8) = 20: inperr%(8) = 0: column%(8) = 5: row%(8) = 17: itemflag%(8) = 0„„CALL Fulledit(row%(), column%(), numentry%, inperr%(), item$(), itemlen%(), itemflag%())„„CLS„„REM *****************BACKGROUND PATTERN SECTION*****************„„FOR row% = 1 TO 25„    FOR column% = 1 TO 80„        LOCATE row%, column%„        COLOR sfg%, sbg%„        PRINT CHR$(177);      'fill screen with background pattern„    NEXT column%„NEXT row%„„REM ****************WINDOWS SECTION******************„„    wintop% = 8             'initialize placement of window„    winbot% = 21            '     "         "     "     "„    winleft% = 10           '     "         "     "     "„    winright% = 70          '     "         "     "     "„„„DIM wintext$(winbot% - wintop% + 1)  'dimension array for lines of text„„    REM wintext$(1) is a null string because the frame will cover it„    wintext$(2) = Justify$("Results returned by Rosewood QB Stuff Input Editor", 2, winleft%, winright%)„    wintext$(4) = "item$(1) = " + item$(1)„    wintext$(5) = "item$(2) = " + item$(2)„    wintext$(6) = "item$(3) = " + item$(3)„    wintext$(7) = "item$(4) = " + item$(4)„    wintext$(8) = Justify$("item$(5) = " + item$(5), 1, winleft%, winright%) 'see justify$ function„    wintext$(9) = Justify$("item$(6) = " + item$(6), 0, winleft%, winright%)„    wintext$(10) = "item$(7) = " + item$(7)„    wintext$(11) = Justify$("item$(8) = " + item$(8), 0, winleft%, winright%)„    wintext$(12) = ""„    wintext$(13) = Justify$("Press any key to continue...", 2, winleft%, winright%)„„CALL WindowSub(wintop%, winbot%, winleft%, winright%, 15, 4, wintext$(), 1)„„REM ***********SECOND WINDOW**********„„wintop% = 10„winbot% = 22„winleft% = 10„winright% = 40„„REDIM wintext$(winbot% - wintop% + 1)„„FOR x% = 2 TO 6„    wintext$(x%) = Justify$("Right Justified", 3, winleft%, winright%)„NEXT x%„„CALL WindowSub(wintop%, winbot%, winleft%, winright%, 15, 3, wintext$(), 0)„„REM **********THIRD WINDOW**********„„wintop% = 6„winbot% = 11„winleft% = 4„winright% = 40„„REDIM wintext$(winbot% - wintop% + 1)„FOR x% = 2 TO 6„    wintext$(x%) = Justify$("Centered Text", 2, winleft%, winright%)„NEXT x%„CALL WindowSub(wintop%, winbot%, winleft%, winright%, 15, 6, wintext$(), 1)„„REM *********FOURTH WINDOW***********„„wintop% = 13„winbot% = 23„winleft% = 10„winright% = 70„„REDIM wintext$(winbot% - wintop% + 1)„wintext$(2) = Justify$("ROSEWOOD QUICKBASIC STUFF is brought to you by:", 2, winleft%, winright%)„wintext$(3) = Justify$("Bert Christensen", 2, winleft%, winright%)„wintext$(4) = Justify$("Rosewood Software", 2, winleft%, winright%)„wintext$(5) = Justify$("135-10 Livonia Place", 2, winleft%, winright%)„wintext$(6) = Justify$("Scarborough, Ontario M1E 4W6  Canada", 2, winleft%, winright%)„wintext$(7) = Justify$("Telephone (416) 284-6119", 2, winleft%, winright%)„wintext$(8) = Justify$("CompuServe 70461,2507  Internet bert.christensen@canrem.com", 2, winleft%, winright%)„wintext$(10) = Justify$("Copyright (c) 1993", 2, winleft%, winright%)„CALL WindowSub(wintop%, winbot%, winleft%, winright%, 15, 5, wintext$(), 1)„COLOR sfg%, sbg%„„END„„SUB Frame (toprow%, bottomrow%, leftcol%, rightcol%)„„        LOCATE toprow%, leftcol%: COLOR ffg%, fbg%: PRINT CHR$(201)  'top left corner„        LOCATE toprow%, rightcol%: COLOR ffg%, fbg%: PRINT CHR$(187) 'top right corner„        LOCATE bottomrow%, leftcol%: COLOR ffg%, fbg%: COLOR ffg%, fbg%: PRINT CHR$(200); 'bottom left corner„        LOCATE bottomrow%, rightcol%: COLOR ffg%, fbg%: PRINT CHR$(188); 'bottom right corner„„        FOR vertline% = toprow% + 1 TO bottomrow% - 1       'vertical lines„                LOCATE vertline%, leftcol%: COLOR ffg%, fbg%: PRINT CHR$(186);„                LOCATE vertline%, rightcol%: COLOR ffg%, fbg%: PRINT CHR$(186);„        NEXT vertline%„„                horizlength% = rightcol% - leftcol% - 1     'horizontal lines„                horizline$ = STRING$(horizlength%, 205)„        LOCATE toprow%, leftcol% + 1: COLOR ffg%, fbg%: PRINT horizline$„        LOCATE bottomrow%, leftcol% + 1: COLOR ffg%, fbg%: PRINT horizline$;„        LOCATE , , 0„END SUB„„SUB Fulledit (row%(), column%(), numentry%, inperr%(), item$(), itemlen%(), itemflag%())„„'there are some Wordstar type commands "scan% = 19 is Ctrl S". I hate Wordstar so I never completed all the commands.„„LOCATE , , 0„insertkey% = 0     'make typeover the default„sc1% = 6           'cursor size for default typeover„sc2% = 7„        FOR menuitem% = 1 TO numentry%                  'make sure that existing entries have proper length„                IF LEN(item$(menuitem%)) < itemlen%(menuitem%) THEN„                        item$(menuitem%) = item$(menuitem%) + STRING$((itemlen%(menuitem%) - LEN(item$(menuitem%))), " ") 'pad with spaces„                ELSEIF LEN(item$(menuitem%)) > itemlen%(menuitem%) THEN„                        item$(menuitem%) = LEFT$(item$(menuitem%), itemlen%(menuitem%))  'truncate if necessary„                END IF„        NEXT menuitem%„        itemnum% = 1    'start a first input entry„        FOR entry% = 1 TO numentry%                         'enter default data and/or spaces in proper places„                colm% = column%(entry%)„                FOR leng% = 1 TO itemlen%(entry%)„                        COLOR rfg%, rbg%„                        LOCATE row%(entry%), colm%„                        defaultstr$ = MID$(item$(entry%), leng%, 1)„                        PRINT defaultstr$;„                        colm% = colm% + 1„                NEXT leng%„        NEXT entry%„        printcolumn% = column%(itemnum%)     'start at leftmost column„ed1:    COLOR rfg%, rbg%: LOCATE row%(itemnum%), printcolumn%, 1, sc1%, sc2%                   'Place the cursor„„ed2:    keypress$ = "": keypress$ = INKEY$: IF keypress$ = "" THEN GOTO ed2     'wait for keypress„        scan% = ASC(keypress$)     'change keypress to integer„ed4:„        IF scan% = 27 THEN                'Esc„                IF inperr%(itemnum%) = 1 THEN  ' to prevent user from escaping from sub„                        BEEP„                ELSE„                        EXIT SUB„                END IF„        END IF„„        IF scan% > 31 AND scan% < 127 THEN           'Alphanum chars only„                DO„                        SELECT CASE itemflag%(itemnum%)       'determine which set of characters are acceptable„                                CASE 0          'any alpha numeric„                                CASE 1          ' 0 to 9 and space„                                        SELECT CASE scan%„                                                CASE 32, 48 TO 57   ' nothing to do. Let if "fall through" the SELECT CASE„                                                CASE ELSE„                                                        BEEP„                                                        GOTO ed2„                                        END SELECT„                                CASE 2         '0 to 9, -,., space„                                        SELECT CASE scan%„                                                CASE 32, 45, 46, 48 TO 57„                                                CASE ELSE„                                                        BEEP„                                                        GOTO ed2„                                        END SELECT„                        END SELECT„„                IF insertkey% = 0 THEN                     'typeover„                        MID$(item$(itemnum%), printcolumn% - column%(itemnum%) + 1, 1) = keypress$„                        PRINT keypress$;„„                ELSE„                        item$(itemnum%) = LEFT$(LEFT$(item$(itemnum%), printcolumn% - column%(itemnum%)) + CHR$(scan%) + MID$(item$(itemnum%), printcolumn% - column%(itemnum%) + 1, column%(itemnum%)), itemlen%(itemnum%))           'insert„                        LOCATE row%(itemnum%), column%(itemnum%), 1, sc1%, sc2%„                        item$(itemnum%) = LEFT$(item$(itemnum%), itemlen%(itemnum%))„                        PRINT item$(itemnum%);„                END IF„                scan% = 77                                   'move right 1 space„                EXIT DO„                LOOP„        END IF„„        IF scan% = 8 AND printcolumn% > column%(itemnum%) THEN          'Back Space„                printcolumn% = printcolumn% - 1„                LOCATE row%(itemnum%), printcolumn%, 1, sc1%, sc2%„                scan% = 83„        END IF„„        IF scan% = 0 THEN scan% = ASC(RIGHT$(keypress$, 1))             'Extended character„„                                ' scan% = 4 is the Wordstar Ctrl D„        IF (scan% = 77 OR scan% = 4) AND printcolumn% < column%(itemnum%) - 1 + itemlen%(itemnum%) THEN     'Right arrow„                printcolumn% = printcolumn% + 1„                GOTO ed1„        END IF„                                 '19 = Ctrl S„        IF (scan% = 75 OR scan% = 19) AND printcolumn% > column%(itemnum%) THEN          'Left arrow„                printcolumn% = printcolumn% - 1„                GOTO ed1„        END IF„„        IF scan% = 79 THEN                                  'end for    End of text„                IF LEN(RTRIM$(item$(itemnum%))) = 0 THEN„                        printcolumn% = column%(itemnum%) + itemlen%(itemnum%) - 1„                ELSE„                        printcolumn% = column%(itemnum%) + LEN(RTRIM$(item$(itemnum%)))„                        IF printcolumn% > column%(itemnum%) + itemlen%(itemnum%) - 1 THEN printcolumn% = column%(itemnum%) + itemlen%(itemnum%) - 1„                END IF„        GOTO ed1„        END IF„„        IF scan% = 99 THEN            'centre text on line„„                lenitm% = LEN(LTRIM$(RTRIM$(item$(itemnum%))))„„                item$(itemnum%) = SPACE$((itemlen%(itemnum%) - lenitm%) \ 2) + LTRIM$(RTRIM$(item$(itemnum%)))„                item$(itemnum%) = item$(itemnum%) + SPACE$(itemlen%(itemnum%) - LEN(item$(itemnum%)))„                        LOCATE row%(itemnum%), column%(itemnum%), 1, sc1%, sc2%„                        PRINT item$(itemnum%);„„                scan% = 80„        END IF„„„        IF scan% = 117 THEN                                   'ctrl +  end to go to end of line„                printcolumn% = column%(itemnum%) + itemlen%(itemnum%) - 1„                GOTO ed1„        END IF„„        IF scan% = 71 THEN                                  ' Home to beginning of text„                IF LEN(RTRIM$(item$(itemnum%))) = 0 THEN„                        printcolumn% = column%(itemnum%)„                ELSE„                        printcolumn% = column%(itemnum%) + ((itemlen%(itemnum%)) - (LEN(LTRIM$(item$(itemnum%)))))„                        IF printcolumn% < column%(itemnum%) THEN printcolumn% = column%(itemnum%)„                END IF„                GOTO ed1„        END IF„„        IF scan% = 119 THEN                             'ctrl + home to start of line„                printcolumn% = column%(itemnum%)„                GOTO ed1„        END IF„„        IF (scan% = 80 OR scan% = 24) OR (scan% = 13 AND itemnum% <> numentry%) THEN  'Down Arrow  or Enter for next field„„                itemnum% = itemnum% + 1„                        IF itemnum% > numentry% THEN itemnum% = numentry%„                                printcolumn% = column%(itemnum%)„                                GOTO ed1„                        END IF„      „„        IF scan% = 81 THEN                             ' pgdn to last line„                itemnum% = numentry%„                printcolumn% = column%(itemnum%)„                GOTO ed1„        END IF„„        IF scan% = 72 OR scan% = 5 THEN                      'Up Arrow„                itemnum% = itemnum% - 1„                IF itemnum% < 1 THEN itemnum% = 1„                printcolumn% = column%(itemnum%)„                GOTO ed1„        END IF„„        IF scan% = 73 THEN                                 'pgup to top line„                itemnum% = 1„                printcolumn% = column%(itemnum%)„                GOTO ed1„        END IF„„        IF scan% = 83 THEN                                  'Delete„                item$(itemnum%) = LEFT$(item$(itemnum%), printcolumn% - column%(itemnum%)) + MID$(item$(itemnum%), printcolumn% - column%(itemnum%) + 2, itemlen%(itemnum%) - printcolumn% + column%(itemnum%) - 1) + " "„                LOCATE row%(itemnum%), column%(itemnum%), 1, sc1%, sc2%„                PRINT item$(itemnum%);„                GOTO ed1„        END IF„„„        IF scan% = 96 THEN                                  ' control f3 to delete line„                item$(itemnum%) = SPACE$(itemlen%(itemnum%))„                printcolumn% = column%(itemnum%)„                LOCATE row%(itemnum%), column%(itemnum%), 1, sc1%, sc2%„                PRINT item$(itemnum%);„                GOTO ed1„        END IF„„        IF scan% = 97 THEN                           'Ctrl F4 to copy„                cutline$ = item$(itemnum%)„                GOTO ed1„        END IF„„        IF scan% = 98 THEN                                   'Ctrl F5 to paste„                item$(itemnum%) = cutline$„                LOCATE row%(itemnum%), column%(itemnum%), 1, sc1%, sc2%„                PRINT LEFT$(item$(itemnum%), itemlen%(itemnum%));„                GOTO ed1„        END IF„„        IF scan% = 82 THEN                                     'insert toggle„                IF insertkey% = 0 THEN„                        insertkey% = 1„                        sc1% = 4       'change to 1/2 block cursor„                        sc2% = 7„                ELSE„                        insertkey% = 0„                        sc1% = 6„                        sc2% = 7„                END IF„                GOTO ed1„         END IF„„         IF scan% = 103 THEN         'ctrl f10 to exit„                scan% = 13„         END IF„      „ed3:„        IF scan% <> 13 THEN GOTO ed1„„        FOR entry% = 1 TO numentry%                   'get rid of any ascii 0's„        tempstring$ = ""„                FOR leng% = 1 TO LEN(item$(entry%))„                        defaultstr$ = MID$(item$(entry%), leng%, 1)„                        IF ASC(defaultstr$) = 0 THEN defaultstr$ = " "„                        tempstring$ = tempstring$ + defaultstr$„                NEXT leng%„        item$(entry%) = RTRIM$(tempstring$)„        NEXT entry%„LOCATE , , 0       'turn off cursor„COLOR sfg%, sbg%„„END SUB„„FUNCTION Justify$ (text$, just%, winleft%, winright%)„REM   function to justify text on a line within a window„REM   text$ is the string to be modified„REM   just% = one of the following„REM   0 = not justiied„REM   1 = left justified„REM   2 = centre justified„REM   3 = right justified„REM   winleft% = the leftmost column of the window„REM   winright% = the rightmost column of the window„„SELECT CASE just%„    CASE 0„        'nothing needs to be done„    CASE 1„        text$ = LTRIM$(text$)    'delete leading spaces„    CASE 2„        centretext$ = LTRIM$(RTRIM$(text$))„        IF LEN(centretext$) MOD 2 <> 0 THEN centretext$ = centretext$ + " "„        lenitm% = LEN(centretext$) 'strip leading & trailing spaces and find length of remaining text„        text$ = SPACE$(((winright% - winleft%) - lenitm%) \ 2) + centretext$  'add proper number of spaces to centre the text„    CASE 3„        lenitm% = LEN(LTRIM$(RTRIM$(text$))) 'find length of text with leading & trailing spaces deleted„        text$ = SPACE$((winright% - winleft%) - (lenitm% + 1)) + LTRIM$(RTRIM$(text$)) 'add proper number of spaces before the text so that text is right justified„END SELECT„„Justify$ = text$  'change justify$ to modified string„„END FUNCTION„„SUB WindowSub (wintop%, winbot%, winleft%, winright%, winforecolour%, winbackcolour%, wintext$(), winborder%)„REM     wintop% & winbot% are the top & bottom rows of the window„REM     winleft% & winright% are the left & right coloumns of the window„REM     fbg% 'window background colour„REM     winforecolour% 'window foreground colour„REM     wintext$() is an array containing the text of each line in the window„REM     winborder% is a flag which signals the program to add a border(frame) around the window„REM         0 = no border, 1 = border„„fbg% = winbackcolour% 'window background colour„ffg% = winforecolour% 'window foreground colour„ „        'set up 2 dimensional array to store characters "under" the window„        DIM charascii%(wintop% TO winbot%, winleft% TO winright%)„„        'same as above but to store color attributes„        DIM charattrib%(wintop% TO winbot%, winleft% TO winright%)„„        FOR winline% = wintop% TO winbot%„            FOR wincolumn% = winleft% TO winright%„                charascii%(winline%, wincolumn%) = SCREEN(winline%, wincolumn%)     'fill character array„                charattrib%(winline%, wincolumn%) = SCREEN(winline%, wincolumn%, 1)  'fill attribute array„            NEXT wincolumn%„        NEXT winline%„        „            textline% = 1„            FOR winline% = wintop% TO winbot%         'put in window filled with„                LOCATE winline%, winleft% + 1         'spaces of background colour„                COLOR winforecolour%, winbackcolour%„                PRINT SPACE$(winright% - winleft%);„                LOCATE winline%, winleft% + 1„                PRINT wintext$(textline%);            'print text in window„                textline% = textline% + 1„            NEXT winline%„„        IF winborder% = 1 THEN CALL Frame(wintop%, winbot%, winleft%, winright%)  'add fram if desired„„        pause$ = INPUT$(1)    'pause ofter window is complete„„        FOR winline% = wintop% TO winbot%               'delete window and replace„           FOR wincolumn% = winleft% TO winright%       'original screen„                LOCATE winline%, wincolumn%„                COLOR charattrib%(winline%, wincolumn%) MOD 16, (charattrib%(winline%, wincolumn%) AND &H70) \ 16  'parse stored colour attributes to foreground and background„                PRINT CHR$(charascii%(winline%, wincolumn%))   'print stored characters„            NEXT wincolumn%„        NEXT winline%„„ERASE wintext$         'get the arrays out of memory„ERASE charascii%„ERASE charattrib%„„END SUB„„Peter Norton                   ASCII TABLE                    DOS World                      11/95 (00:00)          QB, QBasic, PDS        130  3715     ASCII.BAS   'filename:  ascii.bas„'author:    Peter Norton - Felton, CA„'source:    _DOS World_ number 24, Nov.1995, pp 53-54„'for:       QBasic 1.x„„'====================================================+„' Note: Please extract ASCII.BAT from the bottom of  |„' this file and place it in it's own file before     |„' running this program. This program is invoked with |„' ASCII.BAT, so put it in a directory in your PATH   |„' and edit the line that calls ASCII.BAS to reflect  |„' where you put it, so that it will be found.        |„'====================================================+„„DECLARE SUB chart ()„DECLARE SUB special (code!)„DECLARE SUB decode (code!)„„DEF SEG = &HB800            'video segment address for pokes„code$ = ENVIRON$("ASCII")   'variable set in batch file„code = VAL(code$)„    COLOR 14, 1„    IF code$ = "" THEN chart    'print chart and exit„    special code            'print special meaning„    IF code THEN decode code    'decode if number„    IF LEN(code$) = 1 THEN„        code = ASC(code$)„        decode code         'decode if single character„    END IF„    IF code = 0 THEN„        PRINT " Invalid parameter - "; code$;„        SHELL "ASCII /?"    'print usage message„    END IF„SYSTEM„„'--------------8<-----cut here----->8----------------„„SUB chart„    CLS„    A = 3                   'a = cursor position for POKE„    FOR i = 1 TO 9          'i = ASCII code„        PRINT i; SPACE$(4);„        POKE A * 2, i       'position * 2 for attributes„        A = A + 7„    NEXT i„    A = A + 1„    FOR i = 10 TO 99„        PRINT i; SPACE$(3);„        POKE A * 2, i„        A = A + 7„        IF i MOD 11 = 0 THEN A = A + 3  'advance at end of line„    NEXT i„    A = A + 1„    FOR i = 100 TO 255„        PRINT i; SPACE$(2);„        POKE A * 2, i„        A = A + 7„        IF i MOD 11 = 0 THEN A = A + 3„    NEXT i„    COLOR 15„    PRINT "     Press any key to continue...";„    DO„        LOOP WHILE INKEY$ = ""„    PRINT„    SYSTEM„END SUB„„SUB decode (code)„    PRINT " Character "; CHR$(34); " "; CHR$(34);„    POKE (((CSRLIN - 1) * 80) + (POS(0) - 3)) * 2, code„    PRINT " ="; code; "Decimal, ";„    hexvalue$ = HEX$(code)„    IF LEN(hexvalue$) = 1 THEN hexvalue$ = "0" + hexvalue$„    PRINT hexvalue$; " Hexadecimal"„END SUB„„SUB special (code)„    SELECT CASE code„        CASE IS = 7„            PRINT " Beep (Bell)";„        CASE IS = 8„            PRINT " Backspace";„        CASE IS = 9„            PRINT " Tab";„        CASE IS = 10„            PRINT " Line feed";„        CASE IS = 12„            PRINT " Page eject";„        CASE IS = 13„            PRINT " Carriage return";„        CASE IS = 26„            PRINT " End of file";„        CASE IS = 27„            PRINT " Escape";„        CASE IS = 32„            PRINT " Space";„    END SELECT„END SUB„„-----8<-------- ASCII.BAT --------------„@echo off„echo.„echo For advice on using this batch file,„echo type: ASCII /?„echo.„if %1!==/?! goto help„: top„set ascii=%1„„REM ====Edit the following line====„qbasic /run \basic\ascii.bas„REM ======Edit the above line=====„„set ascii=„if %2!==! goto end„shift„GOTO top„: help„echo.„echo Syntax: %0 [codes...] [characters...]„echo You may include any number of characters and codes,„echo separating them with spaces, commas, or semicolons.„echo.„echo You may provide letter or number keys, decimal or hexadecimal„echo numbers, and key combinations such as Ctrl+A. But you must„echo precede hex numbers with &h or &H (for example, &H0A).„echo.„echo If you type ASCII at the DOS prompt, the program prints„echo the entire ASCII chart on screen.„: END„