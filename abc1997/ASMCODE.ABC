Rick Elbers                    ASSEMBLY IN QBASIC 2: DATASEG  t030611@tip.nl                 12-01-96 (05:37)       QB, QBasic, PDS        124  4066     DATASEG.BAS 'ASSEMBLY IN QBASIC PART 2: USING DATASEGMENTS„'----------------------------------------------„'Rick Elbers november 1996„„'This short article is ment as a follow up on STEPHAN van Loendersloot's„'INTERRUPTS IN QBASIC in this directory. He described the very first step„'in calling CALL ABSOLUTE and this article will introduce the logical„'second step. It will very basically describe the way in which you can„'use DATASEGMENTS in your assembler subs.„„'The actual explanation will be done by working throught a very simple„'print string example. It is not ment to be anything fancy, but it is„'designed to be evident.„„DECLARE SUB dosprstr (string2write$)„DECLARE FUNCTION int2str$ (sword%)„DECLARE SUB Pokestring (SEGJE%, OFFJE%, MAIN$)„„dosprstr "What are we going to do ?"„END„„SUB dosprstr (string2write$)„'-------------------------------------------------------------------------„'DATA„a% = LEN(string2write$) + 1: DIM datas%(a% \ 2 + 1)„'-----------------------------„'INTRODUCTION ON DATASEGMENTS:„'------------------------------„'DATAS will be our datasegment. Take good care that we declare it as an„'array since arrays start at segment bounderies. That way we will not be„'surprised by segment changes. This might be trivial but when you use„'a simple variable which is number Xth in the row of variables it just might„'be that your starting adress is at seg:&hfffe. Same holds for stringvariables.„'They do not start at segmentbounderies too. Another feature of strings„'is that they walk around in memory due to garbage collection, making a„'string very unsuited for adressability purposes. So: we use DATAS% and poke„'our variables and strings just inside it!„„'The length of the datasegment in this example is designed to keep only„'the string.„„b$ = string2write$ + "$"         'This is the way DOS processes stringprint„'--------------------------------„'MAKE THE DATASEGMENT ADRESSABLE:„'--------------------------------„'Here is the basic upset of an adressable datasegment:„„dataseg% = VARSEG(datas%(0)): dataoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): dataoff$ = int2str$(dataoff%)„„'Next we poke our string into the datasegment.„Pokestring dataseg%, dataoff%, b$„„'-----------------------------------„'CODE„'push ax„'push dx„'push ds„„'mov ax,dataseg$„'mov ds,ax„'mov dx,dataoff$„'mov ah,09         'printstring with ending $„'int 21„'pop ds„'pop dx„'pop ax„'retf„'-----------------------------------„'pusha„asm$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H52)„asm$ = asm$ + CHR$(&H1E)„„asm$ = asm$ + CHR$(&HB8) + dataseg$      'MOV AX,DATASEG$„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)    'MOV DS,AX„asm$ = asm$ + CHR$(&HBA) + dataoff$      'MOV DX,DATAOFF$„asm$ = asm$ + CHR$(&HB4) + CHR$(&H9)     'MOV AH,9„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)    'INT 21„„'popa„asm$ = asm$ + CHR$(&H1F)„asm$ = asm$ + CHR$(&H5A)„asm$ = asm$ + CHR$(&H58)„'retf„asm$ = asm$ + CHR$(&HCB)„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL ABSOLUTE(Codeoff%)„'________________________________________„DEF SEG„„„END SUB„„FUNCTION int2str$ (sword%)„'This function is translating SWORD Integers into a string. Its only use„'is when you still use asm$ for assembler functions( like i do). In that„'case you can make your integer values usable ..„'THis function simply translates the hexa bytes„'into stringbytes as is.„'----------------------------------------------------„DEF SEG = VARSEG(sword%)„ptr% = VARPTR(sword%)„int2str$ = CHR$(PEEK(ptr%)) + CHR$(PEEK(ptr% + 1))„DEF SEG„„END FUNCTION„„SUB Pokestring (SEGJE%, OFFJE%, MAIN$)„'------------------------------------------------------„'This function pokes a string (might be ASCIIZ)into„'memory at a given location, making it possible to„'access strings in byte form„'------------------------------------------------------„„DEF SEG = SEGJE%„FOR i% = 0 TO LEN(MAIN$) - 1„  POKE OFFJE% + i%, ASC(MID$(MAIN$, i% + 1, 1))„NEXT„DEF SEG„„END SUB„Rick Elbers                    ASSEMBLY IN QBASIC 3: INT86QB  t030611@tip.nl                 12-01-96 (05:37)       QB, QBasic, PDS        175  8442     INT86QB.BAS 'ASSEMBLY IN QBASIC 3: INT86QB„'QBASIC ABOVE AND BEYOND PART...[ASSEMBLY LIBRARIE]„'---------------------------„'Rick Elbers november 1996„'--------------------------„DECLARE FUNCTION int2str$ (sword%)„DECLARE FUNCTION int86qb$ (intnr%, flag%, ax%, bx%, cx%, dx%, di%, si%, bp%, ds%, es%)„„'INTRODUCTION                                     „'-------------„'When i felt the desire to write a routine that make another break in the„'wall of QBASIC opponents who maintain that QBASIC did not have a call„'interrupt, i have choosen for the ASIC approach which distinguishes„'itself from QUICK BASIC(compiler) in that it did not force upon you„'the necessity of defining a REGSTYPE in your main.„'In my humble opinion you should hold things as modulair as possible,meaning„'as much as possible defined in your subs and functions. So therefore, instead„'of INTERRUPT(int%,INREGS as REGStype,OUtregs as REGStype), you will„'be confronted with INT86QB(int%,FLAG%,AX%,BX%,CX%,DX%,DI%,SI%,BP%,DS%,ES%)„'Since it is a function it returns. In fact it returns an array of all the„'registers. For help in parsing this you might take a look at the function„'partstring$ i wrote( available on my homepage in Lstr.zip).„„'First notice should be that int86qb returns also flags (unlike int86 of ASIC)„'----------------------------------------------------------------------------„CLS„a$ = int86qb$(&H21, 0, &H200, 0, 0, &H41, 0, 0, 0, 0, 0)„LOCATE 2, 1: PRINT a$„„'----------------------------------------------------------------------------„'Although the setup of this function might have his advantages, optimal speed„'or minimum length is not one of them. In an optimized CALL INTERRUPT the„'assembly routine could be speeded up *a lot* AND narrowed down to 80 bytes,„'by the way of using STACK instead of DATAS% and XCHG reg, variable instead„'of PUSH reg /MOV reg,value/ MOV variable, reg/POP reg instructions. The only„'advantage of the present int86qb routine might be that it is not as difficult„'as the routine that uses the optimized method, since for the biggest part„'int86qb is merely repetitive.„'----------------------------------------------------------------------------„„FUNCTION int2str$ (sword%)„'This function is translating SWORD Integers into a string. Its only use„'is when you still use asm$ for assembler functions( like i do). In that„'case you can make your integer values usable ..„'THis function simply translates the hexa bytes„'into stringbytes as is.„'----------------------------------------------------„DEF SEG = VARSEG(sword%)„ptr% = VARPTR(sword%)„int2str$ = CHR$(PEEK(ptr%)) + CHR$(PEEK(ptr% + 1))„DEF SEG„„END FUNCTION„„FUNCTION int86qb$ (intnr%, flag%, ax%, bx%, cx%, dx%, di%, si%, bp%, ds%, es%)„'------------------------------------------------------------------------„'Conversion of all integers in strings„flag$ = LEFT$(int2str$(flag%), 1): ax$ = int2str$(ax%):„bx$ = int2str$(bx%): cx$ = int2str$(cx%): dx$ = int2str$(dx%):„di$ = int2str$(di%): si$ = int2str$(si%): bp$ = int2str$(bp%):„ds$ = int2str$(ds%): es$ = int2str$(es%):„'Now all integersvalues are direct usable in asm$„'------------------------------------------------------------------------„DIM datas%(11)    'that is all we need„dataseg% = VARSEG(datas%(0)): flagoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): flagoff$ = int2str$(flagoff%)„axoff$ = int2str$(flagoff% + 2): bxoff$ = int2str$(flagoff% + 4)„cxoff$ = int2str$(flagoff% + 6): dxoff$ = int2str$(flagoff% + 8)„dioff$ = int2str$(flagoff% + 10): sioff$ = int2str$(flagoff% + 12)„bpoff$ = int2str$(flagoff% + 14): dsoff$ = int2str$(flagoff% + 16)„esoff$ = int2str$(flagoff% + 18): intnroff$ = int2str$(flagoff% + 20)„'Now all integers are directly adressable in memory through asm$„'We could have used only this as pointers and leave the immediate values„'but....we don't.„'------------------------------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H9C)                       'pushf             „asm$ = asm$ + CHR$(&H50)                       'push ax         „asm$ = asm$ + CHR$(&H53)                       'push bx         „asm$ = asm$ + CHR$(&H51)                       'push cx        „asm$ = asm$ + CHR$(&H52)                       'push dx         „asm$ = asm$ + CHR$(&H57)                       'push di         „asm$ = asm$ + CHR$(&H56)                       'push si         „asm$ = asm$ + CHR$(&H55)                       'push bp         „asm$ = asm$ + CHR$(&H1E)                       'push ds         „asm$ = asm$ + CHR$(&H6)                        'push es         „„'2)LOAD REGISTERS„'First the flags( questionable if this ever happens):„asm$ = asm$ + CHR$(&HB4) + flag$              'mov ax,flag$„asm$ = asm$ + CHR$(&H9E)                      'sahf stores ah into flags„„'Segment registers mbv ax :  only when not (accidentally) 0„IF ds% <> 0 THEN                              'safety„  asm$ = asm$ + CHR$(&HB8) + ds$              'mov ax,ds$„  asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)       'mov ds,ax„END IF„IF es% <> 0 THEN                              'safety„  asm$ = asm$ + CHR$(&HB8) + es$              'mov ax,es$„  asm$ = asm$ + CHR$(&H8E) + CHR$(&HC0)       'mov es,ax„END IF„'the rest of registers :„asm$ = asm$ + CHR$(&HB8) + ax$                'mov ax,ax$„asm$ = asm$ + CHR$(&HBB) + bx$                'mov bx,bx$ „asm$ = asm$ + CHR$(&HB9) + cx$                'mov cx,cx$ „asm$ = asm$ + CHR$(&HBA) + dx$                'mov dx,dx$ „asm$ = asm$ + CHR$(&HBF) + di$                'mov di,di$ „asm$ = asm$ + CHR$(&HBE) + si$                'mov si,si$ „asm$ = asm$ + CHR$(&HBD) + bp$                'mov bp,bp$„'oke now the interrupt himself„asm$ = asm$ + CHR$(&HCD) + CHR$(intnr%)       'interrupt nr„„'First make our DATAS% adressable:„asm$ = asm$ + CHR$(&H1E)                         'push ds„asm$ = asm$ + CHR$(&HB8) + dataseg$              'mov ax,DATASseg$„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)            'mov ds,ax„                                           „'We first pushed DS segment register since we want to adress our DATA_segment„asm$ = asm$ + CHR$(&H8F) + CHR$(&H6) + dsoff$    'pop dsoff$„asm$ = asm$ + CHR$(&H8C) + CHR$(&H6) + esoff$    'mov esoff$,ES„„asm$ = asm$ + CHR$(&H9F)                         'lahf„asm$ = asm$ + CHR$(&H88) + CHR$(&H26) + flagoff$ 'mov flagoff$,ah„                     „'The rest is more simple i think:„asm$ = asm$ + CHR$(&H89) + CHR$(&H2E) + bpoff$   'mov bpoff$,bp„asm$ = asm$ + CHR$(&H89) + CHR$(&H36) + sioff$   'mov sioff$,si„asm$ = asm$ + CHR$(&H89) + CHR$(&H3E) + dioff$   'mov dioff$,di„asm$ = asm$ + CHR$(&H89) + CHR$(&H16) + dxoff$   'mov dxoff$,dx„asm$ = asm$ + CHR$(&H89) + CHR$(&HE) + cxoff$    'mov cxoff$,cx„asm$ = asm$ + CHR$(&H89) + CHR$(&H1E) + bxoff$   'mov bxoff$,bx„asm$ = asm$ + CHR$(&HA3) + axoff$                'mov axoff$,ax„                                „'Now let us neatly finish by just popping everything back in order„asm$ = asm$ + CHR$(&H7)                          'pop es„asm$ = asm$ + CHR$(&H1F)                         'pop ds         „asm$ = asm$ + CHR$(&H5D)                         'pop bp         „asm$ = asm$ + CHR$(&H5E)                         'pop si         „asm$ = asm$ + CHR$(&H5F)                         'pop di         „asm$ = asm$ + CHR$(&H5A)                         'pop dx         „asm$ = asm$ + CHR$(&H59)                         'pop cx         „asm$ = asm$ + CHR$(&H5B)                         'pop bx         „asm$ = asm$ + CHR$(&H58)                         'pop ax        „asm$ = asm$ + CHR$(&H9D)                         'popf            „'We are done?„asm$ = asm$ + CHR$(&HCB)                         'retf „„DEF SEG = VARSEG(asm$)„offcode% = SADD(asm$): CALL absolute(offcode%): DEF SEG„„ui$ = HEX$(intnr%)„FOR i% = 0 TO 9„  hx$ = HEX$(datas%(i%))„  hx$ = STRING$(4 - LEN(hx$), "0") + hx$„  ui$ = ui$ + "," + hx$„NEXT„„int86qb$ = ui$„„END FUNCTION„„SUB Pokestring (SEGJE%, OFFJE%, MAIN$)„'------------------------------------------------------„'This function pokes a string (might be ASCIIZ)into„'memory at a given location, making it possible to„'access strings in byte form„'------------------------------------------------------„„DEF SEG = SEGJE%„FOR i% = 0 TO LEN(MAIN$) - 1„  POKE OFFJE% + i%, ASC(MID$(MAIN$, i% + 1, 1))„NEXT„DEF SEG„„END SUB„Rick Elbers                    ASSEMBLY IN QBASIC 4: INTERRUPTt030611@tip.nl                 12-01-96 (05:37)       QB, QBasic, PDS        424  18258    DHANDLER.TXT'ASSEMBLY IN QBASIC 4: INTERRUPT HANDLERS„'QBASIC ABOVE AND BEYOND PART....[DISCUSSION INTERRUPTHANDLERS]„'--------------------------------------------------------------------------„'Rick Elbers november 1996„'-------------------------„DECLARE FUNCTION newvec& (segnewint%, offnewint%)„DECLARE FUNCTION oldvec& (nr%)„DECLARE SUB getvec (Svec%, Ovec%, nr%)„DECLARE SUB pokeW (pokeseg%, pokeoff%, word%)„DECLARE SUB pokeDW (pokeseg%, pokeoff%, dword&)„                                                „'INTRODUCTION„'-------------„'When we are concerned with interrupthandlers, then our first goal has to be„'to establish the current way interrupts are handled. When some interrupt is„'processed the processor retrieves the place to jump to (among other things).„'This place he retrieves from 0:INTNR*4. That is to say, in the lower memory„'all interrupts are mapped with a far pointer to the code for that interrupt.„'Of course, since we spoke about FAR pointers every interrupt pointer is„'a double word. That is were the INTNR*4 is coming from. The interrupt pointers„'are commonly referred to as VECTORS.„„'GETTING THE INTERRUPT VECTORS„'-----------------------------„'From inside our QBASIC ide we can get all vectors, but we have to keep„'in mind that we only retrieve vectors as QBASIC looks at them. That is to„'say that some interrupts are handled by qbasic itself, instead of by DOS.„'For instance the values for INT 0 and INT 4 are not the same that you„'get from dumping the lower memory in debug...(you are encouraged to do so..)„'But otherwise the program to execute now is very instructive...„„CLS„FOR nr% = 0 TO &HFF„getvec Vecseg%, Vecoff%, nr%„PRINT " Int "; STRING$(2 - LEN(HEX$(nr%)), "0"); HEX$(nr%); "->";„IF Vecseg% = 0 AND Vecoff% = 0 THEN„  PRINT "Not used ";„ELSE„  PRINT STRING$(4 - LEN(HEX$(Vecseg%)), "0"); HEX$(Vecseg%); ":";„  PRINT STRING$(4 - LEN(HEX$(Vecoff%)), "0"); HEX$(Vecoff%);„END IF„IF nr% MOD 4 = 3 THEN PRINT„IF nr% MOD 80 = 79 THEN SLEEP„NEXT„CLS : PRINT "press a key for next demo part"„SLEEP„„'We have seen that a lot of INTERRUPT VECTORS are free, so we can„'experiment with them. Even when after controlling the so called "FREE„'VECTORS" with debug they appear indeed free. So it is sure and safe„'to experiment with INT 83h for instance. So be it: we will start with„'developing a testcode for our newinterrupt, so that there will be no„'misunderstandings wether we execute int 83h or not. Afterwards we will„'do what is necessary to make it possible to execute int 83h. Our„'handler will do nothing fancy. He will simply print the character 'a' .„'-------„'NEWINT„'-------„DIM newint%(6)„newint%(0) = &H5052              'PUSH AX,DX„newint%(1) = &H41B2              'MOV  DL,41„newint%(2) = &H2B4               'MOV  AH,02„newint%(3) = &H21CD              'INT  21„newint%(4) = &H5A58              'POP DX,AX„newint%(5) = &HCB                'RETF„„segnewint% = VARSEG(newint%(0)): offnewint% = VARPTR(newint%(0))„'Agreed ? Well let us control him:„DEF SEG = segnewint%: CALL absolute(offnewint%)„SLEEP„'Seems to be oke, not ?„'--------------------------„'SETTING INTERRUPT VECTORS„'--------------------------„'Since we have a working handler by now, we might process with the part of„'resetting the interrupt 83h vector( currently 0:0 ) to the adress of our„'handler( currently segnewint%:offnewint%). As it turns out QBASIC„'enables our capacity to set a vector with the DOScall INT 21, 25h. At least„'on my PC this call bumps( when somebody show me otherwise i'll be delighted).„'But for know let us take the more direct route, which is: changing the adress„'stored at 0:83h*4„„setvec:„DEF SEG = 0„POKE (&H83 * 4), offnewint% AND &HFF„POKE (&H83 * 4 + 1), offnewint% \ &HFF„POKE (&H83 * 4 + 2), segnewint% AND &HFF„POKE (&H83 * 4 + 3), segnewint% \ &HFF„SLEEP„„'OKE What we did here was storing the adress of our handler„'in the interrupt vector table in the form:„'                       DW  SEG:OFF„„'Interesting enough in assembler you won't risk such a move since there„'could and in fact will be an interrupt during the writing to the vector„'adress and the vector will be stored inadekwately. One other thing:„'The interrupts are all far return adresses, which is just difficult„'language for that they are words in the form segment:offset. THIS IS„'NOT THE STANDARD WAY OF STORING A WORD! but INTEL designed it so...„'About the formulas used: ANDING AN INTEGER WITH &HFF will give you the„'High Byte since 0000 0000 1111 1111 AND .... .... .... .... will result„'in zeroing the higher byte(agreed ?). The other way around works the„'division which returns the higher byte in the lower byte.„„'[in fact it is not ! for signed integers, luckely i know the segment of„'QBASIC is not a signed value so everything will role smoothly....For code„'that is always okay for signed integers look at the POKEW and POKEDW routines]„„'controle„FOR i% = 0 TO 3„  PRINT HEX$(PEEK(&H20C + i%));„NEXT„DEF SEG„SLEEP„„'So far we seems to be oke: allright ? Well lets review a bit. It is„'called SETVEC wat we have done. It should be easy for you to make this„'into a callable sub. In general you have to poke to INTNR*4+something.„'May be it is just ok to do this first right now before going further...„„'Okay so far,so good. Now the miracle itself. Will it work ? It is easy to„'be so eager to try that you overlook one major change you have to make„'to our handler. It ended so far with RETF, but an interrupt restores the„'flags also so we have to return with an Interrupt-return(IRET):„newint%(5) = &HCF       'IRET replaces RETF„„'Okay now we are ready for the miracle. Have we developed an INTERRUPT ?„'Let's just call INT 83h and look what happens. PFFF........„DIM test%(2)„test%(0) = &H83CD      'INT 83„test%(1) = &HCB        'RETF„„CLS : DEF SEG = VARSEG(test%(0))„CALL absolute(VARPTR(test%(0)))„DEF SEG„„'I do not know what your machine is saying but mine is printing 'a' !„'Is that all ? Yes, that is all. We have passed our first exam!„„„'INTERRUPT HANDLERS:part one„'----------------------------„'When we want to intercept an important interrupt like DOS INT 21 then„'it is obvious that we first must have the ability to store the vector„'so that we can put the original vector back after we are done. Since our„'int 83 can serve further as example interrupt let us call getvec for„'int 83 and then store the vector.„„„getvec segvec%, offvec%, &H83„Savevec:„oldint83& = segvec% * 65536 + offvec%„„'We are going to store the vector in one WORDvalue since 1)It reduces our„'variables with one. Therefore adding to clarity. 2) In essence the vector„'is just one variable. And while we store him this way we can with just one„'instruction like JMP OLDint83 return to our former handler.„'For control again:„PRINT HEX$(oldint83&)„„'Agreed ? No ? Well you are right. This long integer is not really a DW„'since INTEL choosed to put the vectors in the form off(flipped):seg(flipped)„'and not in the expected seg(flipped):off(flipped) way. This might be„'a little confusing at first. But look at it this way: Because we store it„'this way oldint83& is stored in the form off:seg.When later getvec looks at„'the vectors in the table it reads excactly the offset at INTnr*4 and the„'segment at INTnr*4+2. So indeed excactly our OLDINT83&!„„„'A SHORT_LONGCUT :„'--------------------„'Well,okay say we want to interrupt int 21h because we do not like the way„'function 0ah handles function-KEYS like <F1>( it do'nt). We are capable of„'getting the vector already. Also we can store the vector in an adekwate way„'and set the vector to our code. At a certain point we want to restore the„'vector table again(Agreed ?), because we do not want to write code for all„'INt 21h functions. At least not for free.....<G>. So we have to practice one„'other thing. That is :resetting a vector from the one we stored.„„'Now let us return to our practice. We are writing int 83h. Let us now try to„'reset the vector first to 0000:0000 what it was before we were so arrogant to„'take over. This should be simple. Use setvec with SEGnewint%=0 AND OFFnewint%=0„SLEEP„DEF SEG = 0: POKE (&H83 * 4), 0: POKE (&H83 * 4 + 1), 0„POKE (&H83 * 4 + 2), 0: POKE (&H83 * 4 + 3), 0:„„'CONTROL:„getvec segvec%, offvec%, &H83„PRINT HEX$(segvec%), HEX$(offvec%)„DEF SEG„'agreed again ?„SLEEP„„'What was again the question: Oh,yes after Hooking DOS we will reset the„'vector. Since we not put an int handler which interrupted our int 83H at„'0000:0000, which we should by the way never even try, and since the concept„'of interrupting ourselves never managed to come clear to me, we just have„'to imagine we just stored our vector 0:0 at int 83h adres. So what is„'left is that we want to restore the vector after done..Since we have„'oldint83& this should be simple not ? But poke just only writes bytes!„'this means you should write your own pokeDW. Not so..?„„'DEF SEG = 0: POKEDW &H83 * 4, oldint83&: DEF SEG„'and thats it.„„'Control is now important.By the way does everybody knows that doshelp.com„'and edit.com are QBASIC programs started up with QBASIC/edcom and„'QBASIC/qhelp respectively ( so much for not compiler QBASIC ?)„„getvec segvec%, offvec%, &H83„PRINT HEX$(segvec%); HEX$(offvec%): DEF SEG = 0„FOR i% = 0 TO 3: PRINT HEX$(PEEK((&H83 * 4) + i%)): NEXT„„'Okay while this whole document might seem a little bit childish in nature„'you must agree that we are advancing...At this moment we know we can„'restore vectors after using them. A very important feature...„'Also you could have stored the two procedures SETVEC and GETVEC by now i„'guess, making your code even more evident. vecRestore is just a specific„'Setvec and Savevec& is a)evident and b) needs POKE_DW„„'To advance we have to know some basics of an Interrupthandler„'--------------------------------------------------------------„'What an interrupt does is a whole lot, so be aware: An interrupt„'does push first the flags, then pushes cs:ip(return adress),then calculates„'vector adress as we do INTnr*4 loads up ip: then cs of the INTvec. After„'done there is an IRET executed: meaning that first cs then ip then the„'flags are restored from the stack( minus the interrupt and trap flag, which„'are cleared on return).„'In CODE: 'PUSHF„          'PUSH CS„          'PUSH IP„          'vectoradressing: leave the MUL etc for know„          'JMP VECTORADRESS„          '...................„          'DOES WHATEVER HERE IS DONE„          '...................„          'POP IP„          'POP CS„          'POPF„'Although not entiraly true this is sufficient knowledge for know. From„'above it could be concluded that when writing an interrupthandler we have„'to do one extra thing when we define our handler as a far procedure( meaning„'that apart from IP also CS is pushed). We have to do manually PUSHF„'before jumping to the OLDINT and PopF them again as the OLDINT returns„'since the IRET at the end has POPF 'ed . After that we simulated the„'INT call.!„„'Okay before actually going into writing a real interrupt-handler we just„'have to do lots more in the sector of making procedures,using labels„'in our asm-subs. I can tell one thing on before hand : the string way„'of going does not seem to survive procedures,using Data_array,labels etc.„'At least i am returning to a better way of the old code%().It is not„'necessary to use datastatements, and clearity could even be incremented„'using also ASM comments( necessary for bigger asmsubs) in a header like„'in normal assemblerprograms with some modifications. Furthermore, arrays„'does not wander around in mem, so they are adressable as procedures,datas„'etc. At last, since you can use datas directly in your assemblersubs,the„'external use of stack is dropping down to zero. This diminished a lot of„'code_space. Making the code more visible. Okay, i will return on the subject of Hooking Interrupt„'later......„„'Let's round the whole thing off with rewriting our RestoreVEC. We should„'be possible to directly write the VEC back using OLDINT83& ,not?„'Okay let us try.„getvec segvec%, offvec%, &H83: PRINT HEX$(segvec%), HEX$(offvec%)„'reset the vec to 0?„pokeDW 0, &H83 * 4, 0„getvec segvec%, offvec%, &H83: PRINT HEX$(segvec%), HEX$(offvec%)„'we seems to have it done.„'Now restore our vector ?„pokeDW 0, &H83 * 4, oldint83&„getvec segvec%, offvec%, &H83: PRINT HEX$(segvec%), HEX$(offvec%)„„'Maybe you agree that we accurataly restored a vector. Since probably„'the only purpose for getting a vector is to restore him at some time„'we might even change Getvec so that it reads one long integer in the„'format segvec:offvec in our variable OlDINT&„PRINT HEX$(oldvec&(&H83))'seems to be ok?„„'Ok now to summarize we can do the whole thing with enlightening speed„'and shortness:„CLS„pokeDW 0, &H83 * 4, 0           'restore situation to start„oldint83& = oldvec&(&H83)       'get the original int83„pokeDW 0, &H83 * 4, segnewint% * 65536 + offnewint%„                                'set our int83 vector„DEF SEG = VARSEG(test%(0))„CALL absolute(VARPTR(test%(0))) 'execute our handler„DEF SEG„pokeDW 0, &H83 * 4, oldint83&   'restore the original vector„„„'Seems to be oke, not ?  Apart from doing the whole thing in an assembler„'procedure i can see only one thing to improve codeshortness being to„'write a function newvec&(segnewint%,offnewint%) which is trivial„'but in the long run it rules out the flip INTEL confusion. Note that we„'prepared us already on using assembler for the whole thing by consequently„'loading up registers first,before writing to a BASIC variable( which is,„'can be argued, bad code viewed solely from here and now QBASICcode)„„'part 2 to be released on my homepage.some time later will handle the„'actual INT 21 handler.„„„SUB getvec (d%, v%, nr%)„„d% = 1: v% = 2'variabele initialisatie„dataseg% = VARSEG(d%): offset% = VARPTR(d%)„datasg$ = CHR$(dataseg% AND &HFF) + CHR$(dataseg% \ 256)„offset1$ = CHR$(offset% AND &HFF) + CHR$(offset% \ 256)„offset2$ = CHR$((VARPTR(v%) AND &HFF)) + CHR$((VARPTR(v%) \ 256))„„'CODE IN QBASIC„'**************************************„„„ASM$ = ""„ASM$ = ASM$ + CHR$(&HB4) + CHR$(&H35)              'MOV  AH,35        „ASM$ = ASM$ + CHR$(&HB0) + CHR$(nr%)               'MOV  AL,INTnr    „ASM$ = ASM$ + CHR$(&HCD) + CHR$(&H21)              'INT  21           „ASM$ = ASM$ + CHR$(&HB8) + dataseg$                'MOV  AX,dataseg$     „ASM$ = ASM$ + CHR$(&H8E) + CHR$(&HD8)              'MOV  DS,AX        „ASM$ = ASM$ + CHR$(&H8C) + CHR$(&H6) + offset1$    'MOV  ptr[seg],ES„ASM$ = ASM$ + CHR$(&H89) + CHR$(&H1E) + offset2$'  'mov ptr[off],BX „ASM$ = ASM$ + CHR$(&HCB)                           'RETF            „„„'____________________________„ Codeoff% = SADD(ASM$)„ DEF SEG = VARSEG(ASM$)„ CALL absolute(Codeoff%)„'____________________________„DEF SEG„„END SUB„„FUNCTION newvec& (segnewint%, offnewint%)„newvec& = segnewint% * 65536 + offnewint%„END FUNCTION„„FUNCTION oldvec& (nr%)„'-------------------------------------------------------------------'„'This function is a replacement of GETVEC. It stores the old vector„'in INTEL format in an long integer. INTEL format means in the format„'segment:offset here.„'The procedure first stores the vector in ES[BX], before we access it„'IN:  INTnr%„'OUT: oldvec&„'-------------------------------------------------------------------'„s% = 1: o% = 2'variabele initialisatie„dataseg% = VARSEG(s%): offset% = VARPTR(s%)„datasg$ = CHR$(dataseg% AND &HFF) + CHR$(dataseg% \ 256)„offset1$ = CHR$(VARPTR(s%) AND &HFF) + CHR$(VARPTR(s%) \ 256)„offset2$ = CHR$(VARPTR(o%) AND &HFF) + CHR$(VARPTR(o%) \ 256)„„„'CODE IN QBASIC„'**************************************„„„ASM$ = ""„ASM$ = ASM$ + CHR$(&HB4) + CHR$(&H35)              'MOV  AH,35      „ASM$ = ASM$ + CHR$(&HB0) + CHR$(nr%)               'MOV  AL,INTnr  „ASM$ = ASM$ + CHR$(&HCD) + CHR$(&H21)              'INT  21         „ASM$ = ASM$ + CHR$(&HB8) + dataseg$                'MOV  AX,dataseg$   „ASM$ = ASM$ + CHR$(&H8E) + CHR$(&HD8)              'MOV  DS,AX      „ASM$ = ASM$ + CHR$(&H8C) + CHR$(&H6) + offset1$    'MOV  ptr[seg],ES„ASM$ = ASM$ + CHR$(&H89) + CHR$(&H1E) + offset2$'  'mov ptr[off],BX„ASM$ = ASM$ + CHR$(&HCB)                           'RETF          „„„'____________________________„ Codeoff% = SADD(ASM$)„ DEF SEG = VARSEG(ASM$)„ CALL absolute(Codeoff%)„'____________________________„DEF SEG„oldvec& = s% * 65536 + o%„END FUNCTION„„SUB pokeDW (pokeseg%, pokeoff%, dword&)„'This function will just poke a Dword into memory, just like„'the standard function Poke does it, with one enhancement.„'While poke needs a def seg before it we will transfer that to„'the function also! So :„'DW segment to poke word to„'DW offset to poke word to„'DD Dwordvalue to poke„'---------------------------------------------------------------„DEF SEG = VARSEG(dword&)„ptr% = VARPTR(dword&)„LowWlowbyte% = PEEK(ptr%): LowWhighbyte% = PEEK(ptr% + 1)„HighWlowbyte% = PEEK(ptr% + 2): HighWhighbyte% = PEEK(ptr% + 3)„„DEF SEG = pokeseg%„  POKE pokeoff%, LowWlowbyte%„  POKE pokeoff% + 1, LowWhighbyte%„  POKE pokeoff% + 2, HighWlowbyte%„  POKE pokeoff% + 3, HighWhighbyte%„DEF SEG„END SUB„„SUB pokeW (pokeseg%, pokeoff%, word%)„'This function will just poke a word into memory, just like„'the standard function Poke does it, with one enhancement.„'While poke needs a def seg before it we will transfer that to„'the function also! So :„' DW segment to poke word to„' DW offset to poke word to„' DW wordvalue to poke„'Of course you should use this only for reasons of putting all your„'variables in one DATAsegment, since otherwise just defining a integer„'is enough.„'---------------------------------------------------------------„DEF SEG = VARSEG(word%)„ptr% = VARPTR(word%)„highbyte% = PEEK(ptr% + 1): lowbyte% = PEEK(ptr%)„DEF SEG = pokeseg%„  POKE pokeoff%, lowbyte%„  POKE pokeoff% + 1, highbyte%„DEF SEG„„END SUB„Rick Elbers                    ASSEMBLY IN QBASIC 5: PROCS    t030611@tip.nl                 12-01-96 (05:37)       QB, QBasic, PDS        279  10103    PROCS.BAS   'ASSEMBLY IN QBASIC PART 5: USING A PROCEDURE SEGMENT„'-------------------------------------------------------„'Rick Elbers november 1996                                                                                         „„DECLARE SUB pokestring (SEGJE%, OFFJE%, MAIN$)„DECLARE SUB PokeW (pokeseg%, pokeoff%, word%)„DECLARE FUNCTION int2str$ (sword%)„'------------„'INTRODUCTION„'------------„'There are more ways to handle procedures in your assembler subs. This short„'article will discuss one of them. This one is especially done because we„'need him in order to make an interrupthandler, which will be my next„'contribution. When we are discussing procedures we can separate the„'called program( that one is named newint% here) and the caller(that one is„'simply named callsub%).„'-----------------„'CALLED PROCEDURE:„'-----------------„DIM newint%(6)„newint%(0) = &H5052              'PUSH AX,DX„newint%(1) = &H41B2              'MOV  DL,41„newint%(2) = &H2B4               'MOV  AH,02„newint%(3) = &H21CD              'INT  21„newint%(4) = &H5A58              'POP DX,AX„newint%(5) = &HCB                'RETF (returns to the caller)„„'CONTROL IF IT WORKS:„segm% = VARSEG(newint%(0)): offs% = VARPTR(newint%(0))„CLS : DEF SEG = segm%: CALL ABSOLUTE(offs%)„DEF SEG : SLEEP„'For me it worked...„'----------------„'CALLER PROCEDURE„'-----------------„DIM callsub%(3): cdeseg% = VARSEG(callsub%(0)): i% = VARPTR(callsub%(0))„DEF SEG = cdeseg%„„POKE i%, &H9A                  'the opcode for CALL„PokeW cdeseg%, i% + 1, offs%„PokeW cdeseg%, i% + 3, segm%„DEF SEG = cdeseg%             'has to be restored since POKEW returned to def seg„POKE i% + 5, &HCB              'retf (return to QBASIC)„„'This program does nothing but calling the newint% and then„'returning to QBASIC. Let us controle it:„LOCATE 2, 1: CALL ABSOLUTE(i%): DEF SEG„'It does seems to work allright.....„SLEEP„„'-------„'NEWINT$„'-------„'Some off you might have noticed i used integers for storage of the assembler subs„'here. That is for a few good reasons and in some follow up article on this„'i will resolve all mentioned problems with using integers for assembler code„'storage..But for this moment i will add, so to speak for backward„'compatibility, a way to handle procedures when you use strings for assembler„'subs storage.„'----------------„'CALLED PROCEDURE„'----------------„newint$ = ""„newint$ = newint$ + CHR$(&H52) + CHR$(&H50)  'PUSH AX,DX„newint$ = newint$ + CHR$(&HB2) + CHR$(&H41)  'MOV  DL,41„newint$ = newint$ + CHR$(&HB4) + CHR$(&H2)   'MOV  AH,02„newint$ = newint$ + CHR$(&HCD) + CHR$(&H21)  'INT  21„newint$ = newint$ + CHR$(&H58) + CHR$(&H5A)  'POP DX,AX„newint$ = newint$ + CHR$(&HCB)               'RETF (returns to the caller)„„'CONTROL IF IT WORKS:„segm% = VARSEG(newint$): offs% = SADD(newint$)„DEF SEG = segm%: LOCATE 3, 1: CALL ABSOLUTE(offs%): DEF SEG : SLEEP„'seems oke„'-----------------„'CALLING PROCEDURE„'-----------------„'Okay now for the big surprise. We are going to use a PROC segment likewise„'we used a DATAS segment in some other article. In that PROC segment we will„'poke every string_stored_assembler_routine that we want to call.„'After that is done we can call the routines from the calling program the same„'way we readed out data in other instances. Let us see how it works:„„'First let us set up the PROCS segment:„DIM PROCS%(LEN(newint$) \ 2 + 1)„procseg% = VARSEG(PROCS%(0)): procoff% = VARPTR(PROCS%(0))„procseg$ = int2str$(procseg%)„„'Now let us poke newint$ into it and make newint$ adressable„pokestring procseg%, procoff%, newint$: newintoff$ = int2str$(procoff%)„„'-----------------------------------„'CODE„'-----„'call procseg$[newintoff$]„'retf„'-----------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H9A) + newintoff$ + procseg$„'retf„asm$ = asm$ + CHR$(&HCB)„„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$): LOCATE 4, 1:„CALL ABSOLUTE(Codeoff%): DEF SEG : SLEEP„'________________________________________„„'This was our first procedure....!!!„„'--------------„'FINISHING....„'--------------„'I hope you will be realizing the tremendous opportunities of this approach„'since you just can poke ANY routine inside the PROC segment and call him„'in your main program. For the sake of demonstration i will just add one„'more program to it. Actually it is the printstring that i used in the„'second part of ASSEMBLY IN QBASIC. Of course the actual procedures i used„'as calling procedures are very simple and does not seem to add any„'functionality whatsoever. However that is why they serve a great purpose in„'outlining the CONCEPT of a PROCEDURE segment. Actual possibilities should„'be very simple to fantasize and in fact to make when you have understood„'it all....„'--------------------------------------------------------------------------„'DATA:„'------„b$ = "Hello i have been printed indirectly$"  'This is the way DOS processes stringprint„DIM datas%(LEN(b$) \ 2 + 1)„dataseg% = VARSEG(datas%(0)): dataoff% = VARPTR(datas%(0))„dataseg$ = int2str$(dataseg%): dataoff$ = int2str$(dataoff%)„pokestring dataseg%, dataoff%, b$„'CODE:„'-----„prnstr$ = ""„prnstr$ = prnstr$ + CHR$(&H50)                 'pusha„prnstr$ = prnstr$ + CHR$(&H52)„prnstr$ = prnstr$ + CHR$(&H1E)„prnstr$ = prnstr$ + CHR$(&HB8) + dataseg$      'MOV AX,DATASEG$„prnstr$ = prnstr$ + CHR$(&H8E) + CHR$(&HD8)    'MOV DS,AX„prnstr$ = prnstr$ + CHR$(&HBA) + dataoff$      'MOV DX,DATAOFF$„prnstr$ = prnstr$ + CHR$(&HB4) + CHR$(&H9)     'MOV AH,9„prnstr$ = prnstr$ + CHR$(&HCD) + CHR$(&H21)    'INT 21„prnstr$ = prnstr$ + CHR$(&H1F)                 'popa„prnstr$ = prnstr$ + CHR$(&H5A)„prnstr$ = prnstr$ + CHR$(&H58)„prnstr$ = prnstr$ + CHR$(&HCB)                 'retf„„„'PROC„'-----„'We have to adjust our PROC segment to hold both routines now:„REDIM PROCS%(LEN(newint$) \ 2 + 1 + LEN(prnstr$) + 1)„procseg% = VARSEG(PROCS%(0)): procoff% = VARPTR(PROCS%(0))„procseg$ = int2str$(procseg%):„„'Let us poke both routines in the PROC segment now and make the routines„'adressable:„„pokestring procseg%, procoff%, newint$: newintoff$ = int2str$(procoff%)„prnoff% = procoff% + LEN(newint$)„pokestring procseg%, prnoff%, prnstr$: prnstroff$ = int2str$(prnoff%)„„'Okay we have a PROC segment now with:„'PROC:0               newint$„'PROC:LEN(newint$)    prnstr$„„'When we want to call both routines we have to adjust the callers CODE:„'----------------------------------------------------------------------„'CODE„'-----„'call procseg$[newintoff$]„'call procseg$[prnstroff$]„'retf„'-----------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H9A) + newintoff$ + procseg$„asm$ = asm$ + CHR$(&H9A) + prnstroff$ + procseg$„'retf„asm$ = asm$ + CHR$(&HCB)„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$): LOCATE 5, 1„CALL ABSOLUTE(Codeoff%): DEF SEG„'________________________________________„„'There does not seem to be a limit to the possible chaining that you can„'do. You can call procedures from procedures from procedures enz...„'But you might consider to store the heavy used procedures in one PROC„'segment of course.....I hope that this article helps a bit in assembly-„'programming in QBASIC (still the most used BASIC). I hope i pointed out„'in this article(s) that assembly programming in QBASIC is not necessaraly„'very difficult, when you pay attention to the main principles.„'So do not go for quick solutions at an easy level, but instead try to„'make clear choices at levels that still allow you to. I am sure that will„'later on help you * a lot! Seeing the difficulties in simple things often„'makes difficult things simple ......„„„'Bye.„„'Rick„END„„SUB hlpje„'-----------------------------------„'push ax„'push ds„'mov ax,0000„'mov ds,ax„'call 1234:0000„'retf„'-----------------------------------„„prnstr$ = asm$ + CHR$(&H50)„asm$ = asm$ + CHR$(&H1E)„asm$ = asm$ + CHR$(&HB8) + CHR$(&H0) + CHR$(&H0)„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)„asm$ = asm$ + CHR$(&H9A) + CHR$(&H0) + CHR$(&H0) + CHR$(&H34) + CHR$(&H12)„asm$ = asm$ + CHR$(&HCB)„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL ABSOLUTE(Codeoff%)„'________________________________________„DEF SEG„„„END SUB„„FUNCTION int2str$ (sword%)„'This function is translating SWORD Integers into a string. Its only use„'is when you still use asm$ for assembler functions( like i do). In that„'case you can make your integer values usable ..„'THis function simply translates the hexa bytes„'into stringbytes as is.„'----------------------------------------------------„DEF SEG = VARSEG(sword%)„ptr% = VARPTR(sword%)„int2str$ = CHR$(PEEK(ptr%)) + CHR$(PEEK(ptr% + 1))„DEF SEG„„END FUNCTION„„SUB pokestring (SEGJE%, OFFJE%, MAIN$)„'------------------------------------------------------„'This function pokes a string (might be ASCIIZ)into„'memory at a given location, making it possible to„'access strings in byte form„'------------------------------------------------------„„DEF SEG = SEGJE%„FOR i% = 0 TO LEN(MAIN$) - 1„  POKE OFFJE% + i%, ASC(MID$(MAIN$, i% + 1, 1))„NEXT„DEF SEG„„END SUB„„SUB PokeW (pokeseg%, pokeoff%, word%)„'This function will just poke a word into memory, just like„'the standard function Poke does it, with one enhancement.„'While poke needs a def seg before it we will transfer that to„'the function also! So :„' DW segment to poke word to„' DW offset to poke word to„' DW wordvalue to poke„'Of course you should use this only for reasons of putting all your„'variables in one DATAsegment, since otherwise just defining a integer„'is enough.„'---------------------------------------------------------------„DEF SEG = VARSEG(word%)„ptr% = VARPTR(word%)„highbyte% = PEEK(ptr% + 1): lowbyte% = PEEK(ptr%)„DEF SEG = pokeseg%„  POKE pokeoff%, lowbyte%„  POKE pokeoff% + 1, highbyte%„DEF SEG„„END SUB„Rick Elbers                    ASSEMBLY IN QBASIC 2: INSIDE   rick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        130  5610     2INSIDE.BAS 'ASSEMBLY IN QBASIC 2: DEFAULTS„'-----------------------------------------------------------------------„'Rick Elbers februari 1997„'--------------------------„'Introduction„'--------------„'This routine is exploring the values for DS,ES,SS,SP and the return adresses„'as they depend on both the CS:IP you have set by storing the asm routine„'and on the QBASIC IDE environment.„'Both asm$ storage and integer storage design are considered.„'---------------------------------------------------------------------------„DEFINT A-Z„DECLARE SUB inside2 (dat())„„'INITIALIZING:„CLS : DIM dat(18):„header$ = CHR$(179) + " CS " + CHR$(179) + " IP " + CHR$(179) + " DS "„header$ = header$ + CHR$(179) + " ES " + CHR$(179) + " SS " + CHR$(179)„header$ = header$ + " SP " + CHR$(179) + "RECS" + CHR$(179) + "REIP"„header$ = header$ + CHR$(179) + "flag" + CHR$(179)„„'EXECUTE:„inside2 dat()„„'PRINT:„COLOR 0, 7: PRINT SPACE$(13) + "WITH ASM$ APPROACH" + SPACE$(15)„COLOR 7, 0: PRINT STRING$(46, "_"): PRINT header$: COLOR 0, 7„PRINT CHR$(179);„FOR i = 9 TO 17:„  a$ = HEX$(dat(i)): PRINT STRING$(4 - LEN(a$), "0") + a$ + CHR$(179);„NEXT„PRINT : PRINT„COLOR 0, 7: PRINT SPACE$(10) + "INTEGER STORAGE APPROACH" + SPACE$(12)„COLOR 7, 0: PRINT STRING$(46, "_"): PRINT header$: COLOR 0, 7„PRINT CHR$(179);„FOR i = 0 TO 8:„  a$ = HEX$(dat(i)): PRINT STRING$(4 - LEN(a$), "0") + a$ + CHR$(179);„NEXT„PRINT : PRINT„„„'Now let us go for the three sorts of space IN QBASIC:„COLOR 0, 7: PRINT SPACE$(5) + "SPACES INSIDE QBASIC" + SPACE$(5): COLOR 7, 0: PRINT STRING$(30, "_")„PRINT "Stringspace       : "; HEX$(FRE(""))„PRINT "Array(heap) space : "; HEX$(FRE(-1))„PRINT "Stackspace        : "; HEX$(FRE(-2))„PRINT STRING$(30, "_")„„„'1) Take notice that DS=CS=SS=stringsegment for ASM$ and DS=SS for„'   integerstorage. The importance of this information can hardly be„'   overestimated.„'   In some other contributions you can see that because of DS=SS„'   you can set up a pointer to a variable his adress on the stack,„'   and because of DS=stringsegment you do not have to assign DS„'   anoter value in a lot of cases.„„'2) Take a notice that an array startadress is always at a paragraphs„'   boundery, so you do not need to pass the offset through the stack.„'   You can just put it to zero.„„'3) Since there is only one stringsegment, it is also not necessary to„'   redeclare the segment with DEF SEG in a lot of cases. Just leave it„'   pointing to the string/stack segment will do.„„'The use of the mentioned consequences will demonstrated in later articles.„„'Good bye.„„'Rick„„SUB inside2 (dat())„'-------------------------------------------------------------------------„'                                                             [var]BP+6„'------------------------------------------------------------------------„asm$ = ""                                      'SP( on entrance„'                                                   SS:SP-0 =: CS  BP+4„'                                                   SS:SP-2 =: IP  BP+2„„asm$ = asm$ + CHR$(&H55)                        'push bp SS:SP-4   BP+0„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)           'mov bp,sp„asm$ = asm$ + CHR$(&H1E)                        'push ds SS:SP-6„'---------------------------------                                 ^„'First make our DAT adressable:                                  backwards„'---------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(6)   'mov bx,[bp+06]„asm$ = asm$ + CHR$(&HC5) + CHR$(&H37)             'lds si,[bx]„'-------------------------------------------------„'Now let us pop the returns adress of the stack:„'-------------------------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H2) 'mov bx,[bp+&h2]„asm$ = asm$ + CHR$(&H89) + CHR$(&H5C) + CHR$(14)  'mov [si+e],bx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H4) 'mov bx,[bp+&h4]„asm$ = asm$ + CHR$(&H89) + CHR$(&H5C) + CHR$(12)  'mov [si+c],bx„'--------------------------------„'Now store ds,es,ss,sp and flags:„'--------------------------------„asm$ = asm$ + CHR$(&H58)                         'pop ax   get ds to ax„asm$ = asm$ + CHR$(&H89) + CHR$(&H44) + CHR$(4)  'mov [si+4],ax store ds„asm$ = asm$ + CHR$(&H8C) + CHR$(&H44) + CHR$(6)  'mov [si+6],ES store es„asm$ = asm$ + CHR$(&H9C)                         'pushf„asm$ = asm$ + CHR$(&H8F) + CHR$(&H44) + CHR$(16) 'pop [si+&h10] store flags„asm$ = asm$ + CHR$(&H8C) + CHR$(&H54) + CHR$(8)  'mov [si+8],ss store ss„asm$ = asm$ + CHR$(&H83) + CHR$(&HC5) + CHR$(&H2)'add bp,2 'to sp on entrance (only push bp is in between)„asm$ = asm$ + CHR$(&H89) + CHR$(&H6C) + CHR$(10) 'mov [si+a],bp store sp„'--------------------„'Restore ds and bp:„'--------------------„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)             'mov ds,ax„asm$ = asm$ + CHR$(&H5D)                          'pop bp„'-------------„'We are done?„'-------------„asm$ = asm$ + CHR$(&HCA) + MKI$(2)                 'retf 2„„dat(9) = VARSEG(asm$): dat(10) = SADD(asm$):       'STORE CS[IP]„DEF SEG = dat(9): CALL absolute(dat(), dat(10))    'EXECUTE asm$„FOR i = 2 TO 8: dat(i + 9) = dat(i): NEXT          'STORE IN dat(8..17)„„DIM asmI(LEN(asm$) \ 2 + 1):                       'INTEGERSTORAGE„dat(0) = VARSEG(asmI(0)): dat(1) = VARPTR(asmI(0)) 'STORE CS[IP]„DEF SEG = dat(0)                                   'POKE ASM$ IN ARRAY„FOR i = 0 TO LEN(asm$) - 1:„  POKE i, ASC(MID$(asm$, i + 1, 1))„NEXT„„CALL absolute(dat(), dat(1)): DEF SEG              'EXECUTE asmI()„„END SUB„„RRick Elbers                    ASSEMBLY IN QBASIC 3: PASSING  rick@tip.nl                    02-19-97 (21:10)       QB, QBasic, PDS        914  40738    3PASSING.BAS'ASSEMBLY IN QBASIC 3: PASSING VARIABLES, ARRAYS, STRING to the STACK„'---------------------------------------------------------------------„'RICK ELBERS februari 1997„'---------------„'Introduction„'--------------„„'This routine is exploring the way array's, long integers„'and strings are passed to the assembly routine. There will„'be developed efficient procedures for doing this.„'In addition I will demonstrate some of the uses you can make„'of this knowledge. You absolutely need to understand the„'informations and tools presented in this article to make„'some progress with assembly in QBASIC.„'And the other way around too: when you understand them well,I„'think you have ways to gooo.„'----------------------------------------------------------------„DEFINT A-Z„„'INFORMATIONS:„'*************„DECLARE SUB integerinfo ()        'information about integer passing„DECLARE SUB longinfo (longs&)     'information about long passing„DECLARE SUB stringinfo (a$)       'information about variable string passing„DECLARE SUB fixedstringinfo ()    'information about fixed string passing„„DECLARE SUB intarrayinfo ()       'information about integer array passing„DECLARE SUB intarrayinfo2 ()      'information about integer array passing 2„DECLARE SUB longarrayinfo ()      'information about long array passing„DECLARE SUB stringarrayinfo ()    'information about string array passing„„DECLARE SUB typeinfo ()           'information about type passing„„'DEMONSTRATIONS:„'***************„DECLARE FUNCTION dosprn$ ()       'demonstration of stringpassing„DECLARE SUB movearr2arr ()        'demonstration of integer array passing„DECLARE SUB swapstringarray ()    'demonstration of string array passing„DECLARE SUB ascicntdemo ()        'demonstration of long array passing„„TYPE testtype„astring AS STRING * 5„ainteger AS INTEGER„along AS LONG„END TYPE„„DIM SHARED test AS testtype„test.astring = "hallo"„test.ainteger = &HFFFF„test.along = &HF0F0F0F0„„CLS„COLOR 0, 7: PRINT "Let us get some information about passing ..";„COLOR 7, 0:„VIEW PRINT 3 TO 25„„PRINT : PRINT : PRINT "Press a key for integer pass info": SLEEP: CLS„CALL integerinfo„PRINT : PRINT : PRINT "Press a key for long integer pass info": SLEEP: CLS„CALL longinfo(&H123F546F)„PRINT : PRINT : PRINT "Press a key for string pass info ": SLEEP: CLS„CALL stringinfo("Wat is dit")„PRINT : PRINT : PRINT "Press a key for fixed string pass info ": SLEEP: CLS„CALL fixedstringinfo„PRINT : PRINT : PRINT "Press a key for integer array pass info": SLEEP: CLS„CALL intarrayinfo„CALL intarrayinfo2„PRINT : PRINT : PRINT "Press a key for long array pass info": SLEEP: CLS„CALL longarrayinfo„PRINT : PRINT : PRINT "Press a key for array of strings pass info ": SLEEP: CLS„CALL stringarrayinfo„PRINT : PRINT : PRINT "Press a key for type pass info ": SLEEP: CLS„CALL typeinfo„PRINT : PRINT "Press a key": SLEEP: VIEW PRINT: CLS„„COLOR 0, 7: PRINT "Let us demonstrate barely the powers that we discovered..";„COLOR 7, 0:„VIEW PRINT 3 TO 25„PRINT : PRINT "Press a key for string print demo ": SLEEP: CLS 2„„'Using this information we can write an efficient dosprn„COLOR 0, 7: PRINT "STRING PRINT DEMONSTRATION": COLOR 7, 0: PRINT :„asm$ = dosprn$: Codeoff = SADD(asm$):„DEF SEG = VARSEG(asm$): CALL absolute("HaHaThisisAll$", Codeoff)„DEF SEG„„PRINT : PRINT : PRINT "Press a key for array movet demo ": SLEEP: CLS 2„'Using this information we can write an efficient movearray„CALL movearr2arr„„PRINT : PRINT : PRINT "Press a key for stringswap demo ": SLEEP: CLS 2„'Using this information we can write an very efficient stringsort„CALL swapstringarray„„PRINT : PRINT : PRINT "Press a key for ascicount(long array) demo ": SLEEP: CLS 2„CALL ascicntdemo„„PRINT : PRINT : PRINT "Press a key for conclusions ": SLEEP: VIEW PRINT: CLS„„'The use of stringarrays can hardly be overestimated. First they default„'to the stringsegment and second there location is stable. This makes them„'very useful for the storage of asm functions as we will see in the next„'issues of ASM in QBASIC. Also because of the descriptors you could sort„'a complete array of strings with a resultant indexarray of elements„'which make it possible to get the array sorted in QBASIC by:„'FOR i=lbound(arraystring$) TO ubound(arraystring$)„'    print arraystring$(index(i))„'NEXT„'This will be very very fast since the only thing you sort is the index„'and you are not going to copy the strings themselves....„„PRINT SPACE$(30); : COLOR 0, 7: PRINT " CONCLUSIONS ": COLOR 7, 0„PRINT„COLOR 0, 7: PRINT " MEMORY LOCATIONS ": COLOR 7, 0„PRINT "- The memory LOCATIONS of integers, stringarrays and types are STABLE."„PRINT "- The memory LOCATION of a fixed length string is also STABLE."„PRINT "- A variable length string is prone to garbage collection(<>STABLE)."„PRINT„COLOR 0, 7: PRINT " MEANINGFULL STACKPASSING POSSIBILITIES ": COLOR 7, 0„PRINT "-You can pass all types of variables in a meaningful manner through"„PRINT " the stack except the FIXED LENGTH string."„PRINT„COLOR 0, 7: PRINT " PASSING BY VALUE ": COLOR 7, 0„PRINT "-INTEGERS and TYPES are the only 'variables' that are passed by VALUE by default"„PRINT "-It is possible to pass LONG integers by VALUE while using BYVAL"„PRINT„COLOR 0, 7: PRINT " PASSING BY REFERENCE ": COLOR 7, 0„PRINT "-All variables except INTEGERS and TYPES are passed by REFERENCE by default."„PRINT "-INTEGER/TYPE REFERENCING(pointing)is possible by reference to there STACKADRESS"„PRINT„COLOR 0, 7: PRINT " STRANGE BEHAVIORS ": COLOR 7, 0„PRINT "-Like Gunter Ilzig pointed out PASSING by REFERENCE is ALWAYS faster"„PRINT " This is also true for integer and type passing( strange fact)": PRINT„„PRINT "Good bye"„„„„END„„DEFSTR A-Z„SUB ascicntdemo„„COLOR 0, 7: PRINT "LONG ARRAY DEMONSTRATION": COLOR 7, 0: PRINT :„„'---------------------------------------„'THIS FUNCTION TRIES TO SPEED UP„'THE SORT OF FREQUENCY OF CHARACTERS.„'EOF IS STORED TOO!„„'STACKPASSING FREQ&(),A$„„'IN: FREQ ARRAY„'    STRING TO CNT„„'OUT FREQ ARRAY UPDATED„„'Its just an example of the use of long„'array's..„'---------------------------------------„„asm = asm + CHR$(&H55)                               'PUSH BP„asm = asm + CHR$(&H89) + CHR$(&HE5)                  'MOV BP,SP„asm = asm + CHR$(&H1E)                               'PUSH DS„asm = asm + CHR$(&H6)                                'PUSH ES„'DS[SI] TO STRING,CX TO LEN„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)      'MOV BX,[BP+06]„asm = asm + CHR$(&H8B) + CHR$(&HF)                   'MOV CX,[BX]  LENGTH„asm = asm + CHR$(&H8B) + CHR$(&H77) + CHR$(&H2)      'MOV SI,[BX+2]DS[SI] STRING„'ES[DI] TO ARRAY„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)      'MOV BX,[BP+08]„asm = asm + CHR$(&HC4) + CHR$(&H3F)                  'LES DI,[BX] ES[DI] ASCARRAY„asm = asm + CHR$(&HFC)                               'CLD         FUTURE„'LOOPJE:„asm = asm + CHR$(&HAC)                               'LODSB    DS[SI] > AL„asm = asm + CHR$(&H30) + CHR$(&HE4)                  'XOR AH,AH„asm = asm + CHR$(&HC1) + CHR$(&HE0) + CHR$(2)        'SHL AX,2 ASC TO INTELEMENT„asm = asm + CHR$(&H89) + CHR$(&HC3)                  'MOV BX,AX TO ADRESS IN ARRAY„asm = asm + CHR$(&H26) + CHR$(&HFF) + CHR$(&H7)      'ES:INC[BX]„asm = asm + CHR$(&H49)                               'DEC CX„asm = asm + CHR$(&H75) + CHR$(&HF2)                  'JNZ -12 ANOTHER ELEMENT ?„„asm = asm + CHR$(&H7)                                'POP ES„asm = asm + CHR$(&H1F)                               'POP DS„asm = asm + CHR$(&H5D)                               'POP BP„asm = asm + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)       'RETF 4„„ascicnt = asm„'-------------------------------------------------„'LONGDIVINT:„'This function is returning both the division„'and the remainder from an SDWORD to SWORD division.„„'STACKPASSING Word&,Div&„'IN : Word& the Dword to divide„'     Div%  the word to divide by„'OUT: Word& the result of Longintegerdivision„'     DIv%  the remainder of the Longintegerdivision„'--------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                             'push bp         4„asm = asm + CHR$(&H89) + CHR$(&HE5)                'mov bp,sp       1„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)    'mov bx,[bp+0a]  1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)                 'mov AX,[bx]     1+5 low„asm = asm + CHR$(&H8B) + CHR$(&H57) + CHR$(2)      'mov DX,[bx+2]   1+9 high„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)    'mov bx,[bp+06]  1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)                 'mov CX,[bx]     1+5„asm = asm + CHR$(&HF7) + CHR$(&HF9)                'idiv cx         27„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)    'mov bx,[bp+0A]  1+9„asm = asm + CHR$(&H89) + CHR$(&H7)                 'mov [bx],ax     1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)    'mov bx,[bp+08]  1+9„asm = asm + CHR$(&H89) + CHR$(&H17)                'mov [bx],dx     1+5„„asm = asm + CHR$(&H5D)                             'pop bp          4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)     'retf 4          14„longdivint = asm                                       'clocks     105„„'Initiating functions ,arrays and string:„DIM freq&(255): a$ = SPACE$(10000):„FOR I% = 0 TO 255: freq&(I%) = 0: NEXT:„„DEF SEG = &H40: POKE &H1C, PEEK(&H1A)„DEF SEG = VARSEG(ascicnt)„„'Oke and lets go for it( you can hold your breath!even for 300 KB text!)„„PRINT "Give a path of very large(< 100 MB) text file.. ";„f$ = "": DO UNTIL f$ <> "": COLOR 0, 7: LINE INPUT f$: LOOP: COLOR 7, 0„PRINT : a! = TIMER: OPEN f$ FOR BINARY AS #1„mods% = 10000: CALL absolute(LOF(1), divs%, mods%, SADD(longdivint))„„FOR I% = 1 TO divs%„GET #1, , a$:„  '___________________________________________________________„  CALL absolute(freq&(), a$, SADD(ascicnt))„  '___________________________________________________________„NEXT„a$ = SPACE$(mods%): GET #1, , a$            'last part„CALL absolute(freq&(), a$, SADD(ascicnt))„leof& = LOF(1): CLOSE : DEF SEG„c! = TIMER„COLOR 0, 7: PRINT "Frekwenties of 'text' ASCI's"; : COLOR 7, 0: PRINT :„FOR I% = 32 TO 126:„  PRINT CHR$(I%); ":"; : PRINT USING "#######"; freq&(I%); : PRINT " "; :„  IF (I% - 32) MOD 8 = 7 THEN PRINT„NEXT„PRINT : PRINT„PRINT "For a file of "; : COLOR 0, 7: PRINT leof&; : COLOR 7, 0:„PRINT " bytes we needed "; : COLOR 0, 7: PRINT c! - a!; : COLOR 7, 0„„END SUB„„DEFSNG A-Z„FUNCTION dosprn$„'This functions prints a string with only passing the string itself. Period„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H57) + CHR$(&H2)     'mov dx,[bx+2] get sadd„asm$ = asm$ + CHR$(&HB4) + CHR$(&H9)                  'mov ah,9 ds points already to stringseg„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)                 'int 21„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H2) + CHR$(&H0)      'retf 8„dosprn$ = asm$„END FUNCTION„„DEFINT A-Z„SUB fixedstringinfo„'-------------------------------------------------„'This function checks how fixed strings are passed„'through a call absolute procedure„'-------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H89) + CHR$(&HD9)                 'mov cx,bx     get varptr„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)                  'mov ax,[bx]   get len„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx,[bp+0A] first var„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx],ax„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08] sec var„asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx],cx„„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)      'retf 6„„DIM als AS STRING * 31„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(a, b, als$, Codeoff)„'________________________________________„DEF SEG„COLOR 0, 7: PRINT "FIXED STRING PASSING INFORMATION": COLOR 7, 0: PRINT :„COLOR 0, 7: PRINT "Fixed String passed to the stack as a$":„PRINT "CALL ABSOLUTE (a,b,a$,codeoff)"„COLOR 7, 0: PRINT "BX is initialized as BX = [BP+06]"„PRINT "After that:"„PRINT "First variabele( Length of string at [BX])       : "; a„PRINT "Second variabele( 'VARPTR' of string at BX)<NOT> : "; HEX$(b)„PRINT "The control values of LEN and VARPTR are         :"; : COLOR 0, 7:„PRINT LEN(als$); " "; HEX$(VARPTR(als$)); "  ";„COLOR 7, 0„„„END SUB„„SUB intarrayinfo„'-------------------------------------------------------„'This sub does nothing more then change an array!„'SI and DI are used since they are basedisplacement for„'DS where BP is basedisplacement for SS!„'-------------------------------------------------------„„DIM a(1, 1): segje = VARSEG(a(0, 0)): offje = VARPTR(a(0, 0))„COLOR 0, 7: PRINT "Array passing information "; : COLOR 7, 0: PRINT :„PRINT "The array as initialized:"„FOR j = 0 TO 1: FOR I = 0 TO 1:„  a(I, j) = I * 10 + j:„  PRINT "element :"; j; ","; I; "value :"; a(I, j):„NEXT: NEXT„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                          'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„asm$ = asm$ + CHR$(&H1E)                          'push ds„'---------------------------------„'Get si to point to offset array:„'---------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H37)             'mov si,[bx]„'-----------------------„'segment of array to ds:„'----------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08]„asm$ = asm$ + CHR$(&H8E) + CHR$(&H1F)             'mov ds,[bx]„'-------------------------------------„'Increment first element and store it:„'-------------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H3C)             'mov di,[si]„asm$ = asm$ + CHR$(&H47)                          'inc di„asm$ = asm$ + CHR$(&H89) + CHR$(&H3C)             'mov [si],di„'--------------------------------------„'Decrement second element and store it:„'--------------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7C) + CHR$(&H2) 'mov di,[si+2]„asm$ = asm$ + CHR$(&H4F)                          'dec di„asm$ = asm$ + CHR$(&H89) + CHR$(&H7C) + CHR$(&H2) 'mov [si+2],di„„asm$ = asm$ + CHR$(&H1F)                          'pop ds„asm$ = asm$ + CHR$(&H5D)                          'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)  'retf 4„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(segje, offje, Codeoff)„'________________________________________„DEF SEG„„PRINT "The array after machinations: increment first/decrement second element"„FOR j = 0 TO 1: FOR I = 0 TO 1:„  PRINT "element :"; j; ","; I; "value :"; a(I, j):„NEXT: NEXT„„„„END SUB„„SUB intarrayinfo2„'---------------------------------------------------------„'This sub does nothing more then get elements of an array„'---------------------------------------------------------„„DIM a(1, 1):„FOR j = 0 TO 1: FOR I = 0 TO 1:„  a(I, j) = I * 10 + j + 1:„NEXT: NEXT„segje = VARSEG(a(0, 0)): offje = VARPTR(a(0, 0))„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                          'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„asm$ = asm$ + CHR$(&H1E)                          'push ds„'---------------------------------„'Get si to point to offset array:„'---------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06]„asm$ = asm$ + CHR$(&HC5) + CHR$(&H37)             'lds si,[bx]    get ptr to array„asm$ = asm$ + CHR$(&H8C) + CHR$(&HD8)             'mov ax,ds      and saving„asm$ = asm$ + CHR$(&H8B) + CHR$(&H4C) + CHR$(4)   'mov cx,[si+04] get an arrayelement„                                                                  'third element!„asm$ = asm$ + CHR$(&H1F)                          'pop ds„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] last var„asm$ = asm$ + CHR$(&H89) + CHR$(&HF)              'mov [bx],cx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0a]  sec var„asm$ = asm$ + CHR$(&H89) + CHR$(&H37)             'mov [bx],si„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC) 'mov bx,[bp+08] first var„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)              'mov [bx],ax„„asm$ = asm$ + CHR$(&H5D)                          'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)  'retf 8„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(b, c, d, a(), Codeoff)„'________________________________________„DEF SEG„PRINT„COLOR 0, 7: PRINT "Original array passed to the stack as array a()":„PRINT "CALL ABSOLUTE (b,c,d,a(),codeoff)"„COLOR 7, 0: PRINT "BX is initialized as BX = [BP+06]"„PRINT "After that:"„PRINT "First variabele( segment of array at [BX+2])                 : "; HEX$(b)„PRINT "Second variabele( offset of array at [BX])                   : "; HEX$(c)„PRINT "Third variabele (value of element at [BX+2]:[BX+2*elementnr] :"; d„PRINT "The control values are resp.: "; : COLOR 0, 7:„PRINT HEX$(segje), HEX$(offje), a(0, 1); : COLOR 7, 0„„„END SUB„„SUB integerinfo„'--------------------------------------------------------------„'This function checks how integers are passed to call absolute„'First by reference and then by value..„'--------------------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H76) + CHR$(&H6)     'mov si,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H4)                  'mov ax,[si]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H1F)                 'mov bx,[bx]„asm$ = asm$ + CHR$(&H89) + CHR$(&H1C)                 'mov [si],bx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx,[bp+0a]„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx],ax„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08]„asm$ = asm$ + CHR$(&H89) + CHR$(&H37)                 'mov [bx],si„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)      'retf 6„'______________________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$): fill = 76: in = 5: ints = in„CALL absolute(a, fill, ints, Codeoff)„'_______________________________________________________„DEF SEG„COLOR 0, 7: PRINT "INTEGER PASSING INFORMATION"; : COLOR 7, 0: PRINT : PRINT„COLOR 0, 7: PRINT "Integer passed to the stack by reference as ints":„PRINT "CALL ABSOLUTE (a,fill,ints,codeoff)"„COLOR 7, 0: PRINT "BX is intialized as BX =[SP+6]"„PRINT "After that:"„PRINT "First variabele( Value of ints at [BX])         : "; HEX$(a)„PRINT "Second variabele( Varptr of ints at BX)         : "; HEX$(fill)„PRINT "We changed the ints to fill                     : "; HEX$(ints)„PRINT "The control values VARPTR and value are         : "; : COLOR 0, 7:„PRINT HEX$(VARPTR(ints)), HEX$(in): COLOR 7, 0„„'And lets do it by value...„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H46) + CHR$(&H6)     'mov ax,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+0A]„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx],ax„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)      'retf 4„„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$): ints = 8„CALL absolute(ax, BYVAL (ints), Codeoff)„'________________________________________„DEF SEG„PRINT„COLOR 0, 7: PRINT "Integer passed to the stack by value as BYVAL(ints)":„PRINT "CALL ABSOLUTE (AX,BYVAL(ints),codeoff)"„COLOR 7, 0: PRINT "AX is intialized as AX=[SP+6]"„PRINT "After that:"„PRINT "First variabele( Value of ints at AX )          : "; HEX$(ax)„PRINT "The control value of ints is                    : "; : COLOR 0, 7:„PRINT HEX$(ints): COLOR 7, 0„„END SUB„„SUB longarrayinfo„'---------------------------------------------------------„'This sub does nothing more then get elements of a„'array of long integers„'---------------------------------------------------------„COLOR 0, 7: PRINT "LONG INTEGER ARRAY passing information "; : COLOR 7, 0: PRINT :„DIM a&(1, 1):„FOR j = 0 TO 1: FOR I = 0 TO 1:„  a&(I, j) = &HFFFFF + I * 10 + j + 1:„NEXT: NEXT„segje = VARSEG(a&(0, 0)): offje = VARPTR(a&(0, 0))„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                          'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„asm$ = asm$ + CHR$(&H1E)                          'push ds„'---------------------------------„'Get si to point to offset array:„'---------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06]„asm$ = asm$ + CHR$(&HC5) + CHR$(&H37)             'lds si,[bx]    get ptr to array„asm$ = asm$ + CHR$(&H8C) + CHR$(&HD8)             'mov ax,ds      and saving„asm$ = asm$ + CHR$(&H66) + CHR$(&H8B) + CHR$(&H4C) + CHR$(8)'mov ecx,[si+08]get an arrayelement„                                                                  'third element!„asm$ = asm$ + CHR$(&H1F)                          'pop ds„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] last var„asm$ = asm$ + CHR$(&H66) + CHR$(&H89) + CHR$(&HF) 'mov [bx],ecx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0a]  sec var„asm$ = asm$ + CHR$(&H89) + CHR$(&H37)             'mov [bx],si„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC) 'mov bx,[bp+08] first var„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)              'mov [bx],ax„„asm$ = asm$ + CHR$(&H5D)                          'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)  'retf 8„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(b, c, d&, a&(), Codeoff)„'________________________________________„DEF SEG„PRINT„COLOR 0, 7: PRINT "Original array passed to the stack as array a&()":„PRINT "CALL ABSOLUTE (b,c,d&,a&(),codeoff)"„COLOR 7, 0: PRINT "BX is initialized as BX = [BP+06]"„PRINT "After that:"„PRINT "First variabele( segment of array at [BX+2])                 : "; HEX$(b)„PRINT "Second variabele( offset of array at [BX])                   : "; HEX$(c)„PRINT "Third variabele (value of element at [BX+2]:[BX+4*elementnr] :"; d&„PRINT "The control values are resp.: "; : COLOR 0, 7:„PRINT HEX$(segje), HEX$(offje), a&(0, 1); : COLOR 7, 0„„END SUB„„SUB longinfo (longs&)„'------------------------------------------------------------„'This function checks how longs are passed to call absolute„'First by reference and then by value..„'------------------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)                  'mov ax,[bx]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H4F) + CHR$(&H2)     'mov cx,[bx+2]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08]„asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx],cx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx,[bp+0a]„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx],ax„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)      'retf 6„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(a, b, longs&, Codeoff)„'________________________________________„DEF SEG„COLOR 0, 7: PRINT "LONG INTEGER PASSING INFORMATION": COLOR 7, 0: PRINT :„COLOR 0, 7: PRINT "Long integer passed to the stack by reference as longs&":„PRINT "CALL ABSOLUTE (a,b,longs&,codeoff)"„COLOR 7, 0: PRINT "BX is initialized as BX = [BP+06]"„PRINT "After that:"„PRINT "First variabele( Lowword of long at [BX])        : "; HEX$(a)„PRINT "Second variabele( Highword of array at [BX+2])   : "; HEX$(b)„PRINT "The control value of the long integer is:        : "; : COLOR 0, 7:„PRINT HEX$(longs&): COLOR 7, 0„„'And lets do it by value...„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H46) + CHR$(&H6)     'mov ax,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H4E) + CHR$(&H8)     'mov cx,[bp+08]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx,[bp+08]„asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx],cx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)     'mov bx,[bp+0a]„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx],ax„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)      'retf 8„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(a, b, BYVAL (longs&), Codeoff)„'________________________________________„DEF SEG„PRINT„COLOR 0, 7: PRINT "Long integer passed by value to the stack as longs&":„PRINT "CALL ABSOLUTE (a,b,longs&,codeoff)"„COLOR 7, 0: PRINT "BP is initialized as BP = SP"„PRINT "After that:"„PRINT "First variabele( Lowword of long at [BP+06])     : "; HEX$(a)„PRINT "Second variabele( Highword of array at [BP+08])  : "; HEX$(b)„PRINT "The control value of the long integer is:        : "; : COLOR 0, 7:„PRINT HEX$(longs&): COLOR 7, 0„„END SUB„„SUB movearr2arr„„'Wat this function does is something that you need surprisingly„'often. When you take a good look at some interruptlist you„'will notice some difficult parameterblocks there that you have„'to pass to the interrupt. Often those parameterblocks are„'discontinue( if that is the right word) in that they consist„'of bytes,words and dubbel words. That is why this function„'might be extremely useful for loading up some parameterblock„'This is just an example of loading up a parameterblock„'with: DW  length is a long„'      W   handle is an integer„'      DW  offset:segment of array„'      W   handle is an integer„'      DW  32 bit offset is a long„'--actually this is the syntax for XMS.move( just to let you know it)„'You should notice that the uploading of elements is redundant, and that„'is the reason why some large sorting algorithm can be quite small in„'asm source!. Also notice that we never used DS[si] so far since there„'where no strings to pass to the params!„„„'STACKPASSING nrbytes&,XMShandle,source(),XMSoffset,Params()„'IN        : ES[DI] parameterblock„'            ....   parameters to pass to the block„             'nrbytes&„             'XMShandle„             'sourcearray„             'XMSoffset&„'OUT       : ES[DI] filled parameterblock„„'USING IN QBASIC: ARRAYPASSING, "ALL TYPES" PASSING„'-------------------------------------------------------------„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                          'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„asm$ = asm$ + CHR$(&H6)                           'push Es„'----------------------------------------„'Let us first put the destiny in ES[DI]:„'----------------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06]„asm$ = asm$ + CHR$(&HC4) + CHR$(&H3F)             'LES DI,[bx]  get ptr to array„'------------„'Get nrbytes&„'-------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HE) 'mov bx,[bp+0e]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]   lowbyte„asm$ = asm$ + CHR$(&H8B) + CHR$(&H47) + CHR$(&H2) 'mov ax,[bx+2]„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]   highbyte„'--------------------------„'Store 0 for source handle„'--------------------------„asm$ = asm$ + CHR$(&H31) + CHR$(&HC0)             'xor ax,ax„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]   0„'---------------------------------------„'Get offset and segment of source array„'---------------------------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0A]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]  get OFFSRC„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H47) + CHR$(&H2) 'mov ax,[bx+2] get SEGSRC„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]„'-----------------„'Get XMS handle„'-----------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC) 'mov bx,[bp+0C]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]  get handle„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]„'----------------------„'Get XMS 32 bit offset„'----------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]   lowbyte„asm$ = asm$ + CHR$(&H8B) + CHR$(&H47) + CHR$(&H2) 'mov ax,[bx+2]„asm$ = asm$ + CHR$(&HAB)                          'stosw naar es[di]   highbyte„'--------------------------------------------------„'Well in fact we are done. Here is where the real„'XMS thing starts..but thats for later„'--------------------------------------------------„asm$ = asm$ + CHR$(&H7)                           'push Es„asm$ = asm$ + CHR$(&H5D)                          'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&HA) + CHR$(&H0)  'retf a„„„nrbytes& = &HF1234567: DIM src(10000): xmsoff& = &HFEDCBA98„DIM params(7): xmshandle = &H1122„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(nrbytes&, xmshandle, src(), xmsoff&, params(), Codeoff)„'________________________________________„„COLOR 0, 7: PRINT "ARRAY MOVE DEMONSTRATION": COLOR 7, 0: PRINT :„„COLOR 0, 7„FOR I = 0 TO 7: PRINT I, HEX$(params(I)): NEXT„COLOR 7, 0„PRINT "There was passed a:"„COLOR 0, 7: PRINT "CALL ABSOLUTE(nrbytes&, xmshandle, src(), xmsoff&, params(), Codeoff) "„COLOR 7, 0: PRINT "Controlvalues are:": COLOR 0, 7„PRINT "0  DW  Nrbytes   : "; HEX$(nrbytes&)„PRINT "2  W handle      :"; 0„PRINT "3  W offset src  : "; HEX$(VARPTR(src(0)))„PRINT "4  W segment src : "; HEX$(VARSEG(src(0)))„PRINT "5  W XMShandle   : "; HEX$(xmshandle)„PRINT "6  DW XMSoffset  : "; HEX$(xmsoff&)„COLOR 7, 0„END SUB„„SUB stringarrayinfo„'--------------------------------------------------„'This function checks how string array's are passed„'through a call absolute procedure„'--------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H57) + CHR$(&H2)     'mov dx,[bx+2] get seg„asm$ = asm$ + CHR$(&H8B) + CHR$(&H37)                 'mov si,[bx]   get varptr„„asm$ = asm$ + CHR$(&H8B) + CHR$(&HC)                  'mov cx,[si]   get len first element„asm$ = asm$ + CHR$(&H8B) + CHR$(&H44) + CHR$(&H2)     'mov ax,[si+2] get sadd first element„„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HE)     'mov bx,[bp+0E] first var„asm$ = asm$ + CHR$(&H89) + CHR$(&H17)                 'mov [bx],dx  seg„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)     'mov bx,[bp+0C] sec var„asm$ = asm$ + CHR$(&H89) + CHR$(&H37)                 'mov [bx],si  varptr„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx,[bp+0A] third var„asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx],cx   len„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08] fourth var„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx],ax   sadd„„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&HA) + CHR$(&H0)      'retf A„„„CLS : DIM arraystrings$(10)„arraystrings$(0) = "doei"„arraystrings$(1) = "b"„arraystrings$(2) = "En dit dan als ik vragen mag ?"„„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(a, b, c, d, arraystrings$(), Codeoff)„'________________________________________„DEF SEG„COLOR 0, 7: PRINT "STRINGARRAY PASSING INFORMATION": COLOR 7, 0: PRINT :„COLOR 0, 7: PRINT "String passed to the stack as arraystring$()":„PRINT "CALL ABSOLUTE (a,b,c,d,arraystrings$(),codeoff)"„COLOR 7, 0: PRINT "BX is initialized as BX = [BP+06]"„PRINT "After that:"„PRINT "First variabele(  VARSEG of stringsarray at [BX+2] )      : "; HEX$(a)„PRINT "Second variabele( VARPTR of stringsarray at [BX])         : "; HEX$(b)„PRINT "Third variabele( LEN of first string at   [VARPTR])       : "; HEX$(c)„PRINT "Fourth variabele( SADD of first string at [VARPTR+2])     : "; HEX$(d)„PRINT "The control values of SEG, VARPTR, LEN and SADD are       : "; : COLOR 0, 7:„PRINT HEX$(VARSEG(arraystrings$(0))); " "; HEX$(VARPTR(arraystrings$(0))); " "; HEX$(LEN(arraystrings$(0))); " "; HEX$(SADD(arraystrings$(0)))„COLOR 7, 0„„„„END SUB„„SUB stringinfo (a$)„'---------------------------------------------„'This function checks how strings are passed„'through a call absolute procedure„'-------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H89) + CHR$(&HD9)                 'mov cx,bx     get varptr„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7)                  'mov ax,[bx]   get len„asm$ = asm$ + CHR$(&H8B) + CHR$(&H57) + CHR$(&H2)     'mov dx,[bx+2] get sadd„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)     'mov bx,[bp+0c] first var„asm$ = asm$ + CHR$(&H89) + CHR$(&H7)                  'mov [bx],ax„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx,[bp+0a] sec var„asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx],cx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08] third var„asm$ = asm$ + CHR$(&H89) + CHR$(&H17)                 'mov [bx],dx„„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)      'retf 8„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(a, b, c, a$, Codeoff)„'________________________________________„DEF SEG„COLOR 0, 7: PRINT "STRING PASSING INFORMATION": COLOR 7, 0: PRINT :„COLOR 0, 7: PRINT "String passed to the stack as a$":„PRINT "CALL ABSOLUTE (a,b,c,a$,codeoff)"„COLOR 7, 0: PRINT "BX is initialized as BX = [BP+06]"„PRINT "After that:"„PRINT "First variabele( Length of string at [BX]  )     : "; a„PRINT "Second variabele( VARPTR of string at BX)        : "; HEX$(b)„PRINT "Second variabele( SADD of string at [BX+2])      : "; HEX$(c)„PRINT "The control values of LEN, VARPTR and SADD are   :"; : COLOR 0, 7:„PRINT LEN(a$); " "; HEX$(VARPTR(a$)); "  "; HEX$(SADD(a$))„COLOR 7, 0„„END SUB„„SUB swapstringarray„'----------------------------------------------------------------„'This procedure will swap some elements of a stringarray.„'Very useful when you want a fast sort of stringelements.„„'The better method then the one used here for an array of„'fixed length strings is to sort the stringdescriptors. That way„'you only need to copy the strings one time. However QBASIC seems„'to prevent the straightforward updating of the descriptors.„'What IS possible is to pass an index (integerarray) along with„'the array of strings and 'sort' the indexarray.„'----------------------------------------------------------------„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                         'push bp        4„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)            'mov bp,sp      1„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)'mov bx,[bp+06] 1+9„asm$ = asm$ + CHR$(&H8B) + CHR$(&H1F)            'mov bx,[bx]   get varptr  1+5„asm$ = asm$ + CHR$(&HBE) + MKI$(&HA)             'mov si,a       1„asm$ = asm$ + CHR$(&H8B) + CHR$(&H28)            'mov bp,[bx+si]ptr sadd 3d element  1+7„asm$ = asm$ + CHR$(&HBE) + MKI$(&H2)             'mov si,2       1„asm$ = asm$ + CHR$(&H8B) + CHR$(&H18)            'mov bx,[bx+si]ptr sadd 1st element  1+7„asm$ = asm$ + CHR$(&HBE) + MKI$(&H8)             'mov si,A bytes to copy   1„asm$ = asm$ + CHR$(&H8B) + CHR$(&H0)             'mov al,[bx+si] get first element first 2 char 1+7„asm$ = asm$ + CHR$(&H87) + CHR$(&H2)             'xchg al,[bp+si]xchg with third element  3+7„asm$ = asm$ + CHR$(&H89) + CHR$(&H0)             'mov [bx+si],al 1+7„asm$ = asm$ + CHR$(&H83) + CHR$(&HEE) + CHR$(2)  'sub si,2       1„asm$ = asm$ + CHR$(&H79) + CHR$(&HF5)            'jns - 11       3/1„„asm$ = asm$ + CHR$(&H5D)                         'pop bp         4„asm$ = asm$ + CHR$(&HCA) + CHR$(&H2) + CHR$(&H0) 'retf 2         14„„„CLS : DIM arraystrings$(2)„arraystrings$(0) = "doei" + SPACE$(7)„arraystrings$(1) = "b" + SPACE$(9)„arraystrings$(2) = "En dit dan"„COLOR 0, 7: PRINT "STRINGARRAY SWAPPING DEMONSTRATION": COLOR 7, 0: PRINT :„PRINT :„COLOR 0, 7: PRINT "ARRAY BEFORE SWAP": COLOR 7, 0„FOR I = 0 TO 2„  PRINT I; ":", arraystrings$(I)„NEXT„„'________________________________________„Codeoff = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(arraystrings$(), Codeoff)„'________________________________________„DEF SEG : PRINT„COLOR 0, 7: PRINT "ARRAY AFTER SWAP": COLOR 7, 0„FOR I = 0 TO 2„  PRINT I; ":", arraystrings$(I)„NEXT„„'„END SUB„„DEFSNG A-Z„SUB typeinfo„'---------------------------------------------„'This function checks how types are passed„'through a call absolute procedure„'-------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H66) + CHR$(&H8B) + CHR$(&H7)     'mov eax,[bx]  get string„asm$ = asm$ + CHR$(&H8B) + CHR$(&H4F) + CHR$(5)       'mov cx,[bx+5] get int„asm$ = asm$ + CHR$(&H66) + CHR$(&H8B) + CHR$(&H57) + CHR$(7)'mov edx,[bx+7] get long„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC)     'mov bx,[bp+0c] first var„asm$ = asm$ + CHR$(&H66) + CHR$(&H89) + CHR$(&H7)     'mov [bx],eax„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'mov bx,[bp+0a] sec var„asm$ = asm$ + CHR$(&H89) + CHR$(&HF)                  'mov [bx],cx„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08] third var„asm$ = asm$ + CHR$(&H66) + CHR$(&H89) + CHR$(&H17)    'mov [bx],edx„„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)      'retf 8„'________________________________________„Codeoff% = SADD(asm$)„DEF SEG = VARSEG(asm$)„CALL absolute(a&, b%, c&, test, Codeoff%)„'________________________________________„DEF SEG„COLOR 0, 7: PRINT "TYPE PASSING INFORMATION": COLOR 7, 0: PRINT :„COLOR 0, 7: PRINT "TYPE passed to the stack as test:"„PRINT "CALL ABSOLUTE (a&,b%,c&,test,codeoff%)"„COLOR 7, 0: PRINT "BX is initialized as BX = [BP+06]"„PRINT "After that:"„PRINT "First variable (MKL-ed string at [BX]) : "; MKL$(a&)„PRINT "Second variable(integer at [BX+5])     : "; HEX$(b%)„PRINT "Third variabele( long at [BX+7])       : "; HEX$(c&)„PRINT "The control values of string, int and long are   :"; : COLOR 0, 7:„PRINT test.astring; " "; HEX$(test.ainteger); "  "; HEX$(test.along)„COLOR 7, 0„„„END SUB„Rick Elbers                    ASSEMBLY IN QBASIC 4: DATA     rick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        800  34775    4DATA.BAS   'ASSEMBLY IN QBASIC PART 4: USING DATASEGMENTS„'----------------------------------------------„'Rick Elbers november 1996, revised in februari 1997„„DEFINT A-Z„DECLARE SUB appenddatademo ()„DECLARE SUB sectorread (dgroup())„DECLARE FUNCTION shell86qb$ ()„DECLARE FUNCTION getfile$ ()„DECLARE FUNCTION readboot3$ ()„DECLARE FUNCTION readsec4$ ()„DECLARE FUNCTION getdir$ ()„DECLARE FUNCTION datetime$ ()„DECLARE SUB stackdemo ()„DECLARE SUB nodatastring ()„DECLARE SUB dosprstr (string2write$)„„„'This short article is ment as a follow up on STEPHAN van Loendersloot's„'INTERRUPTS IN QBASIC in this directory. He described the very first step„'in calling CALL ABSOLUTE and this article will introduce the logical„'second step. It will very basically describe the way in which you can„'use DATAS in your assembler subs.„„'***************„'INTRODUCTION„'***************„'Every program ( well at least most) consist not only of code, but operates„'on some datas. Same goes for assembly functions that you call from QBASIC.„'That is why it is very important to thoroughly consider how you could do„'that, and what method you should use in which instance.„„'In general this article will distinguish the following use of DATAS in„'incrementing usefullness, complexity:„„'A) Use an array or string to store a bunch of DATA and:„'A1)Pass it to your asm function through the stack :„'   Initialization possible, hardcoding impossible,„'   Uses segment overrides for array's and strings,„'   Base/indexed adressing is not very simple.„'   [!For variables this is also the IAB method!]„„'B) Store DATA somewhere in your code "segment"  and:„'B1)Use asm$ storage  :„'   Initialization possible, hardcoding possible„'   Uses segment overrides for array's but not for strings„'   Base/indexed adressing is not very simple„'   [!This method is best in cases of stringprocessing!]„„'B2)Use asm() storage:„'   Initialization possible, hardcoding possible„'   Uses segment overrides for strings and array's„'   Base/indexed adressing simple„'   [!This method is best in cases of Base/indexed adressing!]„„'Shortly I will elaborate on each one, and a little bit longer on the com-„'bination of force/ problems in B1). Very rudimentair demonstrations will„'be provided. My choice is for very easy examples, since this is not about„'mastering advanced programs, but about mastering advanced technigues. At„'the risk that nobody will see the advantages of course.„„CLS : COLOR 0, 7: PRINT "DEMONSTRATING STACKPASSINGS..": COLOR 7, 0:„VIEW PRINT 3 TO 25„CALL stackdemo„„COLOR 0, 7: PRINT "DEMONSTRATING DGROUP USES..": COLOR 7, 0„VIEW PRINT 3 TO 25„CALL appenddatademo„„LOCATE 23, 1: PRINT "Good bye"„„END„„SUB appenddatademo„„'This will demonstrate the use of DATA by the way of appending them to„'your code. Its main use will be in the area of PARAMETER blocks, although„'you could use this method for the passing of STORAGE blocks too.„'In the approach in this section DATA SPACE is hardcoded so to speak.„'The actual parameters could be:„'1) HARDCODED (if they are not changing, or at least not in your program)„'2) PASSED and STORED with BASE/INDEXED adressing( if they change).„„'The demonstration will be again increasing in complexity. Starting off„'with a simple string hardcoding, we will move on to a special case of„'DATA BLOCKS: the passing of a block of PARAMETERS.„'First we will look into parameter blocks with mainly fixed values. Secondly„'we will discuss DATA passing with parameterblocks with mainly variable„'elements.„„'We will need some BASE/ INDEXED adressing of the parameter block„'inside our assembly procedure in the second case.„„'In the process we will adress the choice of storage of your assembly code„'in integers or strings, since it turns out that the main DATA TYPE could„'be the decisive element right there.„„'At that point we have gone through all basic DATA techniques and you are„'ready to understand even the most difficult of the ASSEMBLY routines in„'QBASIC like XMS/FLATMODE etc.„„'A)A HARDCODED PRINTSTRING:„COLOR 0, 7: PRINT "PRINTING A DGROUP STRING": COLOR 7, 0:„CALL nodatastring„„'This one will have you given a feeling for what hardcoding is all about.„'IF this string was the only one that you had to print in your program„'then hardcoding it, like in the above routine, is MUCH faster and CLEANER„'then passing it through the stack. In general: IF some parameter is not„'going to change in your program you must try to hardcode that parameter.„'Even better: if you have the chance to make a parameter static then you'll„'be advised to do so. Apart from that you do not have to pass the parameter,„'and that you save clocks inside your asm routine, you also keep a clean„'QBASIC program, and prevent passing errors[ like when you pass a wrong„'handle .... ]. Oke thats that about hardcoding. Lets move on to parameters.„„„'B)A HARDCODED STATIC PARAMETERBLOCK„„'The next step to be taken is hardcoding a parameterblock. We discussed„'earlier why hardcoding your parameterblock is favored over passing it time„'and again, certainly when it is almost a static paramblock.„'Of course the distinction between a static and a dynamic parameterblock„'is only gradually. Most parameterblocks require some sort of change in„'parameters, and most blocks have some possibilities for hardcoding too.„'We will start with a sectorread procedure for DOS 4+. This function works„'with an almost static parameterblock. There are a lot of things remarkable„'about this procedure so stay tuned. It's is getting difficult but rewarding„'right now...„„„'Initialize:„PRINT : PRINT : PRINT "Press a key for next demonstration": SLEEP: CLS„COLOR 0, 7: PRINT "READING A DGROUP SECTORBUFFER ON DOS 4 +": COLOR 7, 0:„„'****IMPORTANT: YOU NEED DOS 4+ FOR THIS DEMONSTRATION***********„DIM dgroup(280): CALL sectorread(dgroup())„DEF SEG = VARSEG(dgroup(0)):„„'Read a sector:„„sector& = 1„'Translate sector to unsigned long.„helplowbyte& = sector& AND &HFFFF&„lowbyte = helplowbyte& AND &H7FFF„lowbyte = lowbyte OR -(helplowbyte& AND &H8000):„„helphighbyte& = ((sector& AND &HFFFF0000) \ 65535) AND &HFFFF&„highbyte = helphighbyte& AND &H7FFF„highbyte = highbyte OR -(helphighbyte& AND &H8000)„„sector& = (lowbyte * 65536) OR highbyte„„CALL absolute(sector&, 512)„„FOR I = 0 TO 511„  PRINT HEX$(PEEK(I));„NEXT„DEF SEG„„'Of course the translation of the sector to unsigned should ideally also„'be done inside your asm routine( much much faster too) and you should„'have done some errorchecking , but all that would have made the asm routine„'even more difficult.„'As is ,the routine provides an excellent example of almost everything„'that is important for using DATA inside asm routines:„'1) Choice for integerstorage„'2) Choice for hardcoding AND the parameterblock AND the storagearray„'3) Choice and the way to use .386 instructions inside asm$ routine„'   [this one thanks to Gunther Ilzig and Erika Shulz!]„'4) Passing the dynamic parameter to the asm routine„'5) Putting the dynamic parameter by based adressing to the parameterblock„'I will go shortly into every point now..„„'1) CHOICE FOR INTEGERSTORAGE„'This routine reads out sectors. That is to say that it will read a mixture„'of stringdata and integer data. So whatever youre choice will be for storing„'the sector you have to translate integers to strings with CHR$ OR strings„'to integers with ASC.„'When you look shortly into that you will notice that ASC is much slower then„'CHR$ and in addition requires some byte additions. Added together that will„'make integerstorage the better choice for the storage of the sectors.„'You could make the comment here that having an INTEGER DATABLOCK has„'has nothing to do with the way you will store your assembly CODE. I hope„'to falsify that statement in the explanations below...My statement will be„'that you have to modulate your type of assembly CODE storage to the type of„'the DATA storage.„„'2)CHOICE FOR HARDCODING AND THE PARAMETERBLOCK AND THE STORAGEARRAY„'Since we are not going to write directly to the STORAGE DATA block, It„'is very well justified to hardcode that DATA block too. For easyness of„'reading it out I made the choice to put the DATAstore block BEFORE the„'asm routine( CODE) so that DATA STORAGE starts at offset 0.„„'When you want to CHANGE some DATAstore block directly( making it more like„'a parameter or variable block anyway) then I will NOT advise you to hardcode„'that the way I did it for sectorread. For instance when you have some„'sectorWRITE function and you had your DATA appended to the code like„'in the sector READ function then there is the risk that when you are filling„'the DATA BLOCK you in fact OVERWRITE your ASM CODE. And that will cause„'unpredictable effects when you execute the CALL ABSOLUTE. The same error in„'READING or PASSIVE functions will only give you the wrong output...„„'The general rule that seems to be emerging is that you pass variable DATA„'to the stack and that you hardcode AND the parameterblock itself AND an„'eventually passive DATAstore block itself AND all static parameters.„„'Hardcoding the parameter block is of course much better then passing it„'through the stack. You only need one segment/segment override, and less„'stackpassing between QBASIC and CALL ABSOLUTE. Furthermore you can change„'an eventually variable parameter inside your assembly routine in a simple„'way, where you should have to do that inside your QBASIC program otherwise.„„„'3) CHOICE AND THE WAY TO USE .386 INSTRUCTIONS INSIDE ASSEMBLY ROUTINE„'   [this one thanks to Gunther Ilzig and Erika Shulz!]„„'Since we are passing a long integer(sectornr&) to the asm routine, it pays„'really off to use 32 bit instructions here. In the two simple cases the 32„'bit equivalent of the 8086 instructions is just putting &h66 before the 8086„'instruction and that is that.„'So:„'mov ax,[bx] =&H8B &H7„'mov eax,[bx]=&H66 &H8B &H7„„'By using the extended registers you can fill the long integer at once!„'and store it to the parameterblock at once too. For comparison: in 8086 code„'you should have done something like:„'mov ax,[bx]„'mov dx,[bx+2]„'.....segment overrides„'mov [param:0],ax„'mov [param:2],dx„„'This is adding a few(g) cycles as you can see....Since the .386 codes are„'often applicable, I highly recommend that you read the other contributions„'by Gunther and Erika, since they will explain .386 coding in QBASIC in more„'detail.„„'4) PASSING THE DYNAMIC PARAMETER TO THE ASM ROUTINE„„'When you understood all that was above you will not be surprised that„'we passed the changing parameter sector& through the stack. THat way„'we can maintain a routine that can be initialized by only moving the„'changed parameter to the parameterblock.„„'C)A HARDCODED DYNAMIC PARAMETERBLOCK„„'There is not a separate example routine available for DYNAMIC parameter„'blocks, but the principles of them will be fully explained with reference„'to the dynamic part of the sectorread parameter block.„'While this example routine has an only a very little DYNAMIC part, the„'principles are the same for a more DYNAMIC parameterblock like in XMS/ EMS„'move functions. If you still wanna look at a more DYNAMIC parameterblock„'handling you should have a look at the RAM in QBASIC series.„„'5) STORING THE DYNAMIC PARAMETER BY BASED /INDEXED ADRESSING„„'As in other routines with more dynamic parameters then this sectorread, we„'move the sector& with a simple base displacement to its proper place in the„'parameterblock. This base ( or indexed) displacement is a thing that„'you always need when you have to fill a parameterblock. In a way it is„'the counterpart of hardcoding and the price you have to pay for all„'advantages of an hardcoded parameterblock as I pointed out above.„„'You should know that the segment override we did in this routine with„'push cs:pop ds is specific for integerstorage. When you are going to„'fixate a stringstorage like we did with the first printstring example„'in this part then you do not need a segment override since ds is pointing„'to the stringsegment by default.„„'When you understood the principles and choices from above you should not„'have a big trouble to understand more elaborate parameterblocks like in„'XMS move[ See for that: RAM IN QBASIC 3:XMS] and you have a few tools to„'use DATA inside your assembly routines and in addition some rules against„'which you can evaluate which way of DATA you could/ should use or is optimal.„„„„„END SUB„„DEFSNG A-Z„FUNCTION datetime$„'-------------------------------------------------„'This procedure gets the date and time of a file„„'STACKPASSING : DX, CX„'IN           : CX= HANDLE„'OUT          : DX=FFFF ERROR AND CX= ERRORCODE„'               ELSE DX= DATE„'                    CX = TIME„'--------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                              'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)                 'mov bp,sp„„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7E) + CHR$(&H6)     'mov di,[bp+06]„asm$ = asm$ + CHR$(&H8B) + CHR$(&H1D)                 'mov bx,[di] handle„asm$ = asm$ + CHR$(&HB8) + CHR$(&H0) + CHR$(&H57)     'mov ax,5700„asm$ = asm$ + CHR$(&HBA) + CHR$(&HFF) + CHR$(&HFF)    'mov dx,ffff set to error„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)                 'int 21„asm$ = asm$ + CHR$(&H73) + CHR$(&H2)                  'jnc +2 No error„asm$ = asm$ + CHR$(&H89) + CHR$(&HC1)                 'mov cx,ax > errorcode„asm$ = asm$ + CHR$(&H89) + CHR$(&HD)                  'mov [di],cx time or error„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'mov bx,[bp+08]„asm$ = asm$ + CHR$(&H89) + CHR$(&H17)                 'mov [bx],dx date„asm$ = asm$ + CHR$(&H5D)                              'pop bp„asm$ = asm$ + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)      'retf 4„datetime$ = asm$„END FUNCTION„„FUNCTION getdir$„'------------------------------------------------------------------„'This function returns the current directory from C:\„„'STACKPASSING: buffer$„'IN          : DS[SI] 65 byte buffer„„'OUT         : ERROR :LEFT$(buffer$,1)="G"„'                    :CVI(MID$(buffer$,2,1))= errorcode„'              ELSE  :buffer$=path offset C:\„„'------------------------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                           'push bp           4„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)              'mov bp,sp         1„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(6)    'mov bx,[bP+06]    1+9„asm$ = asm$ + CHR$(&H8B) + CHR$(&H77) + CHR$(&H2)  'mov si,[bx+2]     1+9„asm$ = asm$ + CHR$(&HB4) + CHR$(&H47)              'mov ah,47         1„asm$ = asm$ + CHR$(&H30) + CHR$(&HD2)               'mov dl,0 default  1„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)              'int 21            26„asm$ = asm$ + CHR$(&H72) + CHR$(&H4)               'JC +3 error!      1/3„asm$ = asm$ + CHR$(&H5D)                           'pop bp            4„asm$ = asm$ + CHR$(&HCA) + MKI$(2)                 'RETF 2            14„asm$ = asm$ + CHR$(&H89) + CHR$(&H4)               'mov [si],ax errorreturn!1+9„asm$ = asm$ + CHR$(&HEB) + CHR$(&HF8)              'jmp -9: finish    3„„getdir$ = asm$„END FUNCTION„„FUNCTION getfile$„'-----------------------------------------------------------------„'This function returns the directory in an array, without„'BASIC interference that is........„'„'STACKPASSING: DIR()„'IN          : seg( DIR()):46 search$„'OUT         : seg( DIR()):44 errorcode„'              seg( DIR()):126 files, zero terminated„'------------------------------------------------------------------„asm$ = ""„asm$ = asm$ + CHR$(&H55)                    'push bp          4„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)       'mov bp,sp        1„asm$ = asm$ + CHR$(&H6)                     'push es          3„asm$ = asm$ + CHR$(&H1E)                    'push ds          3„'SET DTA„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(6)'mov bx,[bp+06]1+9„asm$ = asm$ + CHR$(&HC5) + CHR$(&H17)       'lds dx,[bx]      6+5„asm$ = asm$ + CHR$(&H1E)                    'push ds          3„asm$ = asm$ + CHR$(&H7)                     'pop es           3„asm$ = asm$ + CHR$(&HB4) + CHR$(&H1A)       'mov  AH,1A       1„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)       'int  21          26„'FINDFIRST„asm$ = asm$ + CHR$(&H31) + CHR$(&HC9)       'xor cx,cx  attrib=0 1„asm$ = asm$ + CHR$(&HBA) + MKI$(46)         'mov  DX,offset(searchstring$)1„asm$ = asm$ + CHR$(&HB4) + CHR$(&H4E)       'mov  AH,4E       1„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)       'int  21          26„asm$ = asm$ + CHR$(&H72) + CHR$(&H15)       'JB +24 op:       1/3„asm$ = asm$ + CHR$(&HBF) + MKI$(126)        'mov di,offset(result$) 1„'DIRLOOP: ONLY FILENAMES„asm$ = asm$ + CHR$(&HBE) + MKI$(30)         'mov si,offset(DTAstringoff$) 1„'PRINTNAME:„asm$ = asm$ + CHR$(&HFC)                    'cld              2„asm$ = asm$ + CHR$(&HAC)                    'lodsb            5„asm$ = asm$ + CHR$(&HAA)                    'stosb            5„asm$ = asm$ + CHR$(&H84) + CHR$(&HC0)       'test AL,AL       1„asm$ = asm$ + CHR$(&H74) + CHR$(&H2)        'jz next entrance 1/3„asm$ = asm$ + CHR$(&HEB) + CHR$(&HF8)       'jmp printtname   3/1„'FIND NEXT ENTRANCE:„asm$ = asm$ + CHR$(&HB4) + CHR$(&H4F)       'mov ah, 4f       1„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)       'int 21           26„asm$ = asm$ + CHR$(&H73) + CHR$(&HEE)       'Jnc dirloop      3/1„'OP:„asm$ = asm$ + CHR$(&H1F)                    'pop ds            3„asm$ = asm$ + CHR$(&HA3) + MKI$(44)         'mov [errorcode],ax 6+1„asm$ = asm$ + CHR$(&H7)                     'pop es            3„asm$ = asm$ + CHR$(&H5D)                    'pop bp            4„asm$ = asm$ + CHR$(&HCA) + MKI$(2)          'retf 2            14„getfile$ = asm$„„END FUNCTION„„DEFINT A-Z„SUB nodatastring„'-----------------------------------„'Writing a simple com program„'CS=DS=ES„'IP=100 for comprograms„'-----------------------------------„'CS:100„asm$ = asm$ + CHR$(&HBA) + CHR$(&HB) + CHR$(&H1)'mov dx,10B  offset(string)„asm$ = asm$ + CHR$(&HB4) + CHR$(&H9)            'write $ delimited string„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)           'call dos„asm$ = asm$ + CHR$(&HB4) + CHR$(&H4C)           'exit shell„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)           'call dos„'CS:10B :STRING2WRITE„asm$ = asm$ + "Hello, world this is stand alone 'BASIC' Ahum...$"„„'1)EXECUTE this one as a com file„„OPEN "standbas.com" FOR BINARY AS #1„PUT #1, , asm$„CLOSE„„SHELL "standbas.com": PRINT :„„'2) EXECUTE this one inside QBASIC.„'The problems are not very easy , when you want to use some DATA inside„'your code "segment", since there is no easy way of finding out what„'the offset of the DATA is. And when you use a variable length string„'then the adress will be prone to garbage collection too.„'So what we have to do:„'1) DECLARE a fixed length string (length=CODE+DATA) to fixate the memadress.„'2) HARDCODE the offset of your data inside the CODE„'And then it works! and can be initialized too. Be sure not to use an array„'of fixed length strings, since they do not default to the stringsegment.„„DIM staticasm AS STRING * 50: Codeoff = VARPTR(staticasm$)„asm$ = ""„asm$ = asm$ + CHR$(&HBA) + MKI$(Codeoff + 8)'mov dx,offset(string2write)„asm$ = asm$ + CHR$(&HB4) + CHR$(&H9)         'mov ah,9„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)        'int 21„asm$ = asm$ + CHR$(&HCB)                     'retf„'STRING2WRITE:„asm$ = asm$ + "Hello, world this is intrepreted QBASIC!$"„„staticasm$ = asm$„DEF SEG = VARSEG(staticasm$): CALL absolute(Codeoff)„DEF SEG„„„„„END SUB„„SUB sectorread (dgroup())„'------------------------------------------------------------------------„'This routine reads one sector from the C:\ drive.„„'STACKPASSING : LONGSECTOR by reference„'IN           : LONGSECTOR„'OUT          : ERROR =FFFF+ errorcode„„'The sector is read into the parameterblock and the routine executed.„„„'--------------------------********---------------------------------------„'                          *DGROUP*„'                          ********„'0....  512   = sector buffer offset 0 for easy read out!„'512... 546   = assembly routine„'546....      = parameterblock as:„'                0:DW      = sector2start„'                4:W       = nrsector2read„'                6:DW      = offset:segment van buffer„'------------------------------------------------------------------------„'------------------------------------------------------------------------„'DGROUP:256*2 CODE„„asm$ = ""„asm$ = asm$ + CHR$(&H55)                          'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„asm$ = asm$ + CHR$(&H1E)                          'push ds„„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06]„asm$ = asm$ + CHR$(&H66) + CHR$(&H8B) + CHR$(&H7) 'mov eax,[bx] get the long„asm$ = asm$ + CHR$(&HBB) + MKI$(546)              'mov bx,offset(params)„asm$ = asm$ + CHR$(&HE) + CHR$(&H1F)              'push cs:pop ds  set DS„asm$ = asm$ + CHR$(&H66) + CHR$(&H89) + CHR$(&H7) 'mov dwordptr [bx],eax„asm$ = asm$ + CHR$(&HB8) + CHR$(&H2) + CHR$(&H0)  'mov ax,2= C:\ as drive„asm$ = asm$ + CHR$(&HB9) + CHR$(&HFF) + CHR$(&HFF)'mov cx,-1„asm$ = asm$ + CHR$(&HCD) + CHR$(&H25)             'int 25„asm$ = asm$ + CHR$(&H83) + CHR$(&HC4) + CHR$(&H2) 'add sp,2„„asm$ = asm$ + CHR$(&H1F)                          'pop ds„asm$ = asm$ + CHR$(&H5D)                          'pop bp„asm$ = asm$ + CHR$(&HCA) + MKI$(2)                'retf 2„„'Poke asm$ into the array!„DEF SEG = VARSEG(dgroup(0))„FOR I = 0 TO LEN(asm$) - 1: POKE I + 256 * 2, ASC(MID$(asm$, I + 1, 1)): NEXT„„'DGROUP:273*2 PARAMS:!„dgroup(273) = &H0: dgroup(274) = 0   '0:sectornr&„dgroup(275) = 1                       '4:1 sector to read„dgroup(276) = VARPTR(dgroup(0))      '6: offset buffer„dgroup(277) = VARSEG(dgroup(0))      '8: segment buffer„„„END SUB„„DEFSNG A-Z„FUNCTION shell86qb$„asm$ = ""„asm$ = asm$ + CHR$(&H55)                          'push bp„asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„asm$ = asm$ + CHR$(&H1E)                          'push ds„asm$ = asm$ + CHR$(&H6)                           'push es„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06]„asm$ = asm$ + CHR$(&HC4) + CHR$(&H1F)             'les bx,[bx]  ES[BX] points to params„asm$ = asm$ + CHR$(&H8B) + CHR$(&H7E) + CHR$(&H8) 'mov di,[bp+08]„asm$ = asm$ + CHR$(&HC5) + CHR$(&H15)             'lds dx,[di]  DS[DX] points to program„asm$ = asm$ + CHR$(&HB8) + CHR$(&H0) + CHR$(&H4B) 'mov ax,4B00 function„asm$ = asm$ + CHR$(&HCD) + CHR$(&H21)             'int 21      'DOS„asm$ = asm$ + CHR$(&H7)                           'pop es„asm$ = asm$ + CHR$(&H1F)                          'pop ds„asm$ = asm$ + CHR$(&H5D)                          'pop bp„'We are done?„asm$ = asm$ + CHR$(&HCA) + MKI$(4)                'retf 4„shell86qb$ = asm$„„END FUNCTION„„DEFINT A-Z„SUB stackdemo„„'This sub demonstrate the use of DATA by passing them through the stack.„'The demonstration will be increasing in complexity. Starting off with„'a simple variable passing, we will move on to the passing of string DATA„'and an array of DATA. If you are experiencing troubles with the way„'that different data are passed through the stack then you have to look„'at ASM IN QBASIC3:PASSING again. In this article the knowledge„'from that article is assumed.„„'Initializing„asm$ = datetime$: getcurdir$ = getdir$: buffer$ = SPACE$(65)„„'1) Passing DATA as a variable through the stack[Initialized function]„'**********************************************************************„filename$ = "c:\dos\qbasic.exe"„OPEN filename$ FOR BINARY AS #1„  cx = FILEATTR(1, 2)„  '________________________________________„  Codeoff = SADD(asm$)„  DEF SEG = VARSEG(asm$)„  CALL absolute(dx, cx, Codeoff)„  '________________________________________„  „CLOSE :„IF dx = &HFFFF THEN PRINT "Error nr: "; HEX$(cx); " encountered": EXIT SUB„PRINT "DATE of "; : COLOR 0, 7: PRINT UCASE$(filename$): COLOR 7, 0„PRINT "YEAR    "; : COLOR 0, 7: PRINT 1980 + (dx AND &HFE00) \ &H1FF: COLOR 7, 0„PRINT "MONTH   "; : COLOR 0, 7: PRINT (dx AND &H1E0) \ &H1F: COLOR 7, 0„PRINT "DAY     "; : COLOR 0, 7: PRINT (dx AND &H1F): COLOR 7, 0„„PRINT "TIME of "; : COLOR 0, 7: PRINT UCASE$(filename$): COLOR 7, 0„PRINT "HOURS   "; : COLOR 0, 7: PRINT (cx AND &HF800) \ &H7FF: COLOR 7, 0„PRINT "MINUTES "; : COLOR 0, 7: PRINT (cx AND &H7E0) \ &H1F: COLOR 7, 0„PRINT "SECONDS "; : COLOR 0, 7: PRINT 2 * (cx AND &H1F): COLOR 7, 0„„PRINT : PRINT "Press a key for next demonstration": SLEEP: CLS„„„'2) Passing DATA as a string through the stack[function initialized]„„  '________________________________________„  Codeoff = SADD(getcurdir$)„  CALL absolute(buffer$, Codeoff)„  '________________________________________„„„IF ASC(MID$(buffer$, 2, 1)) THEN„  PRINT "Current directory : "; : COLOR 0, 7: PRINT "C:\" + UCASE$(RTRIM$(buffer$));„  COLOR 7, 0„ELSE„  PRINT "Error getting directory nr: "; HEX$(CVI(LEFT$(buffer$, 2)))„END IF„„PRINT : PRINT : PRINT "Press a key for next demonstration": SLEEP: CLS„'Note that in this routine DS is used as default to stack/stringsegment and„'that slowness in errorretrieving with stringfunctions is offered for a„'faster OKE return.„„'***************************************************************************„'Very important for this discussion is that you notice that you should„'start to consider to hardcode the buffer into the routine, since you ALWAYS„'need to use a 65 byte buffer by default AND since stackpassing of an extra„'variable requires:„'-PUSHING an extra variable onto the stack by QBASIC„'-Extra CYCLES in your routine:„' mov bx,[bp+06];mov si,[bx] is taking up 1+9+1+5 ticks( 9 for base+disp calc)„' mov si,value requires 1 cycle!„'-POPPING an extra variable off the stack by QBASIC„'-In addition if the buffer is the ONLY variable to pass you can spare„' one extra cycle by RETF instead of RETF 2.„„'This extra cycles things are slightly less worse for segment passing like„'you will see in the next section. For the hardcoding you have to look for„'the DATAappend demonstrations.„'***************************************************************************„„'3) Passing DATA as an array through the stack[function initialized]„„'It is important that you understand that there are basically two reasons„'why some array is passed to an assembly routine:„„'1) To pass some parameters„'2) To allow some storage arrea.„„„'The difference's are big. For one thing the second array passing is easy,„'and often the passing of parameters is not. For another thing often the„'parameters have to be filled , be it in QBASIC or in the assembly routine,„'and the storage arrea is just passed as a pointer. Examples of the first„'array passings are EXEC, All MOVE memory functions for low memory,„'EMS, XMS, READSECTOR/ WRITESECTOR for DOS 4++, etc, etc. In general: the„'more difficult functions. Examples of the second array passings are much„'more easy, and MarkK covers a lot of them too. You should think of SETDTA,„'READFILE, READSECTOR/WRITESECTOR for DOS 4--, GET DPB, GET DISPLAYSTATE, etc.„„'1)PASSING an array for data storage[initialized]„„'Init and get big enough storage array( < 800 files):„Tasm$ = getfile$: DIM dirs(0) AS STRING * 10000„„'input:„COLOR 0, 7: PRINT "REDIRECTABLE DRIVE-/DIRECTORY-/FILE- SCANNER"„COLOR 7, 0: PRINT "(redirection example c:\>tmp.tmp)"„DEF SEG = &H40: POKE &H1C, PEEK(&H1A): DEF SEG„INPUT "Drive/directory/file to scan : ", fdir$„„'Valid strings to search ?„posi = INSTR(fdir$, ">"):„IF posi > 0 THEN dir$ = LEFT$(fdir$, posi - 1) ELSE dir$ = fdir$„IF INSTR(dir$, ".") <> 0 THEN„  MID$(dirs$(0), 47) = dir$ + "0"„ELSEIF RIGHT$(dir$, 1) <> "\" THEN„  MID$(dirs$(0), 47) = dir$ + "\*.*0"„ELSE„  MID$(dirs$(0), 47) = dir$ + "*.*0"„END IF„„DEF SEG = VARSEG(Tasm$): CALL absolute(dirs(), SADD(Tasm$))„„VIEW PRINT 5 TO 24„DEF SEG = VARSEG(dirs(0)): j = dataoff + 127: k = INSTR(j, dirs(0), CHR$(0) + CHR$(0))„„IF posi <> 0 THEN    'redirection„„  OPEN MID$(fdir$, posi + 1) FOR OUTPUT AS #1„  IF PEEK(44) = 3 THEN„    PRINT #1, "ongeldig pad"„  ELSEIF PEEK(&H16) = 0 AND PEEK(&H17) = 0 THEN„    PRINT #1, "bestand niet gevonden"„  ELSE„    PRINT #1, MID$(dirs(0), j, k - j)„  END IF„„  CLOSE„„'no redirection„ELSE„„  IF PEEK(44) = 3 THEN„    PRINT "ongeldig pad"„  ELSEIF PEEK(&H16) = 0 AND PEEK(&H17) = 0 THEN„    PRINT "bestand niet gevonden"„  ELSE„„  LOCATE 5, 32: COLOR 0, 7: PRINT UCASE$(fdir$):„  VIEW PRINT 6 TO 24: COLOR 7, 0: PRINT MID$(dirs(0), j, k - j);„ „  END IF„DEF SEG„END IF„PRINT CHR$(27)„PRINT : PRINT : PRINT "Press a key for next demonstration": SLEEP:„VIEW PRINT 3 TO 24: CLS 2„„'Note that in this routine there was already some parameter APPENDED to the„'code: the search string. It will be very instructive to look at what changes„'you should make just to PASS the search$ THROUGH the STACK too. You have to„'save DS, set DS to the stringsegment again. Execute a findfirst and RESET DS„'again. Apart from the actual stackpassing that is.„„'************************************************************************„'But the topic of interest was STACKPASSING of an DATAarray for storage.„'We passed the DATAS() and it was filled by the assembly routine. With„'our way of passing the array we have modificated MarkK's method:„'-Instead of passing segment AND offset we passed array()„„'That way we have spared:„'-PUSHING an extra variable onto the stack by QBASIC„'-Extra CYCLES in the routine:„' 2*(mov bx,[bp+06];mov si,[bx] is taking up 2*(1+9+1+5) ticks„' mov bx,[bp+06];lds dx,[bx] is taking up 1+9+7+5 ticks„'-POPPING an extra variable off the stack by QBASIC„„'This routine points to hardcoding the DATAS too, since it could be an„'static space in memory. For the savings you can get by that you have to„'look back to the printstring example before.„'************************************************************************„„'2)PASSING an array for parameters passing[initialized]„„'Until now this article has been pretty straightforward, but now it becomes„'difficult, when we are going to adress the topic of parameterpassing. Not„'only are there different methods to be considered there, also the particular„'functions that need parameterpassing are among the most difficult functions„'existent.„„'It is important to realize that when you pass another (sub)procedure to an„'assembly procedure, that is nothing more then a special case of parameter„'passing. In a later article ASM IN QBASIC 5: PROCS I will get into„'Procedures and there passing into more detail. At this moment we will look„'into a more plain example of parameterpassing: LOAD and EXECUTE. As an„'example of parameter passing the LOAD and EXECUTE function is extremely„'usefull, since it eats no less then TWO parameterblocks.„„„'Initializing:„asm$ = shell86qb$:„DEF SEG = &H40: POKE &H1C, PEEK(&H1A): DEF SEG„PRINT "Give me please the programname with extension ?  ";„DO UNTIL progname$ <> "": COLOR 0, 7: LINE INPUT ; progname$: LOOP„COLOR 7, 0: PRINT "Give the parameters please ? ";„COLOR 0, 7: LINE INPUT ; parameters$: COLOR 7, 0„CLS : PRINT "We shelled from QBasic to: "; : COLOR 0, 7: PRINT progname$:„COLOR 7, 0: PRINT "With the parameters passed :"; : COLOR 0, 7: PRINT parameters$„COLOR 7, 0: PRINT STRING$(80, "_")„VIEW PRINT 5 TO 22„'--------------------------------„'1) PROGRAMNAME BLOCK TO DS[DX]:„'--------------------------------„exec$ = progname$ + "0": l = LEN(exec$): DIM exename((l / 2) + 1)„DEF SEG = VARSEG(exename(0)):„FOR I = 0 TO l - 1: POKE I, ASC(MID$(exec$, I + 1, 1)): NEXT:„'---------------------------------------------------------------------------„'2) PARAMETERBLOCK TO ES[BX]:„'----------------------------„'a)Parameterblock overview:„'----------------------------„'0  W  pointer to environment (0= default dos environment)„'2  DW pointer to commandtail„'6  DW FCB1 pointer„'10 DW FCB2 pointer„'14 FCB=20*nul„'34 Commandtail„'--------------„'Commandtail:„'--------------„commandtail$ = " " + parameters$:„param$ = CHR$(LEN(commandtail$)) + commandtail$ + CHR$(13)„DIM parameter(7 + LEN(param$) + 10):„es = VARSEG(parameter(0)): bx = VARPTR(parameter(0))„'-----------------------------------------------------------„'Filling the parameterblock„'----------------------------„DEF SEG = es:„parameter(0) = 0                                       'default environ„parameter(1) = bx + 34: parameter(2) = es           'ptr > commandtail„parameter(3) = bx + 14: parameter(4) = es           'ptr >FCB 1„parameter(5) = bx + 14: parameter(6) = es           'ptr >FCB2„„FOR I = bx + 14 TO bx + 33: POKE I, 0: NEXT         'FCB's„FOR I = 1 TO LEN(param$):„  POKE bx + 33 + I, ASC(MID$(param$, I, 1)):         'Commandtail„NEXT„„DEF SEG = VARSEG(asm$)„offcode = SADD(asm$): CALL absolute(exename(), parameter(), offcode):„DEF SEG„VIEW PRINT: LOCATE 23, 1„PRINT : PRINT "Press a key for DGROUP demonstrations": SLEEP: CLS„„'This routine provided us with a nice example for parameterpassing, but you„'should have realized it is far from ideal.„'1) Since a lot of entrances in the parameters() will never change ,at least„'   these entrances could be hardcoded.„'2) Furthermore you will hate the way you have to handle the commandline in„'   QBASIC, and when you add to that the knowledge that the maximum length of„'   the commandline$ is fixed at 128 bytes[PSP won't allow more], you are„'   even more driven towards hardcoding space for the commandline inside„'   youre assembly routine too.„„'At this moment the contours of a brand new approach are beginning to take„'form..„'In the end ,the only thing that your optimized routine will do is pass the„'commandtail and params as a string to the assembly routine and the assembly„'routine will handle the rest. In addition to that, both parameterblocks will„'be placed inside your stringsegment, so you only need to override ES.„„'How all of this is possible and why it is the optimized way to go will be„'explained in the next section about appending DATA. For now it is enough„'when you know what the trigger was to develop that approach..„„„END SUB„„RRick Elbers                    ASSEMBLY IN QBASIC 5: PROCS    rick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        568  25682    5PROCS.BAS  'ASSEMBLY IN QBASIC PART 5: USING A PROCEDURE SEGMENT„'-------------------------------------------------------„'Rick Elbers november 1996, modificated februari 1997[]                                                           „„DEFSTR A„DEFINT B-Z„DECLARE FUNCTION asmcaller ()„DECLARE SUB biosvideo (vidbase, prnstr, main)„DECLARE SUB neardemo ()„DECLARE SUB fardemo ()„„'------------„'INTRODUCTION„'------------„'Procedures. When you have taken a short look at assembly programs then you„'know that asm is generally flooded with it. That is why we need a way to„'handle procedures inside our asm functions if we want to do anything even„'remotely advanced.„'The first distinction to keep in mind when speeking about procedures is the„'destinction between FAR and NEAR procedures. Near procedures are procs that„'are procedures in the same SEGMENT and can be CALLED with a NEAR CALL like:„„'NEAR CALLS  examples   clocks  FAR CALLS  examples         clocks„„'CALL relat  CALL 100   3(!)               CALL 1234:FFFF    3„'CALL reg    CALL BX    5                  ES:CALL  [BX]     2+10„'CALL [reg]  CALL [BX]  10+(5 for 32 bits) CALL FAR [BX]     18„'return with:„'RET         RET        5(!)               RETF              13„„'From the above you should have noticed that based/indexed 16 bit calling„'is much less cheap then relative calling. However the base/indexed calling„'is much more flexible of course since you do not need to hardcode or„'calculate the relative/ absolute adress. Next thing you could have noticed„'is that relative adressing is cheaper then absolute adressing. The meaning„'of that is that when you have hardcoded procedures then you should use„'relative adressing. A last thing you could learn from the above is that„'NEAR CALLING/RETURNING is very much favored over FAR CALLING/ RETURNING.„'You only have to compare the RETF(13) with RET(5) to see what I mean. The„'situation for FAR CALLS is much alike of course since there is additional„'pushing/ popping of the segment needed as well as a far jump.„„'For QBASIC when you use stringstorage ALL procedures are near procedures„'by default. When you use integerstorage ONLY the procedures in the same„'array are near procedures and the others are far. It should be very clear„'by now that you should avoid using FAR procedures. But that is not always„'possible. The two reasons to use FAR procedures are:„„'1) You have to CALL some FAR driver/TSR/INTERRUPT routine etc..„'2) You are to lazy to put all your procs into one asm%() << not supported.„„'NEAR PROCEDURES„'****************„'Now that we made clear that basically we need a way to handle NEAR„'PROCEDURES, the next important point is the FLEXIBLILITY that you need.„'Basically there exist the following ways to handle near procedures:„„'1)DGROUP APPROACH: Fast, easy to calculate entries.„'                   Don't need fixed assembly storage„'                   However, not flexible: needs hardcoded CALLS.„'2)STACK APPROACH : Slower, have to know entrie of procs„'                   Need fixed assembly storage„'                   However, is more flexible: needs no hardcoded CALLS„'                   Needs a assembly caller procedure with FAR return.„„'The first approach is closely related to the DATA DGROUP approach, and is„'favored when you either run through a FIXED pattern of procs or you have„'decisions as to which proc to use in your asm code.„'The second approach is favored when you want to handle CONCURRENT procs.„'Say that you want to print a string OR replace a part of a string AND„'then print that part depending on some QBASIC code. In that case you„'should use the second approach.„„'Since we know we can fixate a string in memory it is not necessary any„'different if you use integerstorage or stringstorage of youre assembly„'procedures. I will only elaborate on one of them.„„CALL neardemo„„'***************„'FAR PROCEDURES„'***************„'As have been said before the only reason why you should FAR calls instead„'of near calls is when that type of calling is forced upon you by for„'instance a dos extender, a TSR, some driver like HIMEM, EMM386 etc..„„CALL fardemo„„„„„„END„„DEFSNG B-Z„FUNCTION asmcaller„'--------------------------------------„'This function constitutes a minimal„'structure for calling asm procs..„'-------------------------------------„„asm = ""„asm = asm + CHR$(&H55)                          'push bp„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„„asm = asm + CHR$(&HBE) + MKI$(&HA)              'mov si,a„asm = asm + CHR$(&H8B) + CHR$(&H1A)             'mov bx,[bp+si]„asm = asm + CHR$(&HFF) + CHR$(&H17)             'call [bx] vidbase„asm = asm + CHR$(&HBE) + MKI$(8)                'mov si,8„asm = asm + CHR$(&H8B) + CHR$(&H1A)             'mov bx,[bp+si]„asm = asm + CHR$(&HBE) + MKI$(6)                'mov si,6  point to string„asm = asm + CHR$(&HFF) + CHR$(&H17)             'call [bx] print direct„asm = asm + CHR$(&H89) + CHR$(&HEC)             'mov sp,bp„asm = asm + CHR$(&H5D)                          'pop bp„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6„„asmcaller = asm„END FUNCTION„„DEFINT B-Z„SUB biosvideo (vidbase, prnstr, main)„„'This procedure is the start of a BIOS print dispatcher.„'It needs a little bit elaboration to make it really useful„'an sich, but it gives you the idea what sort of programs„'you can get with structured programming in asm....„„'STACKPASSING STRING1,STRING2„„'This is a very fast printstring procedure, since the„'cursor is only updated at the end of all printing jobs„'and since even the page offset is only updated on request...„„'Initializing:„„DIM asmstore AS STRING * 1000: datas = VARPTR(asmstore)„asm = ""„„'DATA:„asm = asm + MKI$(0)                               '0:OFFSET PAGE„asm = asm + MKI$(0)                               '2:VIDEOSEGMENT„asm = asm + MKI$(0)                               '4:CURRENT CURSORPOS row:col„asm = asm + MKI$(0)                               '6:UPDATED PAGEOFFSET„asm = asm + MKI$(0)                               '8:OFFSET IN VIDEOPAGE„asm = asm + CHR$(0)                               'a:PAGENR„„„'--------------------*****************------------------„'                    *GETVIDBASE PROC*„'                    *****************„'SUBROUTINE : GET THE VIDEOBASE„'IN         : DI points to DATA„'USES       : AX,ES„'WRITES     : VIDEOSEG,VIDEOOFF„'OUT        : BH POINTS TO PAGENR.„vidbase = LEN(asm)„'-------------------------------------------------------„'CODE„asm = asm + CHR$(&H50)                            'PUSH AX„asm = asm + CHR$(&H6)                             'PUSH ES„„asm = asm + CHR$(&HBF) + MKI$(datas)              'MOV DI,OFFSET(DATA)„asm = asm + CHR$(&HB8) + CHR$(&H40) + CHR$(&H0)   'MOV AX,40„asm = asm + CHR$(&H8E) + CHR$(&HC0)               'MOV ES,AX„asm = asm + CHR$(&H26)                            'ES:„asm = asm + CHR$(&HA1) + MKI$(&H4E)               'MOV AX,[4E]„asm = asm + CHR$(&H89) + CHR$(&H5)                'MOV [DI],AX pageoffset„asm = asm + CHR$(&H26)                            'ES:„asm = asm + CHR$(&H8A) + CHR$(&H26) + MKI$(&H62)  'MOV AH,[62]„asm = asm + CHR$(&H88) + CHR$(&H65) + CHR$(&HA)   'MOV [DI+A],AH pagenr„asm = asm + CHR$(&H26)                            'ES:„asm = asm + CHR$(&HA0) + CHR$(&H10) + CHR$(&H0)   'MOV AL,[10]„asm = asm + CHR$(&H24) + CHR$(&H30)               'AND AL,30„asm = asm + CHR$(&H3C) + CHR$(&H30)               'CMP AL,30„asm = asm + CHR$(&H74) + CHR$(&H9)                'JZ MONOchr$OME„asm = asm + CHR$(&HB8) + CHR$(&H0) + CHR$(&HB8)   'MOV AX,B800„asm = asm + CHR$(&H89) + CHR$(&H45) + CHR$(&H2)   'MOV [DI+2],AX vidseg„asm = asm + CHR$(&H7)                             'POP ES„asm = asm + CHR$(&H58)                            'POP AX„asm = asm + CHR$(&HC3)                            'RET„asm = asm + CHR$(&HB8) + CHR$(&H0) + CHR$(&HB0)   'MOV AX,B000„asm = asm + CHR$(&HEB) + CHR$(&HF5)               'JMP -11„'GETVIDBASE ENDP:„„'-----------------****************----------------------„'                 *GETCURSOR PROC*„'                 ****************„'SUBROUTINE : GET THE CURSOR POSITION„'IN         : DI points to DATA„'USES       : AX,BX„'WRITES     : CURSORPOSITION DATA„'OUT        :„getcurs = LEN(asm)„'-------------------------------------------------------„asm = asm + CHR$(&H50)                            'PUSH AX„asm = asm + CHR$(&H53)                            'PUSH BX„asm = asm + CHR$(&H52)                            'PUSH DX„„asm = asm + CHR$(&H8A) + CHR$(&H7D) + CHR$(&HA)   'MOV BH,[DI+A] pagenr„asm = asm + CHR$(&HB4) + CHR$(&H3)                'MOV AH,03„asm = asm + CHR$(&HCD) + CHR$(&H10)               'INT 10„asm = asm + CHR$(&H89) + CHR$(&H55) + CHR$(&H4)   'MOV [DI+4],DX cursorpos„„asm = asm + CHR$(&H5A)                            'POP DX„asm = asm + CHR$(&H5B)                            'POP BX„asm = asm + CHR$(&H58)                            'POP AX„asm = asm + CHR$(&HC3)                            'RET„'GETCURSOR ENDP:„„'-----------------********************----------------------„'                 *OFFSET2CURSOR PROC*„'                 ********************„'SUBROUTINE : UPDATES THE CURSOR POSITION FROM THE PAGE OFFSET„'IN         : DI points to DATA„'USES       : AX,CX„'READS      : OFFSET IN VIDEOPAGE„'WRITES     : CURSORPOSITION„'OUT        :„updcurs = LEN(asm)„'-----------------------------------------------------------„asm = asm + CHR$(&H50)                            'PUSH AX„asm = asm + CHR$(&H51)                            'PUSH CX„„asm = asm + CHR$(&H8B) + CHR$(&H45) + CHR$(8)     'MOV AX,[DI+08]pageoffset„asm = asm + CHR$(&HD1) + CHR$(&HE8)               'SHR AX,1 offset/2=chars„asm = asm + CHR$(&HB1) + CHR$(&H50)               'MOV CL,50 for div„asm = asm + CHR$(&HF6) + CHR$(&HF1)               'DIV CL col to AH row to AL!„asm = asm + CHR$(&H88) + CHR$(&HC5)               'MOV CH,AL row to DH„asm = asm + CHR$(&H88) + CHR$(&HE1)               'MOV CL,AH column to DL„asm = asm + CHR$(&H89) + CHR$(&H4D) + CHR$(&H4)   'MOV [DI+4],CX  cursorpos„„asm = asm + CHR$(&H59)                            'POP CX„asm = asm + CHR$(&H58)                            'POP AX„asm = asm + CHR$(&HC3)                            'RET„'OFFSET2CURSOR ENDP:„'-----------------********************----------------------„'                 *CURSOR2OFFSET PROC*„'                 ********************„'SUBROUTINE : UPDATES THE PAGE OFFSET FROM THE CURSOR POSITION„'IN         : DI points to DATA„'USES       : AX,CX„'READS      : OFFSET IN VIDEOPAGE„'WRITES     : CURSORPOSITION„'OUT        :„crs2off = LEN(asm)„'-----------------------------------------------------------„asm = asm + CHR$(&H50)                            'PUSH AX„asm = asm + CHR$(&H51)                            'PUSH CX„„asm = asm + CHR$(&H8B) + CHR$(&H4D) + CHR$(4)     'MOV CX,[DI+04]cursorpos„asm = asm + CHR$(&HB8) + MKI$(&H50)               'MOV AX,50 for mul„asm = asm + CHR$(&HF6) + CHR$(&HE5)               'MUL CH    (row *&h50„asm = asm + CHR$(&H81) + CHR$(&HE1) + MKI$(&HFF)  'AND CX,&HFF   +„asm = asm + CHR$(&H1) + CHR$(&HC8)                'ADD AX,CX  column)„asm = asm + CHR$(&HD1) + CHR$(&HE0)               'SHL AX,1     *2„asm = asm + CHR$(&H89) + CHR$(&H45) + CHR$(&H8)   'MOV [DI+8],AX pageoffset„„asm = asm + CHR$(&H59)                            'POP CX„asm = asm + CHR$(&H58)                            'POP AX„asm = asm + CHR$(&HC3)                            'RET„'CURSOR2OFFSET ENDPROC:„„'-----------------****************--------------------------„'                 *SETCURSOR PROC*„'                 ****************„'SUBROUTINE : SETS THE CURSOR POSITION„'IN         : DI points to DATA„'USES       : AX,BX„'WRITES     : CURSORPOSITION DATA„'OUT        :„setcurs = LEN(asm)„'------------------------------------------------------------„asm = asm + CHR$(&H50)                            'PUSH AX„asm = asm + CHR$(&H53)                            'PUSH BX„asm = asm + CHR$(&H52)                            'PUSH DX„„asm = asm + CHR$(&H8B) + CHR$(&H55) + CHR$(4)     'MOV DX,[DI+4]cursorpos„asm = asm + CHR$(&H8A) + CHR$(&H7D) + CHR$(&HA)   'MOV BH,[DI+A]pagenr„asm = asm + CHR$(&HB4) + CHR$(&H2)                'MOV AH,02„asm = asm + CHR$(&HCD) + CHR$(&H10)               'INT 10„„asm = asm + CHR$(&H5A)                            'POP DX„asm = asm + CHR$(&H5B)                            'POP BX„asm = asm + CHR$(&H58)                            'POP AX„asm = asm + CHR$(&HC3)                            'RET„'SETCURSOR ENDP:„„'-----------------**************--------------------------„'                 *PRINT STRING*„'                 **************„'SUBROUTINE : PRINTS A STRING USING THE BIOS FUNCTION„'IN         : DI points to DATA,BP+SI to string„'USES       : AX,BX,CX,DX,ES,BP„'WRITES     : STRING„'OUT        :„prnstr = LEN(asm)„'------------------------------------------------------------„'Get string length set DS[si] to adress:„asm = asm + CHR$(&H6)                          'PUSH ES„asm = asm + CHR$(&H50)                         'PUSH AX„asm = asm + CHR$(&H53)                         'PUSH BX„asm = asm + CHR$(&H51)                         'PUSH CX„asm = asm + CHR$(&H52)                         'PUSH DX„asm = asm + CHR$(&H55)                         'PUSH BP„„asm = asm + CHR$(&H8B) + CHR$(&H1A)            'MOV BX,[BP+SI]„asm = asm + CHR$(&H8B) + CHR$(&H6F) + CHR$(&H2)'MOV BP,[BX+2] sadd„asm = asm + CHR$(&HE) + CHR$(&H7)              'PUSH CS:POP ES ES[BP]string„asm = asm + CHR$(&H8B) + CHR$(&HF)             'MOV CX,[BX]   length„asm = asm + CHR$(&HB3) + CHR$(&H70)            'MOV BL,70  attribute„asm = asm + CHR$(&H8A) + CHR$(&H7D) + CHR$(&HA)'MOV BH,[DI+A]pagenr„asm = asm + CHR$(&H8B) + CHR$(&H55) + CHR$(4)  'MOV DX,[DI+4]cursorpos„asm = asm + CHR$(&HB8) + CHR$(&H0) + CHR$(&H13)'MOV AX,1300„asm = asm + CHR$(&HCD) + CHR$(&H10)            'INT 10„„asm = asm + CHR$(&H5D)                         'POP BP„asm = asm + CHR$(&H5A)                         'POP DX„asm = asm + CHR$(&H59)                         'POP CX„asm = asm + CHR$(&H5B)                         'POP BX„asm = asm + CHR$(&H58)                         'POP AX„asm = asm + CHR$(&H7)                          'POP ES„asm = asm + CHR$(&HC3)                         'RET„'PRINTSTRING ENDP:„„'-----------------*******************----------------------„'                 *PRINT DIRECT PROC*„'                 *******************„'SUBROUTINE : PRINTS DIRECTLY TO THE SCREENSEGMENT„'IN         : DI points to DATA,BP+SI TO STRING„'USES       : AX,BX,CX,SI,DI,ES„'READS      : LENGTH OF STRING, OFFSET IN VIDEOBUFFER:PAGE„'WRITES     : STRING, CURSORPOSITION DATA ,VIDEOSEGMENT:OFFSET DATA„'OUT        :„prndir = LEN(asm)„'-----------------------------------------------------------„asm = asm + CHR$(&H6)                          'PUSH ES„asm = asm + CHR$(&H50)                         'PUSH AX„asm = asm + CHR$(&H53)                         'PUSH BX„asm = asm + CHR$(&H51)                         'PUSH CX„asm = asm + CHR$(&H56)                         'PUSH SI„asm = asm + CHR$(&H57)                         'PUSH DI„'Get string length set DS[si] to adress:„asm = asm + CHR$(&H8B) + CHR$(&H1A)            'MOV BX,[BP+SI]„asm = asm + CHR$(&H8B) + CHR$(&H77) + CHR$(&H2)'MOV SI,[BX+2] DS[SI]string„asm = asm + CHR$(&H8B) + CHR$(&HF)             'MOV CX,[BX]   CX length„asm = asm + CHR$(&H8B) + CHR$(&H45) + CHR$(8)  'MOV AX,[DI+08]pageoffset„'adjust string to 'onscreen' length..„asm = asm + CHR$(&HBB) + MKI$(&H1000)          'MOV BX,&H1000 end page„asm = asm + CHR$(&H29) + CHR$(&HC3)            'SUB BX,AX  space on page„asm = asm + CHR$(&HD1) + CHR$(&HEB)            'SHR BX,1   char space on p„asm = asm + CHR$(&H39) + CHR$(&HD9)            'CMP CX,BX  string fits ?„asm = asm + CHR$(&H72) + CHR$(&H2)             'JB OKE +2  yes:oke„asm = asm + CHR$(&H89) + CHR$(&HD9)            'MOV CX,BX  no: adjust length„'Set ES[DI] to current videooffset„asm = asm + CHR$(&HC4) + CHR$(&H3D)            'LES DI,[DI] start off page„asm = asm + CHR$(&H1) + CHR$(&HC7)             'ADD DI,AX  add the pageoffset„'Copy the string to the screen:„asm = asm + CHR$(&HFC)                         'CLD„asm = asm + CHR$(&HA4)                         'MOVSB„asm = asm + CHR$(&H47)                         'INC DI skipp attribute„asm = asm + CHR$(&H49)                         'DEC CX„asm = asm + CHR$(&H75) + CHR$(&HFB)            'JNZ -5„'And store new page offset„asm = asm + CHR$(&H89) + CHR$(&HFB)            'MOV BX,DI current offset„asm = asm + CHR$(&H5F)                         'POP DI„asm = asm + CHR$(&H2B) + CHR$(&H5)             'SUB BX,[DI] in page„asm = asm + CHR$(&H89) + CHR$(&H5D) + CHR$(&H6)'MOV [DI+6],BX„„asm = asm + CHR$(&H5E)                         'POP SI„asm = asm + CHR$(&H59)                         'POP CX„asm = asm + CHR$(&H5B)                         'POP BX„asm = asm + CHR$(&H58)                         'POP AX„asm = asm + CHR$(&H7)                          'POP ES„asm = asm + CHR$(&HC3)                         'ret„'PRINTdirect ENDP:„'-----------------********************--------------------------„'                 *UPDATEOFFSET PROC*„'                 ********************„'SUBROUTINE : UPDATES THE VIDEOPAGEOFFSET„'IN         : DI points to DATA„'USES       : AX„'READS      : NEW PAGEOFFSET„'WRITES     : PAGEOFFSET„'OUT        :„updoffs = LEN(asm)„'------------------------------------------------------------„asm = asm + CHR$(&H50)                            'PUSH AX„„asm = asm + CHR$(&H8B) + CHR$(&H45) + CHR$(6)     'MOV AX,[DI+6]updated„asm = asm + CHR$(&H89) + CHR$(&H45) + CHR$(8)     '[DI+8],AX    pageoffset„„asm = asm + CHR$(&H58)                            'POP AX„asm = asm + CHR$(&HC3)                            'RET„'UPDATEOFFSET ENDP:„„'MAIN:„'-----------------****************------------------------------------------„'                 *MAIN PROCEDURE*„'                 ****************„'MAIN ROUTINE : PRINTS DIRECTLY TO THE SCREENSEGMENT AND UPDATES CURSOR„'IN           : A STRING IS PUSHED ONTO THE STACK„'USES         : BP,DX, GETVIDEOBASE,SETCURSOR,PRINTDIRECT,GETCURSOR„main = LEN(asm)„'-------------------------------------------------------------------------„asm = asm + CHR$(&H55)                                 'PUSH BP„asm = asm + CHR$(&H89) + CHR$(&HE5)                    'MOV BP,SP„asm = asm + CHR$(&HBF) + MKI$(datas)                   'MOV DI,OFFSET(DATA)„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + vidbase) 'CALL GETVIDEOBASE„asm = asm + CHR$(&HBA) + MKI$(&H0)                     'MOV DX,CURSORPOS„asm = asm + CHR$(&H89) + CHR$(&H55) + CHR$(4)          'MOV [DI+4],DX„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + setcurs) 'CALL SETCURSOR„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + crs2off) 'CALL CURSOR2OFFSET„asm = asm + CHR$(&HB9) + MKI$(250)                     'MOV CX,250„'LOOPING....„asm = asm + CHR$(&HBE) + MKI$(6)                       'MOV SI,6„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + prndir)  'CALL PRINTDIRECT„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + updoffs) 'CALL UPDATEOFFSET„asm = asm + CHR$(&HBE) + MKI$(8)                       'MOV SI,8„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + prndir)  'CALL PRINTDIRECT„asm = asm + CHR$(&HE2) + CHR$(&HEF)                    'LOOP -20„'ENDING...„asm = asm + CHR$(&HBE) + MKI$(6)                       'MOV SI,6„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + prndir)  'CALL PRINTDIRECT„'asm = asm + chr$(&HE8) + mki$(-3 - LEN(asm) + updcurs)'CALL UPDATECURSOR„asm = asm + CHR$(&HE8) + MKI$(-3 - LEN(asm) + setcurs) 'CALL SETCURSOR„asm = asm + CHR$(&H89) + CHR$(&HEC)                    'MOV SP,BP„asm = asm + CHR$(&H5D)                                 'POP BP„asm = asm + CHR$(&HCA) + MKI$(4)                       'RETF 2„„asmstore = asm: datas = VARPTR(asmstore)„main = datas + main: vidbase = datas + vidbase„prnstr = datas + prnstr„„„END SUB„„SUB fardemo„„'Since procedures which can be hardcoded do not need any FAR calls,„'as we have seen, the only approach of procedures we will look into in„'this section will be the STACKAPPROACH..„„'Like with the other STACKAPPROACHES we have to distinguish the CALLED„'PROCEDURE{the "would be driver") and the CALLER( our program specific„'assembly code).„„'For the sake of demonstration we will have to assume some code loaded„'into memory. For an elaborated example you should look into the RAM in„'QBASIC series, but at this moment we will simulate some driver with the„'following code:„„'------------------------------------„'CALLED PROCEDURE: simulated driver„'------------------------------------„DIM newint(4): segm = VARSEG(newint(0)): offs = 0„newint(0) = &H41B2              'MOV  DL,41„newint(1) = &H2B4               'MOV  AH,02„newint(2) = &H21CD              'INT  21„newint(3) = &HCB                'RETF (returns to the caller)„„'----------------------------------„'CALLING APPROACH : CALL FAR [BX]„'----------------------------------„'We will just call the far pointer of the driver. A far pointer means„'that the double word is popped of the stack and after that the jump„'is executed. When you load the double word pointer with segment:offset„'then the execution of the far call will jump to the driver. Notice that„'contrary to the stackapproach with NEAR procedures we are doing in fact„'TWO far calls, the first one from QBASIC and the second one from our„'assembly CALLER routine to the driver. Stupid, but unavoidable..„„'----------------„'CALLER PROCEDURE„'-----------------„'So let us do the far call code with stackpassing here.„„asm = ""„asm = asm + CHR$(&H55)                            'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)               'mov bp,sp      1„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)   'mov bx,[bp+06] 1„asm = asm + CHR$(&HFF) + CHR$(&H1F)               'call far [bx]  17„asm = asm + CHR$(&H5D)                            'pop bp         1„asm = asm + CHR$(&HCA) + MKI$(&H2)                'retf 2         14„„'This program does nothing but CALLING THE FAR PROCEDURE("would be driver")„'and returning to QBASIC. Let us controle it:„„CLS : dwordptr& = segm * &H10000 OR offs„DEF SEG = VARSEG(asm): CALL ABSOLUTE(dwordptr&, SADD(asm$)): DEF SEG„„LOCATE 10, 1: PRINT "This was our driver called from QBASIC..": SLEEP:„CLS : LOCATE 10, 1: PRINT "Good bye"„PRINT : PRINT "Rickn"„„END SUB„„SUB neardemo„„'Initiating:„„CALL biosvideo(vidbase, prnstr, main):„stringseg = VARSEG(asm): CLS„„'***************„'DGROUP calling:„'***************„'Have you ever heard of subliminal perception ? I can tell you that for„'commercials on TV it is forbidden..Subliminal perception takes place when„'the folluw up of images is to fast for your eyes. Although you do not„'consciously recognize the image, there is still a part of your brain that„'will notice the image...Well in this demonstration the printing/fading is„'just tooo fast..so you will have a look at a very small part of what is„'actually printed...The string will be moved 10000 times from screenposition„'0 to position 250*8=the end of the screen. So far about this little„'bios dispatcher...When you need really fast prints you could built„'a real nice routine out of this dispatcher, I guess..[of course I„'included bugs...;)<g>]. The topic however was procedures. You should„'notice that all procedures are NEAR!! and HARDCODED. And that is the„'same as saying that there is a FIXED PATTERN of CALLS...which is„'displayed in the procedure I called MAIN.„„a = SPACE$(10000):„DEF SEG = stringseg: away = SPACE$(8)„FOR i = 0 TO 10000„  CALL ABSOLUTE("Gonewind", away, main):„NEXT„FOR i = 7 TO 0 STEP -1„  SCREEN 0, i, i: PRINT "Screenpage "; i; " <key>": SLEEP„NEXT„„PRINT : PRINT "Press a key for next demonstration ..": SLEEP: CLS„„'**************„'STACKPASSING:„'**************„'This time we are going to use the same near procedures from another„'procedure. That is the way to stay flexible. You can call every procedure„'inside your NEAR LIBRARY [I think calling biosvideo a library is best here].„„'So ,you do not need the fixed pattern of calls inside the mainprocedure„'after all!. The only thing you have to do, is to set up a CALLING PROCEDURE„'which will be your INTERFACE between QBASIC and BIOSVIDEO.„„'Initiating: there must be a far caller....„„asm = asmcaller: DEF SEG = VARSEG(asm)„„CALL ABSOLUTE(vidbase, prnstr, "nada", SADD(asm))„DEF SEG :„LOCATE 10, 1: PRINT "This was the demonstration of NEAR PROCEDURES..":„PRINT : PRINT "Press a key for FAR PROCEDURES": SLEEP„„'Although I will not very much go into it I think I should point„'out to you all the possibilities of this type of FLEXIBLE NEAR CALLING„„'This type of calling makes it possible that you do:„'1)Store your assembly procedures as NEAR procedures in a string.„'2)Store the string in a librarie file, without header pointing to the„'  offsets of the different procedures..„'3)Everytime you need a procedure out of your library you just load„'  the file into a string again, and you refer to the„'  string offset+procedure offset inside your CALLING FUNCTION....„'Easy enough...You even could automate the CALLING FUNCTION any further...„'Well, I think I just have to wait for someone to do it, I guess<g>„„„END SUB„„RRick Elbers                    ASSEMBLY IN QBASIC 6: INT86X   rick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        236  10303    6INT86X.BAS 'ASSEMBLY IN QBASIC PART 6: CALL INTERRUPT/ INTERRUPTX„'Rick februari 1997 []„„DEFINT A-Z„DECLARE SUB demo (intx(), regs())„DECLARE SUB int86X (intx(), regs())„„„'Hello, fellow marxists...[shit, type mismatch I guess..<g>]here I am again,„„'This is a completely new routine to emulate INTERRUPTX. The datasegment„'approach is dumped. However when you go to a close look you will see that„'some very important remainder of it still resists.„'This routine tries to simulate CALL INTERRUPT/ INTERRUPTX without the„'hassles that are normally associated with it, like another sub to„'set the interruptnr, or the shared regtype. And guess what ? This routine„'really match up in speed to the regtype things( even if I abstracted from„'the setting of the interruptnumber there).„'There are a few demo's/ testprograms included.„„„'Initialize:„DIM intx(60): DIM regs(10): CALL int86X(intx(), regs())„'Go for it:„demo intx(), regs()„„„'There is one way to make all of this even faster when you put regs and intx„'in one array. That way you avoid the use of the slow segment overrides to CS.„'(2 of them). I will not make such a program because:„'1) I personally do not think you should use INTERRUPTX/ CALL INTERRUPT, but„'   instead more tuned routines. THAT will give you much more speedadvantage.„'2) I think it is more stable this way.„„'A few notes as to the routine, in which I put pretty much everything that„'I know right now:„'1)BP is saved through exchange saving 2 cycles„'2)DS is restored to the stringsegment without push/pop saving 2 cycles„'3)The segment of the regs() is initialized saving the stackthing (1 cycle)„'  and a retf n( 1 cycle too)„'4)I made use of a temporary store of this segment of regs() and therefore„'  had to retrieve it using mov ds,CS[86]. Thats very slow, but interesting„'  enough other solutions are even slower.„'5)The ds and si, and es and di register are set up in a way making it„'  possible to get them both at once, saving 2 cycles in total.„'6)I do not think that you have to save the flags. QBASIC is taking care.„'  But I am not yet sure there.„'7)To make this routine really user friendly you could set up constants for„'  all registers like I did. That way you do not have to remember which reg„'  number stands for which register.„„'If you do not get all the reasons you might take a look on other„'modifications I made to MarkK's tutorial.„„'good bye,„'Rick„„END„„SUB demo (intx(), regs())„CONST intnr = 0, ax = 1, bx = 2, cx = 3, dx = 4, bp = 5, si = 6, ds = 7„CONST di = 8, es = 9, flag = 10„DEF SEG = VARSEG(intx(0)): CLS„„'TIming:„regs(intnr) = &H21: regs(ax) = &H200: regs(dx) = &HB1„a! = TIMER: FOR i = -30000 TO 30000„  CALL absolute(0):„NEXT: b! = TIMER:„„'Timing the same but now tuned routine:„DIM prnchar(3)„prnchar(0) = &H2B4„prnchar(1) = &HB1B2„prnchar(2) = &H21CD„prnchar(3) = &HCB„DEF SEG = VARSEG(prnchar(0)): o = VARPTR(prnchar(0))„c! = TIMER: FOR i = -30000 TO 30000„  CALL absolute(o):„NEXT: d! = TIMER: CLS :„COLOR 0, 7: PRINT "INTX versus TUNED prnchar": COLOR 7, 0„PRINT "INTX   :"; b! - a!„PRINT "prnchar:"; d! - c!„COLOR 0, 7: PRINT "Regs filled like: ": COLOR 7, 0„FOR i = 0 TO 10: PRINT HEX$(regs(i)), : regs(i) = 0: NEXT„LOCATE 22, 1: PRINT : PRINT "Press a key for next demo": LOCATE 8, 1: SLEEP„„DEF SEG = VARSEG(intx(0)): regs(intnr) = &H21: regs(ax) = &H2F00:„FOR i = 2 TO 7: regs(i) = &H1111 * i: NEXT: regs(8) = &H8888„CALL absolute(0):„COLOR 0, 7: PRINT "Get DTA in ES[BX]:": COLOR 7, 0„FOR i = 0 TO 10: PRINT HEX$(regs(i)), : regs(i) = 0: NEXT: PRINT :„SLEEP„„'Functionality:„„'DS[DX]„COLOR 0, 7: PRINT "Print string from DS[DX]:": COLOR 7, 0„a$ = "doei$"„regs(intnr) = &H21: regs(ax) = &H900: regs(dx) = SADD(a$):„regs(ds) = VARSEG(a$): CALL absolute(0): SLEEP: PRINT„„'Various including ES[bp]„COLOR 0, 7: PRINT "Print string from ES[BP]:": COLOR 7, 0„regs(intnr) = &H10: regs(ax) = &H1301: regs(bx) = &H7: regs(cx) = 5„regs(dx) = &H1310: regs(bp) = SADD(a$): regs(es) = VARSEG(a$)„CALL absolute(0): SLEEP„„„'a difficult one:„PRINT : COLOR 0, 7: PRINT "Press a key for last demo"; : COLOR 7, 0: SLEEP: CLS„COLOR 7, 0: PRINT "We shelled from QBASIC to debug": COLOR 7, 0:„VIEW PRINT 2 TO 25:„'---------------------------------------------------------------------„exec$ = "c:\windows\command\debug.exe0": DIM exename(LEN(exec$))„regs(ds) = VARSEG(exename(0)): regs(dx) = VARPTR(exename(0))„DEF SEG = regs(ds):„FOR i = regs(dx) + 1 TO LEN(exec$): POKE i - 1, ASC(MID$(exec$, i, 1)): NEXT„DEF SEG„'---------------------------------------------------------------------------„commandtail$ = "c:\DOS\edit.com"„param$ = CHR$(LEN(commandtail$)) + commandtail$ + CHR$(13)„'---------------------------------------------------------------------------„DIM parameter(7 + LEN(param$) + 10): regs(es) = VARSEG(parameter(0)): regs(bx) = VARPTR(parameter(0))„'------------„'paramblock:„'------------„'0 W  pointer naar omgeving (0= default dos environment)„'2 DW pointer naar commandtail„'6 DW FCB1 pointer„'10 DW FCB2 pointer„'14 FCB=20*nul„'34 Commandtail„'---------------------------------------------------------„DEF SEG = regs(es):„parameter(0) = 0                                       'default environ„parameter(1) = regs(bx) + 34: parameter(2) = regs(es)  'ptr > commandtail„parameter(3) = regs(bx) + 14: parameter(4) = regs(es)  'ptr >FCB 1„parameter(5) = regs(bx) + 14: parameter(6) = regs(es)  'ptr >FCB2„„FOR i = regs(bx) + 14 TO regs(bx) + 33: POKE i, 0: NEXT         'FCB's„FOR i = 1 TO LEN(param$): POKE regs(bx) + 33 + i, ASC(MID$(param$, i, 1)): NEXT„DEF SEG„'------------------------------------------------------------------------„DEF SEG = VARSEG(intx(0)):„regs(intnr) = &H21: regs(ax) = &H4B00:„CALL absolute(0)„„„'Errors oke ?„regs(ax) = &H4800: regs(bx) = &HFFFF„CALL absolute(0)„„LOCATE 15, 1: COLOR 0, 7: PRINT "REGS FILLED LIKE:": COLOR 7, 0„FOR i = 0 TO 10: PRINT HEX$(regs(i)), : regs(i) = 0: NEXT: PRINT„PRINT : PRINT "If flags did not show the carry set, you do not had QBASIC loaded<g>"„PRINT : PRINT "Good bye"„„END SUB„„SUB int86X (intx(), regs())„'-------------------------------------------------------„'This routine gives credit and thanks to Rusty Angel!„'-------------------------------------------------------„'Pass: regs()1   2   3   4   5   6   7   8   9    10„'Array intnr, ax, bx, cx, dx, bp, si, ds, di, es, flag„„'adress: 0    2   4   6   8   a   c       10       14„'displc:      0   2   4   6   8   a       e        12„'-------------------------------------------------------„regseg = VARSEG(regs(0))                                         'clocks bytes„„asm$ = ""„„'Save ES( no trick available)                        „'----------------------------„asm$ = asm$ + CHR$(&H6)                            'push Es          3     01„„'Load DS[SI] with regs() and interruptnr to CS:[&h25]„'---------------------------------------------------„asm$ = asm$ + CHR$(&HB8) + MKI$(regseg)            'mov ax,regseg    1     04„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)              'mov ds,ax        3     06„asm$ = asm$ + CHR$(&HA1) + MKI$(0)                 'mov ax,[0] intnr 1+5   09„asm$ = asm$ + CHR$(&H2E) + CHR$(&HA2) + MKI$(&H25) 'mov CS[&h25],al  2+9+1 13„asm$ = asm$ + CHR$(&HBE) + CHR$(&H2) + CHR$(0)     'mov si,2         1     16„„'Load the registers.                                                    26„'-------------------„asm$ = asm$ + CHR$(&H8B) + CHR$(&H4)              'mov ax,[si]       1+5   18„asm$ = asm$ + CHR$(&H8B) + CHR$(&H5C) + CHR$(&H2) 'mov bx,[si+2]     1+9   21„asm$ = asm$ + CHR$(&H8B) + CHR$(&H4C) + CHR$(&H4) 'mov cx,[si+4]     1+9   24„asm$ = asm$ + CHR$(&H8B) + CHR$(&H54) + CHR$(&H6) 'mov dx,[si+6]     1+9   27„asm$ = asm$ + CHR$(&H87) + CHR$(&H6C) + CHR$(&H8) 'xchg bp,mov [si+8]3+9   30„asm$ = asm$ + CHR$(&HC4) + CHR$(&H7C) + CHR$(&HE) 'les di,[si+E]     6+9   33„asm$ = asm$ + CHR$(&HC5) + CHR$(&H74) + CHR$(&HA) 'lds si,[si+A]     6+9   36„„'Execute interrupt                                                      104„'-----------------„asm$ = asm$ + CHR$(&HCD) + CHR$(&H0)              'int nr           26     38„„'Set up DS[SI] again to regs and store DS                               130„'-----------------------------------------„asm$ = asm$ + CHR$(&H1E)                          'push ds          3      39„asm$ = asm$ + CHR$(&H2E) + CHR$(&H8E) + CHR$(&H1E) + MKI$(86)'mov ds,cs[0]2+9+1 44„asm$ = asm$ + CHR$(&H89) + CHR$(&H36) + MKI$(&HC) 'mov [c],si       1+9    48„asm$ = asm$ + CHR$(&HBE) + CHR$(&H2) + CHR$(&H0)  'mov si,2         1      51„„'Store it!                                                              156„'---------„asm$ = asm$ + CHR$(&H89) + CHR$(&H4)              'mov [si],ax      1+5    53„asm$ = asm$ + CHR$(&H9F)                          'lahf             1      54„asm$ = asm$ + CHR$(&H88) + CHR$(&H64) + CHR$(&H12)'mov [si+12],ah   1+9    57„asm$ = asm$ + CHR$(&H89) + CHR$(&H5C) + CHR$(&H2) 'mov [si+2],bx    1+9    60„asm$ = asm$ + CHR$(&H89) + CHR$(&H4C) + CHR$(&H4) 'mov [si+4],cx    1+9    63„asm$ = asm$ + CHR$(&H89) + CHR$(&H54) + CHR$(&H6) 'mov [si+6],dx    1+9    66„asm$ = asm$ + CHR$(&H87) + CHR$(&H6C) + CHR$(&H8) 'xchg [si+8],bp   3+9    69„asm$ = asm$ + CHR$(&H89) + CHR$(&H7C) + CHR$(&HE) 'mov [si+e],di    1+9    72„asm$ = asm$ + CHR$(&H8C) + CHR$(&H44) + CHR$(&H10)'mov [si+10],es   3+9    75„asm$ = asm$ + CHR$(&H58)                          'pop ax  get ds   4      76„asm$ = asm$ + CHR$(&H89) + CHR$(&H44) + CHR$(&HC) 'mov [si+c] ,ax   1+9    79„'                                                                      251        „asm$ = asm$ + CHR$(&H7)                           'pop es           3      80„asm$ = asm$ + CHR$(&HB8) + MKI$(VARSEG(asm$))     'mov ax,stringseg 1      83„asm$ = asm$ + CHR$(&H8E) + CHR$(&HD8)             'mov ds,ax        3      85„asm$ = asm$ + CHR$(&HCB)                          'retf             13     86„'TEMP Storage arrea:„'-------------„asm$ = asm$ + MKI$(regseg)     'segment regs storage         271 clocks   88 bytes„„DEF SEG = VARSEG(intx(0)): FOR i = 0 TO LEN(asm$) - 1:„POKE i, ASC(MID$(asm$, i + 1, 1)): NEXT„DEF SEG„„„END SUB„„RRick Elbers                    ASSEMBLY IN QBASIC 7: SPEED    rick@tip.nl                    02-07-97 (22:15)       QB, QBasic, PDS        1560 58163    7SPEED.BAS  'ASSEMBLY IN QBASIC 7: ASSEMBLY SPEED ?„'---------------------------------------„'RICK ELBERS FEBRUARI 1997[]„„'---------------„'INTRODUCTION„'--------------„'Ray Moon writes in his excellent x86 FAQ that legitimate reasons for using„'asm are:„„'*   Low level control.  When you need to change the flags, or the control„'    registers of the processor, as when entering protected mode.„„' *  Speed.  Programs written in machine language execute fast!  It can„'    execute 10-100 times the speed of BASIC, and about twice as fast as a„'    program written in C or Pascal.„„' *  Time Critical Code.  Critical sections of programs written in higher„'    level languages, can be written in assembly to speed up sections.„„' *  Small program size.  When you write a TSR for example this is very„'    useful. Writing interrupt handlers is where assembly language shines.„„'While most of my other contributions have been handling low level control,„'this part of ASM in QBASIC will handle speed issues. We will discover„'certain groups of asm functions that can speed up QBASIC. Some timings„'and examples will be given below. And some tentative conclusions reached.„'----------------------------------------------------------------„'A)Peek replacers„'-----------------„DECLARE FUNCTION peek$ ()                 'peeks a byte from memory( obsolete)„DECLARE FUNCTION peekW$ ()                'peeks a word from memory(*)„DECLARE FUNCTION peekDW$ ()               'peeks a long from memory(!)„DECLARE FUNCTION peekmem2arr$ ()          'gets an array from memory(!)„DECLARE FUNCTION peekmem2string$ ()       'gets an ASCIZ string from memory(!)„DECLARE FUNCTION peekarr2string$ ()       'gets an ASCIZ string from array(!)„DECLARE FUNCTION peekbytes2string$ ()     'gets a fixed length string from memory(!)„'DECLARE peekarr2arr=pokearr2arr          'gets an subarray from an array(!)„'DECLARE memcopy bytes                    'copys nrbytes from mem to mem„                                          'You can find that one all over„'B)Poke replacers„'-----------------„DECLARE FUNCTION poke$ ()                 'pokes a byte to memory( obsolete )„DECLARE FUNCTION pokeW$ ()                'pokes a word to memory (*)„DECLARE FUNCTION pokeDW$ ()               'pokes a long to memory (!)„DECLARE FUNCTION pokearr2mem$ ()          'pokes an array to memory (!)„DECLARE FUNCTION pokearr2arr$ ()          'pokes an array to another array (!)„DECLARE FUNCTION pokestring2arr$ ()       'pokes a string into an array (!)„DECLARE FUNCTION pokestring2mem$ ()       'pokes a string into memory (!)„„'C)Math replacers„'-----------------„DECLARE FUNCTION bytes2int$ ()            'gets an integer from 2 bytes (obsolete)„DECLARE FUNCTION int2long$ ()             'get a long from 2 integers(*)„DECLARE FUNCTION getHighLow$ ()           'gets high/low bytes from integer(!)„DECLARE FUNCTION intdivint$ ()            'gets the integerdivision and modulo(!)„DECLARE FUNCTION readbit$ ()              'reads a bit from a long,int(!)„„'D)Misc replacers„'----------------„DECLARE FUNCTION cls3$ ()                 'does a cls for screen 0(!)„DECLARE FUNCTION cls13$ ()                'does a cls for screen 13(!)„DECLARE FUNCTION ascimid$ ()„DECLARE FUNCTION getusWord$ ()            'no function needed: explained!„„'E)Demo's„'----------„DECLARE SUB peekdemo ()„DECLARE SUB mathdemo ()„DECLARE SUB pokedemo ()„DECLARE SUB miscdemo ()„CALL pokedemo„CALL peekdemo„CALL mathdemo„CALL miscdemo„„CLS : COLOR 0, 7:„PRINT "Short resume: "„PRINT "When speed is not the issue use HLL(QBASIC) commands( much easier)"„COLOR 7, 0: PRINT "When speed is important:"„„PRINT "1) Poke/ Peek one byte using "; : COLOR 0, 7: PRINT " QBASIC POKE/PEEK";„COLOR 7, 0: PRINT " commands ": PRINT "2) Poke/ Peek words using "; : COLOR 0, 7:„PRINT " PokeW$/PokeW$": COLOR 7, 0: PRINT "3) Poke/ Peek double words using ";„COLOR 0, 7: PRINT " PokeDW$ / PeekDW$": COLOR 7, 0:„PRINT "4) Poke/ Peek strings from/to array's with "; : COLOR 0, 7:„PRINT " Pokestring2arr$/Peekarr2string$ ": COLOR 7, 0:„PRINT "5) Poke/ Peek strings from/to memory with "; : COLOR 0, 7:„PRINT " Pokestring2mem$/Peekmem2string$ ": COLOR 7, 0„PRINT "6) Poke/ Peek array's from/to memory with "; : COLOR 0, 7:„PRINT " Pokearr2mem$/Peekmem2arr$ ": COLOR 7, 0„PRINT "7) Poke/ Peek array's from array's with "; : COLOR 0, 7:„PRINT " Pokearr2arr$ ": COLOR 7, 0: PRINT "8) Get high/low bytes with "; : COLOR 0, 7„PRINT " Highlow$ ": COLOR 7, 0: PRINT "   division and modulo with "; : COLOR 0, 7:„PRINT " Intdivint$ ": COLOR 7, 0: PRINT "   getting an integer from two bytes with ";„COLOR 0, 7: PRINT " QBASIC * and + ": COLOR 7, 0: PRINT "   bitreading with ";„COLOR 0, 7: PRINT " readbit ": COLOR 7, 0:„PRINT "   getting a long from two integers with "; : COLOR 0, 7: PRINT " Ints2long$ "„COLOR 7, 0: PRINT "9) Get asci of char with "; : COLOR 0, 7: PRINT " ascimid$ "„COLOR 7, 0: PRINT " Clear the screen with "; : COLOR 0, 7:„PRINT " CLS3$,CLS13$ ": COLOR 7, 0:„PRINT "10)Get the length of a string with "; : COLOR 0, 7: PRINT " QBASIC LEN ": COLOR 7, 0„COLOR 0, 7:„PRINT "When you use asm you are in most cases for more then bytes 6 or"„PRINT "more times faster then when you do not ": COLOR 7, 0„PRINT "more..<key>": SLEEP: CLS„PRINT "Furthermore for peeking/ poking/ copying large bundles :"„PRINT "1)If possible use string or array instead of segm and offset passing,"„PRINT "  since this is faster and uses up less variables"„PRINT "2)If possible use stringstorage instead of arraystorage, since this "„PRINT "  faster and uses up 1 less variable."„PRINT "3)If stringspace is tight use arraystorage"„PRINT "4)If both stringspace and arrayspace are tight OR you have to use offsets"„PRINT "  other then zero use segm%,offset% passing"„PRINT„PRINT "When you need speed in other bit-, string- or sortfunctions"„PRINT "you might also turn to assembler functions. ": PRINT :„„PRINT "Good bye"„„„„END„„DEFSTR A„FUNCTION ascimid$„'-----------------------------------------------------------„'Function returns the asci character of the Nth character„'STACKPASSING : String, ascN„„'IN           : String, ascN„'OUT          : ascN has the ascii„„'It is just an example of the power of assembly with string„'functions in general..„'-----------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                             'push bp             4„asm = asm + CHR$(&H89) + CHR$(&HE5)                'mov bp,sp           1„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)    'mov bx,[bp+06]      1+9„asm = asm + CHR$(&H8B) + CHR$(&H17)                'mov dx,[bx] request to dx 1+5„asm = asm + CHR$(&H8B) + CHR$(&H7E) + CHR$(&H8)    'mov di,[bp+08]      1+9„asm = asm + CHR$(&H8B) + CHR$(&HD)                 'mov cx,[di]  length 1+5„asm = asm + CHR$(&H8B) + CHR$(&H7D) + CHR$(&H2)    'mov di,[di+2]sadd   1+9„asm = asm + CHR$(&HB8) + CHR$(&HFF) + CHR$(&HFF)   'mov ax,ffff set to error 1„asm = asm + CHR$(&H9) + CHR$(&HD2)                 'or dx,dx            1„asm = asm + CHR$(&H7E) + CHR$(&HB)                 'jle+B skip it:error 1/3„asm = asm + CHR$(&H39) + CHR$(&HCA)                'cmp dx,cx           1„asm = asm + CHR$(&H7F) + CHR$(&H7)                 'jg +7 skip it:error 1/3„asm = asm + CHR$(&H1) + CHR$(&HD7)                 'add di,dx           1„asm = asm + CHR$(&H4F)                             'dec di zero based   1„asm = asm + CHR$(&H8A) + CHR$(&H5)                 'mov al,[di]         1+5„asm = asm + CHR$(&H30) + CHR$(&HE4)                'xor ah,ah           1„asm = asm + CHR$(&H89) + CHR$(&H7)                 'mov [bx],ax         1+5„asm = asm + CHR$(&H5D)                             'pop bp              4„asm = asm + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)     'retf 4              14„„ascimid$ = asm                                                'clocks  85/91„„„END FUNCTION„„FUNCTION bytes2int$„„'This function translates two bytes to an integer„„'STACKPASSING : INTEGER, HIGHBYTE, LOWBYTE„„'IN     : Highbyte, Lowbyte„„'OUT    : Integer„'[obsolete...just for demonstration purposes..]„'-------------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'push bp                4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp              1„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+08] LOWBYTE 1+9„asm = asm + CHR$(&H8A) + CHR$(&H7)              'mov aL,[bx]            1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+06] HIGHBYTE 1+9„asm = asm + CHR$(&H8A) + CHR$(&H27)             'mov aH,[bx]            1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0A] INTEGER 1+9„asm = asm + CHR$(&H89) + CHR$(&H7)              'mov [bx],aX            1+5„asm = asm + CHR$(&H5D)                          'pop bp                 4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6                 14„bytes2int$ = asm                                               'clocks  71„„END FUNCTION„„FUNCTION cls13$„'----------------------------------------------------------„'This function does nothing but clear screen for„'SCREENS 13, 2, 1 (320*200)„„'[.386 instructions are used..]„'----------------------------------------------------------„asm = ""„asm = asm + CHR$(&HB8) + CHR$(&H0) + CHR$(&HA0) '0:mov ax,a000    1„asm = asm + CHR$(&H8E) + CHR$(&HC0)             '3:mov es,ax      3„asm = asm + CHR$(&H31) + CHR$(&HFF)             '5:xor di,di      1„asm = asm + CHR$(&H66) + CHR$(&H31) + CHR$(&HC0)'7:xor eax,Eax      1„asm = asm + CHR$(&HB9) + MKI$(&H3E80)           '10:mov cx,&h3e80 1„asm = asm + CHR$(&HFC)                          '11:cld           2„asm = asm + CHR$(&HF2) + CHR$(&H66) + CHR$(&HAB)'14:repnz stosd   2+5*3e80„asm = asm + CHR$(&HCB)                          '15:retf          13„cls13$ = asm                                    'clocks         24+5*3e80„„END FUNCTION„„FUNCTION cls3$„'------------------------------------------------------„'This function replaces CLS for textscreens„'on colormonitor for page zero„„'[.386 instructions used...]„'-----------------------------------------------------„asm = ""„asm = asm + CHR$(&HB8) + CHR$(&H0) + CHR$(&HB8) '0:mov ax,b800  1„asm = asm + CHR$(&H8E) + CHR$(&HC0)             '3:mov es,ax    3„asm = asm + CHR$(&H31) + CHR$(&HFF)             '5:xor di,di    1„asm = asm + CHR$(&H66) + CHR$(&HB8) + MKL$(&H7200720) '7:mov Eax,&h720720 1„asm = asm + CHR$(&HB9) + CHR$(&HE8) + CHR$(&H3) '10:mov cx,3e8  1„asm = asm + CHR$(&HFC)                          '11:cld         2„asm = asm + CHR$(&HF2) + CHR$(&H66) + CHR$(&HAB)'12:repnz stosdw 2+5*3e8„asm = asm + CHR$(&HCB)                          '15:retf        13„„cls3$ = asm                                           'clocks 22+5*3e8„„END FUNCTION„„FUNCTION getHighLow$„'-----------------------------------------------------------------„'This function returns the high and low byte of an integer„'STACKPASSING: High%,Low%,WORD%„'IN          : WORD%„'OUT         : High%= High byte of WORD%„'              Low %= Low byte of WORD%„'-----------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'push bp            4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp          1„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0a]     1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]        1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08]     1+9„asm = asm + CHR$(&H88) + CHR$(&H27)             'mov [bx],ah        1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06]     1+9„asm = asm + CHR$(&H88) + CHR$(&H7)              'mov [bx],al        1+5„asm = asm + CHR$(&H5D)                          'pop bp             4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6             14„getHighLow$ = asm                                          'clocks  71„„END FUNCTION„„DEFSNG A„FUNCTION getusWord$„„'The situation where you want to read out an„'unsigned integer. Simple: only make sure that you„'pass the unsigned integer as the low word of a„'long with the high word of that long set to zero!„„'For the opposite operation( f.i. when filling„'registers with unsigned integers you just get the„'string values by LEFT$(MKL$(60000),2)„„a$ = LEFT$(MKL$(60000), 2)„PRINT a$, HEX$(CVI(a$))„„END FUNCTION„„DEFSTR A„FUNCTION int2long$„'-------------------------------------------------------------------„'This function translates two int values to one long !„„'STACKPASSING : LONG&, HIGWORD%, LOWWORD%„„'IN           : HIGH WORD„'               LOW WORD„„'OUT          : LONG„„'[routine is not optimized for .386 instructions]„'--------------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                              'PUSH BP        4„asm = asm + CHR$(&H89) + CHR$(&HE5)                 'MOV BP,SP      1„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)     'MOV BX,[BP+08] 1+9 highint„asm = asm + CHR$(&H8B) + CHR$(&HF)                  'MOV CX,[BX]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'MOV BX,[BP+06] 1+9 lowint„asm = asm + CHR$(&H8B) + CHR$(&H7)                  'MOV AX,[BX]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)     'MOV BX,[BP+0a] 1+9„asm = asm + CHR$(&H89) + CHR$(&H7)                  'MOV [BX],AX    1+5„asm = asm + CHR$(&H89) + CHR$(&H4F) + CHR$(&H2)     'MOV [BX+2],CX  1+9„asm = asm + CHR$(&H5D)                              'POP BP         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)      'RETF 6         14„int2long$ = asm                                            'clocks: 81„END FUNCTION„„FUNCTION intdivint$„'-------------------------------------------------„'This function is returning both the division„'and the remainder from an SWORD to SWORD division.„„'STACKPASSING Word%,Div%„'IN : Word% the word to divide„'     Div%  the word to divide by„'OUT: Word% the result of integerdivision„'     DIv%  the remainder of the integerdivision„'--------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                             'push bp         4„asm = asm + CHR$(&H89) + CHR$(&HE5)                'mov bp,sp       1„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)    'mov bx,[bp+08]  1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)                 'mov ax,[bx]     1+5„asm = asm + CHR$(&H31) + CHR$(&HD2)                'xor dx,dx       1„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)    'mov bx,[bp+06]  1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)                 'mov cx,[bx]     1+5„asm = asm + CHR$(&HF7) + CHR$(&HF9)                'idiv cx         27„asm = asm + CHR$(&H89) + CHR$(&H17)                'mov [bx],dx     1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)    'mov bx,[bp+08]  1+9„asm = asm + CHR$(&H89) + CHR$(&H7)                 'mov [bx],ax     1+5„„asm = asm + CHR$(&H5D)                             'pop bp          4„asm = asm + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)     'retf 4          14„intdivint$ = asm                                       'clocks     105„END FUNCTION„„DEFINT A-Z„SUB mathdemo„„'This demonstration explores the use of an asm sub to divide/receive modulo,„'get high and lowbytes, make integers from bytes, make a long from integers,„'read a bit from a long against QBASIC QBASIC /,\,mod,^ etc. commands„„'Initiating:„'------------„intdiv$ = intdivint$: bits$ = readbit$: bytsint$ = bytes2int$„gethilo$ = getHighLow$: intlong$ = int2long$: CLS : LOCATE 1, 25: COLOR 0, 7:„PRINT "TIMING MATH REPLACEMENTS..": COLOR 7, 0„„DEF SEG = VARSEG(intdiv$): offcode% = SADD(intdiv$)„words% = 456: divs% = &H91„„'1)INTDIVINT„„'asmdivmod:     'Since it is well known that I hate to use to many variables„                'I just refilled them...„word2divide% = 456: divider% = &H91„a! = TIMER„FOR i% = 0 TO 30000„  words% = word2divide%: divs% = divider%„  CALL absolute(words%, divs%, offcode%)„NEXT„B! = TIMER„„DEF SEG„„'qbasic divmod:„g% = 456: m% = &H91: c! = TIMER„FOR i% = 0 TO 30000„  k% = g% / m%: n% = g% MOD m%„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Divide Int by Int ": COLOR 7, 0„PRINT "Assembly sub use    : "; B! - a!, words%, divs%„PRINT "BASIC / and MOD use :"; d! - c!, k%, n%„'Note: can be speeded up a little bit more using 4 variables„„'2) HIGHLOW„„'Initiating:„word% = &H1A1B: high% = 0: low% = 0:„„'ASM highlow:„DEF SEG = VARSEG(gethilo$): offset% = SADD(gethilo$): a! = TIMER„„FOR i% = -30000 TO 30000„  CALL absolute(word%, high%, low%, offset%)„NEXT„B! = TIMER:„„'QBASIC highlow:„DEF SEG : c! = TIMER„„FOR i% = -30000 TO 30000„  h% = (&H1A1B / &H100) AND &HFF„  l% = &H1A1B AND &HFF„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Get high and low bytes ": COLOR 7, 0„PRINT "Assembly use        : "; B! - a!, HEX$(high%), HEX$(low%)„PRINT "BASIC / and AND use :"; d! - c!, HEX$(h%), HEX$(l%)„„'3)BITREAD„„DEF SEG = VARSEG(bits$): offcode% = SADD(bits$)„„a! = TIMER„FOR j% = 0 TO 1000„  FOR i% = 0 TO 31„    bits% = i%„    CALL absolute(value&, bits%, offcode%)„  NEXT„NEXT„B! = TIMER„„c! = TIMER„FOR i% = 0 TO 1000„  FOR B% = 0 TO 30„    res% = ((value& AND (2 ^ B%)) > 0)„  NEXT„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Bitread": COLOR 7, 0„PRINT "Assembly sub use    :  "; B! - a!„PRINT "BASIC ^ and AND use :"; d! - c!„„„'4)Bytes2int„'asm sub:„„offcode% = SADD(bytsint$): high% = &H1A: low% = &H1C„a! = TIMER„FOR i% = -30000 TO 30000„CALL absolute(res%, high%, low%, offcode%)„NEXT„B! = TIMER„„'qbasic code„c! = TIMER„FOR i% = -30000 TO 30000„  resQ% = high% * &H100 + low%„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Byts to Integer": COLOR 7, 0„PRINT "Assembly sub use    :"; B! - a!, HEX$(res%)„PRINT "BASIC ^ and AND use :"; d! - c!, HEX$(resQ%)„„„„'5)Ints2long„„offcode% = SADD(intlong$): high% = &H1C1D: low% = &HFFFF„a! = TIMER„FOR i% = -30000 TO 30000„CALL absolute(res&, high%, low%, offcode%)„NEXT„B! = TIMER„„'qbasic code„c! = TIMER„FOR i% = -30000 TO 30000„  resQ& = (high% * &H10000) + low%„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Integers to Long": COLOR 7, 0„PRINT "Assembly sub use    :"; B! - a!, HEX$(res&)„PRINT "BASIC * and OR use  :"; d! - c!, HEX$(resQ&)„„PRINT„PRINT "Press a key for next demo": SLEEP„„„„„„„END SUB„„SUB miscdemo„'This sub demonstrates the use of some miscallanous other asm functions„'for QBASIC.„'Initiating:„empty3$ = cls3$: empty13$ = cls13$: DEF SEG = VARSEG(empty3$)„asci$ = ascimid$„„CLS : LOCATE 1, 25: COLOR 0, 7:„PRINT "TIMING MISCALLANOUS REPLACEMENTS..": COLOR 7, 0: PRINT :„„'1) An example of stringfunctions:„a$ = "wat is dit dan"„a! = TIMER„FOR i% = -30000 TO 30000„  FOR j% = 1 TO LEN(a$)„    res% = ASC(MID$(a$, j%, 1))„  NEXT„NEXT„B! = TIMER„„DEF SEG = VARSEG(asci$): offcode% = SADD(asci$): c! = TIMER„FOR i% = -30000 TO 30000„  FOR j% = 1 TO LEN(a$)„    CALL absolute(a$, j%, offcode%)„  NEXT„NEXT„d! = TIMER„COLOR 0, 7: PRINT "STRINGFUNCTIONS..": COLOR 7, 0„PRINT "BASIC ASC(MID$) use:"; B! - a!„PRINT "ASM function use   :"; d! - c!„PRINT : PRINT„„PRINT "Next there will be timed CLS functions so do net get scared "„PRINT "when you are going to look at: 'long time no see..'": SLEEP„PRINT "<key..>"„VIEW PRINT 2 TO 25„'Screen 3 clearing:„'asm:„offcode% = SADD(empty3$): a! = TIMER„FOR i% = 0 TO 10000„  CALL absolute(offcode%)„NEXT„B! = TIMER„„'basic:„PRINT "And know the normal one..."„c! = TIMER„FOR i% = 0 TO 10000„  CLS„NEXT„d! = TIMER„„SCREEN 13„„'Screen 13 clearing:„'asm:„„FOR x% = 50 TO 100„CIRCLE (159, 99), 2 * x%, x% + 1„NEXT„„offcode% = SADD(empty13$): e! = TIMER„FOR i% = 0 TO 1000„  CALL absolute(offcode%)„NEXT„f! = TIMER„„'basic:„PRINT "And know the normal one..."„g! = TIMER„FOR i% = 0 TO 1000„  CLS„NEXT„h! = TIMER„„SCREEN 0: WIDTH 80, 25„„COLOR 0, 7: PRINT "CLS for SCREEN 0": COLOR 7, 0„PRINT "Assembly use   :"; B! - a!„PRINT "QBASIC CLS use :"; d! - c!„COLOR 0, 7: PRINT "CLS for SCREEN 13": COLOR 7, 0„PRINT "Assembly use   :"; f! - e!„PRINT "QBASIC CLS use :"; h! - g!„PRINT "Press a key for next demo"; : SLEEP„„„END SUB„„DEFSNG B-Z„DEFSTR A„FUNCTION peek$„'---------------------------------------------------------------„'This function does nothing more then peek one byte from a known„'location. For peeking a word, dword, array or string you should„'use more optimized routines.„„'STACKPASSING: BAS%, SEGMENT, OFFSET„'IN          : SEGMENT, OFFSET„'OUT         : BAS%„„'[Obsolete..just for demonstration purposes.]„'----------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp      1„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H3F)             'mov di,[bx]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]    1+5„asm = asm + CHR$(&H8E) + CHR$(&HC0)             'mov es,ax      3 es[di]adress„asm = asm + CHR$(&H26) + CHR$(&H8B) + CHR$(&H5) 'es:mov ax,[di] 2+5+1 store it„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0A] 1+9„asm = asm + CHR$(&H88) + CHR$(&H7)              'mov [bx],al    1+9„„asm = asm + CHR$(&H5D)                          'pop bp         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6         1„„peek$ = asm                                     'clocks :       70„„END FUNCTION„„FUNCTION peekarr2string$„'-----------------------------------------------------------„'This routine does nothing more then store an ASCIIZ string„'from an array. You should look upon this routine as a„'special case of moving bytes in memory„„'STACKPASSING B$,A%()„'IN :B$  =string big enough to keep the Bytes„'    A%()=the array to get the zero terminated string from.„'OUT:B$  =string contains the array in byte form„„'reference: peekstring2loc,pokestring,pokestring2loc„'[this routine is not optimized for .386 instructions]„'------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                           'push bp          4„asm = asm + CHR$(&H89) + CHR$(&HE5)              'mov bp,sp        1„asm = asm + CHR$(&H1E)                           'PUSH dS          3„„asm = asm + CHR$(&H1E)                           'PUSH DS          3„asm = asm + CHR$(&H7)                            'POP  ES          3„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx,[bp+08]   1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)               'mov cx,[bx] len  1+5„asm = asm + CHR$(&H8B) + CHR$(&H7F) + CHR$(&H2)  'mov di,[bx+02] es[di]string„                                                                  '1+9„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx,[bp+06]   1+9„asm = asm + CHR$(&HC5) + CHR$(&H37)              'lds si,[bx]    ds[si]array„                                                                  '6+5„asm = asm + CHR$(&HFC)                           'CLD future       2„asm = asm + CHR$(&HF6) + CHR$(&HC1) + CHR$(&H1)  'TEST cl,1        1„asm = asm + CHR$(&H74) + CHR$(&H1)               'jz +1            1/3„asm = asm + CHR$(&HA4)                           'movsb odd byte   7„asm = asm + CHR$(&HD1) + CHR$(&HE9)              'shr cx,1 >words  3„asm = asm + CHR$(&HF2) + CHR$(&HA5)              'repnz movsw      2+7*cx„„„asm = asm + CHR$(&H1F)                           'Pop dS           3„asm = asm + CHR$(&H5D)                           'pop bp           4„asm = asm + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)   'retf 4           14„peekarr2string$ = asm                            'clocks           98/101+7*cx„„„END FUNCTION„„FUNCTION peekbytes2string$„'-----------------------------------------------------------„'This routine does nothing more then store the number of string„'bytes from the memory location. You should look upon this„'routine as a special case of moving bytes in memory„„'STACKPASSING: bas$,seg%,offs%„„'IN :B$           = string exactly big enough to keep the Bytes„'    Seg%, offset%= Memory location.„'OUT:B$           = string is filled with memory„„'reference: peekstring2loc,pokestring,pokestring2loc„'[this routine is not optimized for .386 use]„'------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                           'push bp            4„asm = asm + CHR$(&H89) + CHR$(&HE5)              'mov bp,sp          1„asm = asm + CHR$(&H1E)                           'PUSH dS            3„„'Set up es[di] to string and cx to len string:„asm = asm + CHR$(&H1E)                           'PUSH DS            3„asm = asm + CHR$(&H7)                            'POP  ES            3„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)  'mov bx,[bp+0a]     1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)               'mov cx,[bx] len    1+5„asm = asm + CHR$(&H8B) + CHR$(&H7F) + CHR$(&H2)  'mov di,[bx+02]sadd 1+9„„'Set up ds[si] to memloc:„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx,[bp+06]     1+9„asm = asm + CHR$(&H8B) + CHR$(&H37)              'mov si,[bx]        1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx,[bp+08]     1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)               'mov ax,[bx]        1+9„asm = asm + CHR$(&H8E) + CHR$(&HD8)              'mov ds,ax  3  ds[si] to memloc„'Copy it words if possible:„asm = asm + CHR$(&HFC)                           'CLD                2„asm = asm + CHR$(&HF6) + CHR$(&HC1) + CHR$(&H1)  'test cl,1 odd ?    1„asm = asm + CHR$(&H74) + CHR$(&H1)               'jz +1              1/3„asm = asm + CHR$(&HA4)                           'movsb              7„asm = asm + CHR$(&HD1) + CHR$(&HE9)              'shr cx,1           3„asm = asm + CHR$(&HF3) + CHR$(&HA5)              'repz movsw         2+5*cx„„asm = asm + CHR$(&H1F)                           'Pop dS             3„asm = asm + CHR$(&H5D)                           'pop bp             4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)   'retf 6             14„peekbytes2string$ = asm                          'clocks:            116/119+5*cx„„END FUNCTION„„DEFINT A-Z„SUB peekdemo„'This demonstration explores the way assembly subs match up to„'QBASIC in PEEK commands„„'initiating:„peekB$ = peek$: peekI$ = peekW$: peekL$ = peekDW$: peekstr$ = peekmem2string$„test% = &H2EF1: segm% = VARSEG(test%): offs% = VARSEG(test%)„peekbytstr$ = peekbytes2string$: peekstrarr$ = peekarr2string$: CLS„peekarr$ = peekmem2arr$: CLS : LOCATE 1, 25: COLOR 0, 7:„PRINT "TIMING PEEK REPLACEMENTS..": COLOR 7, 0„„„'1) Peek a byte„'---------------„„'asmpeek:„DEF SEG = VARSEG(peekB$): offcode% = SADD(peekB$)„a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(bas%, &H40, &H1A, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'qbasic peek:„„DEF SEG = &H40: c! = TIMER:„„FOR i% = -30000 TO 30000„  bas1% = PEEK(&H1A)„NEXT„„d! = TIMER: DEF SEG :„„COLOR 0, 7: PRINT "Peek bytes ": COLOR 7, 0„PRINT "Assembly use   :"; B! - a!, HEX$(bas%)„PRINT "PEEK use       :"; d! - c!, HEX$(bas1%)„„'2)Peek a word„„'asm peekword:„DEF SEG = VARSEG(peekI$): offcode% = SADD(peekI$)„a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(bas%, &H40, &H63, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'qbasic peek:„„DEF SEG = &H40: c! = TIMER„„FOR i% = -30000 TO 30000„  bas1% = PEEK(&H63) + PEEK(&H64) * &H100„NEXT„„d! = TIMER: DEF SEG :„„COLOR 0, 7: PRINT "Peek words": COLOR 7, 0„PRINT "Assembly use   :"; B! - a!, HEX$(bas%)„PRINT "2*PEEK use     :"; d! - c!, HEX$(bas1%)„„'3)Peek a Doubleword„„'asm peekDword:„DEF SEG = VARSEG(peekL$): offcode% = SADD(peekL$)„a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(bas&, &H40, &HA4, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'qbasic peekDW:( watch out: do not use +/- here :unsigned values!)„„DEF SEG = &H40: c! = TIMER„„FOR i% = -30000 TO 30000„  bas1& = ((PEEK(&HA6) OR (PEEK(&HA7) * &H100&)) * &H10000) OR (PEEK(&HA5) * &H100& OR PEEK(&HA4))„NEXT„„d! = TIMER: DEF SEG :„„COLOR 0, 7: PRINT "Peek Double words": COLOR 7, 0„PRINT "Assembly use   :"; B! - a!, HEX$(bas&)„PRINT "4*PEEK use     :"; d! - c!, HEX$(bas1&)„„„'4)Peek a bundle( to string and array)„„'a)String from a memory location            'F.i read out environmentstrings„„'asm peekstring:„DIM help%(4):                'allocate some memory„help%(0) = &H4142: help%(1) = &H61: segm% = VARSEG(help%(0)):„offs% = VARPTR(help%(0)): bas$ = SPACE$(4)„„DEF SEG = VARSEG(peekstr$): offcode% = SADD(peekstr$): a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(bas$, segm%, offs%, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'qbasic peekstring:„„DEF SEG = segm%: c! = TIMER„„FOR i% = -30000 TO 30000„  bas1$ = CHR$(PEEK(0)) + CHR$(PEEK(1)) + CHR$(PEEK(2)) + CHR$(PEEK(3))„NEXT„„d! = TIMER: DEF SEG :„„'a)Array from a memory location            'F.i read out screensegment„DIM save%(1): DIM sav%(1)„DEF SEG = VARSEG(peekarr$): offcode% = SADD(peekarr$): e! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(save%(), segm%, offs%, 2, offcode%)„NEXT„f! = TIMER: DEF SEG :„„DEF SEG = segm%: g! = TIMER„„FOR i% = -30000 TO 30000„  sav%(0) = PEEK(0) * 256 OR PEEK(1)„  sav%(1) = PEEK(2) * 256 OR PEEK(3)„NEXT„„h! = TIMER: DEF SEG :„„„COLOR 0, 7: PRINT "Peek a bundle from memory": COLOR 7, 0„PRINT "Asm to string  :"; B! - a!, bas$, "length: "; LEN(bas$)„PRINT "PEEK use       :"; d! - c!, bas1$, "length: "; LEN(bas1$)„PRINT "Asm to array   :"; f! - e!, HEX$(save%(0)); HEX$(save%(1)), "length:  4"„PRINT "PEEK use       :"; h! - g!, HEX$(sav%(0)); HEX$(sav%(1)), "length:  4"„„'b)From an array                               f.i. read out stored DTA„„'asm peek string from an array : use help%() this time as array!„bas$ = SPACE$(4)„„DEF SEG = VARSEG(peekstrarr$): offcode% = SADD(peekstrarr$): a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(bas$, help%(), offcode%)„NEXT„B! = TIMER: DEF SEG :„„'qbasic peekstring: use help%() this time as array!„„DEF SEG = segm%: c! = TIMER„„FOR i% = -30000 TO 30000„  bas1$ = MKI$(help%(0)) + MKI$(help%(1))„NEXT„„d! = TIMER: DEF SEG :„„COLOR 0, 7: PRINT "Peek a string from an array": COLOR 7, 0„PRINT "Assembly use   :"; B! - a!, bas$, "length: "; LEN(bas$)„PRINT "PEEK use       :"; d! - c!, bas1$, "length: "; LEN(bas1$)„„'c)Peek known bytes from memory location   f.i. store the screen„„'asm peek bytes string:„bas$ = SPACE$(4000)„„DEF SEG = VARSEG(peekbytstr$): offcode% = SADD(peekbytstr$): a! = TIMER„FOR i% = 0 TO 2000„  CALL absolute(bas$, &HB800, 0, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'qbasic peek bytes string:„„DEF SEG = &HB800: c! = TIMER„FOR i% = 0 TO 3999„  bas3$ = bas3$ + CHR$(PEEK(i%))„NEXT„d! = TIMER: DEF SEG :„„COLOR 0, 7: PRINT "Peek a fixed bytenr to string": COLOR 7, 0„PRINT "Assembly use(2000*!) :"; B! - a!, MID$(bas$, 320, 4); " < 2 bytes/2(beep)attributes<g>"„PRINT "PEEK use    (1*)     :"; d! - c!, MID$(bas3$, 320, 4); " < 2 bytes/2(beep)attributes<g>"„„„COLOR 7, 0: PRINT : PRINT "Press a key for next demo": SLEEP: CLS„„END SUB„„DEFSNG B-Z„DEFSTR A„FUNCTION peekDW$„'----------------------------------------------------------------------„'This function does nothing more then peek one doubleword from a known„'location. For peeking a byte, word, array or string you should„'use more optimized routines.„„'STACKPASSING: DWORD, SEGMENT, OFFSET„'IN          : SEGMENT, OFFSET„'OUT         : DWORD„'[.386 instructions used..]„'-----------------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp      1„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H3F)             'mov di,[bx]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]    1+5„asm = asm + CHR$(&H8E) + CHR$(&HC0)             'mov es,ax      3 es[di]adress„asm = asm + CHR$(&H26) + CHR$(&H66) + CHR$(&H8B) + CHR$(&H5)'es:mov EAX,[di] 2+5+1 store it„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0A] 1+9„asm = asm + CHR$(&H66) + CHR$(&H89) + CHR$(&H7) 'mov [bx],EAX   1+5 Dword„„asm = asm + CHR$(&H5D)                          'pop bp         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6         14„peekDW$ = asm                                   'clocks         83„„END FUNCTION„„FUNCTION peekmem2arr$„'-----------------------------------------------------------„'This routine does nothing more then store an array„'from a memory location. This routine should be looked„'upon as a special case of moving words in memory.„„'STACKPASSING: Save%(),seg%,offs%,nrelements%„„'IN :          Save%()      =array big enough to keep the Bytes„'              Seg%, offset%=Memory location.„'              nrelements%  =the number of integers to get„„'Reference: peekstring2loc,pokestring,pokestring2loc„'[This routine is not optimized for .386 use]„'------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                           'push bp         4„asm = asm + CHR$(&H89) + CHR$(&HE5)              'mov bp,sp       1„asm = asm + CHR$(&H1E)                           'push ds         3„asm = asm + CHR$(&H6)                            'push es         3„„'Set up ES[DI] to save%, cx to length:„'----------------------------------------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC) 'MOV BX,[BP+0C]   1+9„asm = asm + CHR$(&HC4) + CHR$(&H3F)             'LES di,[bx]      6+5„'----------------„'GET NRelements%„'----------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]   1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)              'MOV CX,[BX]      1+5„'----------------------„'GET SOURCE in DS[SI]„'----------------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'MOV BX,[BP+08]   1+9„asm = asm + CHR$(&H8B) + CHR$(&H37)             'MOV SI,[BX]      1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'MOV BX,[BP+0A]   1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'MOV AX,[BX]      1+5„asm = asm + CHR$(&H8E) + CHR$(&HD8)             'MOV DS,AX        3„'--------------------------------------------------„'Lets copy...„'--------------------------------------------------„asm = asm + CHR$(&HFC)                          'CLD              2„asm = asm + CHR$(&HF3) + CHR$(&HA5)             'repnz movsw      2+5*cx„„asm = asm + CHR$(&H7)                           'pop es           3„asm = asm + CHR$(&H1F)                          'POP Ds           3„asm = asm + CHR$(&H5D)                          'POP BP           4„asm = asm + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)  'RETF 8           14„peekmem2arr$ = asm                              'clocks           111+5*cx„„END FUNCTION„„FUNCTION peekmem2string$„'-----------------------------------------------------------„'This routine does nothing more then store an ASCIIZ string„'from a memory location. You should look upon this routine„'as a special case of moving bytes in memory.„„'STACKPASSING: bas$,seg%,offs%„„'IN :B$          =String big enough to keep the Bytes„'    Seg, offset =Memory location.„„'reference: peekstring2loc,pokestring,pokestring2loc„'[This routine is not optimized for .386 use]„'------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                           'push bp            4„asm = asm + CHR$(&H89) + CHR$(&HE5)              'mov bp,sp          1„asm = asm + CHR$(&H1E)                           'PUSH dS            3„„'Set up es[di] to string:„asm = asm + CHR$(&H1E)                           'PUSH DS            3„asm = asm + CHR$(&H7)                            'POP  ES            3„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)  'mov bx,[bp+0a]     1+9„asm = asm + CHR$(&H8B) + CHR$(&H7F) + CHR$(&H2)  'mov di,[bx+02]sadd 1+9„„'Set up ds[si] to memloc:„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx,[bp+06]     1+9„asm = asm + CHR$(&H8B) + CHR$(&H37)              'mov si,[bx]        1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx,[bp+08]     1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)               'mov ax,[bx]        1+5„asm = asm + CHR$(&H8E) + CHR$(&HD8)              'mov ds,ax  3  ds[si] to memloc„„asm = asm + CHR$(&HFC)                           'CLD future         2„asm = asm + CHR$(&HAC) + CHR$(&HAA)              'lodsb:stosb ds[si]>es[di]10„asm = asm + CHR$(&H84) + CHR$(&HC0)              'test al,al         1„asm = asm + CHR$(&H75) + CHR$(&HFA)              'jnz -7             3/1„ „asm = asm + CHR$(&H1F)                           'Pop dS             3„asm = asm + CHR$(&H5D)                           'pop bp             4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)   'retf 6             14„peekmem2string$ = asm                            'clocks:            96/94+10*len„„END FUNCTION„„FUNCTION peekW$„'---------------------------------------------------------------„'This function does nothing more then peek one word from a known„'location. For peeking a byte, dword, array or string you should„'use more optimized routines.„„'STACKPASSING: WORD, SEGMENT, OFFSET„'IN          : SEGMENT, OFFSET„'OUT         : WORD„'---------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp      1„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H3F)             'mov di,[bx]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]    1+5„asm = asm + CHR$(&H8E) + CHR$(&HC0)             'mov es,ax      3 es[di]adress„asm = asm + CHR$(&H26) + CHR$(&H8B) + CHR$(&H5) 'es:mov ax,[di] 2+5+1 store it„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0A] 1+9„asm = asm + CHR$(&H89) + CHR$(&H7)              'mov [bx],ax    1+5„„asm = asm + CHR$(&H5D)                          'pop bp         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6         14„                                                'clocks         82„peekW$ = asm„„END FUNCTION„„FUNCTION poke$„'----------------------------------------------------------------„'This function does nothing more then poke one byte to a know„'location. For poking a byte into a variable/ array you should„'use better optimized routines.„„'STACKPASSING: SEGMENT, OFFSET, BYTE„'IN          : SEGMENT, OFFSET, BYTE„'OUT         : -„'-----------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp      1„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H3F)             'mov di,[bx]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0A] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]    1+5„asm = asm + CHR$(&H8E) + CHR$(&HC0)             'mov es,ax      3 es[di]adress„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]    1+5„asm = asm + CHR$(&H26) + CHR$(&H88) + CHR$(&H5) 'es:mov [di],al 2+5+1 store it„„asm = asm + CHR$(&H5D)                          'pop bp         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6         14„„poke$ = asm                                                     '82 clocks„END FUNCTION„„FUNCTION pokearr2arr$„'------------------------------------------------------------„'This routine copies a (part of) an array to another array.„'You should look upon this routine as both a special case of„'moving memory blocks and filling parameterblocks.„„'STACKPASSING SOURCE%(),DEST%(),nrwords%„„'IN        : DS[SI] SOURCE%()„„'OUT       : ES[DI] FILLED DEST%()„„'[This routine is not optimized for .386 instructions yet]„'-------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'PUSH BP        4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'MOV BP,SP      1„asm = asm + CHR$(&H1E)                          'PUSH DS        3„'----------------------------------------„'LET US FIRST PUT THE DESTINY IN ES[DI]:„'----------------------------------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'MOV BX,[BP+08] 1+9„asm = asm + CHR$(&HC4) + CHR$(&H3F)             'les di,[bx]    6+5„'----------------„'GET NRelements%„'----------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06] 1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)              'MOV CX,[BX]    1+5„'----------------------„'GET SOURCE in DS[SI]„'----------------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'MOV BX,[BP+0A] 1+9„asm = asm + CHR$(&HC5) + CHR$(&H37)             'lds si,[bx]    6+9„'--------------------------------------------------„'Lets copy...„'--------------------------------------------------„asm = asm + CHR$(&HFC)                          'CLD            2„asm = asm + CHR$(&HF2) + CHR$(&HA5)             'repnz movsw    2+7*cx„„asm = asm + CHR$(&H1F)                          'POP Ds         3„asm = asm + CHR$(&H5D)                          'POP BP         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'RETF 6         14„pokearr2arr$ = asm                              'clocks         95+7*cx„„END FUNCTION„„FUNCTION pokearr2mem$„'-----------------------------------------------------------------„'This routine does nothing more then store an array„'from memory. You should look upon this routine as a„'special case of moving bytes in memory„„'STACKPASSING Segm%,offs%,bas%(),nrwords%„'IN :Segm%   = string big enough to keep the Bytes„'    Offs%   = the array to get the zero terminated string from.„'    nrwords%= the number of words to copy from memory to array„'OUT:bas%()  = array filled with memory contents„„'reference: peekstring2loc,pokestring,pokestring2loc„'[this routine is not optimized for .386 instructions]„'------------------------------------------------------------------„„asm = ""„asm = asm + CHR$(&H55)                          'push bp       4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp     1„asm = asm + CHR$(&H1E)                          'PUSH dS       3„„'Set up ES[DI] to memory location, cx to length:„'----------------------------------------„'LET US FIRST PUT THE DESTINY IN ES[DI]:„'----------------------------------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HC) 'MOV BX,[BP+0c]1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]   1+5„asm = asm + CHR$(&H8E) + CHR$(&HC0)             'mov es,ax     3„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'MOV BX,[BP+0a]1+9„asm = asm + CHR$(&H8B) + CHR$(&H3F)             'mov di,[bx]   1+5„'----------------„'GET NRelements%„'----------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)              'MOV CX,[BX]   1+5„'----------------------„'GET SOURCE in DS[SI]„'----------------------„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'MOV BX,[BP+08]1+9„asm = asm + CHR$(&HC5) + CHR$(&H37)             'lds si,[bx]   6+5„'--------------------------------------------------„'Lets copy...„'--------------------------------------------------„asm = asm + CHR$(&HFC)                          'CLD           2„asm = asm + CHR$(&HF2) + CHR$(&HA5)             'repnz movsw   2+7*cx„„asm = asm + CHR$(&H1F)                          'POP Ds        3„asm = asm + CHR$(&H5D)                          'POP BP        4„asm = asm + CHR$(&HCA) + CHR$(&H8) + CHR$(&H0)  'RETF 8        14„pokearr2mem$ = asm                              'clocks        105+7*cx„„END FUNCTION„„DEFINT A-Z„SUB pokedemo„„'This demonstration is exploring the capacities of our assembly poke„'against the QBASIC POKE command.„„'Initiating:„asmpoke$ = poke$: asmpokeW$ = pokeW$: asmpokeDW$ = pokeDW$„arr2arr$ = pokearr2arr$: arr2mem$ = pokearr2mem$:„string2arr$ = pokestring2arr$: string2mem$ = pokestring2mem$:„DIM test%(10): segm% = VARSEG(test%(0)): offs% = VARPTR(test%(0)): CLS„peekarr$ = peekmem2arr$: CLS : LOCATE 1, 25: COLOR 0, 7:„PRINT "TIMING POKE REPLACEMENTS..": COLOR 7, 0„„„'1): Poke one byte„„DEF SEG = VARSEG(asmpoke$): offset% = SADD(asmpoke$): a! = TIMER„„FOR i% = -30000 TO 30000„  CALL absolute(segm%, offs%, &H1A, offset%)„NEXT„„B! = TIMER: DEF SEG = VARSEG(segm%): c! = TIMER„„FOR i% = -30000 TO 30000„  POKE offs%, &H1A„NEXT„„d! = TIMER: DEF SEG„„COLOR 0, 7: PRINT "Poke 1 byte ": COLOR 7, 0„PRINT "Assembly use   :"; B! - a!„PRINT "POKE use       :"; d! - c!„„„'2) Poke a word„„DEF SEG = VARSEG(asmpokeW$): offset% = SADD(asmpokeW$): a! = TIMER„„FOR i% = -30000 TO 30000„  CALL absolute(segm%, offs%, &H1A1B, offset%)„NEXT„„B! = TIMER: DEF SEG = segm%: c! = TIMER„„FOR i% = -30000 TO 30000„  POKE offs% + 3, &H1A„  POKE offs% + 2, &H1B„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Poke a Word ": COLOR 7, 0„PRINT "Assembly use   :"; B! - a!, HEX$(test%(0))„PRINT "2*POKE use     :"; d! - c!, HEX$(test%(1))„„'3)Poke a  double word„„'asm poke„DEF SEG = VARSEG(asmpokeDW$): offset% = SADD(asmpokeDW$): a! = TIMER„„FOR i% = -30000 TO 30000„  CALL absolute(segm%, offs%, &H1C1DF1F2, offset%)„NEXT„„B! = TIMER:„„'qbasic poke:„DEF SEG = segm%: c! = TIMER„„FOR i% = -30000 TO 30000„  POKE offs% + 4, &HF2„  POKE offs% + 5, &HF1„  POKE offs% + 6, &H1D„  POKE offs% + 7, &H1C„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Poke a DWord ": COLOR 7, 0„PRINT "Assembly use   : "; B! - a!, HEX$(test%(0)), HEX$(test%(1))„PRINT "4*POKE use     :"; d! - c!, HEX$(test%(2)), HEX$(test%(3))„„'4)Poke a string„'a)To a memory location            f.i. a screenstore to &ha000„bas$ = "Halloz"„„'asm:„DEF SEG = VARSEG(string2mem$): offcode% = SADD(string2mem$): a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(bas$, segm%, offs% + 6, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'basic:„„DEF SEG = segm%„c! = TIMER„FOR i% = -30000 TO 30000„  FOR j% = 0 TO 5„    POKE j%, ASC(MID$(bas$, j% + 1, 1))„  NEXT„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Poke a string 2 memory ": COLOR 7, 0„PRINT "Assembly use   : "; B! - a!, HEX$(test%(3)); HEX$(test%(4)); HEX$(test%(5))„PRINT "6*POKE use     :"; d! - c!, HEX$(test%(0)); HEX$(test%(1)); HEX$(test%(2))„„„'b)To an array           f.i an asm to an array„bas$ = "daaaag"„„'asm:„DEF SEG = VARSEG(string2arr$): offcode% = SADD(string2arr$): a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(test%(), bas$, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'basic:„„DEF SEG = segm%„c! = TIMER„FOR i% = -30000 TO 30000„  FOR j% = 0 TO 5„    POKE j% + 6, ASC(MID$(bas$, j% + 1, 1))„  NEXT„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Poke a string 2 array ": COLOR 7, 0„PRINT "Assembly use   : "; B! - a!, HEX$(test%(0)); HEX$(test%(1)); HEX$(test%(2))„PRINT "6*POKE use     :"; d! - c!, HEX$(test%(3)); HEX$(test%(4)); HEX$(test%(5))„„„'5)Poke an array„„'C)To another array.         f.i. store a parameterblock into an asm%()„DIM param%(2)„param%(0) = &H1231: param%(2) = &HFFFF„„'asm:„DEF SEG = VARSEG(arr2arr$): offcode% = SADD(arr2arr$): a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(param%(), test%(), 2, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'basic:„„DEF SEG = segm%„c! = TIMER„FOR i% = -30000 TO 30000„test%(2) = param%(0)„test%(3) = param%(1)„NEXT„„d! = TIMER„„e! = TIMER„FOR i% = -30000 TO 30000„  POKE 9, (param%(0) / &H100) AND &HFF„  POKE 10, param%(0) AND &HFF„  POKE 11, (param%(1) / &H100) AND &HFF„  POKE 12, param%(1) AND &HFF„NEXT„f! = TIMER„„„COLOR 0, 7: PRINT "Poke an array 2 array ": COLOR 7, 0„PRINT "Assembly use   : "; B! - a!, HEX$(test%(0)); HEX$(test%(1))„PRINT "arr%()=arr2%() : "; d! - c!, HEX$(test%(2)); HEX$(test%(3))„PRINT "Poke use       :"; f! - e!, HEX$((test%(4) / &HFF) AND &HFF); HEX$(test%(5)); HEX$(test%(6))„„„'d)Finallement: To memory f.i a screen store to &ha000„test%(0) = &H1241: test%(1) = &H943„„'asm:„DEF SEG = VARSEG(arr2mem$): offcode% = SADD(arr2mem$): a! = TIMER„FOR i% = -30000 TO 30000„  CALL absolute(&HB800, 3440, test%(), 2, offcode%)„NEXT„B! = TIMER: DEF SEG :„„'basic:„„DEF SEG = &HB800„c! = TIMER„FOR i% = -30000 TO 30000„  POKE 3600, (test%(0) / &H100) AND &HFF„  POKE 3601, test%(0) AND &HFF„  POKE 3602, (test%(1) / &H100) AND &HFF„  POKE 3603, test%(1) AND &HFF„NEXT„d! = TIMER„„COLOR 0, 7: PRINT "Poke an array 2 memory ": COLOR 7, 0„PRINT "Assembly use   : "; B! - a!„PRINT "4*POKE use     :"; d! - c!„„COLOR 7, 0: PRINT "Press a key for next demo"; : SLEEP: CLS„„„END SUB„„DEFSNG B-Z„DEFSTR A„FUNCTION pokeDW$„'---------------------------------------------------------„'This function pokes a double word into memory„„'STACKPASSING :segm%,off%,bas&„„'IN           :segm%,off%,bas&„„'OUT          :-„'[makes use of .386 instructions for DWORD]„'----------------------------------------------------------„„asm = ""„asm = asm + CHR$(&H55)                          'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp      1„asm = asm + CHR$(&H1E)                          'push ds        3„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06] 1+9„asm = asm + CHR$(&H66) + CHR$(&H8B) + CHR$(&H7) 'mov EAX,[bx]   1+5 DWord„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H37)             'mov si,[bx]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0a] 1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)              'mov cx,[bx]    1+5„asm = asm + CHR$(&H8E) + CHR$(&HD9)             'mov ds,cx      3 ds[si]=mem„„asm = asm + CHR$(&H66) + CHR$(&H89) + CHR$(&H4) 'mov [si],EAX   1+5  store it„„asm = asm + CHR$(&H1F)                          'pop ds         3„asm = asm + CHR$(&H5D)                          'pop bp         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6         14„pokeDW$ = asm                                   'clocks         86„„END FUNCTION„„FUNCTION pokestring2arr$„'--------------------------------------------------------------------------„'This routine does nothing more then poke an ASCIIZ string„'to an array. You should look upon this routine as a„'special case of moving bytes in memory„„'STACKPASSING A%(),B$„'IN :         A%() = array big enough to keep the bytes from the string„'             B$   = string to get bytes from terminated with a zero(ASCIZ)„'OUT:         A%() = array contains the string in integer form„„'reference: peekstring2loc,pokestring,pokestring2loc„'[this routine is not optimized for .386 instructions]„'--------------------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                               'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)                  'mov bp,sp      1„asm = asm + CHR$(&H6)                                'PUSH ES        3„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)      'mov bx,[bp+06] 1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)                   'mov cx,[bx]    len string 1+5„asm = asm + CHR$(&H8B) + CHR$(&H77) + CHR$(&H2)      'mov si,[bx+02] ds[si]string 1+9„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)      'mov bx,[bp+08] 1+9„asm = asm + CHR$(&HC4) + CHR$(&H3F)                  'les di,[bx]    es[di]array 6+5„asm = asm + CHR$(&HFC)                               'CLD future     2„asm = asm + CHR$(&HF6) + CHR$(&HC1) + CHR$(&H1)      'TEST cl,1      1„asm = asm + CHR$(&H74) + CHR$(&H1)                   'jz +1          1/3„asm = asm + CHR$(&HA4)                               'movsb odd byte  7„asm = asm + CHR$(&HD1) + CHR$(&HE9)                  'shr cx,1 >words 3„asm = asm + CHR$(&HF2) + CHR$(&HA5)                  'repnz movsw     2+7*cx„„„asm = asm + CHR$(&H7)                                'Pop ES         3„asm = asm + CHR$(&H5D)                               'pop bp         4„asm = asm + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)       'retf 4         14„pokestring2arr$ = asm                                'clocks         92/94+7*cx„„„END FUNCTION„„FUNCTION pokestring2mem$„'------------------------------------------------------------------„'This routine does nothing more then poke a string to a„'memory location. You should look upon this routine„'as a special case of moving bytes in memory.„„'STACKPASSING: bas$,seg%,offs%„„'IN          : Seg, offset =Memory location.„'              bas$        =The string to poke into memory„„'reference: peekstring2loc,pokestring,pokestring2loc„'[This routine is not optimized for .386 use]„'------------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                           'push bp            4„asm = asm + CHR$(&H89) + CHR$(&HE5)              'mov bp,sp          1„„'Set up ds[si] to string, cx to length:„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA)  'mov bx,[bp+0a]     1+9„asm = asm + CHR$(&H8B) + CHR$(&H77) + CHR$(&H2)  'mov si,[bx+02]sadd 1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)               'mov cx,[bx] length 1+5„„'Set up es[di] to memloc:„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx,[bp+06]  1+9„asm = asm + CHR$(&H8B) + CHR$(&H3F)              'mov di,[bx]     1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx,[bp+08]  1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)               'mov ax,[bx]     1+5„asm = asm + CHR$(&H8E) + CHR$(&HC0)              'mov es,ax  3  es[di] to memloc„„asm = asm + CHR$(&HFC)                           'CLD future      2„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'test cl,1 odd ? 1„asm = asm + CHR$(&H74) + CHR$(&H1)               'jz +1         1/3„asm = asm + CHR$(&HA4)                           'movsb         7„asm = asm + CHR$(&HD1) + CHR$(&HE9)              'shr cx,1      3„asm = asm + CHR$(&HF3) + CHR$(&HA5)              'rep movsw     2+7*cx„                    „asm = asm + CHR$(&H5D)                           'pop bp        4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)   'retf 6        14„pokestring2mem$ = asm                            'clocks :      100/102+7*len„„END FUNCTION„„FUNCTION pokeW$„'--------------------------------------------------------------„'This function does nothing more then poke one word to a known„'location. For poking a word into a variable, a string or an„'array you should use more optimized routines.„„'STACKPASSING:  SEGMENT, OFFSET, WORD„'IN          :  SEGMENT,OFFSET= MEMORY LOCATION„'               WORD          = WORD TO POKE INTO MEMORY LOCATION„„'---------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'push bp        4„asm = asm + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp      1„„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'mov bx,[bp+08] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H3F)             'mov di,[bx]    1+5„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'mov bx,[bp+0A] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]    1+5„asm = asm + CHR$(&H8E) + CHR$(&HC0)             'mov es,ax      3 es[di]adress„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'mov bx,[bp+06] 1+9„asm = asm + CHR$(&H8B) + CHR$(&H7)              'mov ax,[bx]    1+5„asm = asm + CHR$(&H26) + CHR$(&H89) + CHR$(&H5) 'es:mov [di],ax 2+5+1 store it„„asm = asm + CHR$(&H5D)                          'pop bp         4„asm = asm + CHR$(&HCA) + CHR$(&H6) + CHR$(&H0)  'retf 6         14„pokeW$ = asm                                    'CLOCKS:        82„„END FUNCTION„„FUNCTION readbit$„'-------------------------------------------------------„'This function reads a bit of an integer or long„„'STACKPASSING: LONG/INT, BITNR„„'IN          : LONG/INT, BITNR„„'OUT         : BITNR=1 BIT SET„'              BITNR=0 BIT NOT SET„„'This function is just an example of the powers of„'assembly language for bitfunctions.„'[this function is not optimized for .386 instructions]„'-------------------------------------------------------„asm = asm + CHR$(&H55)                           'push bp       4„asm = asm + CHR$(&H89) + CHR$(&HE5)              'mov bp,sp     1„„'Get bit to read into CL„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx,[bp+06]1+9„asm = asm + CHR$(&H8B) + CHR$(&HF)               'mov cx,[bx]   1+5„'Get word to check into ax„asm = asm + CHR$(&H8B) + CHR$(&H7E) + CHR$(&H8)  'mov di,[bp+08]1+9„asm = asm + CHR$(&H8B) + CHR$(&H5)               'mov ax,[di]  1+5 lowword„asm = asm + CHR$(&H80) + CHR$(&HF9) + CHR$(&H10) 'cmp cx,16      1„asm = asm + CHR$(&H72) + CHR$(&H6)               'jb go to check 1/3„'Check highword„asm = asm + CHR$(&H8B) + CHR$(&H45) + CHR$(2)    'mov ax,[di+2]1+9 highword„asm = asm + CHR$(&H83) + CHR$(&HE9) + CHR$(&H10) 'sub cx,16    1„asm = asm + CHR$(&HD3) + CHR$(&HE8)              'shR ax,cl    3„asm = asm + CHR$(&H25) + CHR$(&H1) + CHR$(&H0)   'and ax,1  return 1 for set„'Return the bit„asm = asm + CHR$(&H89) + CHR$(&H7)               'mov [bx],ax 1+5„„asm = asm + CHR$(&H5D)                           'pop bp      4„asm = asm + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)   'retf 4      14„readbit$ = asm                                   'CLOCKS      78/80„„END FUNCTION„„Rick Elbers                    ASSEMBLY IN QBASIC 8: ERROR    rick@tip.nl                    04-21-97 (15:45)       QB, QBasic, PDS        582  24164    8ERROR.BAS  'ASSEMBLY IN QBASIC 8: ERRORHANDLING„'---------------------------------------„'RICK ELBERS APRIL 1997( this one thanks to Brian Mclaughlin)„„'---------------„'INTRODUCTION„'--------------„„'This might seem an easy and minor topic, but it is not.„'Getting errors before the program breaks, and return„'an appropriate message to the user, is what could make„'the difference so to speak.„„'In general you should investigate your program and„'make an estimate for what could be expected errors.„'For instance when you prompt the user for a filename,„'and use OPEN [file] FOR INPUT AS [handle] after that,„'then there is a good chance that the file will not„'exist/ or the path will not exist. I think it is good„'habit to handle that errors IN your BASIC program,„'by redoing the userinput for instance. This might seem„'a trivial example, but it is not. Still a lot of QBASIC„'programs which handle userinput, do not have an„'appropriate ERRORHANDLER installed while that is very„'easy to do with ON ERROR GOTO ERRORHANDLER.„„'ERRORHANDLING FOR ASSEMBLY ROUTINES„'***********************************„'Since the topic of this series is assembly in QBASIC„'I will not demonstrate ON ERROR GOTO here. When we„'are using assembly in QBASIC errorhandling is even more„'important. In a lot of cases the errorinformation„'returned from assembly routines is well documented and„'informative. So that gives you the chance to take„'appropriate action, before youre program has to quit„'on every error. For instance when you want to allocate„'100 KB and the message returned says there is only„'10 KB available you can prompt the user for making the„'choice to still allocate 10 KB or to use other measures.„„'MINIMAL ERRORHANDLING„'*********************„'What I consider the absolute minimum for EVERY assembly„'routine is:„„'1) Check for errors occuring.„„'Although quit obvious, a lot of people using INTERRUPTX just„'forget about that. In case you use that INTERRUPTX you should„'test for the carry flag most of the time( flags and 1).„„'2) Print message about in what routine the error occurred.„„'Not so obvious even to experienced programmers.. Take f.i that„'you are going to write a copy routine in asm, and an error is„'occuring while writing. In that case you have still to close„'source AND destiny. But when the error occurred while opening„'the destiny( say you do that after opening the source), then„'you ONLY need to close the SOURCE. And when the error occurred„'while opening the source you do not have to close any file at„'all. See why you need to know WHERE the error occurred ?„„'3) Print message what error occurred.„„'This is probably the most obvious. THe dos errors are well known,„'so it won't be difficult to translate the errornumber( mostly but„'NOT always in AX) to the appropriate message. This is also where„'the concept MINIMAL is getting some meaning. Printing out the„'message about the error will not help much for taking action.„'Much better is of course to add a few errorhandling routines for„'the known errors of a routine.„„'The points above can be operationalized for QBASIC as follows:„„„'ad 1) Assuming you last variable which you pass to the routine is„'some variable ERRS, you can use almost every time some routine„'like this:„„'[some routines use some value of AX( either 0 or 1) to indicate errors,„'but most of them use Carry flag]„„'          INT   whatever„'          JC    errorhandling„'store needed:„'  „'return to QBASIC:„'          POP   BP„'          RETF  N   „'errorhandling:„'          MOV   BX,[BP+06]„'          MOV   [BX],AX„'          JMP   return to QBASIC:„„'This routine is optimized for no_error! In fact the errorhandling is„'slow beyond belief[ two jumps taken and pipe line stall], but in case„'of error that is not so tragic. It writes NOTHING to the variable„'ERRS if there was no error, so ERRS will remain the same as before.„'Apart from making better optimizing that is also better habit then„'writing 0 to it. When you always use the same ERRS then a former ERROR„'will still show in a later routine, which is nice double check!.„„'ad 2) When you use simple asm routines which call only 1 interrupt or„'handler then you know on beforehand that the error reported has„'occured in that interrupt. Typically my QBASIC routines calling absolute„'are looking like this:„„'DEF SEG=STRINGSEG„'CALL ABSOLUTE(VAR,VAR,VAR,ERRS,SADD(ROUTINE$)„'IF ERRS THEN„'   PRINT "THERE WAS AN ERROR WHILE ......"„'ELSE„'   PRINT "SUCCESFULLY DID ........."„'ENDIF„„'Of course on .....you should fill in the routines exact purpose ( opening„'a file, allocating low memory etc..).„„'When you use complex asm routines which are calling more interrupts,„'device drivers then you need some additions. First of all your asm„'routine needs to store a WHEREID in AH( AL contains dos error), which„'can be done using some algorithm like this:„„'          INT   whatever„'          MOV   AH,WHEREID      'f.i 1st routine gets 0, 2nd 1 etc„'          JC    errorhandling„'store needed:„'  „'return to QBASIC:„'          POP   BP„'          RETF  N   „'errorhandling:„'          MOV   BX,[BP+06]„'          MOV   [BX],AX„'          JMP   return to QBASIC:„„'Since MOV does not affect flags the JC jump is still valid.„'Note: An important trick for control of your errorhandling is„'to reverse the jumps„„'In addition to this errorhandling in asm routine you also need„'some addition in the calling absolute statements like so:„„'DEF SEG=STRINGSEG„'CALL ABSOLUTE(VAR,VAR,VAR,ERRS,SADD(ROUTINE$)„'IF ERRS THEN„' WHEREID=(ERRS/&H100)AND &HFF:ERRS=ERRS AND &HFF„' SELECT CASE WHEREID„'   CASE 1„'   PRINT "THERE WAS AN ERROR WHILE ......"„'   CASE 2„'   PRINT "THERE WAS AN ERROR WHILE......."„'   CASE 3„'   PRINT "THERE WAS AN ERROR WHILE......."„' END SELECT„'ELSE„'   PRINT "SUCCESFULLY DID ........."„'ENDIF„„'Of course this will not cut it in most cases since complex routines„'often needs actions to be taken on some errors, but this is the„'first necessary step! And even after action has been taken this kind„'of routine can tell you how far the routine has executed fine..„„'ad 3) For automating doserrorhandling I made the SUB ERRORHANDLING,„'(with a change suggested by Tyler Barnes), which just prints the„'appropriate message if provided the errornumber. You should adjust„'your routines to call this routine after you print the WHEREID like„'this:„„'DEF SEG=STRINGSEG„'CALL ABSOLUTE(VAR,VAR,VAR,ERRS,SADD(ROUTINE$)„'IF ERRS THEN„'   PRINT "THERE WAS AN ERROR WHILE ......, "„'   CALL ERRORHANDLING(ERRS)„'ELSE„'   PRINT "SUCCESFULLY DID ........."„'ENDIF„„'For the complex routines you can make 1 call to errorhandler after„'END SELECT. I'll leave that up to you.„„'This is basically what errorhandling is about. It took me months of„'experimenting with a lot of different formats to finally find out that„'this might be the best one.„„'For the sake of experimenting a somewhat more maximalized errorhandling„'which still bears the same principles I include a LFN file copier.„'It is still running beta, and does not yet copy filetimes too, but„'it seems to work just fine, including the actions taken on errors.„„DECLARE SUB COPYDEMO ()„DECLARE SUB ERRORHANDLING (ERRS%)„DECLARE FUNCTION COPYLFN$ ()„„'This is program in stage beta 2. Attributes seems oke.„'Filetimes will be added later..„„'All kind of situations are handled oke, like the destiny„'can not be existant, if an read/write error is encountered„'then open files are closed etc..„„'If someone still finds some files open, or some other bug,„'be so kind to mail me so that I can update it. I am getting„'bored testing thats why..„„DEFINT A-Z„„CLS„CALL COPYDEMO„„„'Good bye,„„'Rick(rick@tip.nl)„„„„END„„SUB COPYDEMO„„'This will give a demonstration of the filecopier:„'From a dosbox you can copy from short to lfn from lfn to lfn,„'from lfn to short and from short to short„'From plain dos you can copy from short(alias) to short(alias).„'GOOD luck. RIck( currently beta2: next version will copy filetimes too!)„„'INITIATING..„„copyit$ = COPYLFN$„DEF SEG = VARSEG(copyit$)„„„'USERINPUT:„„PRINT "WHICH SOURCE DO YOU WANT TO COPY..? ";„COLOR 0, 7: DO: LINE INPUT src$„  LOOP UNTIL src$ <> ""„„COLOR 7, 0: PRINT "COPY SOURCE TO WHICH DESTINY......? ";„COLOR 0, 7: DO: LINE INPUT dest$„  LOOP UNTIL dest$ <> ""„„'GO RUN IT.."„PRINT "COPYING....": PRINT„„a! = TIMER„CALL absolute(src$, dest$, ERRS, SADD(copyit$))„b! = TIMER: DEF SEG„IF ERRS THEN„  id = (ERRS / &H100) AND &HFF: ERRS = ERRS AND &HFF„  IF id = 1 THEN„    PRINT "ERROR OPENING SOURCE, ";„  ELSEIF id = 2 THEN„    PRINT "ERROR GETTING SOURCE ATTRIBUTES, ";„  ELSEIF id = 4 THEN„    PRINT "ERROR CREATING DESTINY, ";„  ELSEIF id = 8 THEN„    PRINT "ERROR READING FROM SOURCE, ";„  ELSEIF id = 16 THEN„    PRINT "ERROR WRITING TO DESTINY, ";„  ELSEIF id = 32 THEN„    PRINT "ERROR CLOSING DESTINY, ";„  ELSE„    PRINT "ERROR CLOSING SOURCE, ";„  END IF„  CALL ERRORHANDLING(ERRS)„ELSE„  COLOR 7, 0: PRINT "COPIED FILE: "; : COLOR 0, 7: PRINT src$;„  COLOR 7, 0: PRINT " TO: "; : COLOR 0, 7: PRINT dest$; : COLOR 7, 0:„  PRINT " IN : "; : COLOR 0, 7: PRINT b! - a!; : COLOR 7, 0: PRINT " ticks";„END IF„„END SUB„„DEFSTR A-Z„FUNCTION COPYLFN$„'---------------------------------------------------„'STACKPASSING: FILENAME1,FILENAME2,ERRS„„'copy it using byte per byte copy..„'IN          : FILENAME SRC  ASCI..„'              FILENAME DEST ASCI..„'OUT         : ERRS = 0 OR ERROR„'              ERRS HIGHBYTE=1 OPEN SOURCE ERROR„'                           =2 GET ATTRIBUTES ERROR„'                           =4 CREATE DESTINY ERROR„'                           =8 READ ERROR„'                           =16 WRITE ERROR„'                           =32 CLOSE DESTINY ERROR„'                           =64 CLOSE SOURCE ERROR„'                   LOWBYTE =DOSERRORCODE..„'---------------------------------------------------„'------------********************************-----------------------„'            *BUFFER FOR WIN PATH/ FILENAMES*„'            ********************************„„DIM srcnamebuffer AS STRING * 260               'FILE/PATH BUFFER.„offset% = VARPTR(srcnamebuffer)„DIM DESTnamebuffer AS STRING * 260„offset2% = VARPTR(DESTnamebuffer)„'-------------------------------------------------------------------„'COPYBUFFER NEEDS TO BE STATIC TOO„DIM BUFFER AS STRING * 512: OFFS% = VARPTR(BUFFER)„„'--------------------------------------------------------------------„asm = ""„asm = asm + CHR$(&H55)                          'PUSH BP„asm = asm + CHR$(&H89) + CHR$(&HE5)             'MOV BP,SP„'************„'OPEN SOURCE„'************„'STORE NAME IN BUFFER AND APPEND A ZERO..„asm = asm + CHR$(&H6)                           'PUSH ES„asm = asm + CHR$(&HFC)                          'CLD„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&HA) 'MOV BX,[BP+A]„asm = asm + CHR$(&H8B) + CHR$(&H77) + CHR$(&H2) 'MOV SI,[BX+2]OFFSET(FILE)„asm = asm + CHR$(&H8B) + CHR$(&HF)              'MOV CX,[BX]  LEN(FILE)„asm = asm + CHR$(&HBF) + MKI$(offset%)          'MOV DI,OFFSET(SRCBUFFER)„asm = asm + CHR$(&H89) + CHR$(&HFA)             'MOV DX,DI FOR WIN FUNCTION„asm = asm + CHR$(&HE) + CHR$(&H7)               'PUSH CS:POP ES ES=CS„asm = asm + CHR$(&HF3) + CHR$(&HA4)             'REP MOVSB„asm = asm + CHR$(&HB0) + CHR$(&H0)              'MOV AL,0„asm = asm + CHR$(&HAA)                          'STOSB APPEND 0„„'FILENAME TO DS[SI]„asm = asm + CHR$(&H89) + CHR$(&HD6)             'MOV SI,DX TO FILENAME„„'OPEN&MADE MASK TO DL(open if exist)„asm = asm + CHR$(&HBA) + MKI$(&H1)              'MOV DX,1„„'READ&WRITE MASK TO BX(open for read only)„asm = asm + CHR$(&H31) + CHR$(&HDB)             'XOR BX,BX„„'WINDOWS OPEN EXTENDED..„asm = asm + CHR$(&HB8) + CHR$(&H6C) + CHR$(&H71)'MOV AX,716C„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21„asm = asm + CHR$(&HBA) + MKI$(offset%)          'MOV DX,OFFSET(SRC BUFFER)„asm = asm + CHR$(&H72) + CHR$(107)              'JC +107 DOS OPEN SRC ?„'GO ON :SAVE SCR HANDLE                1„asm = asm + CHR$(&H50)                          'PUSH AX SAVE SRC HANDLE„'GET ATTRIBUTES TO CX„'EXECUTE WINDOZE FUNCTION 43h          13„asm = asm + CHR$(&HB3) + CHR$(&H0)              'MOV BL,0 GET ATTRIBS„asm = asm + CHR$(&HB8) + CHR$(&H43) + CHR$(&H71)'MOV AX,7143„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21„asm = asm + CHR$(&H72) + CHR$(120)              'JC +120 GET ATTRIB ERRS„asm = asm + CHR$(&H51)                          'PUSH CX SAVE ATTRIBUTES„„'*******************„'CREATE DESTINY..„'*******************„'STORE NAME IN BUFFER AND APPEND A ZERO..20„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8) 'MOV BX,[BP+8]„asm = asm + CHR$(&H8B) + CHR$(&H77) + CHR$(&H2) 'MOV SI,[BX+2]OFFSET(FILE)„asm = asm + CHR$(&H8B) + CHR$(&HF)              'MOV CX,[BX]  LEN(FILE)„asm = asm + CHR$(&HBF) + MKI$(offset2%)         'MOV DI,OFFSET(DESTBUFFER)„asm = asm + CHR$(&H89) + CHR$(&HFA)             'MOV DX,DI FOR WIN FUNCTION„asm = asm + CHR$(&HE) + CHR$(&H7)               'PUSH CS:POP ES ES=CS„asm = asm + CHR$(&HF3) + CHR$(&HA4)             'REP MOVSB„asm = asm + CHR$(&HB0) + CHR$(&H0)              'MOV AL,0„asm = asm + CHR$(&HAA)                          'STOSB APPEND 0„„'FILENAME TO DS[SI]                      2„asm = asm + CHR$(&H89) + CHR$(&HD6)             'MOV SI,DX TO FILENAME„„'OPEN&MADE MASK TO DL(make if not exist) 3„asm = asm + CHR$(&HBA) + MKI$(&H10)             'MOV DX,10„„'READ&WRITE MASK TO BX(open for write only) 3„asm = asm + CHR$(&HBB) + MKI$(&H1)              'MOV BX,1„„'FILETYPE TO CX                             2„asm = asm + CHR$(&H59)                          'POP CX ATTRIBUTES SRC„„'WINDOWS OPEN EXTENDED..                    7„asm = asm + CHR$(&HB8) + CHR$(&H6C) + CHR$(&H71)'MOV AX,716C„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21„asm = asm + CHR$(&H72) + CHR$(93)               'JC +93 DOS EXTENDED OPEN?„'GO ON: SAVE DESTINY HANDLE TO DI,SRC HANDLE TO SI          3„asm = asm + CHR$(&H5E)                          'POP SI GET SRC HANDLE TO SI„asm = asm + CHR$(&H89) + CHR$(&HC7)             'MOV DI,AX SAVE DEST HANDLE„„'COPY..                                    6„asm = asm + CHR$(&HB9) + MKI$(&H200)            'MOV CX,512 BUFFERLENGTH„asm = asm + CHR$(&HBA) + MKI$(OFFS%)            'MOV DX,OFFSET(BUFFER)„'COPYLOOP..                                6„asm = asm + CHR$(&H89) + CHR$(&HF3)             'MOV BX,SI SRC HANDLE„asm = asm + CHR$(&HB4) + CHR$(&H3F)             'MOV AH,3F„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21 READ SRC„'ERROR HANDLING                           12„asm = asm + CHR$(&H72) + CHR$(107)              'JC +107 READ ERROR„asm = asm + CHR$(&H39) + CHR$(&HC1)             'CMP AX,CX EOF REACHED ?„asm = asm + CHR$(&H89) + CHR$(&HFB)             'MOV BX,DI DEST HANDLE„asm = asm + CHR$(&H75) + CHR$(&H8)              'JNE +8 EOF„asm = asm + CHR$(&HB4) + CHR$(&H40)             'MOV AH,40„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21 WRITE DEST„'ERROR HANDLING                            4„asm = asm + CHR$(&H72) + CHR$(104)              'JC +104 WRITE ERROR„asm = asm + CHR$(&HEB) + CHR$(&HEA)             'JMP COPYLOOP -22„'EOF HANDLING( WRITE LAST BYTES)        8„asm = asm + CHR$(&H89) + CHR$(&HC1)             'MOV CX,AX„asm = asm + CHR$(&HB4) + CHR$(&H40)             'MOV AH,40„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21 WRITE DEST„asm = asm + CHR$(&H72) + CHR$(94)               'JC +94 WRITE ERROR„'CLOSE DEST HANDLE                      6„asm = asm + CHR$(&H89) + CHR$(&HFB)             'MOV BX,DI CLOSE DESTINY HANDLE„asm = asm + CHR$(&HB4) + CHR$(&H3E)             'MOV AH,3E„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21 CLOSE DESTINY„'ERROR HANDLING                         2„asm = asm + CHR$(&H72) + CHR$(95)               'JC +95 CLOSE DEST ERROR„'CLOSE SCR HANDLE                       6„asm = asm + CHR$(&H89) + CHR$(&HF3)             'MOV BX,SI CLOSE SOURCE HANDLE„asm = asm + CHR$(&HB4) + CHR$(&H3E)             'MOV AH,3E„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21 CLOSE SOURCE„'ERROR HANDLING                         2„asm = asm + CHR$(&H72) + CHR$(96)               'JC +96 CLOSE SRC ERROR„'RETURN(NO) ERROR AND TO QBASIC..       5„asm = asm + CHR$(&H7)                           'POP ES„asm = asm + CHR$(&H5D)                          'POP BP„asm = asm + CHR$(&HCA) + MKI$(6)                'RETF 6„„'ERROR HANDLING: DOSFUNCTIONS ?„'WIN95 FUNCTION OPEN SRC ERROR..       5„asm = asm + CHR$(&H3D) + CHR$(&H0) + CHR$(&H71) 'CMP AX,7100 FUNCTION UNSUPPORTED ?„asm = asm + CHR$(&H75) + CHR$(42)               'JNZ +42 OPEN SRC ERROR..„'IF SO EXECUTE DOS FUNCTION &H6C(EXTENDED OPEN) 8„asm = asm + CHR$(&HB8) + MKI$(&H6C00)           'MOV AX,6C00„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21„asm = asm + CHR$(&H72) + CHR$(35)               'JC +35 OPEN SRC ERROR„asm = asm + CHR$(&H50)                          'PUSH AX SAVE SRC HANDLE„'IF SO EXECUTE DOS FUNCTION &H4300(GET ATTRIBS) 10„asm = asm + CHR$(&HB8) + MKI$(&H4300)           'MOV AX,4300„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21„asm = asm + CHR$(&H72) + CHR$(3)                'JC +3 GET ATTRIBS ERROR„asm = asm + CHR$(&H51)                          'PUSH CX SAVE ATTRIBUTES„asm = asm + CHR$(&HEB) + CHR$(&H77)             'JMP -119 GO ON CREATE DEST..„'GET ATTRIBUTES ERROR:                     10„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„asm = asm + CHR$(&HB4) + CHR$(&H2)              'MOV AH,2„asm = asm + CHR$(&H89) + CHR$(&H7)              'MOV [BX],AX„asm = asm + CHR$(&H5E)                          'POP SI NEED SRC HANDLE„asm = asm + CHR$(&HEB) + CHR$(&HD2)             'JMP -46 CLOSE SOURCE„'WIN95 FUNCTION ERROR ON CREATING DESTINY     5„asm = asm + CHR$(&H3D) + CHR$(&H0) + CHR$(&H71) 'CMP AX,7100 FUNCTION UNSUPPORTED ?„asm = asm + CHR$(&H75) + CHR$(16)               'JNZ +16 CREATE DESTINY ERROR..„'IF SO EXECUTE DOS FUNCTION &H6C(EXTENDED OPEN) 9„asm = asm + CHR$(&HB8) + MKI$(&H6C00)           'MOV AX,6C00„asm = asm + CHR$(&HCD) + CHR$(&H21)             'INT 21„asm = asm + CHR$(&H72) + CHR$(9)                'JC +9 CREATE DESTINY ERROR„asm = asm + CHR$(&HEB) + CHR$(&H95)             'JMP -107 GO ON COPY FILE„'ERRORHANDLING     27             37        48„'**************„'OPEN SRC ERROR:                       7„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„asm = asm + CHR$(&HB4) + CHR$(&H1)              'MOV AH,1„asm = asm + CHR$(&HEB) + CHR$(&HC5)             'JMP -59 RETURN BASIC„'CREATE DEST ERROR:                     10„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„asm = asm + CHR$(&HB4) + CHR$(&H4)              'MOV AH,4„asm = asm + CHR$(&H89) + CHR$(&H7)              'MOV [BX],AX„asm = asm + CHR$(&H5E)                          'POP SI NEED SRC HANDLE„asm = asm + CHR$(&HEB) + CHR$(&HB3)             'JMP -77 CLOSE SOURCE..„'READERROR:                           9„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„asm = asm + CHR$(&HB4) + CHR$(&H8)              'MOV AH,8„asm = asm + CHR$(&H89) + CHR$(&H7)              'MOV [BX],AX„asm = asm + CHR$(&HEB) + CHR$(&HA2)             'JMP -94 CLOSE DESTINY/SOURCE..„'WRITEERROR:                           9„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„asm = asm + CHR$(&HB4) + CHR$(16)               'MOV AH,16„asm = asm + CHR$(&H89) + CHR$(&H7)              'MOV [BX],AX„asm = asm + CHR$(&HEB) + CHR$(&H99)             'JMP -103 CLOSE DESTINY/SOURCE..„'CLOSE DESTINY ERROR                    9„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„asm = asm + CHR$(&HB4) + CHR$(32)               'MOV AH,32„asm = asm + CHR$(&H89) + CHR$(&H7)              'MOV [BX],AX ERROR OR 0„asm = asm + CHR$(&HEB) + CHR$(&H98)             'JMP -104 CLOSE SOURCE„'CLOSE SOURCE ERROR:                    4„asm = asm + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6) 'MOV BX,[BP+06]„asm = asm + CHR$(&HB4) + CHR$(64)               'MOV AH,64„asm = asm + CHR$(&H89) + CHR$(&H7)              'MOV [BX],AX ERROR OR 0„asm = asm + CHR$(&HEB) + CHR$(&H97)             'JMP -105 RETURN TO BASIC„COPYLFN = asm„„END FUNCTION„„DEFINT A-Z„SUB ERRORHANDLING (ERRS)„„„DIM ERRORS$(&H5A)„ERRORS$(1) = "INVALID FUNCTION NUMBER"„ERRORS$(2) = "FILE NOT FOUND"„ERRORS$(3) = "PATH NOT FOUND"„ERRORS$(4) = "TOO MANY OPEN FILES (NO HANDLES LEFT)"„ERRORS$(5) = "ACCESS DENIED"„ERRORS$(6) = "INVALID HANDLE"„ERRORS$(7) = "MEMORY CONTROL BLOCKS DESTROYED"„ERRORS$(8) = "INSUFFICIENT MEMORY"„ERRORS$(9) = "INVALID MEMORY BLOCK ADDRESS"„ERRORS$(10) = "INVALID ENVIRONMENT"„ERRORS$(11) = "INVALID FORMAT"„ERRORS$(12) = "INVALID ACCESS MODE (OPEN MODE IS INVALID)"„ERRORS$(13) = "INVALID DATA"„ERRORS$(14) = "RESERVED"„ERRORS$(15) = "INVALID DRIVE SPECIFIED"„ERRORS$(16) = "ATTEMPT TO REMOVE CURRENT DIRECTORY"„ERRORS$(17) = "NOT SAME DEVICE"„ERRORS$(18) = "NO MORE FILES"„ERRORS$(19) = "ATTEMPT TO WRITE ON A WRITE-PROTECTED DISKETTE"„ERRORS$(20) = "UNKNOWN UNIT"„ERRORS$(21) = "DRIVE NOT READY"„ERRORS$(22) = "UNKNOWN COMMAND"„ERRORS$(23) = "CRC ERROR"„ERRORS$(24) = "BAD REQUEST STRUCTURE LENGTH"„ERRORS$(25) = "SEEK ERROR"„ERRORS$(26) = "UNKNOWN MEDIA TYPE"„ERRORS$(27) = "SECTOR NOT FOUND"„ERRORS$(28) = "PRINTER OUT OF PAPER"„ERRORS$(29) = "WRITE FAULT"„ERRORS$(30) = "READ FAULT"„ERRORS$(31) = "GENERAL FAILURE"„ERRORS$(32) = "SHARING VIOLATION"„ERRORS$(33) = "LOCK VIOLATION"„ERRORS$(34) = "INVALID DISK CHANGE"„ERRORS$(35) = "FCB UNAVAILABLE"„ERRORS$(36) = "SHARING BUFFER OVERFLOW"„ERRORS$(37) = "RESERVED"„ERRORS$(38) = "UNABLE TO COMPLETE FILE OPERATION (DOS 4.X)"„ERRORS$(39) = "1 RESERVED"„ERRORS$(40) = "UNINDENTIFIED FLYING OBJECT!"„ERRORS$(41) = ERRORS$(40): ERRORS$(42) = ERRORS$(40): ERRORS$(43) = ERRORS$(40)„ERRORS$(44) = ERRORS$(40): ERRORS$(45) = ERRORS$(40): ERRORS$(46) = ERRORS$(40)„ERRORS$(47) = ERRORS$(40): ERRORS$(48) = ERRORS$(40): ERRORS$(49) = ERRORS$(40)„ERRORS$(50) = "NETWORK REQUEST NOT SUPPORTED"„ERRORS$(51) = "REMOTE COMPUTER NOT LISTENING"„ERRORS$(52) = "DUPLICATE NAME ON NETWORK"„ERRORS$(53) = "NETWORK NAME NOT FOUND"„ERRORS$(54) = "NETWORK BUSY"„ERRORS$(55) = "NETWORK DEVICE NO LONGER EXISTS"„ERRORS$(56) = "NETBIOS COMMAND LIMIT EXCEEDED"„ERRORS$(57) = "NETWORK ADAPTER ERROR"„ERRORS$(58) = "INCORRECT NETWORK RESPONSE"„ERRORS$(59) = "UNEXPECTED NETWORK ERROR"„ERRORS$(60) = "INCOMPATIBLE REMOTE ADAPTER"„ERRORS$(61) = "PRINT QUEUE FULL"„ERRORS$(62) = "NO SPACE FOR PRINT FILE"„ERRORS$(63) = "PRINT FILE DELETED"„ERRORS$(64) = "NETWORK NAME DELETED"„ERRORS$(65) = "ACCESS DENIED"„ERRORS$(66) = "NETWORK DEVICE TYPE INCORRECT"„ERRORS$(67) = "NETWORK NAME NOT FOUND"„ERRORS$(68) = "NETWORK NAME LIMIT EXCEEDED"„ERRORS$(69) = "NETBIOS SESSION LIMIT EXCEEDED"„ERRORS$(70) = "TEMPORARILY PAUSED"„ERRORS$(71) = "NETWORK REQUEST NOT ACCEPTED"„ERRORS$(72) = "PRINT OR DISK REDIRECTION IS PAUSED"„ERRORS$(73) = ERRORS$(40): ERRORS$(74) = ERRORS$(40)„ERRORS$(75) = ERRORS$(40): ERRORS$(76) = ERRORS$(40)„ERRORS$(77) = ERRORS$(40): ERRORS$(78) = ERRORS$(40): ERRORS$(79) = ERRORS$(40)„ERRORS$(80) = "FILE ALREADY EXISTS"„ERRORS$(81) = "RESERVED"„ERRORS$(82) = "CANNOT MAKE DIRECTORY ENTRY"„ERRORS$(83) = "FAIL ON INT 24"„ERRORS$(84) = "TOO MANY REDIRECTIONS"„ERRORS$(85) = "DUPLICATE REDIRECTION"„ERRORS$(86) = "INVALID PASSWORD"„ERRORS$(87) = "INVALID PARAMETER"„ERRORS$(88) = "NETWORK DEVICE FAULT"„ERRORS$(89) = "FUNCTION NOT SUPPORTED BY NETWORK (DOS 4.X)"„ERRORS$(90) = "REQUIRED SYSTEM COMPONENT NOT INSTALLED (DOS 4.X)"„„PRINT "BECAUSE ";„IF ERRS > &H5A OR ERRS = 0 THEN„  PRINT "YOU ARE ( OR SHOULD BE) DEBUGGING YOUR ASM$ ROUTINE"„ELSE„  PRINT ERRORS$(ERRS)„END IF„„END SUB„Rick Elbers                    ASSEMBLY IN QBASIC 9: 386CODE  rick@tip.nl                    04-24-97 (10:00)       QB, QBasic, PDS        818  32224    9CODE386.BASDECLARE SUB CPYDEMO ()                 'demonstrating .386 blockcopy„DECLARE FUNCTION GETSCREEN13$ ()„DECLARE FUNCTION PUTSCREEN13$ ()„DECLARE FUNCTION BLOCKCPY$ ()          'aligned blockcopy„„DECLARE SUB CPU386ID ()                'do we have 386+„DECLARE SUB MULLEA ()                  'demonstrating multiply with LEA„DECLARE SUB PMODE.DETECT ()            'are we in pmode ?„„'ASSEMBLY IN QBASIC 9: .386 CODING.(rick@tip.nl)„'------------------------------------„CLS„'INTRODUCTION„'------------„'„'Although most people run there programs on a pentium nowadays, most„'programmers still consider the .386 the last real change. The .386„'PC added a lot of new instructions to the set, it added the use„'of 32 bit wide extended registers, and it added a usable pmode.„'Compared to the changes mentioned the changes the .486 ( pipeline)„'and pentium( double pipeline) added were only minor. In this article„'I will shortly touch upon the various .386 topics and include also„'a paragraph about the meaning of the .486 for your code. Pentium„'optimizing goes unnoticed here. It is hoped that after reading„'this article you have an idea how to use .386 codes inside QBASIC and„'also have some basic feeling for .386/.486 optimizing. That will give„'you a start when studying 'real' optimizing texts..„„'--------------------------------------„'A)INTRODUCTION TO EXTENDED REGISTERS„'--------------------------------------„'Since a lot of QBASIC users do not have .386 assemblers but only debug„'or valarrow at their disposal, they might have trouble to find out that„'QBASIC is quit capable of executing .386 codes too. That is why I„'will summarize the rules for extended register use below.„„'I will assume that everyone has the ability to get the .286„'instructions decoded with debug, and will only add the rules„'needed to extend those instructions.„„'1)EXTENDED REGISTERS AS REGISTERS:„'RULE: ADD &H66 BEFORE THE 8086 MACHINE CODE„„'EXAMPLES:„'   MOV AX,BX    =      &H8B &HC3„'   MOV EAX,EBX  = &H66 &H8B &HC3„„'   XCHG AX,[BX] =      &H87 &H7„'   XCHG EAX,[BX]= &H66 &H87 &H7„„'   MOV [BX],AX  =      &H89 &H7„'   MOV [BX],EAX = &H66 &H89 &H7„„'   XOR AX,AX    =      &H31 &HC0„'   XOR EAX,EAX  = &H66 &H31 &HC0„„'2) EXTENDED REGISTERS IN MEMORY REFERENCES:„'RULE: ADD &H67 BEFORE THE 8086 MACHINE CODE„„'EXAMPLES:„'   MOV AX, [BX] =      &H8B &H07„'   MOV AX,[EBX] = &H67 &H8B &H07„„'   XCHG AX,[BX] =      &H87 &H7„'   XCHG AX,[EBX]= &H67 &H87 &H7„„'   MOV [BX],AX  =      &H89 &H7„'   MOV [EBX],AX = &H67 &H89 &H7„„'3) EXTENDED REGISTERS IN REGISTERS AND MEMORY REFERENCES:„'RULE: ADD &H67 &H66 BEFORE THE 8086 MACHINE CODE„„'EXAMPLES:„'   MOV AX , [BX] =           &H8B &H07„'   MOV AX ,[EBX] = &H67      &H8B &H07„'   MOV EAX,[EBX] = &H67 &H66 &H8B &H07„'   MOV AX ,[BX]  =      &H66 &H8B &H07„„'   XCHG AX ,[BX] =           &H87 &H07„'   XCHG AX ,[EBX]= &H67      &H87 &H07„'   XCHG EAX,[EBX]= &H67 &H66 &H87 &H07„'   XCHG EAX,[BX] =      &H66 &H87 &H07„„'   MOV [BX] ,AX  =           &H89 &H07„'   MOV [EBX],AX  = &H67      &H89 &H07„'   MOV [EBX],EAX = &H67 &H66 &H89 &H07„'   MOV [BX] ,EAX =      &H66 &H89 &H07„	 „'B) INTRODUCTION TO NEW AND EXTENDED INSTRUCTIONS„„'The .386 instruction set has a lot of new instructions and„'(dword)extended old instructions. I will introduce them and the„'rules to get them from debug's 8086 codes.„„'1) MOVSD,STOSD,LODSD„'RULE: ADD &H66 BEFORE THE 8086 WORD MACHINE CODES„„'EXAMPLES:„'   MOVSW      =      &HA5„'   MOVSD      = &H66 &HA5„	„'   STOSW      =      &HAB„'   STOSD      = &H66 &HAB„„'   LODSW      =      &HAD„'   LODSD      = &H66 &HAD„„'2) SHIFTS FOR MORE THEN ONE WITHOUT USING CL„„'RULE: REPLACE THE FIRST BYTE OF THE 8086 MACHINE CODE BY &HC1„'      AND ADD THE NUMBER OF SHIFTS AS LAST BYTE„„'EXAMPLES:„'   SHL DX,1   =      &HD1 &HE2„'   SHL DX,CL  =      &HD3 &HE2„'   SHL DX,2   =      &HC1 &HE2 &H2„'   SHL EDX,4  = &H66 &HC1 &HE2 &H4„„'   SHR AX,1   =      &HD1 &HE8„'   SHR AX,CL  =      &HD3 &HE8„'   SHR AX,5   =      &HC1 &HE8 &H5„'   SHR EAX,9  = &H66 &HC1 &HE8 &H9„„'3)CALL DWORDPOINTERS„'RULE:SUBSTRACT 9 FROM THE REGISTER SPECIFIC 8086 POINTERS„'     (WHICH IS THE SECOND BYTE)„ „'EXAMPLES:„'   CALL  WORDPTR[BX] = &HFF &H1F„'   CALL DWORDPTR[BX] = &HFF &H17„„'   CALL  WORDPTR[SI] = &HFF &H1C„'   CALL DWORDPTR[SI] = &HFF &H14„„'   CALL  WORDPTR[DI] = &HFF &H1D„'   CALL DWORDPTR[DI] = &HFF &H15„„'4)POPA( POPAD)/PUSHA( PUSHAD)=„„'This is a relativaly cheap way of pushing and popping all„'general purpose registers( that is ax,cx,dx,bx,sp,bp,si,di)„'totals up to 16 bytes pushed on the stack:„„'EXAMPLES: PUSHA = &H60  CLOCKS ON 486: 11„'          POPA  = &H61  CLOCKS ON 486: 9„„'SO THIS TOTALS UP TO:If you have to push/pop more then„'three of the general purpose registers you could optimize„'for speed by PUSHA/POPA SEQUENCE instead of push/pop„'of 4 clocks each.„„'Of course the extended register can be pushed/popped by„'adding &h66 before the opcode for PUSHA/POPA„„'EXAMPLES: PUSHAD = &H66 &H60„'          POPAD  = &H66 &H61„„'5) LEA instruction.„„'The LEA instruction is extended in two directions. First of all it„'can have every register as memory reference, secondly it allows you„'put some simple adress multiplications INSIDE the LEA instruction.„'Together that adds up to that you can use LEA to do some quick„'multiplications.„„'GENERAL FORM: LEA Ereg,[Ereg*2^N+[Ereg]+[displacement]„'                        N IN [0..3]„„'EXAMPLES: LEA EAX,[EAX*8-EAX] CALCULATES EAX*7„„'RULE= ALWAYS PREFIXING &H66 &H67 &H8D( EXT,EXT, LEA)„'      AFTER THAT SOME CODES POINTING TO THE REGISTERS AND„'      MEMORY OPERANDS USED.„„'Alas, the rules for getting to the other bytes are beyond me.„'So you can not use those in QBASIC when you do not have a .386„'assembler to verify that. As sort of a patch I will give the„'opcodes for LEA instructions I use most.„„„'EXAMPLES:„' LEA EAX,[EAX]        = &H66 &H67 &H8D &H00„' LEA EAX,[EAX*2]      = &H66 &H67 &H8D &H04 &H45 &H00000000„' LEA EAX,[EAX*2+4]    = &H66 &H67 &H8D &H04 &H45 &H00000004„' LEA EAX,[EAX*2]      = &H66 &H67 &H8D &H04 &H45 &H00000000„' LEA EAX,[EAX*2+EAX]  = &H66 &H67 &H8D &H04 &H40„' LEA EAX,[EAX*2+EBX]  = &H66 &H67 &H8D &H04 &H43„' LEA EAX,[EAX*2+EAX+4]= &H66 &H67 &H8D &H44 &H40 &H04„' LEA EAX,[EAX*2+EBX+4]= &H66 &H67 &H8D &H44 &H43 &H04„'„' LEA EAX,[EAX*4]      = &H66 &H67 &H8D &H04 &H85 &H00000000„' LEA EAX,[EAX*4+3]    = &H66 &H67 &H8D &H04 &H85 &H00000003„' LEA EAX,[EAX*4+EAX]  = &H66 &H67 &H8D &H04 &H80„' LEA EAX,[EAX*4+EBX]  = &H66 &H67 &H8D &H04 &H83„' LEA EAX,[EAX*4+EAX+4]= &H66 &H67 &H8D &H84 &H80 &H00000004„' LEA EAX,[EAX*4+EBX+4]= &H66 &H67 &H8D &H84 &H83 &H00000004„„' LEA EAX,[EAX*4]      = &H66 &H67 &H8D &H04 &HC5 &H00000000„' LEA EAX,[EAX*4+3]    = &H66 &H67 &H8D &H04 &HC5 &H00000003„' LEA EAX,[EAX*4+EAX]  = &H66 &H67 &H8D &H04 &HC0„' LEA EAX,[EAX*4+EBX]  = &H66 &H67 &H8D &H04 &HC3„' LEA EAX,[EAX*4+EAX+4]= &H66 &H67 &H8D &H44 &HC0 &H00000004„' LEA EAX,[EAX*4+EBX+4]= &H66 &H67 &H8D &H44 &HC3 &H00000004„„'After a little thought we might agree that the displacement is viewed„'as a long value( use MKL$ for that), that the byte thats before that„'is signifying the number of the multiplication( &hC, &h8, &h4 for multiples„'by 8,4,2) and also the register used for multiply(&h3=(e)bx,&h5=(e)ax, etc„'you can get that with debug).„„'To know what you can do with LEA I have prepared some example code„'It will give a short example of a program to use for multiplication by 1021.„„'At first it might look more difficult then using MUL, but :„„'a) It is not, since MUL puts results in DX:AX and you have to get that„'    back too.„'b) It is a lot faster. In general LEA is better to use when you have„'   to do a multiplication by a constant which you can hardcode..„„'look for *all* information about multiplying with a constant using„'the most optimized methods on Paul Hsiehs homepage at:„'HTTP://WWW.GEOCITIES.COM/SILICONVALLEY/9498/amult.html„„CALL MULLEA„„„'6)SET CC INSTRUCTIONS„„'On .386 processors there are a lot of SET instructions available„'which can be used to avoid JUMPS in a relativaly cheap way.„'In general all JUMPS have there eguivalent in SETS like:„„'SETNZ , SETZ, SETC, SETNC, SETAE, SETB, etc etc„„'The SET instructions needs one 8 bit operand. It can be a 8 bit memory„'reference or an eight bit register:„„'SETZ AL OKE„'SETZ AH OKE„'SETZ AX ERROR„„'SETZ BYTE PTR [BX] OKE„'SETZ BYTE PTR [100] NOT OKE( Not a memory reference but immidiate.„„'The opcode consist of three parts: The opcode for SET, the opcode for„'the FLAVOR OF SET(Z,NZ,G,B,L etc.etc.) and the opcode for the register„'or memory reference to set. I will give a few examples from which it must„'be possible to put every set instruction together:„„'SETZ  AL =&H0F &H94 &HC0„'SETNZ AL =&H0F &H95 &HC0„'SETNZ[BX]=&H0F &H95 &H07„„„'RULES:„„'THE FIRST  OPCODE &H0F = PREFIX FOR EVERY SET CODE„'THE SECOND OPCODE      = POINTING TO THE SORT OF SET = THE JUMPCODE+&H20„'EXAMPLES:„'       JNZ  =&H75 ..„'       SETNZ=&H95„„'THE THIRD OPCODE       = THE OPERAND [AL=&HC0, [BX]=&H07 ETC ETC..]=SAME„'                         FOR ALL INSTRUCTIONS„„„'Since you might wonder why this SET instruction set is there I have„'prepared some example code. In general you can use this SET instructions„'to avoid jumps. We will see why avoiding jumps is very important sometimes.„'In the example we determine if the user has at least a .386 PC. I thought„'translating that widely used INTEL code to QBASIC was worth it, since„'without it we CAN NOT make use of all the goodies in this text!„„CALL CPU386ID„„„'C) THE .486 PIPELINED MACHINES: AVOIDING AGI'S„„'As i have been saying the .486 PC is not so big a deal. There is however„'one programming concept that you have to know when you are programming„'for .486 and above and that concept will be the topic in this section.„„ „'The .486 and pentium do not execute every instruction behind each„'other. At one moment in time the processor is handling as much as 5„'instructions, all at different stages of processing. I will not explain„'everything in detail( I wonder If I even could(g)), but the main thing to„'know is that there can be pipeline stalls, when the processor can not„'progress in a normal way. When one instruction use a register as destiny„'of an adress calculation and the next instruction is using the same„'register as source, then the processor can not execute both instructions„'at the same time. It has to wait until the first is done.„„'EXAMPLES:„„'(0)mov bx,[bp+08]„'(1)mov di,[bp+06]„'(2)mov ax,[di]„„'Normallly both instructions (1)and (2) will be in the pipeline at different„'stages of processing, but when the processor looks at something like this„'it does not process mov ax,[di] until di is calculated in (1).„'Therefore, although it might look strange at first it is more optimal to„'use:„„'EXAMPLES:„„'GET POINTERS FROM THE STACK„'mov di,[bp+06]„'mov bx,[bp+08]„„'GET VALUES„'mov ax,[di]„'mov cx,[bx]„„'Another more obvious source of pipelinestalls is every JUMP. When you are„'thinking about it this might be obvious: After a JUMP CS:IP is changed so„'the processor has to empty his pipeline and fill it again..„„'This sort of stalls is the reason why SET on condition instructions are„'often used instead of JUMP on condition instructions. The SET instructions„'do not execute a pipelinestall.„„'EXAMPLE:„„'STATEMENT TRANSLATED: IF A THEN A=0 ELSE A=1„„'1) OR AX,AX„'2) JNZ else„'3) MOV AX,1„'4) JMP done„'else:  MOV AX,0„'done:  ....etc„„'When the processor reaches 'JNZ else' he is executing 5 instructions at„'different levels. But when the jump is taken( i.e. AX<>0) then he has„'to start all over again. All previously loaded instruction have become„'worthless. That is why jump taken costs more then jump not taken!„'The same process however is done again for the condition that AX= 0„'when we reach JMP done...That is why the code above should be replaced„'by:„„' OR AX,AX„' SETNZ AL„„'No pipeline problems here!„„'Before turning to example codes showing .386 copying routines we have„'to go through another very important feature called aligning. When you„'use aligned data that will speed up your routines considerably, certainly„'when you use REP MOV instructions. Aligning is meaning that WORD operands„'have to be at adresses that are divisable by 2, and DWORD operands that„'are divisable by 4. Knowing that moving double words is faster then„'moving bytes or words, Paul Hsieh has developed an optimized copy routine„'which I ported to QBASIC. The routine is demonstrated after a somewhat more„'straightforward example of screen13 grabbing( no need for aligning there).„'Paul has set up his routine to include an aligned dword copy middle. That„'is why he has to copy some bytes before and some after in some not aligned„'cases. If you wanna know more about the theory behind it you are referred„'again to Paul Hsiehs site: HTTP://WWW.GEOCITIES.COM/SILICONVALLEY/9498„„„CALL CPYDEMO„„„'If you wanna know more about optimizing, .386 and 486 processors, then there„'are a few good sources at: HTTP://ANNOUNCE.COM/AGNER/ASSEM/PENTOPT.ZIP„„„'D) PMODE on .386 + MACHINES„„'Of course a very important feature of .386 PC s is that it has made„'possible a handsome (g) protected mode. On .286 you could only get IN„'protected mode and never out again, but in .386 + machines getting back„'to real mode is possible too.„„'I will not go into everything about PMODE, but will try to make a very BASIC„'introduction. Often people are already just scared of by the very name of it,„'and well I do not think PMODE is basically that difficult. You could use it„'in a difficult manner, and a lot of the information is not readily available,„'or encryted, or spread over a lot of sources, but it is not difficult perse.„„„'IMHO the basics of pmode looking at it from RMODE are:„„'a)extra registers„'b)different segmentadressing„'c)different interruptadressing„„'a) Extra registers.„„'A .386 machine has some extra registers:„„'1) Control registers CR0, CR1, CR2, CR3„'2) Table registers GDTR, IDTR, LDTR„'3) Extra segment registers FS, GS„„'FS and GS are just extra segment registers like ES. In general you„'should not use them in your ASM$ routines in QBASIC because„'the are accesses slower then ES and DS.„„'From the Control registers( CR0..CR3) the CR0 is the only„'one that is very important to know anything off. This register„'has at the lowest 5 bits a few important flags, from which„'the bit 0 is the PMODE flag. If this bit is set then we are in„'PMODE/V86 mode. If it is not set then we are in REAL mode.„„'I prepared some example code which determins from CR0 values if„'you are in REAL MODE. Run it both in PLAIN DOS and from a DOSBOX„'and notice the difference„„CALL PMODE.DETECT„„'The CR0 condition described is also sufficient conditions for„'getting into PMODE/RMODE. So when you are in real mode( PLAIN DOS)„'then the code„„'mov eax,cr0„'or al,1„'mov cr0,eax  =&HF &H22 &HC0„„'is sufficient to get you in PMODE. Easy isn't it ?„„'Not that you can do anything with that at this moment, but you are in the„'PZONE>.„„'The last three registers (IDTR/GDTR/LDTR) will be handled below since they„'have to do with segment and interrupt adressing.„„'b) Another segment adressing„„'When we are in real mode we are used to think that the values we„'load in segment registers are memory references. Since CS, DS, ES, FS, GS„'are only 16 bit wide this can not work for memory references which„'exceeds 1 MB( the maximum reachable space with 16 bits segments).„„'That is why INTEL designed something for it. You load your segments„'in pmode not with memory values, but with an index in a table which„'points( among other things) to a memory value. This index is called„'a SELECTOR. Since every index takes up 8 bytes, the indici are always„'a multiple of 8. Also the first index is reserved so that would make„'indici 8, 16, 24, 32 etc available. So in pmode you get something like:„„'MOV AX,8„'MOV DS,AX„'MOV AX,24„'MOV ES,AX„„'Which does NOT point DS to &h8, but to the first index in some table.„„'This table is called the GDT. It can be virtually everywhere in memory„'so we need a pointer to where it is too. That pointer is called the„'GDT register( GDTR) which expects a 48 bit absolute value. An absolute„'value is nothing more or less then segment*16+offset. So when we make„'a GDT then we have to pass a pointer to it by loading the absolute„'value of it with the GDTR instruction.„„'This table the GDT consists of 8 byte descriptors. That is why it is„'called General Descriptor Table. The descriptor contains information„'about the adress of the selector, the size of it( called that limit),„'some newflags and the privilige level of the selector . The only things„'that are really new about this are the privilige level and the newflags.„„'The privilige level is were protected mode got its name from. You can make„'descriptors of all kinds, which can have all kinds of access or not. I am„'not going into it in detail here, but I quickly mention that normally you„'can not write to your code segments in pmode. That is why mostly the„'codesegments base/limit is aliased( copied) as a datasegment. By writing to„'the datasegment you can still write to the same memory as the codesegment„'that way.„„'A DESCRIPTOR:„„'DW LIMIT(low 16)„'DW BASE (low 16)„'DB BASE (middle 8)„'DB ACCESS„'DB LIMIT(high 4)+newflags„'DW BASE (high 8)„„'As you can see you have to fill in a LIMIT of 20 bits( absolute adress)„'and a BASE of 32 bits( absolute adress) and in addition a few other things.„'The access I have shortly been speaking about. You have to read up on„'the referred texts to fully get that. But a value of &h92 will give„'you an highest access normal datasegment.„„'What I left out for a moment was the newflags. They are most important„'for flat mode. You might already have noticed that the limit field is„'only 20 bit wide. So that makes up for 20 bit absolute adressing which„'is nothing more then 1 MB.„„'BYTE 6:„'newflag| lim(h)„'       |„'G|D|0|5|4|3|2|1„ „„'The newflags however contains a flag G that is called GRANULARITY. When this„'bit is set then the limit is indicating PAGES instead of BYTES. Since a page„'is 4 KB this will extend the limits possibilities to the advertised 4 GB !.„„'The other important newflag D is determining the default segmentsize.„'If this bit is set then you can use the full 32 bit adressing , and if„'zeroed then you can only use 16 bit adressing( which in a 4 GB segment„'will not help you much). The flag called 0 is not important ( must be zero)„'and bit 5 is for use by programmers( free).„„'This is all coming down to a descriptor set up like this for a 4 GB„'adressable segment:„„DIM GDT(7)„GDT(4) = &HFFFF 'LIMIT LOW= &HFFFF„GDT(5) = 0      'BASE ADRESS =0„GDT(6) = &H9200 'ACCESS RIGHTS= &H92, BASE MIDDLE=0„GDT(7) = &HCFFF 'LIMIT HIGH =&HFF, NEWFLAGS=&HCF(GRAN SET, DEF SET)„„'This is basically all there is about segment adressing in pmode. You load„'up your GDT with GDTR to point at your new GDT( remember to take the„'absolute adress) and thats that. There are a few more tricks, like„'setting up the pointer to your GDT in the zero desriptor( works nice),„'etc, but for that I have to refer to Peters PMODE page, which describes„'all of this and more at:  HTTP://GLOBALSERVE.NET/~SUBDEATH/„„„'c) Another interrupt adressing„„'In real mode the interrupt vector table is stored at 0:0 but in pmode„'the interrupt vector table can be anywhere in memory. In addition the„'boundery of 256 interrupts in rmode is left in pmode. You can assign„'less if you want. The way things are handles in pmode parralells the„'segment adressing very much: by the way of tables.„'In fact IDT uses exactly the same 8 byte descriptors although the have„'a different meaning. Since however setting up an IDT requires handling„'the pmode exceptions( int < 32) and in a lot of cases the resetting„'of the PIC I will not go into detail. The only thing you have to know„'is that when you are in pmode that it is not necessarily so that your„'interrupts are pointing to the real mode interrupts. You have to redirect„'them.„„'Well basic assemblers this was about it. The ASM in QBASIC series will„'end here, at least my contributions to it. Maybe some other will take over.„'In fact I hope so. But I really do not know very much more to tell you all.„'You will see a lot of techniques I explained in other articles by me and„'other people on a variety of topics. But basically I have the feeling that„'I was doing more ASM then QBASIC lately, so that called for two other„'approaches: 1) building a QBASIC compiler which also handles some„'               restricted asm keywords.„'            2) Transferring my main programming to MASM alltogether.„„'I will try to keep you all posted on that ones! And for this moment thanks„'for your attentions and reactions.„„'Good bye.„„'Rick„„DEFSTR A-Z„FUNCTION BLOCKCPY„'-----------------------------------------------------------„'This is an aligned blockcopy which makes use of„'Paul Hsiehs align method and .386 coding„„'STACKPASSING: BYVAL(SRCSEG),BYVAL(SRCOFF)„'              BYVAL(DESTSEG),BYVAL(DESTOFF),NROFBYTES„„„'-----------------------------------------------------------„''SET UP STACKFRAME„ASM = ASM + CHR$(&H55)                              'PUSH BP„ASM = ASM + CHR$(&H89) + CHR$(&HE5)                 'MOV BP,SP„ASM = ASM + CHR$(&H1E)                              'PUSH DS„ASM = ASM + CHR$(&H6)                               'PUSH ES„'GET LEN POINTER FROM THE STACK„ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'MOV BX,[BP+06]>LEN„'LOADS SOURCE TO DS[SI], DEST TO ES[DI], LEN TO CX„ASM = ASM + CHR$(&HC4) + CHR$(&H7E) + CHR$(8)       'LES DI,[BP+8]„ASM = ASM + CHR$(&H8B) + CHR$(&HF)                  'MOV CX,[BX]„ASM = ASM + CHR$(&HC5) + CHR$(&H76) + CHR$(&HC)     'LDS SI,[BP+C]„'ALIGN THE START OF THE COPYROUTINE TO ES[DI]MOD 4 =0„ASM = ASM + CHR$(&H89) + CHR$(&HC8)                 'MOV AX,CX„ASM = ASM + CHR$(&H29) + CHR$(&HF9)                 'SUB CX,DI„ASM = ASM + CHR$(&H29) + CHR$(&HC1)                 'SUB CX,AX„ASM = ASM + CHR$(&H81) + CHR$(&HE1) + MKI$(&H3)     'AND CX,3„ASM = ASM + CHR$(&H29) + CHR$(&HC8)                 'SUB AX,CX„ASM = ASM + CHR$(&H7E) + CHR$(13)                   'JLE +13 ONLY_ENDBYTES„'COPY THE FIRST BYTES LEFT OVER WITH MOVSB„ASM = ASM + CHR$(&HF3) + CHR$(&HA4)                 'REP MOVSB„'ALIGN THE NUMBER OF BYTES FOR MAIN COPYLOOP TO LEN MOD 4=0„ASM = ASM + CHR$(&H89) + CHR$(&HC1)                 'MOV CX,AX„ASM = ASM + CHR$(&H25) + CHR$(&H3) + CHR$(&H0)      'AND AX,3„ASM = ASM + CHR$(&HC1) + CHR$(&HE9) + CHR$(2)       'SHR CX,2 <386„'MAIN COPY LOOP WITH THE BLAZE OF MOVSD„ASM = ASM + CHR$(&HF3) + CHR$(&H66) + CHR$(&HA5)    'REP MOVSD< 386„'END_BYTES: COPY THE LEFT OVER BYTES WITH MOVSB„ASM = ASM + CHR$(&H1) + CHR$(&HC1)                  'ADD CX,AX„ASM = ASM + CHR$(&HF3) + CHR$(&HA4)                 'REP MOVSB„'WE ARE DONE :RETURN TO QBASIC„ASM = ASM + CHR$(&H7)                               'POP ES„ASM = ASM + CHR$(&H1F)                              'POP DS„ASM = ASM + CHR$(&H5D)                              'POP BP„ASM = ASM + CHR$(&HCA) + MKI$(10)                   'RETF A„„BLOCKCPY = ASM„„END FUNCTION„„DEFSNG B-Z„SUB CPU386ID„'----------------------------------------------------------------------„'This is an INTEL procedure to detect if„'a .386 processor is available...„„'Theory is that bits 12..15 are always zero„'on pre_386 processors like 286/8088/8086„'-----------------------------------------------------------------------„ASM = ASM + CHR$(&H55)                           'PUSH BP„ASM = ASM + CHR$(&H89) + CHR$(&HE5)              'MOV BP,SP„ASM = ASM + CHR$(&HB9) + CHR$(&H0) + CHR$(&H70)  'MOV CX,7000H SET BIT 12..15„ASM = ASM + CHR$(&H51)                           'PUSH CX„ASM = ASM + CHR$(&H9D)                           'POPF  CX > FLAGS„ASM = ASM + CHR$(&H9C)                           'PUSHF PUSH THEM AGAIN„ASM = ASM + CHR$(&H58)                           'POP AX AND GET THEM BACK„ASM = ASM + CHR$(&H25) + CHR$(&H0) + CHR$(&H70)  'AND AX,7000H MASK BITS 12..15„ASM = ASM + CHR$(&HF) + CHR$(&H95) + CHR$(&HC0)  'SETNZ 386„ASM = ASM + CHR$(&H30) + CHR$(&HE4)              'XOR AH,AH ZERO IT„ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'MOV BX,[BP+06]„ASM = ASM + CHR$(&H89) + CHR$(&H7)               'MOV [BX],AX„ASM = ASM + CHR$(&H5D)                           'POP BP„ASM = ASM + CHR$(&HCA) + CHR$(&H2) + CHR$(&H0)   'RETF 2„„PRINT : COLOR 0, 7: PRINT "CPUID DEMO"; : COLOR 7, 0: PRINT : PRINT„„'________________________________________„codeoff% = SADD(ASM)„DEF SEG = VARSEG(ASM)„CALL ABSOLUTE(CPUid%, codeoff%)„'________________________________________„DEF SEG„IF CPUid% THEN PRINT "386+ AVAILABLE" ELSE PRINT "SORRY, NO 386+ AVAILABLE"„END SUB„„DEFINT A-Z„SUB CPYDEMO„„'In this sub I will demonstrate dword copying from mem to mem„'(the one thats left over from speed.)„'In addition to a full screen copier, I also demonstrate an„'optimized copier which you can use for instance to cpy only„'a part of the screen very fast...[it uses aligning methods]„„PRINT "press a key for next demo": SLEEP„„„'1) SCREENGRABBING...„„'INITIALIZE„„DIM save13%(32000)„GETCPY$ = GETSCREEN13$: PUTCPY$ = PUTSCREEN13$„SCREEN 13„„'LETS PUT SOME ONSCREEN„FOR X = 1 TO 100„	CIRCLE (159, 99), X OR 8, 2 + 3 * X„NEXT„„'AND COPY BACK AND FORTH„„PRINT "PRESS KEY TO LET PICTURE VANISH": SLEEP:„DEF SEG = VARSEG(GETCPY$): CALL ABSOLUTE(save13%(), SADD(GETCPY$))„CLS : PRINT "PRESS KEY TO GET PIC BACK": SLEEP„CALL ABSOLUTE(save13%(), SADD(PUTCPY$))„LOCATE 1, 1: PRINT "PRESS KEY FOR ALGINED COPY DEMO": SLEEP: SCREEN 0: WIDTH 80, 25„„'2) OPTIMIZED MEM TO MEM COPYING (F.I FOR PARTS OF THE SCREEN)„„CPY$ = BLOCKCPY$„„DIM SRC AS STRING * 10: SRC$ = "0WAT EEN!": SRCSEG = VARSEG(SRC$): SRCOFF = VARPTR(SRC)„DIM DEST AS STRING * 10: DEST$ = "1" + SPACE$(9): SRCSEG = VARSEG(DEST$): DESTOFF = VARPTR(DEST)„„COLOR 0, 7: PRINT "OPTIMIZED BLOCKCOPY DEMO"; : COLOR 7, 0: PRINT : PRINT„„CALL ABSOLUTE(BYVAL (SRCSEG), BYVAL (SRCOFF), BYVAL (SRCSEG), BYVAL (DESTOFF), 10, SADD(CPY$))„PRINT "DESTINY: "; DEST: PRINT„DEF SEG„„„END SUB„„DEFSTR A-Z„FUNCTION GETSCREEN13„'-------------------------------------------------------------------„'This function gets a screen 13 to an QBASIC array. 386 + routine„'STACKPASSING: ARRAY%()„'IN          : SCREEN 13 EMPTY„'OUT         : ARRAY%() FILLED„'-------------------------------------------------------------------„'SET UP STACKFRAME„ASM = ASM + CHR$(&H55)                              'PUSH BP„ASM = ASM + CHR$(&H89) + CHR$(&HE5)                 'MOV BP,SP„ASM = ASM + CHR$(&H1E)                              'PUSH DS„ASM = ASM + CHR$(&H6)                               'PUSH ES„'GET POINTER TO ARRAY FROM STACK„ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'MOV BX,[BP+06]>ARRAY()„'SET UP CX TO 64000/4, ES[DI] TO ARRAY, DS[SI] TO A000:0„ASM = ASM + CHR$(&HB9) + CHR$(&H80) + CHR$(&H3E)    'MOV CX,3E80h„ASM = ASM + CHR$(&HC4) + CHR$(&H3F)                 'LES DI,[BX] ARRAY()„ASM = ASM + CHR$(&H31) + CHR$(&HF6)                 'XOR SI,SI„ASM = ASM + CHR$(&HB8) + MKI$(&HA000)               'MOV AX,A000„ASM = ASM + CHR$(&H8E) + CHR$(&HD8)                 'MOV DS,AX SCREENSEG„'COPY IT USING THE BLAZE OF MOVSD„ASM = ASM + CHR$(&HF3) + CHR$(&H66) + CHR$(&HA5)    'REP MOVSD < 386„'WE ARE DONE :RETURN TO QBASIC„ASM = ASM + CHR$(&H7)                               'POP ES„ASM = ASM + CHR$(&H1F)                              'POP DS„ASM = ASM + CHR$(&H5D)                              'POP BP„ASM = ASM + CHR$(&HCA) + MKI$(2)                    'RETF 2„„GETSCREEN13 = ASM„„END FUNCTION„„DEFSNG A-Z„SUB MULLEA„„'This sub demonstrates multiplying constants by the use of LEA,„'which is much much faster then QBASICs * or ASMs mul.„„„COLOR 0, 7: PRINT "LEA MULTIPLICATION DEMONSTRATION";„COLOR 7, 0: PRINT : PRINT„„„'SET UP STACKFRAME„ASM$ = ASM$ + CHR$(&H55)                          'push bp„ASM$ = ASM$ + CHR$(&H89) + CHR$(&HE5)             'mov bp,sp„„ASM$ = ASM$ + CHR$(&H8B) + CHR$(&H7E) + CHR$(&H6) 'mov di,[bp+06]„ASM$ = ASM$ + CHR$(&H66) + CHR$(&H8B) + CHR$(&H5) 'mov eax,[di]„ASM$ = ASM$ + CHR$(&H66) + CHR$(&H89) + CHR$(&HC3)'mov ebx,eax„ASM$ = ASM$ + CHR$(&H66) + CHR$(&HC1) + CHR$(&HE0)„ASM$ = ASM$ + CHR$(&HA)                       'shl eax,10 eax=eax*1024„ASM$ = ASM$ + CHR$(&H66) + CHR$(&H67) + CHR$(&H8D)„ASM$ = ASM$ + CHR$(&H1C) + CHR$(&H5B)      'lea ebx,[ebx*2+ebx]ebx*3„ASM$ = ASM$ + CHR$(&H66) + CHR$(&H2B) + CHR$(&HC3)'sub eax,ebx„ASM$ = ASM$ + CHR$(&H66) + CHR$(&H89) + CHR$(&H5) 'mov [di],eax„„ASM$ = ASM$ + CHR$(&H5D)                         'pop bp„ASM$ = ASM$ + CHR$(&HCA) + CHR$(&H2) + CHR$(&H0) 'retf 2„„'MULTIPLYING 89*1021„A& = 89: DEF SEG = VARSEG(ASM$): CALL ABSOLUTE(A&, SADD(ASM$)): DEF SEG„PRINT "VALUE BY ASM LEA ROUTINE : "; A&„PRINT "VALUE BY QBASIC '*'      : "; 89 * 1021&„„END SUB„„DEFSTR A„SUB PMODE.DETECT„„'Below is some detection routine which should give different results in plain„'dos/windowed dos..Take notice that only Extended register can„'be loaded from CR0.„„„ligne% = CSRLIN: PRINT "press a key for next demo"; : SLEEP: LOCATE ligne%, 1„COLOR 0, 7: PRINT "PMODE DETECTION DEMONSTRATION"; : COLOR 7, 0: PRINT : PRINT„„„ASM = ASM + CHR$(&H55)                           'PUSH BP„ASM = ASM + CHR$(&H89) + CHR$(&HE5)              'MOV BP,SP„ASM = ASM + CHR$(&HF) + CHR$(&H1) + CHR$(&HE0)   'MOV EAX,CR0„ASM = ASM + CHR$(&H24) + CHR$(&H1)               'AND AL,1 MASK BIT 1(PE FLAG)„ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'MOV BX,[BP+06]„ASM = ASM + CHR$(&H88) + CHR$(&H7)               'MOV [BX],AL„ASM = ASM + CHR$(&H5D)                           'POP BP„ASM = ASM + CHR$(&HCA) + CHR$(&H2) + CHR$(&H0)   'RETF 2„„'determine if we are in REAL mode ?„DEF SEG = VARSEG(ASM): CALL ABSOLUTE(PM%, SADD(ASM)): DEF SEG„IF PM% THEN PRINT "We are in PMODE or V86 mode.." ELSE PRINT "Still in REAL mode.."„„END SUB„„DEFSTR B-Z„FUNCTION PUTSCREEN13„'-------------------------------------------------------------------„'This function gets a screen 13 to an QBASIC array. 386 + routine„'STACKPASSING: ARRAY()„'IN          : ARRAY() FILLED„'OUT         : SCREEN 13 FILLED„'-------------------------------------------------------------------„'SET UP STACKFRAME„ASM = ASM + CHR$(&H55)                              'PUSH BP„ASM = ASM + CHR$(&H89) + CHR$(&HE5)                 'MOV BP,SP„ASM = ASM + CHR$(&H1E)                              'PUSH DS„ASM = ASM + CHR$(&H6)                               'PUSH ES„'GET POINTER TO ARRAY FROM STACK„ASM = ASM + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)     'MOV BX,[BP+06]>ARRAY()„'SET UP CX TO 64000/4, ES[DI] TO ARRAY, DS[SI] TO A000:0„ASM = ASM + CHR$(&HB9) + CHR$(&H80) + CHR$(&H3E)    'MOV CX,3E80h„ASM = ASM + CHR$(&H31) + CHR$(&HFF)                 'XOR DI,DI„ASM = ASM + CHR$(&HB8) + MKI$(&HA000)               'MOV AX,A000„ASM = ASM + CHR$(&H8E) + CHR$(&HC0)                 'MOV ES,AX SCREENSEG„ASM = ASM + CHR$(&HC5) + CHR$(&H37)                 'LDS SI,[BX] ARRAY()„'COPY IT USING THE BLAZE OF MOVSD„ASM = ASM + CHR$(&HF3) + CHR$(&H66) + CHR$(&HA5)    'REP MOVSD < 386„'WE ARE DONE :RETURN TO QBASIC„ASM = ASM + CHR$(&H7)                               'POP ES„ASM = ASM + CHR$(&H1F)                              'POP DS„ASM = ASM + CHR$(&H5D)                              'POP BP„ASM = ASM + CHR$(&HCA) + MKI$(2)                    'RETF 2„„PUTSCREEN13 = ASM„„END FUNCTION„Brian Mclaughlin               SORT AN ARRAY OF INTEGERS      comp.lang.basic.misc           01-28-97 (19:59)       ASM                    78   3306     SORTINT.ASM ; SORTINT.ASM - assemble with MASM 5.1 or compatible assembler„;             - for QB4.x / PDS„;             - written by Brian McLaughlin. Released to public domain.„;„; This SUB sorts an array of integers, using the Combsort„; algorithm. You pass it the first element of the array,„; and the number of elements to sort. In this way, SortInt can„; be used to sort a only a part of an integer array, if desired.„; The sorted order is ascending.„;„; DECLARE SUB SortInt (SEG ArrayFirstElement%, NumOfElements%)„;„; Example:„;          FirstElem% = LBOUND(IntArray%)„;          TotalElem% = UBOUND(IntArray%) - FirstElem% + 1„;          SortInt IntArray%(FirstElem%), TotalElem%„„.MODEL MEDIUM, BASIC„.CODE„    Gap    DW ?       ; put variable in code segment„    „SortInt PROC USES DS ES DI SI, Addr:DWORD, Elems:WORD„    Mov BX, Elems     ; point BX at Elements„    Mov CX, [BX]      ; CX = Elements„    Jcxz SortExit     ; gee, no elements to sort!„    Mov BX, CX        ; BX = Elements„    Mov Gap, CX       ; copy it into Gap, too„    Lds SI, Addr      ; point DS:SI at first element„    Push DS„    Pop ES            ; point ES at array's segment„Do:                   ; calculate the value of Gap into AX/memory„    Push BX           ; save BX, we're gonna trash it„    Mov AX, Gap       ; AX = current value of Gap„    Xor DX, DX        ; prepare DX to receive any rotated bits„    Mov CX, 3         ; we'll shift all bits left 3 positions„MultBy8:„    Shl AX, 1         ; multiply (Gap * 8) into DX:AX„    Rcl DX, 1         ; catch any carried bits„    Loop MultBy8      ; go around CX times„    Mov BX, 11        ; dividing by 11„    Div BX            ; divide DX:AX by 11„    Or  AX, AX        ; AX holds quotient, so see if AX = 0„    Jnz CalcDone„    Mov AX, 1         ; if Gap < 1 then Gap = 1„CalcDone:„    Mov Gap, AX       ; leave newly calculated value in Gap„    Pop BX            ; restore BX„    Xor DX, DX        ; set switch to zero„    Mov CX, BX        ; CX = Elements„    Sub CX, AX        ; CX = the FOR loop counter (Elements - Gap)„    Mov DI, AX        ; DI = Gap„    Shl DI, 1         ; convert DI into a memory offset„    Add DI, SI        ; point DS:DI at Array%(J%)  [I%+Gap%]„    Push BX           ; Save value of Elements„    Push SI           ; save offset of first element„For:„    Mov BX, [DI]      ; load BX with value at DS:DI [Array%(J%)]„    Lodsw             ; load AX with value at DS:SI [Array(I%)]„    Cmp AX, BX        ; same as IF AX > BX THEN„    Jle IfEnd         ; if AX <= BX, then skip ahead„    Stosw             ; puts AX into ES:DI (points to Array%(J%))„    Sub DI, 2         ; the Stosw added 2, but we want to do that manually„    Mov [SI-2], BX    ; puts BX into Array%(I%)  [Lodsw inc's SI+2]„    Inc DX            ; set switch to a non-zero value„IfEnd:„    Add DI, 2         ; point DI ahead in tandem with SI„    Loop For„    Pop SI            ; DS:SI points to first element of array„    Pop BX            ; BX = Elements„    Or  DX, DX        ; did we swap any elements?„    Jnz Do            ; if we did, go around again„    Mov AX, Gap„    Cmp AX, 1         ; does Gap = 1?„    Jne Do            ; if not, go around again„SortExit:„    Ret„SortInt ENDP„    END„BBrian Mclaughlin               STRING REPRESENTATION OF LONG #comp.lang.basic.misc           01-28-97 (19:59)       ASM                    68   2509     LSTR.ASM    ; LSTR.ASM  - assemble with MASM 5.1 or compatible assembler.„;           - for use with QB4.x only.„;           - written by Brian McLaughlin. Released to public domain.„;„; The purpose of this FUNCTION is to accept a long integer and pass„; back a string representation of that long integer, so the number„; 1234567 becomes the string "1234567".„;„; Unlike STR$, this routine will not pull the QB4x floating-point„; code into your EXE file, saving you 9K. Also, unlike STR$, this„; FUNCTION does not add a leading space to positive long integers.„;„; Declare it:   DECLARE FUNCTION LStr$ (Integer&)„„.MODEL MEDIUM, BASIC„.DATA„    Leng DW 11„    Addr DW ?„    String DB 11 DUP(0)„„.CODE„„LStr PROC FAR USES SI DI, LInteger:WORD„    Mov BX, LInteger„    Mov AX, [BX]    ; DX:AX contains number to convert„    Mov DX, [BX+2]  „    Xor BX, BX      ; BL will count places, BH hold sign„    Mov SI, Offset String„    Add SI, 10      ; point SI at the end of the string„    Or  DX, DX      ; find out if DX:AX is signed (negative)„    Js  Signed      ; if signed, jump to handle it„Resume:„    Mov DI, 10      ; we're dividing by 10„    Mov CX, AX      ; save low word in CX„    Mov AX, DX      ; put the high word down in AX„    Xor DX, DX      ; and zero out DX„    Div DI          ; now divide 00:highword by 10„    Xchg CX, AX     ; retrieve old low word, while saving quotient in CX„    Div DI          ; now divide remainder:lowword by 10„    Xchg CX, DX     ; put new high word in DX, remainder in CX„    Add CX, "0"     ; convert remainder to ASCII character„    Mov Byte Ptr [SI], CL   ; put low byte of remainder into String at SI„    Dec SI          ; point one byte prior„    Inc BL          ; keep a count of iterations„    Or  AX, AX      ; is there anything left?„    Jnz Resume      ; if so, loop back untilDX:AX is empty„    Or  DX, DX„    Jnz Resume„    Or  BH, BH      ; see if we need to add the "-" character„    Jz  NoSign      ; if no sign, skip ahead„    Inc BL          ; keep track of length of string„    Mov Byte Ptr [SI], BH   ; put sign character at head of string„    Xor BH, BH      ; clear it to make BX hold length only„    Dec SI          ; point one prior, to remain consistant„NoSign:„    Inc SI„    Mov Addr, SI„    Mov Leng, BX„    Mov AX, Offset Leng„    Ret „Signed:„    Mov BH, "-"„    Neg DX         ; perform a 32-bit negation on DX:AX„    Neg AX„    Sbb DX, 0„    Jmp SHORT Resume„LStr ENDP„     END„Brian Mclaughlin               RETURN A PSUEDO-RANDOM INTEGER comp.lang.basic.misc           01-28-97 (19:59)       ASM                    63   2740     RAND.ASM    ; RAND.ASM   - assemble with ASM 5.1 or compatible assembler„;            - for use with QB4.x only„;            - written by Brian McLaughlin. released to public domain.„;„; The Rand% FUNCTION is designed to return a psuedo-random integer between„; two integers (inclusive). Rand%(1, 10) may return: 1, 2, 3 ... 8, 9, 10. „; Rand% detects which integer is greater, and swaps the two if necessary.„;„; The SeedRand SUB sets a new seed for the Rand% FUNCTION, from the timer.„; It is highly recommended to call SeedRand once before calling Rand%. If„; you don't, Rand's return series won't differ from one start-up to the next.„;„; Declare them:  DECLARE SUB SeedRand ()„;                DECLARE FUNCTION Rand% (Lower%, Upper%)„;„; Use them:      SeedRand     'seeds Rand% FUNCTION„;                RandValue% = Rand%(Lower%, Upper%)„;„; This function is MUCH faster than calling RND and then converting„; the floating point return value to an integer. The algorithm should„; produce adequately "random" distributions for most general purposes.„„„.MODEL MEDIUM, BASIC„.CODE„    RandSeed    DW 2663     ; supply a seed, in case user forgets to„    Multiplier  DW 1021     ; these two are important constants:„    Divisor     DW 32768    ; don't change them!„„SeedRand PROC FAR USES ES„    Xor AX, AX„    Mov ES, AX         ; point ES at low memory„    Mov AX, ES:[046Ch] ; get low word of timer ticks count„    Mov RandSeed, AX   ; put it into RandSeed„    Ret„SeedRand EndP„„Rand PROC FAR, Lower:WORD, Upper:WORD„    Mov AX, RandSeed   ; RandSeed into AX„    Mul Multiplier     ; multiply it by Multiplier, result in DX:AX„    Inc AX             ; add 1 to the result„    Div Divisor        ; divide result in DX:AX by Divisor, remainder in DX„    Mov RandSeed, DX   ; save remainder, to seed the next call to Rand„    Mov AX, DX         ; put remainder into AX„    Xor DX, DX         ; DX:AX now equals remainder as a long integer„    Mov BX, Upper      ; the address of Upper„    Mov CX, [BX]       ; CX = value of Upper limit„    Mov BX, Lower      ; address of Lower„    Mov BX, [BX]       ; BX = value of Lower„    Cmp BX, CX         ; are they in correct order?„    Jg  SwapEm         ; if Lower > Upper, go swap them„Resume:„    Inc CX             ; this allows remainders up to Upper limit„    Sub CX, BX         ; CX = range from Lower to Upper„    Div CX             ; divides DX:AX by CX, puts remainder into DX„    Mov AX, BX         ; AX = lower limit, DX is our random number„    Add AX, DX         ; AX = random number between Lower and Upper„    Ret                ; return AX to BASIC program„SwapEm:„    Xchg BX, CX    „    Jmp SHORT Resume„Rand ENDP„     END„BBrian Mclaughlin               GET ONE CHARACTER FROM STRING  comp.lang.basic.misc           01-28-97 (19:59)       ASM                    42   1868     MIDASC.ASM  ; MIDASC.ASM  - assemble with MASM 5.1 or compatible assembler„;             - use with QB4.x only„;             - written by Brian McLaughlin. Released to public domain.„;„; This FUNCTION accepts a string, and an integer describing which„; character in the string to examine. It returns the ASCII code of that „; character. If the string is a null, or an illegal value is passed in CharPos% „; (such as a zero, or a value beyond the end of the string) it returns a -1.„;„; It's best use is when stepping through a string one character at a time,„; looking for some particular character. It's much faster than ASC(MID$()).„;„; Declare it this way:   DECLARE FUNCTION MidAsc%(Test$, CharPos%)„; Use it this way:       AsciiValue% = MidAsc%(Test$, CharPos%)„„„.MODEL MEDIUM, BASIC„.CODE„„MidAsc PROC, String:WORD, CharPos:WORD„„        Mov BX, CharPos ; address of CharPos„        Mov DX, [BX]    ; DX = value of CharPos„        Or  DX, DX      ; if DX = 0 then CharPos is illegal value„        Jz  WasError    ; (an OR sets zero flag if results are zero)„        Mov BX, String  ; address of String's descriptor„        Mov CX, [BX]    ; CX = length of String„        Jcxz WasError   ; if CX = 0 then String is a null„        Cmp DX, CX      ; if DX > CX then CharPos is illegal value„        Ja  WasError    ;„        Mov BX, [BX+2]  ; BX = address of first byte of string„        Add BX, DX      ; add CharPos to address of first byte„        Dec BX          ; move back one place to correct byte„        Mov AL, [BX]    ; put the ASCII value into AL„        Xor AH, AH      ; zeroes AH, so AX = value in AL„Exit:„        Ret             ; return the value in AX„WasError:               ; come here when an error condition„        Mov AX, -1      ; put -1 in AX to flag an error„        Jmp SHORT Exit„MidAsc ENDP„       END„BBrian Mclaughlin               REPLACE ONE CHARACTER W/ANOTHERcomp.lang.basic.misc           01-28-97 (19:59)       ASM                    41   1850     REPLACE.ASM ; REPLACE.ASM  - assemble with MASM 5.1 or compatible assembler„;              - for use with QB4.x only„;              - written by Brian McLaughlin. Released to public domain.„;„; This SUB is designed to replace every occurance of a particular char„; in the designated string with another char. This change occurs„; directly to the string that is passed to the SUB. If you need to keep„; an unchanged copy of the original string, you must copy it before you„; call Replace. The characters are designated by their ASCII code.„;„; Declare it:   DECLARE SUB Replace (St$, OldChar%, NewChar%)„;„; Example:„;           Original$ = "A test string."„;           Replace Original$, ASC("t"), ASC("X")„;           PRINT Original$   'prints "A XesX sXring."„„.MODEL MEDIUM, BASIC„.CODE„„Replace PROC USES ES DI SI, String:WORD, OldChar:WORD, NewChar:WORD„        Push DS                 ; We need to set ES = DS„        Pop ES                  ; so we'll use the stack to do it„        Cld                     ; make certain of forward scan„        Mov BX, String          ; the address of descriptor„        Mov CX, [BX]            ; CX = length of string„        Mov DI, [BX+2]          ; ES:DI = address of first byte of String„        Mov BX, OldChar         ; the address of OldChar„        Mov AL, Byte Ptr [BX]   ; AL = character to replace„        Mov BX, NewChar         ; the address of NewChar„        Mov AH, Byte Ptr [BX]   ; AH = character to replace it with„Top:„        Jcxz Exit               ; exit if it's a null string„        Repne Scasb             ; scan for the old char (in AL)„        Jnz Exit                ; zero flag clear if no match found„        Mov [DI-1], AH          ; DI points one byte beyond the match„        Jmp SHORT Top           „Exit:„        Ret„Replace ENDP„        END„BBrian Mclaughlin               COUNT ALL INSTANCES OF A CHAR  comp.lang.basic.misc           01-28-97 (19:59)       ASM                    38   1517     CHARCNT.ASM ; CHARCNT.ASM  - assemble with MASM 5.1 or compatible assembler„;              - for use with QB4.x / PDS near strings only„;              - written by Brian McLaughlin. Released to public domain.„;„; This FUNCTION is designed to count all instances of a character„; in a string. The character to be counted is passed to the routine„; as an ASCII code.„;„; Declare it:   DECLARE FUNCTION CharCount% (St$, Char%)„;„; Example:   Test$ = "000X000X00"„;            PRINT CharCount% (Test$, ASC("X"))  'prints 2„„.MODEL MEDIUM, BASIC„.CODE„„CharCount PROC USES ES DI SI, String:WORD, Char:WORD„        Push DS                 ; We need to set ES = DS„        Pop ES                  ; so we'll use the stack to do it„        Cld                     ; make certain of forward scan„        Mov BX, String          ; the address of descriptor„        Mov CX, [BX]            ; CX = length of string„        Mov DI, [BX+2]          ; ES:DI = address of first byte of String„        Mov BX, Char            ; the address of Char„        Mov AL, Byte Ptr [BX]   ; AL = character to count„        Xor DX, DX              ; start count at zero„Top:„        Jcxz Exit               ; exit if it's a null string„        Repne Scasb             ; scan for the count char (in AL)„        Jnz Exit                ; zero flag clear if no match found„        Inc DX                  ; DX accumulates the count„        Jmp SHORT Top„Exit:„        Mov AX, DX„        Ret„„CharCount ENDP„          END„BBrian Mclaughlin               REVERSE INSTR ROUTINE          comp.lang.basic.misc           01-28-97 (19:59)       ASM                    67   3481     RINSTR.ASM  ; RINSTR.ASM  - assemble using MASM 5.1 or compatible assembler„;             - for use with QB4.x only„;             - written by Brian McLaughlin. Released to public domain.„;„;„; This FUNCTION acts as a reverse INSTR routine - it looks for the *LAST*„; instance of a string within another string.  RInstr% returns the position of„; the first character of the last instance of Search$ in Target$, as an offset„; from the *START* of the Target$.  „;„; For example, if the last instance of Search$ starts at the first character „; of Target$, RInstr% returns 1. If no instance of the Search$ is found in „; Target$, then RInstr% returns zero.  A zero is returned if Target$ is null,„; if Search$ is null, or if Search$ is longer than the Target$.„;„; Declare it:  DECLARE FUNCTION RInstr% (SearchFor$, Target$)„;„; Example:„;           FullPath$ = "D:\DIR1\DIR2\DIR3\FILENAME.EXT"„;           LastSlash% = RINSTR%("\", FullPath$)  'returns 18„„.MODEL MEDIUM, BASIC„.CODE„„RInstr PROC FAR USES ES DI SI, Search:WORD, Target:WORD„         Mov BX, Search      ;  BX = address of Search$ descriptor„         Mov CX, [BX]        ;  CX = length of Search$„         Jcxz NotFound       ; if Search$ is null, exit with 0„         Mov DX, CX          ; DX = length of Search$„         Mov SI, [BX+2]      ; SI = address of first char of Search$„         Mov BX, Target      ;  BX = address of Target$ descriptor„         Mov CX, [BX]        ; CX = length of Target$„         Jcxz NotFound       ; if Target is a null, exit with zero„         Mov DI, [BX+2]      ; DI = offset of first byte of Target$„         Add DI, CX          ; point DI one byte past end of Target$„         Sub DI, DX          ; point DI at last "possible" byte of Target$„         Mov AL, Byte Ptr [SI] ; AL = value of first char of Search$„         Push DS             ; assign value of DS to ES„         Pop ES              ; using the stack as the vehicle„         Sub CX, DX          ; we may not need to scan all of Target„         Js  NotFound        ; if CX < 0 then Search$ longer than Target$„         Inc CX              ; adjust to get proper number of bytes to scan„ScanStr:„         Std                 ; set direction flag for backward scan„         Repne Scasb         ; scan for a match to AL at ES:DI„         Jnz NotFound        ; zero flag cleared if no match found„         Push SI             ; save the necessary registers before„         Push DI             ; they're destroyed by Cmpsb, and note that„         Push CX             ; ES:DI points one byte prior to matching char„         Cld                 ; now we'll search forward again„         Mov CX, DX          ; for the length of Search$„         Inc DI              ; but first, re-point ES:DI at matching char„         Repe Cmpsb          ; do the comparison„         Pop CX              ; restore earlier loop counter„         Pop DI              ; and point everything back as it was„         Pop SI„         Jnz ScanStr         ; zero flag set means Cmpsb failed to match„         Inc CX              ; Scasb has decremented CX past correct byte„         Mov AX, CX          ; put the placement of first char into AX„Exit:„         Cld                 ; ALWAYS clear the direction flag before return„         Ret                 ; AX holds returned value„NotFound:„         Xor AX, AX          ; return a zero in AX„         Jmp SHORT Exit„RInstr ENDP„       END„BBrian Mclaughlin               OUTPUT SOUND FROM PC SPEAKER   comp.lang.basic.misc           01-28-97 (19:59)       ASM                    72   2921     SPEAKER.ASM ; SPEAKER.ASM  - assemble using MASM 5.1 or compatible assembler„;              - for use with QB4.x only„;              - written by Brian McLaughlin. Released to public domain.„;„; This SUB works a lot like BASIC's SOUND statement, but it won't pull „; BASIC's floating point math library into your EXE file, saving you 9K.„;„; You pass it two integers; the first is the frequency you want„; (in hertz) -- this number must be 40 or greater. The second integer„; is how many timer ticks (1/18th seconds each) you would like the speaker„; to sound. The speaker is initialized only at the first CALL.„; If the duration requested is a negative number or zero, no sound is made.„;„; It is especially good for making beeps less annoying than BEEP makes.„;„; Declare it:   DECLARE SUB Speaker (Freq%, Duration%)„;„; Example:„;          FOR Freq% = 50 TO 1000 STEP 50„;            Speaker Freq%, 1„;          NEXT Freq%„„.MODEL MEDIUM, BASIC„„.CODE„        PortReady   DB 0        ; put this data in code segment„        ClockFreq   DD 1193180  ; put this data in code segment„„Speaker PROC USES ES, Freq:WORD, Ticks:WORD„        Mov BX, Freq    „        Mov CX, [BX]            ; CX = requested frequency in hertz„        Cmp CX, 40              ; trap any frequency below 40„        Jl  Exit                ; Jl because CX is a signed integer„        Mov AL, PortReady       ; let's see if this is the first call„        Cmp AL, 0               ; if it is, PortReady will be zero„        Jz  SetPort„PortSet:„        Mov BX, Offset ClockFreq ; to get the period you must divide„        Mov AX, CS:[BX]          ; Freq by the constant 1193180, so ...„        Mov DX, CS:[BX+2]       ; now DX:AX = 1193180„        Div CX                  ; this puts the period in AX„        Out 42h, AL             ; send it as two consecutive bytes„        Mov AL, AH„        Out 42h, AL„        In  AL, 61h             ; read timer port B„        Mov CL, AL              ; save it„        Or  AL, 3               ; toggle speaker bits on„        Out 61h, AL             ; and send it back„        Xor AX, AX„        Mov ES, AX„        Mov BX, Ticks           „        Mov AX, [BX]            ; AX = requested number of ticks„        Cmp AX, 1               ; see if Ticks requested were < 1„        Jl  SkipLoop            ; remember AX is a signed integer„        Mov DX, ES:[046Ch]      ; peek at low word of timer tick count„        Add AX, DX„WaitLoop:„        Mov DX, ES:[046Ch]      ; peek at low word of timer tick count again„        Cmp AX, DX„        Ja  WaitLoop            ; as long as AX > DX, keep looping„SkipLoop:„        Mov AL, CL              ; restore old port B setting (speaker off)„        Out 61h, AL„Exit:„        Ret„SetPort:„        Mov AL, 182„        Mov PortReady, AL„        Out 43h, AL„        Jmp SHORT PortSet„Speaker ENDP„        END„P„        END„Brian Mclaughlin               BINARY SEARCH                  comp.lang.basic.misc           02-06-97 (00:50)       ASM                    104  4685     BSEARCH.BAS ; BSEARCH.ASM - assemble with MASM 5.1 or compatible assembler„;             - for QB4.x / PDS only„;             - written by Brian McLaughlin. Released to public domain.„;„; This FUNCTION accepts an integer value to search for in a sorted array,„; along with the address of the first element and the total number of„; elements in the array. It returns the number of the element where the„; value was found (assuming a 1-based array). If the value is not found,„; it returns the element (as a negative number) where the value would be „; inserted into the array to preserve its sorted order.  „;„; For example: given a search value of 105, if element 10 contains 100 and „; element 11 contained 110, BSearch would return -11.„;„; BSearch will give valid results ONLY for an array of integers, that is„; sorted in ascending order (lowest to highest), and has no duplicate„; values.„;„; DECLARE FUNCTION BSearch% (FindValue%, SEG Array%, TotalElements%)„;„; Example:„;         LookFor% = 666   'see if any elements of TestArray%() = 666„;         FirstElem% = LBOUND(TestArray%)„;         TotalElem% = UBOUND(TestArray%) - FirstElem% + 1„;         Result% = BSearch%(LookFor%, TestArray%(FirstElem%), TotalElem%)„;„;         IF Result% > 0 THEN„;           Result% = Result% + FirstElem% - 1„;           PRINT "Found "; LookFor%; " in element "; Result%„;         END IF„„.MODEL MEDIUM, BASIC„.CODE„    Last DW 0„„BSearch PROC USES SI DI, Value:WORD, Array:DWORD, Elems:WORD„    Mov BX, Value      ; point BX at Value„    Mov AX, [BX]       ; AX = value to be searched for„    Mov BX, Elems      ; point BX at Elems„    Mov DX, [BX]       ; DX = total number of elements„    Inc DX             ; adding one allows last element to be searched„    Mov DI, DX         ; DI = last element in search area„    Xor SI, SI         ; SI = first element in search area„    Mov Last, DX       ; Last = most recent element searched„    Lds CX, Array      ; point DS:CX at first element of array„    Cmp DX, 3          ; see if Elems was 0 or 1 (DX was inc'ed)„    Jb  ZeroOrOne      ; if so, deal with it as a special case„Search:„    Mov BX, DI         ; DI = top element of "search area"„    Add BX, SI         ; BX points to element halfway between top/bottom„    Add BX, CX         ; add offset of first element within DS„    And BL, 0FEh       ; this is needed whenever DI = SI+1„    Mov DX, [BX]       ; DX = the value at current "halfway" element„    Sub BX, CX         ; readjust BX "back" by amount of offset in CX„    Shr BX, 1          ; and then adjust from offset to index value„    Cmp BX, Last       ; was this element searched once before?„    Je  NotFound       ; if so, we've run out of search area„    Cmp DX, AX         ; does this element match Value?„    Je  Found          ; if it does, we've found our element!„    Mov Last, BX       ; remember we looked here already„    Cmp DX, AX         ; now compare again„    Jg  TopDown        ; if DX was > value, adjust top down„    Mov SI, BX         ; otherwise adjust bottom up„    Jmp SHORT Search   ; and keep on looking„TopDown:„    Mov DI, BX         ; adjust the top down„    Jmp SHORT Search   ; and continue looking„„NotFound:„    Or  BX, BX         ; find out if BX = 0„    Jz  BXZero         ; if so, we must go decide what that means„    Neg BX             ; return a negative number„    Sub BX, 2          ; adjust 0-based to 1-based and el below to el above„    Jmp SHORT Exit„Found:„    Inc BX             ; adjust 0-based to 1-based return value„Exit:„    Mov AX, BX         ; put return value into AX„    Push SS„    Pop DS„    Ret„„ZeroOrOne:„    Mov BX, -1         ; assume a return value of -1„    Dec DX             ; readjust DX to value in Elems„    Or  DX, DX         ; see if Elems = 0„    Jz  Exit           ; if so, exit with return value of -1„    Mov SI, CX         ; points DS:SI at first (and only) element„    Mov CX, [SI]       ; CX = value of only element„    Cmp AX, CX         ; how does it compare to search value?„    Jl  Exit           ; if it's below, exit with -1„    Dec BX             ; assume a return value of -2„    Cmp AX, CX         ; compare again„    Jg  Exit           ; exit with -2„    Mov BX, 1          ; or else, search value equals first element„    Jmp SHORT Exit     ; so return with 1„BXZero:„    Dec BX             ; search value is <> first element, assume it's <„    Cmp DX, AX         ; now, see which it is„    Jg  Exit           ; if it's "<" return -1„    Dec BX             ; otherwise value is ">" so,„    Jmp SHORT Exit     ; return -2„BSearch ENDP„    END„Petter Holmberg                ASSEMBLY TO BASIC              petter.holmberg@usa.net        04-28-97 (12:15)       QB, QBasic, PDS        308  11905    ASM2BAS.BAS ' -------------------------------------------------------------------------- '„' Absolute Assembly by Petter Holmberg, -97. Ver. 1.1beta:                   '„'                                                                            '„' I recently started using DEBUG to create Assembler routines for BASIC with '„' CALL ABSOLUTE. It didn't took me very long to discover that turning        '„' Assembler code into a BASIC string with machine language was a long and    '„' tedious process. Working with the code in a text file instead of directly  '„' from within DEBUG and then then type:                                      '„' DEBUG < sourcefile > destfile                                              '„' made it a little easier, but it was still a lot of work.                   '„' Before the first run through DEBUG, there's no way of knowing how many     '„' bytes of code to unassemble, and after the second run when the source file '„' was modified to unassemble the correct number of bytes, there was still a  '„' lot of work moving the machine code to BASIC. If you have tried yourself,  '„' you know what I mean.                                                      '„' So I made a program to do the work for me. Absolute Assembly 1.0.          '„' But soon after I had finished Absolute Assembly 1.0, I needed to do a      '„' routine with a JMP instruction. So I made this new version with support    '„' for line labels and comments.                                              '„' This program will let you choose a text file with assembler instructions,  '„' a destination file name and a string variable name. The result will be a   '„' set of commented BASIC lines in the destination file which declares a      '„' string with the name you have chosen, ready to be executed.                '„' Ex:                                                                        '„'                                                                            '„' You have a text file looking like this:                                    '„'                                                                            '„'          XOR AX, AX   ; Set AX to 0.                                       '„'          MOV CX, 10   ; Prepare for a loop.                                '„' TheLoop: INC AX       ; Increase AX.                                       '„'          LOOP TheLoop ; Loop 10 times.                                     '„'          RETF         ; Return to BASIC.                                   '„'                                                                            '„' Run it through this program and you will get these lines moved into a      '„' selected QBASIC program:                                                   '„'                                                                            '„' asm$ = ""                                                                  '„' asm$ = asm$ + CHR$(&H31) + CHR$(&HC0) ' XOR     AX,AX                      '„' asm$ = asm$ + CHR$(&HB9) + CHR$(&H10) + CHR$(&H0) ' MOV        CX,0010     '„' asm$ = asm$ + CHR$(&H40) ' TheLoop: INC AX                                 '„' asm$ = asm$ + CHR$(&HE2) + CHR$(&HFD) ' LOOP    TheLoop                    '„' asm$ = asm$ + CHR$(&HCB) ' RETF                                            '„'                                                                            '„' Notes:                                                                     '„' ˛ All lines in the source file must have one Assembler instruction in it.  '„'   Don't use blank lines or lines with just comments.                       '„' ˛ Comments must start with a semicolon, (;).                               '„' ˛ The maximum number of labels is 256. You shouldn't need half as much.    '„' ˛ The maximum number of letters for a label is 16. It's easy to change     '„'   the program to accept a larger number, but it's probably not necessary.  '„' ˛ A label must be immediately followed by a colon, (:).                    '„' ˛ Never use Assembly opcodes or numbers as labels.                         '„' ˛ "Label:" and "label:" are processed as different labels.                 '„' ˛ Do not write lines like: REP MOVSB. When assembling, DEBUG will divide   '„'   this into two lines; REPZ and MOVSB. This will mess up everything for    '„'   this program. Sorry, I didn't bother to write any code to handle such    '„'   occurrences.                                                             '„' ˛ This program was made in QB45, but you should be able to run it in       '„'   QBASIC, PDS, VBDOS and PB as well.                                       '„' ˛ I haven't really tested this program for bugs, so please be patient with '„'   me. :)                                                                   '„' ˛ Any comments/suggestions can be sent to: petter.holmberg@usa.net         '„' ˛ I know, I know, the source code is VERY crappy, but I wrote this in just '„'   an hour or two and it works! Maybe I'll add some more functions later... '„'                                                                            '„' Enjoy the program and have fun!                                            '„' -------------------------------------------------------------------------- '„„CONST rundebug$ = "C:\DOS\DEBUG.EXE" ' Change this if you have DEBUG on„				     ' another location.„CONST tempfile1$ = "TEMPFIL1.TXT"    ' Change this if this filename already„				     ' are in use.„CONST tempfile2$ = "TEMPFIL2.TXT"    ' Change this if this filename already„				     ' are in use.„CONST tempfile3$ = "TEMPFIL3.TXT"    ' Change this if this filename already„				     ' are in use.„„TYPE labeltype                       ' Usertype for storing of labels.„  labelname AS STRING * 16„  labelpos AS STRING * 4„  labelnum AS INTEGER„END TYPE„„DIM label(1 TO 256) AS labeltype     ' Array for storing of labels.„„numlabels% = 0                       ' Label counter.„linecounter% = 1                     ' Line counter.„„CLS„„PRINT "Absolute Assembly by Petter Holmberg, -97. Ver. 1.1beta:"„PRINT„INPUT "Assembly source text file: ", sourcefilename$„INPUT "QBASIC destination file  : ", destfilename$„INPUT "Name of code string      : ", codestring$„PRINT„„conversiontime! = TIMER„„' Insert DEBUG instructions and assembly source code into tempfile and take„' care of lables and comments:„OPEN tempfile1$ FOR OUTPUT AS #1„„OPEN sourcefilename$ FOR INPUT AS #2„DO„   LINE INPUT #2, sourceline$„   IF INSTR(sourceline$, ";") THEN„    sourceline$ = LEFT$(sourceline$, INSTR(sourceline$, ";") - 1)„   END IF„   IF INSTR(sourceline$, ":") THEN„    numlabels% = numlabels% + 1„    label(numlabels%).labelname = LEFT$(sourceline$, INSTR(sourceline$, ":") - 1)„    sourceline$ = MID$(sourceline$, INSTR(sourceline$, ":") + 1)„    label(numlabels%).labelnum = linecounter%„   END IF„   PRINT #1, sourceline$„   linecounter% = linecounter% + 1„LOOP UNTIL EOF(2)„CLOSE #2„„CLOSE #1„„OPEN tempfile2$ FOR OUTPUT AS #1„PRINT #1, "a"„„OPEN tempfile1$ FOR INPUT AS #2„„DO„   LINE INPUT #2, sourceline$„   FOR labelscan% = 1 TO numlabels%„      IF INSTR(sourceline$, RTRIM$(label(labelscan%).labelname)) THEN„       sourceline$ = LEFT$(sourceline$, INSTR(sourceline$, RTRIM$(label(labelscan%).labelname)) - 1) + "100"„      END IF„   NEXT labelscan%„   PRINT #1, sourceline$„LOOP UNTIL EOF(2)„„CLOSE #2„„PRINT #1, ""„PRINT #1, "u 100, 100"„PRINT #1, "q"„CLOSE #1„„' Run DEBUG to create DEBUG output file:„SHELL rundebug$ + "<" + tempfile2$ + ">" + tempfile2$„„' Get length in bytes of source code:„OPEN tempfile2$ FOR INPUT AS #1„„DO„   oldline$ = midline$„   midline$ = newline$„   LINE INPUT #1, newline$„   SEEK #1, SEEK(1) + 2„   IF INSTR(newline$, "^") THEN„    PRINT "Error in source code detected. Look in "; tempfile2$; " for information."„    END„   END IF„LOOP UNTIL newline$ = "-u 100, 100"„„CLOSE #1„„asmlength$ = MID$(oldline$, INSTR(oldline$, ":") + 1, 4)„„PRINT "Source code byte length detected."„„OPEN tempfile2$ FOR OUTPUT AS #1„PRINT #1, "a"„„OPEN tempfile1$ FOR INPUT AS #2„„DO„   LINE INPUT #2, sourceline$„   FOR labelscan% = 1 TO numlabels%„      IF INSTR(sourceline$, RTRIM$(label(labelscan%).labelname)) THEN„       sourceline$ = LEFT$(sourceline$, INSTR(sourceline$, RTRIM$(label(labelscan%).labelname)) - 1) + "100"„      END IF„   NEXT labelscan%„   PRINT #1, sourceline$„LOOP UNTIL EOF(2)„„CLOSE #2„„PRINT #1, ""„PRINT #1, "u 100, "; asmlength$„PRINT #1, "q"„CLOSE #1„„' Run DEBUG to create DEBUG output file again:„SHELL rundebug$ + "<" + tempfile2$ + ">" + tempfile2$„„OPEN tempfile2$ FOR INPUT AS #1„„DO„   LINE INPUT #1, readline$„LOOP UNTIL INSTR(readline$, "-u 100,")„„SEEK #1, SEEK(1) + 2„„labelcounter% = 1„linecounter% = 1„„DO„   LINE INPUT #1, readline$„   IF label(labelcounter%).labelnum = linecounter% THEN„    label(labelcounter%).labelpos = MID$(readline$, 6, 4)„    labelcounter% = labelcounter% + 1„   END IF„   linecounter% = linecounter% + 1„LOOP UNTIL readline$ = "-q"„  „CLOSE #1„„OPEN tempfile2$ FOR OUTPUT AS #1„PRINT #1, "a"„„OPEN tempfile1$ FOR INPUT AS #2„„DO„   LINE INPUT #2, sourceline$„   FOR labelscan% = 1 TO numlabels%„      IF INSTR(sourceline$, RTRIM$(label(labelscan%).labelname)) THEN„       sourceline$ = LEFT$(sourceline$, INSTR(sourceline$, RTRIM$(label(labelscan%).labelname)) - 1) + label(labelscan%).labelpos„      END IF„   NEXT labelscan%„   PRINT #1, sourceline$„LOOP UNTIL EOF(2)„„CLOSE #2„„PRINT #1, ""„PRINT #1, "u 100, "; asmlength$„PRINT #1, "q"„CLOSE #1„„PRINT "Label conversion completed."„„' Run DEBUG to create DEBUG output file again:„SHELL rundebug$ + "<" + tempfile2$ + ">" + tempfile2$„„PRINT "DEBUG output file successfully created."„„' Transform the source code into BASIC string declaration lines:„OPEN tempfile2$ FOR INPUT AS #1„„DO„   LINE INPUT #1, readline$„LOOP UNTIL INSTR(readline$, "-u 100,")„„SEEK #1, SEEK(1) + 2„„OPEN destfilename$ FOR OUTPUT AS #2„„OPEN tempfile1$ FOR INPUT AS #3„„PRINT #2, codestring$ + " = " + CHR$(34) + CHR$(34)„„linecounter% = 1„labelcounter% = 1„„DO„   LINE INPUT #1, readline$„   IF NOT EOF(3) THEN LINE INPUT #3, sourceline$ ELSE sourceline$ = ""„   'PRINT sourceline$„   readline$ = RTRIM$(readline$)„   IF readline$ <> "-q" THEN„    sourcedata$ = MID$(readline$, 11, 14)„    basicline$ = codestring$ + " = " + codestring$ + " + "„    FOR makebasicline% = 1 TO 13 STEP 2„       IF MID$(sourcedata$, makebasicline%, 2) <> "  " THEN„	basicline$ = basicline$ + "CHR$(&H" + MID$(sourcedata$, makebasicline%, 2) + ") + "„       END IF„    NEXT makebasicline%„    basicline$ = RTRIM$(basicline$)„    basicline$ = LEFT$(basicline$, LEN(basicline$) - 1)„    basicline$ = RTRIM$(basicline$)„    basicline$ = basicline$ + " ' "„    IF label(labelcounter%).labelnum = linecounter% THEN„     basicline$ = basicline$ + RTRIM$(label(labelcounter%).labelname) + ": "„     labelcounter% = labelcounter% + 1„    END IF„    basicline$ = basicline$ + RIGHT$(readline$, (LEN(readline$) - 24))„    FOR labelscan% = 1 TO numlabels%„       IF INSTR(sourceline$, RTRIM$(label(labelscan%).labelname)) THEN„	basicline$ = LEFT$(basicline$, LEN(basicline$) - 4)„	basicline$ = basicline$ + RTRIM$(label(labelscan%).labelname)„       END IF„    NEXT labelscan%„    basicline$ = RTRIM$(basicline$)„    PRINT #2, basicline$„   END IF„   linecounter% = linecounter% + 1„LOOP UNTIL readline$ = "-q"„„PRINT #2, ""„„CLOSE #3„CLOSE #2„CLOSE #1„„PRINT "Source code successfully moved to QBASIC destination file."„„KILL tempfile1$„KILL tempfile2$„„PRINT„PRINT "Time of conversion:"; TIMER - conversiontime!; "seconds."„Erika Schulze                  MANDELBROT SET W/MACHINE CODE  100775.2275@CompuServe.com     06-01-97 (06:13)       QB, QBasic, PDS        178  11803    MC.BAS      DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"MC.ZIP",4^6:Z&=8594:?STRING$(50,177);„U"%up()%9%%%I-%A[mnGqh8hpV(7%%'3%%%0%%%%fu%VWvg%VSgfOx.&<+xT]5uwU„U"E]adeU#7IuKpswC-PEZ5]?a4H*LjnUrv/w]Q-G;DmAsFrn0Da4$>hE8bLYv=W6t„U"nVngQ\nTB%c]#_=Usk<KU5u'SK,fRh5rD3<4RWw#nLeS%EX.I5m9FG.=>VyB;R<„U"o&u9KYH[*yQ4M?2m+)88IkQnB36dQi2B>G/viITYL#/m=s/0;h[/=[sG%g.ogW=„U"Ds>cW&f?rm]>i*UhUf.(2;[S7a*WBW_e2EI/>0_''igRYp(aY4/;1[6ZQ,e4;iQ„U"-93#%cIK+)Vi\77,Xcvp,+l_G8\Wp87q#qR%)aog0s1#?2\xO^-[dMZ5-X6V+6,„U"?L':[f),WX_->Ck1rg5^WX._-CWnpYRPu&KVe)u4r6TE9F5#x[#;i8=+m-9iYk8„U"J5u.OgGb5Q\wt_2OV898*yqwFy'GA%;jy.eU8zBMj\VfnIMk,-MLD(RhS-K$e'O„U"(EG+4EGAw,xIaD[9(N*fm+noM9DL%E#ZOa+)i-BTc1ep>,]i$A80hS8vF$Pp:hv„U"N:4Vb2-J/T,neEul/81yh*O*en3<18;Kj]*xl$Xh#jolP(YpuX8Hig*OC7GJ^1z„U"'%IzKUL2M;GK3CQ8l&x??s#Vz?t+h&Iq42Aeg,1O5+dpq<NUG*9IYp*?FBT45zA„U"TnNJ&A,LOYLwL>.f4r/5/9+j&4ZuDd+C_h(S.pfXENX$l)a[m^e?%6aVZPTr8_U„U"fB2iZT9_t$P+.$U[grQSFy*S.0j1zk[qg)__vO<0c7h6Hhb74GA/Fq]+k%NkR6P„U"EX12Ep8Hnsj\c[6%fWghC7gbS+kME\CQkOes8qMrr9pxZVH,t8]?:8=kV>0Pz'5„U"i=bq])o[VLd^\u.337GOWnh5CWOju3SQrucs31U^r\,pE:oHtB7saXMtlHu]qI7„U"TXd;%7$]KIs0nE#E_e.[:O0HYe+jTNdMnDusJEiWsH(r:oo<$/7(/OtZ*1J1nIv„U";Gg+R1NfV)I;/JT%_0UwbNL03pCV%#3d1]rZ6GnY;HW\-qf6i7J)0vrz?]-uZ+:„U"Nf?)eD&JjZlInK'Q(LIMX-zLZ,7gLa)n6oLku7AS>^H.p<=vYM:#Il?=n9SQe_L„U"Gl14RWa;8q/4$Sjtc]<D^4Jf''&=%QYQ2\FYJON$gU4d_jm*Cae(rd\\c?JNVDH„U"+rNmVqffd_zZgK/m)JKtGx+?AM\UFo#'4tP>qRun,W/qNc>:#>NDx4CejptFY99„U"ujS'pt^lf0m(RI_g+E.OqQWI&'nDup%()9%%%%-%(.LnG(5noT%I,%%&(C%%%0%„U"%%%fuVW%vgWS[gfxF_(<xSRo9w+G5q46DgIf[36PqjFBh1d)'hG_VO<hC0u5az,„U"1lk[syYPX6,4HLdE/l2]tfF4rHHTlekb(SoCj0Nh&/?pa>siN+2t6O],b._>Jt>„U"gR$Vt,CZKcZuHD$4.#M<oeX3y$DxB/yl&<>N4XM$n%Ma]C*q2'_f*AjsGmc#]=2„U"'$a_Iy*Dr\KP/\01_PM/8JdS^Lt_O\CeyJ\2jOH_aiG.vQ'?LJ^J?j3X)vkPkt;„U"s)At*AOWs*c=ofN)D^u?N\kVV^%F$el$YKNHl:Z59=)Vx)n(QY\qtb;G;n2Z1E'„U"U:Pr%xu%[Zj9QR[1PO0mW9sGg)w*Z7.W1G^U2o,hVikW?O>='*n%(v*+U%1SmH9„U"1;<wgDheSRoRl[8e%*kTDa&TN1P0AC3Oj^W1_nU[b19&1ltCR0ON1Msch+V&ACU„U"\+QPIXW)vOWbG)eu^_d1Hf_2*nN_:S70T=pF)M:Hu*A3#HpKWXS.-9q8o[WWM$]„U"KV^//NQ2)nW_gJZ*2>CB,=0hkx\di:Bm:SCA0'GGS9qs^_M+:(c2NOO%GCq=(=p„U"(13Qxn-QuSRyg].;oIuWEICa%gcE+O3(*lCWe3uPr+MJcbE<8(=GC.)YqukAlD+„U"%$m$6OpuYMZYrg/&6G4FIyfQlnE)KomyAaSZd-)5BgmyApZ_>7Y^IyFzSf>['#j„U"c,D#:2+p3g,=nvMjGcfACLuTWBFaG<ajc8=ql:j/.vIutz(+pETf;mgCw=QW2%s„U"zS%v[BPnqq16Zku41&PU\pu>AR0nV8%7]&I^'m(VpJq>rv8MsS(#UZt$5i\^LM(„U"3Q5fen'MMq/&h$?R]Ec:+E94v%zqBDfA4o*Q%L))[1pN8__#1I5n]Dyn2N11ZBr„U"je<)0d-1*=aw<W31-[(IDs2.CjBH&*n0-d<#mZq6'c0Q0+6(4Z%;Gv0JBQY2=))„U"3O9]M\:qQUI/nA.QM:E-iKbKGNNosa1b0W2d/*0.7C+o;$nfqTXA.nGu6odW[<<„U"(lDEA9,fW*wP+1f(UlD5gTM=+--6.XJG_Ff;$[ABnr#9Q#*:0\ijs*l>C^G__TU„U"MYwmSw:zKdN(dUMm,K2BMChwa0npUoo(JuI6*._A4/UlR3^RZWl^vcUTn2-Pr8S„U"_r,n2TBEOhi0HCiLBX]q>y1<):H(sb\U?B.1pn%$[Y?QN+oufAP#5<k(Q97<0X$„U"-fZ:YS4.cHelAc*%S-CxK7)h^rRETh*mUu'f>y,onUU]Vb<b1u#XM2G$I7Nf-$T„U"pX?Tm.]iO<1p\_]*CHNV2E8+KXHag_>/&\l_HCS;cgN-]\X\M?bsC^A4]-hjIjd„U"DC'KSXO2x--EHKN&hae.x/.Jo&KX#oKKTSD%zLt2<<*HpF<*.G<#n8Z(+f5'cL\„U":Hd3j(+s7cvkg-P*gE#Q9JvKKmrt#4<<L?,v]VZ<SE&00]n]GdCigc]jcxA2_Ji„U"HX7513;^<8PHnUYkO#$s2Uvn/#/*n+YHQ%xhZVL-?HJX<DvCsQN]LA'SZsG?T)_„U"U??q^HQ2)Y#mWno9m%N-Fv3eX'lciBFFc]PO?Fs_Aw'Zi1VceefbLaUC-,XDH'd„U">*1b?L4SMw\mk(a&]ZvLlsDXIxa0n55rBFYq.JQzbe1G'bhE)yXttK&=x[+v6Y&„U"IZ<S8No<8o3l,tO:iR[?X.A&6c4H3>?Mb^8f:9s(k#7bB)(4eu?R>f(B'xaQ->P„U"gdm)(D1nSI_R6KDXGo_IQeksSBAAGYf18phrPS]]=Jm-bCOGM^q[]sl)[_6]eY?„U"k/l^qO4-/t5t=Du6>uITV;rWV6dFH3tI60p#hW>_W#\6ew:-5lZ3XFrazk-])YH„U"R\-$3NP3I2jzNA;k(HSlt<-AM<#\<NaOMP,tB+LedIFT<t?3KAm2UZj/xL]t]J:„U"i#Mvu1+LJh>WXl1W)gbgz?Rb&hHZ.*cxF?o?Nbo^rwZc)V/$KUOvMd77gM/i=6#„U"1#y*QU.NGLn)uPbm*\CZe&6GZP\kOqgSH^FpDaich>bY<dS^ZDQ(D(mdM]5:]g-„U"$Co7G=0/(GSGGqs\=WbDG=WK/t;[7Yp>5gHwfBPWR$k4wuRSCe&DGZ9.,%NsWK0„U"m-oaI7GbFP&[[K)HMn2rO.3ZOq-'cV21OJmhx)a7p8jT6'8vND_Xp;=>7OUuh,:„U"gLMriZ&N&ccw3OZ/FS<d/OcJ+tE_*7Ea1E]+iwehqf1:WSCV'N5WG:SCA-VA-aE„U")xYgS702ANu9<XF?OK>\A3+4t&6MM$K)u$I2$Hq\\i8hh9RGkGF/rHP:xqXOJVd„U"/_IN9bOIz_Idshtzkht&LkMc2P(do-&x%u%p()9%%%%-+%?&oUGs%h+7',%%%NE„U"%%%0%%%%fuV%WvgX%SgfxNF(L>]S]=x<t_q3)^yVMCrF.<:>:>IE/5#)dlL/T&l„U"s$N1Iu30:nW</kKsJe(]X8'DtTn6q8)*vtJWu5uR2OX<WCs_X175P[cVQTW6RSq„U"Yq9+A/+S,p,zX1$E]z]./<D=E'.^J;.=f/Q7N='*<8[9[.k3pU'o'-L[)QWn&+?„U"+k_7JSq)PF<=^x'Df4hDU[NaMQxM(x,7B#uYyjx<kQmS&L,^msj2[YZN2\ze#7b„U"Es(v)L\6u&^x'z)+m7\=)<+'gg8Yli?2Ptaae<Y[gH-:90<=&RPUghdRq1F4(;3„U"2]fNf)[/#kNdYABgLi%3j'DJsUgEUR1QL?ZZjZAWU'RSQs%R$EK^(ep=B.)g*#,„U"U1='AG]<;J9UV+SSkSBDA<PQQ;4h0^gKFDg)%/]OHc]N.0bQEJEyU*P9#H>U[dc„U"I$R>[97VnB0+%FcCB$%%YWX?auZR3f4?:A0(6BDF=q=hRd)7hfaH=1j&J0V86#j„U"KX8dODG+aH]C7KVT2BBB.w%],39W_[xer_6Ku:qi0-Wj()9S9VPy\_4J/%h7JTh„U"38&/0>MZw;>]k*:5GpM6'$fpLdETgemXn3X'^eYGYLQ,(svI1A;q8[YH2mBJ&/X„U"MYQn]0bo\*^.7tERffz2Lgc>][1>5W7Rk#T\GN.XeKe3+S:cD3b=]Aq2jja<$o_„U"K'H<.w1M#5:0-LA'[(Tu-\9(I9I,oX1/CA*ZB1#i35a[j-9\DO382RRs?vV_sk2„U"Tq8G*n9KfOc[KEou*8R7o_^gtd(,m4Bt0(^[<Et)ag(bn='MF-s.?#YV<.PJVo<„U"mXH(h$'rd_V)Ttnh>]SjnAkD[jCVtF0L^5$\5YT?2i*Xnk#(%^Aya3neEL?8eN$„U"_0f5%%U[dm7[F,2&Hs9)n;Ksr:X*dG[\n9)58#p:$uQYE'W*0cr]5cG[vn9_M8#„U"#&ZrVcf'h5Cq:dZn&+q/cI6c6^jYsrw-]W3L3)9j7aYZRa3>(NJim(tu\b9$DKb„U"?&i5dI0J$BQz;rpQI9SmOG5jH<E5/HM0^$Jk&QGPjYv0*(ZwhIP1b/X&;s\=*wi„U"dil2ac.w3).FiK9->ja4liGj:QfFfpD-ZQuDWbuSWiY)[IG1xW%(oWfn]nu,]tS„U"[bgn;UPk?OGRY;:iRKW8PX8p<?K^hpVWSrk$^^m,YJkvT:IVix'#d9I)+lFs.Vj„U"F,8EP+h,rX%J(m-wP5.%jdc4TmFMM8/C,P0#/2GehV]V]*BuJ-g_vs(VY7K8J/Z„U"a\NEtw2V,$8f#NS)CcaKh+IbhI-Yq/ys)3#.AlxR5M5N1j7Yn.GE^x##[aVtjAU„U"vSL*d-4d#epzo+vM;hO:L%cS5MXQnX.Vh>B8T#T;6a]HZ,[7-A(/le&5-:EJO#\„U"UC4nKPI^/VT7:#)PFeYs7Gz&D5=)9S>.C[uE-,<*m:;B)rt/M3RS_s4sWnHAgd8„U"M#Cg^_[khLXeo5H.Up9rOCguZ1mcbMYneJo</3(;)hYu/0;o$7.NHW+Z4h9^afS„U"ECCV2YXMo\htcWRv=.PK6GxREY\eRF\DU<c#1DgOYcV]tTdG)#(<<X/CzNssLqx„U"AU<:&$jgE724_nM&e.xw-Qu+x7<c43q8<J/cUD&MU?LP[%%I=vy+G:Q&L$^0%.)„U"8<kF14e'1xQ\;.oA#65;-/U1xU\Y=j.+_Mg]ql:nU6WGlD[liQ2%WHq&j/\jr*2„U",y$7pA1Et98Nt)]t#RGaeVMD%^=2j6&/:9PQxUX$8%V+CD8)Dv%IQrFcU+YcJ3=„U"+b>T_ik/LXPX54UY-[)V&LMHOOsi;hq7q3?<+F7>lZ<h*ZL_5]od(:)fciaJ;$B„U":4(//uu_+#\69^VzWc4PjhbK#sZ0Kr'$n2;(PH>I*cv5hL=%YPB&Dn5:^LSo$&4„U"rKFQV9q[S2ahKco%t1Mbe.nLe&;ngdkZC=,d2^6:bem4?E;k+:V2bQ2ciHteUSH„U"b^gqF^l5NBHkjn9cGj#D9FZE<ci0F_R7us>q:eWG\)=Nov5CZ,9e\5kRn9XK>bD„U"jL,ZeX9vpGu,Di<th6AV9Bj/m^v.>r\KKSMJeywr]wHNMVuPO&1yM=&iZFfu=HB„U"Nb9:J)a&f-ube<pGTe<s[9:UHn$GGPRN4jS>Ue9hRw)cIOk)g5#OTT*<\W7l5GV„U"W)'VG.)p<BwPqCZV]mO:]S(:+xDrR^P8#s^]1j6_7-lO/akCC:A[S<1ow3\9P(%„U"XU&-d$1KLgiY]Sw]n$15$L;M5c\nj;dWH<bBnO](qelRLGrL-^W9R':ItL/bdDl„U":=0Xtw%O^&NcNrqA-4Ttse<T<vvW*8bmt=#u:I[<q1n6ror3K.JJNE\^?.R$\.r„U"f$D]i1\vEQPopP\MFRc.Kk[$)MqGooP://fY<-d>F/$R>(C^=*-ZE-xT9cUE1eK„U"k._/1ui>(m)46;ib9)VDf]lp5?k%iV0'/?4t0s')$:HYx9O-Bl3ONspJrW<\Wz_„U"DJDn*8nBl4D/?&T6O\)'x&up%()9%%%%-%+:8nGBOo3q%l2%%&>D%%%/%%%%wjf„U"i%rjSyJ'yT(<TATk(7Ltz2M/n_)xYRN[9GwOp_#CdJdAHrHSnJeXxBL%(2O&^L6„U"W05m%vMP6hbm0XeB4jVy'5/;Iu4t&ncbIN;Nn%f?8HT<m*^YuZF?RS*xdi3/u.v„U"Z8K]JuNNCNdy#..uC%.lUTw,.,M:;-U0lcI;r0A_kq^o[Kt>$Ua6fmXD<)xhAmD„U"U:Q5ODPE6DYP^bfs&)0O4f(DU7tj8v3PiCCSVD86,ydylRP8AKNSr&Rf.S^Kqph„U"-&zG9u^YI72[;?UlET4Ql>f.W=vXia$LRbqfZldYzP+%YH(P4N4r%Dii/xlT,D;„U"90o_mtr.*.lbG6AQnYOfINLE4yUz-F$Qe,Nt$oLfmX#Oo=DVNQ[$U)xLawpbThO„U"jM9tI/2OV,^Qd03w?\_iOV1?GT(Rowvd:Ql3MTqoG,e(q25D?ekTo3n3i>Oqs-z„U";i;,D24E3KOf%DxMIE:zk0+)bH_*x)3kvq.M>Vu8uZ?O-aRtjZR]P&=VDVah#kQ„U"$,Dh\)0nZQn3N<8qXd\sFNe9kfV'+ZCTV_xd\?ciszFfh#yS_[(6kk7vQ%)6/M+„U"yd90tvvIodC5s.MQDVBH;bAJl8J<dSXBYdt?#bSJ?yZ7a&IH*(mKkIY4Y#APS)q„U"o;B;7WQDN#zh>Dj&+L9F&Fb(yl\>6jBD_#7Dm\y6*Gl##3o3x62ajSy.RWB;;*d„U"kxpY=aAE<q?6>KQ6kolKW*$s03/,eVS]$nXK+H&+E2U<^_qC):=u)2-F+S;%y_6„U"$96H+ju1k5Kj=r,#k=gzU6=WqG&f2*:y?dkuPJ=1#3fYG;cz'[,yN:5tHWNArkg„U"QvWl\*'Yj4#v%1Y9/:Z4h7V'Z92+[*3)0Nxw*Z3bee[&qP4h\d%PAc2d[##d68#„U"%mmZkPt]8&xREtc#;5kV(6t[aFDm%&VoxXKmhwQg?(5[_R^PVA=a#8>;T[Q8Y?6„U"jW&QwaoLM.3R*MuZoE[#mrSE0S'nFJ:fC,TV^/;Ii_^HO'ft2^;5nd.Ti5kfWuu„U"sgnqvzphp=VB#9?]XpNnF+s/;Y&Kov4\x$MIhBg-dy3d>[kpF2LcAMZfA9Bm2VY„U"nwjCG??.k+_ulk%._f,Qg\E:<QjD(]_:-L$ARrQ<DSS^xcvC'Mb-#o<46M74Y_F„U"Ezh+SY9IH98r3i^.VMj10>;P9-MJ,2;[VIC1Qu'KBP\e0bn+5mYjeanXmS;7_(o„U"ag&.<AJa69Ji)2d4?vJPm3mZ=R9NWr8qQbOGIL1Wskr$f5POF)#fz:do.W$OK##„U"+nzde=VnGMv5mRt(ekxX:B(>l$(^(oiFox&2_Lu)#XQO)z<]'e&So1*oG8+H<u-„U"<*ODyzIU^-D*5cZvS#p'^me^*'^jIp-AeI&E?=QBKQMF]rkaW=XD+o:.,)Gr=4E„U"aQ^T0i'H-0*$0Y&ad^P]l;1[=+DrXcjd[sAQ(Z5A_ajW(g?jInC%l>ZIGy%7,W)„U"6w%(#-(:8LUMQ.L\UI5o7fs/k3V1na/Y(YGBUmW.=\(KbiujoVSX*O9L.C7q'$/„U"JduVbDK.S+h7'W3M)/K3n\^,*oD?3]o87Ye-$*IO#dAUL:BkC>?W2ynKI8+1h*F„U"tBt-e]#sEhMY56bvn4Pv?uT./akgv=<#4\+^hEY:lYR/5]EpfTT#Of^\4'2txCm„U"bUL]mJWAH9r.l.h\_q(kYV_%1ez?o6_..UwF30p0rSb:q*)UJ4doKmb<.aoE%;*„U"01wUXdMIW27yGgzHdIXEX6DUs?bH:y(\?lJ2wEi:;PA4)2cziv-Te7a[W5H]#lG„U"Ym9H>^O$qFYJh$Sf*Qc2.XI4wiWa-o#N,N+JVTaF%q..s=936rfBZiEm+T+)%$O„U"aZOO-XBsx:OWtv<Q#eVXVa52'UQUja*ou2A6j7_.-DbUM1U.\TCkNP7R>m]s:4<„U",h\t^$b>b]FFT5tU#N0WUh$En^H;*^l.x040C9ek3quD4j:$u0Sn&'oIg)=9FhL„U"g-Wnqta/PC/v:lATR06#qB=DqhAB)58EB[^Y2cah98d#*biKSe6CT_x/fV])SjS„U"OL*]eEeRWy$;Wh0KC>GX8a2l7nRl.N*IY^C3mgh^s6J=vc:BFJ1py3Ptsp'#Uxi„U"tjoLTinou5Xk4xX%Xiu,S0)BM#r#9jV2XhV0BaV>Tj:ZQLlbz6([kPN(Ae?]*>R„U"$q]4PzhaV35Y:,b-#tag%TBslf,rd&.cCA'H44>^-:e*(q,,?Cu)(/\Xg.D%7I'„U"^NopCuHX#=tRwkMhU\k.$%8VL1G+R1Br33*d7ghIBVAvr/'K+WdYr\PWf7qIb6a„U".QO:oDB8A1=QQaEp(i2L:qQ4ew)1aO$<Pj,pV*X>JV;,F5&aBLV4Sh\KT_TSB[+„U"J&]7+0j\o)L*ANCV^fHq#/)Y*URvEm)Qkhv2$WhES:u]$7p\_3Nl_czK;1XV#6-„U"6M,<g&,fv]0B9$9'6i+5$(_1k6D*5tdA86YNd84FN;146#dk%SVrN[fZH=&KYNh„U"VV=\-#T&_gU;RneY3GP97wa=-EO.?$b0id>1YR^$)0?QoQCvwJXHVilww3j*v.f„U"ZspOnB)*T]&5,0y7FD77'OL[cmqR'+Fcl0d:0;X']hgnkI<Tnh4MrX6ZCDgk<S&„U"(Fv3tZ$B4,gxLbpJfB>bSYnmAy[3rPj:g[cU,4XBSssf<Ki&*&eK&bsjE>>L/.f„U"D%<Qs[*2BqZfYFVJ.6mz85oXN1e[:T%vEa[_Z;BsXbBeXfm;#a'W<eFAL0n.oAD„U"#p<rm96haO$$V6C*2Uc[t5)A_>KEaq1+W:<M/3Iho0<-JFV,WPO')cs[)$]A69I„U"l1lK(#iee-k<;PVn0\k_$xHU^)LMYH>uY6YdJh#.Gt6UXWZVXUanGe)#w328R#=„U"q'S-tbXPGMS_xK/9ZN^^4p7A%;j^e[bWakjr_iGjhaQDHJp-.J8c%Ugn/I.B.oO„U"sm\#7-=9&8iFKFW2aOjn_5Wg3rFCY]cKxHTb3Q'P,KK=Fj(e5TJS%(mtS%Fb)h6„U"[lWB<+a\djDFI>ebvvEqpg-<Q4zg1\6V*V\K\Y3P*R$cu_M(<,9dj5V)\=Eg3ug„U"5N0v>Vw+lGgHmnO4>ScV-Co3]7Y79qIc^0K(>u?fbd6FY&8>5Wa?1n^L0rty/qp„U"_Mn,GEj[:1tHsf.,i,>R1Y]FM?3,?&zn&tfOtY,FHuT,Nss'khTidi4p\j%g3I.„U"q_VJK]KL[h')2kUA0N7qt,'#G%bJ+q;#UdN1%Iv3f_lsm#WQ1lFqKR,NU8z:;sk„U"vRJ=>G3]otV.+>[3a=Q7t]X<otq8:#IQzT'NFA-N#FME0/vh]j&zXR'lY-r?2T+„U"MuSOc:0*EL6&VQt;OF8WoFim\L$UZ7,.b^VF>TYx?i\krUoYYtPoph*rl\SO33j„U"X?^Tp.V[SLvmODHz;[$jNj>XU<sL]1aTt/itrd40]X68$v*omQt_Sha,9/a,gY\„U"_-^25qrxeF[15(^LSVA2<et8g7z<YAlYwAtAV?*&7-gL8v;l?#Ap:cKiSDctC;Q„U"GmC5vaS\m#?%:Z.hd9sqaEpGM).3_COST(#61iEGYTg)-2?3ZRKb6^F2^:p=2J_„U"8w26U\^%rKg;BCW4i.<^sE%]en^vS$I9CKecA**96zsk^c_(j7^#n$]t_[bgYtl„U"mrUp]&4>cOrj$-l:.;)G4c.FXFA0:5qx/lB+vriqaC*650[d1SDR#[%_qGOIp&8„U"^+Uq6%mbK#KQr]FROgMAGD.1o8J^WRpe,bwQdO0?71SSI^c^m(d36[kATSFT-W;„U">V%384I2a$xl(W'lt-NCqf<bHHCLWJ5D>IXL02:nJp:L&E+N5Zwt*9>.5=$svcZ„U"eMAnv,(7R+^F.)vFUX,WT;4GlGC)Z8IZY._zN'*l%>H7cq2zyeCE'q(5,t6/c]E„U"L2JdC$n]($cITba3/P=ba#Zp,jhmN;7n)ksJ<fdL\_Z/F9oQRHPY0t;XU%<v;Sc„U"bGonPMoJFb;CLw67sp1K;<&KREKC')dVPD:DrA$ZA+MeedRo=;-WA4XDbn<vtY\„U"Jw>Cvll[oLmT,MSD\i+s3[Q>-.Vm+AMZUNz<(K3YX2#&e]nCTamc_Earum^=7h;„U"dx\9mX(q4lMu2IeC3gE3]^6%5%Y4Sr02S4Nr\Fns41m9&Cz$mq^JlwpH^hhUSNx„U"cdUkn6s:Box$Hd0xAMFdJtM17uIY>H&MEb>QrpNbv3h):WtWev?fD<$ML1]PX].„U"f+D1*$fpb4AKa3XGb8C2+_BYra3)42fL%B=du^k;Yy6^\x>6673M&rZAkulrR;*„U")GM;du7[Cf;Cn7P?q48pa(p=WMDPf.kMjfx%%up&%'9%9%%%%-1%A[nXGqhh+pV„U"(%+%'3%%%0%%%%%%%%%&%E%%%%%%%%%f%uVWv%gVSg%fxup%&'9%%9%%%#-%.L#„U"nG5n%oTI,.%%(C%%%0%%%%%%%%%&%%E%%%%+)%%%fuVW%vgWS%gfxu%p&'9%%9%„U"%[%-%?#&oGs$%h7'%,%%N%E%%0%%%%%%%%%&%%E%%%%x0%%%fuV%WvgX%Sgfx%u„U"p&'%9%9%%%%-%+:8nGBOo3q%l2%%&>D%%%/%%%%%%%%%&%E%%%%O8%%%wj%firj„U".Sy'y%up*+%%%%%%)%)%'\%%%&hE%%%%%„END SUB„CLOSE:IF S=152AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Petter Holmberg                ABSOLUTE ASSEMBLY V2.0         petter.holmberg@usa.net        06-17-97 (11:12)       QB, QBasic, PDS        597  21920    ABSASM2.BAS ' -------------------------------------------------------------------------- '„' Absolute Assembly 2.0 by Petter Holmberg, -97.                             '„'                                                                            '„' Since the release of Absolute Assembly 1.1beta, I've had some ideas for    '„' new program features. Also, a friend of mine who recently started learning '„' Assembler have given me a couple of bug reports and suggestions. So I made '„' this new version for all of you who found Absolute Assembly 1.1 useful.    '„' For those of you who haven't used AbsAsm 1.1, here's what it does:         '„'                                                                            '„' This program will let you choose a text file with Assembly source code,    '„' a destination file name and a string variable name. The result will be a   '„' set of commented BASIC string declaration lines in the destination file,   '„' ready to be executed with CALL ABSOLUTE.                                   '„' For example, you have a text file looking like this:                       '„'                                                                            '„' ; A Useless Program example                                                '„'                                                                            '„'           XOR AX, AX    ; Set AX to 0                                      '„' Loopinit:                                                                  '„'           MOV CX, 4     ; Prepare for a loop                               '„' Increase: INC AX        ; Incease AX by 1                                  '„'           LOOP Increase ; Loop 8 times                                     '„'           CMP AX, 8     ; Is AX 8?                                         '„'           JNZ Loopinit  ; No. Go back to Loopinit                          '„'           RETF          ; Back to BASIC                                    '„'                                                                            '„' Run it through this program and you will get these lines moved into a      '„' selected BASIC program:                                                    '„'                                                                            '„' asm$ = ""                                                                  '„' asm$ = asm$ + CHR$(&H31) + CHR$(&HC0)            ' XOR AX,AX               '„' asm$ = asm$ + CHR$(&HB9) + CHR$(&H4) + CHR$(&H0) ' Loopinit: MOV CX,0004   '„' asm$ = asm$ + CHR$(&H40)                         ' Increase: INC AX        '„' asm$ = asm$ + CHR$(&HE2) + CHR$(&HFD)            ' LOOP Increase           '„' asm$ = asm$ + CHR$(&H3D) + CHR$(&H8) + CHR$(&H0) ' CMP AX,0008             '„' asm$ = asm$ + CHR$(&H75) + CHR$(&HF5)            ' JNZ Loopinit            '„' asm$ = asm$ + CHR$(&HCB)                         ' RETF                    '„'                                                                            '„' Absolute Assembly takes use of DEBUG, the program shipped with MS-DOS.     '„' DEBUG only supports 8088/8086 instructions, but it's still a good tool for '„' getting machine language out of Assembly instructions.                     '„'                                                                            '„' News:                                                                      '„' * Support for blank lines and lines with just comments or lables.          '„' * Support for double Assembly commands, like REP STOSB.                    '„' * Option to automatically add CALL ABSOLUTE lines to output file.          '„' * All Assembly source lines printed to BASIC file in the same column.      '„' * Option to merge lines directly into a BASIC file.                        '„' * Auto-detection of QuickBASIC binary files to ensure safe merging.        '„' * A better handling of errors and bugs in the sourcefile.                  '„'                                                                            '„' Notes:                                                                     '„'   Comments must start with a semicolon, (;).                               '„'   The maximum number of labels are 256. You shouldn't need half as much.   '„'   The maximum number of letters for a label are 16. It's easy to change    '„'   the program to accept a larger number, but it's probably not necessary.  '„'   A line label must be immediately followed by a colon, (:). Do NOT use a  '„'   colon after the label name in jump-instructions.                         '„'   Never use Assembly opcodes, numbers or single letters as labels.         '„'   Do not name labels so that the name includes the letters REP, REPE or    '„'   REPZ after each other, for example RepeatLoop:                           '„'   "Label:" and "label:" are processed as the same label.                   '„'   This program was made in QB45, but you should be able to run it in       '„'   QBASIC, PDS, VBDOS and PB as well.                                       '„'   If the program locks up, it's probably while running DEBUG. If this      '„'   happens; reboot your computer and check your source code for lines with  '„'   other things than Assembly instrucions, comments, labels or spaces.      '„'   I haven't really tested this program for bugs, so please be patient with '„'   me. :)                                                                   '„'   You may use this program freely; distribute it, modify it, learn from it '„'   or erase it from your hard drive. ;) Just be sure to credit me in the    '„'   programs where you have used Absolute Assembly for some of the code.     '„'   That is, if your program isn't used for illegal business like            '„'   destroying secret military computer networks. Then you can take all the  '„'   credits yourself. ;) Please also mail me and tell me about the programs  '„'   where you have had use for Absolute Assembly!                            '„'   Any comments/suggestions can be sent to: petter.holmberg@usa.net         '„'   The source code is still crappy and not very much commented, but I wrote '„'   this in just a couple of hours. The whole program is basically a very    '„'   large and complex string handler - in fact, the most advanced I've ever  '„'   written! Maybe I'll add some more functions later...                     '„'   Enjoy the program and have fun! Petter Holmberg, Sweden.                 '„' -------------------------------------------------------------------------- '„„ON ERROR GOTO ErrorHandler„„' -------------------------------------------------------------------------- '„' Declaration of constants and arrays:                                       '„' -------------------------------------------------------------------------- '„„CONST rundebug$ = "C:\DOS\DEBUG.EXE" ' Change this if you have DEBUG on„				     ' another location.„CONST tempfile1$ = "TEMPFIL1.TXT"    ' Change this if the filename already„				     ' is in use.„CONST tempfile2$ = "TEMPFIL2.TXT"    ' Change this if the filename already„				     ' is in use.„CONST tempfile3$ = "TEMPFIL3.TXT"    ' Change this if the filename already„				     ' is in use.„CONST tempfile4$ = "TEMPFIL4.TXT"    ' Change this if the filename already„				     ' is in use.„CONST errorfile$ = "ERRORS.TXT"      ' Change this if the filename already„				     ' is in use.„„TYPE labeltype                       ' Usertype for storing of labels.„  labelname AS STRING * 16           ' Change this if you want longer labels.„  labelpos AS STRING * 4„  labelnum AS INTEGER„END TYPE„„DIM label(1 TO 256) AS labeltype     ' Array for storing of labels.„„Start:„„numlabels% = 0                       ' Label counter.„linecounter% = 1                     ' Line counter.„errorcounter% = 0                    ' Error counter.„„' -------------------------------------------------------------------------- '„' Ask for settings:                                                          '„' -------------------------------------------------------------------------- '„„CLS„„PRINT "Absolute Assembly 2.0 by Petter Holmberg, -97."„PRINT„„INPUT "Assembly source text file      : ", sourcefilename$„INPUT "BASIC destination file         : ", destfilename$„INPUT "Name of code string            : ", codestring$„„codestring$ = LTRIM$(RTRIM$(codestring$))„IF codestring$ = "" THEN codestring$ = "asm$"„IF RIGHT$(codestring$, 1) <> "$" THEN codestring$ = codestring$ + "$"„„PRINT "Append to destfile? (y/n)      : ";„„DO„   kbd$ = INKEY$„   IF LCASE$(kbd$) = "n" THEN writemethod% = 0„   IF LCASE$(kbd$) = "y" THEN writemethod% = 1„LOOP UNTIL LCASE$(kbd$) = "n" OR LCASE$(kbd$) = "y"„„PRINT LCASE$(kbd$)„„PRINT "Add CALL ABSOLUTE lines? (y/n) : ";„„DO„   kbd$ = INKEY$„   IF LCASE$(kbd$) = "n" THEN callabs% = 0„   IF LCASE$(kbd$) = "y" THEN callabs% = 1„LOOP UNTIL LCASE$(kbd$) = "n" OR LCASE$(kbd$) = "y"„„PRINT LCASE$(kbd$)„„PRINT„„' -------------------------------------------------------------------------- '„' Warn the user if the BASIC destination file is a QuickBASIC binary file:   '„' -------------------------------------------------------------------------- '„„IF writemethod% = 1 THEN„ DIM readstring AS STRING * 3„„ OPEN destfilename$ FOR BINARY AS #1„ GET #1, , readstring„„ IF readstring = CHR$(252) + CHR$(0) + CHR$(1) THEN„  PRINT "BASIC destination file is probably a QuickBASIC binary file"„  PRINT "Continue anyway? (y/n)         : "„ „  DO„     kbd$ = INKEY$„     IF UCASE$(kbd$) = "N" THEN END„  LOOP UNTIL UCASE$(kbd$) = "Y"„ END IF„ „ CLOSE #1„END IF„„' -------------------------------------------------------------------------- '„' Get rid of blank lines, comments and double instructions in sourcefile:    '„' -------------------------------------------------------------------------- '„„conversiontime! = TIMER„„PRINT "Modifying source file..."„„OPEN sourcefilename$ FOR INPUT AS #1„OPEN tempfile1$ FOR OUTPUT AS #2„„DO„   LINE INPUT #1, readline$„„   sourceline$ = sourceline$ + UCASE$(readline$)„  „   IF INSTR(sourceline$, ";") THEN„    sourceline$ = LEFT$(sourceline$, INSTR(sourceline$, ";") - 1)„   END IF„„   sourceline$ = LTRIM$(RTRIM$(sourceline$))„„   IF INSTR(sourceline$, "REPE") THEN„    PRINT #2, LEFT$(sourceline$, INSTR(sourceline$, "REPE") + 2) + "Z"„    sourceline$ = RIGHT$(sourceline$, LEN(sourceline$) - INSTR(sourceline$, "REPE") - 3)„    sourceline$ = LTRIM$(RTRIM$(sourceline$))„   ELSEIF INSTR(sourceline$, "REPZ") THEN„    PRINT #2, LEFT$(sourceline$, INSTR(sourceline$, "REPZ") + 3)„    sourceline$ = RIGHT$(sourceline$, LEN(sourceline$) - INSTR(sourceline$, "REPZ") - 3)„    sourceline$ = LTRIM$(RTRIM$(sourceline$))„   ELSEIF INSTR(sourceline$, "REP") THEN„    PRINT #2, LEFT$(sourceline$, INSTR(sourceline$, "REP") + 2) + "Z"„    sourceline$ = RIGHT$(sourceline$, LEN(sourceline$) - INSTR(sourceline$, "REP") - 2)„    sourceline$ = LTRIM$(RTRIM$(sourceline$))„   END IF„„   IF RIGHT$(sourceline$, 1) <> ":" THEN„    IF LEN(sourceline$) > 0 THEN PRINT #2, sourceline$„    sourceline$ = ""„   END IF„„LOOP UNTIL EOF(1)„„CLOSE #2„CLOSE #1„„' -------------------------------------------------------------------------- '„' Insert DEBUG instructions and Assembly source code into tempfile and take  '„' care of lables:                                                            '„' -------------------------------------------------------------------------- '„„OPEN tempfile1$ FOR INPUT AS #1„OPEN tempfile2$ FOR OUTPUT AS #2„„DO„   LINE INPUT #1, sourceline$„„   IF INSTR(sourceline$, ":") THEN„    numlabels% = numlabels% + 1„    label(numlabels%).labelname = LEFT$(sourceline$, INSTR(sourceline$, ":") - 1)„    sourceline$ = MID$(sourceline$, INSTR(sourceline$, ":") + 1)„    label(numlabels%).labelnum = linecounter%„   END IF„„   sourceline$ = LTRIM$(RTRIM$(sourceline$))„   PRINT #2, sourceline$„„   linecounter% = linecounter% + 1„LOOP UNTIL EOF(1)„„CLOSE #2„CLOSE #1„„OPEN tempfile2$ FOR INPUT AS #1„OPEN tempfile3$ FOR OUTPUT AS #2„„PRINT #2, "a"„„DO„   LINE INPUT #1, sourceline$„„   FOR labelscan% = 1 TO numlabels%„      IF INSTR(sourceline$, LTRIM$(RTRIM$(label(labelscan%).labelname))) THEN„       sourceline$ = LEFT$(sourceline$, INSTR(sourceline$, LTRIM$(RTRIM$(label(labelscan%).labelname))) - 1) + "100"„      END IF„   NEXT labelscan%„„   PRINT #2, sourceline$„LOOP UNTIL EOF(1)„„CLOSE #1„„PRINT #2, ""„PRINT #2, "u 100, 100"„PRINT #2, "q"„„CLOSE #2„„' -------------------------------------------------------------------------- '„' Run DEBUG to find machine language code length in bytes and then update    '„' the tempfile with the correct byte length:                                 '„' All errors detected will be written to the file specified in errorfile$    '„' -------------------------------------------------------------------------- '„„PRINT "Detecting machine language code length..."„„SHELL rundebug$ + "<" + tempfile3$ + ">" + tempfile3$„„OPEN tempfile3$ FOR INPUT AS #1„OPEN errorfile$ FOR OUTPUT AS #2„„linecounter% = 0„„DO„   oldline$ = midline$„   midline$ = newline$„   LINE INPUT #1, newline$„   SEEK #1, SEEK(1) + 2„   IF INSTR(newline$, "^") THEN„    PRINT„    PRINT "Error in line"; RTRIM$(STR$(linecounter% - 1)); ":"„    PRINT midline$„    PRINT newline$„    PRINT #2, "Error in line"; RTRIM$(STR$(linecounter% - 1)); ":"„    PRINT #2, midline$„    PRINT #2, newline$„    errorcounter% = errorcounter% + 1„    linecounter% = linecounter% - 1„   END IF„   linecounter% = linecounter% + 1„LOOP UNTIL newline$ = "-u 100, 100"„„CLOSE #2„CLOSE #1„„IF errorcounter% > 0 THEN„ KILL tempfile1$„ KILL tempfile2$„ KILL tempfile3$„ KILL tempfile4$„ PRINT„ PRINT "Error(s) in source code detected. Look in "; errorfile$; " for information."„ END„END IF„„asmlength$ = MID$(oldline$, INSTR(oldline$, ":") + 1, 4)„„PRINT "Source code byte length detected."„„OPEN tempfile3$ FOR INPUT AS #1„OPEN tempfile4$ FOR OUTPUT AS #2„„SEEK #1, SEEK(1) + 5„„PRINT #2, "a"„„DO„   LINE INPUT #1, sourceline$„   SEEK #1, SEEK(1) + 2„   sourceline$ = RIGHT$(sourceline$, LEN(sourceline$) - 10)„   IF LEN(sourceline$) > 0 THEN PRINT #2, sourceline$„LOOP UNTIL sourceline$ = ""„„CLOSE #1„„PRINT #2, ""„PRINT #2, "u 100, "; asmlength$„PRINT #2, "q"„„CLOSE #2„„' -------------------------------------------------------------------------- '„' Run DEBUG again to create a full output file:                              '„' -------------------------------------------------------------------------- '„„SHELL rundebug$ + "<" + tempfile4$ + ">" + tempfile3$„„' -------------------------------------------------------------------------- '„' Scan through DEBUG output file to get the byte offsets for the lines with  '„' labels in the sourcefile:                                                  '„' -------------------------------------------------------------------------- '„„OPEN tempfile3$ FOR INPUT AS #1„„DO„   LINE INPUT #1, readline$„LOOP UNTIL INSTR(readline$, "-u 100,")„„SEEK #1, SEEK(1) + 2„„labelcounter% = 1„linecounter% = 1„„DO„   LINE INPUT #1, readline$„   IF label(labelcounter%).labelnum = linecounter% THEN„    label(labelcounter%).labelpos = MID$(readline$, 6, 4)„    labelcounter% = labelcounter% + 1„   END IF„   linecounter% = linecounter% + 1„LOOP UNTIL readline$ = "-q"„  „CLOSE #1„„' -------------------------------------------------------------------------- '„' Update tempfile with the correct byte offset numbers for lines with labels '„' in the sourcefile:                                                         '„' -------------------------------------------------------------------------- '„„OPEN tempfile2$ FOR INPUT AS #1„OPEN tempfile3$ FOR OUTPUT AS #2„„PRINT #2, "a"„„DO„   LINE INPUT #1, sourceline$„   FOR labelscan% = 1 TO numlabels%„      IF INSTR(sourceline$, LTRIM$(RTRIM$(label(labelscan%).labelname))) THEN„       sourceline$ = LEFT$(sourceline$, INSTR(sourceline$, LTRIM$(RTRIM$(label(labelscan%).labelname))) - 1) + label(labelscan%).labelpos„      END IF„   NEXT labelscan%„   PRINT #2, sourceline$„LOOP UNTIL EOF(1)„„CLOSE #1„„PRINT #2, ""„PRINT #2, "u 100, "; asmlength$„PRINT #2, "q"„„CLOSE #2„„PRINT "Label conversion completed."„„' -------------------------------------------------------------------------- '„' Make a final pass through DEBUG to create final output file:               '„' -------------------------------------------------------------------------- '„„SHELL rundebug$ + "<" + tempfile3$ + ">" + tempfile3$„„PRINT "DEBUG output file successfully created."„„' -------------------------------------------------------------------------- '„' Calculate the longest possible BASIC string declaration line               '„' -------------------------------------------------------------------------- '„„linecounter% = 1„longestline% = 0„maxsourcelength% = 0„maxcodelength% = 0„„OPEN tempfile3$ FOR INPUT AS #1„„DO„   LINE INPUT #1, readline$„LOOP UNTIL INSTR(readline$, "-u 100,")„„SEEK #1, SEEK(1) + 2„„DO„   LINE INPUT #1, readline$„„   linelength% = LEN(RTRIM$(MID$(readline$, 11, 14)))„„   IF linelength% >= longestline% THEN„    codelength% = 0„    FOR findcodelength% = 1 TO linelength% STEP 2„       IF MID$(RTRIM$(MID$(readline$, 11, 14)), findcodelength%, 1) = "0" THEN„	codelength% = codelength% + 1„       ELSE„	codelength% = codelength% + 2„       END IF„    NEXT findcodelength%„    IF maxsourcelength% < codelength% THEN maxsourcelength% = codelength%„    longestline% = linelength%„   END IF„„   linecounter% = linecounter + 1„LOOP UNTIL readline$ = "-q"„„maxcodelength% = LEN(codestring$) + 3 + LEN(codestring$) + (longestline% \ 2) * 11 + maxsourcelength%„„CLOSE #1„„' -------------------------------------------------------------------------- '„' Transform the source code to BASIC string declaration lines:               '„' -------------------------------------------------------------------------- '„„FOR modifylabels% = 1 TO numlabels%„   MID$(label(modifylabels%).labelname, 2, 16) = LCASE$(RIGHT$(label(modifylabels%).labelname, 15))„NEXT modifylabels%„„OPEN tempfile3$ FOR INPUT AS #1„OPEN tempfile1$ FOR INPUT AS #2„„IF writemethod% = 1 THEN„ OPEN destfilename$ FOR APPEND AS #3„ELSE„ OPEN destfilename$ FOR OUTPUT AS #3„END IF„„DO„   LINE INPUT #1, readline$„LOOP UNTIL INSTR(readline$, "-u 100,")„„SEEK #1, SEEK(1) + 2„„PRINT #3, ""„PRINT #3, "' ------ Created with Absolute Assembly 2.0 by Petter Holmberg, -97. ------- '"„PRINT #3, ""„„PRINT #3, codestring$ + " = " + CHR$(34) + CHR$(34)„„linecounter% = 1„labelcounter% = 1„„DO„   LINE INPUT #1, readline$„   readline$ = RTRIM$(readline$)„   IF NOT EOF(2) THEN LINE INPUT #2, sourceline$ ELSE sourceline$ = ""„„   IF readline$ <> "-q" THEN„„    sourcedata$ = RTRIM$(MID$(readline$, 11, 14))„    basicline$ = codestring$ + " = " + codestring$„„    FOR makebasicline% = 1 TO LEN(sourcedata$) STEP 2„       IF MID$(RTRIM$(MID$(readline$, 11, 14)), makebasicline%, 1) = "0" THEN„	basicline$ = basicline$ + " + CHR$(&H" + MID$(sourcedata$, makebasicline% + 1, 1) + ")"„       ELSE„	basicline$ = basicline$ + " + CHR$(&H" + MID$(sourcedata$, makebasicline%, 2) + ")"„       END IF„    NEXT makebasicline%„„    IF LEN(basicline$) < maxcodelength% THEN basicline$ = basicline$ + SPACE$(maxcodelength% - LEN(basicline$))„„    basicline$ = basicline$ + " ' "„„    IF label(labelcounter%).labelnum = linecounter% THEN„     basicline$ = basicline$ + RTRIM$(label(labelcounter%).labelname) + ": "„     labelcounter% = labelcounter% + 1„    END IF„„    asmline$ = (RIGHT$(readline$, (LEN(readline$) - 24)))„    IF INSTR(asmline$, CHR$(9)) THEN MID$(asmline$, INSTR(asmline$, CHR$(9))) = " "„    asmline$ = RTRIM$(asmline$)„    basicline$ = basicline$ + asmline$„„    FOR labelscan% = 1 TO numlabels%„       IF INSTR(sourceline$, UCASE$(RTRIM$(label(labelscan%).labelname))) AND INSTR(sourceline$, ":") = 0 THEN„	basicline$ = LEFT$(basicline$, LEN(basicline$) - 4)„	basicline$ = basicline$ + RTRIM$(label(labelscan%).labelname)„       END IF„    NEXT labelscan%„„    PRINT #3, basicline$„„   END IF„  „   linecounter% = linecounter% + 1„LOOP UNTIL readline$ = "-q"„„IF writemethod% = 1 THEN„ PRINT #3, ""„ PRINT #3, "offset% = VARPTR("; codestring$; ")"„ PRINT #3, "DEF SEG = VARSEG("; codestring$; ")"„ PRINT #3, "CALL ABSOLUTE(offset%)"„ PRINT #3, "DEF SEG"„END IF„„PRINT #3, ""„PRINT #3, "' ------ Created with Absolute Assembly 2.0 by Petter Holmberg, -97. ------- '"„„CLOSE #3„CLOSE #2„CLOSE #1„„PRINT "Source code successfully moved to BASIC destination file."„„KILL tempfile1$„KILL tempfile2$„KILL tempfile3$„KILL tempfile4$„„PRINT„PRINT "Time of conversion:"; TIMER - conversiontime!; "seconds."„PRINT„„PRINT "Convert another file? (y/n)    : ";„„DO„   kbd$ = INKEY$„   IF LCASE$(kbd$) = "n" THEN„    PRINT LCASE$(kbd$)„    END„   END IF„   IF LCASE$(kbd$) = "y" THEN„    PRINT LCASE$(kbd$)„    GOTO Start„   END IF„LOOP„„END„„' -------------------------------------------------------------------------- '„' Error handler:                                                             '„' -------------------------------------------------------------------------- '„„ErrorHandler:„„CLEAR„PRINT„PRINT "Whoops! An error occured during program execution."„PRINT "Check the spelling of your filenames and check the sourcefile for illegal lines."„PRINT„PRINT "Press any key to end program..."„DO: LOOP WHILE INKEY$ = ""„END„Denis Boyles                   CHANGE BORDER COLORS           FidoNet QUIK_BAS Echo          06-21-97 (20:32)       QB, QBasic, PDS        83   3501     ASMSUB.BAS  ' > write assembly language subroutines?  I've heard lots about them but„' > don't know where to begin. Thank You for your tolerance of the„„' Withing QB, there are really two ways of using an assembly language„' subroutine. The first is by assembling your function into an .OBJ file and„' then linking it into your program.„„' This requires the full Quick BASIC product however, and a suitable„' assembler. QBASIC lacks this functionality. The nice thing here is that you„' can build libraries out of similar .OBJ files. Instead of having several„' OBJ files, you'd have one library file. Which contains all the code of the„' OBJ files for you to link in. This allows one to make a communications„' library, or a special graphics library for you or others to use.„„' The second method, which does work with QBASIC, involves POKEing the„' routine directly into memory. Where you then CALL ABSOLUTE it with the„' desired parameters to invoke the routine.„„' The assembly code is listed as machine language instructions using a series„' of DATA statements. These are then READ and POKEd directly into a DIMed„' array for storage. Once within the array (memory) you can CALL ABSOLUTE it„' to use the function.„„' In fact, CALL ABSOLUTE is specially designed for just that purpose. You can„' be quite creative and accomplish things you might think impossible in„' QBASIC. (I have so far! :)„„' Finishing off, I leave you with an example program that uses the method just„' described. In it, a machine language subroutine is used to change the screen„' border color. The program itself is pretty straightforward, but the machine„' language is probably harder to understand.„„'SetBorder is an INTEGER array to store the machine language code.„'clr acts as a counter for the border colors.„„DIM SetBorder%(9): clr% = 1„„'READ/POKE the machine language into the array for later CALLing.„„DEF SEG = VARSEG(SetBorder%(0))„FOR ct% = 0 TO 16„  READ opcode%„  POKE ct%, opcode%„NEXT„„'Setup a TIMER handler and go into a loop. The loop keeps going until„'a key is pressed on the keyboard, then the program ends.„„ON TIMER(1) GOSUB SetColor: TIMER ON„WHILE INKEY$ = "": WEND„CALL absolute(0, 0)                    'restore to default "black" border„END„„'This is the TIMER handler which changes the border color every second. The„'change is done by calling the machine language subroutine.„„SetColor:„  CALL absolute(clr%, 0)„  clr% = (clr% + 1) AND &HF„  RETURN„„'Here, the DATA statements that comprise the machine language subroutine are„'listed. These are the actual binary opcodes that the CPU executes in order„'to do things. In this case, they change the screen border color.„„DATA &H55,&H89,&HE5,&HB8,&H01,&H10,&H8B,&H5E„DATA &H06,&H8A,&H3F,&HCD,&H10,&H5D,&HCA,&H02„DATA &H00„„'The above opcode values were derived from the following assembly source„'code:„„'SetBorder:„'   push    BP                         ;save BP register to the STACK„'   mov     BP,SP                      ;BP = SP so we can access STACK data„'„'   mov     AX,1001h                   ;AX = &H1001„'   mov     BX,[BP+6]                  ;BX = offset to clr%, passed on STACK„'   mov     BH,[BX]                    ;BH = clr%„'   int     10h                        ;BIOS VIDEO interrupt to change border„'„'   pop     BP                         ;load BP register back from STACK„'   retf    2                          ;FAR return to QBASIC. clear STACK„Andras Hoeffken                DEVELOPING ASSEMBLY ROUTINES   FidoNet QUIK_BAS Echo          07-01-97 (20:11)       QB, QBasic, PDS        253  16646    EXTASM.BAS  DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"EXTASM.ZIP",4^6:Z&=12218:?STRING$(50,177);„U"%up()%9%%%%-%%%RC>SS:ckJ*%%%p2%%%0%%%%fx%ryjx%ySgfLx\%<+x[m5]ws„U":x2ptwH'R*<5;(\$z.F)t;tP\>T*4>hWDPkFpdW8#hWP.p3qaWd3\jOYbrbH_bQ„U"Pb)>>#8-<Up79nbXha;k]D<]qQ[9^dtaWoo9gu]Ig'Ne.a3(%91,gH7\.1%%d)L„U"/'xrgl0sv'S0NEN3l7UQUAA=2;YW5mO.#KK,:_v$lqyXi<Y\Kf,_CP.:kFdO#-c„U"e&o,+7s[##9=1iD1M9)n(SFSSKB,M'NR-ca?q9b,=bh2$VD)$oK\+;o<.$a<Ft&„U"?,L,sY#a>vLXc,-K/.8/.4lbJTm?xsP.v#>P=<1DC(18ofj+z<'33sBn+8pO'=[„U"_-T>=Ff1acQqp9K,<qFWr?F<aR#X1^)O]&*=HG5:'9%M2)Ubt:IS(1w9*YX]9+F„U"\_'Fr-_;FfEaU<Xz/Gh,8E?ogNK0+&*H&U3oXS[6sj5+S*Clb&&EvGTBau&l&<N„U"U^4GB=Jm*aj7u$=cB*%F2(:o-C2=J\JMNe\H-h7%?o'Kv^&7_&,sh0j9TA1%H._„U"X7T;Hz8EOdJ*m.s$doD>OJK7D*:0[UKC:qZ1.VXl(##<+f)hTj#4L<jCJR%[hrJ„U"H*hfNc/;jC]U,wQW#$]]K]=&3E;DWOL<=nz6aUy.lP)gnrsEName(?oDSSKK:)%„U"Fy/h#rOk8G;tj06LM>>qKWoZ(-H<4h+xuN3v4>HNI#EE;Z334;ly=x%mRr>IjN+„U"cs_$HscALelHMc2UA8BkBoWiQ8VDUUrG\x^jmL1fE'd_dC=9XRcg#jc]5QPbj]V„U"mlpCM)RLp1lCw%JQ-#aoRAjsmv1d-cpK,^d(_t7$,X]S=;Zp3\w;YVa5^;Hw-/T„U"Y2i4j<dpZ\J=U<J3/g3ahy=4aOm8pMUPZKUbx+)xGN7-q(\C2vd<]\q3SwF)vIZ„U",tC=zHY9AhZYBXd$nZAG3L&*[-Mrnr1W,Q(%,TogoPGYCXz'S./+Hz$*t::nDg&„U"upBnfFC5BZq57/9_-V9<RjLTZ4<mfr69&#I0sc2$YINkg#kGS[j[.RMGwVLj3gO„U"Y%fSV^y?xhbtH5<)>Z?1A0Pm.#v%?dNdZo/KT&.&-SjGCi#K838joG,(#vG$v_h„U"AAEAI*MbD$/%-feDAp0DAd;dPAis<U[\T/jNBStuAmLAJi#92Tr;$*vC'9P7_.g„U"8S:8yYm;-&?N>dVaiT#:y/J>SG4of2YkG':lSr/'sB$j?Iq/h_m_/UCrih4tR6v„U"r?uFIIu>oinlvq=1\xFrce(pihNh;_%,aEXKtl+Bbf6nOotJ+WNT3Dqb5%RArcA„U"/CUPOCDjYMfBQkGm3#o4<,ma0ejc;Gi,aI_U$^QGv\0csx9TVF_w6K4&::ZkTkV„U"rdOGE\wXs:b[:H'x+LLP7P.FerVD1=ToXz0mqTi3o3oN8fp0xU/z3tjVmC^ZLVt„U"q(:t89b,[s-FxFq=AL&&4=bg9x<+v1MJYg=)/o_5_E9s\P+..ri:B%X4Ha%ME[V„U"uMk.hF(5twLLR&rehM?c:RFdTn*3gVzh=Yw-S6tllg$PZD5t43&=Bi3f($CF/bc„U"ca&Uvgg\l2USqaz//9aLMgmT/lF^Pl(5)OXA*rU)>nihZEKD'LkNN0$hVXO?^D/„U"dtcK=U&7z+%v3(d5eMIH?hKiLAsYy\nD9DwvT94,6]fSNibT=#)?bb)2HU1N$xm„U">-Ou7&?>W]<WZ*EXxwW5gCQr^iB]n5lHWf6:L-zQ\[z80*=]-eJUO%R8?uCDBi4„U"*881Fa7dd<cIeL$BpMJ(bQFJ(WB#uEWDUtjm+DsIxpxPn'rfwj]7$a$f(1%M)2j„U"K\5,k?ba[VB3l)i,w[:DgAA/5Ery.<.i;h3Tkh\>Czl^r>Vch&]y2Df\#d2A8=T„U"_&BZ=/_N%VfQ1V^\ab>I-Cxup%()9%%%%-%%%%C>Oi7B\'q*%%&^5%%%/%%%%fx„U"ry%xySfR][.'7vxT]L5M6U?x)P^XKZcr/].8mGU4._Bo_h*1ooFXIBC3*gs+3Da„U"LB5grrMq&.I$e2>ToZai<OtVuN0X0k)B+704aj(M$ha9)^[lu%bxGJ'Fgk*%MOz„U"F0qw_1m7SYLZji9RijzLx?NYiUQQWQ>jaLkKe''P*LD/3C;,tD:[ka^8csb.0bg„U"Ww?#0?hG+4,a;Fi;DkaKB2FRbmKg.tEg)]<V'QHXTD=h><>B.mui(cI8piu<*hP„U"T:c8lJ0+:4s2-bbNeAuvs;l0h]$DSZEH^<vM?MDKHog)IkI+v&7gG<W^&WhamB3„U"?:udvJiQ9hhg1]$/?/839j<ZgAY)QgMGfbWr2JA<hNp],YTNTZ^&T$%ofbmL[T&„U"*LDtQ$XSq(LJ2ru,>[c'vAs;m8bZ:ib11<kI)wxBMVPF(E#qg.tShy&-i=.Gt#p„U"tS.uR4r[d-Yh[Hx51j<up9?h;IIM3C,_?PnEux35qAO0py#oyI&8b\,05G_#(Dt„U"h2S0cMpYVbr'D)-5FWBB8]hqll:[*c'gd9FH/,Ve32*pVOWtk,h(wC4(VG+x_\O„U"l^2d0l/g4pU=1I:BOG>d8IN,/QB\IXT'tIBdkQDg\WF;UI6hA:]=U26F+HB'I]3„U"I\4e&7O0-yQoI.QdyG#YnQ<M*8%Mi#ZwJH\GiS&(?XVq$-Gc*sd;Rpw_$c_JJ=M„U"%XjiLRg%9F[[4s_5r[h(K5zMo%?l:)Hu0JrKKBwWFfM'8$L%mhm_K2T6zK[KA#:„U"u)R**KU_ZY/L)#(O*J2_e*&;Ry7k&1k&PV/[L*r2(R6KILtuI$0.yMAh\Bm)HuY„U"LjWuR4\3/[0-%q(JjS=0Pnu1N&O(esZ?p$>^3(oTHZ3%C5yJU?UJM3[)TjR03[3„U"T/gs3f#0F5M7vUarj*-ot3Z5D-Mt7;mT,w.gXWG8?Am3vkF$p#*QD-$U30fO:eC„U"-rKcsO$.#eJH#Dr;DAOMPCWmPhs\gK5g7A2u.qg3(_)nDPZcUH;h=P#(^YTXQo;„U"ldt?<BX&<H4gy>06Y&yGW+u/#/nDM1[I\kQ(08^^;\7b&An#hg[g'N?<;J3t;.d„U"&ls%I?8yDBBFT?DX7dIxSC6R,cakk^&V\(uWJ(p/2RJD*9DxW1&mbqpxGVk_*Sq„U"rG'_b2?PQ,]7zZ7uR2\8sb:uh7(1e<%83jj:\EstM4.J2Y.yOz41CE4978_K.+P„U"(#.Gy'V*D]Yb/l2pyF:aFi:Cj5dNi0dEP^M$Q1?:jKe&b>c6Wb#=T==F[>76DRy„U"mziNQp<4VKztL+e5x=',m67),a5[y36lm+H8?A*WAOJeo3\pSLfs<d/p<Z#OoX?„U"#kh;dvPNMoqlLXq>vxsE)dcal:ojm/L<KP2L+H'Y2=HUe7S&Ei-_V2)qlsZ2?Im„U"n0MV;zGT7l%$P&f+6x*-$7E=$*Oi5Cq^be9=B51>Dj'26N)ur$CgY^nEl&K0aq>„U"=bA'mR:.r\F80f-^OOV4$0:Sv:YmHOTpeMpm\,Om3RgU[S=g%$Sgi50d^'2EOYk„U":QUGX\\xfF&l-7kGes)g&/o6o]lOsVoWiVFS\)N$(\2yGFGPK<Ab;xxiKkg.7Co„U"%pPpN%G7NGS=W+$&/^>E79%V/(-Thz&oJUDv<,z(JoAqJ%q;_r)yEMDVd];ks8W„U"Wst\>bFW-d6xfImmCR2bEvkK8tg)y_2Xqrn;o&7ulQD\,sVqv?is3,'LJze#Gz7„U"5:3=0v\C_sp'M<yDP&sz=YB[$Cc&9Aib<ARnncE2MEXS4f3&0j$rgs2lBs(d(Z2„U"MqX(docAOf=29)eMFXhHV:6>7'XcEn,LL3XcY0e\\)b'wQ:v)tS$Sh1LNZNa-nX„U"rs%WV]VKrVu_G$8MUxQMOF1q$SqV_X(U7sgIk&vE4$r;c:-y6y3vZo,'Lc&n2XW„U"%2VXiJg;Ut7?Wf=7K6f##:O/<;>'v,up%()9%%%%-%%%%C>(vo^8%.'%%%t'%%%„U"/%%%%fxry%xySt#goZ$*H:8vs5#$6?0R?5#qFCI&w74:::,Syu0jI<a[4rMUZ(3„U"j+GS-n'l(FZ_tj)6I9jJW(TWE9[N^Q?kN9*IGZ-f9<LR>p/JWYLg6^-%-=RmD_K„U"U\<XUXhjHpI0q>1W)q):Lb-LEwYtO-Jsy2X9;S/hWqT8VEg(poXH6EB[VA?Ii<V„U"ax,wSW5e)of2FOILLFm:O%Mrw8yW,eW:2?C3L)rEIk:,h%V2QJUxwLAgpux>D5V„U">WaNFmchI_P$Ay^D$mtXq]#A,'?A4G7mDicT,(C&B0UMOAeLC3zT&Xf1Te5oh%>„U"lB^W3R_,Q$Rdu2P):7O7f13e3P7ZSWSE7'kw_fDktK,4^;$h<FQAu1_?mY#VoB?„U"qYl,AH']'GFi\WYE1G#Zc;ITH\-9nim2N__f+gx_dCUp\>$VmXs9klat8DxuLu(„U"r19):-co$oHr%p0^xq,yw[&2xdO28&^6Hr;oJXNi2F2+94#L-)02uF<K$-[]?H.„U"K'&&xZMK:lpMS8#3hJul;/d.lrY\ltCPFJ]9cn03H)PH*fxr;hQncj3bNS.%GIW„U"^P_Bn4>l0IM/>(x;PrmDeTNZ_:tl*Vdq\x)q7nFBk&q=Om?p-Clp2ApAF--5wSN„U"'3eMdZtQ4kuVZlDsBB&ebkAAU,3Pq:Tm[D+zw&u%p()9%%%%-%%%%C+>Qzc)*,*„U"%%%F/%%%0%%%%zxj%wyxy%Sqng3fe,q^9&9#NHlhl/,;'m[uo#C&V/zwDXqGL9I„U"+UBY+4VlQ+,*q91)]HC[K=FHRQYhk79Sb),wn80L=;[^wbc/S>#t1ACx:;awLY*„U"[rxNV17YSEd7g$3LbF66Gp7ZLfnKFgf6LF_uwHuGd^XZ2%%;%'<bEw:uQS+x#ep„U"l6D>Np*YJ)86jEM(V=;ef=]G&=0U=uo0jCGNw-w^b%tq6*Bi\bBdF#5Cf:t#-OM„U"]5T>EiI*J'6wTA-jQBg[PSr&Y;Vwh:>]_%dT7mF$iC8BNO65PE]-6P^pAnwFi='„U"u/UB-lUH;4c\V'R?T\v].9<'9ZfkEiH&S\DdBJIL:(&a,L%d=8F\=SI]Dr^^O=5„U"s,:R/Wwk0g0lb:81Wy:3*J#7v\emftw$j84h2SX_Tb%_i3J^$REKOIqiPW*3;8t„U"-k(-q5Edt7LyiTj%Brrce(fxO$Eq>XlmTUiV;Q;L)CMUceLl),u9\eE0;/)]Vpx„U"L$?9sQL$KB?/_[wXMQ6/-7;MIVlN<%);:rUqd6J06:XFLr6Sd(/g+*]=\aF#+\r„U"k2l72jA;gncdwvPzh3*#1eSs)#b-WDdePMQE<0UL+5xJY]s$82G$yp5RciJl-^Q„U"3Ga=,^C+%Swhzxh-aot;'^sqYSi#pg^>3qrz:riJ'3,iJsQ<Tt.(Z8f0:T9cwFI„U")7$\%l(d4HZh7#Xzju6rbD?IsuDi3w#Ag.)9Nl.mKD8ZgM&^l#k/a7U5k)E[,]K„U"s.pLi_-[l=pz&TX-L:-sQcj7g$gt>7f*6^q6_d9bgSJYS8ZihW/EJS\&$L_j*]8„U"XM4;,GXA=l6()xHXSq_0(:h?*UZ0MB8Z*<_R=E<8rlfK&Y,L%iN,,bO5KBGpkND„U"uZH95Q3&x7upxLKNJl9&Q+UsM5xN]eU<w3U]w'u8wSdynf27Kj/fjXCiDnv,iI'„U"XhiJ%<3Tt.Y)8-0T57c1IK)A$%[/pl;JXv8l)y:qY\r_rNLNl.0V8UdU&$OA:S=„U"L#-DVpo3J)iU9Tmf?P4LjB]*UOl#Vo\s2s&*Wt-'[zSKdNYwsh:I''D*%#O1LW^„U"gUC%Yg]14,q)m$B^t$AABk_9n6<h?PCUUqTdI.+;l3:hcZfosU[;3qWgkf&2NAP„U"Gs3WTTjUkb#VDV]XbL<z]cWHRaBKACfzeO,bL6d(zRZ$Ztwh\dk0?oONArU&4x0„U"9CJya&mf]/Jd;DlaSj3iOk9do:_ROZJJO-=;eg.>UCs,*IXW>/3GBRKUj=k#$:1„U"EDEF2Ctmbhb[^B1PrNe^l#*aC$/9h2:a5(y19qsezZQX=-D\L4E^$E.tUvT4?42„U"VfxNnj_3&9fw0?ghaAOS1C#65#YH1H]PKS/9K1'k5(xI8+n(1,A1)Yy#V?qTlEY„U"8t[_iMA?Fs^=Fl/*Y-1^#r]^0a&\VNl\#OS62c#<')L/Z;Xr$q_VYe^S2jiDbC^„U"\C8]UeC/5,GU:j=dGfgcgKM=$VVhqHybqj7W'=DO>#R5#6t^bqFgYZ?bD^Xb72(„U"$(rp?U)hK.xm>t3_$x/L'blLUB4v,q46GohFn<dG,9]2Z(bw=UdX8Rc(_IoX3eX„U"1Q8(?n>5[enFSRA=OTTJxHdG_Ec&:Il$8I1e?f4ZU#A,-oJ#$cEn6c7qQk+[.DO„U"A'Img^:%q682L%mML=;HS,qsN&;4M\Q,-r.x%cGBv$8uTuF-iZ.PwS$S0t6,Ihs„U"Cz6_Zelkm[RnTTN&<pJE>/:Q'.[MSO[M'L5co(2x%%up(%)9%%%%-%%[%C>g_1d„U"bE#4%%?%?%%0%%%%z%xjwy%xySvRqgfg2JKbzki#n5nHT*&ING%3]R;MOOp.1rZ„U".S&VfW'cKSurTcfDIjW2o_-[O\MhXbT1Wj.RzP*HE[SY(]MAf6*e;:=d/-M=1nE„U"/'%/9:(pVr#9eU9yo%QR$nk)i\Y6wSN<o^RYZXuGHNGBmBlGlmp<KFJ7c8_SQC/„U"BFQbnBG9gbPjZ#YI(Oj+gUB'[AI#;hZEl[qm2kHpA/sC2H'8glMT5_O;j/^H>Eh„U"+EVmT8A-r91^]kkjgAH]dW'iBJq3h[.qh5F8^FrmFV+)x(j%Gs0]N3R9kA+&7.G„U"(Ge>GLA^n3-2AOqE#F'?k5^F^Fr7m*+)D(X]$qv_.A,BA+IkW5Y5kX5Z5G^mFV;„U"$rAn&3->j#SE8WYo>*_HBAY3^;ATk45kFm.FwQyOGD_IW=P1$8.EHEFBAK3a#k?„U"ka;+<rI%^OKGQuLA[/>kG1Ff_P&WMs;^8_NADC3[A:Dq>A$d$nAA3I.h,]%6wmF„U"3[*mRCfj,1.[:0Wk]FARm-h:Ku;?']9WrLoTJ__6_HAQ$AZA(O+jC>UVi]%WDNl„U"Gucw0(+A\Wa,Bk_aG$Y43Z<0\uux$xTwx,3D8TNa0n$WaIWutm'lD=_;7kIf4]w„U"IJm3'WZhO>w<qI4TlN?zy&Q0WF%URl1aVs+U(qtI\M$b#60_E34-Nx?v*b9xFFY„U"rhOPDx*];-coDU\T:h(Yxt);>IgE$rMshW^0uIn/OIRnpZ-3lf,ic,JyZseq]yN„U"$jyhHNYF:hjlI2v%*j\lUM?vDK,\hWT.>TzRS2T,H&yR'sT_w=Jln^Oj,;9?/_c„U"]+)Q4jzO8#QYbjDi,a3)]F=gTF)(6%pmre%ynEN_K#vKcB%LFhcDMDE'+k'ufV7„U";XiIXn9*7mKL,\f6($Pz/'CU'?7LJI<Apl5,w77U(s/ggW<_UHmwb8WO\%e-$_X„U"nrq.3_<:D4_gRYX<y(:BBw\zlzhbgc$hWp,_ho29FE)t:^W_]zR$2Mch0-JE1,E„U"%6(t/p%E\\m/=H4*52&cXr3dSt3\GjwCIhV?vjYNcj/b)5h>w2Lvr^Rmo2m\j#k„U".Rwu>MY(Tu3<&vjfNwj(6PFQ:,QosIJTf1PAGVDbruN\?X:/wIyL-%0lK)xwB02„U"?e\SI?S)CB]Kfd\$:?k3f<S1y<C,>9wCdr;.r$CL&EE3SWGsbxLZ#BjY0W9wD[a„U"a.V?ANQ0Q/jLW5Q5%]].mB.aV7VB6$huo>0R%&j62VD?R4q?]7Iu0T[:Bt9GqYh„U"<lMn_Av8QtTb4:o;D0xk4h5+,fVj$9$L>iwaI%3B^BcaLAHWVmab$o<t5c$Q:rt„U"Lagep0K&3>TP_28,vQy#_323,wBKUHm+>yKv(XiNLF9/MoptMUk:\[U[6dAGv6>„U"v1Iz%^bMIRt8n;9H7BYCk^h&g=mP,\jo7?Xdj6\^3'hN4rB9wxvnK1uvc3-(l<=„U"]7uR-[MskNc\DtL;YJorL]N8)hhp7#26]H59T%9$iNMt2h4p?QCNxWh89[A1[*:„U"9jkdd+E\O8:zjIsRWaS^p:*:IknP*((AkL%,gEf#<sCbq]JnAn$UPr_Do[:hFr;„U"Ug;e2JP:S0\p9Q5sy-D')'YC>^EsJYAN#;^X125:G*B<QZ<W?X*=/9'5MRrrjVD„U"D;>Ma'g$KiMvTkWcZ(*U<J;8WRa$;qCDc9ZKIL)N>54#.$ssD'RHC#uKonhWJEX„U"<g-<PII<U/$-#^656U3/8%sQY'lBCJf/UCnF]vd16[lkSwN?tHb12juKlF9n]S3„U"mdcDvRFQ.^nK4TSTwu;2Ntl8b_p<5Jws30=_CdV0GX6.u4vD$kNT(Rs/Wzn2l:&„U"n;yt-l#;A-tH#t)%H&'ndDe-4pCvIv/gFs*B>[u<QBuEBT0;CzLrg9BfiKkQ+wx„U"af^#IQ+^^)2FqX;BruG&pxdvytq4G:LFuk0Z*p?zou*[ph[Y:85>+7]ITGRN.l<„U"lS60faqN8%=C$M(TR)]=MX'&ausV:ZBc\.>Oxjfa%0.hO<:;KRGxnn=fuY[r0gw„U"n938(1A1c_^O#?#0g$,iPV-E#8^T7LMYPmX.AKrsX(J5?pKEyeg+IaqcC(pESN\„U"Qb#cJ:Tj#>S*^Xe8B+G-:kKK^XeXjgn_Z-a785fK0'D*cc,V;r9O<b_#+3O6odx„U"k_LV4H0Pb*=b-h#g-Lt:6V%2b7,ZZnBc.zNa+#r?P#pV53l$eQ)-)X5q,bEuo3Y„U"w#HHi/EDN,X/==$#SSXB4lW*2P#PQBX1BHMdSq;tv:<#?w(lNcfcMOiabIa+m#W„U"nSZFnyrU3O^2B?e&/52],TrN'H'jbY_7Xh)HNA]QhH$NX0G4mbfT1HKDsRp1<FA„U"I/:1yRW^um>.'>25b$HH0A9G><C+;A(o?s,JJ8]'Dl+bl1IulsB5?,0u4b/G<#S„U"$N6B8PVvTX>8#nflEbElU\SXh4;N^mXDUP/fVLr)8]X\pPP0rdpU'-qUSNf0pjT„U"5t]ERuAf;,P6]n0bnkgqNkiR=dJHATW9iv-.jb$6f2PaU=,/wm<?V)n$oWr[+gr„U"pNP.pq%^;>7,E.eCOBiNp^=%ZHR.bGSd?.mA5pc;b:DVe(eAm]-NG7bnO5?0tl4„U"4ZFR^bbEu2et6WqS.0mUqPiE#pt7SMRemxj5W3b8h+Zs4pHC-ZxCKbX1Z.e\m>U„U"kNlWt6:;[1v,5<mX.o?[Y,qU2HL[cJ08sK+4,/-rn2TL1qADVrW3bsgseXO5K]I„U"#O7/IueZbG:sOh8-XLo-d'PDOv]=WQ2u'EO:GG8xy$.8yjUFA7'nqSuGm^D&FI7„U"te)#%e3bsYC6-\?J5?BJaevMV8G^V]_].a3lcbYkq$j'+kzB.s_C:oaEEP#DaoG„U"vk.RJ$,S_^ART:li..<Q3+Hl)UO7Jh)]D9IM7\];CwpvNuCecMcU%inGJB0wWT&„U"aqo1\caiB3<c3v]k-JR\caoB8+okMNBvsW[7HJl^MhtB.'oYN&(mnN[JKoCgNxo„U"=%qnZJ.;o9M8(qB7(oeww%pnBJ*ncYu9KmB/CoiM(+nBOo:Ac-u9KkBdju[s=1j„U"Xj7.4J-o8%xkIaJHw+)]a3o9Oxka[JTuk%GJ#N9RiBdOv+haLRc;t\3,J(Ov+ba„U"9PNrZaJ4MR+rBCoNWtsZka6cuR#J8t&3DJDOu+na7cosN7^eBl)cKq.-_d8oRMJ„U"8v']-Jl[N^kB3$cKf*B#osLuAaa%fosvBkJJ.+vkZJSvNrU\aFoGOwk.cA[w7u2„U"3[a0PcuhafhNh9M[ZWS)/mH_C)bBX^h=kmQAX[5'+p&iJ>oM.UAG+#<tzN_o5ZG„U"pUMp>G$?VpN$%4UXJL0-eG>?,R/Ov.BJi0%&Pex2#lFN4Y<;J)lEg]i-1/vyL6v„U"vXls+pYF5/hK_KL^aRWP3ht%2&Vu%N)U3NWO<%B5D3wqtIn4#lp)FdgQ[$u;pZt„U"rMbSbTGYn'l$wkhFa3lbmd%P&]ZIClpmgvfjR?wKMUDqIJsDvlJcW)[,v#tcT0#„U"9]?O>AC>h.W/:Z4rZA4jZu'u?xv.rfMrRfvFQ*ui*j1*4Z;;ddCUZPiaR3Rh^=K„U"+CIGoGt<Vu?xwkD6C7=Y=:\g.*.i1AK]dXT(,cCgLH*me&(B=ilGrPXe/q:PPb+„U"#5SP\GQd%PaGg6o[<s*>GD=.>:ipW2Urxf[6Z5w%'QCnT'8kR[BQ5Xz1=30h;QL„U"1EZD%KvpSP4jtj2L^i7*0Lt9=y'lW>lUMD+3tW[?=7P$jIm5>\0xvjqY#8.<XHa„U"XfCYy8fi1*EnENsjU8hK(R',5^E,?9Rz0iO=YN9YbjPJA8dW('M9pcx)6M0J=f<„U"SPqtEg0k'K#8/)NB>M:>aOi#8bwkTdbKY9'far9D6]-\v[nNDGLjPc9Dvt3^s/W„U"-YdJ7w\P($KECx#8NXXQF\gc4N,#sUo#UMP%CLdlR8di9&CSTjn#G8GWmK>K8nU„U"-_5nI#<jHXFu8:f,h376oGJ])=?H=DXu,$AWQ&E=cDf#db<E]%)bZ2/IFM8:,nn„U"15vX<k$nFXt_HM4C,GoOUtDFVx\3Yhth$<PAveVMid0W2ld#<2$p#ted2wpn=^o„U"Zh]0rid_nZnyMJwYXC,+8vOJ]N,c7kEtcZ+gD%%ig]B2fjJC='HNC$+P<Cz+n&M„U"8]WSquk<d9^n3':dEQP$c)gC6Z+D\n2)$q&*1]gw71r7v)6MsTRYL%xwnk/t=MS„U"r/D[I;+2I(KuFjnVTU-UUu=PaCnGo7tivC]ttgv3hgQSDy1qDLV\^8J1q>\A8wq„U"v3>CusBHZrVTlh6nAz-+l_]:3/1XJ0q4<=Cv[qrV&9M&)<8Xp1'NQ9lzccU3)7Z„U"aJui$</Sf]+*,E6x*;o'[tcm;Y_^GjDoyUOZ95T,\4eN#K;Ea47O):$(*Sh5y**„U"lC^->[/rRgT;*N''[R0o(PZOO/yqdZ&7VSW-H,z;fNy12u*FRYD9?h-200-cj9]„U"dY/'u/[a<FX;L'BDE(;czzSiP:+(y(zyJ,yYteHJ'(IOWddkcUWDjh2loR[Q-G:„U"A]3:L2Dz'MBE%([nF?l^PyoJLZ9y06/RH*1u:zOGx/$,FU45:0?*H:-^^M*1q9<„U"2psv6WJX^8xk6DD0u/2S)W._.i7P<GlK:[>bK,:bToGR&EZFg9FgLz)6r%26V_<„U"6[E_A*qVc.%uPuQMKA]VVvn^r-QNc/^<QEEg*e'?KlbA]y9l_]h.3T+ySkBg;Y(„U"JGp#-)CqzJf_LjFj2DH]3_IKx)R<\;QJ[8]T.])>Q*rIR((^WT=Y0k:9O^VCn&h„U"vnnh[i-=[TVPtqr.42%,*6-'T:Bq_tTNom9l.s<_P0W3%,tT+W7&tAM+V//l&lU„U"P^Z9P)W1F;?*LxBnSQ/q^:2<tq0:Rq;.RcK5v:9]ZZ;ITbkH'p>V:Vr?1Sdoi<L„U"A+h-Y[F^QyG=u'P26P[1N[;8p&Tn2*O9*RE,8DZ*h;9:n_m?Bo^WJa0Pt\L/5+>„U"p>Pl1Sq8;KZQa*FgATq.hFgM+-F2he\]^pVrpsnh9Vw'1<PqYdPDK/zk:*h4TG/„U"$jqV(N;%g&bh#0rJ5Xc%QZ?^i]qt&x->#,)08jOtd:-M*;'O>'Bu;f0=cp\F/1#„U"\08cSCP#NNPO_q:*g&Q4M-MMZ?z'$:Q)cl[jrJ4JG$'uDup%()9%%%%-%%%%C>R„U"U?n2&+%%%&^%%%%-%%%%fxry%Sgfy7prBQ[vmQG[RNSJap-U\'^'7/-SrMg(^hn„U"/5t>xj#e&*,2<W[Z%m]T#+K',y/r(2<o_Iba%I&n8Ux_1QAMFuD#fGuiAfP*7&K„U"FuM%l&nZuQ/M[(7-S%%up()%9%%%%-%>noiGUv3v?z.%%%8:%%%/%%%%wj%firj„U".Sy'yVD'h>]T]7vt=9x<;;P4_M'&fEHTWGZ*t/LsoPeS-$*ZPg0<:ci*T9IvpJx„U"1wWh>W_i-d;(1e*(GQ$#jh#\hSxH'gZH:hlNs00C^,NLbq\_Am?fhFuchNS=[<b„U"wM43U[,N=Xn.^Gr--%OoD4hAn;mxiQS/yucRcb2jc0up^zzBna3DdnCz#d&T'Oa„U"D$o5a[B6$ryh9wAMI?v,%Q'al2^R-z.SRyHZjE)%f3/&*ru?KGeS8accgz;o/;]„U"EcfH5AZD'C^RKddV2CAqOQDk#^G]hK.%5[]d54e44uNE-z?v'drkT-avF&NY'r2„U"SVnPIez=u6j_)#\t$PG<L^6I*A7Oqxh0C=u+smXkUYn&enfLtpX:TJYk.Dz>>G=„U"DdWF.8hP1Xu9ppWLOg?EZfX/Q*ws<2Nc]7XzdTVneZrj7qwN*;Yq\4^d#.=goir„U"P9W''DoaMm3jF*\y[nr)-*r#uLlW+$0''*ttGtfq%+OGpzuF?PrRVzC0]E<;Dz&„U"7k8%\Jh)K()Fp.kStzo:M=43EIfkA9<eor8BgC9$e>ECcb$x\_-kt(&8-8vo8,>„U"/A+ow2p)AEag_Yj5?ia>(^t7H)0x'>bUS\'^l1=Yt/[Gy]5>3%8wvrfP_lIz;A^„U",tLi1+M>'x8fQifb*qj8P4(-mgvzDB/GX%ZYJo95p[y'RhOU$jZi,J\N*VxOfEK„U"7^[3mU?J\*HMJj6c<1q,jbk2<_xra9N++]L_;i50t5#fU-8PcU'Kq(B],'xQdw2„U"6k6XAF-oMp=^)sd:>P^gHNzu4Te-zr4OhWpI(9XCv0qV*Qoo'/g<qUiM2+Co3uG„U"RGK/?^j5(JWNRw1&l.sc8l<CUHGj7RQgPT866[p[h.#Qc7da.6RRAR*?$RwR=]s„U"FY]+OX0Sp<Cn,Ak(ZpQO#r_Dgwm37PP=\#$yMX4\ZwVXgD$D%r'$Tp)Ji[ij7.j„END SUB„SUB V2„U"iT+bCh:0^h;/wsE4zA=;r4ru,V[55e&Fb4i.x?]Zit7wOB;bdx#]Dw;kYn%tcW/„U"NEb&0Pc*%8_d+CBohF&gL??]C,6o[-Y\-9%T%aCjDMRRNPGo$Xnt6TiaDWa&lf3„U"PDdHTDR8sj<8U(_NstfkLseji38IwY-$L8ZGx7MYRpm^Eh#lv/GnGQk(VFwOyL/„U"ft7PG<fI<_(0bJp/&,-61W$W:>,S,v,pO[.3EiN.pe/d_l\Y/zP%su_V#%IN9Wn„U"-/i'u#iZPueTG)/8IKe,33vp[_>wD(4P]MEYjxBDIGQ3BArY5z4):hp</fN0m0\„U"=Sa-Rnr4?d;ZPq(3oM-R'gu+\6Dro8::%<_[WR$&*5;gdl[I*A%+Z4q2NLCM8g4„U"Pjc8dqa:DaBnThvbv/j^;%;tl%DD3<uP/f7295daJh-Tcfplq;&\M+d&DB^4FDS„U",,ATJg.X,Y7$QhUe8ekJ=X)=a+N/Sid[THdN,yO-l#CJOf+#_9uUnE4X#NTR(cY„U"IT-aZa$H,M%fm7^fiOp:p7AlE;^^y;l*>5x:5LfnUbCa,W^W9,/F=aC/pJN.KBH„U"79>Ytwwc9OM*^rjb/KLuG&;L^;XXBVFYV<OHT<)aUE3Y->)6eZTZbKLm3Cj(WiK„U"qMvT1mmudTG89>Z+P]tR9mF;+Kur$%bs5D>/N7(_J]:$bTH)AHfh,=:,j9w'?>G„U"etNn#ChH8ezgdE[wN5yfIy=hLiw_f$e.2s>LH[fwR<%S2\dbGBUBq$Rl3Yp4RJf„U"/t6T71pHTNG..nnvJl^'f/0mk(&u%98X'/tECI>QCLwWW2]J:=UGWRcOPYR0bDC„U"^.d$5n8</bW#FQrr$DY\M^AIBL0qJ2%R[^sHbi+I^9vDa7,y_bWCYUw]gQnz[/-„U"gku\cYG*d=8bE((^0;Jz771W_p<cq2D]t&>1D%rRkL^gB-+xkbCkGhZkN#k&rCi„U"uv\fcb4Q_235j1^5K>*ECmgO:Orpi$u0al8;k0n,',d?BS6M*l3\d5TeIlb&R^p„U"O-AWXFDr#rIt'3sP#)URU]I0.Uq+=]MM8AD*&El^l0:?(>F<Ai&z:2Yx_t])2L7„U"[[Te7P<b=hPc^tZKYk33wOOe(_$Yz.8+gUtxUUGW'76KB8Eze7A=#DILs>$FjxU„U"jY\LWlGtl-yOOqQ8EATKMDkR5.O15glQC=e/1V,wYWe1domj:_Ag2WM9dIE]Zf]„U"])>8Xm1>5r5Y//6C-1BqTEA.ALJ<tV.L1#BMCr2[cu1ZN:lpTeY*C,%q^Z;\^d$„U"V),WL#e'.BBu#ad<MuAzl:gyf\D>MgCygsNihD*aF]GmH<v\wjtNxln0r*,RW'8„U".Gu#8r#?^e_+WF)^=a7On'*O)GN:q>t[KIRco;E$9dGxV16$365AVgZ=67y??kf„U"xuT()RBsZuasBY9/y/Ae'CEHW_zTjZHd>c-kW,>oaXa&-Ydt\El[K0L)w)9X3II„U"CWn#=&Z\J,F60d*;n[^Pmu7dv,<I39K*25ef;td=eA0II[XziN0bEn$W&S4VH7+„U"1.xW.FKA<J,L6qN>ev'Y-Za:\u2_N-BUq;I_,'IwOgh;4()S15T3]VOEWC5A5:u„U"A)]?vUY>R/*>#S1(s_V;Fh.lUlJwS8On)*n#OVylZk;-/[>>8J2\m-YcAFjZtJZ„U"^6C/+RyO($-0mEcK%)ktCxue^c[QuAuCkFtH6Zu)qIVJL6)'%D6P9J$rB^-EJ&A„U"g:AvF?bn$Ucsim9A/dJ3n^JCm^b^VTsvbpmO*tRR+djX3x>y[bk1DLbAU>c45N$„U"/IVwm3[m?ZRgkJWMb$)+-j6PxYI/]TlN?rW73)2vCGo7Y<$AfNtE_I+EkZ,%-,9„U"I0jo6-=b1p(ZhdZ_55kI+^?C=f]L.UFT[+H-X0%VlGV5+jULcWRmBW=pNS7&iM-„U"n&X[4TjMPM6(n?s%r14rR8Y(C#+b>B2eUo-m)=_JoKxL:i*#?ETJ4%o;xM=xEpG„U"Y0gZ6R;%2<]G,/iwau6>JYh'u*\-\.j%qErp1kM,9I3J^XZ:CxUaEA=AR)$&]'B„U"D:uK%\]),Je%lnQ's?4rjNgo^UFb70R8BdK'S7<LoEIXnzj2[Fup.p2D>Bh-,\.„U"3'0AWC/:zu-M??#E++4W9UM7$$pVPFK0J_$rW^n4?;3at>4IEGYkg6^pCD]hR0J„U"rn+>iZUb+Cv4u%p&'9%%9%%%%-%%[%C>SeSckJ%*%%p%2%%0%%%%%%%%%&%%E%%„U"%%%%%%%fxr%yjxy%Sgfx%up&'%9%9%%%%-%%%%C>Oi7B\'q*%%&^5%%%/%%%%%%„U"%%%&%E%7%%s*%%%fx%ryxy%Sf][%up&'%9%9%%%%-%%%%C>(vo^8%.'%%%t'%%%„U"/%%%%%%%%%%%E%%%%?1%%%fx%ryxy%Stgo%up&'%9%9%%%%-%%%%C>BQzc*&,*%„U"%%F/%%%0%%%%%%%%%%%E%%%%p3%%%zx%jwyx%ySqn%gup&%'9%9%%%%-%%%%CO>„U"g1d+bE4%(%??%%%0%%%%%%%%%%%E[%%%J%8%%z%xjwy%xySv%qgup%&'9%%9%%%„U"%-%%%%C>U?3n2+%.%%^%%%%-%%%%%%%%%&%%E%%%'?H%%%fxry%Sgfy%up&'%9%„U"9%%%%-%7>niGZUvv?&z.%%%8:%%%/%%%%%%%%%&%E%%%%mI%%%wj%firj.Sy'y%„U"up*+%%%%%%,%,%&X&%%%#S%%%%%„END SUB„V2„CLOSE:IF S=27AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„The ABC Programmer             MODE 13H SCROLL LEFT/RIGHT     voxel@freenet.edmonton.ab.ca   07-16-97 (11:57)       ASM                    60   1046     SCROLL.ASM  ; mode 13h Smooth Scrolling Left/Right Pan Demo.„; Not as fast as using OUTs though„; CREDITS: Unknown Author(s)„„ .MODEL MEDIUM, BASIC„ .CODE„„PUBLIC ScrollLeft, ScrollRight„„ScrollLeft PROC„        push ax„        push ds„        push es„        push cx„        push si„        push di„        mov ax,0a000h„        mov ds,ax„        mov ax,0a000h„        mov es,ax„        mov cx,0fffeh„        mov si,1„        mov di,0„        cld„        rep movsb„        pop di„        pop si„        pop cx„        pop es„        pop ds„        pop ax„        ret„ScrollLeft ENDP„„ScrollRight PROC„        push ax„        push ds„        push es„        push cx„        push si„        push di„        mov ax,0a000h„        mov ds,ax„        mov ax,0a000h„        mov es,ax„        mov cx,0fffeh„        mov si,0fffch„        mov di,0fffeh„        std„        rep movsw„        pop di„        pop si„        pop cx„        pop es„        pop ds„        pop ax„        ret„ScrollRight ENDP„„END„Benjamin L. McGee              CAPTURE SCREEN & OUTPUT TO ASM FidoNet QUIK_BAS Echo          08-07-97 (00:16)       QB, QBasic, PDS        138  3596     SCRN2ASM.BASTYPE PointType„  Row AS INTEGER„  Col AS INTEGER„END TYPE„„DECLARE SUB SetScreenArea (UpperLeft AS ANY, LowerRight AS ANY)„DECLARE SUB Screen2ASM (FileName$, ProcName$, UpperLeft AS PointType, LowerRight AS PointType)„„' insert your screen drawing commands below„' sorry, this if for SREEN 0 ONLY!„ „SCREEN 0„CLS„ „FOR Count% = 1 TO 500„  PRINT "Hello World!";„NEXT Count%„ „DIM SHARED UpperLeft AS PointType„DIM SHARED LowerRight AS PointType„ „CALL SetScreenArea(UpperLeft, LowerRight)„CALL Screen2ASM("TEST.ASM", "TestScreen", UpperLeft, LowerRight)„„'SCREEN.BAS„'DECLARE SUB TestScreen ()„'CALL TestScreen„'END„„' split line„SUB Screen2ASM (FileName$, ProcName$, UpperLeft AS PointType, LowerRight AS PointType)„ „OutFile% = FREEFILE„ „OPEN FileName$ FOR OUTPUT AS OutFile%„ „PRINT #OutFile%, "; " + FileName$„PRINT #OutFile%, "; DECLARE SUB " + ProcName$ + " ()"„PRINT #OutFile%, "; " + TIME$„PRINT #OutFile%, "; " + DATE$„PRINT #OutFile%, "; assembles with the Arrowsoft Public Domain Assembler"„PRINT #OutFile%,„PRINT #OutFile%, "_BSS segment word public 'BSS'"„PRINT #OutFile%, "    ; not really necessary"„PRINT #OutFile%, "_BSS ends"„PRINT #OutFile%,„PRINT #OutFile%, "CONST segment word public 'DATA'"„PRINT #OutFile%, "    ; not really necessary"„PRINT #OutFile%, "CONST ends"„PRINT #OutFile%,„PRINT #OutFile%, "SCREEN_TEXT segment word public 'CODE'"„PRINT #OutFile%, "    DGROUP group CONST, _BSS"„PRINT #OutFile%, "    assume cs:SCREEN_TEXT, ds:DGROUP"„PRINT #OutFile%,„PRINT #OutFile%, ProcName$ + " proc far"„PRINT #OutFile%, "    public " + ProcName$„PRINT #OutFile%,„PRINT #OutFile%, "    push ds"„PRINT #OutFile%, "    mov ax, 0B800h"„PRINT #OutFile%, "    mov ds, ax"„PRINT #OutFile%,„ „DEF SEG = &HB800„ „FOR Row% = (UpperLeft.Row - 1) TO (LowerRight.Row - 1)„  PRINT #OutFile%,„  PRINT #OutFile%, ";   Row " + STR$(Row% + 1)„ „  StartOffset% = (Row% * 160) + ((UpperLeft.Col - 1) * 2)„  EndOffset% = StartOffset% + ((LowerRight.Col - UpperLeft.Col) * 2)„ „  FOR Offset% = StartOffset% TO EndOffset%„    PRINT #OutFile%, "    mov word ptr ds:[0";„    Offset$ = HEX$(Offset%)„    PRINT #OutFile%, Offset$ + "h], 0";„ „    Attribute% = PEEK(Offset%)„    Attribute$ = HEX$(Attribute%)„    IF LEN(Attribute$) < 2 THEN Attribute$ = "0" + Attribute$„    Offset% = Offset% + 1„    Character% = PEEK(Offset%)„    Character$ = HEX$(Character%)„ „    PRINT #OutFile%, Character$ + Attribute$ + "h"„  NEXT Offset%„ „NEXT Row%„ „DEF SEG„ „PRINT #OutFile%,„PRINT #OutFile%, "    pop ds"„PRINT #OutFile%, "    ret"„PRINT #OutFile%, ProcName$ + " endp"„PRINT #OutFile%, "SCREEN_TEXT ends"„PRINT #OutFile%, "end"„PRINT #OutFile%,„ „CLOSE OutFile%„ „END SUB„„SUB SetScreenArea (UpperLeft AS PointType, LowerRight AS PointType)„ „Row% = 1„Col% = 1„ „DO„  IF Row% > 25 THEN Row% = 25„  IF Row% < 1 THEN Row% = 1„  IF Col% > 80 THEN Col% = 80„  IF Col% < 1 THEN Col% = 1„ „  LOCATE Row%, Col%, 1„  SELECT CASE INKEY$„    CASE CHR$(0) + CHR$(72)   ' up arrow„      Row% = Row% - 1„    CASE CHR$(0) + CHR$(80)   ' down arrow„      Row% = Row% + 1„    CASE CHR$(0) + CHR$(75)   ' left arrow„      Col% = Col% - 1„    CASE CHR$(0) + CHR$(77)   ' right arrow„      Col% = Col% + 1„    CASE CHR$(13)„      CR% = CR% + 1„      IF CR% = 1 THEN„        UpperLeft.Col = Col%„        UpperLeft.Row = Row%„      ELSE„      IF CR% = 2 THEN„        LowerRight.Col = Col%„        LowerRight.Row = Row%„      END IF„      END IF„  END SELECT„LOOP UNTIL CR% >= 2„ „END SUB„