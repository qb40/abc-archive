Bradley Hartin                 MOVIE CATALOG                  FidoNet QUIK_BAS Echo          10-29-95 (00:41)       QB, QBasic, PDS        307  20245    MOVIE204.BAS'>>> Page 1 of MOVIE204.ZIP begins here. TYPE:BINAA TLEN:14829„DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"MOVIE204.ZIP",4^6:Z&=14829:?STRING$(50,177);„U"%up()%/%%%#%%]\JSB=e%gG*%%%%*%%%%.%%%%rt&%njS%nsnE%VE2/%up()%9%„U"'%.-%d%S,D>M)LwTI#%%\$%%%.%%%%rt&%njS#gfx[2(J>H906xdXe7<+Y_m]1k„U"tC^4'U*n5c6e-.$]ZI#LnZqoSEl4[c2]CBkd%KsSAm6;#vs*+UQ$<HS#C80-W;m„U"Rs^;&CtBM)5t7.(7cu[Rm=y.OaITQkNruGJuTq33in4'Pi4XLep,qb-&(8qVULf„U"RIXMh*ul=,F&jX.lnF6)x;^*m*,q;mN/P(h8vpK-U7]d=<]D.aA=:cw]tq-2_wb„U"W.cG^*2;dZ46HN70e6*o>WS);k5n8s[<W;hdTT*kuk<0&4dH*0emNvIjkYe#T6f„U"0G\7I8/UJgE*2B5G/bNv^&psyCchO&z]gKLdHkeNDITne&.t9wqX%SX,iXxB17t„U"e:4Hug$r^jYgvimn>D=teR>rj*mcERZ?,tWcBLk;q-k9TH'NcFnamz^I&.EnM(q„U"o?<>rzul[V^_V\;gP[NK-k*'sL20%?(Vd%251Jc;2Lw(gr$tiF)etxcF4*;aXD/„U"AB#2j)OR%5;o-H.[WV17<pWm(PgwuOOh+WSLP>Xr]u9a8.:cAa#h)sBqdR-$hUR„U"kg?dtI,pchHK_),l(XkU/\s;SA;*qvU*.[xflob.>/1&>R^/_:&':aRBAz0=W6v„U"_GpGY5hg;)dGQo6F*>#,u*FQ1e75[gMBp3)VGZmEl&^w_5A0/\U>8?.Uk$vwYHE„U"23GP_)eO\=0gA<UoJ2NX:t8z4?AzMIxz:e34r%Bd-3U1;tT_M:Xb=S\a$G2mr(9„U"-#u+ql=;9ES^:arkkQ=dBN.yzgaRTxHfL_X_A5'q52o;P_K;NW7tl+)k-jbqx=7„U"3=WN;1BLOJ>EU#>t>,?=<<(/T,iEl8Tlg>1c=jR4<)EIoAY3#$[.t)XSoERX-22„U"^(4Q51MhWC7IPj21)tRGQW5Q8k>QQD*E:;xC)%q)nqWa=(MFQIb#b=obc-Q.TY9„U"]AGp5O$&e&QI0oABSfBXm<gKa*t^wb/?=pMX*02JJi2/Bri\<vu&h#y7fE-(LOb„U"kg5iDxq7Vm>JZB5O^4J1]aXcdQndH.Z8k==>D_aDKDQ9hRZ)AqRyr+/GBsMLN8^„U"d&C/zom?CQ?WM$7-Acqo6bQ\o8:W%+ACF4Z(1X.JRWVFKyl]?LtT8Yk&rESL]?t„U"u#)Kq'[q.?p-T/'zpY9g-,6J59>h)a>R-BwmVu-c5%vhv^]h_\Qy(AL=]MIoGo?„U"lCv?OeYHS*r+7oV5<-U*FP2xzJoqdO=pMdK#czq5PsTa6qwkY2M5Il;HC$O53,s„U"rU]p^Ak1W4e.\d$RhDk->*VbVXM95m99Co*Lc^R;YZap.IZkjcZI_JN*VrGCQlq„U"8IlII1dk[2.9mcVU.DzHO4IidN>uGb[E$QHlljH?>5XY$s:6AXY^kk<sQKV(0&F„U"qPxPprA;=QHQl%3NgML?L14pQWImz,X^=ngNoSIHJ4HjmP.R8'F3HL'5=8dqQ/?„U":2w<D[uQ'1ih&nfOcnFWTnU+qvnec+G2>[(e<P(O)p=,KNxwM19j&8.fGot.B1j„U"M)d:'M?<w*%C??T)^F9(3]0XtI;S0\&[qBgCO_nvV=,r<Iw[#ane-UR+=ZYl&:B„U"Ts;7E:wm1:SPB2*W*\:YcJ]0Bx=4WS'jUcA4_=VD5p3.5:hSPQIzE+Tr3bz'JN0„U":I)Apw\EIE>g/xO9Mc_XJ0-ci+YtUE'lo2o0NIq.uV;BG<+-y?/2?z>?loYjYQk„U"96ONV[Po-ir:^RH9NZ1LyRDvj5HK0f5$LQAu=Q)U+RzPF3,uCKpELG2tYY8bQ%y„U"mgPiWHiY[mkXGV4zV=P<Y]4H_jie.=:qJ#.N\S1qzyGW]26W\,gOA#9U]>l08X)„U"uKQmBYE;o]M^Jx%j.^M4jBSl8WMdK^#ccQgi3yc/O+C)'XCHA\0n)M'AYpz(2qC„U"V?jc[wiAQuyaq7fS/I^pqT;Zk66F.X#m.<d=G>fIIKAw4'GMs[\F4k#On+PO.^5„U"<>TEF9BE&IO((fQlIqK&QfRRa<je<nv96\uXg\ejrUn#f\QHMLuf-R%7>:\];\h„U"#/wiAZbds=7dvu8%(g?#z*dck0%2?bW.oaGVnSqlSd53Zo'6z-BW<%7RtS;f<N+„U"/SZC'boz(_:bDnPsNgLr/S9n(pdL3M&2Wh5pd-Q7fR2<;t0^i;yFLAPwn=&ljow„U"DLk^LQOixF<W=08P6^adF9eck<W..DX8#kyh,1;W1C,^'HWDY.D=yAbmUCmYcPD„U"[m4cVVULslA+NOSw1OmG8#ZrZ6Hus#>4:Ef:/_T7+qYa:(JSt81O#v<KlKJN;86„U"Bqz[1]\pV'e47geqy1XSkBaImGP4,1,^>-?/q5^JW'N8F9CyVmOp)?Ct5K]H?;m„U"yFp39vFa'.CJ$'MG#1=L%C<3;y_QV<MfYbcR7sTtv82XW]#66Snq:9l7(=)sBP$„U"IsmR8LK:3B[TlILk/eYJef((kVO7&gOFUZnF;21QwcV5Kg:rfQva14=Bz/?&jYL„U"E;:dRg2pow\HupvZ=*#dbB_F[;S&J>23njCR_uKA4q0,EKYFnRDCbNbSvY[eK)j„U"<bcfY89;y&?d#BM:yPn=k(T0?Z$h9=HCRr.F5FEWg7$(*RLeQnY\mBIUoKv=Cw*„U"lK2p-Mm3f16vdD_MlNKl8D#b5n_)5h^nPuOh&l(A>sb065kXbKM6^JDRVt,#ylb„U"-XKXc)#c#<mjb3GU-[txi5dF2hf8XR8afqce$xE+wm2k_tHOZTRk3*'jOe&d=ur„U"ZOd9:h&qtL&WMDNR9suihXx3,X_MEUAKVQk\38_'7Y>o:=Yqoh:ooJqf8b#8ht(„U"d#0S3jQg\lDklWZ6OZzp#uW;'.Y.B>=1S0rI?U?v7%*=sr*%%]jx0G:mG%h<Jb.„U"3kW_tFcL=j$E&v<Ajo/n.itg9e'<]H1rfuB4%h4;LJj'aV:P_NH$99D]U/\JIN'„U"Z/aTpO/jj%dxyNoQSm/&^[9,sFw8u8qd1CV]6I8owPuc*VEK(PgWFphzmoZBwXv„U"z$l>7sfRx1llF&,e9OS7^)J#w$W2L.aNgKN+SfT/J+m1D?o6.NjfW1neBPTncgu„U"IY/W'oj1)z^'RR+]lAM>_#JD1Vi]n#:X6f_WR?JDqbpc]ok,&y]_i^$k.wo$V8T„U"(tipp]xDE7'lXWg?UjFNoKXNj'_).[9Ww]Yt=bH1=SX5I(/VlMEd2+0fh>jb%.c„U"v+'-]rZ2q[;>#hTN\Y$B8]lhnwb;GQW6U*,CO)-V1YBgIfXiRY-E:H3L:_zW-XL„U"5$Ixoqn#8u_pPUsc:Ffgt=I.BO.q=XkebWQa9v#J^sxld\GZ<ljiGvBmRC.Q[mE„U"ACI[+cr<bPpQ\W;G+\o>WN.cn.(h2UB6CF^)O+L*co2RaT:=neZF:*=ZX>0;*p-„U"\RqY4Cex.YTl-ls,trrkZWVY7]ouRd$KM+mkt?j<Ih;\?a#U%1KlYZ.O(;:4uVs„U"Ehn\bl4t#xsz+jVY3M2L)T3MXhKI4X9#-c&kDL&AoaktMBN4nWe7al:D;AdOgDo„U"H7t,1gULs84Km<[0dN68ytb*X6o93QvDs$P4Up[==8VFuhO\0Y8*V5+cn/tM#_S„U"Yi>i$CcOJ.na<doqQ3O#i;bqeKvmdpCovIDf7Du+xgS%['EMR$7+$LDxB^ZrY1*„U"9mS;48GTkJ:bwD+MsgOKAHtUSa*((pxQ/m>b]^Z5.UeUaAF?IC]t&J0tZqP8q8I„U"y5'Y0$J;g9M/8b0.8w5qxot%Y-,1,GY^VX_P-gD%:Qir)e#iipXznpywrq7zDA_„U"LmuXsG_GVM4JCbsQ<Ns;$as%S8cuOZ?Cacc=C#d7*Ses#lXVrHiJx<LMYeF^Sb9„U"N%XgRe7qsfjN)u[7y2S9i**l7W0N]PhQ;EoM^thB/i0Z3;.p^#V[Ntl7<kXO(IS„U"b/VHIO(&_YS:$W-fi.d#OYwwWjsXZO'_4NVK;A^CoK)\axtUX4UJ(5>q\;\*I[D„U"cD]Qt;(_R=*k4&b)enkRa2[DKtdYM2OpaE[*7[[pLi\;uf%q5FpnNa#XoAXx=[A„U"0gkW(RnMc#YZ8nkl:2)+XEA\OgkZ[-Bl-?23h7\,U3ss6dp_.&05Xu*3qU)9Wl9„U"AFW4c-$BY-u2%#D-nKfrdsSqb[j)KkqqxIK*=-YbJ?IE]pY/Te:y/[1OFIv37gK„U"V=5llOZ[AB$>&-xo?<(bF+%71qenW,=?2jga/PD^Z+Pc$KD[j[,d,zEI=):Zz[;„U"f-M#H<+t5^zVBJ/(zllB,oZ:tCV%B>#4Y?H>m+b1cQ+-R=gN<qBVQ?*ls*t[o+E„U"oli>H9Tf)'W<=U*=_uy?ff>?ZxR-lx'(yUu(uMd)[onJ?3JW%k]2^^l\sm264-(„U")x[(/v<v2t)B:NB?rrqGRHH+Z\7riIxzScJYXW,>1nC0O0zj]ZySN.n%]07+)RY„U"8qxDRVZFDCDZwT0_zzIVf3;EB2uC[5K?%oW[z*m+DXxccNDY1;>wsAf^fhW3HGZ„U"*o=H3D=n&((^r^';RJ7A/K4u6Oz9&y,vSxx>4YvE2CrQ3?e9hg#zV'P8dfh0y_'„U"<N#oDb2Y3kt\R$ZO#Zb*4[xl2N0IXELpREp*VO+<*MJ7ugu*%:<&T'Nd]dD<#2G„U"&B*2\b'H]qA4p4d9hkZ1qc;<MGd*%7g.^.g9uGlqi^EiCD&k6#2-8t^U-quD]s,„U"mRb4xt.]m,+6aDfW<;5JYs=(Tk=#D/>-1?R*fGZD/7,)N$5)ZY6xjcWHZ6KbQKQ„U"6bNj5qOJ%NuoQBdEe>LJM=:imeztSu-NcCA*+guX7A2[5:0,L8PVj[=)B;\ujK+„U"$/gI8n'tv%(\>d?M?lZQsETH_aQYvUEIiCx_97NJl_VT'OLU,VGS(uOG4LCRdG0„U"hw<gDuTN6oSj(KA23GpUQ[8A_jFa_:5uC#'+Dl5MN+5C1%vl88u3=AdM#5k_1zI„U"?SxMM]]IW,&4YGg\gWQGj7jku,4-/cDC,p8$ERY>OazMaOKiVxzIZjBZti,8q\$„U"\\)s:sY#L;>=JQ%BjLGt2JjJ:OD\YU;xK35:d'%e(Z]lo<92Zw;'>qNOxV4e*#-„U"AtPMP8kLd)YuikL-+dGiOdQ+L+rZGwi+r/js_R%\Ir/7LeID.L>lIdI'RQWKk*5„U"xqACQC\pEJw-D+3hkWC&edQeB]/tTME2<A,FEuwb5Z0ihtOj^81)t$xg1V>gl&^„U"-/Jm7%Q?D;87]/9\fsSu]FsC&kY<EEd21n+pi8m=Ufn(\,%=t%LCaHIEf;;hBzf„U"Eif>V_0o4i#lg+Zp\svv[XE6o&(nY<]?'gRO<7$NC$1r)1615g9-<^VoD&eN*6Y„U"7*-7J<DK<]OD5XoKlOoiBsv^oy:NCU_TqL.6?c:TK8\UCzYJF[%,L.W7&SCM6ll„U"4tr>cb[3G]kWrAY86UmR&+:p622U?;oPiSrFKr/\aNO9qCGc9VUy<Kzt9#H=I=,„U"0d=82eta%on6(wBfq)((Gv)J?Nce4yQ?VJ,[9,LovG]Mg]RJhp3OUnAZF+*9R,8„U"q1,,G\-9S)USDlQ,JHt1_r.=4<e+/:0]lypv6JKo#79%<#E'LYmci3'eQ;gjQ*1„U"cXSSfle[c=V903U]jaiJi_l/?H4B38D$3t2Vf-2L/?uDf/PO6G0G]G8.1h2JeJg„U"u%M-(jypf\Rzsa=&R[hjzVN-O^>cBo?qsQIByN2J,[oW?bBcV,SJ7mQnW*?wR%w„U"?fFtzi#F+QSPSdTR(nieC^<l;'OFg+=^t%0j&%HFi^cLeh\zk=,d,Sqh=_/6cwd„U"W68dUL?&q,&Z801w$lo#>8,,x^,mW%9.iG\27Og)>W).wRA7v5>VmcJ&KMBy'dq„U"k$Db;Gx$yBR%O\Kg3c9dWdp*%FZa:VH;5nF'prDQ0GlRH;cv]]4-i\.gVVoF$B2„U"^H#/.6HV>M8;?]hP_1febhiVz[5dif*cGt=O#Pgbc5ZA51GO2sQiHrWOX3eq+Ac„U"'F?'^D*qe4W#VTU[.]67Bhsc.uQEhx,2^3MCQ,Z,eA':1_xM\:<l&oQG+gLE1=9„U"cNd439&M.x6feGmWZ]pAH6AC-PtT>z,g>>NTV[]6rXmqg56M5nEMw<\Bs1_3VQ;„U"^Mirc;7*9Uw]]j\X%s8o$,TjMe5lHv3nn?,n?ib3-n]>c?;Bf7M;)x8nUMn5^?H„U"ck&+h/?M.,j[mxW>Bi/srAg7]B2eA\yJzUN,rGm\coT$>wrLCqI.KldYn#aSyHj„U"so4u]_m8x6.m=WpU.__i2l'9y8I4S8t&BnLxP]]yc(A36yJrF.&:*-&#V86Bgl,„U"JV,hwaFnVgeW9O>5op*p971Q(j_8T01U'#B0N9i(,JH3opmrbJ#svju#I6;s6\u„U"iHEX%'.glU,1x%\W8ST:7P\S#gt5(=C.YO?%2]E,.%y'e5)80,R5m]uLK(hQ$q5„U"h&,0CJB&aB(f6#'<AZ]lSw%q1Zssj)>CiBYw9]b6)Lm'C'YRJ779DjbNBkikvEH„U"dq[_,.3eUa'pvdaw,REtc6\$_3#v1ShrN[<ScOh\QHNgVF+;uszU0[[u]El$JNj„U"_6o,3;AuV3U<a:j>)tS-hW3/R[$5-.Nf1;]klQ]s.Th]#]r#9noLx<xKh]c?e;n„U"vti9da5'3o,*\/FR^K'aGzCR-:_=JX_Y5g,N39E*.>)sD8Q#jOw7G<Wl+k0VG.C„U"bAf<J07Lc5)VQ?t^0E/=m[Dn_U>RkB]L7-St\D%'=?DmiB6F&]rt%?BbECleQ[u„U"cLhyt*E?R_U3JIdzlt(p6Fc9C=iqlN3P0>bDV/\(bc^Bh6_qBfbYjof(%H+nO(s„U"WL_o&?cD2O18GS&D&<*9VXj(b)0NKKcbYQ#>XZ9pf9x#U^V;U*PR#RXn;M)c63w„U"e\\;VNr(obB%J4?JNk4s:>t[g46>E33AUz7;P8*J'#.%e3?aut7Hli(Lk.[to9&„U"';)??inSHwH-;#=&9&g-g#M]Xw=Yp%a?f%v57<t*;#CgJFKgB&x3xlB-OKgu]$9„U")J&5=5H.Unh:K4;Dyd)AE,%7)PIn]lbCMqoXvnZHN+PNcF%wz_FX9AJUPwrN/RT„U"*R_'C#,QZ<9Tn[.sb5Zh(pcYEwF[<(Y5:(f[/kQSz#Y9N1'4E*G<I.UXNs1a#Q,„U"EiN]VjhE8DsKc?A4No'3)*=b7WHoW2rNXjq)S:kszYc&3rTi(U&^S,^Yw$70oUg„U")F=?\UHPK<dc*cUa'CXS05IBK8S%B#2EF[^I1%&Rp+-vK9sv^Y+?0hk-%gVZ2PF„U"MIoST,ZO)2g*j\Dz6**qTfo:<dNjgBDD]',]P?)eQ/F\XO(EIxgotri2olM0aN\„U"P4*g>-(/4NYKH<g]iCR;36#j7WTs=)-L;hKqlGb5M+&uy;CADG7M))+W':ErkK3„U"^+lP4GXRq#t5;Y&opG6SU6hyb*Nuvhc'6(0\#bX8<A&FE;.G9:o1cv,B^d7E<fp„U"IWx:tA'H+H&=g4rB_]?$r%*uhC8P4JV97Pod,14CTB$kg>AU]Q'O%aZWb:a&fAS„U"^pAa<ZV>U$qE0*\7,xCkrD7D5Q-Ig)hOBS_hMUH1Ig,(gO,O-KY.LsR^cN-el,\„U"L%aD2LMOhj5dp+)W1-'.'yi1#I0brx=XrQcr/]dYFfZG+'>mK0jVe^_jRb6NYL7„U"&ph#:EGaW6:jX%Th4\/0bP7G'7LX:k4lL+eN,do8URoRXS8;cAh%;]oF2,_T$p(„U"g7U_tkDlmP1r?soR\T>'/NBqaoS=*P-f)9nBj8X%lWnlaj4<P#*#A%<%&8owZ)_„U"pSV8DX<']#FvME5Ou8R/esd2DZ)Em%Stwc5rM1&+j8LTC^qHY#JYIa#byQr:Fde„U"_4lN-i=JtMv\D;vBZG7NW')*;erYyG4cZ)EmV&J6G5'U>Y*PYlk5mU)PdC#Hkrs„U")jafQdI*&D=J([E<AP:1=ApK#&[8kO'Pu1_BcB%4ugY=?O^9%ua?yI[MwKgQ?]M„U"7m-L/o#&4cMXPo'A.];atS&.>]<Fn167/Gi1QgJrf*KrnX>V#P^R]iM\Q8#n'A/„U"Opq.^T.[4&qg.KYlsbwb9i[gP$'W=)VCG9D121M9Xf$%SDQ3+XYxDv$?RX^*b^m„U"VcECNtV2Z0D.TbQHQE91G<p0[)BwrMogL6Xg0>]h?*[v7#JgFq=.pG/&yz2mPYK„U"hp#J_GG&[zjouO4&XsNZ?udanZ2-W;%[5.Fp'G+LdJo&2=k#<;)-9Vq2[2;=RL'„U"9Z(]t<<LOnwNND]$MW=Y=o*&0;O=:]cZ&9jST):##%+bkQ[\$=;^K=%*P$p_s&Q„U"kE&=a-^189uUUg3Paj*'ib-=L*,vtqhrRs'U?,[?W0i(lH*h.6THS6Rkm\Hp#kr„U"H23ewYqRa1JcQVb1%=MIj=>1L+DcgEAp\v5/d9[1)NW#brKA1hVx(3B*NDb+/&#„U"zTk3;(cb\Mbzd5(8VK]F2%dydn0%,5TcwY]VVI07(phtP(f#yGhQ?;pLO=F$j3'„U"J4-Fjvlx&d9MBWqO=e&3>4rsvX_a017p(_'LcZe,Jk1hx%G+%be1cQ&R'ffA(.C„U"\dtX[4F.TNC].O0)a].yuPXK8am&rMk(:9r=g8LGtst[;%pY$7Q82Wm??3fdIC'„U"Evc6UQ_VcFk-g<JFhiwE5QLjtTh7K:u80>29n#v)b_9Ysn1a+jAbF-x$5O&;.\[„U"5%/JnH+]-G+-0c]J2PCT*t2<62;3-jx:6uH3$18CdgNbSmKHiY&:j<3+b&FK?6;„U"G^rk:Y1Zx+8)$1P7/GMi5I;+kVR2Ec$nq:/Vkl;2jz)\=q)_Ij4_\A$Gby1#:TI„U"rJlnQ_Mdoz)m%5_GD8c05&OnsqGff5ke)=jZE^E]mj6IZSTFH,9?'c:a?J>iNUt„U"35UJzJuAC+k36)6Rx^jBA(R9>c;n9r%.)V'LI4+25'k9<>;HdlH]OG4<o)J&MiX„U"&,^w:>W5&7EufC;=]Aui+Bp9h77zj6QO.Qy$k;Y[-:AS=>GO[7Hwki\d3L\ZPag„U"b'(7+6lZtwpy_Eiyjbp'y5)]oyvUx(Q5IyTCrW)/,u:<OhNnwjUboU+Jf*_[BZ6„U":Zaib/g5N\%5/3$WBimbqBqujf9C:Dv:L\3u:F]?Gxos?ZHmIEx:lFSu/8Nl<Hy„U"ue)2MWi8ntrPSg?1nK-7iNIo00K\Eoz;g[fZ04amssS$<jFe*1BXQK%LV)>petA„U"UTv#qgAVH0sQqn+QAwrNIw[2_L$-&*ZW;9Zy-[:&P$lK_ND_U%(a)YJv>>hyREZ„U"tAbWkNQ3,b=b?>wIcZ,8rS0SlLfkXeoEj=-tA?]5h?Yet/W]Snpz;p+h\;V&+G'„U"?52'Nuho\V0>mog<^uVR]dC><d<%^9GWoH.$j6pf1^%]JycipdNreAhvA:FGbjG„U"yKOD^xv7h3#ZMEjb$';ldV=-lH7y+9H+PP#aEH:(6f1l?*aS(OJ$N%6fZz0u,NT„U"&^N4jE3vIEptWGf??&VwJk4D^]ka)XGnrn4ddF#K4DKM_[>%W]$3K8.BsXt*[cW„U"LpHd#oS=\;F<02a)x>JrMVn=%]MvMiju$TCJKK^w-KHjRB+Ucs]Q\8v<1h\4_>F„U"rEjD*,\Gq<qso*9'F_=<.<aEQ$)Zb6T=qZ2D1uHncrqb%#\LRj?6,B$ZWQ4VTH,„U"l&tRpsRtZZb9e5qhOe.BnW[r_L%/(Dw<D(foP>)87MiBIo+/QD%WDBrzb9rQkI8„U"40gONt>CI0b;1V\f6l3Gxfotr&c0uH;W-2>Fko-6wle9\>8JgDEfWFlVmtQcFus„U"a1hV$:1Gsm#8nv1#7N(-T7D$4#<QI)[qp(a^([>>#u-6=x=[Jqm-xRTkC]t/C<g„U"13;']TtZ3%)brCzbk+kbNjPh3ZKNQvCyj7BejyR;i+8JFtdpnT>uwUzt/8#.9_V„U"[oL(l7s&r_RJ<K>I-l.A7zt*x,;\*%>8dICZJjEiGk]'EeY.%?>awS88x*rA'-V„U"YWH\N>HR[V&Yc2-EkH\f+t^yZqor4Wq)=&Y2dM;kVn=zI54scY=?dKIN1jnk>bk„U"&uaBan;$'por*Cm'l<N\Quk#1b<(3f9MMxsHsu%n-+nu_/ErXs1FQ]md+rP5tro„U"WabCXvRXSb>GhO7<?]K?kJ?/F4fX5La=2K9kDvEutuX[0vQ+A;-\5<0%20)QbE3„U"f'&+Pj:STZ9kIC]mf';G[bWm>xaq\5(YBk5DX/h]^\Cc;qRrlKCv+uZx/$BuIj_„U"MLdraT9GvF]NR2a)f:&1bou[dDDc:-&xi6sb(wvsi7N4*Fg^hJABE9J&62X,Cz8„U"3[Im46f?#q9Xsxf#KO&<2eVLj[(uIq)RXJB9POM23M$l#xA(#K[#o7BH%pvb[6S„U"o,1:+JV5eu0ZvQpD,[f)-KGb+#Yz^'imk;gMX^G&b$aJ>knwFSu/QDo1p=&s%IM„U"Q2DNTpA3yLv<[m9LY)&Xb\mPoMfp^d-hN$[sB6pLD\.9s3K6PnDtLPU;u:C:Z\x„U"Xs_OX5pu?pv,(kJ^b6\&-Soti^2;&=/$nZ*W>ko0F$V]BZ9EnkAMcM]^bi.tL%g„U"#WVwud7T$qLas457gW,wAtX\<4+_tOuX*L70;VB7u>:1.3J-l<m,KtHn3U8.Gx*„U"Fl:zf-V.[_M4;uqgz/T&S3%*;(e+4L%%k((cfAAn#KEUb/G^6wu_VuEq:Q-<.*a„U"$uZQ?Z(&Brw)SZ5xi^\cvuO8JM2MMEugJ(AD$XK8h:wtO[;Ni>P*Q)N8G3Wg_Lx„U"*[v]Qam+4e$0P<v5_Et7ssJ1s\XCVv#mtQ4qeoUYFlZlR:'m)SFbQ?A&8?n_F%<„U"*<ST%vuVu<$6rDC6%PJ'ap\)8%:O9<JMr<onE*e+6Sd>]I7&#%7cK_W\W_NW+zj„U"R:u-Qev=HCrcRp];gD^*A>Jx'9QJ0a83.sL33DtK60mTlIQOgk)\Qx\sBBHe6S)„U"0W-A.vJ3PIzwc'FO2O[Sx+MpX&l4(j0q<.5KV[vNvM&9_[OgHYh9/Voty&jV:Bg„U"Wd$>,+kluHseR8g>%Y6-npgek(w:_(SfzSkjoELcZe,3M^#k6q?$efgJwK,a#BO„U"#2b)w:]BPVA:CeI'JYU(r%x$A]'18dabgEM3d8&'<LeLd[jM5ND,IvDHIevEJ9\„U"1nJ+z7s:K_Kt/4yJL<$wu0(UUIe'%yuO5nEX57L)/YlYu48S2?_4,80O'KK&C?^„U"d/HDnD1\z=GI-xk479lI3BHiG/S_X9%k^Jo.xUv)\%-^R8+oC?^\bWUiv6uC%LP„U":Hn7vJ'_$11CZZgJST-tPPj3>Go':.HQ>s7>hOnYqzb*5M4,iqsmK7T)-I<BuN?„U"?,mt;Dcwn?G*NNNonEU$fp&bj(etH<(Rgym_wk3p]p9_oxjsJ6x4IyJuAX]oS^%„U"V.qlyi)*oOzSpRMg%O6<O.szwpimvO5<mOV_QE\+Id[=\e^ZS<LuBBYm2AYf9o:„U"8+3Bnts;X=E0E,q.f/(m5LSGY^g,m.sOnC:16;'lpNjtbbuDe8j>Wge_0U.zGFC„U"p?PJu;=ne*kcjx9ojeR<QlZ+SOe9+F(/Q$]tw:4ZHu]QW'kLR1p=&MGH&o2F^/=„U"7;qpg$';hvwDT,onwJT6VKqkA)=-'Q=R/Ye)TN1aHUbqt7MD,Ec.BABOyAObGw^„U"L514;UMA2i5Z<lCdqg4#0Ir]S<3;Z6\t?U*8kk\FTt0]WfG?Zb^NRFeXHnae1vH„U"(M7T(O4W<8&EvAl/'fr/69H*OAgr3(DsD*6Rc?NcS<TeJeblQCflN=zeMcR(l*8„U"gRa?x<1)PTDOA3)3uz%E$>vAHT:NNa:zd/?LktCe4B$\L<Y5-r-dAT:d,Z0w.'S„U"[fhM^PIcq%hwXLwpIS/2b;.yf'w0up%()/%%%%%%;J:jC(O[)h%,%%%%,%%%%.%„U"%%.rt%n%jSni&'EYV%YE2/%up()%9%'%[-%z4&+D<L,V=I9I%%UK%%%.%%%%rt&„U"%njS[ifyFk,D]\=]+VLsux9N]&z4u.odI<ba;7L(9xKNu4UXx^H&fRKkh0j%qL+„U"X/799;JDeY3.ask-THKLXsmqX(k^b566awkQqNL1_]Pl3Ro(4xPnC[rnU&hRr'i„U":/*qV')nW(^FyftP]9k]Gt't;Lv2bguUQ0n[f)heJ0/_q$;kS2IQ5jgX;CH%%Mo„U"_E10.4yJ/x('jV,4E&O?H&EFIhj04Ld^(u3f.nlm]F[BG/5GIU,2DPUqhraI#3k„U"<7=:a[JrQ60F0NLFZTW*lJ8#,_Pt:S+c+T(V$&xpvOn/SFrYj&_vP<WPpjs66Do„U"gts#>95F3IqohA+%,8=$+/?5gY)s5rFtY'mk,_7Z*FrYSHshO5\0xi&0oLo+H56„U":Z;wbPnkDss>b6-,O]3>'8\>p[Qnr89fZfyQPV7mAFP4,JS#nG&Y2nBRFn&r]ES„U"Z?CKu[(zoj3Qa=Y.j:P)*'Z?C3xi?T,FLDF8#b&R_[3eT[V1rL+JC#c^D/XF(-8„U"(ObnmBk&#5k4GDx?Ba#>u7RcP<#IF>9#(euCp,_$K_(5bcjCWAkFm]AgQ=*Xh)[„U"'RULl_Ab;H=)kvPE1g?bDM*CM=qu?qFxL+'00'd8qu%-4]phjPb2P_SHx;Bn[uN„U"_2z$SP<,xR5n?#7r,i^H7-B'5[*/QWfat50xP/4r/8J0=[?^2m,U$WgKq&qTNwq„U"aQ]J6[C4G0;YGaGnl9o7N%vywN:LALidL:nUX[h:mZt3,#\ks=hGcBwGG:SqT]q„U"vnXWf)]dEM_Cnb4K;;87&[E^RMHS*7]AX1j5r[LBmd]?;HAM/7WH)A5F[Ii8+)g„END SUB„SUB V2„U"Jm2/h1^sOrU=^WPI:M;zXZSad9F=\](4/w<-;B'8LXch/2[r9v1]^wikiX3hU>P„U"ryGtmIIbjl,ZUf5me:SgR+,n+,R]6i<ZfJ^JOQSe*hOU^jG?xFW&s#(E$,dAN7L„U"O]QAX_S&:&D&_l<*b>=&;>GlFKV./D7N$#)_*qn2zhsG($Y'3'3(hELxs3(irc_„U"c3s<E#Bm'iP^uCu'Lftq%0?K1B\'0OU++,:,u)JJot15F0B9kPz/sOM$BJM]u^]„U"c5L5]9sdg/v37FhdwqgEE4Co9SU(s'CknQt5GvHbQ,C\/3*cuU-SLf[s^MG&]AE„U"IwXfEOjW8M]+?3uX*E]3uxbXp.Fg;mCZ4CIq=c*ga#j>#4C]uK,f]rIQ6m148D2„U"3UmnPtuTn6wIFtX5'AzHn\,JhY_grrpxow>QgadrGk34GvtO+EQzT;bD-jD^dNM„U"'Bc&_=t4p(Pa2?5mLa*FX2NsIgv_VW;'?4B,c*J7\,i3qgJ.+g--r8S68_95'\k„U"ZFu1Y1M8Bn%VbzD*u+u'>KMi[B\D*9>cj08>svcX[:uhXb/0zp]+m?D165?[^cF„U"YCB-HroAP[SrZk+RICu&EgskWc3A7gis1k;qBu%'-QJ8H?/^X<UC]+Ld?<pz,[,„U".:(UuAWAyl/7A(LFA9?2RyOQc.$rY0Fq78Xip[t57_U39J/R7n8?%d2Bl's/9Kz„U"jPS*R3ddR=q599A^CU0$ukHOU[d+,*Z[T#MtGOn=gC_v_iXLieE-0^&Ti^vPRKP„U"liYH:s6))ODIVpa0_YXd&#>,(vu+tfew?#Kw=F8P6Utdu/t$VcSeVw8mr(aHsFb„U"b(3klPB90LdL6z&/r[1HgIBo0aUGyDtN^yWT/Twrt4'dH2[KhN%KUxO%+p$i&TK„U"B\q5oFU$2Oe-%(MCL4$)f=l3F%Z$V1XakGq&XbcqF;L8.DD*SF%hO$V>8x-\xHw„U"kbPB)qF>HWa+4K\Zw09=$/(AA551+__6;*s1j;DVS]1,V%o97WJ4iyt2,^.%&P>„U"0jj/QAn^E?f.8f;aZ2HZ=m0cg?9R:CUK(X,M':Np?Ydp$2/Gx*cEO0Lge=$jXqm„U"#*V3J]N&2Hk9]qZNa5?Ie&7-5(bK2[SGhRP?X;^BoM3d0ENK^>Y%nyqeFqEC,Sa„U"/Ql</r5zjvv<?1-Do1y=g1Wc4%0l;:9t\>(/YGF6.SK%lkds7a%JDw2S-S^N<'-„U"*#wn&]=L^\pw:c23Rm*./'a4vgh^??IJqca7j)Yxoe0(rGPv=:m50SZI<Xe64gs„U"N_%=L(:+UJu)jr_;/Q'T3f%9uFGIoTs^aa0'BkfimDx.;pJM,n5av5;60_^mJEM„U"Bu.Gk/,Ru$-XB[4SzKTw=aJRw'WF(aGi_tI)Or&9p3#98vH0VOWrbj?1kBaY:G:„U"JD-2$3s$UXhhB;K,:Llp,Cr-g'A#;41(#&^HFN.?0fLyZv;LMY]RI*IU2J(nQ\o„U"^]N=AC:2'p4:f;jEC/r9'pL9l%)5F34quZH*,zt[=A&4-8S:FowIp1T]?Q$=6Vg„U"*L);.X??,>k-gD1?M+$Z>p%GPEjAok_^5;bdVSLpZwT;v+JaN$xUzi:8x/0&wqk„U".4oKf37Jhjs2T]aca+WGkNd<'Kw#/(<dK]x_N)l8^&Zmsh>9Dp+:ww>8J9XyQ?V„U"joNKgQ-g5Xe=;-qPur#,Sbj()m:CTUG1n*cMO,U0n3&4^BdSC'TqLw_98+<UbX.„U"kpCgIIl]ZRD+4FUMt>)$BG2_7x6q%AeoQlkliDk#?=O>B=sOdO9e#Pdp,u)U;iU„U"Ysp2-L$ngdd<rxl*Dz_]8e6CN</Z.1aMIT/Le56E;WCq=G#.Qxzud95q/%vMc&M„U"&9'2Pahq4)T?j0%oe:U:SbEg9%=v)ZwTIG1lPJ,E,W'qB\-KT4IOL3l/4I+Hh;9„U")D<,'>B;VXa>-,B>Q_I+>#hJPCxr%47w7w#=_s_^t,9[0+^4/4,=:YCnT9'+Q&W„U"T6N)bTJnLZ_Ua&5(_JM7;Kg%5fsGksqGY#tFQoNU&<ZM0rHQnF=-f9$/\/<+5T3„U"I+<i*r8Uf%xk:v-.SxbCk'QSZB6BmpdVZKrGh9^7RUun6)t<oP$LRa&)Y-6?;B:„U"$ar(TfLNsaDiLySlDKyMf36Yp\J^NMBH:5rx[0.?=>fJa+_fvm#tcTO:Q6u=sSv„U"b8OBrhU^_DrgFK2Uu5;2\,%ciS)6U*EhSb>:QAT[oHrXM%8t8N(Q^qHLwFs7:?T„U"3m7X3bQf;]Wd+YaNiNA&/240V2*:9v2RDXg*LJUlr[jLG#WxATBL5AoSJk&A6XE„U"Ee:-t;iXSaU;2?Bi<i)7&PJBfbv#Pp,BCAgL<%v>t88=CA*]7E\RJ>Lw&RTK]G?„U"Sjp*p,fccM%nviHiv&KoZ&N96W55i(Td/K,xqWMio7,T8fIpk<^oF\_(yTL&)/5„U"sRb?My>So5w5Y=z,H+ZtuXwjNUP2E1r\SX<-\)XOu$V.#j1B=jRY1f9Q;6C,T',„U"_s[AK*K2dJ;Lg<=sN$u=_k>Nl&9PS#vw5/4W?fa'C]2?tL$iG/=gS$3Opqb5l2,„U"%rn.jO.Or]WaQ11phvEN2o4(u1rdw0t)*TMP.K2A8Y=9kV&rV=]V\']jfu#v0F9„U"3l=P.(wnjfH[rU*)[P':0VSxIB;uC&Erju/A2M8LY1)XHs&WEH)*7GH[ZZAZ(rh„U"d0X3X5Br5aEClX(1L*o#A5?rMT[6_7^RNB8g9hMZCh:3n;G?n9NNUpQaia43<Bu„U"6amBRoZc,Mq1ar)bd:m:-jZ=gghpRhLUwl:[/]H$DVEJm/kJe:1BajFr_'yeXZE„U"1081oo]/ZTcq'G2remIC=\R^v*v$Hx-u/q3K?sEF-?_GROkv*IS#s)3s1z>,Hs6„U"9=KoY:LQTK(BO</D;XN(UB6/:#Mi2N(iUl8C7vEzFREH$?C^KW-s,D(8*+)w-D&„U"1R9]3p=9L+*afp$xJWCQ$s78eMu2qw*t_9'RnR<-X)l('Hml,RmXjr*'KHx(8W<„U"1:\]Za/(.deB)^S2iOF(ClHU,:)$Qs',Jd;C2(+5FH9QA3s7rXmjo/e8L[Rrw0)„U"3)xs8>(OTnI$Ba(L$mi3?6gKcIBe&mw;to7dnf+?74rR<tY:ROx79cp[TX&4^+Z„U"W'#96rbU2t[GxIO?(\,F9k,S//-ilcah;q',ImCfRkG-VWgH:7rf>p8nN#5?B-t„U"=[Z]tDrdBxl\.xt.N#aMOYj;SWFTP/$MS?A:'d&snc0%2W$s:)JBEIy>[GcC(cv„U"D+ArNBo;SQ3VMU1gZ$S#4rKv5^vi2bUv#v])djQ^0a%#rgl9M*r$$$.<aTHn>5B„U":u6>bPZt'Fq6)Jdb5/EK34/N5Q=7LDDqb2DaYu(DuSXtNZ;Itl;8Maa&%+c-tO'„U"zIRmZ[Y-AvZBsK\fLojoKJ\o+>9,_?._juVO*p,C$P<klJG2w>PDT#,$O.M\1\8„U");e2'RuvEqjy(ailj^BaqPkt8vDBP1U8UYQEvtUZJ-hbXh)3#A%h/C[_xKIQO[b„U".Wa4hF$)Bcoq229WsV:?g)u_mm5nSITH,>TI+Q9.&$_Mvu*-Y9<5d?,=n8tsFBv„U"+[)9VZICn/,JC[)>y[U9Q,+70.HFVQ/N&RirZRnIB6s,/[M[\r*S)Rzx$JghUq^„U"k/lP]fx.UKD'Dkt?wUhIY'bICLAMs:w_8PD5:9caRoXaLw'FMJ4/wKia<_Ed)bM„U"dCr<Wx$QJ\]hj+%PMPH2C$skbOL)x2<NS7iEH)-QPoR=^JJeMl^HgX1Q&h.8ErX„U"QB-1Fsr(=UG$eI9swe8U'JX5LOBpP:*Gyq/MOj=\S_$J/4&eQ%R*^GtOBgDbTYx„U"<+0/wLf/<\i>4wYs\n-lXCEtr(]g9O,1kE/t9%%BOb2,q$sU#SQP12-Phq(nK<0„U"'A_fekGSx[3VuuK29RifxW'x8EiDI)b6,[\dR:Z&$:dZ>Whimr.88O3%y/G9pb^„U"K1K9]^Y>:LqgddgUz/AkS28<CB'-8Q:CN\MUGi_*DlQuQHd%)#OdNYD.3yN1%j>„U"Wt/kTsB,CQ<:c<HCZE?*UD\rX=f9mb.E]wzZJoiX)9/S*EH<-M$:w[?dMtyr(J8„U"GPt^-CTXY;r</KU[,jR;C%5(49M;k,W1s9iFO]Tw=QAa%,SOS;1\mA&1n1;4=k/„U">Lk)3*o<?M.wIltot\&Bes;8bX3NcU$q[,t;*W?o,Y0hn#pG$<T_Wp/gV=Tdf9q„U"g[8gA1UBvs(gsq^HO0e[\<Y.J&\4\+cVF=nJ0o-1ub&O8p6#pCK?q$yL8#Ogb<c„U"I)YWXA8Lq$=S,/.R18wish4>,.S]Ql38$mtTTtLor?/NZ*v?F*TkU4ovB)jC[JU„U">#8ikn/&wm$?)Ic9L#=+-m%H./*&B7iZ-Z1kN_kHju&(;%DQmgZ[4h<EIerf*A2„U"oqnPL<$#(3Pqs2wOv>#lKcB)gjU]cmr=#e#vMGE]jBgH>9F:q(&jf*I:SaZaDVd„U"G8&HHN[&*cS'dBIe=mata<YORmAQ_4]AX=5s84+CU=nIYonYOac9%<2*-H#RRt4„U"p[=HCX'W4nA?I0;x'))nm7u>'EDO_*FVI247w69YGnMM.6#O2-kz8B/*F1#cRr=„U"o=1A&L%0H'a'l7quc55)6:;qR[ybOB]'X6dZq\].Pbddb73QJZi[j#A+QRr%MLU„U"_'DEfcHo&D0$OJ1^YDhc+%h2H[/iPNMhP,m:%WuNzN=_>A*\9'=0jRv[kP].002„U"*rK.zJFMM)fcWOV,rlAVBkfH)'tb=NA5*4[s5CFQJ?Dio\#H8Y(l;JFGm[+08xV„U"GnvUg\J1KL[knV*3?*/tT/>XoG#VNNlGcu02/J$i;c>?Nf[*;xXbnF^YQV6O^Xg„U"qCIu]t>[%$eKq'sNcpOx1gC6J#[;.(iqeDhrMPl0AVt],X<pElR[ZRC'U^Ynakm„U"<;kZphnH?rFov)KrEwT=aZp(3QxXbA'atDeby[9;)ie3-M.5ZqyHq&UG=?aM:ZQ„U"M3#y=ETpN?#TCm?+S*gxRk.qv*Q(#+lVV_kfE/<m4Yl=eTZg.>Q)#D,hKLYD3PY„U"Wz%K$4McoE(nud:L]o5\io,$Tlg675b7Ad5[ygrUQbK/SpjlS\Y3g\o*,oFlKIO„U"&LIrWbW9^CmPsXtYo$NtAOVS5JG&+*Pf#N);xOaz%PBK1NK(]lf)l*L#tj>jNC:„U"?vAH&piYJ9o%p8'I3]LU1)inz9V6iI6#F3e4_$+]OXaeSb$:ENkx[ot(]4%/foA„U"t3vgmV2-7#gzh>l0TW\B5qWi)?/;v[eRp\QKslg+%2,03+5a/SW1+2/k4gVCKw/„U"iCnA%fc[p8wcd_lB'M-QU<f0GnJa-kz<NHLIoAq(\pX5mC2*/]&F$jf8etG]7Wj„U"U_*M(sPE_>8h$Id&E29HQON_b_lvBad/EeBZ)s;X_8j0Xz#?%^n2(a*HMU0uMh?„U"VP(sd/q%0q>->4_ku&zN+^..lk&^>9oU=EM6.J14QCQcK$lb(lbuFPAj93sA5$,„U"6,Yo1^>:6MXkAgUa7b^X+,:LXVQEw9QM2LKmp>aPJ[DPlGDS:A3Gp+HB(leT/p,„U"5tu69$#_nBNm8C\d_kH&'wHU+H/;m^W22v33\TQPJ;Z-k-91ua[X+4r76mD%;vd„U"Eg[iTHIBegXL6*v/lsJ>:_7-j3:.14bj_)wjc4\wJ>[T_#2/9C%$xa%R;;Tr\2)„U"1#r3&-RB#rpd$HU?3I'4I:q=Cixu%p&'9%%/%%%%%%]D\SB=&egG*%%%%*%%%%.„U"%%%%%%%%%&%%E%%%%%%%#%rt%%njSn%snup%&'9%%9%'%.-%d%S,D>M)LwTI#%%„U"\$%%%.%%%%%%%%%&%%E%%%%Q%%%.rt%n%jSgf%xup&%'9%/%%%%%g%J:j.CO[)%„U"h,%%%%,%%%%.%%%%%%%%%&%E#%%%Q%I%%r(t%nj#Sni'%up&'%9%9%%'%-%4z4+„U"Dd<LV=%I9%%)UK%%%.%%%%%%%%%&%E%7%%)I%%%rt&%njS%ifyu%p*+%%%%%)[%„U")%U[%%%t%]%%%%%„END SUB„V2„CLOSE:IF S=251AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„'>>> Page 1 of MOVIE204.ZIP ends here. Last page. TCHK:251„Rommie Brewer                  KEYFILE GENERATOR              FidoNet QUIK_BAS Echo          06-04-93 (23:08)       QB, QBasic, PDS        329  10140    KEYFILE.BAS '   As promised 87 years ago, here is a simple key-file generation„' program.  It is designed to keep honest people honest, as any„' hacker can break it by either breaking the code or patching the„' original program to bypass the registration checking.„'   As written, this will generate a simple key and includes the„' code to check that the key can be decoded.  Several things need„' to be done before it is used in 'real life'.  I'll list them in a„' minute.„„' What it does:„'   1 - Generates a key file that includes a CRC check and an„'       embedded registration name and serial number.„'     - The first two lines of this file show the registration„'       name and serial number.  These lines are not used by the„'       program and can be changed without affecting the programs„'       operation as long as total line length is not changed.„'       They are included so you can do a quick check of who that„'       key is for.  This allows you to make several keys at once„'       and then sort out who gets which one (you would need to„'       include a routine to change the key file name after each„'       generation.„'     - The remaining space is filled by randomly generated ASCII„'       characters, with the TIMER function used to seed the random„'       generator.„'     - The display name and serial number are then encrypted and„'       the letters scattered about the random ASCII.„'     - A 16 bit CRC check is performed, and the value is encrypted„'       and and put into an area not included in the CRC check.„'„'   2 - Generates a historical record, with enough information to„'       generate an identical key at a later date. (This prevents a„'       couple of people from registering a program and getting a„'       key, then requesting a replacement key and comparing the„'       differences in order to break the encryption.)„'     - This data includes the registration name, serial number,„'       date the key is generated, and the seed for the random„'       generator.„'„' What it needs to be usable:„'   1 - Better routines for getting the display name and serial„'       number.  I decided to not waste bandwidth on examples that„'       others have already made.„'   2 - Larger areas for the display name and serial number.  I„'       limited these also for space„'   3 - Places for an address in the historical file„'   4 - Routines to compare names and serial numbers for dupes„'   5 - Routine to look through historical file and select one and„'       generate a replacement key based on the information found.„'   6 - A field for different levels of registration.  That is easy„'       to add using the procedures demonstrated.„'   7 - A drop-dead date for temporary keys.  I suggest that the„'       number of days since some arbitrary date be selected as the„'       base date (1 Jan 1900 ??) and then a value be added with„'       the days after the base date as the drop dead date.  Using„'       the same basedate in the generator and the actual program,„'       an imbedded 'total days' number can be made with each temp„'       key.  Use the system date to get 'current total days'.„'       This prevents someone from hacking a new month into the„'       temp key.„'   8 - Change the encryption value of 64 to 'your' value, between„'       64 and 100.„' So, without further comment (HA!), here it is.  Comments?„„' Onwards....„„„'------------------„' generate registration keys for programs„„DECLARE FUNCTION crc16% (target$)„„' define structure file 1 - which holds your list of past keys„TYPE KeyRecord„   Regno AS STRING * 10„   RegName AS STRING * 30„   Datereg AS STRING * 10„   Rndseed AS LONG„   LnTrn AS STRING * 2„„END TYPE„DIM FileBuffer AS KeyRecord„  FileBuffer.LnTrn = CHR$(13) + CHR$(10)„DIM namepoint(20), serpt(20)„namlength = 5„seriallength = 5„„' open file 1 as past keys„CLS„„GOSUB oldkey„„GOSUB getrandseed:  ' get a seed value for the random function„„GOSUB opnkey: ' open the new KeyFile.Dat to write in the values„„' get display name for key file.  Replace this routine with a better one„INPUT "What display name do you want to use "; Dspnam$„Dspnam$ = LEFT$(Dspnam$ + SPACE$(namlength), seriallength)„„' get serial/registration number.  Replace this routine, also.„INPUT "What is the serial number "; srnmbr$„srnmbr$ = LEFT$(srnmbr$ + SPACE$(seriallength), seriallength)„„' check on dupes of names and numbers„„' get date of registration„   FileBuffer.Datereg = DATE$„„' put info into file one and update„   FileBuffer.Regno = srnmb$„   FileBuffer.RegName = Dspnam$„   FileBuffer.Rndseed = rseed„   FileBuffer.LnTrn = CHR$(13) + CHR$(10)„   totrec = totrec + 1„   PUT #1, totrec, FileBuffer„   GET #1, 1, FileBuffer„   FileBuffer.Rndseed = totrec„   PUT #1, 1, FileBuffer„„„' generate key - file 2„„' pad name with spaces to center„   namspac = LEN(Dspnam$)„   namfre = 80 - namspac - 2„   line1$ = SPACE$(namfre / 2) + Dspnam$ + SPACE$(namfre / 2) + CHR$(13) + CHR$(10)„' put in Key File for your info only.  You use to confirm which key you„' are sending to who, by using a doc viewer„LSET fuline$ = line1$„PUT #2, 1„„' pad serial with spaces to center„   serspac = LEN(srnmbr$)„   serfre = 80 - serspac - 2„   line2$ = SPACE$(serfre / 2) + srnmbr$ + SPACE$(serfre / 2) + CHR$(13) + CHR$(10)„„  ' put in file 2 as second line„LSET fuline$ = line2$„PUT #2, 2„„' close out the two lines and re-open data file as 1 byte„GOSUB keyfill„„  ' fill file 2 with random values„RANDOMIZE (-rseed)„„  FOR x = 161 TO 500„      LSET PtFilr$ = CHR$(RND * 255)„      PUT #2, x„   NEXT x„„' read locations for name letters„RESTORE namdatpt„„  FOR x = 1 TO namlength„     READ namepoint(x)„  NEXT x„„ FOR x = 1 TO namlength„'   convert name digit coded letter„  mp$ = CHR$((ASC(MID$(Dspnam$, x, 1)) + 64))„  LSET PtFilr$ = mp$„   PUT #2, namepoint(x)„ NEXT x„„' read location for serial number„RESTORE serldatpt„  FOR x = 1 TO seriallength„    READ serpt(x)„  NEXT x„„ FOR x = 1 TO seriallength„   sp$ = CHR$((ASC(MID$(srnmbr$, x, 1)) + 64))„   LSET PtFilr$ = sp$„   PUT #2, serpt(x)„ NEXT x„„' calculate the CRC„testcr$ = ""„ FOR x = 161 TO 450„ GET #2, x„ testcr$ = testcr$ + PtFilr$„NEXT x„„' calculate the crc, convert to a string so you can hide it„crcnumber = crc16(testcr$)„PRINT "crc checks as "; crcnumber„crcname$ = STR$(crcnumber)„crcname$ = LEFT$(LTRIM$(crcname$) + "aAbBcCdDeEfFgGhHiIjJkKlL", 10)„„'PRINT "crc word = "; crcname$; "  and value "; VAL(crcname$)„' put the CRC at point 460 , incrementing the value of each letter„'   so it doesn't stand out as a number„FOR x = 460 TO 469„  LSET PtFilr$ = CHR$(ASC(MID$(crcname$, x - 459, 1)) + 64)„  PUT #2, x„NEXT x„„' ----„' This is the part that would be in the program being protected.  It„' is put here to demonstrate the program works.„' The data points and file opening routines would need to be copied,„' also.„„„' retrieve the stored CRC„rechk$ = ""„FOR x = 460 TO 469„  GET #2, x„  rechk$ = rechk$ + CHR$(ASC(PtFilr$) - 64)„NEXT x„crcchk2 = VAL(rechk$):  ' the stored CRC value„„„' calculate the CRC„testcr$ = ""„ FOR x = 161 TO 450„ GET #2, x„ testcr$ = testcr$ + PtFilr$„NEXT x„crcnumber = crc16(testcr$)„„IF crcchk2 = crcnumber THEN„  PRINT "They match as "; crcnumber„     Dspnam$ = ""„     FOR x = 1 TO namlength„'      convert digit coded letter to name„       GET #2, namepoint(x)„       mp$ = CHR$((ASC(PtFilr$) - 64))„       Dspnam$ = Dspnam$ + mp$„     NEXT x„       PRINT "Display Name is "; Dspnam$„„  ELSE PRINT "No Match: something was changed ";„       PRINT crcnumber; " "; crcchk2„„END IF„„CLOSE„END„„„oldkey:„CLOSE #1„OPEN "oldkey.dat" FOR RANDOM AS #1 LEN = LEN(FileBuffer)„GET #1, 1, FileBuffer„  ' check if there is a data file.  If not, start one.„  IF INSTR(FileBuffer.Regno, "Start") = 0 THEN„    FileBuffer.Regno = "Start"„    FileBuffer.RegName = "No-Name"„    FileBuffer.Datereg = DATE$„    FileBuffer.Rndseed = 1„    FileBuffer.LnTrn = CHR$(13) + CHR$(10)„    PUT #1, 1, FileBuffer„    totrec = 1„  END IF„totrec = FileBuffer.Rndseed:  ' total registrations on file„„RETURN„„„opnkey: ' open the new key file„CLOSE #2„OPEN "NewKey.DAT" FOR RANDOM AS #2 LEN = 80„  FIELD #2, 80 AS fuline$„RETURN„„keyfill:„CLOSE #2„OPEN "NewKey.dat" FOR RANDOM AS #2 LEN = 1„FIELD #2, 1 AS PtFilr$„RETURN„„„„getrandseed: ' get the random seed„rseed = INT(TIMER)„rseed = ABS(rseed)„„RETURN„„' below are the data areas where you specify the location inside the random„' generated area for the storage of your values.  For demo purposes, I am„' limiting the number of values so it is easy to visually check there are„' not any locations specified twice.  In actual practice, I suggest you„' write a random list - in order - on a piece of paper and scratch the„' values off as you put them here.„„namdatpt: ' random data points for the name„DATA 241, 152, 423, 367, 275„„serldatpt: ' random locations for the serial number„DATA 342, 467, 199, 300, 400„„FUNCTION crc16% (target$)„STATIC Initialized%, CRCTable%()„' 05-25-93  Douglas Lusher  16bit CRC calculation  1:282/7„IF Initialized% GOTO CalcCRC16„„REDIM CRCTable%(255)„FOR Ptr% = 0 TO 255„  CRC& = Ptr% * &H100&„  FOR Bit% = 0 TO 7„    Carry% = ((CRC& AND &H8000) <> 0)„    'Carry% is True if Bit 16 is set„    CRC& = (CRC& * 2) AND &HFFFF&„    'shift the low 16 bits one place left„    CRC& = CRC& XOR (Carry% AND &H1021)„    'if there was a carry, then XOR in the bitmask„  NEXT„  CRCTable%(Ptr%) = (CRC& - 32768) XOR &H8000„  'change the long int to an unsigned int for the table„NEXT„Initialized% = -1„„CalcCRC16:„„HiByte% = 0„LoByte% = 0„FOR Ptr% = 1 TO LEN(target$)„  Char% = ASC(MID$(target$, Ptr%))„  CRC& = CRCTable%(HiByte% XOR Char%) XOR LoByte%„  CRC& = CRC& * &H100„  HiByte% = (CRC& AND &HFF0000) \ &H10000„  LoByte% = ((CRC& AND &HFF00&) - 32768) XOR &H8000„NEXT„crc16% = HiByte% OR LoByte%„„END FUNCTION„Tom Hammond                    AMORTIZATION PROGRAM           FidoNet QUIK_BAS Echo          12-07-89 (00:00)       QB, QBasic, PDS        561  14391    AMORT.BAS   ' > I am in need of a formula to calculate how much of a loan„' > payment goes towards principle and how much goes towards interest.„' > Can anybody Help???„„    DSN$ = "AMORT1c.BAS (.EXE)"„    AUTHOR$ = "Tom Hammond"„    REVISED$ = "12/07/89"„„    ' Amortization formula„„    '    A = P * (I/(1-(1/((1+I)^N))))„„    '    Where:  A = Amount of payment„    '            P = Principal„    '            N = Number of payments„    '            I = Periodic interest rate„„MAIN:„    GOSUB INTRO.MSG„    GOSUB LOAD.CONSTANTS„    GOSUB ENTER.NAME„    GOSUB ENTER.PRINCIPAL„    GOSUB ENTER.TERM„    GOSUB ENTER.APR„    GOSUB DISPLAY.PMT.DATA.CHECK„    GOSUB SELECT.PRINT.TO.PRINTER„    GOSUB CALC.AMORT.DATA„    GOSUB CHECK.PRINTER.STATUS„    GOSUB PRINT.REPORT.HEADERS„    GOSUB MONTHLY.DATA.ROUTINE„    GOSUB PRINT.FOOTER„„    TXT$ = "Press any <Key> to continue"„    GOSUB SCRNCTR„    WHILE INKEY$ = ""„    WEND„    GOTO MAIN„„INTRO.MSG:„    CLS„    PRINT DSN$; TAB(66); "By: "; AUTHOR$„    LOCATE 25, 32„    PRINT "Revised: "; REVISED$;„    LOCATE 7, 1„    TXT$ = "Written for"„    GOSUB SCRNCTR„    PRINT„    TXT$ = "{EMPLOYMENT SECURITY CREDIT UNION}"„    GOSUB SCRNCTR„    LOCATE 12, 1„    TXT$ = "This program calculates the amortization of a loan    "„    GOSUB SCRNCTR„    TXT$ = "based upon the initial amount of the loan (principal),"„    GOSUB SCRNCTR„    TXT$ = "the length of time that the loan is for (term) and    "„    GOSUB SCRNCTR„    TXT$ = "the annual interest rate (APR).  Estimates assume an  "„    GOSUB SCRNCTR„    TXT$ = "average of 30.4 days per month.                       "„    GOSUB SCRNCTR„    LOCATE 19, 1„    TXT$ = "<C>ontinue or <Q>uit"„    GOSUB SCRNCTR„QUIT.OR.CONT:„    CQ$ = UCASE$(INKEY$)„    IF CQ$ = "" THEN„        GOTO QUIT.OR.CONT„    ELSEIF CQ$ = "Q" THEN„        CLS„        GOSUB TURN.CAPS.AND.NUMLOCK.OFF„        END„    ELSEIF CQ$ <> "C" AND CQ$ <> CHR$(13) THEN„        BEEP„        GOTO QUIT.OR.CONT„    END IF„    RETURN„„LOAD.CONSTANTS:„    HEAD1$ = "           Monthly        Applied        Applied   Unpaid"„    HEAD2$ = "Pmt#       Payment      to Interest   to Principal Balance"„    PF$ = "####   $$###,###.##   $$###,###.##   $$###,###.##     $$###,###.##"„    RETURN„„ENTER.NAME:„    CLS„    LOCATE 4, 1„    TXT$ = "Enter the {NAME} of the person for whom these data are being calcul„    PTAB% = 1„    GOSUB SCRNCTR„    PRINT„    PRINT TAB(5); "Name ==> ";„    GOSUB TURN.CAPS.AND.NUMLOCK.ON„    COLOR 15„    INPUT "", NAME$„    COLOR 7„    RETURN„„ENTER.PRINCIPAL:„    GOSUB TURN.CAPS.AND.NUMLOCK.ON„    PRINT„    PRINT„    TXT$ = "Enter the {amount} of the loan (principal): "„    PTAB% = 1„    GOSUB SCRNCTR„    LOCATE CSRLIN - 1, 60„    COLOR 15„    PRINT "<== Use ";„    COLOR 31„    PRINT "NO";„    COLOR 15„    PRINT " COMMAS "„    LOCATE CSRLIN - 1, 44„    COLOR 15„    INPUT "$", P„    COLOR 7„    IF P <= 0 THEN„        GOTO MAIN„    END IF„    RETURN„„ENTER.TERM:„    LOCATE CSRLIN + 1, 1„    PTAB% = 1„    TXT$ = "Will the {length} (term) of the loan will be in <M>onths or <Y>ears„    GOSUB SCRNCTR„ENTER.TERM.1:„    MY$ = UCASE$(INKEY$)„    IF MY$ = "" THEN„        GOTO ENTER.TERM.1„    END IF„    PRINT„    IF MY$ <> "M" AND MY$ <> "Y" THEN„        BEEP„        GOTO ENTER.TERM.1„    ELSEIF MY$ = "M" THEN„        PTAB% = 10„        TXT$ = "Enter the term in {months}: "„        GOSUB SCRNCTR„        LOCATE CSRLIN - 1, 36„        COLOR 15„        INPUT "", T„        COLOR 7„    ELSEIF MY$ = "Y" THEN„        PTAB% = 10„        TXT$ = "Enter the term in {years}: "„        GOSUB SCRNCTR„        LOCATE CSRLIN - 1, 35„        COLOR 15„        INPUT "", T„        COLOR 7„    END IF„    RETURN„„ENTER.APR:„    PRINT„    PTAB% = 10„    TXT$ = "Enter the {annual percentage rate}: "„    GOSUB SCRNCTR„    LOCATE CSRLIN - 1, 44„    COLOR 15„    INPUT "", APR„    COLOR 7„    PRINT„    PRINT„    RETURN„„DISPLAY.PMT.DATA.CHECK:„    TXT$ = "Do you want to see payment/balance data for each month <{Y}/N>"„    PTAB% = 1„    GOSUB SCRNCTR„DISPLAY.PMT.DATA.CHECK.1:„    MNTHDATA$ = UCASE$(INKEY$)„    IF MNTHDATA$ = "" THEN„        GOTO DISPLAY.PMT.DATA.CHECK.1„    ELSEIF MNTHDATA$ = CHR$(13) THEN„        MNTHDATA$ = "Y"„    ELSEIF MNTHDATA$ <> "Y" AND MNTHDATA$ <> "N" THEN„        BEEP„        GOTO DISPLAY.PMT.DATA.CHECK.1„    END IF„    RETURN„„SELECT.PRINT.TO.PRINTER:„    PRINT„    TXT$ = "Do you want to send the results to your printer <{Y}/N>"„    PTAB% = 1„    GOSUB SCRNCTR„SELECT.PRINT.TO.PRINTER.1:„    PRT$ = UCASE$(INKEY$)„    IF PRT$ = "" THEN„        GOTO SELECT.PRINT.TO.PRINTER.1„    ELSEIF PRT$ = CHR$(13) THEN„        PRT$ = "Y"„    ELSEIF PRT$ <> "Y" AND PRT$ <> "N" THEN„        BEEP„        GOTO SELECT.PRINT.TO.PRINTER.1„    END IF„    IF PRT$ = "Y" THEN„        GOSUB LASER.PRINTER.CHECK„    END IF„    RETURN„„LASER.PRINTER.CHECK:„    PRINT„    TXT$ = "Do you have a Laser Printer <{Y}/N>"„    PTAB% = 1„    GOSUB SCRNCTR„LASER.PRINTER.CHECK.1:„    LASER$ = UCASE$(INKEY$)„    IF LASER$ = "" THEN„        GOTO LASER.PRINTER.CHECK.1„    ELSEIF LASER$ = CHR$(13) THEN„        LASER$ = "Y"„    ELSEIF PRT$ <> "Y" AND PRT$ <> "N" THEN„        BEEP„        GOTO LASER.PRINTER.CHECK.1„    END IF„    RETURN„„CALC.AMORT.DATA:„    D = P                    ' SAVE PRINCIPAL FOR LATER„    IF MY$ = "Y" THEN„        N = T * 12           ' CONVERT YEARS TO MONTHS„    ELSE„        N = T„    END IF„    I = APR * .01            ' CONVERT APR TO DECIMAL„„    I = I / 12               ' CONVERT TO MONTHLY RATE„    A = P * (I / (1 - (1 / ((1 + I) ^ N))))  ' CALCULATE PAYMENT„    RETURN„„PRINT.REPORT.HEADERS:„    CLS„    LOCATE 5, 1„    PRINT USING "$$###,###.##"; P;„    PRINT " for";„    IF MY$ = "M" THEN PRINT T; "months at";„    IF MY$ = "Y" THEN PRINT T; "years at";„    PRINT USING " ##.##%"; APR;„    PRINT " APR"„    PRINT„    PRINT "Monthly Payment is:   ";„    PRINT USING "$$###,###.##"; A„    IF PRT$ = "Y" THEN„        GOSUB CHECK.PRINTER.STATUS„        IF LASER$ = "Y" THEN„            LPRINT CHR$(27); "E";           ' RESET LASER PRINTER„        ELSE„            LPRINT CHR$(27); "@";           ' RESET EPSON LQ PRINTERS„            LPRINT„            LPRINT„            LPRINT„        END IF„        LPRINT TAB(30); "EMPLOYMENT SECURITY CREDIT UNION"„        LPRINT„        LPRINT„        LPRINT TAB(10); "Prepared for: "; NAME$;„        LPRINT TAB(58); "Date: "; DATE$„        LPRINT„        LPRINT TAB(9); USING "$$###,###.##"; P;„        LPRINT " for";„        IF MY$ = "M" THEN„            LPRINT T; "months";„        ELSE„            LPRINT T; "years";„        END IF„        LPRINT " at an Annual Percentage Rate of ";„        LPRINT USING "##.##%"; APR„        LPRINT„        LINES = 7„    END IF„„    IF MNTHDATA$ = "Y" THEN GOSUB PRINT.HEADERS„    IF PRT$ = "Y" THEN GOSUB LPRINT.HEADERS„„    RETURN„„MONTHLY.DATA.ROUTINE:„    BB = 0„    FOR X = 1 TO N„        B = D * I            'INTEREST FOR THIS PERIOD„        BB = BB + B          'SUM INTEREST PAID„        IF D <= A - B THEN„            A = B + D        'LAST PAYMENT CALCULATION„        END IF„        C = A - B            'AMOUNT APPLIED TO PRINCIPLE„        D = D - C            'UNPAID BAL. OF PRINCIPLE„„        GOSUB DATA.PRINT.ROUTINE„„    NEXT X„    RETURN„„DATA.PRINT.ROUTINE:„    IF MNTHDATA$ = "Y" THEN„        IF LINES > 57 THEN„            LPRINT„            LPRINT TAB(10); "continued on the next page";„            IF LASER$ = "N" THEN„                LPRINT CHR$(12);„            END IF„            GOSUB LPRINT.NEXT.PAGE„            GOSUB LPRINT.HEADERS„        END IF„„        PRINT USING PF$; X; A; B; C; D„        IF PRT$ = "Y" THEN„            LPRINT TAB(10); USING PF$; X; A; B; C; D„            LINES = LINES + 1„        END IF„    END IF„    RETURN„„PRINT.FOOTER:„    IF PRT$ = "Y" THEN„        IF LINES > 45 THEN„            LPRINT„            LPRINT TAB(10); "Continued on next page";„            LINES = LINES + 2„            IF LASER$ = "N" OR (LASER$ = "Y" AND LINES < 60) THEN„                LPRINT CHR$(12);„            END IF„            GOSUB LPRINT.NEXT.PAGE„        END IF„        LPRINT„    END IF„    IF PRT$ = "Y" THEN„        LPRINT„        LPRINT TAB(10); "     Amount borrowed:  ";„        LPRINT USING "$$###,###.##"; P„        LPRINT TAB(10); "     Monthly payment:  ";„        LPRINT USING "$$###,###.##"; A„        LPRINT TAB(10); " Total Interest Paid:  ";„        LPRINT USING "$$###,###.##"; BB„        LPRINT TAB(10); "Total Principal Paid:  ";„        LPRINT USING "$$###,###.##"; P„        LPRINT„        LPRINT TAB(10); "Your";„        LPRINT USING "$$###,###.##"; P;„        LPRINT " loan will cost you:";„        LPRINT USING "$$###,###.##"; BB + P„        LPRINT„        LPRINT„        LPRINT TAB(10); "NOTE:  These calculations are based upon 30.4 days per„        LPRINT TAB(10); "       Due to the number of days in the months, your a„        LPRINT TAB(10); "       figures may vary slightly.  Interest is paid on„        LPRINT TAB(10); "       unpaid balance and is calculated on the number„        LPRINT TAB(10); "       between payment.";„        LINES = LINES + 15„        IF LASER$ = "Y" THEN„            IF LINES < 60 THEN„                LPRINT CHR$(12);„            ELSE„                LPRINT„            END IF„        ELSE„            LPRINT CHR$(12);„        END IF„        IF LASER$ = "Y" THEN„            LPRINT CHR$(27); "E";           'RESET LASER PRINTERS„        ELSE„            LPRINT CHR$(27); "@";           'RESET EPSON LQ PRINTERS„„        END IF„    END IF„„    IF MNTHDATA$ = "Y" THEN„        PRINT„        PRINT„    END IF„    PRINT "Total Interest Paid:  ";„    PRINT USING "$$###,###.##"; BB„    PRINT "Total Principal Paid: ";„    PRINT USING "$$###,###.##"; P„    PRINT„    PRINT "Your";„    PRINT USING "$$###,###.##"; P;„    PRINT " loan will cost you:";„    PRINT USING "$$###,###.##"; BB + P„    PRINT„    PRINT„    PRINT„    RETURN„„TURN.CAPS.AND.NUMLOCK.ON:„    DEF SEG = &H40„    POKE 23, 96„    DEF SEG„    RETURN„„TURN.CAPS.AND.NUMLOCK.OFF:„    DEF SEG = &H40„    POKE 23, 0„    DEF SEG„    RETURN„„SCRNCTR:„    ' SCREEN TEXT-CENTERING AND PRINTING ROUTINE TO HIGHLIGHT TEXT„    ' LAST CHANGED 07/10/89„„    ' NOTE: Text enclosed by '{}s' is highlighted WITHOUT the '{}s' printed„    '       Text enclosed by '<>s' is highlighted WITH the '<>s' printed„„    '       If the variable PTAB% is equal to zero, TXT$ will be centered.„    '       PTAB% is reset to zero after each pass through this  routine.„    '       If PTAB% is assigned a value greater than zero, then cente„    '       will be bypassed and the PTAB% value will be used as a TAB value.„„    '       If PTAB$ is assigned ANY negative value, no centering or TABbing„    '       is done, TXT$ is parsed and printed at the current cursor position.„„CHK4TAB:„    ' CHECK FOR TAB% VALUE„    IF PTAB% < 0 THEN„        GOTO PARSETXT„    END IF„    IF PTAB% >= 1 THEN„        LOCATE CSRLIN, PTAB%„        GOTO PARSETXT„    END IF„„    ' CENTER TEXT (FIRST REDUCE LINE LENGH BY # BRACES)„    XBRACE = 0„    BRACES = 0„„„CALCCNTR:„    XBRACE = INSTR(XBRACE + 1, TXT$, "{")„    IF XBRACE = 0 THEN„        GOTO CNTR„    ELSE„         BRACES = BRACES + 2„         GOTO CALCCNTR„    END IF„„CNTR:„    LOCATE CSRLIN, INT((80 - LEN(TXT$) + BRACES) / 2) + 1„„PARSETXT:„    ' PARSE TEXT FOR '<>s' AND '{}s' AND PRINT ACCORDINGLY„    PTAB% = 0„„    POINTER = 1„    PARSED = 0„„PARSE1:„    OBRACE = INSTR(POINTER, TXT$, "{")„    LTSYMB = INSTR(POINTER, TXT$, "<")„    IF OBRACE = 0 AND LTSYMB = 0 AND PARSED = 0 THEN„        GOTO PARSE2„    END IF„    PARSED = 1„    IF LTSYMB > 0 AND OBRACE = LTSYMB + 1 THEN„        GOTO PARSE5„    END IF„    IF (LTSYMB > 0 AND LTSYMB < OBRACE) OR (OBRACE = 0 AND LTSYMB > 0) THEN„        GOTO PARSE4„    END IF„    IF (OBRACE > 0 AND OBRACE < LTSYMB) OR (LTSYMB = 0 AND OBRACE > 0) THEN„        GOTO PARSE5„    END IF„    PRINT MID$(TXT$, POINTER, LEN(TXT$))„    GOTO CNTRDONE„„PARSE2:„    ' PRINT ENTIRE LINE (NO '<' OR '{' SYMBOLS)„    COLOR 7„    PRINT TXT$„    GOTO CNTRDONE„„PARSE4:„    ' ROUTINE TO HIGHLIGHT AND PRINT TEXT, INCLUDING THE '<>' SYMBOLS„    IF LTSYMB > 1 THEN„        PRINT MID$(TXT$, POINTER, LTSYMB - POINTER + 1);„    ELSE„         PRINT LEFT$(TXT$, 1);„    END IF„    COLOR 15„    GTSYMB = INSTR(LTSYMB, TXT$, ">")„    PRINT MID$(TXT$, LTSYMB + 1, GTSYMB - LTSYMB - 1);„    COLOR 7„    PRINT MID$(TXT$, GTSYMB, 1);„    POINTER = GTSYMB + 1„    GOTO PARSE1„„PARSE5:„    ' ROUTINE TO HIGHLIGHT AND PRINT TEXT-ONLY WITHIN '{}' SYMBOLS„    IF OBRACE > 1 THEN„        PRINT MID$(TXT$, POINTER, OBRACE - POINTER);„    END IF„    COLOR 15„    CBRACE = INSTR(OBRACE, TXT$, "}")„    PRINT MID$(TXT$, OBRACE + 1, CBRACE - OBRACE - 1);„    COLOR 7„    POINTER = CBRACE + 1„    GOTO PARSE1„„CNTRDONE:„    RETURN„„CHECK.PRINTER.STATUS:„     DEF SEG = 0„     PORT.NR = 1     ' USE PORT.NR = 1 FOR LPT1 AND N=2 FOR LPT2„     PORT% = PEEK(1030 + (2 * PORT.NR)) + 256 * PEEK(1031 + (2 * PORT.NR))„„GET.PRINTER.STATUS:„     STATUS% = INP(PORT% + 1)„     IF STATUS% AND 8 THEN„         CLS„         DEF SEG„         RETURN„     END IF„     CLS„„„     SOUND 600, 1„     SOUND 800, 1„     SOUND 1000, 1„     LOCATE 11, 32„     PRINT "Printer ";„     COLOR 31„     PRINT "NOT READY"„     COLOR 7„     LOCATE 13, 25„     PRINT "Set printer ";„     COLOR 15„     PRINT "ON-LINE";„     COLOR 7„     PRINT " or ";„     COLOR 15„     PRINT "TURN ON"„     COLOR 7„     SLEEP 2„     CLS„     GOTO GET.PRINTER.STATUS„„PRINT.HEADERS:„    PRINT„    PRINT HEAD1$„    PRINT HEAD2$„    PRINT„    RETURN„„LPRINT.HEADERS:„    LPRINT TAB(10); HEAD1$„    LPRINT TAB(10); HEAD2$„    LPRINT„    LINES = LINES + 3„    RETURN„„LPRINT.NEXT.PAGE:„    IF LASER$ = "N" THEN„        LPRINT„        LPRINT„        LPRINT„    END IF„    LPRINT TAB(10); NAME$; " (cont'd.)"„    LPRINT„    LINES = 2„    RETURN„Alexander Podkolzin            COLOR CHOOSER                  app@sbank.e-burg.su            11-22-95 (07:27)       PB                     141  5189     COLORS.BAS  '---------------------------------------------------------------------------„'„' It's a TOY, wich will help users to write a subroutine to choose„' colors for their APP@lications.   :)„' This little toy is my Christmas present to all ABC readers...„' Use & enjoy.„' Author: Alexander Podkolzin <APP@sbank.e-burg.su>„' Public domain.„'„'---------------------------------------------------------------------------„  DEFINT A-Z„  CLS„'„  xb%=20         '  <<^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^>>„  yb%=10         '  << I think we don't need comments here...  >>„  xe%=xb%+34     '  <<                                         >>„  ye%=yb%+9      '  << Your comments and kisses send to author >>„  ct%=7          '  <<    dayly from 8.30 to 17.30 GMT-5 :))   >>„  cb%=0          '  <<_________________________________________>>„'„  LOCATE ye%+2,19„  PRINT "Use navigation keys for cursor moving..."„  Enter$    = CHR$(13)„  Esc$      = CHR$(27)„  Home$     = CHR$(0,71)„  PgUp$     = CHR$(0,73)„  EndKey$   = CHR$(0,79)„  PgDn$     = CHR$(0,81)„  Up$       = CHR$(0,72)„  Down$     = CHR$(0,80)„  LeftKey$  = CHR$(0,75)„  RightKey$ = CHR$(0,77)„  Ch%= 2 '10                   ' Cursor face„  Hc%= 7                    '„'„  px%=xe%-2                 ' Cursor pointers„  py%=ye%-1                 '„  win 1,xb%,yb%,xe%,ye%,ct%,cb%„  FOR i%=0 TO 7„     PutAttribute xb%+1,yb%+i%+1,0,i%„     FOR j%=0 TO 15„        PutChar xb%+j%+j%+2,yb%+i%+1,CHR$(Hc%)„        PutAttribute xb%+j%+j%+2,yb%+i%+1,j%,i%„        PutAttribute xb%+j%+j%+3,yb%+i%+1,j%,i%„     NEXT j%„  NEXT i%„  PutChar px%,py%,CHR$(Ch%)„  DO„     ctext%=(px%-xb%)\2 -1„     cback%=py%-yb% -1„     ColorFrame xb%,yb%,xe%,ye%,ctext%,cback%„     WHILE NOT INSTAT: WEND„     s$=INKEY$„     PutChar px%,py%,CHR$(Hc%)„     SELECT CASE s$„        CASE Enter$    : CLS„                       : COLOR ctext%,cback%„                       : PRINT "Congratulations !"„                       : PRINT "Your favorite colors are:";„                       : PRINT ctext%;"- Text Color,";„                       : PRINT cback%;"- Background Color."„                       : END„        CASE Esc$      : CLS: PRINT "Bye-bye!": END„        CASE Home$     : px%=xb%+2„        CASE EndKey$   : px%=xe%-2„        CASE PgUp$     : py%=yb%+1„        CASE PgDn$     : py%=ye%-1„        CASE Up$       : DECR py%„        CASE Down$     : INCR py%„        CASE LeftKey$  : DECR px%,2„        CASE RightKey$ : INCR px%,2„     END SELECT„     IF px%<xb%+2 THEN px%=xe%-2„     IF px%>xe%-2 THEN px%=xb%+2„     IF py%<yb%+1 THEN py%=ye%-1„     IF py%>ye%-1 THEN py%=yb%+1„     PutChar px%,py%,CHR$(Ch%)„     SOUND 440+cback%*32+ctext%*32,.2„  LOOP„'---------------------------------------------------------------------------„  SUB PutChar(x%,y%,c$)„     DEF SEG = &hb800                   ' WARNING: System dependent !„     POKE 160*(y%-1)+x%+x%-2,ASC(c$)„     DEF SEG„  END SUB„'---------------------------------------------------------------------------„  SUB PutAttribute(x%,y%,t%,b%)„     c% = b%*16+t%„     DEF SEG = &hb800                   ' WARNING: System dependent !„     POKE 160*(y%-1)+x%+x%-1,c%„     DEF SEG„  END SUB„'---------------------------------------------------------------------------„  SUB ColorFrame(xb%,yb%,xe%,ye%,t%,b%)„     FOR i%=xb% TO xe%„        PutAttribute i%,yb%,t%,b%„        PutAttribute i%,ye%,t%,b%„     NEXT i%„     FOR i%=yb% TO ye%„        PutAttribute xb%,i%,t%,b%„        PutAttribute xe%,i%,t%,b%„     NEXT i%„  END SUB„'---------------------------------------------------------------------------„  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)„'„     OldColor% = pbvScrnTxtAttr         ' Internal PB variable„'„     SELECT CASE t%                     ' Window types„'                                       ' (you can make as much types,„'                                       '  as you want):„        CASE 1„           a%=218:b%=196:c%=191         '™îîîîîîîè„           h%=179: :d%=179              'É   1   É„           g%=192:f%=196:e%=217         'êîîîîîîî©„        CASE 2„           a%=201:b%=205:c%=187         'ôùùùùùùùã„           h%=186: :d%=186              'ä   2   ä„           g%=200:f%=205:e%=188         'òùùùùùùùå„        CASE ELSE„           a%=032:b%= a%:c%= a%         '„           h%= a%: :d%= a%              ' Blanks only„           g%= a%:f%= a%:e%= a%         '„     END SELECT„     COLOR ct%,cb%„     LOCATE yb%,xb% : PRINT CHR$(a%)+REPEAT$(xe%-xb%-1,CHR$(b%))+CHR$(c%)„     FOR i%=yb%+1 TO ye%-1„        LOCATE i%,xb% : PRINT CHR$(h%)+ SPACE$(xe%-xb%-1) +CHR$(d%)„     NEXT„     LOCATE ye%,xb% : PRINT CHR$(g%)+REPEAT$(xe%-xb%-1,CHR$(f%))+CHR$(e%)„     FOR i%=yb%+1 TO ye%+1„        PutAttribute xe%+1,i%,8,0       ' Maiking„     NEXT                               ' shadows„     FOR i%=xb%+1 TO xe%+1              '„        PutAttribute i%,ye%+1,8,0       '„     NEXT„     ct%=OldColor% AND 15               ' restore colors„     cb%=OldColor%\16„     COLOR ct%,cb%„  END SUB„'--------------------------------------------------------------------------„Dave Gjessing                  PERSONAL EXPENSE RECORDER      dgjess@freenet.columbus.oh.us  11-25-95 (00:00)       QB, QBasic, PDS        1810 57045    PER12QB.BAS 'November 25, 1995„'file PER12QB.BAS„'"Personal Expense Recorder"„'Copyright Dave Gjessing 1995„'„'the README file:„'„'PER is intended to be a quick, simple means to record one's day-to-day„'expenses, and to generate handy reports about same. If you are a„'bean-counter type person, you will find it to be completely inadequate,„'and should not waste your time looking at it. If (on the other hand) you„'are a normal person, you just might find it useful.„'„'To use:„'„'While in the directory where the .BAS file resides, type -> qbasic„'Once it is loaded, press SHIFT+F5„'„'The program will ask for a passcode. Since you have not yet set up a„'code, you simply press ENTER.  The main menu will come up.„'„'Press S, to go to the set-up menu. Press 1, and type in your name and a„'passcode. The passcode must be a number. (From here on out you will need„'to type in your passcode when the program starts).„'„'Back at the set-up menu, press 2, to add expense categories. Category„'names may be up to 16 characters long. Some examples: food, shelter, and„'utilities. You also need to provide a two-character category code. For„'the examples above, these might be fo, sh, and ut. You are given a„'chance to accept or re-do each entry. (You may also edit them later on).„'„'Repeat the process for all your expense categories. Don't get carried„'away with creating categories; each entry also has a note attached to„'it. The note is where you should be specific. (I have been getting along„'fine for three months with 15 categories).„'„'Also at the set-up menu, you may fool around with the screen colors. The„'default colors are 1,15.„'„'Once you have set up your categories, return to the main menu.„'„'Press N, to add new expenses. You will be presented with a data file„'name to either accept or reject. The program creates a new file each„'month. The files are named [MMYY]QPER.DAT. If the filename being„'presented to you is the wrong one for the current month, then you need„'to go to DOS and correct your system's date. You may do this from the„'main menu. You may want to add an entry for the month that just ended;„'in that case press ESCAPE, and tell the program the month and year that„'you wish to work with. In most case though, you will simply press ENTER,„'to accept the file shown (the current month's file). Next, you may„'either accept or change the day. If you are recording an expense from a„'few days ago, type in the new day. (Note that you cannot name a new„'month or year at this point; only a new day). In most cases, you will„'again simply press ENTER to accept the current day. Now you have to pick„'a category. (The reasoning behind the two-character category codes will„'now become apparent to you (if there was any doubt)). Pick one, and then„'you must enter in the dollar amount (dollars and cents). You may then„'enter in a short note (up to 40 characters). Next, your entire new entry„'is presented for your approval. Press Y to accept the entry, N do do it„'all over, or Q to quit back to the main menu and forget all about it.„'„'That's all there is to entering expenses. Now to look at what you have„'done...„„'At the main menu, press R for reports, and then A, S, or C. A (All„'Expenses for Month) will give you a complete listing of all the line„'items for all categories for a given month. S (Monthly Summary) will do„'a short report; just totals for each category, and the percentage of the„'grand total that each represents. C (Expenses per Category) will show„'all line items in a given month, for a given category.„'„'With all reports, you are offered a chance to save the report to either„'a file or to a printer. If you save to a file you may import the report„'into any wordprocessing program.„'„'Finally, at the main menu you may press E to edit existing records. You„'have a choice of editing Entries or Categories. You can change anything.„'Be aware that if you eliminate a category code, the program will not be„'able to find prior entries (entered under the old code). I would suggest„'writing down all your category codes. You may need them if you screw up„'whilst editing.„'„'Which brings us to crisis prevention. If you forget your passcode, go to„'DOS and delete the file PERSONAL.DAT. This will allow you to get back„'into the program (but you will have to re-do name, passcode, and„'colors). If you trash your category codes while editing, delete the file„'CATEGORY.DAT, and re-create it at the set-up menu, with the information„'that you wrote down earlier.„'„'                                 ***„'„'This computer programing stuff is great fun. I've been at it in earnest„'for about four months now. This program is written in Visual Basic for„'DOS (although it does not use any of the slick features available in„'VBDOS). This particular version has been converted to run under the QBasic„'interperator.„'„'In the original VB version I used the CURRENCY data type for entry.amount.„'QBasic does not recognise that, so it has been changed to DOUBLE.„'„'I hope that the source code might be helpful to other budding nerds like„'myself. After all, I've spent an absurd amount of time working on this„'thing, gleaning bits of stuff from other people's programs. To all from„'whom I have learned stuff, here is something back! I hope it is useful.„'„'dgjess@freenet.columbus.oh.us„'„'*************************************************************************„'start of the program:„'„DECLARE SUB editentries ()„DECLARE SUB editcategories ()„DECLARE SUB line25 ()„DECLARE SUB sumfile (sumfilename$)„DECLARE SUB sumprint ()„DECLARE SUB selectcolors ()„DECLARE SUB calcsubtotal ()„DECLARE SUB sumscreen ()„DECLARE SUB perhelp (topic$)„DECLARE SUB afmscreen ()„DECLARE SUB background (character%)„DECLARE SUB pcfile (pcfilename$)„DECLARE SUB drawborder (UpRow%, LeftCol%, BotRow%, RtCol%, bgc%)„DECLARE SUB pcprint ()„DECLARE SUB afmprint ()„DECLARE SUB afmfile (afmfilename$)„DECLARE SUB pcscreen ()„DECLARE SUB getamount ()„DECLARE SUB getnote ()„DECLARE SUB getcategory ()„DECLARE SUB addcategories ()„DECLARE SUB getday ()„DECLARE SUB displaycategories ()„DECLARE SUB selectfile ()„DECLARE SUB getpass ()„DECLARE SUB getpersonaldat ()„COMMON SHARED bgc%      'background color - user-defined in setup„COMMON SHARED fgc%      'forground color - user-defined in setup„DEFINT A-Z„„'************************************************************************„'Today's notes... (11/26/95)„„'I have moved mass quantities of code from module level to sub level,„'where it belongs, and eliminated tons of SHARED statements.„„'I need to work on reporting over a range of months.„„'I also plan to make the program multi-user - PERSONAL.DAT will hold any„'number of passcodes; the code entered tells the program who's data files„'to access. Of course, the name of the data files will have to be revised.„„'************************************************************************„'define the form of the PERSONAL.DAT file record„    TYPE personal„        uname AS STRING * 30     'the user's name„        passcode AS SINGLE      'a numeric passcode„        bgc AS INTEGER          'background color„        fgc AS INTEGER         'forground color„    END TYPE„DIM SHARED userid AS personal„'************************************************************************„'define the form of the CATEGORY.DAT file records„    TYPE category„        code AS STRING * 2      'two-character code, easy to remember„        label AS STRING * 16    'full description, tied to the code„    END TYPE„DIM SHARED whatfor AS category„'************************************************************************„'define the form of the expense record file entries„    TYPE expenrec„        day AS STRING * 8       'the date of the expense„        catcode AS STRING * 2   'taken from whatfor.code„        amount AS DOUBLE        'the money„        note AS STRING * 40     'optional note„    END TYPE„DIM SHARED entry AS expenrec„'************************************************************************„DIM SHARED workfilename AS STRING   'the data file currently in use„DIM SHARED screenfull AS INTEGER    'for report subs - a screenfull of stuff„DIM SHARED linenum AS INTEGER       'for printing - a pagefull of stuff„screenfull = 18„linenum = 0„„'************************************************************************„CLS„getpass         'very simple passcode "protection"„„'************************************************************************„'OK, the user is in and we are up and running...„„top:„CLS„COLOR fgc%, bgc%„background (176)    'number in parenthesis is ASCII character code„                    'can be any one you want„„CALL drawborder(8, 8, 16, 72, bgc%) 'draw the box around the menu„COLOR 14, bgc%                             'the main menu...„LOCATE 8, 23„PRINT " PERSONAL EXPENSE RECORDER .12(QB) "„COLOR fgc%, bgc%„LOCATE 10, 29„PRINT "N) Enter New Expenses"„LOCATE 11, 29„PRINT "R) Generate Reports"„LOCATE 12, 29„PRINT "E) Edit Existing Records"„LOCATE 13, 29„PRINT "S) Personal Set-Up"„LOCATE 14, 29„PRINT "D) Set System Date"„LOCATE 16, 29„COLOR 14, bgc%„PRINT " (H)elp - ESC to Quit ";„CALL line25„    DO                                  'main menu selection process...„    mainchoice$ = INKEY$„    mainchoice$ = UCASE$(mainchoice$)„    IF mainchoice$ = "N" THEN CLS : GOTO startnewentry„    IF mainchoice$ = "R" THEN CLS : GOTO reportsmenu„    IF mainchoice$ = "S" THEN CLS : GOTO setup„    IF mainchoice$ = "E" THEN CLS : GOTO editing„    IF mainchoice$ = "H" THEN CLS : CALL perhelp("main"): GOTO top„    IF mainchoice$ = "D" THEN CLS : SHELL "date": GOTO top„    IF mainchoice$ = CHR$(27) THEN : CLOSE : COLOR 7, 0: CLS : END '*SYSTEM„    '* a little QBasic trick: (excuse me if this is common knowlege)„    'If the last command in your program is SYSTEM, you will leave the„    'QBasic environment automaticaly upon termination. This can be used„    'to make it seem like your un-compiled .BAS program runs as a stand-alone„    'program, when you start it with a batch file. For instance, write a„    'per.bat file, as follows:„        'copy con per.bat„        'qbasic /run per12qb„        '<F6>„    'Now replace the END statement above with SYSTEM„    'Now, at the DOS command line, type per„    'The program will load up and run without any further intervention,„    'and when you exit it, you will be puked back onto the command line.„    '"We don't need no stinking compiler!" <bg>„    'End of trick.„        LOCATE 25, 63„        PRINT TIME$; 'this is not in line25 because it changes constantly„    LOOP„'************************************************************************„startnewentry:                  'begin gathering data for new entry„selectfile                      'chose the data file to write to„getday                          'get the day within the selected month„displaycategories               'show the available expense categories„getcategory                     'pick one„getamount                       'get the amount of money (negetive is OK)„getnote                         'get the note about the expense„CLS„'show the data entered, and find out if it is all OK...„COLOR fgc%, bgc%„CALL drawborder(9, 8, 15, 72, bgc%) 'draw the box around the menu„LOCATE 8, 27„COLOR 12, bgc%„PRINT " New Entry Confirmation !"„LOCATE 10, 12„COLOR fgc%, bgc%„PRINT "Record File..: "; workfilename$„LOCATE 11, 12„PRINT "Date.........: "; entry.day„LOCATE 12, 12„PRINT "Category.....: "; entry.catcode; "    ("; RTRIM$(whatfor.label); ")"„LOCATE 13, 12„PRINT USING "Amount.......: $##,###.##"; entry.amount„LOCATE 14, 12„PRINT "Note: "; entry.note„LOCATE 16, 27„COLOR 14, bgc%„PRINT " Is all this OK? (Y/N/Q) "„„    DO„    newentryconf$ = INKEY$„    newentryconf$ = UCASE$(newentryconf$)„    IF newentryconf$ = "Y" THEN GOTO recordnewentry„    IF newentryconf$ = "N" THEN GOTO startnewentry      'start over„    IF newentryconf$ = "Q" THEN GOTO top        'never mind, forget it„    LOOP„„'if it is all OK, then write it to the selected data file...„recordnewentry:„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„numrecords = LOF(3) / LEN(entry)„newplace = numrecords + 1„PUT #3, newplace, entry„CLOSE 3„PRINT„COLOR 14, bgc%„LOCATE 18, 25„PRINT " New entry has been recorded ": SLEEP 1„COLOR fgc%, bgc%„GOTO top„'************************************************************************„reportsmenu:„CLOSE„linenum = 0                     'initialize the number of text lines shown„CLS                             'on the screen to *0*„LOCATE 9„CALL drawborder(9, 8, 15, 72, bgc%) 'draw the box around the menu„COLOR 14, bgc%„LOCATE 9, 20„PRINT " Personal Expense Recorder Reports Menu "„COLOR fgc%, bgc%„LOCATE 11, 27„PRINT "A) ALL Expenses for Month"„LOCATE 12, 27„PRINT "S) Monthly Summary"„LOCATE 13, 27„PRINT "C) Expenses per CATEGORY"„COLOR 14, bgc%„LOCATE 15, 28„PRINT " ESC return to main menu "„COLOR fgc%, bgc%„CALL line25„    DO„    reportschoice$ = INKEY$„    reportschoice$ = UCASE$(reportschoice$)„    IF reportschoice$ = "A" THEN CLS : CALL selectfile: GOTO allformonth„    IF reportschoice$ = "S" THEN CLS : CALL selectfile: GOTO monthsummary„    IF reportschoice$ = "C" THEN CLS : CALL selectfile: GOTO pcscreen„    IF reportschoice$ = CHR$(27) THEN CLS : GOTO top„        LOCATE 25, 63„        PRINT TIME$;„    LOOP„„'**************************************************************************„allformonth:„afmscreen„PRINT„COLOR 13, bgc%„PRINT "                 would you like to save this report?"„PRINT„COLOR fgc%, bgc%„PRINT "                     to save to a file press F"„PRINT "              to send the report to your printer press P"„PRINT "                  press ENTER to forget all about it"„    DO„    afmchoice$ = INKEY$„    afmchoice$ = UCASE$(afmchoice$)„    IF afmchoice$ = "F" THEN GOTO afmfile„    IF afmchoice$ = "P" THEN GOTO afmprint„    IF afmchoice$ = CHR$(13) THEN GOTO reportsmenu„    LOOP„„afmfile:„CLOSE„PRINT„LINE INPUT "filename:  "; afmfilename$„'half-assed bad filename detection...„IF afmfilename$ = "" THEN BEEP: CLS : PRINT "bad filename": SLEEP 2: GOTO reportsmenu„„afmfile (afmfilename$)„„CLS„CLOSE„LOCATE 12, 20„PRINT "report written to "; afmfilename$„SLEEP 2„GOTO reportsmenu„„afmprint:„afmprint„GOTO reportsmenu„'***************************************************************************„monthsummary:„CLOSE„PRINT„OPEN "CATEGORY.DAT" FOR RANDOM AS #4 LEN = LEN(whatfor)„numrec = LOF(4) / LEN(whatfor)„numrec = numrec + 1„counter = 1„grandtotal# = 0             'initialize the grand total to 0„'figure the grand total...„„    WHILE counter < numrec„        FOR X = counter TO counter„            GET #4, X, whatfor„            selectedcatcode$ = whatfor.code„            selectedcatlabel$ = whatfor.label„            counter = counter + 1„            CALL calcsubtotal„    grandtotal# = grandtotal# + subtotal#„    NEXT    'finished with category?, OK, on to the next one...„WEND        'no more categories?, OK, finish the report„„sumscreen„PRINT„COLOR 13, bgc%„PRINT "                 would you like to save this report?"„PRINT„COLOR fgc%, bgc%„PRINT "                     to save to a file press F"„PRINT "              to send the report to your printer press P"„PRINT "                  press ENTER to forget all about it"„    DO„    sumchoice$ = INKEY$„    sumchoice$ = UCASE$(sumchoice$)„    IF sumchoice$ = "F" THEN GOTO sumfile„    IF sumchoice$ = "P" THEN GOTO sumprint„    IF sumchoice$ = CHR$(13) THEN GOTO reportsmenu„    LOOP„„GOTO reportsmenu„„sumfile:„CLOSE„PRINT„LINE INPUT "filename:  "; sumfilename$„'half-assed bad filename detection...„IF sumfilename$ = "" THEN BEEP: CLS : PRINT "bad filename": SLEEP 2: GOTO reportsmenu„    „sumfile (sumfilename$)„CLS„CLOSE„LOCATE 12, 20„PRINT "report written to "; sumfilename$„SLEEP 2„GOTO reportsmenu„„sumprint:„sumprint„GOTO reportsmenu„„'***************************************************************************„pcscreen:„displaycategories„getcategory„pcscreen„„PRINT„COLOR 13, bgc%„PRINT "                 would you like to save this report?"„PRINT„COLOR fgc%, bgc%„PRINT "                     to save to a file press F"„PRINT "              to send the report to your printer press P"„PRINT "                  press ENTER to forget all about it"„    DO„    pcchoice$ = INKEY$„    pcchoice$ = UCASE$(pcchoice$)„    IF pcchoice$ = "F" THEN GOTO pcfile„    IF pcchoice$ = "P" THEN GOTO pcprint„    IF pcchoice$ = CHR$(13) THEN GOTO reportsmenu„    LOOP„„pcfile:„PRINT„LINE INPUT "filename:  "; pcfilename$„IF pcfilename$ = "" THEN BEEP: CLS : PRINT "bad filename": SLEEP 2: GOTO reportsmenu„pcfile (pcfilename$)„CLS„CLOSE„LOCATE 12, 20„PRINT "report written to "; pcfilename$„SLEEP 2„GOTO reportsmenu„„pcprint:„pcprint„GOTO reportsmenu„„'************************************************************************„editing:„CLS„LOCATE 9„PRINT "                             Edit what?"„PRINT„PRINT "                             (E)ntries"„PRINT "                             (C)ategories"„PRINT "                             (Q)uit"„    DO„    editchoice$ = INKEY$„    editchoice$ = UCASE$(editchoice$)„    IF editchoice$ = "E" THEN CLS : GOTO editentries„    IF editchoice$ = "C" THEN CLS : GOTO editcategories„    IF editchoice$ = "Q" THEN CLS : GOTO top„    LOOP„„editentries:„editentries„GOTO top„„editcategories:„editcategories„GOTO top„„'************************************************************************„setup:„setupmenu:„CLS„LOCATE 9„PRINT "                  Personal Expense Recorder Set-Up Menu "„PRINT„PRINT "                        1) set name, passcode"„PRINT "                        2) add expense categories"„PRINT "                        3) set colors"„PRINT "                        M) go back to main menu"„„    DO„    setupchoice$ = INKEY$„    setupchoice$ = UCASE$(setupchoice$)„    IF setupchoice$ = "1" THEN CLS : GOTO personaldat„    IF setupchoice$ = "2" THEN CLS : GOTO categories„    IF setupchoice$ = "3" THEN CLS : CALL selectcolors: GOTO setupmenu„    IF setupchoice$ = "M" THEN CLS : GOTO top„    LOOP„„personaldat:„getpersonaldat„GOTO setupmenu„„categories:„displaycategories„PRINT„addcategories„GOTO setupmenu„GOTO top„„'************************************************************************„END„handler:„CLS„BEEP„LOCATE 12, 30„PRINT "check your printer"„SLEEP 2„CLOSE„„                            'quick fix to stop termination upon„RESUME top                  'off-line printer in the reports sections„'************************************************************************„                            'end of program„„DEFSNG A-Z„SUB addcategories„startaddcategories:„„INPUT "New Category Name      "; newlabel$„INPUT "Two-place abbreviation "; newcode$„„    IF LEN(newcode$) <> 2 THEN BEEP: GOTO startaddcategories„    newcode$ = UCASE$(newcode$)„    whatfor.label = newlabel$„    whatfor.code = newcode$„    „PRINT„PRINT "New entry confirmation: "; whatfor.code; "  "; whatfor.label„PRINT„PRINT "press ESCAPE to do over, ENTER if OK"„„    DO„    verifyaddcategorieschoice$ = INKEY$„    IF verifyaddcategorieschoice$ = CHR$(13) THEN GOTO endaddcategories„    IF verifyaddcategorieschoice$ = CHR$(27) THEN GOTO quitwithoutdoinganything„    LOOP„„endaddcategories:„OPEN "CATEGORY.DAT" FOR RANDOM AS #2 LEN = LEN(whatfor)„numrec = LOF(2) / LEN(whatfor)„numrec = numrec + 1„PUT #2, numrec, whatfor„CLOSE„PRINT„quitwithoutdoinganything:„END SUB„„DEFINT A-Z„SUB afmfile (afmfilename$)„OPEN afmfilename$ FOR OUTPUT AS #5„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„„PRINT #5, "==============================================================================="„PRINT #5, " All expenses paid by "; userid.uname; "             during: "; monthyear$„PRINT #5, "==============================================================================="„PRINT #5, ""„„'just about the same as the screen version...„OPEN "CATEGORY.DAT" FOR RANDOM AS #4 LEN = LEN(whatfor)„numrec = LOF(4) / LEN(whatfor)„numrec = numrec + 1„counter = 1„grandtotal# = 0„„WHILE counter < numrec„„    FOR X = counter TO counter„        GET #4, X, whatfor„        selectedcatcode$ = whatfor.code„        selectedcatlabel$ = whatfor.label„        counter = counter + 1„        GOTO lineitemsafmfile„nextlineitemsafmfile:„„        grandtotal# = grandtotal# + subtotal#„„    NEXT„WEND„PRINT #5, "==============================================================================="„PRINT #5, USING " Total...... $ ##,###.## "; grandtotal#;„PRINT #5, "                              Report Date: "; DATE$„PRINT #5, "==============================================================================="„GOTO endafmfile„„lineitemsafmfile:„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„„Inumrec = LOF(3) / LEN(entry)„Inumrec = Inumrec + 1„Icounter = 1„subtotal# = 0„„WHILE Icounter < Inumrec„FOR Y = Icounter TO Icounter„        GET #3, Y, entry„        IF entry.catcode = selectedcatcode$ THEN GOTO codefoundafmfile„        IF entry.catcode <> selectedcatcode$ THEN GOTO codenotfoundafmfile„codefoundafmfile:„        PRINT #5, " "; entry.day; "  "; entry.catcode;„        PRINT #5, USING "  $ ##,###.##"; entry.amount;„        PRINT #5, "  "; entry.note„        subtotal# = subtotal# + entry.amount„codenotfoundafmfile:„Icounter = Icounter + 1„NEXT„WEND„PRINT #5, ""„PRINT #5, " Sub Total "; selectedcatcode$;„PRINT #5, USING "  $ ##,###.## "; subtotal#;„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„PRINT #5, " ("; selectedcatlabel$; ")"„PRINT #5, "-------------------------------------------------------------------------------"„CLOSE 3„GOTO nextlineitemsafmfile„„endafmfile:„„END SUB„„SUB afmprint„CLOSE„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„„ON ERROR GOTO handler„„LPRINT "==============================================================================="„LPRINT " All expenses paid by "; userid.uname; "             during: "; monthyear$„LPRINT "==============================================================================="„LPRINT„linenum = 4„OPEN "CATEGORY.DAT" FOR RANDOM AS #4 LEN = LEN(whatfor)„numrec = LOF(4) / LEN(whatfor)„numrec = numrec + 1„counter = 1„grandtotal# = 0„„WHILE counter < numrec„„    FOR X = counter TO counter„        GET #4, X, whatfor„        selectedcatcode$ = whatfor.code„        selectedcatlabel$ = whatfor.label„        counter = counter + 1„        linenum = linenum + 1„        GOTO afmprintlineitems„nextafmprintlineitems:„IF linenum > screenfull + 40 THEN„    LPRINT CHR$(12)„    linenum = 0„    ELSE„    END IF„    grandtotal# = grandtotal# + subtotal#„    NEXT„WEND„LPRINT "==============================================================================="„LPRINT USING " Total...... $ ##,###.## "; grandtotal#;„LPRINT "                              Report Date: "; DATE$„LPRINT "==============================================================================="„LPRINT CHR$(12)„GOTO endafmprint„„afmprintlineitems:„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„„Inumrec = LOF(3) / LEN(entry)„Inumrec = Inumrec + 1„Icounter = 1„subtotal# = 0„„WHILE Icounter < Inumrec„FOR Y = Icounter TO Icounter„        GET #3, Y, entry„        IF entry.catcode = selectedcatcode$ THEN GOTO codefoundafmprint„        IF entry.catcode <> selectedcatcode$ THEN GOTO codenotfoundafmprint„codefoundafmprint:„        LPRINT " "; entry.day; "  "; entry.catcode;„        LPRINT USING "  $ ##,###.##"; entry.amount;„        LPRINT "  "; entry.note„        linenum = linenum + 1„        subtotal# = subtotal# + entry.amount„codenotfoundafmprint:„Icounter = Icounter + 1„„IF linenum > screenfull + 40 THEN„    LPRINT CHR$(12)„    linenum = 0„    ELSE„    END IF„„NEXT„WEND„LPRINT„LPRINT " Sub Total "; selectedcatcode$;„LPRINT USING "  $ ##,###.## "; subtotal#;„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„LPRINT " ("; selectedcatlabel$; ")"„LPRINT "-------------------------------------------------------------------------------"„linenum = linenum + 3„CLOSE 3„GOTO nextafmprintlineitems„„endafmprint:„END SUB„„SUB afmscreen„CLOSE„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„„PRINT "==============================================================================="„PRINT " All expenses paid by "; userid.uname; "             during: "; monthyear$„PRINT "==============================================================================="„PRINT„linenum = linenum + 4       'there are four lines right there...„CLOSE„„'we will now get each category code in turn, and display all the entries„'that are associated with each code...„OPEN "CATEGORY.DAT" FOR RANDOM AS #4 LEN = LEN(whatfor)„numrec = LOF(4) / LEN(whatfor)„numrec = numrec + 1„counter = 1„grandtotal# = 0             'initialize the grand total to 0„„    WHILE counter < numrec„        FOR X = counter TO counter„            GET #4, X, whatfor„            selectedcatcode$ = whatfor.code„            selectedcatlabel$ = whatfor.label„            counter = counter + 1„            GOTO afmslineitems       'go and show the line items...„nextafmslineitems:„        IF linenum > screenfull THEN    'if so many lines have been displayed„                                    'on screen then stop and re-set counter„            PRINT„            COLOR 13, bgc%„            PRINT " press any key to continue": Halt$ = INPUT$(1)„            COLOR fgc%, bgc%„            linenum = 0             '(re-set counter)„            ELSE                    'if linenum is not greater than screenfull„        END IF                      'then never mind„„        grandtotal# = grandtotal# + subtotal#„„    NEXT    'finished with category?, OK, on to the next one...„WEND        'no more categories?, OK, finish the report„        IF linenum > screenfull THEN    'if so many lines have been displayed„                                    'on screen then stop and re-set counter„            PRINT„            COLOR 13, bgc%„            PRINT " press any key to continue": Halt$ = INPUT$(1)„            COLOR fgc%, bgc%„            linenum = 0             '(re-set counter)„            ELSE                    'if linenum is not greater than screenfull„        END IF                      'then never mind„„PRINT "==============================================================================="„PRINT USING " Total...... $ ##,###.## "; grandtotal#;„PRINT "                              Report Date: "; DATE$„PRINT "==============================================================================="„„PRINT„COLOR 13, bgc%„PRINT " press any key to continue": Halt$ = INPUT$(1)„GOTO endafms„„afmslineitems:       'go and show the line items...„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„„Inumrec = LOF(3) / LEN(entry)„Inumrec = Inumrec + 1„Icounter = 1„subtotal# = 0„„WHILE Icounter < Inumrec„FOR Y = Icounter TO Icounter„        GET #3, Y, entry„        IF entry.catcode = selectedcatcode$ THEN GOTO codefoundapm„        IF entry.catcode <> selectedcatcode$ THEN GOTO codenotfoundapm„codefoundapm:„        PRINT " "; entry.day; "  "; entry.catcode;„        PRINT USING "  $ ##,###.##"; entry.amount;„        PRINT "  "; entry.note„        linenum = linenum + 1„        subtotal# = subtotal# + entry.amount„codenotfoundapm:„Icounter = Icounter + 1„IF linenum > screenfull THEN„    PRINT„    COLOR 13, bgc%„    PRINT " press any key to continue": Halt$ = INPUT$(1)„    COLOR fgc%, bgc%„    linenum = 0„    END IF„„NEXT„WEND„PRINT„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„PRINT " Sub Total "; selectedcatcode$;„PRINT USING "  $ ##,###.## "; subtotal#;„PRINT " ("; selectedcatlabel$; ")"„COLOR 14, bgc%„PRINT "-------------------------------------------------------------------------------"„COLOR fgc%, bgc%„linenum = linenum + 3„CLOSE 3„„GOTO nextafmslineitems„endafms:„END SUB„„SUB background (character%)„FOR X = 1 TO 25                             'these statements„    LOCATE X, 1                             'place a background„    PRINT STRING$(80, CHR$(character%));    'of ASCII characters„    NEXT                                    'on the screen„„END SUB„„SUB calcsubtotal„SHARED selectedcatcode$„SHARED selectedcatlabel$„SHARED subtotal#„„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„numrec = LOF(3) / LEN(entry)„numrec = numrec + 1„counter = 1„subtotal# = 0„„WHILE counter < numrec„FOR X = counter TO counter„        GET #3, X, entry„        IF entry.catcode = selectedcatcode$ THEN GOTO codefoundct„        IF entry.catcode <> selectedcatcode$ THEN GOTO codenotfoundct„„codefoundct:„subtotal# = subtotal# + entry.amount„„codenotfoundct:„counter = counter + 1„„NEXT„WEND„CLOSE #3„END SUB„„DEFSNG A-Z„SUB displaycategories„OPEN "CATEGORY.DAT" FOR RANDOM AS #2 LEN = LEN(whatfor)„numrec = LOF(2) / LEN(whatfor)„numrec = numrec + 1„counter = 1„col = 2„COLOR 14, bgc%„PRINT " Code  Name            Code  Name            Code  Name"„COLOR fgc%, bgc%„PRINT„WHILE counter < numrec„FOR X = counter TO counter + 1„    GET #2, X, whatfor„    counter = counter + 1„    PRINT TAB(col); whatfor.code; "   "; whatfor.label; " ";„        IF col <= 46 THEN col = col + 22        'does three„        IF col > 46 THEN col = 2: PRINT " "     'columns of categories„NEXT„„WEND„CLOSE„PRINT„„END SUB„„DEFINT A-Z„SUB drawborder (UpRow, LeftCol, BotRow, RtCol, bgc%)„„    'draw the top of the border„    LOCATE UpRow, LeftCol„    PRINT CHR$(213) + STRING$(((RtCol - LeftCol) - 1), CHR$(205)) + CHR$(184)„„    'draw the sides of the border„    FOR i = (UpRow + 1) TO (BotRow - 1)„      LOCATE i, LeftCol„      PRINT CHR$(179) + STRING$(((RtCol - LeftCol) - 1), CHR$(32)) + CHR$(179)„    NEXT„„    'draw the bottom of the border„    LOCATE BotRow, LeftCol„    PRINT CHR$(212) + STRING$(((RtCol - LeftCol) - 1), CHR$(205)) + CHR$(190)„„END SUB„„SUB editcategories„CLOSE„„OPEN "category.dat" FOR RANDOM AS #3 LEN = LEN(whatfor)„numrec = LOF(3) / LEN(whatfor)„numrec = numrec + 1„counter = 1„linenum = 0„PRINT„WHILE counter < numrec„FOR X = counter TO counter„        GET #3, X, whatfor„        linenum = linenum + 1„            IF linenum > screenfull THEN„            PRINT„            linenum = 0„            COLOR 13, bgc%„            INPUT " item # to edit + ENTER, or ENTER to continue ", edit%„                SELECT CASE edit%„                CASE IS > numrec„                    BEEP„                    CLS : LOCATE 12, 35„                    PRINT "no such record": SLEEP 2„                    CLOSE : GOTO endeditcat„                CASE IS < 0„                    BEEP„                    CLS : LOCATE 12, 35„                    PRINT "no such record": SLEEP 2„                    CLOSE : GOTO endeditcat„                'CASE IS = 0„„                CASE ELSE„                    GOTO ReplaceOldCat„„                END SELECT„            COLOR fgc%, bgc%„            END IF„        PRINT "#"; counter; TAB(7); whatfor.label; "  "; whatfor.code„counter = counter + 1„NEXT„WEND„PRINT„COLOR 13, bgc%„„INPUT " item # to edit + ENTER, or ENTER to forget it ", edit%„                SELECT CASE edit%„                CASE IS > numrec„                BEEP„                    CLS : LOCATE 12, 35„                    PRINT "no such record": SLEEP 2„                    CLOSE : GOTO endeditcat„                CASE IS = 0„                    CLOSE„                    GOTO endeditcat„                CASE ELSE„                    GOTO ReplaceOldCat„„                END SELECT„COLOR fgc%, bgc%„ReplaceOldCat:„CLS„PRINT„GET #3, edit%, whatfor„LOCATE 20„COLOR 11, bgc%„        PRINT " OLD ->     ";„        PRINT " "; whatfor.label; "  "; whatfor.code„LOCATE 1, 1„„COLOR fgc%, bgc%„INPUT "New Category Name      "; newlabel$„INPUT "Two-place abbreviation "; newcode$„„    IF LEN(newcode$) <> 2 THEN„        BEEP„        PRINT "Bad code": SLEEP 1„        GOTO endeditcat„        END IF„    newcode$ = UCASE$(newcode$)„    whatfor.label = newlabel$„    whatfor.code = newcode$„„LOCATE 21„COLOR 14, bgc%„„    PRINT " NEW ->     ";„        PRINT " "; whatfor.label; "  "; whatfor.code„PRINT„COLOR 14, bgc%„PRINT " Is all this OK? (Y/N/Q) "„„    DO„    newentryconf$ = INKEY$„    newentryconf$ = UCASE$(newentryconf$)„    IF newentryconf$ = "Y" THEN GOTO recordeditedcat„    IF newentryconf$ = "N" THEN CLOSE : GOTO endeditcat    'start over„    IF newentryconf$ = "Q" THEN CLOSE : GOTO endeditcat      'never mind, forget it„    LOOP„„recordeditedcat:„PUT #3, edit%, whatfor„CLOSE 3„endeditcat:„END SUB„„SUB editentries„selectfile„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„numrec = LOF(3) / LEN(entry)„numrec = numrec + 1„counter = 1„linenum = 0„PRINT„WHILE counter < numrec„FOR X = counter TO counter„        GET #3, X, entry„        linenum = linenum + 1„            IF linenum > screenfull THEN„            PRINT„            linenum = 0„            COLOR 13, bgc%„            INPUT " item # to edit + ENTER, or ENTER to continue ", edit%„                SELECT CASE edit%„                CASE IS > numrec„                    BEEP„                    CLS : LOCATE 12, 35„                    PRINT "no such record": SLEEP 2„                    CLOSE : GOTO endeditentries„                CASE IS < 0„                    BEEP„                    CLS : LOCATE 12, 35„                    PRINT "no such record": SLEEP 2„                    CLOSE : GOTO endeditentries„                CASE IS = 0„„                CASE ELSE„                    GOTO ReplaceOldEntry„„                END SELECT„            COLOR fgc%, bgc%„            END IF„        PRINT "#"; counter; TAB(7); entry.day; "  "; entry.catcode;„        PRINT USING "  $ ##,###.##"; entry.amount;„        PRINT "  "; entry.note„counter = counter + 1„NEXT„WEND„PRINT„COLOR 13, bgc%„INPUT " item # to edit + ENTER, or ENTER to forget it ", edit%„                SELECT CASE edit%„                CASE IS > numrec„                BEEP„                    CLS : LOCATE 12, 35„                    PRINT "no such record": SLEEP 2„                    CLOSE : GOTO endeditentries„                CASE IS = 0„                    CLOSE„                    GOTO endeditentries„                END SELECT„COLOR fgc%, bgc%„ReplaceOldEntry:„CLS„PRINT„GET #3, edit%, entry„LOCATE 20„COLOR 11, bgc%„        PRINT " OLD ->     ";„        PRINT " "; entry.day; "  "; entry.catcode;„        PRINT USING "  $ ##,###.##"; entry.amount;„        PRINT "  "; entry.note;„LOCATE 1, 1„„COLOR fgc%, bgc%„getday                          'get the day within the selected month„getcategory„getamount                       'get the amount of money (negetive is OK)„getnote                         'get the note about the expense„„LOCATE 21„COLOR 14, bgc%„„    PRINT " NEW ->     ";„        PRINT " "; entry.day; "  "; entry.catcode;„        PRINT USING "  $ ##,###.##"; entry.amount;„        PRINT "  "; entry.note„PRINT„COLOR 14, bgc%„PRINT " Is all this OK? (Y/N/Q) "„„    DO„    newentryconf$ = INKEY$„    newentryconf$ = UCASE$(newentryconf$)„    IF newentryconf$ = "Y" THEN GOTO recordeditedentry„    IF newentryconf$ = "N" THEN CLOSE : GOTO endeditentries    'start over„    IF newentryconf$ = "Q" THEN CLOSE : GOTO endeditentries      'never mind, forget it„    LOOP„„recordeditedentry:„PUT #3, edit%, entry„CLOSE 3„„endeditentries:„END SUB„„DEFSNG A-Z„SUB getamount„„INPUT " Amount............ : $", entry.amount„„END SUB„„SUB getcategory„SHARED selectedcat$„startgetcategory:„PRINT„LINE INPUT " Enter Category Code: "; selectedcat$„selectedcat$ = UCASE$(selectedcat$)„entry.catcode = selectedcat$„„OPEN "CATEGORY.DAT" FOR RANDOM AS #2 LEN = LEN(whatfor)„numrec = LOF(2) / LEN(whatfor)„totalrec = numrec„numrec = numrec + 1„counter = 1„„WHILE counter < numrec„FOR X = counter TO counter + 1„    GET #2, X, whatfor„    counter = counter + 1„    IF whatfor.code = entry.catcode THEN GOTO goodcat„    IF counter > totalrec THEN CLOSE 2: BEEP: GOTO startgetcategory„NEXT„WEND„„goodcat:„CLOSE 2„END SUB„„SUB getday„LOCATE 1„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "-" + year$„„thisday$ = MID$(DATE$, 4, 2)„thisday$ = month$ + "-" + thisday$ + "-" + year$„„PRINT " Date of Expense..."; thisday$; "     type new DAY, or ENTER to accept date shown"„LOCATE 1, 23„LINE INPUT newday$„    IF newday$ = "" THEN GOTO todayisfine„    IF VAL(newday$) > 31 THEN BEEP: PRINT "invalid day": GOTO trydayagain„    IF LEN(newday$) <> 2 THEN BEEP: PRINT "invalid day": GOTO trydayagain„„entry.day = month$ + "-" + newday$ + "-" + year$„GOTO donewithday„„trydayagain:„SLEEP 2„CLS„PRINT " Date of Expense..."; thisday$; "     type new DAY, or ENTER to accept date shown"„LOCATE 1, 23„LINE INPUT newday$„    IF newday$ = "" THEN GOTO todayisfine„    IF VAL(newday$) > 31 THEN BEEP: PRINT "invalid day": GOTO trydayagain„    IF LEN(newday$) <> 2 THEN BEEP: PRINT "invalid day": GOTO trydayagain„„entry.day = month$ + "-" + newday$ + "-" + year$„GOTO donewithday„„todayisfine:„entry.day = thisday$„„donewithday:„END SUB„„SUB getnote„LINE INPUT " Note...............: "; entry.note„END SUB„„SUB getpass„„passtry = 0„OPEN "PERSONAL.DAT" FOR RANDOM AS #1 LEN = LEN(userid)„„GET #1, 1, userid                               'get the previously recorded„passcode:                                       'passcode from PERSONAL.DAT„LOCATE 12, 26„PRINT "passcode please";„COLOR 0, 0                                      'hide the code being entered„INPUT try„IF try = userid.passcode THEN CLOSE : GOTO ok„IF try <> userid.passcode THEN BEEP: GOTO notOK„„notOK:„passtry = passtry + 1„LOCATE 14, 10„COLOR 7, 0„„PRINT "Invalid passcode. If none has been set yet, try ENTER "„SLEEP 3„CLS„IF passtry < 3 THEN GOTO passcode„CLS„COLOR 14, 12„LOCATE 12, 20„PRINT " Sorry. (Three strikes and 'yer OUT!) "„COLOR 7, 0„CLOSE„SLEEP 3: CLS : END„„ok:                         'if passcode is lost, delete the„                            'file PERSONAL.DAT, and use the ENTER„„IF userid.bgc = 0 AND userid.fgc = 0 THEN   'if there is no PERSONAL.DAT„    bgc% = 1: fgc% = 15                     'file, then the colors will be„                                            '0,0. This changes them to 1,15„    ELSE„    bgc% = userid.bgc                       'if there is a PERSONAL.DAT file„    fgc% = userid.fgc                       'then get *those* colors„    END IF„„END SUB„„SUB getpersonaldat„startgpd:„„CLOSE„OPEN "PERSONAL.DAT" FOR RANDOM AS #1 LEN = LEN(userid)„PRINT "Current User name: "; userid.uname„PRINT "Current passcode : "; userid.passcode„PRINT„INPUT "New User name    : ", userid.uname„INPUT "New passcode     : ", userid.passcode„„PUT #1, 1, userid„CLOSE„END SUB„„DEFINT A-Z„SUB line25„LOCATE 25, 1„PRINT STRING$(80, CHR$(219));„COLOR fgc%, bgc%„LOCATE 25, 1: PRINT "       "; : PRINT CHR$(16); " For: "; userid.uname; : PRINT "    "; DATE$; "             "; CHR$(17); : PRINT "        ";„END SUB„„SUB pcfile (pcfilename$)„SHARED selectedcat$„OPEN pcfilename$ FOR OUTPUT AS #5„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„OPEN "PERSONAL.DAT" FOR RANDOM AS #4„PRINT #5, "==============================================================================="„PRINT #5, " Expenses paid by "; userid.uname; "                 during: "; monthyear$„PRINT #5, " For category "; selectedcat$; " ONLY"„PRINT #5, "==============================================================================="„CLOSE 4„„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„CLS„numrec = LOF(3) / LEN(entry)„numrec = numrec + 1„counter = 1„total# = 0„PRINT #5,„WHILE counter < numrec„FOR X = counter TO counter„        GET #3, X, entry„        IF entry.catcode = selectedcat$ THEN GOTO pcfcodefound„        IF entry.catcode <> selectedcat$ THEN GOTO pcfcodenotfound„pcfcodefound:„        PRINT #5, " "; entry.day; "  "; entry.catcode;„        PRINT #5, USING "  $ ##,###.##"; entry.amount;„        PRINT #5, "  "; entry.note„        total# = total# + entry.amount„pcfcodenotfound:„counter = counter + 1„NEXT„WEND„PRINT #5,„PRINT #5, "==============================================================================="„PRINT #5, " Total for "; selectedcat$;„PRINT #5, USING ": $ ##,###.## "; total#;„PRINT #5, "                            Report Date: "; DATE$„PRINT #5, "==============================================================================="„CLOSE 3„„END SUB„„SUB pcprint„SHARED selectedcat$„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„OPEN "PERSONAL.DAT" FOR RANDOM AS #4„ON ERROR GOTO handler„LPRINT "==============================================================================="„LPRINT " Expenses paid by "; userid.uname; "                 during: "; monthyear$„LPRINT " For category "; selectedcat$; " ONLY"„LPRINT "==============================================================================="„CLOSE 4„„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„„numrec = LOF(3) / LEN(entry)„numrec = numrec + 1„counter = 1„total# = 0„linenumber = 0„LPRINT„WHILE counter < numrec„FOR X = counter TO counter„        GET #3, X, entry„        IF entry.catcode = selectedcat$ THEN GOTO pccodefound„        IF entry.catcode <> selectedcat$ THEN GOTO pccodenotfound„pccodefound:„        LPRINT " "; entry.day; "  "; entry.catcode;„        LPRINT USING "  $ ##,###.##"; entry.amount;„        LPRINT "  "; entry.note„        total# = total# + entry.amount„        linenumber = linenumber + 1„        IF linenumber = 50 THEN linenumber = 0: LPRINT " continued...": LPRINT CHR$(12)„pccodenotfound:„counter = counter + 1„NEXT„WEND„LPRINT„LPRINT "==============================================================================="„LPRINT " Total for "; selectedcat$;„LPRINT USING ": $ ##,###.## "; total#;„LPRINT "                            Report Date: "; DATE$„LPRINT "==============================================================================="„CLOSE 3„LPRINT CHR$(12)„END SUB„„SUB pcscreen„SHARED selectedcat$„„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„CLS„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„„PRINT "==============================================================================="„PRINT " Expenses paid by "; userid.uname; "                 during: "; monthyear$„PRINT " For category "; selectedcat$; " ONLY"„PRINT "==============================================================================="„linenum = 5„„numrec = LOF(3) / LEN(entry)„numrec = numrec + 1„counter = 1„total# = 0„PRINT„WHILE counter < numrec„FOR X = counter TO counter„        GET #3, X, entry„        IF entry.catcode = selectedcat$ THEN GOTO codefound„        IF entry.catcode <> selectedcat$ THEN GOTO codenotfound„codefound:„        PRINT " "; entry.day; "  "; entry.catcode;„        PRINT USING "  $ ##,###.##"; entry.amount;„        PRINT "  "; entry.note„        total# = total# + entry.amount„        linenum = linenum + 1„            IF linenum > screenfull THEN„            PRINT„            linenum = 0„            COLOR 13, bgc%„            PRINT " press any key to continue": Halt$ = INPUT$(1)„            COLOR fgc%, bgc%„            END IF„„codenotfound:„counter = counter + 1„NEXT„WEND„            IF linenum > screenfull THEN„            PRINT„            linenum = 0„            COLOR 13, bgc%„            PRINT " press any key to continue": Halt$ = INPUT$(1)„            COLOR fgc%, bgc%„            END IF„„PRINT„PRINT "==============================================================================="„PRINT " Total for "; selectedcat$;„PRINT USING ": $ ##,###.## "; total#;„PRINT "                            Report Date: "; DATE$„PRINT "==============================================================================="„CLOSE 3„PRINT„COLOR 13, bgc%„PRINT " press any key to continue": Halt$ = INPUT$(1)„„END SUB„„SUB perhelp (topic$)„'Obviously I was originaly planning on having a lot of on-line help text.„'However, it's a pain in the ass writing all this stuff, and I'm tired of„'fooling with it. I'll do the readme file, but that's it! <bg>„„IF topic$ = "main" THEN„PRINT„PRINT " The Personal Expense Recorder program is intended as an easy-to-use, simple"„PRINT " means to record one's day-to-day expenses. This is the QBasic version .12"„PRINT„PRINT " See the file README.PER for full instructions."„PRINT„PRINT " Expenses are recorded in monthly data files, according to category. The "„PRINT " files are named in the format [MMYY]QPER.DAT. You should back these files up "„PRINT " from time to time."„PRINT„PRINT " The first thing to do is go to Set-Up from the main menu. I would suggest "„PRINT " setting up a few test categories, and then running the program through its"„PRINT " various functions to get a feel for it. Once you see how it works, go to "„PRINT " DOS and delete all the .DAT files, and then start over for real."„PRINT„PRINT " Thanks for helping to test this program. All future versions will use"„PRINT " the same data files as this prototype version, so go ahead and use it."„PRINT„PRINT " PER is by Dave Gjessing (dgjess@freenet.columbus.oh.us). It is freeware."„PRINT " However, any comercial use is prohibited, without prior written consent"„PRINT " from the author. Copyright Dave Gjessing 1995. All rights reserved."„PRINT„„    COLOR 13, bgc%„    PRINT " press any key to continue"; : Halt$ = INPUT$(1)„    'COLOR fgc%, bgc%„    END IF„END SUB„„DEFSNG A-Z„SUB selectcolors„colortop:„CLS„PRINT "Currently, your colors are:"„PRINT "background "; bgc%„PRINT "foreground "; fgc%„PRINT„PRINT "0 - Black     4 - Red         8 - Dark Grey    12 - Light Red"„PRINT "1 - Blue      5 - Magenta     9 - Light Blue   13 - Light Magenta"„PRINT "2 - Green     6 - Brown      10 - Light Green  14 - Yellow"„PRINT "3 - Cyan      7 - White      11 - Light Cyan   15 - Bright White"„PRINT„PRINT "To see what the various combinations look like, indicate"„PRINT "a foreground and a background number below:"„PRINT„„   PRINT "background ";„   INPUT bgc%„   PRINT„   PRINT "foreground ";„   INPUT fgc%„   PRINT„   COLOR fgc%, bgc%„IF bgc% = fgc% THEN     'if user screws up, set colors to default„    BEEP: CLS„    fgc% = 15„    bgc% = 1„    COLOR fgc%, bgc%„    PRINT "You are trying to make the BG the same as the FG! - that's no good."„    GOTO colortop„    END IF„„userid.fgc = fgc%„userid.bgc = bgc%„„OPEN "PERSONAL.DAT" FOR RANDOM AS #1 LEN = LEN(userid)„PUT #1, 1, userid„CLOSE„„END SUB„„SUB selectfile„startselectfile:„CLS„„current$ = DATE$„month$ = LEFT$(current$, 2)„year$ = RIGHT$(current$, 2)„currentfileid$ = month$ + year$„currentfilename$ = currentfileid$ + "QPER.DAT"„CALL drawborder(9, 8, 15, 72, bgc%) 'draw the box around the menu„„LOCATE 10, 20„PRINT "The current month's data file would be... "„COLOR 14, bgc%„LOCATE 12, 33„PRINT currentfilename$„COLOR fgc%, bgc%„LOCATE 14, 13„PRINT "ESCAPE to name another file, ENTER to accept this file"„„    DO„    selectfilechoice$ = INKEY$„    IF selectfilechoice$ = CHR$(13) THEN GOTO current„    IF selectfilechoice$ = CHR$(27) THEN GOTO other„    LOOP„„current:„workfilename$ = currentfilename$„GOTO endselectfile„„other:„PRINT„INPUT "                     month and year you want (MMYY) "; otherfile$„    IF LEN(otherfile$) <> 4 THEN BEEP: CLS : GOTO startselectfile„    proposedmonth$ = LEFT$(otherfile$, 2)„    proposedmonth = VAL(proposedmonth$)„    IF proposedmonth > 12 THEN BEEP: CLS : GOTO startselectfile„„workfilename$ = otherfile$ + "QPER.DAT"„„verifyselectfile:„CLS„LOCATE 9„PRINT "                             You have picked..."„PRINT„COLOR 14, bgc%„PRINT "                               "; workfilename$„PRINT„COLOR fgc%, bgc%„PRINT "                            as the working file."„PRINT„PRINT "                       ESCAPE to do over, ENTER if OK"„„    DO„    verifyselectfilechoice$ = INKEY$„    IF verifyselectfilechoice$ = CHR$(13) THEN GOTO endselectfile„    IF verifyselectfilechoice$ = CHR$(27) THEN GOTO startselectfile„    LOOP„ „endselectfile:„CLS„END SUB„„DEFINT A-Z„SUB sumfile (sumfilename$)„CLOSE„„SHARED grandtotal#„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„„OPEN sumfilename$ FOR OUTPUT AS #5„PRINT #5, "==============================================================================="„PRINT #5, " Summary of expenses paid by "; userid.uname; "      during: "; monthyear$„PRINT #5, "==============================================================================="„PRINT #5, ""„„OPEN "CATEGORY.DAT" FOR RANDOM AS #4 LEN = LEN(whatfor)„numrec = LOF(4) / LEN(whatfor)„numrec = numrec + 1„counter = 1„„    WHILE counter < numrec„        FOR X = counter TO counter„            GET #4, X, whatfor„            selectedcatcode$ = whatfor.code„            selectedcatlabel$ = whatfor.label„            counter = counter + 1„            GOTO lineitemssumfile„nextlineitemssumfile:„        NEXT    'finished with category?, OK, on to the next one...„WEND        'no more categories?, OK, finish the report„PRINT #5, ""„PRINT #5, "==============================================================================="„PRINT #5, USING " Total...... $ ##,###.## "; grandtotal#;„PRINT #5, "                              Report Date: "; DATE$„PRINT #5, "==============================================================================="„GOTO endsumfile„„lineitemssumfile:„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„„Inumrec = LOF(3) / LEN(entry)„Inumrec = Inumrec + 1„Icounter = 1„subtotal# = 0„„WHILE Icounter < Inumrec„FOR Y = Icounter TO Icounter„        GET #3, Y, entry„        IF entry.catcode = selectedcatcode$ THEN GOTO codefoundsumfile„        IF entry.catcode <> selectedcatcode$ THEN GOTO codenotfoundsumfile„„codefoundsumfile:„subtotal# = subtotal# + entry.amount„„codenotfoundsumfile:„Icounter = Icounter + 1„„NEXT„WEND„percentage# = subtotal# / grandtotal#„percentage# = percentage# * 100„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„pad = 16 - LEN(selectedcatlabel$) + 1„PRINT #5, " "; selectedcatlabel$; STRING$(pad, CHR$(46)); " |";„PRINT #5, USING " ###.## %"; percentage#;„PRINT #5, " | "; STRING$(33, CHR$(46));„PRINT #5, USING "  $ ##,###.## "; subtotal#„„CLOSE 3„„GOTO nextlineitemssumfile„endsumfile:„END SUB„„SUB sumprint„CLOSE„„SHARED grandtotal#„ON ERROR GOTO handler„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„„LPRINT "==============================================================================="„LPRINT " Summary of expenses paid by "; userid.uname; "      during: "; monthyear$„LPRINT "==============================================================================="„LPRINT„CLOSE„OPEN "CATEGORY.DAT" FOR RANDOM AS #4 LEN = LEN(whatfor)„numrec = LOF(4) / LEN(whatfor)„numrec = numrec + 1„counter = 1„„    WHILE counter < numrec„        FOR X = counter TO counter„            GET #4, X, whatfor„            selectedcatcode$ = whatfor.code„            selectedcatlabel$ = whatfor.label„            counter = counter + 1„            GOTO lineitemssumprint„nextlineitemssumprint:„„            linenum = linenum + 1„    NEXT    'finished with category?, OK, on to the next one...„WEND        'no more categories?, OK, finish the report„LPRINT„LPRINT "==============================================================================="„LPRINT USING " Total...... $ ##,###.## "; grandtotal#;„LPRINT "                              Report Date: "; DATE$„LPRINT "==============================================================================="„LPRINT CHR$(12)„GOTO endsumprint„„lineitemssumprint:„„„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„„Inumrec = LOF(3) / LEN(entry)„Inumrec = Inumrec + 1„Icounter = 1„subtotal# = 0„„WHILE Icounter < Inumrec„FOR Y = Icounter TO Icounter„        GET #3, Y, entry„        IF entry.catcode = selectedcatcode$ THEN GOTO codefoundsumprint„        IF entry.catcode <> selectedcatcode$ THEN GOTO codenotfoundsumprint„„codefoundsumprint:„subtotal# = subtotal# + entry.amount„„codenotfoundsumprint:„Icounter = Icounter + 1„„NEXT„WEND„percentage# = subtotal# / grandtotal#„percentage# = percentage# * 100„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„pad = 16 - LEN(selectedcatlabel$) + 1„LPRINT " "; selectedcatlabel$; STRING$(pad, CHR$(46)); " |";„LPRINT USING " ###.## %"; percentage#;„LPRINT " | "; STRING$(33, CHR$(46));„LPRINT USING "  $ ##,###.## "; subtotal#„„CLOSE 3„GOTO nextlineitemssumprint„endsumprint:„„END SUB„„SUB sumscreen„CLOSE„„SHARED grandtotal#„    month$ = LEFT$(workfilename$, 2)„    year$ = MID$(workfilename$, 3, 2)„    monthyear$ = month$ + "/" + year$„CLOSE„„„PRINT "==============================================================================="„PRINT " Summary of expenses paid by "; userid.uname; "      during: "; monthyear$„PRINT "==============================================================================="„PRINT„linenum = 4      'there are four lines right there...„CLOSE„OPEN "CATEGORY.DAT" FOR RANDOM AS #4 LEN = LEN(whatfor)„numrec = LOF(4) / LEN(whatfor)„numrec = numrec + 1„counter = 1„„    WHILE counter < numrec„        FOR X = counter TO counter„            GET #4, X, whatfor„            selectedcatcode$ = whatfor.code„            selectedcatlabel$ = whatfor.label„            counter = counter + 1„            GOTO lineitemssumscreen„nextlineitemssumscreen:„„            linenum = linenum + 1„        IF linenum > screenfull THEN„            PRINT„            COLOR 13, bgc%„            PRINT " press any key to continue": Halt$ = INPUT$(1)„            COLOR fgc%, bgc%„            linenum = 0             '(re-set counter)„            ELSE                    'if linenum is not greater than screenfull„        END IF                      'then never mind„„    NEXT    'finished with category?, OK, on to the next one...„WEND        'no more categories?, OK, finish the report„IF linenum > screenfull THEN SLEEP„„PRINT„PRINT "==============================================================================="„PRINT USING " Total...... $ ##,###.## "; grandtotal#;„PRINT "                              Report Date: "; DATE$„PRINT "==============================================================================="„„PRINT„COLOR 13, bgc%„PRINT " press any key to continue": Halt$ = INPUT$(1)„GOTO endsumscreen„„lineitemssumscreen:„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„OPEN workfilename FOR RANDOM AS #3 LEN = LEN(entry)„„Inumrec = LOF(3) / LEN(entry)„Inumrec = Inumrec + 1„Icounter = 1„subtotal# = 0„„WHILE Icounter < Inumrec„FOR Y = Icounter TO Icounter„        GET #3, Y, entry„        IF entry.catcode = selectedcatcode$ THEN GOTO codefoundsum„        IF entry.catcode <> selectedcatcode$ THEN GOTO codenotfoundsum„„codefoundsum:„subtotal# = subtotal# + entry.amount„„codenotfoundsum:„Icounter = Icounter + 1„„NEXT„WEND„percentage# = subtotal# / grandtotal#„percentage# = percentage# * 100„selectedcatlabel$ = RTRIM$(selectedcatlabel$)„pad = 16 - LEN(selectedcatlabel$) + 1„PRINT " "; selectedcatlabel$; STRING$(pad, CHR$(46)); " |";„PRINT USING " ###.## %"; percentage#;„PRINT " | "; STRING$(33, CHR$(46));„PRINT USING "  $ ##,###.## "; subtotal#„„CLOSE 3„GOTO nextlineitemssumscreen:„„endsumscreen:„END SUB„„Raymond Joh                    PASSWORD ENTRY                 Dslayer@gnn.com                12-02-95 (00:00)       QB, QBasic, PDS        102  4395     PASSWORD.BAS' This file was created and runs on QBasic.Let it be known that it is now„' donated to the Public Domain.„' Author:Raymond Joh„' All Comments and some flames welcomed„' Dslayer@gnn.com„DECLARE SUB MESSAGEWINDOW ()„DECLARE SUB GRAPHICS ()„'                   ###################################„'                   ##  === Password Entry Code ===  ##„'                   ###################################„SCREEN 12                                'SCREEN MODE OF CHOICE BY AUTHOR„GRAPHICS                                 'LOADS BACKGROUND AND BORDER„MESSAGEWINDOW                            'LOADS EMPTY MESSAGE WINDOW„100                                      'RESETS USER ENTRY BOX„P% = 39                                  'SETS LINE POSITION FOR LOCATE CALLS„P1% = P%                                 'REMEBERS ORIGINAL LINE POSITION„'                     ##############################„'                     ##  MESSAGE BOX FIXED TEXT  ##„'                     ##############################„LOCATE 16, P%: COLOR 7: PRINT "THIS SYSTEM IS A           "    'ENTER„LOCATE 17, P%: COLOR 15: PRINT "    COMPUTER SOLUTIONS     "   ' YOUR„LOCATE 18, P%: COLOR 7: PRINT "         SECURE SITE       "    '  DESIRED„LOCATE 19, P%: COLOR 12: PRINT " ========================  "   ' TEXT„LOCATE 20, P%: COLOR 7: PRINT "PLEASE ENTER YOUR PASSWORD "    'HERE„'                     ##############################„'                     ##  ENTER PROGRAM PASSWORD  ##„'                     ##############################„PASSWORD$ = "GUEST"„'„PASS$ = ""                               'DEFINES BEGINNING PASSWORD STATE„DO„  DO                                           '  LOOP„    CHAR$ = INKEY$                             '    FOR„  LOOP UNTIL CHAR$ <> ""                       '      INKEY$„  IF CHAR$ = CHR$(8) THEN                      'IF <BS> KEY PRESSED„    PLEN = LEN(PASS$) - 1                      'ADJUST POSITION LENGTH„    IF LEN(PASS$) = 0 THEN PLEN = 0: P% = P1%  'BACKSTOP FOR <BS> ENTRY„    PASS$ = LEFT$(PASS$, PLEN)                 'TRIM PASSWORD STRING„    P% = P% - 1                                'RESET LINE POSTION„    LOCATE 22, P% + 10: COLOR 15: PRINT " "    'REMOVE "X" PLACEHOLDER„  ELSEIF CHAR$ <> CHR$(13) THEN                'ENTER PRESSED ???„    IF P% = 47 THEN                            'SET PASSWORD LENGTH @ 8„      P% = P% - 1                              'STOP LINE INCREMENT„      PASS$ = PASS$                            'FREEZE PASS$„    ELSEIF P% < 47 THEN                        'PASSWORD WITHIN RANGE„      PASS$ = PASS$ + CHAR$                    'ADD INKEY TO PASSWORD„      LOCATE 22, P% + 9: COLOR 15: PRINT "X"   'PRINT "X" PLACEHOLDER„      P% = P% + 1                              'ADVANCE LINE POSITION„    END IF„  END IF„LOOP UNTIL (CHAR$ = CHR$(13))                  'LOOP W/CONTROL ARGUMENT„IF CHAR$ <> CHR$(27) THEN                      'IF ENTER PRESSED„IF UCASE$(PASS$) = PASSWORD$ THEN                         'VALID PASSWORD INPUT„  LOCATE 22, P1%„  COLOR 12„  PRINT "    HELLO, MR. 'GUEST'   "             'GREETING„  SLEEP (1)„  LOCATE 22, P1%„  COLOR 12„  PRINT "    OFF TO SECURE SITE    "„ELSEIF UCASE$(PASS$) <> PASSWORD$ THEN          'INVALID PASSWORD INPUT„  LOCATE 22, P1%„  COLOR 12„  PRINT "       ENTRY DENIED     "              'ENTRY DENIED„  BEEP„  SLEEP (1)„  LOCATE 22, P1%„  COLOR 15„  PRINT "        TRY AGAIN       "              'TRY AGAIN„  SLEEP (1)„  LOCATE 22, P1% - 1„  COLOR 15„  PRINT "                        "              'CLEAR INPUT AREA„  GOSUB 100„END IF„END IF„„SUB GRAPHICS„REM               ###################################„REM               ## PLACE BORDER\SHADE BACKGROUND ##„REM               ###################################„FOR I = 1 TO 26„LOCATE I + 3, 1: COLOR 8: PRINT ; STRING$(80, 177)„NEXT I„LINE (1, 32)-(638, 448), 12, B„LINE (2, 33)-(637, 447), 12, B„LINE (3, 34)-(636, 446), 15, B„LINE (4, 35)-(635, 445), 15, B„LINE (5, 36)-(634, 444), 7, B„LINE (6, 37)-(633, 443), 7, B„END SUB„„SUB MESSAGEWINDOW„REM                ###########################„REM                ## CREATE MESSAGE WINDOW ##„REM                ###########################„LINE (291, 221)-(524, 369), 0, BF„LINE (290, 220)-(525, 370), 7, B„LINE (289, 219)-(526, 371), 15, B„LINE (288, 218)-(527, 372), 12, B„END SUB„„Raymond Joh                    FIXED LENGTH SCROLL            Dslayer@gnn.com                11-30-95 (00:00)       QB, QBasic, PDS        151  5087     SCROLLED.BASDECLARE SUB HOTKEYS ()„DECLARE FUNCTION GETKEY% ()„'SCROLLING A SCREEN LENGTH FIXED MENU-(UP TO 26 FILES POSSIBLE)„'RAYMOND JOH  11/30/95„'COMPUTERS SOLUTIONS„'PANAMA CITY,FLA.„'„'THIS DEMO WAS CREATED WITH "QBasic" AND I'M SURE„'COULD BE GREATLY IMPROVED UPON...MY SECOND MONTH„'AT PROGRAMING...„„CONST UPKEY = 72 * 256, DOWNKEY = 80 * 256, ESCAPE = 27, ENTER = 13„„SCREEN 12                       'SCREEN MODE OF CHOICE OF AUTHOR„„'                      #####################„'                      ##  USER VARIBLES  ##„'                      #####################„LIN% = 13                       'NUMBER OF FILES FOR DISPLAY:CAN BE UP TO 26„DL% = 6                         'BEGINNING OF DISPLAY LINE,ADJUST ACCORDINGLY„P% = 15                         'BEGINNING LINE POSITION,ADJUST ACCORDINGLY„'DATA                           'THE SAMPLE DATA, I HAVE INCLUDED AT THE END„                                'END OF THIS PROGRAM IS JUST THAT. I HAVE„                                'INCLUDED INPUT AND OUTPUT STATEMENTS IN THE„                                'CASE THAT YOU NEED TO ACCESS YOUR DATA FROM„                                'FILES„„„DIM NAM$(1 TO LIN%)               'LAST NAME„DIM NAM1$(1 TO LIN%)              'FIRST NAME„„HOTKEYS„OPEN "C:\DATA.DAT" FOR OUTPUT AS #1       'THIS FILE IS CREATED ON YOUR„FOR C% = 1 TO LIN%                        'C-DRIVE.YOU MAY CHANGE THIS BY„    READ NAM$(C%), NAM1$(C%)              'SELECTING THE DRIVE AND FILE„    WRITE #1, NAM$(C%), NAM1$(C%)         'OF YOUR CHOICE.„NEXT C%„„OPEN "C:\DATA.DAT" FOR INPUT AS #2        'ABOVE  ^ FILE IS READ FROM YOUR„C% = 1                                    'C-DRIVE.BE SURE THEY USE EXACTLY„FOR C% = 1 TO LIN%                        'THE SAME PATH„ INPUT #2, NAM$(C%), NAM1$(C%)„    IF CUR% = O THEN„      LOCATE DL%, P%„      COLOR 12„      PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„      CUR% = CUR% + 1„    ELSE„      LOCATE DL%, P%„      COLOR 15„      PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„    END IF„  DL% = DL% + 1„NEXT C%„„DL% = DL% - LIN%                 'BEGINNING OF DISPLAY LINE„CMXDL% = DL% + LIN%              'CHECK MAXIMUM DISPLAY LINE VARIBLE„CMNDL% = DL%                     'CHECK MINIMUN DISPLAY LINE VARIBLE„C% = 1                           'RESET ARRAY TEXT SUBSCRIPT„DO„  KEYIN% = GETKEY%               'INITIATE INKEY% BY CALLING GETKEY%„  SELECT CASE KEYIN%             '„    CASE DOWNKEY                                     'DOWN-ARROW PRESSED„      IF DL% > DL% - 1 THEN„        IF DL% < CMXDL% - 1 THEN„          LOCATE DL%, P%„          COLOR 15„          PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„          LOCATE DL% + 1, P%„          COLOR 12„          PRINT " "; NAM$(C% + 1); ","; NAM1$(C% + 1); " "„          C% = C% + 1„          DL% = DL% + 1„        ELSEIF DL% = CMXDL% - 1 THEN„          LOCATE DL%, P%„          COLOR 15„          PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„          DL% = DL% - LIN% + 1„          C% = C% - LIN% + 1„          LOCATE DL%, P%„          COLOR 12„          PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„        END IF„      END IF„    CASE UPKEY                                       'UP-ARROW PRESSED„      IF DL% <= CMXDL% + 1 THEN„        IF DL% > CMNDL% THEN„          LOCATE DL% - 1, P%„          COLOR 12„          PRINT " "; NAM$(C% - 1); ","; NAM1$(C% - 1); " "„          LOCATE DL%, P%„          COLOR 15„          PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„          DL% = DL% - 1„          C% = C% - 1„        ELSEIF DL% = CMNDL% THEN„          LOCATE DL%, P%„          COLOR 15„          PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„          DL% = DL% + LIN% - 1„          C% = C% + LIN% - 1„          LOCATE DL%, P%„          COLOR 12„          PRINT " "; NAM$(C%); ","; NAM1$(C%); " "„        END IF„      END IF„    CASE ENTER                                       '<ENTER> PRESSED„      LOCATE 17, 42„      COLOR 15„      PRINT "YOU MADE A SELECTION"„      LOCATE 18, 44„      COLOR 12„      PRINT NAM1$(C%); " "; NAM$(C%)„    CASE ESCAPE                                      '<ESC> PRESSED„      CLS„      LOCATE 10, 30„      PRINT "I SEE YOU FOUND THE WAY OUT"„      SYSTEM„  END SELECT„LOOP„REM                        ###################„REM                        ##  SAMPLE DATA  ##„REM                        ###################„DATA Freud,Ziggy„DATA Jung,Carla„DATA Id,Sid„DATA Ego,Emma„DATA Okiedokie,Ima„DATA Nerosis,Nathan„DATA Psychosis,Patty„DATA Dribble,Sybil„DATA Regressive,Randy„DATA Depressive,Danny„DATA Melocholy,Mary„DATA Maniac,Manny„DATA Joh,Raymond„„FUNCTION GETKEY%„  DO„    KEYIN$ = INKEY$„  LOOP UNTIL LEN(KEYIN$)„  GETKEY% = CVI(KEYIN$ + CHR$(0))„END FUNCTION„„SUB HOTKEYS„LOCATE 24, 18: PRINT "UP-ARROW       SCROLLS UP...DAH          "„LOCATE 25, 18: PRINT "DOWN-ARROW     OK,ONE GUESS,YOU GOT IT   "„LOCATE 26, 18: PRINT "<ENTER>        LETS YOU MAKE A SELECTION "„LOCATE 27, 18: PRINT "<ESC>          IS SETUP YOU TAKE YOU OUT "„END SUB„„Paul Hurst                     MAINTAIN NEAT CODE             FidoNet QUIK_BAS Echo          01-09-96 (22:25)       QB, QBasic, PDS        446  13809    DENT.BAS    'DENT.BAS„'Helps programers maintain neat/pretty code.„'Released to Public domain by Paul Hurst in 1995„'„'Please use this to it's fullest extent!„'„'PLEASE don't take this code, put your name on it, compile„'it and sell it or anything. That type of thing really„'ticks me off.„„DEFINT A-Z„DECLARE FUNCTION Changesub$ (St$, Way%)„DECLARE FUNCTION Getparams% ()„DECLARE FUNCTION Mcase$ (St$)„DECLARE FUNCTION Trim$ (St$)„DECLARE FUNCTION Getfilename$ (Default$, Ext$, X%, Y%)„DECLARE FUNCTION Addext$ (File$, Ext$)„DECLARE FUNCTION Getword$ (St$, WordNum%)„DECLARE FUNCTION Secondword$ (W$)„DECLARE FUNCTION Firstword$ (W$)„DECLARE SUB Processfile ()„DECLARE SUB Center (ROW%, St$)„CONST TRUE = 1, FALSE = NOT TRUE„DIM SHARED FunctionChange, SubChange, SpaceIndent„DIM SHARED Inputfile$, OutPutFile$„FunctionChange = 3„SubChange = 3„SpaceIndent = 3„DO„   Result = GetParams„   IF Result <> 0 THEN„      OPEN Inputfile$ FOR INPUT AS #1„      OPEN OutPutFile$ FOR OUTPUT AS #2„      ProcessFile„      CLOSE #1„      CLOSE #2„   END IF„LOOP UNTIL Result = 0„„END„„FUNCTION Addext$ (File$, Ext$)„   IF File$ = "" OR Ext$ = "" THEN EXIT FUNCTION„   Work$ = ""„   Period = INSTR(File$, ".")„   IF Period = 0 THEN„      Work$ = File$ + "." + Ext$„   ELSE„      Work$ = LEFT$(File$, Period - 1) + "." + Ext$„   END IF„   AddExt$ = Work$„END FUNCTION„„SUB Center (ROW, St$)„   Col = (80 - LEN(St$)) / 2„   LOCATE ROW, Col: PRINT St$„END SUB„„FUNCTION Changesub$ (St$, Way)„   Dec = INSTR(St$, "DECLARE")„   Line$ = St$„   IF Dec = 0 THEN„      TheName$ = GetWord$(Line$, 2)„   ELSE„      TheName$ = GetWord$(Line$, 3) ' sub/function name„   END IF„   Place = INSTR(Line$, TheName$)  ' where is it„   SELECT CASE Way„      CASE 1: TheName$ = UCASE$(TheName$)„      CASE 2: TheName$ = LCASE$(TheName$)„      CASE 3: TheName$ = MCASE$(TheName$)„   END SELECT„   MID$(Line$, Place, LEN(TheName$)) = TheName$„   ChangeSub$ = Line$„END FUNCTION„„FUNCTION Firstword$ (W$)„   IF LEN(W$) = 0 THEN EXIT FUNCTION„   S = INSTR(W$, " ")„   IF S = 0 AND W$ <> "" THEN„      FirstWord$ = W$„   ELSE„      FirstWord$ = LEFT$(W$, S - 1)„   END IF„END FUNCTION„„FUNCTION Getfilename$ (Default$, Ext$, X, Y)„   Begin$ = Default$„   Work$ = Default$„   MaxLen = 12„   LOCATE , , 1, 6, 7„   LOCATE Y, X: PRINT STRING$(MaxLen, 250)„   LOCATE Y, X: PRINT Work$„   „   DO„      LOCATE Y, X + LEN(Work$)„      DO: K$ = UCASE$(INKEY$): LOOP UNTIL K$ <> ""„      SELECT CASE ASC(K$)„         CASE 46„            IF INSTR(Work$, ".") = 0 THEN„               Work$ = Work$ + K$„               LOCATE Y, X: PRINT Work$„            ELSE„               SOUND 100, 1„            END IF„         CASE 25„            Work$ = ""„            LOCATE Y, X: PRINT STRING$(MaxLen, 250)„            LOCATE Y, X„         CASE 27„            LOCATE Y, X: PRINT SPACE$(MaxLen)„            Work$ = Default$„            LOCATE Y, X: PRINT Work$„         CASE 13„            'ignore„         CASE 8„            IF LEN(Work$) > 0 THEN„               Work$ = LEFT$(Work$, LEN(Work$) - 1)„               LOCATE Y, X + LEN(Work$): PRINT CHR$(250)„               LOCATE Y, X + LEN(Work$)„            ELSE„               SOUND 100, 1„            END IF„         CASE 0 TO 32, 47, 58, 59, 60 TO 63, 92„            SOUND 100, 1 'ignore, can't be in a file name„         CASE ELSE„            IF LEN(Work$) < MaxLen THEN„               S = INSTR(Work$, ".")„               IF S <> 0 THEN„                  Ok = 0„                  FOR I = 1 TO 3„                     IF MID$(Work$, S + I, 1) = "" THEN Ok = 1„                  NEXT I„                  IF Ok = 0 THEN„                     K$ = "": SOUND 100, 1„                  END IF„               END IF„               Work$ = Work$ + K$„               LOCATE Y, X: PRINT Work$„            ELSE„               SOUND 100, 1„            END IF„      END SELECT„      „   LOOP UNTIL K$ = CHR$(13) OR K$ = CHR$(27)„   „   IF Work$ <> "" THEN„      IF INSTR(Work$, ".") = 0 THEN Work$ = Work$ + "." + Ext$„      Work$ = TRIM$(Work$)  'must in case„   END IF„   GetFileName$ = UCASE$(Work$)„   „END FUNCTION„„FUNCTION Getparams„   CONST ENTER = 13, ESCAPE = 27„   CONST DOWNARROW = 80, UPARROW = 72, LEFTARROW = 75, RIGHTARROW = 77„   CONST COL1 = 27, COL2 = 49, ROW = 11„   CLS„   Inputfile$ = "": OutPutFile$ = ""„   f = 1:„   COLOR 15, 2„   Center 1, " Dent v1.00 X Public Domain 1995 Paul Hurst "„   COLOR 7, 0„   Center 3, "UP .............. Move to next field"„   Center 4, "DOWN ........ Move to previous field"„   Center 5, "LEFT ......... Rotate field value up"„   Center 6, "RIGHT ...... Rotate field value down"„   Center 7, "ENTER .. Start with current settings"„   Center 8, "ESCAPE ................... Quit Dent"„   Center 22, "Auto-indents source code for neater code. Dent also cases subs / functions"„   Center 23, "Dent was written in QB4.5 and should work with most Basic Code"„   GOSUB DrawSelected„   DO„      „      K$ = INKEY$„      IF K$ = CHR$(0) + CHR$(DOWNARROW) THEN„         f = f + 1: IF f = 6 THEN f = 1„         GOSUB DrawSelected„      END IF„      „      IF K$ = CHR$(0) + CHR$(UPARROW) THEN„         f = f - 1: IF f = 0 THEN f = 5„         GOSUB DrawSelected„      END IF„      „      IF K$ = CHR$(0) + CHR$(RIGHTARROW) THEN„         SELECT CASE f„            CASE 1„               Inputfile$ = GetFileName$(Inputfile$, "BAS", COL1 + 13, ROW)„               OutPutFile$ = AddExt(Inputfile$, "BAK")„               GOSUB DrawSelected„            CASE 2„               OutPutFile$ = GetFileName$(OutPutFile$, "BAK", COL1 + 13, ROW + 1)„               GOSUB DrawSelected„            CASE 3„               SpaceIndent = SpaceIndent + 1„               IF SpaceIndent > 10 THEN SpaceIndent = 0„            CASE 4„               SubChange = SubChange + 1„               IF SubChange = 4 THEN SubChange = 1„            CASE 5„               FunctionChange = FunctionChange + 1„               IF FunctionChange = 4 THEN FunctionChange = 1„         END SELECT„         GOSUB DrawSelected„      END IF„      „      IF K$ = CHR$(0) + CHR$(LEFTARROW) THEN„         SELECT CASE f„            CASE 1„               Inputfile$ = GetFileName$(Inputfile$, "BAS", COL1 + 13, ROW)„               OutPutFile$ = AddExt(Inputfile$, "BAK")„               GOSUB DrawSelected„            CASE 2„               OutPutFile$ = GetFileName$(OutPutFile$, "BAK", COL1 + 13, ROW + 1)„               GOSUB DrawSelected„            CASE 3„               SpaceIndent = SpaceIndent - 1„               IF SpaceIndent = -1 THEN SpaceIndent = 10„            CASE 4„               SubChange = SubChange - 1„               IF SubChange = 0 THEN SubChange = 3„            CASE 5„               FunctionChange = FunctionChange - 1„               IF FunctionChange = 0 THEN FunctionChange = 3„         END SELECT„         GOSUB DrawSelected„      END IF„      „      IF K$ = CHR$(13) THEN„         IF Inputfile$ = "" OR OutPutFile$ = "" THEN K$ = ""„         SOUND 100, 1„      END IF„      „      „   LOOP UNTIL K$ = CHR$(13) OR K$ = CHR$(27)„   „   IF K$ = CHR$(13) THEN GetParams = 1 ELSE GetParams = 0„   EXIT FUNCTION„   „   DrawSelected:„   LOCATE , , 0„   SELECT CASE SubChange„      CASE 1: SubChange$ = "upper"„      CASE 2: SubChange$ = "lower"„      CASE 3: SubChange$ = "mixed"„   END SELECT„   SELECT CASE FunctionChange„      CASE 1: FunctionChange$ = "upper"„      CASE 2: FunctionChange$ = "lower"„      CASE 3: FunctionChange$ = "mixed"„   END SELECT„   „   LOCATE ROW + 0, COL1:       PRINT "Input file   "; Inputfile$; SPACE$(13)„   LOCATE ROW + 1, COL1:       PRINT "output file  "; OutPutFile$; SPACE$(13)„   LOCATE ROW + 2, COL1: PRINT USING "Space indent [##]"; SpaceIndent„   LOCATE ROW + 3, COL1„   PRINT USING "Subs         [ & ]"; SubChange$„   LOCATE ROW + 4, COL1: PRINT USING "Functions    [ & ]"; FunctionChange$„   LOCATE ROW + (f - 1), COL2, 1, 1, 7„   RETURN„   „END FUNCTION„„FUNCTION Getword$ (St$, WordNum)„   „   Work$ = LTRIM$(St$)„   FOR I = 2 TO WordNum   '2 so we skip first word incase WordNum=1„      S = INSTR(Work$, " ")„      IF S = 0 THEN Work$ = ""„      Work$ = RIGHT$(Work$, LEN(Work$) - S)„   NEXT I„   „   S = INSTR(Work$, " ")„   TheWord$ = ""„   IF S = 0 THEN TheWord$ = Work$ ELSE TheWord$ = LEFT$(Work$, S - 1)„   „   GetWord$ = TheWord$„   „END FUNCTION„„FUNCTION Mcase$ (St$)„   'Mixed case   ie PAUL = Paul„   Work$ = St$„   Work$ = LCASE$(Work$)„   MCASE$ = UCASE$(MID$(Work$, 1, 1)) + RIGHT$(Work$, LEN(Work$) - 1)„END FUNCTION„„SUB Processfile„   „   OldLine = -1„   IF OutPutFile$ <> "CON" THEN„      OldLine = CSRLIN„      COLOR 7: PRINT "Working ";„      COLOR 31: PRINT ". . ."„   END IF„   COLOR 7„   Spaces$ = ""„   InCase = FALSE„   CaseIndent = 0„   TotalLines = 0„   WHILE NOT EOF(1)„      LINE INPUT #1, Line$„      „      TotalLines = TotalLines + 1„      Line$ = LTRIM$(Line$)„      Token$ = FirstWord$(Line$)„      „      SELECT CASE Token$„         CASE "DECLARE"„            SecondToken$ = GetWord$(Line$, 2)„            „            IF SecondToken$ = "FUNCTION" THEN„               Line$ = ChangeSub$(Line$, FunctionChange)„               PRINT #2, Spaces$ + Line$„            END IF„            IF SecondToken$ = "SUB" THEN„               Line$ = ChangeSub$(Line$, SubChange)„               PRINT #2, Spaces$ + Line$„            END IF„            „         CASE "ELSE"„            Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„            PRINT #2, Spaces$ + Line$„            Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            „         CASE "ELSEIF"„            Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„            PRINT #2, Spaces$ + Line$„            Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„         CASE "IF"„            PRINT #2, Spaces$ + Line$„            TempNum = INSTR(Line$, "'")„            Temp$ = Line$„            IF TempNum <> 0 THEN Temp$ = LEFT$(Line$, TempNum - 1)„            Temp$ = RTRIM$(Temp$)„            IF RIGHT$(Temp$, 4) = "THEN" THEN Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            „         CASE "SUB"„            Spaces$ = ""„            Line$ = ChangeSub$(Line$, SubChange)„            PRINT #2, Spaces$ + Line$„            Spaces$ = STRING$(SpaceIndent, " ")„            „         CASE "FUNCTION"„            Spaces$ = ""„            Line$ = ChangeSub$(Line$, FunctionChange)„            PRINT #2, Spaces$ + Line$„            Spaces$ = STRING$(SpaceIndent, " ")„            „         CASE "CASE"„            IF CaseIndent = 0 THEN„               PRINT #2, Spaces$ + Line$„               Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„               CaseIndent = CaseIndent + 1„            ELSE„               Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„               PRINT #2, Spaces$ + Line$„               Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            END IF„            „            „         CASE "SELECT"„            PRINT #2, Spaces$ + Line$„            Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            IF CaseIndent <> 0 THEN„               CaseIndent = CaseIndent + 1„               Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            END IF„            „         CASE "TYPE"„            PRINT #2, Spaces$ + Line$„            Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            „         CASE "DO"„            PRINT #2, Spaces$ + Line$„            Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            „         CASE "LOOP"„            Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„            PRINT #2, Spaces$ + Line$„            „         CASE "WHILE"„            PRINT #2, Spaces$ + Line$„            Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            „         CASE "WEND"„            Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„            PRINT #2, Spaces$ + Line$„            „         CASE "FOR"„            PRINT #2, Spaces$ + Line$„            Spaces$ = Spaces$ + STRING$(SpaceIndent, " ")„            „         CASE "NEXT"„            Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„            PRINT #2, Spaces$ + Line$„            „         CASE "END"„            SecondToken$ = GetWord$(Line$, 2)„            IF SecondToken$ = "" THEN„               PRINT #2, Spaces$ + Line$„            END IF„            „            IF SecondToken$ = "TYPE" THEN                      'END TYPE„               Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„               PRINT #2, Spaces$ + Line$„            END IF„            „            IF SecondToken$ = "IF" THEN                      'END IF„               Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent)„               PRINT #2, Spaces$ + Line$„            END IF„            „            IF SecondToken$ = "SELECT" THEN„               Spaces$ = LEFT$(Spaces$, LEN(Spaces$) - SpaceIndent * 2)„               PRINT #2, Spaces$ + Line$„               CaseIndent = CaseIndent - 1„            END IF„            „            IF SecondToken$ = "SUB" OR SecondToken$ = "FUNCTION" THEN„               Spaces$ = ""„               PRINT #2, Spaces$ + Line$„            END IF„            „            „         CASE ELSE„            PRINT #2, Spaces$ + Line$„            „      END SELECT„      „      „      „   WEND„   „   IF OldLine <> -1 THEN„      COLOR 7: LOCATE OldLine: PRINT "Done!            "„   END IF„   „END SUB„„FUNCTION Trim$ (St$)„   TRIM$ = LTRIM$(RTRIM$(St$))„END FUNCTION„„Carl Gorringe                  MS WINDOWS CLIPBOARD UTILITY   FidoNet QUIK_BAS Echo          01-15-96 (19:35)       QB, PDS                434  11688    MSWIND.BAS  '---------------------------------------------------„'  MSWIND.BAS - Microsoft Windows Utils for QB 4.5„'---------------------------------------------------„'       (c) Carl Gorringe 1/15/96„'„' This program contains some routines to„'  report if Windows is running, and to„'   read and write to its Clipboard.„'„' Remember to have Windows loaded or else„' the Clipboard routines WILL NOT WORK!!„'„'    Released to the Public Domain.„'  You may use this any way you see fit,„'  just remember to give credit where„'  credit is due. This program is provided„'  "AS IS", therefore I am not responsible„'  for any consequences of using it.„'„' I can be contacted be sending a message to:„' CARL GORRINGE at FIDOnet's QUICK_BAS echo or„' Internet e-mail: <carl.gorringe@rhosoft.com>„„'-------------------„' $INCLUDE: 'QB.BI'      <-- Remember to load QB with the /L switch!„'-------------------„„CONST FALSE = 0„CONST TRUE = NOT FALSE„„DECLARE FUNCTION Info.DOSver% ()„DECLARE FUNCTION Info.WinMode% ()„DECLARE FUNCTION Clipboard.Detect% ()„DECLARE FUNCTION Clipboard.Size& (Format%, ErrCode%)„DECLARE SUB Clipboard.Empty (ErrCode%)„DECLARE SUB Clipboard.Get (Format%, DataSeg%, DataOff%, ErrCode%)„DECLARE SUB Clipboard.Put (Format%, DataSeg%, DataOff%, DataSize&, ErrCode%)„DECLARE FUNCTION Clipboard.GetText$ (ErrCode%)„DECLARE SUB Clipboard.PutText (Text$, ErrCode%)„„'---------------------------------------------------„CLS„PRINT "MSWIND.BAS - Programmed by Carl Gorringe <carl.gorringe@rhosoft.com>"„PRINT„PRINT "DOS Version:", (Info.DOSver% / 100)„PRINT "Windows Mode:", Info.WinMode%„„ClipExist% = Clipboard.Detect%„IF ClipExist% THEN„	PRINT "Clipboard:", " Available"„ELSE„	PRINT "Clipboard:", " N/A"„END IF„„IF ClipExist% THEN„„	'--- Store Text on Clipboard ---„		PRINT„		INPUT "Enter some text to store on the Clipboard: ", ClipText$„	  „		CALL Clipboard.PutText(ClipText$, ErrCode%)„		PRINT„		PRINT "   ClipText:", ClipText$„		PRINT "    ErrCode:", ErrCode%„		IF ErrCode% <> 0 THEN END„	  „		ClipText$ = ""             '<-- Clear Variable„		„		PRINT„		PRINT "Now press [CTRL]+[ESC] to switch to Windows and check the Clipboard."„		PRINT "Press Any Key to Retrieve the Clipboard contents..."„		I$ = INPUT$(1)„„	'--- Retrieve Text from Clipboard ---„„		Format% = 7„		Size& = Clipboard.Size&(Format%, ErrCode%)„	  „		PRINT„		PRINT "     Format:", Format%„		PRINT "       Size:", Size&; "bytes"„		PRINT "    ErrCode:", ErrCode%„		IF ErrCode% <> 0 THEN END„„		ClipText$ = Clipboard.GetText$(ErrCode%)„		PRINT "   ClipText:", ClipText$„		PRINT "    ErrCode:", ErrCode%„„END IF„„FUNCTION Clipboard.Detect%„„'  (c) Carl Gorringe 1/15/96„'------------------------------------------„'  Returns TRUE (-1) if Windows Clipboard„'  is Detected, else returns FALSE (0).„'------------------------------------------„'<< Done - Tested OK >>„„DIM InReg AS RegType, OutReg AS RegType„„ClipMode% = FALSE„WinMode% = Info.WinMode%„„IF WinMode% > 1 THEN„  InReg.ax = &H1700„  CALL INTERRUPT(&H2F, InReg, OutReg)„  IF OutReg.ax = &H1700 THEN„	 ClipMode% = FALSE„  ELSE„	 ClipMode% = TRUE„  END IF„END IF„„Clipboard.Detect% = ClipMode%„„END FUNCTION„„SUB Clipboard.Empty (ErrCode%)„„'  (c) Carl Gorringe 1/15/96„'---------------------------------------------„'  Empties the Clipboard„'  ErrCode% is the Error Code returned: 0=OK„'---------------------------------------------„'<< Done - Tested OK >>„„DIM InReg AS RegType, OutReg AS RegType„DIM InRegX AS RegTypeX, OutRegX AS RegTypeX„„'--- Open Clipboard ---„	InReg.ax = &H1701„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 1                  '<-- Clipboard is already open (error)„		EXIT SUB„	END IF„„'--- Empty Clipboard ---„	InReg.ax = &H1702„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 3                  '<-- Failure (error)„	END IF„„'--- Close Clipboard ---„	InReg.ax = &H1708„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 2                  '<-- Clipboard wont close (error)„		EXIT SUB„	END IF„„„END SUB„„SUB Clipboard.Get (Format%, DataSeg%, DataOff%, ErrCode%)„„'  (c) Carl Gorringe 1/15/96  << v1.0 >>„'---------------------------------------------„'  Gets Data from the Clipboard and stores„'  it at address DataSeg% : DataOff%„'  ErrCode% is the Error Code returned: 0=OK„'  Format% is the clipboard format number:„'         1 = Text (Windows Text)  <-- Contains garbage chars at end of text„'         2 = Bitmap Picture„'         3 = Metafile Picture„'         7 = OEM Text (DOS Text)  <-- Contains nulls at end of text„'---------------------------------------------„'<< Done - Tested OK >>„„DIM InReg AS RegType, OutReg AS RegType„DIM InRegX AS RegTypeX, OutRegX AS RegTypeX„„'--- Open Clipboard ---„	InReg.ax = &H1701„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 1                  '<-- Clipboard is already open (error)„		EXIT SUB„	END IF„„'--- Get Clipboard Data ---„	InRegX.ax = &H1705„	InRegX.dx = Format%„	InRegX.es = DataSeg%„	InRegX.bx = DataOff%„	CALL INTERRUPTX(&H2F, InRegX, OutRegX)„	IF OutRegX.ax = 0 THEN„		ErrCode% = 3                  '<-- (error)„	END IF„„'--- Close Clipboard ---„	InReg.ax = &H1708„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 2                  '<-- Clipboard wont close (error)„		EXIT SUB„	END IF„„END SUB„„FUNCTION Clipboard.GetText$ (ErrCode%)„„'  (c) Carl Gorringe 1/15/96  << v1.0 >>„'-----------------------------------------------------„'  Gets and Returns Text Data from the Clipboard.„'  Clipboard Format used is "OEM Text" (Format% = 7)„'  ErrCode% is the Error Code returned: 0=OK„'-----------------------------------------------------„'<< Done - Tested OK >>„„ErrCode% = 0„Format% = 1       '<-- 7=OEM Text, 1=Windows Text„„'--- Get Size of Clipboard ---„	Size& = Clipboard.Size&(Format%, ErrCode%)„	IF ErrCode% > 0 THEN EXIT FUNCTION„  „	IF Size& = 0 THEN„		ErrCode% = 4         '<-- Clipboard Empty!„		EXIT FUNCTION„	END IF„„	IF Size& > 32000 THEN„		ErrCode% = 5         '<-- Clipboard Too Large for String Variable!„		EXIT FUNCTION„	END IF„„'--- Get Text from Clipboard and Store It ---„	Temp$ = SPACE$(Size&)„	CALL Clipboard.Get(Format%, VARSEG(Temp$), SADD(Temp$), ErrCode%)„  „	IF ErrCode% = 0 THEN„		'--- Trim Ending Garbage ---„			Temp$ = LEFT$(Temp$, INSTR(Temp$, CHR$(0)) - 1)„„		'--- Trim Ending CR/LF if Exists ---„			IF RIGHT$(Temp$, 2) = CHR$(13) + CHR$(10) THEN„				Temp$ = LEFT$(Temp$, LEN(Temp$) - 2)„			END IF„„		Clipboard.GetText$ = Temp$„	END IF„„END FUNCTION„„SUB Clipboard.Put (Format%, DataSeg%, DataOff%, DataSize&, ErrCode%)„„'  (c) Carl Gorringe 1/15/96  << v1.0 >>„'---------------------------------------------„'  Stores Data on to the Clipboard starting„'  from address DataSeg% : DataOff%„'    and storing DataSize& bytes.„'  ErrCode% is the Error Code returned: 0=OK„'  Format% is the clipboard format number:„'         1 = Text (Windows Text)„'         2 = Bitmap Picture„'         3 = Metafile Picture„'         7 = OEM Text (DOS Text)„'---------------------------------------------„'<< Done - Tested OK >>„„DIM InReg AS RegType, OutReg AS RegType„DIM InRegX AS RegTypeX, OutRegX AS RegTypeX„„'--- Open Clipboard ---„	InReg.ax = &H1701„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 1                  '<-- Clipboard is already open (error)„		EXIT SUB„	END IF„„'--- Store Clipboard Data ---„	InRegX.ax = &H1703„	InRegX.dx = Format%„	InRegX.es = DataSeg%„	InRegX.bx = DataOff%„	IF DataSize& < 32768 THEN„		InRegX.si = 0„		InRegX.cx = DataSize&„	ELSE„		InRegX.si = (DataSize& \ 32768) * 2048   '<-- This part NOT Tested!„		InRegX.cx = DataSize& MOD 32768          '<-- but don't worry about it.„	END IF„  „	CALL INTERRUPTX(&H2F, InRegX, OutRegX)„	IF OutRegX.ax = 0 THEN„		ErrCode% = 3                  '<-- (error)„	END IF„„'--- Close Clipboard ---„	InReg.ax = &H1708„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 2                  '<-- Clipboard wont close (error)„		EXIT SUB„	END IF„„END SUB„„SUB Clipboard.PutText (Text$, ErrCode%)„„'  (c) Carl Gorringe 1/15/96  << v1.0 >>„'---------------------------------------------„'  Stores Text on to the Clipboard in„'     BOTH Clipboard Text Formats.„'  ErrCode% is the Error Code returned: 0=OK„'---------------------------------------------„'<< Done - Tested OK >>„„ErrCode% = 0„„'--- Empty Clipboard ---„	CALL Clipboard.Empty(ErrCode%)„	IF ErrCode% <> 0 THEN„		ErrCode% = ErrCode% + 10„		EXIT SUB„	END IF„„'--- Store Text on to Clipboard ---„	Temp$ = Text$ + CHR$(0)„	TempLen& = LEN(Temp$)„  „	CALL Clipboard.Put(1, VARSEG(Temp$), SADD(Temp$), TempLen&, ErrCode%)„	CALL Clipboard.Put(7, VARSEG(Temp$), SADD(Temp$), TempLen&, ErrCode%)„„„END SUB„„FUNCTION Clipboard.Size& (Format%, ErrCode%)„„'  (c) Carl Gorringe 1/15/96  << v1.0 >>„'---------------------------------------------„'  Returns the current size of the Clipboard„'  in bytes, using the specified Format%„'  ErrCode% is the Error Code returned: 0=OK„'  Format% is the clipboard format number:„'         1 = Text (Windows Text)„'         2 = Bitmap Picture„'         3 = Metafile Picture„'         7 = OEM Text (DOS Text)„'---------------------------------------------„'<< Done - Tested OK >>„„DIM InReg AS RegType, OutReg AS RegType„DIM InRegX AS RegTypeX, OutRegX AS RegTypeX„„ErrCode% = 0„„'--- Open Clipboard ---„	InReg.ax = &H1701„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 1                  '<-- Clipboard is already open„		Clipboard.Size& = 0„		EXIT FUNCTION„	END IF„„'--- Get Size of Clipboard in current Format ---„	InReg.ax = &H1704„	InReg.dx = Format%„	CALL INTERRUPT(&H2F, InReg, OutReg)„	ClipSize& = (OutReg.dx * 16) + OutReg.ax„„'--- Close Clipboard ---„	InReg.ax = &H1708„	CALL INTERRUPT(&H2F, InReg, OutReg)„	IF OutReg.ax = 0 THEN„		ErrCode% = 2                  '<-- Clipboard wont close„		Clipboard.Size& = 0„		EXIT FUNCTION„	END IF„„Clipboard.Size& = ClipSize&„„END FUNCTION„„FUNCTION Info.DOSver%„„'  (c) Carl Gorringe 1/15/96„'--------------------------------------„'  Returns the DOS version times 100.„'  To get decimal representation,„'  devide the number returned by 100.„'--------------------------------------„'<< Done - Tested OK >>„„DIM InReg AS RegType, OutReg AS RegType„„InReg.ax = &H3306„CALL INTERRUPT(&H21, InReg, OutReg)„DOSver% = ((OutReg.bx AND 255) * 100) + (OutReg.bx \ 256)„IF DOSver% = 0 THEN„  InReg.ax = &H3000„  CALL INTERRUPT(&H21, InReg, OutReg)„  DOSver% = ((OutReg.ax AND 255) * 100) + (OutReg.ax \ 256)„END IF„„Info.DOSver% = DOSver%„„END FUNCTION„„FUNCTION Info.WinMode%„„'  (c) Carl Gorringe 1/15/96„'-------------------------------------------------------------„'  Returns the current Windows Mode:„'    0 = Windows not detected„'    1 = Real mode detected (Win 3.0 and earlier only)„'    2 = Standard mode detected. (Win 3.11 and earlier only)„'    3 = 386 enhanced mode detected.„'-------------------------------------------------------------„'<< Done - Tested OK >>„„DIM InReg AS RegType, OutReg AS RegType„„DOSver% = Info.DOSver%„„IF DOSver% >= 300 THEN„  InReg.ax = &H160A„  CALL INTERRUPT(&H2F, InReg, OutReg)„  IF OutReg.ax <> 0 THEN„	 WinMode% = 0„  ELSE„	 WinMode% = OutReg.cx„  END IF„END IF„„Info.WinMode% = WinMode%„„END FUNCTION„„John Rodgers                   ADDRESS LABEL GENERATOR        Wizard Productions             Unknown Date           QB, QBasic, PDS        822  25187    XLABEL.BAS                              'XLABEL  Version 1.0„                   'This is an Address Label Printer Program„                        'single column labels only„DECLARE SUB displayheader ()„DECLARE SUB getMenuSelection (choice%)„DECLARE SUB addRecords ()                                                          'by John Rodgers„DECLARE SUB changeFilename ()                              'declare SUBS                'TCF„DECLARE SUB searcH ()„DECLARE SUB printRecords ()„DECLARE SUB viewrecords ()„DECLARE SUB help ()„DECLARE SUB helPrint ()„DECLARE SUB prntrtadress ()„DECLARE SUB addretadres ()„DECLARE SUB returnaddress ()„DECLARE SUB retchoice ()„DECLARE SUB rviewrec ()„„COMMON SHARED filename$„„filename$ = "test.db"„OPEN filename$ FOR APPEND AS #1: CLOSE #1         ' open or create file„ displayheader                                     'display program frame„DO„ getMenuSelection choice%„SELECT CASE choice%                          'get user choice„  CASE 1„  COLOR 14, 7„      LOCATE 3, 47: PRINT " ADD     "                'add to database file„      addRecords„  CASE 2„  COLOR 14, 7„     LOCATE 3, 47: PRINT " VIEW    "                  'view database file„     viewrecords„  CASE 3„   COLOR 4, 7„    LOCATE 3, 47: PRINT " PRINT    "                   'print labels„   COLOR 15„    printRecords„  CASE 4„  COLOR 14, 7„    LOCATE 3, 47: PRINT " SEARCH  "                     ' search for txt$„    searcH„  CASE 5„  COLOR 14, 7„    LOCATE 3, 47: PRINT " CHOOSE   "„    changeFilename                                   'change database file„  CASE 6„   CLS„   SHELL„   COLOR 1, 7„   displayheader„  CASE 7                                              'make and print„   COLOR 15, 1                                         'return address labels„    LOCATE 3, 47: PRINT " RETURN "„    returnaddress„  CASE 8„   COLOR 15, 7„     LOCATE 3, 47: PRINT " HELP "                       'online help„     help„  CASE 9„   COLOR 15, 1„    LOCATE 3, 47: PRINT " QUIT  "„ END SELECT                                             'quit program„LOOP UNTIL (choice% = 9)„ FOR i% = 1 TO 20„ SOUND (i% * 1000), 2                                    'sound„ NEXT i%„ CLS„SCREEN 7„COLOR 4„LOCATE 8, 8                                           'end logo & music„PRINT "     PRESENTED  BY "„PRINT , , , , , , , , , , , , , , , , , , , , ""„COLOR 13„CIRCLE (145, 115), 32, 14, , , 2 / 9„PAINT (140, 115), 14„CIRCLE STEP(4, -1), 9, 0„PAINT STEP(1, 2), 0„CIRCLE STEP(1, 1), 1, 12„COLOR 14„PRINT "        'WIZARD PRODUCTIONS'"„  COLOR 7„    Music$ = "MBT180o2P2P8L8GGGL1E-P24P8L8FFFL1D"„    PLAY Music$„    WHILE PLAY(0) > 1: WEND„StartTime = TIMER„WHILE TimePast < 13„TimePast = TIMER - StartTimer„WEND„FOR j% = 1 TO 500                             'pause loops„FOR k% = 1 TO 960„NEXT k%                                         'return to System„NEXT j%                                          '.bat file„„SYSTEM„„SUB addRecords„                       'gets and saves data from user„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„PRINT„LOCATE 23, 1„COLOR 15, 1„PRINT "          Type ";„COLOR 14„PRINT "End ";„COLOR 15, 1„PRINT "on the ";                                       'info in colors„PRINT "Name ";„COLOR 15, 1„PRINT "line to save file and quit";„LOCATE 24, 1: COLOR 1, 7„PRINT " Enter Address       Type END for Name to quit...    "; 'status line„VIEW PRINT 5 TO 22„COLOR 15, 1„PRINT„PRINT "                    Enter new address   (without commas)"„PRINT„OPEN filename$ FOR APPEND AS #1„COLOR 7, 1„WHILE (UCASE$(name$) <> "END")                        'end if no more records„    INPUT "                          Name:   ", name$„ IF (UCASE$(name$) <> "END") THEN„    INPUT "                          Address:", addres$„    INPUT "                          City:   ", city$„    INPUT "                          State:  ", state$„    INPUT "                          Zip:    ", zip$„  WRITE #1, name$, addres$, city$, state$, zip$         'write data to file„ END IF„WEND„CLOSE #1„„END SUB„„SUB addretadres„„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„ CLS 2„ COLOR 1, 7„VIEW PRINT„LOCATE 3, 16: PRINT " ": LOCATE 3, 16: PRINT filename$ 'Header info„LOCATE 24, 1: COLOR 1, 7„PRINT "     Enter RETURN Address then press ENTER...       "'status line„VIEW PRINT 5 TO 22„COLOR 15, 1„PRINT "                 Enter new RETURN Address...(without commas)"„PRINT„OPEN filename$ FOR OUTPUT AS #1„    INPUT "             Name:   ", name$„    INPUT "             Address:", addres$„    INPUT "             City:   ", city$„    INPUT "             State:  ", state$„    INPUT "             Zip:    ", zip$„   WRITE #1, name$, addres$, city$, state$, zip$         'write data to file„CLOSE #1„VIEW PRINT„LOCATE 3, 16: PRINT "         ": LOCATE 3, 16: PRINT filename$ 'Header info„LOCATE 24, 1: COLOR 1, 7„PRINT "Press ENTER...                "                         'status line„VIEW PRINT 5 TO 23„COLOR 15, 1„CLS 2„retchoice„„END SUB„„SUB changeFilename„                      'allows user to change database„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„COLOR 1, 7„LOCATE 24, 1: PRINT "  TYPE ' name?.DB ' or Press ENTER...                  ";„VIEW PRINT 5 TO 24„COLOR 15, 1„PRINT " Use this option to Create a new Label file or open an existing one."„PRINT„PRINT "    The current directory contains the following label.db files:"„PRINT                                                         'view .db files„FILES "*.DB"„PRINT„PRINT "          What Label file would you like to work with?"     'default„PRINT„PRINT "         Press ENTER... for default Label file LABEL.DB"     'database„PRINT : COLOR 14„PRINT "           You Must use a Valid filename with a .DB extention! "„COLOR 9„INPUT "                Filename:   ", filename$„COLOR 7„IF (filename$ = "") THEN                                      'set default„filename$ = "LABEL.DB    "                                         'database„ELSE„  filename$ = LTRIM$(RTRIM$(UCASE$(filename$)))„END IF„ OPEN filename$ FOR APPEND AS #1                              'make or check„ CLOSE #1„COLOR 7„„END SUB„„SUB displayheader„CLS                 'displays program name and choices„CLS 2„COLOR 1, 15„CLS„PRINT : COLOR 4„PRINT "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ XLABEL 1.0";„PRINT " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~": COLOR 1„PRINT "~~~~~~~~~~~~~~~~~~~ "; : COLOR 9„PRINT "The Wizard's ";                            'program title„COLOR 4„PRINT "MAGIC ";                                   'change color for 'MAGIC'„COLOR 9„PRINT "Address Label Maker!"; : COLOR 1: PRINT " ~~~~~~~~~~~~~~~~~~~~": COLOR 9„PRINT "Current FILE:                  ";          'print display names„PRINT "Current MODE:                  ";„PRINT "Current TIME:"„COLOR 1„PRINT STRING$(80, "~")„COLOR 4„LOCATE 25, 1: PRINT STRING$(80, "~")„FOR i% = 1 TO 20                                   'sound initilizer„ SOUND (i% * 500), 1„ NEXT i%„„END SUB„„SUB getMenuSelection (choice%)„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„choice% = 0„VIEW PRINT                                                    ' prints current„COLOR 1, 7„LOCATE 3, 16: PRINT "           ": LOCATE 3, 16: PRINT filename$ 'Header info„COLOR 14„LOCATE 3, 47: PRINT "SELECT     "„COLOR 12„LOCATE 3, 76: PRINT LEFT$(TIME$, 5)„COLOR 1, 7„LOCATE 24, 1: PRINT " Type a number between 1 and 9 and press ENTER...     ";„VIEW PRINT 5 TO 23„COLOR 15, 1„CLS 2„PRINT„PRINT„PRINT " SELECT an option:"                                      'prompt user for„PRINT                                                           'choice„PRINT "              1) ADD    ";„COLOR 14„PRINT " Addresses";„COLOR 15, 1„PRINT " Make Label file and save to disk"„COLOR 15, 1„PRINT "              2) VIEW    contents of a Label file on screen"„PRINT "              3) PRINT   contents of Label file to printer"„PRINT "              4) SEARCH  for a specific entry in Label file"„PRINT "              5) CHOOSE  Label files"„PRINT "              6) EXIT    temporarily to DOS... (type";„COLOR 14„PRINT " EXIT";„COLOR 15, 1„PRINT " to return)"„PRINT "              7) RETURN  make";„COLOR 14„PRINT " RETURN ";„COLOR 15, 1„PRINT " Address Labels"„PRINT "              8) HELP    what do I do?"„PRINT "              9) QUIT  ";„COLOR 9„PRINT " 'Wizard's "; : COLOR 4„PRINT "MAGIC "; : COLOR 9„PRINT "Address Label Maker'": COLOR 15„PRINT„DO WHILE (choice% < 1) OR (choice% > 9)„INPUT " Choice (1-9): ", choice%                                'get choice„LOOP„CLS 2„VIEW PRINT„„END SUB„„SUB help„prntHelp$ = "prnthlp.txt"„errorHelp$ = "error.txt"„bHelp$ = "bhlp.txt"„editHelp$ = "edithlp.txt"„pick% = 0„OPEN prntHelp$ FOR APPEND AS #2: CLOSE #2„OPEN errorHelp$ FOR APPEND AS #3: CLOSE #3„OPEN bHelp$ FOR APPEND AS #4: CLOSE #4„OPEN editHelp$ FOR APPEND AS #5: CLOSE #5„LOCATE 24, 1„COLOR 1, 7„PRINT "Enter number between 1 and 6 and press ENTER:  "; : COLOR 14, 1„PRINT "               < WHAT to do next "            'status line„LOCATE 4, 1„COLOR 14, 1„PRINT " FILE you are using /\ now               WHERE /\ you are             TIME  /\  "„PRINT " ADRESSES are stored here               What you are doing          Military"„VIEW PRINT 6 TO 22„CLS 2„COLOR 15, 1„PRINT„PRINT„PRINT " Choose a Help file"„PRINT                                                           'choice„PRINT "                  1) XLBL help    "„PRINT "                  2) Printer Help   "„PRINT "                  3) Error Messages "„PRINT "                  4) Edit LABEL files "„PRINT "                  5) Print Help Files"„PRINT "                  6) End HELP       "„PRINT„DO WHILE (pick% < 1) OR (pick% > 6)„   INPUT " Choice (1-6): ", pick%                                'get choice„LOOP„IF pick% = 1 THEN„    OPEN bHelp$ FOR INPUT AS #4„    CLS 2„   DO WHILE NOT EOF(4)„        LINE INPUT #4, REC$                    'read entries from the file„        PRINT REC$                             'print the entries on the screen„        LOOP„        VIEW PRINT„ LOCATE 23, 1: COLOR 1, 7„ PRINT„ INPUT " Press ENTER to continue...                  ", dummy$„    VIEW PRINT„    CLOSE #4„    help„   END IF„IF pick% = 2 THEN„    OPEN prntHelp$ FOR INPUT AS #2„    CLS 2„    DO WHILE NOT EOF(2)„        LINE INPUT #2, REC$                    'read entries from the file„        PRINT REC$                             'print the entries on the screen„    LOOP„    CLOSE #2„  VIEW PRINT„ LOCATE 23, 1: COLOR 1, 7„ PRINT„ INPUT " Press ENTER to continue...                  ", dummy$„   VIEW PRINT„   help„END IF„IF pick% = 3 THEN„    OPEN errorHelp$ FOR INPUT AS #3„    CLS 2„    DO WHILE (NOT EOF(3))„    LINE INPUT #3, REC$                    'read entries from the file„    PRINT REC$                             'print the entries on the screen.„    LOOP„    CLOSE #3„    VIEW PRINT„ LOCATE 23, 1: COLOR 1, 7„ PRINT„ INPUT " Press ENTER to continue...                  ", dummy$„   VIEW PRINT„    help„END IF„IF pick% = 4 THEN„    OPEN editHelp$ FOR INPUT AS #5„    CLS 2„    DO WHILE NOT EOF(5)„        LINE INPUT #5, REC$                    'read entries from the file„        PRINT REC$                             'print the entries on the screen„        LOOP„    CLOSE #5„        VIEW PRINT„ LOCATE 23, 1: COLOR 1, 7„ PRINT„ INPUT " Press ENTER to continue...                  ", dummy$„    VIEW PRINT„    help„END IF„IF pick% = 5 THEN„   helPrint„END IF„ IF pick% = 6 THEN„  CLS 2                                                           'exit help„END IF„„END SUB„„SUB helPrint„FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                           'sound„ NEXT i%„SOUND (2 * 1000), 7                                             'sound for„CLS 2„PRINT„prntHelp$ = "prnthlp.txt"„errorHelp$ = "error.txt"„qbHelp$ = "bhlp.txt"„editHelp$ = "edithlp.txt"„OPEN prntHelp$ FOR APPEND AS #2: CLOSE #2„OPEN errorHelp$ FOR APPEND AS #3: CLOSE #3                       'check files„OPEN qbHelp$ FOR APPEND AS #4: CLOSE #4„OPEN editHelp$ FOR APPEND AS #5: CLOSE #5„VIEW PRINT 5 TO 22„  PRINT„  COLOR 14„  PRINT "                 BE SURE REGULAR PAPER IS IN PRINTER!"„  PRINT                                                           'printer warning„  PRINT„  COLOR 1, 7„   COLOR 4„   PRINT "                        PRINT HELP FILES? Y/N                                   "„VIEW PRINT„LOCATE 24, 1: COLOR 1, 7„INPUT " Check printer then press Y to print N to quit...", ans$„IF ans$ = "Y" OR ans$ = "y" THEN„    OPEN prntHelp$ FOR INPUT AS #2„DO WHILE (NOT EOF(2))„    INPUT #2, REC$„    LPRINT REC$                                         'print all help files„  LOOP„     CLOSE #2„    OPEN errorHelp$ FOR INPUT AS #3„ DO WHILE (NOT EOF(3))„    INPUT #3, REC$„    LPRINT REC$„  LOOP„    CLOSE #3„   OPEN qbHelp$ FOR INPUT AS #4„ DO WHILE (NOT EOF(4))„    INPUT #4, REC$„    LPRINT REC$„   LOOP„    CLOSE #4„    OPEN editHelp$ FOR INPUT AS #5„ DO WHILE (NOT EOF(5))„    INPUT #5, REC$„    LPRINT REC$„ LOOP„    LPRINT CHR$(12)„    CLOSE #5„  ELSE„END IF„END SUB„„SUB printRecords„                   'prints data in label format (single column)„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                           'sound„ NEXT i%„SOUND (2 * 1000), 7                                             'sound for„VIEW PRINT 5 TO 23                                               'print page„COLOR 15, 1„PRINT„PRINT„PRINT "         This option sends the contents of ";„COLOR 14„PRINT filename$;„COLOR 15„PRINT " to your printer."„PRINT„PRINT "                         This version  of the ": COLOR 9„PRINT "                  'Wizard's "; : COLOR 4„PRINT "MAGIC "; : COLOR 9„PRINT "Address Label Maker'": COLOR 15„PRINT "                    will only print single columns!"         'info„PRINT„PRINT "                        Name and address format!"„PRINT„PRINT "                      Make sure your printer is "; : COLOR 14     'user prompt„PRINT "on."„COLOR 15„PRINT„PRINT "                     USE ";„COLOR 14„PRINT "TEST.DB ";„COLOR 15„PRINT "to check printer!"„VIEW PRINT„LOCATE 24, 1: COLOR 1, 7„PRINT "Enter "; : COLOR 4                                        'status line„PRINT "P "; : COLOR 1„INPUT "to print or R to return to main menu:     ", reply$„VIEW PRINT 5 TO 24„IF (reply$ = "P") OR (reply$ = "p") THEN                     'print command„   OPEN filename$ FOR INPUT AS #1„   DO WHILE (NOT EOF(1))„   INPUT #1, name$, addres$, city$, state$, zip$„    LPRINT„    LPRINT "  "; name$„    LPRINT "  "; addres$„    LPRINT "  "; city$; ","; state$„    LPRINT "  "; zip$„    LPRINT„    LOOP„    CLOSE #1„    END IF„    COLOR 7„END SUB„„SUB prntrtadress„                  'prints data in label format (single column)„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                          'sound„ NEXT i%„SOUND (2 * 1000), 7                                            'sound for„CLS 2„VIEW PRINT„LOCATE 24, 1: COLOR 1, 7                                      'status line„PRINT " Number of Labels to be Printed...             ";„VIEW PRINT 5 TO 23„PRINT„COLOR 15, 1„PRINT„PRINT "         How many RETURN Address Labels would you like to Print?"„PRINT„COLOR 14„INPUT "                          ... ", lblNum%                  'prompt user„COLOR 15, 1„PRINT "   This option sends the contents of ";„COLOR 3„PRINT filename$;„COLOR 15„PRINT " to your printer";„COLOR 14„PRINT "  "; lblNum%;„COLOR 15, 1„PRINT " times."„PRINT„PRINT "                         This version  of the ": COLOR 9„PRINT "                  'Wizard's "; : COLOR 4„PRINT "MAGIC "; : COLOR 9„PRINT "Address Label Maker'": COLOR 15„PRINT "                    will only print single columns!"         'info„PRINT "                        Name and address format!"„PRINT„PRINT "                      Make sure your printer is "; : COLOR 14„PRINT "ON."„COLOR 15„PRINT„PRINT "                     Use ";„COLOR 14„PRINT "TEST.DB ";„COLOR 15„PRINT "to check printer!"„VIEW PRINT„LOCATE 24, 1: COLOR 1, 7„PRINT "Enter "; : COLOR 4„PRINT "P "; : COLOR 1„INPUT "to print or R to return to main menu:   ", reply$„ IF (reply$ = "P") OR (reply$ = "p") THEN„  DO„   OPEN filename$ FOR INPUT AS #1„   INPUT #1, name$, addres$, city$, state$, zip$„   FOR i% = 1 TO lblNum%„   LPRINT                                                        'print return„   LPRINT "  "; name$                                             'address labels„    LPRINT "  "; addres$„    LPRINT "  "; city$; ","; state$„    LPRINT "  "; zip$„    LPRINT„    NEXT i%„    CLOSE #1„  LOOP WHILE lblNum% > i%„END IF„    IF (reply$ <> "P") OR (reply$ <> "p") THEN                    'exit SUB„ retchoice„   END IF„„END SUB„„SUB retchoice„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„ COLOR 1, 7„ VIEW PRINT„LOCATE 3, 16: PRINT "            ": LOCATE 3, 16: PRINT filename$                               'header info„LOCATE 23, 1„COLOR 1, 7„PRINT„PRINT " Enter number between 1 and 5 and press ENTER             "'status line„VIEW PRINT 5 TO 23„COLOR 15, 1„CLS 2„PRINT„PRINT "  Would you like to..."„PRINT                                                           'choice„PRINT "                    1) VIEW     this Label  "„PRINT "                    2) CHANGE   this Label  "„PRINT "                    3) PRINT    this Label "„PRINT "                    4) ANOTHER  change to Another Label"„PRINT "                    5) QUIT     to SELECT "„PRINT„DO WHILE (pick% < 1) OR (pick% > 5)„   INPUT "  Choice (1-5): ", pick%                                'get choice„LOOP„ IF pick% = 1 THEN„ CLS 2                                                            'view return address„ rviewrec„ END IF„ IF pick% = 2 THEN                                              'change return address„  addretadres„ END IF„ IF pick% = 3 THEN                                               'print return address„  prntrtadress„ END IF„ IF pick% = 4 THEN„  returnaddress„ END IF„IF pick% = 5 THEN„  CLS 2                                                            'exit help„  filename$ = "Test.DB"„  OPEN filename$ FOR APPEND AS #1„  CLOSE #1„END IF„END SUB„„SUB returnaddress     'allows user to print return address labels„                     „ FOR i% = 2 TO 6„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„ COLOR 1, 7„ VIEW PRINT„LOCATE 3, 16: PRINT " "; filename$             'Header info„LOCATE 24, 1: PRINT "  TYPE ' name?.LBL ' or Press ENTER...                "„VIEW PRINT 5 TO 23„COLOR 1, 7„CLS 2„OPEN filename$ FOR APPEND AS #1„CLOSE #1„COLOR 15, 1„CLS 2„PRINT„PRINT "  Use this option to create a new RETURN Address Label or open an existing one."„PRINT„PRINT„PRINT "         The current directory contains the following .LBL files:"„PRINT                                                         'view .LBL files„FILES "*.LBL"„PRINT„PRINT "           What Return Address Label would you print? "                  'prompt for new„PRINT "          Press ENTER for default database file RETURN.LBL"„PRINT : COLOR 14„PRINT„PRINT "           You Must use a Valid filename with a .LBL extention! "„PRINT : COLOR 9„INPUT "                Filename:  ", filename$„COLOR 1, 7„IF (filename$ = "") THEN                                      'set default„filename$ = "RETURN.LBL  "                                      'database„OPEN filename$ FOR APPEND AS #1„CLOSE #1„ELSE„VIEW PRINT„  LOCATE 24, 1: COLOR 1, 7„PRINT "Enter New RETURN Address the press ENTER...                   "'status line„VIEW PRINT 5 TO 23„COLOR 15, 1„  filename$ = LTRIM$(RTRIM$(UCASE$(filename$)))„END IF„ OPEN filename$ FOR APPEND AS #1                              'make or check„ CLOSE #1                                                         'file„CLS 2„retchoice„„END SUB„„SUB rviewrec„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„ VIEW PRINT„ COLOR 1, 7„LOCATE 3, 16: PRINT "         ": LOCATE 3, 16: PRINT filename$ 'Header info„LOCATE 24, 1„COLOR 1, 7„PRINT " Press ENTER to continue.....                        "„VIEW PRINT 5 TO 23„COLOR 15, 1„PRINT„PRINT "  This option lets you view your";„PRINT " RETURN Address Label";„PRINT " before you Print it."„PRINT„OPEN filename$ FOR INPUT AS #1„DO WHILE (NOT EOF(1))„INPUT #1, name$, addres$, city$, state$, zip$„ PRINT "                         "; name$„ PRINT "                         "; addres$                    'show label„ PRINT "                         "; city$; ", "; state$         'format„ PRINT "                         "; zip$„LOOP„CLOSE #1„COLOR 14„PRINT„PRINT "           'This is how your Label should look when Printed'"„PRINT„INPUT "", dummy$„CLS 2„retchoice„„END SUB„„SUB searcH„                   'allows user to search data for any string„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„num% = 0                                               'sets or resets found$„found% = 0                                               'and number$ to 0„LOCATE 24, 1: COLOR 1, 7„PRINT "   Enter search category and content...          "   'status line„VIEW PRINT 5 TO 23                                          'open view„COLOR 15, 1„PRINT„PRINT„PRINT "    Select a search category:"„PRINT„PRINT„PRINT "                       1)Search for Name"              'choice display„PRINT "                       2)Search for City"„PRINT "                       3)Search for Zipcode"„ DO WHILE (num% < 1) OR (num% > 3)„ PRINT„   INPUT " Category (1-3):  ", num%„ LOOP„PRINT„COLOR 9„INPUT "                Enter data to be searched for:   ", searchStr$„PRINT„PRINT "                    Search results:"          'prompt user for choice„PRINT„OPEN filename$ FOR INPUT AS #1„DO WHILE (NOT EOF(1))„ INPUT #1, name$, addres$, city$, state$, zip$„SELECT CASE num%„  CASE 1„     IF INSTR(UCASE$(name$), UCASE$(searchStr$)) THEN    'compares strings„       found% = -1„       COLOR 2„PRINT "                     Name:    "; name$: COLOR 15 'changes choice color„PRINT "                              "; addres$„PRINT "                              "; city$           'search by name„PRINT "                              "; state$„PRINT "                              "; zip$„  INPUT "", dummy$„  END IF„  CASE 2„    IF INSTR(UCASE$(city$), UCASE$(searchStr$)) THEN„    found% = -1„    COLOR 15„PRINT "                              "; name$„PRINT "                              "; addres$„COLOR 2„PRINT "                      City:   "; city$: COLOR 15   'search by city„PRINT "                              "; state$„PRINT "                              "; zip$„  INPUT "", dummy$„  END IF„  CASE 3„     IF INSTR(UCASE$(zip$), UCASE$(searchStr$)) THEN„       found% = -1„       COLOR 15, 1„PRINT "                              "; name$„PRINT "                              "; addres$         'search by zipcode„PRINT "                              "; city$„PRINT "                              "; state$„COLOR 2„PRINT "                    Zipcode:  "; zip$: COLOR 15„  INPUT "", dummy$„  END IF„END SELECT„ LOOP„ CLOSE #1„ IF (NOT found%) THEN„ COLOR 2: PRINT "  ", searchStr$;                              'not found„ COLOR 7: PRINT "  not found in "; filename$; " database."„ END IF„VIEW PRINT„ COLOR 1, 7„ LOCATE 24, 1: INPUT "Press ENTER to return to main menu...", dummy$„END SUB„„SUB viewrecords„                 'allows user to view files in label format„ FOR i% = 1 TO 5„ SOUND (i% * 1000), 1                                             'sound„ NEXT i%„LOCATE 15, 1: COLOR 14, 1                                      'status line„PRINT "             This is how your ";„COLOR 15, 1„PRINT "Label ";„COLOR 14, 1„PRINT "will appear when printed "„LOCATE 24, 1: COLOR 1, 7                                      'status line„PRINT "   Press ENTER to continue...                    "„VIEW PRINT 8 TO 12„COLOR 15, 1„PRINT„PRINT„OPEN filename$ FOR INPUT AS #1„DO WHILE (NOT EOF(1))                                       '„INPUT #1, name$, addres$, city$, state$, zip$„ PRINT "                            "; name$„ PRINT "                            "; addres$„ PRINT "                            "; city$; ", "; state$„ PRINT "                            "; zip$„INPUT "", dummy$„LOOP„ CLOSE #1„COLOR 14„PRINT„PRINT„PRINT "                        **End of file reached**"„INPUT "", dummy$„„END SUB„David Arigan                   RANDOM NUMBER GENERATOR        FidoNet QUIK_BAS Echo          02-04-96 (13:42)       QB, QBasic, PDS        174  5871     RANDOM.BAS  ' -> RANDOMIZE TIMER„' > -> randNum = INT(RND * 50) + 1„' > -> I've always used the above method for calculating random numbers.„' > -> Does anyone have a better way of getting a truly random number?„' >  That's the truest "random" number you can get. Laterz..„„'Hmmm... not really„„' > Ok - I thought I had seen other ways of doing it before, but„' > apparently I was mistaken. „„'Here... I recently converted it from 'C'.  You might be able to use it.„„DECLARE FUNCTION rmarin% (ij AS INTEGER, kl AS INTEGER)„DECLARE FUNCTION ranmar% (rvec() AS DOUBLE, ln AS INTEGER)„„'************************************************************************„'This random number generator originally appeared in "Toward a Universal„'Random Number Generator" by George Marsaglia and Arif Zaman.„'Florida State University Report: FSU-SCRI-87-50 (1987)„'„'It was later modified by F. James and published in "A Review of Pseudo-„'random Number Generators"„'„'Converted from FORTRAN to C by Phil Linttell, James F. Hickling„'Management Consultants Ltd, Aug. 14, 1989.„'„'THIS IS THE BEST KNOWN RANDOM NUMBER GENERATOR AVAILABLE.„'      (However, a newly discovered technique can yield„'        a period of 10^600. But that is still in the development stage.)„'„'It passes ALL of the tests for random number generators and has a period„'  of 2^144, is completely portable (gives bit identical results on all„'  machines with at least 24-bit mantissas in the floating point„'  representation).„'„'The algorithm is a combination of a Fibonacci sequence (with lags of 97„'  and 33, and operation "subtraction plus one, modulo one") and an„'  "arithmetic sequence" (using subtraction).„'„'On a Vax 11/780, this random number generator can produce a number in„'   13 microseconds.„'***********************************************************************„„  CONST TRUE = -1„  CONST FALSE = 0„„  DIM SHARED u(97) AS DOUBLE, c AS DOUBLE, cd AS DOUBLE, cm AS DOUBLE„  DIM SHARED i97 AS INTEGER, j97 AS INTEGER, test AS INTEGER„„  DIM temp(100) AS DOUBLE„  DIM i AS INTEGER„  DIM ij AS INTEGER, kl AS INTEGER, ln AS INTEGER„„  ' These are the seeds needed to produce the test case results„„  ij = 1802„  kl = 9373„„  ' Do the initialization„„  IF rmarin(ij, kl) = 1 THEN END„„  ' Generate 20000 random numbers„„  ln = 100„  FOR i = 0 TO 199„    IF ranmar(temp(), ln) = 1 THEN END„  NEXT i„„  ' If the random number generator is working properly,„  ' the next six random numbers should be:„  '„  '          6533892.0  14220222.0   7275067.0„  '          6172232.0   8354498.0  10633180.0„„  ln = 6„  IF ranmar(temp(), ln) = 1 THEN END„  FOR i = 0 TO 5„    PRINT USING "############.#"; 4096# * 4096# * temp(i)„  NEXT„„FUNCTION ranmar% (rvec() AS DOUBLE, ln AS INTEGER)„  DIM uni AS DOUBLE„  DIM ivec AS INTEGER„„  IF NOT test THEN„    PRINT "RANMAR: Call the initialization routine (RMARIN) ";„    PRINT "before calling RANMAR."„    ranmar = 1„    EXIT FUNCTION„  END IF„  FOR ivec = 0 TO ln - 1„    uni = u(i97) - u(j97)„    IF uni < 0# THEN uni = uni + 1#„    u(i97) = uni„    i97 = i97 - 1„    IF i97 < 0 THEN i97 = 96„    j97 = j97 - 1„    IF j97 < 0 THEN j97 = 96„    c = c - cd„    IF c < 0# THEN c = c + cm„    uni = uni - c„    IF uni < 0# THEN uni = uni + 1#„    rvec(ivec) = uni„    ranmar = 0„  NEXT ivec„END FUNCTION„„'************************************************************************„'This is the initialization routine for the random number generator RANMAR()„'NOTE: The seed variables can have values between:    0 <= IJ <= 31328„'                                                     0 <= KL <= 30081„'The random number sequences created by these two seeds are of sufficient„'length to complete an entire calculation with. For example, if several„'different groups are working on different parts of the same calculation,„'each group could be assigned its own IJ seed. This would leave each group„'with 30000 choices for the second seed. That is to say, this random„'number generator can create 900 million different subsequences -- with„'each subsequence having a length of approximately 10^30.„'„'Use IJ = 1802 & KL = 9373 to test the random number generator. The„'subroutine RANMAR should be used to generate 20000 random numbers.„'Then display the next six random numbers generated multiplied by 4096*4096„'If the random number generator is working properly, the random numbers„'should be:„'          6533892.0  14220222.0   7275067.0„'          6172232.0   8354498.0  10633180.0„'***********************************************************************„FUNCTION rmarin% (ij AS INTEGER, kl AS INTEGER)„  DIM s AS DOUBLE, t AS DOUBLE„  DIM i AS INTEGER, j AS INTEGER, k AS INTEGER, l AS INTEGER, m AS INTEGER„  DIM ii AS INTEGER, jj AS INTEGER„„  ' Change FALSE to TRUE in the next statement to test the„  ' random routine.„„  test = TRUE„  IF (ij < 0 OR ij > 31328) OR (kl < 0 OR kl > 30081) THEN„    PRINT "RMARIN: The first random number seed must have a ";„    PRINT "value between 0 and 31328"„    PRINT "        The second random number seed must have a ";„    PRINT "value between 0 and 30081"„    rmarin = 1„    EXIT FUNCTION„  END IF„  i = INT(ij / 177# MOD 177#) + 2„  j = INT(ij MOD 177#) + 2„  k = INT(kl / 169# MOD 178#) + 1„  l = INT(kl MOD 169#)„  FOR ii = 0 TO 96„    s = 0#„    t = .5„    FOR jj = 0 TO 23„      m = INT(k * (i * j MOD 179#) MOD 179#)„      i = j„      j = k„      k = m„      l = INT((l * 53# + 1#) MOD 169#)„      IF (l * m MOD 64#) >= 32 THEN„        s = s + t„      END IF„      t = t * .5„    NEXT jj„    u(ii) = s„  NEXT„  c = 362436# / 16777216#„  cd = 7654321# / 16777216#„  cm = 16777213# / 16777216#„  i97 = 96„  j97 = 32„  test = TRUE„  rmarin = 0„END FUNCTION„Mark K. Kim                    RETURNS WINDOWS VERSION        MarkKKim@aol.com               02-07-96 (20:00)       QB, QBasic, PDS        87   4241     BWVER10A.BAS'BASWinVer version 1.0a -- Find out Windows Version„'Copyright (c)1995-6 Mark K. Kim„'E-mail: MarkKKim@aol.com„'http://users.aol.com/markkkim/„'* Freely distributed.  May be used in other programs with proper notice of„'  credit.„'* This program is provided "as-is".„'* Not compatible with PowerBASIC.„'* In QuickBASIC 4.5, run QB.EXE with /L option. If including QB.BI, then„'  replace the ABSOLUTE SUB declaration statement in QB.BI with the ABSOLUTE„'  SUB declaration within this program. Make other proper revisions.„'* CREDIT: Ralf Brown's interrupt list was used to get interrupt for the„'  function.  Microsoft DOS's Debug was used to convert Assembly code to„'  machine code.  Microsoft is a Registered Trademark of Microsoft Corp.„'  Thanks to beta testers, rt911@aol.com and wildgamer@aol.com„'Read the header of each function to find out the usage of those functions.„'These functions are designed to work with most other routines as it does„'not interfere with any other routines. It is especially designed to work„'with other functions in this BASxx series.„„DECLARE SUB absolute (var1%, var2%, var3%, var4%, var5%, var6%, offset%)„'== BEGIN HEADER ==„DECLARE FUNCTION winver! ()„'== END HEADER ==„„„'== START ==„„PRINT USING "##.##"; winver„„'Returns the version of Windows„'COMMENT:„'* Returns only if the program is run under Windows.„'RETURN:„'* Returns the version of Windows.„'* Returns 0 if Windows is not running.„'* Returns 4.0 under Windows95 (This was not intentional, but that's what„'  beta test showed). A beta tester said it's supposed to return 3.95 but it„'  didn't... oh well.„FUNCTION winver!„  asm$ = ""„  asm$ = asm$ + CHR$(&H55)                           'push bp„  asm$ = asm$ + CHR$(&H89) + CHR$(&HE5)              'mov bp, sp„  asm$ = asm$ + CHR$(&HB8) + CHR$(&HA) + CHR$(&H16)  'mov ax, 160a„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H2F)              'int 2f„  asm$ = asm$ + CHR$(&H3D) + CHR$(&H0) + CHR$(&H0)   'cmp ax, 0000„  asm$ = asm$ + CHR$(&H75) + CHR$(&H17)              'jnz 0124„  asm$ = asm$ + CHR$(&HBA) + CHR$(&H0) + CHR$(&H0)   'mov dx, 0000„  asm$ = asm$ + CHR$(&H89) + CHR$(&HD8)              'mov ax, bx„  asm$ = asm$ + CHR$(&H88) + CHR$(&HE2)              'mov dl, ah„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx, [bp+08]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H17)              'mov [bx],dx„  asm$ = asm$ + CHR$(&H88) + CHR$(&HC2)              'mov dl, al„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H17)              'mov [bx], dx„  asm$ = asm$ + CHR$(&H5D)                           'pop bp„  asm$ = asm$ + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)   'retf„  asm$ = asm$ + CHR$(&HB8) + CHR$(&H0) + CHR$(&H16)  'mov ax, 1600„  asm$ = asm$ + CHR$(&HCD) + CHR$(&H2F)              'int 2f„  asm$ = asm$ + CHR$(&H3C) + CHR$(&H1)               'cmp al, 01„  asm$ = asm$ + CHR$(&H74) + CHR$(&H19)              'jz 0146„  asm$ = asm$ + CHR$(&H3C) + CHR$(&H80)              'cmp al, 80„  asm$ = asm$ + CHR$(&H74) + CHR$(&H1A)              'jz 014b„  asm$ = asm$ + CHR$(&HBA) + CHR$(&H0) + CHR$(&H0)   'mov dx, 0000„  asm$ = asm$ + CHR$(&H88) + CHR$(&HC2)              'mov dl, al„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H8)  'mov bx, [bp+08]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H17)              'mov [bx], dx„  asm$ = asm$ + CHR$(&H88) + CHR$(&HE2)              'mov dl, ah„  asm$ = asm$ + CHR$(&H8B) + CHR$(&H5E) + CHR$(&H6)  'mov bx, [bp+06]„  asm$ = asm$ + CHR$(&H89) + CHR$(&H17)              'mov [bx], dx„  asm$ = asm$ + CHR$(&H5D)                           'pop bp„  asm$ = asm$ + CHR$(&HCA) + CHR$(&H4) + CHR$(&H0)   'retf 0004„  asm$ = asm$ + CHR$(&HB8) + CHR$(&H2) + CHR$(&H0)   'mov ax, 0002„  asm$ = asm$ + CHR$(&HEB) + CHR$(&HE6)              'jmp 0131„  asm$ = asm$ + CHR$(&HB8) + CHR$(&H0) + CHR$(&H0)   'mov ax, 0000„  asm$ = asm$ + CHR$(&HEB) + CHR$(&HE1)              'jmp 0131„„  asmseg% = VARSEG(asm$)„  asmoff% = SADD(asm$)„  DEF SEG = asmseg%„  CALL absolute(var1%, var2%, var3%, var4%, majver%, minver%, asmoff%)„  DEF SEG„  IF majver% = 0 THEN minver% = 0„„  winver! = majver% + (minver% / 100!)„END FUNCTION„„Adam Davila                    QUIZ GENERATOR                 QBTIPS_O.DOC                   07-30-93 (18:57)       QB, QBasic, PDS        166  5120     QUIZ.BAS    '>        I'm endeavoring to write a „'>program that will quiz me on „'>    nursing concepts and would welcome „'>any suggestions. I want„„'Here's a little something I threw together.  Keep in mind, I just„'litteraly threw it together.  It has not been optimized, so don't„'anybody reading this start throwing "That's not efficient"'s at me.„„'Feel free to use this in your program.  Just leave my name somewhere.„'And let me know when you finish your program.  It looks like something I„'could use.„„'This is really two programs.  One called MAKEQUES.BAS, which makes the„'questions and answers file.  The second one, LABDOC.BAS, is the one that„'picks the questions and answers.  I have not made a routine to keep„'questions from popping up more than once.  I thought I'd leave that up„'to you as practice. :> <G>„„'Here is MAKEQUES.BAS„„' Wherever you see a **_**  Unwrap what is after that.„DECLARE SUB WriteData (Question$, Answer1$, Answer2$, Answer3$,CorrectA$, CorrectText$)„OPEN "Question.dat" FOR APPEND AS #1„Start:„CLS„PRINT "Please enter the Question to be asked: (Enter to end) "„LINE INPUT "", Question$„IF Question$ = "" THEN„   CLOSE„   END„END IF„PRINT "Please enter 3 wrong answers to this question (Use CR to start new line):"„LINE INPUT "", Answer1$„LINE INPUT "", Answer2$„LINE INPUT "", Answer3$„PRINT "Please enter the correct Answer:"„LINE INPUT "", CorrectA$„PRINT "Enter the text you wish to display when answer is correct:"„INPUT "", CorrectText$„CALL WriteData(Question$, Answer1$, Answer2$, Answer3$, CorrectA$ , CorrectText$)„GOTO Start„„SUB WriteData (Question$, Answer1$, Answer2$, Answer3$, CorrectA$ , CorrectText$) STATIC„PRINT #1, CHR$(7) ' Delimiter: Tells you where each record starts„PRINT #1, Question$   ' Write the Data to the file #1„PRINT #1, Answer1$    ' ""                         ""„PRINT #1, Answer2$    ' ""                         ""„PRINT #1, Answer3$    ' ""                         ""„PRINT #1, CorrectA$   ' ""                         ""„PRINT #1, CorrectText$' ""                         ""„END SUB„„'  Page Break for ABCREAD, Start of next code.„„'This is LABDOC.BAS.  This program is the quiz generator.„„DECLARE SUB WriteResponse (Locater!, Choice!, Question$)„' Lab Doctor„' By Adam Davila„RANDOMIZE TIMER ' Initialized random # generator„Start:„CLS„GOSUB GetRecords„Locater = INT(RND * 4) + 4 ' Generates the random location of answer„' The above had 4 added to it so that there would be 4 emtpy lines„' after the question„PRINT Question$„IF Locater = 4 THEN   ' The next 4 IF-THENs place the wrong answers„    LOCATE 5„    PRINT Locater - 2; Answer1$„    PRINT Locater - 1; Answer2$„    PRINT Locater - 0; Answer3$„END IF„IF Locater = 5 THEN„    LOCATE 4„    PRINT Locater - 4; Answer1$„    LOCATE 6„    PRINT Locater - 2; Answer2$„    LOCATE 7„    PRINT Locater - 1; Answer3$„END IF„IF Locater = 6 THEN„     LOCATE 4„     PRINT Locater - 5; Answer1$„     LOCATE 5„     PRINT Locater - 4; Answer2$„     LOCATE 7„     PRINT Locater - 2; Answer3$„END IF„IF Locater = 7 THEN„     LOCATE 4„     PRINT Locater - 6; Answer1$„     LOCATE 5„     PRINT Locater - 5; Answer2$„     LOCATE 6„     PRINT Locater - 4; Answer3$„END IF„LOCATE Locater               'Locate the Answer„PRINT Locater - 3; CorrectA$ 'Print the Answer„LOCATE 10, , 1„PRINT ">> ";„Choice$ = ""„DO WHILE Choice$ = ""„   Choice$ = INKEY$„LOOP„PRINT Choice$„LOCATE , , 0' ** Turns Cursor off **„Choice = VAL(Choice$) ' Change the string to an integer„IF Choice = Locater - 3 THEN 'If the answer is right, then print„    LOCATE 12, 1             ' the correct answer text.„    PRINT CorrectText$„END IF„IF Choice <> Locater - 3 THEN  ' If anything other than the right„    LOCATE 12, 1               ' answer if entered, beep and print„    BEEP                       ' the below statement„    PRINT "I'm sorry.  That's not correct"„END IF„CALL WriteResponse(Locater, Choice, Question$)„LOCATE 20, 1, 1„PRINT "Another Question >> ";„Choice$ = ""„DO WHILE Choice$ = ""„  Choice$ = INKEY$„LOOP„IF UCASE$(Choice$) = "Y" GOTO Start„LOCATE , , 0„PRINT Choice$„END„„GetRecords:„OPEN "question.dat" FOR INPUT AS #1„DO WHILE NOT EOF(1)„   LINE INPUT #1, Delimiter$„   IF Delimiter$ = CHR$(7) THEN Found = Found + 1„LOOP„„„GenerateRND:„Selected = INT(RND * (Found + 1))„IF Selected = 0 THEN GOTO GenerateRND„„SEEK #1, 1 ' Start reading at the beggining of the file„DO WHILE NOT EOF(1)„    LINE INPUT #1, Delimiter$„    IF Delimiter$ = CHR$(7) THEN FoundIt = FoundIt + 1„    IF FoundIt = Selected THEN„       LINE INPUT #1, Question$„       LINE INPUT #1, Answer1$„       LINE INPUT #1, Answer2$„       LINE INPUT #1, Answer3$„       LINE INPUT #1, CorrectA$„       LINE INPUT #1, CorrectText$„    END IF„LOOP„CLOSE„RETURN„„SUB WriteResponse (Locater, Choice, Question$)„OPEN "response.dat" FOR APPEND AS #1„PRINT #1, CHR$(7)'Delimiter„PRINT #1, Question$„PRINT #1, "Answer was #"; Locater - 3„PRINT #1, "Response was #"; Choice„CLOSE„END SUB„The ABC Programmer             SIMPLE QWK READER              Try ADVANCED QWK READER        03-06-96 (17:43)       QB, QBasic, PDS        166  5089     QWKREAD.BAS '===================[ Simple Little QWK Reader ]=======================„'„' This SIMPLE little ditty let's you read SWAG or QWK files which have„' EXACTLY the same format.  Additions to dump to file implemented.„' Original PASCAL code by Swag Support Team (Gayle Davis)„' Converted and optimized to BASIC by William Yu (03-06-96)„'„'----------------------------------------------------------------------„„DECLARE SUB DumpHeader (QWK AS ANY)„DECLARE SUB ReadMessage (HDR AS ANY, RelNum&, Chunks)„DECLARE SUB ReadMsg (NumChunks)„DECLARE SUB ReadWriteHdr (QWK AS ANY)„„CONST Height = 25                     ' 25/43/50„CONST False = 0                       ' False = 0„CONST True = NOT False                ' True = -1„CONST DumpQWKtoFile = False           ' Dump messages to file?„                                      ' True = Dump to file„                                      ' False = View from screen„CONST DumpQWKFileName$ = "DUMP.MSG"   ' Dump messages to this file name„CONST QWKPacket$ = "MESSAGES.DAT"     ' MESSAGES.DAT or *.SWG„                                      ' Specify the path if required„TYPE MSGDatHdr                        ' MESSAGES.DAT File Structure„    Status   AS STRING * 1            '  128 bytes altogether„    MSGNum   AS STRING * 7„    Date     AS STRING * 8„    Time     AS STRING * 5„    UpTO     AS STRING * 25           ' Always UpperCase„    UpFROM   AS STRING * 25           ' Always UpperCase„    Subject  AS STRING * 25„    PassWord AS STRING * 12           ' Never/rarely used„    ReferNum AS STRING * 8„    NumChunk AS STRING * 6„    Alive    AS STRING * 1„    LeastSig AS STRING * 1            ' Conference #„    MostSig  AS STRING * 1            ' Used for conf. # greater than 255„    Reserved AS STRING * 3„END TYPE„„DIM QWK AS MSGDatHdr„„WIDTH 80, Height„CLS„„  OPEN QWKPacket$ FOR BINARY AS #1„  IF DumpQWKtoFile THEN OPEN DumpQWKFileName$ FOR OUTPUT AS #2„  SEEK #1, 129  ' Skip Copyright information„  Count& = 129„  WHILE Count& < LOF(1)„        ReadMessage QWK, Count&, Chunks„        IF DumpQWKtoFile THEN„          LOCATE 1, 1: PRINT "Complete:";„          PRINT USING "###.#%"; (Count& + (128 * Chunks)) / LOF(1) * 100„          PRINT #2,„          A$ = INKEY$                        ' ESC Key quits dumping„        ELSE„          PRINT„          PRINT "Press any key to continue .. (ESC Key quits)";„          A$ = INPUT$(1)„          CLS„        END IF„        IF A$ = CHR$(27) THEN CLOSE : END    ' ESC quits Viewing or Dumping„        Count& = Count& + (128 * Chunks)„  WEND„  CLOSE„  END„„SUB DumpHeader (QWK AS MSGDatHdr)„   „    PRINT #2, STRING$(80, "=")„    PRINT #2, "   Date: "; QWK.Date; " ("; QWK.Time; ")";„    PRINT #2, , , "Number: "; QWK.MSGNum„    PRINT #2, "   From: "; QWK.UpFROM;„    PRINT #2, , "Refer#: "; QWK.ReferNum„    PRINT #2, "     To: "; QWK.UpTO;„    PRINT #2, , " Recvd: ";„    InCase$ = "-`^#"„    IF INSTR(QWK.Status, InCase$) THEN„      PRINT #2, "YES"„    ELSE„      PRINT #2, "NO"„    END IF„    PRINT #2, "Subject: "; QWK.Subject;„    Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„    PRINT #2, , "  Conf: "; "("; Conference$; ")"„    PRINT #2, STRING$(80, "-")„„END SUB„„SUB ReadMessage (QWK AS MSGDatHdr, RelNum&, Chunks)„ „  SEEK #1, RelNum&„  ReadWriteHdr QWK„  Chunks = VAL(QWK.NumChunk)„  ReadMsg Chunks„„END SUB„„SUB ReadMsg (NumChunks)„„  DIM Buff AS STRING * 128„„  FOR J = 1 TO NumChunks - 1„    GET #1, , Buff„    FOR I = 1 TO 128„      IF MID$(Buff, I, 1) = CHR$(227) THEN„        IF DumpQWKtoFile THEN PRINT #2,  ELSE PRINT„      ELSE„        IF DumpQWKtoFile THEN„          PRINT #2, MID$(Buff, I, 1);„        ELSE„          PRINT MID$(Buff, I, 1);„        END IF„      END IF„      IF CSRLIN = Height - 1 THEN„        LOCATE Height, 1: PRINT "Hit Any Key for Next Page...";„        A$ = INPUT$(1)„        LOCATE 6, 1: PRINT STRING$((Height - 7) * 80, " ");„        LOCATE 6, 1„      END IF„    NEXT I„  NEXT J„„END SUB„„SUB ReadWriteHdr (QWK AS MSGDatHdr)„„    GET #1, , QWK.Status„    GET #1, , QWK.MSGNum„    GET #1, , QWK.Date„    GET #1, , QWK.Time„    GET #1, , QWK.UpTO„    GET #1, , QWK.UpFROM„    GET #1, , QWK.Subject„    GET #1, , QWK.PassWord„    GET #1, , QWK.ReferNum„    GET #1, , QWK.NumChunk„    GET #1, , QWK.Alive„    GET #1, , QWK.LeastSig„    GET #1, , QWK.MostSig„    GET #1, , QWK.Reserved„„  IF DumpQWKtoFile THEN„    DumpHeader QWK„  ELSE„    PRINT "Date: "; QWK.Date; " ("; QWK.Time; ")";„    PRINT , , "Number: "; QWK.MSGNum„    PRINT "From: "; QWK.UpFROM;„    PRINT , "Refer#: "; QWK.ReferNum„    PRINT "  To: "; QWK.UpTO;„    PRINT , " Recvd: ";„    InCase$ = "-`^#"„    IF INSTR(QWK.Status, InCase$) THEN„      PRINT "YES"„    ELSE„      PRINT "NO"„    END IF„    PRINT "Subj: "; QWK.Subject;„    Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„    PRINT , "  Conf: "; "("; Conference$; ")"„    PRINT STRING$(80, "-");„  END IF„„END SUB„„Justin McCall                  CREATE WORD SEARCH PUZZLES     www.earthlink.net              08-22-95 (17:09)       QB, QBasic, PDS        144  9548     PUZZLE.BAS  DEFINT A-Z:DIM SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.2„SUB V1:OPEN "O",1,"WPUZZLE.ZIP",4^6:Z&=6895:?STRING$(50,177);„U"%up()%9%%%#-%^X7;DNo1=DV5R%%H#%%%0%.%%&u1z))q%jSgfaxfBTb=Tko9R'„U"m4=8N9oN.kYsjITYfSTGDX.7kEMnxsl+7uH361Gb-n5[^MzMOL';tP7f\L',;PV„U"qn,B3^+G>HC+y2KPi)baX$[$EEk^6d]hl-V*EL8>RWY^rqEeWXY6R\[$*j#*8hb„U"N)Red.K'aCFsCuq\o=JNTB>wNnR8vHvM2>mW,JZtl#5lls/H_mq'U6MOr^w1\^b„U"n16[tXue?tlZICgy1?m^N>HSS=:YC5kH$Cg)O9TPlN>;UnUW^e\.Tmw+/p/y1i=„U"-c;XF:<'\ta:sBh(_g89%u1v.+JEP3^C%P9:/cf4+l)vS:MUsy7*tKrAs6mIeTa„U"9g/XdnJS9JVG5,8Fb?uYGG3OZC21f_[B((bEEKBI3#I:/>RBjaG(Y>qR,SrgJ?%„U"o5_z/%I[bbmFh*k1c$*Revev[.kpb?7%F<kmI\l:^vRbU^JLHTX+>Mo$rT:hT6,„U"I)EkX,T5]dnVPuPmFsvNy=]b5fNm[IXfU8y.^/LicPl:9z';oI&:2z7t$D4:Ld/„U"M\Tej4vl.kcF/Z2pVz):?)11%Twzck2R;I3:f/hHp_HtDThsI=Sn:^Z<$elORJn„U"hTV'9p[n042o?#cYGxW=gd<l7%M%Ih_vJcaDR54Kp*0A<&&k>aK#?3iCQbc:/^b„U"F+X**HIS<1X:(^<m:bYW_,%FV+r0)634].?pG95g=NEi)wbr]1gQcwGNd+TY=x4„U")vfu<_fi;heRrICpPB/C5G1DgAqxiB1_)5mulj=M4/%#11[i/k9M_'')GudP7]B„U"K=e9c/^zvrfL.x,GG_I&p,2t0yT7,SEl(Fmc>poRM%9+FIkDO9ocT9YDtWY2Lcb„U"ofZHM9hl/97OxAbaxn[,sRK#>]ed(;S5ZEeZ/kAPJVwb2X4Zuoi%?[.>:Ym)Ca2„U"-lY?bO?9#6575o,U8J6Q4E0#u*_Y])LZR7QH+:x1s\1sW/l;mfd-v2F3gX[H+w%„U"Z=/XkPxCdW'%4J9WE6rUe%G<t0'[E38MFPcFX'89?eu%F$S=uAGNBn?DUJ-Hn:/„U"=<<4$2UspYDt4<'EWQPg9WWQ\v69M;*-:O9T(4mRzFeouNe.0>Z]2IWL86C3/Zd„U"7m94XN.3oSS0glK;'Iq'2RGlQl:xHMPRO4KfmyCca2-]XF[W6KZW%BiAcUE-0'q„U"[J+s2D*,(iEQ9H1(m/I^vyqmMQEtJ2ixdEi'<R,6]o*lr=7u5=:G(TYN/5NUV7U„U"%E?rE8eH4tkdXJR\UI/Q&f;5.(9:^S'oRpvmYQO.)g2fC-r&+lTc(A#P6Y8hm/H„U"e::G/tie#[A^jvp<t5ZIv'<Q?2/o2fRH;uJZ+&lnhyFat7FcSAQ$gvakDp-aGEK„U")g=VmmR*6RcWfT/p&YVogdwG_/BfgIuph$aw?3D$X1j9Ive\I>PWR%)ayzO_4/j„U".5[^1Vei3-be:$7CV,5?&'<*'m'Ss(dBqdqe8FpuMMXP9>oF<7R.ErO4BY5yz#y„U"bvP=MXvW\Ur6)?2&?C_96l5h]P(^1tkB/.#1HiQwYpT%N</N_+]7aF7uz8;jc/'„U"hJG[;Q%E<:Y=DeFXIoQ7]MyIE.HhLbE2)w]?_-t(AvPIv8>#5Lt%C9%tSSuftns„U"dh+ae\1F.tLor8Msk+j9\:?u_M*E0M%5=&62>_IBUp3:cs.qN%i&sYw>hl7beKN„U"r&&co8KZx/ifJdOpqDWZH#Bf1Q&P=Q+2?V.0<41^0&B,8siB;#-g->-Lu%cSdI%„U"*YYO+J&oFj)(7gLwC<kT3Ie;*W):9$3DYkQeFTZ)f84rNWXU1oI3wCI0ASF&=nU„U"XYr;B?b,HWa.;Wq%4JkaHpup\lM9?t]r\1C?$ERt/H_I=FEg\C.p1&FC4PU1Um$„U">O'wlg<+bM\Ha(<HBMB]k=\_LGU:J=3YbJ#((8(e#kc)66(:#/qAL2JdH4l6(JV„U"3B#\h8-k\QXg*ig,D?[A:M>s\m+rH(H2SfjwKLs\??NRhRf6:aA0S,d=sHk2Rh^„U",Vh:Gb=swkqD[5bS*fj.)iArSTpP,'EvBw3N%>c?<Cc<blg.qL?gJ_<Y%$ye5<a„U";%p:t04%&NK^(O'lC.W707v6mC[oEfII-UT=B,EFg;)S$WDQtj7'B-zR3;X[uTL„U"G-4bS3;ZmykQL4G5_6-o.-T)4S(R%glkULO)[&p/UWO](:16**<*h,>f\/YUWU,„U"d*h>h#X*h>*iB*h>>j0/YUW]]VQp0HIt>JI,jp:1-6F,/tUW_XIO=IjA.M=I,j8„U"xU9m[xsu:ITuLb\O?WqQvHV'^UHq3M3xYF?r+_NIpWFy%H-[OapDhu0R_G2h,?2„U"R)Db)#VX<oU1#lkviY[>A3SUqZ+vb%=RKyjw[dQjUdKciG5oV_:pY^u<ItYIsWS„U"([p+$.]4*$GKIh>htWJIxcBC'PVTD9W6;SK3Tn-5ymGrpeink'D$hFmEI7;g1RR„U"7[1>5/u.%n,)M6^f*a=cC$N2'gZ5&I7tPlCLAu1#TvJ06C[l'/Eh)CH?hc0)_6C„U"6bs]\gJ$i\arQr9e=kZiCSS?#H))Q/,4\Dc?G4w2^FL_oSoAwkaWkd\'i42\VMJ„U";>7,gby*1n-E+greMW#XY;%6rBnd>3SF%b?-po(NR+UM)l46x*?7B&nEvW-/ZsZ„U"f6[<ts%R\^iMABD^Pwz^E^9eCex4'Fb/?fF08JR2Tu'ouXfV6unp&D7d&U3CqvM„U"].ZMH.CAbFXj'e7^1FZ$Jc&,zKIphp8VAqKGOq<eu)aW%l,7ce?eu256>gu>0S3„U"Gj;%Ivc6P$DGO>E,VpG3/pr/p?>\<FG4.$?jmc7\H?03j1\<hVlob<VG\VE82l\„U"F\J>>O\JGbp,95:.ZWl>523?0?BP1v$B5IT[f=y=2mP361P,L6MuyDg]xDi&=8a„U"&8Ihc1xiYP)cc=8f(S>S&WN&Ea<4J.;Ih(qigPT-e/bbknMR7H6biD1XJ+(/i]M„U"*,%2iePuYiE%$$kjSa,Ad+b(GgAe\)tc[p,4cJQC=r\A+dB[#,5fS4qDQ=vkTFa„U".$q(W&Z4=Ejm-aVfk]]h)-7]a?_Zm[d,4c1QC?v\Ab6A[4,5f14tF;^';rmY_7W„U"t7FE15/eXloWa%SK;bPD95h3Ah2=0=]UE;r2A]\rdy#aU13VN;-Q*\'G3DTO:]#„U"Q68s*&WjtB<'(3'/B0R=K053Cm0>4;E<C0lNDL1NIN,tq8JYH<eyL1n#IwBWKNf„U"sIpI%\Ng#t-[:cY+D+nulV#'m9QCMTeq4E(+5LL^\S;fKNZ2Z?\m;GDo+;6:rA(„U"bLuIjUXo>==k'DJ&ARv$tYwlp^QC/.:J$[1^<*pSJGLuHRNE$61>X4H-=(h%]r,„U"s17X&^Bj8R#BO#=DX?UktT/-riLeMyv3(wlk:hKrSag8SI>nabP_yvXe:E(wbjf„U"pIrd(jMco/,Bkoh0mnfk,YufER_nt&]kb7/Q22KqR(Tbtp'm[m)<CAXLIKJTZ'R„U"Pk._&)4p)7GW)z/Wa\uz6ljVt()^SFVr15OLA%rbFDgrblfX$Xl'hVt5#qmsrO3„U"Gd:ag<gO6Ko_[gx]](iSYN&35,>DW_;T,ssye[l06/3C/2jmBn+Op=;%)7HnS_J„U"b[e=XEJV2Q)*CR4.Val2c^;gHMQ5%cpJWoW>d5Oi6d0>O8[o,p6YP?.c#%vH?[y„U"6GUuLF]^TSSc&9d1X$xq?/5*(kbZ4#\iwT(&G6%js9N_D_di/%M0K?Ivi)qegJ&„U"IxoCfueb&ZKC7q4j5M%%daV3C1GkYRu^1M_bsC7[ZrIPKZhK%gH4:Fz/k3I8feR„U"ZZmMq=%C0<N\<h;ULBZtSN('U3W<grU::4%f6yG?U/c,kn%BFGQer_<Jk7Eu7/q„U"l^&a-C&$:AuIbg&6B6#P8XQA42A7=X.FLxc-qP%er%U5EuGPx.^r40m_MpaL2%O„U"m1UrZl*f0%LNd3i$7Zb$ur05$Zd0uLpKNXUigt/j'>Pft:Ivb+q3S)NVuxQ:uqg„U"b_=JHq2^3F5u/Lfn2lqSvskv3=($zoskMWPIK(_7N+>WjTe&kEJ8bVosU_TFFoO„U"8n7\2#IX]ZS5O?KJA[pqcr21()r574l(qDP(r55r:c2\jIFd-Z5IAgo1pf-BH<C„U"ob5ua[%\wM=0UZp=0kgwW.d*jMkwJZie?\MLp*n1%+4$>BmE\D9pd3xR<1ZNSm4„U"'KlqpJ+3pFXruV<H<rj3qvK=:FDlx8>cD-MtFts\UjfDDC_lbrv<5x1T#JDvVD\„U"LWu0M'HZdkV<de^*szK_ArrM7FX_Q4pmR%^_wB-H$s>1(IXPa0YM1PCA-R0nw^q„U"I+>.pFYn41-JWrT^0Z3AY$(;vIkMlHJdMbrSJRut6go4,%*>nvu%EQ.D(ggOiLz„U"t0x15DdkI:j#sg2so?8q]Q5Quv_tNG6p'GZwVb(t6vj,(O&xgz$RK2L6tu&?S5i„U"PWjAFZt?EU$syA4:KCNiko#msadNxRH3whj&\84#]w:/5o=n<1MBU:j2\fkuefb„U"/A#t<SFW-?RBGTqM-EK#geJ^ozw,C:S^q&,<PW*%Bh,5a(^ga61K*jknO4nGhq1„U"F8auEMsnt%LdPnhb+X?ltRo(EBiSkOs8lgsZjSmKUmP*RG\[gG826V,126TC6AH„U"-CmAHp/#o=IngGSbBMt5ubKCkfCs1_(cqfdp\I.cLX9RuZtL;b.VJj[OAM,DK8>„U"co'DFS4&pI,xYe;QXFpTh'X5NBE.M;yA:1W,N(0RSPre<X;cqj0,0R>[tj;0B)>„U"[[MqR7-DB4i%$^[=-O?loo)d\K,F&/,;A<=^#A+?kU5P*LFF/;0ADg#Tk,_U<uP„U"2F_N/owlYPNX6dnBFn=n<o/>dr2=.[4=)EI>b0[*P(2-JG9SxK*2ceC-s<CrfTI„U"c8-x&zIy*mmCu:5vH7vd%z7O-cmpD%q'oyS,2RqjO9NqQD:?LUIu^0]_*Pa7+X'„U"lHWW=te_re4/_w8ZKNy\V&o#v,C2i1jC0a3jWJKQ[:tWFj9EoAW2.'M-oB'Cl<;„U"^0cdK0^Br;2+i&gQaKp0^B;Y2+ig%QaK0##r;aEWecS5+Z^ra:wUF%-?-8VTtlS„U"\gYFgR,zOj..Iv%9S0$-5'S;h8+8tl-<uQJWRRwwFxCwaObS.hN755.5h75kV.h„U"75gK.h7J5+.hK7Sc.hlP5GM-lP5=-(Ges8.(GP/VR'p<v(GY/V<'>]EhP#wGFa'„U"6U2WOT\>IaRE/rcEb>w'6F[BRTqkPAKG'h/x55n.&V\M=1x6IRqBvopf,sE1_tM„U"52Z95eZ&f>qV)t)H<-sC3TOg-S32G\dJ-kNpg)Nyjsc8MQR^zG)$DJpW_(u&xIJ„U"A\putHiBpWM8<=49i(=Tq0;jqGOuduoTwFMRjGVEhlc9puu<%up()%9%%%[-%a1„U"7:Dfa4XaM,%%%IT%%%.%%%%xj%yzuS[gfx^h)*>T.[9M\HYxewqHWJ-78JD<5pf„U"/$mo#E.sbTbf/t5)ROZc(lG1(nNLzn)oaeX+em,1QhR>jVG\]S9fEe48YpKq7l,„U"$[^apan;>,7g]8Aq\#r*bG_LBM_Fc$V[<F??brx[W]_/b)Fk,CVl56gc6W#lL^c„U"5;/&Q_fS*P0rR]WrAz\CHC=is6/[tJcW4Gn9HeUDl=bOA>dX$nEgSe3)CEF=U>_„U"qw3RbF<$68oR8SA;xkU*zFEQ5SG&0Z]u0)VjY#f%pjp9B,ScLF,j[qvr:KpF[>M„U"J<WjnUte%>CdGp5f4tnOgC(GT'V,RVZKRD(qxd:%ZEMchp<+&uU2ppDjRe5g+>/„U"]Pn<[eQP_n<3?VvvlPldzerR*9wm#fP;V(-E?Z\0HnC*U3/?q,O-07%USX?<ILc„U"lwWiVFj0SEtP9+\?1b=G?_,mR?h8IRC/(WXFj4]U=GQ_'bK/G[TEXp-K,J1<fE;„U"EDU-'ohwZTtQ4#-?ulDc+]_E2=rY+(/59(8'kU892$tJYNBb7.R'Om^cZP4[dA/„U"\#ROHk_kLtMA-[CZ#$V6SX^PmE^]TtR+K][q-G=*iwS2pEc$3_mP=fm;JEtNdb0„U"FmOZ9Y$VD$M0KvgeU;Qn,1)z-\uV]F(WURSQIE.GMH9TC.k^,4ZIZ.)gq6eLijd„U"fj+:($Rqm&?D=]F;c0S:LurIV)i2YV:z.u>OO;+P>AAc1Kv%gYvX)]p]eWU-(30„U"_JEk>#--P6f;&SbHNO,MnFz<9,6pA5>Lp(%+[L#?tP]fsWjZFXhwx,:grNcQ1G>„U"Lt13-KVHKv)m8=\am(u?C=CS*xXq_JE55&ps'q_3<EiRl#p_7jpQ]m^a&dz]9_=„U"fUIIW+i6]a-1-GdG?jp(0[Q8;il)Wcsc81f^9r7eata9VC,C8*]$KD\i+qhZ^ex„U"5/x7YZG]OW/=*B[m6?N[O-Ci[MKbh>k9$j%\KxLX3M\VQp3b_?cND#oflrI'(N,„U"*jZf6[5-1fyHHK6ikrO7qY\T]29']B*aP()Knu3h6BHgPGoX5GRI^m&UXKB/R*t„U"J&R;^=[Gg,*Q]ps>pTP6>F25N']G5ue5iA3jsHNeDf%U)T8Xp7=6AM7*V/]^\34„U"Ri,6Rj$*O;2GCE:58;bFRXk-I,&RkTWQl(q/)Y)pwK(yCK*Fa3;==2KA)cfwV]j„U"ji$kS<I$Vdf''%Ia3ae>xY?hQ/C\j')ssMnJ>zhy7+B^dDT6ZFO&*]/4(x>2rIv„U"5\w\aYN0SQhXP?aiG?1UVjY*2M^]&fuh/[UIh]C8%'<KD-;*tH91Ut5_]l?:PTR„U"V?-eN-S0EcO#$QzT6ZnSx'[[X+oocUYm-Rmh]Nm9PcTs3Yu7yZ>7?BfO:OnJA^A„U"N6Xm\*t<fJ2T5Cn/T_i>k6J:r0tJSMBRpN[r6OR,D,q;R>jXBN;J*$B9e)U1OPX„U"-.qzQ[1G7z7;'W9wFJaEQ&]Of<(6Cz.MIWov+oIl)ALz'yT\mKdUNA:wCA\9V.H„U"z]l/Y(aO7lI>FLnd2ai[os>Cvh>CauKeHtDuQC?7HkBa0J&nkT7>%_Fm+Zmus;h„U"(<KLhnG8YtI%D=4X-WG8[f&dp9WG1*?ZiLiE5fFbI3YPnCEGZP=13I%0gbKh#h+„U"b7R%djTm:*;paFWgX2?aa'\(vI5.$*5jC3pm=1h^6Z[+[hXp6o$L/)(*fTpxaN1„U"uA/p#=.+[qSws9%KU?1.=21*eQ:M+WNE\ybpPPK1%5X+eOZ5.F+9*5Bg(dw2Z/L„U"NoL%15FA'>Ht8js8[z1veZUDWo&)VmIU%EaxF#5,B-rXz1W,,i0sR?E&LOU9tBo„U"TOU_*_1_hPapUi7m39EoVnU/0whM*PH+G=u'kqgio+\K.6PA)T6F'Z^s'R(-cZl„U"#<6M:&]CGu0OALiGo%^aq)418ua9*1>VaAjtr3a9lj1VaT962Vca9V2>Va9v#N:„U"B,=jJJvR5B)CE^4pt3c_Y9;'DCjF/%Zt.G*x3AhmfY)r]mf/i(Y9N*OxeUC?Pb%„U"p4MzBKwkq+ac/;.Ia90^;sac%/;Ib&9/;I(e0QiC:^iE'MvOUCI_wxJeM+r)sz9„U"m(7)Gn+mZzKLo37'u;CI)MQdp0[&Ph<KszUUE^z1\(iX93*D&NAbe(w1/id$M>$„U";Na/YiX9-'_xI1os?Z'(GvG2TzH:&X7NAbu$w1oq,CiNeX,IhkBI*GS$^nQHHf]„U"$;Hs*Yzi5YG,/CsK#PT>mC^:'bCC3DTpfY$^#Nl',EjTDQVFe;,Lk##*h^7V:T+„U"#T;Ng-OYJ?K-58Q?r%n4,'r.Y/?'S,',-PWzM,-(bQh.reu3rcz9%bC2;QGJ#G'„U"P'[\7?c9j&<W?TeWrkB1NO=Ec8d?=[>TAQmD<Ra-hbyRKfCcS74oB,jJaRKonfB„U"t/oyMuG1(q5pTq<\/h-8[PS8Qo8bBbvk\q_t%dup(%)/%%[%%%Y\Y;D5(u(h-%%„U"%%-%%%%0#%%%&Iuz))%qjSh%klUQ%\QZU%2/up%()9%%%%-%($Y;Df.wBR%m&%%„U"%-'%%%0%%%A&uz)&)qjS#ithDk$D:\mU5?h++x4D:^fIwh)7>RdI9f7h7E(A2<1„U"\H^v(8mqWjwn(BJ0pm4:3bPJu5StnHX$fP:-wG;04:%A^KLm&<llE3yPLNv<,QA„U"-g<h1,Y[h2cLsC>(IL#M2_7_Mg1:##MDDm3L+2R1,ksEEJ$fDoN^HAYe:hhf<yr„U"2l,rLLoEyX9.sgn)=S-7=X[Ss:3*8emUw1D7H>)o&Lw&RtU1%Wx22o_l5m:40kf„U"$.i%29Xm4k]C5-fUNg%L69sXUML-CXxI<3SlcrkH7UtL4sE4nf7E]'[=JKTNoR*„U"^z<)cQx_Ta.NyS1j&Jt04V%j]M\[JgbqwJb>wX6,oHY_*?par1Kv.3[Wk^8?O$G„U"D.Uw%P2o4Ihd?csu/A:o>jJMAM#o]u1'SmMRr$l-Hgj;3YDYZdDj-3s)u%p&'9%„U"%9%%%%-%^\X;DNIo=DV[5%%H&#%%0%%%%%%%%%&%%E%%%%%%%(%&uz)))qj%Sgf„U"x%up&'%9%9%%%%-%+a1:D]faXa&M,%%%IT%%%.%%%%%%%%%&%E%7%%)5%%%xj%y„U"zuS%gfxu%p&'9%%/%%[%%%Y\Y;D5(u(h-%%%%-%%%%0%%%%%%%%%&%%E%%%%z=%„U"(%&uz)))qj%Shkl%up&'%9%9%%%%-%($Y;Df.wBR%m&%%%-'%%%0%%%%%%%%%&%„U"E%.%%U=.%%&u1z))q%jSit%hup*%+%%%%%)%)+%[%%+%p>%%%%%„END SUB„CLOSE:IF S=122AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Justin Pasher                  DUMP OUTBOUND.HIS TO TEXT FILE FidoNet QUIK_BAS Echo          02-07-96 (16:11)       QB, PDS                292  9748     FDHIS.BAS   '-> I'm kinda new to this echo, so hopefully someone will have an„'-> answer.  Does anyone have the format for FrontDoor 2.20's„'-> outbound.his history file?  If so please post it for me.„„' Try this code out. It works fine for my FD 2.02. I believe the formats„'stayed the same. Enjoy! You must load QB.LIB on the command line.„„DECLARE FUNCTION Cvt2Str$ (Value!)„DECLARE FUNCTION DayOfYear! (Month AS INTEGER, Day AS INTEGER, Year AS INTEGER)„DECLARE FUNCTION CurrDay! ()„DECLARE FUNCTION FindFirst! (FileSpec$)„DECLARE FUNCTION FindNext! ()„DECLARE FUNCTION LeapYear! (Year AS INTEGER)„DECLARE FUNCTION Pad$ (tString AS STRING, Spaces AS INTEGER)„DECLARE SUB Check ()„DECLARE SUB GetFileNames ()„DECLARE SUB Header ()„' History Converter v1.1„' Converted from Pascal by Justin Pasher„'„' Converts the FrontDoor history files to a textfile.„'„'   The first record in the .HIS files is not a valid history entry. It„'   contains the date/time when the .HIS file was last packed or when„'   it was created if it has never been packed. So if you're reading„'   the .HIS files for any reason, skip the first record and you'll be„'   at the first valid record.„„'$INCLUDE: 'QB.BI'„DIM SHARED Regs AS RegType„DIM SHARED RegsX AS RegTypeX„CONST Revision = "1.0"  ' version number„CONST False = 0„CONST True = NOT False„COMMON SHARED FDenv$, Quantity, NumFiles, Head, NoCallers„ON ERROR GOTO 1000„„' ****** Pascal structure„'    Year,                     { 1990-xxxx }„'    Month,                    { 1-12 }„'    Day,                      { 1-31 }„'    Hour,                     { 0-23 }„'    Minute,                   { 0-59 }„'    Second,                   { 0-59 }„'    Zone,                     { Zone Number }„'    Net,                      { Net Number  }„'    Node,                     { Node Number }„'    Point     : WORD;„'    SystemName: STRING[30];„'    Location  : STRING[38];„'    TimeOnLine: WORD;         { Seconds spent on-line }„'    RcvdBytes,„'    SentBytes : LONGINT;„'    Cost      : WORD;„„TYPE MailHistType„    Year AS INTEGER           ' 1990-xxxx„    Month AS INTEGER          ' 1-12„    Day AS INTEGER            ' 1-31„    Hour AS INTEGER           ' 0-23„    Minute AS INTEGER         ' 0-59„    Second AS INTEGER         ' 0-59„    Zone AS INTEGER           ' Zone Number„    Net AS INTEGER            ' Net Number„    Node AS INTEGER           ' Node Number„    PointNum AS INTEGER       ' Point (if applicable)„    SNameLen AS STRING * 1„    SystemName AS STRING * 30 ' System Name„    LocLen AS STRING * 1„    Location AS STRING * 38   ' Location„    TimeOnline AS INTEGER     ' Seconds spent on-line„    RcvdBytes AS LONG„    SentBytes AS LONG„    Cost AS INTEGER„END TYPE„DIM SHARED MailHist AS MailHistType„„TYPE SearchType„    DosJunk      AS STRING * 21„    Attr         AS STRING * 1„    Time         AS INTEGER„    Date         AS INTEGER„    Size         AS LONG„    FileName     AS STRING * 13„END TYPE„DIM SHARED Search AS SearchType„„DIM SHARED His(1 TO 25) AS STRING * 12„„  CLS„  RegsX.AX = &H1A00„  RegsX.DS = VARSEG(Search)    'Set DTA Buffer for FindFirst & FindNext„  RegsX.DX = VARPTR(Search)„  CALL InterruptX(&H21, RegsX, RegsX)„  PRINT„  PRINT "  FrontDoor History convertor (revision "; Revision; ")."„  PRINT "  A stupid program from and copyrighted by :"„  PRINT "           GÇ Janssen, 2:284/134@Fido and Helmut Kicken, 2:284/701@Fido"„  PRINT : PRINT "  Converted to QB by Justin Pasher": PRINT„„  '******** Get FD directory„  Path$ = ENVIRON$("FD")„  IF Path$ <> "" THEN„    Path$ = UCASE$(Path$)„    IF RIGHT$(Path$, 1) = "\" THEN FDenv$ = Path$ ELSE FDenv$ = Path$ + "\"„  ELSE„    PRINT "  No FD environment setting found."„    PRINT "  Example:  C:\FD>SET FD=C:\FD"„    SYSTEM„  END IF„  NoCallers = True„  GetFileNames„  OPEN FDenv$ + "HISTORY.TXT" FOR OUTPUT AS #2„  FOR NumFiles = 1 TO Quantity„    OPEN FDenv$ + His(NumFiles) FOR RANDOM AS #1 LEN = LEN(MailHist)„    Check„    IF Head = True THEN PRINT #2, ""„    CLOSE #1„    Head = False„  NEXT„  IF NoCallers = True THEN PRINT "  There was no activity today."„  CLOSE #2„  PRINT "  "; FDenv$; "HISTORY.TXT is now complete!"„  SYSTEM„„1000 IF ERR = 6 THEN RESUME NEXT„„SUB Check„  DIM SendTot AS LONG    ' total send bytes„  DIM RcvdTot AS LONG    ' total received bytes„  DIM TimeTot AS LONG    ' total connect time„  Empty = True           ' if no calls (true) then write no callers„  GET #1, , MailHist     ' dummy read„  IF LOF(1) = 102 THEN EXIT SUB„  DO„    Text$ = ""„    GET #1, , MailHist„    IF NOT Head THEN„ Header„ Head = True„ Foot = True„ NoCallers = False„    END IF„    Empty = False„    IF MailHist.Hour < 10 THEN Text$ = "0"„    Text$ = Text$ + LTRIM$(STR$(MailHist.Hour)) + ":"„    IF MailHist.Minute < 10 THEN Text$ = Text$ + "0"„    SysName$ = LEFT$(MailHist.SystemName, ASC(MailHist.SNameLen))„    Text$ = Text$ + LTRIM$(STR$(MailHist.Minute)) + " " + SysName$„    FOR A = LEN(RTRIM$(SysName$)) TO 29„ Text$ = Text$ + " "„    NEXT„    IF MailHist.SentBytes = 0 THEN„ Text$ = Text$ + "N/A       "„    ELSE„ Text$ = Text$ + Pad$(LTRIM$(STR$(MailHist.SentBytes)), 10)„    END IF„    SendTot = SendTot + MailHist.SentBytes„    IF MailHist.RcvdBytes = 0 THEN„ Text$ = Text$ + "N/A        "„    ELSE„ Text$ = Text$ + Pad$(LTRIM$(STR$(MailHist.RcvdBytes)), 11)„    END IF„    RcvdTot = RcvdTot + MailHist.RcvdBytes„    Minutes = MailHist.TimeOnline \ 60„    Seconds = MailHist.TimeOnline MOD 60„    TimeTot = TimeTot + MailHist.TimeOnline„    IF Minutes < 10 THEN Text$ = Text$ + "0"„    Text$ = Text$ + Cvt2Str$(Minutes) + ":"„    IF Seconds < 10 THEN Text$ = Text$ + "0"„    Text$ = Text$ + Cvt2Str$(Seconds) + "   (" + LTRIM$(STR$(MailHist.Zone)) + ":" + LTRIM$(STR$(MailHist.Net)) + "/" + LTRIM$(STR$(MailHist.Node))„    IF MailHist.PointNum <> 0 THEN„ Text$ = Text$ + "." + LTRIM$(STR$(MailHist.PointNum))„    END IF„    Text$ = Text$ + ")"„    PRINT #2, Text$„  LOOP UNTIL EOF(1)„  IF Empty = False THEN„    PRINT #2, "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"„    PRINT #2, "Totals bytes sent: "; Pad$(LTRIM$(STR$(SendTot)), 36); "Total bytes received: "; Pad$(LTRIM$(STR$(RcvdTot)), 9)„    Hours = TimeTot \ 3600„    Minutes = TimeTot MOD 3600 \ 60„    Seconds = TimeTot MOD 3600 MOD 60„    Text$ = "Total Time: "„    Text$ = Text$ + Cvt2Str$(Hours) + ":"„    IF Hours < 10 THEN Text$ = " 0" + Text$„    IF Minutes < 10 THEN Text$ = Text$ + "0"„    Text$ = Text$ + Cvt2Str$(Minutes) + ":" + Cvt2Str$(Seconds)„    PRINT #2, Text$„    PRINT #2, ""„    PRINT #2, ""„  END IF„END SUB„„FUNCTION CurrDay!„  DIM Month AS INTEGER„  DIM Day AS INTEGER„  DIM Year AS INTEGER„  Month = VAL(LEFT$(DATE$, 2))„  Day = VAL(MID$(DATE$, 4, 2))„  Year = VAL(RIGHT$(DATE$, 4))„  A = DayOfYear(Month, Day, Year) - 1„  IF A = 0 THEN„    IF LeapYear(Year - 1) THEN CurrDay! = 366 ELSE CurrDay! = 365„  ELSE„    CurrDay! = A„  END IF„END FUNCTION„„FUNCTION Cvt2Str$ (Value)„  Cvt2Str$ = LTRIM$(STR$(Value))„END FUNCTION„„FUNCTION DayOfYear (Month AS INTEGER, Day AS INTEGER, Year AS INTEGER)„  IF LeapYear(Year) THEN N = 1 ELSE N = 2„  N = 275 * Month \ 9 - N * ((Month + 9) \ 12) + INT(Day) - 30„  DayOfYear = N„END FUNCTION„„FUNCTION FindFirst (FileSpec$)„  Spec$ = FileSpec$ + CHR$(0)„  DIM DateTime(6)„  RegsX.AX = &H4E00„  RegsX.CX = Attr„  RegsX.DS = VARSEG(Spec$)„  RegsX.DX = SADD(Spec$)„  CALL InterruptX(&H21, RegsX, RegsX)„  Ecode = RegsX.AX„  IF Ecode GOTO NoMore„  F$ = Search.FileName„  Null = INSTR(F$, CHR$(0))„  IF Null THEN Search.FileName = LEFT$(F$, Null - 1)„NoMore:„  IF Ecode = 2 OR Ecode = 18 THEN FindFirst = False ELSE FindFirst = True„END FUNCTION„„FUNCTION FindNext„  DIM DateTime(6)„  RegsX.AX = &H4F00„  CALL InterruptX(&H21, RegsX, RegsX)„  Ecode = RegsX.AX„  IF Ecode GOTO NoMore2„  F$ = Search.FileName„  Null = INSTR(F$, CHR$(0))„  IF Null THEN FileName$ = LEFT$(FileName$, Null - 1)„NoMore2:„  IF Ecode = 2 OR Ecode = 18 THEN FindNext = False ELSE FindNext = True„END FUNCTION„„SUB GetFileNames„  RC = FindFirst(FDenv$ + "*.HIS")„  IF RC = False THEN PRINT "No *.HIS file(s) not found": EXIT SUB„  Quantity = 1„  DO„    FileName$ = UCASE$(RTRIM$(Search.FileName))„    His(Quantity) = FileName$„    IF ASC(RIGHT$(His(Quantity), 1)) = 0 THEN His(Quantity) = LEFT$(His(Quantity), LEN(His(Quantity)) - 1)„    Quantity = Quantity + 1„    RC = FindNext„  LOOP UNTIL RC = False OR Quantity = 25„  Quantity = Quantity - 1„END SUB„„SUB Header„  Month = VAL(LEFT$(DATE$, 2))„  Day = VAL(MID$(DATE$, 4, 2))„  Year = VAL(RIGHT$(DATE$, 4))„  IF LEFT$(His(NumFiles), 1) = "I" THEN„    PRINT #2, "Inbound Mail/Fax/BBS callers history "„  ELSE„    PRINT #2, "Outbound Mail/Fax/BBS callers history "„  END IF„  Text$ = "(" + RTRIM$(His(NumFiles)) + ") from "„  IF Month < 10 THEN Text$ = Text$ + "0"„  Text$ = Text$ + Cvt2Str$(Month) + "-"„  IF Day < 10 THEN Text$ = Text$ + "0"„  Text$ = Text$ + Cvt2Str$(Day) + "-" + Cvt2Str$(Year) + "."„  PRINT #2, Text$„  PRINT #2, ""„  PRINT #2, "Time  System Sent                   Sent      Rcvd      Duration Node Number"„  PRINT #2, STRING$(79, "ƒ")„  PRINT "  Reading "; FDenv$; His(NumFiles)„END SUB„„FUNCTION LeapYear (Year AS INTEGER)„  IF ((Year MOD 100) <> 0) AND ((Year MOD 4) = 0) THEN LeapYear = True ELSE LeapYear = False„END FUNCTION„„FUNCTION Pad$ (tString AS STRING, Spaces AS INTEGER)„  IF LEN(tString) > Spaces THEN Pad = LEFT$(tString, Spaces): EXIT FUNCTION„  Pad = tString + STRING$(Spaces - LEN(tString), " ")„END FUNCTION„Douglas H. Lusher              LED CLOCK DISPLAY              FidoNet QUIK_BAS Echo          03-23-96 (15:23)       QB, QBasic, PDS        200  5604     LED.BAS      DECLARE SUB ClrRowCtrMsg (Message$)„ DECLARE SUB LED1 (Spec$)„ DECLARE SUB LED2 (Spec$)„ DEFINT A-Z„„ 'GOTO Clock„„ SCREEN 0, 1, 0: COLOR 7, 1: CLS„ COLOR 0, 1„ LOCATE 3, 6: PRINT STRING$(69, "‹")„ FOR R% = 4 TO 8    'change 8 to 10 for large LEDs„   LOCATE R%, 6: PRINT STRING$(69, "€");„ NEXT„„ DO„   T$ = "  0:00:00"„   LOCATE 4, 7: COLOR 7, 0: CALL LED1(T$): COLOR 7, 1„   ClrRowCtrMsg "Press any key to begin timing..."„   X$ = INPUT$(1)„   Start! = TIMER„   ClrRowCtrMsg "Press any key to stop timer..."„   DO„     GOSUB ShowTime„     X$ = INKEY$: IF LEN(X$) THEN EXIT DO„   LOOP„   ClrRowCtrMsg "Press ESC to quit, any other key to reset the timer."„   X$ = INPUT$(1): IF X$ = CHR$(27) THEN EXIT DO„ LOOP„ CLS„ END„„ ShowTime:„ T! = TIMER - Start!„ Mins$ = RIGHT$("  " + STR$(INT(T!) \ 60), 3)„ Secs$ = RIGHT$(STR$((INT(T!) MOD 60) + 100), 2)„ Frac$ = MID$(STR$(T! - INT(T!)) + "00", 3, 2)„ MID$(T$, 1, 3) = Mins$: MID$(T$, 5, 2) = Secs$: MID$(T$, 8, 2) = Frac$„ LOCATE 4, 7: COLOR 7, 0: CALL LED1(T$): COLOR 7, 1„ RETURN„„ Clock:„ SCREEN 0, 1, 0: COLOR 7, 1: CLS„ COLOR 0, 1„ LOCATE 3, 10: PRINT STRING$(60, "‹")„ FOR R% = 4 TO 8    'change 8 to 10 for large LEDs„   LOCATE R%, 10: PRINT STRING$(60, "€");„ NEXT„ COLOR 7, 0„ DO UNTIL LEN(INKEY$)„   LOCATE 4, 11: CALL LED1(TIME$)„ LOOP„ CLS„ END„„ SUB ClrRowCtrMsg (Message$)„ LOCATE 12, 1: PRINT SPC(79); " ";„ LOCATE , (82 - LEN(Message$)) \ 2: PRINT Message$;„ END SUB„„ SUB LED1 (Spec$) STATIC„„ IF Initialized% GOTO Begin1„ Top1$ = "‹ﬂﬂﬂﬂ‹"„ Top2$ = "‹    ‹"„ Top3$ = "     ‹"„ Top4$ = "‹     "„ Top5$ = " ﬂﬂﬂﬂ‹"„ Top6$ = "‹ﬂﬂﬂﬂ "„ Bot1$ = " ﬂﬂﬂﬂ "„ Ctr2$ = "€    €"„ Ctr3$ = "     €"„ Ctr4$ = "€     "„ XXX1$ = "      "„ Initialized% = -1„„ Begin1:„ R% = CSRLIN: C% = POS(0)„ FOR Ptr% = 1 TO LEN(Spec$)„  SELECT CASE ASC(MID$(Spec$, Ptr%, 1))„    CASE 48„      T$ = Top1$: C1$ = Ctr2$: M$ = Top2$: C2$ = Ctr2$: B$ = Bot1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 49„      T$ = Top3$: C1$ = Ctr3$: M$ = Top3$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 50„      T$ = Top5$: C1$ = Ctr3$: M$ = Top6$: C2$ = Ctr4$: B$ = Bot1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 51„      T$ = Top5$: C1$ = Ctr3$: M$ = Top5$: C2$ = Ctr3$: B$ = Bot1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 52„      T$ = Top2$: C1$ = Ctr2$: M$ = Top5$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 53„      T$ = Top6$: C1$ = Ctr4$: M$ = Top5$: C2$ = Ctr3$: B$ = Bot1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 54„      T$ = Top4$: C1$ = Ctr4$: M$ = Top1$: C2$ = Ctr2$: B$ = Bot1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 55„      T$ = Top5$: C1$ = Ctr3$: M$ = Top3$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 56„      T$ = Top1$: C1$ = Ctr2$: M$ = Top1$: C2$ = Ctr2$: B$ = Bot1$„      GOSUB ShowChar1: C% = C% + 9„    CASE 57„      T$ = Top1$: C1$ = Ctr2$: M$ = Top5$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar1: C% = C% + 9„    CASE ASC(":")„      LOCATE R% + 1, C%: PRINT "ﬂ";„      LOCATE R% + 3, C%: PRINT "ﬂ";„      C% = C% + 3„    CASE 32„      T$ = XXX1$: C1$ = XXX1$: M$ = XXX1$: C2$ = XXX1$: B$ = XXX1$„      GOSUB ShowChar1: C% = C% + 8„  END SELECT„ NEXT„ EXIT SUB„„ ShowChar1:„ LOCATE R% + 0, C%: PRINT T$;„ LOCATE R% + 1, C%: PRINT C1$;„ LOCATE R% + 2, C%: PRINT M$;„ LOCATE R% + 3, C%: PRINT C2$;„ LOCATE R% + 4, C%: PRINT B$;„ RETURN„ END SUB„„ SUB LED2 (Spec$) STATIC„„ IF Initialized% GOTO Begin2„ Top1$ = "‹ﬂﬂﬂﬂﬂ‹"„ Top2$ = "‹     ‹"„ Top3$ = "      ‹"„ Top4$ = "‹      "„ Top5$ = " ﬂﬂﬂﬂﬂ‹"„ Top6$ = "‹ﬂﬂﬂﬂﬂ "„ Bot1$ = " ﬂﬂﬂﬂﬂ "„ Ctr2$ = "€     €"„ Ctr3$ = "      €"„ Ctr4$ = "€      "„ XXX1$ = "       "„ Initialized% = -1„„ Begin2:„ R% = CSRLIN: C% = POS(0)„ FOR Ptr% = 1 TO LEN(Spec$)„  SELECT CASE ASC(MID$(Spec$, Ptr%, 1))„    CASE 48„      T$ = Top1$: C1$ = Ctr2$: M$ = Top2$: C2$ = Ctr2$: B$ = Bot1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 49„      T$ = Top3$: C1$ = Ctr3$: M$ = Top3$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 50„      T$ = Top5$: C1$ = Ctr3$: M$ = Top6$: C2$ = Ctr4$: B$ = Bot1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 51„      T$ = Top5$: C1$ = Ctr3$: M$ = Top5$: C2$ = Ctr3$: B$ = Bot1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 52„      T$ = Top2$: C1$ = Ctr2$: M$ = Top5$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 53„      T$ = Top6$: C1$ = Ctr4$: M$ = Top5$: C2$ = Ctr3$: B$ = Bot1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 54„      T$ = Top4$: C1$ = Ctr4$: M$ = Top1$: C2$ = Ctr2$: B$ = Bot1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 55„      T$ = Top5$: C1$ = Ctr3$: M$ = Top3$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 56„      T$ = Top1$: C1$ = Ctr2$: M$ = Top1$: C2$ = Ctr2$: B$ = Bot1$„      GOSUB ShowChar2: C% = C% + 9„    CASE 57„      T$ = Top1$: C1$ = Ctr2$: M$ = Top5$: C2$ = Ctr3$: B$ = XXX1$„      GOSUB ShowChar2: C% = C% + 9„    CASE ASC(":")„      LOCATE R% + 1, C%: PRINT "‹";„      LOCATE R% + 4, C%: PRINT "‹";„      C% = C% + 3„    CASE 32„      T$ = XXX1$: C1$ = XXX1$: M$ = XXX1$: C2$ = XXX1$: B$ = XXX1$„      GOSUB ShowChar2: C% = C% + 9„  END SELECT„ NEXT„ EXIT SUB„„ ShowChar2:„ LOCATE R% + 0, C%: PRINT T$;„ LOCATE R% + 1, C%: PRINT C1$;„ LOCATE R% + 2, C%: PRINT C1$;„ LOCATE R% + 3, C%: PRINT M$;„ LOCATE R% + 4, C%: PRINT C2$;„ LOCATE R% + 5, C%: PRINT C2$;„ LOCATE R% + 6, C%: PRINT B$;„ RETURN„ END SUB„Ethan Winer                    INSTALLATION UTILITY           sansbach@gpu.srv.ualberta.ca   01-29-93 (10:58)       QB, PDS                1067 39535    PC-SETUP.BAS'********** PC-SETUP.BAS - PC Magazine Install Utility„„'Copyright (c) 1992 Ethan Winer„„'Note: If you run this program in the QB editor the ExeName function will„'return the directory that QB.EXE was run from, which is not necessarily the„'current directory.  In that case you may have to enter the directory name„'where your various .ZIP files reside for PC-SETUP to find them.„'„'If you are using Crescent's P.D.Q. you must search for all each call to the„'Interrupt routine, and change it as shown in the accompanying comments.  You„'can then compile and link this program for the smallest size possible as„'follows:„'„'   bc pc-setup /o/s;„'   link /nod/noe/packc/far/ex _„'     pc-setup _noread _noval _noerror _cprint , , nul , [basic7] pdq;„'   exe2com pc-setup               (optional)„'   del pc-setup.exe               (optional)„'   ren pc-setup.com pc-setup.exe  (optional)„„„DEFINT A-Z„„'---- BASIC SUB and FUNCTION procedures in this program file„'„DECLARE SUB CopyFile (Source$)„DECLARE SUB DrawBox (ULRow, ULCol, LRRow, LRCol, Style)„DECLARE SUB DrawScreen ()„DECLARE SUB Editor (Text$, Row, LeftCol, Length, KeyCode)„DECLARE SUB EarlyEnd ()„DECLARE SUB ErrorEnd (Message$)„DECLARE SUB MidCharS (Work$, Position, NewChar)„DECLARE SUB ReadNames (Spec$, Array$())„DECLARE SUB SelectFiles (FileNames$(), Choice, ExitCode)„DECLARE SUB SetDrive (Drive$)„DECLARE SUB StuffBuf (Work$)„„DECLARE FUNCTION ChangeDir% (DirName$)„DECLARE FUNCTION DOSVersion% ()„DECLARE FUNCTION Execute% (FileName$, Parameter$)„DECLARE FUNCTION ExeName$ ()„DECLARE FUNCTION FileCount% (FileSpec$, DirFlag)„DECLARE FUNCTION GetComment$ (FileName$)„DECLARE FUNCTION GetDir$ ()„DECLARE FUNCTION GetDrive% ()„DECLARE FUNCTION IntVal% (Work$)„DECLARE FUNCTION MakeDir% (DirName$)„DECLARE FUNCTION MidChar% (Work$, Position)„DECLARE FUNCTION Prompt% (Which)„DECLARE FUNCTION SourceDir$ ()„„„'Define the TYPE and other shared variables needed for using CALL InterruptX.„'„TYPE RegType„  AX    AS INTEGER„  BX    AS INTEGER„  CX    AS INTEGER„  DX    AS INTEGER„  BP    AS INTEGER„  SI    AS INTEGER„  DI    AS INTEGER„  Flags AS INTEGER„  DS    AS INTEGER„  ES    AS INTEGER„END TYPE„DIM SHARED Regs AS RegType„„TYPE DTAType                            'used by find first/next service„  Reserved  AS STRING * 21              'reserved for use by DOS„  Attribute AS STRING * 1               'the file's attribute„  FileTime  AS STRING * 2               'the file's time„  FileDate  AS STRING * 2               'the file's date„  FileSize  AS LONG                     'the file's size„  FileName  AS STRING * 13              'the file's name„END TYPE„DIM SHARED DTA AS DTAType„„DIM SHARED DOS                          'so the DOS procedures can get at it„DIM SHARED ZBuffer AS STRING * 80       'holds ASCIIZ copies of DOS strings„DIM SHARED One, Zero, Zero$             'these save code when used in CALLs„DIM SHARED Temp, Temp$                  'these are reusable scratch variables„„'---- Define some constants and variables, and colors based on display type.„'„CONST MaxFiles% = 19                    'max. number of .ZIP files per disk„CONST DirLength% = 25                   'length of dest. directory display„„One = 1                                 'saves four bytes per use in a CALL„DOS = &H21                              'also saves four bytes per use„Zero$ = CHR$(0)                         'call CHR$() just once here„PadComment$ = SPACE$(36)                'holds each comment when printing„REDIM DirsMade$(1 TO 100)               'remembers directories we created„„Bar$ = "Ã" + STRING$(78, 205) + "π"     'for the main screen separating bars„Msg$ = SPACE$(79)                       'for messages on the bottom line„IF INSTR(UCASE$(COMMAND$), "/B") THEN MonoFlag = -1   '/b forces mono colors„„NormFG = 11: NormBG = 7                 'assume colors for a color display„HiFG = 11: HiBG = 4                     'menu and default directory colors„MainFG = 10: MainBG = 1                 'main screen and box FG and BG colors„CsrSize = 7                             'color displays use 8 scan lines„„DEF SEG = 0                             'see if it's really a color display„MonoMon = (PEEK(&H463) = &HB4)          'if not, MonoMon now equals -1„IF MonoMon OR MonoFlag THEN             'it's monochrome or /b was used„  NormFG = 7: NormBG = 0„  HiFG = 15: HiBG = 0„  MainFG = 0: MainBG = 7„  IF MonoMon THEN CsrSize = 12          'mono displays use 13 scan lines„END IF„„IF DOSVersion% < 300 THEN               'PC-SETUP requires DOS 3.0 or later„  PRINT "DOS 3.0 or later required."„  END„END IF„„'---- Get the directory PC-SETUP was run from or prompt for it if needed, to„'     ensure that there's at least one .ZIP file present to install.„'„InstPath$ = SourceDir$„DO„  IF RIGHT$(InstPath$, 1) <> "\" THEN InstPath$ = InstPath$ + "\"„  InstSpec$ = InstPath$ + "*.ZIP"„  NumFiles = FileCount%(InstSpec$, Zero)„  IF NumFiles THEN EXIT DO„  PRINT "No .ZIP files were found."„  INPUT "Enter the source directory or press Enter to end: ", InstPath$„  IF LEN(InstPath$) = 0 THEN END„LOOP„„IF FileCount%(InstPath$ + "PKUNZIP.EXE", Zero) = 0 THEN 'confirm PKUNZIP„  PRINT "Can't find PKUNZIP."                           '  is available„  END„END IF„     „IF MidChar%(InstPath$, 2) <> 58 THEN    'if there's no drive letter (:)„  InstPath$ = CHR$(GetDrive%) + ":" + InstPath$ 'append the current drive„END IF„„„'---- See if they're installing more than one disk, and if so how many.„'„NumDisks = 1                                'assume only one disk for now„NumDisksFile$ = InstPath$ + "NUMDISKS.*"    'concatenate these just once„„IF FileCount%(NumDisksFile$, Zero) THEN„  DIM NumDisks$(1 TO 1)„  CALL ReadNames(NumDisksFile$, NumDisks$())„  Temp = INSTR(NumDisks$(1), ".")„  NumDisks = IntVal%(MID$(NumDisks$(1), Temp + 1))„END IF„„„'---- See if there's a DEFAULT.DIR file in the root directory of the first„'     distribution disk, and if so read its contents.  Here we're using„'     FileCount to merely see if the file exists.  If there's no DEFAULT.DIR„'     file, default to current drive and directory.  And if the current drive„'     is A or B replace that with C.„'„SaveDir$ = CHR$(GetDrive%) + ":" + GetDir$      'save this while we have it„DefaultDir$ = SaveDir$                          'now assign it as the default„„Temp = ASC(DefaultDir$)                         'avoid using ASC() twice„IF Temp = 65 OR Temp = 66 THEN                  'don't default to A: or B:„  CALL MidCharS(DefaultDir$, 1, 67)             'if A: or B:, substitute C:„END IF„„DefaultDirFile$ = InstPath$ + "DEFAULT.DIR"     'concatenate these just once„„IF FileCount%(DefaultDirFile$, Zero) THEN       'open the file if it exists„  OPEN DefaultDirFile$ FOR INPUT AS #1„  INPUT #1, DefaultDir$                         'read the default directory,„  CLOSE                                         ' trim and capitalize (UCASE$„  DefaultDir$ = UCASE$(RTRIM$(LTRIM$(DefaultDir$))) ' is for cosmetics only)„END IF„„„'---- See if there's a PROGRAM.RUN file in the root directory of the first„'     distribution disk, and if so read its contents.„'„RunFileName$ = InstPath$ + "PROGRAM.RUN"        'concatenate these just once„IF FileCount%(RunFileName$, Zero) THEN          'open the file if it exists„  OPEN RunFileName$ FOR INPUT AS #1„  INPUT #1, RunName$„  CLOSE„  RunName$ = RunName$ + CHR$(13)                'simulate pressing Enter„  IF LEN(RunName$) > 15 THEN RunName$ = ""      'don't use name if too long„END IF„„„'---- This is the main installation loop that cycles through each diskette.„'„FOR Disk = 1 TO NumDisks„„  '---- See how many .ZIP files there are on the current disk, and limit the„  '     number we'll handle to MaxFiles% if there are more than that.  Then„  '     draw/redraw the main screen.„  '„  NumFiles = FileCount%(InstSpec$, Zero)„  IF NumFiles > MaxFiles% THEN NumFiles = MaxFiles%„ „  CALL DrawScreen„ „  '---- Read the .ZIP file names and display them in a vertical menu.  Then„  '     read any default directories (if present) within each .ZIP file's„  '     comment, and display them in the destination directory fields.  For„  '     each .ZIP file that doesn't have a corresponding default directory„  '     in the comment, use the contents of the main DEFAULT.DIR file found„  '     in the root directory of the disk.„  '„  REDIM ZIPName$(1 TO NumFiles)„  REDIM DestDir$(1 TO NumFiles)„  REDIM Comment$(1 TO NumFiles)„„  CALL ReadNames(InstSpec$, ZIPName$())„„  FOR X = 1 TO NumFiles                 'look at each .ZIP file comment„    DestDir$(X) = SPACE$(DirLength%)    'create a string to hold the dest dir„    LSET DestDir$(X) = DefaultDir$      'assume none, use the global default„    Comment$(X) = GetComment$(InstPath$ + ZIPName$(X))„    Temp = INSTR(Comment$(X), "˛")      'see if a directory was given„    IF Temp THEN                        'there is a directory for this file„      LSET DestDir$(X) = UCASE$(MID$(Comment$(X), Temp + 1)) 'dir is on right„      Comment$(X) = LEFT$(Comment$(X), Temp - 1)         'and comment on left„    END IF„  NEXT„„  FOR X = 1 TO NumFiles                 'add leading blanks to make room„    ZIPName$(X) = "   " + ZIPName$(X)   '  for the CHR$(251) check marks„    IF RIGHT$(Comment$(X), 1) = "˚" THEN    'they want this file checked„      CALL MidCharS(ZIPName$(X), 2, 251)    'so check it in the file list box„      Comment$(X) = LEFT$(Comment$(X), LEN(Comment$(X)) - 1)„    END IF„    LSET PadComment$ = Comment$(X)      'display the directories and comments„    COLOR NormFG, NormBG                'while we're here„    LOCATE X + 4, 2: PRINT DestDir$(X);„    LOCATE X + 4, 44: PRINT PadComment$;„  NEXT„„  DO                                    'let the user select the files„    CALL SelectFiles(ZIPName$(), Choice, ExitCode)„    IF ExitCode = 9 THEN                'they pressed Tab„      COLOR MainFG, MainBG„      LOCATE 25, 2„      PRINT SPC(30); "Tab: Select .ZIP files    F2: Begin    Esc: Quit";„„      DO„        CALL Editor(DestDir$(Choice), Choice + 4, 2, 25, ExitCode)„        SELECT CASE ExitCode            'how did the terminate editing?„          CASE -80                      'Down Arrow„            Choice = Choice + 1         'wrap around if they go past the end„            IF Choice > NumFiles THEN Choice = 1„          CASE -72                      'Up Arrow„            Choice = Choice - 1         'wrap to the end if they go before 1„            IF Choice < 1 THEN Choice = NumFiles„          CASE 27                       'Escape„            CALL EarlyEnd„          CASE -60                      'F2„            ExitCode = -60              'tell SelectFiles to come right back„            EXIT DO                     '  so we can exit both levels of DO„          CASE ELSE„            EXIT DO                     'anything else returns to SelectFiles„        END SELECT„      LOOP„    ELSEIF ExitCode = -60 THEN          'F2„      ExitCode = 0                      'prevent unwanted recursion across„      EXIT DO                           '  multiple disks„    ELSEIF ExitCode = 27 THEN           'Escape„      CALL EarlyEnd„    END IF„  LOOP„„„  '---- Install the selected files to the specified destination directories.„  '     For each file that is tagged, either change to the appropriate drive„  '     and directory, or ensure that we're back to the original path.„  '„  FOR X = 1 TO NumFiles                       'for each .ZIP file present„„    IF MidChar%(ZIPName$(X), 2) = 251 THEN    'if it's tagged to install„„      IF X = 1 THEN RunProg = -1              'use PROGRAM.RUN only if first„                                              '  file is being installed„      COLOR MainFG, MainBG                    'for the status message below„      CLS„      LSET Msg$ = "Installing" + RTRIM$(MID$(ZIPName$(X), 3)) + "..."„      COLOR HiFG„      PRINT Msg$                              'advise the user as to progress„      COLOR MainFG„     „      DestPath$ = RTRIM$(DestDir$(X))         'work with a copy of the path„„      IF MidChar%(DestPath$, 2) = 58 THEN     'if a drive was used (58 = ":")„        CALL SetDrive(DestPath$)              'change to that drive„        IF GetDrive% <> ASC(DestPath$) THEN   'no such drive„          CALL ErrorEnd("Drive " + LEFT$(DestPath$, 2) + " invalid")„        END IF„      ELSE„        CALL SetDrive(DefaultDir$)            'else switch to default drive„      END IF„„      'strip off possible trailing "\" unless it refers to the root directory„      IF RIGHT$(DestPath$, 1) = "\" THEN„        Temp = LEN(DestPath$)„        IF Temp > 1 AND RIGHT$(DestPath$, 2) <> ":\" THEN„          DestPath$ = LEFT$(DestPath$, Temp - 1)„        END IF„      END IF„„      Temp = -1                               'assume directory now exists„      IF LEN(DestPath$) THEN                  'if a directory name was given„„        IF RIGHT$(DestPath$, 1) <> "\" THEN   'and it's not a root directory„„          IF FileCount%(DestPath$, -1) = 0 THEN   'does the directory exist?„            IF MakeDir%(DestPath$) THEN       'no, so first try to create it„              CALL ErrorEnd("Cannot create " + DestPath$)„            END IF„            Temp = 0                          'it can't possibly have files„            DirsWeMade = DirsWeMade + 1       'show we created another one„            DirsMade$(DirsWeMade) = DestPath$ 'and remember its name„          END IF„„          FOR Y = 1 TO DirsWeMade             'see if we made this directory„            IF DestPath$ = DirsMade$(Y) THEN  'yes, so there's no need to„              Temp = 0                        ' warn about overwriting files„              EXIT FOR„            END IF„          NEXT„„        END IF„„        IF ChangeDir%(DestPath$) THEN         'then try to change to it„          CALL ErrorEnd("Unable to access " + DestPath$)„        END IF„„      END IF„„      PKCmd$ = "-o "                          'assume they want to be warned„      IF Temp THEN                            'this directory existed„        IF Prompt%(Zero) THEN                 'ask if they want to be warned„          PKCmd$ = ""                         ' to overwrite existing files„        END IF                                ' without further prompting and„      END IF                                  ' use appropriate command if so„„      IF NOT PKCopied THEN                    'copy PKUNZIP first time only„        PKCopied = -1                         'flag that we did it already„        CALL CopyFile(InstPath$)              'show where PKUNZIP.EXE is„        PKDir$ = RTRIM$(DestDir$(X))          'remember where we put it!„        IF LEN(PKDir$) = 0 THEN PKDir$ = DefaultDir$ 'use default dir if none„       „        Temp = ASC(RIGHT$(PKDir$, 1))         'check the right-most character„        IF Temp <> 58 AND Temp <> 92 THEN     'if not a colon or backslash„          PKDir2$ = "\"                       ' create a trailing "\"„        END IF                                ' which is appended below„      END IF„„      '---- Install all of the files contained in this .ZIP file and check„      '     for an errors returned by either DOS or PKUNZIP.  Execute returns„      '     positive error values if PKUNZIP was run okay but it returned an„      '     error via the DOS Errorlevel.  If DOS itself reports an error„      '     (perhaps there wasn't enough memory to run the program) Execute„      '     returns the DOS error value as a negative number.  Error 8 is the„      '     DOS "Out of memory" error.„      '„      Temp = Execute%(PKDir$ + PKDir2$ + "PKUNZIP.EXE", PKCmd$ + InstPath$ + RTRIM$(MID$(ZIPName$(X), 4)))„      IF Temp THEN„        Temp$ = "PKUNZIP reports Error" + STR$(Temp)„        IF Temp < 0 THEN Temp$ = "Out of memory"„        CALL ErrorEnd(Temp$)„      END IF„„      IF INKEY$ = CHR$(27) THEN         'allow aborting by pressing Escape„        CALL EarlyEnd„      END IF„„    END IF„„  NEXT„„  IF Disk < NumDisks THEN               'if there are more disks to install„    LOCATE 25, 2                        'prompt to insert the next disk„    LSET Msg$ = "Insert the next disk and press any key when ready"„    COLOR MainFG, MainBG„    PRINT Msg$;„    LOCATE , 52„    DO: LOOP WHILE LEN(INKEY$)          'first clear any pending keys„    DO: LOOP UNTIL LEN(INKEY$)          'then wait for a keypress„    CALL SetDrive(SaveDir$)             'return to the current drive and its„    Temp = ChangeDir%(SaveDir$)         '  current directory before going on„  END IF„„NEXT Disk„„„'---- Report success and run the specified program (StuffBuf ignores a null„'     string argument.„'„COLOR 7, 0: CLS„LOCATE 13, 30: PRINT "Installation complete!"„LOCATE 22, 1, 1„CALL SetDrive(PKDir$)                   'change to the first drive and„Temp = ChangeDir%(PKDir$)               ' directory we installed to„KILL "PKUNZIP.EXE"                      'delete the copy of PKUNZIP.EXE there„IF RunProg THEN CALL StuffBuf(RunName$) 'stuff the buffer if appropriate„END                                     'and end„„FUNCTION ChangeDir% (DirName$)          'returns 0 if Okay, -1 if an error„ „  ZBuffer$ = DirName$ + Zero$           'make an ASCIIZ string„  Regs.AX = &H3B00                      'DOS change directory service„  Regs.DX = VARPTR(ZBuffer$)            'show DOS where ZBuffer$ is„  CALL Interrupt(DOS, Regs, Regs)       'call DOS„ 'CALL Interrupt(DOS, Regs)             'use this with P.D.Q.„„  IF Regs.Flags AND 1 THEN              'must be an invalid path„    ChangeDir% = -1                     'return -1 as an error„  END IF„„END FUNCTION„„SUB CopyFile (Source$) STATIC           'copies PKUNZIP.EXE„ „  Temp$ = Source$ + "PKUNZIP.EXE"„ „  IF FileCount%(Temp$, Zero) THEN„    OPEN Temp$ FOR BINARY AS #1         'open the input file if it exists„  ELSE                                  'if we can't find it, bag out with„    CALL ErrorEnd("Can't find PKUNZIP.EXE")     ' an error message„  END IF„„  OPEN "PKUNZIP.EXE" FOR BINARY AS #2   'now open the target file„„  Temp$ = SPACE$(LOF(1))                'make a buffer to hold PKUNZIP.EXE„  GET #1, , Temp$                       'read the source file„  PUT #2, , Temp$                       'write it to the destination„ „  CLOSE                                 'all done here„   „END SUB„„FUNCTION DOSVersion% STATIC         'returns DOS version * 100 (3.30 = 330)„„  Regs.AX = &H3000                  'DOS get DOS version service„  CALL Interrupt(DOS, Regs, Regs)„ 'CALL Interrupt(DOS, Regs)         'use this with P.D.Q.„„  'combine the major version in AL and the minor in AH„  DOSVersion% = (Regs.AX AND 255) * 100 + (Regs.AX \ 256)„„END FUNCTION„„SUB DrawBox (ULRow, ULCol, LRRow, LRCol, Style) STATIC„ „  Length = LRCol - ULCol + 1            'calculate this just once„ „  IF Style = 1 THEN„    LineType = 196„    VertBar$ = "≥"„  ELSE„    LineType = 205„    VertBar$ = "∫"„  END IF„„  FOR X = ULRow TO LRRow                'first draw the walls„    LOCATE X, ULCol„    Temp = 32„    IF X = ULRow OR X = LRRow THEN Temp = LineType„    PRINT VertBar$; STRING$(Length - 2, Temp); VertBar$;„  NEXT„„  IF Style = 1 THEN                     'then draw the corners„    LOCATE ULRow, ULCol: PRINT "⁄";„    LOCATE ULRow, LRCol: PRINT "ø";„    LOCATE LRRow, ULCol: PRINT "¿";„    LOCATE LRRow, LRCol: PRINT "Ÿ";„  ELSE„    LOCATE ULRow, ULCol: PRINT "…";„    LOCATE ULRow, LRCol: PRINT "ª";„    LOCATE LRRow, ULCol: PRINT "»";„    LOCATE LRRow, LRCol: PRINT "º";„  END IF„„END SUB„„SUB DrawScreen STATIC„„  SHARED MainFG, MainBG, Bar$„ „  '---- Draw the title screen and surrounding boxes.„  '„  COLOR MainFG, MainBG: CLS : LOCATE , , 0„  CALL DrawBox(One, One, 24, 80, 2)„  LOCATE 2, 24: PRINT "PC Magazine's PC-SETUP Version 1.00"„  LOCATE 3, 1: PRINT Bar$„ „  CALL DrawBox(3, 27, 24, 43, One)„  LOCATE 3, 27:  PRINT "—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—";„  LOCATE 24, 27: PRINT "œÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœ";„ „  LOCATE 4, 3: PRINT "Destination Directories";„  LOCATE , 31: PRINT "ZIP Files";„  LOCATE , 58: PRINT "Comments"„„  LOCATE 25, 2„  PRINT "Up/Down/Space: Select files    Tab: Edit destination    F2: Begin    Esc: Quit";„ „END SUB„„SUB EarlyEnd STATIC„„  IF Prompt%(One) THEN„    COLOR 7, 0„    CLS„    LOCATE 24, , 1„    END„  END IF„  LOCATE , , 0„„END SUB„„SUB Editor (Text$, Row, LeftCol, Length, KeyCode) STATIC„„  SHARED HiFG, HiBG, NormFG, NormBG, MonoMon, CsrSize„„  '----- Work with a temporary copy.„  Edit$ = SPACE$(Length)„  LSET Edit$ = Text$„„  '----- See where to begin editing and print the string.„  TxtPos = 1„  LOCATE Row, LeftCol, 1, CsrSize - 1, CsrSize„  COLOR HiFG, HiBG„  PRINT Edit$;„„  '----- This is the main loop for handling key presses.„  DO„     LOCATE , LeftCol + TxtPos - 1, 1„„     DO„       Ky$ = UCASE$(INKEY$)„     LOOP UNTIL LEN(Ky$)        'wait for a keypress„„     IF LEN(Ky$) = 1 THEN       'create a key code„       KeyCode = ASC(Ky$)       'regular character key„     ELSE                       'extended key„       KeyCode = -ASC(RIGHT$(Ky$, 1))„     END IF„„     '----- Branch according to the key pressed.„     SELECT CASE KeyCode„„       '----- Backspace: decrement the pointer and the„       '      cursor, and ignore if in the first column.„       CASE 8„         TxtPos = TxtPos - 1„         IF TxtPos < 1 THEN TxtPos = 1„         LOCATE , LeftCol + TxtPos - 1, 0„         IF TxtPos > 0 THEN„           IF InsStatus THEN„             MID$(Edit$, TxtPos) = MID$(Edit$, TxtPos + 1) + " "„           ELSE„             MID$(Edit$, TxtPos) = " "„           END IF„           PRINT MID$(Edit$, TxtPos);„         END IF„„       '----- Enter or Escape: this block is optional in„       '      case you want to handle these separately.„       CASE 13, 27„         EXIT DO                'exit the subprogram„„       '----- Letter keys: turn off the cursor to hide„       '      the printing, handle Insert mode as needed.„       CASE 32 TO 254„         LOCATE , , 0„         IF InsStatus THEN      'expand the string„           MID$(Edit$, TxtPos) = Ky$ + MID$(Edit$, TxtPos)„           PRINT MID$(Edit$, TxtPos);„         ELSE                   'else insert character„           MID$(Edit$, TxtPos) = Ky$„           PRINT Ky$;„         END IF„         TxtPos = TxtPos + 1    'update position counter„         IF TxtPos > Length THEN TxtPos = Length„„       '----- Left arrow: decrement the position counter.„       CASE -75„         TxtPos = TxtPos - 1„         IF TxtPos < 1 THEN TxtPos = 1„„       '----- Right arrow: increment position counter.„       CASE -77„         TxtPos = TxtPos + 1„         IF TxtPos > Length THEN TxtPos = Length„„       '----- Home: jump to the first character position.„       CASE -71„         TxtPos = 1„„       '----- End: search for the last non-blank, and„       '      make that the current editing position.„       CASE -79„         FOR N = Length TO 1 STEP -1„           IF MID$(Edit$, N, 1) <> " " THEN EXIT FOR„         NEXT„         TxtPos = N + 1„         IF TxtPos > Length THEN TxtPos = Length„„       '----- Insert key: toggle the Insert state and„       '      adjust the cursor size.„       CASE -82„         InsStatus = NOT InsStatus„         IF InsStatus THEN„           LOCATE , , , CsrSize \ 2, CsrSize„         ELSE„           LOCATE , , , CsrSize - 1, CsrSize„         END IF„„       '----- Delete: delete the current character and„       '      reprint what remains in the string.„       CASE -83„         MID$(Edit$, TxtPos) = MID$(Edit$, TxtPos + 1) + " "„         LOCATE , , 0„         PRINT MID$(Edit$, TxtPos);„„       '---- All other keys: exit the subprogram„       CASE ELSE„         EXIT DO„     END SELECT„„  '----- Loop until the cursor moves out of the field.„  LOOP„„  LSET Edit$ = LTRIM$(Edit$)    'trim and reprint the text in the normal„  LOCATE , 2                    ' color before returning„  COLOR NormFG, NormBG„  PRINT Edit$„„  Text$ = RTRIM$(Edit$)         'now trim what's on the right too„ „END SUB„„SUB ErrorEnd (Message$) STATIC„„  COLOR 7, 0„  CLS„  LOCATE 13, 34 - LEN(Message$) \ 2, 1„  PRINT "Error: "; Message$; ", ending."„  END„„END SUB„„FUNCTION Execute% (Program$, Parameter$) STATIC„ „  '---- Prepare the program name and parameter strings for processing.  DOS„  '     requires that the parameter string hold the length of the parameter„  '     text, followed by the parameter text, and then followed by a CHR$(13)„  '     Enter byte.  The parameter block holds two CHR$(0) bytes followed by„  '     the address and segment of the parameter string.„  '„  DIM Block AS STRING * 14         'this is the DOS parameter block„  DIM Parm AS STRING * 50          'and this is the actual parameter text„ „  ZBuffer$ = Program$ + Zero$      'make an ASCIIZ string for DOS„ „  LSET Parm$ = CHR$(LEN(Parameter$)) + Parameter$ + CHR$(13)„  LSET Block$ = Zero$ + Zero$ + MKI$(VARPTR(Parm$)) + MKI$(VARSEG(Parm$))„„  Dummy& = SETMEM(-500000)         'free up memory for PKUNZIP to run„„  Regs.AX = &H4B00                 'DOS load/execute function„  Regs.DX = VARPTR(ZBuffer$)       'offset of program name into DX„  Regs.ES = VARSEG(Block$)         'segment of parameter block into ES„  Regs.BX = VARPTR(Block$)         'offset of parameter block into BX„  Regs.DS = -1                     'set DS to BASIC's segment„  CALL InterruptX(DOS, Regs, Regs) 'execute it as subordinate process„ 'CALL InterruptX(DOS, Regs)       'use this with P.D.Q.„„  IF Regs.Flags AND 1 THEN         'DOS had an error trying to run PKUNZIP„    Execute% = -Regs.AX            'set function value to exit code„    EXIT FUNCTION„  END IF„„  Regs.AX = &H4D00                 'retrieve subordinate process code„  CALL Interrupt(DOS, Regs, Regs)„ 'CALL Interrupt(DOS, Regs)        'use this with P.D.Q.„  Execute% = Regs.AX               'set function value to exit code„„  Dummy& = SETMEM(500000)          'reclaim the memory reliquished eariler„„END FUNCTION„„FUNCTION ExeName$ STATIC„„  'Returns the name of the currently running program; requires DOS 3.0 +„„  '---- DOS Interrupt &H21 service &H62 returns the PSP segment in BX„  Regs.AX = &H6200„  CALL Interrupt(DOS, Regs, Regs)„ 'CALL Interrupt(DOS, Regs)             'use this with P.D.Q.„„  '---- The environment segment is at address &H2C/&H2D in PSP segment„  DEF SEG = Regs.BX„  DEF SEG = PEEK(&H2C) + PEEK(&H2D) * 256„„  '---- Search the environment segment for two zero bytes in a row.  A count„  '     word (which we skip over) follows that, and the program name follows„  '     the count word.„  Byte = 0„  DO„    IF PEEK(Byte) = 0 THEN              'this is zero„      IF PEEK(Byte + 1) = 0 THEN        'this is too„        Byte = Byte + 2                 'so skip both„        EXIT DO                         'all done„      END IF„    END IF                              'else,„    Byte = Byte + 1                     'keep looking„  LOOP„„  IF PEEK(Byte) = 1 THEN                'if this count byte = 1„    Byte = Byte + 2                     'the name follows„    DO WHILE PEEK(Byte)                 'up to another zero„      Tmp$ = Tmp$ + CHR$(PEEK(Byte))    'this is a different Tmp$ on purpose„      Byte = Byte + 1„    LOOP„    ExeName$ = Tmp$                     'assign the function output„  END IF„„END FUNCTION„„FUNCTION FileCount% (FileSpec$, DirFlag)„ „  Regs.DX = VARPTR(DTA)                 'set new DTA address„  Regs.AX = &H1A00                      'specify service 1Ah„  CALL Interrupt(DOS, Regs, Regs)       'DOS set DTA service„ 'CALL Interrupt(DOS, Regs)             'use this with P.D.Q.„„  Temp = 0                              'clear the counter„  ZBuffer$ = FileSpec$ + Zero$          'make an ASCIIZ string„„  Regs.DX = VARPTR(ZBuffer$)            'the file spec address„  Regs.CX = 39                          'file attribute = all files„  IF DirFlag THEN Regs.CX = 39 OR 16    'include directories too„  Regs.AX = &H4E00                      'find first matching name service„„  DO„    CALL Interrupt(DOS, Regs, Regs)     'see if there's a match„   'CALL Interrupt(DOS, Regs)           'use this with P.D.Q.„    IF Regs.Flags AND 1 THEN EXIT DO    'no more files„„    IF DirFlag THEN                     'do we want directories?„      IF ASC(DTA.Attribute) AND 16 THEN 'yes, but is this a directory?„        IF ASC(DTA.FileName) <> 46 THEN 'filter "." and ".." (46 = period)„          Temp = Temp + 1               'we got another directory name„        END IF„      END IF„    ELSE„      Temp = Temp + 1                   'we got another file name„    END IF„     „    Regs.AX = &H4F00                    'find next name service„  LOOP„„  FileCount% = Temp                     'assign the function output„ „END FUNCTION„„FUNCTION GetComment$ (Zip$) STATIC      'read comment from file named in Zip$„„  ZipID$ = "PK" + CHR$(5) + CHR$(6)     'this identifies a file as a ZIP file„ „  OPEN RTRIM$(Zip$) FOR BINARY AS #1    'open the .ZIP file„  FileSize& = LOF(1)                    'get and save its length„  BufferSize = 3072                     'the default header size„  IF BufferSize > FileSize& THEN BufferSize = FileSize&„  Temp$ = SPACE$(BufferSize)            'make buffer to receive ZIP header„„  GET #1, FileSize& - BufferSize + 1, Temp$„  CLOSE„„  Temp = 0                              'find the last occurrence of PK ID„  DO„     HeaderOffset = Temp                'remember where this one is„     Temp = INSTR(Temp + 1, Temp$, ZipID$)      'find the next one„  LOOP WHILE Temp                               'until no more„„  IF HeaderOffset THEN                  'if there's a comment, extract it„    CommentLen = CVI(MID$(Temp$, HeaderOffset + 20, 2))„    GetComment$ = MID$(Temp$, HeaderOffset + 22, CommentLen)„  END IF„„  Temp$ = ""                            'free up the memory„„END FUNCTION„„FUNCTION GetDir$ STATIC„ „  Regs.AX = &H4700                      'DOS get directory service„  Regs.DX = 0                           'the drive goes in DL, 0 = default„  Regs.SI = VARPTR(ZBuffer$)            'show DOS where ZBuffer$ is„  CALL Interrupt(DOS, Regs, Regs)       'call DOS„ 'CALL Interrupt(DOS, Regs)             'use this with P.D.Q.„ „  IF Regs.Flags AND 1 THEN              'must be an invalid drive„    GetDir$ = ""„  ELSE„    Temp = INSTR(ZBuffer$, Zero$)       'find the zero byte, and return only„    GetDir$ = "\" + LEFT$(ZBuffer$, Temp - 1) ' what precedes it„  END IF„„END FUNCTION„„FUNCTION GetDrive% STATIC„ „  Regs.AX = &H1900                      'DOS Get Current Drive service„  CALL Interrupt(DOS, Regs, Regs)       'call DOS„ 'CALL Interrupt(DOS, Regs)             'use this with P.D.Q.„  GetDrive% = (Regs.AX AND 255) + 65    'drive returned in AL as 0=A, 1=B...„„END FUNCTION„„FUNCTION IntVal% (Work$) STATIC„„ 'IntVal is an integer-only VAL substitute that reduces .EXE size up to 10K„„  Length = LEN(RTRIM$(Work$))„  Value = 0„„  FOR X = Length TO 1 STEP -1„    Temp = MidChar%(Work$, X)„    IF Temp > 47 AND Temp < 58 THEN„      IF X = Length THEN„        Value = Temp - 48„      ELSE„        Value = Value + (Temp - 48) * 10„      END IF„    END IF„  NEXT„ „  IntVal% = Value„„END FUNCTION„„FUNCTION MakeDir% (DirName$) STATIC„„  ZBuffer$ = DirName$ + Zero$           'make an ASCIIZ string„  Regs.AX = &H3900                      'DOS create directory service„  Regs.DX = VARPTR(ZBuffer$)            'show DOS where ZBuffer$ is„  CALL Interrupt(DOS, Regs, Regs)       'call DOS„ 'CALL Interrupt(DOS, Regs)             'use this with P.D.Q.„„  IF Regs.Flags AND 1 THEN              'must be an invalid drive or bad name„    MakeDir% = -1                       'return -1 as an error„  END IF„„END FUNCTION„„FUNCTION MidChar% (Work$, Position)„„  IF Position <= LEN(Work$) THEN„    MidChar% = ASC(MID$(Work$, Position, 1))„  ELSE„    MidChar% = -1„  END IF„„END FUNCTION„„SUB MidCharS (Work$, Position, NewChar) STATIC„„  MID$(Work$, Position, 1) = CHR$(NewChar)„„END SUB„„FUNCTION Prompt% (Which) STATIC„„  SHARED HiFG, HiBG, MonoMon, CsrSize, DestPath$„„  DEF SEG = &HB800                      'assume a color display„  IF MonoMon THEN DEF SEG = &HB000      'nope, use the mono video segment„„  REDIM SaveScrn(10 TO 13, 14 TO 66)    'this saves the underlying screen„  FOR Row = 10 TO 13                    'Here, Row and Col are zero-based„    FOR Col = 14 TO 66„      Temp = Row * 160 + Col * 2        'calculate the address just once„      SaveScrn(Row, Col) = PEEK(Temp) + 256 * PEEK(Temp + 1)„    NEXT„  NEXT„„  COLOR HiFG, HiBG„  CALL DrawBox(11, 15, 14, 67, One)     'draw the surrounding box„  IF Which THEN                         'we were called from EarlyEnd„    LOCATE 12, 31                       'show this directory name„    PRINT "Are you sure you want";      'print the prompt message„    LOCATE 13, 29, 1, CsrSize - 1, CsrSize„    PRINT "to quit installing? (Y/N) ";„  ELSE                                  'prompt if okay to overwrite files„    LOCATE 12, 17                       'show this directory name„    PRINT "Installing to "; DestPath$   'print the prompt message„    LOCATE 13, 17, 1, CsrSize - 1, CsrSize„    PRINT "Prompt before overwriting existing files? (Y/N) ";„  END IF„  DO                                    'wait for Yes or No (only)„    Temp$ = UCASE$(INKEY$)„  LOOP UNTIL INSTR(" YN", Temp$) > 1„  Prompt% = 0                           'assume the answer is No„  IF Temp$ = "Y" THEN Prompt% = -1      'they answered Yes„„  FOR Row = 10 TO 13                    'now restore the screen„    FOR Col = 14 TO 66                  'as above„      Temp = Row * 160 + Col * 2„      POKE Temp, SaveScrn(Row, Col) AND 255„      POKE Temp + 1, SaveScrn(Row, Col) \ 256„    NEXT„  NEXT„„  ERASE SaveScrn„  LOCATE 2                              'put cursor at the top of the screen„„END FUNCTION„„SUB ReadNames (Spec$, Array$()) STATIC  'reads file names into an array„„  ZBuffer$ = Spec$ + Zero$              'make an ASCIIZ string of the spec„  CurFile = 0                           'zero out the file counter„„  Regs.DX = VARPTR(ZBuffer$)            'the file spec address„  Regs.CX = 39                          'file attribute = all files„  Regs.AX = &H4E00                      'find first matching name service„„  DO„    CALL Interrupt(DOS, Regs, Regs)     'see if there's a match„   'CALL Interrupt(DOS, Regs)           'use this with P.D.Q.„    IF Regs.Flags AND 1 THEN EXIT DO    'no more files„„    CurFile = CurFile + 1               'we found another file name„    Array$(CurFile) = SPACE$(12)        'create the string to hold it„    Temp$ = DTA.FileName                'assign the name„    Temp = INSTR(Temp$, Zero$)          'find the terminating zero byte„    LSET Array$(CurFile) = LEFT$(Temp$, Temp - 1) 'keep only what precedes it„„    Regs.AX = &H4F00                    'find the next name„  LOOP„„END SUB„„SUB SelectFiles (FileNames$(), Choice, ExitCode) STATIC„„  SHARED NumFiles, NormFG, NormBG, HiFG, HiBG, MainFG, MainBG„„  IF ExitCode = -60 THEN EXIT SUB       'we got here via F2 pressed in Editor„„  COLOR MainFG, MainBG                  'first display all of the choices„  LOCATE 25, 2                          'and update the status line„  PRINT "Up/Down/Space: Select files    Tab: Edit destination    F2: Begin    Esc: Quit";„„  COLOR NormFG, NormBG„  FOR Temp = 1 TO NumFiles„    LOCATE 4 + Temp, 28, 0              'and turn off the cursor„    PRINT FileNames$(Temp);„  NEXT„„  IF Choice = 0 THEN Choice = 1         'start at element 1 if first time„  IF Choice > UBOUND(FileNames$) THEN Choice = 1 'or if past the end„„  DO„    LOCATE 4 + Choice, 28               'redraw current choice highlighted„    COLOR HiFG, HiBG„    PRINT FileNames$(Choice);„    DO„      KeyHit$ = INKEY$                  'see what they want to do„    LOOP UNTIL LEN(KeyHit$)             'wait for a keypress„   „    IF LEN(KeyHit$) = 1 THEN            'set ExitCode based on the type of„      ExitCode = ASC(KeyHit$)            'key (extended or not) they pressed„    ELSE„      ExitCode = -ASC(MID$(KeyHit$, 2))„    END IF„   „    IF ExitCode = 32 THEN               'spacebar„      IF MidChar%(FileNames$(Choice), 2) = 251 THEN 'if it's now checked„        Temp = 32                       'remove the check mark„      ELSE„        Temp = 251                       'else add a check mark„      END IF„      CALL MidCharS(FileNames$(Choice), 2, Temp)„      ExitCode = -80                    'select the next file automatically„    END IF„„    SELECT CASE ExitCode„      CASE -80                          'Down Arrow„        GOSUB Deselect„        Choice = Choice + 1„        IF Choice > NumFiles THEN Choice = 1„      CASE -79                          'End key„        GOSUB Deselect„        Choice = NumFiles„      CASE -72                          'Up Arrow„        GOSUB Deselect„        Choice = Choice - 1„        IF Choice = 0 THEN Choice = NumFiles„      CASE -71                          'Home„        GOSUB Deselect„        Choice = 1„      CASE -60                          'F2„        EXIT SUB„      CASE 27                           'Escape„        EXIT SUB„      CASE 9                            'Tab„        LOCATE Choice + 4, 33„        GOSUB Deselect„        EXIT SUB„      CASE ELSE                         'this is needed for QB 4.0 only„    END SELECT„  LOOP„„Deselect:                               're-paint the current choice, so it„  LOCATE Choice + 4, 28                 '  won't appear active„  COLOR NormFG, NormBG„  PRINT FileNames$(Choice);„  RETURN„„END SUB„„SUB SetDrive (Drive$) STATIC„   „  Regs.AX = &HE00                       'DOS Set Drive service in AH„  Regs.DX = ASC(UCASE$(Drive$)) - 65    'DL = 0 for A:, 1 for B:, and so on„„  CALL Interrupt(DOS, Regs, Regs)       'see if there's a match„ 'CALL Interrupt(DOS, Regs)             'use this with P.D.Q.„„END SUB„„FUNCTION SourceDir$ STATIC„„  Temp$ = ExeName$                  'get the directory we're running from„„  FOR X = LEN(Temp$) TO 1 STEP -1   'isolate the drive letter and path„    Temp = MidChar%(Temp$, X)       '  (strip off the name PC-SETUP.EXE)„    IF Temp = 58 OR Temp = 92 THEN  'look for a colon or a backslash„      SourceDir$ = LEFT$(Temp$, X)  'by searching for ":" or "\" this will„      EXIT FOR                      ' work even if the program is renamed„    END IF„  NEXT„„END FUNCTION„„SUB StuffBuf (Cmd$) STATIC„       „  '----- Set the segment for poking, define the buffer head and tail, and„  '      then poke each character into the keyboard buffer.„ „  Temp = LEN(Cmd$)„„  DEF SEG = 0„  POKE &H41A, &H1E„  POKE &H41C, &H1E + Temp * 2„   „  FOR X = 1 TO Temp„    POKE &H41C + X * 2, ASC(MID$(Cmd$, X))„  NEXT„„END SUB„„The ABC Programmer             ADVANCED QWK READER            Try SIMPLE QWK READER          04-15-96 (01:10)       QB, QBasic, PDS        494  15280    QWKREAD.BAS '=====================[ More Complex QWK Reader ]=======================„'„' This QWK Reader let's you read the MESSAGES.DAT file contained in all„' .QWK Packets.  Also allows for easy dumping QWK --> ASCII TXT Format.„'„' Original PASCAL code by Swag Support Team (Gayle Davis)„' Converted and optimized to BASIC by William Yu (04-15-96)„'„' Advanced features for this QWK Reader include:„'   * Option of extracting single messages„'   * Full message scroll„'   * Ability to choose which message to read„'„' Basic colors (B&W) for monochrome support.„' Careful, comment out the PCOPY routine and uncomment the BSAVE/BLOAD„' routine in SUB MessageList if you do have a monochrome adapter.„'„' I've tried to implement as many features without adding too much„' extraneous code.„' This program leaves much to be desired, here are some suggestions:„'„'    - Unpack .QWK on the fly„'    - Option of sending the message to printer„'    - Option of changing the saved message file name„'    - Search option„'    - Use screen scroll routine„'----------------------------------------------------------------------„„'$DYNAMIC„DEFINT A-Z„DECLARE SUB DumpHeader (QWK AS ANY)„DECLARE SUB ReadMessage (HDR AS ANY, RelNum&, Chunks)„DECLARE SUB ReadMsg (NumChunks)„DECLARE SUB ReadWriteHdr (QWK AS ANY)„DECLARE SUB DrawBox (X%, Y%, XX%, YY%, C%, BC%, Solid%, CharSet%)„DECLARE SUB MessageList (Messages&(), Max%, QWK AS ANY)„DECLARE SUB DisplayMessage (Messages&(), FPNum, QWK AS ANY, Max)„„CONST Height = 25                     ' 25/43/50„CONST False = 0                       ' False = 0„CONST True = NOT False                ' True = -1„CONST DumpQWKtoFile = False           ' Dump messages to file?„                                      ' True = Dump to file„                                      ' False = View from screen„CONST DumpQWKFileName$ = "DUMP.MSG"   ' Dump messages to this file name„CONST QWKPacket$ = "MESSAGES.DAT"     ' MESSAGES.DAT or *.SWG„                                      ' Specify the path if required„TYPE MSGDatHdr                        ' MESSAGES.DAT File Structure„    Status   AS STRING * 1            '  128 bytes altogether„    MSGNum   AS STRING * 7„    Date     AS STRING * 8„    Time     AS STRING * 5„    UpTO     AS STRING * 25„    UpFROM   AS STRING * 25„    Subject  AS STRING * 25„    PassWord AS STRING * 12           ' Never/rarely used„    ReferNum AS STRING * 8„    NumChunk AS STRING * 6„    Alive    AS STRING * 1„    LeastSig AS STRING * 1            ' Conference #„    MostSig  AS STRING * 1            ' Used for conf. # greater than 255„    Reserved AS STRING * 3„END TYPE„„DIM QWK AS MSGDatHdr„DIM Messages&(10000)„„WIDTH 80, Height„CLS„„  OPEN QWKPacket$ FOR BINARY AS #1„  IF DumpQWKtoFile THEN OPEN DumpQWKFileName$ FOR OUTPUT AS #2„  Count& = 129  ' Skip Copyright information„  Num = 0„  WHILE Count& < LOF(1)„        Num = Num + 1„        ReadMessage QWK, Count&, Chunks„        A$ = INKEY$                          ' ESC Key quits/aborts„        IF DumpQWKtoFile THEN„          LOCATE 1, 1„          PRINT USING "Complete: ###.#%"; (Count& + (128 * Chunks)) / LOF(1) * 100„          PRINT #2,„        ELSE„          Messages&(Num) = Count&            ' Count number of messages„          LOCATE 1, 1: PRINT "Reading:"; Num„          PRINT USING "Complete: ###.#%"; (Count& + (128 * Chunks)) / LOF(1) * 100„        END IF„        IF A$ = CHR$(27) THEN CLOSE : END    ' ESC quits Viewing or Dumping„        Count& = Count& + (128 * Chunks)„  WEND„  CLS„  IF NOT DumpQWKtoFile THEN MessageList Messages&(), Num, QWK„  CLOSE„  END„„REM $STATIC„SUB DisplayMessage (Messages&(), FPNum, QWK AS MSGDatHdr, Max)„„BakFPNum = FPNum        ' So we don't get confused when we jump Next/Prev„„BeginHere:„ „  DIM Buff AS STRING * 128  ' Read in 128 byte blocks„  DIM SetString AS STRING * 80„  DIM Text$(500)            ' Too lazy to implement file pointers :>„                            ' Messages usually don't exceed 500 lines anyways„  COLOR 7, 0: CLS„  LOCATE Height, 1: COLOR 0, 7: PRINT "  Up/Down/PgUp/PgDn/Home/End       E[";„  COLOR 15: PRINT "X"; : COLOR 0: PRINT "]tract   +/- [N]ext/[P]rev              ";„  COLOR 7, 0„  LOCATE 2, 1„    SEEK #1, Messages&(FPNum)„    ReadWriteHdr QWK„    Chunks = VAL(QWK.NumChunk)„    PRINT "  Date: "; QWK.Date; " ("; QWK.Time; ")";„    PRINT , , "Number: "; QWK.MSGNum„    PRINT "  From: "; QWK.UpFROM;„    PRINT , "Refer#: "; QWK.ReferNum„    PRINT "    To: "; QWK.UpTO;„    PRINT , " Recvd: ";„    InCase$ = "-`^#"„    IF INSTR(QWK.Status, InCase$) THEN„      PRINT "YES"„    ELSE„      PRINT "NO"„    END IF„    PRINT "  Subj: "; QWK.Subject;„    Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„    PRINT , "  Conf: "; "("; Conference$; ")"„    LOCATE 2, 66: PRINT USING "#### of ####"; FPNum; Max„    DrawBox 1, 1, 80, 6, 7, 0, 0, 1„ „  N = 1„  FOR J = 1 TO Chunks - 1„    GET #1, , Buff„    X = 1„    FOR I = 1 TO 128„      IF MID$(Buff, I, 1) = CHR$(227) THEN„        N = N + 1„      ELSE„        Text$(N) = Text$(N) + MID$(Buff, I, 1)„      END IF„    NEXT I„  NEXT J„  MaxNum = N„  LOCATE 5, 66: PRINT "# Lines:"; MaxNum„  LOCATE 7„„FOR I = 1 TO Height - 7„  A = INSTR(Text$(I), ">")                        ' Quote„  IF A < 6 AND A > 0 THEN COLOR 15 ELSE COLOR 7   ' Color BrightWhite„  SetString = Text$(I)„  PRINT SetString;„  IF I = MaxNum THEN EXIT FOR„NEXT I„I = 1„COLOR 0, 7: LOCATE Height, 67: PRINT I; "..."; I + Height - 7;„„  DO„    DO„      A$ = INKEY$„    LOOP UNTIL A$ <> ""„    IF LEN(A$) = 2 THEN Char = -ASC(RIGHT$(A$, 1)) ELSE Char = ASC(A$)„    SELECT CASE Char„      CASE 43, 78, 110                  ' +/N Goto Next Message„        FPNum = FPNum + 1„        IF FPNum > Max THEN FPNum = 1„        ERASE Text$„        GOTO BeginHere„      CASE 45, 80, 112                  ' -/P Goto Previous Message„        FPNum = FPNum - 1„        IF FPNum = 0 THEN FPNum = Max„        ERASE Text$„        GOTO BeginHere„      CASE 88, 120                      ' X - Extract Message„        FileName$ = LTRIM$(STR$(FPNum)) + ".MSG"„        OPEN FileName$ FOR OUTPUT AS #2„        DumpHeader QWK„        FOR X = 1 TO MaxNum„           PRINT #2, Text$(X)„        NEXT X„        CLOSE #2„        LOCATE 3, 63: COLOR 15, 0: PRINT "Saved as "; FileName$„      CASE -72                          ' Up arrow key„        IF I > 1 THEN„          I = I - 1„          GOSUB ShowMessage„        END IF„      CASE -73                          ' PageUp„        I = I - Height + 7„        IF I < 1 THEN I = 1„        GOSUB ShowMessage„      CASE -80                          ' Down arrow key„        IF I < MaxNum THEN„          I = I + 1„          GOSUB ShowMessage„        END IF„      CASE -81                          ' PageDown„        I = I + Height - 7„        IF I > MaxNum - Height + 7 THEN I = MaxNum - Height + 7„        GOSUB ShowMessage„      CASE -79                          ' End„        I = MaxNum - Height + 7„        GOSUB ShowMessage„      CASE -71                          ' Home„        I = 1„        GOSUB ShowMessage„      CASE 27                           ' Escape key pressed„         GOTO BackToIndex„    END SELECT„  LOOP„„ShowMessage:„  IF MaxNum < Height - 7 THEN RETURN„  LOCATE 7, 1„  FOR X = 1 TO Height - 7„    A = INSTR(Text$(I), ">")                            ' Quote„    IF A < 6 AND A > 0 THEN COLOR 15, 0 ELSE COLOR 7, 0 ' Color BrightWhite„    SetString = Text$(I)„    PRINT SetString;„    IF I >= MaxNum THEN EXIT FOR„    I = I + 1„  NEXT X„  I = I - Height + 7„  COLOR 0, 7: LOCATE Height, 67: PRINT I; "..."; I + Height - 7;„RETURN„„BackToIndex:„  FPNum = BakFPNum„„END SUB„„SUB DrawBox (X%, Y%, XX%, YY%, C%, BC%, Solid%, CharSet%)„„IF CharSet% = 1 THEN„  Char1$ = "⁄"„  CharHoz$ = "ƒ"„  Char2$ = "ø"„  CharVert$ = "≥"„  Char3$ = "¿"„  Char4$ = "Ÿ"„END IF„„IF CharSet% = 2 THEN„  Char1$ = "…"„  CharHoz$ = "Õ"„  Char2$ = "ª"„  CharVert$ = "∫"„  Char3$ = "»"„  Char4$ = "º"„END IF„„COLOR C%, BC%„A = (XX% - X%) - 1„LOCATE Y%, X%: PRINT Char1$; STRING$(A, CharHoz$); Char2$;„FOR I = Y% + 1 TO YY% - 1„  LOCATE I, X%: PRINT CharVert$;„  IF Solid% = 1 THEN PRINT SPACE$(A);„  LOCATE I, XX%: PRINT CharVert$;„NEXT I„LOCATE YY%, X%: PRINT Char3$; STRING$(A, CharHoz$); Char4$;„„END SUB„„SUB DumpHeader (QWK AS MSGDatHdr)„   „    PRINT #2, STRING$(79, "=")„    PRINT #2, "   Date: "; QWK.Date; " ("; QWK.Time; ")";„    PRINT #2, , , "Number: "; QWK.MSGNum„    PRINT #2, "   From: "; QWK.UpFROM;„    PRINT #2, , "Refer#: "; QWK.ReferNum„    PRINT #2, "     To: "; QWK.UpTO;„    PRINT #2, , " Recvd: ";„    InCase$ = "-`^#"„    IF INSTR(QWK.Status, InCase$) THEN„      PRINT #2, "YES"„    ELSE„      PRINT #2, "NO"„    END IF„    PRINT #2, "Subject: "; QWK.Subject;„    Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„    PRINT #2, , "  Conf: "; "("; Conference$; ")"„    PRINT #2, STRING$(79, "-")„„END SUB„„SUB MessageList (Messages&(), Max, QWK AS MSGDatHdr)„„' Scrolling up/down pages can be optimized by using a Screen Scroll routine„' requiring either a call to ABSOLUTE() Function for QBasic or interrupt„' routines via INTRPT.OBJ in QB.LIB„' Recommended ABC Packet: INTERRPT.ABC, DOS.ABC, and TEXT.ABC, ASMCODE.ABC„„  DrawBox 1, 1, 80, 3, 7, 0, 0, 2„  DrawBox 1, Height - 1, 80, Height, 7, 0, 0, 1„ „  LOCATE 2, 3: PRINT "Number  From               To                 Subject                   Conf"„  FOR I = 1 TO Height - 5„    IF I > Max THEN EXIT FOR„    SEEK #1, Messages&(I)„    ReadWriteHdr QWK„    LOCATE I + 3, 3: PRINT USING "#####"; VAL(QWK.MSGNum);„    PRINT "   "; LEFT$(QWK.UpFROM, 19);„    PRINT LEFT$(QWK.UpTO, 19); QWK.Subject;„    Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„    PRINT " ("; Conference$; ")";„  NEXT I„„  Index = 1„  Position = 4„  SEEK #1, Messages&(Index)„  ReadWriteHdr QWK„  COLOR 0, 7„  LOCATE Position, 2: PRINT USING " #####"; VAL(QWK.MSGNum);„  PRINT "   "; LEFT$(QWK.UpFROM, 19);„  PRINT LEFT$(QWK.UpTO, 19); QWK.Subject;„  Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„  PRINT " ("; Conference$; ")";„ „  DO„    DO„      A$ = INKEY$„    LOOP UNTIL A$ <> ""„    IF LEN(A$) = 2 THEN Char = -ASC(RIGHT$(A$, 1)) ELSE Char = ASC(A$)„    SELECT CASE Char„      CASE 13                          ' ENTER Pressed„        PCOPY 0, 1„        'DEF SEG = &HB000              ' Uncomment these lines„        'BSAVE "LIST.TMP", 0, 4000     ' for monochrome support„        DisplayMessage Messages&(), Index, QWK, Max„        PCOPY 1, 0„        'BLOAD "LIST.TMP"„        'KILL "LIST.TMP"„      CASE -72                          ' Up arrow key„        IF Index > 1 THEN„          COLOR 7, 0: GOSUB SelectMsgNum„          Index = Index - 1„          Position = Position - 1„          COLOR 0, 7: GOSUB SelectMsgNum„        END IF„      CASE -73                          ' PageUp„       IF Max >= Height - 5 THEN„        IF Index <> 1 THEN„          Index = Index - Height + 5 - (Position - 4)„          IF Index <= 0 THEN Index = 1: Position = 4„          X = Position„          GOSUB PrevPage„          Position = X„          Index = Index + (Position - 4)„          COLOR 0, 7: GOSUB SelectMsgNum„        END IF„       END IF„      CASE -80                          ' Down arrow key„        IF Index <> Max THEN„          COLOR 7, 0: GOSUB SelectMsgNum„          Index = Index + 1„          Position = Position + 1„          COLOR 0, 7: GOSUB SelectMsgNum„        END IF„      CASE -81                          ' PageDown„       IF Max >= Height - 5 THEN„        IF Index + (2 * Height) - (Position - 4) - 6 >= Max THEN„          Index = Max„          Position = Height - 2„        ELSE„          Index = Index + (2 * Height) - 11 - (Position - 4)„        END IF„        X = Position„        GOSUB NextPage„        Position = X„        IF Index <> Max THEN„          Index = Index - Height + 6 + (Position - 4)„        ELSE„          Position = Height - 2„          Index = Max„        END IF„        COLOR 0, 7: GOSUB SelectMsgNum„       END IF„      CASE -79                          ' End„       IF Max >= Height - 5 THEN„        Index = Max: Position = Height - 2„        GOSUB NextPage„        GOSUB SelectMsgNum„       END IF„      CASE -71                          ' Home„       IF Max >= Height - 5 THEN„        Index = 1: Position = 4„        GOSUB PrevPage„        GOSUB SelectMsgNum„       END IF„      CASE 27                           ' Escape key pressed„        CLOSE : COLOR 7, 0: CLS : END„    END SELECT„  LOOP„„SelectMsgNum:„  IF Position > Height - 2 THEN GOSUB NextPage„  IF Position = 3 THEN GOSUB PrevPage„  SEEK #1, Messages&(Index)„  ReadWriteHdr QWK„  LOCATE Position, 2: PRINT USING " #####"; VAL(QWK.MSGNum);„  PRINT "   "; LEFT$(QWK.UpFROM, 19);„  PRINT LEFT$(QWK.UpTO, 19); QWK.Subject;„  Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„  PRINT " ("; Conference$; ")";„RETURN„„NextPage:„  Index = Index - Height + 5„  FOR I = 1 TO Height - 5„    Index = Index + 1„    IF Index >= Max THEN EXIT FOR„    SEEK #1, Messages&(Index)„    ReadWriteHdr QWK„    COLOR 7, 0„    LOCATE I + 3, 2: PRINT USING " #####"; VAL(QWK.MSGNum);„    PRINT "   "; LEFT$(QWK.UpFROM, 19);„    PRINT LEFT$(QWK.UpTO, 19); QWK.Subject;„    Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„    PRINT " ("; Conference$; ")"„  NEXT I„  Position = Height - 2„  COLOR 0, 7„RETURN„„PrevPage:„  Index = Index - 1„  FOR I = 1 TO Height - 5„    Index = Index + 1„    IF Index >= Max THEN EXIT FOR„    SEEK #1, Messages&(Index)„    ReadWriteHdr QWK„    COLOR 7, 0„    LOCATE I + 3, 2: PRINT USING " #####"; VAL(QWK.MSGNum);„    PRINT "   "; LEFT$(QWK.UpFROM, 19);„    PRINT LEFT$(QWK.UpTO, 19); QWK.Subject;„    Conference$ = LTRIM$(STR$(ASC(QWK.MostSig) * 256 + ASC(QWK.LeastSig)))„    PRINT " ("; Conference$; ")";„  NEXT I„  Index = Index - (Height - 6)„  Position = 4: COLOR 0, 7„RETURN„„END SUB„„SUB ReadMessage (QWK AS MSGDatHdr, RelNum&, Chunks)„ „  SEEK #1, RelNum&„  ReadWriteHdr QWK„  Chunks = VAL(QWK.NumChunk)„  IF DumpQWKtoFile THEN ReadMsg Chunks„„END SUB„„SUB ReadMsg (NumChunks)„„  DIM Buff AS STRING * 128„„  FOR J = 1 TO NumChunks - 1„    GET #1, , Buff„    FOR I = 1 TO 128„      IF MID$(Buff, I, 1) = CHR$(227) THEN„        PRINT #2,„      ELSE„        PRINT #2, MID$(Buff, I, 1);„      END IF„    NEXT I„  NEXT J„„END SUB„„SUB ReadWriteHdr (QWK AS MSGDatHdr)„„    GET #1, , QWK.Status„    GET #1, , QWK.MSGNum„    GET #1, , QWK.Date„    GET #1, , QWK.Time„    GET #1, , QWK.UpTO„    GET #1, , QWK.UpFROM„    GET #1, , QWK.Subject„    GET #1, , QWK.PassWord„    GET #1, , QWK.ReferNum„    GET #1, , QWK.NumChunk„    GET #1, , QWK.Alive„    GET #1, , QWK.LeastSig„    GET #1, , QWK.MostSig„    GET #1, , QWK.Reserved„„  IF DumpQWKtoFile THEN„    DumpHeader QWK„  END IF„„END SUB„„Andrew Jones                   TYPING DRILL                   FidoNet QUIK_BAS Echo          04-14-96 (14:33)       QB, QBasic, PDS        64   1408     TYPING.BAS  'Typing drill.  Very elementary, not sure if the timing is absolutely„'correct.„„CLS„word = 1„PRINT "Typing drill...  Type one sentence as quickly as you can..."„PRINT "It can be as short as you want or as long, but keep a constant length."„PRINT "The best drill sentence would be: 'The quick brown fox jumped over the lazy dog'"„PRINT "because it uses all alphabet keys...  Long sentences are more stastically"„PRINT "accurate."„PRINT "Timing starts at the first key pressed!"„PRINT„DO„b$ = INKEY$„LOOP UNTIL b$ <> ""„PRINT b$;„TIMER ON„ON TIMER(1) GOSUB timerr„DO„a$ = INKEY$„SELECT CASE a$„CASE CHR$(8)„corr = corr + 1„SOUND 400, .2„SOUND 500, .2„SOUND 400, .2„b$ = MID$(b$, 1, LEN(b$) - 1)„IF LEN(b$) >= 1 THEN„LOCATE CSRLIN, POS(0) - 1„PRINT " ";„LOCATE CSRLIN, POS(0) - 1„ELSE„LOCATE CSRLIN, 1„PRINT " ";„LOCATE CSRLIN, 1„END IF„CASE CHR$(32) TO CHR$(127)„SOUND 200, .2„b$ = b$ + a$„PRINT a$;„CASE ELSE„END SELECT„LOOP UNTIL a$ = CHR$(13)„FOR t = 1 TO LEN(b$)„m$ = MID$(b$, t, 1)„IF m$ = " " THEN word = word + 1„NEXT„PRINT„PRINT„PRINT "Statistics:"„IF sec = 0 THEN„PRINT "No time was passed, at least according to significant figures used!"„END„END IF„PRINT "Seconds typing: "; sec„PRINT "Words Per Second: "; word / sec„PRINT "Words Per Minute: "; (word / sec) * 60„PRINT "Corrections Made: "; corr„ „END„ „timerr:„sec = sec + 1„RETURN„Len Philpot                    TOGGLE COLOR BLINKING ON/OFF   FidoNet QUIK_BAS Echo          05-04-95 (16:29)       QB, PDS                29   1050     SETBLINK.BAS'* I found an OUT statement awhile back, that would turn off blinking on„'* the machine.  But it doesn't work.  In the QB Options, Colors menu, you„„'There's an interrupt call that will toggle between blinking foreground „'and high-intensity background colors. The following is a very simple „'little program I wrote to toggle it back and forth.„„DEFINT A-Z„„'$INCLUDE: 'qb.bi'„„   DIM InRegs AS RegType, OutRegs AS RegType„„   IF COMMAND$ = "ON" THEN„        InRegs.BX = 1                  '*„     ELSEIF COMMAND$ = "OFF" THEN„        InRegs.BX = 0                  '*„      ELSE„        PRINT "Usage:  BLINK on (enables blinking FG and disables bright BG colors)"„        PRINT "        BLINK off (disables blinking FG and enables bright BG colors)"„      END„   END IF„    InRegs.AX = &H1003                 '*„    Interrupt &H10, InRegs, OutRegs    '*„   PRINT„„'The lines commented with an asterisk are what you're looking for. Call „'BIOS interrupt 10h, sub function 1003h. Set bx to 1 to blink, 0 to „'disable it.„Tate P. Sonnier                DATABASE PROGRAM               tate_sonnier@juno.com          05-17-96 (17:01)       QB, QBasic, PDS        1800 29664    DATABASE.BAS'--------------------------------DATABASE.BAS----------------------------------„'This is a simple little database that can be used and configured to store„'as many as 40 fields per database and an unlimited amount of databases.„'There are still a few bugs that need to be worked out. Feel free to use, fix, modify,„'or copy partions of this program for your own use. Send an questions, comments,„'suggestions, or changes you make to TATE_SONNIER@JUNO.COM„„COMMON SHARED DB$„DECLARE SUB VIEWALL ()„DECLARE SUB PRINTALL ()„DECLARE SUB PRINTA ()„DECLARE SUB RECORDSORT ()„DECLARE SUB VIEWRECORD (T!, DB$)„DECLARE SUB RECORDSORTP ()„DECLARE SUB PRINTRECORD (T!, DB$)„DECLARE SUB DELETERECORD ()„DECLARE SUB SORTDELETE (T!, DB$)„DECLARE SUB EDITRECORD ()„DECLARE SUB SORTEDIT (T!, DB$)„DECLARE SUB DELETEFIELD ()„DECLARE SUB EDITFIELD ()„DECLARE SUB NEWFIELD ()„DECLARE SUB ADDRECORD ()„DECLARE SUB NEW ()„DECLARE SUB EDIT ()„DECLARE SUB DELETE ()„ON ERROR GOTO HANDLE„CLS„L = 1„DO„TOP:„COLOR 15, 0: LOCATE 1, 1: PRINT "Selected Database": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ": LOCATE 3, 1: PRINT UCASE$(DB$)„„IF L < 1 OR L > 6 THEN L = 1„COLOR 15, 0„IF L = 1 THEN LOCATE 23, 1: PRINT "CREATES NEW DATABASE                  ": COLOR 15, 4„LOCATE 1, 35„PRINT "New Database"„„COLOR 15, 0„IF L = 2 THEN LOCATE 23, 1: PRINT "SELECTS DATABASE TO BE WORKED WITH                ": COLOR 15, 4„LOCATE 2, 35„PRINT "Select Database"„„COLOR 15, 0„IF L = 3 THEN LOCATE 23, 1: PRINT "THE EDITING MENU (EDIT/CHANGE FIELDS OR RECORD)            ": COLOR 15, 4„LOCATE 3, 35„PRINT "Edit Database"„„COLOR 15, 0„IF L = 4 THEN LOCATE 23, 1: PRINT "PRINTS/VIEWS THE RECORDS OF A DATABASE            ": COLOR 15, 4„LOCATE 4, 35„PRINT "Print/View Database"„„COLOR 15, 0„IF L = 5 THEN LOCATE 23, 1: PRINT "DELETES A DATABASE AND ALL RECORDS IN IT                   ": COLOR 15, 4„LOCATE 5, 35„PRINT "Delete Database"„„COLOR 15, 0„IF L = 6 THEN LOCATE 23, 1: PRINT "EXITS THE PROGRAM                                        ": COLOR 15, 4„LOCATE 6, 35„PRINT "Quit"„„A$ = INKEY$„SELECT CASE A$„CASE IS = CHR$(0) + "P"„L = L + 1„IF L = 7 THEN L = 1„„CASE IS = CHR$(0) + "H"„L = L - 1„IF L = 0 THEN L = 6„„CASE IS = CHR$(13)„IF L = 1 THEN CALL NEW„IF L = 2 THEN„E:„LOCATE 3, 1: COLOR 15, 0„INPUT "-", DB$„IF LEN(DB$) < 1 THEN GOTO E„CLS„END IF„IF L = 3 AND LEN(DB$) > 0 THEN„CALL EDIT„ELSEIF L = 3 AND LEN(DB$) = 0 THEN„LOCATE 23, 1: COLOR 20: PRINT "A DATABASE MUST BE SELECTED FIRST                 ": BEEP: SLEEP 5„END IF„„IF L = 4 AND LEN(DB$) > 0 THEN„CALL PRINTA„ELSEIF L = 4 AND LEN(DB$) = 0 THEN„LOCATE 23, 1: COLOR 20: PRINT "A DATABASE MUST BE SELECTED FIRST                 ": BEEP: SLEEP 5„END IF„„IF L = 5 THEN CALL DELETE„IF L = 6 THEN COLOR 0, 0: CLS : STOP„„END SELECT„LOOP„„HANDLE:„CLS„GOTO TOP„„SUB ADDRECORD„L = 1„V:„CLS„L = 1„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„INPUT #1, C$„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„AD = 0„FOR X = 1 TO COUNT„AD = AD + LNE(X)„NEXT„CLOSE #1„FF = 1„CLOSE #2„OPEN DB$ + ".DBD" FOR APPEND AS #2„K = 1„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 1„PRINT NM$(X + LJ); TAB(31); ":": LOCATE X, 33: COLOR 15, 0: PRINT FI$(X +LJ)„NEXT„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = COUNT + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„PO = 0„FOR R = 1 TO COUNT„DO UNTIL LEN(FI$(R)) = LNE(R)„FI$(R) = FI$(R) + " "„PO = PO + 1„LOOP„ANS$ = ANS$ + FI$(R)„NEXT„IF PO <> AD THEN WRITE #2, ANS$„CLOSE #2„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„LOCATE L, 1„COLOR 15, 0„PRINT NM$(L + LJ); TAB(31); ":";„COLOR 1, 9„FOR T = 1 TO LNE(L + LJ)„PRINT " ";„NEXT„Z$ = ""„INP$ = ""„DO UNTIL Z$ = CHR$(13)„H:„Z$ = INKEY$„„IF Z$ = "" THEN GOTO H„„IF Z$ = CHR$(8) AND LEN(INP$) >= 1 THEN INP$ = LEFT$(INP$, (LEN(INP$) -1)): LOCATE L, 33: COLOR 15, 9: FOR T = 1 TO LNE(L): PRINT " "; : NEXT T: COLOR 15, 9: LOCATE L, 33: PRINT INP$: GOTO H„IF LEN(INP$) < LNE(L + LJ) AND Z$ <> CHR$(13) THEN INP$ = INP$ + Z$„LOCATE L, 33: COLOR 15, 9: PRINT INP$„LOOP„FI$(L) = INP$„LOCATE L, 1„COLOR 15, 4„PRINT NM$(L + LJ); TAB(31); ":";„„IF L < 20 THEN L = L + 1„IF L = COUNT - 20 + 1 AND LJ = 20 THEN L = 1„„END SELECT„„LOOP„„END SUB„„SUB DELETE„L = 1„CLS„I:„INPUT "NAME OF DATABASE TO DELETE "; DB$„IF LEN(DB$) < 1 THEN GOTO I„CLS„PRINT "CONFIRM DELETE OF "; DB$; " (Y/N)"„T:„H$ = INPUT$(1)„IF UCASE$(H$) <> "Y" AND UCASE$(H$) <> "N" THEN GOTO T„IF UCASE$(H$) = "Y" THEN KILL DB$ + ".DBD": KILL DB$ + ".DBI"„CLS„DB$ = ""„END SUB„„SUB DELETEFIELD„VVV:„CLS„„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„INPUT #1, C$„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„CLOSE #1„FF = 1„K = 1„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 1„PRINT NM$(X + LJ); TAB(45); "LENGTH :"; LNE(X + LJ)„NEXT„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = C + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„CLOSE #1„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„„„LOCATE L, 1„COLOR 15, 0„PRINT "CONFIRM DELETE (Y/N)"„28 :„ANS$ = INPUT$(1)„IF UCASE$(ANS$) <> "Y" AND UCASE$(ANS$) <> "N" THEN GOTO 28„IF UCASE$(ANS$) = "Y" THEN„„CLOSE #1„OPEN DB$ + ".DBI" FOR OUTPUT AS #1„WRITE #1, C$„FOR R = 1 TO COUNT„IF R <> L THEN WRITE #1, NM$(R), LNE(R), GO(R)„NEXT„CLS„COLOR 15, 0„EXIT SUB„END IF„END SELECT„„LOOP„„END SUB„„SUB DELETERECORD„L = 1„VAA:„CLS„„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„INPUT #1, C$„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„CLOSE #1„FF = 1„CLOSE #2„OPEN DB$ + ".DBD" FOR APPEND AS #2„K = 1„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT NM$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "Delete Record": LOCATE 2, 1: PRINT "-------------"„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT - 20): CLS„IF L = COUNT + 2 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„CLS„CLOSE #1„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„T = L + LJ„CALL SORTDELETE(T, DB$)„END SELECT„LOOP„„END SUB„„SUB EDIT„„CLS„L = 1„DO„COLOR 15, 0: LOCATE 1, 1: PRINT "Selected Database": LOCATE 2, 1: PRINT "-----------------": LOCATE 3, 1: PRINT UCASE$(DB$)„COLOR 15, 0„IF L = 1 THEN LOCATE 23, 1: PRINT "CREATE NEW FIELD/QUESTION IN A DATABASE             ": COLOR 15, 4„LOCATE 1, 38„PRINT "New Field"„„COLOR 15, 0„IF L = 2 THEN LOCATE 23, 1: PRINT "DELETE FIELD/QUESTION IN A DATABASE            ": COLOR 15, 4„LOCATE 2, 38„PRINT "Delete Field"„COLOR 15, 0„IF L = 3 THEN LOCATE 23, 1: PRINT "EDIT FIELD/QUESTION IN A DATABASE            ": COLOR 15, 4„LOCATE 3, 38„PRINT "Edit Field"„COLOR 15, 0„IF L = 4 THEN LOCATE 23, 1: PRINT "ADD NEW RECORD TO DATABASE                         ": COLOR 15, 4„LOCATE 4, 38„PRINT "Add Record"„„COLOR 15, 0„IF L = 5 THEN LOCATE 23, 1: PRINT "EDIT PREVIOUSLY ENTERED DATABASE                  ": COLOR 15, 4„LOCATE 5, 38„PRINT "Edit Record"„„COLOR 15, 0„IF L = 6 THEN LOCATE 23, 1: PRINT "DELETE PREVIOUSLY ENTERED DATABASE                 ": COLOR 15, 4„LOCATE 6, 38„PRINT "Delete Record"„„COLOR 15, 0„IF L = 7 THEN LOCATE 23, 1: PRINT "EXIT TO MAIN MENU                                  ": COLOR 15, 4„LOCATE 7, 38„PRINT "Quit"„„A$ = INKEY$„SELECT CASE A$„CASE IS = CHR$(0) + "P"„L = L + 1„IF L = 8 THEN L = 1„CASE IS = CHR$(27)„CLS„COLOR 15, 0„EXIT SUB„CASE IS = CHR$(0) + "H"„L = L - 1„IF L = 0 THEN L = 7„„CASE IS = CHR$(13)„IF L = 1 THEN L = 1: CALL NEWFIELD: CLS : L = 1„IF L = 2 THEN L = 1: CALL DELETEFIELD: CLS : L = 1„IF L = 3 THEN L = 1: CALL EDITFIELD: CLS : L = 1„IF L = 4 THEN L = 1: CALL ADDRECORD: CLS : L = 1„IF L = 5 THEN L = 1: CALL EDITRECORD: CLS : L = 1„IF L = 6 THEN L = 1: CALL DELETERECORD: CLS : L = 1„IF L = 7 THEN COLOR 0, 0: CLS : EXIT SUB„„END SELECT„„LOOP„„END SUB„„SUB EDITFIELD„L = 1„VV:„CLS„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„INPUT #1, C$„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„CLOSE #1„FF = 1„K = 1„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 1„PRINT NM$(X + LJ); TAB(45); "LENGTH :"; LNE(X + LJ)„NEXT„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = C + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„CLOSE #1„OPEN DB$ + ".DBI" FOR OUTPUT AS #1„WRITE #1, C$„FOR R = 1 TO COUNT„WRITE #1, NM$(R), LNE(R), GO(R)„NEXT„CLOSE #1„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„„29 :„LOCATE L, 54„COLOR 15, 0„INPUT "", LNE(L + LJ)„IF LEN(LNE(L + LJ)) = 0 THEN GOTO 29„„30 :„LOCATE L, 1„COLOR 15, 0„INPUT "", NM$(L + LJ)„IF LEN(NM$(L + LJ)) < 1 THEN GOTO 30„„LOCATE L, 1„COLOR 15, 4„PRINT NM$(L + LJ)„„„END SELECT„„LOOP„„END SUB„„SUB EDITRECORD„„L = 1„VA:„CLS„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„INPUT #1, C$„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„CLOSE #1„FF = 1„CLOSE #2„OPEN DB$ + ".DBD" FOR APPEND AS #2„K = 1„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT NM$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "Edit Record": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒ"„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = COUNT + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„CLS„CLOSE #1„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„T = L + LJ„CALL SORTEDIT(T, DB$)„END SELECT„„LOOP„„END SUB„„SUB NEW„„CLS„INPUT "Name of database "; DB$„CLS„LOCATE 1, 1„B:„LOCATE 1, 1„PRINT "If the database "; : COLOR 4: PRINT DB$; : COLOR 15: PRINT " has already been created all data in it will be lost"„PRINT "CONTINUE(Y/N)"„A$ = INPUT$(1)„IF UCASE$(A$) <> "Y" AND UCASE$(A$) <> "N" THEN GOTO B„IF UCASE$(A$) = "Y" THEN„OPEN DB$ + ".DBI" FOR OUTPUT AS #1„WRITE #1, DB$„CLOSE #1„END IF„CLS„END SUB„„SUB NEWFIELD„L = 1„CLS„A:„„DO„OPEN DB$ + ".DBI" FOR INPUT AS #1„INPUT #1, C$„B = 0„DO UNTIL EOF(1)„B = B + 1„INPUT #1, NAME$, LE, BE„LOOP„CLOSE #1„OPEN DB$ + ".DBI" FOR APPEND AS #1„„AA:„IF B > 40 THEN BEEP: CLS : PRINT "No more than 41 fields allowed": SLEEP:EXIT SUB„CLS„LOCATE 1, 1„INPUT "Name of New Field (NO MORE THAN 30 CHARACTERS)"; NF$„IF LEN(NF$) < 1 OR LEN(NF$) > 30 THEN : BEEP: PRINT "Invalid Field":SLEEP: GOTO AA„„AAA:„CLS„LOCATE 1, 1„INPUT "LENGTH of New Field "; NFL„IF LEN(NFL) < 1 THEN : BEEP: PRINT "Invalid Field LENGTH": SLEEP: GOTO AAA„CLS„PRINT "Is this OK (Y/N)"„PRINT "The Field ("; NF$; ") with a LENGTH of "; NFL„AAAA:„J$ = INPUT$(1)„IF UCASE$(J$) <> "Y" AND UCASE$(J$) <> "N" THEN GOTO AAAA„f = BE + LE„IF f = 0 THEN f = 1„IF UCASE$(J$) = "Y" THEN WRITE #1, NF$, NFL, f„IF UCASE$(J$) = "N" THEN GOTO AA„CLS„PRINT "Add Another Field (Y/N)"„AAAAA:„J$ = INPUT$(1)„IF UCASE$(J$) <> "Y" AND UCASE$(J$) <> "N" THEN B = B + 1: GOTO AAAAA„IF UCASE$(J$) = "N" THEN CLOSE #1: CLS : EXIT SUB„CLOSE #1„LOOP„END SUB„„SUB PRINTA„CLS„L = 1„DO„COLOR 15, 0: LOCATE 1, 1: PRINT "Selected Database": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ": LOCATE 3, 1: PRINT UCASE$(DB$)„COLOR 15, 0„IF L = 1 THEN LOCATE 23, 1: PRINT "VIEW INDIVIDUAL RECORD                             ": COLOR 15, 4„LOCATE 1, 38„PRINT "View Record"„„COLOR 15, 0„IF L = 2 THEN LOCATE 23, 1: PRINT "PRINT INDIVIDUAL RECORD                            ": COLOR 15, 4„LOCATE 2, 38„PRINT "Print Record"„COLOR 15, 0„IF L = 3 THEN LOCATE 23, 1: PRINT "VIEW ALL RECORDS                                   ": COLOR 15, 4„LOCATE 3, 38„PRINT "View All Records"„COLOR 15, 0„IF L = 4 THEN LOCATE 23, 1: PRINT "PRINT ALL RECORDS                                 ": COLOR 15, 4„LOCATE 4, 38„PRINT "Print All Record"„„COLOR 15, 0„IF L = 5 THEN LOCATE 23, 1: PRINT "RETURNS TO MAIN MENU                               ": COLOR 15, 4„LOCATE 5, 38„PRINT "Quit"„„„„A$ = INKEY$„SELECT CASE A$„CASE IS = CHR$(0) + "P"„L = L + 1„IF L = 6 THEN L = 1„„CASE IS = CHR$(0) + "H"„L = L - 1„IF L = 0 THEN L = 5„CASE IS = CHR$(27)„CLS„EXIT SUB„CASE IS = CHR$(13)„IF L = 1 THEN L = 1: CALL RECORDSORT: CLS : L = 1„IF L = 2 THEN L = 1: CALL RECORDSORTP: CLS : L = 1„IF L = 3 THEN CALL VIEWALL: CLS„IF L = 4 THEN CALL PRINTALL: CLS„IF L = 5 THEN COLOR 0, 0: CLS : EXIT SUB„END SELECT„LOOP„„END SUB„„SUB PRINTALL„CLOSE #1„L = 1„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„ CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„CLOSE #2„„OPEN DB$ + ".DBI" FOR INPUT AS #1„OPEN DB$ + ".DBD" FOR INPUT AS #2„INPUT #1, C$„„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„H = 0„„DO UNTIL EOF(2)„INPUT #2, ANS$„H = H + 1„LOOP„DIM FI1$(1 TO H)„DIM AS$(1 TO H)„CLOSE #2„OPEN DB$ + ".DBD" FOR INPUT AS #2„FOR Y = 1 TO H„FOR X = 1 TO H„IF FI1$(Y) < FI1$(X) THEN SWAP FI1$(Y), FI1$(X): SWAP AS$(X), AS$(Y)„NEXT„NEXT„„FOR X = 1 TO H„INPUT #2, ANS$„AS$(X) = ANS$„NEXT„„„„FF = 1„K = 1„„„„LJ = 0„FOR PP = 1 TO H„„FOR X = 1 TO COUNT„FI$(X) = MID$(AS$(PP), GO(X), LNE(X))„NEXT„„FOR X = 1 TO COUNT„COLOR 15„LPRINT NM$(X + LJ); TAB(31); ": "; FI$(X + LJ)„NEXT„„FOR X = 1 TO 2„LPRINT„NEXT„LPRINT "------------------------------------------------------------------------------"„FOR X = 1 TO 2„LPRINT„NEXT„„NEXT„LPRINT CHR$(10)„END SUB„„SUB PRINTRECORD (T, DB$)„CLOSE #1„L = 1„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„CLOSE #2„„OPEN DB$ + ".DBI" FOR INPUT AS #1„OPEN DB$ + ".DBD" FOR INPUT AS #2„INPUT #1, C$„„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„H = 0„DO UNTIL EOF(2)„INPUT #2, ANS$„H = H + 1„LOOP„DIM FI1$(1 TO H)„DIM AS$(1 TO H)„„CLOSE #2„OPEN DB$ + ".DBD" FOR INPUT AS #2„„FOR X = 1 TO H„INPUT #2, ANS$„AS$(X) = ANS$„FI1$(X) = MID$(ANS$, GO(T), LNE(T))„NEXT„FOR Y = 1 TO H„FOR X = 1 TO H„IF FI1$(Y) < FI1$(X) THEN SWAP FI1$(Y), FI1$(X): SWAP AS$(X), AS$(Y)„NEXT„NEXT„„CLOSE #1„FF = 1„K = 1„„IF H > 20 THEN C = 20:  ELSE C = H„DO„„FOR X = 1 TO H„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT FI1$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "Print Record By": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ": PRINT NM$(T)„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF H > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (H - 20):CLS„IF L = H + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF H > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = H„„CASE IS = CHR$(27)„„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„PP = LJ + L„FOR X = 1 TO COUNT„FI$(X) = MID$(AS$(PP), GO(X), LNE(X))„NEXT„„„FOR X = 1 TO COUNT„COLOR 15„LPRINT NM$(X + LJ); TAB(31); ": "; FI$(X + LJ)„NEXT„„„END SELECT„„LOOP„„END SUB„„SUB RECORDSORT„L = 1„CLS„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„INPUT #1, C$„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„CLOSE #1„FF = 1„CLOSE #2„OPEN DB$ + ".DBD" FOR APPEND AS #2„K = 1„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT NM$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "View Record": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒ"„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = COUNT + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„CLS„CLOSE #1„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„T = L + LJ„CALL VIEWRECORD(T, DB$)„END SELECT„LOOP„„END SUB„„SUB RECORDSORTP„CLS„L = 1„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„„OPEN DB$ + ".DBI" FOR INPUT AS #1„„INPUT #1, C$„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„CLOSE #1„FF = 1„CLOSE #2„OPEN DB$ + ".DBD" FOR APPEND AS #2„K = 1„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT NM$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "Print Record": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒ"„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = COUNT + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„CLS„CLOSE #1„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„T = L + LJ„CALL PRINTRECORD(T, DB$)„END SELECT„LOOP„END SUB„„SUB SORTDELETE (T, DB$)„CLOSE #1„L = 1„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„CLOSE #2„„OPEN DB$ + ".DBI" FOR INPUT AS #1„OPEN DB$ + ".DBD" FOR INPUT AS #2„INPUT #1, C$„„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„H = 0„DO UNTIL EOF(2)„INPUT #2, ANS$„H = H + 1„LOOP„DIM FI1$(1 TO H)„DIM AS$(1 TO H)„„CLOSE #2„OPEN DB$ + ".DBD" FOR INPUT AS #2„„FOR X = 1 TO H„INPUT #2, ANS$„AS$(X) = ANS$„FI1$(X) = MID$(ANS$, GO(T), LNE(T))„NEXT„FOR Y = 1 TO H„FOR X = 1 TO H„IF FI1$(Y) < FI1$(X) THEN SWAP FI1$(Y), FI1$(X): SWAP AS$(X), AS$(Y)„NEXT„NEXT„„CLOSE #1„FF = 1„K = 1„„IF H > 20 THEN C = 20:  ELSE C = H„DO„„FOR X = 1 TO H„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT FI1$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "Delete Record By": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ": LOCATE 3, 1: PRINT NM$(T)„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF H > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (H - 20):CLS„IF L = H + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF H > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„PP = L„„LOCATE 4, 1: COLOR 15: PRINT "CONFERM DELETE (Y/N)"„FG:„ADF$ = INPUT$(1)„IF UCASE$(ADF$) <> "Y" AND UCASE$(ADF$) <> "N" THEN GOTO FG:„IF UCASE$(ADF$) = "N" THEN CLS : EXIT SUB„CLOSE #1„CLOSE #2„OPEN DB$ + ".DBD" FOR OUTPUT AS #1„FOR X = 1 TO H„IF X <> PP THEN WRITE #1, AS$(X)„NEXT„CLOSE #1„CLS„COLOR 15, 0„EXIT SUB„„END SELECT„„LOOP„END SUB„„SUB SORTEDIT (T, DB$)„CLOSE #1„L = 1„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„CLOSE #2„„OPEN DB$ + ".DBI" FOR INPUT AS #1„OPEN DB$ + ".DBD" FOR INPUT AS #2„INPUT #1, C$„„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„H = 0„DO UNTIL EOF(2)„INPUT #2, ANS$„H = H + 1„LOOP„DIM FI1$(1 TO H)„DIM AS$(1 TO H)„„CLOSE #2„OPEN DB$ + ".DBD" FOR INPUT AS #2„„FOR X = 1 TO H„INPUT #2, ANS$„AS$(X) = ANS$„FI1$(X) = MID$(ANS$, GO(T), LNE(T))„NEXT„„FOR Y = 1 TO H„FOR X = 1 TO H„IF FI1$(Y) < FI1$(X) THEN SWAP FI1$(Y), FI1$(X): SWAP AS$(X), AS$(Y)„NEXT„NEXT„CLOSE #1„FF = 1„K = 1„„IF H > 20 THEN C = 20:  ELSE C = H„„DO„„FOR X = 1 TO H„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT FI1$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "Edit Record By": LOCATE 2, 1: PRINT "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ": LOCATE 3, 1: PRINT NM$(T)„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF H > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (H - 20):CLS„IF L = H + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF H > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = H„„CASE IS = CHR$(27)„„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„CLS„PP = L„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„FOR X = 1 TO COUNT„FI$(X) = MID$(AS$(PP), GO(X), LNE(X))„NEXT„„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 1„PRINT NM$(X + LJ); TAB(31); ": "; FI$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = COUNT + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„ANS$ = ""„FOR R = 1 TO COUNT„DO UNTIL LEN(FI$(R)) = LNE(R)„FI$(R) = FI$(R) + " "„LOOP„ANS$ = ANS$ + FI$(R)„NEXT„„AS$(PP) = ANS$„CLOSE #1„CLOSE #2„OPEN DB$ + ".DBD" FOR OUTPUT AS #1„FOR X = 1 TO H„WRITE #1, AS$(X)„NEXT„CLOSE #1„CLS„COLOR 15, 0„EXIT DO„„CASE IS = CHR$(13)„LOCATE L, 1„COLOR 15, 0„PRINT NM$(L + LJ); TAB(31); ": ";„COLOR 1, 9„FOR T = 1 TO LNE(L + LJ)„PRINT " ";„NEXT„Z$ = ""„INP$ = ""„DO UNTIL Z$ = CHR$(13)„HH:„Z$ = INKEY$„„IF Z$ = "" THEN GOTO HH„„IF Z$ = CHR$(8) AND LEN(INP$) >= 1 THEN INP$ = LEFT$(INP$, (LEN(INP$) -1)): LOCATE L, 33: COLOR 15, 9: FOR T = 1 TO LNE(L): PRINT " "; : NEXT T: COLOR 15, 9: LOCATE L, 33: PRINT INP$: GOTO HH„IF LEN(INP$) < LNE(L + LJ) AND Z$ <> CHR$(13) THEN INP$ = INP$ + Z$„LOCATE L, 33: COLOR 15, 9: PRINT INP$„LOOP„„FI$(L + LJ) = INP$„LOCATE L, 1„COLOR 15, 4„PRINT NM$(L + LJ); TAB(31); ":";„L = L + 1„IF L = COUNT + 1 THEN L = 1„„END SELECT„„LOOP„„„END SELECT„„LOOP„„END SUB„„SUB VIEWALL„CLOSE #1„L = 1„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„CLOSE #2„„OPEN DB$ + ".DBI" FOR INPUT AS #1„OPEN DB$ + ".DBD" FOR INPUT AS #2„INPUT #1, C$„„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„„H = 0„„DO UNTIL EOF(2)„INPUT #2, ANS$„H = H + 1„LOOP„DIM FI1$(1 TO H)„DIM AS$(1 TO H)„CLOSE #2„OPEN DB$ + ".DBD" FOR INPUT AS #2„„FOR X = 1 TO H„INPUT #2, ANS$„AS$(X) = ANS$„NEXT„FOR Y = 1 TO H„FOR X = 1 TO H„IF FI1$(Y) < FI1$(X) THEN SWAP FI1$(Y), FI1$(X): SWAP AS$(X), AS$(Y)„NEXT„NEXT„„FF = 1„K = 1„PP = 1„IF H > 20 THEN C = 20:  ELSE C = H„„LJ = 0„I = 0„DO UNTIL I = H„„„FOR X = 1 TO COUNT„FI$(X) = MID$(AS$(PP), GO(X), LNE(X))„NEXT„„FOR X = 1 TO COUNT„COLOR 15„LOCATE X, 1„PRINT NM$(X + LJ); TAB(31); ": "; FI$(X + LJ)„NEXT„„„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„COLOR 15, 0: LOCATE 22, 1: PRINT "PRESS ENTER FOR NEXT PAGE"„„„A$ = INKEY$„SELECT CASE A$„CASE IS = CHR$(27)„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„I = I + 1„IF H > 20 THEN LJ = 20: C = H - 20:  ELSE PP = PP + 1„END SELECT„„LOOP„„END SUB„„SUB VIEWRECORD (T, DB$)„CLS„CLOSE #1„L = 1„OPEN DB$ + ".DBI" FOR INPUT AS #1„„„„INPUT #1, C$„„COUNT = 0„„CLS„„DO UNTIL EOF(1)„„INPUT #1, NAME$, LE, BE„„COUNT = COUNT + 1„„LOOP„„DIM NM$(1 TO COUNT)„DIM LNE(1 TO COUNT)„DIM GO(1 TO COUNT)„DIM FI$(1 TO COUNT)„„CLOSE #1„CLOSE #2„„OPEN DB$ + ".DBI" FOR INPUT AS #1„OPEN DB$ + ".DBD" FOR INPUT AS #2„INPUT #1, C$„„„FOR X = 1 TO COUNT„INPUT #1, NAME$, LE, BE„NM$(X) = NAME$„LNE(X) = LE„GO(X) = BE„NEXT„„H = 0„DO UNTIL EOF(2)„INPUT #2, ANS$„H = H + 1„LOOP„DIM FI1$(1 TO H)„DIM AS$(1 TO H)„„CLOSE #2„OPEN DB$ + ".DBD" FOR INPUT AS #2„„FOR X = 1 TO H„INPUT #2, ANS$„AS$(X) = ANS$„FI1$(X) = MID$(ANS$, GO(T), LNE(T))„NEXT„FOR Y = 1 TO H„FOR X = 1 TO H„IF FI1$(Y) < FI1$(X) THEN SWAP FI1$(Y), FI1$(X): SWAP AS$(X), AS$(Y)„NEXT„NEXT„„CLOSE #1„FF = 1„K = 1„„IF H > 20 THEN C = 20:  ELSE C = H„DO„„FOR X = 1 TO H„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 38„PRINT FI1$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 1, 1: PRINT "View Record By": LOCATE 2, 1: PRINT "---------------": PRINT NM$(T)„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF H > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (H - 20):CLS„IF L = H + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF H > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = H„„CASE IS = CHR$(27)„„CLS„COLOR 15, 0„EXIT SUB„„CASE IS = CHR$(13)„CLS„PP = L„IF COUNT > 20 THEN C = 20:  ELSE C = COUNT„FOR X = 1 TO COUNT„FI$(X) = MID$(AS$(PP), GO(X), LNE(X))„NEXT„„DO„„FOR X = 1 TO C„COLOR 15, 0„IF L = X THEN COLOR 15, 4„LOCATE X, 1„PRINT NM$(X + LJ); TAB(31); ": "; FI$(X + LJ)„NEXT„COLOR 15, 0: LOCATE 23, 1: PRINT "PRESS ESCAPE TO QUIT"„„A$ = INKEY$„„SELECT CASE A$„CASE IS = CHR$(0) + "P"„„L = L + 1„„IF COUNT > 20 AND L = C + 1 THEN CLS : LJ = 20: L = 1: K = 21: C = (COUNT- 20): CLS„IF L = COUNT + 1 THEN L = 1„„CASE IS = CHR$(0) + "H"„„L = L - 1„IF COUNT > 20 AND L = 0 AND K = 21 THEN CLS : L = 20: LJ = 0: C = 20: CLS„IF L = 0 THEN L = C„„CASE IS = CHR$(27)„L = 1„CLS„COLOR 15, 0„EXIT DO„„END SELECT„„LOOP„„„END SELECT„„LOOP„„END SUB„Darryl Schneider               TYPING TUTOR                   fish2@datanet.ab.ca            05-19-96 (12:00)       QB, QBasic, PDS        122  3777     TT.BAS      'This is a little typing drill that tests how„'fast you can type the message and how accurate„'you are in doing so.„'„'Written by Darryl Schneider„'fish2@datanet.ab.ca„'The QBasic Zone„'http://www.geocities.com/SiliconValley/4244/qbasic.html„'„CLS„START:                         'start of program„RANDOMIZE TIMER„DIM TIMEVAR AS DOUBLE          'declaring all variables„DIM WPM AS INTEGER„DIM BEGIN AS STRING„DIM NUMWORDS AS INTEGER„DEFINT E„DEFSTR M, T„„TIMEVAR = TIMER                'giving values to the variables„MA1 = "THE "„MA2 = "QUICK "„MA3 = "BROWN "„MA4 = "FOX "„MA5 = "JUMPED "„MA6 = "OVER "„MA7 = "LAZY "„MA8 = "DOG."„„MESSAGE1 = MA1 + MA2 + MA3 + MA4 + MA5 + MA6 + MA1 + MA7 + MA8„NUMWORDS = LEN(MESSAGE1) / 5    'calculating # of words in message„„CLS                             'starting the type test„PRINT ""„PRINT "                   TYPE TEST"„PRINT ""„PRINT "*************************************************"„PRINT ""„PRINT "THE MESSAGE:"„PRINT ""„PRINT MESSAGE1„PRINT ""„PRINT "READY TO BEGIN(Y)? "     'prompts user for start„DO„BEGIN = UCASE$(INKEY$)„IF BEGIN = "Y" THEN GOSUB TYPING„IF BEGIN = "N" OR BEGIN = "Q" THEN GOSUB QUIT„LOOP WHILE BEGIN = ""„„TYPING:„PRINT ""„INPUT "GO: ", TYPEMESSAGE1                'user message input„TYPEMESSAGE1 = UCASE$(TYPEMESSAGE1)„TIMEVAR = TIMER - TIMEVAR„„MB1 = LEFT$(TYPEMESSAGE1, 4)              'giving each variable„MB2 = MID$(TYPEMESSAGE1, 5, 6)            'of the input the value„MB3 = MID$(TYPEMESSAGE1, 11, 6)           'of a word„MB4 = MID$(TYPEMESSAGE1, 17, 4)„MB5 = MID$(TYPEMESSAGE1, 21, 7)„MB6 = MID$(TYPEMESSAGE1, 28, 5)„MB7 = MID$(TYPEMESSAGE1, 33, 4)„MB8 = MID$(TYPEMESSAGE1, 37, 5)„MB9 = RIGHT$(TYPEMESSAGE1, 4)„„MC1 = LEFT$(MESSAGE1, 4)                  'giving each variable„MC2 = MID$(MESSAGE1, 5, 6)                'of the message the value„MC3 = MID$(MESSAGE1, 11, 6)               'of a word„MC4 = MID$(MESSAGE1, 17, 4)„MC5 = MID$(MESSAGE1, 21, 7)„MC6 = MID$(MESSAGE1, 28, 5)„MC7 = MID$(MESSAGE1, 33, 4)„MC8 = MID$(MESSAGE1, 37, 5)„MC9 = RIGHT$(MESSAGE1, 4)„„PRINT ""„ERRORS = 0„WPM = 60 / TIMEVAR * NUMWORDS        'calculates words per minute„PRINT "It took you "; TIMEVAR; " seconds to type that message."„PRINT "You typed that message at "; WPM; " words per minute."„PRINT ""„„IF NOT MB1 = MC1 THEN ERRORS = ERRORS + 1        'tabulates number of„IF NOT MB2 = MC2 THEN ERRORS = ERRORS + 1        'errors„IF NOT MB3 = MC3 THEN ERRORS = ERRORS + 1„IF NOT MB4 = MC4 THEN ERRORS = ERRORS + 1„IF NOT MB5 = MC5 THEN ERRORS = ERRORS + 1„IF NOT MB6 = MC6 THEN ERRORS = ERRORS + 1„IF NOT MB7 = MC7 THEN ERRORS = ERRORS + 1„IF NOT MB8 = MC8 THEN ERRORS = ERRORS + 1„IF NOT MB9 = MC9 THEN ERRORS = ERRORS + 1„„PRINT "You made "; ERRORS; " errors. "„E1RRORS = 9 - ERRORS                   'calculates accuracy„E2RRORS = E1RRORS / 9 * 100„PRINT "Your accuracy was "; E2RRORS; " %"„IF ERRORS = 0 THEN GOSUB AGAIN„„PRINT ""„PRINT "These are the following errors that you made: "„PRINT ""„IF NOT MB1 = MC1 THEN PRINT MB1; " should be "; MC1     'shows„IF NOT MB2 = MC2 THEN PRINT MB2; " should be "; MC2     'corrections„IF NOT MB3 = MC3 THEN PRINT MB3; " should be "; MC3„IF NOT MB4 = MC4 THEN PRINT MB4; " should be "; MC4„IF NOT MB5 = MC5 THEN PRINT MB5; " should be "; MC5„IF NOT MB6 = MC6 THEN PRINT MB6; " should be "; MC6„IF NOT MB7 = MC7 THEN PRINT MB7; " should be "; MC7„IF NOT MB8 = MC8 THEN PRINT MB8; " should be "; MC8„IF NOT MB9 = MC9 THEN PRINT MB9; " should be "; MC9„„AGAIN:„PRINT ""„PRINT "Try the test again(Y)? "          'prompt to start again„DO„TT = UCASE$(INKEY$)„LOOP WHILE TT = ""„IF TT = "Y" THEN GOSUB START„IF NOT TT = "Y" THEN GOSUB QUIT„„QUIT:„END„Darryl Schneider               BASIC OPERATING SYSTEM         fish2@datanet.ab.ca            05-19-96 (18:39)       QB, QBasic, PDS        247  7113     BOS.BAS     'BOS (Basic Operating System) 1.1„'This program was written to mimic the functions„'and commands available with the DOS Prompt. To„'see a list of commands, type HELP at the input„'prompt and an option menu will come up. In order„'for the program to work properly, you must type„'in proper file names and directories.„'„'Written by Darryl Schneider„'fish2@datanet.ab.ca„'The QBasic Zone„'http://www.geocities.com/SiliconValley/4244/qbasic.html„'„'start of program„'„DEFSTR A-M, P-Z                   'declare the variables„DEFINT N-O„COLOR 15                          'set default color„MESSAGE = "C:\"                   'and message„„CLEARSCREEN:„CLS„„START:„PRINT MESSAGE;„INPUT "", PROMPT                  'user prompt„„COMMANDS:„„EX3 = LEFT$(PROMPT, 6)            'This block of code changes„EX3 = UCASE$(EX3)                 'the message prompt„IF EX3 = "PROMPT" THEN„        EX4 = MID$(PROMPT, 8)„        MESSAGE = EX4„        PRINT ""„        GOSUB START„END IF„„PROMPT = UCASE$(PROMPT)           'User prompt is converted into„                                  'uppercase„„EX1 = LEFT$(PROMPT, 4)            'This block of code„IF EX1 = "DIR\" THEN              'displays the DIR listing„        EX2 = MID$(PROMPT, 5)     'for a specific directory„        FILES EX2„        PRINT ""„        GOSUB START„END IF„„EX5 = LEFT$(PROMPT, 6)             'This block of code„IF EX5 = "MKDIR\" THEN             'makes a directory„        EX6 = MID$(PROMPT, 7)„        MKDIR EX6„        PRINT ""„        GOSUB START„END IF„„EX7 = LEFT$(PROMPT, 6)             'This block of code„IF EX7 = "RMDIR\" THEN             'removes a directory„        EX8 = MID$(PROMPT, 7)„        RMDIR EX8„        PRINT ""„        GOSUB START„END IF„„EX11 = LEFT$(PROMPT, 7)„IF EX11 = "RENAME\" THEN„        ALD = MID$(PROMPT, 8)„        PRINT "Enter new file name for "; ALD;„        INPUT ":", AEW„        NAME ALD AS AEW             'This block of code„        PRINT ""                    'renames a file„        GOSUB START„END IF„„EX12 = LEFT$(PROMPT, 7)„IF EX12 = "DELETE\" THEN„        DELETEFILE = MID$(PROMPT, 8)„        KILL DELETEFILE               'This block of code„        PRINT ""                      'deletes a file„        GOSUB START„END IF„„EX9 = LEFT$(PROMPT, 6)„IF EX9 = "COLOR\" THEN„        EX10 = MID$(PROMPT, 7, 2)      'changes text color„        IF EX10 = "01" THEN COLOR 1„        IF EX10 = "02" THEN COLOR 2„        IF EX10 = "03" THEN COLOR 3„        IF EX10 = "04" THEN COLOR 4„        IF EX10 = "05" THEN COLOR 5„        IF EX10 = "06" THEN COLOR 6„        IF EX10 = "07" THEN COLOR 7„        IF EX10 = "08" THEN COLOR 8„        IF EX10 = "09" THEN COLOR 9„        IF EX10 = "10" THEN COLOR 10„        IF EX10 = "11" THEN COLOR 11„        IF EX10 = "12" THEN COLOR 12„        IF EX10 = "13" THEN COLOR 13„        IF EX10 = "14" THEN COLOR 14„        IF EX10 = "15" THEN COLOR 15„        IF EX10 = "DF" THEN COLOR 15„        PRINT ""„        GOSUB START„END IF„„SELECT CASE PROMPT„     CASE "DIR"„        FILES MESSAGE             'displays DIR listing for„        PRINT ""                  'the prompt directory„        GOSUB START„     CASE "DATE"„        PRINT DATE$               'displays date„        PRINT ""„        GOSUB START„     CASE "TIME"„        PRINT TIME$               'displays time„        PRINT ""„        GOSUB START„     CASE "DOSSHELL"„        PRINT "Error 002 - DOS cannot be started from the BOS Prompt"„        PRINT ""„        GOSUB START„     CASE "WIN"„        PRINT "Error 003 - Windows cannot be started from the BOS Prompt"„        PRINT ""„        GOSUB START„     CASE "ABOUT"„        PRINT "            BOS"„        PRINT "        Version 1.1"„        PRINT " Written by Darryl Schneider"„        PRINT ""„        GOSUB START„     CASE "Q"„        GOSUB QUIT                'quits„     CASE "QUIT"„        GOSUB QUIT                'quits„     CASE "MOUSE"„        PRINT "Error 004 - BOS does not support the mouse"„        PRINT ""„        GOSUB START„     CASE "CLS"„        GOSUB CLEARSCREEN              'clears the screen„     CASE "HELP"„        GOSUB Help                     'goes to help„     CASE ELSE„        GOSUB START                    'back to start„„END SELECT„„QUIT:„END                'ends program„„Help:„CLS„PRINT ""„PRINT "         BOS (Basic Operating System) Prompt Help"„PRINT ""„FOR NUM = 1 TO 58„        PRINT CHR$(196);„NEXT NUM„PRINT ""„PRINT "         1. Keyboard Commands at the BOS Prompt"„PRINT "         2. Text Color Code Chart"„PRINT "         3. Exit BOS Prompt Help"„PRINT ""„INPUT "         Which option would you like(1-3)"; OP„SELECT CASE OP„        CASE 1„           GOSUB KCBP„        CASE 2„           GOSUB TCCC„        CASE 3„           GOSUB START„        CASE ELSE„           GOSUB Help„END SELECT„„KCBP:„CLS„PRINT ""„PRINT "     BOS - Keyboard Commands at the BOS Prompt"„PRINT ""„FOR NUM = 1 TO 58„        PRINT CHR$(196);„NEXT NUM„PRINT ""„PRINT "CLS                  - clears the screen"„PRINT "DIR                  - shows directory listing for BOS Prompt"„PRINT "DIR\directory        - allows you to view a directory listing"„PRINT "MKDIR\directory      - allows you to make a new directory"„PRINT "RMDIR\directory      - allows you to remove a directory"„PRINT "COLOR\##             - allows you to change text color"„PRINT "RENAME\filename      - allows you to rename a file"„PRINT "DELETE\filename      - allows you to delete a file"„PRINT "PROMPT_message       - allows you to enter a new prompt"„PRINT "TIME                 - displays the current time"„PRINT "DATE                 - displays the current date"„PRINT "Q or QUIT            - exits BOS Prompt"„PRINT "HELP                 - goes to BOS Prompt Help"„PRINT "ABOUT                - shows version of BOS and author's name"„PRINT ""„PRINT "*** When you are typing a file name or directory, type the"„PRINT "WHOLE name or directory. (e.g. C:\BOS\BOS11.EXE)"„PRINT ""„PRINT "Press any key to return to BOS Prompt Help..."„DO„R = UCASE$(INKEY$)„IF R = "Q" THEN GOSUB QUIT„LOOP WHILE INKEY$ = ""„GOSUB Help„„TCCC:„CLS„PRINT ""„PRINT "     BOS - Text Color Code Chart"„PRINT ""„FOR NUM = 1 TO 58„        PRINT CHR$(196);„NEXT NUM„PRINT ""„PRINT " Blue   -  01       Bright Blue     -  09"„PRINT " Green  -  02       Bright Green    -  10"„PRINT " Cyan   -  03       Bright Cyan     -  11"„PRINT " Red    -  04       Peach           -  12"„PRINT " Purple -  05       Bright Purple   -  13"„PRINT " Orange -  06       Bright Yellow   -  14"„PRINT " White  -  07       Bright White    -  15"„PRINT " Gray   -  08"„PRINT ""„PRINT "Bright White (15) is the default text color and"„PRINT "can be implemented by typing COLOR\DF at the BOS"„PRINT "Prompt"„PRINT ""„PRINT "Press any key to return to BOS Prompt Help..."„DO„R = UCASE$(INKEY$)„IF R = "Q" THEN GOSUB QUIT„LOOP WHILE R = ""„GOSUB Help„'„'end of program„„„„„„Jason Laviska                  COLOURFUL PERCENTAGE BAR DEMO  jason.laviska@outdoor.com      06-16-96 (16:34)       QB, QBasic, PDS        150  4708     PERCENT.BAS 'Percentage Bar by Jason Laviska.„'LaserArts' Library Function P-02-F„'--- Public Domain --- Use at your own risk ---„„'    This is the percentage bar indicator as found in all the„'LaserCompare programs.  I had a few requests by internet email asking„'for this little code, however, I simply responded with "It's quite easy,„'just think about it."  Well, for those who never bothered, here it is.„'Its a simple subprogram that displays the percentage bar starting where„'your cursor is located.  You may have to modify it if you will be„'transmitting integers for the Current! or Total! parameters.„„Delay& = 15000    ' <<<  Change delay, if needed (from 0 to 2147483647).„„CLS„ScrnMsg 1, 1, 15, "LaserArts Percentage Bar Demo"„ScrnMsg 2, 1, 11, "  Programmer: Jason Laviska"„ScrnMsg 3, 1, 8, "------------------------------"„ScrnMsg 12, 1, 7, "Press any key for next demo."„VIEW PRINT 5 TO 11   'To prevent above lines from clearing on CLS„„CLS„ScrnMsg 5, 1, 11, "The percentage bar can do both + and - numbers."„Temp% = 100„DO„  FOR Temp = 100 TO -100 STEP -1„    LOCATE 7, 1„    GOSUB Delays„    Percent Temp, 100, 50, 15, 7, 8„    IF Temp$ <> "" THEN EXIT DO„  NEXT Temp„  FOR Temp = -100 TO 100„    LOCATE 7, 1„    GOSUB Delays„    Percent Temp, 100, 50, 15, 7, 8„    IF Temp$ <> "" THEN EXIT DO„  NEXT Temp„LOOP„„CLS„ScrnMsg 5, 1, 11, "You can use a different maximum values."„Delay& = INT(Delay& / 2)„DO„  FOR Temp = 0 TO 100„    FOR Temp2 = 7 TO 10„      LOCATE Temp2, 1„      Temp% = (Temp2 - 6) * 25„      GOSUB Delays„      Percent Temp, INT(Temp%), 50, 15, 7, 8„      IF Temp$ <> "" THEN EXIT DO„    NEXT Temp2„  NEXT Temp„LOOP„„CLS„ScrnMsg 5, 1, 11, "You can have different lengths."„Temp% = 100„DO„  FOR Temp = 0 TO 100„    FOR Temp2 = 7 TO 10„      LOCATE Temp2, 1„      GOSUB Delays„      Percent Temp, 100, (Temp2 - 6) * 10, 15, 7, 8„      IF Temp$ <> "" THEN EXIT DO„    NEXT Temp2„  NEXT Temp„LOOP„„CLS„ScrnMsg 5, 1, 11, "You can use different colors."„Delay& = Delay& * 2„DO„  FOR Temp = 1 TO 100„    LOCATE 7, 1„    GOSUB Delays„    IF Temp / 20 = Temp \ 20 OR Temp = 1 THEN„      FOR K% = 1 TO 3: Kr%(K%) = INT(RND * 14 + 1): NEXT K%„    END IF„    Percent Temp, 100, 50, Kr%(1), Kr%(2), Kr%(3)„    IF Temp$ <> "" THEN EXIT DO„  NEXT Temp„LOOP„„VIEW PRINT„CLS„COLOR 7, 0„END„„Delays:„COLOR 10„PRINT USING "#### of"; Temp;„PRINT Temp%,„'PRINT USING "####% "; Temp / Temp% * 100;  'UnRem this line to show %„FOR Paws& = 1 TO Delay&: NEXT Paws&„Temp$ = INKEY$„RETURN„„SUB Percent (Current, Total, NumBlocks%, Kolor1%, Kolor2%, Kolor3%)„„'Current ...... Number of X that are completed.„'Total ........ Maximum number of X that can be accomplished.„'NumBlocks% ... Length of the percentage bar.„'Kolor1% ...... Color of the blocks filled.„'Kolor2% ...... Color of the half block.„'Kolor3% ...... Color of the remaining/unused blocks.„„Temp = ABS(Current) / Total            'Simply solve for percentage.„Temp% = Kolor1%                        'To make sure they are swapped„                                       'back, incase used later on as„                                       'variables.„IF Temp > 1 THEN„  Temp = 1                             'If > 100% then make it 100%„ELSE„  IF Current < 0 THEN„    SWAP Kolor1%, Kolor3%              'Swap colors if negative.„    Temp = ABS(1 - Temp)„  END IF„END IF„NumBlocks% = ABS(NumBlocks%)„Primary% = INT(Temp * NumBlocks%)         'Determine # of filled blocks„Secondary = Temp * NumBlocks% - Primary%  'Determine if 1/2 block needed„IF Primary% > 0 THEN                      'Display % of filled blocks„  COLOR Kolor1%„  PRINT STRING$(Primary%, "*");„' FOR X% = 1 TO Primary%               'UnRemark lines if percentage„'   PRINT "*";                         'bar will be crossing over to„' NEXT X%                              'the next line.  Rem line before„END IF                                 'this for-next loop.„IF Secondary >= .5 THEN                'Display half block, if needed.„  COLOR Kolor2%„  PRINT "*";„  Primary% = Primary% + 1„END IF„COLOR Kolor3%„IF Temp% <> Kolor1% THEN SWAP Kolor1%, Kolor3%   'Swap back if needed.„PRINT STRING$(NumBlocks% - Primary%, "*");       'Display remaining.„'FOR X% = 1 TO NumBlocks% - Primary%   'UnRemark lines if percentage„'  PRINT "*";                          'bar will be crossing over to„'NEXT X%                               'the next line.  Rem line before„                                       'this for-next loop.„„END SUB„„SUB ScrnMsg (X%, Y%, Kolor%, Message$)„„LOCATE X%, Y%, 0„COLOR Kolor%, 0„PRINT Message$;„„END SUB„Darryl Schneider               INTERNET SEARCH UTILITY        fish2@datanet.ab.ca            07-15-96 (22:07)       QB, QBasic, PDS        456  15236    QSEARCH.BAS 'This is a little internet search utility that„'searches all of the web sites or newsgroups in„'its database, depending on the keyword you type„'in. Modify it by adding your own sites to the„'database. It might be kind of hard to read,„'despite the fact I added in a few comments.„'Oh well, as long as it works! Enjoy :)„'„'Written by Darryl Schneider„'E-mail: fish2@datanet.ab.ca„'The QBasic Zone„'http://www.geocities.com/SiliconValley/8191/„'„SCREEN 12„„DIM BCURSOR(1 TO 500)              'draw the little arrow cursor„LINE (50, 50)-(50, 60), 1          'Throughout the program I do„LINE (50, 50)-(70, 55), 1          'not use PSET to move the cursor.„LINE (50, 60)-(70, 55), 1          'Instead I just cover up my tracks„PAINT (55, 55), 3, 1               'with LINE (), , B and move ahead!„GET (50, 50)-(70, 60), BCURSOR     'Save the cursor„„DEFSTR A, C-W                      'define some variables„DEFINT X-Y„DEFLNG Z„CASES = "N"                        'right now it is not case-sensitive„SEARCHLIMITS = "NONE"              'there are no search limits set„„MAINMENU:                          'start of the main menu„CLS„ZTOTAL1 = 0                        'resets some variables to zero„ZTOTAL2 = 0„ZTOTAL3 = 0„ZHTML = 0„ZFTP = 0„ZNEW = 0„ZHTMLT = 2                         'these next three are the number„ZFTPT = 2                          'of sites in each database. When„ZNEWT = 2                          'you add a new site, make sure you„                                   'increase the number corresponding„                                   'to the database or else it won't„                                   'work properly!„ENTER = CHR$(13)„UP = CHR$(0) + CHR$(72)„DOWN = CHR$(0) + CHR$(80)„„LINE (140, 46)-(500, 360), 9, BF        'draw the main menu screen„LINE (140, 46)-(500, 65), 11, BF„COLOR 10: LOCATE 4, 35: PRINT "QuickSearch"„COLOR 15: LOCATE 7, 25: PRINT "Enter keyword: "„COLOR 12: LOCATE 10, 34: PRINT "Search Options"„COLOR 15: LOCATE 13, 25: PRINT "Case-Sensitive: "; : COLOR 14: PRINT CASES„COLOR 15: LOCATE 15, 25: PRINT "Search Limits: "; : COLOR 14: PRINT SEARCHLIMITS; " "„COLOR 10: LOCATE 17, 25: PRINT "Search"„COLOR 15: LOCATE 20, 25: PRINT "About QuickSearch"„COLOR 15: LOCATE 22, 25: PRINT "End Search"„„MM1:                                        'all of the MM labels are„C1 = ""                                     'the different cursor locations„PUT (168, 96), BCURSOR„DO„C1 = INKEY$„IF C1 = ENTER THEN„         LOCATE 7, 40: INPUT "", KEYWORD        'input the keyword„         GOSUB MM1                              'If you type "basic"„END IF                                          'you get 5 of the 6„IF C1 = UP THEN                                 'sites displayed„         LINE (168, 96)-(188, 106), 9, BF„         GOSUB MM6„END IF„IF C1 = DOWN THEN„         LINE (168, 96)-(188, 106), 9, BF„         GOSUB MM2„END IF„LOOP„„MM2:„C2 = ""„PUT (168, 192), BCURSOR„DO„C2 = INKEY$„IF C2 = ENTER THEN„         SELECT CASE CASES„               CASE "N"                  'change to case-sensitive„                   CASES = "Y"„                   LOCATE 13, 41: COLOR 14: PRINT CASES„                   COLOR 15„                   GOSUB MM2„               CASE "Y"                   'change to case-insensitive„                   CASES = "N"„                   LOCATE 13, 41: COLOR 14: PRINT CASES„                   COLOR 15„                   GOSUB MM2„         END SELECT„END IF„IF C2 = UP THEN„         LINE (168, 192)-(188, 202), 9, BF„         GOSUB MM1„END IF„IF C2 = DOWN THEN„         LINE (168, 192)-(188, 202), 9, BF„         GOSUB MM3„END IF„LOOP„„MM3:                              'this label grouping changes the„C3 = ""                           'search limits„PUT (168, 226), BCURSOR„DO„C3 = INKEY$„IF C3 = ENTER THEN„         IF SEARCHLIMITS = "NONE" THEN„                SEARCHLIMITS = "HTML"„                LOCATE 15, 40: COLOR 14: PRINT SEARCHLIMITS„                COLOR 15„                GOSUB MM3„         END IF„         IF SEARCHLIMITS = "HTML" THEN„                SEARCHLIMITS = "FTP"„                LOCATE 15, 40: COLOR 14: PRINT SEARCHLIMITS; " "„                COLOR 15„                GOSUB MM3„         END IF„         IF SEARCHLIMITS = "FTP" THEN„                SEARCHLIMITS = "NEWS"„                LOCATE 15, 40: COLOR 14: PRINT SEARCHLIMITS„                COLOR 15„                GOSUB MM3„         END IF„         IF SEARCHLIMITS = "NEWS" THEN„                SEARCHLIMITS = "NONE"„                LOCATE 15, 40: COLOR 14: PRINT SEARCHLIMITS„                COLOR 15„                GOSUB MM3„         END IF„END IF„IF C3 = UP THEN„         LINE (168, 226)-(188, 236), 9, BF„         GOSUB MM2„END IF„IF C3 = DOWN THEN„         LINE (168, 226)-(188, 236), 9, BF„         GOSUB MM4„END IF„LOOP„„MM4:„C4 = ""„PUT (168, 258), BCURSOR„DO„C4 = INKEY$„IF C4 = ENTER THEN„         GOSUB STARTSEARCH           'begin the search!„END IF„IF C4 = UP THEN„         LINE (168, 258)-(188, 268), 9, BF„         GOSUB MM3„END IF„IF C4 = DOWN THEN„         LINE (168, 258)-(188, 268), 9, BF„         GOSUB MM5„END IF„LOOP„„MM5:„C5 = ""„PUT (168, 306), BCURSOR„DO„C5 = INKEY$„IF C5 = ENTER THEN„         GOSUB ABOUT             'go to the about screen„END IF„IF C5 = UP THEN„         LINE (168, 306)-(188, 316), 9, BF„         GOSUB MM4„END IF„IF C5 = DOWN THEN„         LINE (168, 306)-(188, 316), 9, BF„         GOSUB MM6„END IF„LOOP„MM6:„C6 = ""„PUT (168, 338), BCURSOR„DO„C6 = INKEY$„IF C6 = ENTER THEN„         GOSUB QUIT                             'quit„END IF„IF C6 = UP THEN„         LINE (168, 338)-(188, 348), 9, BF„         GOSUB MM5„END IF„IF C6 = DOWN THEN„         LINE (168, 338)-(188, 348), 9, BF„         GOSUB MM1„END IF„LOOP„„STARTSEARCH:„CLS„IF KEYWORD = "" THEN GOSUB MAINMENU„IF CASES = "N" THEN KEYWORD = UCASE$(KEYWORD)„PRINT "               QuickSearch Results for query: "; : COLOR 14: PRINT KEYWORD„COLOR 15„PRINT ""„IF SEARCHLIMITS = "NONE" THEN GOSUB SEARCH1     'a little filter depending„IF SEARCHLIMITS = "HTML" THEN GOSUB SEARCH1     'on the search limits„IF SEARCHLIMITS = "FTP" THEN GOSUB SEARCH2„IF SEARCHLIMITS = "NEWS" THEN GOSUB SEARCH3„„SEARCH1:„RESTORE HTMLSITES                  'finds all the HTML sites„NEXTHTML:„IF ZHTML = ZHTMLT THEN„        Y1 = 1„        IF SEARCHLIMITS = "NONE" THEN„                IF ZTOTAL1 = 1 THEN ZTOTAL2 = 1„                IF ZTOTAL1 = 2 THEN ZTOTAL2 = 2„                IF ZTOTAL1 = 3 THEN ZTOTAL2 = 3„                IF ZTOTAL1 = 4 THEN ZTOTAL2 = 4„                GOSUB SEARCH2„        END IF„        IF SEARCHLIMITS = "HTML" THEN GOSUB NOMORE„END IF„PREV1:„READ HTMLSITE, HTMLADDRESS, HTMLDESCRIPTION, HTMLDESCRIPTION2„IF CASES = "N" THEN GOSUB HTMLUP„IF CASES = "Y" THEN GOSUB HTMLLOW„HTMLUP:„                IF INSTR(UCASE$(HTMLSITE), UCASE$(KEYWORD)) > 0 THEN„                COLOR 13: PRINT HTMLSITE„                COLOR 11: PRINT "       "; HTMLDESCRIPTION„                PRINT "         "; HTMLDESCRIPTION2„                COLOR 12: PRINT "       http://"; HTMLADDRESS„                COLOR 15:„                PRINT ""„                ZTOTAL1 = ZTOTAL1 + 1„                ZHTML = ZHTML + 1„                IF ZHTML = ZHTMLT THEN GOSUB NEXTHTML„                IF ZTOTAL1 = 4 THEN GOSUB NEXTPAGE„                GOSUB NEXTHTML„        ELSE„                ZHTML = ZHTML + 1„                GOSUB NEXTHTML„        END IF„HTMLLOW:       „         IF INSTR(HTMLSITE, KEYWORD) > 0 THEN„                COLOR 13: PRINT HTMLSITE„                COLOR 11: PRINT "       "; HTMLDESCRIPTION„                PRINT "         "; HTMLDESCRIPTION2„                COLOR 12: PRINT "       http://"; HTMLADDRESS„                COLOR 15:„                PRINT ""„                ZTOTAL1 = ZTOTAL1 + 1„                ZHTML = ZHTML + 1„                IF ZHTML = ZHTMLT THEN GOSUB NEXTHTML„                IF ZTOTAL1 = 4 THEN GOSUB NEXTPAGE„                GOSUB NEXTHTML„        ELSE„                ZHTML = ZHTML + 1„                GOSUB NEXTHTML„        END IF„„SEARCH2:„RESTORE FTPSITES                     'finds the FTP sites„NEXTFTP:„IF ZFTP = ZFTPT THEN„        Y2 = 1„        IF SEARCHLIMITS = "NONE" THEN„                IF ZTOTAL2 = 1 THEN ZTOTAL3 = 1„                IF ZTOTAL2 = 2 THEN ZTOTAL3 = 2„                IF ZTOTAL2 = 3 THEN ZTOTAL3 = 3„                IF ZTOTAL2 = 4 THEN ZTOTAL3 = 4„                GOSUB SEARCH3„        END IF„        IF SEARCHLIMITS = "FTP" THEN GOSUB NOMORE„END IF„IF ZTOTAL2 = 4 THEN GOSUB NEXTPAGE„PREV2:„READ FTPSITE, FTPADDRESS, FTPDESCRIPTION, FTPDESCRIPTION2„IF CASES = "N" THEN GOSUB FTPUP„IF CASES = "Y" THEN GOSUB FTPLOW„FTPUP:„                IF INSTR(UCASE$(FTPSITE), UCASE$(KEYWORD)) > 0 THEN„                COLOR 13: PRINT FTPSITE„                COLOR 11: PRINT "       "; FTPDESCRIPTION„                PRINT "         "; FTPDESCRIPTION2„                COLOR 12: PRINT "       ftp://"; FTPADDRESS„                COLOR 15:„                PRINT ""„                ZTOTAL2 = ZTOTAL2 + 1„                ZFTP = ZFTP + 1„                IF ZFTP = ZFTPT THEN GOSUB NEXTFTP„                IF ZTOTAL2 = 4 THEN GOSUB NEXTPAGE„                GOSUB NEXTFTP„        ELSE„                ZFTP = ZFTP + 1„                GOSUB NEXTFTP„        END IF„FTPLOW:„                IF INSTR(FTPSITE, KEYWORD) > 0 THEN„                COLOR 13: PRINT FTPSITE„                COLOR 11: PRINT "       "; FTPDESCRIPTION„                PRINT "         "; FTPDESCRIPTION2„                COLOR 12: PRINT "       ftp://"; FTPADDRESS„                COLOR 15:„                PRINT ""„                ZTOTAL2 = ZTOTAL2 + 1„                ZFTP = ZFTP + 1„                IF ZFTP = ZFTPT THEN GOSUB NEXTFTP„                IF ZTOTAL2 = 4 THEN GOSUB NEXTPAGE„                GOSUB NEXTFTP„        ELSE„                ZFTP = ZFTP + 1„                GOSUB NEXTFTP„        END IF„„SEARCH3:„RESTORE NEWSITES                       'finds some newsgroups„NEXTNEW:„IF ZNEW = ZNEWT THEN„        IF SEARCHLIMITS = "NONE" THEN GOSUB NOMORE„        IF SEARCHLIMITS = "NEWS" THEN GOSUB NOMORE„END IF„IF ZTOTAL3 = 4 THEN GOSUB NEXTPAGE„PREV3:„READ NEWSITE, NEWDESCRIPTION, NEWDESCRIPTION2„IF CASES = "N" THEN GOSUB NEWUP„IF CASES = "Y" THEN GOSUB NEWLOW„NEWUP:„                IF INSTR(UCASE$(NEWSITE), UCASE$(KEYWORD)) > 0 THEN„                COLOR 13: PRINT NEWSITE„                COLOR 11: PRINT "       "; NEWDESCRIPTION„                PRINT "         "; NEWDESCRIPTION2„                COLOR 15:„                PRINT ""„                ZTOTAL3 = ZTOTAL3 + 1„                ZNEW = ZNEW + 1„                IF ZNEW = ZNEWT THEN GOSUB NEXTNEW„                IF ZTOTAL3 = 4 THEN GOSUB NEXTPAGE„                GOSUB NEXTNEW„        ELSE„                ZNEW = ZNEW + 1„                GOSUB NEXTNEW„        END IF„NEWLOW:„                IF INSTR(NEWSITE, KEYWORD) > 0 THEN„                COLOR 13: PRINT NEWSITE„                COLOR 11: PRINT "       "; NEWDESCRIPTION„                PRINT "         "; NEWDESCRIPTION2„                COLOR 15:„                PRINT ""„                ZTOTAL3 = ZTOTAL3 + 1„                ZNEW = ZNEW + 1„                IF ZNEW = ZNEWT THEN GOSUB NEXTNEW„                IF ZTOTAL3 = 4 THEN GOSUB NEXTPAGE„                GOSUB NEXTNEW„        ELSE„                ZNEW = ZNEW + 1„                GOSUB NEXTNEW„        END IF„„NOMORE:                             'no more matches to the keyword„LOCATE 25, 5: PRINT "No more matches...press enter to return to the main menu..."„DO„D2 = UCASE$(INKEY$)„IF D2 = ENTER THEN GOSUB MAINMENU„LOOP„„'databases„„HTMLSITES:„DATA The QBasic Zone, www.geocities.com/SiliconValley/8191/, - Includes programs; tutorials; compilers; a huge, list of links and much more!„DATA The All Basic Code Home Page, charlie.simplenet.com/abc/abchome.html, - Has ABC packets filled with tons of, source code for you to use.„„FTPSITES:„DATA M / K Productions, members.aol.com/blood225/, - Lots of files to download,„DATA SimTel MSDOS Basic, oak.oakland.edu/SimTel/msdos/basic/, An archive of files to download,„„NEWSITES:„DATA comp.lang.basic.misc, - Discussion of any BASIC programming language,„DATA alt.lang.basic, - Discussion of all the BASIC programming languages,„„'end of databases„„ABOUT:                     'the infamous about screen„CLS„PRINT "                   About QuickSearch"„PRINT ""„PRINT "QuickSearch was written in Microsoft QuickBasic by 14-year old Darryl"„PRINT "Schneider. It is designed to be an off-line search utility so you"„PRINT "do not have to go back and forth while 'web surfing' to search for"„PRINT "the address of a web site. Above this in the source code are the"„PRINT "DATA statements for HTML and FTP sites, as well as Newsgroups. You"„PRINT "may add your own sites to the list, and build up a large database."„PRINT "With the HTML and FTP databases, the first series of words is the title"„PRINT "of the site, the next series is the address, next the first line of the"„PRINT "description, and then the second line of description. It is the same for"„PRINT "newsgroups except there is no address. At the main menu you can have"„PRINT "a case-sensitive or non-sensitive search, and can search with no"„PRINT "limits (None), only in HTMLs (HTML), only in FTPs (FTP), or only in"„PRINT "newsgroups (NEWS), by cycling through pressing enter. I hope that this"„PRINT "application proves useful in some way and helps you with programming"„PRINT "or your web surfing!"„PRINT ""„PRINT "Press enter to return to the main menu..."„DO„D3 = UCASE$(INKEY$)„IF D3 = ENTER THEN GOSUB MAINMENU„LOOP„„QUIT:„END„„NEXTPAGE:„LOCATE 25, 5: PRINT "Press enter for more or 'Q' to quit..."„DO„D1 = UCASE$(INKEY$)               'goes to the next page after 4„IF D1 = ENTER THEN                'sites have been displayed„        IF Y1 = 1 THEN GOSUB NEXT2„        IF ZTOTAL1 = 4 THEN„           IF ZHTML = ZHTMLT THEN GOSUB NEXTHTML„           ZTOTAL1 = 0„           CLS„           PRINT "               QuickSearch Results for query: "; : COLOR 14: PRINT KEYWORD„           PRINT ""„           COLOR 15„           GOSUB PREV1„        END IF„NEXT2:     „        IF Y2 = 1 THEN GOSUB NEXT3„        IF ZTOTAL2 = 4 THEN„           IF ZFTP = ZFTPT THEN GOSUB NEXTFTP„           ZTOTAL2 = 0„           CLS„           PRINT "               QuickSearch Results for query: "; : COLOR 14: PRINT KEYWORD„           PRINT ""„           COLOR 15„           GOSUB PREV2„        END IF„NEXT3:„        IF ZTOTAL3 = 4 THEN„           IF ZNEW = ZNEWT THEN GOSUB NEXTNEW„           ZTOTAL3 = 0„           CLS„           PRINT "               QuickSearch Results for query: "; : COLOR 14: PRINT KEYWORD„           PRINT ""„           COLOR 15„           GOSUB PREV3„        END IF„END IF„IF D1 = "Q" THEN GOSUB MAINMENU„LOOP„„'end of QuickSearch„Christoph Kummetat             PROGRAM THE PARALLEL PORT      FidoNet QUIK_BAS Echo          07-13-96 (13:44)       QB, QBasic, PDS        125  5033     PARALLEL.BAS'> With 8 data lines I have many options and combinations thereof. I am„'> not familair with the bit structure of characters. Any clue as to how„'> to go about deciding the characters to use that would activate line„'> "1" only while leaving the others alone?„„'here's some code, which might help you to program the parallel port. „'Originally it is a programm to set 8 relais via LPT. I shortened it to the „'important things. If you have more questions about, feel free to ask me...„„InitVar:„   DEFINT A-Z„   DIM SHARED Bit(8), BitStatus, Port, RelNr„   DIM SHARED Anzahl(8)„„   CONST Blk = 0, Blu = 1, Grn = 2, Zyn = 3, Red = 4  'set colors„   CONST Gry = 7, Yel = 14, Wht = 15, Blink = 16„   CONST TRUE = 1, FALSE = NOT TRUE                   'set boolean„„   CLS : Count = 1„   FOR i = 1 TO 8„      Bit(i) = Count                                  'set bits with bit-values„      Count = Count + Count                           'increase values (0,1,2,4,8,16,32,64,128)„   NEXT i„„   CALL DATEN.Find.LPT                                'search for LPTs„„   BitStatus = 0                                      'switch all lines OFF„   OUT Port, BitStatus                                'send to LPT„   CALL DATEN.Get.Status                              'read LPT„„„WHILE INKEY$ <> "q"„   CALL DATEN.Set.Status„   FOR i = 1 TO 8„      CALL DATEN.Get.Status„   NEXT i„WEND„„      OUT Port, LEDStatus                                      'an par. SN senden„„SUB DATEN.Find.LPT„   DEF SEG = 0: DIM Port(4)„   Count = 0: COLOR Wht, Blu„   FOR i = 1032 TO 1036 STEP 2„      IF PEEK(i) + 256 * PEEK(i + 1) > 0 THEN„         Count = Count + 1„         Port(Count) = VAL("&H" + HEX$(PEEK(i) + 256 * PEEK(i + 1)))„         LOCATE 4 + Count, 6„         PRINT "Printerport"; STR$(Count); " : ";„         PRINT "&H" + HEX$(PEEK(i) + 256 * PEEK(i + 1))„      END IF„   NEXT i„   IF Count = 0 THEN                                          'no port found„      PRINT "No parallel port found on your PC !";„      ch$ = INPUT$(1)„      CLOSE : COLOR Wht, Blk: CLS : END„   END IF„„GetPrt:                                                        'choose LPT„   LOCATE , 6: PRINT "Which parallel port do you want to use : ";„   v$ = INPUT$(1)                                              'ask for LPT„   IF VAL(v$) < 1 OR VAL(v$) > Count THEN„      SOUND 3200, .3: GOTO GetPrt                              'invalid value„   END IF„   Port = Port(VAL(v$))                                        'define port„END SUB„„SUB DATEN.Get.Status„     BitStatus = INP(Port)                                     'read LPT„     FOR i = 1 TO 8„         IF BitStatus AND Bit(i) THEN„            Status = 1„         ELSE„            Status = 0„         END IF„     CALL DISPLAY.Status(i, Status)„     NEXT i„END SUB„„SUB DATEN.Relais.Reset„     BitStatus = 0: OUT Port, BitStatus                        'reset all registers at LPT„END SUB„„SUB DATEN.Set.Status                                           'send value to LPT„   COLOR Blk, Gry:„   LOCATE 12, 6: PRINT "which line to set ? : "„   LOCATE 13, 6: PRINT "(number 1 - 8 or 0 for all OUT)  "„„GetBit:„   v$ = INPUT$(1)                                              'number of LPT„   BitNr = VAL(v$)„   IF ASC(v$) = 27 THEN COLOR Wht, Blk: CLS : END              'Escape, end program„   IF BitNr > 8 THEN SOUND 3200, .3: GOTO GetBit               'hey, you can only choose between 1 and 8„GetSts:„   IF BitNr = 0 THEN„      BitStatus = 0                                            'switch all lines OFF„      OUT Port, BitStatus                                      'send to LPT„      CALL DISPLAY.Status(BitNr, BitStatus)                    'display status„   ELSEIF BitStatus AND Bit(BitNr) THEN                        'is line ON or OFF ?„      BitStatus = BitStatus XOR Bit(BitNr)                     'swith bit/line to OFF„      OUT Port, BitStatus                                      'send to LPT„      CALL DISPLAY.Status(BitNr, BitStatus)                    'display status„   ELSE„      BitStatus = BitStatus + Bit(BitNr)                       'add bit/line„      OUT Port, BitStatus                                      'send to LPT„      CALL DISPLAY.Status(BitNr, BitStatus)                    'display status„   END IF„END SUB„„SUB DISPLAY.Status (BitNr, Status)                             'show status of bits/lines„   IF BitNr >= 1 THEN„      IF Status >= 1 THEN„         COLOR Wht, Red                                        'bit/line active„         LOCATE 8, ((BitNr * 8) + BitNr) - 3: PRINT "  ON  "„       ELSE„         COLOR Wht, Grn                                        'bit/line inactive„          LOCATE 8, ((BitNr * 8) + BitNr) - 3: PRINT " OFF  "„      END IF„   ELSE„      COLOR Wht, Grn                                           'all bits/lines OFF„         FOR i = 1 TO 8„         LOCATE 8, ((i * 8) + i) - 3: PRINT " OFF  "„      NEXT i„   END IF„END SUB„Robert Fortune                 BBS GAME PROGRAMMING           FidoNet QUIK_BAS Echo          04-14-96 (00:00)       QB, QBasic, PDS        245  8996     GAMESHEL.BAS'>statements, but the Real problem is, what if a new user„'>wants to use the game? Can someone help... I need it to„'>open the player.dat file, search for the Real Name, Load„'>The Data, And Save The Data in the right spot.... Can„'>Someone Help Me?„„'   I can try. The following code uses a random access file to keep„'   scores for a BBS game. The PlayerName field is the key field„'   that the code uses to keep track of the players and their scores,„'   etc... The code also creates an SCORES.ANS file which is just an ANSI„'   high scores file that a SysOp can use on his BBS bulletin(s) menu. You„'   can modify as needed or use as a rough guide. It will reach you in„'   2 messages as it's kind of long so you will need to edit it back into„'   a single file before running it. Hope it helps. Good luck!„„' ----------------------- CUT HERE -------------CUT HERE ----------------„REM GAMESHEL.BAS  04/14/96„REM QB/QBX Demo game shell using a Random Access data file to store,„REM sort and display players names and scores. Also creates an ANSI„REM color high scores bulletin file (SCORES.ANS)„„DEFINT A-Z  ' all untyped variables default to type integer„DECLARE SUB MoveCursor (X%, Y%)           ' position cursor on screen„DECLARE SUB SetColors (FG%, BG%, Attrib%) ' set ANSI colors to use„„REM Define our random access file structure„TYPE GameRecord„     RecordNumber AS INTEGER„     PlayerAlias AS STRING * 25„     PlayerName AS STRING * 25„     ExperPoints AS LONG„     GoldOnHand AS LONG„     GoldInBank AS LONG„     Beauty AS LONG„     GEMS AS LONG„     PlayerScore AS LONG„     PlayerDay AS STRING * 11„END TYPE„DIM PlayerRecord AS GameRecord   ' reserve some memory„DIM TempRecord AS GameRecord„„CONST True = -1, False = NOT True„ClrScrn$ = CHR$(27) + "[2J"      ' clear ANSI screen„„OPEN "CONS:" FOR OUTPUT AS #1    ' local output via CONSole device„„REM Open the random access players file„OPEN "GAMEFILE.DAT" FOR RANDOM AS #2 LEN = LEN(PlayerRecord)„„REM Here is where you would normally get the player's name from the BBS drop„REM file (DOOR.SYS, PCBOARD.SYS, etc...). As an example we get the player's„REM name manually. In a BBS game door you should get the info from the BBS„REM drop file.„„DO„  CLS„  LINE INPUT "Please enter your FULL Name: "; FullName$„  FullName$ = UCASE$(FullName$)„LOOP WHILE FullName$ = ""„„REM Search existing records for a match on player's full name.„REM We're using record number 1 for the All-Time-Winner record„REM to keep all the player data in the same file.„„RecordNumber% = 1   ' this record is reserved for All-Time-Winner„IF LOF(2) > 0 THEN  ' Any records in the file yet?„   DO„      RecordNumber% = RecordNumber% + 1„      GET #2, RecordNumber%, PlayerRecord„   LOOP UNTIL (RTRIM$(PlayerRecord.PlayerName) = FullName$) OR (EOF(2))„ELSE„   RecordNumber% = RecordNumber% + 1„   PlayerRecord.PlayerName = FullName$„   PlayerRecord.PlayerScore = 500  ' start each player with 500 points„   PlayerRecord.PlayerDay = DATE$„   PUT #2, 1, PlayerRecord„   PUT #2, 2, PlayerRecord„END IF„„REM Did we find a match?„„IF RTRIM$(PlayerRecord.PlayerName) <> FullName$ THEN ' No match, new player„   RecordNumber% = LOF(2) \ LEN(PlayerRecord) + 1„   PlayerRecord.PlayerName = FullName$„   PlayerRecord.PlayerScore = 500  ' start each player with 500 points„   PlayerRecord.PlayerDay = DATE$„   PUT #2, RecordNumber%, PlayerRecord„END IF„CLOSE #2„„Score# = PlayerRecord.PlayerScore„„Start:„„' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„' YOUR PROGRAM STARTS HERE„' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„„' Somewhere in your game player would win/lose points as in„„Score# = Score# + 10   ' demo score keeper for game„„' More of your game program„„' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„' YOUR GAME ENDS HERE. Now we need to update the player's scores.„' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *„„Finish:„„OPEN "GAMEFILE.DAT" FOR RANDOM AS #2 LEN = LEN(PlayerRecord)„OPEN "SCORES.ANS" FOR OUTPUT AS #3  ' open ANSI high scores bulletin file„„RecordNumber% = 2„GET #2, RecordNumber%, PlayerRecord„DO UNTIL RTRIM$(PlayerRecord.PlayerName) = FullName$„   RecordNumber% = RecordNumber% + 1„   GET #2, RecordNumber%, PlayerRecord„LOOP„PlayerRecord.PlayerScore = Score#„PlayerRecord.PlayerDay = DATE$„„REM See if we have a new All-Time-Winner„GET #2, 1, TempRecord„IF PlayerRecord.PlayerScore > TempRecord.PlayerScore THEN„   PUT #2, 1, PlayerRecord    ' write a new all-time winner record„END IF„„REM Write the updated player's record to random access highscores file„PUT #2, RecordNumber%, PlayerRecord„' (Disk) Sort players scores using basic bubblesort from MS QB Bible book„DO„   Switch = False„   FOR I% = 2 TO (LOF(2) \ LEN(PlayerRecrd)) - 1„       GET #2, I%, PlayerRecord„       GET #2, I% + 1, TempRecord„       IF PlayerRecord.PlayerScore < TempRecord.PlayerScore THEN„          SWAP PlayerRecord, TempRecord„          PUT #2, I%, PlayerRecord„          PUT #2, I% + 1, TempRecord„          Switch = True„       END IF„   NEXT I„LOOP WHILE Switch„' Now print the players names and scores which are in sorted order„' in the GAMEFILE.DAT file (sorted on players' scores).„„PRINT #1, ClrScrn$        ' clear the screen„PRINT #3, ClrScrn$„„REM this is where the final score board starts .„GET #2, 1, PlayerRecord„CALL SetColors(33, 40, 1)  ' make screen colors bright yellow on black„„REM (Long line split to fit email line length)„Text$ = "< < <  " + RTRIM$(PlayerRecord.PlayerName) + " won "„Text$ = Text$ + LTRIM$(STR$(PlayerRecord.PlayerScore)) + " points on "„Text$ = Text$ + PlayerRecord.PlayerDay + "  > > > "„„X% = 2                     ' print on 2nd line of screen„Y% = 40 - LEN(Text$) \ 2   ' center the high scores title„CALL MoveCursor(X%, Y%)    ' position the cursor„PRINT #1, Text$      ' print high scores title to the screen„PRINT #3, Text$      ' print high scores title to the SCORES.ANS file„CALL SetColors(34, 40, 1) ' make screen colors bright blue on black„Text$ = "Last Played     Player                  Score"„X% = 4„Y% = 40 - LEN(Text$) \ 2„CALL MoveCursor(X%, Y%)„PRINT #1, Text$„PRINT #3, Text$„CALL SetColors(31, 40, 1)   ' make screen colors bright red on black„Text$ = "-------------------------------------------------"„X% = X% + 1„Y% = 40 - LEN(Text$) \ 2„CALL MoveCursor(X%, Y%)„PRINT #1, Text$„PRINT #3, Text$„CALL SetColors(32, 40, 1)   ' make screen colors bright green on black„Y% = Y% + 2„REM Print out the first 10 records in our random access file„IF LOF(2) \ LEN(PlayerRecord) < 12 THEN„   Bottom% = LOF(2) \ LEN(PlayerRecord)„ELSE„   Bottom% = 11„END IF„FOR I% = 2 TO Bottom%„    GET #2, I%, PlayerRecord„    Text$ = PlayerRecord.PlayerDay + "      " + PlayerRecord.PlayerName„    Text$ = Text$ + "    " + STR$(PlayerRecord.PlayerScore)„    X% = X% + 1„    CALL MoveCursor(X%, Y%)„    PRINT #1, Text$„    PRINT #3, Text$„NEXT I%„REM Print an underline after top scores are displayed„CALL SetColors(31, 40, 1)   ' make screen colors bright red on black„Text$ = "================================================="„X% = X% + 1„Y% = 40 - LEN(Text$) \ 2„CALL MoveCursor(X%, Y%)„PRINT #1, Text$„PRINT #3, Text$„CALL SetColors(40, 37, 1)  ' set screen colors bright white on black„Text$ = "[PRESS ANY KEY TO CONTINUE]"„X% = X% + 2„Y% = 40 - LEN(Text$) \ 2„CALL MoveCursor(X%, Y%)„PRINT #1, Text$„DO„   AnyKey$ = INKEY$„LOOP UNTIL LEN(AnyKey$)„CALL SetColors(37, 40, 0)  ' reset screen colors to drab white on black„PRINT #1, ClrScrn$         ' clear the screen„CLOSE #1, #2, #3           ' All done. Close up all open files„END                        ' The End„„' Position cursor on ANSI screen where X% = screen row position and„' Y% = screen column position where X% can equal 1 thru 25 and Y%„' can equal 1 thru 80.„SUB MoveCursor (X%, Y%)„Move$ = CHR$(27) + "[" + LTRIM$(STR$(X%)) + ";"„Move$ = Move$ + LTRIM$(STR$(Y%)) + "H"„PRINT #1, Move$;„END SUB„„' Set ANSI screen colors„' FG% = ANSI foreground color, BG% = ANSI background color.„' Valid fore colors (FG%)     Valid back colors (BG%)„' Black   30                        40„' Red     31                        41„' Green   32                        42„' Yellow  33                        43„' Blue    34                        44„' Magenta 35                        45„' Cyan    36                        46„' White   37                        47„' ANSI Attr% = attribute (bright(1), blink(5), reverse(7), reset(0)-„' cancelled(8), underline(4) (mono only else blue)„SUB SetColors (FG%, BG%, Attr%)„    Text$ = CHR$(27) + "[" + LTRIM$(STR$(Attr%)) + ";"„    Text$ = Text$ + LTRIM$(STR$(BG%)) + ";" + LTRIM$(STR$(FG%)) + "m"„    PRINT #1, Text$;„    PRINT #3, Text$;„END SUB„Rick Pedley                    SET NEW PRINTER TIMEOUT VALUE  QBTIPS_R.DOC                   10-09-93 (14:35)       QB, PDS                40   1403     TIMEOUT.BAS 'TIMEOUT.BAS „'Sets printer `timeout retry' value to help prevent `printer busy' „'errors. Most machines copy the value 20 (&h14) from the BIOS into „'three RAM addresses, corresponding to printer ports LPT1, 2, and 3. „'Before DOS gives a printer busy error, it cycles 20 x ~260,000 „'times to see if the error has cleared. On a fast computer, say a „'50 MHz 486, this _may_ not be long enough and even copying a file „'to the printer from DOS may cause a R)etry, A)bort, F)ail to be „'displayed. This utility can be run from the DOS prompt or in your „'AUTOEXEC.BAT. If no parameter is specified, it prints the current „'values for each port and a short message. If you regularly get „'printer busy errors even in DOS, run this utility trying different „'values, starting with something greater than 20, until the errors „'disappear. „' „'R. Pedley, 93-10-09 „ „DEFINT A-Z „DEF SEG = 64        '0040 „IF LEN(COMMAND$) THEN „   T = VAL(COMMAND$) „   IF T > 0 AND T < 256 THEN „      POKE 120, T   '    :0078 „      POKE 121, T   '    :0079 „      POKE 122, T   '    :007A „   ELSE „      BEEP „   END IF „END IF „PRINT „PRINT "Current printer timeout values are:" „PRINT „PRINT "LPT1:"; PEEK(120) „PRINT "LPT2:"; PEEK(121) „PRINT "LPT3:"; PEEK(122) „PRINT „PRINT "To set a new value, use a parameter between 1 and 255," „PRINT "e.g. TIMEOUT 45" „PRINT „DEF SEG „Nicolas Culberson              MOUSE DRIVEN TRIANGLE          exnihilo@rhunebbs.com          10-29-96 (00:06)       QB, PDS                136  5551     TRIMOUS.BAS 'Ok... this program doesn't ACTUALLY do anything.  It's the result of a lack„'of INTERNET connection combined with boredom and visiting relatives you„'don't want to know you are home.„'You need a mouse... a computer... some memory... a little hard-drive...„'patience... boredom... the default library... the real QUICKBASIC.„'Load up QuickBASIC by typing "QB/L" this loads the default library...„'You can use this however you like... I really don't care...„'If you make money off of it... pay me... I'm broke.„'If you at least bother to look at it...„'send me an e-mail...„'exnihilo@rhunebbs.com.„'Send me the latest ABC packet.„'Send me your funky code.„'Send me a life.„'All code by NICOLAS CULBERSON.„'This program intentionally bounces around like that!  Oh yeah, and it was„'created on a 486/33 so if it doesn't work right on your computer don't„'tell me about it.  I don't care.„„DECLARE SUB warp ()         'Declare stuff...„DECLARE SUB right ()        'Declare stuff...„DECLARE SUB down ()         'Declare stuff...„DECLARE SUB up ()           'Declare stuff...„DECLARE SUB left ()         'Declare stuff...„DECLARE SUB shoot ()        'Declare stuff...„REM $INCLUDE: 'QB.BI'       'Include the library thing...„DIM SHARED regx  AS RegTypeX'Dim regx as regtypex and share it between the„			    'subs(see "Declare stuff...")„DIM SHARED a, b             'Do the same thing with the variables a,b„RANDOMIZE TIMER             'This Randomizes the computer timer(duh)„„CLS                         'Clear the screen.  If you don't understand this„			    'statement... don't bother trying to figure the„			    'program out.  You need a manual.„SCREEN 13                   'Put the screen into 320 * 200 graphics mode.„a = regx.cx / 2             'Define the variable regx.cx„			    '(the X AXIS on the mouse) as variable named a.„			    'You must divide by half in screen 13.„b = regx.dx                 'Do the same thing to the variable named b with„			    'the Y AXIS„DO                          'Begin LOOP(see LOOP)„a$ = INKEY$                 'Look for a keypress and place it in STRING A$„IF a$ = CHR$(27) THEN END   'If the key pressed is "esc" then escape.(please„			    '(note:  this is high level programming, do not„			    'attempt to put such wonderful features in your„			    'own programs without adult supervision.)„regx.ax = 2                 'Hide the mouse cursor„CALL INTERRUPTX(&H33, regx, regx) 'Call the mouse interrupt at the address„				  '&H33... this works on most computers...„regx.ax = 3                       'I dunno what this does but it has to be„				  'there last time I checked.„CALL INTERRUPTX(&H33, regx, regx) 'Call it again.„REM IF regx.dx > 139 THEN regx.dx = regx.dx - 1 'This line is remmed...„						'ignore it.„IF a > regx.cx / 2 THEN CALL left  'Call the sub LEFT if the mouse„				   'moves in the left direction.„IF a < regx.cx / 2 THEN CALL right 'Call the sub RIGHT if the mouse„				   'moves in the right direction.„IF b > regx.dx THEN CALL up        'Call the sub UP if the mouse„				   'moves in the UP direction.„IF b < regx.dx THEN CALL down      'Bear with me here... things do change.„IF regx.bx = 1 THEN CALL shoot     'Regx.bx is the mouse button variable.„				   '.bx=1 is button number 1„				   '.bx=2 is button number 2„				   '.bx=3 is button number 1 and 2 at the„				   'same time or button 3 if you have it, I„				   'think.„				   'So, this line checks for button 1...„				   'and if it is pressed, calls the sub„				   'named shoot.„IF regx.bx = 2 THEN CALL warp      'If button 2 is pressed...„				   'call the WARP sub.„LOOP UNTIL bob = 1                 'Loop forever.  Whose BOB?„„„'Hmmm... you're still reading eh?  Your internet connection must be down too.„'How about calling Zeitgeist BBS in Saint John... the phone number is„'(506)832-9012 or something like that.  Experiment... you never know who you„'might get.  When you get there... e-mail Ex Nihilo, or Beanpole, or„'Ebenezer. „„SUB down„PSET (a, b), 0               'Delete the old one„DRAW "e10f10l20"             'by drawing over top of it in black.„b = b + 1                    'Move the picture down 1.„PSET (a, b), 12              'Redraw it.„DRAW "e10f10l20"             '  "    " .„PAINT (a + 3, b - 1), 14, 12 'Paint the yellow inside.„END SUB 'End the Sub(pretty self explanatory)„„SUB left„PSET (a, b), 0   'See SUB DOWN... it's the same thing.„DRAW "e10f10l20"„a = a - 1„PSET (a, b), 12„DRAW "e10f10l20"„PAINT (a + 3, b - 1), 14, 12„END SUB„„SUB right„PSET (a, b), 0   'See SUB DOWN it's the same thing...„DRAW "e10f10l20"„a = a + 1„PSET (a, b), 12„DRAW "e10f10l20"„PAINT (a + 3, b - 1), 14, 12„„END SUB„„SUB shoot„LINE (a + 10, b - 13)-(a + 10, b - 50), 10  'Draw the green shooting line.„FOR cool = 1 TO 100: NEXT cool              'Delay...„LINE (a + 10, b - 13)-(a + 10, b - 50), 0   'Draw over top of the shooting„					    'line in black.„END SUB„„SUB up„PSET (a, b), 0    'See SUB DOWN.  Same dif...„DRAW "e10f10l20"„b = b - 1„PSET (a, b), 12„DRAW "e10f10l20"„PAINT (a + 3, b - 1), 14, 12„END SUB„„SUB warp„PAINT (a + 3, b - 1), 0, 12 'This SUB drops the ship somewhere else.„PSET (a, b), 0              'Figure it out each line by line for yourself...„DRAW "e10f10l20"            'I'm sick of explaining every little thing...„a = INT(RND * 300)„b = INT(RND * 180)„PSET (a, b), 12„DRAW "e10f10l20"„PAINT (a + 3, b - 1), 14, 12„FOR cool = 1 TO 1000: NEXT cool„END SUB„Marek Piotrowski               PARALLEL PORT TEST UTILITY     ao487@freenet.toronto.on.ca    10-29-96 (19:33)       QB, QBasic, PDS        335  11414    PRNPORT.BAS '…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª„'∫                                                                            ∫„'∫                                                                            ∫„'∫ PRNPORT.BAS is a parallel port test utility. It allows single bit toggle   ∫„'∫          and single bit monitoring of a selected parallel port.            ∫„'∫                                                                            ∫„'∫         Author: Marek Piotrowski ao487@toronto.freenet.on.ca               ∫„'∫                                                                            ∫„'∫         Credits: Christoph Kummetat for FindPort subroutine.               ∫„'∫                                                                            ∫„'»ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº„„DIM SHARED Bit(2, 7) AS INTEGER„DIM SHARED OldByte(2) AS INTEGER„DIM SHARED Byte(2) AS INTEGER„DIM SHARED Port(4) AS INTEGER„„DECLARE SUB ToggleBit (PortNum$)„DECLARE SUB DrawBottomBar ()„DECLARE SUB FindPort (PortNum$)„DECLARE SUB DrawScreen ()„DECLARE SUB PrintPortHeaders (PortNum$)„DECLARE SUB ReadPort (PortNum$)„DECLARE SUB BitPinToggle (Q$, BitPinSw%)„DECLARE SUB MoveCursor (Q$)„„„„BitPinSw% = 1                          'Bit or Pin number display switch„                                       '(1 = Bit numer display)„FOR Pt% = 0 TO 2„OldByte(Pt%) = NOT Byte(Pt%)„NEXT Pt%„„„CLS„„DATA " 9"," 8"," 7"," 6"," 5"," 4"," 3"," 2"„DATA "11","10","12","13","15","  ","  ","  "„DATA "  ","  ","  ","  ","17","16","14"," 1"„„FindPort PortNum$             'Find ports available„DrawBottomBar„DrawScreen                    'Draw screen subroutine„BitPinToggle Q$, BitPinSw%    'Bit/Pin number display toggle subroutine„PrintPortHeaders PortNum$     'PrintPortHeaders subroutine„„„„DO„Q$ = INKEY$„„ReadPort PortNum$   'read data from the ports subroutine„„„„„    IF Q$ = CHR$(9) THEN„        BitPinToggle Q$, BitPinSw%   'Bit/Pin number display toggle subroutine„    END IF„„    IF LEN(Q$) > 1 THEN„        MoveCursor Q$                'Cursor movement subroutine„    END IF„„    IF Q$ = CHR$(32) THEN     'Detect space bar to toggle single bit„                              'at cursor position.„ToggleBit PortNum$        'Toggle one bit„„„    END IF„„„LOOP WHILE Q$ <> CHR$(27)„COLOR 7, 0„CLS„„SUB BitPinToggle (Q$, BitPinSw%)„„        OldCurRow% = CSRLIN„        OldCurCol% = POS(0)„„„            IF BitPinSw% > 0 THEN          'Toggle Pin to Bit numbers„            COLOR 7, 0„            FOR Row% = 20 TO 21„                LOCATE Row%, 3: PRINT STRING$(77, 32)„            NEXT Row%„„„            COLOR 12, 1„            LOCATE 9, 4: PRINT "Bit"„                FOR i = 55 TO 48 STEP -1„                LOCATE 11 + (55 - i), 5„                PRINT " "; CHR$(i)„                NEXT i„            LOCATE 9, 29: PRINT "Bit"„                FOR i = 55 TO 48 STEP -1„                LOCATE 11 + (55 - i), 30„                PRINT " "; CHR$(i)„                NEXT i„            LOCATE 9, 53: PRINT "Bit"„                    FOR i = 55 TO 48 STEP -1„                    LOCATE 11 + (55 - i), 54„                    PRINT " "; CHR$(i)„                    NEXT i„            ELSE„„„„            COLOR 10, 1„            LOCATE 9, 4: PRINT "Pin"        'Toggle Bit to Pin numbers„                FOR i = 55 TO 48 STEP -1„                READ A$„                LOCATE 11 + (55 - i), 5„                PRINT A$„                NEXT i„            LOCATE 9, 29: PRINT "Pin"„                FOR i = 55 TO 48 STEP -1„                READ A$„                LOCATE 11 + (55 - i), 30„                PRINT A$„                NEXT i„            LOCATE 9, 53: PRINT "Pin"„                    FOR i = 55 TO 48 STEP -1„                    READ A$„                    LOCATE 11 + (55 - i), 54„                    PRINT A$„                    NEXT i„„            COLOR 7, 0„            LOCATE 20, 3: PRINT "Pin numbers apply to D-type 25 pin connector."„            LOCATE 21, 3: PRINT "Pins 18 through 25 are logic ground."„            RESTORE„            END IF„„    COLOR 7, 0„    LOCATE OldCurRow%, OldCurCol%, 1, 0, 4„„    BitPinSw% = -BitPinSw%„„„END SUB„„SUB DrawBottomBar„„LOCATE 23, 1„COLOR 7, 0: PRINT " ";„COLOR 0, 11: PRINT "       Esc ";„COLOR 15, 11: PRINT "- quit, ";„COLOR 0, 11: PRINT "Tab ";„COLOR 15, 11: PRINT "- Bit/Pin number toggle, ";„COLOR 0, 11: PRINT "Space Bar ";„COLOR 15, 11: PRINT "- toggle a bit      ";„„COLOR 7, 0„„END SUB„„SUB DrawScreen„LOCATE 1, 1„PRINT STRING$(80, 32)„PRINT " "; : COLOR 14, 1: PRINT " …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫          PARALLEL PORT DIAGNOSTIC UTILITY - by Marek Piotrowski          ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫                               PORT ADDRESS                               ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ“ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ“ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫      ..... OUTPUT      ∫      ..... INPUT      ∫      ..... OUTPUT       ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " «ƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥Status≥  Function   ∫   ≥Status≥  Function  ∫   ≥Status≥  Function    ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " «ƒƒƒ≈ƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒ≈ƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒ≈ƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥busy        ∫   ≥ .... ≥reserved      ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥acknowledge ∫   ≥ .... ≥reserved      ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥out of paper∫   ≥ .... ≥reserved      ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥prn.selected∫   ≥ .... ≥enable IRQ    ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥error       ∫   ≥ .... ≥select prn.   ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥IRQ occured ∫   ≥ .... ≥initialize prn∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥reserved    ∫   ≥ .... ≥auto line feed∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " ∫   ≥ .... ≥ data        ∫   ≥ .... ≥reserved    ∫   ≥ .... ≥strobe        ∫ "; : COLOR 7, 0: PRINT " "„PRINT " "; : COLOR 14, 1: PRINT " »ÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕº "; : COLOR 7, 0: PRINT " "„LOCATE 22, 3: PRINT "Output pins 1, 14, 17 and input pin 11 operate in negative logic."„LOCATE 11, 8, 1, 0, 4„„END SUB„„SUB FindPort (PortNum$)„„   DEF SEG = 0„   Count = 0„   FOR i = 1032 TO 1036 STEP 2„      PortAdd% = PEEK(i) + 256 * PEEK(i + 1)„      IF PortAdd% > 0 THEN„         Count = Count + 1„         Port(Count) = VAL("&H" + HEX$(PortAdd%))„         PRINT "Parallel port"; STR$(Count); " at ";„         PRINT "&H" + HEX$(PortAdd%)„      END IF„   NEXT i„„    IF Count = 0 THEN                                          'no port found„        PRINT "No parallel port found on your PC !";„    ELSE„        PRINT "Which parallel port do you want to use : ";„            DO„            PortNum$ = INKEY$„            LOOP WHILE VAL(PortNum$) < 1 OR VAL(PortNum$) > Count„„    END IF„„END SUB„„SUB MoveCursor (Q$)„„         Q$ = RIGHT$(Q$, 1)„         SELECT CASE ASC(Q$)„            CASE 75 TO 77              'When left or right arrow key pressed„                IF POS(0) < 34 THEN    'toggle cursor column between 8 and 57.„                LOCATE , 57, 1, 0, 4„                ELSE„                LOCATE , 8, 1, 0, 4„                END IF„            CASE IS = 72                     'When up arrow key pressed„                IF CSRLIN > 11 THEN          'move cursor up or wrap from„                LOCATE CSRLIN - 1, , 1, 0, 4 'row 11 to 18.„                ELSE„                LOCATE 18, , 1, 0, 4„                END IF„            CASE IS = 80                     'When down arrow key pressed„                IF CSRLIN > 17 THEN          'move cursor down or wrap from„                LOCATE 11, , 1, 0, 4         'row 18 to 11.„                ELSE„                LOCATE CSRLIN + 1, , 1, 0, 4„                END IF„„„         END SELECT„„END SUB„„SUB PrintPortHeaders (PortNum$)„„        OldCurRow% = CSRLIN„        OldCurCol% = POS(0)„        COLOR 14, 1„        LOCATE 7, 10„        PRINT "&H"; HEX$(Port(VAL(PortNum$)));„        LOCATE 7, 35„        PRINT "&H"; HEX$(Port(VAL(PortNum$)) + 1)„        LOCATE 7, 59„        PRINT "&H"; HEX$(Port(VAL(PortNum$)) + 2)„        LOCATE OldCurRow%, OldCurCol%„„END SUB„„SUB ReadPort (PortNum$)„„„    FOR Pt% = 0 TO 2                            'Read data from the port„„                OldCurRow% = CSRLIN             'Save old cursor„                OldCurCol% = POS(0)             'position before screen update„„„        Byte(Pt%) = INP(Port(VAL(PortNum$)) + Pt%)„„        IF Byte(Pt%) <> OldByte(Pt%) THEN       'If new byte differs from„                                                'old one write new bits„„            FOR Bt% = 0 TO 7„            Bit(Pt%, Bt%) = (2 ^ Bt% AND Byte(Pt%)) \ (2 ^ Bt%)„            NEXT Bt%„„„„            SELECT CASE Pt%„                CASE IS = 0„                    Clmn% = 9„                CASE IS = 1„                    Clmn% = 34„                CASE IS = 2„                    Clmn% = 58„            END SELECT„„            FOR Bt% = 7 TO 0 STEP -1„                IF Bit(Pt%, Bt%) > 0 THEN„                    COLOR 15, 4„                    Tag$ = "High"„                    ELSE„                    COLOR 0, 2„                    Tag$ = "Low "„                END IF„„„                LOCATE 18 - Bt%, Clmn%„                PRINT Tag$„            NEXT Bt%„„            COLOR 7, 0„            LOCATE OldCurRow%, OldCurCol%, 1, 0, 4     'Restore cursor position„„„        END IF„„        OldByte(Pt%) = Byte(Pt%)„„    NEXT Pt%„„„END SUB„„SUB ToggleBit (PortNum$)„„„        SELECT CASE POS(0)    'Determine which output you will write to.„            CASE IS = 8„                Pt% = 0„            CASE IS = 57„                Pt% = 2„        END SELECT„„        IF Bit(Pt%, 18 - CSRLIN) > 0 THEN        'Toggle sigle bit.„            Bit(Pt%, 18 - CSRLIN) = 0„            ELSE„            Bit(Pt%, 18 - CSRLIN) = 1„        END IF„„„        Byte(Pt%) = 0„        FOR i = 0 TO 7„            Byte(Pt%) = Byte(Pt%) + (Bit(Pt%, i) * 2 ^ i)„        NEXT i„„        OUT (Port(VAL(PortNum$)) + Pt%), Byte(Pt%)„„END SUB„