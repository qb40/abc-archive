The ABC Programmer             SOLVING LCM AND GCD            Computer Science Book          10-28-95 (12:00)       QB, QBasic, PDS        168  4809     LCMGCD.BAS  '==========================================„' Finding the Lowest(Least) Common Multiple„' and the Greatest Common Divisor„' Programmed by William Yu (10-28-1995)„'„' This program helps, where calculators„' can not compute the exact fractions.„'==========================================„„DECLARE SUB FindLCM (Numbers(), Max, X)„DECLARE SUB FindGCD (Numbers(), Max, X)„DECLARE SUB AddFractionDemo (Numbers(), Max, Denominator)„„DIM Numbers(10)„„CLS„                       ' Keeping the numbers simple to avoid long waits„Numbers(1) = 28        ' You can modify/add/remove as you wish„Numbers(2) = 42        ' If you add or remove one or more numbers„Numbers(3) = 126       ' make sure you do the same for the AddFractionDemo„Numbers(4) = 98        ' Numerators()„„Max = 4                ' Change this to correspond to Max Numbers()„                       '                       and Max Numerators()„„PRINT "The LCM for"; : COLOR 15„FOR I = 1 TO Max„  PRINT Numbers(I);„NEXT I„COLOR 7: PRINT "is"; : COLOR 15„„FindLCM Numbers(), Max, X„Denominator = X: PRINT X„„COLOR 7: PRINT "The GCD for"; : COLOR 15„FOR I = 1 TO Max„  PRINT Numbers(I);„NEXT I„COLOR 7: PRINT "is"; : COLOR 15„„FindGCD Numbers(), Max, X„PRINT X„„AddFractionDemo Numbers(), Max, Denominator„„SUB AddFractionDemo (Numbers(), Max, Denominator)„„' Adding fractions using LCM as our Denominator„' Can you think of another way to add fractions?„' There is, but is not commonly used because it can be tedious doing by„' hand, and even on the computer it is quite slow.„' But the other way of adding fractions is to multiply all the denominators„' to get your grand total.  And then add your numerators.  Now that you„' have two great big numbers to work with, you find the GCD to reduce„' the fraction.  Try it, which one is faster?  Using LCM or GCD?„' Obviously GCD works best if you cannot find the LCM, but sometimes it„' will not work because the numbers are too large.  LCM is your best bet.„„DIM Numerator(10), Fraction(2)„„Numerator(1) = 22„Numerator(2) = 3„Numerator(3) = 35„Numerator(4) = 4„„PRINT : PRINT "Add Fraction Demo:"; : COLOR 7: PRINT : PRINT„PRINT "      ";„FOR I = 1 TO Max„  PRINT USING "###"; Numerator(I); : PRINT "   ";„NEXT I„PRINT„PRINT "      ";„FOR I = 1 TO Max„  PRINT "---";„  COLOR 15: IF I <> Max THEN PRINT " + ";„  COLOR 7„NEXT I„PRINT "  = ----"„PRINT "      ";„FOR I = 1 TO Max„  PRINT USING "###"; Numbers(I); : PRINT "   ";„NEXT I„„PRINT Denominator„„' Next, we calculate the numerator„„FOR I = 1 TO Max„  Numerator = Numerator + (Denominator / Numbers(I) * Numerator(I))„NEXT I„PRINT : PRINT "     "; Numerator„PRINT "      ----  =   Find GCD": PRINT "     "; Denominator„„Fraction(1) = Numerator          ' Plug in the numbers„Fraction(2) = Denominator        ' to be reduced„„FindGCD Fraction(), 2, X         ' Find the GCD to reduce the fraction„„Numerator = Numerator / X        ' Divide by the GCD„Denominator = Denominator / X„PRINT : PRINT "     "; Numerator„PRINT "      ----  =   Divided by GCD": PRINT "     "; Denominator„„I = 0„IF Numerator > Denominator THEN         ' Let's convert this to mixed„  DO                                    ' fraction„    I = I + 1„    Numerator = Numerator - Denominator„  LOOP UNTIL Numerator <= Denominator„END IF„„' We are finally done!  Let's print the answer.„„PRINT : PRINT "     "; Numerator: PRINT ; "   ";„IF I > 0 THEN PRINT I;  ELSE PRINT "   ";„PRINT "----  =   Answer": PRINT "     "; Denominator„„END SUB„„SUB FindGCD (Numbers(), Max, X)„„HighestNumber = Numbers(1)„HoldX = 1„C = 1„„FOR I = 2 TO Max„  IF Numbers(I) = Numbers(1) THEN C = C + 1„  IF Numbers(I) > HighestNumber THEN HighestNumber = Numbers(I) / 2„NEXT I„„IF C = Max THEN X = Numbers(1): EXIT SUB„„X = 2: I = 1„„DO„  IF Numbers(I) MOD X THEN        ' Check for Remainder„    X = X + 1„    I = 1„  ELSE                            ' No remainder, passed„    I = I + 1„  END IF„  IF I = Max + 1 THEN HoldX = X: I = 1: X = X + 1„  IF X = HighestNumber + 1 THEN EXIT DO„LOOP„„X = HoldX„„END SUB„„SUB FindLCM (Numbers(), Max, X)„„X = Numbers(1): I = 1„„DO„  IF INT(X / Numbers(I)) = X / Numbers(I) THEN   ' Are they really equal?„    IF I = Max THEN                              ' Last number checked is„      EXIT DO                                    ' equal, end do..loop„    ELSE„      I = I + 1                                  ' Equal, check next number„      IF I = Max + 1 THEN I = Max„    END IF„  ELSE                                           ' No they're not„    X = X + 1: I = 1                             ' Start from beginning„  END IF                                         ' Incr X (Slow)„LOOP„„END SUB„„Joe Krzton                     STRING MATH                    FidoNet QUIK_BAS Echo          10-31-95 (16:01)       QB, QBasic, PDS        58   1739     STNGMATH.BASDECLARE FUNCTION Add$ (o1$, o2$)„DECLARE SUB AlignDot (x1$, x2$)„DECLARE FUNCTION Subtract$ (o1$, o2$)„DEFDBL A-Z„b = 1.5: c = 0„DO„    b = b + c * 16„    pi = pi + 4 / b„    PRINT pi; : LOCATE , 1„    c = c + 1„LOOP UNTIL INKEY$ = CHR$(27)„END„„DEFINT A-Z„FUNCTION Add$ (o1$, o2$)„op1$ = o1$: op2$ = o2$„IF LEFT$(op1$, 1) = "-" THEN s1 = -1:  ELSE s1 = 1„IF INSTR("+-", LEFT$(op1$, 1)) > 0 THEN op1$ = MID$(op1$, 2)„IF LEFT$(op2$, 1) = "-" THEN s2 = -1:  ELSE s2 = 1„IF INSTR("+-", LEFT$(op2$, 1)) > 0 THEN op2$ = MID$(op2$, 2)„„IF s1 = -1 AND s2 = 1 THEN Add$ = Subtract$(op2$, op1$): EXIT FUNCTION„IF s1 = 1 AND s2 = -1 THEN Add$ = Subtract$(op1$, op2$): EXIT FUNCTION„pfx$ = "": IF s1 = -1 THEN pfx$ = "-"„„AlignDot op1$, op2$„out$ = "": carry = 0„„FOR z = LEN(op1$) TO 1 STEP -1„    IF MID$(op1$, z, 1) <> "." THEN„        ans = VAL(MID$(op1$, z, 1)) + VAL(MID$(op2$, z, 1)) + carry„        IF out$ <> "" OR (ans MOD 10) > 0 THEN out$ = CHR$(48 + (ans MOD 10)) + out$„        carry = INT(ans / 10)„    ELSE„        out$ = "." + out$„    END IF„NEXT z„„IF RIGHT$(out$, 1) = "." THEN out$ = LEFT$(out$, LEN(out$) - 1)„IF carry > 0 THEN out$ = CHR$(48 + carry) + out$„Add$ = pfx$ + out$„END FUNCTION„„DEFSNG A-Z„SUB AlignDot (x1$, x2$)„IF INSTR(x1$, ".") = 0 THEN x1$ = x1$ + ".0"„IF INSTR(x2$, ".") = 0 THEN x2$ = x2$ + ".0"„da1 = INSTR(x1$, ".")„da2 = INSTR(x2$, ".")„IF da1 < da2 THEN x1$ = STRING$(da2 - da1, "0") + x1$„IF da1 > da2 THEN x2$ = STRING$(da1 - da2, "0") + x2$„IF LEN(x1$) > LEN(x2$) THEN x2$ = x2$ + STRING$(LEN(x1$) - LEN(x2$), "0")„IF LEN(x2$) > LEN(x1$) THEN x1$ = x1$ + STRING$(LEN(x2$) - LEN(x1$), "0")„END SUB„„FUNCTION Subtract$ (o1$, o2$)„END FUNCTION„„Jamshid Khoshrangi             ALGERBRAIC FORMULA SOLVER 2.01 qjackson@direct.ca             01-13-96 (00:00)       PB32                   318  20987    ARDAF.BAS   ' Please run under PowerBASIC to extract ARDAF201.ZIP„DEFINT A-Z:SHARED K,S,B&,Z&:V1 'Created by PostIt! 7.1„SUB V1:OPEN "O",1,"ARDAF201.ZIP",4^6:Z&=15443:?STRING$(50,177);„U"%up()%9%%%.-%,yRRE%S?bcR$m%%iY%%%1%%%%fw%ifkW%UVSgRfxNL):B#lYaY„U"pZbgxu;%nKe[CMQ4*/ajHe('cUK%&?%N6D06t%&M'bq9C<Vd27?e<e.2D?)t(a0„U"l,EHpS1O$VWzEI8Cz8%<B^6hQEA/FLz%%%;%%7O6j1Bfs3wiXL-KU>WS3<6j\nF„U",3X9-AmCYoHei(SKi59ML-b7S,m'RtfWljwo_B*[]sSRVVUrU>MGsNCku04<Kt=„U"_8QqzHr3PLO>E]Gz8u,;cjSPIvzjWD5/(-krX%oSnZAX,e/;ua4_9##d%tZN7aC„U"2j6f;;TEnEm<\Vl;0vPB)s.09ZSVPlG=T=.5o2*Yg6TGrMyv6>8Ep8Prb4oTFr6„U"sD($x[3j3cz6'<vrd0-n<a0C1fX/ASW7VSFLz\%+gp]-+S=Z[HB91<?1/si\YJ?„U"WJB_R(\,I)8i9R#h>(s/&Kn&*E<%E9g4p4g?42__?-VhA,TlmR$K&/Ls,nk[,8k„U"W)U=AXN8S.biH7,W0etCCcFU.r\A;i,b_sx0i)Ld7qvskN6KnLW_+JQ]Yl#hrZ9„U"(MYXLIj2F;sQMXfApN=6Fx]A#h[]Hp#yDl4ek0Z4$fvZ60VEPNiuBZvm[5PGL>b„U"tMt+V+A-,T0E&UX.\G2Ej)x>A%akH[4FE^^D'>r+%d3ma)23FMd\6c4I0gGi_O(„U"Q<%j5V79U6csD+NowHH:qeS2?<.-P:(0iHiRGg^(S::Ysl^10rLcIJWv:.L&C<^„U"+B74JBk//Ew.l01jeZ.;\(]5+k#XWkDhhHFlZM]7h[$=#xT&BWHp4PXtu^K]=g,„U"*W:pAQDT=U#u#M\LUxo\(J_1ObIse46mtHk9Ra4*NJ?b^[g=VCh#kUx7t]m]&I_„U".cVCUW>#;2Vqf7Q?E^C?FSj5_Ji)W5*Avd;*37^s0DZ%E.M%HY,VZRG?3K#7H=?„U"<7o*$0k=>#0H5XY5_Y]dDEr)]>'n4)+4RHGDF-e27gl:WKW\ht6<#483Wai0n91„U"'?W]2j8Em*<STrxP69?'<oFi'd5OAS[Apu-AaV3li-Y2x1O'f1S.sgkNK+B8<=#„U"QHI-,VUVTQ_v7[tl$'HNTXdPt8Fb=q/(P#:k\v8j,w8Yi8V32VgU5,IiCQtj,aH„U":%(l?<gmqb9A_1F#r07NoTx7%#T/mX3dvvojQb&R4Lm5[U9j3eegd5M5#tmd'CE„U"nI_(gFG]86kvNKxgQ4[1%KZtiehlmSHwpOIiF1Ugrp3$G_aJ,A*-g18]o_UDE$m„U",8+t()_MI/bG0jA$[G2MN5*IQ%b%7BUjP0[)h6md;oVdtin[*f>%$5.d/i%3'A2„U"4'k5;/$$>;'quHP]:W62]a_I;K/CM_ImPTE'u?jEnKFFlBAjr<JcXhL:[]Ggo$A„U"qxX3K,DQtZ?^fj3__C+nsXu;c=^26H#R8E9HgkeVLX?W0j>IMV>5IS.G$P-Z]x;„U"=R,GEfRCrj?HYVX+a2:lJ(GWB7Ow]bG(kL&2_pU82QR[c;mfC)=0[<S1,/^GKA-„U"GSO/;)o)RwL4\Bv8^c(NvME?d25.lnA6tRLAOj0Y&(J<Y2ld?XjbP]-CgWhaF'I„U"a5?UJ%WmW.&?dbG9]RlaXF6QY2]2>2QkH3tL,#aa39Vle$mhjgVGBQlRg+o*g<\„U"2ITi*Lp<%vLEAFt(tA\hKWP/F_Y6];l)e,+J$VzjGf'X&a[Am*Ax>=i9lrThl2n„U"\(xG=2$E%A1-Ss8<zeAC+v.aE_zX'6Kriqdg<5$c($fA/9U*c,i:)HiUVOw%(hv„U"+6l:<f+apbh>84Hdnh2:x-Pf2jnr\MpV+nHqtLT5%uOAVK+D#EK;+NeR4fOqeo$„U"-8fhK2;_DVh$m..K[m-]G<CmHv55K48/$4jotjXj?MffuO(R_gUkNcS1MUfUMuw„U"/gz&2P6V?MG75]?q%VGsuIrZif>f\5=]FPx;MykClnN0fu$6c3Uv.\f7D?nD]q<„U"p2HrLWYTriYw]jaF/W$[s$m_y#9gD2^J__TAx]9tx,%>&X%VebA$)BDH'TdjQ9F„U"6+MQjJ=lZ9L=7L*D>5x0.2KuLnUOWGZtRq&:lmx7eJ18_JAs\L>mSK[u\s9_OIV„U"[sHLA>I2J8=Xe$1Uf'd\=/q/S&94)?7ed-TeF>C2]jxnkpAELM)n?)=_n>3r42_„U"P?+2J;4-q7#chn*)8=-vk<EL$nho_GVqUa.e%IMWOk/90P4$LVztlk;I-T?9C%*„U"7HZ*W^8RwSA]ekH\;aG]VB\QjrG/Qd?8,Qt;yy)r^u.ZRZd7*Ns%x&P=.r[0TkL„U"cb??l$l%j'FtVj=khME?&OK_-Sai4(lJdU)?9S[?Dz(:V=m)Ua5*YUS+$/R7tcq„U"0F'H#KIUS6,so?QjYuCR*^&2+Z&(c##[OlD%udKn=Zs#:3Hh,L4wz95Pd_,<w6=„U"a#[+^I_fVE)/fFT,*\_Sk+fiCmbA]m*jX\/a\1&#LP_%I]l7QP1Kf'n$rl%6X34„U"Asm5Bv8kEMwtzo8tsf)ZEDQYgciy9_5KAD^fFTDRRjK?=jEFLBN;kCUjc\_bR(k„U"SEr\g0-es$P3)Sr<(#)bS[&n2+oGb?1wVk\QBlbR,b\Wp+Xv>W0h*xCIDaz$iH]„U"nNendNo3%wJl$)dD9Hj^X#IA-P$1JTDe&iD_L9Jw%gP+5y=FiabDmb]gl*ZofKH„U"-XM'VU2?JYS:Kn)_=5'^sB;3q2i#H1LYn#0HnB6.'dn=WuKVJHTg0S?/Ya8q3-D„U"iXu4n7]8feP:j+,UT77&0.t#u/F/Oasm#7b<gH\Cj[W\3BJOR3r#AfXPs85Kfd2„U"Pss/67SE3J9?Y=-4;_:?e\>PpR2'qL%]>aNc2d+a%4*<O\Ho?jb+,fIe(aIxT$*„U"H]5\Gi\_0,HDxBCEY.;b%V(jWppq<vAR(^'7hnXt'l+$<D6aaYOm-]1#[,H53[p„U"R%D7b0-T'e\wj95ofZXiqbkvYl41'BI^%j#c1aKDVa)Z/qG]S^g\p_C$;;[uI6U„U"e77y=3Sk-ty^m%&EmY(L#$F3=qC5VO2:GIn3B40lfwoL9d/Dt:B8?nJY(RU%V0C„U"mQ]2ZT9?_*>X4A<[,^KFFp8I-^hNXRpiEFN9Ury/K&]o,prWw;8bVNzF7g7F%C=„U"EASBYv'Ync(Aa*.?QECN?B;[rr?IIUx28^k:u-'ZIBVKY.bU&1nNcLX['?'XQHa„U"q&w-nWdD9mNrKSWjj]]31Cp-Adq>]b3sY].R=Ear>K-^x'99I35WG_j#pT;-a2D„U".:7lep;>;aBiYg'=B;LUg;6-rsH.hT_r%;T/%'v31*.o=wl9h*=%elq9NN:FPOj„U"KEB$o)ZflhJ;</g-<nr&kO#rlQw2i:EON$+8cR=D[/yT<:1?W>:VQ$\C.^^D.E3„U"XBdlVrg8g%<O^-fmYX*Acu>aB1S*kC=ZJ_EQ)UCC0nnDmi'R(?HDuQjP%?M=:*R„U"x,B228u,&BUUL.>iF?&J$lK&U,$2?+#xbLW*ERAg/ye,0]kAjz*L>?)7QwFY_MR„U"%C14inB\[X%DQPYK;8s-7,S\U8uXI.\#(n\jH[Bi]Og(S*Jo1F[W-A*7/'3+hih„U"*nt?hQ&7zd&dtB&fS*l$c6UEgYiDRRy23J9]-aB#piVK5oLNG-Vp/F4E?.]_MV8„U"*aE=)[>qtbIEk%=9_GVGV0xN85&tDFBZip,rYC)Fe=A8_SZx<?:0?uIU:0N4d12„U"hmauQw=v5xdh<)0pFvas6W)#9_GaguN_YMhZ-q:(JJM-_l^r8f6dN#TMIB#65CA„U"oaFnWt$E2*65?c2L^&W'k.bsAk.%T3;>KHMtODHAAF2.,AI;q4/(Y\Aw;jFn=AV„U"/7+Y<VmFaURlSC[Zx0F2lx6GQc'W31G\xky(]n?S:iW:'>?6H<Jm$E2f[*2c_$J„U"?3Aom?e>D>(]qSL8])>tEiTp9'0H6'3z+A]#s?\9Zm_nQ=Sa$S$WX$RtCZh,66>„U"JHpe5#0Ue:x==-oCBc(ID)]1'R87]l;mtaRZuE9U^SJdF%g_kpRg=\;tVQkYeU7„U"?GLQj]45';:.XDH,+aOoaD[6YsJ25HQ\_7liRM?%4_16CV##*(y;RVxo0oWE197„U"^w\N+::Y;l':i;Pvj)E0qeQXqQQlDR5-WpHf<c%,pxk(8^v1TiA]rQ-xhtnH?3H„U":f]gX#e<4U.pKCF=b+D-\,Dlt)VJAr$M&HY1;sZwGX5E1AU#0;p%tV48m#(D&tA„U"jW<upsP\F6AwQoRh7,wO&0_:J<9TZ)(Q1*?#5>5pVC(FD1oac.iICgAb7:Sh<?T„U"p=n4%=m(ti>LuE;67vv,n)U1n;z;Oc/:mLN%^9lek%k1^>kh#f.<4d_2w8ReR-q„U"_(/M,)$8b7uF<D=[jy.wY.f8e6G/4GJG3fos.B1B-%b+<Wf&bSeEtt#QAHoK;L/„U"Y'?#lOC'r2C?aSs'%T^LbH5Q6glWU7(s44AKX070*T%glO,\[v]\i\O5lJiC(zP„U"la%sW^(,#e4=:=lH2vbgZVWS)aP.NIP=D=Y1P[*rn7q\nj'/V(pHBN,,F<[qbsL„U"B/>.0tZ.$cF,Z5*md#,o.3X6T62XFl#9X+E8FT<%[u]=//GHQqb9*:l$p<OZoc5„U"EI?lEKX-68oFnVTum6tCa4>8'X'9F&m*YRloe$umBpOibMO5]#eqJ-5U7Sjrq3b„U"KYRIR(a5Hm]o?p*LKEjDvLx[rS7cArjMZ$6l5X>W;0EhhE'&HBtGS.%Da&AWk>Q„U"jt9&?jNa*'dW1hBX_R.fA^i]QaA28#m<ZEjgd\V6]YD/b?bZ'h-/%L_$H^G_'Z,„U"-:VA0B0#Hlm.iih&+;3xF,+>o5qK/;R(7_0.=B$Fr<FPfMlSRspzcKN%H4YOS>2„U"]0:8]AgakKr8j+'mf#Mr,0*$xMX0/s[:\U)x5nS6PdGj,p?[bpL,4:6y1?9fWs4„U"3OY9s#k>p&QdOeB3j%0P&P%X*$=I4N2L0qp^sK7)v-$1i(q8.A%v,8\t>sae,#3„U"jU:S\vb[8qRN6KYM&?TYCUcRtcdhp76)G1Jf^^*Ir(Y-gi+TJg2Kk_TM2rbNASP„U"%vxNs27Ve,etmJQNVrI=,RKk/lU:\JKQG:>*2o#Bm9KCX?)lnZlx]?F>C&VV&\3„U"h4<v.MY%PvRjP))MG:F4Yq^cHj#[Dfr#C>j/56I4i=hp>kaQ.1jH9I=u\.K%hOL„U"]OP)^q1N)o/zBCSS:h$\H+eaFcold_4cC:d_BJ>M-b-cBSzLxis7?H#9H+&$THm„U"kH?#F1>.IM6lW$a]oE]:5gc3P/uf/(IRO4%j'RlPmVyrO)upY.E5J-ug]bv1%q'„U"ig4?xOpOW)K)Hh_/_]<zY[<>,uO^)*PW2BKjCu_)$Z:Ws;ph'2G/):F5]JfcpLZ„U"Nh%6X<t]0sgAZ5w0I(DWg-/AwfgAO(a%pq;31<,^pt1:.HV?>_Ho*QlWm#CeO1S„U"lYGe*(hwlH#6*</)[GG/?Np_Gs*]5P.B1P2;2c&=a4/=[4RiuF+9-Z/^3<NvPQI„U"lQ$:0IMY_YWYKv,u.M+6>X'%LFr?>2>KC_c^.t:9?jFD'</k2S*B[nABQC$3MS)„U"42JI.X7k\$\7sARAyTx(<[1#m6ht5Q>;r2aVF^gKLdg]#.OA,:5h]]6aEu]AW^I„U"E,F#L)[X.FH4q^-&20wx[]H^;ZD)<l+;TSP&#.qErg=FD:.P)6>2GR,$9rn%98;„U"O^TAOH5DX%iwg$_cTV/B=9L55[a-Kh/v5M]/&a]OsI:F^(<_3,5_lkuJ034&nvp„U"C_4kNi6/G9\3+U=Mn_ooUxoL&V4e&tGr''mX_N&q$UBMo5rnK9)Guw5\$DBk/bh„U"M;6GTN]q7;tTenr_;'>yS%bSRlDc44m1+j>xuoa^Cg&'wL05jeaHEwN=/Tiz8Il„U"VZNm?B0]Ul\Z?ALQGOC.Eln$$Y8.:JV$F2AybbG[k&F=$:2_kju,_E1I7bb/Uk[„U"qChU[S1/Yi?c0m8ibxrxL#R=#a.pmQmXmO.E)/'^$aSs[ntA$T$7LPTPWYz_a++„U";T'/a[vdDIAGA)Q8T6SNEw:A*\B8#+/$r3+)&u)g(Cg7/OR9%W+8*i,BVBFEoFV„U"7^_Y-6oOWy&[,pJ\R&Ag>w/AVh/V)kX6kZA3UCQKN4z,Z(OGqd=IWZ6:P#=Esvf„U"wP%k]gA5plt<H4YRbKtxJqXYv>M40R,5Si/4x7oh'sK:1y:0i)(AU3K5/$Zl-_)„U"G;obD[Te5(u)Dq_G*D+')(foqT;3m)77_fMd3ru)iy-yqq$'os3F8d,Dk/Gqeo=„U"%'AN^oK21%Jsl.cJ)y5[dd^S9W=]qb]a(vU^:#JwXo*cQak(<=m;2707VGmeNtE„U"iRlUt#q_p4>22>yV,<A?1opVJqAg:U9>FDzbi2YTPow&Sy9\Pne&[o=^WFJd&lT„U"3#150/gil=H5d3j,.$*=%v_RHrm\U,UuxY_A$6T,IqZaZXDDUvr,-dCQMn?;Mf1„U"U9%_do$%r<F#9,.q==m1=HjC/k.%06:yAug_M?H[AFf6$V-h+$rd;_zMc/8sS$H„U"?Q6R0^Me3UoZX*dQ?Vg:'u\.LJC1yU#pZjXrK(YN2dFofX*FXajXTrEPyUaEjP$„U"0b_vkedldvo&canME2243c:?pHu^A='m]7]Y?kuR,$xlmilCY#m&&Px)Ljb%SUn„U"45S-elEe4ra(jYmS\4:-hZF%Bpd]nkN7AZ$,GM$fbFY]q'T7F]NJkkn]n3P8YJ:„U"J$6V3OVM>]YQft75ULtu00E&3Vqj[[R?fo)6\9))>pXDh7;'Xg7mJGr+Htr+>Xm„U"5&ksdR$CixN(t:m%JoqPx$-Y9/B5C9hR3+Gf0hhb\o#U#hW=-;jWm>??v5s$_to„U"W-F_&bXx8G2YlXDcVDwhRHQk.w)Sa7vcmV/[Q'vR]1BQ>Q$M]u>bq6RfHT%27P*„U"4C\M7U/I5$3FHRf3;apZ1av9=VnbO##jq=&;Lo?74*-CbEP5>O]nIS??Gthx=F;„U"A=xcOEbR?bk8n'l1C#]RHG^[=-(j\#atM:]HgEUavV'&_4XQdJD9PF>3[,MPlc(„U"e=ya=L_.Nv3s%8-Gh2v[Dj&LD9$*67]*Vk67ri,2RL_hxSd?Zf+Wk'9f'eNbo,P„U"TY?9BX&LL&&W6RJ.R\^.OZqzYZ9szWu=1gQ(F%BU3L^H<.U&);^UfS1x-Isqq3T„U"nza'_^RcDI);AVGC8/N)>X$O5sws_;Bv,<_\R(WY[*BZk0$yVT#^<ZOTYhLGwc*„U"P3rK$)[ke?rHgppuUjx18jFG+Q4y1bq0$N[D0Ez[,-,S39/taE<R8O>dB9rIvk'„U"dYZk2V;XW7wN$EZtIN7$g4::1=M%fl.1<4u:SMP)G\XETF%e&$o)fH;TW&-1Kj4„U"UYjlV/<A'(-#_3h%9Y..WFa%##umH+oJI>EHOgZ5L6IZ,>gV+5^hVaX'0r[jjDa„U"m?,(3+)]q*#DR#r9cON$AxiAN_3,\&Nm%w#cP^1=It';?'wXXgI.[H*9]_esxPj„U"FiXC_mR=EP$0/\etd%XI_608</WCi>W5;.r;2x]'LY^LKgWQFq\RMvUjt[[rV?e„U"*hy7hnP&CB<.'^&_W?f4Cq:T;$Qo)n>mVyPAQ9JXX0FSGzVdoJaRDQ^+h2)JSrk„U"qb*^UQoHd-FQ>Ii3&n$<3QDmslwJg8SXI8g[k[[-LWC1#SX=UI&6e:(hjg5<YbV„U"0-?xm%LKdBG^RGu;H%_.deG%[%:1NJc-IMq2[D+?m;r]NJP]#v1W+u4'/ajeU]%„U">1VjlmIn73w+<TJTJS6\(<Uhr\bdV02i%2SM,\Yv+ce0g^7/oVm**h(ikTg9&l,„U"L6L2]6YSQShG3s9?e)U<pLlcr:HhcT3^ek\DS$<nF^OIcIEGY8.2#N&5A=^<;oe„U"_J?6TQKI*$0f^AwUm)ID\tE0N2)O>$7kXG44Lt)lMrtKQ2ndmeA.(bYf-/C)Y8W„U"%1xa>ip'Q*9hWSFy#_E)ET1VW[?$F52$Q0VFa5)S39WBsCxn;Om[s4x-ks/(IbI„U"DPiGsmkC0t3v-n1>UFlT=n(dmS']3z9M%-yXJf:vONHqVb(Ynm%*p09l9dI$Ufi„U"U]f)PQ4%$lIUuOd=,*hl%OlZK^A+?'y/Cdu5RRV*O'2R:Jl-1?]sTs7Nbt%te_(„U"Zs).GQ\QIu0fw>G4hRnqWMO6W29ppp_RjeW%FL<gfDRWF*'7c\y5%>/QcepXk'S„U"&c6w$rjuIwjFNRJ\PR<2OeE^7d+C&[>*-paj'^?70:;P$kSd95j)=6mO?;i6cT4„U"v(J9P=1a]h3THZsf_fm'TJl*sUa$kGoxBXyQwy]l2Dil3V=:Vr%tq6vn_YHdXmm„U"L8zjgXm5:9E.Q+XS+qVG*=K-mVstw)=ejQb'le#)5:Wd6YI5ORCh$,3E&VEKVn'„U"(Yl,T.VOYNEJsWeX-0BNx\lqpZ_9^%w%)0]TiD^jmwU5RnK$1-Ue??8X[9tB5h8„U"C/>iiYX]lQC.Nq=If2,hYYGubs^sV\'cFiEi_dc8HVcVN3\m+gmXu44DlVr(9He„U"I&KQba$Bmr+2Nm+Zl8W.Za,+X9<%]nV,x(xh5QfGAOQv'3%7&AU:NPJfP?9L&A.„U"k)cM.sB69CH5DXrsf%i$Y+piTRExc/&\74_$7)3sQWyr:UMjjP=AiZgc%F7^5Gq„U"28R:<u8.lJK8Q[LLaQ3WJ<?AcQ:WnTiYRfo&[](F.Y^2/=qEMRmccl,S/i7pYwr„U"6kWkm(?fR%rDWo<tALE&wP/F.EmO\2s]U1WXK1;0EZ?sN:Yu9w$6hzzuQ6CIn=o„U"vjKn8K3p&Q:nh_Xno6=ioj&BZQb7U\pHSwn9pG;rY<(XEc,4Y5o9:wc(8G6<dE8„U"^?enF1mC.[/NR&d%7sv+%nWF?.SK2A?q-(\<e==;c4aB#;EQ/9:CEg)zCb11a/T„U"PRc[.Q3fc3X#/WHVfe[g/\vOrPIMjoAPQ(sgUFu+wmg#f]Mx$pdXi,;v20_RSo3„U"T:ZUNhO'uS6?B=t=ZIb\5I$Z+^(k)_$?+e3T0A['[\uB&#KM63I(ZCyr:v3:Sd#„U"F8Uam*Xm3+1J+Nrq\K1v8):[aHWjh-Sn5P;a\GG'#C4>UVCd+fZ*7*VQn<0_;tH„U"i_e+*9P;^l-ua&IDeVddU71oc]JsE14>$uBl+i'a$B4\a8;;#O+607H*g+[Z$H.„U"KDLF2FFqHTj,L%GEKG5K9*%d]IiIK)H+Thbg/i(d.;Vji7d4TdhS]<?s:Cz4&q[„U"C00(XHxi-]AL3qE]'SRb'9?W],#025+G+JyO\x:5mJDrw*4T3;8xNZ77el.ZTXc„U"cUiqf(Ib*Fn^9;+mY]=YXr,X=A(HZ4Wgv-S$\/FL'Qf=0CE>je(#QN%8qWZio?B„U"2\_GJoD.'5l.*Kjyr#fvX#R?1tl<g:J?8w/Fp;)vP5u3VKITa++vMUK$CD:Nb;q„U"F*uDm36qE1'>1);'PW'-O.*0V4&FUmJ5?b>j)e0LO$OE(6KQY5L6-xak*pGgW+R„U"v&OcBuBnfx&NGE.?2$ub0Fu/*aM3L)/:Sew,*Z1yGjU:ON*R*i*)/ax5)TX[l[:„U"fihP9\THb_O/q$cKk<'&?pC5Otsw</sT]WXXvJDDB^;_D=pTpY*&:EF(^kuDWdG„U"tHl+-oFr0R,N0&Do&G]-UvQ\ylRbQn;NBRK&wa6UFaK[[2cr?IqSq+NeWr,i6Z,„U"_n^TIQWI?*([\7E;1:%bmF47)oCIe_b'>sf=Xr_US\[0ta5RuJVa6Q<C?<eo0G5„U"'=:W#.'R4F%R;*[e9MFsqI]u/A%,$QYmpmTt(LqiN.I];csKa2zdYh^_B_6Vu0e„U"_6gKJwU83*dEpHU(8IqS^byk:?'/U#v3bkKw.8[)s;vyEr/zL^%b\nNJEJsPCqK„U"YhP5L)dOaGShcQulY2be?;9aaGEug^x_e>vk2*>hejL;sy3g7L\LjSf(dl1\V<:„U"CQf5UOu.s-4<1LSH*H>j]8#[H\yL,.cH8XvgvKAaJc-KQ2sGPRU:0%PX#O9f:YY„U">&nUiB]?H_Hdg>fsi1M:zMk?T88#JhUdSz2$(N&-LE]YACDbgAj(FtULo3&_0tW„U"C:<p8DfG,ovp*xREzZcIAeP[l'fk,hvy,5&;A,F$9eK(RS2N<:60N#W\wOTKIBA„U";IIX30j1SffBlF^V93>siqEnMoN.D<,NGU5u<*<8[,ee;<)&9)%a5O-r;uwD*YZ„U"#,*1?%\sg[6&KKgr\]c+m0Jir.Ha%9e+GO.+wv_,/(pPX>p]Dqz=0G?Va>+d'CD„U"WMAQvD$1D2Y\J#$<SD#;El.m^acg_A%s8HbL$wL=$pAm\mxzE(fTKlgcnF50rP2„U"j-nBFw[W<%7.$3#J>=Zf($Uhq]d0[92%f5tNRNd,rK+YH1+/eXm=M(n5zg^;QLq„U"?GNgU3TGI[BWNhH.*g2]sGte(?%MK+:Jnw6^FA$;//#2Jr=/WLoO5wsl#NI]JNa„U"Pi*?,d'eWUxdFtD?'5*CdJ%E#\#=Ik:dsoZk\Sp438mJ97.FT[Y#^O7zllk[Y1#„U"E%bXjM4=Ol6Fog$IIoE*k&-R&xRU4=KT,<?dLI[dtlBC&Y-c'\>*p[yV(Cg:vAm„U"]Pzj6<+r)=AS*7VTIs#/kDdCIp+)v1=#w%#A;M6t?S:7Q0&/t&D]+dgl4Mz'jAX„U"(9nGzxJuLccJt=N((h9^9.uVc[T<N=.vt.M7>b6.o7hb]Y=%-1i_;'S&3Pv6ph^„U"M,Kb1I,oe3sWTuA)0x2e1[.9[:UzpKK247iH$(ESyV:CZ_=VV58FYl#1K\rgxa0„U"9*X]:%Q;.WIXETYl^#O)R9qGb'8$u2aD_)WSsa<5+%Ce&Xhnue)#-Bj_.3vz]hs„U"qXH^f3D;t,IeLV#_LnLdk4njk'nt%uZrCKk>4**kV^eB#f3yru0WqdQ,NwIU49c„U"a\NM(LN\B?*nQNaeCEJ$[jHZ[^Y^1XqVH-J+\#BD)E$fGqH,Ugu)Tg/&EPia0Co„U"-q7(77DH&?0R:E&?^&Xd=hX'[/ltQYs[3SrW0N5Tk*Ei6hEI4r^qA3>eP[bJhVP„U"grYt%CK8>NcR,/9cT0YHeK^Jp18bDLV-WPFQsB;)wR&olHYW5?*Lf]'AN8V+T5'„U"I)z$-\tck0b&roW?fAfRIt?#g4(^j#$8PVd&bU77JKcLQBr5'chL0&N4*B%pRCC„U"oF;D20Uv8?hn8lOuXgtV^OY0JDbl15-Pl?]YHN$qi\q>.qXxiqs=Ja2iF5BOIs(„U"^RsONlh,F0oFpKj)V;:PHTNW;$.,Hxq=VC(Jt21DeTz-_Cxy87d=Ax=*ejav](_„U"<OP2&Dt3MnM#=OC.n37E1O&Wolo/I[*i#Zk3CPWZULt;0_a)'<fBDbJVz<>6mW'„U"vu,9q<Tqk2aWW9LDr)Q2b2wWLkq&)Tn8cnXurKS6CgZ2aI[BMj;F_=,Gp#6#)q0„U"2(9VA]GsjP_FF6&ZYXIbm*pdLQnVaKD7J#MA-^Bw4#WYpDoqm3^#sxtp2<qka6X„U"J(P/310t[;>E(ZtflE:0Yj>aBcDkansNppAnT0t.eg7tInk^tr8wu#xjE#HJb4[„U"<caCtg,SGsmttwjhnU\0mh+fl+CAVRUqs#]Q0WzvAK'$3<quL\7?PPBY>u#NOcv„U"ffJvT.ltm7s,i;rFLFD7n)#PLC>TvMf<3Q$>R:TvG':xm6xPTWmm$NmI?8mg?sG„U"q*J+T[$)<PMio,<WJKXY;qFsQ1NPS4xnbA)5/ed/cE3il_9eWEs0GNi4R08SI^e„U"FK'C&>QY)M++:#e2rkN4h;aXh6E<&x8qml0SX<(XCuwm^^jz0Fv^zNU5r2Ltni4„U">y.mork2#n*a)pspCYDkIr#Bri24E]2JhC&?jJ(n2K#,h7ZV^nlGMd[QD*G_cGf„U"Alzm4rKYAKB?ppGMD(%d'0&INYb3uPk$d4Yg.TMnOak%%hldvOGYfJZ./2pp9[Q„U"*3Nf[&\FyNFjjAM9)CB$5tmLRM6&WU<hV1_wXDPuu%UiP3c?a9<0B+y&h,wD<_U„U"FiER7-1YVM3lWg(:)a&O9*cf/l<0%Jx-7H#.]YX-Rhp[n]mE;-2dxvKmsDaAu<O„U"v1,]yl5tYwwg4'(VrnfB+sOh'e(o4WLcae8+D+WABX$,/BD0;M*.G46q<'d*_BR„U"xQ8e5Q8WiSj))Ne3+R2Ovx#.r+2zOQ$f?kx^TMJZ&wEZY]qPB0Q)gbX)<<5;?/c„U"Dri4(q1q;:sgnP?6;_pST%meU>p-\J[>nV93_$3QEu2,IFT3<],bCcMgC5/sE>o„U"S,aFAq7#gVulb=)*Q(qehVh'lZ*s*QUU;W1InWlsGrR#6_2&A:9s#MANb\3vaCO„U"r/;]G#^'Y0vf)c>%7SmITH42^0YJp+]iK[e+yD>P_cAT'16uaEFka^W[#LdPqMo„U"'2?o?-OPRs[&YHM3lEJfRD*T%J:_4--_e9v5Z3R=b=7RO#B]<VQNQ.EW0%:1'qJ„U"\.1)CUdC8>:lYat;3bhR)iWcvGR1Z[t6j;0vTs:q>I9'ZKHl^6Bo.EBLbRg$0(t„U"q(V&<;8$jbPS[r5P&T%V9auKIs0R)xZl30&))Pq#3o1aNFz<:PD1gF_e?1K0?Kn„U"RihGE.nNaWs:HkYg((Od1Rkz^\Q7(2RH?\'%M#K8Q2Y_Au:%9Men.?Z9F+pX(B(„U"'M2*f6kBs\f%OtOl:Gu&+z$8_(hj:*I&lUr*hr[$sk<q1q&jpJv:::%V:BrRgPS„U"/HaCJM]V(C9LyuU28T$&4m[]UMEY7xR'\r2sR[Z)ygXr4C6jPPU,k?0x%zCUq.X„U"tMR#(0s0fSn7WmFs+\cj_.?GSE$pBY5UFsonI:pr/avcANs;rY]:Dh]/+4PycQT„END SUB„SUB V2„U"uY.9?$/TU=Ayn4_1>2tmUp3*]o)djM8lMw\ssV3mlLc$0\>EL5<\.3vV+dOnaH?„U"r2g*?M(J(QE5PD4x3^%s.-j;]H0:R<+Ss=1LVA*y64=ni.neB)ncMhq:m:HuXC?„U"Wm4;9TAwcV;Bm$P;,$8cKDRuX%8T9aDvd2KS*:Lumt%n*j>LGEKzRlXb8TAsDxx„U"-uU#8HMAn;+t=kJdG\:-+V8C_xtDGjQKw+ZLrk.*QDuR^6.rt[ZRzy,,U7_0q(.„U"NowE0GEo.zrXo;;)DHn9&Pv21I68tz+Mx'm<p6Ax/0d1&y-qB>TcxS)7r8n,]$m„U">+rlo$6azJ1]U?8,RxLd1Fy/:4d.EK81NmB;TzjxX0b.dNd)xYWa3B)bN=KrqW,„U"Kql>d3F-e^PwJx:U3r-RimF(UA(5=TQ;It[??W?A.kAY/oE=/;-sY=J^zrvQ(9A„U"XR[6hMz^SARjM(uPnC)<;?.q0,x2K;Zn#YfSf:k]cK7u)ybXTFMwGY-<>\c.9)\„U"i&ckGxERx9C*J0C&WvyLI]%_JIYo%Q>?0AR96F[b+oT/LK2WE'&IGM_<J3K7.GT„U"oj3[(E_K83l,E6B3%vYe8%yR)j$T7%Ih>DR*5qe3/c?VOJfwc4qk6at\L]8Ey>9„U"*q0T3a-S?g3Es3%A5*B&sWqBY]fU5J']MBiBK2PgOGW>.Wn=nKpi;gujrx#n*2R„U":a%?l3^p_CAZ9Bnkp+eRY_8$FhlsQ],RiVPnC/XDoG5_spvh,?-v-5=3;9Aup*S„U"Q5[r37H;IRzF*H]Kp;SKVHVy-iSP'?>ro31x<ylhJ\iNp+nQ&Sy2wwPI1F'tb&i„U":7ScB1jRC9Z3nB?s7Jzpi'JGQUSs/n4I_h$Pie;U[Hwhagje]9?J%S+vAnLIBV3„U"sIwE_eI37rzRu#%Jo4=^]EF0$38^qs\J0X01,TMfU4P,/Al)fUbFEhnWa?#.9z$„U"b'tI9M>vSTfBKdU4Uf^d.N^qrdBP(WCa4uc(M_Uq%BWY?Ah8#cDfR/s3W&mh\a7„U"K/ivgrFY7_7;A.1Xo>#0g'$Pv,/m)s7)^Vx%XBp%zZmAJ*d/SMuX7h,CRmUdxmo„U"\dwlYNxtNuufhxis>d-OsT>.n.[HTf5zT5Tf1X_6C0V:I3j1acLiLNuii(^(2Ny„U"29($^2$xp?gXgv:aYUx2<?<x&?scVIiTXz<&bv^]wVV9qA4h<Nza2ptCO#wj=kG„U"1p^9XyDfc$nz,Z5fXDiT0zNc7FY/+Z8B][OFO6f=gEJKkscc_RO$M#K+$geUnoU„U"l7/AR*g%V:6>Q.\%%-s/LUa?&J/0VFf,\q;QQaOWp#NhZ%Krre2.t_=FJJ6h(B1„U"AtaJB/bOxffk?Y[Yx+m_vOPb,t5mTX)U#LZVJGh**NS>bh3WYary[Q:BP0Jnc#J„U"BMDyIsn[thBpi6:I52*5*Q/iXg-,+;'?bwKMt7UgF,&&8Q0.Q9^*dk.1GgVLXy[„U"[uOubU.B,mz'X4:kH-F_M^AWV%g&:X]3&K-&JJRM12X?J^QZ.L%PskP;Qagb)_=„U"%uCoSPCnBA>Hd)[pHElrPgKC>IN%iK8IoZCQo+2]lh/rFu^DU+5u\m=6(,(L)y+„U"J5OAgPb;eCj[0%KjtOQ:QW3CZe4%h_Xl^>x:_xJ?1T='r4OtDS<+o>*+e+HwH<)„U"yjIq0212:2Yo,Y$xkuK\f&rr+(?sO\Lq^%W+t''qCHC*nB(1ipoU$;r)+ao+uBc„U"8kEabZx-F?F9%]3'gu_)wGZpU3gC5UZ(I&*]oKAYXB,f1N7Hob7Gc7,tWwn%6ad„U"rqiuiTLHVe3FNkYsDagRII^]qaao>UE7qgWF9d$Crk-9m;pV1%EF[lOnI+IvvMu„U"pU#DW('5SRG7d'1w<cRmz_ME$w,usJTBWnXoC^b0Rcd9/BWq#vdNQ4\Yb[1q+N9„U"u0k=.XR-J3f-'PAYJntHE2K70hB.Rf8R<(xr_]*9ik%H3VfgkFk&fz[T'<vEZ.K„U"-ZqcYWugrJBXE3,q-a2UaxSAh8rVkMv=Pz1&.S+n*J2+FY$UYVV9erkEZqI<3XH„U"rnr#u#>aw;K0f=iJx,Ur^?x,Z?,<6Zix\bo$,#x6v8bbPA+NG$Uy\%+/i'wU?:5„U"IaoB>l5hZ&\.A*5+?jIm+*1_wEA>;sWhy2Xp\0zf;(3+\qrr#j'1E%*+lGMtRLz„U"4;(Ci-JN(.vc;PQBPbBsNG,XGQC8FMInAFXK[v8'Nfs[;s>oCmR1U<f:%MFjKcP„U"kZUZg2OS(j1S.XxM5IA$.A*y54P>,WL7'%Y'*56zJQ/ku:#C=GY,*eH&]CNO+zE„U"<EueTVTXs8PLN%s5-&S(qmD;n<:#pr_*rCQp,8]d>47^I)TgF;jAhfNo^]<OtrU„U"qtSf,uc>lD^Wp9>,20u_DswnJ+;EYVl4.u^9+nnBWGrABfb7r:e32+nirGC(=zw„U"uq31d<NN[lg([Pm1QuN;Qe:mE&=?Nq1?,KM-n4/&NrKKHZTEfx0j(5i)m*iV<M9„U"zLp.Yidlq+HJW#$>gx+OT&h7vg8R1u?DL[*vN(;Ac#/nnxf%l-Trx[6]h7)x#-K„U"<%KHk4sba73Zw&bBDw>p87q2eIYIItW'k.lIa)5O,=PDK=klU-iA&^:)POeB^w#„U"7xRf+\-,nI7T1g)QoBYY4eV963$nti%5UMY5(p6(J2cq-M+suel3+:9NdTLS;q5„U"^S'9=<Psbk[UPl1j>I:U*D-N\-7eJhtm#vhf2t(2AX_I7'P*;AZ<)Q\fJ<:0k3&„U"XddGBA'KAk6VVH(ntNG]v8l_(0HQR7>bQ(2/(cKwE#-)\*&QE2qHedo-%OhGI7j„U"H.SV=inBuHWKt(4(ko14ufba,Zw#J,[\1DV+Tr,hvX>n$W^-JaRY&3<,mEu]HY#„U"bYK7MM?tyQhx(yfQAdRqras8<M#+WnQf=nc?DJ0y4v8fkl^NKbkY7)RZ5Y&a9v^„U"(Lb)''>8cMDSMvy]8Q/O6UJw5*)RQOL&szC=7>Ta$2_XTb*bjMNoWKd.sT(nmcr„U"):?4:xj,W9_o'iKDV1Ae=z<Q9]>A^Ru0(N3R+;-,X%$F:^bfp/w<_7:.TPj8y&3„U"N1oM>ls=&F,UfX*LR[m/2i.0JZ>sJTB=;p$Ts\n8aX\HDk=/FlrU5i<=624/hux„U"DWdgyNbQXn$<+D4S\8NeWn;%o>#^QQipY6**/CS=(d?1p/\'lv:UO#]M,fdDef7„U",p(oAG(qhki^:?W+PZgMtL-2xAjw%>#[f=Cjo1W83UqN.4+iE8;S0,)O(wAZ]wJ„U"=9-TFyQuRDu^F;vp&501H:TSJ;o*jC0sBY5o?oQ/=r/o9XR)gPhMCj1#EF=5S26„U"AP*UCIsNsj)TAWt6MD?OSrZ]#z)GX]KNtHP2l3dqyhfg-.Mv8a$IqD<^7oe4dNd„U"?flLo7EfXE\2PvxQ4C][J]-KcZVs0'JA#xIG:0.W,uqdE>R:xDx(_bq1liHBJG2„U"3nmnF^(E1(%uxb-[.4_FxOZaeZl%KU]DqL&sW1f1X1*cun/\Y&jK-2=1NwmkA5w„U"O$=FNtyw&39sdnzQf$vMVUp9<K=L:s:I7XrnYV+E5j*\3*l(oL1-KO>Ow?(]g*C„U"z^<81M<.ptmOIqxS/'pDdnB=qe?smN='m3HP7Frb#*jUb&vSyib8oCIVgF?.KC[„U"7WQ'*Ravb%Uzg/=0Zb6:QDgVX?_RH<:lJv%=A3V#_Knz8'3SZt=_$tjsZm'k<0:„U"#Wb??3Rkp:t$d\:Mk)EB$++VW2l3DHTP2l7Z5jP5x]Fb]94Jln-q*zV&B[8r#-,„U"79WM^Q1'+Qw)7hvm3+%m:IxVey/(LvyXt1kw47pbDh%IPnvNk(2n3$<-WJ]Kp72„U"pmsLthAZ>R(:Ej;2wdz3JKG>*I>6SaPt63Fi*#n8fhs6_ZXi32?6e]K\QfXK-dD„U"KN';HgWjq#$b#RAb;(WoAo=gADlIgU?%2<O$<,XA7mX'sNW$-p+:&kffG+v'mz]„U"jG6<RHwME[BxDgO#GRX5J$1WqOQ\s_2>^:iE-(Sp:9>sL?]w^.):LDd'W)#93'e„U"]Mg^oi:6cIyW9i5l)QQn,UXYWyh$dw9Doi6kZO*A2VW'Ev#7lnLtQE>mNU3SmFv„U"9h7p2J+uj>=\,CZEItS0xC>VJiU(C2sS0+jDvA3Kkab;(?n7b?47U>Kb>SY3/L<„U"4Egee&KOFsP3.r[JBsDT1#.HvH0uFnI?hMc<4x%o=xW.i,gDdzR9\?;L/4SNoV^„U"vLPN>km/w:Vw=E:(bdJMtsJ.Ux><Z5<SaUl3UfI-K_i#*#kf0Jku'P/6Z5#<GkG„U"o[\;ZwuBhotd8>8uuL;\SM%qK+-sX,c2c*Q'(<RJ0K>k2aI2hdcleo4#Y>3tXRY„U"9DVy5y_$>n.gfmyPj#[1rR<ilU$co?P(M:Oa)Pjfn]3zpjKWOW%995>):qUPPqg„U"pPoFcBTspIP+p*:+Jb<ZD6(I7,)&;Pyp*r4qXeN/I&lM>YE\APUl3k&vl>?^^D/„U"f[WA\>7_WfR>>w^km^7&Uf\m$H'p.C<1tW8/RSE0-wYnGmYw6XJCSUw(t2XL(&&„U"Y:h7el:2z&x>2SOY^5TXE+?vGd\E8?/^[Ihe.ewECL%C;-#/NGEvN*LlZkpR*un„U"F\\63+MKIeZVEDfZ#X+7<qVVon-O&qY6M#/N[lC#Tps^2fv?Ktl7%]1gVjlTXTr„U"rp]D;^U11'8_U:wq#thkpcOV[Q08ORPN)N41Y>;w_F.5OjQ9b89R+-N\BPjuze(„U"Fe\MkL80Qgsjo291f6*^n*v-wR'biX):g2+,f%]xi%xB=)3&aohbq^NYr)WT.Ve„U"Q9wrs6jA\D*UWf3KxKO_E_.gXO99CM.k;mWqcB:vmp/UPPjZL,#/u:kk%^w496y„U"Gnp'_8C+%CKSq5\b=Z1x6kO38l$Yh(fw;>JSfBjP#r?^<O0YVV?7'V>+VHn5Zp5„U"333vp)f2LHCFsDQ.0E:Fz3\AB:Dz,TJb3EEp%HFN().^W+)QyKa1tT4Lh)r*BMa„U"wXB%rtOiV9fuOcNnfgMt#=K=[T28<^\aA^-:o%NwtfHkuWIl_UPm\^gVqXw^PtD„U"#hB8OcInimMl0[k[ZA.C&9a6&K>4urpJ03b'fr#>wLz4ql\c]m4p1]XIPM%jCRK„U"DCEnm\guN;B2WieFu?wpOJw7B1%,Gh4d%4,OoPPfTho,F#ZaXNj<wUqr;2bmm+D„U",JuIG,NWB\+VnCV$-qVkVUI)j?z[L8PAH]V6H:$_/8eXw7*s:%\X&x<W_D(zDb_„U"QJm8/>;?g$1QY.fem_AlnkdjB4AJE$1lf$kWDd\j>nvi.Qw*XZ8,Esgteya[7hW„U"S::LHm&SdQ9kZ:+u0rRykmWO0]sh9+-Iu*K<1zted%6Kgl/$vlS:L:/]$$(Jc$Z„U";ciJQmp<&lHZ[(9&T#SvYN*2sQ2q0(E0;+jIlKNE=hhKr&(h3[vK1bW)Zk%WWV5„U"pKi_5oAt=EpK0cF/cWB\pK/_$1>c6v.KWHh.TP4XM>]i4]>pX^3+S0Ztr]o3pm>„U"e&js4a;ZmO>fUr&$BSBVDQsycg'RcPNdZ*U\_Z8=uPfEJhU4_T*CDm9iLV?u(Ds„U"Ztv_#$W]>byc?N[?C8+3qTrPA4MmJ6i0RN:_#qiBhVav'eRuKRgW8iY/hlC<:bU„U"HsT2wq.#BHJK0'Z=+(wkLJ-fFl?n5b)[PdTjdlrY45fW*9Fx8RVS_T=Nbj<Nx4K„U"X5quk)qn2]h^bb7/pvmTstXGKK5L3M'q[SB,vf4IvNi?;x#Bjx^Xwn(kVcouMr6„U"bcM*J,.t)npOP]u7]hbt:XcxU=hbHW5;1b.*>]7%<]IQL]4nIb>arBe1t3yuNks„U"5;R<V_z;CfM>(wAQE1KvO-sl[aI7A+KaG&kWhb9'PG,%kauJN)7N^mHAE;9Bt:N„U"%]8B0DJjw#ty%d-N,O,k\<r\AbtdJ$oKdVVIz3pk5+_gdM$Xx3gt$Z-]>DJdv]u„U"^3#XukJ8hZ=X,br;47Yh^J>S.YKkONE9b>O\UF])_#2[t=((4\,\AVt)bsl,UHI„U"XeV)q8f[8hQ.M&K?]<[vsU>nv^G.dtcS,:j\<tHWmwlnM.hw\M8SVhYx5+p.Vw1„U"ni9NVQ?fe+lE8=pkj<-X#6xTA#\I:hRW:)ZeXOX2FbFws*GdFD>S/.Ptpan?G<r„U"&*k=T,5gf9;SbK2yIY1h>8*R[Qk%oOG:W%*wW*rajxBn:lq1NyspaWl,X8cF.h<„U"Ge'\OFDT(eV0:?H;FXGX6q=2gV+CFU,$0d(dE*rNow=1n^ROlLh'2B0srzlt=3<„U"GRJ>)TjQT%Xtcq+fBaD]p[2onRRlmj9K:.,WVbkluJkFJc0S,[G?k$0Dkte%vXT„U"]<C6ZV<;l/5t.frxT$L\s98Q6/SD+pMOa9t)T;PWd-nLytYL>iK*0-,*E<O3k5C„U"b4p+W9vTuBGRmgw4W[y7Oo&ws5T_[2$t6p&29Re0qAv,fOAiw&l>\al\MP;Q$m*„U"%^c;Au-[#J$eR(Zc1I?:2r)dOo:2Y;>y4%=hH%GHxdo9eB_qH=Q'c>8-kZjC;VP„U"wZjYXdBV:giSDZme:PjX(8gZ1D:XhnF?q:bkjT\2sxY6?daS]hW5s3qy$:)O^ek„U"Z3Z\:ujz/)9'dbm1l'O&.(?H/NW)t^i0?f++Db^.>qnaAnrrfF9.oVS>q7?,F9i„U";:(O,$_FJT50uchAS]L6#?jlY:wT=u)wF19[8^%u^z3%nsd0-hx'u%p&'9%%9%%„U"#%-%,[yRE%tSbcR[$%%i'Y%%1%%%%%%%%%&%%E%%%%%%%%%fwi%fkWU%VSgf%xu„U"p*%+%%%%%&%&%%_%%%%(a%%%%%„END SUB„V2„CLOSE:IF S=155AND B&=Z&THEN?" :) Ok!"ELSE?" :( Bad!„SUB U(A$):FOR A=1TO LEN(A$):C=ASC(MID$(A$,A))-37:IF C<0THEN C=91+C*32„IF K<4THEN K=C+243ELSE?#1,CHR$(C+(K MOD 3)*86);:K=K\3:B&=B&+1„S=(S+C)AND 255:NEXT:LOCATE,1:?STRING$(B&*50\Z&,219);:END SUB„Craig W. Uthe                  NORMAL DISTRIBUTION ROUTINES   Rolf@ice.prima.ruhr.de         03-03-82 (12:00)       QB, QBasic, PDS        131  7424     NORMAL-Z.BAS100  '**********************************************************************„110  '********                                                   ***********„120  '********           NORMAL DISTRIBUTION ROUTINES            ***********„130  '********                                                   ***********„140  '**********************************************************************„150  '            *   COPYRIGHT 1982 - CRAIG W. UTHE          *„160  '            *   WRITTEN 3/3/82 BY CRAIG W. UTHE         *„170  '            *                 * * * *                   *„180  '            *   ANY INDIVIDUAL MAY COPY THIS PROGRAM    *„190  '            *   AND MAKE MODIFICATIONS TO IT IF THAT    *„200  '            *   INDIVIDUAL ARRANGES TO CONTRIBUTE ONE   *„210  '            *   OTHER PROGRAM TO THE PHILA. AREA IBM    *„215  '            *   PC USER GROUP PUBLIC DOMAIN SOFTWARE    *„220  '            *   EXCHANGE LIBRARY.  HOWEVER, COPIES      *„230  '            *   ARE NOT ALLOWED TO BE SOLD, NOT IN      *„240  '            *   WHOLE NOR IN PART, NOT SEPARATELY       *„250  '            *   NOR JOINTLY WITH OTHER SOFTWARE.        *„260  '            *********************************************„270  '„280  '„1000 'MASTER-CONTROL ROUTINE„1010     CLS„1020     PRINT "This program computes areas under the normal distribution"„1030     PRINT "probability curve from the mean to a designated `Z' value."„1040     PRINT "This program also can compute `Z' values from a given area."„1050     PRINT„1060     PRINT "Just as in most statistical tables, only half the curve is„1070     PRINT "considered.  Z values must be between -4 and +4 (these"„1080     PRINT "limits are somewhat arbitrary) and area figures must be"„1090     PRINT "between 0 and 0.5 (actually .49997).  If out-of-range"„1100     PRINT "figures are input, the nearest range limit is assumed"„1110     PRINT "instead."„1120     PRINT„1130     PRINT "HIT ANY KEY TO START"„1140     SELECTION$ = INKEY$ : IF SELECTION$ = "" THEN GOTO 1140 'SAME LINE„1150     ' Area results (given Z) are accurate to the 5 displayed digits.„1160     ' Z values are accurate to 2 digits based on an input area,„1170     ' or the 3 displayed digits based on the program's approximation„1180     ' of that area.„1190     '„1200     ' This precision can be changed by changing the precision„1210     ' constants in the program from their 0.000001 setting.„1220     ' For higher precision, you might also want to change the„1230     ' variables to double, instead of single, precision form.„1240     ' With higher precision, you may wish to change the number„1250     ' of digits displayed, too.„1260     '„1270     ' Out of respect, please do not mutilate the structured„1280     ' programming approach that makes changes so easy and„1290     ' makes the program almost readable.  Of course you can„1300     ' easily use the subroutines in more elaborate programs.„1310     ' This program is fairly insignificant by itself.„1320     '„1330     SELECTION$ = "1" 'initialization„1340     WHILE (SELECTION$ = "1" OR SELECTION$ = "2")„1350         CLS : PRINT STRING$(60,42)„1360         PRINT : PRINT "MENU:"„1370         PRINT : PRINT "     <1> . . . . . . . . COMPUTE AREA FROM Z"„1380         PRINT : PRINT "     <2> . . . . . . . . COMPUTE Z VALUE FROM AREA"„1390         PRINT : PRINT "     <ANY OTHER KEY> . . EXIT PROGRAM"„1400         PRINT : PRINT STRING$(60,45)„1410         PRINT : PRINT "HIT ANY KEY IN INDICATED RANGE TO MAKE SELECTION:"„1420         SELECTION$ = INKEY$ : IF SELECTION$ = "" THEN GOTO 1420 'SAME LINE„1430         CLS : PRINT "THANK YOU."„1440         IF 0 = INSTR("12",SELECTION$)                                                       THEN : PRINT "I HOPE THE PROGRAM WAS USEFUL TO YOU.  BYE."                             : GOTO 1480 'WEND„1450         ON INSTR("12",SELECTION$) GOSUB 3000,2000„1460             'IE:  IF 1, GOSUB COMPUTE-Z-FROM-AREA ROUTINE„1470             '     IF 2, GOSUB COMPUTE-AREA-FROM-Z ROUTINE„1480         WEND„1490     END„1500 '„1510 '„2000 'COMPUTE-Z-FROM-AREA ROUTINE„2010     PRINT : PRINT STRING$(80,42) : PRINT„2020     QUIT% = 0„2030     WHILE NOT QUIT%„2040            PRINT "INPUT AREA VALUE FROM WHICH TO COMPUTE FREQUENCY."„2050            PRINT "(ENTRIES OVER 5.0 CAUSE RETURN TO MENU.)"„2060            INPUT "INPUT AREA VALUE (0 TO 0.49997): ",AREA„2070            IF AREA > 5 THEN QUIT% = -1 : GOTO 2230 'WEND„2080            HI.CALCULATED.AREA = .49997 : HI.Z = 4  '*** area < .49997„2090            LO.CALCULATED.AREA = 0      : LO.Z = 0  '*** area > 0„2100            IF AREA >= .49997 THEN CALCULATED.AREA = .49997 : Z = 4                                                 : GOTO 2170„2110            IF AREA <= 0 THEN CALCULATED.AREA = 0 : Z = 0 : GOTO 2170 'PRNT„2120            WHILE ABS(CALCULATED.AREA - AREA) > .000001„2130                    IF AREA > CALCULATED.AREA                                                          THEN LO.CALCULATED.AREA = CALCULATED.AREA : LO.Z = Z                            ELSE HI.CALCULATED.AREA = CALCULATED.AREA : HI.Z = Z„2140                    Z = (LO.Z + HI.Z) / 2„2150                    GOSUB 4000 'McLAUREN-METHOD-AREA-CALCULATION ROUTINE„2160                    WEND„2170            PRINT : PRINT "THE NORMAL-DISTRIBUTION Z-VALUE CORRESPONDING"„2180                    PRINT "TO A MEAN-TO-Z AREA OF ";„2190                    PRINT USING "#.#####"; CALCULATED.AREA;„2200                    PRINT " is:  ";„2210                    PRINT USING "#.###"; Z„2220            PRINT : PRINT STRING$(80,42) : PRINT„2230            WEND„2240     RETURN„2250 '„3000 'COMPUTE-AREA-FROM-Z ROUTINE„3010     PRINT : PRINT STRING$(80,42) : PRINT„3020     QUIT% = 0„3030     WHILE NOT QUIT%„3040            PRINT "INPUT Z VALUE FROM WHICH TO COMPUTE FREQUENCY."„3050            PRINT "(ENTRIES OVER 5.0 CAUSE RETURN TO MENU.)"„3060            INPUT "INPUT Z VALUE (-4.0 TO +4.0):  ", Z„3070            IF Z >= 5 THEN QUIT% = -1 : GOTO 3150 'WEND„3080            IF ABS(Z) >= 4 THEN CALCULATED.AREA = .49997 : Z.SGN% = SGN(Z)                                  : Z = 4 :GOTO 3100 'PRINT OUTPUT„3090            GOSUB 4000 'McLAUREN-METHOD-AREA-CALCULATION ROUTINE„3100            PRINT :PRINT "THE AREA UNDER THE NORMAL DISTRIBUTION CURVE"„3110                    PRINT "FROM THE MEAN TO Z = " Z.SGN%*Z " IS:  ";„3120                    PRINT USING "#.#####"; CALCULATED.AREA„3130            PRINT„3140            PRINT : PRINT STRING$(80,42) : PRINT„3150            WEND„3160     RETURN„3170 '„4000 'McLAUREN-METHOD-AREA-CALCULATION ROUTINE„4010     '„4020     Z.SGN% = SGN(Z) : Z = ABS(Z) : Z.SQR = Z*Z„4030     CALCULATED.AREA = Z * (1/SQR(2*3.141592654#))„4040     Z.CONSTANT = CALCULATED.AREA„4050     PRECISION.ERROR = 1 : INTERMEDIATE.TERM = 1 : I% = 1„4060     '„4070     WHILE ABS(PRECISION.ERROR) > .000001„4080            INTERMEDIATE.TERM = -(INTERMEDIATE.TERM * Z.SQR) / (2*I%)„4090            PRECISION.ERROR = Z.CONSTANT * (INTERMEDIATE.TERM / (2*I% + 1))„4100            CALCULATED.AREA = CALCULATED.AREA + PRECISION.ERROR„4110            I% = I% + 1„4120            WEND„4130            CALCULATED.AREA = CALCULATED.AREA - PRECISION.ERROR„4140     RETURN„Jeff S. Root                   ROMAN TO ARABIC # TRANSLATOR   FidoNet QUIK_BAS Echo          02-11-96 (10:30)       QB, QBasic, PDS        92   3371     ROMANUM.BAS ' > > 1. There are 7 letters:„' > >    I=1, V=5, X=10, L=50, C=100, D=500, M=1000„ „' > There are actually 14; their case determines their value.„' > I forget the values for the caps, but "I" is not 1, "i" is.„ „'Hello, <Mr. Person>!„ „'What you said there was completely wrong.  I've seen both cap„'and lower case Roman numerals in a lot of situations, and the„'case never had any affect on the values.„ „'In fact, lower-case letters were not invented until the Middle„'Ages, well after the Roman Empire had dissolved.  And until a„'couple of hundred years ago, there was no subtraction in Roman„'numbers.  The number "4" was always written as "IIII", and "9"„'was always written as "VIIII", for example.  The shorthand use„'of "IV" and "IX" is a relatively recent invention.  The old„'form is easier for doing calculations.„ „'Here's a program I wrote recently for a little contest:„ „ ' ROMANUM.BAS * Roman to Arabic number translator„ ' Copyright MCMXCV by Jeff S. Root, Minneapolis, MN„ ' FREEWARE * Unlimited use and distribution * QBASIC„ „ DEFINT A-Z: DIM Num(22)„ „ CLS : PRINT„ DO„   Roman$ = "": Arabic = 0: BadFlag = 0: ERASE Num„   PRINT "Roman numerals: ";„   LOCATE , , 1, 12, 13       'Cursor on„   DO„     DO: k$ = UCASE$(INKEY$): LOOP WHILE k$ = ""„     IF k$ = CHR$(27) THEN Roman$ = "": EXIT DO  'Esc„     IF k$ = CHR$(8) AND Roman$ > "" THEN„       Roman$ = LEFT$(Roman$, LEN(Roman$) - 1)   'Backspace„       PRINT CHR$(29); " "; CHR$(29);„     ELSEIF INSTR(1, "IVXLCDM", k$) THEN„       IF LEN(Roman$) < 21 THEN„         Roman$ = Roman$ + k$: PRINT k$;         'Add character„       END IF„     END IF„   LOOP UNTIL k$ = CHR$(13)                      'Enter„   LOCATE , 1, 0: PRINT TAB(38); : LOCATE , 1    'Cursor off„ „   IF Roman$ = "" THEN END   'Exit ROMANUM„   FOR n = 1 TO LEN(Roman$)„     SELECT CASE MID$(Roman$, n, 1)„       CASE "I": Num(n) = 1„       CASE "V": Num(n) = 5„       CASE "X": Num(n) = 10„       CASE "L": Num(n) = 50„       CASE "C": Num(n) = 100„       CASE "D": Num(n) = 500„       CASE "M": Num(n) = 1000„     END SELECT„   NEXT n„   FOR n = 1 TO LEN(Roman$) - 1„     IF Num(n) < Num(n + 1) OR Num(n) < Num(n + 2) THEN„       IF INSTR(1, "VLD", MID$(Roman$, n, 1)) THEN„         IF BadFlag = 0 THEN BadFlag = 1„       ELSEIF Num(n - 1) = Num(n) AND Num(n) = Num(n + 1) THEN„         IF BadFlag = 0 THEN BadFlag = 2„       ELSEIF Num(n) = Num(n + 2) THEN„         IF BadFlag = 0 THEN BadFlag = 3„       ELSEIF Num(n) < Num(n + 2) AND Num(n) <> Num(n + 1) THEN„         IF BadFlag = 0 THEN BadFlag = 4„       END IF„       Arabic = Arabic - Num(n)„     ELSE„       Arabic = Arabic + Num(n)„     END IF„   NEXT n„   Arabic = Arabic + Num(n)   'Add final character„   IF BadFlag THEN„     PRINT Roman$; " is bad format:  ";„     SELECT CASE BadFlag„       CASE 1: PRINT "Multiples of five may not be subtracted.";„       CASE 2: PRINT "Only two subtractions allowed together.";„       CASE 3: PRINT "This adds and subtracts the same value.";„       CASE 4: PRINT "Put high values before low values.";„     END SELECT„     LOCATE , 1: SLEEP 4: k$ = INKEY$   'Clear keybuffer„     PRINT TAB(80); : LOCATE , 1„   ELSE„     PRINT CHR$(30);   'Up a line„     PRINT TAB(22 - LEN(Roman$)); Roman$; "  = "; Arabic„     PRINT„   END IF„ LOOP„Aaron Scott Zabudsky           TOLERANCE CALCULATOR           zabudsk@ecf.toronto.edu        02-17-94 (20:30)       QB, QBasic, PDS        155  3967     TOLCALC.BAS DECLARE SUB CLR (x!)„TYPE PrecNumber„   Value AS SINGLE„   Tol AS SINGLE„END TYPE„CLS„LOCATE 2, 1„PRINT "[F]ind average of a set of numbers"„PRINT "[C]hange a number"„PRINT "[A]dd numbers together"„PRINT "[M]ultiply numbers together"„PRINT "[D]ivide numbers"„PRINT "[R]aise number to a power"„PRINT "[T]ransfer buffer to number"„PRINT„PRINT "Current Values Entered"„„DIM Buff AS PrecNumber„DIM Nums(10) AS PrecNumber„num = 0„Buff.Value = 0„Buff.Tol = 0„FOR counter = 1 TO 10„PRINT USING "## "; counter;„PRINT Nums(counter).Value; "Ò"; Nums(counter).Tol„NEXT counter„PRINT "ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ";„PRINT„PRINT "Buffer: "; Buff.Value; "Ò"; Buff.Tol„a$ = ""„WHILE a$ <> "Q" AND a$ <> CHR$(27)„a$ = ""„WHILE a$ = ""„a$ = UCASE$(INKEY$)„WEND„IF a$ = "C" THEN„   LOCATE 23, 1„   INPUT "Change number: ", t„   CLR 23„   LOCATE 23, 1„   INPUT "Value: ", Nums(t).Value„   CLR 23„   LOCATE 23, 1„   INPUT "Tolerance: ", Nums(t).Tol„   CLR 23„   CLR 10 + t„   LOCATE 10 + t, 1„   PRINT USING "## "; t;„   PRINT Nums(t).Value; "Ò"; Nums(t).Tol„END IF„IF a$ = "A" THEN„   LOCATE 23, 1„   INPUT "First Number (0 for buffer): ", t„   CLR 23„   LOCATE 23, 1„   INPUT "Second Number (0 for buffer): ", u„   CLR 23„   IF (t <> 0) AND (u <> 0) THEN„      Buff.Value = Nums(t).Value + Nums(u).Value„      Buff.Tol = SQR(Nums(t).Tol ^ 2 + Nums(u).Tol ^ 2)„   ELSE„      IF t = 0 AND u <> 0 THEN„         Buff.Value = Buff.Value + Nums(u).Value„         Buff.Tol = SQR(Buff.Tol ^ 2 + Nums(u).Tol ^ 2)„      END IF„      IF t <> 0 AND u = 0 THEN„         Buff.Value = Buff.Value + Nums(t).Value„         Buff.Tol = SQR(Buff.Tol ^ 2 + Nums(t).Tol ^ 2)„      END IF„      IF t = 0 AND u = 0 THEN„         Buff.Value = Buff.Value * 2„         Buff.Tol = SQR(2 * (Buff.Tol ^ 2))„      END IF„  „   END IF„   „   CLR 22„   LOCATE 22, 1„   PRINT "Buffer: "; Buff.Value; "Ò"; Buff.Tol„END IF„IF a$ = "F" THEN„   TotVal = 0„   TotTol = 0„   t = 1„   Number = 0„   WHILE t <> 0„      LOCATE 23, 1„      INPUT "Enter line to average: ", t„      TotVal = TotVal + Nums(t).Value„      TotTol = TotTol + Nums(t).Tol ^ 2„      Number = Number + 1„      CLR 23„   WEND„   Number = Number - 1„   IF Number > 0 THEN„      Buff.Value = TotVal / Number„      Buff.Tol = SQR(TotTol) / Number„      CLR 22„      LOCATE 22, 1„      PRINT "Buffer: "; Buff.Value; "Ò"; Buff.Tol„   END IF„END IF„IF a$ = "T" THEN„   LOCATE 23, 1„   INPUT "Enter destination line for buffer: ", t„   Nums(t).Value = Buff.Value„   Nums(t).Tol = Buff.Tol„   CLR 23„   CLR 10 + t„   LOCATE 10 + t, 1„   PRINT USING "## "; t;„   PRINT Nums(t).Value; "Ò"; Nums(t).Tol„END IF„IF a$ = "M" OR a$ = "D" THEN„   LOCATE 23, 1„   IF a$ = "D" THEN PRINT "Numerator or ";„   INPUT "First Number: ", t„   CLR 23„   LOCATE 23, 1„   IF a$ = "D" THEN PRINT "Denominator or ";„   INPUT "Second Number: ", u„   CLR 23„   IF a$ = "M" THEN Buff.Value = Nums(t).Value * Nums(u).Value„   IF a$ = "D" THEN Buff.Value = Nums(t).Value / Nums(u).Value„   IF Nums(t).Tol <> 0 AND Nums(u).Tol <> 0 THEN Buff.Tol = Buff.Value * SQR((Nums(t).Tol / Nums(t).Value) ^ 2 + (Nums(u).Tol / Nums(u).Value) ^ 2)„   IF Nums(t).Tol = 0 AND Nums(u).Tol <> 0 THEN Buff.Tol = Nums(t).Value * Nums(u).Tol„   IF Nums(u).Tol = 0 THEN Buff.Tol = Nums(u).Value * Nums(t).Tol„   CLR 22„   LOCATE 22, 1„   PRINT "Buffer: "; Buff.Value; "Ò"; Buff.Tol„END IF„IF a$ = "R" THEN„   LOCATE 23, 1„   INPUT "Line Number to use as a Base: ", t„   CLR 23„   LOCATE 23, 1„   INPUT "Exponent: ", ex„   CLR 23„   Buff.Value = Nums(t).Value ^ ex„   Buff.Tol = Buff.Value * ABS(ex) * (Nums(t).Tol / Nums(t).Value)„   CLR 22„   LOCATE 22, 1„   PRINT "Buffer: "; Buff.Value; "Ò"; Buff.Tol„END IF„WEND„„„SUB CLR (x)„b = CSRLIN„a = POS(0)„LOCATE x, 1„PRINT SPACE$(80);„LOCATE b, a„END SUB„„Aaron Scott Zabudsky           GRAPHING PROGRAM               zabudsk@ecf.toronto.edu        12-27-95 (00:13)       QB, QBasic, PDS        164  4408     GRAPH.BAS   DECLARE SUB pprint (x!, y!, A$)„SCREEN 12„PALETTE 0, 63 + 256 * 63 + 65536 * 63„PALETTE 15, 0„sx = 640„sy = 480„axisc = 12„gridc = 9„autounits = 1„xunitovr = .2„yunitovr = .2„xmin = -5„xmax = 5„ymin = -5„ymax = 5„„IF xmin <= 0 AND xmax >= 0 THEN„   LINE (((0 - xmin) / (xmax - xmin)) * sx - 1, 0)-(((0 - xmin) / (xmax - xmin)) * sx + 1, sy), axisc, BF„END IF„IF ymin <= 0 AND ymax >= 0 THEN„   LINE (0, sy - ((0 - ymin) / (ymax - ymin)) * sy - 1)-(sx, sy - ((0 - ymin) / (ymax - ymin)) * sy + 1), axisc, BF„END IF„„IF autounits = 1 THEN„   xunitovr = (xmax - xmin) / 10„   yunitovr = (ymax - ymin) / 10„   rx = 0„   ry = 0„   IF xunitovr < 1 THEN„      WHILE xunitovr < 1„         xunitovr = xunitovr * 10„         rx = rx - 1„      WEND„   END IF„   IF xunitovr >= 10 THEN„      WHILE xunitovr >= 10„         xunitovr = xunitovr / 10„         rx = rx + 1„      WEND„   END IF„   IF xunitovr < 1.5 THEN xunitovr = 1„   IF xunitovr >= 1.5 AND xunitovr < 3.5 THEN xunitovr = 2„   IF xunitovr >= 3.5 AND xunitovr < 7.5 THEN xunitovr = 5„   IF xunitovr >= 7.5 THEN xunitovr = 10„   xunitovr = xunitovr * 10 ^ rx„   IF yunitovr < 1 THEN„      WHILE yunitovr < 1„         yunitovr = yunitovr * 10„         ry = ry - 1„      WEND„   END IF„   IF yunitovr >= 10 THEN„      WHILE yunitovr >= 10„         yunitovr = yunitovr / 10„         ry = ry + 1„      WEND„   END IF„„   IF yunitovr < 1.5 THEN yunitovr = 1„   IF yunitovr >= 1.5 AND yunitovr < 3.5 THEN yunitovr = 2„   IF yunitovr >= 3.5 AND yunitovr < 7.5 THEN yunitovr = 5„   IF yunitovr >= 7.5 THEN yunitovr = 10„   yunitovr = yunitovr * 10 ^ ry„END IF„„„„FOR x = (INT(xmin / xunitovr) - 1) * xunitovr TO (INT(xmax / xunitovr) + 1) * xunitovr STEP xunitovr„   LINE ((x - xmin) / (xmax - xmin) * sx, 0)-((x - xmin) / (xmax - xmin) * sx, sy), gridc„NEXT x„FOR y = (INT(ymin / yunitovr) - 1) * yunitovr TO (INT(ymax / yunitovr) + 1) * yunitovr STEP yunitovr„   LINE (0, sy - ((y - ymin) / (ymax - ymin)) * sy)-(sx, sy - ((y - ymin) / (ymax - ymin)) * sy), gridc„NEXT y„x = 50„y = 50„c = 0„WHILE c < 3„x = x + 1„IF c = 1 THEN xb = x + 1„IF POINT(x, y) = axisc THEN c = 0„IF POINT(x, y) = gridc THEN c = c + 1„WEND„c = 0„x = xb„WHILE c < 3„y = y + 1„IF c = 1 THEN yb = y + 1„IF POINT(x, y) = axisc THEN c = 0„IF POINT(x, y) = gridc THEN c = c + 1„WEND„xb = xb + 16„yb = yb + 32„fx = INT(xb / 8)„fy = INT(yb / 16)„xb = fx * 8„yb = fy * 16„IF xmin <= 0 AND xmax - xunitovr >= 0 THEN„   px = ((0 - xmin) / (xmax - xmin)) * sx„   FOR y = 20 TO sy„      IF POINT(px + 2, y) = gridc THEN pprint px, y - 19, STR$(INT((((sy - y) * (ymax - ymin)) / sy + ymin) / yunitovr + yunitovr * .1) * yunitovr)„   NEXT y„ELSE„   FOR y = 20 TO sy„      IF POINT(2, y) = gridc THEN pprint 0, y - 19, STR$(INT((((sy - y) * (ymax - ymin)) / sy + ymin) / yunitovr + yunitovr * .1) * yunitovr)„   NEXT y„END IF„„IF ymin < 0 AND ymax - yunitovr >= 0 THEN„   py = sy - ((0 - ymin) / (ymax - ymin)) * sy„   FOR x = 0 TO sx„      IF POINT(x, py + 2) = gridc THEN pprint x, py + 2, STR$(INT((((x) * (xmax - xmin)) / sx + xmin) / xunitovr + xunitovr * .1) * xunitovr)„   NEXT x„ELSE„   FOR x = 0 TO sx„      IF POINT(x, 2) = gridc THEN pprint x, sy - 18, STR$(INT((((x) * (xmax - xmin)) / sx + xmin) / xunitovr + xunitovr * .1) * xunitovr)„   NEXT x„END IF„„pprint 610, 232, "x"„pprint 308, 10, "y"„pprint 200, 140, "y = x  + 2"„pprint 240, 130, "2"„„rep:„undefval = xmin - 1„xb = xmin„IF xmin <> undefval THEN„   yb = xmin ^ 2 + 2„ELSE skip = 1„END IF„gradx = (xmax - xmin) / sx„FOR x = (xmin + gradx) TO xmax STEP gradx„IF x <> undefval THEN„   y = x ^ 2 + 2„ELSE skip = 1„END IF„„IF y <= ymax AND y >= ymin AND skip = 0 THEN LINE (((xb - xmin) / (xmax - xmin)) * sx, sy - ((yb - ymin) / (ymax - ymin)) * sy)-(((x - xmin) / (xmax - xmin)) * sx, sy - ((y - ymin) / (ymax - ymin)) * sy), 15„yb = y„xb = x„IF skip = 1 THEN skip = 0„NEXT x„„„WHILE INKEY$ = ""„WEND„„GOTO rep„„SUB pprint (x, y, A$)„SHARED fy, fx, xb, yb, sx, sy„DIM B(16)  AS LONG„A$ = LTRIM$(RTRIM$(A$))„FOR d = 1 TO LEN(A$)„LOCATE fy, fx„PRINT MID$(A$, d, 1)„REM LINE (xb - 10, yb - 18)-(xb - 1, yb - 1), 3, B„GET (xb - 9, yb - 17)-(xb - 2, yb - 2), B„IF (x + d * 8) <= sx - 8 AND y <= sy - 16 THEN PUT (x + d * 8, y), B, PSET„NEXT d„LOCATE fy, fx„PRINT " "„END SUB„„Jeff S. Root                   ARABIC TO ROMAN NUMERALS       FidoNet QUIK_BAS Echo          02-22-96 (16:29)       QB, QBasic, PDS        78   2305     ROMANCE.BAS  ' ROMANCE.BAS * Arabic to Roman number translator„ ' Copyright MCMXCV by Jeff S. Root, Minneapolis, MN„ ' FREEWARE * Unlimited use and distribution * QBASIC„ „ DEFINT A-Z„ „ CLS : PRINT„ DO„   Arabic$ = ""„   PRINT "Number: ";„   LOCATE , , 1, 12, 13   'Cursor on„   DO„     DO: k$ = INKEY$: LOOP WHILE LEN(k$) <> 1      'Get input„     IF k$ = CHR$(27) THEN Arabic$ = "": EXIT DO   'Esc„     IF k$ = CHR$(8) AND Arabic$ > "" THEN„       Arabic$ = LEFT$(Arabic$, LEN(Arabic$) - 1)  'Backspace„       PRINT CHR$(29); " "; CHR$(29);„     ELSEIF k$ > "/" AND k$ < ":" THEN             '0-9 are ok„       IF k$ = "0" AND Arabic$ = "" THEN k$ = ""   'No lead 0s„       IF LEN(Arabic$) < 4 THEN„         Arabic$ = Arabic$ + k$: PRINT k$;      'Add character„       END IF„     END IF„   LOOP UNTIL k$ = CHR$(13)                     'Enter„   LOCATE , 1, 0: PRINT TAB(13); : LOCATE , 1   'Cursor off„   IF Arabic$ = "" THEN END                     'Exit ROMANCE„ „   a$ = "": b$ = "": c$ = "": d$ = ""„   n = LEN(Arabic$)„   SELECT CASE MID$(Arabic$, n, 1)„     CASE "1": a$ = "I"„     CASE "2": a$ = "II"„     CASE "3": a$ = "III"„     CASE "4": a$ = "IV"„     CASE "5": a$ = "V"„     CASE "6": a$ = "VI"„     CASE "7": a$ = "VII"„     CASE "8": a$ = "VIII"„     CASE "9": a$ = "IX"„   END SELECT„   n = n - 1„   IF n THEN„     SELECT CASE MID$(Arabic$, n, 1)„       CASE "1": b$ = "X"„       CASE "2": b$ = "XX"„       CASE "3": b$ = "XXX"„       CASE "4": b$ = "XL"„       CASE "5": b$ = "L"„       CASE "6": b$ = "LX"„       CASE "7": b$ = "LXX"„       CASE "8": b$ = "LXXX"„       CASE "9": b$ = "XC"„     END SELECT„     n = n - 1„     IF n THEN„       SELECT CASE MID$(Arabic$, n, 1)„         CASE "1": c$ = "C"„         CASE "2": c$ = "CC"„         CASE "3": c$ = "CCC"„         CASE "4": c$ = "CD"„         CASE "5": c$ = "D"„         CASE "6": c$ = "DC"„         CASE "7": c$ = "DCC"„         CASE "8": c$ = "DCCC"„         CASE "9": c$ = "CM"„       END SELECT„       n = n - 1„       IF n THEN„         n = VAL(MID$(Arabic$, n, 1))„         FOR i = 1 TO n: d$ = d$ + "M": NEXT i„       END IF„     END IF„   END IF„   PRINT CHR$(30);„   PRINT SPC(4 - LEN(Arabic$)); Arabic$; " = ";„   PRINT d$; c$; b$; a$„   PRINT„ LOOP„Dave Gjessing                  MATH TEST                      dgjess@freenet.columbus.oh.us  03-30-96 (00:00)       QB, QBasic, PDS        459  15835    QMATHTST.BASDEFINT A-Z„„'QMATHTST.BAS - a little math test prog based on the„'IFACE_06.BAS text user interface - Dave Gjessing 1996„'(as if *I* know anything about math! <BG>)„„'Thanks to Ken Melvin for contributing the music bits to ABC„'and to William Yu for maintaining same (ABC)„„main:„„DLBox 2, 1, 23, 80, 176, 0, 15, 1, 0„MenuBar 1, 15, 1„DLBox 8, 26, 13, 54, 0, 1, 15, 1, 0„LOCATE 9, 30: PRINT "Addition"„LOCATE 10, 30: PRINT "Subtraction"„LOCATE 11, 30: PRINT "Multiplication"„LOCATE 12, 30: PRINT "Division"„IF TotalProbs! > 0 THEN„        Average! = (TotalCorrect! * 100) / TotalProbs!„        LOCATE 17, 18: PRINT " So far, your average score is  ";„        PRINT USING "###"; Average!;„        PRINT "% correct ";„        END IF„CommandPointer 9, 28, 12, 15, 1, DoLine%„SELECT CASE DoLine%„   CASE 9„   addprobs„   GOTO main„   CASE 10„   subprobs„   GOTO main„   CASE 11„   multprobs„   GOTO main„   CASE 12„   divprobs„   GOTO main„   CASE 610             'F10 key re-initializes score-keeping„   TotalProbs! = 0„   TotalCorrect! = 0„   GOTO main„   CASE 900             'ESC key exits the program„   CLS„   LOCATE 11, 30: PRINT "Thanks for playing!"„   LOCATE 13, 25: PRINT "dgjess@freenet.columbus.oh.us"„   SLEEP 3: CLS„   END„   CASE ELSE            'anything else does nothing„   GOTO main„END SELECT„„SUB addprobs„SHARED TotalProbs!„SHARED TotalCorrect!„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„MenuBar 2, 15, 1„„LOCATE 3, 4: PRINT "Addition test!"„LOCATE 5, 4: PRINT "I, your computer, will be making up addition problems"„LOCATE 6, 4: PRINT "for you, based on the answers you give to the next few questions."„LOCATE 10, 4: INPUT "What is the largest number you want me to use"; tops„LOCATE 12, 4: INPUT "How many problems do you want me to give you (up to 20)"; probs„IF probs > 20 THEN probs = 20„TotalProbs! = TotalProbs! + probs„correct = 0„wrong = 0„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„RANDOMIZE tops„            FOR I% = 1 TO probs„                LOCATE 1, 2: PRINT (probs - I%) + 1; " to go";„                x = INT(RND * tops) + 1„                y = INT(RND * tops) + 1„                answer = x + y„                DLBox 12, 20, 14, 60, 0, 1, 15, 1, 0„                LOCATE 13, 23: PRINT y; " plus "; x; " equals ";„                INPUT try„                IF try = answer THEN correct = correct + 1: PLAY "t240o3l8d#fgl8b-p8l8gl2b-": LOCATE 8, 37: PRINT "RIGHT!": SLEEP 1: LOCATE 8, 37: PRINT "      "„                IF try <> answer THEN„                PLAY "t255l16o1bo4dg#o2f"„                wrong = wrong + 1„                LOCATE 15, 30: PRINT "the answer is "; answer;„                SLEEP 2„                DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„                END IF„                LOCATE 1, 2: PRINT STRING$(40, 0);„            NEXT I%„DLBox 2, 1, 23, 80, 176, 1, 15, 1, 0„DLBox 8, 26, 11, 54, 0, 1, 15, 1, 0„LOCATE 9, 28: PRINT "you got -> "; correct; "correct"„TotalCorrect! = TotalCorrect! + correct„LOCATE 10, 28: PRINT "you got -> "; wrong; "wrong"„IF wrong = 0 THEN BEEP„DLBox 14, 26, 16, 54, 0, 1, 15, 1, 0„LOCATE 15, 28: LINE INPUT "press ENTER to continue "; junk$„„END SUB„„SUB CommandPointer (firstline%, Col%, BotLimit%, Fgc%, Bgc%, DoLine%)„'this is where the user reacts to menu choices...„„COLOR Fgc%, Bgc%„DoLine% = firstline%    'set aside the first line (sent with the sub call)„                        'as the upper limit to the list. (Work with DoLine%)„LOCATE firstline%, Col% 'go to the line and column called for in the„                        'subroutine call„PRINT CHR$(16)          'and print the line pointer on the screen„„DO                      'run around in circles awaiting instructions„selection$ = INKEY$„selection$ = UCASE$(selection$)„„'the next two IF's move the pointer up and down...„IF selection$ = CHR$(0) + "H" THEN           'UpArrow„   LOCATE DoLine%, Col%: PRINT CHR$(0)       'first blank out old pointer„   DoLine% = DoLine% - 1                     'move up one line„   IF DoLine% < firstline% THEN DoLine% = BotLimit% 'jump to bottom if at top„   LOCATE DoLine%, Col%                      'go to where directed„   PRINT CHR$(16)                            'print new pointer on screen„   END IF„IF selection$ = CHR$(0) + "P" THEN           'DnArrow„   LOCATE DoLine%, Col%: PRINT CHR$(0)       'cover the last pointer„   DoLine% = DoLine% + 1                     'move down one line„   IF DoLine% > BotLimit% THEN DoLine% = firstline% 'jump to top if at bottom„   LOCATE DoLine%, Col%                      'go to where directed„   PRINT CHR$(16)                            'new pointer„   END IF„„'this IF reacts to the user pressing the ENTER key. The sub ends with a new„'value for DoLine%, equal to the line that the pointer was on.„IF selection$ = CHR$(13) THEN„    DoLine% = DoLine%„    EXIT SUB„    END IF„„'these other IF's return a value for DoLine% which is not a valid screen„'coordinate. It is up to the SELECT CASE statements that follow the line„'that called CommandPointer to determine what to do with the returned value„„IF selection$ = CHR$(0) + CHR$(81) THEN      'page down key„   DoLine% = 100„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(73) THEN      'page up key„   DoLine% = 200„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(59) THEN      'F1 key„   DoLine% = 601„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(60) THEN      'F2 key„   DoLine% = 602„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(61) THEN      'F3 key„   DoLine% = 603„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(62) THEN      'F4 key„   DoLine% = 604„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(63) THEN      'F5 key„   DoLine% = 605„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(64) THEN      'F6 key„   DoLine% = 606„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(65) THEN      'F7 key„   DoLine% = 607„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(66) THEN      'F8 key„   DoLine% = 608„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(67) THEN      'F9 key„   DoLine% = 609„   EXIT SUB„   END IF„IF selection$ = CHR$(0) + CHR$(68) THEN      'F10 key„   DoLine% = 610„   EXIT SUB„   END IF„IF selection$ = CHR$(27) THEN                'escape key„   DoLine% = 900„   EXIT SUB„   END IF„LOOP„'break out of the loop and return to the calling module with a new variable„'called DoLine%, equal to the line number on screen where the selected item„'was being displayed, or else with a number beyond the screen size (100, 200,„'etc.), which will be used to convey special instructions„END SUB„„SUB divprobs„SHARED TotalProbs!„SHARED TotalCorrect!„„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„MenuBar 2, 15, 1„„LOCATE 3, 4: PRINT "Division test!"„LOCATE 5, 4: PRINT "I, your computer, will be making up division problems"„LOCATE 6, 4: PRINT "for you, based on the answers you give to the next few questions."„LOCATE 8, 4: INPUT "What number do you want to divide by"; table„LOCATE 10, 4: INPUT "What is the largest number you want me to use"; tops„LOCATE 12, 4: INPUT "How many problems do you want me to give you (up to 20)"; probs„IF probs > 20 THEN probs = 20„TotalProbs! = TotalProbs! + probs„correct = 0„wrong = 0„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„RANDOMIZE tops„            FOR I% = 1 TO probs„                LOCATE 1, 2: PRINT (probs - I%) + 1; " to go";„                x = INT(RND * tops) + 1„                answer = x \ table„                DLBox 12, 20, 14, 60, 0, 1, 15, 1, 0„                LOCATE 13, 23: PRINT x; " divided by "; table; " equals ";„                LINE INPUT try$„                IF LEN(try$) = 0 THEN GOTO wrong„                try = VAL(try$)„                IF try = answer THEN„                correct = correct + 1: PLAY "t240o3l8d#fgl8b-p8l8gl2b-": LOCATE 8, 37: PRINT "RIGHT!": SLEEP 1: LOCATE 8, 37: PRINT "      "„                GOTO nextprob„                END IF„                IF try <> answer THEN„wrong:„                PLAY "t255l16o1bo4dg#o2f"„                wrong = wrong + 1„                LOCATE 15, 30: PRINT "the answer is "; answer;„                SLEEP 2„                DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„                END IF„nextprob:„                LOCATE 1, 2: PRINT STRING$(40, 0);„            NEXT I%„DLBox 2, 1, 23, 80, 176, 1, 15, 1, 0„DLBox 8, 26, 11, 54, 0, 1, 15, 1, 0„LOCATE 9, 28: PRINT "you got -> "; correct; "correct"„TotalCorrect! = TotalCorrect! + correct„LOCATE 10, 28: PRINT "you got -> "; wrong; "wrong"„IF wrong = 0 THEN BEEP„DLBox 14, 26, 16, 54, 0, 1, 15, 1, 0„LOCATE 15, 28: LINE INPUT "press ENTER to continue "; junk$„„END SUB„„SUB DLBox (TLine, LCol, BLine, RCol, FieldNo, border, Fgc, Bgc, shadow)„'DLBOX (DeLuxe Box) is a fancy box sub-routine that includes„'a user-defined background character parameter, single or double-„'line border (or no border), and foreground and background color parameters,„'plus shadow or no shadow option.„'„'The no-border option makes this "box" routine able to replace "background"„'routines.„COLOR Fgc, Bgc„   IF border = 0 THEN    'no border at all„      ULC = FieldNo„      URC = FieldNo„      LLC = FieldNo„      LRC = FieldNo„      HORIZ = FieldNo„      VERT = FieldNo„         END IF„   IF border = 1 THEN   'single line border„      ULC = 218         'upper left corner„      URC = 191         'upper right corner„      LLC = 192         'lower left corner„      LRC = 217         'lower right corner„      HORIZ = 196       'horizontal lines„      VERT = 179        'vertical lines„         END IF„   IF border = 2 THEN   'double line border„      ULC = 201         'ditto all above„      URC = 187„      LLC = 200„      LRC = 188„      HORIZ = 205„      VERT = 186„         END IF„„LOCATE TLine, LCol„PRINT CHR$(ULC) + STRING$(((RCol - LCol) - 1), CHR$(HORIZ)) + CHR$(URC)„FOR x = 1 TO (BLine - TLine) - 1„LOCATE ((TLine + 1) + NextLine), LCol„   NextLine = NextLine + 1„PRINT CHR$(VERT) + STRING$(((RCol - LCol) - 1), CHR$(FieldNo)) + CHR$(VERT);„NEXT x„LOCATE BLine, LCol„PRINT CHR$(LLC) + STRING$(((RCol - LCol) - 1), CHR$(HORIZ)) + CHR$(LRC);„ „„IF shadow = 1 THEN   'for consistancy, use 1 for shadows, 0 for no shadow„   IF BLine > 24 OR RCol > 79 THEN GOTO badshadow„COLOR 7, 0           'shadows are dark„„LOCATE BLine + 1, LCol + 1                 'across the„PRINT STRING$((RCol - LCol), CHR$(176));  'bottom...„ „FOR I = TLine + 1 TO BLine + 1              'on the„LOCATE I, RCol + 1: PRINT CHR$(176);         'right side„NEXT„„END IF„COLOR Fgc, Bgc       'restore original colors„badshadow:„„END SUB„„SUB MenuBar (message, Fgc, Bgc)„COLOR Bgc%, Bgc%                             'nothing but background„LOCATE 1, 1: PRINT STRING$(80, 219);           'color bar 1 at top„LOCATE 24, 1: PRINT STRING$(80, 219);          'color bar 2 at bottom„LOCATE 25, 1: PRINT STRING$(80, 219);          'color bar 3 at very bottom„COLOR Fgc%, Bgc%                             'activate foreground color„progname$ = "QMATHTST.BAS - a math test program in QBasic"„title1$ = "Select a subject"„LOCATE 25, (40 - (LEN(progname$) / 2)): PRINT progname$;   'prog name„„IF message% = 1 THEN„    LOCATE 1, 1: PRINT " <ESC> quits "; CHR$(4); " <ARROWS> & <ENTER> to select "; CHR$(4); " <F10> to re-set score"„    LOCATE 24, (40 - (LEN(title1$) / 2)): PRINT title1$;„END IF„„IF message% = 2 THEN„END IF„„IF message% = 3 THEN„END IF„„IF message% = 4 THEN„END IF„„IF message% = 5 THEN„END IF„„IF message% = 6 THEN„END IF„„IF message% = 7 THEN„END IF„„IF message% = 8 THEN„END IF„„IF message% = 9 THEN„END IF„„IF message% = 10 THEN„END IF„„END SUB„„SUB multprobs„SHARED TotalProbs!„SHARED TotalCorrect!„„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„MenuBar 2, 15, 1„„LOCATE 3, 4: PRINT "Multiplication test!"„LOCATE 5, 4: PRINT "I, your computer, will be making up multiplication problems"„LOCATE 6, 4: PRINT "for you, based on the answers you give to the next few questions."„LOCATE 8, 4: INPUT "What number do you want to multiply by"; table„LOCATE 10, 4: INPUT "What is the largest number you want me to use"; tops„LOCATE 12, 4: INPUT "How many problems do you want me to give you (up to 20)"; probs„IF probs > 20 THEN probs = 20„TotalProbs! = TotalProbs! + probs„„correct = 0„wrong = 0„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„RANDOMIZE tops„            FOR I% = 1 TO probs„                LOCATE 1, 2: PRINT (probs - I%) + 1; " to go";„                x = INT(RND * tops) + 1„                answer = x * table„                DLBox 12, 20, 14, 60, 0, 1, 15, 1, 0„                LOCATE 13, 23: PRINT table; " times "; x; " equals ";„                INPUT try„                IF try = answer THEN correct = correct + 1: PLAY "t240o3l8d#fgl8b-p8l8gl2b-": LOCATE 8, 37: PRINT "RIGHT!": SLEEP 1: LOCATE 8, 37: PRINT "      "„                IF try <> answer THEN„                PLAY "t255l16o1bo4dg#o2f"„                wrong = wrong + 1„                LOCATE 15, 30: PRINT "the answer is "; answer;„                SLEEP 2„                DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„                END IF„                LOCATE 1, 2: PRINT STRING$(40, 0);„            NEXT I%„DLBox 2, 1, 23, 80, 176, 1, 15, 1, 0„DLBox 8, 26, 11, 54, 0, 1, 15, 1, 0„LOCATE 9, 28: PRINT "you got -> "; correct; "correct"„TotalCorrect! = TotalCorrect! + correct„LOCATE 10, 28: PRINT "you got -> "; wrong; "wrong"„IF wrong = 0 THEN BEEP„DLBox 14, 26, 16, 54, 0, 1, 15, 1, 0„LOCATE 15, 28: LINE INPUT "press ENTER to continue "; junk$„END SUB„„SUB subprobs„SHARED TotalProbs!„SHARED TotalCorrect!„„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„MenuBar 2, 15, 1„„LOCATE 3, 4: PRINT "Subtraction test!"„LOCATE 5, 4: PRINT "I, your computer, will be making up subtraction problems"„LOCATE 6, 4: PRINT "for you, based on the answers you give to the next few questions."„LOCATE 10, 4: INPUT "What is the largest number you want me to use"; tops„LOCATE 12, 4: INPUT "How many problems do you want me to give you (up to 20)"; probs„IF probs > 20 THEN probs = 20„TotalProbs! = TotalProbs! + probs„„correct = 0„wrong = 0„DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„RANDOMIZE tops„            FOR I% = 1 TO probs„                LOCATE 1, 2: PRINT (probs - I%) + 1; " to go";„                x = INT(RND * tops) + 1„                y = INT(RND * tops) + 1„                DLBox 12, 20, 14, 60, 0, 1, 15, 1, 0„                IF x >= y THEN„                answer = x - y„                LOCATE 13, 23: PRINT x; " take away "; y; " equals ";„                END IF„                IF y > x THEN„                answer = y - x„                LOCATE 13, 23: PRINT y; " take away "; x; " equals ";„                END IF„                INPUT try„                IF try = answer THEN correct = correct + 1: PLAY "t240o3l8d#fgl8b-p8l8gl2b-": LOCATE 8, 37: PRINT "RIGHT!": SLEEP 1: LOCATE 8, 37: PRINT "      "„                IF try <> answer THEN„                PLAY "t255l16o1bo4dg#o2f"„                wrong = wrong + 1„                LOCATE 15, 30: PRINT "the answer is "; answer;„                SLEEP 2„                DLBox 2, 1, 23, 80, 0, 1, 15, 1, 0„                END IF„                LOCATE 1, 2: PRINT STRING$(40, 0);„            NEXT I%„DLBox 2, 1, 23, 80, 176, 1, 15, 1, 0„DLBox 8, 26, 11, 54, 0, 1, 15, 1, 0„LOCATE 9, 28: PRINT "you got -> "; correct; "correct"„TotalCorrect! = TotalCorrect! + correct„LOCATE 10, 28: PRINT "you got -> "; wrong; "wrong"„IF wrong = 0 THEN BEEP„DLBox 14, 26, 16, 54, 0, 1, 15, 1, 0„LOCATE 15, 28: LINE INPUT "press ENTER to continue "; junk$„„END SUB„„Dave Gjessing                  BUBBLE SORT                    dgjess@freenet.columbus.oh.us  01-01-96 (00:00)       QB, QBasic, PDS        93   3331     BUBLSORT.BAS'SORTER3.BAS    Dave Gjessing, 12/31/95, cleaned and remarked 1/1/96„'I wanted to figure out how to sort a random file before the year was out!„'This routine seems to do the job pretty darn well.„'-worked this out with playing cards on the kitchen table. I guess this is„'what is called a "bubble sort".„„DEFINT A-Z„TYPE fullname„   firstN AS STRING * 20„   lastN AS STRING * 20„END TYPE„DIM SHARED entry AS fullname„'************************ start ******************************„menu:„CLS„PRINT "1 - run the sorter"„PRINT "2 - add records"„PRINT "3 - review file"„PRINT "K - kill the file"„PRINT "(Q)uit"„„DO                      'get a keystroke„ans$ = INKEY$„IF ans$ = "1" THEN GOTO sortfile„IF ans$ = "2" THEN GOTO addrecs„IF ans$ = "3" THEN GOTO review„IF ans$ = "K" OR ans$ = "k" THEN KILL "sorter3.dat": GOTO menu„IF ans$ = "Q" OR ans$ = "q" THEN END„LOOP„„'******************> the sorting routine <*********************„sortfile:„OPEN "sorter3.dat" FOR RANDOM AS #1 LEN = LEN(entry)„numrec = LOF(1) / LEN(entry)„DIM A AS fullname      'make a couple of distinct arrays to    „DIM B AS fullname      'hold TYPE fullname file entries in memory„„FOR x = 1 TO numrec               'do the whole thing for as many„counter = 1                       'records as there are„„FOR y = 1 TO numrec - 1           '(-1 or blank record is added)„ GET #1, counter, entry           'get the first (or next) record„  A = entry                       'put it in array A„   GET #1, counter + 1, entry     'get the second (or next + 1) record„    B = entry                     'put it in array B„    IF UCASE$(A.lastN) > UCASE$(B.lastN) THEN  'compare the arrays...„„      'if the first is greater than the second, then switch their„      'places in the file, as follows.„       „        '(you may compare (and so sort by) *any* element of the array)„        '(the UCASE$ comparison is important; an uppercase letter has„        'a different ASCII value than it's lowercase counterpart!)„„    entry = B                     'temporarily make entry = B„    PUT #1, counter, entry        'put that in A's former place (counter)„    entry = A                     'temporarily make entry = A„    PUT #1, counter + 1, entry    'put in B's former place (counter + 1)„    END IF„   counter = counter + 1          'bump the counter(s)„  NEXT y                          'do this for all of them„NEXT x                            'do *entire* process for all of them„CLOSE 1                           'done!„GOTO menu„„'****************** get sample data ****************************„addrecs:„LINE INPUT "first name : "; entry.firstN„LINE INPUT "last name  : "; entry.lastN„OPEN "sorter3.dat" FOR RANDOM AS #1 LEN = LEN(entry)„numrec = LOF(1) / LEN(entry)„numrec = numrec + 1„PUT #1, numrec, entry„CLOSE 1„GOTO menu„„'****************** look at the file ***************************„review:„CLS„PRINT "here is the file": PRINT„OPEN "sorter3.dat" FOR RANDOM AS #1 LEN = LEN(entry)„numrec = LOF(1) / LEN(entry)„counter = 1„FOR x = counter TO numrec„GET #1, counter, entry„PRINT entry.lastN; " "; entry.firstN„counter = counter + 1„NEXT x„PRINT : LINE INPUT "enter to continue"; junk$„CLOSE 1„GOTO menu„'************************* end *******************************„„Christopher Pinder             EXPRESSION EVALUATOR           comp.lang.basic.misc           04-14-96 (10:55)       PB                     175  4500     EVALUATE.BAS' POWER BASIC SOURCE„' A Recusive Descent Bracket Thingy to mess with parenthesized?„' Expressions. This is a bodged version in BASIC of the code given„' in Bjarne Stroustrup's The C++ Programming Language with the„' Symbol Table Stuff stripped out.„' Very little error checking etc... but it works (Famous last words)„' Probably got more bugs than three year old yogurt but hey !„„' I'm not too sure how copyright would go regarding a bit of code„' translated from a book into another language so I won't donate it„' cos I might not have the right. But I wrote this version and I don't„' care wot happens to it.„„%NUMBER   = 1„%END      = 3„%PLUS     = 4„%MINUS    = 5„%MUL      = 6„%DIV      = 7„%LP       = 8„%RP       = 9„„shared EVAL$„shared n$,v„shared currenttoken%„„FUNCTION  GetToken%„  shared n$,v„  shared EVAL$„  shared currenttoken%„  static state%„  static curpos%„    if state% = 0 then curpos% = 1:n$="" 'yeuch !„„        NUM$="0123456789."„        OPER$="+-*/=()~!@"„        WHITE$=" "+chr$(8)„„„'Skip whitespace„        x$=mid$(EVAL$,curpos%,1)„        l% = len(EVAL$)„        while (((instr(WHITE$,x$)) and (curpos%<l%) ))„          incr curpos%„          x$=mid$(EVAL$,curpos%,1)„        wend„        if curpos% >= l% then„            currenttoken% = %END:„            state% = 0:„            exit function„        end if„„        state% = 1:„        dp% = 0:„        zz$=""„        'do the numbers first„        if(instr(NUM$,x$)>0)then„          while   ((instr(NUM$,x$)>0)  and_„                  (instr(WHITE$,x$)=0) and_„                  (instr(OPER$,x$)=0)  and_„                  (dp% < 2))„        if x$="." then incr dp%:„            if dp% = 2 then exit function:„            zz$ =zz$+ x$„            if curpos% < l% then„              incr curpos%„                x$ = mid$(EVAL$,curpos%,1)„            end if„         wend„         v = val(zz$)„         currenttoken% = %NUMBER:„         exit function:„         end if„„         if instr(OPER$,x$) then„          incr curpos%„          select case x$:„              case "+":currenttoken% = %PLUS„              case "-":currenttoken% = %MINUS„              case "*":currenttoken% = %MUL„              case "/":currenttoken% = %DIV„              case "(":currenttoken% = %LP„              case ")":currenttoken% = %RP„            case else„              currenttoken% = %END:„            end select„            exit function„         end if„ end function:„„function expr„     shared n$,v:„         shared currenttoken%„         local myleft„         myleft = term„         while 1„         select case currenttoken%„         case %PLUS„          GetToken%„            myleft = myleft+term:iterate„         case %MINUS„          GetToken%„            myleft = myleft-term:iterate„         case else„            expr = myleft: exit function:„         end select„         wend„end function„„function term„    shared n$,v:„    local myleft„        myleft = prim„        while 1„        select case currenttoken%„        case %MUL„          GetToken%„            myleft = myleft * prim: iterate„        case %DIV„          GetToken%„            d = prim : if d = 0.00 then d = 1„            myleft = myleft / d: iterate„            case else„            term = myleft:exit function:„            end select„            wend„    end function„„„function prim„    shared n$,v:„  select case currenttoken%„      case %NUMBER„          prim = v„            GetToken%„        case %LP„          GetToken%„            e = expr„            if(currenttoken% <> %RP) then„              prim = 0:„                print "Mismatched Parenthesis"„                exit function„                end if„            GetToken%„            prim = e:exit function:„„        case %MINUS„          GetToken%„            prim = - prim: exit function„„        case %END„        prim = 0:„        end select„end function:„„„Function Evaluate(p$)„         shared EVAL$„         EVAL$=p$+" "    'cos we read ahead - tacky I know !„         GetToken%„         Evaluate = expr!„         end function„„'----------------------------------------------------------------------„' And now - to eat the pudding !„'----------------------------------------------------------------------„„„cls„print "input or ! to end"„while a$ <> "!"„  a$ =""„  input a$„  ? a$ " = " ; evaluate(a$)„wend„Larry Stone                    EXTRACT/SET LOW & HIGH BYTES   QB TidBits                     06-07-91 (11:09)       QB, QBasic, PDS        90   3617     LSET.BAS    'Code to extract (or set) low and high bytes from an integer by Larry Stone,„'June 7, 1991.„'„'Code to extract (or set) low and high integers from a LONG derived from code„'published in the June, 1991, issue of "Inside QuickBASIC" by Doug Quebbeman.„„DEFINT A-Z                      'Default to integers„„'****************************************************************************„'                              TYPE Declarations                            *„'****************************************************************************„„TYPE Integr                     'Create a template (structure), Integr„    Num AS INTEGER              '(only has 1 element)„END TYPE„„TYPE SplitInt                   'Create a template (structure), SplitInt„    LowByte AS STRING * 1„    HiByte  AS STRING * 1„END TYPE„„TYPE Longe                      'Create a template (structure), Longe„    Dword AS LONG               '(only has 1 element)„END TYPE„„TYPE SplitLong                  'Create a template (structure), SplitLong„    LowWord AS INTEGER„    HiWord AS INTEGER„END TYPE„„'****************************************************************************„'                 DIM memory variables as Structured TYPEs                  *„'****************************************************************************„„DIM Integr AS Integr            'Create our memory variable, Integr„DIM SplitInt AS SplitInt        'Create our memory variable, SplitInt„DIM Longe AS Longe              'Create our memory variable, Longe„DIM SplitLong AS SplitLong      'Create our memory variable, SplitLong„„'****************************************************************************„'                          Make It Work - Main Code                         *„'****************************************************************************„„CLS                             'Clear the screen„„Integr.Num = 32767„PRINT "Our INTEGER"; Integr.Num;„„LSET SplitInt = Integr          'Get low and high bytes of our Integr„PRINT "has a low byte of"; ASC(SplitInt.LowByte);„PRINT "and a high byte of"; ASC(SplitInt.HiByte)„„SplitInt.HiByte = CHR$(128)     'Assign a new high byte for our Integr„PRINT "Setting the high byte of the INTEGER to"; ASC(SplitInt.HiByte);„„LSET Integr = SplitInt          'Set the Integr to these new byte values„PRINT "changes it's value to "; Integr.Num„PRINT„„„Longe.Dword = 131071„PRINT "Our LONG Integer"; Longe.Dword;„„LSET SplitLong = Longe          'Get the low and high integers of our Longe„PRINT "has a low integer of "; SplitLong.LowWord;„PRINT "and a high integer of"; SplitLong.HiWord„„Integr.Num = SplitLong.LowWord  'Assign Integr as the LowWord„LSET SplitInt = Integr          'Now get the bytes of our LowWord„„PRINT "The low integer's ( "; Integr.Num; ") low byte is";„PRINT ASC(SplitInt.LowByte);„PRINT "and its high byte is"; ASC(SplitInt.HiByte)„„Integr.Num = SplitLong.HiWord   'Assign Integr as the HiWord„LSET SplitInt = Integr          'Now get the low and high bytes of HiWord„„PRINT "The high integer's ("; Integr.Num; ") low byte is";„PRINT ASC(SplitInt.LowByte);„PRINT "and its high byte is"; ASC(SplitInt.HiByte)„PRINT„„SplitLong.HiWord = 32767        'Change the high INTEGER of our variable„„PRINT "Assigning"; SplitLong.HiWord; "as our LONG's high word ";„LSET Longe = SplitLong          'Now assign the above integers to Longe„„PRINT "changes its value to"; Longe.Dword„PRINT "The low integer of"; Longe.Dword; "reports as "; SplitLong.LowWord;„PRINT "and the high integer is"; SplitLong.HiWord„Darryl Schneider               PYTHAGOREAN THEOREM DEMO       fish2@datanet.ab.ca            05-26-96 (00:24)       QB, QBasic, PDS        147  4632     PYTH.BAS    'This is a little interactive educational program that„'explains how to find the hypotenuse of a right-angle„'triangle using the Pythagorean Theorem.„'„'Written by Darryl Schneider„'fish2@datanet.ab.ca„'The QBasic Zone„'http://www.geocities.com/SiliconValley/4244/qbasic.html„'„START:„CLS„DEFSTR E-F                              'declare all of the„DEFSNG A-D, G-Z                         'variables„SCREEN 12„PRINT ""„PRINT "              The Pythagorean Theorem"„PRINT ""„FOR D = 1 TO 50                         'draw the line„    PRINT CHR$(196);„NEXT D„PRINT ""„PRINT ""„LINE (100, 80)-(100, 200), 1            'draw and paint the triangle„LINE (100, 200)-(300, 200), 1„LINE (300, 200)-(100, 80), 1„PAINT (150, 120), 2, 1„LOCATE 7, 40: PRINT "a = altitude"      'print the legend„LOCATE 8, 40: PRINT "b = base"„LOCATE 9, 40: PRINT "h = hypotenuse"„LOCATE 9, 11: PRINT "a"„LOCATE 8, 27: PRINT "h"„PRINT ""„PRINT ""„PRINT ""„PRINT ""„PRINT ""„PRINT "                       b"„PRINT ""„PRINT ""„PRINT "       In order to understand the Pythagorean Theorem, let's"„PRINT "       do a little interactive demonstration to find the"„PRINT "       hypotenuse of a triangle."„PRINT ""„PRINT "       Press any key to begin....."„PRINT "       [Type 'Q' to quit]"„ATRIES = 0„BTRIES = 0„HTRIES = 0„DO„F = UCASE$(INKEY$)                  'asks for a one-character response„IF F = "Q" THEN END„LOOP UNTIL F <> ""„„FINDH:„CLS„PRINT ""„PRINT "       Finding the hypotenuse of a triangle"„PRINT ""„FOR D = 1 TO 50                           'draw the line„     PRINT CHR$(196);„NEXT D„PRINT ""„PRINT ""„LINE (100, 80)-(100, 200), 1              'draw the triangle„LINE (100, 200)-(300, 200), 1„LINE (300, 200)-(100, 80), 1„PAINT (150, 120), 2, 1„LOCATE 7, 40: PRINT "a = altitude = "; A  'print the legend with values„LOCATE 8, 40: PRINT "b = base = "; B„LOCATE 9, 40: PRINT "h = hypotenuse = ?"„LOCATE 9, 5: PRINT A„LOCATE 8, 27: PRINT "h"„PRINT ""„PRINT ""„PRINT ""„PRINT ""„PRINT ""„PRINT "                       "; B„PRINT ""„PRINT ""„IF ATRIES = 0 THEN„          INPUT "What is the altitude"; A      'asks for altitude„          ATRIES = ATRIES + 1                  'of the triangle„          GOSUB FINDH„END IF„IF BTRIES = 0 THEN„          INPUT "What is the base"; B          'asks for base„          BTRIES = BTRIES + 1                  'of the triangle„          GOSUB FINDH„END IF„IF ATRIES = 1 AND BTRIES = 1 THEN GOSUB FINDHA     'altitude and„                                                   'base values have„                                                   'been given so we„                                                   'can now proceed„FINDHA:„PLAY "O3L20P1P1"„PRINT ""„PRINT " Now we can calculate the length of the hypotenuse:"„PRINT ""„LOCATE 20, 1: PRINT " a˝ + b˝"; : LOCATE 20, 25: PRINT " = h˝           'first write down the formula"„PLAY "O3L20P1P1"„LOCATE 21, 1: PRINT ""; A; "˝ + "; B; "˝": LOCATE 21, 25: PRINT " = h˝           'substitute a and b with numbers"„PLAY "O3L20P1P1"„G = A * A„H = B * B„LOCATE 22, 1: PRINT ""; G; " + "; H; : LOCATE 22, 25: PRINT " = h˝           'find the product of each square"„PLAY "O3L20P1P1"„LOCATE 23, 1: PRINT ""; G + H; : LOCATE 23, 25: PRINT " = h˝           'add the products of the squares"„LOCATE 24, 25: PRINT "                 together "„PLAY "O3L20P1P1"„LOCATE 25, 1: PRINT " ˚"; G + H; : LOCATE 25, 25: PRINT " = h            'the square root of the sum will equal"„LOCATE 26, 25: PRINT "                 the hypotenuse"„H = SQR(G + H)„PLAY "O3L20P1P1"„LOCATE 27, 1: PRINT ""; H; : LOCATE 27, 25: PRINT " = h            'the answer for the hypotenuse"„PLAY "o3l20p1p1"„„CLS„PRINT ""„PRINT "    End of the Interactive Demonstration of the Pythagorean Theorem"„PRINT ""„FOR D = 1 TO 70„    PRINT CHR$(196);                         'draw the line„NEXT D„LINE (100, 80)-(100, 200), 1                 'draw the triangle„LINE (100, 200)-(300, 200), 1„LINE (300, 200)-(100, 80), 1„PAINT (150, 120), 2, 1„LOCATE 7, 40: PRINT "a = altitude = "; A     'print legend with all„LOCATE 8, 40: PRINT "b = base = "; B         'values„LOCATE 9, 40: PRINT "h = hypotenuse = "; H„LOCATE 9, 5: PRINT A„LOCATE 8, 27: PRINT H„PRINT ""„PRINT ""„PRINT ""„PRINT ""„PRINT ""„PRINT "                       "; B„PRINT ""„PRINT "       Type 'S' to start the program again or any other key to quit....."„'above is another one-character response prompt„DO„E = UCASE$(INKEY$)„IF E = "S" THEN GOSUB START„LOOP UNTIL E <> ""„IF NOT E = "S" THEN END„Carl Gorringe                  FIBONACCI SEQUENCE GENERATOR   FidoNet QUIK_BAS Echo          05-27-96 (00:00)       QB, QBasic, PDS        133  3638     FIBO.BAS    '>Is there any way to get greater precision than DOUBLE? I am trying to explo„'>the Fibonacci <sp> numbers, and they quickly become hundreds of digits long„„'I remember once trying to calculate the Fibonacci sequence, and had the„'same problem that you did: It wouldn't go up to very many digits!„'So, I decided to try it out again and I found a way to do it!„'What I did was to store a number in a STRING variable as text, and then„'make a special function that would add it with another number stored in„'a string. What I came up with is the following. Theoretically it can go„'up to at least 32000 digits, since that's the limit for the length of a„'string variable. Of course, it would take many days to get that far! :)„'Enjoy!„„'------------------------------------------„'  FIB.BAS - Fibonacci Sequence Generator„'------------------------------------------„'      (c) Carl Gorringe 5/27/96„'    Released to the PUBLIC DOMAIN.„'„'   This program will calculate the„' Fibonacci Sequence up to thousands of„' digits if let to run. It does this by„' storing very long numbers in strings.„'„' I can be contacted be sending a message to:„' CARL GORRINGE at FIDOnet's QuickBASIC echo or„' Internet e-mail: <carl.gorringe@rhosoft.com>„'„'------------------------------------------------„DECLARE FUNCTION AddStr$ (StrNum1$, StrNum2$)„„'--- Credits ---„   SCREEN 0: WIDTH 80, 25„   CLS„   PRINT "FIB.BAS v1.0 - Fibonacci Sequence Generator (by Carl Gorringe)"„   PRINT "----------- Press Any Key for Next Number, <ESC> To Exit -----------"„   PRINT "Count:                Digits:"„   PRINT„   PRINT "Double Precision:"„   PRINT„   PRINT„   PRINT "String Number:"„„'--- Open File ---„   'OPEN "FIBO.DAT" FOR OUTPUT AS #1    '<-- Un-rem this to Save to File!„„'--- Display Fibonacci Sequence ---„„   A# = 1: SA$ = "1"„   B# = 2: SB$ = "2"„   LOCATE 21, 1„   PRINT 1„   PRINT 1„   PRINT 2„„   Count% = 3„   DO„      SC$ = AddStr$(SA$, SB$)„      LOCATE 3, 30„      PRINT LEN(SC$);„„      VIEW PRINT 9 TO 24„      LOCATE 24, 2„      PRINT SC$„      'PRINT #1, SC$        '<-- Un-rem this to Save to File!„      SA$ = SB$„      SB$ = SC$„„      VIEW PRINT„      Count% = Count% + 1„      LOCATE 3, 7„      PRINT Count%;„„      IF LEN(SB$) < 300 THEN„         C# = A# + B#„         LOCATE 6, 1„         PRINT C#;„         A# = B#„         B# = C#„      ELSE„         LOCATE 6, 1„         PRINT "*** Overflow ***        ";„      END IF„„      I$ = INPUT$(1)       '<-- Rem this and„      'I$ = INKEY$         '<-- un-rem this to take out Pause„„   LOOP UNTIL I$ = CHR$(27)„„'--- Close File ---„   'CLOSE #1         '<-- Un-rem this to Save to File!„„END„„FUNCTION AddStr$ (Num1$, Num2$)„„' (c) Carl Gorringe  5/27/96  << v1.0 >>„'----------------------------------------------„'    Add the Numbers stored in Strings„' together and return the result as a string.„'----------------------------------------------„„Len1% = LEN(Num1$)„Len2% = LEN(Num2$)„„IF Len1% > Len2% THEN„   Num2$ = STRING$(Len1% - Len2%, "0") + Num2$„   Len3% = Len1%„ELSEIF Len1% < Len2% THEN„   Num1$ = STRING$(Len2% - Len1%, "0") + Num1$„   Len3% = Len2%„ELSE„   Len3% = Len1%„END IF„„Num3$ = ""„Carry% = 0„FOR A% = Len3% TO 1 STEP -1„   Digit1% = ASC(MID$(Num1$, A%, 1)) - 48„   Digit2% = ASC(MID$(Num2$, A%, 1)) - 48„   Sum% = Digit1% + Digit2% + Carry%„   Digit3% = Sum% MOD 10„   Carry% = Sum% \ 10„   Num3$ = CHR$(Digit3% + 48) + Num3$„NEXT A%„„IF Carry% > 0 THEN„   Num3$ = CHR$(Carry% + 48) + Num3$„END IF„„AddStr$ = Num3$„„END FUNCTION„Alexander Podkolzin            SIMPLE PB CALCULATOR           APP@nw.sbank.e-burg.su         06-24-96 (08:56)       PB32                   329  10421    CALCUL.BAS  $IF 0„   /---------------------------------------------------------------------\„   |                          PowerBASIC 3.2+                            |„   |                         Simple Calculator.                          |„   |                                                                     |„   |   Author:.............Alexander Podkolzin <App@nw.sbank.e-burg.su>  |„   |   This  SUB ( written in TB )  was tested by many different users.  |„   |   Extracted from my old TurboBASIC library and converted to PB3.2.  |„   |   Use it, as you want and enjoy.................................:)  |„   |                                                                     |„   |                        Happy calculations !                         |„   |                                                                     |„   \---------------------------------------------------------------------/„$ENDIF„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„' Num Lock on Your keyboard has to be "ON".„' Simple test for calclators: 123456789 * 9 + 10 = 1111111111„'„  DEFINT A-Z„  CALL Calculator„  END„'„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'„' Note : I do not test case "Overflow".„'„  SUB Calculator()„     wx%=POS„     wy%=CSRLIN„     IF wx%=1 then wx%=2„     iattr%=pbvScrnTxtAttr„     ct%=iattr% and 15„     cb%=iattr% \ 16„     CALL SaveScreen(wc$,59,1,79,23,0)„'„'''' This peace of code makes screen image of calculator: '''''''''''''''''''„'„     CALL Win(1,59,10,79,23,8,0)„     CALL Win(1,60,11,78,23,7,0)„     CALL ClWin(61,12,77,12,0,3)„     FOR i%=62 to 74 step 4„        FOR j%=14 to 22 step 2„           CALL ClWin(i%,j%,i%+2,j%,0,3)„        NEXT j%„     NEXT i%„     CALL ClWin(74,17,76,17,0,3)„     CALL ClWin(74,21,76,21,0,3)„     CALL ClWin(62,22,66,22,0,3)„     CALL ClWin(62,14,64,14,0,2)„     CALL PutString(62,14,"NLK  /   *   -")„     CALL PutString(62,16," 7   8   9")„     CALL PutString(62,18," 4   5   6")„     CALL PutString(62,20," 1   2   3")„     CALL PutString(62,22," 0       .")„     CALL PutString (75,17,"+")„     CALL PutString (75,21,"=")„     COLOR 29,0 : LOCATE 13,77 : PRINT "^"„     CALL Win(1,61,2,77,10,0,7)„     CALL ClWin(63,5,63,9,14,7)„     CALL ClWin(62,3,76,3,14,7)„     CALL PutString(64, 3,"Calculator:")„     CALL PutString(63, 5,"+.........Add")„     CALL PutString(63, 6,"-....Subtract")„     CALL PutString(63, 7,"*... Multiply")„     CALL PutString(63, 8,"/......Divide")„     CALL PutString(63, 9,"p....Percents")„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'„     Summator#  =  0„     Result#    =  0„     Operation$ = "="„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'„  DO„     s$ = "0"„     DO WHILE ASC(s$) >= 48 AND ASC(s$) <= 57 OR ASC(s$) = 46„        WHILE NOT INSTAT:WEND„        s$=INKEY$„        k% = ASC(s$)„        IF k%=13 THEN                   ' Enter„           s$ = "="„        ELSEIF k%=96 OR k%=112 THEN     ' P,p (%)„           s$ = "%"„        END IF„        IF LEN(s$)=1 AND k%<>8 AND k%<>9 THEN„           CALL PutString(77,12,s$)„           CALL DisplayShiftLeft(62,12,16)„        END IF„     LOOP„     IF LEN(s$)=2 OR k%=8 OR k%=9 THEN ITERATE LOOP„     IF k% = 27 THEN                    ' Esc„        CALL RestoreScreen(wc$,59,1)„        COLOR  ct%,cb%„        LOCATE wy%,wx%„        EXIT SUB„     END IF„     GOSUB GetSummator„     CALL ScrollTape(60,1,76,9)„     CALL MoveLine(61,12,62,10,16)„     IF s$="=" THEN„        GOSUB CalculateResult„        GOSUB PrintResult„        Summator# = 0„        Result#   = 0„        ITERATE LOOP„     ELSE„        GOSUB CalculateResult„        Operation$ = s$„     END IF„'„  LOOP„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„„CalculateResult:„     SELECT CASE Operation$„        CASE "+"„           Result# = Result# + Summator#„        CASE "-"„           Result# = Result# - Summator#„        CASE "*"„           Result# = Result# * Summator#„        CASE "/"„           IF Summator#=0 then„              Call PutString(77,10," ") ' Scratch "=" on "paper"„              CALL PutString(62,12,"Division by zero")„              SOUND 880,.5„              WHILE NOT INSTAT: WEND„              w$=INKEY$„              CALL ClWin(61,12,77,12,0,3)„              EXIT SELECT„           ELSE„              Result# = Result# / Summator#„           END IF„        CASE "%"„           Result# = (Result# * Summator#) / 100.„        CASE ELSE„           Result# = Summator#„     END SELECT„     Summator#=0„     Operation$=s$„     RETURN„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„„GetSummator:„     st$=""„     FOR i%=0 TO 15„        st$=st$+CHR$(SCREEN(12,61+i%))„     next i%„     Summator#=VAL(st$)„     RETURN„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„„PrintResult:                      ' Two digits after decimal point„     CALL ScrollTape (60,1,76,9)„     CALL ScrollTape (60,1,76,9)„     CALL PutString(62,9,STRING$(15,196))„     Res$ = USING$("#############.##",Result#)„     n = INSTR(Res$,".00")„     IF n THEN Res$="   "+LEFT$(Res$,n-1)„     PutString 61,10,Res$„     RETURN„'„  END SUB    ' End of SUB Calculator„'„'„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB DisplayShiftLeft(x%,y%,l%)„     LOCAL i%„     FOR i%=x% to x%+l%-1„        ch$= CHR$(SCREEN(y%,i%,0))„        CALL PutString(i%-1,y%,ch$)„     NEXT i%„     CALL PutString(77,12," ")„  END SUB„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB MoveLine(x%,y%,xn%,yn%,l%)„     s$=GetString$(x%,y%,l%)„     CALL PutString(x%,y%,SPACE$(l%))„     CALL PutString(xn%,yn%,s$)„  END SUB„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  FUNCTION GetString$(x%,y%,n%)„    s$=""„    FOR  i%=0 TO n%-1„      s$=s$+CHR$(SCREEN(y%,x%+i%,0))„    NEXT„    GetString$ = s$„  END FUNCTION„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB ScrollTape(xb%,yb%,xe%,ye%)„     REG 1,&H0601„     REG 2,&H7000„     REG 3,yb%*256+xb%„     REG 4,ye%*256+xe%„     CALL INTERRUPT &H10„  END SUB„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB Win(t%,xb%,yb%,xe%,ye%,ct%,cb%)„'„     OldColor% = PBVSCRNTXTATTR   ' Internal PB variable„     SELECT CASE t%               ' Window types„'                                 ' (you can make as much types,„'                                 ' as you want).„        CASE 1„           a%=218:b%=196:c%=191   ' Single frame,„           h%=179:      :d%=179   '„           g%=192:f%=196:e%=217   '„        CASE 2„           a%=201:b%=205:c%=187   ' double frame,„           h%=186:      :d%=186   '„           g%=200:f%=205:e%=188   '„        CASE ELSE„           a%=032:b%= a%:c%= a%   '„           h%= a%:      :d%= a%   ' blanks only.„           g%= a%:f%= a%:e%= a%   '„'„     END SELECT„     COLOR ct%,cb%„     LOCATE yb%,xb%„     PRINT    CHR$(a%) + REPEAT$(xe%-xb%-1,CHR$(b%)) + CHR$(c%)„     FOR i%=yb%+1 TO ye%-1„        LOCATE i%,xb%„        PRINT CHR$(h%) + SPACE$(xe%-xb%-1)           + CHR$(d%)„     NEXT„     LOCATE ye%,xb%„     PRINT    CHR$(g%) + REPEAT$(xe%-xb%-1,CHR$(f%)) + CHR$(e%)„'„''''''''''''''''''''''''''''''''''''''''''''''''''''''„'''     FOR i%=yb%+1 TO ye%+1                      '''„'''        PutAttribute xe%+1,i%,8,0 ' Making      '''  Don't use here„'''     NEXT                         ' shadows     '''„'''     FOR i%=xb%+1 TO xe%+1        '             '''„'''        PutAttribute i%,ye%+1,8,0               '''„'''     NEXT                                       '''„''''''''''''''''''''''''''''''''''''''''''''''''''''''„'„     ct%=OldColor% AND 15         ' Restore colors„     cb%=OldColor%\16„     COLOR ct%,cb%„  END SUB„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB PutString(x%,y%,st$)        ' Puts string to video memory„     DIM Cell AS BYTE PTR„     DIM TextPtr AS BYTE PTR„'„     TextPtr = STRPTR32( st$ )„     Cell = PBVSCRNBUFF + ( y% - 1 ) * 160 + ( x% - 1 ) * 2„     FOR i% = 1 TO LEN( st$ )„        @Cell = @TextPtr„        INCR TextPtr„        INCR Cell, 2„     NEXT„  END SUB„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'  Special thanks to Eric Olson for his public domain SUBs SaveScreen and   '„'  RestoreScreen (I'v rewrote them using pointers).                         '„'„  SUB SaveScreen(w$,xb%,yb%,xe%,ye%,sh%)„     DIM temp AS BYTE PTR„     DIM WinPtr AS BYTE PTR„     DIM TextPtr AS BYTE PTR„     lx% = (xe% - xb% + 1) * 2„     ly% = ye% - yb% + 1„     IF sh% THEN„        INCR lx%,2„        INCR ly%„     END IF„     l$ = RIGHT$(" " + STR$(lx%), 3 )„     w$ = l$ + SPACE$( lx% * ly% )„     WinPtr = PBVSCRNBUFF + (yb%-1)*160 + (xb%-1)*2„     TextPtr = STRPTR32(w$) + 3„     FOR i%=1 TO ly%„        temp = WinPtr„        FOR k%=1 TO lx%„           @TextPtr = @temp„           INCR TextPtr„           INCR temp„        NEXT„        INCR WinPtr,160„     NEXT„  END SUB„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB RestoreScreen(w$,xb%,yb%)„     DIM temp AS BYTE PTR„     DIM WinPtr AS BYTE PTR„     DIM TextPtr AS BYTE PTR„     l$ = LEFT$(w$,3)„     w$ = LTRIM$(w$,l$)„     lx% = VAL(l$)„     ly% = LEN(w$) \ lx%„     TextPtr = STRPTR32(w$)„     WinPtr = PBVSCRNBUFF + (yb%-1)*160 + (xb%-1)*2„     FOR i%=1 TO ly%„        temp = WinPtr„        FOR k%=1 TO lx%„           @temp = @TextPtr„           INCR TextPtr„           INCR temp„        NEXT„        INCR WinPtr,160„     NEXT„'   w$ = ""„  END SUB„'„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„  SUB ClWin(xb%,yb%,xe%,ye%,ct%,cb%)    ' Clears text window„     REG 1,&H0600„     REG 2,cb%*4096+ct%*256„     REG 3,(yb%-1)*256+(xb%-1)„     REG 4,(ye%-1)*256+(xe%-1)„     CALL INTERRUPT &H10„  END SUB„'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''„'„Kurt Kuzba                     BRESENHAM LINE/CIRCLE ALGORITHMFidoNet QUIK_BAS Echo          04-16-96 (00:00)       QB, QBasic, PDS        73   2314     BRESNHAM.BAS'_|_|_|   BRESNHAM.BAS„'_|_|_|   This program demonstrates the Bresenham Algorithms„'_|_|_|   for the drawing of lines and circles, using PSET.„'_|_|_|   Adapted from BRESNHAM.C in Bob Stout's SNIPPETS.„'_|_|_|   No warrantee or guarantee is implied or given.„'_|_|_|   Released to   PUBLIC DOMAIN   by Kurt Kuzba. (4/16/96)„DECLARE SUB BLine (x%, y%, x2%, y2%, c%)„DECLARE SUB BCircle (x%, y%, r%, c%)„SCREEN 13„HIGH% = 200   'The Bresenham Cirlce will need to know the screen„WIDE% = 320   'dimensions, which are found in these SHARED variables„ndx% = 0„RANDOMIZE (TIMER * 100 + INP(64))„DIM xy(412) AS LONG„BCircle 159, 99, 65, 77„DEF SEG = &HA000„FOR t& = 0 TO 63999„   IF PEEK(t&) = 77 THEN xy(ndx%) = t&: ndx% = ndx% + 1„NEXT:„WHILE INKEY$ = ""„   BCircle 159, 99, RND * 129 + 70, RND * 255„   ndx% = (RND * 400 + 5)„   l1& = xy(ndx%)„   x1% = l1& MOD 320„   y1% = l1& \ 320„   l2& = xy(ndx% + 3)„   x2% = l2& MOD 320„   y2% = l2& \ 320„   BLine x1%, y1%, x2%, y2%, RND * 255„WEND„SOUND 999, 1„WHILE INKEY$ = "": WEND„SCREEN 0„WIDTH 80, 25„END„SUB BCircle (xc%, yc%, r%, c%)„'_|_|_|   Bresenham Circle Drawing Algorithm„'_|_|_|   Adapted from BRESNHAM.C in Bob Stout's SNIPPETS.„   SHARED WIDE%, HIGH%„   x% = 0: d% = 2 * (1 - r%): W% = 2 * WIDE% \ HIGH%„   WHILE r% >= 0„      PSET (xc% + x%, yc% + r%), c%„      PSET (xc% + x%, yc% - r%), c%„      PSET (xc% - x%, yc% + r%), c%„      PSET (xc% - x%, yc% - r%), c%„      IF (d% + r%) > 0 THEN r% = r% - 1: d% = d% - W% * r% - 1„      IF x% > d% THEN x% = x% + 1: d% = d% + 2 * x% + 1„   WEND„END SUB„SUB BLine (x%, y%, x2%, y2%, c%)„'_|_|_|   Bresenham Line Drawing Algorithm„'_|_|_|   Adapted from BRESNHAM.C in Bob Stout's SNIPPETS.„   i% = 0: steep% = 0: e% = 0„   IF (x2% - x%) > 0 THEN sx% = 1: ELSE sx% = -1„   dx% = ABS(x2% - x%)„   IF (y2% - y%) > 0 THEN sy% = 1:  ELSE sy% = -1„   dy% = ABS(y2% - y%)„   IF (dy% > dx%) THEN„      steep% = 1„      SWAP x%, y%„      SWAP dx%, dy%„      SWAP sx%, sy%„   END IF„   e% = 2 * dy% - dx%„   FOR i% = 0 TO dx% - 1„      IF steep% = 1 THEN PSET (y%, x%), c%:  ELSE PSET (x%, y%), c%„      WHILE e% >= 0„         y% = y% + sy%: e% = e% - 2 * dx%„      WEND„      x% = x% + sx%: e% = e% + 2 * dy%„   NEXT„   PSET (x2%, y2%), c%„END SUB„Tyler Barnes                   BASE CONVERSION ROUTINE        Tyler.Barnes@access.cn.camriv.b07-28-96 (12:32)       QB, QBasic, PDS        47   1659     BASE.BAS    'A lot of the code in this sub is extraneous, and is only put there to speed things up.„„'If you don't know how to use this, just email me at Tyler.Barnes@access.cn.camriv.bc.ca„„DECLARE SUB Base2Base (Number1$, Digits1$, Number2$, Digits2$)„CONST Bin = "01", Oct = "01234567", Dec = "0123456789", Hex = "0123456789ABCDEF"„„DEFLNG A-Z„SUB Base2Base (Number1$, Digits1$, Number2$, Digits2$)„Number1$ = UCASE$(Number1$): Digits1$ = UCASE$(Digits1$)„Digits2$ = UCASE$(Digits2$)„IF Digits1$ <> "0123456789" THEN„FOR I% = LEN(Number1$) TO 1 STEP -1„IF Digits1$ = "01234567" THEN FinalNum = VAL("&O" + Number1$): I% = 1„IF Digits1$ = "0123456789ABCDEF" THEN FinalNum = VAL("&H" + Number1$): I% = 1„CD$ = MID$(Number1$, I%, 1)„CV% = INSTR(Digits1$, CD$) - 1„FinalNum = FinalNum + (CV% * (LEN(Digits1$) ^ ABS(I% - LEN(Number1$))))„NEXT I%„ELSE„FinalNum = VAL(Number1$)„END IF„IF Digits2$ = "0123456789" THEN Number2$ = LTRIM$(STR$(FinalNum)): EXIT SUB„IF Digits2$ = "0123456789ABCDEF" THEN Number2$ = HEX$(FinalNum): EXIT SUB„IF Digits2$ = "01234567" THEN Number2$ = OCT$(FinalNum): EXIT SUB„Number2$ = "": NeverDone% = 1„LD2% = LEN(Digits2$)„DO„FOR I% = 1 TO LD2%„IT& = (I% - 1) * (LD2% ^ DPos%)„IF IT& > FinalNum THEN Z% = 1: I% = I% - 1„IF IT& = FinalNum OR Z% = 1 THEN„IF Z% = 1 THEN„IF I% = 1 THEN I% = LD2%: DPos% = DPos% - 1„END IF„IF NeverDone% = 1 THEN NeverDone% = 0: N2$ = STRING$(DPos% + 1, "0")„MID$(N2$, LEN(N2$) - DPos%, 1) = MID$(Digits2$, I%, 1)„FinalNum = FinalNum - ((I% - 1) * (LD2% ^ DPos%))„DPos% = -1„Z% = 0„EXIT FOR„END IF„NEXT I%„DPos% = DPos% + 1„LOOP UNTIL FinalNum = 0„Number2$ = N2$„END SUB„M. Rosenberg                   PB HUFFMAN ENCODER             QBTIPS_T.DOC                   12-03-93 (15:30)       PB                     133  4759     HUFFMAN.BAS 'Hey all, well I a recently got a Hufman algrorithm for BASIC. Sadly it„'was made only for PowerBasic and I use QuickBasic.  Could some of you„'guys out there with both QB/PB experience possibly modify the code ??„„CLS„InFile$="A SIMPLE STRING TO BE ENCODED USING A MINIMAL NUMBER OF BITS"„„CALL Huffman(InFile$,OutFile$,NewFile$)„print:print:print„PRINT "In:  ";LEN(InFile$);InFile$„PRINT "Out: ";LEN(OutFile$)„PRINT "New: ";LEN(NewFile$);NewFile$„input,r„„END„'**********************************************************************„'   Huffman Encoding File Compression Technique„'„'   From: R Sedgwick.  Algorithms.  Reading, MA: Addison-Wesley.„'                      1984.  Second Ed.  pp  286 / 93.„'„'   Converted to Power Basic by M. Rosenberg CI$: [73707,2545]„'„SUB Huffman(InText$,OutText$,NewText$)„    SHARED N%,Heap%(),Count%()„    DIM Count%(1024),Heap%(1024),Dad%(1024),Code%(256),Leng%(256)„„' Count the frequency of each character in the message to be encoded (P. 287)„    FOR I%=0 to 255 : Count%(I%)=0 : NEXT I%„    Csr%=0„    DO : INCR Csr% : X%=ASC(MID$(InText$,Csr%,1)) : INCR Count%(X%)„         LOOP UNTIL Csr%=LEN(InText$)„„' Initialize the heap array to point to non-zero frequency counts (P. 290)„„    N%=0 : FOR I%=0 to 255 : IF Count%(I%)<>0 THEN INCR N% : Heap%(N%)=I%„           NEXT I%„' Construct an indirect heap on the frequency values (P. 289)„„    FOR K% = N% TO 1 STEP -1 : CALL PqDownHeap(K%) : NEXT K%„„' Construct the trie (P. 290)„    DO : T%=Heap%(1) : Heap%(1)=Heap%(N%) : DECR N%„             CALL PqDownHeap(1)„             Count%(255+N%)=Count%(Heap%(1))+Count%(T%)„             Dad%(T%)=255+N% : Dad%(Heap%(1))=-255-N%„             Heap%(1)=255+N% : CALL PqDownHeap(1)„    LOOP UNTIL N%=1„    Dad%(255+N%)=0„„' Reconstruct the information from the representation of the coding tree (P.291)„'    computed during the sifting process.„„    FOR K% = 0 TO 255„        IF Count%(K%)=0 THEN„           Code%(K%)=0 : Leng%(K%)=0„        ELSE„           I%=0 : J&=1 : T%=Dad%(K%) : X%=0„           DO : IF T%<0 THEN X%=X%+J& : T%=0-T%„                T%=Dad%(T%) : J&=J&+J& : INCR I%„           LOOP UNTIL T%=0„           Code%(K%)=X% : Leng%(K%)=I%„        END IF„    NEXT K%„' Use the computed representations of the code to encode the string (P. 292)„„    J%=0 : OutText$="" : Hold$=""„    DO : INCR J%„             Char%=ASC(MID$(InText$,J%,1)) : Compr$=BIN$(Code%(Char%))„             DO WHILE LEN(Compr$)< Leng%(Char%) : Compr$="0"+Compr$ : LOOP„             Hold$=Hold$+Compr$„             IF LEN(Hold$)>8 THEN„                          „                OutText$=OutText$+CHR$(Bin2Int(LEFT$(Hold$,8))) Hold$=RIGHT$(Hold$,LEN(Hold$)-8)„             END IF„    LOOP UNTIL J%=LEN(InText$)„„' Add a byte at the end that contains any left-over bits„„    IF LEN(Hold$)>0 THEN„             Hold$=Hold$+STRING$(8-LEN(Hold$),"0")„             OutText$=OutText$+CHR$(Bin2Int(LEFT$(Hold$,8)))„    END IF„'**********************************************************************„' Unpack compressed string into character representation of binary„„    J%=0 : UnCompr$="" : NewText$=""„    DO : INCR J%„         Hold$=MID$(OutText$,J%,1) : Hold$=BIN$(ASC(Hold$))„         DO WHILE LEN(Hold$)<8 : Hold$="0"+Hold$ : LOOP„         UnCompr$=UnCompr$+Hold$„    LOOP UNTIL J%=LEN(OutText$)„„' Decode compressed string„„    DO : FOR  K%=1 TO 256„         IF K%=256 THEN EXIT LOOP 'All done„         IF Leng%(K%)>0 THEN„            IF Bin2Int(LEFT$(UnCompr$,Leng%(K%)))=Code%(K%) THEN„                                                                     „               UnCompr$=RIGHT$(UnCompr$,LEN(UnCompr$)-Leng%(K%))„               NewText$=NewText$+CHR$(K%) : EXIT FOR„            END IF„        END IF„        NEXT K%„    LOOP UNTIL LEN(UnCompr$) = 0„„„END SUB 'Huffman„„SUB PqDownHeap(K%)„' Build and maintain an indirect heap on the frequency values (P. 139)„'     reversing the inequalities since we want the smallest values first.„„    SHARED N%,Heap%(),Count%()„    LOCAL J%,V%,Limit%„    V%=Heap%(K%) : Limit% = N%/2„    DO WHILE K% <= Limit%„       J%=K%+K%„       IF J%<N% THEN IF Count%(Heap%(J%)) > Count%(Heap%(J%+1)) THEN INCR J%„       IF Count%(V%)<=Count%(Heap%(J%)) THEN Heap%(K%)=V% : EXIT SUB„       Heap%(K%)=Heap%(J%) : Heap%(J%)=V% : K%=J%„    LOOP„END SUB 'PqDownHeap„„'**********************************************************************„FUNCTION Bin2Int(X$)„X$=RTRIM$(X$) :X$=LTRIM$(X$) : Ll%=LEN(X$) : Ex%=0 : Tot%=0 : I%=Ll%„    DO WHILE I% > 0„        IF MID$(X$,I%,1)="1" THEN Tot&=Tot&+(2^Ex&)„        INCR Ex& : DECR I% : WEND„    Bin2Int=Tot&„END FUNCTION 'Bin2Int„Franklin Villamor              NUMBER OF POSSIBLE COMBINATIONSartvil@ix.netcom.com           08-25-96 (22:38)       QB, QBasic, PDS        17   545      COMBINAT.BASTo find out how many possibilities there can be:„„cls„input "Number of different states for each object: ", a„input "Number of objects: ", b„„for x = 0 to b - 1„c = c + a^x„next x„„print "Number of possibilities: ", c„„Imagine a row of four sheets of paper. Each paper can be in one of two„states, either the blank side, or the written on side. The variable "a" is„the number of states (in this case 2). The variable "b" is the number of„objects (in this case 4). This will have 15 different unique combinations„(which is "c").„Steve Horstmeyer               CALCULATE WIND CHILL           Internet                       10/95 (00:00)          QB, QBasic, PDS        153  4975     WINDCHL.BAS 'BASIC LANGUAGE PROGRAM TO CALCULATE WIND CHILL BASED ON SIPLE FORMULA„' WEATHERWISE MAGAZINE OCTOBER/NOVEMBER 1995 BY STEVE HORSTMEYER„'RUNS UNDER DOS v5.x & V6.x QBASIC, OR QUICKBASIC OR QUICKBASIC EXTENDED.„'THIS PROGRAM WILL NOT RUN UNDER OLDER VERSIONS OF GWBASIC, BASIC OR BASICA„'FROM DOS V4.X OR EARLIER. LINE NUMBERS ARE NOT REQUIRED IN QBASIC, WHERE„'NEEDED A LINE CAN HAVE A LABEL LIKE CHOOSEMODE: ONEWCHILL: AND TABLE: BELOW.„„DIM WTABLE(11, 13), TEMPS(13), WIND(11)„CLS„'DEF FNWCT defines a function that calculates wind chill using  the Siple„'formula. Statement IF VEL<=4 sets wind chill to temp if wind is <=4mph.„'to de-activate add 'to make lie a comment, result is rounded„„DEF FNWCT (VEL, TMP)„  WC = .0817 * (3.71 * (VEL ^ .5) + 5.81 - .25 * VEL) * (TMP - 91.4) + 91.4„  IF VEL <= 4 THEN WC = TMP„  FNWCT = CINT(WC)„END DEF„„CLS„LOCATE 2, 9: COLOR 14, 0: PRINT "BASIC LANGUAGE PROGRAM TO CALCULATE WIND CHILL USING SIPLE FORMULA"„LOCATE 5, 20: PRINT "REQUIRES MS-DOS (V5.X OR HIGHER) QBASIC "„LOCATE 6, 21: PRINT "OR QUICKBASIC OR QUICK BASIC EXTENDED"„LOCATE 7, 27: PRINT "WEATHERWISE NOVEMBER 1995"„LOCATE 8, 30: PRINT "BY STEVE HORSTMEYER"„LOCATE 10, 34: COLOR 31, 0: PRINT "PRESS ANY KEY"„WHILE INKEY$ = "": WEND„„„'*****determine if user wants a single value or table*****„CHOOSEMODE:„  CLS : COLOR 7, 0„  LOCATE 3, 1: PRINT "TO CALCULATE A SINGLE VALUE PRESS S "„  LOCATE 5, 1: PRINT "TO DISPLAY A TABLE PRESS T "„  INPUT MODE$: MODE$ = UCASE$(MODE$)„  SELECT CASE MODE$„         CASE "S"„            GOSUB ONEWCHILL„         CASE "T"„            GOSUB TABLE„         CASE ELSE„            GOTO CHOOSEMODE„  END SELECT„END„'*******************SUBROUTINES*****************„'*****find  single windchill*****„ONEWCHILL:„  CLS : COLOR 7, 0„  LOCATE 2, 1: INPUT "ENTER TEMPERATURE (F)        "; T: T = CINT(T)„  LOCATE 4, 1: INPUT "ENTER WIND VELOCITY (MPH)    "; V: V = CINT(V)„  IF V < 0 THEN„     CLS : LOCATE 1, 1: COLOR 30, 0„     PRINT "WIND VELOCITY MUST BE POSITIVE"„     COLOR 30, 0„     PRINT "TO START AGAIN PRESS ANY KEY"„     WHILE INKEY$ = "": WEND„     GOTO ONEWCHILL„  END IF„„  CLS„  LOCATE 2, 1: PRINT "WIND CHILL BASED ON SIPLE FORMULA"„  LOCATE 4, 1: PRINT "TEMPERATURE   "; T; "F AND"„  LOCATE 6, 1: PRINT "WIND VELOCITY "; V; "MPH"„  COLOR 9, 0: LOCATE 8, 1: PRINT "WIND CHILL = "; FNWCT(V, T); " F"„„REPEAT:„  LOCATE 12, 1: COLOR 14, 0: INPUT " ANOTHER S, RESTART R OR EXIT E "; AGAIN$„  AGAIN$ = UCASE$(AGAIN$)„  SELECT CASE AGAIN$„         CASE "S"„            GOTO ONEWCHILL„         CASE "R"„            GOTO CHOOSEMODE„         CASE "E"„            END„         CASE ELSE„            GOTO REPEAT„  END SELECT„RETURN: '*****end of subroutine to calculate single value*****„'*****calculate and display table*****„TABLE:„  CLS„  LOCATE 3, 1: PRINT "ENTER MINIMUM TEMPERATURE (FOR >80 PROGRAM DEFAULTS TO 80)"„  LOCATE 5, 1: PRINT "TABLE WILL BE CALCULATED FOR 5 DEGREE INCREMENTS"„  LOCATE 7, 1: PRINT "WIND SPEEDS ARE FIXED FROM ZERO TO 45 MPH IN 5 MPH INCREMENTS"„  LOCATE 9, 1: COLOR 30, 0: PRINT "PRESS ANY KEY TO CONTINUE"„  WHILE INKEY$ = "": WEND: COLOR 14, 0„„  LOCATE 12, 1: INPUT "ENTER LOWEST TEMPERATURE F"; MNTEMP„  MNTEMP = CINT(MNTEMP): COLOR 7, 0„  IF MNTEMP > 80 THEN MNTEMP = 80„„  FOR V = 0 TO 50 STEP 5„  WINDEX = V / 5: WIND(WINDEX) = V: TINDEX = 0„  FOR T = MNTEMP TO MNTEMP + 60 STEP 5„  TEMPS(TINDEX) = T„  WTABLE(WINDEX, TINDEX) = FNWCT(V, T): TINDEX = TINDEX + 1„  NEXT T: NEXT V„„'*****display table on screen*****„WRITETABLE:„  CLS : COLOR 14, 0„  LOCATE 2, 2: PRINT "WIND": LOCATE 2, 33: PRINT "AIR TEMPERATURE"„  FOR I = 0 TO 12„  PRINT TAB(10 + I * 5); TEMPS(I);„  NEXT I„„  LOCATE 3, 3: PRINT "VEL": COLOR 7, 0„  FOR I = 2 TO 4„  LOCATE I, 9: PRINT "|"„  NEXT I„„  LOCATE 4, 10: PRINT STRING$(70, "="): LOCATE 3, 10„   „  FOR ROW = 0 TO 9„  LOCATE 2 * ROW + 5, 4„  COLOR 14, 0: PRINT WIND(ROW)„  COLOR 7, 0: LOCATE 2 * ROW + 5, 9: PRINT "|"„„  FOR COLUMN = 0 TO 12: COLOR 15, 0„  SELECT CASE WTABLE(ROW, COLUMN)„         CASE IS > TEMPS(COLUMN)„            IF WTABLE(ROW, COLUMN) > 120 THEN„                COLOR 4, 0„                ELSE COLOR 12, 0„            END IF„        CASE 11 TO 32„            COLOR 1, 0„         CASE -20 TO 10„            COLOR 9, 0„         CASE -49 TO -21„            COLOR 13, 0„         CASE IS <= -50„            COLOR 29, 0„  END SELECT„„  LOCATE 2 * ROW + 5, 10 + COLUMN * 5: PRINT WTABLE(ROW, COLUMN)„  LOCATE 2 * ROW + 6, 9: COLOR 7, 0: PRINT "|";„  NEXT COLUMN: NEXT ROW„„  COLOR 14, 0„  LOCATE 25, 1: INPUT "PRESS <R> TO RESTART PRESS <E> TO EXIT "; RERUN$„  RERUN$ = UCASE$(RERUN$)„  SELECT CASE RERUN$„         CASE "E"„            CLS„            END„         CASE "R"„            GOTO CHOOSEMODE„         CASE ELSE„            GOTO WRITETABLE„  END SELECT„RETURN: '*****end of table subroutine*****„