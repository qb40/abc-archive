Richard Kelly                  Encode Text                    newson@37.com                  06-15-01 (19:34)       QB, QBasic, PDS, GWB   48   2897     Encode.bas  60 'Author: Richard Kelly	05/27/2001	E-Mail: Newson@37.com„61 '„62 'This Public Domain release should work fine with GW-BASIC, BASICA,„63 'Q-BASIC, QuickBASIC, PDS, and FirstBASIC.„64 '„65 'The program simply changes readable text into an "encoded" format.„66 'This is great for "hiding" data in adventure games or in DRAW„67 'commands.  Just to make it harder to "translate", the B$ string is„68 'always written backwards.  I could have "scrambled" the characters„69 'around as well, but it was simpler and faster to do it the way it is„70 'now.„71 '„72 'The subroutine in Line 2000 will encode all the text in A$, and the„73 'subroutine in Line 2010 will decode A$.  The altered string is stored„74 'in B$, and A$ remains unchanged.„75 '„76 'The routine is made for standard text messages and DRAW string commands.„77 'The program will *not* work properly with characters above a particular„78 'ASC value, so special symbols like CHR$(250) which are *not* used in„79 'standard text shouldn't be used with this program as is.  Sorry.„80 '„81 'The easiest way to use this program for your own purposes is to create„82 'a program that READs the data into string arrays, make a FOR/NEXT loop,„83 'have A$ equal each string of the array called in the FOR loop, call Line„84 '2000, and write B$ to the data file after Line 2000 has RETURNed.  The„85 'program you distribute to the public would have a similar FOR/LOOP,„86 'only that you'd call Line 2010 first, and have the string array equal B$.„87 '„88 'For those of you who *don't* want to have your data encoded into a„89 'separate file when you release it, just make the encoded file, use MS„90 'Edit, "Copy" the data from the data file to the Clipboard, load your„91 'BASIC file, and then "Paste" the data in there. You can then access the„92 'data by using READ statements.  If you do this, make absolute certain„93 'that you're not going to try to change *any* of the data you choose to„94 'encode, or you'll either have to write it back to a file again and„95 'decode it, or translate the string yourself one character at a time.  :-(„96 '„1000 CLS:PRINT"If you don't want people examining your game data and figuring out things that":PRINT"you don't want them to know, then check this program out.":PRINT„1001 A$="Use letters, numbers (1, 5, 2, ect.), & symbols and this program will encode    them."„1002 PRINT A$:GOSUB 2000:PRINT B$:PRINT„1010 A$="ú‚◊é”“›—”“é€œ‡’›‡ﬁé”÷‚é÷—‚œÂéÂ›º"„1011 GOSUB 2010:PRINT A$:PRINT B$:PRINT„1020 PRINT"Now *you* type in something to encode.":PRINT„1021 LINE INPUT"Go on, now.  ";A$:IF A$=""THEN 1021„1022 GOSUB 2000:PRINT B$:PRINT:PRINT"Thanks for giving this program a try.":PRINT:END:RUN„2000 B$="":FOR L=1 TO LEN(A$):A=ASC(MID$(A$,L,1)):A=A+110:B$=CHR$(A)+B$:NEXT:RETURN„2010 B$="":FOR L=1 TO LEN(A$):A=ASC(MID$(A$,L,1)):A=A-110:B$=CHR$(A)+B$:NEXT:RETURN„„Walt Decker                    Text-mode Palette              lydia2hg@yahoo.com             10-12-01 (  :  )       QBasic,QB, PDS         347  9507     BASICFX.BAS '*********************************************************„'PROGRAM NAME: BASICFX.BAS„'DATE:         10-20-2001„'*********************************************************„„'Many people don't realize that the colors in screen mode 0 can be changed.„'This little routine writes directly to the DAC registers to change the„'palette in mode 0.„„'With some modification, this routine should work in all screen modes. „'Modifications include the print locations (LOCATE) to fit the screen„'resolution, adjusting the size of typSysPal() and typNewPal() to fit the„'size of the palette (although that is not necessary), and adding mouse„'support.„„'SUBs SetPal, GetKey, SetColors, and GetColors can be used with a variety of„'applications and screen modes.„„'-------------------------------------------------------------------------„'                DECLARE SUB ROUTINES„'------------------------------------------------------------------------„DECLARE SUB PrtColorBar (Hline$, CLine$)„DECLARE SUB GetKey (KeyPress AS STRING)„DECLARE SUB PrtBlock (intCly%, intClx%, strHline$, strLine$, intColor%)„DECLARE SUB PrtColorGraph (intRy%, intRx%, strHline$, intSysPal%, strLine$, intColor%, intO%)„DECLARE SUB GetColorNum (intBy%, intBx%, intColor%)„DECLARE SUB SetPal (Pal() AS ANY, intVal%, intComPonent%, intColor%)„DECLARE SUB SetCurX (intX%, intY%, intRy%, intGy%, intBy%, intJ%, Hline$)„DECLARE SUB SetColors (Pal() AS ANY, Ic1%, Lc%)„DECLARE SUB Getcolors (Pal() AS ANY, Ic1%, Lc%)„„'------------------------- STRUCTURE FOR DAC REGISTERS -----------------„TYPE Pal„  red   AS INTEGER„  blue  AS INTEGER„  green AS INTEGER„END TYPE„„'----------------------- DECLARE VARIABLES -----------------------------„DIM strLine  AS STRING * 1„DIM strHline AS STRING„DIM strInput AS STRING„DIM strRed   AS STRING„DIM strGreen AS STRING„DIM strBlue  AS STRING„DIM strUarow AS STRING * 2„DIM strLarow AS STRING * 2„DIM strDarow AS STRING * 2„DIM strRarow AS STRING * 2„DIM strEnd   AS STRING * 2„DIM strStrng AS STRING„„DIM intI     AS INTEGER„DIM intJ     AS INTEGER„DIM intRx    AS INTEGER„DIM intRy    AS INTEGER„DIM intBx    AS INTEGER„DIM intBy    AS INTEGER„DIM intGx    AS INTEGER„DIM intGy    AS INTEGER„DIM intClx   AS INTEGER„DIM intCly   AS INTEGER„DIM intColor AS INTEGER„DIM intCval  AS INTEGER„DIM intCurX  AS INTEGER„DIM intCurY  AS INTEGER„„DIM typSysPal(0 TO 255) AS Pal„DIM typNewPal(0 TO 255) AS Pal„„'------------------------ INITIALIZE SOME VARIABLES ----------------------„strLine = CHR$(219)„strUarow = CHR$(0) + "H"„strLarow = CHR$(0) + "K"„strDarow = CHR$(0) + "P"„strRarow = CHR$(0) + "M"„strEnd = CHR$(0) + "O"„„intClx = 60„intCly = 1„intRx = 1„intRy = 9„intGx = 1„intGy = 11„intBx = 1„intBy = 13„„SCREEN 0             '  SET SCREEN MODE„CLS                  '  CLEAR THE SCREEN„„CALL Getcolors(typSysPal(), 0, 255)  'LOAD SYSTEM PALETTE ARRAY„„FOR intI = 0 TO 255                  'INITIALIZE WORKING PALETTE ARRAY„  typNewPal(intI) = typSysPal(intI)„NEXT intI„„CALL PrtColorBar(strHline, strLine)  'PRINT SOME COLORS„„'----------------------- SHOW INSTRUCTIONS ---------------------------„COLOR 7„PRINT„PRINT„„PRINT "Use Up/Down Arrow Keys and ENTER to select"„PRINT "     color component or color"„„PRINT "Use Right/Left Arrow Keys to increase/decrease"„PRINT "     color component values"„„PRINT "Use END to quit program"„CALL PrtBlock((intCly), intClx, strHline, strLine, intColor) 'MAKE A BLOCK OF COLOR„„'--------------------- BUILD COLOR GRAPH --------------------------„intI = typNewPal(1).red„intColor = 1„CALL PrtColorGraph(intRy, intRx, strHline, intI, strLine, intColor, 1)„intI = typNewPal(1).green„CALL PrtColorGraph(intGy, intGx, strHline, intI, strLine, intColor, 2)„intI = typNewPal(1).blue„CALL PrtColorGraph(intBy, intBx, strHline, intI, strLine, intColor, 3)„„Color.Loop: '„„CALL GetColorNum(intBy, intBx, intColor)„CALL PrtColorBar(strHline, strLine)„CALL PrtBlock((intCly), intClx, strHline, strLine, intColor)„„intCval = typNewPal(intColor).green„intJ = 1„CALL PrtColorGraph(intGy, intGx, strHline, intCval, strLine, intColor, 2)„„intCval = typNewPal(intColor).blue„CALL PrtColorGraph(intBy, intBx, strHline, intCval, strLine, intColor, 3)„„intCval = typNewPal(intColor).red„CALL PrtColorGraph(intRy, intRx, strHline, intCval, strLine, intColor, intJ)„„'------------------ SET CURSOR AT 1ST GRAPH ---------------------------„intCurX = LEN("RED :" + strHline)„intCurY = intRy„„LOCATE intCurY, intCurX, 1, 31, 1„„'------------------ GET USER INPUT ---------------------------„DO„  CALL GetKey(strStrng)„  SELECT CASE strStrng„    CASE IS = strUarow„„      intJ = intJ - 1„      IF intJ < 0 THEN intJ = 3„      GOSUB GetCval„      GOSUB SelectGraph„      CALL SetCurX(intCurX, intCurY, intRy, intGy, intBy, intJ, strHline)„„    CASE IS = strLarow„„      intCval = intCval - 1„      IF intCval < 0 THEN intCval = 0„      CALL SetPal(typNewPal(), intCval, intJ, intColor)„      CALL SetColors(typNewPal(), intColor, intColor)„      GOSUB SelectGraph„      CALL SetCurX(intCurX, intCurY, intRy, intGy, intBy, intJ, strHline)„„    CASE IS = strDarow„„      intJ = intJ + 1„      IF intJ > 3 THEN intJ = 1„      GOSUB GetCval„      GOSUB SelectGraph„      CALL SetCurX(intCurX, intCurY, intRy, intGy, intBy, intJ, strHline)„„    CASE IS = strRarow„„      intCval = intCval + 1„      IF intCval > 63 THEN intCval = 63„      CALL SetPal(typNewPal(), intCval, intJ, intColor)„      CALL SetColors(typNewPal(), intColor, intColor)„      GOSUB SelectGraph„      CALL SetCurX(intCurX, intCurY, intRy, intGy, intBy, intJ, strHline)„„    CASE IS = strEnd„„      EXIT DO„„    CASE IS = CHR$(13)„      GOTO Color.Loop„  END SELECT„LOOP„CALL SetColors(typSysPal(), 0, 255)   'RESET SYSTEM PALETTE„END„„SelectGraph:      '„„  SELECT CASE intJ„    CASE 1„      CALL PrtColorGraph(intRy, intRx, strHline, intCval, strLine, intColor, intJ)„    CASE 2„      CALL PrtColorGraph(intGy, intGx, strHline, intCval, strLine, intColor, intJ)„    CASE 3„      CALL PrtColorGraph(intBy, intBx, strHline, intCval, strLine, intColor, intJ)„  END SELECT„RETURN„„GetCval: '„„  SELECT CASE intJ„    CASE 1„      intCval = typNewPal(intColor).red„    CASE 2„      intCval = typNewPal(intColor).green„    CASE 3„      intCval = typNewPal(intColor).blue„  END SELECT„RETURN„„DEFINT A-Z„SUB GetColorNum (intBy, intBx, intColor)„„LOCATE intBy + 2, intBx„PRINT STRING$(75, " ")„„LOCATE intBy + 2, intBx„PRINT "Enter Color (0 to 63)";„„INPUT intColor„„END SUB„„SUB Getcolors (Pal() AS Pal, Ic1, Lc)„„'polls the DAC registers for the current colors„'values for the colors are in the range 0 to 63„'each for red, green, and blue„„   OUT &H3C7, Ic1                    'tell controller to get ready„   FOR I = Ic1 TO Lc                 'first to last„      Pal(I).red = INP(&H3C9)        'get red component„      Pal(I).green = INP(&H3C9)       'get green component„      Pal(I).blue = INP(&H3C9)        'get blue component„   NEXT I„END SUB„„DEFSNG A-Z„SUB GetKey (KeyPress AS STRING)„DO„  KeyPress = INKEY$„  IF LEN(KeyPress) THEN EXIT DO„LOOP„END SUB„„DEFINT A-Z„SUB PrtBlock (intCly, intClx, strHline$, strLine$, intColor)„„IF intColor > 31 THEN EXIT SUB„„DIM intI AS INTEGER„„LOCATE intCly, intClx„COLOR intColor„strHline$ = STRING$(19, strLine$)„„FOR intI = 1 TO 4„  PRINT strHline$„  LOCATE , intClx„NEXT intI„„END SUB„„SUB PrtColorBar (Hline$, CLine$)„„Hline$ = CLine$ + CLine$ + CLine$„LOCATE 1, 1„FOR intI = 1 TO 16„  COLOR intI„  PRINT Hline$;„NEXT intI„„END SUB„„SUB PrtColorGraph (intRy, intRx, strHline$, intSysPal, strLine$, intColor, intO)„„strHline$ = STRING$(75, " ")„COLOR 0„LOCATE intRy, intRx„PRINT strHline$„COLOR 7„LOCATE intRy, intRx„„IF intO = 1 THEN„  strHline$ = STRING$(intSysPal, strLine$)„  PRINT "RED :"; strHline$„END IF„„IF intO = 2 THEN„  strHline$ = STRING$(intSysPal, strLine$)„  PRINT "GREEN :"; strHline$„END IF„„IF intO = 3 THEN„  strHline$ = STRING$(intSysPal, strLine$)„  PRINT "BLUE :"; strHline$„END IF„END SUB„„SUB SetColors (Pal() AS Pal, Ic1, Lc)„„'sets the DAC registers with the values contained in variable Pal()„'values are in the range of 0 to 63 each for red, green, and blue„„   OUT &H3C8, Ic1                            'tell controller to get ready„   FOR I = Ic1 TO Lc                         'from first to last„      OUT &H3C9, Pal(I).red                  'send red component„      OUT &H3C9, Pal(I).green                  'send green component„      OUT &H3C9, Pal(I).blue                  'send blue component„   NEXT I„END SUB„„SUB SetCurX (intX%, intY%, intRy%, intGy%, intBy%, intJ%, Hline$)„      SELECT CASE intJ%„        CASE 1„          intX% = LEN("RED :" + Hline$)„          intY = intRy„        CASE 2„          intX% = LEN("GREEN :" + Hline$)„          intY% = intGy%„        CASE 3„          intX% = LEN("BLUE :" + Hline$)„          intY% = intBy%„      END SELECT„      LOCATE intY%, intX%, 1, 31, 1„„END SUB„„DEFSNG A-Z„SUB SetPal (Pal() AS Pal, intVal%, intComPonent%, intColor%)„      SELECT CASE intComPonent%„        CASE 1„          Pal(intColor%).red = intVal%„        CASE 2„          Pal(intColor%).green = intVal%„        CASE 3„          Pal(intColor%).blue = intVal%„      END SELECT„„END SUB„„